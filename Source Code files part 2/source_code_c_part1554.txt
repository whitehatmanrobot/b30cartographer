l->buffer + (row * level->width + col) * 2;
    result->luminance = image[0];
    result->alpha = image[1];
}

/*
** Get a texture element out of the three component texture buffer
** with a border.
*/
void FASTCALL __glExtractTexelRGB_B(__GLmipMapLevel *level, __GLtexture *tex,
			GLint row, GLint col, __GLtexel *result)
{
    __GLtextureBuffer *image;

#ifdef __GL_LINT
    tex = tex;
#endif
    row++;
    col++;
    image = level->buffer + (row * level->width + col) * 3;
    result->r = image[0];
    result->g = image[1];
    result->b = image[2];
}

/*
** Get a texture element out of the four component texture buffer
** with a border.
*/
void FASTCALL __glExtractTexelRGBA_B(__GLmipMapLevel *level, __GLtexture *tex,
			GLint row, GLint col, __GLtexel *result)
{
    __GLtextureBuffer *image;

#ifdef __GL_LINT
    tex = tex;
#endif
    row++;
    col++;
    image = level->buffer + (row * level->width + col) * 4;
    result->r = image[0];
    result->g = image[1];
    result->b = image[2];
    result->alpha = image[3];
}

void FASTCALL __glExtractTexelA_B(__GLmipMapLevel *level, __GLtexture *tex,
			GLint row, GLint col, __GLtexel *result)
{
    __GLtextureBuffer *image;

#ifdef __GL_LINT
    tex = tex;
#endif
    row++;
    col++;
    image = level->buffer + (row * level->width + col);
    result->alpha = image[0];
}

void FASTCALL __glExtractTexelI_B(__GLmipMapLevel *level, __GLtexture *tex,
			GLint row, GLint col, __GLtexel *result)
{
    __GLtextureBuffer *image;

#ifdef __GL_LINT
    tex = tex;
#endif
    row++;
    col++;
    image = level->buffer + (row * level->width + col);
    result->intensity = image[0];
}

void FASTCALL __glExtractTexelBGR8_B(__GLmipMapLevel *level, __GLtexture *tex,
			GLint row, GLint col, __GLtexel *result)
{
    __GLcontext *gc = tex->gc;
    GLubyte *image;

#ifdef __GL_LINT
    tex = tex;
#endif
    row++;
    col++;
    image = (GLubyte *)level->buffer + (row * level->width + col) * 4;
    result->r = __GL_UB_TO_FLOAT(image[2]);
    result->g = __GL_UB_TO_FLOAT(image[1]);
    result->b = __GL_UB_TO_FLOAT(image[0]);
}

void FASTCALL __glExtractTexelBGRA8_B(__GLmipMapLevel *level, __GLtexture *tex,
			GLint row, GLint col, __GLtexel *result)
{
    __GLcontext *gc = tex->gc;
    GLubyte *image;

#ifdef __GL_LINT
    tex = tex;
#endif
    row++;
    col++;
    image = (GLubyte *)level->buffer + (row * level->width + col) * 4;
    result->r = __GL_UB_TO_FLOAT(image[2]);
    result->g = __GL_UB_TO_FLOAT(image[1]);
    result->b = __GL_UB_TO_FLOAT(image[0]);
    result->alpha = __GL_UB_TO_FLOAT(image[3]);
}

#ifdef GL_EXT_paletted_texture
void FASTCALL __glExtractTexelPI8BGRA_B(__GLmipMapLevel *level, __GLtexture *tex,
			GLint row, GLint col, __GLtexel *result)
{
    __GLcontext *gc = tex->gc;
    GLubyte *image;
    RGBQUAD *rgb;

    row++;
    col++;
    image = (GLubyte *)level->buffer + (row * level->width + col);
    rgb = &tex->paletteData[image[0] & (tex->paletteSize-1)];
    result->r = __GL_UB_TO_FLOAT(rgb->rgbRed);
    result->g = __GL_UB_TO_FLOAT(rgb->rgbGreen);
    result->b = __GL_UB_TO_FLOAT(rgb->rgbBlue);
    result->alpha = __GL_UB_TO_FLOAT(rgb->rgbReserved);
}

void FASTCALL __glExtractTexelPI8BGR_B(__GLmipMapLevel *level, __GLtexture *tex,
			GLint row, GLint col, __GLtexel *result)
{
    __GLcontext *gc = tex->gc;
    GLubyte *image;
    RGBQUAD *rgb;

    row++;
    col++;
    image = (GLubyte *)level->buffer + (row * level->width + col);
    rgb = &tex->paletteData[image[0] & (tex->paletteSize-1)];
    result->r = __GL_UB_TO_FLOAT(rgb->rgbRed);
    result->g = __GL_UB_TO_FLOAT(rgb->rgbGreen);
    result->b = __GL_UB_TO_FLOAT(rgb->rgbBlue);
}

void FASTCALL __glExtractTexelPI16BGRA_B(__GLmipMapLevel *level, __GLtexture *tex,
			GLint row, GLint col, __GLtexel *result)
{
    __GLcontext *gc = tex->gc;
    GLushort *image;
    RGBQUAD *rgb;

    row++;
    col++;
    image = (GLushort *)level->buffer + (row * level->width + col);
    rgb = &tex->paletteData[image[0] & (tex->paletteSize-1)];
    result->r = __GL_UB_TO_FLOAT(rgb->rgbRed);
    result->g = __GL_UB_TO_FLOAT(rgb->rgbGreen);
    result->b = __GL_UB_TO_FLOAT(rgb->rgbBlue);
    result->alpha = __GL_UB_TO_FLOAT(rgb->rgbReserved);
}

void FASTCALL __glExtractTexelPI16BGR_B(__GLmipMapLevel *level, __GLtexture *tex,
			GLint row, GLint col, __GLtexel *result)
{
    __GLcontext *gc = tex->gc;
    GLushort *image;
    RGBQUAD *rgb;

    row++;
    col++;
    image = (GLushort *)level->buffer + (row * level->width + col);
    rgb = &tex->paletteData[image[0] & (tex->paletteSize-1)];
    result->r = __GL_UB_TO_FLOAT(rgb->rgbRed);
    result->g = __GL_UB_TO_FLOAT(rgb->rgbGreen);
    result->b = __GL_UB_TO_FLOAT(rgb->rgbBlue);
}
#endif // GL_EXT_paletted_texture
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\soft\so_texim.c ===
/*
** Copyright 1991,1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/
#include "precomp.h"
#pragma hdrstop

#include <glmath.h>
#include <devlock.h>

static __GLtexture *CheckTexImageArgs(__GLcontext *gc, GLenum target, GLint lod,
				      GLint components, GLint border,
				      GLenum format, GLenum type, GLint dim)
{
    __GLtexture *tex = __glLookUpTexture(gc, target);

    if (!tex || (tex->dim != dim)) {
      bad_enum:
	__glSetError(GL_INVALID_ENUM);
	return 0;
    }

    switch (type) {
      case GL_BITMAP:
	if (format != GL_COLOR_INDEX) goto bad_enum;
      case GL_BYTE:
      case GL_UNSIGNED_BYTE:
      case GL_SHORT:
      case GL_UNSIGNED_SHORT:
      case GL_INT:
      case GL_UNSIGNED_INT:
      case GL_FLOAT:
	break;
      default:
	goto bad_enum;
    }

    switch (format) {
      case GL_COLOR_INDEX:	case GL_RED:
      case GL_GREEN:		case GL_BLUE:
      case GL_ALPHA:		case GL_RGB:
      case GL_RGBA:		case GL_LUMINANCE:
      case GL_LUMINANCE_ALPHA:
#ifdef GL_EXT_bgra
      case GL_BGRA_EXT:
      case GL_BGR_EXT:
#endif
	break;
      default:
	goto bad_enum;
    }

    if ((lod < 0) || (lod >= gc->constants.maxMipMapLevel)) {
	__glSetError(GL_INVALID_VALUE);
	return 0;
    }

    switch (components) {
      case GL_LUMINANCE:	case 1:
      case GL_LUMINANCE4:	case GL_LUMINANCE8:
      case GL_LUMINANCE12:	case GL_LUMINANCE16:
	break;
      case GL_LUMINANCE_ALPHA:	        case 2:
      case GL_LUMINANCE4_ALPHA4:	case GL_LUMINANCE6_ALPHA2:
      case GL_LUMINANCE8_ALPHA8:	case GL_LUMINANCE12_ALPHA4:
      case GL_LUMINANCE12_ALPHA12:	case GL_LUMINANCE16_ALPHA16:
	break;
      case GL_RGB:		case 3:
      case GL_R3_G3_B2:		case GL_RGB4:
      case GL_RGB5:		case GL_RGB8:
      case GL_RGB10:	        case GL_RGB12:
      case GL_RGB16:
	break;
      case GL_RGBA:		case 4:
      case GL_RGBA2:	        case GL_RGBA4:
      case GL_RGBA8:	        case GL_RGBA12:
      case GL_RGBA16:	        case GL_RGB5_A1:
      case GL_RGB10_A2:
	break;
      case GL_ALPHA:
      case GL_ALPHA4:	        case GL_ALPHA8:
      case GL_ALPHA12:	        case GL_ALPHA16:
	break;
      case GL_INTENSITY:
      case GL_INTENSITY4:	case GL_INTENSITY8:
      case GL_INTENSITY12:	case GL_INTENSITY16:
	break;
#ifdef GL_EXT_paletted_texture
      case GL_COLOR_INDEX1_EXT:     case GL_COLOR_INDEX2_EXT:
      case GL_COLOR_INDEX4_EXT:     case GL_COLOR_INDEX8_EXT:
      case GL_COLOR_INDEX12_EXT:    case GL_COLOR_INDEX16_EXT:
        if (format != GL_COLOR_INDEX)
        {
            __glSetError(GL_INVALID_OPERATION);
            return NULL;
        }
        break;
#endif
      default:
	goto bad_enum;
    }

    if ((border < 0) || (border > 1)) {
#ifdef NT
	__glSetError(GL_INVALID_VALUE);
	return 0;
#else
	goto bad_enum;
#endif
    }

    return tex;
}

#ifdef GL_EXT_paletted_texture
// Attempt to set the extraction function.  If no palette is set,
// this can't be done
void __glSetPaletteLevelExtract8(__GLtexture *tex, __GLmipMapLevel *lp,
                                 GLint border)
{
    if (tex->paletteBaseFormat == GL_RGB)
    {
        if (border)
        {
            lp->extract = __glExtractTexelPI8BGR_B;
        }
        else
        {
            lp->extract = __glExtractTexelPI8BGR;
        }
    }
    else if (tex->paletteBaseFormat == GL_RGBA)
    {
            
        if (border)
        {
            lp->extract = __glExtractTexelPI8BGRA_B;
        }
        else
        {
            lp->extract = __glExtractTexelPI8BGRA;
        }
    }
#if DBG
    else
    {
        ASSERTOPENGL(tex->paletteBaseFormat == GL_NONE,
                     "Unexpected paletteBaseFormat\n");
    }
#endif
}

void __glSetPaletteLevelExtract16(__GLtexture *tex, __GLmipMapLevel *lp,
                                  GLint border)
{
    if (tex->paletteBaseFormat == GL_RGB)
    {
        if (border)
        {
            lp->extract = __glExtractTexelPI16BGR_B;
        }
        else
        {
            lp->extract = __glExtractTexelPI16BGR;
        }
    }
    else if (tex->paletteBaseFormat == GL_RGBA)
    {
        if (border)
        {
            lp->extract = __glExtractTexelPI16BGRA_B;
        }
        else
        {
            lp->extract = __glExtractTexelPI16BGRA;
        }
    }
#if DBG
    else
    {
        ASSERTOPENGL(tex->paletteBaseFormat == GL_NONE,
                     "Unexpected paletteBaseFormat\n");
    }
#endif
}
#endif // GL_EXT_paletted_texture

static GLint ComputeTexLevelSize(__GLcontext *gc, __GLtexture *tex,
				 __GLmipMapLevel *lp, GLint lod,
				 GLint components, GLsizei w, GLsizei h,
				 GLint border, GLint dim)
{
    GLint texelStorageSize;

    if ((w - border*2) > gc->constants.maxTextureSize ||
	(h - border*2) > gc->constants.maxTextureSize)
    {
	return -1;
    }

    lp->requestedFormat = (GLenum) components;
    lp->redSize = 0;
    lp->greenSize = 0;
    lp->blueSize = 0;
    lp->alphaSize = 0;
    lp->luminanceSize = 0;
    lp->intensitySize = 0;

    switch (lp->requestedFormat) {
      case GL_LUMINANCE:	case 1:
      case GL_LUMINANCE4:	case GL_LUMINANCE8:
      case GL_LUMINANCE12:	case GL_LUMINANCE16:
	lp->baseFormat = GL_LUMINANCE;
	lp->internalFormat = GL_LUMINANCE;
	lp->luminanceSize = 24;
	texelStorageSize = 1 * sizeof(__GLfloat);
	if (border) {
	    lp->extract = __glExtractTexelL_B;
	} else {
	    lp->extract = __glExtractTexelL;
	}
	break;
      case GL_LUMINANCE_ALPHA:	        case 2:
      case GL_LUMINANCE4_ALPHA4:	case GL_LUMINANCE6_ALPHA2:
      case GL_LUMINANCE8_ALPHA8:	case GL_LUMINANCE12_ALPHA4:
      case GL_LUMINANCE12_ALPHA12:	case GL_LUMINANCE16_ALPHA16:
	lp->baseFormat = GL_LUMINANCE_ALPHA;
	lp->internalFormat = GL_LUMINANCE_ALPHA;
	lp->luminanceSize = 24;
	lp->alphaSize = 24;
	texelStorageSize = 2 * sizeof(__GLfloat);
	if (border) {
	    lp->extract = __glExtractTexelLA_B;
	} else {
	    lp->extract = __glExtractTexelLA;
	}
	break;
      case GL_RGB:		case 3:
      case GL_R3_G3_B2:		case GL_RGB4:
      case GL_RGB5:		case GL_RGB8:
	lp->baseFormat = GL_RGB;
	lp->internalFormat = GL_BGR_EXT;
	lp->redSize = 8;
	lp->greenSize = 8;
	lp->blueSize = 8;
        // Kept as 32-bit quantities for alignment
	texelStorageSize = 4 * sizeof(GLubyte);
	if (border) {
	    lp->extract = __glExtractTexelBGR8_B;
	} else {
	    lp->extract = __glExtractTexelBGR8;
	}
        break;
      case GL_RGB10:	case GL_RGB12:
      case GL_RGB16:
	lp->baseFormat = GL_RGB;
	lp->internalFormat = GL_RGB;
	lp->redSize = 24;
	lp->greenSize = 24;
	lp->blueSize = 24;
	texelStorageSize = 3 * sizeof(__GLfloat);
	if (border) {
	    lp->extract = __glExtractTexelRGB_B;
	} else {
	    lp->extract = __glExtractTexelRGB;
	}
	break;
      case GL_RGBA:		case 4:
      case GL_RGBA2:	        case GL_RGBA4:
      case GL_RGBA8:            case GL_RGB5_A1:
	lp->baseFormat = GL_RGBA;
	lp->internalFormat = GL_BGRA_EXT;
	lp->redSize = 8;
	lp->greenSize = 8;
	lp->blueSize = 8;
	lp->alphaSize = 8;
	texelStorageSize = 4 * sizeof(GLubyte);
	if (border) {
	    lp->extract = __glExtractTexelBGRA8_B;
	} else {
	    lp->extract = __glExtractTexelBGRA8;
	}
        break;
      case GL_RGBA12:       case GL_RGBA16:
      case GL_RGB10_A2:
	lp->baseFormat = GL_RGBA;
	lp->internalFormat = GL_RGBA;
	lp->redSize = 24;
	lp->greenSize = 24;
	lp->blueSize = 24;
	lp->alphaSize = 24;
	texelStorageSize = 4 * sizeof(__GLfloat);
	if (border) {
	    lp->extract = __glExtractTexelRGBA_B;
	} else {
	    lp->extract = __glExtractTexelRGBA;
	}
	break;
      case GL_ALPHA:
      case GL_ALPHA4:	case GL_ALPHA8:
      case GL_ALPHA12:	case GL_ALPHA16:
	lp->baseFormat = GL_ALPHA;
	lp->internalFormat = GL_ALPHA;
	lp->alphaSize = 24;
	texelStorageSize = 1 * sizeof(__GLfloat);
	if (border) {
	    lp->extract = __glExtractTexelA_B;
	} else {
	    lp->extract = __glExtractTexelA;
	}
	break;
      case GL_INTENSITY:
      case GL_INTENSITY4:	case GL_INTENSITY8:
      case GL_INTENSITY12:	case GL_INTENSITY16:
	lp->baseFormat = GL_INTENSITY;
	lp->internalFormat = GL_INTENSITY;
	lp->intensitySize = 24;
	texelStorageSize = 1 * sizeof(__GLfloat);
	if (border) {
	    lp->extract = __glExtractTexelI_B;
	} else {
	    lp->extract = __glExtractTexelI;
	}
	break;
#ifdef GL_EXT_paletted_texture
      case GL_COLOR_INDEX1_EXT:
      case GL_COLOR_INDEX2_EXT:
      case GL_COLOR_INDEX4_EXT:
      case GL_COLOR_INDEX8_EXT:
        // Inherit the current palette data type
	lp->baseFormat = tex->paletteBaseFormat;
	lp->internalFormat = GL_COLOR_INDEX8_EXT;
	texelStorageSize = sizeof(GLubyte);
        __glSetPaletteLevelExtract8(tex, lp, border);
        break;
      case GL_COLOR_INDEX12_EXT:
      case GL_COLOR_INDEX16_EXT:
        // Inherit the current palette data type
	lp->baseFormat = tex->paletteBaseFormat;
	lp->internalFormat = GL_COLOR_INDEX16_EXT;
	texelStorageSize = sizeof(GLushort);
        __glSetPaletteLevelExtract16(tex, lp, border);
        break;
#endif
      default:
	break;
    }

    return (w * h * texelStorageSize);
}

__GLtextureBuffer *FASTCALL __glCreateProxyLevel(__GLcontext *gc,
                                                 __GLtexture *tex,
				      GLint lod, GLint components,
				      GLsizei w, GLsizei h, GLint border,
				      GLint dim)
{
    __GLmipMapLevel templ, *lp = &tex->level[lod];
    GLint size;

    size = ComputeTexLevelSize(gc, tex, &templ, lod, components,
			       w, h, border, dim);

    if (size < 0) {
	/* Proxy allocation failed */
	lp->width = 0;
	lp->height = 0;
	lp->border = 0;
	lp->requestedFormat = 0;
	lp->baseFormat = 0;
	lp->internalFormat = 0;
	lp->redSize = 0;
	lp->greenSize = 0;
	lp->blueSize = 0;
	lp->alphaSize = 0;
	lp->luminanceSize = 0;
	lp->intensitySize = 0;
	lp->extract = __glNopExtract;
    } else {
	/* Proxy allocation succeeded */
	lp->width = w;
	lp->height = h;
	lp->border = border;
	lp->requestedFormat = templ.requestedFormat;
	lp->baseFormat = templ.baseFormat;
	lp->internalFormat = templ.internalFormat;
	lp->redSize = templ.redSize;
	lp->greenSize = templ.greenSize;
	lp->blueSize = templ.blueSize;
	lp->alphaSize = templ.alphaSize;
	lp->luminanceSize = templ.luminanceSize;
	lp->intensitySize = templ.intensitySize;
	lp->extract = templ.extract;
    }
    return 0;
}

__GLtextureBuffer *FASTCALL __glCreateLevel(__GLcontext *gc, __GLtexture *tex,
				      GLint lod, GLint components,
				      GLsizei w, GLsizei h, GLint border,
				      GLint dim)
{
    __GLmipMapLevel templ, *lp = &tex->level[lod];
    GLint size;
#ifdef NT
    __GLtextureBuffer* pbuffer;
#endif

    size = ComputeTexLevelSize(gc, tex, &templ, lod, components,
			       w, h, border, dim);

    if (size < 0) {
	__glSetError(GL_INVALID_VALUE);
	return 0;
    }

    pbuffer = (__GLtextureBuffer*)
        GCREALLOC(gc, lp->buffer, (size_t)size);
    if (!pbuffer && size != 0)
        GCFREE(gc, lp->buffer);
    lp->buffer = pbuffer;

    if (lp->buffer) {
	/* Fill in new level info */
	lp->width = w;
	lp->height = h;
	lp->width2 = w - border*2;
	lp->widthLog2 = __glIntLog2(lp->width2);
        lp->height2 = h - border*2;
        lp->heightLog2 = __glIntLog2(lp->height2);
	lp->width2f = lp->width2;
	lp->height2f = lp->height2;
	lp->border = border;
	lp->requestedFormat = templ.requestedFormat;
	lp->baseFormat = templ.baseFormat;
	lp->internalFormat = templ.internalFormat;
	lp->redSize = templ.redSize;
	lp->greenSize = templ.greenSize;
	lp->blueSize = templ.blueSize;
	lp->alphaSize = templ.alphaSize;
	lp->luminanceSize = templ.luminanceSize;
	lp->intensitySize = templ.intensitySize;
	lp->extract = templ.extract;
    } else {
	/* Out of memory or the texture level is being freed */
	lp->width = 0;
	lp->height = 0;
	lp->width2 = 0;
	lp->height2 = 0;
	lp->widthLog2 = 0;
	lp->heightLog2 = 0;
	lp->border = 0;
	lp->requestedFormat = 0;
	lp->baseFormat = 0;
	lp->internalFormat = 0;
	lp->redSize = 0;
	lp->greenSize = 0;
	lp->blueSize = 0;
	lp->alphaSize = 0;
	lp->luminanceSize = 0;
	lp->intensitySize = 0;
	lp->extract = __glNopExtract;
    }

    if (lod == 0) {
	tex->p = lp->heightLog2;
	if (lp->widthLog2 > lp->heightLog2) {
	    tex->p = lp->widthLog2;
	}
    }
    return lp->buffer;
}

void FASTCALL __glInitTextureStore(__GLcontext *gc, __GLpixelSpanInfo *spanInfo,
			  GLenum internalFormat)
{
    spanInfo->dstSkipPixels = 0;
    spanInfo->dstSkipLines = 0;
    spanInfo->dstSwapBytes = GL_FALSE;
    spanInfo->dstLsbFirst = GL_TRUE;
    spanInfo->dstLineLength = spanInfo->width;

    switch(internalFormat) {
      case GL_LUMINANCE:
	spanInfo->dstFormat = GL_RED;
	spanInfo->dstType = GL_FLOAT;
        spanInfo->dstAlignment = 4;
	break;
      case GL_LUMINANCE_ALPHA:
	spanInfo->dstFormat = __GL_RED_ALPHA;
	spanInfo->dstType = GL_FLOAT;
        spanInfo->dstAlignment = 4;
	break;
      case GL_RGB:
	spanInfo->dstFormat = GL_RGB;
	spanInfo->dstType = GL_FLOAT;
        spanInfo->dstAlignment = 4;
	break;
      case GL_RGBA:
	spanInfo->dstFormat = GL_RGBA;
	spanInfo->dstType = GL_FLOAT;
        spanInfo->dstAlignment = 4;
	break;
      case GL_ALPHA:
	spanInfo->dstFormat = GL_ALPHA;
	spanInfo->dstType = GL_FLOAT;
        spanInfo->dstAlignment = 4;
	break;
      case GL_INTENSITY:
	spanInfo->dstFormat = GL_RED;
	spanInfo->dstType = GL_FLOAT;
        spanInfo->dstAlignment = 4;
	break;
      case GL_BGR_EXT:
        // Be a little tricky here to pad the data out
        // to 32 bits
	spanInfo->dstFormat = GL_BGRA_EXT;
	spanInfo->dstType = GL_UNSIGNED_BYTE;
        spanInfo->dstAlignment = 4;
	break;
      case GL_BGRA_EXT:
	spanInfo->dstFormat = GL_BGRA_EXT;
	spanInfo->dstType = GL_UNSIGNED_BYTE;
        spanInfo->dstAlignment = 4;
	break;
#ifdef GL_EXT_paletted_texture
      case GL_COLOR_INDEX8_EXT:
      case GL_COLOR_INDEX16_EXT:
        spanInfo->dstFormat = GL_COLOR_INDEX;
        spanInfo->dstType =
            internalFormat == GL_COLOR_INDEX8_EXT ?
            GL_UNSIGNED_BYTE : GL_UNSIGNED_SHORT;
        spanInfo->dstAlignment = 1;
        break;
#endif
    }
}

/*
** Used for extraction from textures.  "packed" is set to GL_TRUE if this
** image is being pulled out of a display list, and GL_FALSE if it is 
** being pulled directly out of an application.
*/
void FASTCALL __glInitTextureUnpack(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
		           GLint width, GLint height, GLenum format, 
			   GLenum type, const GLvoid *buf,
			   GLenum internalFormat, GLboolean packed)
{
    spanInfo->x = 0;
    spanInfo->zoomx = __glOne;
    spanInfo->realWidth = spanInfo->width = width;
    spanInfo->height = height;
    spanInfo->srcFormat = format;
    spanInfo->srcType = type;
    spanInfo->srcImage = buf;
    __glInitTextureStore(gc, spanInfo, internalFormat);
    __glLoadUnpackModes(gc, spanInfo, packed);
}

/*
** Return GL_TRUE if the given range (length or width/height) is a legal
** power of 2, taking into account the border.  The range is not allowed
** to be negative either.
*/
static GLboolean FASTCALL IsLegalRange(__GLcontext *gc, GLsizei r, GLint border)
{
#ifdef __GL_LINT
    gc = gc;
#endif
    r -= border * 2;
    if ((r < 0) || (r & (r - 1))) {
	__glSetError(GL_INVALID_VALUE);
	return GL_FALSE;
    }
    return GL_TRUE;
}

__GLtexture *FASTCALL __glCheckTexImage1DArgs(__GLcontext *gc, GLenum target, GLint lod,
				     GLint components, GLsizei length,
				     GLint border, GLenum format, GLenum type)
{
    __GLtexture *tex;

    /* Check arguments and get the right texture being changed */
    tex = CheckTexImageArgs(gc, target, lod, components, border,
			    format, type, 1);
    if (!tex) {
	return 0;
    }
    if (!IsLegalRange(gc, length, border)) {
	return 0;
    }
    return tex;
}

__GLtexture *FASTCALL __glCheckTexImage2DArgs(__GLcontext *gc, GLenum target, GLint lod,
				     GLint components, GLsizei w, GLsizei h,
				     GLint border, GLenum format, GLenum type)
{
    __GLtexture *tex;

    /* Check arguments and get the right texture being changed */
    tex = CheckTexImageArgs(gc, target, lod, components, border,
			    format, type, 2);
    if (!tex) {
	return 0;
    }
    if (!IsLegalRange(gc, w, border)) {
	return 0;
    }
    if (!IsLegalRange(gc, h, border)) {
	return 0;
    }
    return tex;
}

#ifdef NT
void APIPRIVATE __glim_TexImage1D(GLenum target, GLint lod, 
		       GLint components, GLsizei length,
		       GLint border, GLenum format,
		       GLenum type, const GLvoid *buf, GLboolean _IsDlist)
#else
void APIPRIVATE __glim_TexImage1D(GLenum target, GLint lod, 
		       GLint components, GLsizei length,
		       GLint border, GLenum format,
		       GLenum type, const GLvoid *buf)
#endif
{
    __GLtexture *tex;
    __GLtextureBuffer *dest;
    __GLpixelSpanInfo spanInfo;
    /*
    ** Validate because we use the copyImage proc which may be affected
    ** by the pickers.
    */
    __GL_SETUP_NOT_IN_BEGIN_VALIDATE();

    /* Check arguments and get the right texture being changed */
    tex = __glCheckTexImage1DArgs(gc, target, lod, components, length,
				  border, format, type);
    if (!tex) {
	return;
    }

    // If we don't currently have the texture lock, take it.
    if (!glsrvLazyGrabSurfaces((__GLGENcontext *)gc, TEXTURE_LOCK_FLAGS))
    {
        return;
    }
    
    /* Allocate memory for the level data */
    dest = (*tex->createLevel)(gc, tex, lod, components,
			       length, 1+border*2, border, 1);

    /* Copy image data */
    if (buf && dest) {
        spanInfo.dstImage = dest;
#ifdef NT
        __glInitTextureUnpack(gc, &spanInfo, length, 1, format, type, buf, 
			      tex->level[lod].internalFormat,
			      (GLboolean) (_IsDlist ? GL_TRUE : GL_FALSE));
#else
        __glInitTextureUnpack(gc, &spanInfo, length, 1, format, type, buf, 
			      tex->level[lod].internalFormat, GL_FALSE);
#endif
	spanInfo.dstSkipLines += border;
        __glInitUnpacker(gc, &spanInfo);
        __glInitPacker(gc, &spanInfo);
        (*gc->procs.copyImage)(gc, &spanInfo, GL_TRUE);
#ifdef NT
        __glTexPriListLoadImage(gc, GL_TEXTURE_1D);
#endif
    }

    /* Might have just disabled texturing... */
    __GL_DELAY_VALIDATE(gc);
}

#ifndef NT
void __gllei_TexImage1D(__GLcontext *gc, GLenum target, GLint lod,
		        GLint components, GLsizei length, GLint border,
		        GLenum format, GLenum type, const GLubyte *image)
{
    __GLtexture *tex;
    __GLtextureBuffer *dest;
    __GLpixelSpanInfo spanInfo;
    GLuint beginMode;

    /*
    ** Validate because we use the copyImage proc which may be affected
    ** by the pickers.
    */
    beginMode = gc->beginMode;
    if (beginMode != __GL_NOT_IN_BEGIN) {
	if (beginMode == __GL_NEED_VALIDATE) {
	    (*gc->procs.validate)(gc);
	    gc->beginMode = __GL_NOT_IN_BEGIN;
	} else {
	    __glSetError(GL_INVALID_OPERATION);
	    return;
	}
    }

    /* Check arguments and get the right texture being changed */
    tex = __glCheckTexImage1DArgs(gc, target, lod, components, length,
				  border, format, type);
    if (!tex) {
	return;
    }

    // If we don't currently have the texture lock, take it.
    if (!glsrvLazyGrabSurfaces((__GLGENcontext *)gc, TEXTURE_LOCK_FLAGS))
    {
        return;
    }
    
    /* Allocate memory for the level data */
    dest = (*tex->createLevel)(gc, tex, lod, components,
			       length, 1+border*2, border, 1);

    /* Copy image data */
    if (image && dest) {
        spanInfo.dstImage = dest;
        __glInitTextureUnpack(gc, &spanInfo, length, 1, format, type, image,
			      tex->level[lod].internalFormat, GL_TRUE);
	spanInfo.dstSkipLines += border;
        __glInitUnpacker(gc, &spanInfo);
        __glInitPacker(gc, &spanInfo);
        (*gc->procs.copyImage)(gc, &spanInfo, GL_TRUE);
#ifdef NT
        __glTexPriListLoadImage(gc, GL_TEXTURE_1D);
#endif
    }

    /* Might have just disabled texturing... */
    __GL_DELAY_VALIDATE(gc);
}
#endif // !NT

/************************************************************************/

void APIPRIVATE __glim_TexImage2D(GLenum target, GLint lod, GLint components,
		       GLsizei w, GLsizei h, GLint border, GLenum format,
		       GLenum type, const GLvoid *buf, GLboolean _IsDlist)
{
    __GLtexture *tex;
    __GLtextureBuffer *dest;
    __GLpixelSpanInfo spanInfo;
    /*
    ** Validate because we use the copyImage proc which may be affected
    ** by the pickers.
    */
    __GL_SETUP_NOT_IN_BEGIN_VALIDATE();

    /* Check arguments and get the right texture being changed */
    tex = __glCheckTexImage2DArgs(gc, target, lod, components, w, h,
				  border, format, type);
    if (!tex) {
	return;
    }

    // Check for a DirectDraw texture
    if (target == GL_TEXTURE_2D && gc->texture.ddtex.levels > 0)
    {
        __glSetError(GL_INVALID_OPERATION);
        return;
    }
    
    // If we don't currently have the texture lock, take it.
    if (!glsrvLazyGrabSurfaces((__GLGENcontext *)gc, TEXTURE_LOCK_FLAGS))
    {
        return;
    }
    
    /* Allocate memory for the level data */
    dest = (*tex->createLevel)(gc, tex, lod, components, w, h, border, 2);

    /* Copy image data */
    if (buf && dest) {
        spanInfo.dstImage = dest;
#ifdef NT
        __glInitTextureUnpack(gc, &spanInfo, w, h, format, type, buf,
			      (GLenum) tex->level[lod].internalFormat,
			      (GLboolean) (_IsDlist ? GL_TRUE : GL_FALSE));
#else
        __glInitTextureUnpack(gc, &spanInfo, w, h, format, type, buf,
			      tex->level[lod].internalFormat, GL_FALSE);
#endif
        __glInitUnpacker(gc, &spanInfo);
        __glInitPacker(gc, &spanInfo);
        (*gc->procs.copyImage)(gc, &spanInfo, GL_TRUE);
#ifdef NT
        __glTexPriListLoadImage(gc, GL_TEXTURE_2D);
#endif
    }

    /* Might have just disabled texturing... */
    __GL_DELAY_VALIDATE(gc);
}

#ifndef NT
void __gllei_TexImage2D(__GLcontext *gc, GLenum target, GLint lod, 
		        GLint components, GLsizei w, GLsizei h, 
		        GLint border, GLenum format, GLenum type,
		        const GLubyte *image)
{
    __GLtexture *tex;
    __GLtextureBuffer *dest;
    __GLpixelSpanInfo spanInfo;
    GLuint beginMode;

    /*
    ** Validate because we use the copyImage proc which may be affected
    ** by the pickers.
    */
    beginMode = gc->beginMode;
    if (beginMode != __GL_NOT_IN_BEGIN) {
	if (beginMode == __GL_NEED_VALIDATE) {
	    (*gc->procs.validate)(gc);
	    gc->beginMode = __GL_NOT_IN_BEGIN;
	} else {
	    __glSetError(GL_INVALID_OPERATION);
	    return;
	}
    }

    /* Check arguments and get the right texture being changed */
    tex = __glCheckTexImage2DArgs(gc, target, lod, components, w, h,
				  border, format, type);
    if (!tex) {
	return;
    }

    // If we don't currently have the texture lock, take it.
    if (!glsrvLazyGrabSurfaces((__GLGENcontext *)gc, TEXTURE_LOCK_FLAGS))
    {
        return;
    }
    
    /* Allocate memory for the level data */
    dest = (*tex->createLevel)(gc, tex, lod, components, w, h, border, 2);

    /* Copy image data */
    if (image && dest) {
        spanInfo.dstImage = dest;
        __glInitTextureUnpack(gc, &spanInfo, w, h, format, type, image,
			      tex->level[lod].internalFormat, GL_TRUE);
        __glInitUnpacker(gc, &spanInfo);
        __glInitPacker(gc, &spanInfo);
        (*gc->procs.copyImage)(gc, &spanInfo, GL_TRUE);
#ifdef NT
        __glTexPriListLoadImage(gc, GL_TEXTURE_2D);
#endif
    }

    /* Might have just disabled texturing... */
    __GL_DELAY_VALIDATE(gc);
}
#endif // !NT

/***********************************************************************/

static __GLtexture *CheckTexSubImageArgs(__GLcontext *gc, GLenum target,
					 GLint lod, GLenum format,
					 GLenum type, GLint dim)
{
    __GLtexture *tex = __glLookUpTexture(gc, target);
    __GLmipMapLevel *lp;

    if (!tex || (target == GL_PROXY_TEXTURE_1D) ||
		(target == GL_PROXY_TEXTURE_2D))
    {
      bad_enum:
	__glSetError(GL_INVALID_ENUM);
	return 0;
    }

    if (tex->dim != dim) {
	goto bad_enum;
    }

    switch (type) {
      case GL_BITMAP:
	if (format != GL_COLOR_INDEX) goto bad_enum;
      case GL_BYTE:
      case GL_UNSIGNED_BYTE:
      case GL_SHORT:
      case GL_UNSIGNED_SHORT:
      case GL_INT:
      case GL_UNSIGNED_INT:
      case GL_FLOAT:
	break;
      default:
	goto bad_enum;
    }

    switch (format) {
      case GL_COLOR_INDEX:	case GL_RED:
      case GL_GREEN:		case GL_BLUE:
      case GL_ALPHA:		case GL_RGB:
      case GL_RGBA:		case GL_LUMINANCE:
      case GL_LUMINANCE_ALPHA:
#ifdef GL_EXT_bgra
      case GL_BGRA_EXT:
      case GL_BGR_EXT:
#endif
	break;
      default:
	goto bad_enum;
    }

    if ((lod < 0) || (lod >= gc->constants.maxMipMapLevel)) {
	__glSetError(GL_INVALID_VALUE);
	return 0;
    }

#ifdef GL_EXT_paletted_texture
    lp = &tex->level[lod];
    if ((lp->internalFormat == GL_COLOR_INDEX8_EXT ||
         lp->internalFormat == GL_COLOR_INDEX16_EXT) &&
        format != GL_COLOR_INDEX)
    {
        goto bad_enum;
    }
#endif

    return tex;
}

/*
** Used for extraction from textures.  "packed" is set to GL_TRUE if this
** image is being pulled out of a display list, and GL_FALSE if it is 
** being pulled directly out of an application.
*/
void __glInitTexSubImageUnpack(__GLcontext *gc, __GLpixelSpanInfo *spanInfo, 
			       __GLmipMapLevel *lp,
		               GLsizei xoffset, GLsizei yoffset,
			       GLint width, GLint height, GLenum format, 
			       GLenum type, const GLvoid *buf, GLboolean packed)
{
    spanInfo->x = 0;
    spanInfo->zoomx = __glOne;
    spanInfo->realWidth = spanInfo->width = width;
    spanInfo->height = height;
    spanInfo->srcFormat = format;
    spanInfo->srcType = type;
    spanInfo->srcImage = buf;

    __glLoadUnpackModes(gc, spanInfo, packed);

    spanInfo->dstImage = lp->buffer;
    spanInfo->dstSkipPixels = xoffset + lp->border;
    spanInfo->dstSkipLines = yoffset + lp->border;
    spanInfo->dstSwapBytes = GL_FALSE;
    spanInfo->dstLsbFirst = GL_TRUE;
    spanInfo->dstLineLength = lp->width;

    switch(lp->internalFormat) {
      case GL_LUMINANCE:
	spanInfo->dstFormat = GL_RED;
	spanInfo->dstType = GL_FLOAT;
	spanInfo->dstAlignment = 4;
	break;
      case GL_LUMINANCE_ALPHA:
	spanInfo->dstFormat = __GL_RED_ALPHA;
	spanInfo->dstType = GL_FLOAT;
	spanInfo->dstAlignment = 4;
	break;
      case GL_RGB:
	spanInfo->dstFormat = GL_RGB;
	spanInfo->dstType = GL_FLOAT;
	spanInfo->dstAlignment = 4;
	break;
      case GL_RGBA:
	spanInfo->dstFormat = GL_RGBA;
	spanInfo->dstType = GL_FLOAT;
	spanInfo->dstAlignment = 4;
	break;
      case GL_ALPHA:
	spanInfo->dstFormat = GL_ALPHA;
	spanInfo->dstType = GL_FLOAT;
	spanInfo->dstAlignment = 4;
	break;
      case GL_INTENSITY:
	spanInfo->dstFormat = GL_RED;
	spanInfo->dstType = GL_FLOAT;
	spanInfo->dstAlignment = 4;
	break;
    case GL_BGR_EXT:
        // Be a little tricky here to pad the data out to 32 bits
	spanInfo->dstFormat = GL_BGRA_EXT;
	spanInfo->dstType = GL_UNSIGNED_BYTE;
	spanInfo->dstAlignment = 4;
        break;
    case GL_BGRA_EXT:
	spanInfo->dstFormat = GL_BGRA_EXT;
	spanInfo->dstType = GL_UNSIGNED_BYTE;
	spanInfo->dstAlignment = 4;
        break;
#ifdef GL_EXT_paletted_texture
      case GL_COLOR_INDEX8_EXT:
      case GL_COLOR_INDEX16_EXT:
        spanInfo->dstFormat = GL_COLOR_INDEX;
        spanInfo->dstType =
            lp->internalFormat == GL_COLOR_INDEX8_EXT ?
            GL_UNSIGNED_BYTE : GL_UNSIGNED_SHORT;
	spanInfo->dstAlignment = 1;
        break;
#endif
    }
}

static GLboolean CheckTexSubImageRange(__GLcontext *gc, __GLmipMapLevel *lp,
				       GLint xoffset, GLint yoffset,
				       GLsizei w, GLsizei h)
{
#ifdef __GL_LINT
    gc = gc;
#endif
    if ((w < 0) || (h < 0) ||
	(xoffset < -lp->border) || (xoffset+w > lp->width-lp->border) ||
        (yoffset < -lp->border) || (yoffset+h > lp->height-lp->border))
    {
	__glSetError(GL_INVALID_VALUE);
	return GL_FALSE;
    }
    return GL_TRUE;
}

__GLtexture *__glCheckTexSubImage1DArgs(__GLcontext *gc, GLenum target,
					GLint lod,
					GLint xoffset, GLint length,
					GLenum format, GLenum type)
{
    __GLtexture *tex;
    __GLmipMapLevel *lp;

    /* Check arguments and get the right texture being changed */
    tex = CheckTexSubImageArgs(gc, target, lod, format, type, 1);
    if (!tex) {
	return 0;
    }
    lp = &tex->level[lod];
    if (!CheckTexSubImageRange(gc, lp, xoffset, 0, length, 1)) {
	return 0;
    }
    return tex;
}

__GLtexture *__glCheckTexSubImage2DArgs(__GLcontext *gc, GLenum target,
					GLint lod,
					GLint xoffset, GLint yoffset,
					GLsizei w, GLsizei h,
					GLenum format, GLenum type)
{
    __GLtexture *tex;
    __GLmipMapLevel *lp;

    /* Check arguments and get the right texture being changed */
    tex = CheckTexSubImageArgs(gc, target, lod, format, type, 2);
    if (!tex) {
	return 0;
    }
    lp = &tex->level[lod];
    if (!CheckTexSubImageRange(gc, lp, xoffset, yoffset, w, h)) {
	return 0;
    }
    return tex;
}

#ifdef NT
void APIPRIVATE __glim_TexSubImage1D(GLenum target, GLint lod, 
		       GLint xoffset, GLint length,
		       GLenum format, GLenum type, const GLvoid *buf,
		       GLboolean _IsDlist)
#else
void APIPRIVATE __glim_TexSubImage1D(GLenum target, GLint lod, 
		       GLint xoffset, GLint length,
		       GLenum format, GLenum type, const GLvoid *buf)
#endif
{
    __GLtexture *tex;
    __GLmipMapLevel *lp;
    __GLpixelSpanInfo spanInfo;
    /*
    ** Validate because we use the copyImage proc which may be affected
    ** by the pickers.
    */
    __GL_SETUP_NOT_IN_BEGIN_VALIDATE();

    /* Check arguments and get the right texture level being changed */
    tex = __glCheckTexSubImage1DArgs(gc, target, lod, xoffset, length,
				     format, type);
    if (!tex) {
	return;
    }

    lp = &tex->level[lod];
    if (lp->buffer == NULL) {
	__glSetError(GL_INVALID_OPERATION);
	return;
    }

    // If we don't currently have the texture lock, take it.
    if (!glsrvLazyGrabSurfaces((__GLGENcontext *)gc, TEXTURE_LOCK_FLAGS))
    {
        return;
    }
    
    /* Copy sub-image data */
#ifdef NT
    __glInitTexSubImageUnpack(gc, &spanInfo, lp, xoffset, 0, length, 1,
			      format, type, buf,
			      (GLboolean) (_IsDlist ? GL_TRUE : GL_FALSE));
#else
    __glInitTexSubImageUnpack(gc, &spanInfo, lp, xoffset, 0, length, 1,
			      format, type, buf, GL_FALSE);
#endif
    spanInfo.dstSkipLines += lp->border;
    __glInitUnpacker(gc, &spanInfo);
    __glInitPacker(gc, &spanInfo);
    (*gc->procs.copyImage)(gc, &spanInfo, GL_TRUE);
#ifdef NT
    __glTexPriListLoadSubImage(gc, GL_TEXTURE_1D, lod, xoffset, 0,
                               length, 1);
#endif
}

#ifndef NT
void __gllei_TexSubImage1D(__GLcontext *gc, GLenum target, GLint lod,
		        GLint xoffset, GLint length,
		        GLenum format, GLenum type, const GLubyte *image)
{
    __GLtexture *tex;
    __GLmipMapLevel *lp;
    __GLpixelSpanInfo spanInfo;
    GLuint beginMode;

    /*
    ** Validate because we use the copyImage proc which may be affected
    ** by the pickers.
    */
    beginMode = gc->beginMode;
    if (beginMode != __GL_NOT_IN_BEGIN) {
	if (beginMode == __GL_NEED_VALIDATE) {
	    (*gc->procs.validate)(gc);
	    gc->beginMode = __GL_NOT_IN_BEGIN;
	} else {
	    __glSetError(GL_INVALID_OPERATION);
	    return;
	}
    }

    /* Check arguments and get the right texture level being changed */
    tex = __glCheckTexSubImage1DArgs(gc, target, lod, xoffset, length,
				     format, type);
    if (!tex) {
	return;
    }

    lp = &tex->level[lod];
    if (lp->buffer == NULL) {
	__glSetError(GL_INVALID_OPERATION);
	return;
    }

    // If we don't currently have the texture lock, take it.
    if (!glsrvLazyGrabSurfaces((__GLGENcontext *)gc, TEXTURE_LOCK_FLAGS))
    {
        return;
    }
    
    /* Copy sub-image data */
    __glInitTexSubImageUnpack(gc, &spanInfo, lp, xoffset, 0, length, 1,
			      format, type, image, GL_TRUE);
    spanInfo.dstSkipLines += lp->border;
    __glInitUnpacker(gc, &spanInfo);
    __glInitPacker(gc, &spanInfo);
    (*gc->procs.copyImage)(gc, &spanInfo, GL_TRUE);
#ifdef NT
    __glTexPriListLoadSubImage(gc, GL_TEXTURE_1D, lod, xoffset, 0,
                               length, 1);
#endif
}
#endif // !NT

#ifdef NT
void APIPRIVATE __glim_TexSubImage2D(GLenum target, GLint lod,
		       GLint xoffset, GLint yoffset,
		       GLsizei w, GLsizei h, GLenum format,
		       GLenum type, const GLvoid *buf, GLboolean _IsDlist)
#else
void APIPRIVATE __glim_TexSubImage2D(GLenum target, GLint lod,
		       GLint xoffset, GLint yoffset,
		       GLsizei w, GLsizei h, GLenum format,
		       GLenum type, const GLvoid *buf)
#endif
{
    __GLtexture *tex;
    __GLmipMapLevel *lp;
    __GLpixelSpanInfo spanInfo;
    /*
    ** Validate because we use the copyImage proc which may be affected
    ** by the pickers.
    */
    __GL_SETUP_NOT_IN_BEGIN_VALIDATE();

    /* Check arguments and get the right texture level being changed */
    tex = __glCheckTexSubImage2DArgs(gc, target, lod, xoffset, yoffset, w, h,
				     format, type);
    if (!tex) {
	return;
    }

    lp = &tex->level[lod];
    if (lp->buffer == NULL) {
	__glSetError(GL_INVALID_OPERATION);
	return;
    }

    // If we don't currently have the texture lock, take it.
    if (!glsrvLazyGrabSurfaces((__GLGENcontext *)gc, TEXTURE_LOCK_FLAGS))
    {
        return;
    }
    
    /* Copy sub-image data */
#ifdef NT
    __glInitTexSubImageUnpack(gc, &spanInfo, lp, xoffset, yoffset, w, h,
			      format, type, buf,
			      (GLboolean) (_IsDlist ? GL_TRUE : GL_FALSE));
#else
    __glInitTexSubImageUnpack(gc, &spanInfo, lp, xoffset, yoffset, w, h,
			      format, type, buf, GL_FALSE);
#endif
    __glInitUnpacker(gc, &spanInfo);
    __glInitPacker(gc, &spanInfo);
    (*gc->procs.copyImage)(gc, &spanInfo, GL_TRUE);
#ifdef NT
    __glTexPriListLoadSubImage(gc, GL_TEXTURE_2D, lod, xoffset, yoffset,
                               w, h);
#endif
}

#ifndef NT
void __gllei_TexSubImage2D(__GLcontext *gc, GLenum target, GLint lod, 
		        GLint xoffset, GLint yoffset,
			GLsizei w, GLsizei h, GLenum format, GLenum type,
		        const GLubyte *image)
{
    __GLtexture *tex;
    __GLmipMapLevel *lp;
    __GLpixelSpanInfo spanInfo;
    GLuint beginMode;

    /*
    ** Validate because we use the copyImage proc which may be affected
    ** by the pickers.
    */
    beginMode = gc->beginMode;
    if (beginMode != __GL_NOT_IN_BEGIN) {
	if (beginMode == __GL_NEED_VALIDATE) {
	    (*gc->procs.validate)(gc);
	    gc->beginMode = __GL_NOT_IN_BEGIN;
	} else {
	    __glSetError(GL_INVALID_OPERATION);
	    return;
	}
    }

    /* Check arguments and get the right texture level being changed */
    tex = __glCheckTexSubImage2DArgs(gc, target, lod, xoffset, yoffset, w, h,
				     format, type);
    if (!tex) {
	return;
    }

    lp = &tex->level[lod];
    if (lp->buffer == NULL) {
	__glSetError(GL_INVALID_OPERATION);
	return;
    }

    // If we don't currently have the texture lock, take it.
    if (!glsrvLazyGrabSurfaces((__GLGENcontext *)gc, TEXTURE_LOCK_FLAGS))
    {
        return;
    }
    
    /* Copy sub-image data */
    __glInitTexSubImageUnpack(gc, &spanInfo, lp, xoffset, yoffset, w, h,
			      format, type, image, GL_TRUE);
    __glInitUnpacker(gc, &spanInfo);
    __glInitPacker(gc, &spanInfo);
    (*gc->procs.copyImage)(gc, &spanInfo, GL_TRUE);
#ifdef NT
    __glTexPriListLoadSubImage(gc, GL_TEXTURE_2D, lod, xoffset, yoffset,
                               w, h);
#endif
}
#endif // !NT

/************************************************************************/

// Routine to set up all the correct pixel modes for a straight data
// copy.  Preserves state for later shutoff
typedef struct _StraightCopyStorage
{
    __GLpixelPackMode pack;
    __GLpixelUnpackMode unpack;
    __GLpixelTransferMode transfer;
} StraightCopyStorage;

void StartStraightCopy(__GLcontext *gc, StraightCopyStorage *state)
{
    state->pack = gc->state.pixel.packModes;
    state->unpack = gc->state.pixel.unpackModes;
    state->transfer = gc->state.pixel.transferMode;

    gc->state.pixel.packModes.swapEndian = GL_FALSE;
    gc->state.pixel.packModes.lsbFirst = GL_FALSE;
    gc->state.pixel.packModes.lineLength = 0;
    gc->state.pixel.packModes.skipLines = 0;
    gc->state.pixel.packModes.skipPixels = 0;
    gc->state.pixel.packModes.alignment = 4;
    gc->state.pixel.unpackModes.swapEndian = GL_FALSE;
    gc->state.pixel.unpackModes.lsbFirst = GL_FALSE;
    gc->state.pixel.unpackModes.lineLength = 0;
    gc->state.pixel.unpackModes.skipLines = 0;
    gc->state.pixel.unpackModes.skipPixels = 0;
    gc->state.pixel.unpackModes.alignment = 4;
    gc->state.pixel.transferMode.r_scale = 1.0f;
    gc->state.pixel.transferMode.g_scale = 1.0f;
    gc->state.pixel.transferMode.b_scale = 1.0f;
    gc->state.pixel.transferMode.a_scale = 1.0f;
    gc->state.pixel.transferMode.d_scale = 1.0f;
    gc->state.pixel.transferMode.r_bias = 0.0f;
    gc->state.pixel.transferMode.g_bias = 0.0f;
    gc->state.pixel.transferMode.b_bias = 0.0f;
    gc->state.pixel.transferMode.a_bias = 0.0f;
    gc->state.pixel.transferMode.d_bias = 0.0f;
    gc->state.pixel.transferMode.zoomX = 1.0f;
    gc->state.pixel.transferMode.zoomY = 1.0f;
    gc->state.pixel.transferMode.indexShift = 0;
    gc->state.pixel.transferMode.indexOffset = 0;
    gc->state.pixel.transferMode.mapColor = GL_FALSE;
    gc->state.pixel.transferMode.mapStencil = GL_FALSE;

    // Many states have changed so force a repick
    __GL_DELAY_VALIDATE(gc);
}

void EndStraightCopy(__GLcontext *gc, StraightCopyStorage *state)
{
    gc->state.pixel.packModes = state->pack;
    gc->state.pixel.unpackModes = state->unpack;
    gc->state.pixel.transferMode = state->transfer;

    // Many states have changed so force a repick
    __GL_DELAY_VALIDATE(gc);
}

void APIPRIVATE __glim_CopyTexImage1D(GLenum target, GLint level,
                           GLenum internalformat, GLint x, GLint y,
                           GLsizei width, GLint border)
{
    GLubyte *pixels;
    GLenum format, type;
    StraightCopyStorage state;

    __GL_SETUP();
    
    if (target != GL_TEXTURE_1D ||
        (internalformat >= 1 && internalformat <= 4))
    {
        __glSetError(GL_INVALID_ENUM);
        return;
    }

    // Use BGRA format because that matches our internal texture format
    format = GL_BGRA_EXT;
    type = GL_UNSIGNED_BYTE;
    
    // Allocate space for pixel data, read pixels into it from the
    // frame buffer and then do a TexImage
    
    pixels = (GLubyte *)GCALLOC(gc, width*4);
    if (pixels == NULL)
    {
        return;
    }

    StartStraightCopy(gc, &state);

    // __glim_ReadPixels will take the texture lock.
    __glim_ReadPixels(x, y, width, 1, format, type, pixels);
    __glim_TexImage1D(target, level, internalformat,
                      width, border, format, type,
                      pixels, GL_FALSE);

    EndStraightCopy(gc, &state);
    
    GCFREE(gc, pixels);
}

void APIPRIVATE __glim_CopyTexImage2D(GLenum target, GLint level,
                           GLenum internalformat, GLint x, GLint y,
                           GLsizei width, GLsizei height, GLint border)
{
    GLubyte *pixels;
    GLenum format, type;
    StraightCopyStorage state;

    __GL_SETUP();
    
    if (target != GL_TEXTURE_2D ||
        (internalformat >= 1 && internalformat <= 4))
    {
        __glSetError(GL_INVALID_ENUM);
        return;
    }

    // Check for a DirectDraw texture
    if (target == GL_TEXTURE_2D && gc->texture.ddtex.levels > 0)
    {
        __glSetError(GL_INVALID_OPERATION);
        return;
    }
    
    // Use BGRA format because that matches our internal texture format
    format = GL_BGRA_EXT;
    type = GL_UNSIGNED_BYTE;
    
    // Allocate space for pixel data, read pixels into it from the
    // frame buffer and then do a TexImage
    
    pixels = (GLubyte *)GCALLOC(gc, width*height*4);
    if (pixels == NULL)
    {
        return;
    }

    StartStraightCopy(gc, &state);
    
    // __glim_ReadPixels will take the texture lock.
    __glim_ReadPixels(x, y, width, height, format, type, pixels);
    __glim_TexImage2D(target, level, internalformat,
                      width, height, border, format,
                      type, pixels, GL_FALSE);

    EndStraightCopy(gc, &state);
    
    GCFREE(gc, pixels);
}

void APIPRIVATE __glim_CopyTexSubImage1D(GLenum target, GLint level, GLint xoffset,
                              GLint x, GLint y, GLsizei width)
{
    GLubyte *pixels;
    GLenum format, type;
    StraightCopyStorage state;

    __GL_SETUP();
    
    if (target != GL_TEXTURE_1D)
    {
        __glSetError(GL_INVALID_ENUM);
        return;
    }

    // Use BGRA format because that matches our internal texture format
    format = GL_BGRA_EXT;
    type = GL_UNSIGNED_BYTE;
    
    // Allocate space for pixel data, read pixels into it from the
    // frame buffer and then do a TexImage
    
    pixels = (GLubyte *)GCALLOC(gc, width*4);
    if (pixels == NULL)
    {
        return;
    }

    StartStraightCopy(gc, &state);
    
    // __glim_ReadPixels will take the texture lock.
    __glim_ReadPixels(x, y, width, 1, format, type, pixels);
    __glim_TexSubImage1D(target, level, xoffset,
                         width, format, type,
                         pixels, GL_FALSE);

    EndStraightCopy(gc, &state);
    
    GCFREE(gc, pixels);
}

void APIPRIVATE __glim_CopyTexSubImage2D(GLenum target, GLint level, GLint xoffset,
                              GLint yoffset, GLint x, GLint y,
                              GLsizei width, GLsizei height)
{
    GLubyte *pixels;
    GLenum format, type;
    StraightCopyStorage state;

    __GL_SETUP();
    
    if (target != GL_TEXTURE_2D)
    {
        __glSetError(GL_INVALID_ENUM);
        return;
    }

    // Use BGRA format because that matches our internal texture format
    format = GL_BGRA_EXT;
    type = GL_UNSIGNED_BYTE;
    
    // Allocate space for pixel data, read pixels into it from the
    // frame buffer and then do a TexImage
    
    pixels = (GLubyte *)GCALLOC(gc, width*height*4);
    if (pixels == NULL)
    {
        return;
    }

    StartStraightCopy(gc, &state);
    
    // __glim_ReadPixels will take the texture lock.
    __glim_ReadPixels(x, y, width, height, format, type, pixels);
    __glim_TexSubImage2D(target, level, xoffset,
                         yoffset, width, height,
                         format, type, pixels, GL_FALSE);

    EndStraightCopy(gc, &state);
    
    GCFREE(gc, pixels);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\soft\so_xform.c ===
/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Transformation procedures.
**
** $Revision: 1.38 $
** $Date: 1993/11/29 20:34:48 $
*/
#include "precomp.h"
#pragma hdrstop

#define __glGenericPickIdentityMatrixProcs(gc, m)	    \
{							                            \
    (m)->xf1 = __glXForm1_2DNRW;			            \
    (m)->xf2 = __glXForm2_2DNRW;			            \
    (m)->xf3 = __glXForm3_2DNRW;			            \
    (m)->xf4 = __glXForm4_2DNRW;			            \
    (m)->xfNorm = __glXForm3_2DNRW;			            \
    (m)->xf1Batch = __glXForm1_2DNRWBatch;		        \
    (m)->xf2Batch = __glXForm2_2DNRWBatch;		        \
    (m)->xf3Batch = __glXForm3_2DNRWBatch;		        \
    (m)->xf4Batch = __glXForm4_2DNRWBatch;		        \
    (m)->xfNormBatch = __glXForm3_2DNRWBatchNormal;		\
    (m)->xfNormBatchN = __glXForm3_2DNRWBatchNormalN;	\
}

void FASTCALL __glScaleMatrix(__GLcontext *gc, __GLmatrix *m, void *data);
void FASTCALL __glTranslateMatrix(__GLcontext *gc, __GLmatrix *m, void *data);
void FASTCALL __glMultiplyMatrix(__GLcontext *gc, __GLmatrix *m, void *data);

// Bit flags that identify matrix entries that contain 0 or 1.

#define _M00_0  0x00000001
#define _M01_0  0x00000002
#define _M02_0  0x00000004
#define _M03_0  0x00000008
#define _M10_0  0x00000010
#define _M11_0  0x00000020
#define _M12_0  0x00000040
#define _M13_0  0x00000080
#define _M20_0  0x00000100
#define _M21_0  0x00000200
#define _M22_0  0x00000400
#define _M23_0  0x00000800
#define _M30_0  0x00001000
#define _M31_0  0x00002000
#define _M32_0  0x00004000
#define _M33_0  0x00008000

#define _M00_1  0x00010000
#define _M01_1  0x00020000
#define _M02_1  0x00040000
#define _M03_1  0x00080000
#define _M10_1  0x00100000
#define _M11_1  0x00200000
#define _M12_1  0x00400000
#define _M13_1  0x00800000
#define _M20_1  0x01000000
#define _M21_1  0x02000000
#define _M22_1  0x04000000
#define _M23_1  0x08000000
#define _M30_1  0x10000000
#define _M31_1  0x20000000
#define _M32_1  0x40000000
#define _M33_1  0x80000000

// Pre-defined matrix types.
#define _MT_IDENTITY                            \
    (_M00_1 | _M01_0 | _M02_0 | _M03_0 |        \
     _M10_0 | _M11_1 | _M12_0 | _M13_0 |        \
     _M20_0 | _M21_0 | _M22_1 | _M23_0 |        \
     _M30_0 | _M31_0 | _M32_0 | _M33_1)

#define _MT_IS2DNR                              \
    (         _M01_0 | _M02_0 | _M03_0 |        \
     _M10_0 |          _M12_0 | _M13_0 |        \
     _M20_0 | _M21_0 |          _M23_0 |        \
                                _M33_1)

#define _MT_IS2D                                \
    (                  _M02_0 | _M03_0 |        \
                       _M12_0 | _M13_0 |        \
     _M20_0 | _M21_0 |          _M23_0 |        \
                                _M33_1)

#define _MT_W0001                               \
    (                           _M03_0 |        \
                                _M13_0 |        \
                                _M23_0 |        \
                                _M33_1)

#define GET_MATRIX_MASK(m,i,j)                                  \
        if ((m)->matrix[i][j] == zer) rowMask |= _M##i##j##_0;  \
        else if ((m)->matrix[i][j] == one) rowMask |= _M##i##j##_1;

// Note: If you are adding a new type, make sure all functions
// using matrixType are correct!  (__glScaleMatrix, __glTranslateMatrix, 
// __glInvertTransposeMatrix, and __glGenericPickVertexProcs)

void FASTCALL __glUpdateMatrixType(__GLmatrix *m)
{
    register __GLfloat zer = __glZero;
    register __GLfloat one = __glOne;
    DWORD rowMask = 0; // identifies 0 and 1 entries

    GET_MATRIX_MASK(m,0,0);
    GET_MATRIX_MASK(m,0,1);
    GET_MATRIX_MASK(m,0,2);
    GET_MATRIX_MASK(m,0,3);
    GET_MATRIX_MASK(m,1,0);
    GET_MATRIX_MASK(m,1,1);
    GET_MATRIX_MASK(m,1,2);
    GET_MATRIX_MASK(m,1,3);
    GET_MATRIX_MASK(m,2,0);
    GET_MATRIX_MASK(m,2,1);
    GET_MATRIX_MASK(m,2,2);
    GET_MATRIX_MASK(m,2,3);
    GET_MATRIX_MASK(m,3,0);
    GET_MATRIX_MASK(m,3,1);
    GET_MATRIX_MASK(m,3,2);
    GET_MATRIX_MASK(m,3,3);

// Some common cases.
// Order of finding matrix type is important!

    if ((rowMask & _MT_IDENTITY) == _MT_IDENTITY)
        m->matrixType = __GL_MT_IDENTITY;
    else if ((rowMask & _MT_IS2DNR) == _MT_IS2DNR)
        m->matrixType = __GL_MT_IS2DNR;
    else if ((rowMask & _MT_IS2D) == _MT_IS2D)
        m->matrixType = __GL_MT_IS2D;
    else if ((rowMask & _MT_W0001) == _MT_W0001)
        m->matrixType = __GL_MT_W0001;
    else 
        m->matrixType = __GL_MT_GENERAL;
}

static void SetDepthRange(__GLcontext *gc, double zNear, double zFar)
{
    __GLviewport *vp = &gc->state.viewport;
    double scale, zero = __glZero, one = __glOne;

    /* Clamp depth range to legal values */
    if (zNear < zero) zNear = zero;
    if (zNear > one) zNear = one;
    if (zFar < zero) zFar = zero;
    if (zFar > one) zFar = one;
    vp->zNear = zNear;
    vp->zFar = zFar;

    /* Compute viewport values for the new depth range */
    if (((__GLGENcontext *)gc)->pMcdState)
        scale = GENACCEL(gc).zDevScale * __glHalf;
    else
        scale = gc->depthBuffer.scale * __glHalf;
    gc->state.viewport.zScale =	(zFar - zNear) * scale;
    gc->state.viewport.zCenter = (zFar + zNear) * scale;

#ifdef _MCD_
    MCD_STATE_DIRTY(gc, VIEWPORT);
#endif
}

void FASTCALL __glInitTransformState(__GLcontext *gc)
{
    GLint i, numClipPlanes, numClipTemp;
    __GLtransform *tr;
    __GLtransformP *ptr;
    __GLtransformT *ttr;
    __GLvertex *vx;

    /* Allocate memory for clip planes */
    numClipPlanes = gc->constants.numberOfClipPlanes;
    numClipTemp = (numClipPlanes + 6) * 2;

    gc->state.transform.eyeClipPlanes = (__GLcoord *)
	GCALLOCZ(gc, 2 * numClipPlanes * sizeof(__GLcoord));
#ifdef NT
    if (NULL == gc->state.transform.eyeClipPlanes)
        return;
#endif
    gc->state.transform.eyeClipPlanesSet =
        gc->state.transform.eyeClipPlanes + numClipPlanes;

    /* Allocate memory for matrix stacks */
    gc->transform.modelViewStack = (__GLtransform*)
	GCALLOCZ(gc, __GL_WGL_MAX_MODELVIEW_STACK_DEPTH*sizeof(__GLtransform));
#ifdef NT
    if (NULL == gc->transform.modelViewStack)
        return;
#endif

    gc->transform.projectionStack = (__GLtransformP*)
	GCALLOCZ(gc, __GL_WGL_MAX_PROJECTION_STACK_DEPTH*
                 sizeof(__GLtransformP));
#ifdef NT
    if (NULL == gc->transform.projectionStack)
        return;
#endif

    gc->transform.textureStack = (__GLtransformT*)
	GCALLOCZ(gc, __GL_WGL_MAX_TEXTURE_STACK_DEPTH*
                 sizeof(__GLtransformT));
#ifdef NT
    if (NULL == gc->transform.textureStack)
        return;
#endif

    /* Allocate memory for clipping temporaries */
    gc->transform.clipTemp = (__GLvertex*)
	GCALLOCZ(gc, numClipTemp * sizeof(__GLvertex));
#ifdef NT
    if (NULL == gc->transform.clipTemp)
        return;
#endif


    gc->state.transform.matrixMode = GL_MODELVIEW;
    SetDepthRange(gc, __glZero, __glOne);

    gc->transform.modelView = tr = &gc->transform.modelViewStack[0];
    __glMakeIdentity(&tr->matrix);
    __glGenericPickIdentityMatrixProcs(gc, &tr->matrix);
    __glMakeIdentity(&tr->inverseTranspose);
    __glGenericPickIdentityMatrixProcs(gc, &tr->inverseTranspose);
    tr->flags = XFORM_CHANGED;

    __glMakeIdentity(&tr->mvp);
    gc->transform.projection = ptr = &gc->transform.projectionStack[0];
    __glMakeIdentity((__GLmatrix *) &ptr->matrix);
    __glGenericPickMvpMatrixProcs(gc, &tr->mvp);

    gc->transform.texture = ttr = &gc->transform.textureStack[0];
    __glMakeIdentity(&ttr->matrix);
    __glGenericPickIdentityMatrixProcs(gc, &ttr->matrix);

    vx = &gc->transform.clipTemp[0];
    for (i = 0; i < numClipTemp; i++, vx++) {/*XXX*/
	vx->color = &vx->colors[__GL_FRONTFACE];
    }

    gc->state.current.normal.z = __glOne;
}

/************************************************************************/

void APIPRIVATE __glim_MatrixMode(GLenum mode)
{
    __GL_SETUP_NOT_IN_BEGIN();

    switch (mode) {
      case GL_MODELVIEW:
      case GL_PROJECTION:
      case GL_TEXTURE:
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    gc->state.transform.matrixMode = mode;
}

void APIPRIVATE __glim_LoadIdentity(void)
{
    __GL_SETUP_NOT_IN_BEGIN();
    __glDoLoadMatrix(gc, NULL, TRUE);
}

void APIPRIVATE __glim_LoadMatrixf(const GLfloat m[16])
{
    __GL_SETUP_NOT_IN_BEGIN();
    __glDoLoadMatrix(gc, (__GLfloat (*)[4])m, FALSE);
}

void APIPRIVATE __glim_MultMatrixf(const GLfloat m[16])
{
    __GL_SETUP_NOT_IN_BEGIN();
    __glDoMultMatrix(gc, (void *) m, __glMultiplyMatrix);
}

void APIPRIVATE __glim_Rotatef(GLfloat angle, GLfloat ax, GLfloat ay, GLfloat az)
{
    __GLmatrix m;
    __GLfloat radians, sine, cosine, ab, bc, ca, t;
    __GLfloat av[4], axis[4];

    __GL_SETUP_NOT_IN_BEGIN();

    av[0] = ax;
    av[1] = ay;
    av[2] = az;
    av[3] = 0;
    __glNormalize(axis, av);

    radians = angle * __glDegreesToRadians;
    sine = __GL_SINF(radians);
    cosine = __GL_COSF(radians);
    ab = axis[0] * axis[1] * (1 - cosine);
    bc = axis[1] * axis[2] * (1 - cosine);
    ca = axis[2] * axis[0] * (1 - cosine);

#ifdef NT
    m.matrix[0][3] = __glZero;
    m.matrix[1][3] = __glZero;
    m.matrix[2][3] = __glZero;
    m.matrix[3][0] = __glZero;
    m.matrix[3][1] = __glZero;
    m.matrix[3][2] = __glZero;
    m.matrix[3][3] = __glOne;
#else
    __glMakeIdentity(&m);
#endif // NT
    t = axis[0] * axis[0];
    m.matrix[0][0] = t + cosine * (1 - t);
    m.matrix[2][1] = bc - axis[0] * sine;
    m.matrix[1][2] = bc + axis[0] * sine;

    t = axis[1] * axis[1];
    m.matrix[1][1] = t + cosine * (1 - t);
    m.matrix[2][0] = ca + axis[1] * sine;
    m.matrix[0][2] = ca - axis[1] * sine;

    t = axis[2] * axis[2];
    m.matrix[2][2] = t + cosine * (1 - t);
    m.matrix[1][0] = ab - axis[2] * sine;
    m.matrix[0][1] = ab + axis[2] * sine;
    __glDoMultMatrix(gc, &m, __glMultiplyMatrix);
}

struct __glScaleRec {
    __GLfloat x,y,z;
};

void APIPRIVATE __glim_Scalef(GLfloat x, GLfloat y, GLfloat z)
{
    struct __glScaleRec scale;
    __GL_SETUP_NOT_IN_BEGIN();

    scale.x = x;
    scale.y = y;
    scale.z = z;
    __glDoMultMatrix(gc, &scale, __glScaleMatrix);
}

struct __glTranslationRec {
    __GLfloat x,y,z;
};

void APIPRIVATE __glim_Translatef(GLfloat x, GLfloat y, GLfloat z)
{
    struct __glTranslationRec trans;
    __GL_SETUP_NOT_IN_BEGIN();

    trans.x = x;
    trans.y = y;
    trans.z = z;
    __glDoMultMatrix(gc, &trans, __glTranslateMatrix);
}

void APIPRIVATE __glim_PushMatrix(void)
{
#ifdef NT
    __GL_SETUP_NOT_IN_BEGIN();	// no need to validate
    switch (gc->state.transform.matrixMode)
    {
      case GL_MODELVIEW:
	__glPushModelViewMatrix(gc);
	break;
      case GL_PROJECTION:
	__glPushProjectionMatrix(gc);
	break;
      case GL_TEXTURE:
	__glPushTextureMatrix(gc);
	break;
    }
#else
    __GL_SETUP_NOT_IN_BEGIN_VALIDATE();
    (*gc->procs.pushMatrix)(gc);
#endif
}

void APIPRIVATE __glim_PopMatrix(void)
{
#ifdef NT
    __GL_SETUP_NOT_IN_BEGIN();	// no need to validate
    switch (gc->state.transform.matrixMode)
    {
      case GL_MODELVIEW:
	__glPopModelViewMatrix(gc);
	break;
      case GL_PROJECTION:
	__glPopProjectionMatrix(gc);
	break;
      case GL_TEXTURE:
	__glPopTextureMatrix(gc);
	break;
    }
#else
    __GL_SETUP_NOT_IN_BEGIN_VALIDATE();
    (*gc->procs.popMatrix)(gc);
#endif
}

void APIPRIVATE __glim_Frustum(GLdouble left, GLdouble right,
		    GLdouble bottom, GLdouble top,
		    GLdouble zNear, GLdouble zFar)
{
    __GLmatrix m;
    __GLfloat deltaX, deltaY, deltaZ;
    __GL_SETUP_NOT_IN_BEGIN();

    deltaX = right - left;
    deltaY = top - bottom;
    deltaZ = zFar - zNear;
    if ((zNear <= (GLdouble) __glZero) || (zFar <= (GLdouble) __glZero) || (deltaX == __glZero) || 
	    (deltaY == __glZero) || (deltaZ == __glZero)) {
	__glSetError(GL_INVALID_VALUE);
	return;
    }

#ifdef NT
    m.matrix[0][1] = __glZero;
    m.matrix[0][2] = __glZero;
    m.matrix[0][3] = __glZero;
    m.matrix[1][0] = __glZero;
    m.matrix[1][2] = __glZero;
    m.matrix[1][3] = __glZero;
    m.matrix[3][0] = __glZero;
    m.matrix[3][1] = __glZero;
#else
    __glMakeIdentity(&m);
#endif
    m.matrix[0][0] = zNear * __glDoubleTwo / deltaX;
    m.matrix[1][1] = zNear * __glDoubleTwo / deltaY;
    m.matrix[2][0] = (right + left) / deltaX;
    m.matrix[2][1] = (top + bottom) / deltaY;
    m.matrix[2][2] = -(zFar + zNear) / deltaZ;
    m.matrix[2][3] = __glMinusOne;
    m.matrix[3][2] = __glDoubleMinusTwo * zNear * zFar / deltaZ;
    m.matrix[3][3] = __glZero;
    __glDoMultMatrix(gc, &m, __glMultiplyMatrix);
}

void APIPRIVATE __glim_Ortho(GLdouble left, GLdouble right, GLdouble bottom, 
		  GLdouble top, GLdouble zNear, GLdouble zFar)
{
    __GLmatrix m;
    GLdouble deltax, deltay, deltaz;
    __GL_SETUP_NOT_IN_BEGIN();

    deltax = right - left;
    deltay = top - bottom;
    deltaz = zFar - zNear;
    if ((deltax == (GLdouble) __glZero) || (deltay == (GLdouble) __glZero) || (deltaz == (GLdouble) __glZero)) {
	__glSetError(GL_INVALID_VALUE);
	return;
    }

#ifdef NT
    m.matrix[0][1] = __glZero;
    m.matrix[0][2] = __glZero;
    m.matrix[0][3] = __glZero;
    m.matrix[1][0] = __glZero;
    m.matrix[1][2] = __glZero;
    m.matrix[1][3] = __glZero;
    m.matrix[2][0] = __glZero;
    m.matrix[2][1] = __glZero;
    m.matrix[2][3] = __glZero;
    m.matrix[3][3] = __glOne;
#else
    __glMakeIdentity(&m);
#endif
    m.matrix[0][0] = __glDoubleTwo / deltax;
    m.matrix[3][0] = -(right + left) / deltax;
    m.matrix[1][1] = __glDoubleTwo / deltay;
    m.matrix[3][1] = -(top + bottom) / deltay;
    m.matrix[2][2] = __glDoubleMinusTwo / deltaz;
    m.matrix[3][2] = -(zFar + zNear) / deltaz;

    __glDoMultMatrix(gc, &m, __glMultiplyMatrix);
}

void FASTCALL __glUpdateViewport(__GLcontext *gc)
{
    __GLfloat ww, hh, w2, h2;

    /* Compute operational viewport values */
    w2 = gc->state.viewport.width * __glHalf;
    h2 = gc->state.viewport.height * __glHalf;
    ww = w2 - gc->constants.viewportEpsilon;
    hh = h2 - gc->constants.viewportEpsilon;
    gc->state.viewport.xScale = ww;
    gc->state.viewport.xCenter = gc->state.viewport.x + w2 +
	gc->constants.fviewportXAdjust;
    if (gc->constants.yInverted) {
	gc->state.viewport.yScale = -hh;
	gc->state.viewport.yCenter =
	    gc->constants.height - (gc->state.viewport.y + h2) +
	    gc->constants.fviewportYAdjust;

#if 0
        DbgPrint("UV ys %.3lf, yc %.3lf (%.3lf)\n",
                 -hh, gc->state.viewport.yCenter,
                 gc->constants.height - (gc->state.viewport.y + h2));
#endif
    } else {
	gc->state.viewport.yScale = hh;
	gc->state.viewport.yCenter = gc->state.viewport.y + h2 +
	    gc->constants.fviewportYAdjust;
    }
}

void FASTCALL __glUpdateViewportDependents(__GLcontext *gc)
{
    /* 
    ** Now that the implementation may have found us a new window size,
    ** we compute these offsets...
    */
    gc->transform.minx = gc->state.viewport.x + gc->constants.viewportXAdjust;
    gc->transform.maxx = gc->transform.minx + gc->state.viewport.width;
    gc->transform.fminx = gc->transform.minx;
    gc->transform.fmaxx = gc->transform.maxx;

    gc->transform.miny =
        (gc->constants.height -
         (gc->state.viewport.y + gc->state.viewport.height)) + 
         gc->constants.viewportYAdjust;
    gc->transform.maxy = gc->transform.miny + gc->state.viewport.height;
    gc->transform.fminy = gc->transform.miny;
    gc->transform.fmaxy = gc->transform.maxy;
}

void APIPRIVATE __glim_Viewport(GLint x, GLint y, GLsizei w, GLsizei h)
{
    __GLfloat ww, hh;
    __GL_SETUP_NOT_IN_BEGIN();

    if ((w < 0) || (h < 0)) {
	__glSetError(GL_INVALID_VALUE);
	return;
    }

    if ((gc->state.viewport.x == x) && (gc->state.viewport.y == y) &&
        (gc->state.viewport.width == w) && (gc->state.viewport.height == h))
        return;
    
    if (h > gc->constants.maxViewportHeight) {
	h = gc->constants.maxViewportHeight;
    }
    if (w > gc->constants.maxViewportWidth) {
	w = gc->constants.maxViewportWidth;
    }

    gc->state.viewport.x = x;
    gc->state.viewport.y = y;
    gc->state.viewport.width = w;
    gc->state.viewport.height = h;

    __glUpdateViewport(gc);

    (*gc->procs.applyViewport)(gc);

    __glUpdateViewportDependents(gc);
    
    /*
    ** Pickers that notice when the transformation matches the viewport
    ** exactly need to be revalidated.  Ugh.
    */
    __GL_DELAY_VALIDATE(gc);
}

void APIPRIVATE __glim_DepthRange(GLdouble zNear, GLdouble zFar)
{
    __GL_SETUP_NOT_IN_BEGIN();

    SetDepthRange(gc, zNear, zFar);
    __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_DEPTH);
}

void APIPRIVATE __glim_Scissor(GLint x, GLint y, GLsizei w, GLsizei h)
{
    __GL_SETUP_NOT_IN_BEGIN();

    if ((w < 0) || (h < 0)) {
	__glSetError(GL_INVALID_VALUE);
	return;
    }

    gc->state.scissor.scissorX = x;
    gc->state.scissor.scissorY = y;
    gc->state.scissor.scissorWidth = w;
    gc->state.scissor.scissorHeight = h;

#ifdef NT
#ifdef _MCD_
    MCD_STATE_DIRTY(gc, SCISSOR);
#endif

    // applyViewport does both
    (*gc->procs.applyViewport)(gc);
#else
    (*gc->procs.applyScissor)(gc);
    (*gc->procs.computeClipBox)(gc);
#endif
}

void APIPRIVATE __glim_ClipPlane(GLenum pi, const GLdouble pv[])
{
    __GLtransform *tr;
    __GL_SETUP_NOT_IN_BEGIN();

    pi -= GL_CLIP_PLANE0;
#ifdef NT
    // pi is unsigned!
    if (pi >= (GLenum) gc->constants.numberOfClipPlanes) {
#else
    if ((pi < 0) || (pi >= gc->constants.numberOfClipPlanes)) {
#endif // NT
	__glSetError(GL_INVALID_ENUM);
	return;
    }
    
    gc->state.transform.eyeClipPlanesSet[pi].x = pv[0];
    gc->state.transform.eyeClipPlanesSet[pi].y = pv[1];
    gc->state.transform.eyeClipPlanesSet[pi].z = pv[2];
    gc->state.transform.eyeClipPlanesSet[pi].w = pv[3];

    /*
    ** Project user clip plane into eye space.
    */
    tr = gc->transform.modelView;
    if (tr->flags & XFORM_UPDATE_INVERSE) {
	__glComputeInverseTranspose(gc, tr);
    }
    (*tr->inverseTranspose.xf4)(&gc->state.transform.eyeClipPlanes[pi],
                                &gc->state.transform.eyeClipPlanesSet[pi].x,
				&tr->inverseTranspose);

    __GL_DELAY_VALIDATE(gc);
#ifdef _MCD_
    MCD_STATE_DIRTY(gc, CLIPCTRL);
#endif
}

/************************************************************************/

void FASTCALL __glPushModelViewMatrix(__GLcontext *gc)
{
    __GLtransform **trp, *tr, *stack;

    trp = &gc->transform.modelView;
    stack = gc->transform.modelViewStack;
    tr = *trp;
    if (tr < &stack[__GL_WGL_MAX_MODELVIEW_STACK_DEPTH-1]) {
	tr[1] = tr[0];
	*trp = tr + 1;
    } else {
	__glSetError(GL_STACK_OVERFLOW);
    }
}

void FASTCALL __glPopModelViewMatrix(__GLcontext *gc)
{
    __GLtransform **trp, *tr, *stack, *mvtr;
    __GLtransformP *ptr;

    trp = &gc->transform.modelView;
    stack = gc->transform.modelViewStack;
    tr = *trp;
    if (tr > &stack[0]) {
	*trp = tr - 1;

	/*
	** See if sequence number of modelView matrix is the same as the
	** sequence number of the projection matrix.  If not, then
	** recompute the mvp matrix.
	*/
	mvtr = gc->transform.modelView;
	ptr = gc->transform.projection;
	if (mvtr->sequence != ptr->sequence) {
	    mvtr->sequence = ptr->sequence;
	    __glMultMatrix(&mvtr->mvp, &mvtr->matrix, (__GLmatrix *) &ptr->matrix);
            __glUpdateMatrixType(&mvtr->mvp);
	}
        __glGenericPickMvpMatrixProcs(gc, &mvtr->mvp);
    } else {
        __glSetError(GL_STACK_UNDERFLOW);
        return;
    }
}

void FASTCALL __glComputeInverseTranspose(__GLcontext *gc, __GLtransform *tr)
{
    __GLmatrix inv;

    __glInvertTransposeMatrix(&tr->inverseTranspose, &tr->matrix);
    __glUpdateMatrixType(&tr->inverseTranspose);
    __glGenericPickMatrixProcs(gc, &tr->inverseTranspose);
    tr->flags &= ~XFORM_UPDATE_INVERSE;
}

/************************************************************************/

void FASTCALL __glPushProjectionMatrix(__GLcontext *gc)
{
    __GLtransformP **trp, *tr, *stack;

    trp = &gc->transform.projection;
    stack = gc->transform.projectionStack;
    tr = *trp;
    if (tr < &stack[__GL_WGL_MAX_PROJECTION_STACK_DEPTH-1]) {
	tr[1] = tr[0];
	*trp = tr + 1;
    } else {
	__glSetError(GL_STACK_OVERFLOW);
    }
}

void FASTCALL __glPopProjectionMatrix(__GLcontext *gc)
{
    __GLtransform *mvtr;
    __GLtransformP **trp, *tr, *stack, *ptr;

    trp = &gc->transform.projection;
    stack = gc->transform.projectionStack;
    tr = *trp;
    if (tr > &stack[0]) {
	*trp = tr - 1;

	/*
	** See if sequence number of modelView matrix is the same as the
	** sequence number of the projection matrix.  If not, then
	** recompute the mvp matrix.
	*/
	mvtr = gc->transform.modelView;
	ptr = gc->transform.projection;
	if (mvtr->sequence != ptr->sequence) {
	    mvtr->sequence = ptr->sequence;
	    __glMultMatrix(&mvtr->mvp, &mvtr->matrix, (__GLmatrix *) &ptr->matrix);
            __glUpdateMatrixType(&mvtr->mvp);
	}
	__glGenericPickMvpMatrixProcs(gc, &mvtr->mvp);
    } else {
	__glSetError(GL_STACK_UNDERFLOW);
	return;
    }
}

/************************************************************************/

void FASTCALL __glPushTextureMatrix(__GLcontext *gc)
{
    __GLtransformT **trp, *tr, *stack;

    trp = &gc->transform.texture;
    stack = gc->transform.textureStack;
    tr = *trp;
    if (tr < &stack[__GL_WGL_MAX_TEXTURE_STACK_DEPTH-1]) {
	tr[1] = tr[0];
	*trp = tr + 1;
    } else {
	__glSetError(GL_STACK_OVERFLOW);
    }
}

void FASTCALL __glPopTextureMatrix(__GLcontext *gc)
{
    __GLtransformT **trp, *tr, *stack;

    trp = &gc->transform.texture;
    stack = gc->transform.textureStack;
    tr = *trp;
    if (tr > &stack[0]) {
	*trp = tr - 1;
        MCD_STATE_DIRTY(gc, TEXTRANSFORM);
    } else {
	__glSetError(GL_STACK_UNDERFLOW);
	return;
    }
}

/************************************************************************/


void FASTCALL __glDoLoadMatrix(__GLcontext *gc, const __GLfloat m[4][4], BOOL bIsIdentity)
{
    __GLtransform *mvtr;
    __GLtransformP *ptr;
    __GLtransformT *ttr;

    switch (gc->state.transform.matrixMode) {
      case GL_MODELVIEW:
	mvtr = gc->transform.modelView;
	if (bIsIdentity)
	{
            __glMakeIdentity(&mvtr->matrix);
	    __glGenericPickIdentityMatrixProcs(gc, &mvtr->matrix);
            __glMakeIdentity(&mvtr->inverseTranspose);
	    __glGenericPickIdentityMatrixProcs(gc, &mvtr->inverseTranspose);
            mvtr->flags = XFORM_CHANGED;
	}
	else
	{
	    *(__GLmatrixBase *)mvtr->matrix.matrix = *(__GLmatrixBase *)m;
            __glUpdateMatrixType(&mvtr->matrix);
	    __glGenericPickMatrixProcs(gc, &mvtr->matrix);
	    mvtr->flags = XFORM_CHANGED | XFORM_UPDATE_INVERSE;
	}

        /* Update mvp matrix */
        ptr = gc->transform.projection;
            ASSERTOPENGL(mvtr->sequence == ptr->sequence,
                "__glDoLoadMatrix: bad projection sequence\n");
        if (bIsIdentity)
        {
                *(__GLmatrixBase *)mvtr->mvp.matrix = *(__GLmatrixBase *)ptr->matrix.matrix;
                mvtr->mvp.matrixType = ptr->matrix.matrixType;
        }
        else
        {
	        __glMultMatrix(&mvtr->mvp, &mvtr->matrix, (__GLmatrix *) &ptr->matrix);
                __glUpdateMatrixType(&mvtr->mvp);
        }
        __glGenericPickMvpMatrixProcs(gc, &mvtr->mvp);
        break;

      case GL_PROJECTION:
        ptr = gc->transform.projection;
        if (bIsIdentity)
        {
                __glMakeIdentity((__GLmatrix *) &ptr->matrix);
        }
        else
        {
	        *(__GLmatrixBase *)ptr->matrix.matrix = *(__GLmatrixBase *)m;
                __glUpdateMatrixType((__GLmatrix *) &ptr->matrix);
        }

#ifdef NT
        ptr->sequence = ++gc->transform.projectionSequence;
#else
        if (++gc->transform.projectionSequence == 0) {
	        __glInvalidateSequenceNumbers(gc);
        } else {
	        ptr->sequence = gc->transform.projectionSequence;
        }
#endif // NT

	/* Update mvp matrix */
	mvtr = gc->transform.modelView;
	mvtr->sequence = ptr->sequence;
        mvtr->flags |= XFORM_CHANGED;
	if (bIsIdentity)
	{
            *(__GLmatrixBase *)mvtr->mvp.matrix = *(__GLmatrixBase *)mvtr->matrix.matrix;
            mvtr->mvp.matrixType = mvtr->matrix.matrixType;
	}
	else
	{
	    __glMultMatrix(&mvtr->mvp, &mvtr->matrix, (__GLmatrix *) &ptr->matrix);
            __glUpdateMatrixType(&mvtr->mvp);
	}
	__glGenericPickMvpMatrixProcs(gc, &mvtr->mvp);
	break;

      case GL_TEXTURE:
        ttr = gc->transform.texture;
        if (bIsIdentity)
        {
            __glMakeIdentity(&ttr->matrix);
            __glGenericPickIdentityMatrixProcs(gc, &ttr->matrix);
        }
        else
        {
            *(__GLmatrixBase *)ttr->matrix.matrix = *(__GLmatrixBase *)m;
            __glUpdateMatrixType(&ttr->matrix);
            __glGenericPickMatrixProcs(gc, &ttr->matrix);
        }
        MCD_STATE_DIRTY(gc, TEXTRANSFORM);
	break;
    }
}

void FASTCALL __glDoMultMatrix(__GLcontext *gc, void *data, 
    void (FASTCALL *multiply)(__GLcontext *gc, __GLmatrix *m, void *data))
{
    __GLtransform *mvtr;
    __GLtransformT *ttr;
    __GLtransformP *ptr;

    switch (gc->state.transform.matrixMode) {
      case GL_MODELVIEW:
	mvtr = gc->transform.modelView;
	(*multiply)(gc, &mvtr->matrix, data);
	mvtr->flags = XFORM_CHANGED | XFORM_UPDATE_INVERSE;
	__glGenericPickMatrixProcs(gc, &mvtr->matrix);

        /* Update mvp matrix */
            ASSERTOPENGL(mvtr->sequence == gc->transform.projection->sequence,
                "__glDoMultMatrix: bad projection sequence\n");
        (*multiply)(gc, &mvtr->mvp, data);
        __glGenericPickMvpMatrixProcs(gc, &mvtr->mvp);
        break;

      case GL_PROJECTION:
        ptr = gc->transform.projection;
        (*multiply)(gc, (__GLmatrix *) &ptr->matrix, data);
#ifdef NT
        ptr->sequence = ++gc->transform.projectionSequence;
#else
        if (++gc->transform.projectionSequence == 0) {
	        __glInvalidateSequenceNumbers(gc);
        } else {
	        ptr->sequence = gc->transform.projectionSequence;
        }
#endif

	/* Update mvp matrix */
	mvtr = gc->transform.modelView;
	mvtr->sequence = ptr->sequence;
        mvtr->flags |= XFORM_CHANGED;
	__glMultMatrix(&mvtr->mvp, &mvtr->matrix, (__GLmatrix *) &ptr->matrix);
        __glUpdateMatrixType(&mvtr->mvp);
	__glGenericPickMvpMatrixProcs(gc, &mvtr->mvp);
	break;

      case GL_TEXTURE:
	ttr = gc->transform.texture;
	(*multiply)(gc, &ttr->matrix, data);
	__glGenericPickMatrixProcs(gc, &ttr->matrix);
        MCD_STATE_DIRTY(gc, TEXTRANSFORM);
	break;
    }
}

/************************************************************************/

/*
** Muliply the first matrix by the second one keeping track of the matrix
** type of the newly combined matrix.
*/
void FASTCALL __glMultiplyMatrix(__GLcontext *gc, __GLmatrix *m, void *data)
{
    __GLmatrix *tm;

    tm = data;
    __glMultMatrix(m, tm, m);
    __glUpdateMatrixType(m);
}

void FASTCALL __glScaleMatrix(__GLcontext *gc, __GLmatrix *m, void *data)
{
    struct __glScaleRec *scale;
    __GLfloat x,y,z;
    __GLfloat M0, M1, M2, M3;

    if (m->matrixType > __GL_MT_IS2DNR) {
	m->matrixType = __GL_MT_IS2DNR;
    }
    scale = data;
    x = scale->x;
    y = scale->y;
    z = scale->z;
    
    M0 = x * m->matrix[0][0];
    M1 = x * m->matrix[0][1];
    M2 = x * m->matrix[0][2];
    M3 = x * m->matrix[0][3];
    m->matrix[0][0] = M0;
    m->matrix[0][1] = M1;
    m->matrix[0][2] = M2;
    m->matrix[0][3] = M3;

    M0 = y * m->matrix[1][0];
    M1 = y * m->matrix[1][1];
    M2 = y * m->matrix[1][2];
    M3 = y * m->matrix[1][3];
    m->matrix[1][0] = M0;
    m->matrix[1][1] = M1;
    m->matrix[1][2] = M2;
    m->matrix[1][3] = M3;

    M0 = z * m->matrix[2][0];
    M1 = z * m->matrix[2][1];
    M2 = z * m->matrix[2][2];
    M3 = z * m->matrix[2][3];
    m->matrix[2][0] = M0;
    m->matrix[2][1] = M1;
    m->matrix[2][2] = M2;
    m->matrix[2][3] = M3;
}

/*
** Matrix type of m stays the same.
*/
void FASTCALL __glTranslateMatrix(__GLcontext *gc, __GLmatrix *m, void *data)
{
    struct __glTranslationRec *trans;
    __GLfloat x,y,z;
    __GLfloat M30, M31, M32, M33;

    if (m->matrixType > __GL_MT_IS2DNR) {
	m->matrixType = __GL_MT_IS2DNR;
    }
    trans = data;
    x = trans->x;
    y = trans->y;
    z = trans->z;
    M30 = x * m->matrix[0][0] + y * m->matrix[1][0] + z * m->matrix[2][0] + 
	    m->matrix[3][0];
    M31 = x * m->matrix[0][1] + y * m->matrix[1][1] + z * m->matrix[2][1] + 
	    m->matrix[3][1];
    M32 = x * m->matrix[0][2] + y * m->matrix[1][2] + z * m->matrix[2][2] + 
	    m->matrix[3][2];
    M33 = x * m->matrix[0][3] + y * m->matrix[1][3] + z * m->matrix[2][3] + 
	    m->matrix[3][3];
    m->matrix[3][0] = M30;
    m->matrix[3][1] = M31;
    m->matrix[3][2] = M32;
    m->matrix[3][3] = M33;
}

/************************************************************************/

#define __GLXFORM1_INIT(v)                  \
    __GLfloat x = (v)[0];                   \
    __GLfloat mat00, mat01, mat02, mat03;   \
    __GLfloat mat30, mat31, mat32, mat33;   \
    __GLfloat a0, a1, a2, a3;               \
                                            \
    mat00 = m->matrix[0][0];                \
    mat01 = m->matrix[0][1];                \
    mat02 = m->matrix[0][2];                \
    mat03 = m->matrix[0][3];                \
                                            \
    mat30 = m->matrix[3][0];                \
    mat31 = m->matrix[3][1];                \
    mat32 = m->matrix[3][2];                \
    mat33 = m->matrix[3][3];                

#define __GLXFORM1_CONT(v)                  \
    x = (v)[0];

#define __GLXFORM1(res)                     \
    a0 = x * mat00;                         \
    a1 = x * mat01;                         \
    a2 = x * mat02;                         \
    a3 = x * mat03;                         \
                                            \
    res->x = a0 + mat30;                    \
    res->y = a1 + mat31;                    \
    res->z = a2 + mat32;                    \
    res->w = a3 + mat33;


#define __GLXFORM1_W_INIT(v)                \
    __GLfloat x = (v)[0];                   \
    __GLfloat mat00, mat01, mat02;          \
    __GLfloat mat30, mat31, mat32;          \
    __GLfloat a0, a1, a2;                   \
                                            \
    mat00 = m->matrix[0][0];                \
    mat01 = m->matrix[0][1];                \
    mat02 = m->matrix[0][2];                \
                                            \
    mat30 = m->matrix[3][0];                \
    mat31 = m->matrix[3][1];                \
    mat32 = m->matrix[3][2];

#define __GLXFORM1_W(res)                   \
    a0 = x * mat00;                         \
    a1 = x * mat01;                         \
    a2 = x * mat02;                         \
                                            \
    res->x = a0 + mat30;                    \
    res->y = a1 + mat31;                    \
    res->z = a2 + mat32;                    \
    res->w = ((__GLfloat) 1.0);


#define __GLXFORM1_2DW_INIT(v)              \
    __GLfloat x = (v)[0];                   \
    __GLfloat mat00, mat01;                 \
    __GLfloat mat30, mat31, mat32;          \
    __GLfloat a0, a1;                       \
                                            \
    mat00 = m->matrix[0][0];                \
    mat01 = m->matrix[0][1];                \
                                            \
    mat30 = m->matrix[3][0];                \
    mat31 = m->matrix[3][1];                \
                                            \
    mat32 = m->matrix[3][2];



#define __GLXFORM1_2DW(res)                 \
    a0 = x * mat00;                         \
    a1 = x * mat01;                         \
                                            \
    res->x = a0 + mat30;                    \
    res->y = a1 + mat31;                    \
    res->z = mat32;                         \
    res->w = ((__GLfloat) 1.0);


#define __GLXFORM1_2DNRW_INIT(v)            \
    __GLfloat x = (v)[0];                   \
    __GLfloat mat00, mat01;                 \
    __GLfloat mat30, mat31, mat32;          \
    __GLfloat a0;                           \
                                            \
    mat00 = m->matrix[0][0];                \
    mat01 = m->matrix[0][1];                \
                                            \
    mat30 = m->matrix[3][0];                \
    mat31 = m->matrix[3][1];                \
                                            \
    mat32 = m->matrix[3][2];


#define __GLXFORM1_2DNRW(res)               \
    a0 = x * mat00;                         \
                                            \
    res->x = a0 + mat30;                    \
    res->y = mat31;                         \
    res->z = mat32;                         \
    res->w = ((__GLfloat) 1.0);


#define __GLXFORM2_INIT(v)                  \
    __GLfloat x = (v)[0];                   \
    __GLfloat y = (v)[1];                   \
    __GLfloat mat00, mat01, mat02, mat03;   \
    __GLfloat mat10, mat11, mat12, mat13;   \
    __GLfloat mat30, mat31, mat32, mat33;   \
    __GLfloat a0, a1, a2, a3;               \
    __GLfloat b0, b1, b2, b3;               \
                                            \
    mat00 = m->matrix[0][0];                \
    mat01 = m->matrix[0][1];                \
    mat02 = m->matrix[0][2];                \
    mat03 = m->matrix[0][3];                \
                                            \
    mat10 = m->matrix[1][0];                \
    mat11 = m->matrix[1][1];                \
    mat12 = m->matrix[1][2];                \
    mat13 = m->matrix[1][3];                \
                                            \
    mat30 = m->matrix[3][0];                \
    mat31 = m->matrix[3][1];                \
    mat32 = m->matrix[3][2];                \
    mat33 = m->matrix[3][3];

#define __GLXFORM2_CONT(v)                  \
    x = (v)[0];                             \
    y = (v)[1];


#define __GLXFORM2(res)                     \
    a0 = x * mat00;                         \
    a1 = x * mat01;                         \
    a2 = x * mat02;                         \
    a3 = x * mat03;                         \
                                            \
    b0 = y * mat10;                         \
    b1 = y * mat11;                         \
    b2 = y * mat12;                         \
    b3 = y * mat13;                         \
                                            \
    a0 += mat30;                            \
    a1 += mat31;                            \
    a2 += mat32;                            \
    a3 += mat33;                            \
                                            \
    res->x = a0 + b0;                       \
    res->y = a1 + b1;                       \
    res->z = a2 + b2;                       \
    res->w = a3 + b3;


#define __GLXFORM2_W_INIT(v)                \
    __GLfloat x = (v)[0];                   \
    __GLfloat y = (v)[1];                   \
    __GLfloat mat00, mat01, mat02;          \
    __GLfloat mat10, mat11, mat12;          \
    __GLfloat mat30, mat31, mat32;          \
    __GLfloat a0, a1, a2;                   \
    __GLfloat b0, b1, b2;                   \
                                            \
    mat00 = m->matrix[0][0];                \
    mat01 = m->matrix[0][1];                \
    mat02 = m->matrix[0][2];                \
                                            \
    mat10 = m->matrix[1][0];                \
    mat11 = m->matrix[1][1];                \
    mat12 = m->matrix[1][2];                \
                                            \
    mat30 = m->matrix[3][0];                \
    mat31 = m->matrix[3][1];                \
    mat32 = m->matrix[3][2];


#define __GLXFORM2_W(res)                   \
    a0 = x * mat00;                         \
    a1 = x * mat01;                         \
    a2 = x * mat02;                         \
                                            \
    b0 = y * mat10;                         \
    b1 = y * mat11;                         \
    b2 = y * mat12;                         \
                                            \
    a0 += mat30;                            \
    a1 += mat31;                            \
    a2 += mat32;                            \
                                            \
    res->x = a0 + b0;                       \
    res->y = a1 + b1;                       \
    res->z = a2 + b2;                       \
    res->w = ((__GLfloat) 1.0);


#define __GLXFORM2_2DW_INIT(v)              \
    __GLfloat x = (v)[0];                   \
    __GLfloat y = (v)[1];                   \
    __GLfloat mat00, mat01;                 \
    __GLfloat mat10, mat11;                 \
    __GLfloat mat30, mat31, mat32;          \
    __GLfloat a0, a1;                       \
    __GLfloat b0, b1;                       \
                                            \
    mat00 = m->matrix[0][0];                \
    mat01 = m->matrix[0][1];                \
                                            \
    mat10 = m->matrix[1][0];                \
    mat11 = m->matrix[1][1];                \
                                            \
    mat30 = m->matrix[3][0];                \
    mat31 = m->matrix[3][1];                \
    mat32 = m->matrix[3][2];


#define __GLXFORM2_2DW(res)                 \
    a0 = x * mat00;                         \
    a1 = x * mat01;                         \
                                            \
    b0 = y * mat10;                         \
    b1 = y * mat11;                         \
                                            \
    a0 += mat30;                            \
    a1 += mat31;                            \
                                            \
    res->x = a0 + b0;                       \
    res->y = a1 + b1;                       \
    res->z = mat32;                         \
    res->w = ((__GLfloat) 1.0);



#define __GLXFORM2_2DNRW_INIT(v)            \
    __GLfloat x = (v)[0];                   \
    __GLfloat y = (v)[1];                   \
    __GLfloat mat00;                        \
    __GLfloat mat11;                        \
    __GLfloat mat30, mat31, mat32;          \
    __GLfloat a0, b0;                       \
                                            \
    mat00 = m->matrix[0][0];                \
                                            \
    mat11 = m->matrix[1][1];                \
                                            \
    mat30 = m->matrix[3][0];                \
    mat31 = m->matrix[3][1];                \
    mat32 = m->matrix[3][2];


#define __GLXFORM2_2DNRW(res)               \
    a0 = x * mat00;                         \
                                            \
    b0 = y * mat11;                         \
                                            \
    res->x = a0 + mat30;                    \
    res->y = b0 + mat31;                    \
    res->z = mat32;                         \
    res->w = ((__GLfloat) 1.0);


#define __GLXFORM3_INIT(v)                  \
    __GLfloat x = (v)[0];                   \
    __GLfloat y = (v)[1];                   \
    __GLfloat z = (v)[2];                   \
    __GLfloat mat00, mat01, mat02, mat03;   \
    __GLfloat mat10, mat11, mat12, mat13;   \
    __GLfloat mat20, mat21, mat22, mat23;   \
    __GLfloat mat30, mat31, mat32, mat33;   \
    __GLfloat a0, a1, a2, a3;               \
    __GLfloat b0, b1, b2, b3;               \
    __GLfloat c0, c1, c2, c3;               \
                                            \
    mat00 = m->matrix[0][0];                \
    mat01 = m->matrix[0][1];                \
    mat02 = m->matrix[0][2];                \
    mat03 = m->matrix[0][3];                \
                                            \
    mat10 = m->matrix[1][0];                \
    mat11 = m->matrix[1][1];                \
    mat12 = m->matrix[1][2];                \
    mat13 = m->matrix[1][3];                \
                                            \
    mat20 = m->matrix[2][0];                \
    mat21 = m->matrix[2][1];                \
    mat22 = m->matrix[2][2];                \
    mat23 = m->matrix[2][3];                \
                                            \
    mat30 = m->matrix[3][0];                \
    mat31 = m->matrix[3][1];                \
    mat32 = m->matrix[3][2];                \
    mat33 = m->matrix[3][3];

#define __GLXFORM3_CONT(v)                  \
    x = (v)[0];                             \
    y = (v)[1];                             \
    z = (v)[2];

#define __GLXFORM3(res)                     \
    a0 = mat00 * x;                         \
    a1 = mat01 * x;                         \
    a2 = mat02 * x;                         \
    a3 = mat03 * x;                         \
                                            \
    b0 = mat10 * y;                         \
    b1 = mat11 * y;                         \
    b2 = mat12 * y;                         \
    b3 = mat13 * y;                         \
                                            \
    c0 = mat20 * z;                         \
    c1 = mat21 * z;                         \
    c2 = mat22 * z;                         \
    c3 = mat23 * z;                         \
                                            \
    a0 += mat30;                            \
    a1 += mat31;                            \
    a2 += mat32;                            \
    a3 += mat33;                            \
                                            \
    a0 += b0;                               \
    a1 += b1;                               \
    a2 += b2;                               \
    a3 += b3;                               \
                                            \
    res->x = a0 + c0;                       \
    res->y = a1 + c1;                       \
    res->z = a2 + c2;                       \
    res->w = a3 + c3;


#define __GLXFORM3_W_INIT(v)                \
    __GLfloat x = (v)[0];                   \
    __GLfloat y = (v)[1];                   \
    __GLfloat z = (v)[2];                   \
    __GLfloat mat00, mat01, mat02;          \
    __GLfloat mat10, mat11, mat12;          \
    __GLfloat mat20, mat21, mat22;          \
    __GLfloat mat30, mat31, mat32;          \
    __GLfloat a0, a1, a2;                   \
    __GLfloat b0, b1, b2;                   \
    __GLfloat c0, c1, c2;                   \
                                            \
    mat00 = m->matrix[0][0];                \
    mat01 = m->matrix[0][1];                \
    mat02 = m->matrix[0][2];                \
                                            \
    mat10 = m->matrix[1][0];                \
    mat11 = m->matrix[1][1];                \
    mat12 = m->matrix[1][2];                \
                                            \
    mat20 = m->matrix[2][0];                \
    mat21 = m->matrix[2][1];                \
    mat22 = m->matrix[2][2];                \
                                            \
    mat30 = m->matrix[3][0];                \
    mat31 = m->matrix[3][1];                \
    mat32 = m->matrix[3][2];

#define __GLXFORM3x3_INIT(v)                \
    __GLfloat x = (v)[0];                   \
    __GLfloat y = (v)[1];                   \
    __GLfloat z = (v)[2];                   \
    __GLfloat mat00, mat01, mat02;          \
    __GLfloat mat10, mat11, mat12;          \
    __GLfloat mat20, mat21, mat22;          \
    __GLfloat a0, a1, a2;                   \
    __GLfloat b0, b1, b2;                   \
    __GLfloat c0, c1, c2;                   \
                                            \
    mat00 = m->matrix[0][0];                \
    mat01 = m->matrix[0][1];                \
    mat02 = m->matrix[0][2];                \
                                            \
    mat10 = m->matrix[1][0];                \
    mat11 = m->matrix[1][1];                \
    mat12 = m->matrix[1][2];                \
                                            \
    mat20 = m->matrix[2][0];                \
    mat21 = m->matrix[2][1];                \
    mat22 = m->matrix[2][2];                \
                                            \

#define __GLXFORM3x3(res)                   \
    a0 = mat00 * x;                         \
    a1 = mat01 * x;                         \
    a2 = mat02 * x;                         \
                                            \
    b0 = mat10 * y;                         \
    b1 = mat11 * y;                         \
    b2 = mat12 * y;                         \
                                            \
    c0 = mat20 * z;                         \
    c1 = mat21 * z;                         \
    c2 = mat22 * z;                         \
                                            \
    a0 += b0;                               \
    a1 += b1;                               \
    a2 += b2;                               \
                                            \
    res->x = a0 + c0;                       \
    res->y = a1 + c1;                       \
    res->z = a2 + c2;                       

#define __GLXFORM3_W(res)                   \
    a0 = mat00 * x;                         \
    a1 = mat01 * x;                         \
    a2 = mat02 * x;                         \
                                            \
    b0 = mat10 * y;                         \
    b1 = mat11 * y;                         \
    b2 = mat12 * y;                         \
                                            \
    c0 = mat20 * z;                         \
    c1 = mat21 * z;                         \
    c2 = mat22 * z;                         \
                                            \
    a0 += mat30;                            \
    a1 += mat31;                            \
    a2 += mat32;                            \
                                            \
    a0 += b0;                               \
    a1 += b1;                               \
    a2 += b2;                               \
                                            \
    res->x = a0 + c0;                       \
    res->y = a1 + c1;                       \
    res->z = a2 + c2;                       \
    res->w = ((__GLfloat) 1.0);

#define __GLXFORM3_2DW_INIT(v)              \
    __GLfloat x = (v)[0];                   \
    __GLfloat y = (v)[1];                   \
    __GLfloat z = (v)[2];                   \
    __GLfloat mat00, mat01;                 \
    __GLfloat mat10, mat11;                 \
    __GLfloat mat22;                        \
    __GLfloat mat30, mat31, mat32;          \
    __GLfloat a0, a1;                       \
    __GLfloat b0, b1;                       \
    __GLfloat c0;                           \
                                            \
    mat00 = m->matrix[0][0];                \
    mat01 = m->matrix[0][1];                \
    mat22 = m->matrix[2][2];                \
                                            \
    mat10 = m->matrix[1][0];                \
    mat11 = m->matrix[1][1];                \
                                            \
    mat30 = m->matrix[3][0];                \
    mat31 = m->matrix[3][1];                \
    mat32 = m->matrix[3][2];

#define __GLXFORM3_2DW(res)                 \
    a0 = mat00 * x;                         \
    a1 = mat01 * x;                         \
                                            \
    c0 = mat22 * z;                         \
                                            \
    b0 = mat10 * y;                         \
    b1 = mat11 * y;                         \
                                            \
    a0 += mat30;                            \
    a1 += mat31;                            \
                                            \
    res->x = a0 + b0;                       \
    res->y = a1 + b1;                       \
    res->z = c0 + mat32;                    \
    res->w = ((__GLfloat) 1.0);


#define __GLXFORM3_2DNRW_INIT(v)            \
    __GLfloat x = (v)[0];                   \
    __GLfloat y = (v)[1];                   \
    __GLfloat z = (v)[2];                   \
    __GLfloat mat00, mat11, mat22;          \
    __GLfloat mat30, mat31, mat32;          \
    __GLfloat a0;                           \
    __GLfloat b0;                           \
    __GLfloat c0;                           \
                                            \
    mat00 = m->matrix[0][0];                \
    mat11 = m->matrix[1][1];                \
    mat22 = m->matrix[2][2];                \
                                            \
    mat30 = m->matrix[3][0];                \
    mat31 = m->matrix[3][1];                \
    mat32 = m->matrix[3][2];

#define __GLXFORM3_2DNRW(res)               \
    a0 = mat00 * x;                         \
    b0 = mat11 * y;                         \
    c0 = mat22 * z;                         \
                                            \
    res->x = a0 + mat30;                    \
    res->y = b0 + mat31;                    \
    res->z = c0 + mat32;                    \
    res->w = ((__GLfloat) 1.0);


#define __GLXFORM4_INIT(v)                  \
    __GLfloat x = (v)[0];                   \
    __GLfloat y = (v)[1];                   \
    __GLfloat z = (v)[2];                   \
    __GLfloat w = (v)[3];                   \
                                            \
    __GLfloat mat00, mat01, mat02, mat03;   \
    __GLfloat mat10, mat11, mat12, mat13;   \
    __GLfloat mat20, mat21, mat22, mat23;   \
    __GLfloat mat30, mat31, mat32, mat33;   \
    __GLfloat a0, a1, a2, a3;               \
    __GLfloat b0, b1, b2, b3;               \
    __GLfloat c0, c1, c2, c3;               \
    __GLfloat d0, d1, d2, d3;               \
                                            \
    mat00 = m->matrix[0][0];                \
    mat01 = m->matrix[0][1];                \
    mat02 = m->matrix[0][2];                \
    mat03 = m->matrix[0][3];                \
                                            \
    mat10 = m->matrix[1][0];                \
    mat11 = m->matrix[1][1];                \
    mat12 = m->matrix[1][2];                \
    mat13 = m->matrix[1][3];                \
                                            \
    mat20 = m->matrix[2][0];                \
    mat21 = m->matrix[2][1];                \
    mat22 = m->matrix[2][2];                \
    mat23 = m->matrix[2][3];                \
                                            \
    mat30 = m->matrix[3][0];                \
    mat31 = m->matrix[3][1];                \
    mat32 = m->matrix[3][2];                \
    mat33 = m->matrix[3][3];

#define __GLXFORM4_CONT(v)                  \
    x = (v)[0];                             \
    y = (v)[1];                             \
    z = (v)[2];                             \
    w = (v)[3];


#define __GLXFORM4(res)                     \
    a0 = mat00 * x;                         \
    a1 = mat01 * x;                         \
    a2 = mat02 * x;                         \
    a3 = mat03 * x;                         \
                                            \
    b0 = mat10 * y;                         \
    b1 = mat11 * y;                         \
    b2 = mat12 * y;                         \
    b3 = mat13 * y;                         \
                                            \
    c0 = mat20 * z;                         \
    c1 = mat21 * z;                         \
    c2 = mat22 * z;                         \
    c3 = mat23 * z;                         \
                                            \
    d0 = mat30 * w;                         \
    d1 = mat31 * w;                         \
    d2 = mat32 * w;                         \
    d3 = mat33 * w;                         \
                                            \
    a0 += b0;                               \
    a1 += b1;                               \
    a2 += b2;                               \
    a3 += b3;                               \
                                            \
    a0 += c0;                               \
    a1 += c1;                               \
    a2 += c2;	                            \
    a3 += c3;                               \
                                            \
    res->x = a0 + d0;                       \
    res->y = a1 + d1;                       \
    res->z = a2 + d2;                       \
    res->w = a3 + d3;

#define __GLXFORM4_W_INIT(v)                \
    __GLfloat x = (v)[0];                   \
    __GLfloat y = (v)[1];                   \
    __GLfloat z = (v)[2];                   \
    __GLfloat w = (v)[3];                   \
    __GLfloat mat00, mat01, mat02;          \
    __GLfloat mat10, mat11, mat12;          \
    __GLfloat mat20, mat21, mat22;          \
    __GLfloat mat30, mat31, mat32;          \
    __GLfloat a0, a1, a2;                   \
    __GLfloat b0, b1, b2;                   \
    __GLfloat c0, c1, c2;                   \
    __GLfloat d0, d1, d2;                   \
                                            \
    mat00 = m->matrix[0][0];                \
    mat01 = m->matrix[0][1];                \
    mat02 = m->matrix[0][2];                \
                                            \
    mat10 = m->matrix[1][0];                \
    mat11 = m->matrix[1][1];                \
    mat12 = m->matrix[1][2];                \
                                            \
    mat20 = m->matrix[2][0];                \
    mat21 = m->matrix[2][1];                \
    mat22 = m->matrix[2][2];                \
                                            \
    mat30 = m->matrix[3][0];                \
    mat31 = m->matrix[3][1];                \
    mat32 = m->matrix[3][2];


#define __GLXFORM4_W(res)                   \
    a0 = mat00 * x;                         \
    a1 = mat01 * x;                         \
    a2 = mat02 * x;                         \
                                            \
    b0 = mat10 * y;                         \
    b1 = mat11 * y;                         \
    b2 = mat12 * y;                         \
                                            \
    c0 = mat20 * z;                         \
    c1 = mat21 * z;                         \
    c2 = mat22 * z;                         \
                                            \
    d0 = mat30 * w;                         \
    d1 = mat31 * w;                         \
    d2 = mat32 * w;                         \
                                            \
    a0 += b0;                               \
    a1 += b1;                               \
    a2 += b2;                               \
                                            \
    a0 += c0;                               \
    a1 += c1;                               \
    a2 += c2;                               \
                                            \
    res->x = a0 + d0;                       \
    res->y = a1 + d1;                       \
    res->z = a2 + d2;                       \
    res->w = w;

#define __GLXFORM4_2DW_INIT(v)              \
    __GLfloat x = (v)[0];                   \
    __GLfloat y = (v)[1];                   \
    __GLfloat z = (v)[2];                   \
    __GLfloat w = (v)[3];                   \
    __GLfloat mat00, mat01;                 \
    __GLfloat mat10, mat11;                 \
    __GLfloat mat22;                        \
    __GLfloat mat30, mat31, mat32;          \
    __GLfloat a0, a1;                       \
    __GLfloat b0, b1;                       \
    __GLfloat c0;                           \
    __GLfloat d0;                           \
                                            \
    mat00 = m->matrix[0][0];                \
    mat01 = m->matrix[0][1];                \
    mat22 = m->matrix[2][2];                \
                                            \
    mat10 = m->matrix[1][0];                \
    mat11 = m->matrix[1][1];                \
                                            \
    mat30 = m->matrix[3][0];                \
    mat31 = m->matrix[3][1];                \
    mat32 = m->matrix[3][2];


#define __GLXFORM4_2DW(res)                 \
    a0 = mat00 * x;                         \
    a1 = mat01 * x;                         \
    c0 = mat22 * z;                         \
                                            \
    b0 = mat10 * y;                         \
    b1 = mat11 * y;                         \
                                            \
    d0 = mat32 * w;                         \
                                            \
    a0 += mat30;                            \
    a1 += mat31;                            \
                                            \
    res->x = a0 + b0;                       \
	res->y = a1 + b1;                       \
    res->z = c0 + d0;                       \
    res->w = w;

#define __GLXFORM4_2DNRW_INIT(v)            \
    __GLfloat x = (v)[0];                   \
    __GLfloat y = (v)[1];                   \
    __GLfloat z = (v)[2];                   \
    __GLfloat w = (v)[3];                   \
    __GLfloat mat00;                        \
    __GLfloat mat11;                        \
    __GLfloat mat22;                        \
    __GLfloat mat30, mat31, mat32;          \
    __GLfloat a0;                           \
    __GLfloat b0;                           \
    __GLfloat c0;                           \
    __GLfloat d0, d1, d2;                   \
                                            \
    mat00 = m->matrix[0][0];                \
    mat11 = m->matrix[1][1];                \
    mat22 = m->matrix[2][2];                \
                                            \
    mat30 = m->matrix[3][0];                \
    mat31 = m->matrix[3][1];                \
    mat32 = m->matrix[3][2];

#define __GLXFORM4_2DNRW(res)               \
    a0 = mat00 * x;                         \
    b0 = mat11 * y;                         \
    c0 = mat22 * z;                         \
                                            \
    d0 = mat30 * w;                         \
    d1 = mat31 * w;                         \
    d2 = mat32 * w;                         \
                                            \
    res->x = a0 + d0;                       \
    res->y = b0 + d1;                       \
    res->z = c0 + d2;                       \
    res->w = w;

#define __GLXFORM_NORMAL_BATCH(funcName, initFunc, workFunc, continueFunc)  \
void FASTCALL funcName(POLYARRAY *pa, const __GLmatrix *m)                  \
{                                                                           \
    POLYDATA *pd = pa->pd0;                                                 \
    POLYDATA *pdLast = pa->pdNextVertex;                                    \
                                                                            \
    for (;pd < pdLast; pd++) {                                              \
        if (pd->flags & POLYDATA_NORMAL_VALID)                              \
        {                                                                   \
            __GLcoord *res = &pd->normal;                                   \
            initFunc((__GLfloat *)res);                                     \
            workFunc(res);                                                  \
            continueFunc((__GLfloat *)res);                                 \
        }                                                                   \
    }                                                                       \
}

#define __GLXFORM_NORMAL_BATCHN(funcName, initFunc, workFunc, continueFunc) \
void FASTCALL funcName(POLYARRAY *pa,  const __GLmatrix *m)                 \
{                                                                           \
    POLYDATA *pd = pa->pd0;                                                 \
    POLYDATA *pdLast = pa->pdNextVertex;                                    \
                                                                            \
    for (;pd < pdLast; pd++) {                                              \
        if (pd->flags & POLYDATA_NORMAL_VALID)                              \
        {                                                                   \
            __GLcoord *res = &pd->normal;                                   \
            initFunc((__GLfloat *)res);                                     \
            workFunc(res);                                                  \
            continueFunc((__GLfloat *)res);                                 \
            __glNormalize((__GLfloat *)res, (__GLfloat *)res);              \
        }                                                                   \
    }                                                                       \
}

#define __GLXFORM_BATCH(funcName, initFunc, workFunc, continueFunc)         \
void FASTCALL funcName(__GLcoord *res, __GLcoord *end, const __GLmatrix *m) \
{                                                                           \
    initFunc((__GLfloat *)res);                                             \
                                                                            \
    for (;;) {                                                              \
        workFunc(res);                                                      \
        (char *)res += sizeof(POLYDATA);                                    \
        if (res > end)                                                      \
            break;                                                          \
        continueFunc((__GLfloat *)res);                                     \
    }                                                                       \
}

/*
** Note: These xform routines must allow for the case where the result
** vector is equal to the source vector.
*/

#ifndef __GL_ASM_XFORM1
/*
** Avoid some transformation computations by knowing that the incoming
** vertex has y=0, z=0 and w=1.
*/
void FASTCALL __glXForm1(__GLcoord *res, const __GLfloat v[1], const __GLmatrix *m)
{
    __GLXFORM1_INIT(v)

    __GLXFORM1(res);
}
#endif /* !__GL_ASM_XFORM1 */

#ifndef __GL_ASM_XFORM1BATCH
__GLXFORM_BATCH(__glXForm1Batch, __GLXFORM1_INIT, __GLXFORM1, __GLXFORM1_CONT);
#endif /* !__GL_ASM_XFORM1BATCH */

#ifndef __GL_ASM_XFORM2
/*
** Avoid some transformation computations by knowing that the incoming
** vertex has z=0 and w=1
*/
void FASTCALL __glXForm2(__GLcoord *res, const __GLfloat v[2], const __GLmatrix *m)
{
    __GLXFORM2_INIT(v)

    __GLXFORM2(res);
}
#endif /* !__GL_ASM_XFORM2 */

#ifndef __GL_ASM_XFORM2BATCH
__GLXFORM_BATCH (__glXForm2Batch, __GLXFORM2_INIT, __GLXFORM2, __GLXFORM2_CONT);
#endif /* !__GL_ASM_XFORM2BATCH */

#ifndef __GL_ASM_XFORM3
/*
** Avoid some transformation computations by knowing that the incoming
** vertex has w=1.
*/
void FASTCALL __glXForm3(__GLcoord *res, const __GLfloat v[3], const __GLmatrix *m)
{
    __GLXFORM3_INIT(v)

    __GLXFORM3(res);
}
#endif /* !__GL_ASM_XFORM3 */

#ifndef __GL_ASM_XFORM3BATCH
__GLXFORM_BATCH (__glXForm3Batch, __GLXFORM3_INIT, __GLXFORM3, __GLXFORM3_CONT);
#endif /* !__GL_ASM_XFORM3BATCH */

#ifndef __GL_ASM_XFORM4
/*
** Full 4x4 transformation.
*/
void FASTCALL __glXForm4(__GLcoord *res, const __GLfloat v[4], const __GLmatrix *m)
{
    __GLXFORM4_INIT(v)

    __GLXFORM4(res);
}
#endif /* !__GL_ASM_XFORM4 */

#ifndef __GL_ASM_XFORM4BATCH
__GLXFORM_BATCH (__glXForm4Batch, __GLXFORM4_INIT, __GLXFORM4, __GLXFORM4_CONT);
#endif /* !__GL_ASM_XFORM4BATCH */

/************************************************************************/

#ifndef __GL_ASM_XFORM1_W
/*
** Avoid some transformation computations by knowing that the incoming
** vertex has y=0, z=0 and w=1.  The w column of the matrix is [0 0 0 1].
*/
void FASTCALL __glXForm1_W(__GLcoord *res, const __GLfloat v[1], const __GLmatrix *m)
{
    __GLXFORM1_W_INIT(v)

    __GLXFORM1_W(res);
}
#endif /* !__GL_ASM_XFORM1_W */

#ifndef __GL_ASM_XFORM1_WBATCH
__GLXFORM_BATCH (__glXForm1_WBatch, __GLXFORM1_W_INIT, __GLXFORM1_W, __GLXFORM1_CONT);
#endif /* !__GL_ASM_XFORM1_WBATCH */

#ifndef __GL_ASM_XFORM2_W
/*
** Avoid some transformation computations by knowing that the incoming
** vertex has z=0 and w=1.  The w column of the matrix is [0 0 0 1].
*/
void FASTCALL __glXForm2_W(__GLcoord *res, const __GLfloat v[2], const __GLmatrix *m)
{
    __GLXFORM2_W_INIT(v)

    __GLXFORM2_W(res);
}
#endif /* !__GL_ASM_XFORM2_W */

#ifndef __GL_ASM_XFORM2_WBATCH
__GLXFORM_BATCH (__glXForm2_WBatch, __GLXFORM2_W_INIT, __GLXFORM2_W, __GLXFORM2_CONT);
#endif /* !__GL_ASM_XFORM2_WBATCH */

#ifndef __GL_ASM_XFORM3_W
/*
** Avoid some transformation computations by knowing that the incoming
** vertex has w=1.  The w column of the matrix is [0 0 0 1].
*/
void FASTCALL __glXForm3_W(__GLcoord *res, const __GLfloat v[3], const __GLmatrix *m)
{
    __GLXFORM3_W_INIT(v)

    __GLXFORM3_W(res);
}
#endif /* !__GL_ASM_XFORM3_W */

#ifndef __GL_ASM_XFORM3_WBATCH
__GLXFORM_BATCH (__glXForm3_WBatch, __GLXFORM3_W_INIT, __GLXFORM3_W, __GLXFORM3_CONT);
#endif /* !__GL_ASM_XFORM3_WBATCH */

#ifndef __GL_ASM_XFORM3x3
/*
** Avoid some transformation computations by knowing that the incoming
** vertex is a normal.  This is allowed according to the OpenGL spec.
*/
void FASTCALL __glXForm3x3(__GLcoord *res, const __GLfloat v[3], const __GLmatrix *m)
{
    __GLXFORM3x3_INIT(v);

    __GLXFORM3x3(res);
}
#endif /* !__GL_ASM_XFORM3x3 */

#ifndef __GL_ASM_XFORM3x3BATCH
__GLXFORM_BATCH (__glXForm3x3Batch, __GLXFORM3x3_INIT, __GLXFORM3x3, __GLXFORM3_CONT);
#endif /* !__GL_ASM_XFORM3x3BATCH */

#ifndef __GL_ASM_XFORM4_W
/*
** Full 4x4 transformation.  The w column of the matrix is [0 0 0 1].
*/
void FASTCALL __glXForm4_W(__GLcoord *res, const __GLfloat v[4], const __GLmatrix *m)
{
    __GLXFORM4_W_INIT(v)

    __GLXFORM4_W(res);
}
#endif /* !__GL_ASM_XFORM4_W */

#ifndef __GL_ASM_XFORM4_WBATCH
__GLXFORM_BATCH (__glXForm4_WBatch, __GLXFORM4_W_INIT, __GLXFORM4_W, __GLXFORM4_CONT);
#endif /* !__GL_ASM_XFORM4_WBATCH */

#ifndef __GL_ASM_XFORM1_2DW
/*
** Avoid some transformation computations by knowing that the incoming
** vertex has y=0, z=0 and w=1.
**
** The matrix looks like:
** | . . 0 0 |
** | . . 0 0 |
** | 0 0 . 0 |
** | . . . 1 |
*/
void FASTCALL __glXForm1_2DW(__GLcoord *res, const __GLfloat v[1], const __GLmatrix *m)
{
    __GLXFORM1_2DW_INIT(v)

    __GLXFORM1_2DW(res);
}
#endif /* !__GL_ASM_XFORM1_2DW */

#ifndef __GL_ASM_XFORM1_2DWBATCH
__GLXFORM_BATCH (__glXForm1_2DWBatch, __GLXFORM1_2DW_INIT, __GLXFORM1_2DW, __GLXFORM1_CONT);
#endif /* !__GL_ASM_XFORM1_2DWBATCH */

#ifndef __GL_ASM_XFORM2_2DW
/*
** Avoid some transformation computations by knowing that the incoming
** vertex has z=0 and w=1.
**
** The matrix looks like:
** | . . 0 0 |
** | . . 0 0 |
** | 0 0 . 0 |
** | . . . 1 |
*/
void FASTCALL __glXForm2_2DW(__GLcoord *res, const __GLfloat v[2],
		    const __GLmatrix *m)
{
    __GLXFORM2_2DW_INIT(v)

    __GLXFORM2_2DW(res);
}
#endif /* !__GL_ASM_XFORM2_2DW */

#ifndef __GL_ASM_XFORM2_2DWBATCH
__GLXFORM_BATCH (__glXForm2_2DWBatch, __GLXFORM2_2DW_INIT, __GLXFORM2_2DW, __GLXFORM2_CONT);
#endif /* !__GL_ASM_XFORM2_2DWBATCH */

#ifndef __GL_ASM_XFORM3_2DW
/*
** Avoid some transformation computations by knowing that the incoming
** vertex has w=1.
**
** The matrix looks like:
** | . . 0 0 |
** | . . 0 0 |
** | 0 0 . 0 |
** | . . . 1 |
*/
void FASTCALL __glXForm3_2DW(__GLcoord *res, const __GLfloat v[3],
		    const __GLmatrix *m)
{
    __GLXFORM3_2DW_INIT(v)

    __GLXFORM3_2DW(res);
}
#endif /* !__GL_ASM_XFORM3_2DW */

#ifndef __GL_ASM_XFORM3_2DWBATCH
__GLXFORM_BATCH (__glXForm3_2DWBatch, __GLXFORM3_2DW_INIT, __GLXFORM3_2DW, __GLXFORM3_CONT);
#endif /* !__GL_ASM_XFORM3_2DWBATCH */

#ifndef __GL_ASM_XFORM4_2DW
/*
** Full 4x4 transformation.
**
** The matrix looks like:
** | . . 0 0 |
** | . . 0 0 |
** | 0 0 . 0 |
** | . . . 1 |
*/
void FASTCALL __glXForm4_2DW(__GLcoord *res, const __GLfloat v[4],
		    const __GLmatrix *m)
{
    __GLXFORM4_2DW_INIT(v)

    __GLXFORM4_2DW(res);
}
#endif /* !__GL_ASM_XFORM4_2DW */

#ifndef __GL_ASM_XFORM4_2DWBATCH
__GLXFORM_BATCH (__glXForm4_2DWBatch, __GLXFORM4_2DW_INIT, __GLXFORM4_2DW, __GLXFORM4_CONT);
#endif /* !__GL_ASM_XFORM4_2DWBATCH */

#ifndef __GL_ASM_XFORM1_2DNRW
/*
** Avoid some transformation computations by knowing that the incoming
** vertex has y=0, z=0 and w=1.
**
** The matrix looks like:
** | . 0 0 0 |
** | 0 . 0 0 |
** | 0 0 . 0 |
** | . . . 1 |
*/
void FASTCALL __glXForm1_2DNRW(__GLcoord *res, const __GLfloat v[1], const __GLmatrix *m)
{
    __GLXFORM1_2DNRW_INIT(v)

    __GLXFORM1_2DNRW(res);
}
#endif /* !__GL_ASM_XFORM1_2DNRW */

#ifndef __GL_ASM_XFORM1_2DNRWBATCH
__GLXFORM_BATCH (__glXForm1_2DNRWBatch, __GLXFORM1_2DNRW_INIT, __GLXFORM1_2DNRW, __GLXFORM1_CONT);
#endif /* !__GL_ASM_XFORM1_2DNRWBATCH */

#ifndef __GL_ASM_XFORM2_2DNRW
/*
** Avoid some transformation computations by knowing that the incoming
** vertex has z=0 and w=1.
**
** The matrix looks like:
** | . 0 0 0 |
** | 0 . 0 0 |
** | 0 0 . 0 |
** | . . . 1 |
*/
void FASTCALL __glXForm2_2DNRW(__GLcoord *res, const __GLfloat v[2],
		      const __GLmatrix *m)
{
    __GLXFORM2_2DNRW_INIT(v)

    __GLXFORM2_2DNRW(res);
}
#endif /* !__GL_ASM_XFORM2_2DNRW */

#ifndef __GL_ASM_XFORM2_2DNRWBATCH
__GLXFORM_BATCH (__glXForm2_2DNRWBatch, __GLXFORM2_2DNRW_INIT, __GLXFORM2_2DNRW, __GLXFORM2_CONT);
#endif /* !__GL_ASM_XFORM2_2DNRWBATCH */

#ifndef __GL_ASM_XFORM3_2DNRW
/*
** Avoid some transformation computations by knowing that the incoming
** vertex has w=1.
**
** The matrix looks like:
** | . 0 0 0 |
** | 0 . 0 0 |
** | 0 0 . 0 |
** | . . . 1 |
*/
void FASTCALL __glXForm3_2DNRW(__GLcoord *res, const __GLfloat v[3],
		      const __GLmatrix *m)
{
    __GLXFORM3_2DNRW_INIT(v)

    __GLXFORM3_2DNRW(res);
}
#endif /* !__GL_ASM_XFORM3_2DNRW */

#ifndef __GL_ASM_XFORM3_2DNRWBATCH
__GLXFORM_BATCH (__glXForm3_2DNRWBatch, __GLXFORM3_2DNRW_INIT, __GLXFORM3_2DNRW, __GLXFORM3_CONT);
#endif /* !__GL_ASM_XFORM3_2DNRWBATCH */

#ifndef __GL_ASM_XFORM4_2DNRW
/*
** Full 4x4 transformation.
**
** The matrix looks like:
** | . 0 0 0 |
** | 0 . 0 0 |
** | 0 0 . 0 |
** | . . . 1 |
*/
void FASTCALL __glXForm4_2DNRW(__GLcoord *res, const __GLfloat v[4],
		      const __GLmatrix *m)
{
    __GLXFORM4_2DNRW_INIT(v)

    __GLXFORM4_2DNRW(res);
}
#endif /* !__GL_ASM_XFORM4_2DNRW */

#ifndef __GL_ASM_XFORM4_2DNRWBATCH
__GLXFORM_BATCH (__glXForm4_2DNRWBatch, __GLXFORM4_2DNRW_INIT, __GLXFORM4_2DNRW, __GLXFORM4_CONT);
#endif /* !__GL_ASM_XFORM4_2DNRWBATCH */

#ifndef __GL_ASM_NORMAL_BATCH

__GLXFORM_NORMAL_BATCH (__glXForm3_2DNRWBatchNormal,  __GLXFORM3x3_INIT, __GLXFORM3x3, __GLXFORM3_CONT);
__GLXFORM_NORMAL_BATCHN(__glXForm3_2DNRWBatchNormalN, __GLXFORM3x3_INIT, __GLXFORM3x3, __GLXFORM3_CONT);

__GLXFORM_NORMAL_BATCH (__glXForm3_2DWBatchNormal,  __GLXFORM3x3_INIT, __GLXFORM3x3, __GLXFORM3_CONT);
__GLXFORM_NORMAL_BATCHN(__glXForm3_2DWBatchNormalN, __GLXFORM3x3_INIT, __GLXFORM3x3, __GLXFORM3_CONT);

__GLXFORM_NORMAL_BATCH (__glXForm3x3BatchNormal,  __GLXFORM3x3_INIT, __GLXFORM3x3, __GLXFORM3_CONT);
__GLXFORM_NORMAL_BATCHN(__glXForm3x3BatchNormalN, __GLXFORM3x3_INIT, __GLXFORM3x3, __GLXFORM3_CONT);

#endif //  __GL_ASM_NORMAL_BATCH

/************************************************************************/
/*
** A special picker for the mvp matrix which picks the mvp matrix, then
** calls the vertex picker, because the vertex picker depends upon the mvp 
** matrix.
*/
void FASTCALL __glGenericPickMvpMatrixProcs(__GLcontext *gc, __GLmatrix *m)
{
    __glGenericPickMatrixProcs(gc, m);
    (*gc->procs.pickVertexProcs)(gc);
}

void FASTCALL __glGenericPickMatrixProcs(__GLcontext *gc, __GLmatrix *m)
{
    switch(m->matrixType) 
    {
    case __GL_MT_GENERAL:
        m->xf1 = __glXForm1;
        m->xf2 = __glXForm2;
        m->xf3 = __glXForm3;
        m->xf4 = __glXForm4;
        m->xfNorm = __glXForm3x3;
        m->xf1Batch = __glXForm1Batch;
        m->xf2Batch = __glXForm2Batch;
        m->xf3Batch = __glXForm3Batch;
        m->xf4Batch = __glXForm4Batch;
        m->xfNormBatch = __glXForm3x3BatchNormal;
        m->xfNormBatchN = __glXForm3x3BatchNormalN;
        break;
    case __GL_MT_W0001:
        m->xf1 = __glXForm1_W;
        m->xf2 = __glXForm2_W;
        m->xf3 = __glXForm3_W;
        m->xf4 = __glXForm4_W;
        m->xfNorm = __glXForm3x3;
        m->xf1Batch = __glXForm1_WBatch;
        m->xf2Batch = __glXForm2_WBatch;
        m->xf3Batch = __glXForm3_WBatch;
        m->xf4Batch = __glXForm4_WBatch;
        m->xfNormBatch = __glXForm3x3BatchNormal;
        m->xfNormBatchN = __glXForm3x3BatchNormalN;
        break;
    case __GL_MT_IS2D:
        m->xf1 = __glXForm1_2DW;
        m->xf2 = __glXForm2_2DW;
        m->xf3 = __glXForm3_2DW;
        m->xf4 = __glXForm4_2DW;
        m->xfNorm = __glXForm3_2DW;
        m->xf1Batch = __glXForm1_2DWBatch;
        m->xf2Batch = __glXForm2_2DWBatch;
        m->xf3Batch = __glXForm3_2DWBatch;
        m->xf4Batch = __glXForm4_2DWBatch;
        m->xfNormBatch = __glXForm3_2DWBatchNormal;
        m->xfNormBatchN = __glXForm3_2DWBatchNormalN;
        break;
    case __GL_MT_IS2DNR:
    case __GL_MT_IDENTITY:	/* probably never hit */
        // Update __glGenericPickIdentityMatrixProcs if we change __GL_MT_IDENTITY
        // procs!
        m->xf1 = __glXForm1_2DNRW;
        m->xf2 = __glXForm2_2DNRW;
        m->xf3 = __glXForm3_2DNRW;
        m->xf4 = __glXForm4_2DNRW;
        m->xfNorm = __glXForm3_2DNRW;
        m->xf1Batch = __glXForm1_2DNRWBatch;
        m->xf2Batch = __glXForm2_2DNRWBatch;
        m->xf3Batch = __glXForm3_2DNRWBatch;
        m->xf4Batch = __glXForm4_2DNRWBatch;
        m->xfNormBatch = __glXForm3_2DNRWBatchNormal;
        m->xfNormBatchN = __glXForm3_2DNRWBatchNormalN;
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\soft\so_zfunc.c ===
/*
** Copyright 1994, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "precomp.h"
#pragma hdrstop

#ifndef __GL_USEASMCODE

/*
** this is a series of depth testers written in C
*/

/***********************  non-masked writes ***********************/

/*
** NEVER, no mask
*/
GLboolean FASTCALL
__glDT_NEVER( __GLzValue z, __GLzValue *zfb )
{
    return GL_FALSE;
}

/*
** LEQUAL, no mask
*/
GLboolean FASTCALL
__glDT_LEQUAL( __GLzValue z, __GLzValue *zfb )
{
    if( z <= *zfb ) {
        zfb[0] = z;
        return GL_TRUE;
    } else {
        return GL_FALSE;
    }
}

/*
** LESS, no mask
*/
GLboolean FASTCALL
__glDT_LESS( __GLzValue z, __GLzValue *zfb )
{
    if( z < *zfb ) {
        zfb[0] = z;
        return GL_TRUE;
    } else {
        return GL_FALSE;
    }
}

/*
** EQUAL, no mask
*/
GLboolean FASTCALL
__glDT_EQUAL( __GLzValue z, __GLzValue *zfb )
{
    if( z == *zfb ) {
        zfb[0] = z;     /* why is this there?  Who uses GL_EQUAL anyway? */
        return GL_TRUE;
    } else {
        return GL_FALSE;
    }
}

/*
** GREATER, no mask
*/
GLboolean FASTCALL
__glDT_GREATER( __GLzValue z, __GLzValue *zfb )
{
    if( z > *zfb ) {
        zfb[0] = z;
        return GL_TRUE;
    } else {
        return GL_FALSE;
    }
}

/*
** NOTEQUAL, no mask
*/
GLboolean FASTCALL
__glDT_NOTEQUAL( __GLzValue z, __GLzValue *zfb )
{
    if( z != *zfb ) {
        zfb[0] = z;
        return GL_TRUE;
    } else {
        return GL_FALSE;
    }
}

/*
** GEQUAL, no mask
*/
GLboolean FASTCALL
__glDT_GEQUAL( __GLzValue z, __GLzValue *zfb )
{
    if( z >= *zfb ) {
        zfb[0] = z;
        return GL_TRUE;
    } else {
        return GL_FALSE;
    }
}

/*
** ALWAYS, no mask
*/
GLboolean FASTCALL
__glDT_ALWAYS( __GLzValue z, __GLzValue *zfb )
{
    zfb[0] = z;
    return GL_TRUE;
}



/***********************  masked writes ***********************/

/*
** LEQUAL, mask
*/
GLboolean FASTCALL
__glDT_LEQUAL_M( __GLzValue z, __GLzValue *zfb )
{
    return (z <= *zfb);
}

/*
** LESS, mask
*/
GLboolean FASTCALL
__glDT_LESS_M( __GLzValue z, __GLzValue *zfb )
{
    return (z < *zfb);
}

/*
** EQUAL, mask
*/
GLboolean FASTCALL
__glDT_EQUAL_M( __GLzValue z, __GLzValue *zfb )
{
    return (z == *zfb);
}

/*
** GREATER, mask
*/
GLboolean FASTCALL
__glDT_GREATER_M( __GLzValue z, __GLzValue *zfb )
{
    return (z > *zfb);
}

/*
** NOTEQUAL, mask
*/
GLboolean FASTCALL
__glDT_NOTEQUAL_M( __GLzValue z, __GLzValue *zfb )
{
    return (z != *zfb);
}

/*
** GEQUAL, mask
*/
GLboolean FASTCALL
__glDT_GEQUAL_M( __GLzValue z, __GLzValue *zfb )
{
    return (z >= *zfb);
}

/*
** ALWAYS, mask
*/
GLboolean FASTCALL
__glDT_ALWAYS_M( __GLzValue z, __GLzValue *zfb )
{
    return GL_TRUE;
}


/***********************  16-bit z versions ***********************/

/*
** LEQUAL, no mask
*/
GLboolean FASTCALL
__glDT16_LEQUAL( __GLzValue z, __GLzValue *zfb )
{
#if 0
    if( (GLuint)z <= (GLuint)zbv ) {
        zfb[0] = z;
        return GL_TRUE;
    } else {
        return GL_FALSE;
    }
#else
    __GLz16Value z16 = z >> Z16_SHIFT;

    if( z16 <= *((__GLz16Value *)zfb) ) {
        *((__GLz16Value *)zfb) = z16;
        return GL_TRUE;
    } else {
        return GL_FALSE;
    }
#endif
}

/*
** LESS, no mask
*/
GLboolean FASTCALL
__glDT16_LESS( __GLzValue z, __GLzValue *zfb )
{
    __GLz16Value z16 = z >> Z16_SHIFT;

    if( z16 < *((__GLz16Value *)zfb) ) {
        *((__GLz16Value *)zfb) = z16;
        return GL_TRUE;
    } else {
        return GL_FALSE;
    }
}

/*
** EQUAL, no mask
*/
GLboolean FASTCALL
__glDT16_EQUAL( __GLzValue z, __GLzValue *zfb )
{
    __GLz16Value z16 = z >> Z16_SHIFT;

    if( z16 == *((__GLz16Value *)zfb) ) {
        *((__GLz16Value *)zfb) = z16;
        return GL_TRUE;
    } else {
        return GL_FALSE;
    }
}

/*
** GREATER, no mask
*/
GLboolean FASTCALL
__glDT16_GREATER( __GLzValue z, __GLzValue *zfb )
{
    __GLz16Value z16 = z >> Z16_SHIFT;

    if( z16 > *((__GLz16Value *)zfb) ) {
        *((__GLz16Value *)zfb) = z16;
        return GL_TRUE;
    } else {
        return GL_FALSE;
    }
}

/*
** NOTEQUAL, no mask
*/
GLboolean FASTCALL
__glDT16_NOTEQUAL( __GLzValue z, __GLzValue *zfb )
{
    __GLz16Value z16 = z >> Z16_SHIFT;

    if( z16 != *((__GLz16Value *)zfb) ) {
        *((__GLz16Value *)zfb) = z16;
        return GL_TRUE;
    } else {
        return GL_FALSE;
    }
}

/*
** GEQUAL, no mask
*/
GLboolean FASTCALL
__glDT16_GEQUAL( __GLzValue z, __GLzValue *zfb )
{
    __GLz16Value z16 = z >> Z16_SHIFT;

    if( z16 >= *((__GLz16Value *)zfb) ) {
        *((__GLz16Value *)zfb) = z16;
        return GL_TRUE;
    } else {
        return GL_FALSE;
    }
}

/*
** ALWAYS, no mask
*/
GLboolean FASTCALL
__glDT16_ALWAYS( __GLzValue z, __GLzValue *zfb )
{
    *((__GLz16Value *)zfb) = z >> Z16_SHIFT;
    return GL_TRUE;
}



/***********************  masked writes ***********************/

/*
** LEQUAL, mask
*/
GLboolean FASTCALL
__glDT16_LEQUAL_M( __GLzValue z, __GLzValue *zfb )
{
    return( (z >> Z16_SHIFT) <= *((__GLz16Value *)zfb) );
}

/*
** LESS, mask
*/
GLboolean FASTCALL
__glDT16_LESS_M( __GLzValue z, __GLzValue *zfb )
{
    return( (z >> Z16_SHIFT) < *((__GLz16Value *)zfb) );
}

/*
** EQUAL, mask
*/
GLboolean FASTCALL
__glDT16_EQUAL_M( __GLzValue z, __GLzValue *zfb )
{
    return( (z >> Z16_SHIFT) == *((__GLz16Value *)zfb) );
}

/*
** GREATER, mask
*/
GLboolean FASTCALL
__glDT16_GREATER_M( __GLzValue z, __GLzValue *zfb )
{
    return( (z >> Z16_SHIFT) > *((__GLz16Value *)zfb) );
}

/*
** NOTEQUAL, mask
*/
GLboolean FASTCALL
__glDT16_NOTEQUAL_M( __GLzValue z, __GLzValue *zfb )
{
    return( (z >> Z16_SHIFT) != *((__GLz16Value *)zfb) );
}

/*
** GEQUAL, mask
*/
GLboolean FASTCALL
__glDT16_GEQUAL_M( __GLzValue z, __GLzValue *zfb )
{
    return( (z >> Z16_SHIFT) >= *((__GLz16Value *)zfb) );
}

/*
** ALWAYS, mask
*/
GLboolean FASTCALL
__glDT16_ALWAYS_M( __GLzValue z, __GLzValue *zfb )
{
    return GL_TRUE;
}


#endif /* !__GL_USEASMCODE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\soft\so_txobj.c ===
/*
** Copyright 1991,1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/
#include "precomp.h"
#pragma hdrstop

#include <namesint.h>
#include <glmath.h>
#include <devlock.h>

/************************************************************************/
/*
** Texture Object routines.
*/
/************************************************************************/


#define __GL_CHECK_VALID_N_PARAM(failStatement)                         \
    if (n < 0) {                                                        \
        __glSetError(GL_INVALID_VALUE);                                 \
    }                                                                   \
    if (n == 0) {                                                       \
        failStatement;                                                  \
    }                                                                   \


GLvoid APIPRIVATE __glim_GenTextures(GLsizei n, GLuint* textures)
{
    __GL_SETUP_NOT_IN_BEGIN();
    __GL_CHECK_VALID_N_PARAM(return);

    if (NULL == textures) return;

    ASSERTOPENGL(NULL != gc->texture.shared->namesArray,
                 "No texture names array\n");

    __glNamesGenNames(gc, gc->texture.shared->namesArray, n, textures);

}

GLvoid APIPRIVATE __glim_DeleteTextures(GLsizei n, const GLuint* textures)
{
    GLuint start, rangeVal, numTextures, targetIndex, i;
    __GLnamesArray *array;
    __GLtextureObject *texobj, **pBoundTexture;

    __GL_SETUP_NOT_IN_BEGIN();
    __GL_CHECK_VALID_N_PARAM(return);

    array = gc->texture.shared->namesArray;
    numTextures = gc->constants.numberOfTextures;

    /*
    ** Send the texture names in ranges to the names module to be
    ** deleted.  Ignore any references to default textures.
    ** If a texture that is being deleted is currently bound,
    ** bind the default texture to its target.
    ** The names routine ignores any names that don't refer to
    ** textures.
    */
    start = rangeVal = textures[0];
    for (i=0; i < (GLuint)n; i++, rangeVal++) {
        if (0 == textures[i]) {         /* skip default textures */
            /* delete up to this one */
            __glNamesDeleteRange(gc,array,start,rangeVal-start);
            /* skip over this one by setting start to the next one */
            start = textures[i+1];
            rangeVal = start-1;         /* because it gets incremented later */
            continue;
        }
        /*
        ** If the texture is currently bound, bind the defaultTexture
        ** to its target.  The problem here is identifying the target.
        ** One way is to look up the texobj with the name.  Another is
        ** to look through all of the currently bound textures and
        ** check each for the name.  It has been implemented with the
        ** assumption that looking through the currently bound textures
        ** is faster than retrieving the texobj that corresponds to
        ** the name.
        */
        for (targetIndex=0, pBoundTexture = gc->texture.boundTextures;
                targetIndex < numTextures; targetIndex++, pBoundTexture++) {

            /* Is the texture currently bound? */
            if (*pBoundTexture != &gc->texture.ddtex.texobj &&
                (*pBoundTexture)->texture.map.texobjs.name == textures[i]) {
                __GLperTextureState *pts;
                pts = &gc->state.texture.texture[targetIndex];
                /* if we don't unlock it, it won't get deleted */
                __glNamesUnlockData(gc, *pBoundTexture, __glCleanupTexObj);

                /* bind the default texture to this target */
                texobj = gc->texture.defaultTextures + targetIndex;
                ASSERTOPENGL(texobj->texture.map.texobjs.name == 0,
                             "Non-default texture\n");
                gc->texture.texture[targetIndex] = &(texobj->texture);
                *pBoundTexture = texobj;
                pts->texobjs = texobj->texture.map.texobjs;
                pts->params = texobj->texture.map.params;

                /* Need to reset the current texture and such. */
                __GL_DELAY_VALIDATE(gc);
                break;
            }
        }
        if (textures[i] != rangeVal) {
            /* delete up to this one */
            __glNamesDeleteRange(gc,array,start,rangeVal-start);
            start = rangeVal = textures[i];
        }
    }
    __glNamesDeleteRange(gc,array,start,rangeVal-start);
}


// These macros used for comparing properties of 2 textures

#define _DIFFERENT_TEX_PARAMS( tex1, tex2 ) \
      ( ! RtlEqualMemory( &(tex1)->params, &(tex2)->params, sizeof(__GLtextureParamState)) )

#define _DIFFERENT_TEXDATA_FORMATS( tex1, tex2 ) \
    ( (tex1)->level[0].internalFormat != (tex2)->level[0].internalFormat )

/*
** This routine is used by the pick routines to actually perform
** the bind.
*/
void FASTCALL __glBindTexture(__GLcontext *gc, GLuint targetIndex,
                              GLuint texture, GLboolean callGen)
{
    __GLtextureObject *texobj;

    ASSERTOPENGL(NULL != gc->texture.shared->namesArray,
                 "No texture names array\n");

    // Check if this texture is the currently bound one
    if( (targetIndex != __GL_TEX_TARGET_INDEX_DDRAW &&
         gc->texture.boundTextures[targetIndex] != &gc->texture.ddtex.texobj &&
         texture == gc->texture.boundTextures[targetIndex]->
         texture.map.texobjs.name) ||
        (targetIndex == __GL_TEX_TARGET_INDEX_DDRAW &&
         gc->texture.boundTextures[__GL_TEX_TARGET_INDEX_2D] ==
         &gc->texture.ddtex.texobj))
    {
        return;
    }

    /*
    ** Retrieve the texture object from the namesArray structure.
    */
    if (targetIndex == __GL_TEX_TARGET_INDEX_DDRAW)
    {
        targetIndex = __GL_TEX_TARGET_INDEX_2D;
        texobj = &gc->texture.ddtex.texobj;
    }
    else if (texture == 0)
    {
        texobj = gc->texture.defaultTextures + targetIndex;
        ASSERTOPENGL(NULL != texobj, "No default texture\n");
        ASSERTOPENGL(texobj->texture.map.texobjs.name == 0,
                     "Non-default texture\n");
    }
    else
    {
        texobj = (__GLtextureObject *)
                __glNamesLockData(gc, gc->texture.shared->namesArray, texture);
    }


    /*
    ** Is this the first time this name has been bound?
    ** If so, create a new texture object and initialize it.
    */
    if (NULL == texobj) {
        texobj = (__GLtextureObject *)GCALLOCZ(gc, sizeof(*texobj));
        if (texobj == NULL)
        {
            return;
        }
        if (!__glInitTextureObject(gc, texobj, texture, targetIndex))
        {
            GCFREE(gc, texobj);
            return;
        }
        __glInitTextureMachine(gc, targetIndex, &(texobj->texture), GL_TRUE);
        __glNamesNewData(gc, gc->texture.shared->namesArray, texture, texobj);
        /*
        ** Shortcut way to lock without doing another lookup.
        */
        __glNamesLockArray(gc, gc->texture.shared->namesArray);
        texobj->refcount++;
        __glNamesUnlockArray(gc, gc->texture.shared->namesArray);
        __glTexPriListAdd(gc, texobj, GL_TRUE);
    }
    else {
        /*
        ** Retrieved an existing texture object.  Do some
        ** sanity checks.
        */
        if (texobj->targetIndex != targetIndex) {
            __glSetError(GL_INVALID_OPERATION);
            return;
        }
        ASSERTOPENGL(texture == texobj->texture.map.texobjs.name,
                     "Texture name mismatch\n");
    }

    {
        __GLperTextureState *pts;
        __GLtexture *ptm;
        __GLtextureObject *boundTexture;

        pts = &(gc->state.texture.texture[targetIndex]);
        ptm = &(gc->texture.texture[targetIndex]->map);
        boundTexture = gc->texture.boundTextures[targetIndex];

        /* Copy the current stackable state into the bound texture. */
        ptm->params = pts->params;
        ptm->texobjs = pts->texobjs;

        // If the DDraw texture is currently bound, release its
        // resources
        if (boundTexture == &gc->texture.ddtex.texobj)
        {
            glsrvUnbindDirectDrawTexture(gc);
        }
        else if (boundTexture->texture.map.texobjs.name != 0)
        {
            /* Unlock the texture that is being unbound.  */
            __glNamesUnlockData(gc, boundTexture, __glCleanupTexObj);
        }

        /*
        ** Install the new texture into the correct target and save
        ** its pointer so it can be unlocked easily when it is unbound.
        */
        gc->texture.texture[targetIndex] = &(texobj->texture);
        gc->texture.boundTextures[targetIndex] = texobj;

        /* Copy the new texture's stackable state into the context state. */
        pts->params = texobj->texture.map.params;
        pts->texobjs = texobj->texture.map.texobjs;

        if (callGen)
        {
            __glGenMakeTextureCurrent(gc, &texobj->texture.map,
                                      texobj->loadKey);
        }

        __GL_DELAY_VALIDATE_MASK( gc, __GL_DIRTY_TEXTURE );

        // We can avoid dirtying generic if the new texture has same
        // properties as the old one...

        if( !( gc->dirtyMask & __GL_DIRTY_GENERIC ) )
        {
            // GL_DIRTY_GENERIC has not yet been set
            __GLtexture *newTex = &texobj->texture.map;
            __GLtexture *oldTex = &boundTexture->texture.map;

            if( (_DIFFERENT_TEX_PARAMS( newTex, oldTex )) ||
                (_DIFFERENT_TEXDATA_FORMATS( newTex, oldTex )) ||
                (texobj->targetIndex != boundTexture->targetIndex) )
            {
                __GL_DELAY_VALIDATE( gc ); // dirty generic
            }
        }
    }
}

GLvoid APIPRIVATE __glim_BindTexture(GLenum target, GLuint texture)
{
    GLuint targetIndex;
    /*
    ** Need to validate in case a new texture was popped into
    ** the state immediately prior to this call.
    */
    __GL_SETUP_NOT_IN_BEGIN_VALIDATE();

    switch (target) {
    case GL_TEXTURE_1D:
        targetIndex = 2;
        break;
    case GL_TEXTURE_2D:
        targetIndex = 3;
        break;
    default:
        __glSetError(GL_INVALID_ENUM);
        return;
    }

    __glBindTexture(gc, targetIndex, texture, GL_TRUE);
}

#ifdef GL_WIN_multiple_textures
void APIPRIVATE __glim_BindNthTextureWIN(GLuint index, GLenum target, GLuint texture)
{
}
#endif // GL_WIN_multiple_textures

GLvoid APIPRIVATE __glim_PrioritizeTextures(GLsizei n,
                           const GLuint* textures,
                           const GLclampf* priorities)
{
    int i;
    __GLtextureObject *texobj;
    GLuint targetIndex;
    __GLtextureObject **pBoundTexture;
    GLclampf priority;

    __GL_SETUP_NOT_IN_BEGIN();
    __GL_CHECK_VALID_N_PARAM(return);

    for (i=0; i < n; i++) {
        /* silently ignore default texture */
        if (0 == textures[i]) continue;

        texobj = (__GLtextureObject *)
            __glNamesLockData(gc, gc->texture.shared->namesArray, textures[i]);

        /* silently ignore non-texture */
        if (NULL == texobj) continue;

        priority = __glClampf(priorities[i], __glZero, __glOne);
        texobj->texture.map.texobjs.priority = priority;

        // If this texture is currently bound, also update the
        // copy of the priority in the gc's state
        // Keeping copies is not a good design.  This
        // should be improved
        for (targetIndex = 0, pBoundTexture = gc->texture.boundTextures;
             targetIndex < (GLuint)gc->constants.numberOfTextures;
             targetIndex++, pBoundTexture++)
        {
            /* Is the texture currently bound? */
            if (*pBoundTexture != &gc->texture.ddtex.texobj &&
                (*pBoundTexture)->texture.map.texobjs.name == textures[i])
            {
                gc->state.texture.texture[targetIndex].texobjs.priority =
                    priority;
                break;
            }
        }

        __glTexPriListChangePriority(gc, texobj, GL_FALSE);
        __glNamesUnlockData(gc, texobj, __glCleanupTexObj);
    }
    __glNamesLockArray(gc, gc->texture.shared->namesArray);
    __glTexPriListRealize(gc);
    __glNamesUnlockArray(gc, gc->texture.shared->namesArray);
}

GLboolean APIPRIVATE __glim_AreTexturesResident(GLsizei n,
                               const GLuint* textures,
                               GLboolean* residences)
{
    int i;
    __GLtextureObject *texobj;
    GLboolean allResident = GL_TRUE;
    GLboolean currentResident;

    __GL_SETUP_NOT_IN_BEGIN2();
    __GL_CHECK_VALID_N_PARAM(return GL_FALSE);

    for (i=0; i < n; i++) {
        /* Can't query a default texture. */
        if (0 == textures[i]) {
            __glSetError(GL_INVALID_VALUE);
            return GL_FALSE;
        }
        texobj = (__GLtextureObject *)
            __glNamesLockData(gc, gc->texture.shared->namesArray, textures[i]);
        /*
        ** Ensure that all of the names have corresponding textures.
        */
        if (NULL == texobj) {
            __glSetError(GL_INVALID_VALUE);
            return GL_FALSE;
        }

        if (((__GLGENcontext *)gc)->pMcdState && texobj->loadKey) {
            currentResident = ((GenMcdTextureStatus((__GLGENcontext *)gc, texobj->loadKey) & MCDRV_TEXTURE_RESIDENT) != 0);
        } else
            currentResident = texobj->resident;

        if (!currentResident) {
            allResident = GL_FALSE;
        }
        residences[i] = currentResident;
        __glNamesUnlockData(gc, texobj, __glCleanupTexObj);
    }

    return allResident;
}

GLboolean APIPRIVATE __glim_IsTexture(GLuint texture)
{
    __GLtextureObject *texobj;
    __GL_SETUP_NOT_IN_BEGIN2();

    if (0 == texture) return GL_FALSE;

    texobj = (__GLtextureObject *)
        __glNamesLockData(gc, gc->texture.shared->namesArray, texture);
    if (texobj != NULL)
    {
        __glNamesUnlockData(gc, texobj, __glCleanupTexObj);
        return GL_TRUE;
    }
    return GL_FALSE;
}

#ifdef NT
GLboolean FASTCALL __glCanShareTextures(__GLcontext *gc, __GLcontext *shareMe)
{
    GLboolean canShare = GL_TRUE;

    if (gc->texture.shared != NULL)
    {
        __glNamesLockArray(gc, gc->texture.shared->namesArray);

        // Make sure we're not trying to replace a shared object
        // The spec also says that it is illegal for the new context
        // to have any textures
        canShare = gc->texture.shared->namesArray->refcount == 1 &&
            gc->texture.shared->namesArray->tree == NULL;

        __glNamesUnlockArray(gc, gc->texture.shared->namesArray);
    }

    return canShare;
}

void FASTCALL __glShareTextures(__GLcontext *gc, __GLcontext *shareMe)
{
    GLint i, numTextures;

    if (gc->texture.shared != NULL)
    {
        // We know that the names array doesn't have any contents
        // so no texture names can be selected as the current texture
        // or anything else.  Therefore it is safe to simply free
        // our array
        __glFreeSharedTextureState(gc);
    }

    __glNamesLockArray(gc, shareMe->texture.shared->namesArray);

    gc->texture.shared = shareMe->texture.shared;
    gc->texture.shared->namesArray->refcount++;

    // Add the new sharer's default textures to the priority list
    numTextures = gc->constants.numberOfTextures;
    for (i = 0; i < numTextures; i++)
    {
        __glTexPriListAddToList(gc, gc->texture.defaultTextures+i);
    }
    // No realization of priority list because these contexts aren't
    // current

    DBGLEVEL3(LEVEL_INFO, "Sharing textures %p with %p, count %d\n",
              gc, shareMe, gc->texture.shared->namesArray->refcount);

    __glNamesUnlockArray(gc, shareMe->texture.shared->namesArray);
}
#endif

/******************************Public*Routine******************************\
*
* glsrvBindDirectDrawTexture
*
* Make the DirectDraw texture data in gc->texture the current 2D texture
*
* History:
*  Wed Sep 04 11:35:59 1996     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL APIENTRY glsrvBindDirectDrawTexture(__GLcontext *gc,
                                         int levels,
                                         LPDIRECTDRAWSURFACE *apdds,
                                         DDSURFACEDESC *pddsd,
                                         ULONG flags)
{
    __GLmipMapLevel *lev;
    __GLtexture *tex;
    GLint levIndex;
    GLint width, height;
    GLint wlog2, hlog2;
    __GLddrawTexture *pddtex;

    ASSERTOPENGL(levels <= gc->constants.maxMipMapLevel,
                 "Too many levels in DDraw texture\n");

    // Bind the fake DDraw texture.
    __glBindTexture(gc, __GL_TEX_TARGET_INDEX_DDRAW, __GL_TEX_DDRAW, GL_FALSE);

    pddtex = &gc->texture.ddtex;
    tex = &pddtex->texobj.texture.map;

    pddtex->levels = levels;
    memcpy(gc->texture.ddtex.pdds, apdds, levels*sizeof(LPDIRECTDRAWSURFACE));
    pddtex->gdds.pdds = apdds[0];
    pddtex->gdds.ddsd = *pddsd;
    pddtex->gdds.dwBitDepth =
        DdPixDepthToCount(pddsd->ddpfPixelFormat.dwRGBBitCount);
    pddtex->flags = flags;

    // Fill out the DirectDraw texture data

    width = (GLint)pddtex->gdds.ddsd.dwWidth;
    wlog2 = __glIntLog2(width);
    height = (GLint)pddtex->gdds.ddsd.dwHeight;
    hlog2 = __glIntLog2(height);

    if (wlog2 > hlog2)
    {
        tex->p = wlog2;
    }
    else
    {
        tex->p = hlog2;
    }

    lev = tex->level;
    for (levIndex = 0; levIndex < gc->texture.ddtex.levels; levIndex++)
    {
        // Buffer pointer is filled in at attention time.
        // If we're going to pass this texture to the MCD then we
        // fill in the surface handles at this time so they're
        // given to the driver at create time.
        if (flags & DDTEX_VIDEO_MEMORY)
        {
            lev->buffer = (__GLtextureBuffer *)
                ((LPDDRAWI_DDRAWSURFACE_INT)apdds[levIndex])->
                lpLcl->hDDSurface;
        }
        else
        {
            lev->buffer = NULL;
        }

        lev->width = width;
        lev->height = height;
        lev->width2 = width;
        lev->height2 = height;
        lev->width2f = (__GLfloat)width;
        lev->height2f = (__GLfloat)height;
        lev->widthLog2 = wlog2;
        lev->heightLog2 = hlog2;
        lev->border = 0;

        lev->luminanceSize = 0;
        lev->intensitySize = 0;

        if (pddtex->gdds.ddsd.ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED8)
        {
            lev->requestedFormat = tex->paletteRequestedFormat;
            lev->baseFormat = tex->paletteBaseFormat;
            lev->internalFormat = GL_COLOR_INDEX8_EXT;

            __glSetPaletteLevelExtract8(tex, lev, 0);

            lev->redSize = 0;
            lev->greenSize = 0;
            lev->blueSize = 0;
            lev->alphaSize = 0;
        }
        else
        {
            if (pddtex->gdds.ddsd.ddsCaps.dwCaps & DDSCAPS_ALPHA)
            {
                lev->requestedFormat = GL_RGBA;
                lev->baseFormat = GL_RGBA;
            }
            else
            {
                lev->requestedFormat = GL_RGB;
                lev->baseFormat = GL_RGB;
            }
            lev->internalFormat = GL_BGRA_EXT;

            lev->extract = __glExtractTexelBGRA8;

            lev->redSize = 8;
            lev->greenSize = 8;
            lev->blueSize = 8;
            lev->alphaSize = 8;
        }

        if (width != 1)
        {
            width >>= 1;
            wlog2--;
        }
        if (height != 1)
        {
            height >>= 1;
            hlog2--;
        }

        lev++;
    }

    // If the texture is in VRAM then attempt to create an MCD handle for it.
    // This must be done before palette operations so that
    // the loadKey is set.
    if (flags & DDTEX_VIDEO_MEMORY)
    {
        pddtex->texobj.loadKey =
            __glGenLoadTexture(gc, tex, MCDTEXTURE_DIRECTDRAW_SURFACES);

        // Remove handles that were set earlier.
        lev = tex->level;
        for (levIndex = 0; levIndex < gc->texture.ddtex.levels; levIndex++)
        {
            lev->buffer = NULL;
            lev++;
        }
    }
    else
    {
        pddtex->texobj.loadKey = 0;
    }

    // Pick up palette for paletted surface
    if (pddtex->gdds.ddsd.ddpfPixelFormat.dwFlags & DDPF_PALETTEINDEXED8)
    {
        LPDIRECTDRAWPALETTE pddp;
        HRESULT hr;

        hr = pddtex->gdds.pdds->lpVtbl->
            GetPalette(pddtex->gdds.pdds, &pddp);
        if (hr == DD_OK && pddp != NULL)
        {
            PALETTEENTRY pe[256];

            if (pddp->lpVtbl->GetEntries(pddp, 0, 0, 256, pe) == DD_OK)
            {
                __glim_ColorTableEXT(GL_TEXTURE_2D, GL_RGB,
                                     256, GL_RGBA, GL_UNSIGNED_BYTE,
                                     pe, GL_FALSE);
            }

            pddp->lpVtbl->Release(pddp);
        }
    }

    // If we have a loadKey, make the texture current
    if (pddtex->texobj.loadKey != 0)
    {
        __glGenMakeTextureCurrent(gc, tex, pddtex->texobj.loadKey);
    }

    __GL_DELAY_VALIDATE(gc);

    return TRUE;
}

/******************************Public*Routine******************************\
*
* glsrvUnbindDirectDrawTexture
*
* Cleans up DirectDraw texture data
*
* History:
*  Wed Sep 04 13:45:08 1996     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void APIENTRY glsrvUnbindDirectDrawTexture(__GLcontext *gc)
{
    GLint i;
    __GLddrawTexture *pddtex;
    __GLGENcontext *gengc = (__GLGENcontext *)gc;

    pddtex = &gc->texture.ddtex;

    // Make sure a texture is bound
    if (pddtex->levels <= 0)
    {
        return;
    }

    // Delete any MCD information
    if (pddtex->texobj.loadKey != 0)
    {
        __glGenFreeTexture(gc, &pddtex->texobj.texture.map,
                           pddtex->texobj.loadKey);
        pddtex->texobj.loadKey = 0;
    }

    for (i = 0; i < pddtex->levels; i++)
    {
        // If we're currently in an attention then we locked the texture
        // surfaces and need to unlock them before we release them.
        //
        // Since there's no way to bind new DD textures in a batch, we
        // are guaranteed to have had the texture active at the beginning
        // of the batch and therefore we're guaranteed to have the texture
        // locks.
        if (gengc->fsLocks & LOCKFLAG_DD_TEXTURE)
        {
            DDSUNLOCK(pddtex->pdds[i],
                      pddtex->texobj.texture.map.level[i].buffer);
#if DBG
            pddtex->texobj.texture.map.level[i].buffer = NULL;
#endif
        }

        pddtex->pdds[i]->lpVtbl->
            Release(pddtex->pdds[i]);
#if DBG
        pddtex->pdds[i] = NULL;
#endif
    }

#if DBG
    memset(&pddtex->gdds, 0, sizeof(pddtex->gdds));
#endif

    pddtex->levels = 0;
    if (gengc->fsGenLocks & LOCKFLAG_DD_TEXTURE)
    {
        gengc->fsGenLocks &= ~LOCKFLAG_DD_TEXTURE;
        gengc->fsLocks &= ~LOCKFLAG_DD_TEXTURE;
    }

    __GL_DELAY_VALIDATE(gc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\soft\so_tprls.c ===
/*
** Copyright 1991,1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/
#include "precomp.h"
#pragma hdrstop

#include <namesint.h>

void __glTexPriListRealize(__GLcontext *gc)
{
    __GLtextureObject *high, *low;
    GLboolean tryUnload = GL_TRUE;
    MCDHANDLE loadKey;
    
    __GL_NAMES_ASSERT_LOCKED(gc->texture.shared->namesArray);
    
    // Attempt to load as many of the highest priority textures as
    // possible.  If a lower priority texture is resident and a
    // higher priority texture is unable to load, kick it out
    // and try again
    high = gc->texture.shared->priorityListHighest;
    low = gc->texture.shared->priorityListLowest;

    while (high != NULL)
    {
        // We only want to load textures that have image data
        // Consider - Should check all mipmap levels?
        if (high->loadKey == 0 && high->texture.map.level[0].buffer != NULL)
        {
            for (;;)
            {
                // If high == low then there are no longer any
                // lower-priority textures to consider for unloading
                if (high == low)
                {
                    tryUnload = GL_FALSE;
                }
        
                loadKey = __glGenLoadTexture(gc, &high->texture.map, 0);
                if (loadKey != 0)
                {
                    high->resident = GL_TRUE;
                    high->loadKey = loadKey;
                    break;
                }

                if (tryUnload)
                {
                    while (low->loadKey == 0 && low != high)
                    {
                        low = low->higherPriority;
                    }

                    if (low->loadKey != 0)
                    {
                        __glGenFreeTexture(gc, &low->texture.map, low->loadKey);
                        low->loadKey = 0;
                        low->resident = GL_FALSE;
                    }
                }
                else
                {
                    break;
                }
            }
        }

        high = high->lowerPriority;
    }
}

void __glTexPriListAddToList(__GLcontext *gc, __GLtextureObject *texobj)
{
    __GLtextureObject *texobjLower;

    __GL_NAMES_ASSERT_LOCKED(gc->texture.shared->namesArray);
    
    // Walk the priority list to find a lower priority texture object
    texobjLower = gc->texture.shared->priorityListHighest;
    while (texobjLower != NULL &&
           texobjLower->texture.map.texobjs.priority >
           texobj->texture.map.texobjs.priority)
    {
        texobjLower = texobjLower->lowerPriority;
    }

    if (texobjLower == NULL)
    {
        // Place at end of list
        if (gc->texture.shared->priorityListLowest != NULL)
        {
            gc->texture.shared->priorityListLowest->lowerPriority = texobj;
        }
        else
        {
            gc->texture.shared->priorityListHighest = texobj;
        }
        texobj->higherPriority = gc->texture.shared->priorityListLowest;
        gc->texture.shared->priorityListLowest = texobj;
    }
    else
    {
        if (texobjLower->higherPriority != NULL)
        {
            texobjLower->higherPriority->lowerPriority = texobj;
        }
        else
        {
            gc->texture.shared->priorityListHighest = texobj;
        }
        texobj->higherPriority = texobjLower->higherPriority;
        texobjLower->higherPriority = texobj;
    }
    texobj->lowerPriority = texobjLower;
}

void __glTexPriListAdd(__GLcontext *gc, __GLtextureObject *texobj,
                       GLboolean realize)
{
    __glNamesLockArray(gc, gc->texture.shared->namesArray);
    
    __glTexPriListAddToList(gc, texobj);
    if (realize)
    {
        __glTexPriListRealize(gc);
    }

    __glNamesUnlockArray(gc, gc->texture.shared->namesArray);
}

void __glTexPriListRemoveFromList(__GLcontext *gc, __GLtextureObject *texobj)
{
    __GL_NAMES_ASSERT_LOCKED(gc->texture.shared->namesArray);
    
#if DBG
    {
        __GLtextureObject *t;

        for (t = gc->texture.shared->priorityListHighest;
             t != NULL; t = t->lowerPriority)
        {
            if (t == texobj)
            {
                break;
            }
        }
        ASSERTOPENGL(t != NULL, "Removing an unlisted texobj");
    }
#endif

    if (texobj->higherPriority != NULL)
    {
        texobj->higherPriority->lowerPriority = texobj->lowerPriority;
    }
    else
    {
        gc->texture.shared->priorityListHighest = texobj->lowerPriority;
    }
    if (texobj->lowerPriority != NULL)
    {
        texobj->lowerPriority->higherPriority = texobj->higherPriority;
    }
    else
    {
        gc->texture.shared->priorityListLowest = texobj->higherPriority;
    }
}

void __glTexPriListRemove(__GLcontext *gc, __GLtextureObject *texobj,
                          GLboolean realize)
{
    __glNamesLockArray(gc, gc->texture.shared->namesArray);
    
    __glTexPriListRemoveFromList(gc, texobj);

    __glGenFreeTexture(gc, &texobj->texture.map, texobj->loadKey);
    texobj->loadKey = 0;
    texobj->resident = GL_FALSE;

    if (realize)
    {
        __glTexPriListRealize(gc);
    }

    __glNamesUnlockArray(gc, gc->texture.shared->namesArray);
}

void __glTexPriListChangePriority(__GLcontext *gc, __GLtextureObject *texobj,
                                  GLboolean realize)
{
    __glNamesLockArray(gc, gc->texture.shared->namesArray);
    
    __glTexPriListRemoveFromList(gc, texobj);
    __glTexPriListAddToList(gc, texobj);

    // If we're re-realizing, don't bother calling the MCD texture-priority
    // function:

    if (realize) {
        __glTexPriListRealize(gc);
    } else if (((__GLGENcontext *)gc)->pMcdState && texobj->loadKey) {
        GenMcdUpdateTexturePriority((__GLGENcontext *)gc, 
                                    &texobj->texture.map, texobj->loadKey);
    }

    __glNamesUnlockArray(gc, gc->texture.shared->namesArray);
}

void __glTexPriListLoadSubImage(__GLcontext *gc, GLenum target, GLint lod, 
                                GLint xoffset, GLint yoffset, 
                                GLsizei w, GLsizei h)
{
    __GLtextureObject *pto;

    // Always mark things as resident:

    pto = __glLookUpTextureObject(gc, target);
    pto->resident = GL_TRUE;
    __glGenUpdateTexture(gc, &pto->texture.map, pto->loadKey);

    // For MCD, send down the full subimage command:

    if (((__GLGENcontext *)gc)->pMcdState && pto->loadKey) {
        GenMcdUpdateSubTexture((__GLGENcontext *)gc, &pto->texture.map, 
                               pto->loadKey, lod, 
                               xoffset, yoffset, w, h);
    }
}

void __glTexPriListLoadImage(__GLcontext *gc, GLenum target)
{
    __GLtextureObject *pto;

    // If we're unaccelerated then always mark things as resident
    pto = __glLookUpTextureObject(gc, target);
    pto->resident = GL_TRUE;
    __glGenUpdateTexture(gc, &pto->texture.map, pto->loadKey);

    // For simplicity, we will assume that the texture size or format
    // has changed, so delete the texture and re-realize the list.
    //
    // !!! If this becomes a performance issue, we *could* be smart about
    // !!! detecting the cases where the texture size and format remains the
    // !!! same.  However, modifying a texture should really be done through
    // !!! SubImage calls.

    if (((__GLGENcontext *)gc)->pMcdState) {
        if (pto->loadKey) {
            GenMcdDeleteTexture((__GLGENcontext *)gc, pto->loadKey);
            pto->loadKey = 0;
        }
        __glNamesLockArray(gc, gc->texture.shared->namesArray);
        __glTexPriListRealize(gc);
        __glNamesUnlockArray(gc, gc->texture.shared->namesArray);
    }
}

void __glTexPriListUnloadAll(__GLcontext *gc)
{
    __GLtextureObject *texobj;

    __GL_NAMES_ASSERT_LOCKED(gc->texture.shared->namesArray);

    texobj = gc->texture.shared->priorityListHighest;
    while (texobj != NULL)
    {
        __glGenFreeTexture(gc, &texobj->texture.map, texobj->loadKey);
        texobj->loadKey = 0;
        texobj->resident = GL_FALSE;

        texobj = texobj->lowerPriority;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\wgl\glsrvspt.c ===
/*
** Copyright 1991-1993, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/


/*
 * AUTOMATICALLY UPDATED OR GENERATED BY SGI: DO NOT EDIT
 * IF YOU MUST MODIFY THIS FILE, PLEASE CONTACT ptar@sgi.com 415-390-1483
 */

/* Server Side Procedure Table */

#include "precomp.h"
#pragma hdrstop

#include "glsbmsg.h"
#include "glsbmsgh.h"
#include "glsrvsb.h"
#include "glsrvspt.h"

GLSRVSBPROCTABLE glSrvSbProcTable = {

    NULL,  /* Make First Entry NULL */

/* gl Entry points */

     sbs_glDrawPolyArray          ,
     sbs_glBitmap                 ,
     sbs_glColor4fv               ,
     sbs_glEdgeFlag               ,
     sbs_glIndexf                 ,
     sbs_glNormal3fv              ,
     sbs_glRasterPos4fv           ,
     sbs_glTexCoord4fv            ,
     sbs_glClipPlane              ,
     sbs_glColorMaterial          ,
     sbs_glCullFace               ,
     sbs_glAddSwapHintRectWIN     ,
     sbs_glFogfv                  ,
     sbs_glFrontFace              ,
     sbs_glHint                   ,
     sbs_glLightfv                ,
     sbs_glLightModelfv           ,
     sbs_glLineStipple            ,
     sbs_glLineWidth              ,
     sbs_glMaterialfv             ,
     sbs_glPointSize              ,
     sbs_glPolygonMode            ,
     sbs_glPolygonStipple         ,
     sbs_glScissor                ,
     sbs_glShadeModel             ,
     sbs_glTexParameterfv         ,
     sbs_glTexParameteriv         ,
     sbs_glTexImage1D             ,
     sbs_glTexImage2D             ,
     sbs_glTexEnvfv               ,
     sbs_glTexEnviv               ,
     sbs_glTexGenfv               ,
     sbs_glFeedbackBuffer         ,
     sbs_glSelectBuffer           ,
     sbs_glRenderMode             ,
     sbs_glInitNames              ,
     sbs_glLoadName               ,
     sbs_glPassThrough            ,
     sbs_glPopName                ,
     sbs_glPushName               ,
     sbs_glDrawBuffer             ,
     sbs_glClear                  ,
     sbs_glClearAccum             ,
     sbs_glClearIndex             ,
     sbs_glClearColor             ,
     sbs_glClearStencil           ,
     sbs_glClearDepth             ,
     sbs_glStencilMask            ,
     sbs_glColorMask              ,
     sbs_glDepthMask              ,
     sbs_glIndexMask              ,
     sbs_glAccum                  ,
     sbs_glDisable                ,
     sbs_glEnable                 ,
     sbs_glPopAttrib              ,
     sbs_glPushAttrib             ,
     sbs_glAlphaFunc              ,
     sbs_glBlendFunc              ,
     sbs_glLogicOp                ,
     sbs_glStencilFunc            ,
     sbs_glStencilOp              ,
     sbs_glDepthFunc              ,
     sbs_glPixelZoom              ,
     sbs_glPixelTransferf         ,
     sbs_glPixelTransferi         ,
     sbs_glPixelStoref            ,
     sbs_glPixelStorei            ,
     sbs_glPixelMapfv             ,
     sbs_glPixelMapuiv            ,
     sbs_glPixelMapusv            ,
     sbs_glReadBuffer             ,
     sbs_glCopyPixels             ,
     sbs_glReadPixels             ,
     sbs_glDrawPixels             ,
     sbs_glGetBooleanv            ,
     sbs_glGetClipPlane           ,
     sbs_glGetDoublev             ,
     sbs_glGetError               ,
     sbs_glGetFloatv              ,
     sbs_glGetIntegerv            ,
     sbs_glGetLightfv             ,
     sbs_glGetLightiv             ,
     sbs_glGetMapdv               ,
     sbs_glGetMapfv               ,
     sbs_glGetMapiv               ,
     sbs_glGetMaterialfv          ,
     sbs_glGetMaterialiv          ,
     sbs_glGetPixelMapfv          ,
     sbs_glGetPixelMapuiv         ,
     sbs_glGetPixelMapusv         ,
     sbs_glGetPolygonStipple      ,
     sbs_glGetTexEnvfv            ,
     sbs_glGetTexEnviv            ,
     sbs_glGetTexGendv            ,
     sbs_glGetTexGenfv            ,
     sbs_glGetTexGeniv            ,
     sbs_glGetTexImage            ,
     sbs_glGetTexParameterfv      ,
     sbs_glGetTexParameteriv      ,
     sbs_glGetTexLevelParameterfv ,
     sbs_glGetTexLevelParameteriv ,
     sbs_glIsEnabled              ,
     sbs_glDepthRange             ,
     sbs_glFrustum                ,
     sbs_glLoadIdentity           ,
     sbs_glLoadMatrixf            ,
     sbs_glMatrixMode             ,
     sbs_glMultMatrixf            ,
     sbs_glOrtho                  ,
     sbs_glPopMatrix              ,
     sbs_glPushMatrix             ,
     sbs_glRotatef                ,
     sbs_glScalef                 ,
     sbs_glTranslatef             ,
     sbs_glViewport               ,
     sbs_glAreTexturesResident    ,
     sbs_glBindTexture            ,
     sbs_glCopyTexImage1D         ,
     sbs_glCopyTexImage2D         ,
     sbs_glCopyTexSubImage1D      ,
     sbs_glCopyTexSubImage2D      ,
     sbs_glDeleteTextures         ,
     sbs_glGenTextures            ,
     sbs_glIsTexture              ,
     sbs_glPrioritizeTextures     ,
     sbs_glTexSubImage1D          ,
     sbs_glTexSubImage2D          ,
     sbs_glColorTableEXT          ,
     sbs_glColorSubTableEXT       ,
     sbs_glGetColorTableEXT       ,
     sbs_glGetColorTableParameterivEXT,
     sbs_glGetColorTableParameterfvEXT,
     sbs_glPolygonOffset          ,
#ifdef GL_WIN_multiple_textures
     sbs_glCurrentTextureIndexWIN,
     sbs_glBindNthTextureWIN,
     sbs_glNthTexCombineFuncWIN,
#endif // GL_WIN_multiple_textures
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\wgl\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#include <stddef.h>
#include <string.h>

#include <wingdip.h>
#define _NO_DDRAWINT_NO_COM
#include <winddi.h>

#include <glp.h>
#include <gencx.h>
#include <fixed.h>
#include <batchinf.h>
#include <glteb.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\wgl\glsrvgs.c ===
/*
** Copyright 1991-1993, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/


/*
 * AUTOMATICALLY UPDATED OR GENERATED BY SGI: DO NOT EDIT
 * IF YOU MUST MODIFY THIS FILE, PLEASE CONTACT ptar@sgi.com 415-390-1483
 */

#include "precomp.h"
#pragma hdrstop

#define const           // Don't bother with const

#include <imfuncs.h>
#include "glsbmsg.h"
#include "glsbmsgh.h"

VOID * FASTCALL
sbs_glAddSwapHintRectWIN ( __GLcontext *gc, IN GLMSG_ADDSWAPHINTRECTWIN *pMsg )
{
    __glim_AddSwapHintRectWIN(
        pMsg->xs, pMsg->ys, pMsg->xe, pMsg->ye);

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glDrawPolyArray ( __GLcontext *gc, IN GLMSG_DRAWPOLYARRAY *pMsg )
{
    __glim_DrawPolyArray( pMsg->pa0 );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glColor4fv ( __GLcontext *gc, IN GLMSG_COLOR4FV *pMsg )
{
    __glim_Color4fv( pMsg->v );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glEdgeFlag ( __GLcontext *gc, IN GLMSG_EDGEFLAG *pMsg )
{
    __glim_EdgeFlag( pMsg->flag );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glIndexf ( __GLcontext *gc, IN GLMSG_INDEXF *pMsg )
{
    __glim_Indexf( pMsg->c );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glNormal3fv ( __GLcontext *gc, IN GLMSG_NORMAL3FV *pMsg )
{
    __glim_Normal3fv( pMsg->v );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glRasterPos4fv ( __GLcontext *gc, IN GLMSG_RASTERPOS4FV *pMsg )
{
    __glim_RasterPos4fv( pMsg->v );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glTexCoord4fv ( __GLcontext *gc, IN GLMSG_TEXCOORD4FV *pMsg )
{
    __glim_TexCoord4fv( pMsg->v );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glClipPlane ( __GLcontext *gc, IN GLMSG_CLIPPLANE *pMsg )
{
    __glim_ClipPlane( pMsg->plane, pMsg->equation );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glColorMaterial ( __GLcontext *gc, IN GLMSG_COLORMATERIAL *pMsg )
{
    __glim_ColorMaterial( pMsg->face, pMsg->mode );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glCullFace ( __GLcontext *gc, IN GLMSG_CULLFACE *pMsg )
{
    __glim_CullFace( pMsg->mode );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glFogfv ( __GLcontext *gc, IN GLMSG_FOGFV *pMsg )
{
    __glim_Fogfv( pMsg->pname, &pMsg->params[0] );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glFrontFace ( __GLcontext *gc, IN GLMSG_FRONTFACE *pMsg )
{
    __glim_FrontFace( pMsg->mode );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glHint ( __GLcontext *gc, IN GLMSG_HINT *pMsg )
{
    __glim_Hint( pMsg->target, pMsg->mode );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glLightfv ( __GLcontext *gc, IN GLMSG_LIGHTFV *pMsg )
{
    __glim_Lightfv( pMsg->light, pMsg->pname, &pMsg->params[0] );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glLightModelfv ( __GLcontext *gc, IN GLMSG_LIGHTMODELFV *pMsg )
{
    __glim_LightModelfv( pMsg->pname, &pMsg->params[0] );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glLineStipple ( __GLcontext *gc, IN GLMSG_LINESTIPPLE *pMsg )
{
    __glim_LineStipple( pMsg->factor, pMsg->pattern );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glLineWidth ( __GLcontext *gc, IN GLMSG_LINEWIDTH *pMsg )
{
    __glim_LineWidth( pMsg->width );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glMaterialfv ( __GLcontext *gc, IN GLMSG_MATERIALFV *pMsg )
{
    __glim_Materialfv( pMsg->face, pMsg->pname, &pMsg->params[0] );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glPointSize ( __GLcontext *gc, IN GLMSG_POINTSIZE *pMsg )
{
    __glim_PointSize( pMsg->size );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glPolygonMode ( __GLcontext *gc, IN GLMSG_POLYGONMODE *pMsg )
{
    __glim_PolygonMode( pMsg->face, pMsg->mode );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glScissor ( __GLcontext *gc, IN GLMSG_SCISSOR *pMsg )
{
    __glim_Scissor( pMsg->x, pMsg->y, pMsg->width, pMsg->height );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glShadeModel ( __GLcontext *gc, IN GLMSG_SHADEMODEL *pMsg )
{
    __glim_ShadeModel( pMsg->mode );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glTexParameterfv ( __GLcontext *gc, IN GLMSG_TEXPARAMETERFV *pMsg )
{
    __glim_TexParameterfv( pMsg->target, pMsg->pname, &pMsg->params[0] );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glTexParameteriv ( __GLcontext *gc, IN GLMSG_TEXPARAMETERIV *pMsg )
{
    __glim_TexParameteriv( pMsg->target, pMsg->pname, &pMsg->params[0] );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glTexEnvfv ( __GLcontext *gc, IN GLMSG_TEXENVFV *pMsg )
{
    __glim_TexEnvfv( pMsg->target, pMsg->pname, &pMsg->params[0] );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glTexEnviv ( __GLcontext *gc, IN GLMSG_TEXENVIV *pMsg )
{
    __glim_TexEnviv( pMsg->target, pMsg->pname, &pMsg->params[0] );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glTexGenfv ( __GLcontext *gc, IN GLMSG_TEXGENFV *pMsg )
{
    __glim_TexGenfv( pMsg->coord, pMsg->pname, &pMsg->params[0] );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glInitNames ( __GLcontext *gc, IN GLMSG_INITNAMES *pMsg )
{
    __glim_InitNames( );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glLoadName ( __GLcontext *gc, IN GLMSG_LOADNAME *pMsg )
{
    __glim_LoadName( pMsg->name );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glPassThrough ( __GLcontext *gc, IN GLMSG_PASSTHROUGH *pMsg )
{
    __glim_PassThrough( pMsg->token );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glPopName ( __GLcontext *gc, IN GLMSG_POPNAME *pMsg )
{
    __glim_PopName( );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glPushName ( __GLcontext *gc, IN GLMSG_PUSHNAME *pMsg )
{
    __glim_PushName( pMsg->name );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glDrawBuffer ( __GLcontext *gc, IN GLMSG_DRAWBUFFER *pMsg )
{
    __glim_DrawBuffer( pMsg->mode );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glClear ( __GLcontext *gc, IN GLMSG_CLEAR *pMsg )
{
    __glim_Clear( pMsg->mask );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glClearAccum ( __GLcontext *gc, IN GLMSG_CLEARACCUM *pMsg )
{
    __glim_ClearAccum( pMsg->red, pMsg->green, pMsg->blue, pMsg->alpha );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glClearIndex ( __GLcontext *gc, IN GLMSG_CLEARINDEX *pMsg )
{
    __glim_ClearIndex( pMsg->c );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glClearColor ( __GLcontext *gc, IN GLMSG_CLEARCOLOR *pMsg )
{
    __glim_ClearColor( pMsg->red, pMsg->green, pMsg->blue, pMsg->alpha );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glClearStencil ( __GLcontext *gc, IN GLMSG_CLEARSTENCIL *pMsg )
{
    __glim_ClearStencil( pMsg->s );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glClearDepth ( __GLcontext *gc, IN GLMSG_CLEARDEPTH *pMsg )
{
    __glim_ClearDepth( pMsg->depth );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glStencilMask ( __GLcontext *gc, IN GLMSG_STENCILMASK *pMsg )
{
    __glim_StencilMask( pMsg->mask );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glColorMask ( __GLcontext *gc, IN GLMSG_COLORMASK *pMsg )
{
    __glim_ColorMask( pMsg->red, pMsg->green, pMsg->blue, pMsg->alpha );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glDepthMask ( __GLcontext *gc, IN GLMSG_DEPTHMASK *pMsg )
{
    __glim_DepthMask( pMsg->flag );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glIndexMask ( __GLcontext *gc, IN GLMSG_INDEXMASK *pMsg )
{
    __glim_IndexMask( pMsg->mask );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glAccum ( __GLcontext *gc, IN GLMSG_ACCUM *pMsg )
{
    __glim_Accum( pMsg->op, pMsg->value );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glDisable ( __GLcontext *gc, IN GLMSG_DISABLE *pMsg )
{
    __glim_Disable( pMsg->cap );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glEnable ( __GLcontext *gc, IN GLMSG_ENABLE *pMsg )
{
    __glim_Enable( pMsg->cap );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glPopAttrib ( __GLcontext *gc, IN GLMSG_POPATTRIB *pMsg )
{
    __glim_PopAttrib( );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glPushAttrib ( __GLcontext *gc, IN GLMSG_PUSHATTRIB *pMsg )
{
    __glim_PushAttrib( pMsg->mask );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glAlphaFunc ( __GLcontext *gc, IN GLMSG_ALPHAFUNC *pMsg )
{
    __glim_AlphaFunc( pMsg->func, pMsg->ref );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glBlendFunc ( __GLcontext *gc, IN GLMSG_BLENDFUNC *pMsg )
{
    __glim_BlendFunc( pMsg->sfactor, pMsg->dfactor );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glLogicOp ( __GLcontext *gc, IN GLMSG_LOGICOP *pMsg )
{
    __glim_LogicOp( pMsg->opcode );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glStencilFunc ( __GLcontext *gc, IN GLMSG_STENCILFUNC *pMsg )
{
    __glim_StencilFunc( pMsg->func, pMsg->ref, pMsg->mask );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glStencilOp ( __GLcontext *gc, IN GLMSG_STENCILOP *pMsg )
{
    __glim_StencilOp( pMsg->fail, pMsg->zfail, pMsg->zpass );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glDepthFunc ( __GLcontext *gc, IN GLMSG_DEPTHFUNC *pMsg )
{
    __glim_DepthFunc( pMsg->func );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glPixelZoom ( __GLcontext *gc, IN GLMSG_PIXELZOOM *pMsg )
{
    __glim_PixelZoom( pMsg->xfactor, pMsg->yfactor );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glPixelTransferf ( __GLcontext *gc, IN GLMSG_PIXELTRANSFERF *pMsg )
{
    __glim_PixelTransferf( pMsg->pname, pMsg->param );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glPixelTransferi ( __GLcontext *gc, IN GLMSG_PIXELTRANSFERI *pMsg )
{
    __glim_PixelTransferi( pMsg->pname, pMsg->param );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glPixelStoref ( __GLcontext *gc, IN GLMSG_PIXELSTOREF *pMsg )
{
    __glim_PixelStoref( pMsg->pname, pMsg->param );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glPixelStorei ( __GLcontext *gc, IN GLMSG_PIXELSTOREI *pMsg )
{
    __glim_PixelStorei( pMsg->pname, pMsg->param );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glPixelMapfv ( __GLcontext *gc, IN GLMSG_PIXELMAPFV *pMsg )
{

// VARIABLE_IN

    VOID *pData;
    VOID *NextOffset;
    NextOffset = (VOID *) ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
    pData = (VOID *) pMsg->valuesOff;

    __glim_PixelMapfv( pMsg->map, pMsg->mapsize, pData );

    return( NextOffset );
}

VOID * FASTCALL
sbs_glPixelMapuiv ( __GLcontext *gc, IN GLMSG_PIXELMAPUIV *pMsg )
{

// VARIABLE_IN

    VOID *pData;
    VOID *NextOffset;
    NextOffset = (VOID *) ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
    pData = (VOID *) pMsg->valuesOff;

    __glim_PixelMapuiv( pMsg->map, pMsg->mapsize, pData );

    return( NextOffset );
}

VOID * FASTCALL
sbs_glPixelMapusv ( __GLcontext *gc, IN GLMSG_PIXELMAPUSV *pMsg )
{

// VARIABLE_IN

    VOID *pData;
    VOID *NextOffset;
    NextOffset = (VOID *) ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
    pData = (VOID *) pMsg->valuesOff;

    __glim_PixelMapusv( pMsg->map, pMsg->mapsize, pData );

    return( NextOffset );
}

VOID * FASTCALL
sbs_glReadBuffer ( __GLcontext *gc, IN GLMSG_READBUFFER *pMsg )
{
    __glim_ReadBuffer( pMsg->mode );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glCopyPixels ( __GLcontext *gc, IN GLMSG_COPYPIXELS *pMsg )
{
#ifdef _MCD_
    if (((__GLGENcontext *)gc)->pMcdState)
    {
    // This function potentially touches the framebuffer memory.  Since,
    // this function is not going to first pass through the MCD driver
    // (which would give the MCD driver the oportunity to sync to the HW),
    // we need to do this synchronization explicitly.

        GenMcdSynchronize((__GLGENcontext *)gc);
    }
#endif

    __glim_CopyPixels( pMsg->x, pMsg->y, pMsg->width, pMsg->height, pMsg->type );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetBooleanv ( __GLcontext *gc, IN GLMSG_GETBOOLEANV *pMsg )
{
    __glim_GetBooleanv( pMsg->pname, pMsg->params );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetClipPlane ( __GLcontext *gc, IN GLMSG_GETCLIPPLANE *pMsg )
{
    __glim_GetClipPlane( pMsg->plane, pMsg->equation );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetDoublev ( __GLcontext *gc, IN GLMSG_GETDOUBLEV *pMsg )
{
    __glim_GetDoublev( pMsg->pname, pMsg->params );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetError ( __GLcontext *gc, IN GLMSG_GETERROR *pMsg )
{
    GLTEB_RETURNVALUE() =
        (ULONG)__glim_GetError( );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetFloatv ( __GLcontext *gc, IN GLMSG_GETFLOATV *pMsg )
{
    __glim_GetFloatv( pMsg->pname, pMsg->params );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetIntegerv ( __GLcontext *gc, IN GLMSG_GETINTEGERV *pMsg )
{
    __glim_GetIntegerv( pMsg->pname, pMsg->params );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetLightfv ( __GLcontext *gc, IN GLMSG_GETLIGHTFV *pMsg )
{
    __glim_GetLightfv( pMsg->light, pMsg->pname, pMsg->params );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetLightiv ( __GLcontext *gc, IN GLMSG_GETLIGHTIV *pMsg )
{
    __glim_GetLightiv( pMsg->light, pMsg->pname, pMsg->params );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetMapdv ( __GLcontext *gc, IN GLMSG_GETMAPDV *pMsg )
{

// VARIABLE_OUT

    VOID *pData;
    VOID *NextOffset;
    NextOffset = (VOID *) ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
    pData = (VOID *) pMsg->vOff;

    __glim_GetMapdv( pMsg->target, pMsg->query, pData );

    return( NextOffset );
}

VOID * FASTCALL
sbs_glGetMapfv ( __GLcontext *gc, IN GLMSG_GETMAPFV *pMsg )
{

// VARIABLE_OUT

    VOID *pData;
    VOID *NextOffset;
    NextOffset = (VOID *) ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
    pData = (VOID *) pMsg->vOff;

    __glim_GetMapfv( pMsg->target, pMsg->query, pData );

    return( NextOffset );
}

VOID * FASTCALL
sbs_glGetMapiv ( __GLcontext *gc, IN GLMSG_GETMAPIV *pMsg )
{

// VARIABLE_OUT

    VOID *pData;
    VOID *NextOffset;
    NextOffset = (VOID *) ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
    pData = (VOID *) pMsg->vOff;

    __glim_GetMapiv( pMsg->target, pMsg->query, pData );

    return( NextOffset );
}

VOID * FASTCALL
sbs_glGetMaterialfv ( __GLcontext *gc, IN GLMSG_GETMATERIALFV *pMsg )
{
    __glim_GetMaterialfv( pMsg->face, pMsg->pname, pMsg->params );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetMaterialiv ( __GLcontext *gc, IN GLMSG_GETMATERIALIV *pMsg )
{
    __glim_GetMaterialiv( pMsg->face, pMsg->pname, pMsg->params );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetPixelMapfv ( __GLcontext *gc, IN GLMSG_GETPIXELMAPFV *pMsg )
{

// VARIABLE_OUT

    VOID *pData;
    VOID *NextOffset;
    NextOffset = (VOID *) ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
    pData = (VOID *) pMsg->valuesOff;

    __glim_GetPixelMapfv( pMsg->map, pData );

    return( NextOffset );
}

VOID * FASTCALL
sbs_glGetPixelMapuiv ( __GLcontext *gc, IN GLMSG_GETPIXELMAPUIV *pMsg )
{

// VARIABLE_OUT

    VOID *pData;
    VOID *NextOffset;
    NextOffset = (VOID *) ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
    pData = (VOID *) pMsg->valuesOff;

    __glim_GetPixelMapuiv( pMsg->map, pData );

    return( NextOffset );
}

VOID * FASTCALL
sbs_glGetPixelMapusv ( __GLcontext *gc, IN GLMSG_GETPIXELMAPUSV *pMsg )
{

// VARIABLE_OUT

    VOID *pData;
    VOID *NextOffset;
    NextOffset = (VOID *) ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
    pData = (VOID *) pMsg->valuesOff;

    __glim_GetPixelMapusv( pMsg->map, pData );

    return( NextOffset );
}

VOID * FASTCALL
sbs_glGetTexEnvfv ( __GLcontext *gc, IN GLMSG_GETTEXENVFV *pMsg )
{
    __glim_GetTexEnvfv( pMsg->target, pMsg->pname, pMsg->params );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetTexEnviv ( __GLcontext *gc, IN GLMSG_GETTEXENVIV *pMsg )
{
    __glim_GetTexEnviv( pMsg->target, pMsg->pname, pMsg->params );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetTexGendv ( __GLcontext *gc, IN GLMSG_GETTEXGENDV *pMsg )
{
    __glim_GetTexGendv( pMsg->coord, pMsg->pname, pMsg->params );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetTexGenfv ( __GLcontext *gc, IN GLMSG_GETTEXGENFV *pMsg )
{
    __glim_GetTexGenfv( pMsg->coord, pMsg->pname, pMsg->params );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetTexGeniv ( __GLcontext *gc, IN GLMSG_GETTEXGENIV *pMsg )
{
    __glim_GetTexGeniv( pMsg->coord, pMsg->pname, pMsg->params );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetTexParameterfv ( __GLcontext *gc, IN GLMSG_GETTEXPARAMETERFV *pMsg )
{
    __glim_GetTexParameterfv( pMsg->target, pMsg->pname, pMsg->params );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetTexParameteriv ( __GLcontext *gc, IN GLMSG_GETTEXPARAMETERIV *pMsg )
{
    __glim_GetTexParameteriv( pMsg->target, pMsg->pname, pMsg->params );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetTexLevelParameterfv ( __GLcontext *gc, IN GLMSG_GETTEXLEVELPARAMETERFV *pMsg )
{
    __glim_GetTexLevelParameterfv( pMsg->target, pMsg->level, pMsg->pname, pMsg->params );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetTexLevelParameteriv ( __GLcontext *gc, IN GLMSG_GETTEXLEVELPARAMETERIV *pMsg )
{
    __glim_GetTexLevelParameteriv( pMsg->target, pMsg->level, pMsg->pname, pMsg->params );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glIsEnabled ( __GLcontext *gc, IN GLMSG_ISENABLED *pMsg )
{
    GLTEB_RETURNVALUE() =
        (ULONG)__glim_IsEnabled( pMsg->cap );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glDepthRange ( __GLcontext *gc, IN GLMSG_DEPTHRANGE *pMsg )
{
    __glim_DepthRange( pMsg->zNear, pMsg->zFar );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glFrustum ( __GLcontext *gc, IN GLMSG_FRUSTUM *pMsg )
{
    __glim_Frustum( pMsg->left, pMsg->right, pMsg->bottom, pMsg->top, pMsg->zNear, pMsg->zFar );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glLoadIdentity ( __GLcontext *gc, IN GLMSG_LOADIDENTITY *pMsg )
{
    __glim_LoadIdentity( );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glLoadMatrixf ( __GLcontext *gc, IN GLMSG_LOADMATRIXF *pMsg )
{
    __glim_LoadMatrixf( pMsg->m );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glMatrixMode ( __GLcontext *gc, IN GLMSG_MATRIXMODE *pMsg )
{
    __glim_MatrixMode( pMsg->mode );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glMultMatrixf ( __GLcontext *gc, IN GLMSG_MULTMATRIXF *pMsg )
{
    __glim_MultMatrixf( pMsg->m );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glOrtho ( __GLcontext *gc, IN GLMSG_ORTHO *pMsg )
{
    __glim_Ortho( pMsg->left, pMsg->right, pMsg->bottom, pMsg->top, pMsg->zNear, pMsg->zFar );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glPopMatrix ( __GLcontext *gc, IN GLMSG_POPMATRIX *pMsg )
{
    __glim_PopMatrix( );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glPushMatrix ( __GLcontext *gc, IN GLMSG_PUSHMATRIX *pMsg )
{
    __glim_PushMatrix( );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glRotatef ( __GLcontext *gc, IN GLMSG_ROTATEF *pMsg )
{
    __glim_Rotatef( pMsg->angle, pMsg->x, pMsg->y, pMsg->z );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glScalef ( __GLcontext *gc, IN GLMSG_SCALEF *pMsg )
{
    __glim_Scalef( pMsg->x, pMsg->y, pMsg->z );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glTranslatef ( __GLcontext *gc, IN GLMSG_TRANSLATEF *pMsg )
{
    __glim_Translatef( pMsg->x, pMsg->y, pMsg->z );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glViewport ( __GLcontext *gc, IN GLMSG_VIEWPORT *pMsg )
{
    __glim_Viewport( pMsg->x, pMsg->y, pMsg->width, pMsg->height );

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\wgl\glsrvgsh.c ===
/*
** Copyright 1991-1993, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "precomp.h"
#pragma hdrstop

#include <imfuncs.h>
#include "glsbmsg.h"
#include "glsbmsgh.h"

#include "srvsize.h"

/********************************************************************/


VOID * FASTCALL
sbs_glRenderMode( __GLcontext *gc, IN GLMSG_RENDERMODE *pMsg)
{
    GLint Result;

    /*
     *  Make the call
     *
     *  When exiting Selection mode, RenderMode returns the number of hit
     *  records or -1 if an overflow occured.
     *
     *  When exiting Feedback mode, RenderMode returns the number of values
     *  placed in the feedback buffer or -1 if an overflow occured.
     */

    Result =
        __glim_RenderMode
            ( pMsg->mode );

    GLTEB_RETURNVALUE() = (ULONG)Result;

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}


VOID * FASTCALL
sbs_glFeedbackBuffer( __GLcontext *gc, IN GLMSG_FEEDBACKBUFFER *pMsg )
{
    __GLGENcontext *gengc;
    GLint PreviousError;
    GLfloat *Buffer;
    GLuint SizeInBytes;

    gengc = (__GLGENcontext *)gc;

    /*
     *  Save the current error code so that we can determine
     *  if the call was successful.
     */

    PreviousError = gc->error;
    gc->error     = GL_NO_ERROR;    /* clear the error code */

    /*
     *  Figure out the size of the buffer in bytes
     */

    SizeInBytes = pMsg->size * sizeof(GLfloat);

    /*
     *  Allocate the server side buffer
     *  Use GenMalloc() because it may be used indefinitely.
     */

    if ( NULL == (Buffer = (GLfloat *) pMsg->bufferOff) )
    {
        __glSetError(GL_OUT_OF_MEMORY);
        DBGERROR("GenMalloc failed\n");
    }
    else
    {
        /*
         *  Make the call
         */

        __glim_FeedbackBuffer(
                pMsg->size, pMsg->type, Buffer );

        /*
         *  If the call was successful, save the parameters
         */

        if ( GL_NO_ERROR == gc->error )
        {
            gc->error = PreviousError;      /* Restore the error code */

            gengc->RenderState.SrvFeedbackBuffer  = Buffer;
            gengc->RenderState.CltFeedbackBuffer  = (GLfloat *)pMsg->bufferOff;
            gengc->RenderState.FeedbackBufferSize = SizeInBytes;
            gengc->RenderState.FeedbackType       = pMsg->type;
        }
    }
    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glSelectBuffer( __GLcontext *gc, IN GLMSG_SELECTBUFFER *pMsg)
{
    __GLGENcontext *gengc;
    GLint PreviousError;
    GLuint *Buffer;
    GLuint SizeInBytes;

    gengc = (__GLGENcontext *)gc;

    /*
     *  Save the current error code so that we can determine
     *  if the call was successful.
     */

    PreviousError = gc->error;
    gc->error     = GL_NO_ERROR;    /* clear the error code */

    /*
     *  Figure out the size of the buffer in bytes
     */

    SizeInBytes = pMsg->size * sizeof(GLuint);

    /*
     *  Allocate the server side buffer
     *  Use GenMalloc() because it may be used indefinitely.
     */

    if ( NULL == (Buffer = (GLuint *) pMsg->bufferOff) )
    {
        __glSetError(GL_OUT_OF_MEMORY);
        DBGERROR("GenMalloc failed\n");
    }
    else
    {
        /*
         *  Make the call
         */

        __glim_SelectBuffer
                    (pMsg->size, Buffer );

        /*
         *  If the call was successful, save the parameters
         */

        if ( GL_NO_ERROR == gc->error )
        {
            gc->error = PreviousError;      /* Restore the error code */

            gengc->RenderState.SrvSelectBuffer  = Buffer;
            gengc->RenderState.CltSelectBuffer  = (GLuint *)pMsg->bufferOff;
            gengc->RenderState.SelectBufferSize = SizeInBytes;
        }
    }
    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

/******************* Pixel Functions ********************************/

VOID * FASTCALL
sbs_glReadPixels ( __GLcontext *gc, IN GLMSG_READPIXELS *pMsg )
{
    VOID *Data;
    VOID *NextOffset;

#ifdef _MCD_
    if (((__GLGENcontext *)gc)->pMcdState)
    {
    // This function potentially touches the framebuffer memory.  Since,
    // this function is not going to first pass through the MCD driver
    // (which would give the MCD driver the oportunity to sync to the HW),
    // we need to do this synchronization explicitly.

        GenMcdSynchronize((__GLGENcontext *)gc);
    }
#endif

    NextOffset = (VOID *) ( ((BYTE *)pMsg) + GLMSG_ALIGN(sizeof(*pMsg)) );
    Data = (VOID *) pMsg->pixelsOff;

    __glim_ReadPixels
        (   pMsg->x,
            pMsg->y,
            pMsg->width,
            pMsg->height,
            pMsg->format,
            pMsg->type,
            Data );

    return( NextOffset );
}

VOID * FASTCALL
sbs_glGetPolygonStipple ( __GLcontext *gc, IN GLMSG_GETPOLYGONSTIPPLE *pMsg )
{
    VOID *Data;
    VOID *NextOffset;

    NextOffset = (VOID *) ( ((BYTE *)pMsg) + GLMSG_ALIGN(sizeof(*pMsg)) );
    Data = (VOID *) pMsg->maskOff;

    __glim_GetPolygonStipple
            ( Data );

    return( NextOffset );
}

/*
 *  XXXX From Ptar:
 *
 *      This code is very similar to __glCheckReadPixelArgs() in
 *      pixel/px_api.c, and could possibly replace it.
 */


VOID * FASTCALL
sbs_glGetTexImage ( __GLcontext *gc, IN GLMSG_GETTEXIMAGE *pMsg )
{
    VOID *Data;
    VOID *NextOffset;

    NextOffset = (VOID *) ( ((BYTE *)pMsg) + GLMSG_ALIGN(sizeof(*pMsg)) );
    Data = (VOID *) pMsg->pixelsOff;

    __glim_GetTexImage
        (   pMsg->target,
            pMsg->level,
            pMsg->format,
            pMsg->type,
            Data );

    return( NextOffset );
}


VOID * FASTCALL
sbs_glDrawPixels ( __GLcontext *gc, IN GLMSG_DRAWPIXELS *pMsg )
{
    VOID *Data;
    VOID *NextOffset;

#ifdef _MCD_
    if (((__GLGENcontext *)gc)->pMcdState)
    {
    // This function potentially touches the framebuffer memory.  Since,
    // this function is not going to first pass through the MCD driver
    // (which would give the MCD driver the oportunity to sync to the HW),
    // we need to do this synchronization explicitly.

        GenMcdSynchronize((__GLGENcontext *)gc);
    }
#endif

    NextOffset = (VOID *) ( ((BYTE *)pMsg) + GLMSG_ALIGN(sizeof(*pMsg)) );
    Data = (VOID *) pMsg->pixelsOff;

    __glim_DrawPixels
        (   pMsg->width,
            pMsg->height,
            pMsg->format,
            pMsg->type,
#ifdef NT
            Data,
	    pMsg->_IsDlist);
#else
            Data );
#endif

    return( NextOffset );
}

VOID * FASTCALL
sbs_glPolygonStipple ( __GLcontext *gc, IN GLMSG_POLYGONSTIPPLE *pMsg )
{
    VOID *Data;
    VOID *NextOffset;

    NextOffset = (VOID *) ( ((BYTE *)pMsg) + GLMSG_ALIGN(sizeof(*pMsg)) );
    Data = (VOID *) pMsg->maskOff;

    __glim_PolygonStipple
#ifdef NT
            ( Data, pMsg->_IsDlist );
#else
            ( Data );
#endif

    return( NextOffset );
}

/*
 *  XXXX from Ptar:
 *
 *  The whole bitmap is copied, the server (not the client)
 *  could be modified so that only the data starting at
 *  xorig and yorig is copied, then width and height probably
 *  need to be modified.
 *  Note that __glBitmap_size() will also need to be modified
 *
 */

VOID * FASTCALL
sbs_glBitmap ( __GLcontext *gc, IN GLMSG_BITMAP *pMsg )
{
    VOID *Data;
    VOID *NextOffset;

#ifdef _MCD_
    if (((__GLGENcontext *)gc)->pMcdState)
    {
    // This function potentially touches the framebuffer memory.  Since,
    // this function is not going to first pass through the MCD driver
    // (which would give the MCD driver the oportunity to sync to the HW),
    // we need to do this synchronization explicitly.

        GenMcdSynchronize((__GLGENcontext *)gc);
    }
#endif

    NextOffset = (VOID *) ( ((BYTE *)pMsg) + GLMSG_ALIGN(sizeof(*pMsg)) );
    Data = (VOID *) pMsg->bitmapOff;

    __glim_Bitmap
        (
            pMsg->width ,
            pMsg->height,
            pMsg->xorig ,
            pMsg->yorig ,
            pMsg->xmove ,
            pMsg->ymove ,
#ifdef NT
            Data        ,
            pMsg->_IsDlist
#else
            Data
#endif
        );

    return( NextOffset );
}

VOID * FASTCALL
sbs_glTexImage1D ( __GLcontext *gc, IN GLMSG_TEXIMAGE1D *pMsg )
{
    VOID *Data;
    VOID *NextOffset;

    NextOffset = (VOID *) ( ((BYTE *)pMsg) + GLMSG_ALIGN(sizeof(*pMsg)) );
    Data = (VOID *) pMsg->pixelsOff;

    __glim_TexImage1D
        (
            pMsg->target        ,
            pMsg->level         ,
            pMsg->components    ,
            pMsg->width         ,
            pMsg->border        ,
            pMsg->format        ,
            pMsg->type          ,
#ifdef NT
            Data                ,
            pMsg->_IsDlist
#else
            Data
#endif
        );

    return( NextOffset );
}

VOID * FASTCALL
sbs_glTexImage2D ( __GLcontext *gc, IN GLMSG_TEXIMAGE2D *pMsg )
{
    VOID *Data;
    VOID *NextOffset;

    NextOffset = (VOID *) ( ((BYTE *)pMsg) + GLMSG_ALIGN(sizeof(*pMsg)) );

    Data = (VOID *) pMsg->pixelsOff;

    __glim_TexImage2D
        (
            pMsg->target        ,
            pMsg->level         ,
            pMsg->components    ,
            pMsg->width         ,
            pMsg->height        ,
            pMsg->border        ,
            pMsg->format        ,
            pMsg->type          ,
#ifdef NT
            Data                ,
            pMsg->_IsDlist
#else
            Data
#endif
        );

    return( NextOffset );
}

VOID * FASTCALL
sbs_glAreTexturesResident( __GLcontext *gc, IN GLMSG_ARETEXTURESRESIDENT    *pMsg)
{
    GLboolean retval;
        
    retval = __glim_AreTexturesResident
        ( pMsg->n, pMsg->textures, pMsg->residences );
    
    GLTEB_RETURNVALUE() = (ULONG)retval;
    
    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glBindTexture( __GLcontext *gc, IN GLMSG_BINDTEXTURE            *pMsg)
{
    __glim_BindTexture
        ( pMsg->target, pMsg->texture );
    
    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glCopyTexImage1D( __GLcontext *gc, IN GLMSG_COPYTEXIMAGE1D         *pMsg)
{
    __glim_CopyTexImage1D
        ( pMsg->target, pMsg->level, pMsg->internalformat, pMsg->x,
          pMsg->y, pMsg->width, pMsg->border);
    
    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glCopyTexImage2D( __GLcontext *gc, IN GLMSG_COPYTEXIMAGE2D         *pMsg)
{
    __glim_CopyTexImage2D
        ( pMsg->target, pMsg->level, pMsg->internalformat, pMsg->x,
          pMsg->y, pMsg->width, pMsg->height, pMsg->border);
    
    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glCopyTexSubImage1D( __GLcontext *gc, IN GLMSG_COPYTEXSUBIMAGE1D      *pMsg)
{
    __glim_CopyTexSubImage1D
        ( pMsg->target, pMsg->level, pMsg->xoffset, pMsg->x,
          pMsg->y, pMsg->width);
    
    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glCopyTexSubImage2D( __GLcontext *gc, IN GLMSG_COPYTEXSUBIMAGE2D      *pMsg)
{
    __glim_CopyTexSubImage2D
        ( pMsg->target, pMsg->level, pMsg->xoffset, pMsg->yoffset, pMsg->x,
          pMsg->y, pMsg->width, pMsg->height);
    
    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glDeleteTextures( __GLcontext *gc, IN GLMSG_DELETETEXTURES         *pMsg)
{
    __glim_DeleteTextures
        ( pMsg->n, pMsg->textures );
    
    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGenTextures( __GLcontext *gc, IN GLMSG_GENTEXTURES            *pMsg)
{
    __glim_GenTextures
        ( pMsg->n, pMsg->textures );
    
    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glIsTexture( __GLcontext *gc, IN GLMSG_ISTEXTURE              *pMsg)
{
    GLboolean retval;
    
    retval = __glim_IsTexture
        ( pMsg->texture );
    
    GLTEB_RETURNVALUE() = (ULONG)retval;
    
    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glPrioritizeTextures( __GLcontext *gc, IN GLMSG_PRIORITIZETEXTURES     *pMsg)
{
    __glim_PrioritizeTextures
        ( pMsg->n, pMsg->textures, pMsg->priorities );
    
    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glTexSubImage1D( __GLcontext *gc, IN GLMSG_TEXSUBIMAGE1D          *pMsg)
{
    __glim_TexSubImage1D
        (pMsg->target, pMsg->level, pMsg->xoffset, pMsg->width,
         pMsg->format, pMsg->type,
#ifdef NT
         (const GLvoid *)pMsg->pixelsOff, pMsg->_IsDlist);
#else
         (const GLvoid *)pMsg->pixelsOff);
#endif
    
    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glTexSubImage2D( __GLcontext *gc, IN GLMSG_TEXSUBIMAGE2D          *pMsg)
{
    __glim_TexSubImage2D
        (pMsg->target, pMsg->level, pMsg->xoffset, pMsg->yoffset, pMsg->width,
         pMsg->height, pMsg->format, pMsg->type,
#ifdef NT
         (const GLvoid *)pMsg->pixelsOff, pMsg->_IsDlist);
#else
         (const GLvoid *)pMsg->pixelsOff);
#endif
    
    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glColorTableEXT( __GLcontext *gc, IN GLMSG_COLORTABLEEXT          *pMsg)
{
    __glim_ColorTableEXT
        (pMsg->target, pMsg->internalFormat, pMsg->width, pMsg->format, pMsg->type,
         pMsg->data, pMsg->_IsDlist);
    
    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glColorSubTableEXT( __GLcontext *gc, IN GLMSG_COLORSUBTABLEEXT    *pMsg)
{
    __glim_ColorSubTableEXT
        (pMsg->target, pMsg->start, pMsg->count, pMsg->format, pMsg->type,
         pMsg->data, pMsg->_IsDlist);
    
    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetColorTableEXT( __GLcontext *gc, IN GLMSG_GETCOLORTABLEEXT          *pMsg)
{
    __glim_GetColorTableEXT
        (pMsg->target, pMsg->format, pMsg->type, pMsg->data);
    
    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetColorTableParameterivEXT( __GLcontext *gc, IN GLMSG_GETCOLORTABLEPARAMETERIVEXT          *pMsg)
{
    __glim_GetColorTableParameterivEXT
        (pMsg->target, pMsg->pname, pMsg->params);
    
    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glGetColorTableParameterfvEXT( __GLcontext *gc, IN GLMSG_GETCOLORTABLEPARAMETERFVEXT          *pMsg)
{
    __glim_GetColorTableParameterfvEXT
        (pMsg->target, pMsg->pname, pMsg->params);
    
    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glPolygonOffset( __GLcontext *gc, IN GLMSG_POLYGONOFFSET          *pMsg)
{
    __glim_PolygonOffset
        (pMsg->factor, pMsg->units);
    
    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

#ifdef GL_WIN_multiple_textures
VOID * FASTCALL
sbs_glCurrentTextureIndexWIN( __GLcontext *gc, IN GLMSG_CURRENTTEXTUREINDEXWIN *pMsg)
{
    __glim_CurrentTextureIndexWIN
        (pMsg->index);

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glBindNthTextureWIN( __GLcontext *gc, IN GLMSG_BINDNTHTEXTUREWIN *pMsg)
{
    __glim_BindNthTextureWIN
        (pMsg->index, pMsg->target, pMsg->texture);

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}

VOID * FASTCALL
sbs_glNthTexCombineFuncWIN( __GLcontext *gc, IN GLMSG_NTHTEXCOMBINEFUNCWIN *pMsg)
{
    __glim_NthTexCombineFuncWIN
        (pMsg->index, pMsg->leftColorFactor, pMsg->colorOp,
         pMsg->rightColorFactor, pMsg->leftAlphaFactor,
         pMsg->alphaOp, pMsg->rightAlphaFactor);

    return ( (BYTE *)pMsg + GLMSG_ALIGN(sizeof(*pMsg)) );
}
#endif // GL_WIN_multiple_textures
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\wgl\srvsize.h ===
#ifndef __SRVSIZE_H__
#define __SRVSIZE_H__

#ifndef _CLIENTSIDE_
GLint __glReadPixels_size ( GLenum format, GLenum type, GLint w, GLint h);
GLint __glGetTexImage_size ( GLenum target, GLint  level, GLenum format, GLenum type );
GLint __glDrawPixels_size ( GLenum Format, GLenum Type, GLint Width, GLint Height );
GLint __glTexImage_size ( GLint Level, GLint Components, GLsizei Width, GLsizei Height, GLint Border, GLenum Format, GLenum Type );
#endif

#endif /* !__SRVSIZE_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\wgl\glsrvsb.h ===
/*
** Copyright 1991-1993, Silicon Graphics, Inc.
** All Rights Reserved.
** 
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
** 
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/


/*
 * AUTOMATICALLY UPDATED OR GENERATED BY SGI: DO NOT EDIT
 * IF YOU MUST MODIFY THIS FILE, PLEASE CONTACT ptar@sgi.com 415-390-1483
 */

#ifndef __GLSRVSB_H__
#define __GLSRVSB_H__

/* Server Side SubBatch Prototypes */


/* gl Entry points */

VOID * FASTCALL sbs_glDrawPolyArray          ( __GLcontext *gc, IN GLMSG_DRAWPOLYARRAY *pMsg );
VOID * FASTCALL sbs_glBitmap                 ( __GLcontext *gc, IN GLMSG_BITMAP *pMsg );
VOID * FASTCALL sbs_glColor4fv               ( __GLcontext *gc, IN GLMSG_COLOR4FV *pMsg );
VOID * FASTCALL sbs_glEdgeFlag               ( __GLcontext *gc, IN GLMSG_EDGEFLAG *pMsg );
VOID * FASTCALL sbs_glIndexf                 ( __GLcontext *gc, IN GLMSG_INDEXF *pMsg );
VOID * FASTCALL sbs_glNormal3fv              ( __GLcontext *gc, IN GLMSG_NORMAL3FV *pMsg );
VOID * FASTCALL sbs_glRasterPos4fv           ( __GLcontext *gc, IN GLMSG_RASTERPOS4FV *pMsg );
VOID * FASTCALL sbs_glTexCoord4fv            ( __GLcontext *gc, IN GLMSG_TEXCOORD4FV *pMsg );
VOID * FASTCALL sbs_glClipPlane              ( __GLcontext *gc, IN GLMSG_CLIPPLANE *pMsg );
VOID * FASTCALL sbs_glColorMaterial          ( __GLcontext *gc, IN GLMSG_COLORMATERIAL *pMsg );
VOID * FASTCALL sbs_glCullFace               ( __GLcontext *gc, IN GLMSG_CULLFACE *pMsg );
VOID * FASTCALL sbs_glFogfv                  ( __GLcontext *gc, IN GLMSG_FOGFV *pMsg );
VOID * FASTCALL sbs_glFrontFace              ( __GLcontext *gc, IN GLMSG_FRONTFACE *pMsg );
VOID * FASTCALL sbs_glHint                   ( __GLcontext *gc, IN GLMSG_HINT *pMsg );
VOID * FASTCALL sbs_glLightfv                ( __GLcontext *gc, IN GLMSG_LIGHTFV *pMsg );
VOID * FASTCALL sbs_glLightModelfv           ( __GLcontext *gc, IN GLMSG_LIGHTMODELFV *pMsg );
VOID * FASTCALL sbs_glLineStipple            ( __GLcontext *gc, IN GLMSG_LINESTIPPLE *pMsg );
VOID * FASTCALL sbs_glLineWidth              ( __GLcontext *gc, IN GLMSG_LINEWIDTH *pMsg );
VOID * FASTCALL sbs_glMaterialfv             ( __GLcontext *gc, IN GLMSG_MATERIALFV *pMsg );
VOID * FASTCALL sbs_glPointSize              ( __GLcontext *gc, IN GLMSG_POINTSIZE *pMsg );
VOID * FASTCALL sbs_glPolygonMode            ( __GLcontext *gc, IN GLMSG_POLYGONMODE *pMsg );
VOID * FASTCALL sbs_glPolygonStipple         ( __GLcontext *gc, IN GLMSG_POLYGONSTIPPLE *pMsg );
VOID * FASTCALL sbs_glScissor                ( __GLcontext *gc, IN GLMSG_SCISSOR *pMsg );
VOID * FASTCALL sbs_glShadeModel             ( __GLcontext *gc, IN GLMSG_SHADEMODEL *pMsg );
VOID * FASTCALL sbs_glTexParameterfv         ( __GLcontext *gc, IN GLMSG_TEXPARAMETERFV *pMsg );
VOID * FASTCALL sbs_glTexParameteriv         ( __GLcontext *gc, IN GLMSG_TEXPARAMETERIV *pMsg );
VOID * FASTCALL sbs_glTexImage1D             ( __GLcontext *gc, IN GLMSG_TEXIMAGE1D *pMsg );
VOID * FASTCALL sbs_glTexImage2D             ( __GLcontext *gc, IN GLMSG_TEXIMAGE2D *pMsg );
VOID * FASTCALL sbs_glTexEnvfv               ( __GLcontext *gc, IN GLMSG_TEXENVFV *pMsg );
VOID * FASTCALL sbs_glTexEnviv               ( __GLcontext *gc, IN GLMSG_TEXENVIV *pMsg );
VOID * FASTCALL sbs_glTexGenfv               ( __GLcontext *gc, IN GLMSG_TEXGENFV *pMsg );
VOID * FASTCALL sbs_glFeedbackBuffer         ( __GLcontext *gc, IN GLMSG_FEEDBACKBUFFER *pMsg );
VOID * FASTCALL sbs_glSelectBuffer           ( __GLcontext *gc, IN GLMSG_SELECTBUFFER *pMsg );
VOID * FASTCALL sbs_glRenderMode             ( __GLcontext *gc, IN GLMSG_RENDERMODE *pMsg );
VOID * FASTCALL sbs_glInitNames              ( __GLcontext *gc, IN GLMSG_INITNAMES *pMsg );
VOID * FASTCALL sbs_glLoadName               ( __GLcontext *gc, IN GLMSG_LOADNAME *pMsg );
VOID * FASTCALL sbs_glPassThrough            ( __GLcontext *gc, IN GLMSG_PASSTHROUGH *pMsg );
VOID * FASTCALL sbs_glPopName                ( __GLcontext *gc, IN GLMSG_POPNAME *pMsg );
VOID * FASTCALL sbs_glPushName               ( __GLcontext *gc, IN GLMSG_PUSHNAME *pMsg );
VOID * FASTCALL sbs_glDrawBuffer             ( __GLcontext *gc, IN GLMSG_DRAWBUFFER *pMsg );
VOID * FASTCALL sbs_glClear                  ( __GLcontext *gc, IN GLMSG_CLEAR *pMsg );
VOID * FASTCALL sbs_glClearAccum             ( __GLcontext *gc, IN GLMSG_CLEARACCUM *pMsg );
VOID * FASTCALL sbs_glClearIndex             ( __GLcontext *gc, IN GLMSG_CLEARINDEX *pMsg );
VOID * FASTCALL sbs_glClearColor             ( __GLcontext *gc, IN GLMSG_CLEARCOLOR *pMsg );
VOID * FASTCALL sbs_glClearStencil           ( __GLcontext *gc, IN GLMSG_CLEARSTENCIL *pMsg );
VOID * FASTCALL sbs_glClearDepth             ( __GLcontext *gc, IN GLMSG_CLEARDEPTH *pMsg );
VOID * FASTCALL sbs_glStencilMask            ( __GLcontext *gc, IN GLMSG_STENCILMASK *pMsg );
VOID * FASTCALL sbs_glColorMask              ( __GLcontext *gc, IN GLMSG_COLORMASK *pMsg );
VOID * FASTCALL sbs_glDepthMask              ( __GLcontext *gc, IN GLMSG_DEPTHMASK *pMsg );
VOID * FASTCALL sbs_glIndexMask              ( __GLcontext *gc, IN GLMSG_INDEXMASK *pMsg );
VOID * FASTCALL sbs_glAccum                  ( __GLcontext *gc, IN GLMSG_ACCUM *pMsg );
VOID * FASTCALL sbs_glDisable                ( __GLcontext *gc, IN GLMSG_DISABLE *pMsg );
VOID * FASTCALL sbs_glEnable                 ( __GLcontext *gc, IN GLMSG_ENABLE *pMsg );
VOID * FASTCALL sbs_glPopAttrib              ( __GLcontext *gc, IN GLMSG_POPATTRIB *pMsg );
VOID * FASTCALL sbs_glPushAttrib             ( __GLcontext *gc, IN GLMSG_PUSHATTRIB *pMsg );
VOID * FASTCALL sbs_glAlphaFunc              ( __GLcontext *gc, IN GLMSG_ALPHAFUNC *pMsg );
VOID * FASTCALL sbs_glBlendFunc              ( __GLcontext *gc, IN GLMSG_BLENDFUNC *pMsg );
VOID * FASTCALL sbs_glLogicOp                ( __GLcontext *gc, IN GLMSG_LOGICOP *pMsg );
VOID * FASTCALL sbs_glStencilFunc            ( __GLcontext *gc, IN GLMSG_STENCILFUNC *pMsg );
VOID * FASTCALL sbs_glStencilOp              ( __GLcontext *gc, IN GLMSG_STENCILOP *pMsg );
VOID * FASTCALL sbs_glDepthFunc              ( __GLcontext *gc, IN GLMSG_DEPTHFUNC *pMsg );
VOID * FASTCALL sbs_glPixelZoom              ( __GLcontext *gc, IN GLMSG_PIXELZOOM *pMsg );
VOID * FASTCALL sbs_glPixelTransferf         ( __GLcontext *gc, IN GLMSG_PIXELTRANSFERF *pMsg );
VOID * FASTCALL sbs_glPixelTransferi         ( __GLcontext *gc, IN GLMSG_PIXELTRANSFERI *pMsg );
VOID * FASTCALL sbs_glPixelStoref            ( __GLcontext *gc, IN GLMSG_PIXELSTOREF *pMsg );
VOID * FASTCALL sbs_glPixelStorei            ( __GLcontext *gc, IN GLMSG_PIXELSTOREI *pMsg );
VOID * FASTCALL sbs_glPixelMapfv             ( __GLcontext *gc, IN GLMSG_PIXELMAPFV *pMsg );
VOID * FASTCALL sbs_glPixelMapuiv            ( __GLcontext *gc, IN GLMSG_PIXELMAPUIV *pMsg );
VOID * FASTCALL sbs_glPixelMapusv            ( __GLcontext *gc, IN GLMSG_PIXELMAPUSV *pMsg );
VOID * FASTCALL sbs_glReadBuffer             ( __GLcontext *gc, IN GLMSG_READBUFFER *pMsg );
VOID * FASTCALL sbs_glCopyPixels             ( __GLcontext *gc, IN GLMSG_COPYPIXELS *pMsg );
VOID * FASTCALL sbs_glReadPixels             ( __GLcontext *gc, IN GLMSG_READPIXELS *pMsg );
VOID * FASTCALL sbs_glDrawPixels             ( __GLcontext *gc, IN GLMSG_DRAWPIXELS *pMsg );
VOID * FASTCALL sbs_glGetBooleanv            ( __GLcontext *gc, IN GLMSG_GETBOOLEANV *pMsg );
VOID * FASTCALL sbs_glGetClipPlane           ( __GLcontext *gc, IN GLMSG_GETCLIPPLANE *pMsg );
VOID * FASTCALL sbs_glGetDoublev             ( __GLcontext *gc, IN GLMSG_GETDOUBLEV *pMsg );
VOID * FASTCALL sbs_glGetError               ( __GLcontext *gc, IN GLMSG_GETERROR *pMsg );
VOID * FASTCALL sbs_glGetFloatv              ( __GLcontext *gc, IN GLMSG_GETFLOATV *pMsg );
VOID * FASTCALL sbs_glGetIntegerv            ( __GLcontext *gc, IN GLMSG_GETINTEGERV *pMsg );
VOID * FASTCALL sbs_glGetLightfv             ( __GLcontext *gc, IN GLMSG_GETLIGHTFV *pMsg );
VOID * FASTCALL sbs_glGetLightiv             ( __GLcontext *gc, IN GLMSG_GETLIGHTIV *pMsg );
VOID * FASTCALL sbs_glGetMapdv               ( __GLcontext *gc, IN GLMSG_GETMAPDV *pMsg );
VOID * FASTCALL sbs_glGetMapfv               ( __GLcontext *gc, IN GLMSG_GETMAPFV *pMsg );
VOID * FASTCALL sbs_glGetMapiv               ( __GLcontext *gc, IN GLMSG_GETMAPIV *pMsg );
VOID * FASTCALL sbs_glGetMaterialfv          ( __GLcontext *gc, IN GLMSG_GETMATERIALFV *pMsg );
VOID * FASTCALL sbs_glGetMaterialiv          ( __GLcontext *gc, IN GLMSG_GETMATERIALIV *pMsg );
VOID * FASTCALL sbs_glGetPixelMapfv          ( __GLcontext *gc, IN GLMSG_GETPIXELMAPFV *pMsg );
VOID * FASTCALL sbs_glGetPixelMapuiv         ( __GLcontext *gc, IN GLMSG_GETPIXELMAPUIV *pMsg );
VOID * FASTCALL sbs_glGetPixelMapusv         ( __GLcontext *gc, IN GLMSG_GETPIXELMAPUSV *pMsg );
VOID * FASTCALL sbs_glGetPolygonStipple      ( __GLcontext *gc, IN GLMSG_GETPOLYGONSTIPPLE *pMsg );
VOID * FASTCALL sbs_glGetTexEnvfv            ( __GLcontext *gc, IN GLMSG_GETTEXENVFV *pMsg );
VOID * FASTCALL sbs_glGetTexEnviv            ( __GLcontext *gc, IN GLMSG_GETTEXENVIV *pMsg );
VOID * FASTCALL sbs_glGetTexGendv            ( __GLcontext *gc, IN GLMSG_GETTEXGENDV *pMsg );
VOID * FASTCALL sbs_glGetTexGenfv            ( __GLcontext *gc, IN GLMSG_GETTEXGENFV *pMsg );
VOID * FASTCALL sbs_glGetTexGeniv            ( __GLcontext *gc, IN GLMSG_GETTEXGENIV *pMsg );
VOID * FASTCALL sbs_glGetTexImage            ( __GLcontext *gc, IN GLMSG_GETTEXIMAGE *pMsg );
VOID * FASTCALL sbs_glGetTexParameterfv      ( __GLcontext *gc, IN GLMSG_GETTEXPARAMETERFV *pMsg );
VOID * FASTCALL sbs_glGetTexParameteriv      ( __GLcontext *gc, IN GLMSG_GETTEXPARAMETERIV *pMsg );
VOID * FASTCALL sbs_glGetTexLevelParameterfv ( __GLcontext *gc, IN GLMSG_GETTEXLEVELPARAMETERFV *pMsg );
VOID * FASTCALL sbs_glGetTexLevelParameteriv ( __GLcontext *gc, IN GLMSG_GETTEXLEVELPARAMETERIV *pMsg );
VOID * FASTCALL sbs_glIsEnabled              ( __GLcontext *gc, IN GLMSG_ISENABLED *pMsg );
VOID * FASTCALL sbs_glDepthRange             ( __GLcontext *gc, IN GLMSG_DEPTHRANGE *pMsg );
VOID * FASTCALL sbs_glFrustum                ( __GLcontext *gc, IN GLMSG_FRUSTUM *pMsg );
VOID * FASTCALL sbs_glLoadIdentity           ( __GLcontext *gc, IN GLMSG_LOADIDENTITY *pMsg );
VOID * FASTCALL sbs_glLoadMatrixf            ( __GLcontext *gc, IN GLMSG_LOADMATRIXF *pMsg );
VOID * FASTCALL sbs_glMatrixMode             ( __GLcontext *gc, IN GLMSG_MATRIXMODE *pMsg );
VOID * FASTCALL sbs_glMultMatrixf            ( __GLcontext *gc, IN GLMSG_MULTMATRIXF *pMsg );
VOID * FASTCALL sbs_glOrtho                  ( __GLcontext *gc, IN GLMSG_ORTHO *pMsg );
VOID * FASTCALL sbs_glPopMatrix              ( __GLcontext *gc, IN GLMSG_POPMATRIX *pMsg );
VOID * FASTCALL sbs_glPushMatrix             ( __GLcontext *gc, IN GLMSG_PUSHMATRIX *pMsg );
VOID * FASTCALL sbs_glRotatef                ( __GLcontext *gc, IN GLMSG_ROTATEF *pMsg );
VOID * FASTCALL sbs_glScalef                 ( __GLcontext *gc, IN GLMSG_SCALEF *pMsg );
VOID * FASTCALL sbs_glTranslatef             ( __GLcontext *gc, IN GLMSG_TRANSLATEF *pMsg );
VOID * FASTCALL sbs_glViewport               ( __GLcontext *gc, IN GLMSG_VIEWPORT *pMsg );
VOID * FASTCALL sbs_glAddSwapHintRectWIN     ( __GLcontext *gc, IN GLMSG_ADDSWAPHINTRECTWIN *pMsg );
VOID * FASTCALL sbs_glAreTexturesResident    ( __GLcontext *gc, IN GLMSG_ARETEXTURESRESIDENT    *pMsg);
VOID * FASTCALL sbs_glBindTexture            ( __GLcontext *gc, IN GLMSG_BINDTEXTURE            *pMsg);
VOID * FASTCALL sbs_glCopyTexImage1D         ( __GLcontext *gc, IN GLMSG_COPYTEXIMAGE1D         *pMsg);
VOID * FASTCALL sbs_glCopyTexImage2D         ( __GLcontext *gc, IN GLMSG_COPYTEXIMAGE2D         *pMsg);
VOID * FASTCALL sbs_glCopyTexSubImage1D      ( __GLcontext *gc, IN GLMSG_COPYTEXSUBIMAGE1D      *pMsg);
VOID * FASTCALL sbs_glCopyTexSubImage2D      ( __GLcontext *gc, IN GLMSG_COPYTEXSUBIMAGE2D      *pMsg);
VOID * FASTCALL sbs_glDeleteTextures         ( __GLcontext *gc, IN GLMSG_DELETETEXTURES         *pMsg);
VOID * FASTCALL sbs_glGenTextures            ( __GLcontext *gc, IN GLMSG_GENTEXTURES            *pMsg);
VOID * FASTCALL sbs_glIsTexture              ( __GLcontext *gc, IN GLMSG_ISTEXTURE              *pMsg);
VOID * FASTCALL sbs_glPrioritizeTextures     ( __GLcontext *gc, IN GLMSG_PRIORITIZETEXTURES     *pMsg);
VOID * FASTCALL sbs_glTexSubImage1D          ( __GLcontext *gc, IN GLMSG_TEXSUBIMAGE1D          *pMsg);
VOID * FASTCALL sbs_glTexSubImage2D          ( __GLcontext *gc, IN GLMSG_TEXSUBIMAGE2D          *pMsg);
VOID * FASTCALL sbs_glColorTableEXT          ( __GLcontext *, IN GLMSG_COLORTABLEEXT          *pMsg);
VOID * FASTCALL sbs_glColorSubTableEXT       ( __GLcontext *, IN GLMSG_COLORSUBTABLEEXT       *pMsg);
VOID * FASTCALL sbs_glGetColorTableEXT       ( __GLcontext *, IN GLMSG_GETCOLORTABLEEXT       *pMsg);
VOID * FASTCALL sbs_glGetColorTableParameterivEXT( __GLcontext *, IN GLMSG_GETCOLORTABLEPARAMETERIVEXT *pMsg);
VOID * FASTCALL sbs_glGetColorTableParameterfvEXT( __GLcontext *, IN GLMSG_GETCOLORTABLEPARAMETERFVEXT *pMsg);
VOID * FASTCALL sbs_glPolygonOffset          ( __GLcontext *gc, IN GLMSG_POLYGONOFFSET          *pMsg);
#ifdef GL_WIN_multiple_textures
VOID * FASTCALL sbs_glCurrentTextureIndexWIN ( __GLcontext *gc, IN GLMSG_CURRENTTEXTUREINDEXWIN *pMsg);
VOID * FASTCALL sbs_glBindNthTextureWIN      ( __GLcontext *gc, IN GLMSG_BINDNTHTEXTUREWIN *pMsg);
VOID * FASTCALL sbs_glNthTexCombineFuncWIN   ( __GLcontext *gc, IN GLMSG_NTHTEXCOMBINEFUNCWIN *pMsg);
#endif // GL_WIN_multiple_textures

#endif /* __GLSRVSB_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\wgl\driver.c ===
/*
** Copyright 1991, 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "precomp.h"
#pragma hdrstop

#include <ntcsrdll.h>   // CSR declarations and data structures.

// #define DETECT_FPE
#ifdef DETECT_FPE
#include <float.h>
#endif

#include "glsbmsg.h"
#include "glsbmsgh.h"
#include "glsrvspt.h"
#include "devlock.h"
#include "global.h"

#include "glscreen.h"

typedef VOID * (FASTCALL *SERVERPROC)(__GLcontext *, IN VOID *);

#define LASTPROCOFFSET(ProcTable)   (sizeof(ProcTable) - sizeof(SERVERPROC))

extern GLSRVSBPROCTABLE glSrvSbProcTable;
#if DBG
char *glSrvSbStringTable[] = {

    NULL,  /* Make First Entry NULL */

/* gl Entry points */

     "glDrawPolyArray          ",
     "glBitmap                 ",
     "glColor4fv               ",
     "glEdgeFlag               ",
     "glIndexf                 ",
     "glNormal3fv              ",
     "glRasterPos4fv           ",
     "glTexCoord4fv            ",
     "glClipPlane              ",
     "glColorMaterial          ",
     "glCullFace               ",
     "glAddSwapHintRectWIN     ",
     "glFogfv                  ",
     "glFrontFace              ",
     "glHint                   ",
     "glLightfv                ",
     "glLightModelfv           ",
     "glLineStipple            ",
     "glLineWidth              ",
     "glMaterialfv             ",
     "glPointSize              ",
     "glPolygonMode            ",
     "glPolygonStipple         ",
     "glScissor                ",
     "glShadeModel             ",
     "glTexParameterfv         ",
     "glTexParameteriv         ",
     "glTexImage1D             ",
     "glTexImage2D             ",
     "glTexEnvfv               ",
     "glTexEnviv               ",
     "glTexGenfv               ",
     "glFeedbackBuffer         ",
     "glSelectBuffer           ",
     "glRenderMode             ",
     "glInitNames              ",
     "glLoadName               ",
     "glPassThrough            ",
     "glPopName                ",
     "glPushName               ",
     "glDrawBuffer             ",
     "glClear                  ",
     "glClearAccum             ",
     "glClearIndex             ",
     "glClearColor             ",
     "glClearStencil           ",
     "glClearDepth             ",
     "glStencilMask            ",
     "glColorMask              ",
     "glDepthMask              ",
     "glIndexMask              ",
     "glAccum                  ",
     "glDisable                ",
     "glEnable                 ",
     "glPopAttrib              ",
     "glPushAttrib             ",
     "glMap1d                  ",
     "glMap1f                  ",
     "glMap2d                  ",
     "glMap2f                  ",
     "glMapGrid1f              ",
     "glMapGrid2f              ",
     "glAlphaFunc              ",
     "glBlendFunc              ",
     "glLogicOp                ",
     "glStencilFunc            ",
     "glStencilOp              ",
     "glDepthFunc              ",
     "glPixelZoom              ",
     "glPixelTransferf         ",
     "glPixelTransferi         ",
     "glPixelStoref            ",
     "glPixelStorei            ",
     "glPixelMapfv             ",
     "glPixelMapuiv            ",
     "glPixelMapusv            ",
     "glReadBuffer             ",
     "glCopyPixels             ",
     "glReadPixels             ",
     "glDrawPixels             ",
     "glGetBooleanv            ",
     "glGetClipPlane           ",
     "glGetDoublev             ",
     "glGetError               ",
     "glGetFloatv              ",
     "glGetIntegerv            ",
     "glGetLightfv             ",
     "glGetLightiv             ",
     "glGetMapdv               ",
     "glGetMapfv               ",
     "glGetMapiv               ",
     "glGetMaterialfv          ",
     "glGetMaterialiv          ",
     "glGetPixelMapfv          ",
     "glGetPixelMapuiv         ",
     "glGetPixelMapusv         ",
     "glGetPolygonStipple      ",
     "glGetTexEnvfv            ",
     "glGetTexEnviv            ",
     "glGetTexGendv            ",
     "glGetTexGenfv            ",
     "glGetTexGeniv            ",
     "glGetTexImage            ",
     "glGetTexParameterfv      ",
     "glGetTexParameteriv      ",
     "glGetTexLevelParameterfv ",
     "glGetTexLevelParameteriv ",
     "glIsEnabled              ",
     "glDepthRange             ",
     "glFrustum                ",
     "glLoadIdentity           ",
     "glLoadMatrixf            ",
     "glMatrixMode             ",
     "glMultMatrixf            ",
     "glOrtho                  ",
     "glPopMatrix              ",
     "glPushMatrix             ",
     "glRotatef                ",
     "glScalef                 ",
     "glTranslatef             ",
     "glViewport               ",
     "glAreTexturesResident    ",
     "glBindTexture            ",
     "glCopyTexImage1D         ",
     "glCopyTexImage2D         ",
     "glCopyTexSubImage1D      ",
     "glCopyTexSubImage2D      ",
     "glDeleteTextures         ",
     "glGenTextures            ",
     "glIsTexture              ",
     "glPrioritizeTextures     ",
     "glTexSubImage1D          ",
     "glTexSubImage2D          ",
     "glColorTableEXT          ",
     "glColorSubTableEXT       ",
     "glGetColorTableEXT       ",
     "glGetColorTableParameterivEXT",
     "glGetColorTableParameterfvEXT",
     "glPolygonOffset          ",
#ifdef GL_WIN_multiple_textures
     "glCurrentTextureIndexWIN ",
     "glBindNthTextureWIN      ",
     "glNthTexCombineFuncWIN   ",
#endif // GL_WIN_multiple_textures

};
#endif

#ifdef DOGLMSGBATCHSTATS
#define STATS_INC_SERVERCALLS()     pMsgBatchInfo->BatchStats.ServerCalls++
#define STATS_INC_SERVERTRIPS()     (pMsgBatchInfo->BatchStats.ServerTrips++)
#else
#define STATS_INC_SERVERCALLS()
#define STATS_INC_SERVERTRIPS()
#endif

DWORD BATCH_LOCK_TICKMAX = 99;
DWORD TICK_RANGE_LO = 60;
DWORD TICK_RANGE_HI = 100;
DWORD gcmsOpenGLTimer;

// The GDISAVESTATE structure is used to save/restore DC drawing state
// that could affect OpenGL rasterization.

typedef struct _GDISAVESTATE {
    int iRop2;
} GDISAVESTATE;

void FASTCALL vSaveGdiState(HDC, GDISAVESTATE *);
void FASTCALL vRestoreGdiState(HDC, GDISAVESTATE *);

#if DBG
extern long glDebugLevel;
#endif


/***************************************************************************\
* CheckCritSectionIn
*
* This function asserts that the current thread owns the specified
* critical section.  If it doesn't it display some output on the debugging
* terminal and breaks into the debugger.  At some point we'll have RIPs
* and this will be a little less harsh.
*
* The function is used in code where global values that both the RIT and
* application threads access are used to verify they are protected via
* the raw input critical section.  There's a macro to use this function
* called CheckCritIn() which will be defined to nothing for a non-debug
* version of the system.
*
* History:
* 11-29-90 DavidPe      Created.
\***************************************************************************/

#if DBG

VOID APIENTRY CheckCritSectionIn(
    LPCRITICAL_SECTION pcs)
{
    //!!!dbug -- implement
    #if 0
    /*
     * If the current thread doesn't own this critical section,
     * that's bad.
     */
    if (NtCurrentTeb()->ClientId.UniqueThread != pcs->OwningThread)
    {
        RIP("CheckCritSectionIn: Not in critical section!");
    }
    #endif
}


VOID APIENTRY CheckCritSectionOut(
    LPCRITICAL_SECTION pcs)
{
    //!!!dbug -- implement
    #if 0
    /*
     * If the current thread owns this critical section, that's bad.
     */
    if (NtCurrentTeb()->ClientId.UniqueThread == pcs->OwningThread)
    {
        RIP("CheckCritSectionOut: In critical section!");
    }
    #endif
}

#endif

/******************************Public*Routine******************************\
* ResizeAlphaBufs
*
* Resize alpha buffers associated with the drawable.
*
* Returns:
*   No return value.
\**************************************************************************/

static void ResizeAlphaBufs(__GLcontext *gc, __GLGENbuffers *buffers,
                            GLint width, GLint height)
{
    __GLbuffer *common, *local;
    BOOL bSuccess;

    // front alpha buffer

    common = buffers->alphaFrontBuffer;
    // We are using the generic ancillary resize here...
    bSuccess = (*buffers->resize)(buffers, common, width, height);
    if( !bSuccess ) {
        __glSetError(GL_OUT_OF_MEMORY);
        return;
    }
    local = &gc->front->alphaBuf.buf;
    UpdateSharedBuffer( local, common );

    if ( gc->modes.doubleBufferMode) {
        // Handle back alpha buffer
        common = buffers->alphaBackBuffer;
        bSuccess = (*buffers->resize)(buffers, common, width, height);
        if( !bSuccess ) {
            __glSetError(GL_OUT_OF_MEMORY);
            return;
        }
        local = &gc->back->alphaBuf.buf;
        UpdateSharedBuffer( local, common );
    }
}

/******************************Public*Routine******************************\
* ResizeAncillaryBufs
*
* Resize each of the ancillary buffers associated with the drawable.
*
* Returns:
*   No return value.
\**************************************************************************/

static void ResizeAncillaryBufs(__GLcontext *gc, __GLGENbuffers *buffers,
                                GLint width, GLint height)
{
    __GLbuffer *common, *local;
    GLboolean forcePick = GL_FALSE;

    if (buffers->createdAccumBuffer)
    {
        common = &buffers->accumBuffer;
        local = &gc->accumBuffer.buf;
        gc->modes.haveAccumBuffer =
            (*buffers->resize)(buffers, common, width, height);

        UpdateSharedBuffer(local, common);
        if (!gc->modes.haveAccumBuffer)    // Lost the ancillary buffer
        {
            forcePick = GL_TRUE;
            __glSetError(GL_OUT_OF_MEMORY);
        }
    }

    if (buffers->createdDepthBuffer)
    {
        common = &buffers->depthBuffer;
        local = &gc->depthBuffer.buf;
        gc->modes.haveDepthBuffer =
            (*buffers->resizeDepth)(buffers, common, width, height);

        UpdateSharedBuffer(local, common);
        if (!gc->modes.haveDepthBuffer)    // Lost the ancillary buffer
        {
            forcePick = GL_TRUE;
            __glSetError(GL_OUT_OF_MEMORY);
        }
    }

    if (buffers->createdStencilBuffer)
    {
        common = &buffers->stencilBuffer;
        local = &gc->stencilBuffer.buf;
        gc->modes.haveStencilBuffer =
            (*buffers->resize)(buffers, common, width, height);

        UpdateSharedBuffer(local, common);
        if (!gc->modes.haveStencilBuffer)    // Lost the ancillary buffer
        {
            forcePick = GL_TRUE;
            gc->validateMask |= (__GL_VALIDATE_STENCIL_FUNC |
                                 __GL_VALIDATE_STENCIL_OP);
            __glSetError(GL_OUT_OF_MEMORY);
        }
    }
    if (forcePick)
    {
    // Cannot use DELAY_VALIDATE, may be in glBegin/End

        __GL_INVALIDATE(gc);
        (*gc->procs.validate)(gc);
    }
}

/******************************Public*Routine******************************\
* wglResizeBuffers
*
* Resize the back and ancillary buffers.
*
* History:
*  20-Apr-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID wglResizeBuffers(__GLGENcontext *gengc, GLint width, GLint height)
{
    __GLcontext *gc = &gengc->gc;
    GLGENwindow *pwnd;
    __GLGENbuffers *buffers;

    pwnd = gengc->pwndLocked;
    ASSERTOPENGL(pwnd, "wglResizeBuffers: bad window\n");

    buffers = pwnd->buffers;
    ASSERTOPENGL(buffers, "wglResizeBuffers: bad buffers\n");

    ASSERT_WINCRIT(pwnd);
    
// Resize back buffer.

    gengc->errorcode = 0;
    if ( gengc->pMcdState )
    {
    // If the shared buffer struct has not lost its MCD info and
    // the MCD buffers are still valid, we can use MCD.

        if ( !(buffers->flags & GLGENBUF_MCD_LOST) &&
             GenMcdResizeBuffers(gengc) )
        {
            UpdateSharedBuffer(&gc->backBuffer.buf, &buffers->backBuffer);
            if (gc->modes.doubleBufferMode)
                (*gc->back->resize)(buffers, gc->back, width, height);
        }
        else
        {
        // If GenMcdConvertContext succeeds, then pMcdState will
        // no longer exist.  The context is now an "ordinary"
        // generic context.

            if ( !GenMcdConvertContext(gengc, buffers) )
            {
            // Not only have we lost the MCD buffers, but we cannot
            // convert the context to generic.  For now, disable
            // drawing (by setting the window bounds to empty).  On
            // the next batch we will reattempt MCD buffer access
            // and context conversion.

                buffers->width       = 0;
                buffers->height      = 0;
                gc->constants.width  = 0;
                gc->constants.height = 0;

                (*gc->procs.applyViewport)(gc);
                return;
            }
            else
            {
                goto wglResizeBuffers_GenericBackBuf;
            }
        }
    }
    else
    {
wglResizeBuffers_GenericBackBuf:

        if ( gc->modes.doubleBufferMode )
        {
        // Have to update the back buffer BEFORE resizing because
        // another thread may have changed the shared back buffer
        // already, but this thread was unlucky enough to get yet
        // ANOTHER window resize.

            UpdateSharedBuffer(&gc->backBuffer.buf, &buffers->backBuffer);

            gengc->errorcode = 0;
            (*gc->back->resize)(buffers, gc->back, width, height);

        // If resize failed, set width & height to 0

            if ( gengc->errorcode )
            {
                gc->constants.width  = 0;
                gc->constants.height = 0;

            // Memory failure has occured.  But if a resize happens
            // that returns window size to size before memory error
            // occurred (i.e., consistent with original
            // buffers->{width|height}) we will not try to resize again.
            // Therefore, we need to set buffers->{width|height} to zero
            // to ensure that next thread will attempt to resize.

                buffers->width  = 0;
                buffers->height = 0;
            }
        }
        if ( gc->modes.alphaBits )
        {
            ResizeAlphaBufs( gc, buffers, width, height );
            if (gengc->errorcode)
                return;
        }

    }

    (*gc->procs.applyViewport)(gc);

// Check if new size caused a memory failure.
// The viewport code will set width & height to zero
// punt on ancillary buffers, will try next time.

    if (gengc->errorcode)
        return;

// Resize ancillary buffers (depth, stencil, accum).

    ResizeAncillaryBufs(gc, buffers, width, height);
}

/******************************Public*Routine******************************\
* wglUpdateBuffers
*
* The __GLGENbuffers structure contains the data specifying the shared
* buffers (back, depth, stencil, accum, etc.).
*
* This function updates the context with the shared buffer information.
*
* Returns:
*   TRUE if one of the existence of any of the buffers changes (i.e.,
*   gained or lost).  FALSE if the state is the same as before.
*
*   In other words, if function returns TRUE, the pick procs need to
*   be rerun because one or more of the buffers changed.
*
* History:
*  20-Apr-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL wglUpdateBuffers(__GLGENcontext *gengc, __GLGENbuffers *buffers)
{
    BOOL bRet = FALSE;
    __GLcontext *gc = &gengc->gc;

    UpdateSharedBuffer(&gc->backBuffer.buf, &buffers->backBuffer);
    UpdateSharedBuffer(&gc->accumBuffer.buf, &buffers->accumBuffer);
    UpdateSharedBuffer(&gc->depthBuffer.buf, &buffers->depthBuffer);
    UpdateSharedBuffer(&gc->stencilBuffer.buf, &buffers->stencilBuffer);
    if( gc->modes.alphaBits ) {
        UpdateSharedBuffer(&gc->frontBuffer.alphaBuf.buf, buffers->alphaFrontBuffer);
        if (gc->modes.doubleBufferMode)
            UpdateSharedBuffer(&gc->backBuffer.alphaBuf.buf, buffers->alphaBackBuffer);
    }

    (*gc->procs.applyViewport)(gc);

// Check if any ancillary buffers were lost or regained.

    if ( ( gc->modes.haveAccumBuffer && (buffers->accumBuffer.base == NULL)) ||
         (!gc->modes.haveAccumBuffer && (buffers->accumBuffer.base != NULL)) )
    {
        if ( buffers->accumBuffer.base == NULL )
            gc->modes.haveAccumBuffer = GL_FALSE;
        else
            gc->modes.haveAccumBuffer = GL_TRUE;
        bRet = TRUE;
    }
    if ( ( gc->modes.haveDepthBuffer && (buffers->depthBuffer.base == NULL)) ||
         (!gc->modes.haveDepthBuffer && (buffers->depthBuffer.base != NULL)) )
    {
        if ( buffers->depthBuffer.base == NULL )
            gc->modes.haveDepthBuffer = GL_FALSE;
        else
            gc->modes.haveDepthBuffer = GL_TRUE;
        bRet = TRUE;
    }
    if ( ( gc->modes.haveStencilBuffer && (buffers->stencilBuffer.base == NULL)) ||
         (!gc->modes.haveStencilBuffer && (buffers->stencilBuffer.base != NULL)) )
    {
        if ( buffers->stencilBuffer.base == NULL )
            gc->modes.haveStencilBuffer = GL_FALSE;
        else
            gc->modes.haveStencilBuffer = GL_TRUE;
        gc->validateMask |= (__GL_VALIDATE_STENCIL_FUNC |
                             __GL_VALIDATE_STENCIL_OP);
        bRet = TRUE;
    }

    return bRet;
}

/******************************Public*Routine******************************\
* UpdateWindowInfo
*
*  Update context data if window changed
*     position
*     size
*     palette
*
*  No need to worry about clipping changes.
*
* Returns:
*   No return value.
\**************************************************************************/

void UpdateWindowInfo(__GLGENcontext *gengc)
{
    GLGENwindow *pwnd;
    __GLGENbuffers *buffers;
    __GLcontext *gc = (__GLcontext *)gengc;
    GLint width, height, visWidth, visHeight;
    GLboolean forcePick = GL_FALSE;

    pwnd = gengc->pwndLocked;
    ASSERTOPENGL(pwnd, "UpdateWindowInfo(): bad window\n");
    buffers = pwnd->buffers;
    ASSERTOPENGL(buffers, "UpdateWindowInfo(): bad buffers\n");

    ASSERT_WINCRIT(pwnd);
    
// Memory DC case -- need to check bitmap size.  The DC is not bound to
// a window, so there is no message or visrgn watcher to inform us of size
// changes.

    if ( GLSURF_IS_MEMDC(gengc->dwCurrentFlags) )
    {
        DIBSECTION ds;
        int iRetVal;

        if ( iRetVal =
             GetObject(GetCurrentObject(gengc->gwidCurrent.hdc, OBJ_BITMAP),
                       sizeof(ds), &ds) )
        {
            ASSERTOPENGL(pwnd->rclClient.left == 0 &&
                         pwnd->rclClient.top == 0,
                         "UpdateWindowInfo(): bad rclClient for memDc\n");

        // Bitmap may have changed.  If DIB, force reload of base pointer and
        // outer width (buffer pitch).

            if ( (iRetVal == sizeof(ds)) && ds.dsBm.bmBits )
            {
            // For backwards compatibility with Get/SetBitmapBits, GDI does
            // not accurately report the bitmap pitch in bmWidthBytes.  It
            // always computes bmWidthBytes assuming WORD-aligned scanlines
            // regardless of the platform.
            //
            // Therefore, if the platform is WinNT, which uses DWORD-aligned
            // scanlines, adjust the bmWidthBytes value.

                if ( dwPlatformId == VER_PLATFORM_WIN32_NT )
                {
                    ds.dsBm.bmWidthBytes = (ds.dsBm.bmWidthBytes + 3) & ~3;
                }

            // If biHeight is positive, then the bitmap is a bottom-up DIB.
            // If biHeight is negative, then the bitmap is a top-down DIB.

                if ( ds.dsBmih.biHeight > 0 )
                {
                    gengc->gc.frontBuffer.buf.base = (PVOID) (((ULONG_PTR) ds.dsBm.bmBits) +
                        (ds.dsBm.bmWidthBytes * (ds.dsBm.bmHeight - 1)));
                    gengc->gc.frontBuffer.buf.outerWidth = -ds.dsBm.bmWidthBytes;
                }
                else
                {
                    gengc->gc.frontBuffer.buf.base = ds.dsBm.bmBits;
                    gengc->gc.frontBuffer.buf.outerWidth = ds.dsBm.bmWidthBytes;
                }
            }

        // Bitmap size different from window?

            if ( ds.dsBm.bmWidth != pwnd->rclClient.right ||
                 ds.dsBm.bmHeight != pwnd->rclClient.bottom )
            {
            // Save new size.

                pwnd->rclClient.right  = ds.dsBm.bmWidth;
                pwnd->rclClient.bottom = ds.dsBm.bmHeight;
                pwnd->rclBounds.right  = ds.dsBm.bmWidth;
                pwnd->rclBounds.bottom = ds.dsBm.bmHeight;

            // Increment uniqueness numbers.
            // Don't let it hit -1.  -1 is special and is used by
            // MakeCurrent to signal that an update is required

                buffers->WndUniq++;

                buffers->WndSizeUniq++;

                if (buffers->WndUniq == -1)
                    buffers->WndUniq = 0;

                if (buffers->WndSizeUniq == -1)
                    buffers->WndSizeUniq = 0;
            }
        }
        else
        {
            WARNING("UpdateWindowInfo: could not get bitmap info for memDc\n");
        }
    }

// Compute current window dimensions.

    width = pwnd->rclClient.right - pwnd->rclClient.left;
    height = pwnd->rclClient.bottom - pwnd->rclClient.top;

// Check MCD buffers.

    if ( gengc->pMcdState )
    {
        BOOL bAllocOK;

    // Do we need an initial MCDAllocBuffers (via GenMcdResizeBuffers)?
    // The bAllocOK flag will be set to FALSE if the resize fails.

        if ( gengc->pMcdState->mcdFlags & MCD_STATE_FORCERESIZE )
        {
        // Attempt resize.  If it fails, convert context (see below).

            if (GenMcdResizeBuffers(gengc))
            {
                UpdateSharedBuffer(&gc->backBuffer.buf, &buffers->backBuffer);
                if (gc->modes.doubleBufferMode)
                    (*gc->back->resize)(buffers, gc->back, width, height);

                bAllocOK = TRUE;
            }
            else
                bAllocOK = FALSE;

        // Clear the flag.  If resize succeeded, we don't need to
        // force the resize again.  If resize failed, the context
        // will be converted, so we don't need to force the resize.

            gengc->pMcdState->mcdFlags &= ~MCD_STATE_FORCERESIZE;
        }
        else
            bAllocOK = TRUE;

    // If the shared buffer struct has lost its MCD info or we could
    // not do the initial allocate, convert the context.

        if ( (buffers->flags & GLGENBUF_MCD_LOST) || !bAllocOK )
        {
        // If GenMcdConvertContext succeeds, then pMcdState will
        // no longer exist.  The context is now an "ordinary"
        // generic context.

            if ( !GenMcdConvertContext(gengc, buffers) )
            {
            // Not only have we lost the MCD buffers, but we cannot
            // convert the context to generic.  For now, disable
            // drawing (by setting the window bounds to empty).  On
            // the next batch we will reattempt MCD buffer access
            // and context conversion.

                buffers->width       = 0;
                buffers->height      = 0;
                gc->constants.width  = 0;
                gc->constants.height = 0;

                (*gc->procs.applyViewport)(gc);
                return;
            }
        }
    }

// Check the uniqueness signature.  If different, the window client area
// state has changed.
//
// Note that we actually have two uniqueness numbers, WndUniq and WndSizeUniq.
// WndUniq is incremented whenever any client window state (size or position)
// changes.  WndSizeUniq is incremented only when the size changes and is
// maintained as an optimization.  WndSizeUniq allows us to skip copying
// the shared buffer info and recomputing the viewport if only the position
// has changed.
//
// WndSizeUniq is a subset of WndUniq, so checking only WndUniq suffices at
// this level.

    if ( gengc->WndUniq != buffers->WndUniq )
    {
    // Update origin of front buffer in case it moved

        gc->frontBuffer.buf.xOrigin = pwnd->rclClient.left;
        gc->frontBuffer.buf.yOrigin = pwnd->rclClient.top;

    // If acceleration is wired-in, set the offsets for line drawing.

        if ( gengc->pPrivateArea )
        {
            __fastLineComputeOffsets(gengc);
        }

    // Check for size changed
    // Update viewport and ancillary buffers

        visWidth  = pwnd->rclBounds.right - pwnd->rclBounds.left;
        visHeight = pwnd->rclBounds.bottom - pwnd->rclBounds.top;

    // Sanity check the info from window.

        ASSERTOPENGL(
            width <= __GL_MAX_WINDOW_WIDTH && height <= __GL_MAX_WINDOW_HEIGHT,
            "UpdateWindowInfo(): bad window client size\n"
            );
        ASSERTOPENGL(
            visWidth <= __GL_MAX_WINDOW_WIDTH && visHeight <= __GL_MAX_WINDOW_HEIGHT,
            "UpdateWindowInfo(): bad visible size\n"
            );

        (*gc->front->resize)(buffers, gc->front, width, height);

        if ( (width != buffers->width) ||
             (height != buffers->height) )
        {
            gc->constants.width = width;
            gc->constants.height = height;

        // This RC needs to resize back & ancillary buffers

            gengc->errorcode = 0;
            wglResizeBuffers(gengc, width, height);

        // Check if new size caused a memory failure
        // viewport code will set width & height to zero
        // punt on ancillary buffers, will try next time

            if (gengc->errorcode)
                return;

            buffers->width = width;
            buffers->height = height;
        }
        else if ( (gengc->WndSizeUniq != buffers->WndSizeUniq) ||
                  (width != gc->constants.width) ||
                  (height != gc->constants.height) )
        {
        // The buffer size is consistent with the window, so another thread
        // has already resized the buffer, but we need to update the
        // gc shared buffers and recompute the viewport.

            gc->constants.width = width;
            gc->constants.height = height;

            forcePick = (GLboolean)wglUpdateBuffers(gengc, buffers);

            if ( forcePick )
            {
                /* Cannot use DELAY_VALIDATE, may be in glBegin/End */
                __GL_INVALIDATE(gc);
                (*gc->procs.validate)(gc);
            }
        }
        else if ( (visWidth != gengc->visibleWidth) ||
                  (visHeight != gengc->visibleHeight) )
        {
        // The buffer size has not changed.  However, the visibility of
        // the window has changed so the viewport data must be recomputed.

            (*gc->procs.applyViewport)(gc);
        }

    // Make sure we swap the whole window

        buffers->fMax = TRUE;

    // The context is now up-to-date with the buffer size.  Set the
    // uniqueness numbers to match.

        gengc->WndUniq = buffers->WndUniq;
        gengc->WndSizeUniq = buffers->WndSizeUniq;
    }

// Update palette info is palette has changed

    HandlePaletteChanges(gengc, pwnd);
}

/******************************Public*Routine******************************\
* vSaveGdiState
*
* Saves current GDI drawing state to the GDISAVESTATE structure passed in.
* Sets GDI state needed for OpenGL rendering.
*
* History:
*  19-Jul-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void FASTCALL vSaveGdiState(HDC hdc, GDISAVESTATE *pGdiState)
{
// Currently, the only state needed is the line code which may use
// GDI lines.  Rop2 must be R2_COPYPEN (draws with the pen color).

    pGdiState->iRop2 = SetROP2(hdc, R2_COPYPEN);
}

/******************************Public*Routine******************************\
* vRestoreGdiState
*
* Restores GDI drawing state from the GDISAVESTATE structure passed in.
*
* History:
*  19-Jul-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void FASTCALL vRestoreGdiState(HDC hdc, GDISAVESTATE *pGdiState)
{
    SetROP2(hdc, pGdiState->iRop2);
}

/******************************Public*Routine******************************\
*
* glsrvSynchronizeWithGdi
*
* Synchronizes access to a locked surface with GDI
* This allows GDI calls to be made safely even on a locked surface
* so that we don't have to release the lock we're holding
*
* Win95 doesn't allow this so it just releases the screen lock
*
* History:
*  Wed Aug 28 11:10:27 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

#ifdef WINNT
void APIENTRY glsrvSynchronizeWithGdi(__GLGENcontext *gengc,
                                      GLGENwindow *pwnd,
                                      FSHORT surfBits)
{
    // Nothing to do
}
#else
void APIENTRY glsrvSynchronizeWithGdi(__GLGENcontext *gengc,
                                      GLGENwindow *pwnd,
                                      FSHORT surfBits)
{
    glsrvReleaseSurfaces(gengc, pwnd, surfBits);
}
#endif

/******************************Public*Routine******************************\
*
* glsrvDecoupleFromGdi
*
* Indicates that it's no longer necessary to have GDI access to a surface
* synchronized with direct memory access
*
* Exists for Win95 where synchronization isn't done so the screen lock
* must be reacquired
*
* History:
*  Wed Aug 28 11:12:50 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

#ifdef WINNT
void APIENTRY glsrvDecoupleFromGdi(__GLGENcontext *gengc,
                                   GLGENwindow *pwnd,
                                   FSHORT surfBits)
{
    GdiFlush();

    // Consider - How can this code be made surface specific?  Right now
    // surfBits is ignored.
    
    // Wait for any GDI accelerator operations to complete before we
    // return to direct access
    if (gengc->pgddsFront != NULL)
    {
        // Is there a better way to do this than looping?
        //          Does ISBLTDONE cover all the cases we need to wait for?
        for (;;)
        {
            if (gengc->pgddsFront->pdds->lpVtbl->
                GetBltStatus(gengc->pgddsFront->pdds,
                             DDGBS_ISBLTDONE) != DDERR_WASSTILLDRAWING)
            {
                break;
            }

            Sleep(20);
        }
    }
}
#else
void APIENTRY glsrvDecoupleFromGdi(__GLGENcontext *gengc,
                                   GLGENwindow *pwnd,
                                   FSHORT surfBits)
{
    // Failure is unhandled
    glsrvGrabSurfaces(gengc, pwnd, surfBits);
}
#endif

/******************************Public*Routine******************************\
*
* LockDdSurf
*
* Locks a GLDDSURF, handling surface loss
*
* History:
*  Wed Aug 28 15:32:08 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

#define LDDS_LOCKED             0
#define LDDS_LOCKED_NEW         1
#define LDDS_ERROR              2

// #define VERBOSE_LOCKDDSURF

DWORD LockDdSurf(GLDDSURF *pgdds, RECT *prcClient)
{
    HRESULT hr;
    LPDIRECTDRAWSURFACE pdds;
    DWORD dwRet;

    pdds = pgdds->pdds;
    dwRet = LDDS_LOCKED;
    
    hr = DDSLOCK(pdds, &pgdds->ddsd, DDLOCK_SURFACEMEMORYPTR | DDLOCK_WAIT, prcClient);
#ifdef VERBOSE_LOCKDDSURF
    if (hr != DD_OK)
    {
	DbgPrint("LockDdSurf: Lock failed with 0x%08lX\n", hr);
    }
#endif
    
// If lock failed because of a resolution change, try to recreate
// the primary surface.  We can only do this if the surface is the
// screen surface because for app-provided DDraw surfaces we don't
// know what content needs to be recreated on the lost surface before
// it can be reused.

    if ( hr == DDERR_SURFACELOST &&
	 pgdds == &GLSCREENINFO->gdds )
    {
        DDSURFACEDESC ddsd;

        memset(&ddsd, 0, sizeof(ddsd));
        ddsd.dwSize = sizeof(ddsd);
        if (pdds->lpVtbl->Restore(pdds) == DD_OK &&
            pdds->lpVtbl->GetSurfaceDesc(pdds, &ddsd) == DD_OK)
        {
        // While OpenGL generic implementation can handle screen dimension
        // changes, it cannot yet deal with a color depth change.

            if (ddsd.ddpfPixelFormat.dwRGBBitCount ==
                pgdds->ddsd.ddpfPixelFormat.dwRGBBitCount)
            {
                pgdds->ddsd = ddsd;
                
            // Try lock with the new surface.

                dwRet = LDDS_LOCKED_NEW;
                hr = DDSLOCK(pdds, &pgdds->ddsd,
                         DDLOCK_SURFACEMEMORYPTR | DDLOCK_WAIT, prcClient);
#ifdef VERBOSE_LOCKDDSURF
		if (hr != DD_OK)
		{
		    DbgPrint("LockDdSurf: Relock failed with 0x%08lX\n", hr);
		}
#endif
            }
            else
            {
                hr = DDERR_GENERIC;
#ifdef VERBOSE_LOCKDDSURF
		DbgPrint("LockDdSurf: Bit count changed\n");
#endif
            }
        }
        else
        {
            hr = DDERR_GENERIC;
#ifdef VERBOSE_LOCKDDSURF
	    DbgPrint("LockDdSurf: Restore/GetSurfaceDesc failed\n");
#endif
        }
    }

    return hr == DD_OK ? dwRet : LDDS_ERROR;
}

/******************************Public*Routine******************************\
* BeginDirectScreenAccess
*
* Attempts to begin direct screen access for the primary surface.
*
* If the screen resolution changes, the primary surface is invalidated.  To
* regain access, the primary surface must be recreated.  If successful,
* the pointer to the primary surface passed into this function will be
* modified.
*
* Note: as currently written, generic implementation of OpenGL cannot
* handle color depth changes.  So we fail the call if this is detected.
*
* History:
*  21-Mar-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL BeginDirectScreenAccess(__GLGENcontext *gengc, GLGENwindow *pwnd,
                             PIXELFORMATDESCRIPTOR *ppfd)
{
    DWORD dwRet;
    
    ASSERTOPENGL((pwnd->ulFlags & GLGENWIN_DIRECTSCREEN) == 0,
                 "BeginDirectScreenAccess called with access\n");
    ASSERT_WINCRIT(pwnd);
    
// Do not acquire access if gengc format does not match pixelformat.

    if (gengc->pgddsFront->dwBitDepth != ppfd->cColorBits)
    {
        WARNING("BeginDirectScreenAccess: "
                "surface not compatible with context\n");
        return FALSE;
    }

// OK to try lock now.

    dwRet = LockDdSurf(gengc->pgddsFront, (RECT*) &pwnd->rclBounds);
    if (dwRet == LDDS_LOCKED_NEW)
    {
        __GLGENbuffers *buffers = (__GLGENbuffers *) NULL;

        // If screen changes, the MCD surfaces are lost and must be
        // recreated from scratch.  This can be triggered by simply
        // changing the window uniqueness numbers.

        buffers = pwnd->buffers;
        if (buffers)
        {
            buffers->WndUniq++;
                    
            buffers->WndSizeUniq++;

            // Don't let it hit -1.  -1 is special and is used by
            // MakeCurrent to signal that an update is required

            if (buffers->WndUniq == -1)
                buffers->WndUniq = 0;

            if (buffers->WndSizeUniq == -1)
                buffers->WndSizeUniq = 0;
        }
    }

// If we really have access to the surface, set the lock flag.
// Otherwise return error.

    if (dwRet != LDDS_ERROR)
    {
        ASSERTOPENGL(gengc->pgddsFront->ddsd.lpSurface != NULL,
                     "BeginDirectScreenAccess: expected non-NULL pointer\n");

        pwnd->pddsDirectScreen = gengc->pgddsFront->pdds;
        pwnd->pddsDirectScreen->lpVtbl->AddRef(pwnd->pddsDirectScreen);
        pwnd->pvDirectScreenLock = gengc->pgddsFront->ddsd.lpSurface;

        // DirectDraw returns a pointer offset to the specified rectangle;
        // undo that offset.

        gengc->pgddsFront->ddsd.lpSurface = (BYTE*) gengc->pgddsFront->ddsd.lpSurface 
            - pwnd->rclBounds.left * (gengc->pgddsFront->ddsd.ddpfPixelFormat.dwRGBBitCount >> 3) 
            - pwnd->rclBounds.top * gengc->pgddsFront->ddsd.lPitch;

        pwnd->pvDirectScreen = gengc->pgddsFront->ddsd.lpSurface;
        
        pwnd->ulFlags |= GLGENWIN_DIRECTSCREEN;

        return TRUE;
    }
    else
    {
        //XXX too noisy in stress when mode changes enabled
        //WARNING("BeginDirectScreenAccess failed\n");
        return FALSE;
    }
}

/******************************Public*Routine******************************\
* EndDirectScreenAccess
*
* Release lock acquired via BeginDirectScreenAccess.
*
* History:
*  28-Mar-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID EndDirectScreenAccess(GLGENwindow *pwnd)
{
    ASSERTOPENGL(pwnd->ulFlags & GLGENWIN_DIRECTSCREEN,
                 "EndDirectScreenAccess: not holding screen lock!\n");
    ASSERT_WINCRIT(pwnd);

    pwnd->ulFlags &= ~GLGENWIN_DIRECTSCREEN;
    if (pwnd->pddsDirectScreen != NULL)
    {
        DDSUNLOCK(pwnd->pddsDirectScreen, pwnd->pvDirectScreenLock);
        pwnd->pddsDirectScreen->lpVtbl->Release(pwnd->pddsDirectScreen);
        pwnd->pddsDirectScreen = NULL;
    }
}

/******************************Public*Routine******************************\
*
* glsrvGrabSurfaces
*
* Acquire all necessary surface locks and handle any changes that occurred
* since the last acquisition.
*
* NOTE: surfBits is currently ignored because taking fine-grained
* locks can lead to deadlocks because lock need has no guaranteed
* order.  To avoid this, all locks are taken if any locks are needed.
*
* History:
*  Tue Apr 02 13:10:26 1996	-by-	Drew Bliss [drewb]
*   Split out of glsrvGrabLock
*
\**************************************************************************/

BOOL APIENTRY glsrvGrabSurfaces(__GLGENcontext *gengc, GLGENwindow *pwnd,
                                FSHORT surfBits)
{
#if DBG
// If debugging, remember the surface offset in case it changes when we grab
// the lock.

    static void *pvCurSurf = NULL;
#endif

    BOOL bDoOver;
    FSHORT takeLocks;
    FSHORT locksTaken = 0;
    int lev = 0;

    ASSERT_WINCRIT(pwnd);
    
#ifndef DEADLOCKS_OK
    // See above note.
    surfBits = LAZY_LOCK_FLAGS;
#endif

    // Mask out MCD bit if no MCD.
    if (gengc->pMcdState == NULL)
    {
        surfBits &= ~LOCKFLAG_MCD;
    }
    
    // Early out if we don't actually need locks for the requested surfaces.

    takeLocks = gengc->fsGenLocks & surfBits;
    if (takeLocks == 0)
    {
        return TRUE;
    }

    // We can assume this function is not invoked if we already have the lock.

    ASSERTOPENGL((gengc->fsLocks & surfBits) == 0,
                 "glsrvGrabSurfaces: locks already held\n");

    // We already check this in glsrvAttention, but there are other
    // functions that call this so check that the window is correct
    // to be safe.

    if (pwnd != gengc->pwndMakeCur)
    {
        // One way an app could cause this is if the current HDC is released
        // without releasing (wglMakeCurrent(0, 0)) the corresponding HGLRC.
        // If GetDC returns this same HDC but for a different window, then
        // pwndGetFromID will return the pwnd associated with the new window.
        // However, the HGLRC is still bound to the original window.  In
        // such a situation we must fail the lock.

        WARNING("glsrvGrabSurfaces: mismatched windows\n");
        return FALSE;
    }

    if (takeLocks & LOCKFLAG_FRONT_BUFFER)
    {
        // Grab, test, and release the lock until the visregion is stable.
        // IsClipListChanged is currently hard-coded to return TRUE,
        // so force this loop to terminate after one update.  If
        // IsClipListChanged gets implemented correctly this will be
        // unnecessary.

        bDoOver = FALSE;
    
        do
        {
            UpdateWindowInfo(gengc);

            // Grab the screen lock.

            if (!BeginDirectScreenAccess(gengc, pwnd, &gengc->gsurf.pfd))
            {
#if 0
		// Too verbose under stress.
                WARNING("glsrvGrabLock(): BeginDirectScreenAccess failed\n");
#endif
                goto glsrvGrabSurfaces_exit;
            }

            if (bDoOver)
            {
                break;
            }

            // The surface may not have a clipper associated with it.
            if (pwnd->pddClip == NULL)
            {
                break;
            }
            
            // Did the window change during the time the lock was released?
            // If so, we need recompute the clip list and call UpdateWindowInfo
            // again.
            
            if ( pwnd->pddClip->lpVtbl->
                 IsClipListChanged(pwnd->pddClip, &bDoOver) == DD_OK &&
                 bDoOver )
            {
                BOOL bHaveClip;

                bHaveClip = wglGetClipList(pwnd);

                // Release access because we're going to loop around
                // to UpdateWindowInfo again and it makes a lot of
                // GDI calls.

                EndDirectScreenAccess(pwnd);

                if (!bHaveClip)
                {
                    WARNING("glsrvGrabSurfaces(): wglGetClipList failed\n");
                    goto glsrvGrabSurfaces_exit;
                }
            }
        } while ( bDoOver );

        // UpdateWindowInfo can cause a context conversion so we
        // may have lost MCD state since the start of locking activity.
        // Check again to make sure.

        if (gengc->pMcdState == NULL)
        {
            surfBits &= ~LOCKFLAG_MCD;
            takeLocks &= ~LOCKFLAG_MCD;
        }
        
        // Now that screen lock is held, set the lock flag.
        
        locksTaken |= LOCKFLAG_FRONT_BUFFER;
    }

    // Lock Z surface if necessary.
    if (takeLocks & LOCKFLAG_DD_DEPTH)
    {
        if (LockDdSurf(&gengc->gsurf.dd.gddsZ, NULL) == LDDS_ERROR)
        {
            goto glsrvGrabSurfaces_unlock;
        }
    
        locksTaken |= LOCKFLAG_DD_DEPTH;
    }

    // If there's a DirectDraw texture bound, lock its surface
    // and all mipmaps for use.
    if (takeLocks & LOCKFLAG_DD_TEXTURE)
    {
        GLDDSURF gdds;

        gdds = gengc->gc.texture.ddtex.gdds;
        for (lev = 0; lev < gengc->gc.texture.ddtex.levels; lev++)
        {
            gdds.pdds = gengc->gc.texture.ddtex.pdds[lev];
            if (LockDdSurf(&gdds, NULL) == LDDS_ERROR)
            {
                goto glsrvGrabSurfaces_unlock;
            }
            
            gengc->gc.texture.ddtex.texobj.texture.map.level[lev].buffer =
                gdds.ddsd.lpSurface;
        }

        locksTaken |= LOCKFLAG_DD_TEXTURE;
    }

    // Take MCD lock last so that buffer information is current.
    if (takeLocks & LOCKFLAG_MCD)
    {
        ASSERTOPENGL(gengc->pMcdState != NULL,
                     "MCD lock request but no MCD\n");
        
        if ((gpMcdTable->pMCDLock)(&gengc->pMcdState->McdContext) !=
            MCD_LOCK_TAKEN)
        {
            WARNING("glsrvGrabSurfaces(): MCDLock failed\n");
            goto glsrvGrabSurfaces_unlock;
        }

        locksTaken |= LOCKFLAG_MCD;
    }
    
    gengc->fsLocks |= locksTaken;

    ASSERTOPENGL(((gengc->fsLocks ^ gengc->fsGenLocks) & surfBits) == 0,
                 "Real locks/generic locks mismatch\n");
    
    if (takeLocks & LOCKFLAG_MCD)
    {
        // This must be called after fsLocks is updated since
        // GenMcdUpdateBufferInfo checks fsLocks to see what locks
        // are held.
        GenMcdUpdateBufferInfo(gengc);
    }
        
    // Base and width may have changed since last lock.  Refresh
    // the data in the gengc.

    // If the MCD lock was taken then the front buffer pointer was
    // updated.
    if ((takeLocks & (LOCKFLAG_FRONT_BUFFER | LOCKFLAG_MCD)) ==
         LOCKFLAG_FRONT_BUFFER)
    {
        gengc->gc.frontBuffer.buf.base =
            (VOID *)gengc->pgddsFront->ddsd.lpSurface;
        gengc->gc.frontBuffer.buf.outerWidth =
            gengc->pgddsFront->ddsd.lPitch;
    }

    if (takeLocks & LOCKFLAG_DD_DEPTH)
    {
        gengc->gc.depthBuffer.buf.base =
            gengc->gsurf.dd.gddsZ.ddsd.lpSurface;
        if (gengc->gsurf.dd.gddsZ.dwBitDepth == 16)
        {
            gengc->gc.depthBuffer.buf.outerWidth =
                gengc->gsurf.dd.gddsZ.ddsd.lPitch >> 1;
        }
        else
        {
            gengc->gc.depthBuffer.buf.outerWidth =
                gengc->gsurf.dd.gddsZ.ddsd.lPitch >> 2;
        }
    }

    // Record the approximate time the lock was grabbed.  That way we
    // can compute the time the lock is held and release it if necessary.

    gcmsOpenGLTimer = GetTickCount();
    gengc->dwLockTick = gcmsOpenGLTimer;
    gengc->dwLastTick = gcmsOpenGLTimer;
    gengc->dwCalls = 0;
    gengc->dwCallsPerTick = 16;

#if DBG
#define LEVEL_SCREEN   LEVEL_INFO

    if (takeLocks & LOCKFLAG_FRONT_BUFFER)
    {
        // Did the surface offset change?  If so, report it if debugging.

        if (pvCurSurf != gengc->pgddsFront->ddsd.lpSurface)
        {
            DBGLEVEL (LEVEL_SCREEN, "=============================\n");
            DBGLEVEL (LEVEL_SCREEN, "Surface offset changed\n\n");
            DBGLEVEL1(LEVEL_SCREEN, "\tdwOffSurface  = 0x%lx\n",
                      gengc->pgddsFront->ddsd.lpSurface);
            DBGLEVEL (LEVEL_SCREEN, "=============================\n");

            pvCurSurf = gengc->pgddsFront->ddsd.lpSurface;
        }
    }
#endif

    return TRUE;
    
 glsrvGrabSurfaces_unlock:
    while (--lev >= 0)
    {
        DDSUNLOCK(gengc->gc.texture.ddtex.pdds[lev],
                  gengc->gc.texture.ddtex.
                  texobj.texture.map.level[lev].buffer);

#if DBG
        gengc->gc.texture.ddtex.texobj.texture.map.level[lev].buffer = NULL;
#endif
    }
    
    if (locksTaken & LOCKFLAG_DD_DEPTH)
    {
        DDSUNLOCK(gengc->gsurf.dd.gddsZ.pdds,
                  gengc->gsurf.dd.gddsZ.ddsd.lpSurface);
    }

    if (locksTaken & LOCKFLAG_FRONT_BUFFER)
    {
        EndDirectScreenAccess(pwnd);
    }

 glsrvGrabSurfaces_exit:
    // Set the error codes.  GL_OUT_OF_MEMORY is used not because we
    // actually had a memory failure, but because this implies that
    // the OpenGL state is now indeterminate.

    gengc->errorcode = GLGEN_DEVLOCK_FAILED;
    __glSetError(GL_OUT_OF_MEMORY);

    return FALSE;
}

/******************************Public*Routine******************************\
*
* glsrvReleaseSurfaces
*
* Releases all resources held for screen access
*
* History:
*  Tue Apr 02 13:18:52 1996	-by-	Drew Bliss [drewb]
*   Split from glsrvReleaseLock
*
\**************************************************************************/

VOID APIENTRY glsrvReleaseSurfaces(__GLGENcontext *gengc,
                                   GLGENwindow *pwnd,
                                   FSHORT surfBits)
{
    FSHORT relLocks;

    ASSERT_WINCRIT(pwnd);
    
#ifndef DEADLOCKS_OK
    // See above note.
    surfBits = LAZY_LOCK_FLAGS;
#endif

    // Mask out MCD bit if no MCD.
    if (gengc->pMcdState == NULL)
    {
        surfBits &= ~LOCKFLAG_MCD;
    }
    
    // Early exit if locks are not actually held.

    relLocks = gengc->fsGenLocks & surfBits;
    if (relLocks == 0)
    {
        return;
    }
    
    if (relLocks & LOCKFLAG_MCD)
    {
        ASSERTOPENGL(gengc->pMcdState != NULL,
                     "MCD unlock request but no MCD\n");
        
        (gpMcdTable->pMCDUnlock)(&gengc->pMcdState->McdContext);
        gengc->fsLocks &= ~LOCKFLAG_MCD;
    }

    if (relLocks & LOCKFLAG_DD_TEXTURE)
    {
        int lev;
        
        lev = gengc->gc.texture.ddtex.levels;
        while (--lev >= 0)
        {
            DDSUNLOCK(gengc->gc.texture.ddtex.pdds[lev],
                      gengc->gc.texture.ddtex.
                      texobj.texture.map.level[lev].buffer);
#if DBG
            gengc->gc.texture.ddtex.texobj.texture.
                map.level[lev].buffer = NULL;
#endif
        }
        gengc->fsLocks &= ~LOCKFLAG_DD_TEXTURE;
    }

    if (relLocks & LOCKFLAG_DD_DEPTH)
    {
        DDSUNLOCK(gengc->gsurf.dd.gddsZ.pdds,
                  gengc->gsurf.dd.gddsZ.ddsd.lpSurface);
        gengc->fsLocks &= ~LOCKFLAG_DD_DEPTH;
        
#if DBG
        // NULL out our buffer information to ensure that we
        // can't access the surface unless we're really holding the lock

        gengc->gc.depthBuffer.buf.base = NULL;
        gengc->gc.depthBuffer.buf.outerWidth = 0;
#endif
    }

    if (relLocks & LOCKFLAG_FRONT_BUFFER)
    {
	EndDirectScreenAccess(pwnd);
	gengc->fsLocks &= ~LOCKFLAG_FRONT_BUFFER;
        
#if DBG
        // NULL out our front-buffer information to ensure that we
        // can't access the surface unless we're really holding the lock

        gengc->gc.frontBuffer.buf.base = NULL;
        gengc->gc.frontBuffer.buf.outerWidth = 0;
#endif
    }

    ASSERTOPENGL((gengc->fsLocks & surfBits) == 0,
                 "Surface locks still held after ReleaseSurfaces\n");
}

/******************************Public*Routine******************************\
* glsrvGrabLock
*
* Grab the display lock and tear down the cursor as needed.  Also, initialize
* the tickers and such that help determine when the thread should give up
* the lock.
*
* Note that for contexts that draw only to the generic back buffer do not
* need to grab the display lock or tear down the cursor.  However, to prevent
* another thread of a multithreaded app from resizing the drawable while
* this thread is using it, a per-drawable semaphore will be grabbed.
*
* Note: while the return value indicates whether the function succeeded,
* some APIs that might call this (like the dispatch function for glCallList
* and glCallLists) may not be able to return failure.  So, an error code
* of GLGEN_DEVLOCK_FAILED is posted to the GLGENcontext if the lock fails.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  12-Apr-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY glsrvGrabLock(__GLGENcontext *gengc)
{
    BOOL bRet = FALSE;
    BOOL bBackBufferOnly = GENERIC_BACKBUFFER_ONLY((__GLcontext *) gengc);
    GLGENwindow *pwnd;

    ASSERTOPENGL(gengc->pwndLocked == NULL,
                 "Unlocked gengc with window pointer\n");
    
    // Mostly ignore attempts to lock IC's
    if (gengc->gsurf.dwFlags & GLSURF_METAFILE)
    {
        // If we're running with a real window then we need to look it
        // up to detect whether it's died or not
        if (gengc->ipfdCurrent != 0)
        {
            pwnd = pwndGetFromID(&gengc->gwidCurrent);
            if (pwnd == NULL)
            {
                return FALSE;
            }
            if (pwnd != gengc->pwndMakeCur)
            {
                WARNING("glsrvGrabLock: mismatched windows (info DC)\n");
		pwndRelease(pwnd);
                return FALSE;
            }
        }
        else
        {
            pwnd = gengc->pwndMakeCur;
        }

        ENTER_WINCRIT_GC(pwnd, gengc);
        UpdateWindowInfo(gengc);
        return TRUE;
    }

    // Get the window from the DC.  This has the side effect of locking it
    // against deletion.
    
    pwnd = pwndGetFromID(&gengc->gwidCurrent);
    if (pwnd == NULL)
    {
        WARNING("glsrvGrabLock: No pwnd found\n");
        goto glsrvGrabLock_exit;
    }
    if (pwnd != gengc->pwndMakeCur)
    {
        // One way an app could cause this is if the current HDC is released
        // without releasing (wglMakeCurrent(0, 0)) the corresponding HGLRC.
        // If GetDC returns this same HDC but for a different window, then
        // pwndGetFromID will return the pwnd associated with the new window.
        // However, the HGLRC is still bound to the original window.  In
        // such a situation we must fail the lock.

#ifdef BAD_WINDOW_BREAK
        DbgPrint("%p:%p:%p thinks %p:%p but finds %p:%p\n",
                 gengc, gengc->gwidCurrent.hdc, gengc->gwidCurrent.hwnd,
                 gengc->pwndMakeCur, gengc->pwndMakeCur->gwid.hwnd,
                 pwnd, pwnd->gwid.hwnd);
        DebugBreak();
#else
        WARNING("glsrvGrabLock: mismatched windows\n");
#endif
        goto glsrvGrabLock_exit;
    }

    //
    // Compute locks necessary for generic rendering code to operate.
    // If a non-generic code path is going to run first these locks
    // won't actually be taken until after the non-generic code
    // has had a chance at rendering.
    //

    // We always need the window lock.
    gengc->fsGenLocks = LOCKFLAG_WINDOW;

    // If MCD is active we need to do MCD locking.
    if (gengc->pMcdState != NULL)
    {
        gengc->fsGenLocks |= LOCKFLAG_MCD;
    }
    
    // If we're going to be drawing to a direct-access front-buffer
    // then we need the front buffer lock.  MCD always requires
    // a front buffer lock on direct access buffers, so if
    // MCD is active the only thing that is checked is direct access.
    if ((gengc->pMcdState != NULL || !bBackBufferOnly) &&
        gengc->pgddsFront != NULL)
    {
        gengc->fsGenLocks |= LOCKFLAG_FRONT_BUFFER;
    }

    // If we have a DDraw depth buffer we need a lock on it.
    if ((gengc->dwCurrentFlags & GLSURF_DIRECTDRAW) &&
        gengc->gsurf.dd.gddsZ.pdds != NULL)
    {
        gengc->fsGenLocks |= LOCKFLAG_DD_DEPTH;
    }

    // If we have a current DDraw texture we need a lock on it.
    if (gengc->gc.texture.ddtex.levels > 0)
    {
        gengc->fsGenLocks |= LOCKFLAG_DD_TEXTURE;
    }
    
    // All lock types require the GLGENwindow structure lock.

    ENTER_WINCRIT_GC(pwnd, gengc);
    
    gengc->fsLocks |= LOCKFLAG_WINDOW;

    // If the current window is out-of-process then we haven't
    // been receiving any updates on its status.  Manually
    // check its position, size and palette information
    if (pwnd->ulFlags & GLGENWIN_OTHERPROCESS)
    {
        RECT rct;
        POINT pt;
        BOOL bPosChanged, bSizeChanged;

        if (!IsWindow(pwnd->gwid.hwnd))
        {
            // Window was destroyed
            pwndCleanup(pwnd);
            pwnd = NULL;
            goto glsrvGrabLock_exit;
        }

        if (!GetClientRect(pwnd->gwid.hwnd, &rct))
        {
            goto glsrvGrabLock_exit;
        }
        pt.x = rct.left;
        pt.y = rct.top;
        if (!ClientToScreen(pwnd->gwid.hwnd, &pt))
        {
            goto glsrvGrabLock_exit;
        }

        bPosChanged =
            GLDIRECTSCREEN &&
            (pt.x != pwnd->rclClient.left ||
             pt.y != pwnd->rclClient.top);
        bSizeChanged =
            rct.right != (pwnd->rclClient.right-pwnd->rclClient.left) ||
            rct.bottom != (pwnd->rclClient.bottom-pwnd->rclClient.top);

        if (bPosChanged || bSizeChanged)
        {
            __GLGENbuffers *buffers = NULL;

            pwnd->rclClient.left = pt.x;
            pwnd->rclClient.top = pt.y;
            pwnd->rclClient.right = pt.x+rct.right;
            pwnd->rclClient.bottom = pt.y+rct.bottom;
            pwnd->rclBounds = pwnd->rclClient;
            
            buffers = pwnd->buffers;
            if (buffers != NULL)
            {
                // Don't let it hit -1.  -1 is special and is used by
                // MakeCurrent to signal that an update is required
                
                if (++buffers->WndUniq == -1)
                {
                    buffers->WndUniq = 0;
                }
                if (bSizeChanged &&
                    ++buffers->WndSizeUniq == -1)
                {
                    buffers->WndSizeUniq = 0;
                }
            }
        }

        // The palette watcher should be active since we
        // are going to use its count.

        if (tidPaletteWatcherThread == 0)
        {
            goto glsrvGrabLock_exit;
        }
        pwnd->ulPaletteUniq = ulPaletteWatcherCount;
    }

    // If there's no MCD then generic code is going to be entered
    // immediately so go ahead and grab the appropriate locks.
    // Update drawables.

    if ( gengc->pMcdState == NULL &&
         gengc->fsGenLocks != gengc->fsLocks )
    {
        // UpdateWindowInfo needs to be called to ensure that
        // the gc's buffer state is synchronized with the current window
        // state.  Locking the front buffer will do this, but if
        // we aren't locking the front buffer then we need to do
        // it here to make sure it gets done.
        if ((gengc->fsGenLocks & LOCKFLAG_FRONT_BUFFER) == 0)
        {
            UpdateWindowInfo(gengc);
        }
            
        if (!glsrvGrabSurfaces(gengc, pwnd, gengc->fsGenLocks))
        {
            goto glsrvGrabLock_exit;
        }
    }
    else
    {
        UpdateWindowInfo(gengc);

        // Update MCD buffer state for MCD drivers w/o direct support.

        if (gengc->pMcdState)
        {
            GenMcdUpdateBufferInfo(gengc);
        }
        else
        {
            // UpdateWindowInfo can result in a context conversion.
            // This can be detected if pMcdState is NULL but
            // fsGenLocks is different from fsLocks (which implies that
            // pMcdState was not NULL prior to the call to
            // UpdateWindowInfo).
            //
            // If so, the locks must be grabbed immediately.

            gengc->fsGenLocks &= ~LOCKFLAG_MCD;
            if ( gengc->fsGenLocks != gengc->fsLocks )
            {
                if (!glsrvGrabSurfaces(gengc, pwnd, gengc->fsGenLocks))
                {
                    goto glsrvGrabLock_exit;
                }
            }
        }
    }

    bRet = TRUE;

glsrvGrabLock_exit:

    if (!bRet)
    {
        gengc->fsGenLocks = 0;
        gengc->fsLocks = 0;

        if (pwnd != NULL)
        {
	    if (gengc->pwndLocked != NULL)
	    {
		LEAVE_WINCRIT_GC(pwnd, gengc);
	    }
            
            pwndRelease(pwnd);
        }

    // Set the error codes.  GL_OUT_OF_MEMORY is used not because we
    // actually had a memory failure, but because this implies that
    // the OpenGL state is now indeterminate.

        gengc->errorcode = GLGEN_DEVLOCK_FAILED;
        __glSetError(GL_OUT_OF_MEMORY);
    }

    return bRet;
}

/******************************Public*Routine******************************\
* glsrvReleaseLock
*
* Releases display or drawable semaphore as appropriate.
*
* Returns:
*   No return value.
*
* History:
*  12-Apr-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID APIENTRY glsrvReleaseLock(__GLGENcontext *gengc)
{
    GLGENwindow *pwnd = gengc->pwndLocked;
    GLint lev;

    ASSERTOPENGL(gengc->pwndLocked != NULL, "glsrvReleaseLock: No window\n");
    
    // Mostly ignore attempts to lock IC's
    if (gengc->gsurf.dwFlags & GLSURF_METAFILE)
    {
        LEAVE_WINCRIT_GC(pwnd, gengc);
        
        // If we have a real window we need to release it
        if (gengc->ipfdCurrent != 0)
        {
            pwndRelease(pwnd);
        }
        
        return;
    }

    if ( gengc->fsLocks & LAZY_LOCK_FLAGS )
    {
        glsrvReleaseSurfaces(gengc, pwnd, gengc->fsLocks);
    }

    ASSERTOPENGL(gengc->fsLocks == LOCKFLAG_WINDOW,
                 "Wrong locks held\n");
    
// Note: pwndUnlock releases the window semaphore.

    pwndUnlock(pwnd, gengc);

    gengc->fsGenLocks = 0;
    gengc->fsLocks = 0;
}

/******************************Public*Routine******************************\
* glsrvAttention
*
* Dispatches each of the OpenGL API calls in the shared memory window.
*
* So that a single complex or long batch does not starve the rest of the
* system, the lock is released periodically based on the number of ticks
* that have elapsed since the lock was acquired.
*
* The user Raw Input Thread (RIT) and OpenGL share the gcmsOpenGLTimer
* value.  Because the RIT may be blocked, it does not always service
* the gcmsOpenGLTimer.  To compensate, glsrvAttention (as well as the
* display list dispatchers for glCallList and glCallLists) update
* gcmsOpenGLTimer explicitly with NtGetTickCount (a relatively expensive
* call) every N calls.
*
* The value N, or the number of APIs dispatched per call to NtGetTickCount,
* is variable.  glsrvAttention and its display list equivalents attempt
* to adjust N so that NtGetTickCount is called approximately every
* TICK_RANGE_LO to TICK_RANGE_HI ticks.
*
* Returns:
*   TRUE if entire batch is processed, FALSE otherwise.
*
* History:
*  12-Apr-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY glsrvAttention(PVOID pdlo, PVOID pdco, PVOID pdxo, HANDLE hdev)
{
    BOOL bRet = FALSE;
    ULONG *pOffset;
    SERVERPROC Proc;
    GLMSGBATCHINFO *pMsgBatchInfo = GLTEB_SHAREDMEMORYSECTION();
    __GLGENcontext *gengc = (__GLGENcontext *) GLTEB_SRVCONTEXT();
#ifdef CHAIN_DRAWPOLYARRAY_MSG
    POLYARRAY *paBegin = (POLYARRAY *) NULL;
    POLYARRAY *paEnd, *pa;
    GLMSG_DRAWPOLYARRAY *pMsgDrawPolyArray = NULL;
#endif
    UINT old_fp;
    GDISAVESTATE GdiState;

#ifdef DETECT_FPE
    old_fp = _controlfp(0, 0);
    _controlfp(_EM_INEXACT, _MCW_EM);
#endif
    if ((gengc->gsurf.dwFlags & GLSURF_DIRECTDRAW) == 0)
    {
        vSaveGdiState(gengc->gsurf.hdc, &GdiState);
    }
    
    DBGENTRY("glsrvAttention\n");

    DBGLEVEL1(LEVEL_INFO, "glsrvAttention: pMsgBatchInfo=0x%lx\n",
            pMsgBatchInfo);

    STATS_INC_SERVERTRIPS();

// Grab the lock.

    if (!glsrvGrabLock(gengc))
    {
	//!!! mcd/dma too?
	PolyArrayResetBuffer((__GLcontext *) gengc);
        goto glsrvAttention_exit;
    }

// Dispatch the calls in the batch.

    pOffset = (ULONG *)(((BYTE *)pMsgBatchInfo) + pMsgBatchInfo->FirstOffset);

    // If we don't require any locks we don't need to burden our processing
    // with timer checks.

    if (gengc->fsGenLocks == LOCKFLAG_WINDOW)
    {
        while (*pOffset)
        {
            ASSERTOPENGL(*pOffset <= LASTPROCOFFSET(glSrvSbProcTable),
                "Bad ProcOffset: memory corruption - we are hosed!\n");

            STATS_INC_SERVERCALLS();

            DBGLEVEL1(LEVEL_ENTRY, "%s\n",
                      glSrvSbStringTable[*pOffset / sizeof(SERVERPROC *)]);

#ifdef CHAIN_DRAWPOLYARRAY_MSG
            if (*pOffset == offsetof(GLSRVSBPROCTABLE, glsrvDrawPolyArray))
		pMsgDrawPolyArray = (GLMSG_DRAWPOLYARRAY *) pOffset;
#endif

        // Dispatch the call.  The return value is the offset of the next
        // message in the batch.

            Proc    = (*((SERVERPROC *)( ((BYTE *)(&glSrvSbProcTable)) +
                            *pOffset )));
            pOffset = (*Proc)((__GLcontext *) gengc, pOffset);

#ifdef CHAIN_DRAWPOLYARRAY_MSG
        // If we are processing DrawPolyArray, we need to update the pointers
        // that indicate the beginning and end of the POLYARRAY data for
        // the current range of DrawPolyArray chain.

	    if (pMsgDrawPolyArray)
	    {
		pa = (POLYARRAY *) pMsgDrawPolyArray->pa;
		pMsgDrawPolyArray = NULL;   // get ready for next iteration

		// Skip this primitive if no rendering is needed.
		if (!(pa->flags & POLYARRAY_RENDER_PRIMITIVE))
		{
		    PolyArrayRestoreColorPointer(pa);
		}
		else
		{
		// Add to DrawPolyArray chain
		    pa->paNext = NULL;
		    if (!paBegin)
			paBegin = pa;
		    else
			paEnd->paNext = pa;
		    paEnd = pa;
		}

		// If the next message is not a DrawPolyArray, then we need to
		// flush the primitive drawing.
		if (*pOffset != offsetof(GLSRVSBPROCTABLE, glsrvDrawPolyArray)
		    && paBegin)
		{
		    // Draw all the POLYARRAY primitives between paBegin
		    // and paEnd
		    glsrvFlushDrawPolyArray((void *) paBegin);
		    paBegin = NULL;
		}
	    }
#endif
        }
    }
    else
    {
        while (*pOffset)
        {
            ASSERTOPENGL(*pOffset <= LASTPROCOFFSET(glSrvSbProcTable),
                "Bad ProcOffset: memory corruption - we are hosed!\n");

            STATS_INC_SERVERCALLS();

            DBGLEVEL1(LEVEL_ENTRY, "%s\n",
                      glSrvSbStringTable[*pOffset / sizeof(SERVERPROC *)]);

#ifdef CHAIN_DRAWPOLYARRAY_MSG
            if (*pOffset == offsetof(GLSRVSBPROCTABLE, glsrvDrawPolyArray))
		pMsgDrawPolyArray = (GLMSG_DRAWPOLYARRAY *) pOffset;
#endif

        // Dispatch the call.  The return value is the offset of the next
        // message in the batch.

            Proc    = (*((SERVERPROC *)( ((BYTE *)(&glSrvSbProcTable)) +
                            *pOffset )));
            pOffset = (*Proc)((__GLcontext *) gengc, pOffset);

#ifdef CHAIN_DRAWPOLYARRAY_MSG
        // If we are processing DrawPolyArray, we need to update the pointers
        // that indicate the beginning and end of the POLYARRAY data for
        // the current range of DrawPolyArray chain.

	    if (pMsgDrawPolyArray)
	    {
		pa = (POLYARRAY *) pMsgDrawPolyArray->pa;
		pMsgDrawPolyArray = NULL;   // get ready for next iteration

		// Skip this primitive if no rendering is needed.
		if (!(pa->flags & POLYARRAY_RENDER_PRIMITIVE))
		{
		    PolyArrayRestoreColorPointer(pa);
		}
		else
		{
		// Add to DrawPolyArray chain
		    pa->paNext = NULL;
		    if (!paBegin)
			paBegin = pa;
		    else
			paEnd->paNext = pa;
		    paEnd = pa;
		}

		// If the next message is not a DrawPolyArray, then we need to
		// flush the primitive drawing.
		if (*pOffset != offsetof(GLSRVSBPROCTABLE, glsrvDrawPolyArray)
		    && paBegin)
		{
		    // Draw all the POLYARRAY primitives between paBegin
		    // and paEnd
		    glsrvFlushDrawPolyArray((void *) paBegin);
		    paBegin = NULL;
		}
	    }
#endif

//!!!XXX -- Better to use other loop until lock is grabbed then
//!!!XXX    switch to this loop.  But good enough for now to
//!!!XXX    check flag in loop.

        // If display lock held, we may need to periodically unlock to give
        // other apps a chance.

            if (gengc->fsLocks & LOCKFLAG_FRONT_BUFFER)
            {
            // Force a check of the current tick count every N calls.

                gengc->dwCalls++;

                if (gengc->dwCalls >= gengc->dwCallsPerTick)
                {
                    gcmsOpenGLTimer = GetTickCount();

                // If the tick delta is out of range, then increase or decrease
                // N as appropriate.  Be careful not to let it grow out of
                // bounds or to shrink to zero.

                    if ((gcmsOpenGLTimer - gengc->dwLastTick) < TICK_RANGE_LO)
                        if (gengc->dwCallsPerTick < 64)
                            gengc->dwCallsPerTick *= 2;
                    else if ((gcmsOpenGLTimer - gengc->dwLastTick) > TICK_RANGE_HI)
                        // The + 1 is to keep it from hitting 0
                        gengc->dwCallsPerTick = (gengc->dwCallsPerTick + 1) / 2;

                    gengc->dwLastTick = gcmsOpenGLTimer;
                    gengc->dwCalls = 0;
                }

            // Check if time slice has expired.  If so, relinquish the lock.

                if ((gcmsOpenGLTimer - gengc->dwLockTick) > BATCH_LOCK_TICKMAX)
                {
#ifdef CHAIN_DRAWPOLYARRAY_MSG
                    //!!! Before we release the lock, we may need to flush the
                    //!!! DrawPolyArray chain.  For now, just flush it although
                    //!!! it is probably unnecessary.
                    if (paBegin)
                    {
                        // Draw all the POLYARRAY primitives between paBegin
                        // and paEnd
                        glsrvFlushDrawPolyArray((void *) paBegin);
                        paBegin = NULL;
                    }
#endif

                // Release and regrab lock.  This will allow the cursor to
                // redraw as well as reset the cursor timer.

                    glsrvReleaseLock(gengc);
                    if (!glsrvGrabLock(gengc))
                    {
                        //!!! mcd/dma too?
                        PolyArrayResetBuffer((__GLcontext *) gengc);
                        goto glsrvAttention_exit;
                    }
                }
            }
        }
    }

// Release the lock.

    glsrvReleaseLock(gengc);

// Success.

    bRet = TRUE;

glsrvAttention_exit:

    if ((gengc->gsurf.dwFlags & GLSURF_DIRECTDRAW) == 0)
    {
        vRestoreGdiState(gengc->gsurf.hdc, &GdiState);
    }
    
#ifdef DETECT_FPE
    _controlfp(old_fp, _MCW_EM);
#endif
    
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\index\antindx.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  antiindex.c 
 *  The program draws a wireframe icosahedron with 
 *  antialiased lines, in color index mode.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

#define RAMPSIZE 16
#define RAMPSTART 32

/*  Initialize antialiasing for color index mode, 
 *  including loading a grey color ramp starting 
 *  at RAMPSTART, which must be a multiple of 16.
 */
void myinit(void)
{
    int i;

    for (i = 0; i < RAMPSIZE; i++) {
	GLfloat shade;
	shade = (GLfloat) i/(GLfloat) RAMPSIZE;
	auxSetOneColor(RAMPSTART+(GLint)i, shade, shade, shade);
    }

    glEnable (GL_LINE_SMOOTH);
    glHint (GL_LINE_SMOOTH_HINT, GL_DONT_CARE);
    glLineWidth (1.5);

    glClearIndex ((GLfloat) RAMPSTART);
    glShadeModel(GL_FLAT);
    glDepthFunc(GL_LESS);
    glEnable(GL_DEPTH_TEST);
}

/*  display() draws an icosahedron.
 */
void display(void)
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glIndexi(RAMPSTART);
    auxWireIcosahedron(1.0);
    glFlush();
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective (45.0, (GLfloat) w/(GLfloat) h, 3.0, 5.0);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity ();
    glTranslatef (0.0, 0.0, -4.0);  /*  move object into view   */
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  color index display mode, depth buffer, 
 *  and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_INDEX | AUX_DEPTH16);
    auxInitPosition (0, 0, 400, 400);
    auxInitWindow (argv[0]);
    myinit();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\index\fogindex.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  fogindex.c
 *  This program demonstrates fog in color index mode.  
 *  Three cones are drawn at different z values in a linear 
 *  fog.  32 contiguous colors (from 16 to 47) are loaded 
 *  with a color ramp.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

/*  Initialize color map and fog.  Set screen clear color 
 *  to end of color ramp.
 */
#define NUMCOLORS 32
#define RAMPSTART 16

void myinit(void)
{
    int i;

    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LESS);
    for (i = 0; i < NUMCOLORS; i++) {
	GLfloat shade;
	shade = (GLfloat) (NUMCOLORS-i)/(GLfloat) NUMCOLORS;
	auxSetOneColor (16 + i, shade, shade, shade);
    }
    glEnable(GL_FOG);

    glFogi (GL_FOG_MODE, GL_LINEAR);
    glFogi (GL_FOG_INDEX, NUMCOLORS);
    glFogf (GL_FOG_START, 0.0);
    glFogf (GL_FOG_END, 4.0);
    glHint (GL_FOG_HINT, GL_NICEST);
    glClearIndex((GLfloat) (NUMCOLORS+RAMPSTART-1));
}

/*  display() renders 3 cones at different z positions.
 */
void display(void)
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glPushMatrix ();
    glTranslatef (-1.0, -1.0, -1.0);
    glRotatef (-90.0, 1.0, 0.0, 0.0);
    glIndexi (RAMPSTART);
    auxSolidCone(1.0, 2.0);
    glPopMatrix ();

    glPushMatrix ();
    glTranslatef (0.0, -1.0, -2.25);
    glRotatef (-90.0, 1.0, 0.0, 0.0);
    glIndexi (RAMPSTART);
    auxSolidCone(1.0, 2.0);
    glPopMatrix ();

    glPushMatrix ();
    glTranslatef (1.0, -1.0, -3.5);
    glRotatef (-90.0, 1.0, 0.0, 0.0);
    glIndexi (RAMPSTART);
    auxSolidCone(1.0, 2.0);
    glPopMatrix ();
    glFlush();
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (w <= h)
	glOrtho (-2.0, 2.0, -2.0*(GLfloat)h/(GLfloat)w, 
	    2.0*(GLfloat)h/(GLfloat)w, 0.0, 10.0);
    else
	glOrtho (-2.0*(GLfloat)w/(GLfloat)h, 
	    2.0*(GLfloat)w/(GLfloat)h, -2.0, 2.0, 0.0, 10.0);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity ();
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, depth buffer, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_INDEX | AUX_DEPTH16);
    auxInitPosition (0, 0, 200, 200);
    auxInitWindow (argv[0]);
    myinit();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\accnot.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*  accnot.c
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

/*  Initialize lighting and other values.
 */

void myinit(void)
{
    GLfloat mat_ambient[] = { 1.0, 1.0, 1.0, 1.0 };
    GLfloat mat_specular[] = { 1.0, 1.0, 1.0, 1.0 };
    GLfloat light_position[] = { 0.0, 0.0, 10.0, 1.0 };
    GLfloat lm_ambient[] = { 0.2, 0.2, 0.2, 1.0 };

    glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient);
    glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
    glMaterialf(GL_FRONT, GL_SHININESS, 50.0);
    glLightfv(GL_LIGHT0, GL_POSITION, light_position);
    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lm_ambient);
    
    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);
    glDepthFunc(GL_LESS);
    glEnable(GL_DEPTH_TEST);
}

void display(void)
{
    GLfloat torus_diffuse[] = { 0.7, 0.7, 0.0, 1.0 };
    GLfloat cube_diffuse[] = { 0.0, 0.7, 0.7, 1.0 };
    GLfloat sphere_diffuse[] = { 0.7, 0.0, 0.7, 1.0 };
    GLfloat octa_diffuse[] = { 0.7, 0.4, 0.4, 1.0 };

    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    glShadeModel (GL_FLAT);
    glPushMatrix ();
    glRotatef (30.0, 1.0, 0.0, 0.0);

    glPushMatrix ();
    glTranslatef (-0.80, 0.35, 0.0); 
    glRotatef (100.0, 1.0, 0.0, 0.0);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, torus_diffuse);
    auxSolidTorus (0.275, 0.85);
    glPopMatrix ();

    glPushMatrix ();
    glTranslatef (-0.75, -0.50, 0.0); 
    glRotatef (45.0, 0.0, 0.0, 1.0);
    glRotatef (45.0, 1.0, 0.0, 0.0);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, cube_diffuse);
    auxSolidCube (1.5);
    glPopMatrix ();

    glPushMatrix ();
    glTranslatef (0.75, 0.60, 0.0); 
    glRotatef (30.0, 1.0, 0.0, 0.0);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, sphere_diffuse);
    auxSolidSphere (1.0);
    glPopMatrix ();

    glPushMatrix ();
    glTranslatef (0.70, -0.90, 0.25); 
    glMaterialfv(GL_FRONT, GL_DIFFUSE, octa_diffuse);
    auxSolidOctahedron (1.0);
    glPopMatrix ();

    glPopMatrix ();
    glFlush();
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (w <= h) 
	glOrtho (-2.25, 2.25, -2.25*h/w, 2.25*h/w, -10.0, 10.0);
    else 
	glOrtho (-2.25*w/h, 2.25*w/h, -2.25, 2.25, -10.0, 10.0);
    glMatrixMode(GL_MODELVIEW);
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB
			| AUX_ACCUM | AUX_DEPTH16);
    auxInitPosition (0, 0, 250, 250);
    auxInitWindow (argv[0]);
    myinit();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\accanti.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*  accanti.c
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"
#include "jitter.h"

/*  Initialize lighting and other values.
 */
void myinit(void)
{
    GLfloat mat_ambient[] = { 1.0, 1.0, 1.0, 1.0 };
    GLfloat mat_specular[] = { 1.0, 1.0, 1.0, 1.0 };
    GLfloat light_position[] = { 0.0, 0.0, 10.0, 1.0 };
    GLfloat lm_ambient[] = { 0.2, 0.2, 0.2, 1.0 };

    glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient);
    glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
    glMaterialf(GL_FRONT, GL_SHININESS, 50.0);
    glLightfv(GL_LIGHT0, GL_POSITION, light_position);
    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lm_ambient);
    
    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);
    glDepthFunc(GL_LESS);
    glEnable(GL_DEPTH_TEST);
    glShadeModel (GL_FLAT);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glClearAccum(0.0, 0.0, 0.0, 0.0);
}

void displayObjects(void) 
{
    GLfloat torus_diffuse[] = { 0.7, 0.7, 0.0, 1.0 };
    GLfloat cube_diffuse[] = { 0.0, 0.7, 0.7, 1.0 };
    GLfloat sphere_diffuse[] = { 0.7, 0.0, 0.7, 1.0 };
    GLfloat octa_diffuse[] = { 0.7, 0.4, 0.4, 1.0 };
    
    glPushMatrix ();
    glRotatef (30.0, 1.0, 0.0, 0.0);

    glPushMatrix ();
    glTranslatef (-0.80, 0.35, 0.0); 
    glRotatef (100.0, 1.0, 0.0, 0.0);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, torus_diffuse);
    auxSolidTorus (0.275, 0.85);
    glPopMatrix ();

    glPushMatrix ();
    glTranslatef (-0.75, -0.50, 0.0); 
    glRotatef (45.0, 0.0, 0.0, 1.0);
    glRotatef (45.0, 1.0, 0.0, 0.0);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, cube_diffuse);
    auxSolidCube (1.5);
    glPopMatrix ();

    glPushMatrix ();
    glTranslatef (0.75, 0.60, 0.0); 
    glRotatef (30.0, 1.0, 0.0, 0.0);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, sphere_diffuse);
    auxSolidSphere (1.0);
    glPopMatrix ();

    glPushMatrix ();
    glTranslatef (0.70, -0.90, 0.25); 
    glMaterialfv(GL_FRONT, GL_DIFFUSE, octa_diffuse);
    auxSolidOctahedron (1.0);
    glPopMatrix ();

    glPopMatrix ();
}

#define ACSIZE	8

void display(void)
{
    GLint viewport[4];
    int jitter;

    glGetIntegerv (GL_VIEWPORT, viewport);

    glClear(GL_ACCUM_BUFFER_BIT);
    for (jitter = 0; jitter < ACSIZE; jitter++) {
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	glPushMatrix ();
/*	Note that 4.5 is the distance in world space between
 *	left and right and bottom and top.
 *	This formula converts fractional pixel movement to 
 *	world coordinates.
 */
	glTranslatef (j8[jitter].x*4.5/viewport[2],
	    j8[jitter].y*4.5/viewport[3], 0.0);
	displayObjects ();
	glPopMatrix ();
	glAccum(GL_ACCUM, 1.0/ACSIZE);
        glFlush();
        auxSwapBuffers();
    }
    glAccum (GL_RETURN, 1.0);
    glFlush();
    auxSwapBuffers();
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (w <= h) 
	glOrtho (-2.25, 2.25, -2.25*h/w, 2.25*h/w, -10.0, 10.0);
    else 
	glOrtho (-2.25*w/h, 2.25*w/h, -2.25, 2.25, -10.0, 10.0);
    glMatrixMode(GL_MODELVIEW);
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_DOUBLE | AUX_RGB
			| AUX_ACCUM | AUX_DEPTH16);
    auxInitPosition (0, 0, 250, 250);
    auxInitWindow (argv[0]);
    myinit();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\index\maplight.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  maplight.c
 *  This program demonstrates the use of the GL lighting model.
 *  A sphere is drawn using a magenta diffuse reflective and
 *  white specular material property.
 *  A single light source illuminates the object.  This program
 *  illustrates lighting in color map mode.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

/*  Initialize material property, light source, and lighting model.
 */
void myinit(void)
{
    GLint i;

    GLfloat light_position[] = { 1.0, 1.0, 1.0, 0.0 };
    GLfloat mat_colormap[] = { 16.0, 48.0, 79.0 };
    GLfloat mat_shininess[] = { 10.0 };
    
    glMaterialfv(GL_FRONT, GL_COLOR_INDEXES, mat_colormap);
    glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);
    glLightfv(GL_LIGHT0, GL_POSITION, light_position);

    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);

    glDepthFunc(GL_LESS);
    glEnable(GL_DEPTH_TEST);

    for (i = 0; i < 32; i++) {
	auxSetOneColor (16 + i, 1.0 * (i/32.0), 0.0, 1.0 * (i/32.0));
	auxSetOneColor (48 + i, 1.0, 1.0 * (i/32.0), 1.0);
    }
    glClearIndex(0);
}

void display(void)
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    auxSolidSphere(1.0);
    glFlush();
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (w <= h) 
	glOrtho (-1.5, 1.5, -1.5*(GLfloat)h/(GLfloat)w, 
	    1.5*(GLfloat)h/(GLfloat)w, -10.0, 10.0);
    else 
	glOrtho (-1.5*(GLfloat)w/(GLfloat)h, 
	    1.5*(GLfloat)w/(GLfloat)h, -1.5, 1.5, -10.0, 10.0);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
}

/*  Main Loop
 *  Open window with initial window size, title bar, color 
 *  index display mode, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_INDEX | AUX_DEPTH16);
    auxInitPosition (0, 0, 500, 500);
    auxInitWindow (argv[0]);
    myinit();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\index\antipndx.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  antipindex.c
 *  The program draws antialiased points, 
 *  in color index mode.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

#define RAMPSIZE 16
#define RAMPSTART 32

/*  Initialize point antialiasing for color index mode, 
 *  including loading a grey color ramp starting at 
 *  RAMPSTART, which must be a multiple of 16.
 */
void myinit(void)
{
    int i;

    for (i = 0; i < RAMPSIZE; i++) {
	GLfloat shade;
	shade = (GLfloat) i/(GLfloat) RAMPSIZE;
	auxSetOneColor (RAMPSTART+(GLint)i, shade, shade, shade);
    }
    glEnable (GL_POINT_SMOOTH);
    glHint (GL_POINT_SMOOTH_HINT, GL_FASTEST);
    glPointSize (3.0);
    glClearIndex ((GLfloat) RAMPSTART);
}

/*  display() draws several points.  */

void display(void)
{
    int i;

    glClear(GL_COLOR_BUFFER_BIT);
    glIndexi (RAMPSTART);
    glBegin (GL_POINTS);
	for (i = 1; i < 10; i++) {
	    glVertex2f ((GLfloat) i * 10.0, (GLfloat) i * 10.0);
	}
    glEnd ();
    glFlush();
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (w < h) 
	glOrtho (0.0, 100.0, 0.0, 
	    100.0*(GLfloat) h/(GLfloat) w, -1.0, 1.0);
    else
	glOrtho (0.0, 100.0*(GLfloat) w/(GLfloat) h, 
	    0.0, 100.0, -1.0, 1.0);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity ();
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  color index display mode, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_INDEX);
    auxInitPosition (0, 0, 100, 100);
    auxInitWindow (argv[0]);
    myinit();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\ogpt\ogpt.c ===
/*
gstrip need to be implemented
bigchar needs to be implemented



Here is a new version of perf, for use in measuring graphics performance.
I've renamed it to be gpt, and added a lot of functionality.

I'd like it to be the standard way for ESD to measure performance.
It measures the performance of geometric primitives over a range
of angles, as specified in the Periodic Table.

I've calibrated gpt by running it on a GT, a VGX, a PI, a Magnum,
and a Hollywood.  I believe it gives accurate and consistent
numbers.  It measures all of the numbers that we publish, including
fill rate and DMA.

If you find bugs in gpt, or want to add features, feel free to
modify it.  But please mail out the new copy to this group, so
we all have a consistent version.

Jim

*/

/*
 *  gpt.c  -  Graphics Performance Tester
 *
 *	Benchmark for performance testing.
 *
 *	Vimal Parikh - 1988  Silicon Graphics Inc.
 *
 *  Modified by Jim Bennett - 1991
 *	- Added self timing and loop count
 *	- Added pixel dma tests
 *	- Added tests at various angles
 *	- Added named tests and modifiers mechanism
 *  Modified by Gary Tarolli - 1991
 *	- Unrolled loops somemore, and optimized some of them a little
 *	- fixed some minor bugs, like forgetting to use ortho to test 3d
 *	- use v2f for fast 2d primitives
 *  Modified by David Ligon - 1992
 *	- cleaned up loops
 *	- added mdifiers (dashed, width, pattern, cmode)
 *	- varied dma size
 *	- varied viewport size for clear
 *	- added qstrip
 *	- added 2d for geometry
 *	- added anti aliased points
 *	- added check for bad parameter combinations
 *  Modified by Gianpaolo Tommasi - 1993
 *	- ported to OpenGL
 *  Modified by Scott Carr - 1993
 *	- Use libaux so I can run it on NT
 *
 *  Usage: gpt <test> [<modifiers>] [loop count] [duration]
 *
 *	The currently supported tests are:
 *
 *	  xform		Test transform rate (points)
 *	  fill		Test fill rate
 *	  dma		Test DMA rate
 *	  char		Test character drawing rate
 *	  line		Test line drawing rate
 *	  poly		Test polygon drawing rate
 *	  tmesh		Test Triangle mesh drawing rate
 *	  qmesh		Test Quad mesh drawing rate
 *	  clear		Test screen clear rate	  
 *	  varray	Test vertex array rate (uses tmesh)
 *
 *	The currently supported modifiers are:
 *
 *	  +2d		Restrict transform to 2D
 *	  +z		Enable Z buffering
 *	  +shade	Enable Gouraud shading
 *	  +cmode	Use color index mode (Not implemented yet)
 *	  +1ilight	Enable 1 infinite light
 *	  +2ilight	Enable 2 infinite lights
 *	  +4ilight	Enable 4 infinite lights
 *	  +1llight	Enable 1 local light
 *	  +2llight	Enable 2 local lights
 *	  +4llight	Enable 4 local lights
 *	  +lmcolor	Enable colored lighted vertices
 *	  +depth	Enable depth cueing
 *	  +aa		Enable anti-aliasing
 *	  +snap		Set subpixel FALSE (fast path for PI).
 *	  +dashed	Enable dashed lines
 *	  +width	Set line width, +width n (n = 0-9 pixels)
 *	  +pattern	Enable pattern filling 
 *	  +scale	Set scale for geometry (not implemented yet)
 *	  +oldwindow	Open window at (100,900)-(100,650)
 *	  +brief	Brief text output
 *	  +bigger	Bigger tmesh 20x20
 *	  +backface	Sets frontface or backface to cull all primitives
 *	  +dlist	Use display lists
 *        +db           Use double-buffered visual
 *        +avg          Print averages only
 *        +size <size>  Size of line or side of triangle
 *    +mod_texture Use Texture mapping.
 *    +blend    Blend the texture with the color 
 *    +modulate Use the modulation function for textures
 *              (Decal mode is the default)
 *    +texfile <filename> Specify the texture file
 *                        (the abobe three work only if mod_texture)
 *
 *	Loop count specifies the number of times the test is run,
 *	and duration specifies the length of each run of the test.
 *	By default, the test is run once for one second.
 *
 *	The line, poly, and tmesh tests are run 16 times, at a
 *	variety of angles, and the average result is printed.
 *
 */

/*
 * Notes for OpenGL version:
 *  - Uses linear fog instead of depth cueing.
 *  - 8 bit pixel writes are done by writing to only the red channel of an 
 *    RGB visual as opposed to writing to a 8 bit CI visual as the IrisGL 
 *    version did.
 *  - Since the polygons used in the perfpoly test are all quadrilaterals, 
 *    GL_QUADS are used.
 */

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <time.h>
#include <GL/glu.h>
#include <GL/gl.h>
#include "glaux.h"

#define M_SQRT2		1.41421356237309504880
#define M_SQRT1_2	0.70710678118654752440

/* default window size for geometry testing */
#define	WINWIDTH	620
#define	WINHEIGHT	440
#define MINDIMENSION    440

/* default texture size */
#define DEF_TEX_WIDTH   64
#define DEF_TEX_HEIGHT  64

#define MESH_W   64
#define MESH_H   64
#define DEF_PRIM_SIZE 10

#define	QUAD_ROUND(x) (((x)+0x0f)&(~0x0f))

#define	NVERT	62
#define	NNORM	 4
#define	NCOLR	 8
#define NTEXTR   4


typedef struct {
    GLfloat x;
    GLfloat y;
    GLfloat z;
} vertType;

typedef struct {
    GLfloat r;
    GLfloat g;
    GLfloat b;
} colorType;

typedef struct {
    vertType vertex;
    vertType normal;
    colorType color;
    vertType texture;
} MESHVERTEX;

char fiftychars[51] = {
"12345678901234567890123456789012345678901234567890"
};

float	*v;		/* Vertices	*/
float	*mv;		/* Farhad's Vertices	*/
float	*n;		/* Normals	*/
float	*c;		/* Colors	*/
float   *t;     /* Texture coords */
MESHVERTEX   *va;    /* Vertex Array */
GLuint *ve;    /* Vertex Element array */
int stride = sizeof (MESHVERTEX);

int	mod_2d = 0;
int	mod_z = 0;
int	mod_shade = 0;
int	mod_cmode = 0;
int	mod_light = 0;
int	mod_1ilight = 0;
int	mod_2ilight = 0;
int	mod_4ilight = 0;
int	mod_1llight = 0;
int	mod_2llight = 0;
int	mod_4llight = 0;
int 	mod_lmcolor = 0;
int	mod_depth = 0;
int	mod_aa = 0;
int	mod_snap = 0;
int	mod_dashed = 0;
int	mod_width = 0;
int	mod_pattern = 0;
int	mod_oldwindow = 0;
int	mod_brief = 0;
int	mod_bigger = 0;
int	mod_backface = 0;
int     mod_doublebuffer = 0;
int     mod_average = 0;
int     mod_size = 0;
int mod_blend = 0;
int mod_modulate = 0;
int mod_texfile = 0;
int mod_texture = 0;
char tex_fname[50];

float   prim_size = DEF_PRIM_SIZE;

int tex_width = DEF_TEX_WIDTH;
int tex_height = DEF_TEX_HEIGHT;

float	secspertest;
float	angle;
float	secs;
float	sum_secs;
int	sum_n;
int	rate;
int	loopcount;

long	xsize,ysize;

static	int	delay_counter;

static DWORD startelapsed, endelapsed;

short line_width = 1;

static unsigned int pattern[] = { 
    0x55555555, 0xaaaaaaaa,
    0x55555555, 0xaaaaaaaa,
    0x55555555, 0xaaaaaaaa,
    0x55555555, 0xaaaaaaaa,
    0x55555555, 0xaaaaaaaa,
    0x55555555, 0xaaaaaaaa,
    0x55555555, 0xaaaaaaaa,
    0x55555555, 0xaaaaaaaa,
    0x55555555, 0xaaaaaaaa,
    0x55555555, 0xaaaaaaaa,
    0x55555555, 0xaaaaaaaa,
    0x55555555, 0xaaaaaaaa,
    0x55555555, 0xaaaaaaaa,
    0x55555555, 0xaaaaaaaa,
    0x55555555, 0xaaaaaaaa,
    0x55555555, 0xaaaaaaaa,
};

GLubyte *image; //place to store the texture
AUX_RGBImageRec *image_rec ;

static float gold_col[] = {0.2, 0.2, 0.0, 1.0};
static float gold_dif[] = {0.9, 0.5, 0.0, 1.0};
static float gold_spec[] = {0.7, 0.7, 0.0, 1.0};
static float gold_shiny[] = {20.0};

static float white_inf_light_amb[] = {0.0, 0.0, 0.0, 1.0};
static float white_inf_light_dif[] = {0.9, 0.9, 0.9, 1.0};
static float white_inf_light_pos[] = {50.0, 50.0, 50.0, 0.0};

static float blue_inf_light_amb[] = {0.0, 0.0, 0.0, 1.0};
static float blue_inf_light_dif[] = {0.30, 0.10, 0.90, 1.0};
static float blue_inf_light_pos[] = {-50.0, 50.0, 50.0, 0.0};

static float red_inf_light_amb[] = {0.0, 0.0, 0.0, 1.0};
static float red_inf_light_dif[] = {0.90, 0.10, 0.30, 1.0};
static float red_inf_light_pos[] = {-50.0, -50.0, 50.0, 0.0};

static float white2_inf_light_amb[] = {0.0, 0.0, 0.0, 1.0};
static float white2_inf_light_dif[] = {0.60, 0.60, 0.60, 1.0};
static float white2_inf_light_pos[] = {50.0, -50.0, 50.0, 0.0};

static float blue_local_light_amb[] = {0.0, 0.0, 0.0, 1.0};
static float blue_local_light_dif[] = {0.30, 0.10, 0.90, 1.0}; 
static float blue_local_light_pos[] = {-50.0, 50.0, -50.0, 1.0};

static float red_local_light_amb[] = {0.0, 0.0, 0.0, 1.0};
static float red_local_light_dif[] = {0.90, 0.10, 0.10, 1.0};
static float red_local_light_pos[] = {50.0, 50.0, -50.0, 1.0};

static float green_local_light_amb[] = {0.0, 0.0, 0.0, 1.0};
static float green_local_light_dif[] = {0.10, 0.90, 0.10, 1.0};
static float green_local_light_pos[] = {50.0, -50.0, -50.0, 1.0};

static float white_local_light_amb[] = {0.0, 0.0, 0.0, 1.0};
static float white_local_light_dif[] = {0.90, 0.90, 0.90, 1.0};
static float white_local_light_pos[] = {-50.0, -50.0, -50.0, 1.0};

static float lightmod_amb[] = {0.3, 0.3, 0.3, 1.0};
static float lightmod_loc[] = {GL_FALSE};

enum {
    BLACK = 0,
    RED = 13,
    GREEN = 14,
    YELLOW = 15,
    BLUE = 16,
    MAGENTA = 17,
    CYAN = 18,
    WHITE = 19
};

GLboolean useList = GL_FALSE;
GLboolean newList = GL_FALSE;
GLuint listID = 0;

/*****************************************************************************/
/*
 * Some support routines
 */

static void initListMode(void) {
    useList = GL_TRUE;
    newList = GL_FALSE;
    listID  = glGenLists(1);
}

static float timer(int flag)
{
    if (useList && flag) {
        if (newList) {
            glEndList();
            newList = GL_FALSE;
        }
        glFinish();
        startelapsed = GetTickCount();
        glCallList(listID);
    }
    glFinish();
    if (flag == 0) {
	startelapsed = GetTickCount();
	return(0.0);
    }

    endelapsed = GetTickCount();

    return(endelapsed - startelapsed) / (float)1000;
}


static int starttest(int flag)
{
    if (useList) {
        if (flag == 0) {
            glNewList(listID, GL_COMPILE);
            newList = GL_TRUE;
	    return(1);
        }
	else
	    return(0);
    } else {
	glFinish();
	startelapsed = GetTickCount();
	return(1);
    }
}


static void endtest(char *s, int r, int force)
{
    if (useList) {
        if (newList) {
            glEndList();
            newList = GL_FALSE;
        }
	glFinish();
	startelapsed = GetTickCount();
        glCallList(listID);
    }
    glFinish();
    endelapsed = GetTickCount();
    secs = (endelapsed - startelapsed) / (float)1000;
    if (!mod_average || force) {
        printf("%-44s--", s);
        printf("%12.2f/sec (%6.3f secs)\n", r/secs, secs);
        fflush(stdout);
    }
    sum_secs += secs;
    sum_n += r;
    Sleep(300);
}

static void printaverage (void)
{
    printf("\n%-44s--", "Average over all angles");
    printf("%12.2f/sec\n", sum_n/sum_secs);
}


static void pixendtest(char *s, int r, int xpix, int ypix)
{
    double pixrate;
    char pbuf[256];

    secs = timer(1);
    sprintf(pbuf,"%dx%d %s",xpix,ypix,s);
    printf("%-44s--", pbuf);
#if 0
    pixrate = r/secs;
    pixrate = (pixrate * xpix * ypix) / 1000000.0;
    printf("%10.4f Million pixels/sec\n", pixrate);
#else
    pixrate = ((double)(r * xpix * ypix) / secs);
    if (pixrate > 1000000.0)
        printf("%10.4f Million pixels/sec\n", pixrate/1000000.0);
    else if (pixrate > 1000.0)
        printf("%10.4f Thousand pixels/sec\n", pixrate/1000.0);
    else
        printf("%10.4f Pixels/sec\n", pixrate);
#endif
    fflush(stdout);
    Sleep(250);
}


static void clearendtest(char *s, int r, int numpix)
{
    double pixrate;

    secs = timer(1);

    printf("%s \n",s);
    printf("\ttotal time: %f for %d clears  \n", secs, r);
    printf("\tcalculated average time for a clear: %f ms\n",1000.0*secs/(float)r);
    pixrate = ((double)(r * numpix) / secs) / 1000000.0;
    printf("\t%10.4f Million pixels/sec\n\n",pixrate);
    fflush(stdout);
    Sleep(250);

}


static void spindelay(void)
{
    int	i;

    delay_counter = 0;
    for (i=0; i<2000000; i++) {
	delay_counter = delay_counter + i;
	delay_counter = delay_counter/39;
    }
}


static void makeramp(int i, int r1, int g1, int b1, int r2, int g2, int b2,
		     int nindexes)
{
#ifdef PORTME
    XColor col;
    int count;
    int r,g,b;

    for (count = 0; count < nindexes; count++) {
	r = (r2 - r1) * count/(nindexes - 1) + r1;
	g = (g2 - g1) * count/(nindexes - 1) + g1;
	b = (b2 - b1) * count/(nindexes - 1) + b1;
	col.red = r * (65535.0 / 255);
	col.green = g * (65535.0 / 255);
	col.blue = b * (65535.0 / 255);
	col.pixel = i;
	col.flags = DoRed | DoGreen | DoBlue;
	XStoreColor(theDisplay, theCMap, &col);
	i++;
    }

    XFlush(theDisplay);
#endif
}


static void setLightingParameters(void)
{
    if (mod_1ilight || mod_2ilight || mod_4ilight) {
	/* lmbind(LIGHT1, 1); */
	glEnable(GL_LIGHTING);
	glLightfv(GL_LIGHT0, GL_AMBIENT, white_inf_light_amb);
	glLightfv(GL_LIGHT0, GL_DIFFUSE, white_inf_light_dif);
	glLightfv(GL_LIGHT0, GL_POSITION, white_inf_light_pos); 
	glEnable(GL_LIGHT0);
    }
    if (mod_2ilight || mod_4ilight) {
	/* lmbind(LIGHT1, 1);lmbind(LIGHT2, 2); */
	glLightfv(GL_LIGHT1, GL_AMBIENT, blue_inf_light_amb);
	glLightfv(GL_LIGHT1, GL_DIFFUSE, blue_inf_light_dif);
	glLightfv(GL_LIGHT1, GL_POSITION, blue_inf_light_pos); 
	glEnable(GL_LIGHT1);
    }
    if (mod_4ilight) {
	/* lmbind(LIGHT1, 1);lmbind(LIGHT2, 2);
	   lmbind(LIGHT3, 3);lmbind(LIGHT4, 4); */
	glLightfv(GL_LIGHT2, GL_AMBIENT, red_inf_light_amb);
	glLightfv(GL_LIGHT2, GL_DIFFUSE, red_inf_light_dif);
	glLightfv(GL_LIGHT2, GL_POSITION, red_inf_light_pos); 
	glEnable(GL_LIGHT2);
	glLightfv(GL_LIGHT3, GL_AMBIENT, white2_inf_light_amb);
	glLightfv(GL_LIGHT3, GL_DIFFUSE, white2_inf_light_dif);
	glLightfv(GL_LIGHT3, GL_POSITION, white2_inf_light_pos); 
	glEnable(GL_LIGHT3);
    }
    
    if (mod_1llight || mod_2llight || mod_4llight) {
	/* lmbind(LIGHT5, 5); */
	glEnable(GL_LIGHTING);
	glLightfv(GL_LIGHT4, GL_AMBIENT, blue_local_light_amb);
	glLightfv(GL_LIGHT4, GL_DIFFUSE, blue_local_light_dif);
	glLightfv(GL_LIGHT4, GL_POSITION, blue_local_light_pos); 
	glEnable(GL_LIGHT4);
    }
    if (mod_2llight) {
	/* lmbind(LIGHT5, 5);lmbind(LIGHT6, 6);*/
	glLightfv(GL_LIGHT5, GL_AMBIENT, red_local_light_amb);
	glLightfv(GL_LIGHT5, GL_DIFFUSE, red_local_light_dif);
	glLightfv(GL_LIGHT5, GL_POSITION, red_local_light_pos); 
	glEnable(GL_LIGHT5);
    }
    if (mod_4llight) {
	/* lmbind(LIGHT5, 5);lmbind(LIGHT6, 6);lmbind(LIGHT7, 7);
	   lmbind(LIGHT0, 8); */
	glLightfv(GL_LIGHT6, GL_AMBIENT, green_local_light_amb);
	glLightfv(GL_LIGHT6, GL_DIFFUSE, green_local_light_dif);
	glLightfv(GL_LIGHT6, GL_POSITION, green_local_light_pos); 
	glEnable(GL_LIGHT6);
	glLightfv(GL_LIGHT7, GL_AMBIENT, white_local_light_amb);
	glLightfv(GL_LIGHT7, GL_DIFFUSE, white_local_light_dif);
	glLightfv(GL_LIGHT7, GL_POSITION, white_local_light_pos); 
	glEnable(GL_LIGHT7);
    }
    
    /* lmbind(LMODEL, 1); */
    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lightmod_amb);
    glLightModelfv(GL_LIGHT_MODEL_LOCAL_VIEWER, lightmod_loc);
    
    /* lmbind(MATERIAL, 1); */
    glMaterialfv(GL_FRONT, GL_AMBIENT, gold_col);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, gold_dif);
    glMaterialfv(GL_FRONT, GL_SPECULAR, gold_spec);
    glMaterialfv(GL_FRONT, GL_SHININESS, gold_shiny);
    
    /* if (mod_lmcolor) lmcolor(LMC_DIFFUSE); */
    if (mod_lmcolor) {
	glColorMaterial(GL_FRONT_AND_BACK, GL_DIFFUSE);
	glEnable(GL_COLOR_MATERIAL);
    }
}



/******************************Public*Routine******************************\
* ss_fRand
*
* Generates float random number min...max
*
\**************************************************************************/

FLOAT ss_fRand( FLOAT min, FLOAT max )
{
    FLOAT diff;

    diff = max - min;
    return min + ( diff * ( ((float)rand()) / ((float)(RAND_MAX)) ) );
}

static int GenVertData (int num_x, int num_y)
{
    int i, j, k, ti, ci, ni, num_tri, num_vert;
    int l0, l1, l2, l3, numVinRow, numVinCol;
    GLfloat curr_x, curr_y, beg;
    float *tt;

    srand ( (unsigned) time (NULL));

    numVinRow = num_x;
    numVinCol = num_y;
    
    num_vert = numVinRow * numVinCol;
    num_tri = (numVinRow - 1) * (numVinCol - 1) * 2;
    va = (MESHVERTEX *) malloc (sizeof (MESHVERTEX) * num_vert);
    ve = (GLuint *) malloc (sizeof (GLuint) * num_tri * 3);

    printf ("num_vert = %d, prim_size = %f, num_tri = %d\n",
            num_vert, prim_size, num_tri);
    
    /* 255 = r, 240 = g, 255 = b */
    makeramp(208,255,0,0,0,0,255,16);
    makeramp(224,0,0,255,255,255,0,16);
    makeramp(240,255,255,0,255,0,255,16);
            
    k = 0;
    beg = - (numVinRow * prim_size) / 2.0;
    for (i = 0, curr_y = beg; i < numVinCol; i++, curr_y += prim_size) {
        for (j = 0, curr_x = beg; j < numVinRow; 
             j++, k++, curr_x += prim_size) {
            va [k].vertex.x = curr_x;
            va [k].vertex.y = curr_y;
            va [k].vertex.z = 0.0;            

            va [k].normal.x = ss_fRand (-0.25, 0.25);
            va [k].normal.y = ss_fRand (-0.25, 0.25);
            va [k].normal.z = 1.0;

            va [k].texture.x = (float) (j % 4) / 4.0;
            va [k].texture.y = (float) (i % 4) / 4.0;

            if (i % 2) { 
                if (j % 2) {ci = 4; ni = 255;}
                else {ci = 8; ni = 240;}
            } else {
                if (j % 2) {ci = 16; ni = 223;}
                else {ci = 8; ni = 208;}
            }
            if (!mod_cmode) { /* Color Mode */
                va [k].color.r = c[ci];
                va [k].color.g = c[ci+1];
                va [k].color.b = c[ci+2];
            } else {          /* Color Index mode */
                va [k].color.r = (float) ni;
            }
        }
    }

    /* Assign the element array to draw triangles */
    k = 0; 
    for (i = 0; i < (numVinCol - 1); i++) {
        for (j = 0; j < (numVinRow - 1); j++) {
            l0 = i * numVinRow + j;
            l1 = (i + 1) * numVinRow + j;
            l2 = l0 + 1;
            l3 = l1 + 1;
            ve[k++] = l0; ve[k++] = l1; ve[k++] = l2;
            ve[k++] = l2; ve[k++] = l1; ve[k++] = l3;          
        }
    }
    
    /* Specify vertex array data */
    glNormalPointer (GL_FLOAT, stride, &(va[0].normal.x));
    glColorPointer (3, GL_FLOAT, stride, &(va[0].color.r));
    glIndexPointer (GL_FLOAT, stride, &(va[0].color.r));
    glTexCoordPointer (2, GL_FLOAT, stride, &(va[0].texture.x));
    
    /* Enable the appropriate arrays */
    glDisableClientState (GL_EDGE_FLAG_ARRAY);
    glEnableClientState (GL_VERTEX_ARRAY);
    if (mod_texture) glEnableClientState (GL_TEXTURE_COORD_ARRAY);
    else glDisableClientState (GL_TEXTURE_COORD_ARRAY);

    printf ("Num elements = %d\n", k);
    return (k);
}


static void CreateImage(void)
{
int i, j;
GLubyte col = 0 ;
    
    tex_width = DEF_TEX_WIDTH;
    tex_height = DEF_TEX_HEIGHT;
    
    image = (GLubyte *) LocalAlloc (LMEM_FIXED, 
                                sizeof (GLubyte) * tex_width * tex_height * 3);

    for(i=0; i<tex_width; i++)
        for(j=0; j<tex_height; j++)
            if( ((j/8)%2 && (i/8)%2) || (!((j/8)%2) && !((i/8)%2)) )
            {
                image[(i*tex_height+j)*3] = 127 ;
                image[(i*tex_height+j)*3+1] = 127 ;
                image[(i*tex_height+j)*3+2] = 127 ;
            }
            else
            {
                image[(i*tex_height+j)*3] = 0 ;
                image[(i*tex_height+j)*3+1] = 0 ;
                image[(i*tex_height+j)*3+2] = 0 ;
            }
}


static void MyLoadImage(void)
{
    image_rec = auxDIBImageLoad(tex_fname);
    tex_width = image_rec->sizeX;
    tex_height = image_rec->sizeY;
    printf("Image size -- X= %d, Y= %d\n", tex_width, tex_height) ;
}


static void InitTexParams (void)
{
    if (mod_blend)
        glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_BLEND) ;
    else if (mod_modulate)
        glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE) ;
    else
        glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL) ;

    if (!mod_texfile) {
        glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT) ;
        glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT) ;
        glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST) ;
        glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST) ;
        glTexImage2D(GL_TEXTURE_2D, 0, 3, tex_width, tex_height, 0, GL_RGB, 
                     GL_UNSIGNED_BYTE, image) ;
    } else {
        glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
        glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT) ;
        glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT) ;
        glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST) ;
        glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST) ;
        gluBuild2DMipmaps(GL_TEXTURE_2D, 3, image_rec->sizeX, 
                          image_rec->sizeY, GL_RGB, GL_UNSIGNED_BYTE, 
                          image_rec->data);
    }
    glEnable (GL_TEXTURE_2D);
}



/*****************************************************************************/

/*
 * The tests proper
 */

static void perfpoint(void)
{
    int i, k;
    float *vp = v;

    /*** POINTS *****/

    if (mod_width) {
	glPointSize(line_width);
    }

    if (mod_aa) {
	glEnable(GL_POINT_SMOOTH);
	if (mod_cmode) {
	    /* create a colour ramp appropriate for anti-aliasing */
	    /* i, r1, g1, b1, r2, g2, b2, nindexes */
	    makeramp(240, 0, 0, 0, 255, 255, 255, 16);
	    glClearIndex(240);
	    glClear(GL_COLOR_BUFFER_BIT);
	    glIndexi(240);
	} else {
	    glEnable(GL_BLEND);
	    /* blendfunction(BF_SA,BF_ONE); */
	    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
	}
    }


    /****** Calibration Loop ******/
    secs = 0.0;
    rate = 125;
    while (secs < (secspertest/4.0)) {
	rate = rate * 2;
	starttest(0);
	glBegin(GL_POINTS);
	if (mod_2d)
	    for (i = 0; i < rate; i++)
		glVertex2fv(vp);
	else
	    for (i = 0; i < rate; i++)
		glVertex3fv(vp);
	glEnd();

	secs = timer(1);
    }
    rate = rate * (secspertest / secs);
    rate = 10 * (rate / 10);

    /* do the real thing */
    for (k = 0; k < loopcount; k++) {
      if (starttest(k)) {
	glBegin(GL_POINTS);
	if (mod_2d) {
	    for (i = rate / 10; i; i--) {
		glVertex2fv(vp);
		glVertex2fv(vp);
		glVertex2fv(vp);
		glVertex2fv(vp);
		glVertex2fv(vp);
		glVertex2fv(vp);
		glVertex2fv(vp);
		glVertex2fv(vp);
		glVertex2fv(vp);
		glVertex2fv(vp);
	    }
	} else {
	    for (i = rate / 10; i; i--) {
		glVertex3fv(vp);
		glVertex3fv(vp);
		glVertex3fv(vp);
		glVertex3fv(vp);
		glVertex3fv(vp);
		glVertex3fv(vp);
		glVertex3fv(vp);
		glVertex3fv(vp);
		glVertex3fv(vp);
		glVertex3fv(vp);
	    }
	}
	glEnd();
      }
      endtest("", rate, 1);
    }
    if (mod_doublebuffer) {
        auxSwapBuffers();
        Sleep(2000);               /* for visual feedback */
    }
    exit(0);
}


static void perfline(void)
{
    int i,k;
    char pbuf[256];
    float *vp=v;

    if (mod_dashed) {
	glEnable(GL_LINE_STIPPLE);
	glLineStipple(1, 0x5555);
    }

    if (mod_width) {
	glLineWidth(line_width);
    }

    /*** ANTI_ALIAS LINES *****/
    
    if (mod_aa) {
	glEnable(GL_LINE_SMOOTH);
	if (mod_cmode) {
	    makeramp(240,0,0,0,255,255,255,16);
	    glClearIndex(240);
	    glClear(GL_COLOR_BUFFER_BIT);
	    glIndexi(240);
	} else {
	    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
	}
    }

    /*** DEPTHCUED LINES *****/

    /* 
     * OpenGL has no depth cueing, we'll use linear fog instead.
     */
    if (mod_depth) {
	glEnable(GL_FOG);
	glFogi(GL_FOG_MODE, GL_LINEAR);
	glDepthRange(0.0, 1.0);
	glFogf(GL_FOG_START, 0.0);
	glFogf(GL_FOG_END, 1.0);
	
	if (mod_cmode) {
	    makeramp(240,250,250,250,255,255,0,16);
	    glIndexi(240);
	    glFogf(GL_FOG_INDEX, 16);
	} else
	    glFogfv(GL_FOG_COLOR, &c[16]);
	
	sum_secs = 0.0;
	sum_n = 0;
	vp[4] -= 1.0;	/* make lines 10 pixels instead of 11	*/
	for (angle = 2.0; angle < 360.0; angle += 22.5) {
	    glPushMatrix();
	    glRotatef(angle, 0, 0, 1);

	    /****** Calibration Loop ******/
	    secs = 0.0; rate = 125;

	    while (secs < (secspertest/4.0)) {
		rate = rate*2;
		starttest(0);
		glBegin(GL_LINE_STRIP);
		/* No 2D depth cued lines - Go straight to 3D */
		for(i=(rate)/2; i; i--) {
		    glVertex3fv(vp);
		    glVertex3fv(vp+4);
		}
		glEnd();

		secs = timer(1);
	    }
	    rate = rate * (secspertest/secs);
	    rate = 10 * (rate/10);

	    for (k=0; k<loopcount; k++) {
	      if (starttest(k)) {
		glBegin(GL_LINE_STRIP);
		for(i=(rate)/10; i; i--) {
		    glVertex3fv(vp);
		    glVertex3fv(vp+4);
		    glVertex3fv(vp);
		    glVertex3fv(vp+4);
		    glVertex3fv(vp);
		    glVertex3fv(vp+4);
		    glVertex3fv(vp);
		    glVertex3fv(vp+4);
		    glVertex3fv(vp);
		    glVertex3fv(vp+4);
		}
		glEnd();
	      }
              if (!mod_average)
    	        sprintf(pbuf, "Angle %6.2f", angle);

	      endtest(pbuf, rate, 0);
	    }
	    glPopMatrix();
	}
	printaverage();
        if (mod_doublebuffer) {
            auxSwapBuffers();
            Sleep(2000);               /* for visual feedback */
        }
	exit(0);
    }    

    if (!mod_shade) {

	/**** Flat shaded RGB or Color mapped lines ****/
	/**** Color should already be set           ****/

	sum_secs = 0.0;
	sum_n = 0;
	vp[4] -= 1.0;	/* make lines 10 pixels instead of 11	*/
	for (angle = 2.0; angle < 360.0; angle += 22.5) {
	    glPushMatrix();
	    glRotatef(angle, 0, 0, 1);

	    /****** Calibration Loop ******/
	    secs = 0.0; rate = 125;

	    while (secs < (secspertest/4.0)) {
		rate = rate*2;
		starttest(0);
		glBegin(GL_LINE_STRIP);
		if (mod_2d) {
		    for(i=(rate)/2; i; i--) {
			glVertex2fv(vp);
			glVertex2fv(vp+4);
		    }
		} else {
		    for(i=(rate)/2; i; i--) {
			glVertex3fv(vp);
			glVertex3fv(vp+4);
		    }
		}
		glEnd();

		secs = timer(1);
	    }
	    rate = rate * (secspertest/secs);
	    rate = 10 * (rate/10);

	    for (k=0; k<loopcount; k++) {
	      if (starttest(k)) {
		glBegin(GL_LINE_STRIP);
		if (mod_2d) { 
		    for(i=(rate)/10; i; i--) {
			glVertex2fv(vp);
			glVertex2fv(vp+4);
			glVertex2fv(vp);
			glVertex2fv(vp+4);
			glVertex2fv(vp);
			glVertex2fv(vp+4);
			glVertex2fv(vp);
			glVertex2fv(vp+4);
			glVertex2fv(vp);
			glVertex2fv(vp+4);
		    } 

		} else {
		    for(i=(rate)/10; i; i--) {
			glVertex3fv(vp);
			glVertex3fv(vp+4);
			glVertex3fv(vp);
			glVertex3fv(vp+4);
			glVertex3fv(vp);
			glVertex3fv(vp+4);
			glVertex3fv(vp);
			glVertex3fv(vp+4);
			glVertex3fv(vp);
			glVertex3fv(vp+4);
		    }
		}
		glEnd();
	      }
              if (!mod_average)
	        sprintf(pbuf, "Angle %6.2f", angle);

	      endtest(pbuf, rate, 0);
	    }
	    glPopMatrix();
	}
	printaverage();

    } else {

	if (mod_cmode) {

	    /**** Gouraud  Color mapped lines ****/
	    makeramp(240,255,0,0,0,0,255,16);

	    sum_secs = 0.0;
	    sum_n = 0;
	    vp[4] -= 1.0;	/* make lines 10 pixels instead of 11	*/
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
		glPushMatrix();
		glRotatef(angle, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;

		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);
		    glBegin(GL_LINE_STRIP);
		    if (mod_2d) {
			for(i=(rate)/2; i; i--) {
			    glIndexi(240);
			    glVertex2fv(vp);
			    glIndexi(255);
			    glVertex2fv(vp+4);
			}
		    } else {
			for(i=(rate)/2; i; i--) {
			    glIndexi(240);
			    glVertex3fv(vp);
			    glIndexi(255);
			    glVertex3fv(vp+4);
			}
		    }
		    glEnd();

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = 10 * (rate/10);

		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    glBegin(GL_LINE_STRIP);
		    if (mod_2d) { 
			for(i=(rate)/10; i; i--) {
			    glIndexi(240);
			    glVertex2fv(vp);
			    glIndexi(255);
			    glVertex2fv(vp+4);
			    glIndexi(240);
			    glVertex2fv(vp);
			    glIndexi(255);
			    glVertex2fv(vp+4);
			    glIndexi(240);
			    glVertex2fv(vp);
			    glIndexi(255);
			    glVertex2fv(vp+4);
			    glIndexi(240);
			    glVertex2fv(vp);
			    glIndexi(255);
			    glVertex2fv(vp+4);
			    glIndexi(240);
			    glVertex2fv(vp);
			    glIndexi(255);
			    glVertex2fv(vp+4);
			} 

		    } else {
			for(i=(rate)/10; i; i--) {
			    glIndexi(240);
			    glVertex2fv(vp);
			    glIndexi(255);
			    glVertex2fv(vp+4);
			    glIndexi(240);
			    glVertex2fv(vp);
			    glIndexi(255);
			    glVertex2fv(vp+4);
			    glIndexi(240);
			    glVertex2fv(vp);
			    glIndexi(255);
			    glVertex2fv(vp+4);
			    glIndexi(240);
			    glVertex2fv(vp);
			    glIndexi(255);
			    glVertex2fv(vp+4);
			    glIndexi(240);
			    glVertex2fv(vp);
			    glIndexi(255);
			    glVertex2fv(vp+4);
			}
		    }
		    glEnd();
	          }
                  if (!mod_average)
		    sprintf (pbuf, "Angle %6.2f", angle);
		    
		  endtest(pbuf, rate, 0);
		}
		glPopMatrix();
	    }
	    printaverage();

	} else {

	    /**** Gouraud shaded RGB index lines ****/

	    sum_secs = 0.0;
	    sum_n = 0;
	    vp[4] -= 1.0;	/* make lines 10 pixels instead of 11	*/
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
		glPushMatrix();
		glRotatef(angle, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;

		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);
		    glBegin(GL_LINE_STRIP);
		    if (mod_2d) {
			for(i=(rate)/2; i; i--) {
			    glColor3fv(&c[12]);
			    glVertex2fv(vp);
			    glColor3fv(&c[8]);
			    glVertex2fv(vp+4);
			}
		    } else {
			for(i=(rate)/2; i; i--) {
			    glColor3fv(&c[12]);
			    glVertex3fv(vp);
			    glColor3fv(&c[8]);
			    glVertex3fv(vp+4);
			}
		    }
		    glEnd();

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = 10 * (rate/10);

		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    glBegin(GL_LINE_STRIP);
		    if (mod_2d) { 
			for(i=(rate)/10; i; i--) {
			    glColor3fv(&c[12]);
			    glVertex2fv(vp);
			    glColor3fv(&c[8]);
			    glVertex2fv(vp+4);
			    glColor3fv(&c[12]);
			    glVertex2fv(vp);
			    glColor3fv(&c[8]);
			    glVertex2fv(vp+4);
			    glColor3fv(&c[12]);
			    glVertex2fv(vp);
			    glColor3fv(&c[8]);
			    glVertex2fv(vp+4);
			    glColor3fv(&c[12]);
			    glVertex2fv(vp);
			    glColor3fv(&c[8]);
			    glVertex2fv(vp+4);
			    glColor3fv(&c[12]);
			    glVertex2fv(vp);
			    glColor3fv(&c[8]);
			    glVertex2fv(vp+4);
			} 

		    } else {
			for(i=(rate)/10; i; i--) {
			    glColor3fv(&c[12]);
			    glVertex2fv(vp);
			    glColor3fv(&c[8]);
			    glVertex2fv(vp+4);
			    glColor3fv(&c[12]);
			    glVertex2fv(vp);
			    glColor3fv(&c[8]);
			    glVertex2fv(vp+4);
			    glColor3fv(&c[12]);
			    glVertex2fv(vp);
			    glColor3fv(&c[8]);
			    glVertex2fv(vp+4);
			    glColor3fv(&c[12]);
			    glVertex2fv(vp);
			    glColor3fv(&c[8]);
			    glVertex2fv(vp+4);
			    glColor3fv(&c[12]);
			    glVertex2fv(vp);
			    glColor3fv(&c[8]);
			    glVertex2fv(vp+4);
			}
		    }
		    glEnd();
		  }
                  if (!mod_average)
		    sprintf (pbuf, "Angle %6.2f", angle);
		    
		  endtest(pbuf, rate, 0);
		}
		glPopMatrix();
	    }
	    printaverage();
	}
    }
    if (mod_doublebuffer) {
        auxSwapBuffers();
        Sleep(2000);               /* for visual feedback */
    }
    exit(0);
}


static void perfchar(void)
{
    int i,k;

    /*** CHARACTERS *****/

#ifdef PORTME
    /* create the bitmaps */
    glXUseXFont(theFont, '0', 10, '0');
#endif
    glListBase(0);

    /****** Calibration Loop ******/
    secs = 0.0; rate = 125;
    while (secs < (secspertest/4.0)) {
	rate = rate*2;
	starttest(0);
	for(i=(rate)/50; i; i--) {
	    glRasterPos3i(10-(WINWIDTH/2), 10, 0);
	    glCallLists(strlen(fiftychars), GL_UNSIGNED_BYTE, fiftychars);
	}

	secs = timer(1);
    }
    rate = rate * (secspertest/secs);
    rate = 50 * (rate/50);

    for (k=0; k<loopcount; k++) {
      if (starttest(k)) {
	for(i=(rate)/50; i; i--) {
	    glRasterPos3i(10-(WINWIDTH/2), 10, 0);
	    glCallLists(strlen(fiftychars), GL_UNSIGNED_BYTE, fiftychars);
	}
      }
      endtest("", rate, 1);
    }
}


static void perftmesh(void)
{
    int i,j,k;
    float *vtx = &v[0];
    char pbuf[256];
    int cVert = 60;

    /* Triangle mesh tests:  Each tmesh contains 62 vertices, or	*/
    /* 60 triangles.  To make the calculation exact, the rate	*/
    /* must be a multiple of 60.					*/

    if (mod_backface){
	glEnable(GL_CULL_FACE);
	glCullFace(GL_FRONT);
    }

    if (mod_bigger) {
	vtx = &mv[0];
	printf("bigger in tmesh\n");
    }

    /* If the triangle size is specified, set the size of the triangle mesh to
    ** fit the window.  The number of vertices must be a multiple of four (due
    ** to code below), and it must not exceed 60.
    */
    if (mod_size) {
        cVert = (int) (MINDIMENSION*2 / prim_size) - 2;
        if (cVert & 1) cVert++;
        cVert &= ~3;
        if (cVert < 4) cVert = 4;
        if (cVert > 60) cVert = 60;
    }
    
    for(i=0; i<NVERT; i++) {
	vtx[i*4+1] -= ((cVert+2)/4.0 * prim_size);
    }

    if (!mod_2d) {
	if (mod_cmode && mod_shade) {

	    /*** GOURAUD SHADED CMODE TMESH ***/
	    /* 255 = r, 240 = g, 255 = b */
	    makeramp(208,255,0,0,0,0,255,16);
	    makeramp(224,0,0,255,255,255,0,16);
	    makeramp(240,255,255,0,255,0,255,16);

	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
                if (!mod_average)
		  sprintf(pbuf, "Angle %6.2f", angle);
		  
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);
		    for(i=(rate)/cVert; i; i--) {
			glBegin(GL_TRIANGLE_STRIP);
			for (j=0; j<cVert; j+=4) {
			    glIndexi(255);
			    glVertex3fv(&vtx[j*4]);
			    glIndexi(240);
			    glVertex3fv(&vtx[(j+1)*4]);
			    glIndexi(223);
			    glVertex3fv(&vtx[(j+2)*4]);
			    glIndexi(208);
			    glVertex3fv(&vtx[(j+3)*4]);
			}
			glIndexi(255);
			glVertex3fv(&vtx[j*4]);
			glIndexi(240);
			glVertex3fv(&vtx[(j+1)*4]);
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = cVert * (rate/cVert);

		/* Do the real thing GOURAUD shaded Cmode tmesh */
		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    for(i=(rate)/cVert; i; i--) {
			glBegin(GL_TRIANGLE_STRIP);
			for (j=0; j<cVert; j+=4) {
			    glIndexi(255);
			    glVertex3fv(&vtx[j*4]);
			    glIndexi(240);
			    glVertex3fv(&vtx[(j+1)*4]);
			    glIndexi(223);
			    glVertex3fv(&vtx[(j+2)*4]);
			    glIndexi(208);
			    glVertex3fv(&vtx[(j+3)*4]);
			}
			glIndexi(255);
			glVertex3fv(&vtx[j*4]);
			glIndexi(240);
			glVertex3fv(&vtx[(j+1)*4]);
			glEnd();
		    }
		  }
		  endtest(pbuf, rate, 0);
		}

		glPopMatrix();
	    }
	    printaverage();

	} else if (!mod_light && !mod_shade) {

	    /*** FLAT SHADED TMESH ***/
	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
                if (!mod_average)
		  sprintf(pbuf, "Angle %6.2f", angle);
		  
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;

		    starttest(0);

		    for(i=(rate)/cVert; i; i--) {
			glBegin(GL_TRIANGLE_STRIP);
			for (j=0; j<cVert+2; j++) {
			    glVertex3fv(&vtx[j*4]);
			}
			glEnd();
		    }

		    secs = timer(1);

		}
		rate = rate * (secspertest/secs);
		rate = cVert * (rate/cVert);
	    
		/* Do the real thing - FLAT shaded tmesh */
		for (k=0; k<loopcount; k++) {

		  if (starttest(k)) {

		    for(i=(rate)/cVert; i; i--) {
			glBegin(GL_TRIANGLE_STRIP);
			for (j=0; j<cVert+2; j++) {
			    glVertex3fv(&vtx[j*4]);
			}
			glEnd();
		    }
		  }
		  endtest(pbuf, rate, 0);
		}
		glPopMatrix();
	    }
	    printaverage();

	} else if (!mod_cmode && mod_light) {
	    /*** LIGHTED RGB MESH ***/

	    glLoadIdentity();

	    glMatrixMode(GL_PROJECTION);
	    glLoadIdentity();
	    glOrtho(-0.5*xsize,0.5*xsize,-0.5*ysize,0.5*ysize,1.0,-1.0);

	    glMatrixMode(GL_MODELVIEW);

	    /* set lights */
	    setLightingParameters();

	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
                if (!mod_average)
		  sprintf (pbuf, "Angle %6.2f", angle);
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    if (mod_lmcolor) {
		        starttest(0);
		        for(i=(rate)/cVert; i; i--) {
			    glBegin(GL_TRIANGLE_STRIP);
			    for (j=0; j<cVert; j+=4) {
				glColor3fv(&c[16]);
			        glNormal3fv(&n[0]);
			        glVertex3fv(&vtx[j*4]);
				glColor3fv(&c[20]);
			        glNormal3fv(&n[4]);
			        glVertex3fv(&vtx[(j+1)*4]);
				glColor3fv(&c[4]);
			        glNormal3fv(&n[8]);
			        glVertex3fv(&vtx[(j+2)*4]);
				glColor3fv(&c[8]);
			        glNormal3fv(&n[12]);
			        glVertex3fv(&vtx[(j+3)*4]);
			    }
			    glColor3fv(&c[16]);
			    glNormal3fv(&n[0]);
			    glVertex3fv(&vtx[j*4]);
			    glColor3fv(&c[20]);
			    glNormal3fv(&n[4]);
			    glVertex3fv(&vtx[(j+1)*4]);
			    glEnd();
		        }
    
		        secs = timer(1);
		    }
		    else {
		        starttest(0);  
		        for(i=(rate)/cVert; i; i--) {
			    glBegin(GL_TRIANGLE_STRIP);
			    for (j=0; j<cVert; j+=4) {
			        glNormal3fv(&n[0]);
			        glVertex3fv(&vtx[j*4]);
			        glNormal3fv(&n[4]);
			        glVertex3fv(&vtx[(j+1)*4]);
			        glNormal3fv(&n[8]);
			        glVertex3fv(&vtx[(j+2)*4]);
			        glNormal3fv(&n[12]);
			        glVertex3fv(&vtx[(j+3)*4]);
			    }
			    glNormal3fv(&n[0]);
			    glVertex3fv(&vtx[j*4]);
			    glNormal3fv(&n[4]);
			    glVertex3fv(&vtx[(j+1)*4]);
			    glEnd();
		        }
    
		        secs = timer(1);
		    }
		}
		rate = rate * (secspertest/secs);
		rate = cVert * (rate/cVert);

		for (k=0; k<loopcount; k++) {
		    if (mod_lmcolor) {
		      if (starttest(k)) {
		        for(i=(rate)/cVert; i; i--) {
			    glBegin(GL_TRIANGLE_STRIP);
			    for (j=0; j<cVert; j+=4) {
				glColor3fv(&c[16]);
			        glNormal3fv(&n[0]);
			        glVertex3fv(&vtx[j*4]);
				glColor3fv(&c[20]);
			        glNormal3fv(&n[4]);
			        glVertex3fv(&vtx[(j+1)*4]);
				glColor3fv(&c[4]);
			        glNormal3fv(&n[8]);
			        glVertex3fv(&vtx[(j+2)*4]);
				glColor3fv(&c[8]);
			        glNormal3fv(&n[12]);
			        glVertex3fv(&vtx[(j+3)*4]);
			    }
			    glColor3fv(&c[16]);
			    glNormal3fv(&n[0]);
			    glVertex3fv(&vtx[j*4]);
			    glColor3fv(&c[20]);
			    glNormal3fv(&n[4]);
			    glVertex3fv(&vtx[(j+1)*4]);
			    glEnd();
		        }
		      }
		      endtest(pbuf, rate, 0);
		    }
		    else {
		      if (starttest(k)) {
		        for(i=(rate)/cVert; i; i--) {
			    glBegin(GL_TRIANGLE_STRIP);
			    for (j=0; j<cVert; j+=4) {
			        glNormal3fv(&n[0]);
			        glVertex3fv(&vtx[j*4]);
			        glNormal3fv(&n[4]);
			        glVertex3fv(&vtx[(j+1)*4]);
			        glNormal3fv(&n[8]);
			        glVertex3fv(&vtx[(j+2)*4]);
			        glNormal3fv(&n[12]);
			        glVertex3fv(&vtx[(j+3)*4]);
			    }
			    glNormal3fv(&n[0]);
			    glVertex3fv(&vtx[j*4]);
			    glNormal3fv(&n[4]);
			    glVertex3fv(&vtx[(j+1)*4]);
			    glEnd();
		        }
		      }
		      endtest(pbuf, rate, 0);
		    }
		}
		glPopMatrix();
	    }
	    printaverage();

	} else if (!mod_cmode && mod_shade) {

	    /*** GOURAUD SHADED RGB TMESH ***/
	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
                if (!mod_average)
		  sprintf(pbuf, "Angle %6.2f", angle);
		  
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);
		    for(i=(rate)/cVert; i; i--) {
			glBegin(GL_TRIANGLE_STRIP);
			for (j=0; j<cVert; j+=4) {
			    glColor3fv(&c[4]);
			    glVertex3fv(&vtx[j*4]);
			    glColor3fv(&c[8]);
			    glVertex3fv(&vtx[(j+1)*4]);
			    glColor3fv(&c[12]);
			    glVertex3fv(&vtx[(j+2)*4]);
			    glColor3fv(&c[16]);
			    glVertex3fv(&vtx[(j+3)*4]);
			}
			glColor3fv(&c[4]);
			glVertex3fv(&vtx[j*4]);
			glColor3fv(&c[8]);
			glVertex3fv(&vtx[(j+1)*4]);
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = cVert * (rate/cVert);

		/* Do the real thing GOURAUD shaded tmesh */
		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    for(i=(rate)/cVert; i; i--) {
			glBegin(GL_TRIANGLE_STRIP);
			for (j=0; j<cVert; j+=4) {
			    glColor3fv(&c[4]);
			    glVertex3fv(&vtx[j*4]);
			    glColor3fv(&c[8]);
			    glVertex3fv(&vtx[(j+1)*4]);
			    glColor3fv(&c[12]);
			    glVertex3fv(&vtx[(j+2)*4]);
			    glColor3fv(&c[16]);
			    glVertex3fv(&vtx[(j+3)*4]);
			}
			glColor3fv(&c[4]);
			glVertex3fv(&vtx[j*4]);
			glColor3fv(&c[8]);
			glVertex3fv(&vtx[(j+1)*4]);
			glEnd();
		    }
		  }
		  endtest(pbuf, rate, 0);
		}

		glPopMatrix();
	    }
	    printaverage();
	}

    } else {	/* must be 2d */
	if (mod_cmode && mod_shade) { /* color map lighting yet */

	    /*** GOURAUD SHADED CMODE TMESH ***/
	    /* 255 = r, 240 = g, 255 = b */
	    makeramp(208,255,0,0,0,0,255,16);
	    makeramp(224,0,0,255,255,255,0,16);
	    makeramp(240,255,255,0,255,0,255,16);

	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
                if (!mod_average)
		  sprintf(pbuf, "Angle %6.2f", angle);
		  
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);
		    for(i=(rate)/cVert; i; i--) {
			glBegin(GL_TRIANGLE_STRIP);
			for (j=0; j<cVert; j+=4) {
			    glIndexi(255);
			    glVertex2fv(&vtx[j*4]);
			    glIndexi(240);
			    glVertex2fv(&vtx[(j+1)*4]);
			    glIndexi(223);
			    glVertex3fv(&vtx[(j+2)*4]);
			    glIndexi(208);
			    glVertex3fv(&vtx[(j+3)*4]);
			}
			glIndexi(255);
			glVertex3fv(&vtx[j*4]);
			glIndexi(240);
			glVertex3fv(&vtx[(j+1)*4]);
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = cVert * (rate/cVert);

		/* Do the real thing GOURAUD shaded Cmode tmesh */
		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    for(i=(rate)/cVert; i; i--) {
			glBegin(GL_TRIANGLE_STRIP);
			for (j=0; j<cVert; j+=4) {
			    glIndexi(255);
			    glVertex2fv(&vtx[j*4]);
			    glIndexi(240);
			    glVertex2fv(&vtx[(j+1)*4]);
			    glIndexi(223);
			    glVertex3fv(&vtx[(j+2)*4]);
			    glIndexi(208);
			    glVertex3fv(&vtx[(j+3)*4]);
			}
			glIndexi(255);
			glVertex3fv(&vtx[j*4]);
			glIndexi(240);
			glVertex3fv(&vtx[(j+1)*4]);
			glEnd();
		    }
		  }
		  endtest(pbuf, rate, 0);
		}

		glPopMatrix();
	    }
	    printaverage();

	} else if (!mod_light && !mod_shade) {

	    /*** FLAT SHADED TMESH ***/
	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
                if (!mod_average)
		  sprintf(pbuf, "Angle %6.2f", angle);
		  
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);
		    for(i=(rate)/cVert; i; i--) {
			glBegin(GL_TRIANGLE_STRIP);
			for (j=0; j<cVert+2; j++) {
			    glVertex2fv(&vtx[j*4]);
			}
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = cVert * (rate/cVert);
	    
		/* Do the real thing - FLAT shaded tmesh */
		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    for(i=(rate)/cVert; i; i--) {
			glBegin(GL_TRIANGLE_STRIP);
			for (j=0; j<cVert+2; j++) {
			    glVertex2fv(&vtx[j*4]);
			}
			glEnd();
		    }
		  }
		  endtest(pbuf, rate, 0);
		}
		glPopMatrix();
	    }
	    printaverage();

	} else if (!mod_cmode && mod_light) {

	    /*** LIGHTED RGB MESH ***/
	    glLoadIdentity();

	    glMatrixMode(GL_PROJECTION);
	    glLoadIdentity();
	    glOrtho(-0.5*xsize,0.5*xsize,-0.5*ysize,0.5*ysize,1.0,-1.0);
	    glMatrixMode(GL_MODELVIEW);

	    /* set lights */
	    setLightingParameters();

	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
                if (!mod_average)
		  sprintf (pbuf, "Angle %6.2f", angle);
		  
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    if (mod_lmcolor) {
		        starttest(0);
		        for(i=(rate)/cVert; i; i--) {
			    glBegin(GL_TRIANGLE_STRIP);
			    for (j=0; j<cVert; j+=4) {
				glColor3fv(&c[16]);
			        glNormal3fv(&n[0]);
			        glVertex3fv(&vtx[j*4]);
				glColor3fv(&c[20]);
			        glNormal3fv(&n[4]);
			        glVertex3fv(&vtx[(j+1)*4]);
				glColor3fv(&c[4]);
			        glNormal3fv(&n[8]);
			        glVertex3fv(&vtx[(j+2)*4]);
				glColor3fv(&c[8]);
			        glNormal3fv(&n[12]);
			        glVertex3fv(&vtx[(j+3)*4]);
			    }
			    glColor3fv(&c[16]);
			    glNormal3fv(&n[0]);
			    glVertex3fv(&vtx[j*4]);
			    glColor3fv(&c[20]);
			    glNormal3fv(&n[4]);
			    glVertex3fv(&vtx[(j+1)*4]);
			    glEnd();
		        }
    
		        secs = timer(1);
		    }
		    else {
		        starttest(0);
		        for(i=(rate)/cVert; i; i--) {
			    glBegin(GL_TRIANGLE_STRIP);
			    for (j=0; j<cVert; j+=4) {
			        glNormal3fv(&n[0]);
			        glVertex3fv(&vtx[j*4]);
			        glNormal3fv(&n[4]);
			        glVertex3fv(&vtx[(j+1)*4]);
			        glNormal3fv(&n[8]);
			        glVertex3fv(&vtx[(j+2)*4]);
			        glNormal3fv(&n[12]);
			        glVertex3fv(&vtx[(j+3)*4]);
			    }
			    glNormal3fv(&n[0]);
			    glVertex3fv(&vtx[j*4]);
			    glNormal3fv(&n[4]);
			    glVertex3fv(&vtx[(j+1)*4]);
			    glEnd();
		        }
    
		        secs = timer(1);
		    }
		}
		rate = rate * (secspertest/secs);
		rate = cVert * (rate/cVert);

		for (k=0; k<loopcount; k++) {
		    if (mod_lmcolor) {
		      if (starttest(k)) {
		        for(i=(rate)/cVert; i; i--) {
			    glBegin(GL_TRIANGLE_STRIP);
			    for (j=0; j<cVert; j+=4) {
				glColor3fv(&c[16]);
			        glNormal3fv(&n[0]);
			        glVertex3fv(&vtx[j*4]);
				glColor3fv(&c[20]);
			        glNormal3fv(&n[4]);
			        glVertex3fv(&vtx[(j+1)*4]);
				glColor3fv(&c[4]);
			        glNormal3fv(&n[8]);
			        glVertex3fv(&vtx[(j+2)*4]);
				glColor3fv(&c[8]);
			        glNormal3fv(&n[12]);
			        glVertex3fv(&vtx[(j+3)*4]);
			    }
			    glColor3fv(&c[16]);
			    glNormal3fv(&n[0]);
			    glVertex3fv(&vtx[j*4]);
			    glColor3fv(&c[20]);
			    glNormal3fv(&n[4]);
			    glVertex3fv(&vtx[(j+1)*4]);
			    glEnd();
		        }
		      }
		      endtest(pbuf, rate, 0);
		    }
		    else {
		      if (starttest(k)) {
		        for(i=(rate)/cVert; i; i--) {
			    glBegin(GL_TRIANGLE_STRIP);
			    for (j=0; j<cVert; j+=4) {
			        glNormal3fv(&n[0]);
			        glVertex3fv(&vtx[j*4]);
			        glNormal3fv(&n[4]);
			        glVertex3fv(&vtx[(j+1)*4]);
			        glNormal3fv(&n[8]);
			        glVertex3fv(&vtx[(j+2)*4]);
			        glNormal3fv(&n[12]);
			        glVertex3fv(&vtx[(j+3)*4]);
			    }
			    glNormal3fv(&n[0]);
			    glVertex3fv(&vtx[j*4]);
			    glNormal3fv(&n[4]);
			    glVertex3fv(&vtx[(j+1)*4]);
			    glEnd();
		        }
		      }
		      endtest(pbuf, rate, 0);
		    }
		}
		glPopMatrix();
	    }
	    printaverage();

	} else if (!mod_cmode && mod_shade) {

	    /*** GOURAUD SHADED RGB TMESH ***/
	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
                if (!mod_average)
		  sprintf(pbuf, "Angle %6.2f", angle);
		  
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);
		    for(i=(rate)/cVert; i; i--) {
			glBegin(GL_TRIANGLE_STRIP);
			for (j=0; j<cVert; j+=4) {
			    glColor3fv(&c[4]);
			    glVertex3fv(&vtx[j*4]);
			    glColor3fv(&c[8]);
			    glVertex3fv(&vtx[(j+1)*4]);
			    glColor3fv(&c[12]);
			    glVertex3fv(&vtx[(j+2)*4]);
			    glColor3fv(&c[16]);
			    glVertex3fv(&vtx[(j+3)*4]);
			}
			glColor3fv(&c[4]);
			glVertex3fv(&vtx[j*4]);
			glColor3fv(&c[8]);
			glVertex3fv(&vtx[(j+1)*4]);
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = cVert * (rate/cVert);

		/* Do the real thing GOURAUD shaded tmesh */
		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    for(i=(rate)/cVert; i; i--) {
			glBegin(GL_TRIANGLE_STRIP);
			for (j=0; j<cVert; j+=4) {
			    glColor3fv(&c[4]);
			    glVertex3fv(&vtx[j*4]);
			    glColor3fv(&c[8]);
			    glVertex3fv(&vtx[(j+1)*4]);
			    glColor3fv(&c[12]);
			    glVertex3fv(&vtx[(j+2)*4]);
			    glColor3fv(&c[16]);
			    glVertex3fv(&vtx[(j+3)*4]);
			}
			glColor3fv(&c[4]);
			glVertex3fv(&vtx[j*4]);
			glColor3fv(&c[8]);
			glVertex3fv(&vtx[(j+1)*4]);
			glEnd();
		    }
		  }
		  endtest(pbuf, rate, 0);
		}

		glPopMatrix();
	    }
	    printaverage();

	}
    }
    if (mod_doublebuffer) {
        auxSwapBuffers();
        Sleep(2000);               /* for visual feedback */
    }
    exit(0);
}


static void perfpoly(void)
{
    float *vtx = &v[0];
    int i, k;
    char pbuf[256];
    int cPoly;

    if (mod_pattern) {
	glEnable(GL_POLYGON_STIPPLE);
	glPolygonStipple((GLubyte *) pattern);
    }

    /* If the polygon size is specified, set the number of polygons to
    ** fit the window.  The maximum number of polygons is 5.
    */
    cPoly = 5;
    if (mod_size) {
        cPoly = (int) (MINDIMENSION/2 / prim_size);
        if (cPoly < 1) cPoly = 1;
        if (cPoly > 5) cPoly = 5;
    }
    
    if (!mod_2d) {

	/**** 3D POLYGONS ****/

	if (mod_light && !mod_cmode) {

	/*** POLYGONS (LIGHTED) *****/

	    glLoadIdentity();
	    
	    glMatrixMode(GL_PROJECTION);
	    glLoadIdentity();
	    glOrtho(-0.5*xsize, 0.5*xsize,-0.5*ysize, 0.5*ysize,1.0, -1.0);
	    
	    glMatrixMode(GL_MODELVIEW);

	    /* set lights */
	    setLightingParameters();

	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
                if (!mod_average)
		  sprintf (pbuf, "Angle %6.2f", angle);
		  
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    if (mod_lmcolor) {
		        starttest(0);
		        for(i=(rate)/cPoly; i; i--) {
			    glBegin(GL_QUADS);
                            switch (cPoly) {
                              case 5:
			        glColor3fv(&c[4]); glNormal3fv(&n[0]); 
			        glVertex3fv(vtx+32); 
			        glColor3fv(&c[16]); glNormal3fv(&n[4]); 
			        glVertex3fv(vtx+36); 
			        glColor3fv(&c[8]); glNormal3fv(&n[8]); 
			        glVertex3fv(vtx+44); 
			        glColor3fv(&c[8]); glNormal3fv(&n[12]); 
			        glVertex3fv(vtx+40);
                              case 4:
			        glColor3fv(&c[4]); glNormal3fv(&n[0]); 
			        glVertex3fv(vtx+24); 
			        glColor3fv(&c[16]); glNormal3fv(&n[4]); 
			        glVertex3fv(vtx+28); 
			        glColor3fv(&c[8]); glNormal3fv(&n[8]); 
			        glVertex3fv(vtx+36); 
			        glColor3fv(&c[8]); glNormal3fv(&n[12]); 
			        glVertex3fv(vtx+32);
                              case 3:
			        glColor3fv(&c[4]); glNormal3fv(&n[0]); 
			        glVertex3fv(vtx+16); 
			        glColor3fv(&c[16]); glNormal3fv(&n[4]); 
			        glVertex3fv(vtx+20); 
			        glColor3fv(&c[8]); glNormal3fv(&n[8]); 
			        glVertex3fv(vtx+28); 
			        glColor3fv(&c[8]); glNormal3fv(&n[12]); 
			        glVertex3fv(vtx+24);
                              case 2:
			        glColor3fv(&c[4]); glNormal3fv(&n[0]); 
			        glVertex3fv(vtx+8); 
			        glColor3fv(&c[16]); glNormal3fv(&n[4]); 
			        glVertex3fv(vtx+12); 
			        glColor3fv(&c[8]); glNormal3fv(&n[8]); 
			        glVertex3fv(vtx+20); 
			        glColor3fv(&c[8]); glNormal3fv(&n[12]); 
			        glVertex3fv(vtx+16);
                              case 1:
			        glColor3fv(&c[4]); glNormal3fv(&n[0]); 
			        glVertex3fv(vtx); 
			        glColor3fv(&c[16]); glNormal3fv(&n[4]); 
			        glVertex3fv(vtx+4); 
			        glColor3fv(&c[8]); glNormal3fv(&n[8]); 
			        glVertex3fv(vtx+12); 
			        glColor3fv(&c[8]); glNormal3fv(&n[12]); 
			        glVertex3fv(vtx+8);
			    }
			    glEnd();
		        }
    
		        secs = timer(1);
		    }
		    else {
		        starttest(0);
		        for(i=(rate)/cPoly; i; i--) {
			    glBegin(GL_QUADS);
			    switch (cPoly) {
			      case 5:
			        glNormal3fv(&n[0]); glVertex3fv(vtx+32); 
			        glNormal3fv(&n[4]); glVertex3fv(vtx+36); 
			        glNormal3fv(&n[8]); glVertex3fv(vtx+44); 
			        glNormal3fv(&n[12]); glVertex3fv(vtx+40);
                              case 4:
			        glNormal3fv(&n[0]); glVertex3fv(vtx+24); 
			        glNormal3fv(&n[4]); glVertex3fv(vtx+28); 
			        glNormal3fv(&n[8]); glVertex3fv(vtx+36); 
			        glNormal3fv(&n[12]); glVertex3fv(vtx+32);
                              case 3:
			        glNormal3fv(&n[0]); glVertex3fv(vtx+16); 
			        glNormal3fv(&n[4]); glVertex3fv(vtx+20); 
			        glNormal3fv(&n[8]); glVertex3fv(vtx+28); 
			        glNormal3fv(&n[12]); glVertex3fv(vtx+24);
                              case 2:
			        glNormal3fv(&n[0]); glVertex3fv(vtx+8); 
			        glNormal3fv(&n[4]); glVertex3fv(vtx+12); 
			        glNormal3fv(&n[8]); glVertex3fv(vtx+20); 
			        glNormal3fv(&n[12]); glVertex3fv(vtx+16);
                              case 1:
			        glNormal3fv(&n[0]); glVertex3fv(vtx); 
			        glNormal3fv(&n[4]); glVertex3fv(vtx+4); 
			        glNormal3fv(&n[8]); glVertex3fv(vtx+12); 
			        glNormal3fv(&n[12]); glVertex3fv(vtx+8);
			    }
			    glEnd();
			}
    
		        secs = timer(1);
		    }
		}
		rate = rate * (secspertest/secs);
		rate = cPoly * (rate/cPoly);

		for (k=0; k<loopcount; k++) {
		    if (mod_lmcolor) {
		      if (starttest(k)) {
		        for(i=(rate)/cPoly; i; i--) {
			    glBegin(GL_QUADS);
			    switch (cPoly) {
			      case 5:
			        glColor3fv(&c[4]); glNormal3fv(&n[0]);
			        glVertex3fv(vtx+32); 
			        glColor3fv(&c[16]); glNormal3fv(&n[4]);
			        glVertex3fv(vtx+36); 
			        glColor3fv(&c[8]); glNormal3fv(&n[8]);
			        glVertex3fv(vtx+44); 
			        glColor3fv(&c[8]); glNormal3fv(&n[12]);
			        glVertex3fv(vtx+40);
                              case 4:
			        glColor3fv(&c[4]); glNormal3fv(&n[0]);
			        glVertex3fv(vtx+24); 
			        glColor3fv(&c[16]); glNormal3fv(&n[4]);
			        glVertex3fv(vtx+28); 
			        glColor3fv(&c[8]); glNormal3fv(&n[8]);
			        glVertex3fv(vtx+36); 
			        glColor3fv(&c[8]); glNormal3fv(&n[12]);
			        glVertex3fv(vtx+32);
                              case 3:
			        glColor3fv(&c[4]); glNormal3fv(&n[0]);
			        glVertex3fv(vtx+16); 
			        glColor3fv(&c[16]); glNormal3fv(&n[4]);
			        glVertex3fv(vtx+20); 
			        glColor3fv(&c[8]); glNormal3fv(&n[8]);
			        glVertex3fv(vtx+28); 
			        glColor3fv(&c[8]); glNormal3fv(&n[12]);
			        glVertex3fv(vtx+24);
                              case 2:
			        glColor3fv(&c[4]); glNormal3fv(&n[0]);
			        glVertex3fv(vtx+8); 
			        glColor3fv(&c[16]); glNormal3fv(&n[4]);
			        glVertex3fv(vtx+12); 
			        glColor3fv(&c[8]); glNormal3fv(&n[8]);
			        glVertex3fv(vtx+20); 
			        glColor3fv(&c[8]); glNormal3fv(&n[12]);
			        glVertex3fv(vtx+16);
                              case 1:
			        glColor3fv(&c[4]); glNormal3fv(&n[0]);
			        glVertex3fv(vtx); 
			        glColor3fv(&c[16]); glNormal3fv(&n[4]); 
			        glVertex3fv(vtx+4); 
			        glColor3fv(&c[8]); glNormal3fv(&n[8]);
			        glVertex3fv(vtx+12); 
			        glColor3fv(&c[8]); glNormal3fv(&n[12]);
			        glVertex3fv(vtx+8);
			    }
			    glEnd();
		        }
		      }
		      endtest(pbuf, rate, 0);
		    }
		    else {
		      if (starttest(k)) {
		        for(i=(rate)/cPoly; i; i--) {
			    glBegin(GL_QUADS);
			    switch (cPoly) {
			      case 5:
			        glNormal3fv(&n[0]); glVertex3fv(vtx+32); 
			        glNormal3fv(&n[4]); glVertex3fv(vtx+36); 
			        glNormal3fv(&n[8]); glVertex3fv(vtx+44); 
			        glNormal3fv(&n[12]); glVertex3fv(vtx+40);
                              case 4:
			        glNormal3fv(&n[0]); glVertex3fv(vtx+24); 
			        glNormal3fv(&n[4]); glVertex3fv(vtx+28); 
			        glNormal3fv(&n[8]); glVertex3fv(vtx+36); 
			        glNormal3fv(&n[12]); glVertex3fv(vtx+32);
                              case 3:
			        glNormal3fv(&n[0]); glVertex3fv(vtx+16); 
			        glNormal3fv(&n[4]); glVertex3fv(vtx+20); 
			        glNormal3fv(&n[8]); glVertex3fv(vtx+28); 
			        glNormal3fv(&n[12]); glVertex3fv(vtx+24);
                              case 2:
			        glNormal3fv(&n[0]); glVertex3fv(vtx+8); 
			        glNormal3fv(&n[4]); glVertex3fv(vtx+12); 
			        glNormal3fv(&n[8]); glVertex3fv(vtx+20); 
			        glNormal3fv(&n[12]); glVertex3fv(vtx+16);
                              case 1:
			        glNormal3fv(&n[0]); glVertex3fv(vtx); 
			        glNormal3fv(&n[4]); glVertex3fv(vtx+4); 
			        glNormal3fv(&n[8]); glVertex3fv(vtx+12); 
			        glNormal3fv(&n[12]); glVertex3fv(vtx+8);
			    }
			    glEnd();
		        }
		      }
		      endtest(pbuf, rate, 0);
		    }
		}

		glPopMatrix();
	    }
	    printaverage();
	} else if (mod_shade && !mod_cmode) {

	    /*** POLYGONS (SHADED RGB) *****/

	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
                if (!mod_average)
		  sprintf(pbuf, "Angle %6.2f", angle);
		  
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);
		    for(i=(rate)/cPoly; i; i--) {
			glBegin(GL_QUADS);
			switch (cPoly) {
			  case 5:
			    glColor3fv(&c[4]); glVertex3fv(vtx+32); 
			    glColor3fv(&c[16]); glVertex3fv(vtx+36); 
			    glColor3fv(&c[8]); glVertex3fv(vtx+44); 
			    glColor3fv(&c[8]); glVertex3fv(vtx+40);
                          case 4:
			    glColor3fv(&c[4]); glVertex3fv(vtx+24); 
			    glColor3fv(&c[16]); glVertex3fv(vtx+28); 
			    glColor3fv(&c[8]); glVertex3fv(vtx+36); 
			    glColor3fv(&c[8]); glVertex3fv(vtx+32);
                          case 3:
			    glColor3fv(&c[4]); glVertex3fv(vtx+16); 
			    glColor3fv(&c[16]); glVertex3fv(vtx+20); 
			    glColor3fv(&c[8]); glVertex3fv(vtx+28); 
			    glColor3fv(&c[8]); glVertex3fv(vtx+24);
                          case 2:
			    glColor3fv(&c[4]); glVertex3fv(vtx+8); 
			    glColor3fv(&c[16]); glVertex3fv(vtx+12); 
			    glColor3fv(&c[8]); glVertex3fv(vtx+20); 
			    glColor3fv(&c[8]); glVertex3fv(vtx+16);
                          case 1:
			    glColor3fv(&c[4]); glVertex3fv(vtx); 
			    glColor3fv(&c[16]); glVertex3fv(vtx+4); 
			    glColor3fv(&c[8]); glVertex3fv(vtx+12); 
			    glColor3fv(&c[8]); glVertex3fv(vtx+8);
			}
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = cPoly * (rate/cPoly);

		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    for(i=(rate)/cPoly; i; i--) {
			glBegin(GL_QUADS);
			switch (cPoly) {
			  case 5:
			    glColor3fv(&c[4]); glVertex3fv(vtx+32); 
			    glColor3fv(&c[16]); glVertex3fv(vtx+36); 
			    glColor3fv(&c[8]); glVertex3fv(vtx+44); 
			    glColor3fv(&c[8]); glVertex3fv(vtx+40);
                          case 4:
			    glColor3fv(&c[4]); glVertex3fv(vtx+24); 
			    glColor3fv(&c[16]); glVertex3fv(vtx+28); 
			    glColor3fv(&c[8]); glVertex3fv(vtx+36); 
			    glColor3fv(&c[8]); glVertex3fv(vtx+32);
                          case 3:
			    glColor3fv(&c[4]); glVertex3fv(vtx+16); 
			    glColor3fv(&c[16]); glVertex3fv(vtx+20); 
			    glColor3fv(&c[8]); glVertex3fv(vtx+28); 
			    glColor3fv(&c[8]); glVertex3fv(vtx+24);
                          case 2:
			    glColor3fv(&c[4]); glVertex3fv(vtx+8); 
			    glColor3fv(&c[16]); glVertex3fv(vtx+12); 
			    glColor3fv(&c[8]); glVertex3fv(vtx+20); 
			    glColor3fv(&c[8]); glVertex3fv(vtx+16);
                          case 1:
			    glColor3fv(&c[4]); glVertex3fv(vtx); 
			    glColor3fv(&c[16]); glVertex3fv(vtx+4); 
			    glColor3fv(&c[8]); glVertex3fv(vtx+12); 
			    glColor3fv(&c[8]); glVertex3fv(vtx+8);
			}
			glEnd();
		    }
		  }
		  endtest(pbuf, rate, 0);
		}

		glPopMatrix();
	    }
	    printaverage();
	} else if (mod_shade && mod_cmode) {

	    /*** POLYGONS (SHADED COLOR MAPPED) *****/

	    /* 255 = r, 240 = g, 255 = b */
	    makeramp(208, 255, 0, 0, 0, 0, 255, 16);
	    makeramp(224, 0, 0, 255, 255, 255, 0, 16);
	    makeramp(240, 255, 255, 0, 255, 0, 255, 16);

	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
                if (!mod_average)
		  sprintf(pbuf, "Angle %6.2f", angle);
		  
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);
		    for(i=(rate)/cPoly; i; i--) {
			glBegin(GL_QUADS);
			switch (cPoly) {
			  case 5:
			    glIndexi(255); glVertex3fv(vtx+32); 
			    glIndexi(240); glVertex3fv(vtx+36); 
			    glIndexi(223); glVertex3fv(vtx+44); 
			    glIndexi(208); glVertex3fv(vtx+40);
                          case 4:
			    glIndexi(255); glVertex3fv(vtx+24); 
			    glIndexi(240); glVertex3fv(vtx+28); 
			    glIndexi(223); glVertex3fv(vtx+36); 
			    glIndexi(208); glVertex3fv(vtx+32);
                          case 3:
			    glIndexi(255); glVertex3fv(vtx+16); 
			    glIndexi(240); glVertex3fv(vtx+20); 
			    glIndexi(223); glVertex3fv(vtx+28); 
			    glIndexi(208); glVertex3fv(vtx+24);
                          case 2:
			    glIndexi(255); glVertex3fv(vtx+8); 
			    glIndexi(240); glVertex3fv(vtx+12); 
			    glIndexi(223); glVertex3fv(vtx+20); 
			    glIndexi(208); glVertex3fv(vtx+16);
                          case 1:
			    glIndexi(255); glVertex3fv(vtx); 
			    glIndexi(240); glVertex3fv(vtx+4); 
			    glIndexi(223); glVertex3fv(vtx+12); 
			    glIndexi(208); glVertex3fv(vtx+8);
			}
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = cPoly * (rate/cPoly);

		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    for(i=(rate)/cPoly; i; i--) {
			glBegin(GL_QUADS);
			switch (cPoly) {
			  case 5:
			    glIndexi(255); glVertex3fv(vtx+32); 
			    glIndexi(240); glVertex3fv(vtx+36); 
			    glIndexi(223); glVertex3fv(vtx+44); 
			    glIndexi(208); glVertex3fv(vtx+40);
                          case 4:
			    glIndexi(255); glVertex3fv(vtx+24); 
			    glIndexi(240); glVertex3fv(vtx+28); 
			    glIndexi(223); glVertex3fv(vtx+36); 
			    glIndexi(208); glVertex3fv(vtx+32);
                          case 3:
			    glIndexi(255); glVertex3fv(vtx+16); 
			    glIndexi(240); glVertex3fv(vtx+20); 
			    glIndexi(223); glVertex3fv(vtx+28); 
			    glIndexi(208); glVertex3fv(vtx+24);
                          case 2:
			    glIndexi(255); glVertex3fv(vtx+8); 
			    glIndexi(240); glVertex3fv(vtx+12); 
			    glIndexi(223); glVertex3fv(vtx+20); 
			    glIndexi(208); glVertex3fv(vtx+16);
                          case 1:
			    glIndexi(255); glVertex3fv(vtx); 
			    glIndexi(240); glVertex3fv(vtx+4); 
			    glIndexi(223); glVertex3fv(vtx+12); 
			    glIndexi(208); glVertex3fv(vtx+8);
			}
			glEnd();
		    }
		  }
		  endtest(pbuf, rate, 0);
		}

		glPopMatrix();
	    }
	    printaverage();

	} else if (!mod_light && !mod_shade) {

	    /*** POLYGONS (FLAT SHADED) *****/

	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
                if (!mod_average)
		  sprintf(pbuf, "Angle %6.2f", angle);
		  
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);
		    for(i=(rate)/cPoly; i; i--) {
			glBegin(GL_QUADS);
			switch (cPoly) {
			  case 5:
			    glVertex3fv(vtx+32); glVertex3fv(vtx+36);
			    glVertex3fv(vtx+44); glVertex3fv(vtx+40);
                          case 4:
			    glVertex3fv(vtx+24); glVertex3fv(vtx+28);
			    glVertex3fv(vtx+36); glVertex3fv(vtx+32);
                          case 3:
			    glVertex3fv(vtx+16); glVertex3fv(vtx+20);
			    glVertex3fv(vtx+28); glVertex3fv(vtx+24);
                          case 2:
			    glVertex3fv(vtx+8); glVertex3fv(vtx+12);
			    glVertex3fv(vtx+20); glVertex3fv(vtx+16);
                          case 1:
			    glVertex3fv(vtx); glVertex3fv(vtx+4);
			    glVertex3fv(vtx+12); glVertex3fv(vtx+8);
			}
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = cPoly * (rate/cPoly);

		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    for(i=(rate)/cPoly; i; i--) {
			glBegin(GL_QUADS);
			switch (cPoly) {
			  case 5:
			    glVertex3fv(vtx+32); glVertex3fv(vtx+36);
			    glVertex3fv(vtx+44); glVertex3fv(vtx+40);
			  case 4:
			    glVertex3fv(vtx+24); glVertex3fv(vtx+28);
			    glVertex3fv(vtx+36); glVertex3fv(vtx+32);
			  case 3:
			    glVertex3fv(vtx+16); glVertex3fv(vtx+20);
			    glVertex3fv(vtx+28); glVertex3fv(vtx+24);
			  case 2:
			    glVertex3fv(vtx+8); glVertex3fv(vtx+12);
			    glVertex3fv(vtx+20); glVertex3fv(vtx+16);
			  case 1:
			    glVertex3fv(vtx+0); glVertex3fv(vtx+4);
			    glVertex3fv(vtx+12); glVertex3fv(vtx+8);
			}
			glEnd();
		    }
		  }
		  endtest(pbuf, rate, 0);
		}
		glPopMatrix();
	    }
	    printaverage();
	}
    } else {

	/**** 2D POLYGONS ****/

	if (mod_light && !mod_cmode) {

	/*** POLYGONS (LIGHTED) *****/

	    glLoadIdentity();

	    glMatrixMode(GL_PROJECTION);
	    glLoadIdentity();
	    gluOrtho2D(-0.5*xsize, 0.5*xsize,-0.5*ysize, 0.5*ysize);
	    glMatrixMode(GL_MODELVIEW);

	    /* set lights */
	    setLightingParameters();
    
	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
                if (!mod_average)
		  sprintf(pbuf, "Angle %6.2f", angle);
		  
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    if (mod_lmcolor) {
		        starttest(0);
		        for(i=(rate)/cPoly; i; i--) {
			    glBegin(GL_QUADS);
			    switch (cPoly) {
			      case 5:
			        glColor3fv(&c[4]); glNormal3fv(&n[0]); 
			        glVertex2fv(vtx+32); 
			        glColor3fv(&c[16]); glNormal3fv(&n[4]); 
			        glVertex2fv(vtx+36); 
			        glColor3fv(&c[8]); glNormal3fv(&n[8]); 
			        glVertex2fv(vtx+44); 
			        glColor3fv(&c[8]); glNormal3fv(&n[12]);
			        glVertex2fv(vtx+40);
			      case 4:
			        glColor3fv(&c[4]); glNormal3fv(&n[0]); 
			        glVertex2fv(vtx+24); 
			        glColor3fv(&c[16]); glNormal3fv(&n[4]);
			        glVertex2fv(vtx+28); 
			        glColor3fv(&c[8]); glNormal3fv(&n[8]); 
			        glVertex2fv(vtx+36); 
			        glColor3fv(&c[8]); glNormal3fv(&n[12]);
			        glVertex2fv(vtx+32);
			      case 3:
			        glColor3fv(&c[4]); glNormal3fv(&n[0]);
			        glVertex2fv(vtx+16); 
			        glColor3fv(&c[16]); glNormal3fv(&n[4]);
			        glVertex2fv(vtx+20); 
			        glColor3fv(&c[8]); glNormal3fv(&n[8]); 
			        glVertex2fv(vtx+28); 
			        glColor3fv(&c[8]); glNormal3fv(&n[12]);
			        glVertex2fv(vtx+24);
			      case 2:
			        glColor3fv(&c[4]); glNormal3fv(&n[0]); 
			        glVertex2fv(vtx+8); 
			        glColor3fv(&c[16]); glNormal3fv(&n[4]);
			        glVertex2fv(vtx+12); 
			        glColor3fv(&c[8]); glNormal3fv(&n[8]);
			        glVertex2fv(vtx+20); 
			        glColor3fv(&c[8]); glNormal3fv(&n[12]);
			        glVertex2fv(vtx+16);
			      case 1:
			        glColor3fv(&c[4]); glNormal3fv(&n[0]);
			        glVertex2fv(vtx); 
			        glColor3fv(&c[16]); glNormal3fv(&n[4]);
			        glVertex2fv(vtx+4); 
			        glColor3fv(&c[8]); glNormal3fv(&n[8]);
			        glVertex2fv(vtx+12); 
			        glColor3fv(&c[8]); glNormal3fv(&n[12]);
			        glVertex2fv(vtx+8);
			    }
			    glEnd();
		        }
    
		        secs = timer(1);
		    }
		    else {
		        starttest(0);
		        for(i=(rate)/cPoly; i; i--) {
			    glBegin(GL_QUADS);
			    switch (cPoly) {
			      case 5:
			        glNormal3fv(&n[0]); glVertex2fv(vtx+32); 
			        glNormal3fv(&n[4]); glVertex2fv(vtx+36); 
			        glNormal3fv(&n[8]); glVertex2fv(vtx+44); 
			        glNormal3fv(&n[12]); glVertex2fv(vtx+40);
			      case 4:
			        glNormal3fv(&n[0]); glVertex2fv(vtx+24); 
			        glNormal3fv(&n[4]); glVertex2fv(vtx+28); 
			        glNormal3fv(&n[8]); glVertex2fv(vtx+36); 
			        glNormal3fv(&n[12]); glVertex2fv(vtx+32);
			      case 3:
			        glNormal3fv(&n[0]); glVertex2fv(vtx+16); 
			        glNormal3fv(&n[4]); glVertex2fv(vtx+20); 
			        glNormal3fv(&n[8]); glVertex2fv(vtx+28); 
			        glNormal3fv(&n[12]); glVertex2fv(vtx+24);
			      case 2:
			        glNormal3fv(&n[0]); glVertex2fv(vtx+8); 
			        glNormal3fv(&n[4]); glVertex2fv(vtx+12); 
			        glNormal3fv(&n[8]); glVertex2fv(vtx+20); 
			        glNormal3fv(&n[12]); glVertex2fv(vtx+16);
			      case 1:
			        glNormal3fv(&n[0]); glVertex2fv(vtx); 
			        glNormal3fv(&n[4]); glVertex2fv(vtx+4); 
			        glNormal3fv(&n[8]); glVertex2fv(vtx+12); 
			        glNormal3fv(&n[12]); glVertex2fv(vtx+8);
			    }
			    glEnd();
		        }
    
		        secs = timer(1);
		    }
		}
		rate = rate * (secspertest/secs);
		rate = cPoly * (rate/cPoly);

		for (k=0; k<loopcount; k++) {
		    if (mod_lmcolor) {
		      if (starttest(k)) {
		        for(i=(rate)/cPoly; i; i--) {
			    glBegin(GL_QUADS);
			    switch (cPoly) {
			      case 5:
			        glColor3fv(&c[4]); glNormal3fv(&n[0]);
			        glVertex2fv(vtx+32); 
			        glColor3fv(&c[16]); glNormal3fv(&n[4]);
			        glVertex2fv(vtx+36); 
			        glColor3fv(&c[8]); glNormal3fv(&n[8]);
			        glVertex2fv(vtx+44); 
			        glColor3fv(&c[8]); glNormal3fv(&n[12]);
			        glVertex2fv(vtx+40);
			      case 4:
			        glColor3fv(&c[4]); glNormal3fv(&n[0]);
			        glVertex2fv(vtx+24); 
			        glColor3fv(&c[16]); glNormal3fv(&n[4]);
			        glVertex2fv(vtx+28); 
			        glColor3fv(&c[8]); glNormal3fv(&n[8]);
			        glVertex2fv(vtx+36); 
			        glColor3fv(&c[8]); glNormal3fv(&n[12]);
			        glVertex2fv(vtx+32);
			      case 3:
			        glColor3fv(&c[4]); glNormal3fv(&n[0]);
			        glVertex2fv(vtx+16); 
			        glColor3fv(&c[16]); glNormal3fv(&n[4]);
			        glVertex2fv(vtx+20); 
			        glColor3fv(&c[8]); glNormal3fv(&n[8]);
			        glVertex2fv(vtx+28); 
			        glColor3fv(&c[8]); glNormal3fv(&n[12]);
			        glVertex2fv(vtx+24);
			      case 2:
			        glColor3fv(&c[4]); glNormal3fv(&n[0]);
			        glVertex2fv(vtx+8); 
			        glColor3fv(&c[16]); glNormal3fv(&n[4]);
			        glVertex2fv(vtx+12); 
			        glColor3fv(&c[8]); glNormal3fv(&n[8]);
			        glVertex2fv(vtx+20); 
			        glColor3fv(&c[8]); glNormal3fv(&n[12]);
			        glVertex2fv(vtx+16);
			      case 1:
			        glColor3fv(&c[4]); glNormal3fv(&n[0]);
			        glVertex2fv(vtx); 
			        glColor3fv(&c[16]); glNormal3fv(&n[4]);
			        glVertex2fv(vtx+4); 
			        glColor3fv(&c[8]); glNormal3fv(&n[8]);
			        glVertex2fv(vtx+12); 
			        glColor3fv(&c[8]); glNormal3fv(&n[12]);
			        glVertex2fv(vtx+8);
			    }
			    glEnd();
		        }
		      }
		      endtest(pbuf, rate, 0);
		    }
		    else {
		      if (starttest(k)) {
		        for(i=(rate)/cPoly; i; i--) {
			    glBegin(GL_QUADS);
			    switch (cPoly) {
			      case 5:
			        glNormal3fv(&n[0]); glVertex2fv(vtx+32); 
			        glNormal3fv(&n[4]); glVertex2fv(vtx+36); 
			        glNormal3fv(&n[8]); glVertex2fv(vtx+44); 
			        glNormal3fv(&n[12]); glVertex2fv(vtx+40);
			      case 4:
			        glNormal3fv(&n[0]); glVertex2fv(vtx+24); 
			        glNormal3fv(&n[4]); glVertex2fv(vtx+28); 
			        glNormal3fv(&n[8]); glVertex2fv(vtx+36); 
			        glNormal3fv(&n[12]); glVertex2fv(vtx+32);
			      case 3:
			        glNormal3fv(&n[0]); glVertex2fv(vtx+16); 
			        glNormal3fv(&n[4]); glVertex2fv(vtx+20); 
			        glNormal3fv(&n[8]); glVertex2fv(vtx+28); 
			        glNormal3fv(&n[12]); glVertex2fv(vtx+24);
			      case 2:
			        glNormal3fv(&n[0]); glVertex2fv(vtx+8); 
			        glNormal3fv(&n[4]); glVertex2fv(vtx+12); 
			        glNormal3fv(&n[8]); glVertex2fv(vtx+20); 
			        glNormal3fv(&n[12]); glVertex2fv(vtx+16);
			      case 1:
			        glNormal3fv(&n[0]); glVertex2fv(vtx); 
			        glNormal3fv(&n[4]); glVertex2fv(vtx+4); 
			        glNormal3fv(&n[8]); glVertex2fv(vtx+12); 
			        glNormal3fv(&n[12]); glVertex2fv(vtx+8);
			    }
			    glEnd();
		        }
		      }
		      endtest(pbuf, rate, 0);
		    }
		}

		glPopMatrix();
	    }
	    printaverage();
	} else if (mod_shade && !mod_cmode) {

	    /*** POLYGONS (SHADED RGB) *****/

	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
                if (!mod_average)
		  sprintf(pbuf, "Angle %6.2f", angle);
		  
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);
		    for(i=(rate)/cPoly; i; i--) {
			glBegin(GL_QUADS);
			switch (cPoly) {
			  case 5:
			    glColor3fv(&c[4]); glVertex2fv(vtx+32); 
			    glColor3fv(&c[16]); glVertex2fv(vtx+36); 
			    glColor3fv(&c[8]); glVertex2fv(vtx+44); 
			    glColor3fv(&c[8]); glVertex2fv(vtx+40);
			  case 4:
			    glColor3fv(&c[4]); glVertex2fv(vtx+24); 
			    glColor3fv(&c[16]); glVertex2fv(vtx+28); 
			    glColor3fv(&c[8]); glVertex2fv(vtx+36); 
			    glColor3fv(&c[8]); glVertex2fv(vtx+32);
			  case 3:
			    glColor3fv(&c[4]); glVertex2fv(vtx+16); 
			    glColor3fv(&c[16]); glVertex2fv(vtx+20); 
			    glColor3fv(&c[8]); glVertex2fv(vtx+28); 
			    glColor3fv(&c[8]); glVertex2fv(vtx+24);
			  case 2:
			    glColor3fv(&c[4]); glVertex2fv(vtx+8); 
			    glColor3fv(&c[16]); glVertex2fv(vtx+12); 
			    glColor3fv(&c[8]); glVertex2fv(vtx+20); 
			    glColor3fv(&c[8]); glVertex2fv(vtx+16);
			  case 1:
			    glColor3fv(&c[4]); glVertex2fv(vtx); 
			    glColor3fv(&c[16]); glVertex2fv(vtx+4); 
			    glColor3fv(&c[8]); glVertex2fv(vtx+12); 
			    glColor3fv(&c[8]); glVertex2fv(vtx+8);
			}
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = cPoly * (rate/cPoly);

		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    for(i=(rate)/cPoly; i; i--) {
			glBegin(GL_QUADS);
			switch (cPoly) {
			  case 5:
			    glColor3fv(&c[4]); glVertex2fv(vtx+32); 
			    glColor3fv(&c[16]); glVertex2fv(vtx+36); 
			    glColor3fv(&c[8]); glVertex2fv(vtx+44); 
			    glColor3fv(&c[8]); glVertex2fv(vtx+40);
			  case 4:
			    glColor3fv(&c[4]); glVertex2fv(vtx+24); 
			    glColor3fv(&c[16]); glVertex2fv(vtx+28); 
			    glColor3fv(&c[8]); glVertex2fv(vtx+36); 
			    glColor3fv(&c[8]); glVertex2fv(vtx+32);
			  case 3:
			    glColor3fv(&c[4]); glVertex2fv(vtx+16); 
			    glColor3fv(&c[16]); glVertex2fv(vtx+20); 
			    glColor3fv(&c[8]); glVertex2fv(vtx+28); 
			    glColor3fv(&c[8]); glVertex2fv(vtx+24);
			  case 2:
			    glColor3fv(&c[4]); glVertex2fv(vtx+8); 
			    glColor3fv(&c[16]); glVertex2fv(vtx+12); 
			    glColor3fv(&c[8]); glVertex2fv(vtx+20); 
			    glColor3fv(&c[8]); glVertex2fv(vtx+16);
			  case 1:
			    glColor3fv(&c[4]); glVertex2fv(vtx); 
			    glColor3fv(&c[16]); glVertex2fv(vtx+4); 
			    glColor3fv(&c[8]); glVertex2fv(vtx+12); 
			    glColor3fv(&c[8]); glVertex2fv(vtx+8);
			}
			glEnd();
		    }
		  }
		  endtest(pbuf, rate, 0);
		}

		glPopMatrix();
	    }
	    printaverage();
	} else if (mod_shade && mod_cmode) {

	    /*** POLYGONS (SHADED COLOR MAPPED) *****/

	    /* 255 = r, 240 = g, 255 = b */
	    makeramp(208, 255, 0, 0, 0, 0, 255, 16);
	    makeramp(224, 0, 0, 255, 255, 255, 0, 16);
	    makeramp(240, 255, 255, 0, 255, 0, 255, 16);

	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
                if (!mod_average)
		  sprintf(pbuf, "Angle %6.2f", angle);
		  
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);
		    for(i=(rate)/cPoly; i; i--) {
			glBegin(GL_QUADS);
			switch (cPoly) {
			  case 5:
			    glIndexi(255); glVertex2fv(vtx+32); 
			    glIndexi(240); glVertex2fv(vtx+36); 
			    glIndexi(223); glVertex2fv(vtx+44); 
			    glIndexi(208); glVertex2fv(vtx+40);
			  case 4:
			    glIndexi(255); glVertex2fv(vtx+24); 
			    glIndexi(240); glVertex2fv(vtx+28); 
			    glIndexi(223); glVertex2fv(vtx+36); 
			    glIndexi(208); glVertex2fv(vtx+32);
			  case 3:
			    glIndexi(255); glVertex2fv(vtx+16); 
			    glIndexi(240); glVertex2fv(vtx+20); 
			    glIndexi(223); glVertex2fv(vtx+28); 
			    glIndexi(208); glVertex2fv(vtx+24);
			  case 2:
			    glIndexi(255); glVertex2fv(vtx+8); 
			    glIndexi(240); glVertex2fv(vtx+12); 
			    glIndexi(223); glVertex2fv(vtx+20); 
			    glIndexi(208); glVertex2fv(vtx+16);
			  case 1:
			    glIndexi(255); glVertex2fv(vtx); 
			    glIndexi(240); glVertex2fv(vtx+4); 
			    glIndexi(223); glVertex2fv(vtx+12); 
			    glIndexi(208); glVertex2fv(vtx+8);
			}
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = cPoly * (rate/cPoly);

		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    for(i=(rate)/cPoly; i; i--) {
			glBegin(GL_QUADS);
			switch (cPoly) {
			  case 5:
			    glIndexi(255); glVertex2fv(vtx+32); 
			    glIndexi(240); glVertex2fv(vtx+36); 
			    glIndexi(223); glVertex2fv(vtx+44); 
			    glIndexi(208); glVertex2fv(vtx+40);
			  case 4:
			    glIndexi(255); glVertex2fv(vtx+24); 
			    glIndexi(240); glVertex2fv(vtx+28); 
			    glIndexi(223); glVertex2fv(vtx+36); 
			    glIndexi(208); glVertex2fv(vtx+32);
			  case 3:
			    glIndexi(255); glVertex2fv(vtx+16); 
			    glIndexi(240); glVertex2fv(vtx+20); 
			    glIndexi(223); glVertex2fv(vtx+28); 
			    glIndexi(208); glVertex2fv(vtx+24);
			  case 2:
			    glIndexi(255); glVertex2fv(vtx+8); 
			    glIndexi(240); glVertex2fv(vtx+12); 
			    glIndexi(223); glVertex2fv(vtx+20); 
			    glIndexi(208); glVertex2fv(vtx+16);
			  case 1:
			    glIndexi(255); glVertex2fv(vtx); 
			    glIndexi(240); glVertex2fv(vtx+4); 
			    glIndexi(223); glVertex2fv(vtx+12); 
			    glIndexi(208); glVertex2fv(vtx+8);
			}
			glEnd();
		    }
		  }
		  endtest(pbuf, rate, 0);
		}

		glPopMatrix();
	    }
	    printaverage();

	} else if (!mod_light && !mod_shade) {

	    /*** POLYGONS (FLAT SHADED) *****/

	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
                if (!mod_average)
		  sprintf(pbuf, "Angle %6.2f", angle);
		  
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);
		    for(i=(rate)/cPoly; i; i--) {
			glBegin(GL_QUADS);
			switch (cPoly) {
			  case 5:
			    glVertex2fv(vtx+32); glVertex2fv(vtx+36);
			    glVertex2fv(vtx+44); glVertex2fv(vtx+40);
			  case 4:
			    glVertex2fv(vtx+24); glVertex2fv(vtx+28);
			    glVertex2fv(vtx+36); glVertex2fv(vtx+32);
			  case 3:
			    glVertex2fv(vtx+16); glVertex2fv(vtx+20);
			    glVertex2fv(vtx+28); glVertex2fv(vtx+24);
			  case 2:
			    glVertex2fv(vtx+8); glVertex2fv(vtx+12);
			    glVertex2fv(vtx+20); glVertex2fv(vtx+16);
			  case 1:
			    glVertex2fv(vtx); glVertex2fv(vtx+4);
			    glVertex2fv(vtx+12); glVertex2fv(vtx+8);
			}
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = cPoly * (rate/cPoly);

		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    for(i=(rate)/cPoly; i; i--) {
			glBegin(GL_QUADS);
			switch (cPoly) {
			  case 5:
			    glVertex2fv(vtx+32); glVertex2fv(vtx+36);
			    glVertex2fv(vtx+44); glVertex2fv(vtx+40);
			  case 4:
			    glVertex2fv(vtx+24); glVertex2fv(vtx+28);
			    glVertex2fv(vtx+36); glVertex2fv(vtx+32);
			  case 3:
			    glVertex2fv(vtx+16); glVertex2fv(vtx+20);
			    glVertex2fv(vtx+28); glVertex2fv(vtx+24);
			  case 2:
			    glVertex2fv(vtx+8); glVertex2fv(vtx+12);
			    glVertex2fv(vtx+20); glVertex2fv(vtx+16);
			  case 1:
			    glVertex2fv(vtx); glVertex2fv(vtx+4);
			    glVertex2fv(vtx+12); glVertex2fv(vtx+8);
			}
			glEnd();
		    }
		  }
		  endtest(pbuf, rate, 0);
		}

		glPopMatrix();
	    }
	    printaverage();
	}

    }
    if (mod_doublebuffer) {
        auxSwapBuffers();
        Sleep(2000);               /* for visual feedback */
    }
    exit(0);
}

/* original fill rate was 25 */

#define FILL_RATE 1

static void perffill(void)
{
    int    i, j, k;
    float  boxx[5], boxy[5];
    int    boxsizes = 5;	/* must be same a boxx, and boxy
					 * size */

    boxx[0] = boxy[0] = 10;
    boxx[1] = boxy[1] = 100;
    boxx[2] = boxy[2] = 500;
    boxx[3] = 640;
    boxy[3] = 480;
    boxx[4] = xsize;
    boxy[4] = ysize;

    if (mod_z) {
	glEnable(GL_DEPTH_TEST);
	glClear(GL_DEPTH_BUFFER_BIT);
    }
    if (mod_pattern) {
	glEnable(GL_POLYGON_STIPPLE);
	glPolygonStipple((GLubyte *) pattern);
    }

    glLoadIdentity();
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (mod_2d)
	gluOrtho2D(0.0, xsize, 0.0, ysize); 
    else
	glOrtho(0.0, xsize, 0.0, ysize, 1.0, -1.0); 
    glMatrixMode(GL_MODELVIEW);

    for (j = 0; j < boxsizes; j++) {

	v[0] = 0.0;
	v[1] = 0.0;
	v[2] = 0.0;
	v[4] = boxx[j];
	v[5] = 0.0;
	v[6] = 0.0;		/* why the X.01? */
	v[8] = boxx[j];
	v[9] = boxy[j];
	v[10] = 0.0;
	v[12] = 0.0;
	v[13] = boxy[j];
	v[14] = 0.0;

	if (mod_2d && !mod_z && !mod_shade && !mod_light) {

	    printf("Using FLAT shaded 2D screen aligned rectangles - no transforms\n");
	    fflush(stdout);
	    Sleep(250);

	    /*** RECTANGLES (SCREEN ALIGNED, FLAT SHADED) *****/

	    /****** Calibration Loop ******/
	    secs = 0.0;
	    rate = FILL_RATE;
	    while (secs < (secspertest/4.0)) {
		rate = rate * 2;
		starttest(0);
		for (i = (rate); i; i--)
		    glRectf(0.0, 0.0, v[8], v[9]);

		secs = timer(1);
	    }

	    rate = rate * (secspertest / secs);
            if (rate < 1) rate = 1;
            
	    for (k = 0; k < loopcount; k++) {
	      if (starttest(k)) {
		for (i = (rate); i; i--)
		    glRectf(0.0, 0.0, v[8], v[9]);
	      }
	      pixendtest("glRect() fill", rate, (int) boxx[j], (int) boxy[j]);
	    }
	}

	if (!mod_2d) {

	    /***** 3D DRAWING *****/

	    if (mod_cmode && mod_shade) {

		/*** GOURAUD SHADED CMODE RECTANGLES, SCREEN ALIGNED ***/

		/* 255 = r, 240 = g, 255 = b */
		makeramp(208, 255, 0, 0, 0, 0, 255, 16);
		makeramp(224, 0, 0, 255, 255, 255, 0, 16);
		makeramp(240, 255, 255, 0, 255, 0, 255, 16);

		secs = 0.0;
		rate = FILL_RATE;
		while (secs < (secspertest/4.0)) {
		    rate = rate * 2;
		    starttest(0);
		    for (i = (rate); i; i--) {
			glBegin(GL_POLYGON);
			glIndexi(255);
			glVertex3fv(&v[0]);
			glIndexi(240);
			glVertex3fv(&v[4]);
			glIndexi(223);
			glVertex3fv(&v[8]);
			glIndexi(208);
			glVertex3fv(&v[12]);
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest / secs);
                if (rate < 1) rate = 1;

		for (k = 0; k < loopcount; k++) {
		  if (starttest(k)) {
		    for (i = (rate); i; i--) {
			glBegin(GL_POLYGON);
			glIndexi(255);
			glVertex3fv(&v[0]);
			glIndexi(240);
			glVertex3fv(&v[4]);
			glIndexi(223);
			glVertex3fv(&v[8]);
			glIndexi(208);
			glVertex3fv(&v[12]);
			glEnd();
		    }
		  }
		  pixendtest("rectangle fill", rate, (int) boxx[j], (int) boxy[j]);
		}

	    } else if (!mod_shade && !mod_light) {

		/*** RECTANGLES (SCREEN ALIGNED, FLAT SHADED) *****/

		/****** Calibration Loop ******/
		secs = 0.0;
		rate = FILL_RATE;
		while (secs < (secspertest/ 
4.0)) {
		    rate = rate * 2;
		    starttest(0);
		    for (i = (rate); i; i--) {
			glBegin(GL_POLYGON);
			glVertex3fv(&v[0]);
			glVertex3fv(&v[4]);
			glVertex3fv(&v[8]);
			glVertex3fv(&v[12]);
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest / secs);
                if (rate < 1) rate = 1;

		for (k = 0; k < loopcount; k++) {
		  if (starttest(k)) {
		    for (i = (rate); i; i--) {
			glBegin(GL_POLYGON);
			glVertex3fv(&v[0]);
			glVertex3fv(&v[4]);
			glVertex3fv(&v[8]);
			glVertex3fv(&v[12]);
			glEnd();
		    }
		  }
		  pixendtest("rectangle fill", rate, (int) boxx[j], (int) boxy[j]);
		}

	    } else if (!mod_cmode && mod_light) {

		/*** RECTANGLES (LIGHTED GOURAUD SHADED RBG SCREEN ALIGNED) ***/

		glLoadIdentity();
		glMatrixMode(GL_PROJECTION);
		glLoadIdentity();
		glOrtho(0.0, xsize, 0.0, ysize, 1.0, -1.0);
		glMatrixMode(GL_MODELVIEW);

		/* set lights */
		setLightingParameters();

		/****** Calibration Loop ******/
		secs = 0.0;
		rate = FILL_RATE;
		while (secs < (secspertest/4.0)) {
		    rate = rate * 2;
		    starttest(0);
		    for (i = (rate); i; i--) {
			glBegin(GL_POLYGON);
			glNormal3fv(&n[0]);
			glVertex3fv(&v[0]);
			glNormal3fv(&n[4]);
			glVertex3fv(&v[4]);
			glNormal3fv(&n[8]);
			glVertex3fv(&v[8]);
			glNormal3fv(&n[12]);
			glVertex3fv(&v[12]);
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest / secs);
                if (rate < 1) rate = 1;

		for (k = 0; k < loopcount; k++) {
		  if (starttest(k)) {
		    for (i = (rate); i; i--) {
			glBegin(GL_POLYGON);
			glNormal3fv(&n[0]);
			glVertex3fv(&v[0]);
			glNormal3fv(&n[4]);
			glVertex3fv(&v[4]);
			glNormal3fv(&n[8]);
			glVertex3fv(&v[8]);
			glNormal3fv(&n[12]);
			glVertex3fv(&v[12]);
			glEnd();
		    }
		  }
		  pixendtest("rectangle fill", rate, (int) boxx[j], (int) boxy[j]);
		}

	    } else if (!mod_cmode && mod_shade) {

		/*** RECTANGLES (SCREEN ALIGNED, RGB GOURAUD SHADED) *****/

		/****** Calibration Loop ******/
		secs = 0.0;
		rate = FILL_RATE;
		while (secs < (secspertest/4.0)) {
		    rate = rate * 2;
		    starttest(0);
		    for (i = (rate); i; i--) {
			glBegin(GL_POLYGON);
			glColor3fv(&c[4]);
			glVertex3fv(&v[0]);
			glColor3fv(&c[8]);
			glVertex3fv(&v[4]);
			glColor3fv(&c[12]);
			glVertex3fv(&v[8]);
			glColor3fv(&c[16]);
			glVertex3fv(&v[12]);
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest / secs);
                if (rate < 1) rate = 1;

		for (k = 0; k < loopcount; k++) {
		  if (starttest(k)) {
		    for (i = (rate); i; i--) {
			glBegin(GL_POLYGON);
			glColor3fv(&c[4]);
			glVertex3fv(&v[0]);
			glColor3fv(&c[8]);
			glVertex3fv(&v[4]);
			glColor3fv(&c[12]);
			glVertex3fv(&v[8]);
			glColor3fv(&c[16]);
			glVertex3fv(&v[12]);
			glEnd();
		    }
		  }
		  pixendtest("rectangle fill", rate, (int) boxx[j], (int) boxy[j]);
		}
	    }
	} else {		/***** 2D DRAWING *****/

	    if (mod_cmode && mod_shade) {

		/*** GOURAUD SHADED CMODE SCREEN ALIGNED RECTANGLES ***/
		/* 255 = r, 240 = g, 255 = b */
		makeramp(208, 255, 0, 0, 0, 0, 255, 16);
		makeramp(224, 0, 0, 255, 255, 255, 0, 16);
		makeramp(240, 255, 255, 0, 255, 0, 255, 16);

		secs = 0.0;
		rate = FILL_RATE;
		while (secs < (secspertest/4.0)) {
		    rate = rate * 2;
		    starttest(0);
		    for (i = (rate); i; i--) {
			glBegin(GL_POLYGON);
			glIndexi(255);
			glVertex2fv(&v[0]);
			glIndexi(240);
			glVertex2fv(&v[4]);
			glIndexi(223);
			glVertex2fv(&v[8]);
			glIndexi(208);
			glVertex2fv(&v[12]);
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest / secs);
                if (rate < 1) rate = 1;

		for (k = 0; k < loopcount; k++) {
		  if (starttest(k)) {
		    for (i = (rate); i; i--) {
			glBegin(GL_POLYGON);
			glIndexi(255);
			glVertex2fv(&v[0]);
			glIndexi(240);
			glVertex2fv(&v[4]);
			glIndexi(223);
			glVertex2fv(&v[8]);
			glIndexi(208);
			glVertex2fv(&v[12]);
			glEnd();
		    }
		  }
		  pixendtest("rectangle fill", rate, (int) boxx[j], (int) boxy[j]);
		}

	    } else if (!mod_shade && !mod_light) {

		/*** RECTANGLES (SCREEN ALIGNED, FLAT SHADED) *****/

		/****** Calibration Loop ******/
		secs = 0.0;
		rate = FILL_RATE;
		while (secs < (secspertest/4.0)) {
		    rate = rate * 2;
		    starttest(0);
		    for (i = (rate); i; i--) {
			glBegin(GL_POLYGON);
			glVertex2fv(&v[0]);
			glVertex2fv(&v[4]);
			glVertex2fv(&v[8]);
			glVertex2fv(&v[12]);
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest / secs);
                if (rate < 1) rate = 1;

		for (k = 0; k < loopcount; k++) {
		  if (starttest(k)) {
		    for (i = (rate); i; i--) {
			glBegin(GL_POLYGON);
			glVertex2fv(&v[0]);
			glVertex2fv(&v[4]);
			glVertex2fv(&v[8]);
			glVertex2fv(&v[12]);
			glEnd();
		    }
		  }
		  pixendtest("rectangle fill", rate, (int) boxx[j], (int) boxy[j]);
		}

	    } else if (!mod_cmode && mod_light) {

		/*** RECTANGLES (LIGHTED GOURAUD SHADED RBG SCREEN ALIGNED) ***/

		glLoadIdentity();
		glMatrixMode(GL_PROJECTION);
		glLoadIdentity();
		glOrtho(0.0, xsize, 0.0, ysize, 1.0, -1.0);
		glMatrixMode(GL_MODELVIEW);

		/* set lights */
		setLightingParameters();

		/****** Calibration Loop ******/
		secs = 0.0;
		rate = FILL_RATE;
		while (secs < (secspertest/4.0)) {
		    rate = rate * 2;
		    starttest(0);
		    for (i = (rate); i; i--) {
			glBegin(GL_POLYGON);
			glNormal3fv(&n[0]);
			glVertex2fv(&v[0]);
			glNormal3fv(&n[4]);
			glVertex2fv(&v[4]);
			glNormal3fv(&n[8]);
			glVertex2fv(&v[8]);
			glNormal3fv(&n[12]);
			glVertex2fv(&v[12]);
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest / secs);
                if (rate < 1) rate = 1;

		for (k = 0; k < loopcount; k++) {
		  if (starttest(k)) {
		    for (i = (rate); i; i--) {
			glBegin(GL_POLYGON);
			glNormal3fv(&n[0]);
			glVertex2fv(&v[0]);
			glNormal3fv(&n[4]);
			glVertex2fv(&v[4]);
			glNormal3fv(&n[8]);
			glVertex2fv(&v[8]);
			glNormal3fv(&n[12]);
			glVertex2fv(&v[12]);
			glEnd();
		    }
		  }
		  pixendtest("rectangle fill", rate, (int) boxx[j], (int) boxy[j]);
		}

	    } else if (!mod_cmode && mod_shade) {

		/*** RECTANGLES (SCREEN ALIGNED, RGB GOURAUD SHADED) *****/

		/****** Calibration Loop ******/
		secs = 0.0;
		rate = FILL_RATE;
		while (secs < (secspertest/4.0)) {
		    rate = rate * 2;
		    starttest(0);
		    for (i = (rate); i; i--) {
			glBegin(GL_POLYGON);
			glColor3fv(&c[4]);
			glVertex2fv(&v[0]);
			glColor3fv(&c[8]);
			glVertex2fv(&v[4]);
			glColor3fv(&c[12]);
			glVertex2fv(&v[8]);
			glColor3fv(&c[16]);
			glVertex2fv(&v[12]);
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest / secs);
                if (rate < 1) rate = 1;

		for (k = 0; k < loopcount; k++) {
		  if (starttest(k)) {
		    for (i = (rate); i; i--) {
			glBegin(GL_POLYGON);
			glColor3fv(&c[4]);
			glVertex2fv(&v[0]);
			glColor3fv(&c[8]);
			glVertex2fv(&v[4]);
			glColor3fv(&c[12]);
			glVertex2fv(&v[8]);
			glColor3fv(&c[16]);
			glVertex2fv(&v[12]);
			glEnd();
		    }
		  }
		  pixendtest("rectangle fill", rate, (int) boxx[j], (int) boxy[j]);
		}
	    }
	}
    }
    exit(0);
}



static void perfpixels(void)
{
    long i, k;
    long iw, ih;
    unsigned long  *pixels;

    unsigned long pix;
    long npixels, j, imgwid[5], imght[5], numimges = 5;

    imgwid[0] = imght[0] = 10;
    imgwid[1] = imght[1] = 100;
    imgwid[2] = imght[2] = 500;
    imgwid[3] = 640; imght[3] = 480;
    imgwid[4] = xsize; imght[4] = ysize;
    npixels = xsize * ysize;

    pixels = (unsigned long *) malloc(npixels * sizeof(unsigned long));
    
    printf("DMA test.  No modifiers have any effect\n");
    printf("Pixel Writes:\n");
    fflush(stdout);
    Sleep(250);

    for (i = 0, pix = 0x7b8c9eaf; i < npixels; i++) {
	pix = (pix * 8191) + 0x70615243;
	pixels[i] = pix;
    }

    /* fill from top to bottom */
    /* pixmode(PM_TTOB,1); not available in OpenGL */

    glClearColor(c[0], c[1], c[2], c[3]);


    /**** 32 BIT PIXEL WRITES ****/
    for (j = 0; j < numimges; j++) {
	iw = imgwid[j];
	ih = imght[j];

	glClear(GL_COLOR_BUFFER_BIT);

	/****** Calibration Loop ******/
	secs = 0.0;
	rate = 15;
	while (secs < (secspertest/4.0)) {
	    rate = rate * 2;
	    starttest(0);
	    for (i = (rate); i; i--) {
		/* lrectwrite(1, 1, iw, ih, pixels); */
		glRasterPos2f(-0.5 * xsize, -0.5 * ysize);
		glDrawPixels(iw, ih, GL_RGBA, GL_BYTE, pixels);
	    }

	    secs = timer(1);
	}
	rate = rate * (secspertest / secs);

	for (k = 0; k < loopcount; k++) {
	  if (starttest(k)) {
	    for (i = (rate); i; i--) {
		glRasterPos2f(-0.5 * xsize, -0.5 * ysize);
		glDrawPixels(iw, ih, GL_RGBA, GL_BYTE, pixels);
	    }
	  }
	  pixendtest("32-bit Pixel Write", rate, iw, ih);
	}
    }


    printf("\n");
    fflush(stdout);
    Sleep(250);

    /*
     * This is not quite right.  I think the correct way would be to get
     * a colorindex visual and use that as the target of our writes.
     */
    /**** 8 BIT PIXEL WRITES ****/
    for (j = 0; j < numimges; j++) {
	iw = imgwid[j];
	ih = imght[j];
	glClear(GL_COLOR_BUFFER_BIT);

	/****** Calibration Loop ******/
	secs = 0.0;
	rate = 15;
	while (secs < (secspertest/4.0)) {
	    rate = rate * 2;
	    starttest(0);
	    for (i = (rate); i; i--) {
		glRasterPos2i(1, 1);
		glDrawPixels(iw, ih, GL_RED, GL_BYTE, pixels);
	    }

	    secs = timer(1);
	}
	rate = rate * (secspertest / secs);

	for (k = 0; k < loopcount; k++) {
	  if (starttest(k)) {
	    for (i = (rate); i; i--) {
		glRasterPos2i(1, 1);
		glDrawPixels(iw, ih, GL_RED, GL_BYTE, pixels);
	    }
	  }
	  pixendtest("8-bit Pixel Write", rate, iw, ih);
	}
    }

    printf("\n");
    printf("Pixel Reads:\n");
    fflush(stdout);
    Sleep(250);

    for (i=0; i< npixels; i++) {
	pixels[i] = 0;
    }


    /**** PIXEL READS *****/
    /* make a polygon to read */
    {
	float myv1[3], myv2[3], myv3[3], myv4[3];
	myv1[0] = myv4[0] = -0.5*xsize,
	myv2[0] = myv3[0] = 0.5*xsize;
	myv1[1] = myv2[1] = -0.5*ysize;
	myv3[1] = myv4[1] = 0.5*ysize;
	myv1[2] = myv2[2] =  myv3[2] = myv4[2] = 0.0;

	glBegin(GL_POLYGON);
	glColor3fv(&c[4]);
	glVertex3fv(myv1);
	glColor3fv(&c[8]);
	glVertex3fv(myv2);
	glColor3fv(&c[12]);
	glVertex3fv(myv3);
	glColor3fv(&c[28]);
	glVertex3fv(myv4);
	glEnd();
    }


    /**** 32 BIT PIXEL READS ****/
    for (j = 0; j < numimges; j++) {
	iw = imgwid[j];
	ih = imght[j];

	/****** Calibration Loop ******/
	secs = 0.0; 
	rate = 15;
	while (secs < (secspertest/4.0)) {
	    rate = rate*2;
	    starttest(0);
	    for(i=(rate); i; i--) {
		/* lrectread(1, 1, iw, ih, pixels); */
		glReadPixels(-0.5 * xsize, -0.5 * ysize, iw, ih, 
			     GL_RGBA, GL_BYTE, pixels);
	    }

	    secs = timer(1);
	}
	rate = rate * (secspertest/secs);

	for (k=0; k<loopcount; k++) {
	  if (starttest(k)) {
	    for(i=(rate); i; i--) {
		glReadPixels(-0.5 * xsize, -0.5 * ysize, iw, ih, 
			     GL_RGBA, GL_BYTE, pixels);
	    }
	  }
	  pixendtest ("32-bit Pixel Read", rate, iw, ih);
	}
    }


    printf("\n");
    fflush(stdout);
    Sleep(250);

    /*** 8 BIT PIXEL READS ******/

    for (j = 0; j < numimges; j++) {
	iw = imgwid[j];
	ih = imght[j];

	/****** Calibration Loop ******/
	secs = 0.0; 
	rate = 15;
	while (secs < (secspertest/4.0)) {
	    rate = rate*2;
	    starttest(0);
	    for(i=(rate); i; i--) {
		glReadPixels(-0.5 * xsize, -0.5 * ysize, iw, ih, 
			     GL_RED, GL_BYTE, pixels);
	    }

	    secs = timer(1);
	}
	rate = rate * (secspertest/secs);

	for (k=0; k<loopcount; k++) {
	  if (starttest(k)) {
	    for(i=(rate); i; i--) {
		glReadPixels(-0.5 * xsize, -0.5 * ysize, iw, ih, 
			     GL_RED, GL_BYTE, pixels);
	    }
	  }
	  pixendtest("8-bit Pixel Read", rate, iw, ih);
	}
    }
}

static void perfclear(void)
{
    long            viewwd, viewht;
    long	    winwd[5], winht[5];
    long	    numscreens = 5; /* should be same size as win arrays */
    long            zval;
    int    i, j, k;
    char   pbuf[256];

    winwd[0] = 100;
    winht[0] = 100;
    winwd[1] = 500;
    winht[1] = 500;
    winwd[2] = 640;
    winht[2] = 480;
    winwd[3] = xsize;
    winht[3] = ysize;
    winwd[4] = 1;
    winht[4] = 1;

    glDisable(GL_DITHER);

    for (j = 0; j < numscreens; j++) {
	viewwd = winwd[j];
	viewht = winht[j];
	glEnable(GL_SCISSOR_TEST);
	glScissor(0, 0, viewwd - 1, viewht - 1);

	if (mod_z) {		/* include clearing the zbuffer */

	    glClearDepth(1.0);

	    /** USING glClear(COLOR); glClear(DEPTH) **/

	    if (!mod_cmode) {
		glClearColor(c[16], c[17], c[18], c[19]);
	    } else {
		glClearIndex(YELLOW);
	    }

	    glFlush();
	    sum_secs = 0.0;
	    sum_n = 0;

	    /****** Calibration Loop ******/
	    secs = 0.0;
	    rate = 125;
	    while (secs < (secspertest/4.0)) {
		rate = rate * 2;
		starttest(0);
		for (i = (rate); i; i--) {
		    glClear(GL_COLOR_BUFFER_BIT);
		    glClear(GL_DEPTH_BUFFER_BIT);
		}

		secs = timer(1);
	    }

	    /** Do the real thing **/
	    rate = rate * (secspertest / secs);
	    for (k = 0; k < loopcount; k++) {
	      if (starttest(k)) {
		for (i = rate; i; i--) {
		    glClear(GL_COLOR_BUFFER_BIT);
		    glClear(GL_DEPTH_BUFFER_BIT);
		}
		sprintf(pbuf, "glClear(COLOR); glClear(DEPTH); clear screen size %ld %ld",
			viewwd, viewht);
	      }
	      clearendtest(pbuf, rate, viewwd * viewht);
	    }

	    glFlush();
	    sum_secs = 0.0;
	    sum_n = 0;

	    /****** Calibration Loop ******/

	    /** USING glClear(COLOR|DEPTH) **/

	    if (!mod_cmode) {
		glClearColor(c[8], c[9], c[10], c[11]);
	    } else {
		glClearIndex(BLUE);
	    }

	    secs = 0.0;
	    rate = 125;
	    while (secs < (secspertest/4.0)) {
		rate = rate * 2;
		starttest(0);
		for (i = (rate); i; i--) {
		    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
		}
		    
		secs = timer(1);
	    }
	    rate = rate * (secspertest / secs);
	    for (k = 0; k < loopcount; k++) {
	      if (starttest(k)) {
		for (i = (rate); i; i--) {
		    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
		}
		sprintf(pbuf, "glClear(COLOR|DEPTH)  clear screen size %ld %ld",
			viewwd, viewht);
	      }
	      clearendtest(pbuf, rate, viewwd * viewht);
	    }
	} else {		/* no z buffering */
	    
	    /** JUST PLAIN OLD CLEAR() */
	    
	    if (mod_cmode) {
		glClearIndex(CYAN);
	    } else {
		glClearColor(c[24], c[25], c[26], c[27]);
	    }

	    sum_secs = 0.0;
	    sum_n = 0;
	    sprintf(pbuf, "clear screen size %ld %ld", viewwd, viewht);

	    /****** Calibration Loop ******/
	    secs = 0.0;
	    rate = 125;
	    while (secs < (secspertest/4.0)) {
		rate = rate * 2;
		starttest(0);
		for (i = (rate); i; i--)
		    glClear(GL_COLOR_BUFFER_BIT);

		secs = timer(1);
	    }
	    rate = rate * (secspertest / secs);
	    for (k = 0; k < loopcount; k++) {
	      if (starttest(k)) {
		for (i = (rate); i; i--)
		    glClear(GL_COLOR_BUFFER_BIT);
	      }
	      clearendtest(pbuf, rate, viewwd * viewht);
	    }
	}
	if (mod_cmode) {
	    glClearIndex(BLACK);
	} else {
	    glClearColor(c[0], c[1], c[2], c[3]);
	}
	glClear(GL_COLOR_BUFFER_BIT);
    }
    exit(0);
}


static void perfqstrip(void)
{
    int i,j,k;
    char pbuf[256];
    int cVert = 60;
    int cVertDiv2 = 30;
    
    /* Triangle mesh tests:  Each qstrip contains 62 vertices, or	*/
    /* 60 triangles.  To make the calculation exact, the rate	*/
    /* must be a multiple of 60.					*/

    /* If the quad size is specified, set the size of the quad strip to
    ** fit the window.  The number of vertices must be a multiple of four (due
    ** to code below), and it must not exceed 60.
    */
    if (mod_size) {
        cVert = (int) (MINDIMENSION*2 / prim_size) - 2;
        if (cVert & 1) cVert++;
        cVert &= ~3;
        if (cVert < 4) cVert = 4;
        if (cVert > 60) cVert = 60;
    }
    cVertDiv2 = cVert >> 1;
    
    if (!mod_2d) {
	if (mod_cmode && mod_shade) {

	    /*** GOURAUD SHADED CMODE QSTRIP ***/
	    /* 255 = r, 240 = g, 255 = b */
	    makeramp(208,255,0,0,0,0,255,16);
	    makeramp(224,0,0,255,255,255,0,16);
	    makeramp(240,255,255,0,255,0,255,16);

	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);
		    for(i=(rate)/cVertDiv2; i; i--) {
			glBegin(GL_QUAD_STRIP);
			for (j=0; j<=cVertDiv2; j+=2) {
			    glIndexi(255);
			    glVertex3fv(&v[j*4]);
			    glIndexi(240);
			    glVertex3fv(&v[(j+1)*4]);
			}
			for (j=cVertDiv2-2; j>=0; j-=2) {
			    glIndexi(223);
			    glVertex3fv(&v[j*4]);
			    glIndexi(208);
			    glVertex3fv(&v[(j+1)*4]);
			}
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = cVert * (rate/cVertDiv2);

		/* Do the real thing GOURAUD shaded Cmode qstrip */
		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    for(i=(rate)/cVertDiv2; i; i--) {
			glBegin(GL_QUAD_STRIP);
			for (j=0; j<=cVertDiv2; j+=2) {
			    glIndexi(255);
			    glVertex3fv(&v[j*4]);
			    glIndexi(240);
			    glVertex3fv(&v[(j+1)*4]);
			}
			for (j=cVertDiv2-2; j>=0; j-=2) {
			    glIndexi(223);
			    glVertex3fv(&v[j*4]);
			    glIndexi(208);
			    glVertex3fv(&v[(j+1)*4]);
			}
			glEnd();
		    }
                    if (!mod_average)
		      sprintf (pbuf, "Angle %6.2f", angle);
		  }
		  endtest(pbuf, rate, 0);
		}

		glPopMatrix();
	    }
	    printaverage ();

	} else if (!mod_light && !mod_shade) {

	    /*** FLAT SHADED QSTRIP ***/
	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);
		    for(i=(rate)/cVertDiv2; i; i--) {
			glBegin(GL_QUAD_STRIP);
			for (j=0; j<=cVertDiv2; j++) {
			    glVertex3fv(&v[j*4]);
			}
			for (j=cVertDiv2-2; j>=0; j-=2) {
			    glVertex3fv(&v[j*4]);
			    glVertex3fv(&v[(j+1)*4]);
			}
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = cVert * (rate/cVertDiv2);
	    
		/* Do the real thing - FLAT shaded qstrip */
		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    for(i=(rate)/cVertDiv2; i; i--) {
			glBegin(GL_QUAD_STRIP);
			for (j=0; j<=cVertDiv2; j++) {
			    glVertex3fv(&v[j*4]);
			}
			for (j=cVertDiv2-2; j>=0; j-=2) {
			    glVertex3fv(&v[j*4]);
			    glVertex3fv(&v[(j+1)*4]);
			}
			glEnd();
		    }
                    if (!mod_average)
		      sprintf(pbuf, "Angle %6.2f", angle);
		  }
		  endtest(pbuf, rate, 0);
		}
		glPopMatrix();
	    }
	    printaverage();

	} else if (!mod_cmode && mod_light) {

	    /*** LIGHTED RGB QSTRIP ***/

	    glLoadIdentity();

	    glMatrixMode(GL_PROJECTION);
	    glLoadIdentity();
	    glOrtho(-0.5*xsize,0.5*xsize,-0.5*ysize,0.5*ysize,1.0,-1.0);
	    glMatrixMode(GL_MODELVIEW);

	    /* set lights */
	    setLightingParameters();

	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);

		    for(i=(rate)/cVertDiv2; i; i--) {
			glBegin(GL_QUAD_STRIP);
			for (j=0; j<=cVertDiv2; j+=2) {
			    glNormal3fv(&n[0]);
			    glVertex3fv(&v[j*4]);
			    glNormal3fv(&n[4]);
			    glVertex3fv(&v[(j+1)*4]);
			}
			for (j=cVertDiv2-2; j>=0; j-=2) {
			    glNormal3fv(&n[8]);
			    glVertex3fv(&v[j*4]);
			    glNormal3fv(&n[12]);
			    glVertex3fv(&v[(j+1)*4]);
			}
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = cVert * (rate/cVertDiv2);

		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    for(i=(rate)/cVertDiv2; i; i--) {
			glBegin(GL_QUAD_STRIP);
			for (j=0; j<=cVertDiv2; j+=2) {
			    glNormal3fv(&n[0]);
			    glVertex3fv(&v[j*4]);
			    glNormal3fv(&n[4]);
			    glVertex3fv(&v[(j+1)*4]);
			}
			for (j=cVertDiv2-2; j>=0; j-=2) {
			    glNormal3fv(&n[8]);
			    glVertex3fv(&v[j*4]);
			    glNormal3fv(&n[12]);
			    glVertex3fv(&v[(j+1)*4]);
			}
			glEnd();
		    }
                    if (!mod_average)
		      sprintf(pbuf, "Angle %6.2f", angle);
		  }
		  endtest(pbuf, rate, 0);
		}
		glPopMatrix();
	    }
	    printaverage();

	} else if (!mod_cmode && mod_shade) {

	    /*** GOURAUD SHADED RGB TMESH ***/
	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);
		    for(i=(rate)/cVertDiv2; i; i--) {
			glBegin(GL_QUAD_STRIP);
			for (j=0; j<=cVertDiv2; j+=2) {
			    glColor3fv(&c[16]);
			    glVertex3fv(&v[j*4]);
			    glColor3fv(&c[20]);
			    glVertex3fv(&v[(j+1)*4]);
			}
			for (j=cVertDiv2-2; j>=0; j-=2) {
			    glColor3fv(&c[4]);
			    glVertex3fv(&v[j*4]);
			    glColor3fv(&c[8]);
			    glVertex3fv(&v[(j+1)*4]);
			}
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = cVert * (rate/cVertDiv2);

		/* Do the real thing GOURAUD shaded qstrip */
		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    for(i=(rate)/cVertDiv2; i; i--) {
			glBegin(GL_QUAD_STRIP);
			for (j=0; j<=cVertDiv2; j+=2) {
			    glColor3fv(&c[16]);
			    glVertex3fv(&v[j*4]);
			    glColor3fv(&c[20]);
			    glVertex3fv(&v[(j+1)*4]);
			}
			for (j=cVertDiv2-2; j>=0; j-=2) {
			    glColor3fv(&c[4]);
			    glVertex3fv(&v[j*4]);
			    glColor3fv(&c[8]);
			    glVertex3fv(&v[(j+1)*4]);
			}
			glEnd();
		    }
		  }
                  if (!mod_average)
		    sprintf(pbuf, "Angle %6.2f", angle);
		    
		  endtest(pbuf, rate, 0);
		}

		glPopMatrix();
	    }
	    printaverage();
	}

    } else {	/* must be 2d */
	if (mod_cmode && mod_shade) { /* color map lighting yet */

	    /*** GOURAUD SHADED CMODE TMESH ***/
	    /* 255 = r, 240 = g, 255 = b */
	    makeramp(208,255,0,0,0,0,255,16);
	    makeramp(224,0,0,255,255,255,0,16);
	    makeramp(240,255,255,0,255,0,255,16);

	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);

		    for(i=(rate)/cVertDiv2; i; i--) {
			glBegin(GL_QUAD_STRIP);
			for (j=0; j<=cVertDiv2; j+=2) {
			    glIndexi(255);
			    glVertex2fv(&v[j*4]);
			    glIndexi(240);
			    glVertex2fv(&v[(j+1)*4]);
			}
			for (j=cVertDiv2-2; j>=0; j-=2) {
			    glIndexi(223);
			    glVertex2fv(&v[j*4]);
			    glIndexi(208);
			    glVertex2fv(&v[(j+1)*4]);
			}
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = cVert * (rate/cVertDiv2);

		/* Do the real thing GOURAUD shaded Cmode qstrip */
		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    for(i=(rate)/cVertDiv2; i; i--) {
			glBegin(GL_QUAD_STRIP);
			for (j=0; j<=cVertDiv2; j+=2) {
			    glIndexi(255);
			    glVertex2fv(&v[j*4]);
			    glIndexi(240);
			    glVertex2fv(&v[(j+1)*4]);
			}
			for (j=cVertDiv2-2; j>=0; j-=2) {
			    glIndexi(223);
			    glVertex2fv(&v[j*4]);
			    glIndexi(208);
			    glVertex2fv(&v[(j+1)*4]);
			}
			glEnd();
		    }
		  }
                  if (!mod_average)
		    sprintf(pbuf, "Angle %6.2f", angle);
		    
		  endtest(pbuf, rate, 0);
		}

		glPopMatrix();
	    }
	    printaverage();

	} else if (!mod_light && !mod_shade) {

	    /*** FLAT SHADED QSTRIP ***/
	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);

		    for(i=(rate)/cVertDiv2; i; i--) {
			glBegin(GL_QUAD_STRIP);
			for (j=0; j<=cVertDiv2; j++) {
			    glVertex2fv(&v[j*4]);
			}
			for (j=cVertDiv2-2; j>=0; j-=2) {
			    glVertex2fv(&v[j*4]);
			    glVertex2fv(&v[(j+1)*4]);
			}
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = cVert * (rate/cVertDiv2);
	    
		/* Do the real thing - FLAT shaded qstrip */
		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    for(i=(rate)/cVertDiv2; i; i--) {
			glBegin(GL_QUAD_STRIP);
			for (j=0; j<=cVertDiv2; j++) {
			    glVertex2fv(&v[j*4]);
			}
			for (j=cVertDiv2-2; j>=0; j-=2) {
			    glVertex2fv(&v[j*4]);
			    glVertex2fv(&v[(j+1)*4]);
			}
			glEnd();
		    }
		  }
                  if (!mod_average)
		    sprintf(pbuf, "Angle %6.2f", angle);
		    
		  endtest(pbuf, rate, 0);
		}
		glPopMatrix();
	    }
	    printaverage();

	} else if (!mod_cmode && mod_light) {

	    /*** LIGHTED RGB QSTRIP ***/

	    glLoadIdentity();
	    
	    glMatrixMode(GL_PROJECTION);
	    glLoadIdentity();
	    glOrtho(-0.5*xsize,0.5*xsize,-0.5*ysize,0.5*ysize,1.0,-1.0);
	    glMatrixMode(GL_MODELVIEW);

	    /* set lights */
	    setLightingParameters();

	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);
		    for(i=(rate)/cVertDiv2; i; i--) {
			glBegin(GL_QUAD_STRIP);
			for (j=0; j<=cVertDiv2; j+=2) {
			    glNormal3fv(&n[0]);
			    glVertex2fv(&v[j*4]);
			    glNormal3fv(&n[4]);
			    glVertex2fv(&v[(j+1)*4]);
			}
			for (j=cVertDiv2-2; j>=0; j-=2) {
			    glNormal3fv(&n[8]);
			    glVertex2fv(&v[j*4]);
			    glNormal3fv(&n[12]);
			    glVertex2fv(&v[(j+1)*4]);
			}
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = cVert * (rate/cVertDiv2);

		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    for(i=(rate)/cVertDiv2; i; i--) {
			glBegin(GL_QUAD_STRIP);
			for (j=0; j<=cVertDiv2; j+=2) {
			    glNormal3fv(&n[0]);
			    glVertex2fv(&v[j*4]);
			    glNormal3fv(&n[4]);
			    glVertex2fv(&v[(j+1)*4]);
			}
			for (j=cVertDiv2-2; j>=0; j-=2) {
			    glNormal3fv(&n[8]);
			    glVertex2fv(&v[j*4]);
			    glNormal3fv(&n[12]);
			    glVertex2fv(&v[(j+1)*4]);
			}
			glEnd();
		    }
		  }
                  if (!mod_average)
		    sprintf(pbuf, "Angle %6.2f", angle);
		    
		  endtest(pbuf, rate, 0);
		}
		glPopMatrix();
	    }
	    printaverage();

	} else if (!mod_cmode && mod_shade) {

	    /*** GOURAUD SHADED RGB TMESH ***/
	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);
		    for(i=(rate)/cVertDiv2; i; i--) {
			glBegin(GL_QUAD_STRIP);
			for (j=0; j<=cVertDiv2; j+=2) {
			    glColor3fv(&c[16]);
			    glVertex2fv(&v[j*4]);
			    glColor3fv(&c[20]);
			    glVertex2fv(&v[(j+1)*4]);
			}
			for (j=cVertDiv2-2; j>=0; j-=2) {
			    glColor3fv(&c[4]);
			    glVertex2fv(&v[j*4]);
			    glColor3fv(&c[8]);
			    glVertex2fv(&v[(j+1)*4]);
			}
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = cVert * (rate/cVertDiv2);

		/* Do the real thing GOURAUD shaded qstrip */
		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    for(i=(rate)/cVertDiv2; i; i--) {
			glBegin(GL_QUAD_STRIP);
			for (j=0; j<=cVertDiv2; j+=2) {
			    glColor3fv(&c[16]);
			    glVertex2fv(&v[j*4]);
			    glColor3fv(&c[20]);
			    glVertex2fv(&v[(j+1)*4]);
			}
			for (j=cVertDiv2-2; j>=0; j-=2) {
			    glColor3fv(&c[4]);
			    glVertex2fv(&v[j*4]);
			    glColor3fv(&c[8]);
			    glVertex2fv(&v[(j+1)*4]);
			}
			glEnd();
		    }
		  }
                  if (!mod_average)
		    sprintf(pbuf, "Angle %6.2f", angle);
		    
		  endtest(pbuf, rate, 0);
		}

		glPopMatrix();
	    }
	    printaverage();

	}
    }
    if (mod_doublebuffer) {
        auxSwapBuffers();
        Sleep(2000);               /* for visual feedback */
    }
    exit(0);
}


static void perfqstriptex(void)
{
    int i,j,k, ti;
    char pbuf[256];
    int cVert = 60;
    int cVertDiv2 = 30;

    if (mod_texfile) MyLoadImage();
    else CreateImage();

    InitTexParams();
    
    /* Triangle mesh tests:  Each qstrip contains 62 vertices, or	*/
    /* 60 triangles.  To make the calculation exact, the rate	*/
    /* must be a multiple of 60.					*/

    /* If the quad size is specified, set the size of the quad strip to
    ** fit the window.  The number of vertices must be a multiple of four (due
    ** to code below), and it must not exceed 60.
    */
    if (mod_size) {
        cVert = (int) (MINDIMENSION*2 / prim_size) - 2;
        if (cVert & 1) cVert++;
        cVert &= ~3;
        if (cVert < 4) cVert = 4;
        if (cVert > 60) cVert = 60;
    }
    cVertDiv2 = cVert >> 1;
    
    if (!mod_2d) {
	if (mod_cmode && mod_shade) {

	    /*** GOURAUD SHADED CMODE QSTRIP ***/
	    /* 255 = r, 240 = g, 255 = b */
	    makeramp(208,255,0,0,0,0,255,16);
	    makeramp(224,0,0,255,255,255,0,16);
	    makeramp(240,255,255,0,255,0,255,16);

	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);
		    for(i=(rate)/cVertDiv2; i; i--) {
			glBegin(GL_QUAD_STRIP); 
			for (j=0, ti=0; j<=cVertDiv2; j+=2, ti = ti%4 ) {
			    glIndexi(255);
                glTexCoord2fv (&t[ti++]);
			    glVertex3fv(&v[j*4]);
			    glIndexi(240);
                glTexCoord2fv (&t[ti++]);
			    glVertex3fv(&v[(j+1)*4]);
			}
			for (j=cVertDiv2-2, ti=0; j>=0; j-=2, ti = ti%4 ) {
			    glIndexi(223);
                glTexCoord2fv (&t[ti++]);
			    glVertex3fv(&v[j*4]);
			    glIndexi(208);
                glTexCoord2fv (&t[ti++]);
			    glVertex3fv(&v[(j+1)*4]);
			}
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = cVert * (rate/cVertDiv2);

		/* Do the real thing GOURAUD shaded Cmode qstrip */
		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    for(i=(rate)/cVertDiv2; i; i--) {
			glBegin(GL_QUAD_STRIP);
			for (j=0, ti=0; j<=cVertDiv2; j+=2, ti = ti%4 ) {
			    glIndexi(255);
                glTexCoord2fv (&t[ti++]);
			    glVertex3fv(&v[j*4]);
			    glIndexi(240);
                glTexCoord2fv (&t[ti++]);
			    glVertex3fv(&v[(j+1)*4]);
			}
			for (j=cVertDiv2-2, ti=0; j>=0; j-=2, ti = ti%4 ) {
			    glIndexi(223);
                glTexCoord2fv (&t[ti++]);
			    glVertex3fv(&v[j*4]);
			    glIndexi(208);
                glTexCoord2fv (&t[ti++]);
			    glVertex3fv(&v[(j+1)*4]);
			}
			glEnd();
		    }
                    if (!mod_average)
		      sprintf (pbuf, "Angle %6.2f", angle);
		  }
		  endtest(pbuf, rate, 0);
		}

		glPopMatrix();
	    }
	    printaverage ();

	} else if (!mod_light && !mod_shade) {

	    /*** FLAT SHADED QSTRIP ***/
	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);
		    for(i=(rate)/cVertDiv2; i; i--) {
			glBegin(GL_QUAD_STRIP);
			for (j=0, ti=0; j<=cVertDiv2; j++, ti=ti%4 ) {
                glTexCoord2fv (&t[ti++]);
			    glVertex3fv(&v[j*4]);
			}
			for (j=cVertDiv2-2, ti=0; j>=0; j-=2, ti=ti%4 ) {
                glTexCoord2fv (&t[ti++]);
			    glVertex3fv(&v[j*4]);
                glTexCoord2fv (&t[ti++]);
			    glVertex3fv(&v[(j+1)*4]);
			}
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = cVert * (rate/cVertDiv2);
	    
		/* Do the real thing - FLAT shaded qstrip */
		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    for(i=(rate)/cVertDiv2; i; i--) {
			glBegin(GL_QUAD_STRIP);
			for (j=0, ti=0; j<=cVertDiv2; j++,ti=ti%4 ) {
                glTexCoord2fv (&t[ti++]);
			    glVertex3fv(&v[j*4]);
			}
			for (j=cVertDiv2-2, ti=0; j>=0; j-=2, ti=ti%4 ) {
                glTexCoord2fv (&t[ti++]);
			    glVertex3fv(&v[j*4]);
                glTexCoord2fv (&t[ti++]);
			    glVertex3fv(&v[(j+1)*4]);
			}
			glEnd();
		    }
                    if (!mod_average)
		      sprintf(pbuf, "Angle %6.2f", angle);
		  }
		  endtest(pbuf, rate, 0);
		}
		glPopMatrix();
	    }
	    printaverage();

	} else if (!mod_cmode && mod_light) {

	    /*** LIGHTED RGB QSTRIP ***/

	    glLoadIdentity();

	    glMatrixMode(GL_PROJECTION);
	    glLoadIdentity();
	    glOrtho(-0.5*xsize,0.5*xsize,-0.5*ysize,0.5*ysize,1.0,-1.0);
	    glMatrixMode(GL_MODELVIEW);

	    /* set lights */
	    setLightingParameters();

	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);

		    for(i=(rate)/cVertDiv2; i; i--) {
			glBegin(GL_QUAD_STRIP);
			for (j=0, ti=0; j<=cVertDiv2; j+=2, ti=ti%4 ) {
			    glNormal3fv(&n[0]);
                glTexCoord2fv (&t[ti++]);
			    glVertex3fv(&v[j*4]);
			    glNormal3fv(&n[4]);
                glTexCoord2fv (&t[ti++]);
			    glVertex3fv(&v[(j+1)*4]);
			}
			for (j=cVertDiv2-2, ti=0; j>=0; j-=2, ti=ti%4 ) {
			    glNormal3fv(&n[8]);
                glTexCoord2fv (&t[ti++]);
			    glVertex3fv(&v[j*4]);
			    glNormal3fv(&n[12]);
                glTexCoord2fv (&t[ti++]);
			    glVertex3fv(&v[(j+1)*4]);
			}
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = cVert * (rate/cVertDiv2);

		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    for(i=(rate)/cVertDiv2; i; i--) {
			glBegin(GL_QUAD_STRIP);
			for (j=0, ti=0; j<=cVertDiv2; j+=2, ti=ti%4 ) {
			    glNormal3fv(&n[0]);
                glTexCoord2fv (&t[ti++]);
			    glVertex3fv(&v[j*4]);
			    glNormal3fv(&n[4]);
                glTexCoord2fv (&t[ti++]);
			    glVertex3fv(&v[(j+1)*4]);
			}
			for (j=cVertDiv2-2, ti=0; j>=0; j-=2, ti=ti%4 ) {
                glTexCoord2fv (&t[ti++]);
			    glNormal3fv(&n[8]);
			    glVertex3fv(&v[j*4]);
			    glNormal3fv(&n[12]);
                glTexCoord2fv (&t[ti++]);
			    glVertex3fv(&v[(j+1)*4]);
			}
			glEnd();
		    }
                    if (!mod_average)
		      sprintf(pbuf, "Angle %6.2f", angle);
		  }
		  endtest(pbuf, rate, 0);
		}
		glPopMatrix();
	    }
	    printaverage();

	} else if (!mod_cmode && mod_shade) {

	    /*** GOURAUD SHADED RGB TMESH ***/
	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);
		    for(i=(rate)/cVertDiv2; i; i--) {
			glBegin(GL_QUAD_STRIP);
			for (j=0, ti=0; j<=cVertDiv2; j+=2, ti=ti%4 ) {
			    glColor3fv(&c[16]);
                glTexCoord2fv (&t[ti++]);
			    glVertex3fv(&v[j*4]);
			    glColor3fv(&c[20]);
                glTexCoord2fv (&t[ti++]);
			    glVertex3fv(&v[(j+1)*4]);
			}
			for (j=cVertDiv2-2, ti=0; j>=0; j-=2, ti=ti%4 ) {
			    glColor3fv(&c[4]);
                glTexCoord2fv (&t[ti++]);
			    glVertex3fv(&v[j*4]);
			    glColor3fv(&c[8]);
                glTexCoord2fv (&t[ti++]);
			    glVertex3fv(&v[(j+1)*4]);
			}
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = cVert * (rate/cVertDiv2);

		/* Do the real thing GOURAUD shaded qstrip */
		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    for(i=(rate)/cVertDiv2; i; i--) {
			glBegin(GL_QUAD_STRIP);
			for (j=0, ti=0; j<=cVertDiv2; j+=2,  ti=ti%4) {
			    glColor3fv(&c[16]);
                glTexCoord2fv (&t[ti++]);
			    glVertex3fv(&v[j*4]);
			    glColor3fv(&c[20]);
                glTexCoord2fv (&t[ti++]);
			    glVertex3fv(&v[(j+1)*4]);
			}
			for (j=cVertDiv2-2, ti=0; j>=0; j-=2, ti=ti%4) {
			    glColor3fv(&c[4]);
                glTexCoord2fv (&t[ti++]);
			    glVertex3fv(&v[j*4]);
			    glColor3fv(&c[8]);
                glTexCoord2fv (&t[ti++]);
			    glVertex3fv(&v[(j+1)*4]);
			}
			glEnd();
		    }
		  }
                  if (!mod_average)
		    sprintf(pbuf, "Angle %6.2f", angle);
		    
		  endtest(pbuf, rate, 0);
		}

		glPopMatrix();
	    }
	    printaverage();
	}

    } else {	/* must be 2d */
	if (mod_cmode && mod_shade) { /* color map lighting yet */

	    /*** GOURAUD SHADED CMODE TMESH ***/
	    /* 255 = r, 240 = g, 255 = b */
	    makeramp(208,255,0,0,0,0,255,16);
	    makeramp(224,0,0,255,255,255,0,16);
	    makeramp(240,255,255,0,255,0,255,16);

	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);

		    for(i=(rate)/cVertDiv2; i; i--) {
			glBegin(GL_QUAD_STRIP);
			for (j=0, ti=0; j<=cVertDiv2; j+=2, ti=ti%4 ) {
			    glIndexi(255);
                glTexCoord2fv (&t[ti++]);
			    glVertex2fv(&v[j*4]);
			    glIndexi(240);
                glTexCoord2fv (&t[ti++]);
			    glVertex2fv(&v[(j+1)*4]);
			}
			for (j=cVertDiv2-2, ti=0; j>=0; j-=2, ti=ti%4 ) {
			    glIndexi(223);
                glTexCoord2fv (&t[ti++]);
			    glVertex2fv(&v[j*4]);
			    glIndexi(208);
                glTexCoord2fv (&t[ti++]);
			    glVertex2fv(&v[(j+1)*4]);
			}
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = cVert * (rate/cVertDiv2);

		/* Do the real thing GOURAUD shaded Cmode qstrip */
		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    for(i=(rate)/cVertDiv2; i; i--) {
			glBegin(GL_QUAD_STRIP);
			for (j=0, ti=0; j<=cVertDiv2; j+=2, ti=ti%4 ) {
			    glIndexi(255);
                glTexCoord2fv (&t[ti++]);
			    glVertex2fv(&v[j*4]);
			    glIndexi(240);
                glTexCoord2fv (&t[ti++]);
			    glVertex2fv(&v[(j+1)*4]);
			}
			for (j=cVertDiv2-2, ti=0; j>=0; j-=2, ti=ti%4 ) {
			    glIndexi(223);
                glTexCoord2fv (&t[ti++]);
			    glVertex2fv(&v[j*4]);
			    glIndexi(208);
                glTexCoord2fv (&t[ti++]);
			    glVertex2fv(&v[(j+1)*4]);
			}
			glEnd();
		    }
		  }
                  if (!mod_average)
		    sprintf(pbuf, "Angle %6.2f", angle);
		    
		  endtest(pbuf, rate, 0);
		}

		glPopMatrix();
	    }
	    printaverage();

	} else if (!mod_light && !mod_shade) {

	    /*** FLAT SHADED QSTRIP ***/
	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);

		    for(i=(rate)/cVertDiv2; i; i--) {
			glBegin(GL_QUAD_STRIP);
			for (j=0, ti=0; j<=cVertDiv2; j++,  ti=ti%4 ) {
                glTexCoord2fv (&t[ti++]);
			    glVertex2fv(&v[j*4]);
			}
			for (j=cVertDiv2-2, ti=0; j>=0; j-=2, ti=ti%4 ) {
                glTexCoord2fv (&t[ti++]);
			    glVertex2fv(&v[j*4]);
                glTexCoord2fv (&t[ti++]);
			    glVertex2fv(&v[(j+1)*4]);
			}
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = cVert * (rate/cVertDiv2);
	    
		/* Do the real thing - FLAT shaded qstrip */
		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    for(i=(rate)/cVertDiv2; i; i--) {
			glBegin(GL_QUAD_STRIP);
			for (j=0; j<=cVertDiv2, ti=0; j++, ti=ti%4 ) {
                glTexCoord2fv (&t[ti++]);
			    glVertex2fv(&v[j*4]);
			}
			for (j=cVertDiv2-2, ti=0; j>=0; j-=2, ti=ti%4 ) {
                glTexCoord2fv (&t[ti++]);
			    glVertex2fv(&v[j*4]);
                glTexCoord2fv (&t[ti++]);
			    glVertex2fv(&v[(j+1)*4]);
			}
			glEnd();
		    }
		  }
                  if (!mod_average)
		    sprintf(pbuf, "Angle %6.2f", angle);
		    
		  endtest(pbuf, rate, 0);
		}
		glPopMatrix();
	    }
	    printaverage();

	} else if (!mod_cmode && mod_light) {

	    /*** LIGHTED RGB QSTRIP ***/

	    glLoadIdentity();
	    
	    glMatrixMode(GL_PROJECTION);
	    glLoadIdentity();
	    glOrtho(-0.5*xsize,0.5*xsize,-0.5*ysize,0.5*ysize,1.0,-1.0);
	    glMatrixMode(GL_MODELVIEW);

	    /* set lights */
	    setLightingParameters();

	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);
		    for(i=(rate)/cVertDiv2; i; i--) {
			glBegin(GL_QUAD_STRIP);
			for (j=0, ti=0; j<=cVertDiv2; j+=2, ti=ti%4 ) {
			    glNormal3fv(&n[0]);
                glTexCoord2fv (&t[ti++]);
			    glVertex2fv(&v[j*4]);
			    glNormal3fv(&n[4]);
                glTexCoord2fv (&t[ti++]);
			    glVertex2fv(&v[(j+1)*4]);
			}
			for (j=cVertDiv2-2, ti=0; j>=0; j-=2, ti=ti%4 ) {
			    glNormal3fv(&n[8]);
                glTexCoord2fv (&t[ti++]);
			    glVertex2fv(&v[j*4]);
			    glNormal3fv(&n[12]);
                glTexCoord2fv (&t[ti++]);
			    glVertex2fv(&v[(j+1)*4]);
			}
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = cVert * (rate/cVertDiv2);

		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    for(i=(rate)/cVertDiv2, ti=0; i; i--) {
			glBegin(GL_QUAD_STRIP);
			for (j=0; j<=cVertDiv2; j+=2, ti=ti%4 ) {
			    glNormal3fv(&n[0]);
                glTexCoord2fv (&t[ti++]);
			    glVertex2fv(&v[j*4]);
			    glNormal3fv(&n[4]);
                glTexCoord2fv (&t[ti++]);
			    glVertex2fv(&v[(j+1)*4]);
			}
			for (j=cVertDiv2-2, ti=0; j>=0; j-=2, ti=ti%4 ) {
			    glNormal3fv(&n[8]);
                glTexCoord2fv (&t[ti++]);
			    glVertex2fv(&v[j*4]);
			    glNormal3fv(&n[12]);
                glTexCoord2fv (&t[ti++]);
			    glVertex2fv(&v[(j+1)*4]);
			}
			glEnd();
		    }
		  }
                  if (!mod_average)
		    sprintf(pbuf, "Angle %6.2f", angle);
		    
		  endtest(pbuf, rate, 0);
		}
		glPopMatrix();
	    }
	    printaverage();

	} else if (!mod_cmode && mod_shade) {

	    /*** GOURAUD SHADED RGB TMESH ***/
	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);
		    for(i=(rate)/cVertDiv2; i; i--) {
			glBegin(GL_QUAD_STRIP);
			for (j=0, ti=0; j<=cVertDiv2; j+=2, ti=ti%4 ) {
			    glColor3fv(&c[16]);
                glTexCoord2fv (&t[ti++]);
			    glVertex2fv(&v[j*4]);
			    glColor3fv(&c[20]);
                glTexCoord2fv (&t[ti++]);
			    glVertex2fv(&v[(j+1)*4]);
			}
			for (j=cVertDiv2-2, ti=0; j>=0; j-=2, ti=ti%4 ) {
			    glColor3fv(&c[4]);
                glTexCoord2fv (&t[ti++]);
			    glVertex2fv(&v[j*4]);
			    glColor3fv(&c[8]);
                glTexCoord2fv (&t[ti++]);
			    glVertex2fv(&v[(j+1)*4]);
			}
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = cVert * (rate/cVertDiv2);

		/* Do the real thing GOURAUD shaded qstrip */
		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    for(i=(rate)/cVertDiv2; i; i--) {
			glBegin(GL_QUAD_STRIP);
			for (j=0, ti=0; j<=cVertDiv2; j+=2, ti=ti%4 ) {
			    glColor3fv(&c[16]);
                glTexCoord2fv (&t[ti++]);
			    glVertex2fv(&v[j*4]);
			    glColor3fv(&c[20]);
                glTexCoord2fv (&t[ti++]);
			    glVertex2fv(&v[(j+1)*4]);
			}
			for (j=cVertDiv2-2, ti=0; j>=0; j-=2, ti=ti%4 ) {
			    glColor3fv(&c[4]);
                glTexCoord2fv (&t[ti++]);
			    glVertex2fv(&v[j*4]);
			    glColor3fv(&c[8]);
                glTexCoord2fv (&t[ti++]);
			    glVertex2fv(&v[(j+1)*4]);
			}
			glEnd();
		    }
		  }
                  if (!mod_average)
		    sprintf(pbuf, "Angle %6.2f", angle);
		    
		  endtest(pbuf, rate, 0);
		}

		glPopMatrix();
	    }
	    printaverage();

	}
    }
    if (mod_doublebuffer) {
        auxSwapBuffers();
        Sleep(2000);               /* for visual feedback */
    }
    exit(0);
}


static void perfpolytex(void)
{
    float *vtx = &v[0];
    int i, k;
    char pbuf[256];
    int cPoly;

    if (mod_texfile) MyLoadImage();
    else CreateImage();

    InitTexParams();

    /* If the polygon size is specified, set the number of polygons to
    ** fit the window.  The maximum number of polygons is 5.
    */
    cPoly = 5;
    if (mod_size) {
        cPoly = (int) (MINDIMENSION/2 / prim_size);
        if (cPoly < 1) cPoly = 1;
        if (cPoly > 5) cPoly = 5;
    }

    if (!mod_2d) {

	/**** 3D POLYGONS ****/

	if (mod_light && !mod_cmode) {

	/*** POLYGONS (LIGHTED) *****/

	    glLoadIdentity();
	    
	    glMatrixMode(GL_PROJECTION);
	    glLoadIdentity();
	    glOrtho(-0.5*xsize, 0.5*xsize,-0.5*ysize, 0.5*ysize,1.0, -1.0);
	    
	    glMatrixMode(GL_MODELVIEW);

	    /* set lights */
	    setLightingParameters();

	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
                if (!mod_average)
		  sprintf (pbuf, "Angle %6.2f", angle);
		  
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    if (mod_lmcolor) {
		        starttest(0);
		        for(i=(rate)/cPoly; i; i--) {
			    glBegin(GL_QUADS);
                            switch (cPoly) {
                              case 5:
			        glColor3fv(&c[4]); glNormal3fv(&n[0]); 
			        glTexCoord2fv(&t[0]); glVertex3fv(vtx+32); 
			        glColor3fv(&c[16]); glNormal3fv(&n[4]); 
			        glTexCoord2fv(&t[2]); glVertex3fv(vtx+36); 
			        glColor3fv(&c[8]); glNormal3fv(&n[8]); 
			        glTexCoord2fv(&t[4]); glVertex3fv(vtx+44); 
			        glColor3fv(&c[8]); glNormal3fv(&n[12]); 
			        glTexCoord2fv(&t[6]); glVertex3fv(vtx+40);
                              case 4:
			        glColor3fv(&c[4]); glNormal3fv(&n[0]); 
			        glTexCoord2fv(&t[0]); glVertex3fv(vtx+24); 
			        glColor3fv(&c[16]); glNormal3fv(&n[4]); 
			        glTexCoord2fv(&t[2]); glVertex3fv(vtx+28); 
			        glColor3fv(&c[8]); glNormal3fv(&n[8]); 
			        glTexCoord2fv(&t[4]); glVertex3fv(vtx+36); 
			        glColor3fv(&c[8]); glNormal3fv(&n[12]); 
			        glTexCoord2fv(&t[6]); glVertex3fv(vtx+32);
                              case 3:
			        glColor3fv(&c[4]); glNormal3fv(&n[0]); 
			        glTexCoord2fv(&t[0]); glVertex3fv(vtx+16); 
			        glColor3fv(&c[16]); glNormal3fv(&n[4]); 
			        glTexCoord2fv(&t[2]); glVertex3fv(vtx+20); 
			        glColor3fv(&c[8]); glNormal3fv(&n[8]); 
			        glTexCoord2fv(&t[4]); glVertex3fv(vtx+28); 
			        glColor3fv(&c[8]); glNormal3fv(&n[12]); 
			        glTexCoord2fv(&t[6]); glVertex3fv(vtx+24);
                              case 2:
			        glColor3fv(&c[4]); glNormal3fv(&n[0]); 
			        glTexCoord2fv(&t[0]); glVertex3fv(vtx+8); 
			        glColor3fv(&c[16]); glNormal3fv(&n[4]); 
			        glTexCoord2fv(&t[2]); glVertex3fv(vtx+12); 
			        glColor3fv(&c[8]); glNormal3fv(&n[8]); 
			        glTexCoord2fv(&t[4]); glVertex3fv(vtx+20); 
			        glColor3fv(&c[8]); glNormal3fv(&n[12]); 
			        glTexCoord2fv(&t[6]); glVertex3fv(vtx+16);
                              case 1:
			        glColor3fv(&c[4]); glNormal3fv(&n[0]); 
			        glTexCoord2fv(&t[0]); glVertex3fv(vtx); 
			        glColor3fv(&c[16]); glNormal3fv(&n[4]); 
			        glTexCoord2fv(&t[2]); glVertex3fv(vtx+4); 
			        glColor3fv(&c[8]); glNormal3fv(&n[8]); 
			        glTexCoord2fv(&t[4]); glVertex3fv(vtx+12); 
			        glColor3fv(&c[8]); glNormal3fv(&n[12]); 
			        glTexCoord2fv(&t[6]); glVertex3fv(vtx+8);
			    }
			    glEnd();
		        }
    
		        secs = timer(1);
		    }
		    else {
		        starttest(0);
		        for(i=(rate)/cPoly; i; i--) {
			    glBegin(GL_QUADS);
			    switch (cPoly) {
			      case 5:
                    glTexCoord2fv(&t[0]);
			        glNormal3fv(&n[0]); glVertex3fv(vtx+32); 
                    glTexCoord2fv(&t[2]);
			        glNormal3fv(&n[4]); glVertex3fv(vtx+36); 
                    glTexCoord2fv(&t[4]);
			        glNormal3fv(&n[8]); glVertex3fv(vtx+44); 
                    glTexCoord2fv(&t[6]);
			        glNormal3fv(&n[12]); glVertex3fv(vtx+40);
                              case 4:
                    glTexCoord2fv(&t[0]);
			        glNormal3fv(&n[0]); glVertex3fv(vtx+24); 
                    glTexCoord2fv(&t[2]);
			        glNormal3fv(&n[4]); glVertex3fv(vtx+28); 
                    glTexCoord2fv(&t[4]);
			        glNormal3fv(&n[8]); glVertex3fv(vtx+36); 
                    glTexCoord2fv(&t[6]);
			        glNormal3fv(&n[12]); glVertex3fv(vtx+32);
                              case 3:
                    glTexCoord2fv(&t[0]);
			        glNormal3fv(&n[0]); glVertex3fv(vtx+16); 
                    glTexCoord2fv(&t[2]);
			        glNormal3fv(&n[4]); glVertex3fv(vtx+20); 
                    glTexCoord2fv(&t[4]);
			        glNormal3fv(&n[8]); glVertex3fv(vtx+28); 
                    glTexCoord2fv(&t[6]);
			        glNormal3fv(&n[12]); glVertex3fv(vtx+24);
                              case 2:
                    glTexCoord2fv(&t[0]);
			        glNormal3fv(&n[0]); glVertex3fv(vtx+8); 
                    glTexCoord2fv(&t[2]);
			        glNormal3fv(&n[4]); glVertex3fv(vtx+12); 
                    glTexCoord2fv(&t[4]);
			        glNormal3fv(&n[8]); glVertex3fv(vtx+20); 
                    glTexCoord2fv(&t[6]);
			        glNormal3fv(&n[12]); glVertex3fv(vtx+16);
                              case 1:
                    glTexCoord2fv(&t[0]);
			        glNormal3fv(&n[0]); glVertex3fv(vtx); 
                    glTexCoord2fv(&t[2]);
			        glNormal3fv(&n[4]); glVertex3fv(vtx+4); 
                    glTexCoord2fv(&t[4]);
			        glNormal3fv(&n[8]); glVertex3fv(vtx+12); 
                    glTexCoord2fv(&t[6]);
			        glNormal3fv(&n[12]); glVertex3fv(vtx+8);
			    }
			    glEnd();
			}
    
		        secs = timer(1);
		    }
		}
		rate = rate * (secspertest/secs);
		rate = cPoly * (rate/cPoly);

		for (k=0; k<loopcount; k++) {
		    if (mod_lmcolor) {
		      if (starttest(k)) {
		        for(i=(rate)/cPoly; i; i--) {
			    glBegin(GL_QUADS);
			    switch (cPoly) {
			      case 5:
			        glColor3fv(&c[4]); glNormal3fv(&n[0]);
			        glTexCoord2fv(&t[0]); glVertex3fv(vtx+32); 
			        glColor3fv(&c[16]); glNormal3fv(&n[4]);
			        glTexCoord2fv(&t[2]); glVertex3fv(vtx+36); 
			        glColor3fv(&c[8]); glNormal3fv(&n[8]);
			        glTexCoord2fv(&t[4]); glVertex3fv(vtx+44); 
			        glColor3fv(&c[8]); glNormal3fv(&n[12]);
			        glTexCoord2fv(&t[6]); glVertex3fv(vtx+40);
                              case 4:
			        glColor3fv(&c[4]); glNormal3fv(&n[0]);
			        glTexCoord2fv(&t[0]); glVertex3fv(vtx+24); 
			        glColor3fv(&c[16]); glNormal3fv(&n[4]);
			        glTexCoord2fv(&t[2]); glVertex3fv(vtx+28); 
			        glColor3fv(&c[8]); glNormal3fv(&n[8]);
			        glTexCoord2fv(&t[4]); glVertex3fv(vtx+36); 
			        glColor3fv(&c[8]); glNormal3fv(&n[12]);
			        glTexCoord2fv(&t[6]); glVertex3fv(vtx+32);
                              case 3:
			        glColor3fv(&c[4]); glNormal3fv(&n[0]);
			        glTexCoord2fv(&t[0]); glVertex3fv(vtx+16); 
			        glColor3fv(&c[16]); glNormal3fv(&n[4]);
			        glTexCoord2fv(&t[2]); glVertex3fv(vtx+20); 
			        glColor3fv(&c[8]); glNormal3fv(&n[8]);
			        glTexCoord2fv(&t[4]); glVertex3fv(vtx+28); 
			        glColor3fv(&c[8]); glNormal3fv(&n[12]);
			        glTexCoord2fv(&t[6]); glVertex3fv(vtx+24);
                              case 2:
			        glColor3fv(&c[4]); glNormal3fv(&n[0]);
			        glTexCoord2fv(&t[0]); glVertex3fv(vtx+8); 
			        glColor3fv(&c[16]); glNormal3fv(&n[4]);
			        glTexCoord2fv(&t[2]); glVertex3fv(vtx+12); 
			        glColor3fv(&c[8]); glNormal3fv(&n[8]);
			        glTexCoord2fv(&t[4]); glVertex3fv(vtx+20); 
			        glColor3fv(&c[8]); glNormal3fv(&n[12]);
			        glTexCoord2fv(&t[6]); glVertex3fv(vtx+16);
                              case 1:
			        glColor3fv(&c[4]); glNormal3fv(&n[0]);
			        glTexCoord2fv(&t[0]); glVertex3fv(vtx); 
			        glColor3fv(&c[16]); glNormal3fv(&n[4]); 
			        glTexCoord2fv(&t[2]); glVertex3fv(vtx+4); 
			        glColor3fv(&c[8]); glNormal3fv(&n[8]);
			        glTexCoord2fv(&t[4]); glVertex3fv(vtx+12); 
			        glColor3fv(&c[8]); glNormal3fv(&n[12]);
			        glTexCoord2fv(&t[6]); glVertex3fv(vtx+8);
			    }
			    glEnd();
		        }
		      }
		      endtest(pbuf, rate, 0);
		    }
		    else {
		      if (starttest(k)) {
		        for(i=(rate)/cPoly; i; i--) {
			    glBegin(GL_QUADS);
			    switch (cPoly) {
			      case 5:
                    glTexCoord2fv(&t[0]);
			        glNormal3fv(&n[0]); glVertex3fv(vtx+32); 
                    glTexCoord2fv(&t[2]);
			        glNormal3fv(&n[4]); glVertex3fv(vtx+36); 
                    glTexCoord2fv(&t[4]);
			        glNormal3fv(&n[8]); glVertex3fv(vtx+44); 
                    glTexCoord2fv(&t[6]);
			        glNormal3fv(&n[12]); glVertex3fv(vtx+40);
                              case 4:
                    glTexCoord2fv(&t[0]);
			        glNormal3fv(&n[0]); glVertex3fv(vtx+24); 
                    glTexCoord2fv(&t[2]);
			        glNormal3fv(&n[4]); glVertex3fv(vtx+28); 
                    glTexCoord2fv(&t[4]);
			        glNormal3fv(&n[8]); glVertex3fv(vtx+36); 
                    glTexCoord2fv(&t[6]);
			        glNormal3fv(&n[12]); glVertex3fv(vtx+32);
                              case 3:
                    glTexCoord2fv(&t[0]);
			        glNormal3fv(&n[0]); glVertex3fv(vtx+16); 
                    glTexCoord2fv(&t[2]);
			        glNormal3fv(&n[4]); glVertex3fv(vtx+20); 
                    glTexCoord2fv(&t[4]);
			        glNormal3fv(&n[8]); glVertex3fv(vtx+28); 
                    glTexCoord2fv(&t[6]);
			        glNormal3fv(&n[12]); glVertex3fv(vtx+24);
                              case 2:
                    glTexCoord2fv(&t[0]);
			        glNormal3fv(&n[0]); glVertex3fv(vtx+8); 
                    glTexCoord2fv(&t[2]);
			        glNormal3fv(&n[4]); glVertex3fv(vtx+12); 
                    glTexCoord2fv(&t[4]);
			        glNormal3fv(&n[8]); glVertex3fv(vtx+20); 
                    glTexCoord2fv(&t[6]);
			        glNormal3fv(&n[12]); glVertex3fv(vtx+16);
                              case 1:
                    glTexCoord2fv(&t[0]);
			        glNormal3fv(&n[0]); glVertex3fv(vtx); 
                    glTexCoord2fv(&t[2]);
			        glNormal3fv(&n[4]); glVertex3fv(vtx+4); 
                    glTexCoord2fv(&t[4]);
			        glNormal3fv(&n[8]); glVertex3fv(vtx+12); 
                    glTexCoord2fv(&t[6]);
			        glNormal3fv(&n[12]); glVertex3fv(vtx+8);
			    }
			    glEnd();
		        }
		      }
		      endtest(pbuf, rate, 0);
		    }
		}

		glPopMatrix();
	    }
	    printaverage();
	} else if (mod_shade && !mod_cmode) {

	    /*** POLYGONS (SHADED RGB) *****/

	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
                if (!mod_average)
		  sprintf(pbuf, "Angle %6.2f", angle);
		  
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);
		    for(i=(rate)/cPoly; i; i--) {
			glBegin(GL_QUADS);
			switch (cPoly) {
			  case 5:
                glTexCoord2fv(&t[0]);
			    glColor3fv(&c[4]); glVertex3fv(vtx+32); 
                glTexCoord2fv(&t[2]);
			    glColor3fv(&c[16]); glVertex3fv(vtx+36); 
                glTexCoord2fv(&t[4]);
			    glColor3fv(&c[8]); glVertex3fv(vtx+44); 
                glTexCoord2fv(&t[6]);
			    glColor3fv(&c[8]); glVertex3fv(vtx+40);
                          case 4:
                glTexCoord2fv(&t[0]);
			    glColor3fv(&c[4]); glVertex3fv(vtx+24); 
                glTexCoord2fv(&t[2]);
			    glColor3fv(&c[16]); glVertex3fv(vtx+28); 
                glTexCoord2fv(&t[4]);
			    glColor3fv(&c[8]); glVertex3fv(vtx+36); 
                glTexCoord2fv(&t[6]);
			    glColor3fv(&c[8]); glVertex3fv(vtx+32);
                          case 3:
                glTexCoord2fv(&t[0]);
			    glColor3fv(&c[4]); glVertex3fv(vtx+16); 
                glTexCoord2fv(&t[2]);
			    glColor3fv(&c[16]); glVertex3fv(vtx+20); 
                glTexCoord2fv(&t[4]);
			    glColor3fv(&c[8]); glVertex3fv(vtx+28); 
                glTexCoord2fv(&t[6]);
			    glColor3fv(&c[8]); glVertex3fv(vtx+24);
                          case 2:
                glTexCoord2fv(&t[0]);
			    glColor3fv(&c[4]); glVertex3fv(vtx+8); 
                glTexCoord2fv(&t[2]);
			    glColor3fv(&c[16]); glVertex3fv(vtx+12); 
                glTexCoord2fv(&t[4]);
			    glColor3fv(&c[8]); glVertex3fv(vtx+20); 
                glTexCoord2fv(&t[6]);
			    glColor3fv(&c[8]); glVertex3fv(vtx+16);
                          case 1:
                glTexCoord2fv(&t[0]);
			    glColor3fv(&c[4]); glVertex3fv(vtx); 
                glTexCoord2fv(&t[2]);
			    glColor3fv(&c[16]); glVertex3fv(vtx+4); 
                glTexCoord2fv(&t[4]);
			    glColor3fv(&c[8]); glVertex3fv(vtx+12); 
                glTexCoord2fv(&t[6]);
			    glColor3fv(&c[8]); glVertex3fv(vtx+8);
			}
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = cPoly * (rate/cPoly);

		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    for(i=(rate)/cPoly; i; i--) {
			glBegin(GL_QUADS);
			switch (cPoly) {
			  case 5:
                glTexCoord2fv(&t[0]);
			    glColor3fv(&c[4]); glVertex3fv(vtx+32); 
                glTexCoord2fv(&t[2]);
			    glColor3fv(&c[16]); glVertex3fv(vtx+36); 
                glTexCoord2fv(&t[4]);
			    glColor3fv(&c[8]); glVertex3fv(vtx+44); 
                glTexCoord2fv(&t[6]);
			    glColor3fv(&c[8]); glVertex3fv(vtx+40);
                          case 4:
                glTexCoord2fv(&t[0]);
			    glColor3fv(&c[4]); glVertex3fv(vtx+24); 
                glTexCoord2fv(&t[2]);
			    glColor3fv(&c[16]); glVertex3fv(vtx+28); 
                glTexCoord2fv(&t[4]);
			    glColor3fv(&c[8]); glVertex3fv(vtx+36); 
                glTexCoord2fv(&t[6]);
			    glColor3fv(&c[8]); glVertex3fv(vtx+32);
                          case 3:
                glTexCoord2fv(&t[0]);
			    glColor3fv(&c[4]); glVertex3fv(vtx+16); 
                glTexCoord2fv(&t[2]);
			    glColor3fv(&c[16]); glVertex3fv(vtx+20); 
                glTexCoord2fv(&t[4]);
			    glColor3fv(&c[8]); glVertex3fv(vtx+28); 
                glTexCoord2fv(&t[6]);
			    glColor3fv(&c[8]); glVertex3fv(vtx+24);
                          case 2:
                glTexCoord2fv(&t[0]);
			    glColor3fv(&c[4]); glVertex3fv(vtx+8); 
                glTexCoord2fv(&t[2]);
			    glColor3fv(&c[16]); glVertex3fv(vtx+12); 
                glTexCoord2fv(&t[4]);
			    glColor3fv(&c[8]); glVertex3fv(vtx+20); 
                glTexCoord2fv(&t[6]);
			    glColor3fv(&c[8]); glVertex3fv(vtx+16);
                          case 1:
                glTexCoord2fv(&t[0]);
			    glColor3fv(&c[4]); glVertex3fv(vtx); 
                glTexCoord2fv(&t[2]);
			    glColor3fv(&c[16]); glVertex3fv(vtx+4); 
                glTexCoord2fv(&t[4]);
			    glColor3fv(&c[8]); glVertex3fv(vtx+12); 
                glTexCoord2fv(&t[6]);
			    glColor3fv(&c[8]); glVertex3fv(vtx+8);
			}
			glEnd();
		    }
		  }
		  endtest(pbuf, rate, 0);
		}

		glPopMatrix();
	    }
	    printaverage();
	} else if (mod_shade && mod_cmode) {

	    /*** POLYGONS (SHADED COLOR MAPPED) *****/

	    /* 255 = r, 240 = g, 255 = b */
	    makeramp(208, 255, 0, 0, 0, 0, 255, 16);
	    makeramp(224, 0, 0, 255, 255, 255, 0, 16);
	    makeramp(240, 255, 255, 0, 255, 0, 255, 16);

	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
                if (!mod_average)
		  sprintf(pbuf, "Angle %6.2f", angle);
		  
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);
		    for(i=(rate)/cPoly; i; i--) {
			glBegin(GL_QUADS);
			switch (cPoly) {
			  case 5:
                glTexCoord2fv(&t[0]);
			    glIndexi(255); glVertex3fv(vtx+32); 
                glTexCoord2fv(&t[2]);
			    glIndexi(240); glVertex3fv(vtx+36); 
                glTexCoord2fv(&t[4]);
			    glIndexi(223); glVertex3fv(vtx+44); 
                glTexCoord2fv(&t[6]);
			    glIndexi(208); glVertex3fv(vtx+40);
                          case 4:
                glTexCoord2fv(&t[0]);
			    glIndexi(255); glVertex3fv(vtx+24); 
                glTexCoord2fv(&t[2]);
			    glIndexi(240); glVertex3fv(vtx+28); 
                glTexCoord2fv(&t[4]);
			    glIndexi(223); glVertex3fv(vtx+36); 
                glTexCoord2fv(&t[6]);
			    glIndexi(208); glVertex3fv(vtx+32);
                          case 3:
                glTexCoord2fv(&t[0]);
			    glIndexi(255); glVertex3fv(vtx+16); 
                glTexCoord2fv(&t[2]);
			    glIndexi(240); glVertex3fv(vtx+20); 
                glTexCoord2fv(&t[4]);
			    glIndexi(223); glVertex3fv(vtx+28); 
                glTexCoord2fv(&t[6]);
			    glIndexi(208); glVertex3fv(vtx+24);
                          case 2:
                glTexCoord2fv(&t[0]);
			    glIndexi(255); glVertex3fv(vtx+8); 
                glTexCoord2fv(&t[2]);
			    glIndexi(240); glVertex3fv(vtx+12); 
                glTexCoord2fv(&t[4]);
			    glIndexi(223); glVertex3fv(vtx+20); 
                glTexCoord2fv(&t[6]);
			    glIndexi(208); glVertex3fv(vtx+16);
                          case 1:
                glTexCoord2fv(&t[0]);
			    glIndexi(255); glVertex3fv(vtx); 
                glTexCoord2fv(&t[2]);
			    glIndexi(240); glVertex3fv(vtx+4); 
                glTexCoord2fv(&t[4]);
			    glIndexi(223); glVertex3fv(vtx+12); 
                glTexCoord2fv(&t[6]);
			    glIndexi(208); glVertex3fv(vtx+8);
			}
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = cPoly * (rate/cPoly);

		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    for(i=(rate)/cPoly; i; i--) {
			glBegin(GL_QUADS);
			switch (cPoly) {
			  case 5:
                glTexCoord2fv(&t[0]);
			    glIndexi(255); glVertex3fv(vtx+32); 
                glTexCoord2fv(&t[2]);
			    glIndexi(240); glVertex3fv(vtx+36); 
                glTexCoord2fv(&t[4]);
			    glIndexi(223); glVertex3fv(vtx+44); 
                glTexCoord2fv(&t[6]);
			    glIndexi(208); glVertex3fv(vtx+40);
                          case 4:
                glTexCoord2fv(&t[0]);
			    glIndexi(255); glVertex3fv(vtx+24); 
                glTexCoord2fv(&t[2]);
			    glIndexi(240); glVertex3fv(vtx+28); 
                glTexCoord2fv(&t[4]);
			    glIndexi(223); glVertex3fv(vtx+36); 
                glTexCoord2fv(&t[6]);
			    glIndexi(208); glVertex3fv(vtx+32);
                          case 3:
                glTexCoord2fv(&t[0]);
			    glIndexi(255); glVertex3fv(vtx+16); 
                glTexCoord2fv(&t[2]);
			    glIndexi(240); glVertex3fv(vtx+20); 
                glTexCoord2fv(&t[4]);
			    glIndexi(223); glVertex3fv(vtx+28); 
                glTexCoord2fv(&t[6]);
			    glIndexi(208); glVertex3fv(vtx+24);
                          case 2:
                glTexCoord2fv(&t[0]);
			    glIndexi(255); glVertex3fv(vtx+8); 
                glTexCoord2fv(&t[2]);
			    glIndexi(240); glVertex3fv(vtx+12); 
                glTexCoord2fv(&t[4]);
			    glIndexi(223); glVertex3fv(vtx+20); 
                glTexCoord2fv(&t[6]);
			    glIndexi(208); glVertex3fv(vtx+16);
                          case 1:
                glTexCoord2fv(&t[0]);
			    glIndexi(255); glVertex3fv(vtx); 
                glTexCoord2fv(&t[2]);
			    glIndexi(240); glVertex3fv(vtx+4); 
                glTexCoord2fv(&t[4]);
			    glIndexi(223); glVertex3fv(vtx+12); 
                glTexCoord2fv(&t[6]);
			    glIndexi(208); glVertex3fv(vtx+8);
			}
			glEnd();
		    }
		  }
		  endtest(pbuf, rate, 0);
		}

		glPopMatrix();
	    }
	    printaverage();

	} else if (!mod_light && !mod_shade) {

	    /*** POLYGONS (FLAT SHADED) *****/

	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
                if (!mod_average)
		  sprintf(pbuf, "Angle %6.2f", angle);
		  
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);
		    for(i=(rate)/cPoly; i; i--) {
			glBegin(GL_QUADS);
			switch (cPoly) {
			  case 5:
			    glTexCoord2fv(&t[0]); glVertex3fv(vtx+32); 
                glTexCoord2fv(&t[2]); glVertex3fv(vtx+36);
			    glTexCoord2fv(&t[4]); glVertex3fv(vtx+44); 
                glTexCoord2fv(&t[6]); glVertex3fv(vtx+40);
                          case 4:
			    glTexCoord2fv(&t[0]); glVertex3fv(vtx+24); 
                glTexCoord2fv(&t[2]); glVertex3fv(vtx+28);
			    glTexCoord2fv(&t[4]); glVertex3fv(vtx+36); 
                glTexCoord2fv(&t[6]); glVertex3fv(vtx+32);
                          case 3:
			    glTexCoord2fv(&t[0]); glVertex3fv(vtx+16); 
                glTexCoord2fv(&t[2]); glVertex3fv(vtx+20);
			    glTexCoord2fv(&t[4]); glVertex3fv(vtx+28); 
                glTexCoord2fv(&t[6]); glVertex3fv(vtx+24);
                          case 2:
			    glTexCoord2fv(&t[0]); glVertex3fv(vtx+8); 
                glTexCoord2fv(&t[2]); glVertex3fv(vtx+12);
			    glTexCoord2fv(&t[4]); glVertex3fv(vtx+20); 
                glTexCoord2fv(&t[6]); glVertex3fv(vtx+16);
                          case 1:
			    glTexCoord2fv(&t[0]); glVertex3fv(vtx); 
                glTexCoord2fv(&t[2]); glVertex3fv(vtx+4);
			    glTexCoord2fv(&t[4]); glVertex3fv(vtx+12); 
                glTexCoord2fv(&t[6]); glVertex3fv(vtx+8);
			}
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = cPoly * (rate/cPoly);

		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    for(i=(rate)/cPoly; i; i--) {
			glBegin(GL_QUADS);
			switch (cPoly) {
			  case 5:
			    glTexCoord2fv(&t[0]); glVertex3fv(vtx+32); 
                glTexCoord2fv(&t[2]); glVertex3fv(vtx+36);
			    glTexCoord2fv(&t[4]); glVertex3fv(vtx+44); 
                glTexCoord2fv(&t[6]); glVertex3fv(vtx+40);
			  case 4:
			    glTexCoord2fv(&t[0]); glVertex3fv(vtx+24); 
                glTexCoord2fv(&t[2]); glVertex3fv(vtx+28);
			    glTexCoord2fv(&t[4]); glVertex3fv(vtx+36); 
                glTexCoord2fv(&t[6]); glVertex3fv(vtx+32);
			  case 3:
			    glTexCoord2fv(&t[0]); glVertex3fv(vtx+16); 
                glTexCoord2fv(&t[2]); glVertex3fv(vtx+20);
			    glTexCoord2fv(&t[4]); glVertex3fv(vtx+28); 
                glTexCoord2fv(&t[6]); glVertex3fv(vtx+24);
			  case 2:
			    glTexCoord2fv(&t[0]); glVertex3fv(vtx+8); 
                glTexCoord2fv(&t[2]); glVertex3fv(vtx+12);
			    glTexCoord2fv(&t[4]); glVertex3fv(vtx+20); 
                glTexCoord2fv(&t[6]); glVertex3fv(vtx+16);
			  case 1:
			    glTexCoord2fv(&t[0]); glVertex3fv(vtx+0); 
                glTexCoord2fv(&t[2]); glVertex3fv(vtx+4);
			    glTexCoord2fv(&t[4]); glVertex3fv(vtx+12); 
                glTexCoord2fv(&t[6]); glVertex3fv(vtx+8);
			}
			glEnd();
		    }
		  }
		  endtest(pbuf, rate, 0);
		}
		glPopMatrix();
	    }
	    printaverage();
	}
    } else {

	/**** 2D POLYGONS ****/

	if (mod_light && !mod_cmode) {

	/*** POLYGONS (LIGHTED) *****/

	    glLoadIdentity();

	    glMatrixMode(GL_PROJECTION);
	    glLoadIdentity();
	    gluOrtho2D(-0.5*xsize, 0.5*xsize,-0.5*ysize, 0.5*ysize);
	    glMatrixMode(GL_MODELVIEW);

	    /* set lights */
	    setLightingParameters();
    
	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
                if (!mod_average)
		  sprintf(pbuf, "Angle %6.2f", angle);
		  
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    if (mod_lmcolor) {
		        starttest(0);
		        for(i=(rate)/cPoly; i; i--) {
			    glBegin(GL_QUADS);
			    switch (cPoly) {
			      case 5:
			        glColor3fv(&c[4]); glNormal3fv(&n[0]); 
			        glTexCoord2fv(&t[0]); glVertex2fv(vtx+32); 
			        glColor3fv(&c[16]); glNormal3fv(&n[4]); 
			        glTexCoord2fv(&t[2]); glVertex2fv(vtx+36); 
			        glColor3fv(&c[8]); glNormal3fv(&n[8]); 
			        glTexCoord2fv(&t[4]); glVertex2fv(vtx+44); 
			        glColor3fv(&c[8]); glNormal3fv(&n[12]);
			        glTexCoord2fv(&t[6]); glVertex2fv(vtx+40);
			      case 4:
			        glColor3fv(&c[4]); glNormal3fv(&n[0]); 
			        glTexCoord2fv(&t[0]); glVertex2fv(vtx+24); 
			        glColor3fv(&c[16]); glNormal3fv(&n[4]);
			        glTexCoord2fv(&t[2]); glVertex2fv(vtx+28); 
			        glColor3fv(&c[8]); glNormal3fv(&n[8]); 
			        glTexCoord2fv(&t[4]); glVertex2fv(vtx+36); 
			        glColor3fv(&c[8]); glNormal3fv(&n[12]);
			        glTexCoord2fv(&t[6]); glVertex2fv(vtx+32);
			      case 3:
			        glColor3fv(&c[4]); glNormal3fv(&n[0]);
			        glTexCoord2fv(&t[0]); glVertex2fv(vtx+16); 
			        glColor3fv(&c[16]); glNormal3fv(&n[4]);
			        glTexCoord2fv(&t[2]); glVertex2fv(vtx+20); 
			        glColor3fv(&c[8]); glNormal3fv(&n[8]); 
			        glTexCoord2fv(&t[4]); glVertex2fv(vtx+28); 
			        glColor3fv(&c[8]); glNormal3fv(&n[12]);
			        glTexCoord2fv(&t[6]); glVertex2fv(vtx+24);
			      case 2:
			        glColor3fv(&c[4]); glNormal3fv(&n[0]); 
			        glTexCoord2fv(&t[0]); glVertex2fv(vtx+8); 
			        glColor3fv(&c[16]); glNormal3fv(&n[4]);
			        glTexCoord2fv(&t[2]); glVertex2fv(vtx+12); 
			        glColor3fv(&c[8]); glNormal3fv(&n[8]);
			        glTexCoord2fv(&t[4]); glVertex2fv(vtx+20); 
			        glColor3fv(&c[8]); glNormal3fv(&n[12]);
			        glTexCoord2fv(&t[6]); glVertex2fv(vtx+16);
			      case 1:
			        glColor3fv(&c[4]); glNormal3fv(&n[0]);
			        glTexCoord2fv(&t[0]); glVertex2fv(vtx); 
			        glColor3fv(&c[16]); glNormal3fv(&n[4]);
			        glTexCoord2fv(&t[2]); glVertex2fv(vtx+4); 
			        glColor3fv(&c[8]); glNormal3fv(&n[8]);
			        glTexCoord2fv(&t[4]); glVertex2fv(vtx+12); 
			        glColor3fv(&c[8]); glNormal3fv(&n[12]);
			        glTexCoord2fv(&t[6]); glVertex2fv(vtx+8);
			    }
			    glEnd();
		        }
    
		        secs = timer(1);
		    }
		    else {
		        starttest(0);
		        for(i=(rate)/cPoly; i; i--) {
			    glBegin(GL_QUADS);
			    switch (cPoly) {
			      case 5:
                    glTexCoord2fv(&t[0]);
			        glNormal3fv(&n[0]); glVertex2fv(vtx+32); 
                    glTexCoord2fv(&t[2]);
			        glNormal3fv(&n[4]); glVertex2fv(vtx+36); 
                    glTexCoord2fv(&t[4]);
			        glNormal3fv(&n[8]); glVertex2fv(vtx+44); 
                    glTexCoord2fv(&t[6]);
			        glNormal3fv(&n[12]); glVertex2fv(vtx+40);
			      case 4:
                    glTexCoord2fv(&t[0]);
			        glNormal3fv(&n[0]); glVertex2fv(vtx+24); 
                    glTexCoord2fv(&t[2]);
			        glNormal3fv(&n[4]); glVertex2fv(vtx+28); 
                    glTexCoord2fv(&t[4]);
			        glNormal3fv(&n[8]); glVertex2fv(vtx+36); 
                    glTexCoord2fv(&t[6]);
			        glNormal3fv(&n[12]); glVertex2fv(vtx+32);
			      case 3:
                    glTexCoord2fv(&t[0]);
			        glNormal3fv(&n[0]); glVertex2fv(vtx+16); 
                    glTexCoord2fv(&t[2]);
			        glNormal3fv(&n[4]); glVertex2fv(vtx+20); 
                    glTexCoord2fv(&t[4]);
			        glNormal3fv(&n[8]); glVertex2fv(vtx+28); 
                    glTexCoord2fv(&t[6]);
			        glNormal3fv(&n[12]); glVertex2fv(vtx+24);
			      case 2:
                    glTexCoord2fv(&t[0]);
			        glNormal3fv(&n[0]); glVertex2fv(vtx+8); 
                    glTexCoord2fv(&t[2]);
			        glNormal3fv(&n[4]); glVertex2fv(vtx+12); 
                    glTexCoord2fv(&t[4]);
			        glNormal3fv(&n[8]); glVertex2fv(vtx+20); 
                    glTexCoord2fv(&t[6]);
			        glNormal3fv(&n[12]); glVertex2fv(vtx+16);
			      case 1:
                    glTexCoord2fv(&t[0]);
			        glNormal3fv(&n[0]); glVertex2fv(vtx); 
                    glTexCoord2fv(&t[2]);
			        glNormal3fv(&n[4]); glVertex2fv(vtx+4); 
                    glTexCoord2fv(&t[4]);
			        glNormal3fv(&n[8]); glVertex2fv(vtx+12); 
                    glTexCoord2fv(&t[6]);
			        glNormal3fv(&n[12]); glVertex2fv(vtx+8);
			    }
			    glEnd();
		        }
    
		        secs = timer(1);
		    }
		}
		rate = rate * (secspertest/secs);
		rate = cPoly * (rate/cPoly);

		for (k=0; k<loopcount; k++) {
		    if (mod_lmcolor) {
		      if (starttest(k)) {
		        for(i=(rate)/cPoly; i; i--) {
			    glBegin(GL_QUADS);
			    switch (cPoly) {
			      case 5:
			        glColor3fv(&c[4]); glNormal3fv(&n[0]);
			        glTexCoord2fv(&t[0]); glVertex2fv(vtx+32); 
			        glColor3fv(&c[16]); glNormal3fv(&n[4]);
			        glTexCoord2fv(&t[2]); glVertex2fv(vtx+36); 
			        glColor3fv(&c[8]); glNormal3fv(&n[8]);
			        glTexCoord2fv(&t[4]); glVertex2fv(vtx+44); 
			        glColor3fv(&c[8]); glNormal3fv(&n[12]);
			        glTexCoord2fv(&t[6]); glVertex2fv(vtx+40);
			      case 4:
			        glColor3fv(&c[4]); glNormal3fv(&n[0]);
			        glTexCoord2fv(&t[0]); glVertex2fv(vtx+24); 
			        glColor3fv(&c[16]); glNormal3fv(&n[4]);
			        glTexCoord2fv(&t[2]); glVertex2fv(vtx+28); 
			        glColor3fv(&c[8]); glNormal3fv(&n[8]);
			        glTexCoord2fv(&t[4]); glVertex2fv(vtx+36); 
			        glColor3fv(&c[8]); glNormal3fv(&n[12]);
			        glTexCoord2fv(&t[6]); glVertex2fv(vtx+32);
			      case 3:
			        glColor3fv(&c[4]); glNormal3fv(&n[0]);
			        glTexCoord2fv(&t[0]); glVertex2fv(vtx+16); 
			        glColor3fv(&c[16]); glNormal3fv(&n[4]);
			        glTexCoord2fv(&t[2]); glVertex2fv(vtx+20); 
			        glColor3fv(&c[8]); glNormal3fv(&n[8]);
			        glTexCoord2fv(&t[4]); glVertex2fv(vtx+28); 
			        glColor3fv(&c[8]); glNormal3fv(&n[12]);
			        glTexCoord2fv(&t[6]); glVertex2fv(vtx+24);
			      case 2:
			        glColor3fv(&c[4]); glNormal3fv(&n[0]);
			        glTexCoord2fv(&t[0]); glVertex2fv(vtx+8); 
			        glColor3fv(&c[16]); glNormal3fv(&n[4]);
			        glTexCoord2fv(&t[2]); glVertex2fv(vtx+12); 
			        glColor3fv(&c[8]); glNormal3fv(&n[8]);
			        glTexCoord2fv(&t[4]); glVertex2fv(vtx+20); 
			        glColor3fv(&c[8]); glNormal3fv(&n[12]);
			        glTexCoord2fv(&t[6]); glVertex2fv(vtx+16);
			      case 1:
			        glColor3fv(&c[4]); glNormal3fv(&n[0]);
			        glTexCoord2fv(&t[0]); glVertex2fv(vtx); 
			        glColor3fv(&c[16]); glNormal3fv(&n[4]);
			        glTexCoord2fv(&t[2]); glVertex2fv(vtx+4); 
			        glColor3fv(&c[8]); glNormal3fv(&n[8]);
			        glTexCoord2fv(&t[4]); glVertex2fv(vtx+12); 
			        glColor3fv(&c[8]); glNormal3fv(&n[12]);
			        glTexCoord2fv(&t[6]); glVertex2fv(vtx+8);
			    }
			    glEnd();
		        }
		      }
		      endtest(pbuf, rate, 0);
		    }
		    else {
		      if (starttest(k)) {
		        for(i=(rate)/cPoly; i; i--) {
			    glBegin(GL_QUADS);
			    switch (cPoly) {
			      case 5:
                    glTexCoord2fv(&t[0]);
			        glNormal3fv(&n[0]); glVertex2fv(vtx+32); 
                    glTexCoord2fv(&t[2]);
			        glNormal3fv(&n[4]); glVertex2fv(vtx+36); 
                    glTexCoord2fv(&t[4]);
			        glNormal3fv(&n[8]); glVertex2fv(vtx+44); 
                    glTexCoord2fv(&t[6]);
			        glNormal3fv(&n[12]); glVertex2fv(vtx+40);
			      case 4:
                    glTexCoord2fv(&t[0]);
			        glNormal3fv(&n[0]); glVertex2fv(vtx+24); 
                    glTexCoord2fv(&t[2]);
			        glNormal3fv(&n[4]); glVertex2fv(vtx+28); 
                    glTexCoord2fv(&t[4]);
			        glNormal3fv(&n[8]); glVertex2fv(vtx+36); 
                    glTexCoord2fv(&t[6]);
			        glNormal3fv(&n[12]); glVertex2fv(vtx+32);
			      case 3:
                    glTexCoord2fv(&t[0]);
			        glNormal3fv(&n[0]); glVertex2fv(vtx+16); 
                    glTexCoord2fv(&t[2]);
			        glNormal3fv(&n[4]); glVertex2fv(vtx+20); 
                    glTexCoord2fv(&t[4]);
			        glNormal3fv(&n[8]); glVertex2fv(vtx+28); 
                    glTexCoord2fv(&t[6]);
			        glNormal3fv(&n[12]); glVertex2fv(vtx+24);
			      case 2:
                    glTexCoord2fv(&t[0]);
			        glNormal3fv(&n[0]); glVertex2fv(vtx+8); 
                    glTexCoord2fv(&t[2]);
			        glNormal3fv(&n[4]); glVertex2fv(vtx+12); 
                    glTexCoord2fv(&t[4]);
			        glNormal3fv(&n[8]); glVertex2fv(vtx+20); 
                    glTexCoord2fv(&t[6]);
			        glNormal3fv(&n[12]); glVertex2fv(vtx+16);
			      case 1:
                    glTexCoord2fv(&t[0]);
			        glNormal3fv(&n[0]); glVertex2fv(vtx); 
                    glTexCoord2fv(&t[2]);
			        glNormal3fv(&n[4]); glVertex2fv(vtx+4); 
                    glTexCoord2fv(&t[4]);
			        glNormal3fv(&n[8]); glVertex2fv(vtx+12); 
                    glTexCoord2fv(&t[6]);
			        glNormal3fv(&n[12]); glVertex2fv(vtx+8);
			    }
			    glEnd();
		        }
		      }
		      endtest(pbuf, rate, 0);
		    }
		}

		glPopMatrix();
	    }
	    printaverage();
	} else if (mod_shade && !mod_cmode) {

	    /*** POLYGONS (SHADED RGB) *****/

	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
                if (!mod_average)
		  sprintf(pbuf, "Angle %6.2f", angle);
		  
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);
		    for(i=(rate)/cPoly; i; i--) {
			glBegin(GL_QUADS);
			switch (cPoly) {
			  case 5:
                glTexCoord2fv(&t[0]);
			    glColor3fv(&c[4]); glVertex2fv(vtx+32); 
                glTexCoord2fv(&t[2]);
			    glColor3fv(&c[16]); glVertex2fv(vtx+36); 
                glTexCoord2fv(&t[4]);
			    glColor3fv(&c[8]); glVertex2fv(vtx+44); 
                glTexCoord2fv(&t[6]);
			    glColor3fv(&c[8]); glVertex2fv(vtx+40);
			  case 4:
                glTexCoord2fv(&t[0]);
			    glColor3fv(&c[4]); glVertex2fv(vtx+24); 
                glTexCoord2fv(&t[2]);
			    glColor3fv(&c[16]); glVertex2fv(vtx+28); 
                glTexCoord2fv(&t[4]);
			    glColor3fv(&c[8]); glVertex2fv(vtx+36); 
                glTexCoord2fv(&t[6]);
			    glColor3fv(&c[8]); glVertex2fv(vtx+32);
			  case 3:
                glTexCoord2fv(&t[0]);
			    glColor3fv(&c[4]); glVertex2fv(vtx+16); 
                glTexCoord2fv(&t[2]);
			    glColor3fv(&c[16]); glVertex2fv(vtx+20); 
                glTexCoord2fv(&t[4]);
			    glColor3fv(&c[8]); glVertex2fv(vtx+28); 
                glTexCoord2fv(&t[6]);
			    glColor3fv(&c[8]); glVertex2fv(vtx+24);
			  case 2:
                glTexCoord2fv(&t[0]);
			    glColor3fv(&c[4]); glVertex2fv(vtx+8); 
                glTexCoord2fv(&t[2]);
			    glColor3fv(&c[16]); glVertex2fv(vtx+12); 
                glTexCoord2fv(&t[4]);
			    glColor3fv(&c[8]); glVertex2fv(vtx+20); 
                glTexCoord2fv(&t[6]);
			    glColor3fv(&c[8]); glVertex2fv(vtx+16);
			  case 1:
                glTexCoord2fv(&t[0]);
			    glColor3fv(&c[4]); glVertex2fv(vtx); 
                glTexCoord2fv(&t[2]);
			    glColor3fv(&c[16]); glVertex2fv(vtx+4); 
                glTexCoord2fv(&t[4]);
			    glColor3fv(&c[8]); glVertex2fv(vtx+12); 
                glTexCoord2fv(&t[6]);
			    glColor3fv(&c[8]); glVertex2fv(vtx+8);
			}
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = cPoly * (rate/cPoly);

		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    for(i=(rate)/cPoly; i; i--) {
			glBegin(GL_QUADS);
			switch (cPoly) {
			  case 5:
                glTexCoord2fv(&t[0]);
			    glColor3fv(&c[4]); glVertex2fv(vtx+32); 
                glTexCoord2fv(&t[2]);
			    glColor3fv(&c[16]); glVertex2fv(vtx+36); 
                glTexCoord2fv(&t[4]);
			    glColor3fv(&c[8]); glVertex2fv(vtx+44); 
                glTexCoord2fv(&t[6]);
			    glColor3fv(&c[8]); glVertex2fv(vtx+40);
			  case 4:
                glTexCoord2fv(&t[0]);
			    glColor3fv(&c[4]); glVertex2fv(vtx+24); 
                glTexCoord2fv(&t[2]);
			    glColor3fv(&c[16]); glVertex2fv(vtx+28); 
                glTexCoord2fv(&t[4]);
			    glColor3fv(&c[8]); glVertex2fv(vtx+36); 
                glTexCoord2fv(&t[6]);
			    glColor3fv(&c[8]); glVertex2fv(vtx+32);
			  case 3:
                glTexCoord2fv(&t[0]);
			    glColor3fv(&c[4]); glVertex2fv(vtx+16); 
                glTexCoord2fv(&t[2]);
			    glColor3fv(&c[16]); glVertex2fv(vtx+20); 
                glTexCoord2fv(&t[4]);
			    glColor3fv(&c[8]); glVertex2fv(vtx+28); 
                glTexCoord2fv(&t[6]);
			    glColor3fv(&c[8]); glVertex2fv(vtx+24);
			  case 2:
                glTexCoord2fv(&t[0]);
			    glColor3fv(&c[4]); glVertex2fv(vtx+8); 
                glTexCoord2fv(&t[2]);
			    glColor3fv(&c[16]); glVertex2fv(vtx+12); 
                glTexCoord2fv(&t[4]);
			    glColor3fv(&c[8]); glVertex2fv(vtx+20); 
                glTexCoord2fv(&t[6]);
			    glColor3fv(&c[8]); glVertex2fv(vtx+16);
			  case 1:
                glTexCoord2fv(&t[0]);
			    glColor3fv(&c[4]); glVertex2fv(vtx); 
                glTexCoord2fv(&t[2]);
			    glColor3fv(&c[16]); glVertex2fv(vtx+4); 
                glTexCoord2fv(&t[4]);
			    glColor3fv(&c[8]); glVertex2fv(vtx+12); 
                glTexCoord2fv(&t[6]);
			    glColor3fv(&c[8]); glVertex2fv(vtx+8);
			}
			glEnd();
		    }
		  }
		  endtest(pbuf, rate, 0);
		}

		glPopMatrix();
	    }
	    printaverage();
	} else if (mod_shade && mod_cmode) {

	    /*** POLYGONS (SHADED COLOR MAPPED) *****/

	    /* 255 = r, 240 = g, 255 = b */
	    makeramp(208, 255, 0, 0, 0, 0, 255, 16);
	    makeramp(224, 0, 0, 255, 255, 255, 0, 16);
	    makeramp(240, 255, 255, 0, 255, 0, 255, 16);

	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
                if (!mod_average)
		  sprintf(pbuf, "Angle %6.2f", angle);
		  
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);
		    for(i=(rate)/cPoly; i; i--) {
			glBegin(GL_QUADS);
			switch (cPoly) {
			  case 5:
                glTexCoord2fv(&t[0]);
			    glIndexi(255); glVertex2fv(vtx+32); 
                glTexCoord2fv(&t[2]);
			    glIndexi(240); glVertex2fv(vtx+36); 
                glTexCoord2fv(&t[4]);
			    glIndexi(223); glVertex2fv(vtx+44); 
                glTexCoord2fv(&t[6]);
			    glIndexi(208); glVertex2fv(vtx+40);
			  case 4:
                glTexCoord2fv(&t[0]);
			    glIndexi(255); glVertex2fv(vtx+24); 
                glTexCoord2fv(&t[2]);
			    glIndexi(240); glVertex2fv(vtx+28); 
                glTexCoord2fv(&t[4]);
			    glIndexi(223); glVertex2fv(vtx+36); 
                glTexCoord2fv(&t[6]);
			    glIndexi(208); glVertex2fv(vtx+32);
			  case 3:
                glTexCoord2fv(&t[0]);
			    glIndexi(255); glVertex2fv(vtx+16); 
                glTexCoord2fv(&t[2]);
			    glIndexi(240); glVertex2fv(vtx+20); 
                glTexCoord2fv(&t[4]);
			    glIndexi(223); glVertex2fv(vtx+28); 
                glTexCoord2fv(&t[6]);
			    glIndexi(208); glVertex2fv(vtx+24);
			  case 2:
                glTexCoord2fv(&t[0]);
			    glIndexi(255); glVertex2fv(vtx+8); 
                glTexCoord2fv(&t[2]);
			    glIndexi(240); glVertex2fv(vtx+12); 
                glTexCoord2fv(&t[4]);
			    glIndexi(223); glVertex2fv(vtx+20); 
                glTexCoord2fv(&t[6]);
			    glIndexi(208); glVertex2fv(vtx+16);
			  case 1:
                glTexCoord2fv(&t[0]);
			    glIndexi(255); glVertex2fv(vtx); 
                glTexCoord2fv(&t[2]);
			    glIndexi(240); glVertex2fv(vtx+4); 
                glTexCoord2fv(&t[4]);
			    glIndexi(223); glVertex2fv(vtx+12); 
                glTexCoord2fv(&t[6]);
			    glIndexi(208); glVertex2fv(vtx+8);
			}
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = cPoly * (rate/cPoly);

		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    for(i=(rate)/cPoly; i; i--) {
			glBegin(GL_QUADS);
			switch (cPoly) {
			  case 5:
                glTexCoord2fv(&t[0]);
			    glIndexi(255); glVertex2fv(vtx+32); 
                glTexCoord2fv(&t[2]);
			    glIndexi(240); glVertex2fv(vtx+36); 
                glTexCoord2fv(&t[4]);
			    glIndexi(223); glVertex2fv(vtx+44); 
                glTexCoord2fv(&t[6]);
			    glIndexi(208); glVertex2fv(vtx+40);
			  case 4:
                glTexCoord2fv(&t[0]);
			    glIndexi(255); glVertex2fv(vtx+24); 
                glTexCoord2fv(&t[2]);
			    glIndexi(240); glVertex2fv(vtx+28); 
                glTexCoord2fv(&t[4]);
			    glIndexi(223); glVertex2fv(vtx+36); 
                glTexCoord2fv(&t[6]);
			    glIndexi(208); glVertex2fv(vtx+32);
			  case 3:
                glTexCoord2fv(&t[0]);
			    glIndexi(255); glVertex2fv(vtx+16); 
                glTexCoord2fv(&t[2]);
			    glIndexi(240); glVertex2fv(vtx+20); 
                glTexCoord2fv(&t[4]);
			    glIndexi(223); glVertex2fv(vtx+28); 
                glTexCoord2fv(&t[6]);
			    glIndexi(208); glVertex2fv(vtx+24);
			  case 2:
                glTexCoord2fv(&t[0]);
			    glIndexi(255); glVertex2fv(vtx+8); 
                glTexCoord2fv(&t[2]);
			    glIndexi(240); glVertex2fv(vtx+12); 
                glTexCoord2fv(&t[4]);
			    glIndexi(223); glVertex2fv(vtx+20); 
                glTexCoord2fv(&t[6]);
			    glIndexi(208); glVertex2fv(vtx+16);
			  case 1:
                glTexCoord2fv(&t[0]);
			    glIndexi(255); glVertex2fv(vtx); 
                glTexCoord2fv(&t[2]);
			    glIndexi(240); glVertex2fv(vtx+4); 
                glTexCoord2fv(&t[4]);
			    glIndexi(223); glVertex2fv(vtx+12); 
                glTexCoord2fv(&t[6]);
			    glIndexi(208); glVertex2fv(vtx+8);
			}
			glEnd();
		    }
		  }
		  endtest(pbuf, rate, 0);
		}

		glPopMatrix();
	    }
	    printaverage();

	} else if (!mod_light && !mod_shade) {

	    /*** POLYGONS (FLAT SHADED) *****/

	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
                if (!mod_average)
		  sprintf(pbuf, "Angle %6.2f", angle);
		  
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);
		    for(i=(rate)/cPoly; i; i--) {
			glBegin(GL_QUADS);
			switch (cPoly) {
			  case 5:
			    glTexCoord2fv(&t[0]); glVertex2fv(vtx+32); 
                glTexCoord2fv(&t[2]); glVertex2fv(vtx+36);
			    glTexCoord2fv(&t[4]); glVertex2fv(vtx+44); 
                glTexCoord2fv(&t[6]); glVertex2fv(vtx+40);
			  case 4:
			    glTexCoord2fv(&t[0]); glVertex2fv(vtx+24); 
                glTexCoord2fv(&t[2]); glVertex2fv(vtx+28);
			    glTexCoord2fv(&t[4]); glVertex2fv(vtx+36); 
                glTexCoord2fv(&t[6]); glVertex2fv(vtx+32);
			  case 3:
			    glTexCoord2fv(&t[0]); glVertex2fv(vtx+16); 
                glTexCoord2fv(&t[2]); glVertex2fv(vtx+20);
			    glTexCoord2fv(&t[4]); glVertex2fv(vtx+28); 
                glTexCoord2fv(&t[6]); glVertex2fv(vtx+24);
			  case 2:
			    glTexCoord2fv(&t[0]); glVertex2fv(vtx+8); 
                glTexCoord2fv(&t[2]); glVertex2fv(vtx+12);
			    glTexCoord2fv(&t[4]); glVertex2fv(vtx+20); 
                glTexCoord2fv(&t[6]); glVertex2fv(vtx+16);
			  case 1:
			    glTexCoord2fv(&t[0]); glVertex2fv(vtx); 
                glTexCoord2fv(&t[2]); glVertex2fv(vtx+4);
			    glTexCoord2fv(&t[4]); glVertex2fv(vtx+12); 
                glTexCoord2fv(&t[6]); glVertex2fv(vtx+8);
			}
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = cPoly * (rate/cPoly);

		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    for(i=(rate)/cPoly; i; i--) {
			glBegin(GL_QUADS);
			switch (cPoly) {
			  case 5:
			    glTexCoord2fv(&t[0]); glVertex2fv(vtx+32); 
                glTexCoord2fv(&t[2]); glVertex2fv(vtx+36);
			    glTexCoord2fv(&t[4]); glVertex2fv(vtx+44); 
                glTexCoord2fv(&t[6]); glVertex2fv(vtx+40);
			  case 4:
			    glTexCoord2fv(&t[0]); glVertex2fv(vtx+24); 
                glTexCoord2fv(&t[2]); glVertex2fv(vtx+28);
			    glTexCoord2fv(&t[4]); glVertex2fv(vtx+36); 
                glTexCoord2fv(&t[6]); glVertex2fv(vtx+32);
			  case 3:
			    glTexCoord2fv(&t[0]); glVertex2fv(vtx+16); 
                glTexCoord2fv(&t[2]); glVertex2fv(vtx+20);
			    glTexCoord2fv(&t[4]); glVertex2fv(vtx+28); 
                glTexCoord2fv(&t[6]); glVertex2fv(vtx+24);
			  case 2:
			    glTexCoord2fv(&t[0]); glVertex2fv(vtx+8); 
                glTexCoord2fv(&t[2]); glVertex2fv(vtx+12);
			    glTexCoord2fv(&t[4]); glVertex2fv(vtx+20); 
                glTexCoord2fv(&t[6]); glVertex2fv(vtx+16);
			  case 1:
			    glTexCoord2fv(&t[0]); glVertex2fv(vtx); 
                glTexCoord2fv(&t[2]); glVertex2fv(vtx+4);
			    glTexCoord2fv(&t[4]); glVertex2fv(vtx+12); 
                glTexCoord2fv(&t[6]); glVertex2fv(vtx+8);
			}
			glEnd();
		    }
		  }
		  endtest(pbuf, rate, 0);
		}

		glPopMatrix();
	    }
	    printaverage();
	}

    }
    if (mod_doublebuffer) {
        auxSwapBuffers();
        Sleep(2000);               /* for visual feedback */
    }
    exit(0);
}


static void perftmeshtex(void)
{
    int i,j,k, tin;
    float *vtx = &v[0];
    char pbuf[256];
    int cVert = 60;


    if (mod_texfile) MyLoadImage();
    else CreateImage();

    InitTexParams();

    /* Triangle mesh tests:  Each tmesh contains 62 vertices, or	*/
    /* 60 triangles.  To make the calculation exact, the rate	*/
    /* must be a multiple of 60.					*/

    if (mod_backface){
        glEnable(GL_CULL_FACE);
        glCullFace(GL_FRONT);
    }

    if (mod_bigger) {
        vtx = &mv[0];
        printf("bigger in tmesh\n");
    }

    /* If the triangle size is specified, set the size of the triangle mesh to
    ** fit the window.  The number of vertices must be a multiple of four (due
    ** to code below), and it must not exceed 60.
    */
    if (mod_size) {
        cVert = (int) (MINDIMENSION*2 / prim_size) - 2;
        if (cVert & 1) cVert++;
        cVert &= ~3;
        if (cVert < 4) cVert = 4;
        if (cVert > 60) cVert = 60;
    }
    
    for(i=0; i<NVERT; i++) {
        vtx[i*4+1] -= ((cVert+2)/4.0 * prim_size);
    }

    if (!mod_2d) {
        if (mod_cmode && mod_shade) {

            /*** GOURAUD SHADED CMODE TMESH ***/
            /* 255 = r, 240 = g, 255 = b */
            makeramp(208,255,0,0,0,0,255,16);
            makeramp(224,0,0,255,255,255,0,16);
            makeramp(240,255,255,0,255,0,255,16);

            sum_secs = 0.0;
            sum_n = 0;
            for (angle = 2.0; angle < 360.0; angle += 22.5) {
                if (!mod_average)
		  sprintf(pbuf, "Angle %6.2f", angle);
		  
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);
		    for(i=(rate)/cVert; i; i--) {
			glBegin(GL_TRIANGLE_STRIP);
			for (j=0, tin=-2; j<cVert; j+=4, tin=-2) {
                glIndexi(255); glTexCoord2fv (&t[tin+=2]);
			    glVertex3fv(&vtx[j*4]);
			    glIndexi(240); glTexCoord2fv (&t[tin+=2]);
			    glVertex3fv(&vtx[(j+1)*4]);
			    glIndexi(223); glTexCoord2fv (&t[tin+=2]);
			    glVertex3fv(&vtx[(j+2)*4]);
			    glIndexi(208); glTexCoord2fv (&t[tin+=2]);
			    glVertex3fv(&vtx[(j+3)*4]);
			}
			glIndexi(255); glTexCoord2fv (&t[tin+=2]);
			glVertex3fv(&vtx[j*4]);
			glIndexi(240); glTexCoord2fv (&t[tin+=2]);
			glVertex3fv(&vtx[(j+1)*4]);
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = cVert * (rate/cVert);

		/* Do the real thing GOURAUD shaded Cmode tmesh */
		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    for(i=(rate)/cVert; i; i--) {
			glBegin(GL_TRIANGLE_STRIP);
			for (j=0, tin=-2; j<cVert; j+=4, tin=-2) {
			    glIndexi(255); glTexCoord2fv (&t[tin+=2]);
			    glVertex3fv(&vtx[j*4]);
			    glIndexi(240); glTexCoord2fv (&t[tin+=2]);
			    glVertex3fv(&vtx[(j+1)*4]);
			    glIndexi(223); glTexCoord2fv (&t[tin+=2]);
			    glVertex3fv(&vtx[(j+2)*4]);
			    glIndexi(208); glTexCoord2fv (&t[tin+=2]);
			    glVertex3fv(&vtx[(j+3)*4]);
			}
			glIndexi(255); glTexCoord2fv (&t[tin+=2]);
			glVertex3fv(&vtx[j*4]);
			glIndexi(240); glTexCoord2fv (&t[tin+=2]);
			glVertex3fv(&vtx[(j+1)*4]);
			glEnd();
		    }
		  }
		  endtest(pbuf, rate, 0);
		}

		glPopMatrix();
	    }
	    printaverage();

	} else if (!mod_light && !mod_shade) {

	    /*** FLAT SHADED TMESH ***/
	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
                if (!mod_average)
		  sprintf(pbuf, "Angle %6.2f", angle);
		  
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;

		    starttest(0);

		    for(i=(rate)/cVert; i; i--) {
			glBegin(GL_TRIANGLE_STRIP);
			for (j=0, tin=0; j<cVert+2; j++, tin= (tin+2)%8) {
                glTexCoord2fv(&t[tin]);
			    glVertex3fv(&vtx[j*4]);
			}
			glEnd();
		    }

		    secs = timer(1);

		}
		rate = rate * (secspertest/secs);
		rate = cVert * (rate/cVert);
	    
		/* Do the real thing - FLAT shaded tmesh */
		for (k=0; k<loopcount; k++) {

		  if (starttest(k)) {

		    for(i=(rate)/cVert; i; i--) {
			glBegin(GL_TRIANGLE_STRIP);
			for (j=0, tin=0; j<cVert+2; j++, tin=(tin+2)%8) {
                glTexCoord2fv(&t[tin]);
			    glVertex3fv(&vtx[j*4]);
			}
			glEnd();
		    }
		  }
		  endtest(pbuf, rate, 0);
		}
		glPopMatrix();
	    }
	    printaverage();

	} else if (!mod_cmode && mod_light) {
	    /*** LIGHTED RGB MESH ***/

	    glLoadIdentity();

	    glMatrixMode(GL_PROJECTION);
	    glLoadIdentity();
	    glOrtho(-0.5*xsize,0.5*xsize,-0.5*ysize,0.5*ysize,1.0,-1.0);

	    glMatrixMode(GL_MODELVIEW);

	    /* set lights */
	    setLightingParameters();

	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
                if (!mod_average)
		  sprintf (pbuf, "Angle %6.2f", angle);
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    if (mod_lmcolor) {
		        starttest(0);
		        for(i=(rate)/cVert; i; i--) {
			    glBegin(GL_TRIANGLE_STRIP);
			    for (j=0, tin=-2; j<cVert; j+=4, tin=-2) {
				glColor3fv(&c[16]);
                glTexCoord2fv(&t[tin+=2]);
			        glNormal3fv(&n[0]);
			        glVertex3fv(&vtx[j*4]);
				glColor3fv(&c[20]);
                glTexCoord2fv(&t[tin+=2]);
			        glNormal3fv(&n[4]);
			        glVertex3fv(&vtx[(j+1)*4]);
				glColor3fv(&c[4]);
                glTexCoord2fv(&t[tin+=2]);
			        glNormal3fv(&n[8]);
			        glVertex3fv(&vtx[(j+2)*4]);
				glColor3fv(&c[8]);
                glTexCoord2fv(&t[tin+=2]);
			        glNormal3fv(&n[12]);
			        glVertex3fv(&vtx[(j+3)*4]);
			    }
			    glColor3fv(&c[16]);
                glTexCoord2fv(&t[tin+=2]);
			    glNormal3fv(&n[0]);
			    glVertex3fv(&vtx[j*4]);
			    glColor3fv(&c[20]);
                glTexCoord2fv(&t[tin+=2]);
			    glNormal3fv(&n[4]);
			    glVertex3fv(&vtx[(j+1)*4]);
			    glEnd();
		        }
    
		        secs = timer(1);
		    }
		    else {
		        starttest(0);  
		        for(i=(rate)/cVert; i; i--) {
			    glBegin(GL_TRIANGLE_STRIP);
			    for (j=0, tin=-2; j<cVert; j+=4, tin=-2) {
			        glNormal3fv(&n[0]);
                    glTexCoord2fv(&t[tin+=2]);
			        glVertex3fv(&vtx[j*4]);
			        glNormal3fv(&n[4]);
                    glTexCoord2fv(&t[tin+=2]);
			        glVertex3fv(&vtx[(j+1)*4]);
			        glNormal3fv(&n[8]);
                    glTexCoord2fv(&t[tin+=2]);
			        glVertex3fv(&vtx[(j+2)*4]);
			        glNormal3fv(&n[12]);
                    glTexCoord2fv(&t[tin+=2]);
			        glVertex3fv(&vtx[(j+3)*4]);
			    }
			    glNormal3fv(&n[0]);
                glTexCoord2fv(&t[tin+=2]);
			    glVertex3fv(&vtx[j*4]);
			    glNormal3fv(&n[4]);
                glTexCoord2fv(&t[tin+=2]);
			    glVertex3fv(&vtx[(j+1)*4]);
			    glEnd();
		        }
    
		        secs = timer(1);
		    }
		}
		rate = rate * (secspertest/secs);
		rate = cVert * (rate/cVert);

		for (k=0; k<loopcount; k++) {
		    if (mod_lmcolor) {
		      if (starttest(k)) {
		        for(i=(rate)/cVert; i; i--) {
			    glBegin(GL_TRIANGLE_STRIP);
			    for (j=0, tin=-2; j<cVert; j+=4, tin=-2) {
				glColor3fv(&c[16]);
                glTexCoord2fv(&t[tin+=2]);
			        glNormal3fv(&n[0]);
			        glVertex3fv(&vtx[j*4]);
				glColor3fv(&c[20]);
                glTexCoord2fv(&t[tin+=2]);
			        glNormal3fv(&n[4]);
			        glVertex3fv(&vtx[(j+1)*4]);
				glColor3fv(&c[4]);
                glTexCoord2fv(&t[tin+=2]);
			        glNormal3fv(&n[8]);
			        glVertex3fv(&vtx[(j+2)*4]);
				glColor3fv(&c[8]);
                glTexCoord2fv(&t[tin+=2]);
			        glNormal3fv(&n[12]);
			        glVertex3fv(&vtx[(j+3)*4]);
			    }
			    glColor3fv(&c[16]);
                glTexCoord2fv(&t[tin+=2]);
			    glNormal3fv(&n[0]);
			    glVertex3fv(&vtx[j*4]);
			    glColor3fv(&c[20]);
                glTexCoord2fv(&t[tin+=2]);
			    glNormal3fv(&n[4]);
			    glVertex3fv(&vtx[(j+1)*4]);
			    glEnd();
		        }
		      }
		      endtest(pbuf, rate, 0);
		    }
		    else {
		      if (starttest(k)) {
		        for(i=(rate)/cVert; i; i--) {
			    glBegin(GL_TRIANGLE_STRIP);
			    for (j=0, tin=-2; j<cVert; j+=4, tin=-2) {
                glTexCoord2fv(&t[tin+=2]);
			        glNormal3fv(&n[0]);
			        glVertex3fv(&vtx[j*4]);
                glTexCoord2fv(&t[tin+=2]);
			        glNormal3fv(&n[4]);
			        glVertex3fv(&vtx[(j+1)*4]);
                glTexCoord2fv(&t[tin+=2]);
			        glNormal3fv(&n[8]);
			        glVertex3fv(&vtx[(j+2)*4]);
                glTexCoord2fv(&t[tin+=2]);
			        glNormal3fv(&n[12]);
			        glVertex3fv(&vtx[(j+3)*4]);
			    }
                glTexCoord2fv(&t[tin+=2]);
			    glNormal3fv(&n[0]);
			    glVertex3fv(&vtx[j*4]);
                glTexCoord2fv(&t[tin+=2]);
			    glNormal3fv(&n[4]);
			    glVertex3fv(&vtx[(j+1)*4]);
			    glEnd();
		        }
		      }
		      endtest(pbuf, rate, 0);
		    }
		}
		glPopMatrix();
	    }
	    printaverage();

	} else if (!mod_cmode && mod_shade) {

	    /*** GOURAUD SHADED RGB TMESH ***/
	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
                if (!mod_average)
		  sprintf(pbuf, "Angle %6.2f", angle);
		  
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);
		    for(i=(rate)/cVert; i; i--) {
			glBegin(GL_TRIANGLE_STRIP);
			for (j=0, tin=-2; j<cVert; j+=4, tin=-2) {
			    glColor3fv(&c[4]);
                glTexCoord2fv(&t[tin+=2]);
			    glVertex3fv(&vtx[j*4]);
			    glColor3fv(&c[8]);
                glTexCoord2fv(&t[tin+=2]);
			    glVertex3fv(&vtx[(j+1)*4]);
			    glColor3fv(&c[12]);
                glTexCoord2fv(&t[tin+=2]);
			    glVertex3fv(&vtx[(j+2)*4]);
			    glColor3fv(&c[16]);
                glTexCoord2fv(&t[tin+=2]);
			    glVertex3fv(&vtx[(j+3)*4]);
			}
			glColor3fv(&c[4]);
            glTexCoord2fv(&t[tin+=2]);
			glVertex3fv(&vtx[j*4]);
			glColor3fv(&c[8]);
            glTexCoord2fv(&t[tin+=2]);
			glVertex3fv(&vtx[(j+1)*4]);
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = cVert * (rate/cVert);

		/* Do the real thing GOURAUD shaded tmesh */
		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    for(i=(rate)/cVert; i; i--) {
			glBegin(GL_TRIANGLE_STRIP);
			for (j=0, tin=-2; j<cVert; j+=4, tin=-2) {
			    glColor3fv(&c[4]);
                glTexCoord2fv(&t[tin+=2]);
			    glVertex3fv(&vtx[j*4]);
			    glColor3fv(&c[8]);
                glTexCoord2fv(&t[tin+=2]);
			    glVertex3fv(&vtx[(j+1)*4]);
			    glColor3fv(&c[12]);
                glTexCoord2fv(&t[tin+=2]);
			    glVertex3fv(&vtx[(j+2)*4]);
			    glColor3fv(&c[16]);
                glTexCoord2fv(&t[tin+=2]);
			    glVertex3fv(&vtx[(j+3)*4]);
			}
			glColor3fv(&c[4]);
            glTexCoord2fv(&t[tin+=2]);
			glVertex3fv(&vtx[j*4]);
			glColor3fv(&c[8]);
            glTexCoord2fv(&t[tin+=2]);
			glVertex3fv(&vtx[(j+1)*4]);
			glEnd();
		    }
		  }
		  endtest(pbuf, rate, 0);
		}

		glPopMatrix();
	    }
	    printaverage();
	}

    } else {	/* must be 2d */
        if (mod_cmode && mod_shade) {

            /*** GOURAUD SHADED CMODE TMESH ***/
            /* 255 = r, 240 = g, 255 = b */
            makeramp(208,255,0,0,0,0,255,16);
            makeramp(224,0,0,255,255,255,0,16);
            makeramp(240,255,255,0,255,0,255,16);

            sum_secs = 0.0;
            sum_n = 0;
            for (angle = 2.0; angle < 360.0; angle += 22.5) {
                if (!mod_average)
		  sprintf(pbuf, "Angle %6.2f", angle);
		  
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);
		    for(i=(rate)/cVert; i; i--) {
			glBegin(GL_TRIANGLE_STRIP);
			for (j=0, tin=-2; j<cVert; j+=4, tin=-2) {
                glIndexi(255); glTexCoord2fv (&t[tin+=2]);
			    glVertex2fv(&vtx[j*4]);
			    glIndexi(240); glTexCoord2fv (&t[tin+=2]);
			    glVertex2fv(&vtx[(j+1)*4]);
			    glIndexi(223); glTexCoord2fv (&t[tin+=2]);
			    glVertex2fv(&vtx[(j+2)*4]);
			    glIndexi(208); glTexCoord2fv (&t[tin+=2]);
			    glVertex2fv(&vtx[(j+3)*4]);
			}
			glIndexi(255); glTexCoord2fv (&t[tin+=2]);
			glVertex2fv(&vtx[j*4]);
			glIndexi(240); glTexCoord2fv (&t[tin+=2]);
			glVertex2fv(&vtx[(j+1)*4]);
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = cVert * (rate/cVert);

		/* Do the real thing GOURAUD shaded Cmode tmesh */
		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    for(i=(rate)/cVert; i; i--) {
			glBegin(GL_TRIANGLE_STRIP);
			for (j=0, tin=-2; j<cVert; j+=4, tin=-2) {
			    glIndexi(255); glTexCoord2fv (&t[tin+=2]);
			    glVertex2fv(&vtx[j*4]);
			    glIndexi(240); glTexCoord2fv (&t[tin+=2]);
			    glVertex2fv(&vtx[(j+1)*4]);
			    glIndexi(223); glTexCoord2fv (&t[tin+=2]);
			    glVertex2fv(&vtx[(j+2)*4]);
			    glIndexi(208); glTexCoord2fv (&t[tin+=2]);
			    glVertex2fv(&vtx[(j+3)*4]);
			}
			glIndexi(255); glTexCoord2fv (&t[tin+=2]);
			glVertex2fv(&vtx[j*4]);
			glIndexi(240); glTexCoord2fv (&t[tin+=2]);
			glVertex2fv(&vtx[(j+1)*4]);
			glEnd();
		    }
		  }
		  endtest(pbuf, rate, 0);
		}

		glPopMatrix();
	    }
	    printaverage();

	} else if (!mod_light && !mod_shade) {

	    /*** FLAT SHADED TMESH ***/
	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
                if (!mod_average)
		  sprintf(pbuf, "Angle %6.2f", angle);
		  
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;

		    starttest(0);

		    for(i=(rate)/cVert; i; i--) {
			glBegin(GL_TRIANGLE_STRIP);
			for (j=0, tin=0; j<cVert+2; j++, tin= (tin+2)%8) {
                glTexCoord2fv(&t[tin]);
			    glVertex2fv(&vtx[j*4]);
			}
			glEnd();
		    }

		    secs = timer(1);

		}
		rate = rate * (secspertest/secs);
		rate = cVert * (rate/cVert);
	    
		/* Do the real thing - FLAT shaded tmesh */
		for (k=0; k<loopcount; k++) {

		  if (starttest(k)) {

		    for(i=(rate)/cVert; i; i--) {
			glBegin(GL_TRIANGLE_STRIP);
			for (j=0, tin=0; j<cVert+2; j++, tin=(tin+2)%8) {
                glTexCoord2fv(&t[tin]);
			    glVertex2fv(&vtx[j*4]);
			}
			glEnd();
		    }
		  }
		  endtest(pbuf, rate, 0);
		}
		glPopMatrix();
	    }
	    printaverage();

	} else if (!mod_cmode && mod_light) {
	    /*** LIGHTED RGB MESH ***/

	    glLoadIdentity();

	    glMatrixMode(GL_PROJECTION);
	    glLoadIdentity();
	    glOrtho(-0.5*xsize,0.5*xsize,-0.5*ysize,0.5*ysize,1.0,-1.0);

	    glMatrixMode(GL_MODELVIEW);

	    /* set lights */
	    setLightingParameters();

	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
                if (!mod_average)
		  sprintf (pbuf, "Angle %6.2f", angle);
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    if (mod_lmcolor) {
		        starttest(0);
		        for(i=(rate)/cVert; i; i--) {
			    glBegin(GL_TRIANGLE_STRIP);
			    for (j=0, tin=-2; j<cVert; j+=4, tin=-2) {
				glColor3fv(&c[16]);
                glTexCoord2fv(&t[tin+=2]);
			        glNormal3fv(&n[0]);
			        glVertex2fv(&vtx[j*4]);
				glColor3fv(&c[20]);
                glTexCoord2fv(&t[tin+=2]);
			        glNormal3fv(&n[4]);
			        glVertex2fv(&vtx[(j+1)*4]);
				glColor3fv(&c[4]);
                glTexCoord2fv(&t[tin+=2]);
			        glNormal3fv(&n[8]);
			        glVertex2fv(&vtx[(j+2)*4]);
				glColor3fv(&c[8]);
                glTexCoord2fv(&t[tin+=2]);
			        glNormal3fv(&n[12]);
			        glVertex2fv(&vtx[(j+3)*4]);
			    }
			    glColor3fv(&c[16]);
                glTexCoord2fv(&t[tin+=2]);
			    glNormal3fv(&n[0]);
			    glVertex2fv(&vtx[j*4]);
			    glColor3fv(&c[20]);
                glTexCoord2fv(&t[tin+=2]);
			    glNormal3fv(&n[4]);
			    glVertex2fv(&vtx[(j+1)*4]);
			    glEnd();
		        }
    
		        secs = timer(1);
		    }
		    else {
		        starttest(0);  
		        for(i=(rate)/cVert; i; i--) {
			    glBegin(GL_TRIANGLE_STRIP);
			    for (j=0, tin=-2; j<cVert; j+=4, tin=-2) {
			        glNormal3fv(&n[0]);
                    glTexCoord2fv(&t[tin+=2]);
			        glVertex2fv(&vtx[j*4]);
			        glNormal3fv(&n[4]);
                    glTexCoord2fv(&t[tin+=2]);
			        glVertex2fv(&vtx[(j+1)*4]);
			        glNormal3fv(&n[8]);
                    glTexCoord2fv(&t[tin+=2]);
			        glVertex2fv(&vtx[(j+2)*4]);
			        glNormal3fv(&n[12]);
                    glTexCoord2fv(&t[tin+=2]);
			        glVertex2fv(&vtx[(j+3)*4]);
			    }
			    glNormal3fv(&n[0]);
                glTexCoord2fv(&t[tin+=2]);
			    glVertex2fv(&vtx[j*4]);
			    glNormal3fv(&n[4]);
                glTexCoord2fv(&t[tin+=2]);
			    glVertex2fv(&vtx[(j+1)*4]);
			    glEnd();
		        }
    
		        secs = timer(1);
		    }
		}
		rate = rate * (secspertest/secs);
		rate = cVert * (rate/cVert);

		for (k=0; k<loopcount; k++) {
		    if (mod_lmcolor) {
		      if (starttest(k)) {
		        for(i=(rate)/cVert; i; i--) {
			    glBegin(GL_TRIANGLE_STRIP);
			    for (j=0, tin=-2; j<cVert; j+=4, tin=-2) {
				glColor3fv(&c[16]);
                glTexCoord2fv(&t[tin+=2]);
			        glNormal3fv(&n[0]);
			        glVertex2fv(&vtx[j*4]);
				glColor3fv(&c[20]);
                glTexCoord2fv(&t[tin+=2]);
			        glNormal3fv(&n[4]);
			        glVertex2fv(&vtx[(j+1)*4]);
				glColor3fv(&c[4]);
                glTexCoord2fv(&t[tin+=2]);
			        glNormal3fv(&n[8]);
			        glVertex2fv(&vtx[(j+2)*4]);
				glColor3fv(&c[8]);
                glTexCoord2fv(&t[tin+=2]);
			        glNormal3fv(&n[12]);
			        glVertex2fv(&vtx[(j+3)*4]);
			    }
			    glColor3fv(&c[16]);
                glTexCoord2fv(&t[tin+=2]);
			    glNormal3fv(&n[0]);
			    glVertex2fv(&vtx[j*4]);
			    glColor3fv(&c[20]);
                glTexCoord2fv(&t[tin+=2]);
			    glNormal3fv(&n[4]);
			    glVertex2fv(&vtx[(j+1)*4]);
			    glEnd();
		        }
		      }
		      endtest(pbuf, rate, 0);
		    }
		    else {
		      if (starttest(k)) {
		        for(i=(rate)/cVert; i; i--) {
			    glBegin(GL_TRIANGLE_STRIP);
			    for (j=0, tin=-2; j<cVert; j+=4, tin=-2) {
                glTexCoord2fv(&t[tin+=2]);
			        glNormal3fv(&n[0]);
			        glVertex2fv(&vtx[j*4]);
                glTexCoord2fv(&t[tin+=2]);
			        glNormal3fv(&n[4]);
			        glVertex2fv(&vtx[(j+1)*4]);
                glTexCoord2fv(&t[tin+=2]);
			        glNormal3fv(&n[8]);
			        glVertex2fv(&vtx[(j+2)*4]);
                glTexCoord2fv(&t[tin+=2]);
			        glNormal3fv(&n[12]);
			        glVertex2fv(&vtx[(j+3)*4]);
			    }
                glTexCoord2fv(&t[tin+=2]);
			    glNormal3fv(&n[0]);
			    glVertex2fv(&vtx[j*4]);
                glTexCoord2fv(&t[tin+=2]);
			    glNormal3fv(&n[4]);
			    glVertex2fv(&vtx[(j+1)*4]);
			    glEnd();
		        }
		      }
		      endtest(pbuf, rate, 0);
		    }
		}
		glPopMatrix();
	    }
	    printaverage();

	} else if (!mod_cmode && mod_shade) {

	    /*** GOURAUD SHADED RGB TMESH ***/
	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
                if (!mod_average)
		  sprintf(pbuf, "Angle %6.2f", angle);
		  
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);
		    for(i=(rate)/cVert; i; i--) {
			glBegin(GL_TRIANGLE_STRIP);
			for (j=0, tin=-2; j<cVert; j+=4, tin=-2) {
			    glColor3fv(&c[4]);
                glTexCoord2fv(&t[tin+=2]);
			    glVertex2fv(&vtx[j*4]);
			    glColor3fv(&c[8]);
                glTexCoord2fv(&t[tin+=2]);
			    glVertex2fv(&vtx[(j+1)*4]);
			    glColor3fv(&c[12]);
                glTexCoord2fv(&t[tin+=2]);
			    glVertex2fv(&vtx[(j+2)*4]);
			    glColor3fv(&c[16]);
                glTexCoord2fv(&t[tin+=2]);
			    glVertex2fv(&vtx[(j+3)*4]);
			}
			glColor3fv(&c[4]);
            glTexCoord2fv(&t[tin+=2]);
			glVertex2fv(&vtx[j*4]);
			glColor3fv(&c[8]);
            glTexCoord2fv(&t[tin+=2]);
			glVertex2fv(&vtx[(j+1)*4]);
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = cVert * (rate/cVert);

		/* Do the real thing GOURAUD shaded tmesh */
		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    for(i=(rate)/cVert; i; i--) {
			glBegin(GL_TRIANGLE_STRIP);
			for (j=0, tin=-2; j<cVert; j+=4, tin=-2) {
			    glColor3fv(&c[4]);
                glTexCoord2fv(&t[tin+=2]);
			    glVertex2fv(&vtx[j*4]);
			    glColor3fv(&c[8]);
                glTexCoord2fv(&t[tin+=2]);
			    glVertex2fv(&vtx[(j+1)*4]);
			    glColor3fv(&c[12]);
                glTexCoord2fv(&t[tin+=2]);
			    glVertex2fv(&vtx[(j+2)*4]);
			    glColor3fv(&c[16]);
                glTexCoord2fv(&t[tin+=2]);
			    glVertex2fv(&vtx[(j+3)*4]);
			}
			glColor3fv(&c[4]);
            glTexCoord2fv(&t[tin+=2]);
			glVertex2fv(&vtx[j*4]);
			glColor3fv(&c[8]);
            glTexCoord2fv(&t[tin+=2]);
			glVertex2fv(&vtx[(j+1)*4]);
			glEnd();
		    }
		  }
		  endtest(pbuf, rate, 0);
		}

		glPopMatrix();
	    }
	    printaverage();
	}

    }
    if (mod_doublebuffer) {
        auxSwapBuffers();
        Sleep(2000);               /* for visual feedback */
    }
    exit(0);
}



static void perfvarray(void)
{
    int i,j,k, tin;
    float len;
    char pbuf[256];
    int cVert = 20;
    int num_eles, num_tris;
    
    if (mod_texture) {
        if (mod_texfile) MyLoadImage();
        else CreateImage();
        InitTexParams();
    }

    /* Triangle mesh tests:  Each tmesh contains 62 vertices, or	*/
    /* 60 triangles.  To make the calculation exact, the rate	*/
    /* must be a multiple of 60.					*/

    if (mod_backface){
        glEnable(GL_CULL_FACE);
        glCullFace(GL_FRONT);
    }

    if (mod_bigger) {
        printf("bigger in tmesh\n");
    }

    /* If the triangle size is specified, set the size of the triangle mesh to
    ** fit the window.  The number of vertices must be a multiple of four (due
    ** to code below), and it must not exceed 60.
    */
    if (mod_size) {
        cVert = (int) (MINDIMENSION / prim_size / (float)M_SQRT2) - 2;
        if (cVert & 1) cVert++;
        cVert &= ~3;
        if (cVert < 4) cVert = 4;
        if (cVert > 60) cVert = 60;
    }
    
    num_eles = GenVertData (cVert, cVert, stride);
    num_tris = num_eles/3;
    if (!mod_2d)
        glVertexPointer (3, GL_FLOAT, stride, &(va[0].vertex.x));
    else
        glVertexPointer (2, GL_FLOAT, stride, &(va[0].vertex.x));

    if (mod_cmode && mod_shade) {

        /*** GOURAUD SHADED CMODE TMESH ***/
        glDisableClientState (GL_COLOR_ARRAY);
        glDisableClientState (GL_NORMAL_ARRAY);
        glEnableClientState (GL_INDEX_ARRAY);

    } else if (!mod_light && !mod_shade) {

        /*** FLAT SHADED TMESH ***/
        glDisableClientState (GL_COLOR_ARRAY);
        glDisableClientState (GL_NORMAL_ARRAY);
        glDisableClientState (GL_INDEX_ARRAY);

    } else if (!mod_cmode && mod_light) {

        /*** LIGHTED RGB MESH ***/
        glDisableClientState (GL_INDEX_ARRAY);
        glEnableClientState (GL_NORMAL_ARRAY);
        if (mod_lmcolor)
            glEnableClientState (GL_COLOR_ARRAY);
        else 
            glDisableClientState (GL_COLOR_ARRAY);

//         glMatrixMode(GL_PROJECTION);
//         glLoadIdentity();
//         glOrtho(-0.5*xsize,0.5*xsize,-0.5*ysize,0.5*ysize,1.0,-1.0);
//         glMatrixMode(GL_MODELVIEW);

        /* set lights */
        setLightingParameters();

    } else if (!mod_cmode && mod_shade) {

        /*** GOURAUD SHADED RGB TMESH ***/
        glDisableClientState (GL_INDEX_ARRAY);
        glDisableClientState (GL_NORMAL_ARRAY);
        glEnableClientState (GL_COLOR_ARRAY);
    }

    sum_secs = 0.0;
    sum_n = 0;
    for (angle = 2.0; angle < 360.0; angle += 22.5) {
      
        if (!mod_average)
            sprintf (pbuf, "Angle %6.2f", angle);

        glPushMatrix ();
        glRotatef (angle-90.0, 0, 0, 1.0);
        
        /****** Calibration Loop ******/
        secs = 0.0; rate = 125;
        while (secs < (secspertest/4.0)) {
            rate = rate*2;
            starttest(0);
            for(i=(rate)/num_tris; i; i--) 
                glDrawElements (GL_TRIANGLES, num_eles, GL_UNSIGNED_INT, ve);
            secs = timer(1);
        }

        /****** Real thing *******/
        rate = rate * (secspertest/secs);
        rate = cVert * (rate/cVert);
        for (k=0; k<loopcount; k++) {
            if (starttest(k)) 
                for(i=(rate)/num_tris; i; i--) 
                    glDrawElements (GL_TRIANGLES, num_eles, GL_UNSIGNED_INT, 
                                    ve);
            endtest(pbuf, rate, 0);
        }
        glPopMatrix ();
    }

    printaverage();

    if (mod_doublebuffer) {
         auxSwapBuffers();
         Sleep(2000);               /* for visual feedback */
    }
    exit(0);
}


#ifdef Portme
Static Void Buildattributelist(Int *List, Int Mod_Cmode, Int Mod_Z)
{
    If (!Mod_Cmode) {
	*List++ = Glx_Rgba;
	*List++ = Glx_Red_Size; *List++ = 1;
	*List++ = Glx_GREEN_SIZE; *list++ = 1;
	*list++ = GLX_BLUE_SIZE; *list++ = 1;
    }
    
    if (mod_z) {
	*list++ = GLX_DEPTH_SIZE; 
	*list++ = 1;
    }

    *list = None;
}


static Colormap buildColormap(XVisualInfo *vis, int mod_cmode)
{
    Colormap cmap;
    XColor col;
    int i;

    if (mod_cmode) {
	XColor col;
	
	cmap = XCreateColormap(theDisplay, 
			       RootWindow(theDisplay, vis->screen),
			       vis->visual, AllocAll);

	/* create default entries */
	col.flags = DoRed | DoGreen | DoBlue;
	for (i = BLACK; i <= WHITE; i++) {
	    col.pixel = i;
	    col.red = (i % 2 == 1) ? 0xffff : 0;
	    col.green = ((i >> 1) % 2 == 1) ? 0xffff : 0;
	    col.blue = ((i >> 2) % 2 == 1) ? 0xffff : 0;

	    XStoreColor(theDisplay, cmap, &col);
	}
    }
    else
	cmap= XCreateColormap(theDisplay, 
			      RootWindow(theDisplay, vis->screen),
			      vis->visual, AllocNone);
    
    return cmap;
}
    

static Bool WaitForNotify(Display *d, XEvent *e, char *arg) {
    return (e->type == MapNotify) && (e->xmap.window == (Window)arg);
}
#endif

static void print_usage (char *str)
{
    printf ("%s - Usage:\n", str);
    printf ("gpt <test> [<modifiers>] [loop count] [duration]\n");

    printf ("\nValid tests:\n");
    printf ("    xform    Test transform rate\n");
    printf ("    fill     Test fill rate\n");
    printf ("    dma      Test DMA rate\n");
    printf ("    char     Test character drawing rate\n");
    printf ("    line     Test line drawing rate\n");
    printf ("    poly     Test polygon drawing rate\n");
    printf ("    tmesh    Test Triangle mesh drawing rate\n");
    printf ("    qstrip   Test Quad strip rate\n");
    printf ("    clear    Test screen clear rate\n");
    printf ("    varray   Test vertex array drawing rate\n");
 				      
    printf ("\nValid modifiers:\n");
    printf ("    +2d       Restrict transform to 2D, use glVertex2fv\n");
    printf ("    +z        Enable Z buffering\n");
    printf ("    +shade    Enable Gouraud shading\n");
    printf ("    +cmode    Use color index mode (Limited support)\n");
    printf ("    +1ilight  Enable 1 infinite light\n");
    printf ("    +2ilight  Enable 2 infinite lights\n");
    printf ("    +4ilight  Enable 4 infinite lights\n");
    printf ("    +1llight  Enable 1 local light\n");
    printf ("    +2llight  Enable 2 local lights\n");
    printf ("    +4llight  Enable 4 local lights\n");
    printf ("    +lmcolor  Enable colored lighted vertices\n");
    printf ("    +depth    Enable depth cueing (Lines only) \n");
    printf ("    +aa       Enable anti-aliasing (Points and lines only)\n");
    printf ("    +snap     Set subpixel FALSE (Fast path for PI).\n");
    printf ("    +dashed   Enable dashed lines.\n");
    printf ("    +width    Set line width, +width n (n = 0-9 pixels)\n");
    printf ("    +pattern  Enable pattern filling.\n");
    printf ("    +oldwindow  Open window at (100,900)-(100,650)\n");
    printf ("    +brief    Brief text output\n");
    printf ("    +backface Sets frontface or backface to cull primitives\n");
    printf ("    +dlist    Use display lists (not implemented)\n");
    printf ("    +texture  Use Texture mapping\n");
    printf ("    +blend    Use texture blend mode instead of decal\n");
    printf ("    +modulate Use texure modulate function instead of decal\n");
    printf ("    +db       Use double-buffered pixel format\n");
    printf ("    +avg      Print averages only\n");
    printf ("    +size <size> Sets size of line or side of triangle\n");
    printf ("    +texfile <filename> Texture file\n");
}

static void badparam(int param, char *paramstr)
{
    if (param) printf ("%s ",paramstr);
}

void reshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);

    if (mod_2d)
	gluOrtho2D(-0.5*xsize, 0.5*xsize,-0.5*ysize, 0.5*ysize);
    else
	glOrtho(-0.5*xsize, 0.5*xsize,-0.5*ysize, 0.5*ysize,1.0, -1.0);
}


main(int argc, char *argv[])
{
    int	test_xform = 0;
    int	test_fill = 0;
    int	test_dma = 0;
    int	test_char = 0;
    int	test_line = 0;
    int	test_poly = 0;
    int	test_tmesh = 0;
    int	test_clear = 0;
    int	test_varray = 0;
    int test_qstrip = 0;
    
    int	i;

    char pbuf[256];
    char pbuf2[256];
    char pbuf3[256];

    extern void bzero(void *, int);

    /* Data initialization.					*/
    /* These are malloced and assigned so we get quad alignment	*/

    v = (float *)malloc ((NVERT+1)*4*sizeof(float));
    v = (float *)QUAD_ROUND((int)v);

    mv = (float *)malloc ((NVERT+1)*4*sizeof(float));
    mv = (float *)QUAD_ROUND((int)mv);

    n = (float *)malloc ((NNORM+1)*4*sizeof(float));
    n = (float *)QUAD_ROUND((int)n);

    c = (float *)malloc ((NCOLR+1)*4*sizeof(float));
    c = (float *)QUAD_ROUND((int)c);

    t = (float *)malloc ((NTEXTR)*2*sizeof(float));



    n[0]=1.0; n[1]=0.0; n[2]=0.0; n[3]=0.0;
    n[4]=0.0; n[5]=1.0; n[6]=0.0; n[7]=0.0;
    n[8]=0.0; n[9]=0.0; n[10]=1.0; n[11]=0.0;
    n[12]=0.0; n[13]=M_SQRT1_2; n[14]=M_SQRT1_2; n[15]=0.0;

    c[0]=0.0; c[1]=0.0; c[2]=0.0; c[3]=0.0;
    c[4]=1.0; c[5]=0.0; c[6]=0.0; c[7]=0.0;
    c[8]=0.0; c[9]=1.0; c[10]=0.0; c[11]=0.0;
    c[12]=0.0; c[13]=0.0; c[14]=1.0; c[15]=0.0;
    c[16]=1.0; c[17]=1.0; c[18]=0.0; c[19]=0.0;
    c[20]=1.0; c[21]=0.0; c[22]=1.0; c[23]=0.0;
    c[24]=0.0; c[25]=1.0; c[26]=1.0; c[27]=0.0;
    c[28]=1.0; c[29]=1.0; c[30]=1.0; c[31]=0.0;

    t[0]=0.0; t[1]=0.0;
    t[2]=1.0; t[3]=0.0;
    t[6]=1.0; t[7]=1.0;
    t[4]=0.0; t[5]=1.0;
      
    
    /* Process command line arguments		*/
    /* First, check for which test is specified	*/

    if (argc <= 1) {
	print_usage ("");
	exit (1);
    }

    if (strcmp (argv[1], "xform") == 0)
	test_xform = 1;
    else if (strcmp (argv[1], "fill") == 0)
	test_fill = 1;
    else if (strcmp (argv[1], "dma") == 0)
	test_dma = 1;
    else if (strcmp (argv[1], "char") == 0)
	test_char = 1;
    else if (strcmp (argv[1], "line") == 0)
	test_line = 1;
    else if (strcmp (argv[1], "poly") == 0)
	test_poly = 1;
    else if (strcmp (argv[1], "tmesh") == 0)
	test_tmesh = 1;
    else if (strcmp (argv[1], "clear") == 0)
	test_clear = 1;
    else if (strcmp (argv[1], "qstrip") == 0)
	test_qstrip = 1;
    else if (strcmp (argv[1], "varray") == 0) 
    test_varray = 1;
    else {
	print_usage ("Invalid test");
	exit (1);
    }

    /* Next, check for modifiers	*/

    for (i=2; i<argc; i++) {
	if (*(argv[i]) != '+') break;

	if (strcmp (argv[i], "+2d") == 0)
	    mod_2d = 1;
	else if (strcmp (argv[i], "+z") == 0)
	    mod_z = 1;
	else if (strcmp (argv[i], "+texture") == 0)
	    mod_texture = 1;
	else if (strcmp (argv[i], "+blend") == 0)
	    mod_blend = 1;
	else if (strcmp (argv[i], "+modulate") == 0)
	    mod_modulate = 1;
	else if (strcmp (argv[i], "+shade") == 0)
	    mod_shade = 1;
	else if (strcmp (argv[i], "+cmode") == 0)
	    mod_cmode = 1;
	else if (strcmp (argv[i], "+1ilight") == 0)
	    mod_1ilight = 1;
	else if (strcmp (argv[i], "+2ilight") == 0)
	    mod_2ilight = 1;
	else if (strcmp (argv[i], "+4ilight") == 0)
	    mod_4ilight = 1;
	else if (strcmp (argv[i], "+1llight") == 0)
	    mod_1llight = 1;
	else if (strcmp (argv[i], "+2llight") == 0)
	    mod_2llight = 1;
	else if (strcmp (argv[i], "+4llight") == 0)
	    mod_4llight = 1;
	else if (strcmp (argv[i], "+lmcolor") == 0)
	    mod_lmcolor = 1;
	else if (strcmp (argv[i], "+depth") == 0)
	    mod_depth = 1;
	else if (strcmp (argv[i], "+aa") == 0)
	    mod_aa = 1;
	else if (strcmp (argv[i], "+snap") == 0)
	    mod_snap = 1;
	else if (strcmp (argv[i], "+dashed") == 0)
	    mod_dashed = 1;
	else if (strcmp (argv[i], "+oldwindow") == 0)
	    mod_oldwindow = 1;
	else if (strcmp (argv[i], "+brief") == 0)
	    mod_brief = 1;
	else if (strcmp (argv[i], "+backface") == 0)
	    mod_backface = 1;
	else if (strcmp (argv[i], "+bigger") == 0)
	    { mod_bigger = 1; printf("bigger\n"); }
	else if (strcmp (argv[i], "+width") == 0) {
	    if ((i+1 < argc) && ((*(argv[i+1]) >= '0') || (*(argv[i+1]) <= '9'))) {
		mod_width = 1;
		line_width = atoi(argv[i+1]);
		i++;
	    } 
	}
	else if (strcmp (argv[i], "+pattern") == 0)
	    mod_pattern = 1;
        else if (strcmp (argv[i], "+dlist") == 0)
            useList = GL_TRUE;
        else if (strcmp (argv[i], "+db") == 0)
            mod_doublebuffer = 1;
        else if (strcmp (argv[i], "+avg") == 0)
            mod_average = 1;
	else if (strcmp (argv[i], "+size") == 0) {
	    if (i+1 < argc) {
	        mod_size = 1;
		prim_size = (float) atoi(argv[i+1]);
		i++;
	    } 
	}
	else if (strcmp (argv[i], "+texfile") == 0) {
	    if (i+1 < argc) {
	        mod_texfile = 1;
            strcpy(tex_fname, argv[i+1]);
            i++; 
	    } 
	}
	else {
	    sprintf(pbuf,"%s: Invalid modifier\n",argv[i]);
	    print_usage (pbuf);
	    exit (1);
	}
    }

    /* Finally, check if count and duration were specified	*/

    /* make sure we have a digit here */
    if ((i < argc) && ((*(argv[i]) < '0') || (*(argv[i]) > '9'))) {
	print_usage ("Invalid argument");
	exit (1);
    }

    secspertest = 1.0;
    loopcount = 1;
    if (i < argc) {
	loopcount = atoi(argv[i]);
	if (loopcount <= 0) loopcount = 1;
    }

    i++;
    if (i < argc) {
	secspertest = atof(argv[i]);
	if (secspertest < 0.1) secspertest = 1.0;
    }

    /* vertex initialization was moved to here due to the +size modifier */

    for (i=0; i<NVERT; i++) {
        v[4*i] = ((i&0x01) ? prim_size + 10 : 10.0);
        v[(4*i)+1] = prim_size*(i>>1) + 10.0;
        v[(4*i)+2] = 0.0;
        v[(4*i)+3] = 1.0;
        
        mv[4*i] = ((i&0x01) ? 30.0 : 10.0);
        mv[(4*i)+1] = 20.0 *((i>>1)+1);
        mv[(4*i)+2] = 0.0;
        mv[(4*i)+3] = 1.0;
    }
    

    /*--------------------------------------------------------*/
    /* check for unsupported or unimplemented combinations   */
    /*--------------------------------------------------------*/

    if (mod_bigger && (!test_tmesh)) {
	printf("+bigger only works on tmesh\n");
	exit (1);
    }

    if (mod_size && (!(test_tmesh || test_line || test_poly || test_qstrip 
                        || test_varray))) {
	printf("+size only works with line, tmesh, varray, poly and qstrip\n");
	exit (1);
    }

    if (mod_backface && !(test_tmesh || test_poly || test_qstrip )) {
	printf("+backface only works on tmesh, poly, varray or qstrip\n");
	exit(1);
    }

    if (mod_1ilight || mod_2ilight || mod_4ilight || mod_lmcolor ||
        	       mod_1llight || mod_2llight || mod_4llight)
        mod_light = 1;
        
    if (mod_lmcolor && !(mod_1ilight || mod_2ilight || mod_4ilight ||
			 mod_1llight || mod_2llight || mod_4llight)) {
        printf("Can't have +lmcolor without lighting enabled\n");
        exit(1);
    }

    if (mod_blend && !mod_texture) {
        printf("+blend works only with texture\n");
        exit (1);
    }

    if (mod_modulate && !mod_texture) {
        printf("+modulate works only with texture\n");
        exit (1);
    }

    if (mod_blend && mod_modulate) {
        printf("Use either +blend or +modulate, not both\n");
        exit (1);
    }

    if (mod_texfile && !mod_texture) {
        printf("+texfile works only with texture\n");
        exit (1);
    }
    
    if (mod_width && !(test_line || test_xform)) {
	printf("Width only available with lines and points\n");
	exit(1);
    }

    if (mod_snap)
	printf("+snap has no effect in OpenGL, disregarding\n");

    if (test_xform) {
	if (mod_light || mod_depth || mod_pattern || mod_dashed) {
	    printf("%s: invalid parameter:\n",argv[1]);
	    badparam(mod_light,"+light");
	    badparam(mod_depth,"+depth");
	    badparam(mod_pattern,"+pattern");
	    badparam(mod_dashed,"+dashed");
	    printf("\n");
	    exit(1);
	}
    }

    if (test_line) {
	if (mod_pattern || mod_light) {
	    printf("%s: invalid parameter:\n",argv[1]);
	    badparam(mod_pattern,"+pattern");
	    badparam(mod_light,"+light");
	    printf("\n");
	    exit(1);
	}

	if ((mod_light && mod_cmode) || (mod_aa&&mod_depth) || 
	    (mod_depth&&mod_2d)){

	    printf("%s: invalid parameter combination:\n",argv[1]);
	    badparam(mod_light&&mod_cmode," +light && +cmode");
	    badparam(mod_aa&&mod_depth," +aa && +depth");
	    badparam(mod_depth&&mod_2d," +depth && +2d");

	    printf("\n");
	    exit(1);
	}
    }

    if (test_char) {
	if (mod_pattern || mod_width || mod_dashed || mod_aa ||
	    mod_depth || mod_light || mod_texture) {

	    printf("%s: invalid parameter:\n",argv[1]);
	    badparam(mod_pattern,"+pattern");
	    badparam(mod_dashed,"+dashed");
	    badparam(mod_width,"+width");
	    badparam(mod_depth,"+depth");
	    badparam(mod_texture,"+texture");
	    badparam(mod_aa,"+aa");
	    badparam(mod_light,"+light");
	    printf("\n");
	    exit(1);
	}
    }

    if (test_tmesh || test_qstrip || test_varray) {
	if (mod_pattern || mod_dashed || mod_width || mod_depth || mod_aa ) {
	    printf("%s: invalid parameter:\n",argv[1]);
	    badparam(mod_pattern,"+pattern");
	    badparam(mod_dashed,"+dashed");
	    badparam(mod_width,"+width");
	    badparam(mod_depth,"+depth");
	    badparam(mod_aa,"+aa");
	    printf("\n");
	    exit(1);
	}
    }

    if (test_poly) {
	if (mod_aa || mod_width || mod_depth) {
	    printf("%s: invalid parameter:\n",argv[1]);
	    badparam(mod_dashed,"+dashed");
	    badparam(mod_width,"+width");
	    badparam(mod_depth,"+depth");
	    badparam(mod_aa,"+aa");
	    printf("\n");
	    exit(1);
	}
    }


    if (test_dma) {
	if (mod_2d || mod_z || mod_shade || mod_cmode || mod_light ||
	mod_depth || mod_aa || mod_snap || mod_dashed || mod_width ||
	mod_pattern || mod_oldwindow || mod_texture) {
	    printf("DMA test. No modifiers have any effect\n");
	    printf("\n");
	    exit(1);
	}
	mod_2d = 1;
	mod_shade = 1;
	mod_oldwindow = 0;
    }

    if(test_clear) {
	if(mod_2d || mod_shade || mod_light || mod_depth || mod_aa || 
       mod_texture || 
	    mod_dashed || mod_width || mod_oldwindow || mod_pattern) {
	    printf("%s: invalid parameter:\n",argv[1]);
	    badparam(mod_2d,"+2d");
	    badparam(mod_shade,"+shade");
	    badparam(mod_dashed,"+dashed");
	    badparam(mod_width,"+width");
	    badparam(mod_depth,"+depth");
	    badparam(mod_aa,"+aa");
	    badparam(mod_oldwindow,"+oldwindow");
	    badparam(mod_pattern,"+pattern");
	    printf("\n");
	    exit(1);
	}
    }		

    if(test_fill) {
	if(mod_depth || mod_aa || mod_dashed || mod_width || 
       mod_texture || mod_oldwindow) {
	    printf("%s: invalid parameter:\n",argv[1]);
	    badparam(mod_dashed,"+dashed");
	    badparam(mod_width,"+width");
	    badparam(mod_depth,"+depth");
	    badparam(mod_oldwindow,"+oldwindow");
	    printf("\n");
	    exit(1);
	}
    }		


    /* Arguments all OK, put up a window, and an informative banner	*/
    xsize = WINWIDTH;
    ysize = WINHEIGHT;
    if (mod_doublebuffer)
        auxInitDisplayMode(AUX_DOUBLE | AUX_RGB | AUX_DEPTH);
    else
        auxInitDisplayMode(AUX_SINGLE | AUX_RGB | AUX_DEPTH);
        
    auxInitPosition(0, 0, 0 + xsize, 0 + ysize);
    auxInitWindow("ogpt");
    auxReshapeFunc(reshape);

#ifdef FONTS_NEEDED
    /* get the font if required */
    if (test_char) {
	XFontStruct *fontInfo = NULL;
        fontInfo = XLoadQueryFont(theDisplay, IRISFONT);
	if (fontInfo == NULL) {
	    printf("Could not load font '%s'\n", IRISFONT);
	    exit(1);
	}
	theFont = fontInfo->fid;
    }
#endif

    if (!mod_brief) {
        printf ("\nOpenGL Graphics Performance Tester - version 1.0\n");
        printf ("------------------------------------------------\n\n");
        printf ("window size = %ld %ld\n", xsize,ysize);
        printf ("%6s: ", argv[1]);
        printf ("%s, %s, %s, %s\n",
	    (mod_2d ? "2D" : "3D"),
	    (mod_z ? "Z buffered" : "not Z buffered"),
	    (mod_shade ? "Gouraud shaded" : "flat shaded"),
	    (mod_pattern ? "patterned" : "not patterned") );
        printf ("        %s, %s, %s, width = %d, %s,\n",
	    (mod_light ? "lighted" : "not lighted"),
	    (mod_depth ? "depth cued" : "not depth cued"),
	    (mod_dashed ? "dashed" : "not dashed"),
	    line_width,
	    (mod_aa ? "anti-aliased" : "not anti-aliased") );
        printf ("        %s, %s\n",
	    (mod_cmode ? "CImode" : "RGBmode"),
	    (mod_backface ? "backface(TRUE)" : "backface(FALSE)"));
        printf ("        %s\n",
	    (mod_texture ? "Texturing on" : "Texturing off"));
        printf ("        %s\n",
        (mod_blend ? "Blending on" : (mod_modulate ? "Modulation on" : 
                                      "Decal on")));
    }
    else {
	sprintf(pbuf,"width=%d ",line_width);
	sprintf(pbuf2,"lighted ( %s%s%s%s%s%s) ",
					   (mod_1ilight ? "1inf " : ""),
					   (mod_2ilight ? "2inf " : ""),
					   (mod_4ilight ? "4inf " : ""),
					   (mod_1llight ? "1lcl " : ""),
					   (mod_2llight ? "2lcl " : ""),
					   (mod_4llight ? "4lcl " : ""));
	printf("%6s: ", argv[1]);
	printf("%s", (mod_2d ? "2D " : ""));
        printf("%s", (mod_z ? "Zbuf " : ""));
        printf("%s", (mod_shade ? "Gouraud " : ""));
        printf("%s", (mod_pattern ? "patterned " : ""));
        printf("%s", (mod_depth ? "depth cued " : ""));
        printf("%s", (mod_dashed ? "dashed " : ""));
        printf("%s", (line_width!=1 ? pbuf : ""));
        printf("%s", (mod_aa ? "anti-aliased " : ""));
        printf("%s", (mod_cmode ? "cmode " : ""));
        printf("%s", (mod_light ? pbuf2 : ""));
        printf("%s", (mod_lmcolor ? "lmcolor " : ""));
        printf("%s", (mod_oldwindow ? "oldwindow " : ""));
        printf("%s", (mod_backface ? "backfaced " : ""));
        printf("%s", (mod_texture ? "textured " : ""));
        printf("%s", (mod_blend && mod_texture ? "blend " : ""));
        printf("%s", (mod_modulate && mod_texture ? "modulate " : ""));
        printf("%s", (!mod_modulate && !mod_blend && mod_texture ? 
                      "decal " : ""));
        printf("\n");
    }

    /* Then run the requested test	*/

    if (useList)
        initListMode();

    glShadeModel(mod_shade ? GL_SMOOTH : GL_FLAT);
    if (mod_z) {
	glEnable(GL_DEPTH_TEST);
	/* make z function the same as IrisGL's default */
	glDepthFunc(GL_LEQUAL);
    }
    else
	glDisable(GL_DEPTH_TEST);

    Sleep(1000);	/* wait for window system to quiet down	*/

    if (mod_cmode) {
	glClearIndex(BLACK);
	glIndexi(WHITE);
    } else {
	glClearColor(c[0], c[1], c[2], c[3]);
	glColor3fv(&c[28]);
    }
    glClear(GL_COLOR_BUFFER_BIT);

    if (mod_z) {
	glClear(GL_DEPTH_BUFFER_BIT);
    }

    if (test_xform)
	auxMainLoop(perfpoint);

    if (test_line)
	auxMainLoop(perfline);

    if (test_tmesh && !mod_texture)
        auxMainLoop(perftmesh);

    if (test_tmesh && mod_texture)
        auxMainLoop(perftmeshtex);

    if (test_poly && !mod_texture)
        auxMainLoop(perfpoly);

    if (test_poly && mod_texture)
        auxMainLoop(perfpolytex);

    if (test_qstrip && !mod_texture)
        auxMainLoop(perfqstrip);

    if (test_qstrip && mod_texture)
        auxMainLoop(perfqstriptex);

    if (test_fill)
        auxMainLoop(perffill);
        
    if (test_clear)
        auxMainLoop(perfclear);

    if (test_varray)
        auxMainLoop(perfvarray);

#ifdef PORTME
    if (test_char)
	perfchar();

    if (test_fill)
	perffill();

    if (test_dma)
	perfpixels();

    if (test_clear)
	perfclear();

/*
    if (test_texture)
	perftexture();
*/
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\ogpt\mv\ogpt.c ===
/*
gstrip need to be implemented
bigchar needs to be implemented



Here is a new version of perf, for use in measuring graphics performance.
I've renamed it to be gpt, and added a lot of functionality.

I'd like it to be the standard way for ESD to measure performance.
It measures the performance of geometric primitives over a range
of angles, as specified in the Periodic Table.

I've calibrated gpt by running it on a GT, a VGX, a PI, a Magnum,
and a Hollywood.  I believe it gives accurate and consistent
numbers.  It measures all of the numbers that we publish, including
fill rate and DMA.

If you find bugs in gpt, or want to add features, feel free to
modify it.  But please mail out the new copy to this group, so
we all have a consistent version.

Jim

*/

/*
 *  gpt.c  -  Graphics Performance Tester
 *
 *	Benchmark for performance testing.
 *
 *	Vimal Parikh - 1988  Silicon Graphics Inc.
 *
 *  Modified by Jim Bennett - 1991
 *	- Added self timing and loop count
 *	- Added pixel dma tests
 *	- Added tests at various angles
 *	- Added named tests and modifiers mechanism
 *  Modified by Gary Tarolli - 1991
 *	- Unrolled loops somemore, and optimized some of them a little
 *	- fixed some minor bugs, like forgetting to use ortho to test 3d
 *	- use v2f for fast 2d primitives
 *  Modified by David Ligon - 1992
 *	- cleaned up loops
 *	- added mdifiers (dashed, width, pattern, cmode)
 *	- varied dma size
 *	- varied viewport size for clear
 *	- added qstrip
 *	- added 2d for geometry
 *	- added anti aliased points
 *	- added check for bad parameter combinations
 *  Modified by Gianpaolo Tommasi - 1993
 *	- ported to OpenGL
 *  Modified by Scott Carr - 1993
 *	- Use libaux so I can run it on NT
 *
 *  Usage: gpt <test> [<modifiers>] [loop count] [duration]
 *
 *	The currently supported tests are:
 *
 *	  xform		Test transform rate (points)
 *	  fill		Test fill rate
 *	  dma		Test DMA rate
 *	  char		Test character drawing rate
 *	  line		Test line drawing rate
 *	  poly		Test polygon drawing rate
 *	  tmesh		Test Triangle mesh drawing rate
 *	  qmesh		Test Quad mesh drawing rate
 *	  clear		Test screen clear rate	  
 *	  texture	Test texture mapped rate (Not implemented yet)
 *
 *	The currently supported modifiers are:
 *
 *	  +2d		Restrict transform to 2D
 *	  +z		Enable Z buffering
 *	  +shade	Enable Gouraud shading
 *	  +cmode		Use color index mode (Not implemented yet)
 *	  +1ilight	Enable 1 infinite light
 *	  +2ilight	Enable 2 infinite lights
 *	  +4ilight	Enable 4 infinite lights
 *	  +1llight	Enable 1 local light
 *	  +2llight	Enable 2 local lights
 *	  +4llight	Enable 4 local lights
 *	  +lmcolor	Enable colored lighted vertices
 *	  +depth	Enable depth cueing
 *	  +aa		Enable anti-aliasing
 *	  +snap		Set subpixel FALSE (fast path for PI).
 *	  +dashed	Enable dashed lines
 *	  +width	Set line width, +width n (n = 0-9 pixels)
 *	  +pattern	Enable pattern filling 
 *	  +scale	Set scale for geometry (not implemented yet)
 *	  +oldwindow	Open window at (100,900)-(100,650)
 *	  +brief	Brief text output
 *	  +bigger	Bigger tmesh 20x20
 *	  +backface	Sets frontface or backface to cull all primitives
 *	  +dlist	Use display lists
 *        +db           Use double-buffered visual
 *        +avg          Print averages only
 *
 *	Loop count specifies the number of times the test is run,
 *	and duration specifies the length of each run of the test.
 *	By default, the test is run once for one second.
 *
 *	The line, poly, and tmesh tests are run 16 times, at a
 *	variety of angles, and the average result is printed.
 *
 */

/*
 * Notes for OpenGL version:
 *  - Uses linear fog instead of depth cueing.
 *  - 8 bit pixel writes are done by writing to only the red channel of an 
 *    RGB visual as opposed to writing to a 8 bit CI visual as the IrisGL 
 *    version did.
 *  - Since the polygons used in the perfpoly test are all quadrilaterals, 
 *    GL_QUADS are used.
 */

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <math.h>
#include <GL/glu.h>
#include <GL/gl.h>
#include <auxlib.h>

#define M_SQRT2		1.41421356237309504880
#define M_SQRT1_2	0.70710678118654752440

/* default window size for geometry testing */
#define	WINWIDTH	800
#define	WINHEIGHT	550

#define	QUAD_ROUND(x) (((x)+0x0f)&(~0x0f))

#define	NVERT	62
#define	NNORM	 4
#define	NCOLR	 8


char fiftychars[51] = {
"12345678901234567890123456789012345678901234567890"
};

float	*v;		/* Vertices	*/
float	*mv;		/* Farhad's Vertices	*/
float	*n;		/* Normals	*/
float	*c;		/* Colors	*/

int	mod_2d = 0;
int	mod_z = 0;
int	mod_shade = 0;
int	mod_cmode = 0;
int	mod_light = 0;
int	mod_1ilight = 0;
int	mod_2ilight = 0;
int	mod_4ilight = 0;
int	mod_1llight = 0;
int	mod_2llight = 0;
int	mod_4llight = 0;
int 	mod_lmcolor = 0;
int	mod_depth = 0;
int	mod_aa = 0;
int	mod_snap = 0;
int	mod_dashed = 0;
int	mod_width = 0;
int	mod_pattern = 0;
int	mod_oldwindow = 0;
int	mod_brief = 0;
int	mod_bigger = 0;
int	mod_backface = 0;
int     mod_doublebuffer = 0;
int     mod_average = 0;

float	secspertest;
float	angle;
float	secs;
float	sum_secs;
int	sum_n;
int	rate;
int	loopcount;

long	xsize,ysize;

static	int	delay_counter;

static DWORD startelapsed, endelapsed;

short line_width = 1;

static unsigned int pattern[] = { 
    0x55555555, 0xaaaaaaaa,
    0x55555555, 0xaaaaaaaa,
    0x55555555, 0xaaaaaaaa,
    0x55555555, 0xaaaaaaaa,
    0x55555555, 0xaaaaaaaa,
    0x55555555, 0xaaaaaaaa,
    0x55555555, 0xaaaaaaaa,
    0x55555555, 0xaaaaaaaa,
    0x55555555, 0xaaaaaaaa,
    0x55555555, 0xaaaaaaaa,
    0x55555555, 0xaaaaaaaa,
    0x55555555, 0xaaaaaaaa,
    0x55555555, 0xaaaaaaaa,
    0x55555555, 0xaaaaaaaa,
    0x55555555, 0xaaaaaaaa,
    0x55555555, 0xaaaaaaaa,
};


static float gold_col[] = {0.2, 0.2, 0.0, 1.0};
static float gold_dif[] = {0.9, 0.5, 0.0, 1.0};
static float gold_spec[] = {0.7, 0.7, 0.0, 1.0};
static float gold_shiny[] = {20.0};

static float white_inf_light_amb[] = {0.0, 0.0, 0.0, 1.0};
static float white_inf_light_dif[] = {0.9, 0.9, 0.9, 1.0};
static float white_inf_light_pos[] = {50.0, 50.0, 50.0, 0.0};

static float blue_inf_light_amb[] = {0.0, 0.0, 0.0, 1.0};
static float blue_inf_light_dif[] = {0.30, 0.10, 0.90, 1.0};
static float blue_inf_light_pos[] = {-50.0, 50.0, 50.0, 0.0};

static float red_inf_light_amb[] = {0.0, 0.0, 0.0, 1.0};
static float red_inf_light_dif[] = {0.90, 0.10, 0.30, 1.0};
static float red_inf_light_pos[] = {-50.0, -50.0, 50.0, 0.0};

static float white2_inf_light_amb[] = {0.0, 0.0, 0.0, 1.0};
static float white2_inf_light_dif[] = {0.60, 0.60, 0.60, 1.0};
static float white2_inf_light_pos[] = {50.0, -50.0, 50.0, 0.0};

static float blue_local_light_amb[] = {0.0, 0.0, 0.0, 1.0};
static float blue_local_light_dif[] = {0.30, 0.10, 0.90, 1.0}; 
static float blue_local_light_pos[] = {-50.0, 50.0, -50.0, 1.0};

static float red_local_light_amb[] = {0.0, 0.0, 0.0, 1.0};
static float red_local_light_dif[] = {0.90, 0.10, 0.10, 1.0};
static float red_local_light_pos[] = {50.0, 50.0, -50.0, 1.0};

static float green_local_light_amb[] = {0.0, 0.0, 0.0, 1.0};
static float green_local_light_dif[] = {0.10, 0.90, 0.10, 1.0};
static float green_local_light_pos[] = {50.0, -50.0, -50.0, 1.0};

static float white_local_light_amb[] = {0.0, 0.0, 0.0, 1.0};
static float white_local_light_dif[] = {0.90, 0.90, 0.90, 1.0};
static float white_local_light_pos[] = {-50.0, -50.0, -50.0, 1.0};

static float lightmod_amb[] = {0.3, 0.3, 0.3, 1.0};
static float lightmod_loc[] = {GL_FALSE};

enum {
    BLACK = 0,
    RED = 13,
    GREEN = 14,
    YELLOW = 15,
    BLUE = 16,
    MAGENTA = 17,
    CYAN = 18,
    WHITE = 19
};

GLboolean useList = GL_FALSE;
GLboolean newList = GL_FALSE;
GLuint listID = 0;

/*****************************************************************************/
/*
 * Some support routines
 */

static void initListMode(void) {
    useList = GL_TRUE;
    newList = GL_FALSE;
    listID  = glGenLists(1);
}

static float timer(int flag)
{
    if (useList && flag) {
        if (newList) {
            glEndList();
            newList = GL_FALSE;
        }
        glFinish();
        startelapsed = GetTickCount();
        glCallList(listID);
    }
    glFinish();
    if (flag == 0) {
	startelapsed = GetTickCount();
	return(0.0);
    }

    endelapsed = GetTickCount();

    return(endelapsed - startelapsed) / (float)1000;
}


static int starttest(int flag)
{
    if (useList) {
        if (flag == 0) {
            glNewList(listID, GL_COMPILE);
            newList = GL_TRUE;
	    return(1);
        }
	else
	    return(0);
    } else {
	glFinish();
	startelapsed = GetTickCount();
	return(1);
    }
}


static void endtest(char *s, int r, int force)
{
    if (useList) {
        if (newList) {
            glEndList();
            newList = GL_FALSE;
        }
	glFinish();
	startelapsed = GetTickCount();
        glCallList(listID);
    }
    glFinish();
    endelapsed = GetTickCount();
    secs = (endelapsed - startelapsed) / (float)1000;
    if (!mod_average || force) {
        printf("%-44s--", s);
        printf("%12.2f/sec (%6.3f secs)\n", r/secs, secs);
        fflush(stdout);
    }
    sum_secs += secs;
    sum_n += r;
    Sleep(300);
}

static void printaverage (void)
{
    printf("\n%-44s--", "Average over all angles");
    printf("%12.2f/sec\n", sum_n/sum_secs);
}


static void pixendtest(char *s, int r, int xpix, int ypix)
{
    double pixrate;
    char pbuf[80];

    secs = timer(1);
    sprintf(pbuf,"%dx%d %s",xpix,ypix,s);
    printf("%-44s--", pbuf);
#if 0
    pixrate = r/secs;
    pixrate = (pixrate * xpix * ypix) / 1000000.0;
    printf("%10.4f Million pixels/sec\n", pixrate);
#else
    pixrate = ((double)(r * xpix * ypix) / secs);
    if (pixrate > 1000000.0)
        printf("%10.4f Million pixels/sec\n", pixrate/1000000.0);
    else if (pixrate > 1000.0)
        printf("%10.4f Thousand pixels/sec\n", pixrate/1000.0);
    else
        printf("%10.4f Pixels/sec\n", pixrate);
#endif
    fflush(stdout);
    Sleep(250);
}


static void clearendtest(char *s, int r, int numpix)
{
    double pixrate;

    secs = timer(1);

    printf("%s \n",s);
    printf("\ttotal time: %f for %d clears  \n", secs, r);
    printf("\tcalculated average time for a clear: %f ms\n",1000.0*secs/(float)r);
    pixrate = ((double)(r * numpix) / secs) / 1000000.0;
    printf("\t%10.4f Million pixels/sec\n\n",pixrate);
    fflush(stdout);
    Sleep(250);

}


static void spindelay(void)
{
    int	i;

    delay_counter = 0;
    for (i=0; i<2000000; i++) {
	delay_counter = delay_counter + i;
	delay_counter = delay_counter/39;
    }
}


static void makeramp(int i, int r1, int g1, int b1, int r2, int g2, int b2,
		     int nindexes)
{
#ifdef PORTME
    XColor col;
    int count;
    int r,g,b;

    for (count = 0; count < nindexes; count++) {
	r = (r2 - r1) * count/(nindexes - 1) + r1;
	g = (g2 - g1) * count/(nindexes - 1) + g1;
	b = (b2 - b1) * count/(nindexes - 1) + b1;
	col.red = r * (65535.0 / 255);
	col.green = g * (65535.0 / 255);
	col.blue = b * (65535.0 / 255);
	col.pixel = i;
	col.flags = DoRed | DoGreen | DoBlue;
	XStoreColor(theDisplay, theCMap, &col);
	i++;
    }

    XFlush(theDisplay);
#endif
}


static void setLightingParameters(void)
{
    if (mod_1ilight || mod_2ilight || mod_4ilight) {
	/* lmbind(LIGHT1, 1); */
	glEnable(GL_LIGHTING);
	glLightfv(GL_LIGHT0, GL_AMBIENT, white_inf_light_amb);
	glLightfv(GL_LIGHT0, GL_DIFFUSE, white_inf_light_dif);
	glLightfv(GL_LIGHT0, GL_POSITION, white_inf_light_pos); 
	glEnable(GL_LIGHT0);
    }
    if (mod_2ilight || mod_4ilight) {
	/* lmbind(LIGHT1, 1);lmbind(LIGHT2, 2); */
	glLightfv(GL_LIGHT1, GL_AMBIENT, blue_inf_light_amb);
	glLightfv(GL_LIGHT1, GL_DIFFUSE, blue_inf_light_dif);
	glLightfv(GL_LIGHT1, GL_POSITION, blue_inf_light_pos); 
	glEnable(GL_LIGHT1);
    }
    if (mod_4ilight) {
	/* lmbind(LIGHT1, 1);lmbind(LIGHT2, 2);
	   lmbind(LIGHT3, 3);lmbind(LIGHT4, 4); */
	glLightfv(GL_LIGHT2, GL_AMBIENT, red_inf_light_amb);
	glLightfv(GL_LIGHT2, GL_DIFFUSE, red_inf_light_dif);
	glLightfv(GL_LIGHT2, GL_POSITION, red_inf_light_pos); 
	glEnable(GL_LIGHT2);
	glLightfv(GL_LIGHT3, GL_AMBIENT, white2_inf_light_amb);
	glLightfv(GL_LIGHT3, GL_DIFFUSE, white2_inf_light_dif);
	glLightfv(GL_LIGHT3, GL_POSITION, white2_inf_light_pos); 
	glEnable(GL_LIGHT3);
    }
    
    if (mod_1llight || mod_2llight || mod_4llight) {
	/* lmbind(LIGHT5, 5); */
	glEnable(GL_LIGHTING);
	glLightfv(GL_LIGHT4, GL_AMBIENT, blue_local_light_amb);
	glLightfv(GL_LIGHT4, GL_DIFFUSE, blue_local_light_dif);
	glLightfv(GL_LIGHT4, GL_POSITION, blue_local_light_pos); 
	glEnable(GL_LIGHT4);
    }
    if (mod_2llight) {
	/* lmbind(LIGHT5, 5);lmbind(LIGHT6, 6);*/
	glLightfv(GL_LIGHT5, GL_AMBIENT, red_local_light_amb);
	glLightfv(GL_LIGHT5, GL_DIFFUSE, red_local_light_dif);
	glLightfv(GL_LIGHT5, GL_POSITION, red_local_light_pos); 
	glEnable(GL_LIGHT5);
    }
    if (mod_4llight) {
	/* lmbind(LIGHT5, 5);lmbind(LIGHT6, 6);lmbind(LIGHT7, 7);
	   lmbind(LIGHT0, 8); */
	glLightfv(GL_LIGHT6, GL_AMBIENT, green_local_light_amb);
	glLightfv(GL_LIGHT6, GL_DIFFUSE, green_local_light_dif);
	glLightfv(GL_LIGHT6, GL_POSITION, green_local_light_pos); 
	glEnable(GL_LIGHT6);
	glLightfv(GL_LIGHT7, GL_AMBIENT, white_local_light_amb);
	glLightfv(GL_LIGHT7, GL_DIFFUSE, white_local_light_dif);
	glLightfv(GL_LIGHT7, GL_POSITION, white_local_light_pos); 
	glEnable(GL_LIGHT7);
    }
    
    /* lmbind(LMODEL, 1); */
    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lightmod_amb);
    glLightModelfv(GL_LIGHT_MODEL_LOCAL_VIEWER, lightmod_loc);
    
    /* lmbind(MATERIAL, 1); */
    glMaterialfv(GL_FRONT, GL_AMBIENT, gold_col);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, gold_dif);
    glMaterialfv(GL_FRONT, GL_SPECULAR, gold_spec);
    glMaterialfv(GL_FRONT, GL_SHININESS, gold_shiny);
    
    /* if (mod_lmcolor) lmcolor(LMC_DIFFUSE); */
    if (mod_lmcolor) {
	glColorMaterial(GL_FRONT_AND_BACK, GL_DIFFUSE);
	glEnable(GL_COLOR_MATERIAL);
    }
}

/*****************************************************************************/

/*
 * The tests proper
 */

static void perfpoint(void)
{
    int i, k;
    float *vp = v;

    /*** POINTS *****/

    if (mod_width) {
	glPointSize(line_width);
    }

    if (mod_aa) {
	glEnable(GL_POINT_SMOOTH);
	if (mod_cmode) {
	    /* create a colour ramp appropriate for anti-aliasing */
	    /* i, r1, g1, b1, r2, g2, b2, nindexes */
	    makeramp(240, 0, 0, 0, 255, 255, 255, 16);
	    glClearIndex(240);
	    glClear(GL_COLOR_BUFFER_BIT);
	    glIndexi(240);
	} else {
	    glEnable(GL_BLEND);
	    /* blendfunction(BF_SA,BF_ONE); */
	    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
	}
    }


    /****** Calibration Loop ******/
    secs = 0.0;
    rate = 125;
    while (secs < (secspertest/4.0)) {
	rate = rate * 2;
	starttest(0);
	glBegin(GL_POINTS);
	if (mod_2d)
	    for (i = 0; i < rate; i++)
		glVertex2fv(vp);
	else
	    for (i = 0; i < rate; i++)
		glVertex3fv(vp);
	glEnd();

	secs = timer(1);
    }
    rate = rate * (secspertest / secs);
    rate = 10 * (rate / 10);

    /* do the real thing */
    for (k = 0; k < loopcount; k++) {
      if (starttest(k)) {
	glBegin(GL_POINTS);
	if (mod_2d) {
	    for (i = rate / 10; i; i--) {
		glVertex2fv(vp);
		glVertex2fv(vp);
		glVertex2fv(vp);
		glVertex2fv(vp);
		glVertex2fv(vp);
		glVertex2fv(vp);
		glVertex2fv(vp);
		glVertex2fv(vp);
		glVertex2fv(vp);
		glVertex2fv(vp);
	    }
	} else {
	    for (i = rate / 10; i; i--) {
		glVertex3fv(vp);
		glVertex3fv(vp);
		glVertex3fv(vp);
		glVertex3fv(vp);
		glVertex3fv(vp);
		glVertex3fv(vp);
		glVertex3fv(vp);
		glVertex3fv(vp);
		glVertex3fv(vp);
		glVertex3fv(vp);
	    }
	}
	glEnd();
      }
      endtest("", rate, 1);
    }
    if (mod_doublebuffer) {
        auxSwapBuffers();
        Sleep(2000);               /* for visual feedback */
    }
    exit(0);
}


static void perfline(void)
{
    int i,k;
    char pbuf[80];
    float *vp=v;

    if (mod_dashed) {
	glEnable(GL_LINE_STIPPLE);
	glLineStipple(1, 0x5555);
    }

    if (mod_width) {
	glLineWidth(line_width);
    }

    /*** ANTI_ALIAS LINES *****/
    
    if (mod_aa) {
	glEnable(GL_LINE_SMOOTH);
	if (mod_cmode) {
	    makeramp(240,0,0,0,255,255,255,16);
	    glClearIndex(240);
	    glClear(GL_COLOR_BUFFER_BIT);
	    glIndexi(240);
	} else {
	    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
	}
    }

    /*** DEPTHCUED LINES *****/

    /* 
     * OpenGL has no depth cueing, we'll use linear fog instead.
     */
    if (mod_depth) {
	glEnable(GL_FOG);
	glFogi(GL_FOG_MODE, GL_LINEAR);
	glDepthRange(0.0, 1.0);
	glFogf(GL_FOG_START, 0.0);
	glFogf(GL_FOG_END, 1.0);
	
	if (mod_cmode) {
	    makeramp(240,250,250,250,255,255,0,16);
	    glIndexi(240);
	    glFogf(GL_FOG_INDEX, 16);
	} else
	    glFogfv(GL_FOG_COLOR, &c[16]);
	
	sum_secs = 0.0;
	sum_n = 0;
	vp[4] -= 1.0;	/* make lines 10 pixels instead of 11	*/
	for (angle = 2.0; angle < 360.0; angle += 22.5) {
	    glPushMatrix();
	    glRotatef(angle, 0, 0, 1);

	    /****** Calibration Loop ******/
	    secs = 0.0; rate = 125;

	    while (secs < (secspertest/4.0)) {
		rate = rate*2;
		starttest(0);
		glBegin(GL_LINE_STRIP);
		/* No 2D depth cued lines - Go straight to 3D */
		for(i=(rate)/2; i; i--) {
		    glVertex3fv(vp);
		    glVertex3fv(vp+4);
		}
		glEnd();

		secs = timer(1);
	    }
	    rate = rate * (secspertest/secs);
	    rate = 10 * (rate/10);

	    for (k=0; k<loopcount; k++) {
	      if (starttest(k)) {
		glBegin(GL_LINE_STRIP);
		for(i=(rate)/10; i; i--) {
		    glVertex3fv(vp);
		    glVertex3fv(vp+4);
		    glVertex3fv(vp);
		    glVertex3fv(vp+4);
		    glVertex3fv(vp);
		    glVertex3fv(vp+4);
		    glVertex3fv(vp);
		    glVertex3fv(vp+4);
		    glVertex3fv(vp);
		    glVertex3fv(vp+4);
		}
		glEnd();
	      }
              if (!mod_average)
    	        sprintf(pbuf, "Angle %6.2f", angle);

	      endtest(pbuf, rate, 0);
	    }
	    glPopMatrix();
	}
	printaverage();
        if (mod_doublebuffer) {
            auxSwapBuffers();
            Sleep(2000);               /* for visual feedback */
        }
	exit(0);
    }    

    if (!mod_shade) {

	/**** Flat shaded RGB or Color mapped lines ****/
	/**** Color should already be set           ****/

	sum_secs = 0.0;
	sum_n = 0;
	vp[4] -= 1.0;	/* make lines 10 pixels instead of 11	*/
	for (angle = 2.0; angle < 360.0; angle += 22.5) {
	    glPushMatrix();
	    glRotatef(angle, 0, 0, 1);

	    /****** Calibration Loop ******/
	    secs = 0.0; rate = 125;

	    while (secs < (secspertest/4.0)) {
		rate = rate*2;
		starttest(0);
		glBegin(GL_LINE_STRIP);
		if (mod_2d) {
		    for(i=(rate)/2; i; i--) {
			glVertex2fv(vp);
			glVertex2fv(vp+4);
		    }
		} else {
		    for(i=(rate)/2; i; i--) {
			glVertex3fv(vp);
			glVertex3fv(vp+4);
		    }
		}
		glEnd();

		secs = timer(1);
	    }
	    rate = rate * (secspertest/secs);
	    rate = 10 * (rate/10);

	    for (k=0; k<loopcount; k++) {
	      if (starttest(k)) {
		glBegin(GL_LINE_STRIP);
		if (mod_2d) { 
		    for(i=(rate)/10; i; i--) {
			glVertex2fv(vp);
			glVertex2fv(vp+4);
			glVertex2fv(vp);
			glVertex2fv(vp+4);
			glVertex2fv(vp);
			glVertex2fv(vp+4);
			glVertex2fv(vp);
			glVertex2fv(vp+4);
			glVertex2fv(vp);
			glVertex2fv(vp+4);
		    } 

		} else {
		    for(i=(rate)/10; i; i--) {
			glVertex3fv(vp);
			glVertex3fv(vp+4);
			glVertex3fv(vp);
			glVertex3fv(vp+4);
			glVertex3fv(vp);
			glVertex3fv(vp+4);
			glVertex3fv(vp);
			glVertex3fv(vp+4);
			glVertex3fv(vp);
			glVertex3fv(vp+4);
		    }
		}
		glEnd();
	      }
              if (!mod_average)
	        sprintf(pbuf, "Angle %6.2f", angle);

	      endtest(pbuf, rate, 0);
	    }
	    glPopMatrix();
	}
	printaverage();

    } else {

	if (mod_cmode) {

	    /**** Gouraud  Color mapped lines ****/
	    makeramp(240,255,0,0,0,0,255,16);

	    sum_secs = 0.0;
	    sum_n = 0;
	    vp[4] -= 1.0;	/* make lines 10 pixels instead of 11	*/
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
		glPushMatrix();
		glRotatef(angle, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;

		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);
		    glBegin(GL_LINE_STRIP);
		    if (mod_2d) {
			for(i=(rate)/2; i; i--) {
			    glIndexi(240);
			    glVertex2fv(vp);
			    glIndexi(255);
			    glVertex2fv(vp+4);
			}
		    } else {
			for(i=(rate)/2; i; i--) {
			    glIndexi(240);
			    glVertex3fv(vp);
			    glIndexi(255);
			    glVertex3fv(vp+4);
			}
		    }
		    glEnd();

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = 10 * (rate/10);

		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    glBegin(GL_LINE_STRIP);
		    if (mod_2d) { 
			for(i=(rate)/10; i; i--) {
			    glIndexi(240);
			    glVertex2fv(vp);
			    glIndexi(255);
			    glVertex2fv(vp+4);
			    glIndexi(240);
			    glVertex2fv(vp);
			    glIndexi(255);
			    glVertex2fv(vp+4);
			    glIndexi(240);
			    glVertex2fv(vp);
			    glIndexi(255);
			    glVertex2fv(vp+4);
			    glIndexi(240);
			    glVertex2fv(vp);
			    glIndexi(255);
			    glVertex2fv(vp+4);
			    glIndexi(240);
			    glVertex2fv(vp);
			    glIndexi(255);
			    glVertex2fv(vp+4);
			} 

		    } else {
			for(i=(rate)/10; i; i--) {
			    glIndexi(240);
			    glVertex2fv(vp);
			    glIndexi(255);
			    glVertex2fv(vp+4);
			    glIndexi(240);
			    glVertex2fv(vp);
			    glIndexi(255);
			    glVertex2fv(vp+4);
			    glIndexi(240);
			    glVertex2fv(vp);
			    glIndexi(255);
			    glVertex2fv(vp+4);
			    glIndexi(240);
			    glVertex2fv(vp);
			    glIndexi(255);
			    glVertex2fv(vp+4);
			    glIndexi(240);
			    glVertex2fv(vp);
			    glIndexi(255);
			    glVertex2fv(vp+4);
			}
		    }
		    glEnd();
	          }
                  if (!mod_average)
		    sprintf (pbuf, "Angle %6.2f", angle);
		    
		  endtest(pbuf, rate, 0);
		}
		glPopMatrix();
	    }
	    printaverage();

	} else {

	    /**** Gouraud shaded RGB index lines ****/

	    sum_secs = 0.0;
	    sum_n = 0;
	    vp[4] -= 1.0;	/* make lines 10 pixels instead of 11	*/
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
		glPushMatrix();
		glRotatef(angle, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;

		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);
		    glBegin(GL_LINE_STRIP);
		    if (mod_2d) {
			for(i=(rate)/2; i; i--) {
			    glColor3fv(&c[12]);
			    glVertex2fv(vp);
			    glColor3fv(&c[8]);
			    glVertex2fv(vp+4);
			}
		    } else {
			for(i=(rate)/2; i; i--) {
			    glColor3fv(&c[12]);
			    glVertex3fv(vp);
			    glColor3fv(&c[8]);
			    glVertex3fv(vp+4);
			}
		    }
		    glEnd();

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = 10 * (rate/10);

		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    glBegin(GL_LINE_STRIP);
		    if (mod_2d) { 
			for(i=(rate)/10; i; i--) {
			    glColor3fv(&c[12]);
			    glVertex2fv(vp);
			    glColor3fv(&c[8]);
			    glVertex2fv(vp+4);
			    glColor3fv(&c[12]);
			    glVertex2fv(vp);
			    glColor3fv(&c[8]);
			    glVertex2fv(vp+4);
			    glColor3fv(&c[12]);
			    glVertex2fv(vp);
			    glColor3fv(&c[8]);
			    glVertex2fv(vp+4);
			    glColor3fv(&c[12]);
			    glVertex2fv(vp);
			    glColor3fv(&c[8]);
			    glVertex2fv(vp+4);
			    glColor3fv(&c[12]);
			    glVertex2fv(vp);
			    glColor3fv(&c[8]);
			    glVertex2fv(vp+4);
			} 

		    } else {
			for(i=(rate)/10; i; i--) {
			    glColor3fv(&c[12]);
			    glVertex2fv(vp);
			    glColor3fv(&c[8]);
			    glVertex2fv(vp+4);
			    glColor3fv(&c[12]);
			    glVertex2fv(vp);
			    glColor3fv(&c[8]);
			    glVertex2fv(vp+4);
			    glColor3fv(&c[12]);
			    glVertex2fv(vp);
			    glColor3fv(&c[8]);
			    glVertex2fv(vp+4);
			    glColor3fv(&c[12]);
			    glVertex2fv(vp);
			    glColor3fv(&c[8]);
			    glVertex2fv(vp+4);
			    glColor3fv(&c[12]);
			    glVertex2fv(vp);
			    glColor3fv(&c[8]);
			    glVertex2fv(vp+4);
			}
		    }
		    glEnd();
		  }
                  if (!mod_average)
		    sprintf (pbuf, "Angle %6.2f", angle);
		    
		  endtest(pbuf, rate, 0);
		}
		glPopMatrix();
	    }
	    printaverage();
	}
    }
    if (mod_doublebuffer) {
        auxSwapBuffers();
        Sleep(2000);               /* for visual feedback */
    }
    exit(0);
}


static void perfchar(void)
{
    int i,k;

    /*** CHARACTERS *****/

#ifdef PORTME
    /* create the bitmaps */
    glXUseXFont(theFont, '0', 10, '0');
#endif
    glListBase(0);

    /****** Calibration Loop ******/
    secs = 0.0; rate = 125;
    while (secs < (secspertest/4.0)) {
	rate = rate*2;
	starttest(0);
	for(i=(rate)/50; i; i--) {
	    glRasterPos3i(10-(WINWIDTH/2), 10, 0);
	    glCallLists(strlen(fiftychars), GL_UNSIGNED_BYTE, fiftychars);
	}

	secs = timer(1);
    }
    rate = rate * (secspertest/secs);
    rate = 50 * (rate/50);

    for (k=0; k<loopcount; k++) {
      if (starttest(k)) {
	for(i=(rate)/50; i; i--) {
	    glRasterPos3i(10-(WINWIDTH/2), 10, 0);
	    glCallLists(strlen(fiftychars), GL_UNSIGNED_BYTE, fiftychars);
	}
      }
      endtest("", rate, 1);
    }
}


static void perftmesh(void)
{
    int i,j,k;
    float *vtx = &v[0];
    char pbuf[80];

    /* Triangle mesh tests:  Each tmesh contains 62 vertices, or	*/
    /* 60 triangles.  To make the calculation exact, the rate	*/
    /* must be a multiple of 60.					*/

    if (mod_backface){
	glEnable(GL_CULL_FACE);
	glCullFace(GL_FRONT);
    }
    for(i=0; i<NVERT; i++) {
	vtx[i*4+1] -= ((NVERT+2)/4.0 * 10.0);
    }

    if (mod_bigger) {
	vtx = &mv[0];
	printf("bigger in tmesh\n");
    }

    if (!mod_2d) {
	if (mod_cmode && mod_shade) {

	    /*** GOURAUD SHADED CMODE TMESH ***/
	    /* 255 = r, 240 = g, 255 = b */
	    makeramp(208,255,0,0,0,0,255,16);
	    makeramp(224,0,0,255,255,255,0,16);
	    makeramp(240,255,255,0,255,0,255,16);

	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
                if (!mod_average)
		  sprintf(pbuf, "Angle %6.2f", angle);
		  
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);
		    for(i=(rate)/60; i; i--) {
			glBegin(GL_TRIANGLE_STRIP);
			for (j=0; j<60; j+=4) {
			    glIndexi(255);
			    glVertex3fv(&vtx[j*4]);
			    glIndexi(240);
			    glVertex3fv(&vtx[(j+1)*4]);
			    glIndexi(223);
			    glVertex3fv(&vtx[(j+2)*4]);
			    glIndexi(208);
			    glVertex3fv(&vtx[(j+3)*4]);
			}
			glIndexi(255);
			glVertex3fv(&vtx[j*4]);
			glIndexi(240);
			glVertex3fv(&vtx[(j+1)*4]);
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = 60 * (rate/60);

		/* Do the real thing GOURAUD shaded Cmode tmesh */
		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    for(i=(rate)/60; i; i--) {
			glBegin(GL_TRIANGLE_STRIP);
			for (j=0; j<60; j+=4) {
			    glIndexi(255);
			    glVertex3fv(&vtx[j*4]);
			    glIndexi(240);
			    glVertex3fv(&vtx[(j+1)*4]);
			    glIndexi(223);
			    glVertex3fv(&vtx[(j+2)*4]);
			    glIndexi(208);
			    glVertex3fv(&vtx[(j+3)*4]);
			}
			glIndexi(255);
			glVertex3fv(&vtx[j*4]);
			glIndexi(240);
			glVertex3fv(&vtx[(j+1)*4]);
			glEnd();
		    }
		  }
		  endtest(pbuf, rate, 0);
		}

		glPopMatrix();
	    }
	    printaverage();

	} else if (!mod_light && !mod_shade) {

	    /*** FLAT SHADED TMESH ***/
	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
                if (!mod_average)
		  sprintf(pbuf, "Angle %6.2f", angle);
		  
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;

		    starttest(0);

		    for(i=(rate)/60; i; i--) {
			glBegin(GL_TRIANGLE_STRIP);
			for (j=0; j<62; j++) {
			    glVertex3fv(&vtx[j*4]);
			}
			glEnd();
		    }

		    secs = timer(1);

		}
		rate = rate * (secspertest/secs);
		rate = 60 * (rate/60);
	    
		/* Do the real thing - FLAT shaded tmesh */
		for (k=0; k<loopcount; k++) {

		  if (starttest(k)) {

		    for(i=(rate)/60; i; i--) {
			glBegin(GL_TRIANGLE_STRIP);
			for (j=0; j<62; j++) {
			    glVertex3fv(&vtx[j*4]);
			}
			glEnd();
		    }
		  }
		  endtest(pbuf, rate, 0);
		}
		glPopMatrix();
	    }
	    printaverage();

	} else if (!mod_cmode && mod_light) {
	    /*** LIGHTED RGB MESH ***/

	    glLoadIdentity();

	    glMatrixMode(GL_PROJECTION);
	    glLoadIdentity();
	    glOrtho(-0.5*xsize,0.5*xsize,-0.5*ysize,0.5*ysize,1.0,-1.0);

	    glMatrixMode(GL_MODELVIEW);

	    /* set lights */
	    setLightingParameters();

	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
                if (!mod_average)
		  sprintf (pbuf, "Angle %6.2f", angle);
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    if (mod_lmcolor) {
		        starttest(0);
		        for(i=(rate)/60; i; i--) {
			    glBegin(GL_TRIANGLE_STRIP);
			    for (j=0; j<60; j+=4) {
				glColor3fv(&c[16]);
			        glNormal3fv(&n[0]);
			        glVertex3fv(&vtx[j*4]);
				glColor3fv(&c[20]);
			        glNormal3fv(&n[4]);
			        glVertex3fv(&vtx[(j+1)*4]);
				glColor3fv(&c[4]);
			        glNormal3fv(&n[8]);
			        glVertex3fv(&vtx[(j+2)*4]);
				glColor3fv(&c[8]);
			        glNormal3fv(&n[12]);
			        glVertex3fv(&vtx[(j+3)*4]);
			    }
			    glColor3fv(&c[16]);
			    glNormal3fv(&n[0]);
			    glVertex3fv(&vtx[j*4]);
			    glColor3fv(&c[20]);
			    glNormal3fv(&n[4]);
			    glVertex3fv(&vtx[(j+1)*4]);
			    glEnd();
		        }
    
		        secs = timer(1);
		    }
		    else {
		        starttest(0);  
		        for(i=(rate)/60; i; i--) {
			    glBegin(GL_TRIANGLE_STRIP);
			    for (j=0; j<60; j+=4) {
			        glNormal3fv(&n[0]);
			        glVertex3fv(&vtx[j*4]);
			        glNormal3fv(&n[4]);
			        glVertex3fv(&vtx[(j+1)*4]);
			        glNormal3fv(&n[8]);
			        glVertex3fv(&vtx[(j+2)*4]);
			        glNormal3fv(&n[12]);
			        glVertex3fv(&vtx[(j+3)*4]);
			    }
			    glNormal3fv(&n[0]);
			    glVertex3fv(&vtx[j*4]);
			    glNormal3fv(&n[4]);
			    glVertex3fv(&vtx[(j+1)*4]);
			    glEnd();
		        }
    
		        secs = timer(1);
		    }
		}
		rate = rate * (secspertest/secs);
		rate = 60 * (rate/60);

		for (k=0; k<loopcount; k++) {
		    if (mod_lmcolor) {
		      if (starttest(k)) {
		        for(i=(rate)/60; i; i--) {
			    glBegin(GL_TRIANGLE_STRIP);
			    for (j=0; j<60; j+=4) {
				glColor3fv(&c[16]);
			        glNormal3fv(&n[0]);
			        glVertex3fv(&vtx[j*4]);
				glColor3fv(&c[20]);
			        glNormal3fv(&n[4]);
			        glVertex3fv(&vtx[(j+1)*4]);
				glColor3fv(&c[4]);
			        glNormal3fv(&n[8]);
			        glVertex3fv(&vtx[(j+2)*4]);
				glColor3fv(&c[8]);
			        glNormal3fv(&n[12]);
			        glVertex3fv(&vtx[(j+3)*4]);
			    }
			    glColor3fv(&c[16]);
			    glNormal3fv(&n[0]);
			    glVertex3fv(&vtx[j*4]);
			    glColor3fv(&c[20]);
			    glNormal3fv(&n[4]);
			    glVertex3fv(&vtx[(j+1)*4]);
			    glEnd();
		        }
		      }
		      endtest(pbuf, rate, 0);
		    }
		    else {
		      if (starttest(k)) {
		        for(i=(rate)/60; i; i--) {
			    glBegin(GL_TRIANGLE_STRIP);
			    for (j=0; j<60; j+=4) {
			        glNormal3fv(&n[0]);
			        glVertex3fv(&vtx[j*4]);
			        glNormal3fv(&n[4]);
			        glVertex3fv(&vtx[(j+1)*4]);
			        glNormal3fv(&n[8]);
			        glVertex3fv(&vtx[(j+2)*4]);
			        glNormal3fv(&n[12]);
			        glVertex3fv(&vtx[(j+3)*4]);
			    }
			    glNormal3fv(&n[0]);
			    glVertex3fv(&vtx[j*4]);
			    glNormal3fv(&n[4]);
			    glVertex3fv(&vtx[(j+1)*4]);
			    glEnd();
		        }
		      }
		      endtest(pbuf, rate, 0);
		    }
		}
		glPopMatrix();
	    }
	    printaverage();

	} else if (!mod_cmode && mod_shade) {

	    /*** GOURAUD SHADED RGB TMESH ***/
	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
                if (!mod_average)
		  sprintf(pbuf, "Angle %6.2f", angle);
		  
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);
		    for(i=(rate)/60; i; i--) {
			glBegin(GL_TRIANGLE_STRIP);
			for (j=0; j<60; j+=4) {
			    glColor3fv(&c[4]);
			    glVertex3fv(&vtx[j*4]);
			    glColor3fv(&c[8]);
			    glVertex3fv(&vtx[(j+1)*4]);
			    glColor3fv(&c[12]);
			    glVertex3fv(&vtx[(j+2)*4]);
			    glColor3fv(&c[16]);
			    glVertex3fv(&vtx[(j+3)*4]);
			}
			glColor3fv(&c[4]);
			glVertex3fv(&vtx[j*4]);
			glColor3fv(&c[8]);
			glVertex3fv(&vtx[(j+1)*4]);
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = 60 * (rate/60);

		/* Do the real thing GOURAUD shaded tmesh */
		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    for(i=(rate)/60; i; i--) {
			glBegin(GL_TRIANGLE_STRIP);
			for (j=0; j<60; j+=4) {
			    glColor3fv(&c[4]);
			    glVertex3fv(&vtx[j*4]);
			    glColor3fv(&c[8]);
			    glVertex3fv(&vtx[(j+1)*4]);
			    glColor3fv(&c[12]);
			    glVertex3fv(&vtx[(j+2)*4]);
			    glColor3fv(&c[16]);
			    glVertex3fv(&vtx[(j+3)*4]);
			}
			glColor3fv(&c[4]);
			glVertex3fv(&vtx[j*4]);
			glColor3fv(&c[8]);
			glVertex3fv(&vtx[(j+1)*4]);
			glEnd();
		    }
		  }
		  endtest(pbuf, rate, 0);
		}

		glPopMatrix();
	    }
	    printaverage();
	}

    } else {	/* must be 2d */
	if (mod_cmode && mod_shade) { /* color map lighting yet */

	    /*** GOURAUD SHADED CMODE TMESH ***/
	    /* 255 = r, 240 = g, 255 = b */
	    makeramp(208,255,0,0,0,0,255,16);
	    makeramp(224,0,0,255,255,255,0,16);
	    makeramp(240,255,255,0,255,0,255,16);

	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
                if (!mod_average)
		  sprintf(pbuf, "Angle %6.2f", angle);
		  
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);
		    for(i=(rate)/60; i; i--) {
			glBegin(GL_TRIANGLE_STRIP);
			for (j=0; j<60; j+=4) {
			    glIndexi(255);
			    glVertex2fv(&vtx[j*4]);
			    glIndexi(240);
			    glVertex2fv(&vtx[(j+1)*4]);
			    glIndexi(223);
			    glVertex3fv(&vtx[(j+2)*4]);
			    glIndexi(208);
			    glVertex3fv(&vtx[(j+3)*4]);
			}
			glIndexi(255);
			glVertex3fv(&vtx[j*4]);
			glIndexi(240);
			glVertex3fv(&vtx[(j+1)*4]);
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = 60 * (rate/60);

		/* Do the real thing GOURAUD shaded Cmode tmesh */
		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    for(i=(rate)/60; i; i--) {
			glBegin(GL_TRIANGLE_STRIP);
			for (j=0; j<60; j+=4) {
			    glIndexi(255);
			    glVertex2fv(&vtx[j*4]);
			    glIndexi(240);
			    glVertex2fv(&vtx[(j+1)*4]);
			    glIndexi(223);
			    glVertex3fv(&vtx[(j+2)*4]);
			    glIndexi(208);
			    glVertex3fv(&vtx[(j+3)*4]);
			}
			glIndexi(255);
			glVertex3fv(&vtx[j*4]);
			glIndexi(240);
			glVertex3fv(&vtx[(j+1)*4]);
			glEnd();
		    }
		  }
		  endtest(pbuf, rate, 0);
		}

		glPopMatrix();
	    }
	    printaverage();

	} else if (!mod_light && !mod_shade) {

	    /*** FLAT SHADED TMESH ***/
	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
                if (!mod_average)
		  sprintf(pbuf, "Angle %6.2f", angle);
		  
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);
		    for(i=(rate)/60; i; i--) {
			glBegin(GL_TRIANGLE_STRIP);
			for (j=0; j<62; j++) {
			    glVertex2fv(&vtx[j*4]);
			}
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = 60 * (rate/60);
	    
		/* Do the real thing - FLAT shaded tmesh */
		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    for(i=(rate)/60; i; i--) {
			glBegin(GL_TRIANGLE_STRIP);
			for (j=0; j<62; j++) {
			    glVertex2fv(&vtx[j*4]);
			}
			glEnd();
		    }
		  }
		  endtest(pbuf, rate, 0);
		}
		glPopMatrix();
	    }
	    printaverage();

	} else if (!mod_cmode && mod_light) {

	    /*** LIGHTED RGB MESH ***/
	    glLoadIdentity();

	    glMatrixMode(GL_PROJECTION);
	    glLoadIdentity();
	    glOrtho(-0.5*xsize,0.5*xsize,-0.5*ysize,0.5*ysize,1.0,-1.0);
	    glMatrixMode(GL_MODELVIEW);

	    /* set lights */
	    setLightingParameters();

	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
                if (!mod_average)
		  sprintf (pbuf, "Angle %6.2f", angle);
		  
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    if (mod_lmcolor) {
		        starttest(0);
		        for(i=(rate)/60; i; i--) {
			    glBegin(GL_TRIANGLE_STRIP);
			    for (j=0; j<60; j+=4) {
				glColor3fv(&c[16]);
			        glNormal3fv(&n[0]);
			        glVertex3fv(&vtx[j*4]);
				glColor3fv(&c[20]);
			        glNormal3fv(&n[4]);
			        glVertex3fv(&vtx[(j+1)*4]);
				glColor3fv(&c[4]);
			        glNormal3fv(&n[8]);
			        glVertex3fv(&vtx[(j+2)*4]);
				glColor3fv(&c[8]);
			        glNormal3fv(&n[12]);
			        glVertex3fv(&vtx[(j+3)*4]);
			    }
			    glColor3fv(&c[16]);
			    glNormal3fv(&n[0]);
			    glVertex3fv(&vtx[j*4]);
			    glColor3fv(&c[20]);
			    glNormal3fv(&n[4]);
			    glVertex3fv(&vtx[(j+1)*4]);
			    glEnd();
		        }
    
		        secs = timer(1);
		    }
		    else {
		        starttest(0);
		        for(i=(rate)/60; i; i--) {
			    glBegin(GL_TRIANGLE_STRIP);
			    for (j=0; j<60; j+=4) {
			        glNormal3fv(&n[0]);
			        glVertex3fv(&vtx[j*4]);
			        glNormal3fv(&n[4]);
			        glVertex3fv(&vtx[(j+1)*4]);
			        glNormal3fv(&n[8]);
			        glVertex3fv(&vtx[(j+2)*4]);
			        glNormal3fv(&n[12]);
			        glVertex3fv(&vtx[(j+3)*4]);
			    }
			    glNormal3fv(&n[0]);
			    glVertex3fv(&vtx[j*4]);
			    glNormal3fv(&n[4]);
			    glVertex3fv(&vtx[(j+1)*4]);
			    glEnd();
		        }
    
		        secs = timer(1);
		    }
		}
		rate = rate * (secspertest/secs);
		rate = 60 * (rate/60);

		for (k=0; k<loopcount; k++) {
		    if (mod_lmcolor) {
		      if (starttest(k)) {
		        for(i=(rate)/60; i; i--) {
			    glBegin(GL_TRIANGLE_STRIP);
			    for (j=0; j<60; j+=4) {
				glColor3fv(&c[16]);
			        glNormal3fv(&n[0]);
			        glVertex3fv(&vtx[j*4]);
				glColor3fv(&c[20]);
			        glNormal3fv(&n[4]);
			        glVertex3fv(&vtx[(j+1)*4]);
				glColor3fv(&c[4]);
			        glNormal3fv(&n[8]);
			        glVertex3fv(&vtx[(j+2)*4]);
				glColor3fv(&c[8]);
			        glNormal3fv(&n[12]);
			        glVertex3fv(&vtx[(j+3)*4]);
			    }
			    glColor3fv(&c[16]);
			    glNormal3fv(&n[0]);
			    glVertex3fv(&vtx[j*4]);
			    glColor3fv(&c[20]);
			    glNormal3fv(&n[4]);
			    glVertex3fv(&vtx[(j+1)*4]);
			    glEnd();
		        }
		      }
		      endtest(pbuf, rate, 0);
		    }
		    else {
		      if (starttest(k)) {
		        for(i=(rate)/60; i; i--) {
			    glBegin(GL_TRIANGLE_STRIP);
			    for (j=0; j<60; j+=4) {
			        glNormal3fv(&n[0]);
			        glVertex3fv(&vtx[j*4]);
			        glNormal3fv(&n[4]);
			        glVertex3fv(&vtx[(j+1)*4]);
			        glNormal3fv(&n[8]);
			        glVertex3fv(&vtx[(j+2)*4]);
			        glNormal3fv(&n[12]);
			        glVertex3fv(&vtx[(j+3)*4]);
			    }
			    glNormal3fv(&n[0]);
			    glVertex3fv(&vtx[j*4]);
			    glNormal3fv(&n[4]);
			    glVertex3fv(&vtx[(j+1)*4]);
			    glEnd();
		        }
		      }
		      endtest(pbuf, rate, 0);
		    }
		}
		glPopMatrix();
	    }
	    printaverage();

	} else if (!mod_cmode && mod_shade) {

	    /*** GOURAUD SHADED RGB TMESH ***/
	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
                if (!mod_average)
		  sprintf(pbuf, "Angle %6.2f", angle);
		  
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);
		    for(i=(rate)/60; i; i--) {
			glBegin(GL_TRIANGLE_STRIP);
			for (j=0; j<60; j+=4) {
			    glColor3fv(&c[4]);
			    glVertex3fv(&vtx[j*4]);
			    glColor3fv(&c[8]);
			    glVertex3fv(&vtx[(j+1)*4]);
			    glColor3fv(&c[12]);
			    glVertex3fv(&vtx[(j+2)*4]);
			    glColor3fv(&c[16]);
			    glVertex3fv(&vtx[(j+3)*4]);
			}
			glColor3fv(&c[4]);
			glVertex3fv(&vtx[j*4]);
			glColor3fv(&c[8]);
			glVertex3fv(&vtx[(j+1)*4]);
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = 60 * (rate/60);

		/* Do the real thing GOURAUD shaded tmesh */
		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    for(i=(rate)/60; i; i--) {
			glBegin(GL_TRIANGLE_STRIP);
			for (j=0; j<60; j+=4) {
			    glColor3fv(&c[4]);
			    glVertex3fv(&vtx[j*4]);
			    glColor3fv(&c[8]);
			    glVertex3fv(&vtx[(j+1)*4]);
			    glColor3fv(&c[12]);
			    glVertex3fv(&vtx[(j+2)*4]);
			    glColor3fv(&c[16]);
			    glVertex3fv(&vtx[(j+3)*4]);
			}
			glColor3fv(&c[4]);
			glVertex3fv(&vtx[j*4]);
			glColor3fv(&c[8]);
			glVertex3fv(&vtx[(j+1)*4]);
			glEnd();
		    }
		  }
		  endtest(pbuf, rate, 0);
		}

		glPopMatrix();
	    }
	    printaverage();

	}
    }
    if (mod_doublebuffer) {
        auxSwapBuffers();
        Sleep(2000);               /* for visual feedback */
    }
    exit(0);
}


static void perfpoly(void)
{
    float *vtx = &v[0];
    int i, k;
    char pbuf[80];

    if (mod_pattern) {
	glEnable(GL_POLYGON_STIPPLE);
	glPolygonStipple((GLubyte *) pattern);
    }

    if (!mod_2d) {

	/**** 3D POLYGONS ****/

	if (mod_light && !mod_cmode) {

	/*** POLYGONS (LIGHTED) *****/

	    glLoadIdentity();
	    
	    glMatrixMode(GL_PROJECTION);
	    glLoadIdentity();
	    glOrtho(-0.5*xsize, 0.5*xsize,-0.5*ysize, 0.5*ysize,1.0, -1.0);
	    
	    glMatrixMode(GL_MODELVIEW);

	    /* set lights */
	    setLightingParameters();

	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
                if (!mod_average)
		  sprintf (pbuf, "Angle %6.2f", angle);
		  
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    if (mod_lmcolor) {
		        starttest(0);
		        for(i=(rate)/5; i; i--) {
			    glBegin(GL_QUADS);
			    glColor3fv(&c[4]); glNormal3fv(&n[0]); 
			    glVertex3fv(vtx); 
			    glColor3fv(&c[16]); glNormal3fv(&n[4]); 
			    glVertex3fv(vtx+4); 
			    glColor3fv(&c[8]); glNormal3fv(&n[8]); 
			    glVertex3fv(vtx+12); 
			    glColor3fv(&c[8]); glNormal3fv(&n[12]); 
			    glVertex3fv(vtx+8);

			    glColor3fv(&c[4]); glNormal3fv(&n[0]); 
			    glVertex3fv(vtx+8); 
			    glColor3fv(&c[16]); glNormal3fv(&n[4]); 
			    glVertex3fv(vtx+12); 
			    glColor3fv(&c[8]); glNormal3fv(&n[8]); 
			    glVertex3fv(vtx+20); 
			    glColor3fv(&c[8]); glNormal3fv(&n[12]); 
			    glVertex3fv(vtx+16);

			    glColor3fv(&c[4]); glNormal3fv(&n[0]); 
			    glVertex3fv(vtx+16); 
			    glColor3fv(&c[16]); glNormal3fv(&n[4]); 
			    glVertex3fv(vtx+20); 
			    glColor3fv(&c[8]); glNormal3fv(&n[8]); 
			    glVertex3fv(vtx+28); 
			    glColor3fv(&c[8]); glNormal3fv(&n[12]); 
			    glVertex3fv(vtx+24);

			    glColor3fv(&c[4]); glNormal3fv(&n[0]); 
			    glVertex3fv(vtx+24); 
			    glColor3fv(&c[16]); glNormal3fv(&n[4]); 
			    glVertex3fv(vtx+28); 
			    glColor3fv(&c[8]); glNormal3fv(&n[8]); 
			    glVertex3fv(vtx+36); 
			    glColor3fv(&c[8]); glNormal3fv(&n[12]); 
			    glVertex3fv(vtx+32);

			    glColor3fv(&c[4]); glNormal3fv(&n[0]); 
			    glVertex3fv(vtx+32); 
			    glColor3fv(&c[16]); glNormal3fv(&n[4]); 
			    glVertex3fv(vtx+36); 
			    glColor3fv(&c[8]); glNormal3fv(&n[8]); 
			    glVertex3fv(vtx+44); 
			    glColor3fv(&c[8]); glNormal3fv(&n[12]); 
			    glVertex3fv(vtx+40);
			    glEnd();
		        }
    
		        secs = timer(1);
		    }
		    else {
		        starttest(0);
		        for(i=(rate)/5; i; i--) {
			    glBegin(GL_QUADS);
			    glNormal3fv(&n[0]); glVertex3fv(vtx); 
			    glNormal3fv(&n[4]); glVertex3fv(vtx+4); 
			    glNormal3fv(&n[8]); glVertex3fv(vtx+12); 
			    glNormal3fv(&n[12]); glVertex3fv(vtx+8);
    
			    glNormal3fv(&n[0]); glVertex3fv(vtx+8); 
			    glNormal3fv(&n[4]); glVertex3fv(vtx+12); 
			    glNormal3fv(&n[8]); glVertex3fv(vtx+20); 
			    glNormal3fv(&n[12]); glVertex3fv(vtx+16);
    
			    glNormal3fv(&n[0]); glVertex3fv(vtx+16); 
			    glNormal3fv(&n[4]); glVertex3fv(vtx+20); 
			    glNormal3fv(&n[8]); glVertex3fv(vtx+28); 
			    glNormal3fv(&n[12]); glVertex3fv(vtx+24);
    
			    glNormal3fv(&n[0]); glVertex3fv(vtx+24); 
			    glNormal3fv(&n[4]); glVertex3fv(vtx+28); 
			    glNormal3fv(&n[8]); glVertex3fv(vtx+36); 
			    glNormal3fv(&n[12]); glVertex3fv(vtx+32);
    
			    glNormal3fv(&n[0]); glVertex3fv(vtx+32); 
			    glNormal3fv(&n[4]); glVertex3fv(vtx+36); 
			    glNormal3fv(&n[8]); glVertex3fv(vtx+44); 
			    glNormal3fv(&n[12]); glVertex3fv(vtx+40);
			    glEnd();
			}
    
		        secs = timer(1);
		    }
		}
		rate = rate * (secspertest/secs);
		rate = 5 * (rate/5);

		for (k=0; k<loopcount; k++) {
		    if (mod_lmcolor) {
		      if (starttest(k)) {
		        for(i=(rate)/5; i; i--) {
			    glBegin(GL_QUADS);
			    glColor3fv(&c[4]); glNormal3fv(&n[0]);
			    glVertex3fv(vtx); 
			    glColor3fv(&c[16]); glNormal3fv(&n[4]); 
			    glVertex3fv(vtx+4); 
			    glColor3fv(&c[8]); glNormal3fv(&n[8]);
			    glVertex3fv(vtx+12); 
			    glColor3fv(&c[8]); glNormal3fv(&n[12]);
			    glVertex3fv(vtx+8);

			    glColor3fv(&c[4]); glNormal3fv(&n[0]);
			    glVertex3fv(vtx+8); 
			    glColor3fv(&c[16]); glNormal3fv(&n[4]);
			    glVertex3fv(vtx+12); 
			    glColor3fv(&c[8]); glNormal3fv(&n[8]);
			    glVertex3fv(vtx+20); 
			    glColor3fv(&c[8]); glNormal3fv(&n[12]);
			    glVertex3fv(vtx+16);
    
			    glColor3fv(&c[4]); glNormal3fv(&n[0]);
			    glVertex3fv(vtx+16); 
			    glColor3fv(&c[16]); glNormal3fv(&n[4]);
			    glVertex3fv(vtx+20); 
			    glColor3fv(&c[8]); glNormal3fv(&n[8]);
			    glVertex3fv(vtx+28); 
			    glColor3fv(&c[8]); glNormal3fv(&n[12]);
			    glVertex3fv(vtx+24);
    
			    glColor3fv(&c[4]); glNormal3fv(&n[0]);
			    glVertex3fv(vtx+24); 
			    glColor3fv(&c[16]); glNormal3fv(&n[4]);
			    glVertex3fv(vtx+28); 
			    glColor3fv(&c[8]); glNormal3fv(&n[8]);
			    glVertex3fv(vtx+36); 
			    glColor3fv(&c[8]); glNormal3fv(&n[12]);
			    glVertex3fv(vtx+32);
    
			    glColor3fv(&c[4]); glNormal3fv(&n[0]);
			    glVertex3fv(vtx+32); 
			    glColor3fv(&c[16]); glNormal3fv(&n[4]);
			    glVertex3fv(vtx+36); 
			    glColor3fv(&c[8]); glNormal3fv(&n[8]);
			    glVertex3fv(vtx+44); 
			    glColor3fv(&c[8]); glNormal3fv(&n[12]);
			    glVertex3fv(vtx+40);
			    glEnd();
		        }
		      }
		      endtest(pbuf, rate, 0);
		    }
		    else {
		      if (starttest(k)) {
		        for(i=(rate)/5; i; i--) {
			    glBegin(GL_QUADS);
			    glNormal3fv(&n[0]); glVertex3fv(vtx); 
			    glNormal3fv(&n[4]); glVertex3fv(vtx+4); 
			    glNormal3fv(&n[8]); glVertex3fv(vtx+12); 
			    glNormal3fv(&n[12]); glVertex3fv(vtx+8);
    
			    glNormal3fv(&n[0]); glVertex3fv(vtx+8); 
			    glNormal3fv(&n[4]); glVertex3fv(vtx+12); 
			    glNormal3fv(&n[8]); glVertex3fv(vtx+20); 
			    glNormal3fv(&n[12]); glVertex3fv(vtx+16);
    
			    glNormal3fv(&n[0]); glVertex3fv(vtx+16); 
			    glNormal3fv(&n[4]); glVertex3fv(vtx+20); 
			    glNormal3fv(&n[8]); glVertex3fv(vtx+28); 
			    glNormal3fv(&n[12]); glVertex3fv(vtx+24);
    
			    glNormal3fv(&n[0]); glVertex3fv(vtx+24); 
			    glNormal3fv(&n[4]); glVertex3fv(vtx+28); 
			    glNormal3fv(&n[8]); glVertex3fv(vtx+36); 
			    glNormal3fv(&n[12]); glVertex3fv(vtx+32);
    
			    glNormal3fv(&n[0]); glVertex3fv(vtx+32); 
			    glNormal3fv(&n[4]); glVertex3fv(vtx+36); 
			    glNormal3fv(&n[8]); glVertex3fv(vtx+44); 
			    glNormal3fv(&n[12]); glVertex3fv(vtx+40);
			    glEnd();
		        }
		      }
		      endtest(pbuf, rate, 0);
		    }
		}

		glPopMatrix();
	    }
	    printaverage();
	} else if (mod_shade && !mod_cmode) {

	    /*** POLYGONS (SHADED RGB) *****/

	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
                if (!mod_average)
		  sprintf(pbuf, "Angle %6.2f", angle);
		  
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);
		    for(i=(rate)/5; i; i--) {
			glBegin(GL_QUADS);
			glColor3fv(&c[4]); glVertex3fv(vtx); 
			glColor3fv(&c[16]); glVertex3fv(vtx+4); 
			glColor3fv(&c[8]); glVertex3fv(vtx+12); 
			glColor3fv(&c[8]); glVertex3fv(vtx+8);

			glColor3fv(&c[4]); glVertex3fv(vtx+8); 
			glColor3fv(&c[16]); glVertex3fv(vtx+12); 
			glColor3fv(&c[8]); glVertex3fv(vtx+20); 
			glColor3fv(&c[8]); glVertex3fv(vtx+16);

			glColor3fv(&c[4]); glVertex3fv(vtx+16); 
			glColor3fv(&c[16]); glVertex3fv(vtx+20); 
			glColor3fv(&c[8]); glVertex3fv(vtx+28); 
			glColor3fv(&c[8]); glVertex3fv(vtx+24);

			glColor3fv(&c[4]); glVertex3fv(vtx+24); 
			glColor3fv(&c[16]); glVertex3fv(vtx+28); 
			glColor3fv(&c[8]); glVertex3fv(vtx+36); 
			glColor3fv(&c[8]); glVertex3fv(vtx+32);

			glColor3fv(&c[4]); glVertex3fv(vtx+32); 
			glColor3fv(&c[16]); glVertex3fv(vtx+36); 
			glColor3fv(&c[8]); glVertex3fv(vtx+44); 
			glColor3fv(&c[8]); glVertex3fv(vtx+40);
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = 5 * (rate/5);

		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    for(i=(rate)/5; i; i--) {
			glBegin(GL_QUADS);
			glColor3fv(&c[4]); glVertex3fv(vtx); 
			glColor3fv(&c[16]); glVertex3fv(vtx+4); 
			glColor3fv(&c[8]); glVertex3fv(vtx+12); 
			glColor3fv(&c[8]); glVertex3fv(vtx+8);

			glColor3fv(&c[4]); glVertex3fv(vtx+8); 
			glColor3fv(&c[16]); glVertex3fv(vtx+12); 
			glColor3fv(&c[8]); glVertex3fv(vtx+20); 
			glColor3fv(&c[8]); glVertex3fv(vtx+16);

			glColor3fv(&c[4]); glVertex3fv(vtx+16); 
			glColor3fv(&c[16]); glVertex3fv(vtx+20); 
			glColor3fv(&c[8]); glVertex3fv(vtx+28); 
			glColor3fv(&c[8]); glVertex3fv(vtx+24);

			glColor3fv(&c[4]); glVertex3fv(vtx+24); 
			glColor3fv(&c[16]); glVertex3fv(vtx+28); 
			glColor3fv(&c[8]); glVertex3fv(vtx+36); 
			glColor3fv(&c[8]); glVertex3fv(vtx+32);

			glColor3fv(&c[4]); glVertex3fv(vtx+32); 
			glColor3fv(&c[16]); glVertex3fv(vtx+36); 
			glColor3fv(&c[8]); glVertex3fv(vtx+44); 
			glColor3fv(&c[8]); glVertex3fv(vtx+40);
			glEnd();
		    }
		  }
		  endtest(pbuf, rate, 0);
		}

		glPopMatrix();
	    }
	    printaverage();
	} else if (mod_shade && mod_cmode) {

	    /*** POLYGONS (SHADED COLOR MAPPED) *****/

	    /* 255 = r, 240 = g, 255 = b */
	    makeramp(208, 255, 0, 0, 0, 0, 255, 16);
	    makeramp(224, 0, 0, 255, 255, 255, 0, 16);
	    makeramp(240, 255, 255, 0, 255, 0, 255, 16);

	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
                if (!mod_average)
		  sprintf(pbuf, "Angle %6.2f", angle);
		  
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);
		    for(i=(rate)/5; i; i--) {
			glBegin(GL_QUADS);
			glIndexi(255); glVertex3fv(vtx); 
			glIndexi(240); glVertex3fv(vtx+4); 
			glIndexi(223); glVertex3fv(vtx+12); 
			glIndexi(208); glVertex3fv(vtx+8);

			glIndexi(255); glVertex3fv(vtx+8); 
			glIndexi(240); glVertex3fv(vtx+12); 
			glIndexi(223); glVertex3fv(vtx+20); 
			glIndexi(208); glVertex3fv(vtx+16);

			glIndexi(255); glVertex3fv(vtx+16); 
			glIndexi(240); glVertex3fv(vtx+20); 
			glIndexi(223); glVertex3fv(vtx+28); 
			glIndexi(208); glVertex3fv(vtx+24);

			glIndexi(255); glVertex3fv(vtx+24); 
			glIndexi(240); glVertex3fv(vtx+28); 
			glIndexi(223); glVertex3fv(vtx+36); 
			glIndexi(208); glVertex3fv(vtx+32);

			glIndexi(255); glVertex3fv(vtx+32); 
			glIndexi(240); glVertex3fv(vtx+36); 
			glIndexi(223); glVertex3fv(vtx+44); 
			glIndexi(208); glVertex3fv(vtx+40);
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = 5 * (rate/5);

		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    for(i=(rate)/5; i; i--) {
			glBegin(GL_QUADS);
			glIndexi(255); glVertex3fv(vtx); 
			glIndexi(240); glVertex3fv(vtx+4); 
			glIndexi(223); glVertex3fv(vtx+12); 
			glIndexi(208); glVertex3fv(vtx+8);

			glIndexi(255); glVertex3fv(vtx+8); 
			glIndexi(240); glVertex3fv(vtx+12); 
			glIndexi(223); glVertex3fv(vtx+20); 
			glIndexi(208); glVertex3fv(vtx+16);

			glIndexi(255); glVertex3fv(vtx+16); 
			glIndexi(240); glVertex3fv(vtx+20); 
			glIndexi(223); glVertex3fv(vtx+28); 
			glIndexi(208); glVertex3fv(vtx+24);

			glIndexi(255); glVertex3fv(vtx+24); 
			glIndexi(240); glVertex3fv(vtx+28); 
			glIndexi(223); glVertex3fv(vtx+36); 
			glIndexi(208); glVertex3fv(vtx+32);

			glIndexi(255); glVertex3fv(vtx+32); 
			glIndexi(240); glVertex3fv(vtx+36); 
			glIndexi(223); glVertex3fv(vtx+44); 
			glIndexi(208); glVertex3fv(vtx+40);
			glEnd();
		    }
		  }
		  endtest(pbuf, rate, 0);
		}

		glPopMatrix();
	    }
	    printaverage();

	} else if (!mod_light && !mod_shade) {

	    /*** POLYGONS (FLAT SHADED) *****/

	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
                if (!mod_average)
		  sprintf(pbuf, "Angle %6.2f", angle);
		  
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);
		    for(i=(rate)/5; i; i--) {
			glBegin(GL_QUADS);
			glVertex3fv(vtx); glVertex3fv(vtx+4);
			glVertex3fv(vtx+12); glVertex3fv(vtx+8);

			glVertex3fv(vtx+8); glVertex3fv(vtx+12);
			glVertex3fv(vtx+20); glVertex3fv(vtx+16);

			glVertex3fv(vtx+16); glVertex3fv(vtx+20);
			glVertex3fv(vtx+28); glVertex3fv(vtx+24);

			glVertex3fv(vtx+24); glVertex3fv(vtx+28);
			glVertex3fv(vtx+36); glVertex3fv(vtx+32);

			glVertex3fv(vtx+32); glVertex3fv(vtx+36);
			glVertex3fv(vtx+44); glVertex3fv(vtx+40);
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = 5 * (rate/5);

		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    for(i=(rate)/5; i; i--) {
			glBegin(GL_QUADS);
			glVertex3fv(vtx+0); glVertex3fv(vtx+4);
			glVertex3fv(vtx+12); glVertex3fv(vtx+8);

			glVertex3fv(vtx+8); glVertex3fv(vtx+12);
			glVertex3fv(vtx+20); glVertex3fv(vtx+16);

			glVertex3fv(vtx+16); glVertex3fv(vtx+20);
			glVertex3fv(vtx+28); glVertex3fv(vtx+24);

			glVertex3fv(vtx+24); glVertex3fv(vtx+28);
			glVertex3fv(vtx+36); glVertex3fv(vtx+32);

			glVertex3fv(vtx+32); glVertex3fv(vtx+36);
			glVertex3fv(vtx+44); glVertex3fv(vtx+40);
			glEnd();
		    }
		  }
		  endtest(pbuf, rate, 0);
		}
		glPopMatrix();
	    }
	    printaverage();
	}
    } else {

	/**** 2D POLYGONS ****/

	if (mod_light && !mod_cmode) {

	/*** POLYGONS (LIGHTED) *****/

	    glLoadIdentity();

	    glMatrixMode(GL_PROJECTION);
	    glLoadIdentity();
	    gluOrtho2D(-0.5*xsize, 0.5*xsize,-0.5*ysize, 0.5*ysize);
	    glMatrixMode(GL_MODELVIEW);

	    /* set lights */
	    setLightingParameters();
    
	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
                if (!mod_average)
		  sprintf(pbuf, "Angle %6.2f", angle);
		  
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    if (mod_lmcolor) {
		        starttest(0);
		        for(i=(rate)/5; i; i--) {
			    glBegin(GL_QUADS);
			    glColor3fv(&c[4]); glNormal3fv(&n[0]);
			    glVertex2fv(vtx); 
			    glColor3fv(&c[16]); glNormal3fv(&n[4]);
			    glVertex2fv(vtx+4); 
			    glColor3fv(&c[8]); glNormal3fv(&n[8]);
			    glVertex2fv(vtx+12); 
			    glColor3fv(&c[8]); glNormal3fv(&n[12]);
			    glVertex2fv(vtx+8);

			    glColor3fv(&c[4]); glNormal3fv(&n[0]); 
			    glVertex2fv(vtx+8); 
			    glColor3fv(&c[16]); glNormal3fv(&n[4]);
			    glVertex2fv(vtx+12); 
			    glColor3fv(&c[8]); glNormal3fv(&n[8]);
			    glVertex2fv(vtx+20); 
			    glColor3fv(&c[8]); glNormal3fv(&n[12]);
			    glVertex2fv(vtx+16);

			    glColor3fv(&c[4]); glNormal3fv(&n[0]);
			    glVertex2fv(vtx+16); 
			    glColor3fv(&c[16]); glNormal3fv(&n[4]);
			    glVertex2fv(vtx+20); 
			    glColor3fv(&c[8]); glNormal3fv(&n[8]); 
			    glVertex2fv(vtx+28); 
			    glColor3fv(&c[8]); glNormal3fv(&n[12]);
			    glVertex2fv(vtx+24);

			    glColor3fv(&c[4]); glNormal3fv(&n[0]); 
			    glVertex2fv(vtx+24); 
			    glColor3fv(&c[16]); glNormal3fv(&n[4]);
			    glVertex2fv(vtx+28); 
			    glColor3fv(&c[8]); glNormal3fv(&n[8]); 
			    glVertex2fv(vtx+36); 
			    glColor3fv(&c[8]); glNormal3fv(&n[12]);
			    glVertex2fv(vtx+32);

			    glColor3fv(&c[4]); glNormal3fv(&n[0]); 
			    glVertex2fv(vtx+32); 
			    glColor3fv(&c[16]); glNormal3fv(&n[4]); 
			    glVertex2fv(vtx+36); 
			    glColor3fv(&c[8]); glNormal3fv(&n[8]); 
			    glVertex2fv(vtx+44); 
			    glColor3fv(&c[8]); glNormal3fv(&n[12]);
			    glVertex2fv(vtx+40);
			    glEnd();
		        }
    
		        secs = timer(1);
		    }
		    else {
		        starttest(0);
		        for(i=(rate)/5; i; i--) {
			    glBegin(GL_QUADS);
			    glNormal3fv(&n[0]); glVertex2fv(vtx); 
			    glNormal3fv(&n[4]); glVertex2fv(vtx+4); 
			    glNormal3fv(&n[8]); glVertex2fv(vtx+12); 
			    glNormal3fv(&n[12]); glVertex2fv(vtx+8);

			    glNormal3fv(&n[0]); glVertex2fv(vtx+8); 
			    glNormal3fv(&n[4]); glVertex2fv(vtx+12); 
			    glNormal3fv(&n[8]); glVertex2fv(vtx+20); 
			    glNormal3fv(&n[12]); glVertex2fv(vtx+16);

			    glNormal3fv(&n[0]); glVertex2fv(vtx+16); 
			    glNormal3fv(&n[4]); glVertex2fv(vtx+20); 
			    glNormal3fv(&n[8]); glVertex2fv(vtx+28); 
			    glNormal3fv(&n[12]); glVertex2fv(vtx+24);

			    glNormal3fv(&n[0]); glVertex2fv(vtx+24); 
			    glNormal3fv(&n[4]); glVertex2fv(vtx+28); 
			    glNormal3fv(&n[8]); glVertex2fv(vtx+36); 
			    glNormal3fv(&n[12]); glVertex2fv(vtx+32);

			    glNormal3fv(&n[0]); glVertex2fv(vtx+32); 
			    glNormal3fv(&n[4]); glVertex2fv(vtx+36); 
			    glNormal3fv(&n[8]); glVertex2fv(vtx+44); 
			    glNormal3fv(&n[12]); glVertex2fv(vtx+40);
			    glEnd();
		        }
    
		        secs = timer(1);
		    }
		}
		rate = rate * (secspertest/secs);
		rate = 5 * (rate/5);

		for (k=0; k<loopcount; k++) {
		    if (mod_lmcolor) {
		      if (starttest(k)) {
		        for(i=(rate)/5; i; i--) {
			    glBegin(GL_QUADS);
			    glColor3fv(&c[4]); glNormal3fv(&n[0]);
			    glVertex2fv(vtx); 
			    glColor3fv(&c[16]); glNormal3fv(&n[4]);
			    glVertex2fv(vtx+4); 
			    glColor3fv(&c[8]); glNormal3fv(&n[8]);
			    glVertex2fv(vtx+12); 
			    glColor3fv(&c[8]); glNormal3fv(&n[12]);
			    glVertex2fv(vtx+8);

			    glColor3fv(&c[4]); glNormal3fv(&n[0]);
			    glVertex2fv(vtx+8); 
			    glColor3fv(&c[16]); glNormal3fv(&n[4]);
			    glVertex2fv(vtx+12); 
			    glColor3fv(&c[8]); glNormal3fv(&n[8]);
			    glVertex2fv(vtx+20); 
			    glColor3fv(&c[8]); glNormal3fv(&n[12]);
			    glVertex2fv(vtx+16);

			    glColor3fv(&c[4]); glNormal3fv(&n[0]);
			    glVertex2fv(vtx+16); 
			    glColor3fv(&c[16]); glNormal3fv(&n[4]);
			    glVertex2fv(vtx+20); 
			    glColor3fv(&c[8]); glNormal3fv(&n[8]);
			    glVertex2fv(vtx+28); 
			    glColor3fv(&c[8]); glNormal3fv(&n[12]);
			    glVertex2fv(vtx+24);

			    glColor3fv(&c[4]); glNormal3fv(&n[0]);
			    glVertex2fv(vtx+24); 
			    glColor3fv(&c[16]); glNormal3fv(&n[4]);
			    glVertex2fv(vtx+28); 
			    glColor3fv(&c[8]); glNormal3fv(&n[8]);
			    glVertex2fv(vtx+36); 
			    glColor3fv(&c[8]); glNormal3fv(&n[12]);
			    glVertex2fv(vtx+32);

			    glColor3fv(&c[4]); glNormal3fv(&n[0]);
			    glVertex2fv(vtx+32); 
			    glColor3fv(&c[16]); glNormal3fv(&n[4]);
			    glVertex2fv(vtx+36); 
			    glColor3fv(&c[8]); glNormal3fv(&n[8]);
			    glVertex2fv(vtx+44); 
			    glColor3fv(&c[8]); glNormal3fv(&n[12]);
			    glVertex2fv(vtx+40);
			    glEnd();
		        }
		      }
		      endtest(pbuf, rate, 0);
		    }
		    else {
		      if (starttest(k)) {
		        for(i=(rate)/5; i; i--) {
			    glBegin(GL_QUADS);
			    glNormal3fv(&n[0]); glVertex2fv(vtx); 
			    glNormal3fv(&n[4]); glVertex2fv(vtx+4); 
			    glNormal3fv(&n[8]); glVertex2fv(vtx+12); 
			    glNormal3fv(&n[12]); glVertex2fv(vtx+8);

			    glNormal3fv(&n[0]); glVertex2fv(vtx+8); 
			    glNormal3fv(&n[4]); glVertex2fv(vtx+12); 
			    glNormal3fv(&n[8]); glVertex2fv(vtx+20); 
			    glNormal3fv(&n[12]); glVertex2fv(vtx+16);

			    glNormal3fv(&n[0]); glVertex2fv(vtx+16); 
			    glNormal3fv(&n[4]); glVertex2fv(vtx+20); 
			    glNormal3fv(&n[8]); glVertex2fv(vtx+28); 
			    glNormal3fv(&n[12]); glVertex2fv(vtx+24);

			    glNormal3fv(&n[0]); glVertex2fv(vtx+24); 
			    glNormal3fv(&n[4]); glVertex2fv(vtx+28); 
			    glNormal3fv(&n[8]); glVertex2fv(vtx+36); 
			    glNormal3fv(&n[12]); glVertex2fv(vtx+32);

			    glNormal3fv(&n[0]); glVertex2fv(vtx+32); 
			    glNormal3fv(&n[4]); glVertex2fv(vtx+36); 
			    glNormal3fv(&n[8]); glVertex2fv(vtx+44); 
			    glNormal3fv(&n[12]); glVertex2fv(vtx+40);
			    glEnd();
		        }
		      }
		      endtest(pbuf, rate, 0);
		    }
		}

		glPopMatrix();
	    }
	    printaverage();
	} else if (mod_shade && !mod_cmode) {

	    /*** POLYGONS (SHADED RGB) *****/

	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
                if (!mod_average)
		  sprintf(pbuf, "Angle %6.2f", angle);
		  
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);
		    for(i=(rate)/5; i; i--) {
			glBegin(GL_QUADS);
			glColor3fv(&c[4]); glVertex2fv(vtx); 
			glColor3fv(&c[16]); glVertex2fv(vtx+4); 
			glColor3fv(&c[8]); glVertex2fv(vtx+12); 
			glColor3fv(&c[8]); glVertex2fv(vtx+8);

			glColor3fv(&c[4]); glVertex2fv(vtx+8); 
			glColor3fv(&c[16]); glVertex2fv(vtx+12); 
			glColor3fv(&c[8]); glVertex2fv(vtx+20); 
			glColor3fv(&c[8]); glVertex2fv(vtx+16);

			glColor3fv(&c[4]); glVertex2fv(vtx+16); 
			glColor3fv(&c[16]); glVertex2fv(vtx+20); 
			glColor3fv(&c[8]); glVertex2fv(vtx+28); 
			glColor3fv(&c[8]); glVertex2fv(vtx+24);

			glColor3fv(&c[4]); glVertex2fv(vtx+24); 
			glColor3fv(&c[16]); glVertex2fv(vtx+28); 
			glColor3fv(&c[8]); glVertex2fv(vtx+36); 
			glColor3fv(&c[8]); glVertex2fv(vtx+32);

			glColor3fv(&c[4]); glVertex2fv(vtx+32); 
			glColor3fv(&c[16]); glVertex2fv(vtx+36); 
			glColor3fv(&c[8]); glVertex2fv(vtx+44); 
			glColor3fv(&c[8]); glVertex2fv(vtx+40);
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = 5 * (rate/5);

		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    for(i=(rate)/5; i; i--) {
			glBegin(GL_QUADS);
			glColor3fv(&c[4]); glVertex2fv(vtx); 
			glColor3fv(&c[16]); glVertex2fv(vtx+4); 
			glColor3fv(&c[8]); glVertex2fv(vtx+12); 
			glColor3fv(&c[8]); glVertex2fv(vtx+8);

			glColor3fv(&c[4]); glVertex2fv(vtx+8); 
			glColor3fv(&c[16]); glVertex2fv(vtx+12); 
			glColor3fv(&c[8]); glVertex2fv(vtx+20); 
			glColor3fv(&c[8]); glVertex2fv(vtx+16);

			glColor3fv(&c[4]); glVertex2fv(vtx+16); 
			glColor3fv(&c[16]); glVertex2fv(vtx+20); 
			glColor3fv(&c[8]); glVertex2fv(vtx+28); 
			glColor3fv(&c[8]); glVertex2fv(vtx+24);

			glColor3fv(&c[4]); glVertex2fv(vtx+24); 
			glColor3fv(&c[16]); glVertex2fv(vtx+28); 
			glColor3fv(&c[8]); glVertex2fv(vtx+36); 
			glColor3fv(&c[8]); glVertex2fv(vtx+32);

			glColor3fv(&c[4]); glVertex2fv(vtx+32); 
			glColor3fv(&c[16]); glVertex2fv(vtx+36); 
			glColor3fv(&c[8]); glVertex2fv(vtx+44); 
			glColor3fv(&c[8]); glVertex2fv(vtx+40);
			glEnd();
		    }
		  }
		  endtest(pbuf, rate, 0);
		}

		glPopMatrix();
	    }
	    printaverage();
	} else if (mod_shade && mod_cmode) {

	    /*** POLYGONS (SHADED COLOR MAPPED) *****/

	    /* 255 = r, 240 = g, 255 = b */
	    makeramp(208, 255, 0, 0, 0, 0, 255, 16);
	    makeramp(224, 0, 0, 255, 255, 255, 0, 16);
	    makeramp(240, 255, 255, 0, 255, 0, 255, 16);

	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
                if (!mod_average)
		  sprintf(pbuf, "Angle %6.2f", angle);
		  
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);
		    for(i=(rate)/5; i; i--) {
			glBegin(GL_QUADS);
			glIndexi(255); glVertex2fv(vtx); 
			glIndexi(240); glVertex2fv(vtx+4); 
			glIndexi(223); glVertex2fv(vtx+12); 
			glIndexi(208); glVertex2fv(vtx+8);

			glIndexi(255); glVertex2fv(vtx+8); 
			glIndexi(240); glVertex2fv(vtx+12); 
			glIndexi(223); glVertex2fv(vtx+20); 
			glIndexi(208); glVertex2fv(vtx+16);

			glIndexi(255); glVertex2fv(vtx+16); 
			glIndexi(240); glVertex2fv(vtx+20); 
			glIndexi(223); glVertex2fv(vtx+28); 
			glIndexi(208); glVertex2fv(vtx+24);

			glIndexi(255); glVertex2fv(vtx+24); 
			glIndexi(240); glVertex2fv(vtx+28); 
			glIndexi(223); glVertex2fv(vtx+36); 
			glIndexi(208); glVertex2fv(vtx+32);

			glIndexi(255); glVertex2fv(vtx+32); 
			glIndexi(240); glVertex2fv(vtx+36); 
			glIndexi(223); glVertex2fv(vtx+44); 
			glIndexi(208); glVertex2fv(vtx+40);
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = 5 * (rate/5);

		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    for(i=(rate)/5; i; i--) {
			glBegin(GL_QUADS);
			glIndexi(255); glVertex2fv(vtx); 
			glIndexi(240); glVertex2fv(vtx+4); 
			glIndexi(223); glVertex2fv(vtx+12); 
			glIndexi(208); glVertex2fv(vtx+8);

			glIndexi(255); glVertex2fv(vtx+8); 
			glIndexi(240); glVertex2fv(vtx+12); 
			glIndexi(223); glVertex2fv(vtx+20); 
			glIndexi(208); glVertex2fv(vtx+16);

			glIndexi(255); glVertex2fv(vtx+16); 
			glIndexi(240); glVertex2fv(vtx+20); 
			glIndexi(223); glVertex2fv(vtx+28); 
			glIndexi(208); glVertex2fv(vtx+24);

			glIndexi(255); glVertex2fv(vtx+24); 
			glIndexi(240); glVertex2fv(vtx+28); 
			glIndexi(223); glVertex2fv(vtx+36); 
			glIndexi(208); glVertex2fv(vtx+32);

			glIndexi(255); glVertex2fv(vtx+32); 
			glIndexi(240); glVertex2fv(vtx+36); 
			glIndexi(223); glVertex2fv(vtx+44); 
			glIndexi(208); glVertex2fv(vtx+40);
			glEnd();
		    }
		  }
		  endtest(pbuf, rate, 0);
		}

		glPopMatrix();
	    }
	    printaverage();

	} else if (!mod_light && !mod_shade) {

	    /*** POLYGONS (FLAT SHADED) *****/

	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
                if (!mod_average)
		  sprintf(pbuf, "Angle %6.2f", angle);
		  
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);
		    for(i=(rate)/5; i; i--) {
			glBegin(GL_QUADS);
			glVertex2fv(vtx); glVertex2fv(vtx+4);
			glVertex2fv(vtx+12); glVertex2fv(vtx+8);

			glVertex2fv(vtx+8); glVertex2fv(vtx+12);
			glVertex2fv(vtx+20); glVertex2fv(vtx+16);

			glVertex2fv(vtx+16); glVertex2fv(vtx+20);
			glVertex2fv(vtx+28); glVertex2fv(vtx+24);

			glVertex2fv(vtx+24); glVertex2fv(vtx+28);
			glVertex2fv(vtx+36); glVertex2fv(vtx+32);

			glVertex2fv(vtx+32); glVertex2fv(vtx+36);
			glVertex2fv(vtx+44); glVertex2fv(vtx+40);
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = 5 * (rate/5);

		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    for(i=(rate)/5; i; i--) {
			glBegin(GL_QUADS);
			glVertex2fv(vtx); glVertex2fv(vtx+4);
			glVertex2fv(vtx+12); glVertex2fv(vtx+8);

			glVertex2fv(vtx+8); glVertex2fv(vtx+12);
			glVertex2fv(vtx+20); glVertex2fv(vtx+16);

			glVertex2fv(vtx+16); glVertex2fv(vtx+20);
			glVertex2fv(vtx+28); glVertex2fv(vtx+24);

			glVertex2fv(vtx+24); glVertex2fv(vtx+28);
			glVertex2fv(vtx+36); glVertex2fv(vtx+32);

			glVertex2fv(vtx+32); glVertex2fv(vtx+36);
			glVertex2fv(vtx+44); glVertex2fv(vtx+40);
			glEnd();
		    }
		  }
		  endtest(pbuf, rate, 0);
		}

		glPopMatrix();
	    }
	    printaverage();
	}

    }
    if (mod_doublebuffer) {
        auxSwapBuffers();
        Sleep(2000);               /* for visual feedback */
    }
    exit(0);
}

/* original fill rate was 25 */

#define FILL_RATE 1

static void perffill(void)
{
    int    i, j, k;
    float  boxx[5], boxy[5];
    int    boxsizes = 5;	/* must be same a boxx, and boxy
					 * size */

    boxx[0] = boxy[0] = 10;
    boxx[1] = boxy[1] = 100;
    boxx[2] = boxy[2] = 500;
    boxx[3] = 640;
    boxy[3] = 480;
    boxx[4] = xsize;
    boxy[4] = ysize;

    if (mod_z) {
	glEnable(GL_DEPTH_TEST);
	glClear(GL_DEPTH_BUFFER_BIT);
    }
    if (mod_pattern) {
	glEnable(GL_POLYGON_STIPPLE);
	glPolygonStipple((GLubyte *) pattern);
    }

    glLoadIdentity();
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (mod_2d)
	gluOrtho2D(0.0, xsize, 0.0, ysize); 
    else
	glOrtho(0.0, xsize, 0.0, ysize, 1.0, -1.0); 
    glMatrixMode(GL_MODELVIEW);

    for (j = 0; j < boxsizes; j++) {

	v[0] = 0.0;
	v[1] = 0.0;
	v[2] = 0.0;
	v[4] = boxx[j];
	v[5] = 0.0;
	v[6] = 0.0;		/* why the X.01? */
	v[8] = boxx[j];
	v[9] = boxy[j];
	v[10] = 0.0;
	v[12] = 0.0;
	v[13] = boxy[j];
	v[14] = 0.0;

	if (mod_2d && !mod_z && !mod_shade && !mod_light) {

	    printf("Using FLAT shaded 2D screen aligned rectangles - no transforms\n");
	    fflush(stdout);
	    Sleep(250);

	    /*** RECTANGLES (SCREEN ALIGNED, FLAT SHADED) *****/

	    /****** Calibration Loop ******/
	    secs = 0.0;
	    rate = FILL_RATE;
	    while (secs < (secspertest/4.0)) {
		rate = rate * 2;
		starttest(0);
		for (i = (rate); i; i--)
		    glRectf(0.0, 0.0, v[8], v[9]);

		secs = timer(1);
	    }

	    rate = rate * (secspertest / secs);
            if (rate < 1) rate = 1;
            
	    for (k = 0; k < loopcount; k++) {
	      if (starttest(k)) {
		for (i = (rate); i; i--)
		    glRectf(0.0, 0.0, v[8], v[9]);
	      }
	      pixendtest("glRect() fill", rate, (int) boxx[j], (int) boxy[j]);
	    }
	}

	if (!mod_2d) {

	    /***** 3D DRAWING *****/

	    if (mod_cmode && mod_shade) {

		/*** GOURAUD SHADED CMODE RECTANGLES, SCREEN ALIGNED ***/

		/* 255 = r, 240 = g, 255 = b */
		makeramp(208, 255, 0, 0, 0, 0, 255, 16);
		makeramp(224, 0, 0, 255, 255, 255, 0, 16);
		makeramp(240, 255, 255, 0, 255, 0, 255, 16);

		secs = 0.0;
		rate = FILL_RATE;
		while (secs < (secspertest/4.0)) {
		    rate = rate * 2;
		    starttest(0);
		    for (i = (rate); i; i--) {
			glBegin(GL_POLYGON);
			glIndexi(255);
			glVertex3fv(&v[0]);
			glIndexi(240);
			glVertex3fv(&v[4]);
			glIndexi(223);
			glVertex3fv(&v[8]);
			glIndexi(208);
			glVertex3fv(&v[12]);
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest / secs);
                if (rate < 1) rate = 1;

		for (k = 0; k < loopcount; k++) {
		  if (starttest(k)) {
		    for (i = (rate); i; i--) {
			glBegin(GL_POLYGON);
			glIndexi(255);
			glVertex3fv(&v[0]);
			glIndexi(240);
			glVertex3fv(&v[4]);
			glIndexi(223);
			glVertex3fv(&v[8]);
			glIndexi(208);
			glVertex3fv(&v[12]);
			glEnd();
		    }
		  }
		  pixendtest("rectangle fill", rate, (int) boxx[j], (int) boxy[j]);
		}

	    } else if (!mod_shade && !mod_light) {

		/*** RECTANGLES (SCREEN ALIGNED, FLAT SHADED) *****/

		/****** Calibration Loop ******/
		secs = 0.0;
		rate = FILL_RATE;
		while (secs < (secspertest/ 
4.0)) {
		    rate = rate * 2;
		    starttest(0);
		    for (i = (rate); i; i--) {
			glBegin(GL_POLYGON);
			glVertex3fv(&v[0]);
			glVertex3fv(&v[4]);
			glVertex3fv(&v[8]);
			glVertex3fv(&v[12]);
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest / secs);
                if (rate < 1) rate = 1;

		for (k = 0; k < loopcount; k++) {
		  if (starttest(k)) {
		    for (i = (rate); i; i--) {
			glBegin(GL_POLYGON);
			glVertex3fv(&v[0]);
			glVertex3fv(&v[4]);
			glVertex3fv(&v[8]);
			glVertex3fv(&v[12]);
			glEnd();
		    }
		  }
		  pixendtest("rectangle fill", rate, (int) boxx[j], (int) boxy[j]);
		}

	    } else if (!mod_cmode && mod_light) {

		/*** RECTANGLES (LIGHTED GOURAUD SHADED RBG SCREEN ALIGNED) ***/

		glLoadIdentity();
		glMatrixMode(GL_PROJECTION);
		glLoadIdentity();
		glOrtho(0.0, xsize, 0.0, ysize, 1.0, -1.0);
		glMatrixMode(GL_MODELVIEW);

		/* set lights */
		setLightingParameters();

		/****** Calibration Loop ******/
		secs = 0.0;
		rate = FILL_RATE;
		while (secs < (secspertest/4.0)) {
		    rate = rate * 2;
		    starttest(0);
		    for (i = (rate); i; i--) {
			glBegin(GL_POLYGON);
			glNormal3fv(&n[0]);
			glVertex3fv(&v[0]);
			glNormal3fv(&n[4]);
			glVertex3fv(&v[4]);
			glNormal3fv(&n[8]);
			glVertex3fv(&v[8]);
			glNormal3fv(&n[12]);
			glVertex3fv(&v[12]);
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest / secs);
                if (rate < 1) rate = 1;

		for (k = 0; k < loopcount; k++) {
		  if (starttest(k)) {
		    for (i = (rate); i; i--) {
			glBegin(GL_POLYGON);
			glNormal3fv(&n[0]);
			glVertex3fv(&v[0]);
			glNormal3fv(&n[4]);
			glVertex3fv(&v[4]);
			glNormal3fv(&n[8]);
			glVertex3fv(&v[8]);
			glNormal3fv(&n[12]);
			glVertex3fv(&v[12]);
			glEnd();
		    }
		  }
		  pixendtest("rectangle fill", rate, (int) boxx[j], (int) boxy[j]);
		}

	    } else if (!mod_cmode && mod_shade) {

		/*** RECTANGLES (SCREEN ALIGNED, RGB GOURAUD SHADED) *****/

		/****** Calibration Loop ******/
		secs = 0.0;
		rate = FILL_RATE;
		while (secs < (secspertest/4.0)) {
		    rate = rate * 2;
		    starttest(0);
		    for (i = (rate); i; i--) {
			glBegin(GL_POLYGON);
			glColor3fv(&c[4]);
			glVertex3fv(&v[0]);
			glColor3fv(&c[8]);
			glVertex3fv(&v[4]);
			glColor3fv(&c[12]);
			glVertex3fv(&v[8]);
			glColor3fv(&c[16]);
			glVertex3fv(&v[12]);
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest / secs);
                if (rate < 1) rate = 1;

		for (k = 0; k < loopcount; k++) {
		  if (starttest(k)) {
		    for (i = (rate); i; i--) {
			glBegin(GL_POLYGON);
			glColor3fv(&c[4]);
			glVertex3fv(&v[0]);
			glColor3fv(&c[8]);
			glVertex3fv(&v[4]);
			glColor3fv(&c[12]);
			glVertex3fv(&v[8]);
			glColor3fv(&c[16]);
			glVertex3fv(&v[12]);
			glEnd();
		    }
		  }
		  pixendtest("rectangle fill", rate, (int) boxx[j], (int) boxy[j]);
		}
	    }
	} else {		/***** 2D DRAWING *****/

	    if (mod_cmode && mod_shade) {

		/*** GOURAUD SHADED CMODE SCREEN ALIGNED RECTANGLES ***/
		/* 255 = r, 240 = g, 255 = b */
		makeramp(208, 255, 0, 0, 0, 0, 255, 16);
		makeramp(224, 0, 0, 255, 255, 255, 0, 16);
		makeramp(240, 255, 255, 0, 255, 0, 255, 16);

		secs = 0.0;
		rate = FILL_RATE;
		while (secs < (secspertest/4.0)) {
		    rate = rate * 2;
		    starttest(0);
		    for (i = (rate); i; i--) {
			glBegin(GL_POLYGON);
			glIndexi(255);
			glVertex2fv(&v[0]);
			glIndexi(240);
			glVertex2fv(&v[4]);
			glIndexi(223);
			glVertex2fv(&v[8]);
			glIndexi(208);
			glVertex2fv(&v[12]);
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest / secs);
                if (rate < 1) rate = 1;

		for (k = 0; k < loopcount; k++) {
		  if (starttest(k)) {
		    for (i = (rate); i; i--) {
			glBegin(GL_POLYGON);
			glIndexi(255);
			glVertex2fv(&v[0]);
			glIndexi(240);
			glVertex2fv(&v[4]);
			glIndexi(223);
			glVertex2fv(&v[8]);
			glIndexi(208);
			glVertex2fv(&v[12]);
			glEnd();
		    }
		  }
		  pixendtest("rectangle fill", rate, (int) boxx[j], (int) boxy[j]);
		}

	    } else if (!mod_shade && !mod_light) {

		/*** RECTANGLES (SCREEN ALIGNED, FLAT SHADED) *****/

		/****** Calibration Loop ******/
		secs = 0.0;
		rate = FILL_RATE;
		while (secs < (secspertest/4.0)) {
		    rate = rate * 2;
		    starttest(0);
		    for (i = (rate); i; i--) {
			glBegin(GL_POLYGON);
			glVertex2fv(&v[0]);
			glVertex2fv(&v[4]);
			glVertex2fv(&v[8]);
			glVertex2fv(&v[12]);
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest / secs);
                if (rate < 1) rate = 1;

		for (k = 0; k < loopcount; k++) {
		  if (starttest(k)) {
		    for (i = (rate); i; i--) {
			glBegin(GL_POLYGON);
			glVertex2fv(&v[0]);
			glVertex2fv(&v[4]);
			glVertex2fv(&v[8]);
			glVertex2fv(&v[12]);
			glEnd();
		    }
		  }
		  pixendtest("rectangle fill", rate, (int) boxx[j], (int) boxy[j]);
		}

	    } else if (!mod_cmode && mod_light) {

		/*** RECTANGLES (LIGHTED GOURAUD SHADED RBG SCREEN ALIGNED) ***/

		glLoadIdentity();
		glMatrixMode(GL_PROJECTION);
		glLoadIdentity();
		glOrtho(0.0, xsize, 0.0, ysize, 1.0, -1.0);
		glMatrixMode(GL_MODELVIEW);

		/* set lights */
		setLightingParameters();

		/****** Calibration Loop ******/
		secs = 0.0;
		rate = FILL_RATE;
		while (secs < (secspertest/4.0)) {
		    rate = rate * 2;
		    starttest(0);
		    for (i = (rate); i; i--) {
			glBegin(GL_POLYGON);
			glNormal3fv(&n[0]);
			glVertex2fv(&v[0]);
			glNormal3fv(&n[4]);
			glVertex2fv(&v[4]);
			glNormal3fv(&n[8]);
			glVertex2fv(&v[8]);
			glNormal3fv(&n[12]);
			glVertex2fv(&v[12]);
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest / secs);
                if (rate < 1) rate = 1;

		for (k = 0; k < loopcount; k++) {
		  if (starttest(k)) {
		    for (i = (rate); i; i--) {
			glBegin(GL_POLYGON);
			glNormal3fv(&n[0]);
			glVertex2fv(&v[0]);
			glNormal3fv(&n[4]);
			glVertex2fv(&v[4]);
			glNormal3fv(&n[8]);
			glVertex2fv(&v[8]);
			glNormal3fv(&n[12]);
			glVertex2fv(&v[12]);
			glEnd();
		    }
		  }
		  pixendtest("rectangle fill", rate, (int) boxx[j], (int) boxy[j]);
		}

	    } else if (!mod_cmode && mod_shade) {

		/*** RECTANGLES (SCREEN ALIGNED, RGB GOURAUD SHADED) *****/

		/****** Calibration Loop ******/
		secs = 0.0;
		rate = FILL_RATE;
		while (secs < (secspertest/4.0)) {
		    rate = rate * 2;
		    starttest(0);
		    for (i = (rate); i; i--) {
			glBegin(GL_POLYGON);
			glColor3fv(&c[4]);
			glVertex2fv(&v[0]);
			glColor3fv(&c[8]);
			glVertex2fv(&v[4]);
			glColor3fv(&c[12]);
			glVertex2fv(&v[8]);
			glColor3fv(&c[16]);
			glVertex2fv(&v[12]);
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest / secs);
                if (rate < 1) rate = 1;

		for (k = 0; k < loopcount; k++) {
		  if (starttest(k)) {
		    for (i = (rate); i; i--) {
			glBegin(GL_POLYGON);
			glColor3fv(&c[4]);
			glVertex2fv(&v[0]);
			glColor3fv(&c[8]);
			glVertex2fv(&v[4]);
			glColor3fv(&c[12]);
			glVertex2fv(&v[8]);
			glColor3fv(&c[16]);
			glVertex2fv(&v[12]);
			glEnd();
		    }
		  }
		  pixendtest("rectangle fill", rate, (int) boxx[j], (int) boxy[j]);
		}
	    }
	}
    }
    exit(0);
}



static void perfpixels(void)
{
    long i, k;
    long iw, ih;
    unsigned long  *pixels;

    unsigned long pix;
    long npixels, j, imgwid[5], imght[5], numimges = 5;

    imgwid[0] = imght[0] = 10;
    imgwid[1] = imght[1] = 100;
    imgwid[2] = imght[2] = 500;
    imgwid[3] = 640; imght[3] = 480;
    imgwid[4] = xsize; imght[4] = ysize;
    npixels = xsize * ysize;

    pixels = (unsigned long *) malloc(npixels * sizeof(unsigned long));
    
    printf("DMA test.  No modifiers have any effect\n");
    printf("Pixel Writes:\n");
    fflush(stdout);
    Sleep(250);

    for (i = 0, pix = 0x7b8c9eaf; i < npixels; i++) {
	pix = (pix * 8191) + 0x70615243;
	pixels[i] = pix;
    }

    /* fill from top to bottom */
    /* pixmode(PM_TTOB,1); not available in OpenGL */

    glClearColor(c[0], c[1], c[2], c[3]);


    /**** 32 BIT PIXEL WRITES ****/
    for (j = 0; j < numimges; j++) {
	iw = imgwid[j];
	ih = imght[j];

	glClear(GL_COLOR_BUFFER_BIT);

	/****** Calibration Loop ******/
	secs = 0.0;
	rate = 15;
	while (secs < (secspertest/4.0)) {
	    rate = rate * 2;
	    starttest(0);
	    for (i = (rate); i; i--) {
		/* lrectwrite(1, 1, iw, ih, pixels); */
		glRasterPos2f(-0.5 * xsize, -0.5 * ysize);
		glDrawPixels(iw, ih, GL_RGBA, GL_BYTE, pixels);
	    }

	    secs = timer(1);
	}
	rate = rate * (secspertest / secs);

	for (k = 0; k < loopcount; k++) {
	  if (starttest(k)) {
	    for (i = (rate); i; i--) {
		glRasterPos2f(-0.5 * xsize, -0.5 * ysize);
		glDrawPixels(iw, ih, GL_RGBA, GL_BYTE, pixels);
	    }
	  }
	  pixendtest("32-bit Pixel Write", rate, iw, ih);
	}
    }


    printf("\n");
    fflush(stdout);
    Sleep(250);

    /*
     * This is not quite right.  I think the correct way would be to get
     * a colorindex visual and use that as the target of our writes.
     */
    /**** 8 BIT PIXEL WRITES ****/
    for (j = 0; j < numimges; j++) {
	iw = imgwid[j];
	ih = imght[j];
	glClear(GL_COLOR_BUFFER_BIT);

	/****** Calibration Loop ******/
	secs = 0.0;
	rate = 15;
	while (secs < (secspertest/4.0)) {
	    rate = rate * 2;
	    starttest(0);
	    for (i = (rate); i; i--) {
		glRasterPos2i(1, 1);
		glDrawPixels(iw, ih, GL_RED, GL_BYTE, pixels);
	    }

	    secs = timer(1);
	}
	rate = rate * (secspertest / secs);

	for (k = 0; k < loopcount; k++) {
	  if (starttest(k)) {
	    for (i = (rate); i; i--) {
		glRasterPos2i(1, 1);
		glDrawPixels(iw, ih, GL_RED, GL_BYTE, pixels);
	    }
	  }
	  pixendtest("8-bit Pixel Write", rate, iw, ih);
	}
    }

    printf("\n");
    printf("Pixel Reads:\n");
    fflush(stdout);
    Sleep(250);

    for (i=0; i< npixels; i++) {
	pixels[i] = 0;
    }


    /**** PIXEL READS *****/
    /* make a polygon to read */
    {
	float myv1[3], myv2[3], myv3[3], myv4[3];
	myv1[0] = myv4[0] = -0.5*xsize,
	myv2[0] = myv3[0] = 0.5*xsize;
	myv1[1] = myv2[1] = -0.5*ysize;
	myv3[1] = myv4[1] = 0.5*ysize;
	myv1[2] = myv2[2] =  myv3[2] = myv4[2] = 0.0;

	glBegin(GL_POLYGON);
	glColor3fv(&c[4]);
	glVertex3fv(myv1);
	glColor3fv(&c[8]);
	glVertex3fv(myv2);
	glColor3fv(&c[12]);
	glVertex3fv(myv3);
	glColor3fv(&c[28]);
	glVertex3fv(myv4);
	glEnd();
    }


    /**** 32 BIT PIXEL READS ****/
    for (j = 0; j < numimges; j++) {
	iw = imgwid[j];
	ih = imght[j];

	/****** Calibration Loop ******/
	secs = 0.0; 
	rate = 15;
	while (secs < (secspertest/4.0)) {
	    rate = rate*2;
	    starttest(0);
	    for(i=(rate); i; i--) {
		/* lrectread(1, 1, iw, ih, pixels); */
		glReadPixels(-0.5 * xsize, -0.5 * ysize, iw, ih, 
			     GL_RGBA, GL_BYTE, pixels);
	    }

	    secs = timer(1);
	}
	rate = rate * (secspertest/secs);

	for (k=0; k<loopcount; k++) {
	  if (starttest(k)) {
	    for(i=(rate); i; i--) {
		glReadPixels(-0.5 * xsize, -0.5 * ysize, iw, ih, 
			     GL_RGBA, GL_BYTE, pixels);
	    }
	  }
	  pixendtest ("32-bit Pixel Read", rate, iw, ih);
	}
    }


    printf("\n");
    fflush(stdout);
    Sleep(250);

    /*** 8 BIT PIXEL READS ******/

    for (j = 0; j < numimges; j++) {
	iw = imgwid[j];
	ih = imght[j];

	/****** Calibration Loop ******/
	secs = 0.0; 
	rate = 15;
	while (secs < (secspertest/4.0)) {
	    rate = rate*2;
	    starttest(0);
	    for(i=(rate); i; i--) {
		glReadPixels(-0.5 * xsize, -0.5 * ysize, iw, ih, 
			     GL_RED, GL_BYTE, pixels);
	    }

	    secs = timer(1);
	}
	rate = rate * (secspertest/secs);

	for (k=0; k<loopcount; k++) {
	  if (starttest(k)) {
	    for(i=(rate); i; i--) {
		glReadPixels(-0.5 * xsize, -0.5 * ysize, iw, ih, 
			     GL_RED, GL_BYTE, pixels);
	    }
	  }
	  pixendtest("8-bit Pixel Read", rate, iw, ih);
	}
    }
}

static void perfclear(void)
{
    long            viewwd, viewht;
    long	    winwd[5], winht[5];
    long	    numscreens = 5; /* should be same size as win arrays */
    long            zval;
    int    i, j, k;
    char   pbuf[80];

    winwd[0] = 100;
    winht[0] = 100;
    winwd[1] = 500;
    winht[1] = 500;
    winwd[2] = 640;
    winht[2] = 480;
    winwd[3] = xsize;
    winht[3] = ysize;
    winwd[4] = 1;
    winht[4] = 1;

    glDisable(GL_DITHER);

    for (j = 0; j < numscreens; j++) {
	viewwd = winwd[j];
	viewht = winht[j];
	glEnable(GL_SCISSOR_TEST);
	glScissor(0, 0, viewwd - 1, viewht - 1);

	if (mod_z) {		/* include clearing the zbuffer */

	    glClearDepth(1.0);

	    /** USING glClear(COLOR); glClear(DEPTH) **/

	    if (!mod_cmode) {
		glClearColor(c[16], c[17], c[18], c[19]);
	    } else {
		glClearIndex(YELLOW);
	    }

	    glFlush();
	    sum_secs = 0.0;
	    sum_n = 0;

	    /****** Calibration Loop ******/
	    secs = 0.0;
	    rate = 125;
	    while (secs < (secspertest/4.0)) {
		rate = rate * 2;
		starttest(0);
		for (i = (rate); i; i--) {
		    glClear(GL_COLOR_BUFFER_BIT);
		    glClear(GL_DEPTH_BUFFER_BIT);
		}

		secs = timer(1);
	    }

	    /** Do the real thing **/
	    rate = rate * (secspertest / secs);
	    for (k = 0; k < loopcount; k++) {
	      if (starttest(k)) {
		for (i = rate; i; i--) {
		    glClear(GL_COLOR_BUFFER_BIT);
		    glClear(GL_DEPTH_BUFFER_BIT);
		}
		sprintf(pbuf, "glClear(COLOR); glClear(DEPTH); clear screen size %ld %ld",
			viewwd, viewht);
	      }
	      clearendtest(pbuf, rate, viewwd * viewht);
	    }

	    glFlush();
	    sum_secs = 0.0;
	    sum_n = 0;

	    /****** Calibration Loop ******/

	    /** USING glClear(COLOR|DEPTH) **/

	    if (!mod_cmode) {
		glClearColor(c[8], c[9], c[10], c[11]);
	    } else {
		glClearIndex(BLUE);
	    }

	    secs = 0.0;
	    rate = 125;
	    while (secs < (secspertest/4.0)) {
		rate = rate * 2;
		starttest(0);
		for (i = (rate); i; i--) {
		    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
		}
		    
		secs = timer(1);
	    }
	    rate = rate * (secspertest / secs);
	    for (k = 0; k < loopcount; k++) {
	      if (starttest(k)) {
		for (i = (rate); i; i--) {
		    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
		}
		sprintf(pbuf, "glClear(COLOR|DEPTH)  clear screen size %ld %ld",
			viewwd, viewht);
	      }
	      clearendtest(pbuf, rate, viewwd * viewht);
	    }
	} else {		/* no z buffering */
	    
	    /** JUST PLAIN OLD CLEAR() */
	    
	    if (mod_cmode) {
		glClearIndex(CYAN);
	    } else {
		glClearColor(c[24], c[25], c[26], c[27]);
	    }

	    sum_secs = 0.0;
	    sum_n = 0;
	    sprintf(pbuf, "clear screen size %ld %ld", viewwd, viewht);

	    /****** Calibration Loop ******/
	    secs = 0.0;
	    rate = 125;
	    while (secs < (secspertest/4.0)) {
		rate = rate * 2;
		starttest(0);
		for (i = (rate); i; i--)
		    glClear(GL_COLOR_BUFFER_BIT);

		secs = timer(1);
	    }
	    rate = rate * (secspertest / secs);
	    for (k = 0; k < loopcount; k++) {
	      if (starttest(k)) {
		for (i = (rate); i; i--)
		    glClear(GL_COLOR_BUFFER_BIT);
	      }
	      clearendtest(pbuf, rate, viewwd * viewht);
	    }
	}
	if (mod_cmode) {
	    glClearIndex(BLACK);
	} else {
	    glClearColor(c[0], c[1], c[2], c[3]);
	}
	glClear(GL_COLOR_BUFFER_BIT);
    }
    exit(0);
}


static void perfqstrip(void)
{
    int i,j,k;
    char pbuf[80];

    /* Triangle mesh tests:  Each qstrip contains 62 vertices, or	*/
    /* 60 triangles.  To make the calculation exact, the rate	*/
    /* must be a multiple of 60.					*/

    if (!mod_2d) {
	if (mod_cmode && mod_shade) {

	    /*** GOURAUD SHADED CMODE QSTRIP ***/
	    /* 255 = r, 240 = g, 255 = b */
	    makeramp(208,255,0,0,0,0,255,16);
	    makeramp(224,0,0,255,255,255,0,16);
	    makeramp(240,255,255,0,255,0,255,16);

	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);
		    for(i=(rate)/30; i; i--) {
			glBegin(GL_QUAD_STRIP);
			for (j=0; j<32; j+=2) {
			    glIndexi(255);
			    glVertex3fv(&v[j*4]);
			    glIndexi(240);
			    glVertex3fv(&v[(j+1)*4]);
			}
			for (j=28; j>=0; j-=2) {
			    glIndexi(223);
			    glVertex3fv(&v[j*4]);
			    glIndexi(208);
			    glVertex3fv(&v[(j+1)*4]);
			}
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = 60 * (rate/30);

		/* Do the real thing GOURAUD shaded Cmode qstrip */
		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    for(i=(rate)/30; i; i--) {
			glBegin(GL_QUAD_STRIP);
			for (j=0; j<32; j+=2) {
			    glIndexi(255);
			    glVertex3fv(&v[j*4]);
			    glIndexi(240);
			    glVertex3fv(&v[(j+1)*4]);
			}
			for (j=28; j>=0; j-=2) {
			    glIndexi(223);
			    glVertex3fv(&v[j*4]);
			    glIndexi(208);
			    glVertex3fv(&v[(j+1)*4]);
			}
			glEnd();
		    }
                    if (!mod_average)
		      sprintf (pbuf, "Angle %6.2f", angle);
		  }
		  endtest(pbuf, rate, 0);
		}

		glPopMatrix();
	    }
	    printaverage ();

	} else if (!mod_light && !mod_shade) {

	    /*** FLAT SHADED QSTRIP ***/
	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);
		    for(i=(rate)/30; i; i--) {
			glBegin(GL_QUAD_STRIP);
			for (j=0; j<32; j++) {
			    glVertex3fv(&v[j*4]);
			}
			for (j=28; j>=0; j-=2) {
			    glVertex3fv(&v[j*4]);
			    glVertex3fv(&v[(j+1)*4]);
			}
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = 60 * (rate/30);
	    
		/* Do the real thing - FLAT shaded qstrip */
		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    for(i=(rate)/30; i; i--) {
			glBegin(GL_QUAD_STRIP);
			for (j=0; j<32; j++) {
			    glVertex3fv(&v[j*4]);
			}
			for (j=28; j>=0; j-=2) {
			    glVertex3fv(&v[j*4]);
			    glVertex3fv(&v[(j+1)*4]);
			}
			glEnd();
		    }
                    if (!mod_average)
		      sprintf(pbuf, "Angle %6.2f", angle);
		  }
		  endtest(pbuf, rate, 0);
		}
		glPopMatrix();
	    }
	    printaverage();

	} else if (!mod_cmode && mod_light) {

	    /*** LIGHTED RGB QSTRIP ***/

	    glLoadIdentity();

	    glMatrixMode(GL_PROJECTION);
	    glLoadIdentity();
	    glOrtho(-0.5*xsize,0.5*xsize,-0.5*ysize,0.5*ysize,1.0,-1.0);
	    glMatrixMode(GL_MODELVIEW);

	    /* set lights */
	    setLightingParameters();

	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);

		    for(i=(rate)/30; i; i--) {
			glBegin(GL_QUAD_STRIP);
			for (j=0; j<32; j+=2) {
			    glNormal3fv(&n[0]);
			    glVertex3fv(&v[j*4]);
			    glNormal3fv(&n[4]);
			    glVertex3fv(&v[(j+1)*4]);
			}
			for (j=28; j>=0; j-=2) {
			    glNormal3fv(&n[8]);
			    glVertex3fv(&v[j*4]);
			    glNormal3fv(&n[12]);
			    glVertex3fv(&v[(j+1)*4]);
			}
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = 60 * (rate/30);

		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    for(i=(rate)/30; i; i--) {
			glBegin(GL_QUAD_STRIP);
			for (j=0; j<32; j+=2) {
			    glNormal3fv(&n[0]);
			    glVertex3fv(&v[j*4]);
			    glNormal3fv(&n[4]);
			    glVertex3fv(&v[(j+1)*4]);
			}
			for (j=28; j>=0; j-=2) {
			    glNormal3fv(&n[8]);
			    glVertex3fv(&v[j*4]);
			    glNormal3fv(&n[12]);
			    glVertex3fv(&v[(j+1)*4]);
			}
			glEnd();
		    }
                    if (!mod_average)
		      sprintf(pbuf, "Angle %6.2f", angle);
		  }
		  endtest(pbuf, rate, 0);
		}
		glPopMatrix();
	    }
	    printaverage();

	} else if (!mod_cmode && mod_shade) {

	    /*** GOURAUD SHADED RGB TMESH ***/
	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);
		    for(i=(rate)/30; i; i--) {
			glBegin(GL_QUAD_STRIP);
			for (j=0; j<32; j+=2) {
			    glColor3fv(&c[16]);
			    glVertex3fv(&v[j*4]);
			    glColor3fv(&c[20]);
			    glVertex3fv(&v[(j+1)*4]);
			}
			for (j=28; j>=0; j-=2) {
			    glColor3fv(&c[4]);
			    glVertex3fv(&v[j*4]);
			    glColor3fv(&c[8]);
			    glVertex3fv(&v[(j+1)*4]);
			}
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = 60 * (rate/30);

		/* Do the real thing GOURAUD shaded qstrip */
		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    for(i=(rate)/30; i; i--) {
			glBegin(GL_QUAD_STRIP);
			for (j=0; j<32; j+=2) {
			    glColor3fv(&c[16]);
			    glVertex3fv(&v[j*4]);
			    glColor3fv(&c[20]);
			    glVertex3fv(&v[(j+1)*4]);
			}
			for (j=28; j>=0; j-=2) {
			    glColor3fv(&c[4]);
			    glVertex3fv(&v[j*4]);
			    glColor3fv(&c[8]);
			    glVertex3fv(&v[(j+1)*4]);
			}
			glEnd();
		    }
		  }
                  if (!mod_average)
		    sprintf(pbuf, "Angle %6.2f", angle);
		    
		  endtest(pbuf, rate, 0);
		}

		glPopMatrix();
	    }
	    printaverage();
	}

    } else {	/* must be 2d */
	if (mod_cmode && mod_shade) { /* color map lighting yet */

	    /*** GOURAUD SHADED CMODE TMESH ***/
	    /* 255 = r, 240 = g, 255 = b */
	    makeramp(208,255,0,0,0,0,255,16);
	    makeramp(224,0,0,255,255,255,0,16);
	    makeramp(240,255,255,0,255,0,255,16);

	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);

		    for(i=(rate)/30; i; i--) {
			glBegin(GL_QUAD_STRIP);
			for (j=0; j<32; j+=2) {
			    glIndexi(255);
			    glVertex2fv(&v[j*4]);
			    glIndexi(240);
			    glVertex2fv(&v[(j+1)*4]);
			}
			for (j=28; j>=0; j-=2) {
			    glIndexi(223);
			    glVertex2fv(&v[j*4]);
			    glIndexi(208);
			    glVertex2fv(&v[(j+1)*4]);
			}
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = 60 * (rate/30);

		/* Do the real thing GOURAUD shaded Cmode qstrip */
		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    for(i=(rate)/30; i; i--) {
			glBegin(GL_QUAD_STRIP);
			for (j=0; j<32; j+=2) {
			    glIndexi(255);
			    glVertex2fv(&v[j*4]);
			    glIndexi(240);
			    glVertex2fv(&v[(j+1)*4]);
			}
			for (j=28; j>=0; j-=2) {
			    glIndexi(223);
			    glVertex2fv(&v[j*4]);
			    glIndexi(208);
			    glVertex2fv(&v[(j+1)*4]);
			}
			glEnd();
		    }
		  }
                  if (!mod_average)
		    sprintf(pbuf, "Angle %6.2f", angle);
		    
		  endtest(pbuf, rate, 0);
		}

		glPopMatrix();
	    }
	    printaverage();

	} else if (!mod_light && !mod_shade) {

	    /*** FLAT SHADED QSTRIP ***/
	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);

		    for(i=(rate)/30; i; i--) {
			glBegin(GL_QUAD_STRIP);
			for (j=0; j<32; j++) {
			    glVertex2fv(&v[j*4]);
			}
			for (j=28; j>=0; j-=2) {
			    glVertex2fv(&v[j*4]);
			    glVertex2fv(&v[(j+1)*4]);
			}
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = 60 * (rate/30);
	    
		/* Do the real thing - FLAT shaded qstrip */
		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    for(i=(rate)/30; i; i--) {
			glBegin(GL_QUAD_STRIP);
			for (j=0; j<32; j++) {
			    glVertex2fv(&v[j*4]);
			}
			for (j=28; j>=0; j-=2) {
			    glVertex2fv(&v[j*4]);
			    glVertex2fv(&v[(j+1)*4]);
			}
			glEnd();
		    }
		  }
                  if (!mod_average)
		    sprintf(pbuf, "Angle %6.2f", angle);
		    
		  endtest(pbuf, rate, 0);
		}
		glPopMatrix();
	    }
	    printaverage();

	} else if (!mod_cmode && mod_light) {

	    /*** LIGHTED RGB QSTRIP ***/

	    glLoadIdentity();
	    
	    glMatrixMode(GL_PROJECTION);
	    glLoadIdentity();
	    glOrtho(-0.5*xsize,0.5*xsize,-0.5*ysize,0.5*ysize,1.0,-1.0);
	    glMatrixMode(GL_MODELVIEW);

	    /* set lights */
	    setLightingParameters();

	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);
		    for(i=(rate)/30; i; i--) {
			glBegin(GL_QUAD_STRIP);
			for (j=0; j<32; j+=2) {
			    glNormal3fv(&n[0]);
			    glVertex2fv(&v[j*4]);
			    glNormal3fv(&n[4]);
			    glVertex2fv(&v[(j+1)*4]);
			}
			for (j=28; j>=0; j-=2) {
			    glNormal3fv(&n[8]);
			    glVertex2fv(&v[j*4]);
			    glNormal3fv(&n[12]);
			    glVertex2fv(&v[(j+1)*4]);
			}
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = 60 * (rate/30);

		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    for(i=(rate)/30; i; i--) {
			glBegin(GL_QUAD_STRIP);
			for (j=0; j<32; j+=2) {
			    glNormal3fv(&n[0]);
			    glVertex2fv(&v[j*4]);
			    glNormal3fv(&n[4]);
			    glVertex2fv(&v[(j+1)*4]);
			}
			for (j=28; j>=0; j-=2) {
			    glNormal3fv(&n[8]);
			    glVertex2fv(&v[j*4]);
			    glNormal3fv(&n[12]);
			    glVertex2fv(&v[(j+1)*4]);
			}
			glEnd();
		    }
		  }
                  if (!mod_average)
		    sprintf(pbuf, "Angle %6.2f", angle);
		    
		  endtest(pbuf, rate, 0);
		}
		glPopMatrix();
	    }
	    printaverage();

	} else if (!mod_cmode && mod_shade) {

	    /*** GOURAUD SHADED RGB TMESH ***/
	    sum_secs = 0.0;
	    sum_n = 0;
	    for (angle = 2.0; angle < 360.0; angle += 22.5) {
		glPushMatrix();
		glRotatef(angle-90.0, 0, 0, 1);

		/****** Calibration Loop ******/
		secs = 0.0; rate = 125;
		while (secs < (secspertest/4.0)) {
		    rate = rate*2;
		    starttest(0);
		    for(i=(rate)/30; i; i--) {
			glBegin(GL_QUAD_STRIP);
			for (j=0; j<32; j+=2) {
			    glColor3fv(&c[16]);
			    glVertex2fv(&v[j*4]);
			    glColor3fv(&c[20]);
			    glVertex2fv(&v[(j+1)*4]);
			}
			for (j=28; j>=0; j-=2) {
			    glColor3fv(&c[4]);
			    glVertex2fv(&v[j*4]);
			    glColor3fv(&c[8]);
			    glVertex2fv(&v[(j+1)*4]);
			}
			glEnd();
		    }

		    secs = timer(1);
		}
		rate = rate * (secspertest/secs);
		rate = 60 * (rate/30);

		/* Do the real thing GOURAUD shaded qstrip */
		for (k=0; k<loopcount; k++) {
		  if (starttest(k)) {
		    for(i=(rate)/30; i; i--) {
			glBegin(GL_QUAD_STRIP);
			for (j=0; j<32; j+=2) {
			    glColor3fv(&c[16]);
			    glVertex2fv(&v[j*4]);
			    glColor3fv(&c[20]);
			    glVertex2fv(&v[(j+1)*4]);
			}
			for (j=28; j>=0; j-=2) {
			    glColor3fv(&c[4]);
			    glVertex2fv(&v[j*4]);
			    glColor3fv(&c[8]);
			    glVertex2fv(&v[(j+1)*4]);
			}
			glEnd();
		    }
		  }
                  if (!mod_average)
		    sprintf(pbuf, "Angle %6.2f", angle);
		    
		  endtest(pbuf, rate, 0);
		}

		glPopMatrix();
	    }
	    printaverage();

	}
    }
    if (mod_doublebuffer) {
        auxSwapBuffers();
        Sleep(2000);               /* for visual feedback */
    }
    exit(0);
}



#ifdef PORTME
static void buildAttributeList(int *list, int mod_cmode, int mod_z)
{
    if (!mod_cmode) {
	*list++ = GLX_RGBA;
	*list++ = GLX_RED_SIZE; *list++ = 1;
	*list++ = GLX_GREEN_SIZE; *list++ = 1;
	*list++ = GLX_BLUE_SIZE; *list++ = 1;
    }
    
    if (mod_z) {
	*list++ = GLX_DEPTH_SIZE; 
	*list++ = 1;
    }

    *list = None;
}


static Colormap buildColormap(XVisualInfo *vis, int mod_cmode)
{
    Colormap cmap;
    XColor col;
    int i;

    if (mod_cmode) {
	XColor col;
	
	cmap = XCreateColormap(theDisplay, 
			       RootWindow(theDisplay, vis->screen),
			       vis->visual, AllocAll);

	/* create default entries */
	col.flags = DoRed | DoGreen | DoBlue;
	for (i = BLACK; i <= WHITE; i++) {
	    col.pixel = i;
	    col.red = (i % 2 == 1) ? 0xffff : 0;
	    col.green = ((i >> 1) % 2 == 1) ? 0xffff : 0;
	    col.blue = ((i >> 2) % 2 == 1) ? 0xffff : 0;

	    XStoreColor(theDisplay, cmap, &col);
	}
    }
    else
	cmap= XCreateColormap(theDisplay, 
			      RootWindow(theDisplay, vis->screen),
			      vis->visual, AllocNone);
    
    return cmap;
}
    

static Bool WaitForNotify(Display *d, XEvent *e, char *arg) {
    return (e->type == MapNotify) && (e->xmap.window == (Window)arg);
}
#endif

static void print_usage (char *str)
{
    printf ("%s - Usage:\n", str);
    printf ("gpt <test> [<modifiers>] [loop count] [duration]\n");

    printf ("\nValid tests:\n");
    printf ("    xform    Test transform rate\n");
    printf ("    fill     Test fill rate\n");
    printf ("    dma      Test DMA rate\n");
    printf ("    char     Test character drawing rate\n");
    printf ("    line     Test line drawing rate\n");
    printf ("    poly     Test polygon drawing rate\n");
    printf ("    tmesh    Test Triangle mesh drawing rate\n");
    printf ("    qstrip   Test Quad strip rate\n");
    printf ("    clear    Test screen clear rate\n");
    printf ("    texture  Test Texture mapped rate (Not implemented)\n");
 				      
    printf ("\nValid modifiers:\n");
    printf ("    +2d       Restrict transform to 2D, use glVertex2fv\n");
    printf ("    +z        Enable Z buffering\n");
    printf ("    +shade    Enable Gouraud shading\n");
    printf ("    +cmode    Use color index mode (Limited support)\n");
    printf ("    +1ilight  Enable 1 infinite light\n");
    printf ("    +2ilight  Enable 2 infinite lights\n");
    printf ("    +4ilight  Enable 4 infinite lights\n");
    printf ("    +1llight  Enable 1 local light\n");
    printf ("    +2llight  Enable 2 local lights\n");
    printf ("    +4llight  Enable 4 local lights\n");
    printf ("    +lmcolor  Enable colored lighted vertices\n");
    printf ("    +depth    Enable depth cueing (Lines only) \n");
    printf ("    +aa       Enable anti-aliasing (Points and lines only)\n");
    printf ("    +snap     Set subpixel FALSE (Fast path for PI).\n");
    printf ("    +dashed   Enable dashed lines.\n");
    printf ("    +width    Set line width, +width n (n = 0-9 pixels)\n");
    printf ("    +pattern  Enable pattern filling.\n");
    printf ("    +oldwindow  Open window at (100,900)-(100,650)\n");
    printf ("    +brief    Brief text output\n");
    printf ("    +backface Sets frontface or backface to cull primitives\n");
    printf ("    +dlist    Use display lists\n");
    printf ("    +db       Use double-buffered pixel format\n");
    printf ("    +avg      Print averages only\n");
}

static void badparam(int param, char *paramstr)
{
    if (param) printf ("%s ",paramstr);
}

void reshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);

    if (mod_2d)
	gluOrtho2D(-0.5*xsize, 0.5*xsize,-0.5*ysize, 0.5*ysize);
    else
	glOrtho(-0.5*xsize, 0.5*xsize,-0.5*ysize, 0.5*ysize,1.0, -1.0);
}


main(int argc, char *argv[])
{
    int	test_xform = 0;
    int	test_fill = 0;
    int	test_dma = 0;
    int	test_char = 0;
    int	test_line = 0;
    int	test_poly = 0;
    int	test_tmesh = 0;
    int	test_clear = 0;
    int	test_texture = 0;
    int test_qstrip = 0;

    int	i;

    char pbuf[80];
    char pbuf2[80];

    extern void bzero(void *, int);

    /* print something so that console window pops up before graphics */
    printf("\n");
    
    /* Data initialization.					*/
    /* These are malloced and assigned so we get quad alignment	*/

    v = (float *)malloc ((NVERT+1)*4*sizeof(float));
    v = (float *)QUAD_ROUND((int)v);

    mv = (float *)malloc ((NVERT+1)*4*sizeof(float));
    mv = (float *)QUAD_ROUND((int)mv);

    n = (float *)malloc ((NNORM+1)*4*sizeof(float));
    n = (float *)QUAD_ROUND((int)n);

    c = (float *)malloc ((NCOLR+1)*4*sizeof(float));
    c = (float *)QUAD_ROUND((int)c);

    for (i=0; i<NVERT; i++) {
	v[4*i] = ((i&0x01) ? 20.0 : 10.0);
	v[(4*i)+1] = 10.0*((i>>1)+1);
	v[(4*i)+2] = 0.0;
	v[(4*i)+3] = 1.0;

	mv[4*i] = ((i&0x01) ? 30.0 : 10.0);
	mv[(4*i)+1] = 20.0*((i>>1)+1);
	mv[(4*i)+2] = 0.0;
	mv[(4*i)+3] = 1.0;

/*
	printf("v[%d]=%7.3f v[%d]=%7.3f v[%d]=%7.3f v[%d]=%7.3f\n",4*i,v[4*i],
						       4*i+1,v[4*i+1],
						       4*i+2,v[4*i+2],
						       4*i+3,v[4*i+3]);
*/
    }




    n[0]=1.0; n[1]=0.0; n[2]=0.0; n[3]=0.0;
    n[4]=0.0; n[5]=1.0; n[6]=0.0; n[7]=0.0;
    n[8]=0.0; n[9]=0.0; n[10]=1.0; n[11]=0.0;
    n[12]=0.0; n[13]=M_SQRT1_2; n[14]=M_SQRT1_2; n[15]=0.0;

    c[0]=0.0; c[1]=0.0; c[2]=0.0; c[3]=0.0;
    c[4]=1.0; c[5]=0.0; c[6]=0.0; c[7]=0.0;
    c[8]=0.0; c[9]=1.0; c[10]=0.0; c[11]=0.0;
    c[12]=0.0; c[13]=0.0; c[14]=1.0; c[15]=0.0;
    c[16]=1.0; c[17]=1.0; c[18]=0.0; c[19]=0.0;
    c[20]=1.0; c[21]=0.0; c[22]=1.0; c[23]=0.0;
    c[24]=0.0; c[25]=1.0; c[26]=1.0; c[27]=0.0;
    c[28]=1.0; c[29]=1.0; c[30]=1.0; c[31]=0.0;

    /* Process command line arguments		*/
    /* First, check for which test is specified	*/

    if (argc <= 1) {
	print_usage ("");
	exit (1);
    }

    if (strcmp (argv[1], "xform") == 0)
	test_xform = 1;
    else if (strcmp (argv[1], "fill") == 0)
	test_fill = 1;
    else if (strcmp (argv[1], "dma") == 0)
	test_dma = 1;
    else if (strcmp (argv[1], "char") == 0)
	test_char = 1;
    else if (strcmp (argv[1], "line") == 0)
	test_line = 1;
    else if (strcmp (argv[1], "poly") == 0)
	test_poly = 1;
    else if (strcmp (argv[1], "tmesh") == 0)
	test_tmesh = 1;
    else if (strcmp (argv[1], "clear") == 0)
	test_clear = 1;
    else if (strcmp (argv[1], "qstrip") == 0)
	test_qstrip = 1;
    else if (strcmp (argv[1], "texture") == 0) {
	printf("Texture not implemented yet \n");
	exit(1);
    } else {
	print_usage ("Invalid test");
	exit (1);
    }

    /* Next, check for modifiers	*/

    for (i=2; i<argc; i++) {
	if (*(argv[i]) != '+') break;

	if (strcmp (argv[i], "+2d") == 0)
	    mod_2d = 1;
	else if (strcmp (argv[i], "+z") == 0)
	    mod_z = 1;
	else if (strcmp (argv[i], "+shade") == 0)
	    mod_shade = 1;
	else if (strcmp (argv[i], "+cmode") == 0)
	    mod_cmode = 1;
	else if (strcmp (argv[i], "+1ilight") == 0)
	    mod_1ilight = 1;
	else if (strcmp (argv[i], "+2ilight") == 0)
	    mod_2ilight = 1;
	else if (strcmp (argv[i], "+4ilight") == 0)
	    mod_4ilight = 1;
	else if (strcmp (argv[i], "+1llight") == 0)
	    mod_1llight = 1;
	else if (strcmp (argv[i], "+2llight") == 0)
	    mod_2llight = 1;
	else if (strcmp (argv[i], "+4llight") == 0)
	    mod_4llight = 1;
	else if (strcmp (argv[i], "+lmcolor") == 0)
	    mod_lmcolor = 1;
	else if (strcmp (argv[i], "+depth") == 0)
	    mod_depth = 1;
	else if (strcmp (argv[i], "+aa") == 0)
	    mod_aa = 1;
	else if (strcmp (argv[i], "+snap") == 0)
	    mod_snap = 1;
	else if (strcmp (argv[i], "+dashed") == 0)
	    mod_dashed = 1;
	else if (strcmp (argv[i], "+oldwindow") == 0)
	    mod_oldwindow = 1;
	else if (strcmp (argv[i], "+brief") == 0)
	    mod_brief = 1;
	else if (strcmp (argv[i], "+backface") == 0)
	    mod_backface = 1;
	else if (strcmp (argv[i], "+bigger") == 0)
	    { mod_bigger = 1; printf("bigger\n"); }
	else if (strcmp (argv[i], "+width") == 0) {
	    if ((i+1 < argc) && ((*(argv[i+1]) >= '0') || (*(argv[i+1]) <= '9'))) {
		mod_width = 1;
		line_width = atoi(argv[i+1]);
		i++;
	    } 
	}
	else if (strcmp (argv[i], "+pattern") == 0)
	    mod_pattern = 1;
        else if (strcmp (argv[i], "+dlist") == 0)
            useList = GL_TRUE;
        else if (strcmp (argv[i], "+db") == 0)
            mod_doublebuffer = 1;
        else if (strcmp (argv[i], "+avg") == 0)
            mod_average = 1;
	else {
	    sprintf(pbuf,"%s: Invalid modifier\n",argv[i]);
	    print_usage (pbuf);
	    exit (1);
	}
    }

    /* Finally, check if count and duration were specified	*/

    /* make sure we have a digit here */
    if ((i < argc) && ((*(argv[i]) < '0') || (*(argv[i]) > '9'))) {
	print_usage ("Invalid argument");
	exit (1);
    }

    secspertest = 1.0;
    loopcount = 1;
    if (i < argc) {
	loopcount = atoi(argv[i]);
	if (loopcount <= 0) loopcount = 1;
    }

    i++;
    if (i < argc) {
	secspertest = atof(argv[i]);
	if (secspertest < 0.1) secspertest = 1.0;
    }

    /*--------------------------------------------------------*/
    /* check for unsupported or unimplemented combinations   */
    /*--------------------------------------------------------*/

    if (mod_bigger && (!test_tmesh)) {
	printf("+bigger only works on tmesh\n");
	exit (1);
    }

    if (mod_backface && (!test_tmesh || !test_poly || !test_qstrip)) {
	printf("+backface only works on tmesh, poly or qstrip\n");
	exit(1);
    }

    if (mod_1ilight || mod_2ilight || mod_4ilight || mod_lmcolor ||
        	       mod_1llight || mod_2llight || mod_4llight)
        mod_light = 1;
        
    if (mod_lmcolor && !(mod_1ilight || mod_2ilight || mod_4ilight ||
			 mod_1llight || mod_2llight || mod_4llight)) {
        printf("Can't have +lmcolor without lighting enabled\n");
	exit(1);
    }

    if (mod_width && !(test_line || test_xform)) {
	printf("Width only available with lines and points\n");
	exit(1);
    }

    if (mod_snap)
	printf("+snap has no effect in OpenGL, disregarding\n");

    if (test_xform) {
	if (mod_light || mod_depth || mod_pattern || mod_dashed) {
	    printf("%s: invalid parameter:\n",argv[1]);
	    badparam(mod_light,"+light");
	    badparam(mod_depth,"+depth");
	    badparam(mod_pattern,"+pattern");
	    badparam(mod_dashed,"+dashed");
	    printf("\n");
	    exit(1);
	}
    }

    if (test_line) {
	if (mod_pattern || mod_light) {
	    printf("%s: invalid parameter:\n",argv[1]);
	    badparam(mod_pattern,"+pattern");
	    badparam(mod_light,"+light");
	    printf("\n");
	    exit(1);
	}

	if ((mod_light && mod_cmode) || (mod_aa&&mod_depth) || 
	    (mod_depth&&mod_2d)){

	    printf("%s: invalid parameter combination:\n",argv[1]);
	    badparam(mod_light&&mod_cmode," +light && +cmode");
	    badparam(mod_aa&&mod_depth," +aa && +depth");
	    badparam(mod_depth&&mod_2d," +depth && +2d");

	    printf("\n");
	    exit(1);
	}
    }

    if (test_char) {
	if (mod_pattern || mod_width || mod_dashed || mod_aa ||
	    mod_depth || mod_light) {

	    printf("%s: invalid parameter:\n",argv[1]);
	    badparam(mod_pattern,"+pattern");
	    badparam(mod_dashed,"+dashed");
	    badparam(mod_width,"+width");
	    badparam(mod_depth,"+depth");
	    badparam(mod_aa,"+aa");
	    badparam(mod_light,"+light");
	    printf("\n");
	    exit(1);
	}
    }

    if (test_tmesh || test_qstrip) {
	if (mod_pattern || mod_dashed || mod_width || mod_depth || mod_aa ) {
	    printf("%s: invalid parameter:\n",argv[1]);
	    badparam(mod_pattern,"+pattern");
	    badparam(mod_dashed,"+dashed");
	    badparam(mod_width,"+width");
	    badparam(mod_depth,"+depth");
	    badparam(mod_aa,"+aa");
	    printf("\n");
	    exit(1);
	}
    }

    if (test_poly) {
	if (mod_aa || mod_width || mod_depth) {
	    printf("%s: invalid parameter:\n",argv[1]);
	    badparam(mod_dashed,"+dashed");
	    badparam(mod_width,"+width");
	    badparam(mod_depth,"+depth");
	    badparam(mod_aa,"+aa");
	    printf("\n");
	    exit(1);
	}
    }

    if (test_dma) {
	if (mod_2d || mod_z || mod_shade || mod_cmode || mod_light ||
	mod_depth || mod_aa || mod_snap || mod_dashed || mod_width ||
	mod_pattern || mod_oldwindow) {
	    printf("DMA test. No modifiers have any effect\n");
	    printf("\n");
	    exit(1);
	}
	mod_2d = 1;
	mod_shade = 1;
	mod_oldwindow = 0;
    }

    if(test_clear) {
	if(mod_2d || mod_shade || mod_light || mod_depth || mod_aa || 
	    mod_dashed || mod_width || mod_oldwindow || mod_pattern) {
	    printf("%s: invalid parameter:\n",argv[1]);
	    badparam(mod_2d,"+2d");
	    badparam(mod_shade,"+shade");
	    badparam(mod_dashed,"+dashed");
	    badparam(mod_width,"+width");
	    badparam(mod_depth,"+depth");
	    badparam(mod_aa,"+aa");
	    badparam(mod_oldwindow,"+oldwindow");
	    badparam(mod_pattern,"+pattern");
	    printf("\n");
	    exit(1);
	}
    }		

    if(test_fill) {
	if(mod_depth || mod_aa || mod_dashed || mod_width || mod_oldwindow) {
	    printf("%s: invalid parameter:\n",argv[1]);
	    badparam(mod_dashed,"+dashed");
	    badparam(mod_width,"+width");
	    badparam(mod_depth,"+depth");
	    badparam(mod_oldwindow,"+oldwindow");
	    printf("\n");
	    exit(1);
	}
    }		


    /* Arguments all OK, put up a window, and an informative banner	*/
    xsize = WINWIDTH;
    ysize = WINHEIGHT;
    if (mod_doublebuffer)
        auxInitDisplayMode(AUX_DOUBLE | AUX_RGB);
    else
        auxInitDisplayMode(AUX_SINGLE | AUX_RGB);
        
    auxInitPosition(50, 50, 50 + xsize, 50 + ysize);
    auxInitWindow("ogpt");
    auxReshapeFunc(reshape);

#ifdef FONTS_NEEDED
    /* get the font if required */
    if (test_char) {
	XFontStruct *fontInfo = NULL;
        fontInfo = XLoadQueryFont(theDisplay, IRISFONT);
	if (fontInfo == NULL) {
	    printf("Could not load font '%s'\n", IRISFONT);
	    exit(1);
	}
	theFont = fontInfo->fid;
    }
#endif

    if (!mod_brief) {
        printf ("\nOpenGL Graphics Performance Tester - version 1.0\n");
        printf ("------------------------------------------------\n\n");
        printf ("window size = %ld %ld\n", xsize,ysize);
        printf ("%6s: ", argv[1]);
        printf ("%s, %s, %s, %s\n",
	    (mod_2d ? "2D" : "3D"),
	    (mod_z ? "Z buffered" : "not Z buffered"),
	    (mod_shade ? "Gouraud shaded" : "flat shaded"),
	    (mod_pattern ? "patterned" : "not patterned") );
        printf ("        %s, %s, %s, width = %d, %s,\n",
	    (mod_light ? "lighted" : "not lighted"),
	    (mod_depth ? "depth cued" : "not depth cued"),
	    (mod_dashed ? "dashed" : "not dashed"),
	    line_width,
	    (mod_aa ? "anti-aliased" : "not anti-aliased") );
        printf ("        %s, %s\n",
	    (mod_cmode ? "CImode" : "RGBmode"),
	    (mod_backface ? "backface(TRUE)" : "backface(FALSE)"));
    }
    else {
	sprintf(pbuf,"width=%d ",line_width);
	sprintf(pbuf2,"lighted ( %s%s%s%s%s%s) ",
					   (mod_1ilight ? "1inf " : ""),
					   (mod_2ilight ? "2inf " : ""),
					   (mod_4ilight ? "4inf " : ""),
					   (mod_1llight ? "1lcl " : ""),
					   (mod_2llight ? "2lcl " : ""),
					   (mod_4llight ? "4lcl " : ""));
	printf("%6s: %s%s%s%s%s%s%s%s%s%s%s%s%s%s\n",
					   argv[1],
					   (mod_2d ? "2D " : ""),
					   (mod_z ? "Zbuf " : ""),
					   (mod_shade ? "Gouraud " : ""),
					   (mod_pattern ? "patterned " : ""),
					   (mod_depth ? "depth cued " : ""),
					   (mod_dashed ? "dashed " : ""),
					   (line_width!=1 ? pbuf : ""),
					   (mod_aa ? "anti-aliased " : ""),
					   (mod_cmode ? "cmode " : ""),
					   (mod_light ? pbuf2 : ""),
					   (mod_lmcolor ? "lmcolor " : ""),
					   (mod_oldwindow ? "oldwindow " : ""),
					   (mod_backface ? "backfaced " : ""));
    }

    /* Then run the requested test	*/

    if (useList)
        initListMode();

    glShadeModel(mod_shade ? GL_SMOOTH : GL_FLAT);
    if (mod_z) {
	glEnable(GL_DEPTH_TEST);
	/* make z function the same as IrisGL's default */
	glDepthFunc(GL_LEQUAL);
    }
    else
	glDisable(GL_DEPTH_TEST);

    Sleep(1000);	/* wait for window system to quiet down	*/

    if (mod_cmode) {
	glClearIndex(BLACK);
	glIndexi(WHITE);
    } else {
	glClearColor(c[0], c[1], c[2], c[3]);
	glColor3fv(&c[28]);
    }
    glClear(GL_COLOR_BUFFER_BIT);

    if (mod_z) {
	glClear(GL_DEPTH_BUFFER_BIT);
    }

    if (test_xform)
	auxMainLoop(perfpoint);

    if (test_line)
	auxMainLoop(perfline);

    if (test_tmesh)
	auxMainLoop(perftmesh);

    if (test_poly)
	auxMainLoop(perfpoly);

    if (test_qstrip)
	auxMainLoop(perfqstrip);

    if (test_fill)
        auxMainLoop(perffill);
        
    if (test_clear)
        auxMainLoop(perfclear);


#ifdef PORTME
    if (test_char)
	perfchar();

    if (test_fill)
	perffill();

    if (test_dma)
	perfpixels();

    if (test_clear)
	perfclear();

/*
    if (test_texture)
	perftexture();
*/
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\accpersp.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*  accpersp.c
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include <math.h>
#include "glaux.h"
#include "jitter.h"

#define PI_ 3.14159265358979323846

/*	accFrustum()
 *  The first 6 arguments are identical to the glFrustum() call.
 *  
 *  pixdx and pixdy are anti-alias jitter in pixels. 
 *  Set both equal to 0.0 for no anti-alias jitter.
 *  eyedx and eyedy are depth-of field jitter in pixels. 
 *  Set both equal to 0.0 for no depth of field effects.
 *
 *  focus is distance from eye to plane in focus. 
 *  focus must be greater than, but not equal to 0.0.
 *
 *  Note that accFrustum() calls glTranslatef().  You will 
 *  probably want to insure that your ModelView matrix has been 
 *  initialized to identity before calling accFrustum().
 */

void accFrustum(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top,
    GLdouble znear, GLdouble zfar, GLdouble pixdx, GLdouble pixdy, 
    GLdouble eyedx, GLdouble eyedy, GLdouble focus)
{
    GLdouble xwsize, ywsize; 
    GLdouble dx, dy;
    GLint viewport[4];

    glGetIntegerv (GL_VIEWPORT, viewport);
	
    xwsize = right - left;
    ywsize = top - bottom;
	
    dx = -(pixdx*xwsize/(GLdouble) viewport[2] + eyedx*znear/focus);
    dy = -(pixdy*ywsize/(GLdouble) viewport[3] + eyedy*znear/focus);
	
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glFrustum (left + dx, right + dx, bottom + dy, top + dy, znear, zfar);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    glTranslatef (-eyedx, -eyedy, 0.0);
}

/*  accPerspective()
 * 
 *  The first 4 arguments are identical to the gluPerspective() call.
 *  pixdx and pixdy are anti-alias jitter in pixels. 
 *  Set both equal to 0.0 for no anti-alias jitter.
 *  eyedx and eyedy are depth-of field jitter in pixels. 
 *  Set both equal to 0.0 for no depth of field effects.
 *
 *  focus is distance from eye to plane in focus. 
 *  focus must be greater than, but not equal to 0.0.
 *
 *  Note that accPerspective() calls accFrustum().
 */
void accPerspective(GLdouble fovy, GLdouble aspect, 
    GLdouble znear, GLdouble zfar, GLdouble pixdx, GLdouble pixdy, 
    GLdouble eyedx, GLdouble eyedy, GLdouble focus)
{
    GLdouble fov2,left,right,bottom,top;

    fov2 = ((fovy*PI_) / 180.0) / 2.0;

    top = znear / (cos(fov2) / sin(fov2));
    bottom = -top;

    right = top * aspect;
    left = -right;

    accFrustum (left, right, bottom, top, znear, zfar,
	pixdx, pixdy, eyedx, eyedy, focus);
}

/*  Initialize lighting and other values.
 */
void myinit(void)
{
    GLfloat mat_ambient[] = { 1.0, 1.0, 1.0, 1.0 };
    GLfloat mat_specular[] = { 1.0, 1.0, 1.0, 1.0 };
    GLfloat light_position[] = { 0.0, 0.0, 10.0, 1.0 };
    GLfloat lm_ambient[] = { 0.2, 0.2, 0.2, 1.0 };

    glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient);
    glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
    glMaterialf(GL_FRONT, GL_SHININESS, 50.0);
    glLightfv(GL_LIGHT0, GL_POSITION, light_position);
    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lm_ambient);
    
    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);
    glDepthFunc(GL_LESS);
    glEnable(GL_DEPTH_TEST);
    glShadeModel (GL_FLAT);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glClearAccum(0.0, 0.0, 0.0, 0.0);
}

void displayObjects(void) 
{
    GLfloat torus_diffuse[] = { 0.7, 0.7, 0.0, 1.0 };
    GLfloat cube_diffuse[] = { 0.0, 0.7, 0.7, 1.0 };
    GLfloat sphere_diffuse[] = { 0.7, 0.0, 0.7, 1.0 };
    GLfloat octa_diffuse[] = { 0.7, 0.4, 0.4, 1.0 };
    
    glPushMatrix ();
    glTranslatef (0.0, 0.0, -5.0); 
    glRotatef (30.0, 1.0, 0.0, 0.0);

    glPushMatrix ();
    glTranslatef (-0.80, 0.35, 0.0); 
    glRotatef (100.0, 1.0, 0.0, 0.0);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, torus_diffuse);
    auxSolidTorus (0.275, 0.85);
    glPopMatrix ();

    glPushMatrix ();
    glTranslatef (-0.75, -0.50, 0.0); 
    glRotatef (45.0, 0.0, 0.0, 1.0);
    glRotatef (45.0, 1.0, 0.0, 0.0);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, cube_diffuse);
    auxSolidCube (1.5);
    glPopMatrix ();

    glPushMatrix ();
    glTranslatef (0.75, 0.60, 0.0); 
    glRotatef (30.0, 1.0, 0.0, 0.0);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, sphere_diffuse);
    auxSolidSphere (1.0);
    glPopMatrix ();

    glPushMatrix ();
    glTranslatef (0.70, -0.90, 0.25); 
    glMaterialfv(GL_FRONT, GL_DIFFUSE, octa_diffuse);
    auxSolidOctahedron (1.0);
    glPopMatrix ();

    glPopMatrix ();
}

#define ACSIZE	8

void display(void)
{
    GLint viewport[4];
    int jitter;

    glGetIntegerv (GL_VIEWPORT, viewport);

    glClear(GL_ACCUM_BUFFER_BIT);
    for (jitter = 0; jitter < ACSIZE; jitter++) {
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	accPerspective (50.0, 
		(GLdouble) viewport[2]/(GLdouble) viewport[3], 
		1.0, 15.0, j8[jitter].x, j8[jitter].y,
		0.0, 0.0, 1.0);
	displayObjects ();
	glAccum(GL_ACCUM, 1.0/ACSIZE);
    	glFlush();
	auxSwapBuffers();
    }
    glAccum (GL_RETURN, 1.0);
    glFlush();
    auxSwapBuffers();
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_DOUBLE | AUX_RGB
			| AUX_ACCUM | AUX_DEPTH16);
    auxInitPosition (0, 0, 250, 250);
    auxInitWindow (argv[0]);
    myinit();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\accum.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*  accum.c
 */
#include <windows.h>
#include <stdio.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

GLsizei width, height;

void myinit(void)
{
    GLfloat ambient[] = { 0.4, 0.4, 0.4, 1.0 };
    GLfloat diffuse[] = { 1.0, 1.0, 1.0, 1.0 };
    GLfloat specular[] = { 1.0, 1.0, 1.0, 1.0 };
    GLfloat position[] = { 0.0, 2.0, 2.0, 0.0 };
    GLfloat mat_ambient[] = { 0.2, 0.2, 0.2, 1.0 };
    GLfloat mat_diffuse[] = { 0.7, 0.7, 0.7, 1.0 };
    GLfloat mat_specular[] = { 0.9, 0.9, 0.9, 1.0 };
    GLfloat mat_shininess[] = { 50.0 };
    GLfloat lmodel_ambient[] = { 0.2, 0.2, 0.2, 1.0 };
    
    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LESS);

    glLightfv(GL_LIGHT0, GL_AMBIENT, ambient);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuse);
    glLightfv(GL_LIGHT0, GL_SPECULAR, specular);
    glLightfv(GL_LIGHT0, GL_POSITION, position);
    
    glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
    glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
    glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);

    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_ambient);

    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);
    glEnable(GL_AUTO_NORMAL);
    glEnable(GL_NORMALIZE);

    glEnable(GL_CULL_FACE);
    glCullFace(GL_FRONT);

    glClearAccum(0.0, 0.0, 0.0, 0.0);
}

#define ACSIZE 16

GLfloat dx[ACSIZE], dy[ACSIZE];

GLfloat jitter3[3][2] = {
    {0.5, 0.5}, 
    {1.35899e-05, 0.230369}, 
    {0.000189185, 0.766878}, 
};

GLfloat jitter11[11][2] = {
    {0.5, 0.5}, {0.406537, 0.135858}, 
    {0.860325, 0.968558}, {0.680141, 0.232877}, 
    {0.775694, 0.584871}, {0.963354, 0.309056}, 
    {0.593493, 0.864072}, {0.224334, 0.415055}, 
    {0.0366643, 0.690884}, {0.139685, 0.0313988}, 
    {0.319861, 0.767097}, 
};

GLfloat jitter16[16][2] = {
    {0.4375, 0.4375}, {0.1875, 0.5625}, 
    {0.9375, 1.1875}, {0.4375, 0.9375-1}, 
    {0.6875, 0.5625}, {0.1875, 0.0625}, 
    {0.6875, 0.3125}, {0.1875, 0.3125}, 
    {0.4375, 0.1875}, {0.9375-1, 0.4375}, 
    {0.6875, 0.8125}, {0.4375, 0.6875}, 
    {0.6875, 0.0625}, {0.9375, 0.9375}, 
    {1.1875, 0.8125}, {0.9375, 0.6875}, 
};

GLfloat jitter29[29][2] = {
    {0.5, 0.5}, {0.498126, 0.141363}, 
    {0.217276, 0.651732}, {0.439503, 0.954859}, 
    {0.734171, 0.836294}, {0.912454, 0.79952}, 
    {0.406153, 0.671156}, {0.0163892, 0.631994}, 
    {0.298064, 0.843476}, {0.312025, 0.0990405}, 
    {0.98135, 0.965697}, {0.841999, 0.272378}, 
    {0.559348, 0.32727}, {0.809331, 0.638901}, 
    {0.632583, 0.994471}, {0.00588314, 0.146344}, 
    {0.713365, 0.437896}, {0.185173, 0.246584}, 
    {0.901735, 0.474544}, {0.366423, 0.296698}, 
    {0.687032, 0.188184}, {0.313256, 0.472999}, 
    {0.543195, 0.800044}, {0.629329, 0.631599}, 
    {0.818263, 0.0439354}, {0.163978, 0.00621497}, 
    {0.109533, 0.812811}, {0.131325, 0.471624}, 
    {0.0196755, 0.331813}, 
};

GLfloat jitter90[90][2] = {
    {0.5, 0.5}, {0.784289, 0.417355}, 
    {0.608691, 0.678948}, {0.546538, 0.976002}, 
    {0.972245, 0.270498}, {0.765121, 0.189392}, 
    {0.513193, 0.743827}, {0.123709, 0.874866}, 
    {0.991334, 0.745136}, {0.56342, 0.0925047}, 
    {0.662226, 0.143317}, {0.444563, 0.928535}, 
    {0.248017, 0.981655}, {0.100115, 0.771923}, 
    {0.593937, 0.559383}, {0.392095, 0.225932}, 
    {0.428776, 0.812094}, {0.510615, 0.633584}, 
    {0.836431, 0.00343328}, {0.494037, 0.391771}, 
    {0.617448, 0.792324}, {0.688599, 0.48914}, 
    {0.530421, 0.859206}, {0.0742278, 0.665344}, 
    {0.979388, 0.626835}, {0.183806, 0.479216}, 
    {0.151222, 0.0803998}, {0.476489, 0.157863}, 
    {0.792675, 0.653531}, {0.0990416, 0.267284}, 
    {0.776667, 0.303894}, {0.312904, 0.296018}, 
    {0.288777, 0.691008}, {0.460097, 0.0436075}, 
    {0.594323, 0.440751}, {0.876296, 0.472043}, 
    {0.0442623, 0.0693901}, {0.355476, 0.00442787}, 
    {0.391763, 0.361327}, {0.406994, 0.696053}, 
    {0.708393, 0.724992}, {0.925807, 0.933103}, 
    {0.850618, 0.11774}, {0.867486, 0.233677}, 
    {0.208805, 0.285484}, {0.572129, 0.211505}, 
    {0.172931, 0.180455}, {0.327574, 0.598031}, 
    {0.685187, 0.372379}, {0.23375, 0.878555}, 
    {0.960657, 0.409561}, {0.371005, 0.113866}, 
    {0.29471, 0.496941}, {0.748611, 0.0735321}, 
    {0.878643, 0.34504}, {0.210987, 0.778228}, 
    {0.692961, 0.606194}, {0.82152, 0.8893}, 
    {0.0982095, 0.563104}, {0.214514, 0.581197}, 
    {0.734262, 0.956545}, {0.881377, 0.583548}, 
    {0.0560485, 0.174277}, {0.0729515, 0.458003}, 
    {0.719604, 0.840564}, {0.325388, 0.7883}, 
    {0.26136, 0.0848927}, {0.393754, 0.467505}, 
    {0.425361, 0.577672}, {0.648594, 0.0248658}, 
    {0.983843, 0.521048}, {0.272936, 0.395127}, 
    {0.177695, 0.675733}, {0.89175, 0.700901}, 
    {0.632301, 0.908259}, {0.782859, 0.53611}, 
    {0.0141421, 0.855548}, {0.0437116, 0.351866}, 
    {0.939604, 0.0450863}, {0.0320883, 0.962943}, 
    {0.341155, 0.895317}, {0.952087, 0.158387}, 
    {0.908415, 0.820054}, {0.481435, 0.281195}, 
    {0.675525, 0.25699}, {0.585273, 0.324454}, 
    {0.156488, 0.376783}, {0.140434, 0.977416}, 
    {0.808155, 0.77305}, {0.282973, 0.188937}, 
};

void loaddxdy(void)
{
    long i;
    for (i = 0; i < ACSIZE; i++) {
	dx[i] = jitter16[i][0]*10/width;
	dy[i] = jitter16[i][1]*10/height;
    }
}

void display(void)
{
    int i;

    glClear(GL_ACCUM_BUFFER_BIT);
    loaddxdy();
    for (i = 0; i < (ACSIZE); i++) {
	printf("Pass %d\n", i);
	glPushMatrix();
	glTranslatef(dx[i], dy[i], 0.0);
	glRotatef(45.0, 1.0, 1.0, 1.0);
	glClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);
	auxSolidTeapot(1.0);
	glPopMatrix();
	glAccum(GL_ACCUM, 1.0/(ACSIZE));
	glFlush();
	auxSwapBuffers();
    }
    printf("final job\n");
    glAccum(GL_RETURN, 1.0);
    printf("done\n");
    glFlush();
    auxSwapBuffers();
}

void myReshape(GLsizei w, GLsizei h)
{
    width = w; height = h;
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (w <= h)
	glOrtho(-3.0, 3.0, -3.0*(GLfloat) h/(GLfloat) w, 
	    3.0*(GLfloat) h/(GLfloat) w, -15.0, 15.0);
    else
	glOrtho(-3.0*(GLfloat) w/(GLfloat) h, 
	    3.0*(GLfloat) w/(GLfloat) h, -3.0, 3.0, -15.0, 15.0);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
}

int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_DOUBLE | AUX_RGB
			| AUX_ACCUM | AUX_DEPTH16);
    auxInitPosition (0, 0, 300, 300);
    auxInitWindow (argv[0]);
    myinit();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\alpha3d.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  alpha3D.c
 *  This program demonstrates how to intermix opaque and
 *  alpha blended polygons in the same scene, by using glDepthMask.
 *  Pressing the left mouse button toggles the eye position.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

void myinit(void)
{
    GLfloat mat_ambient[] = { 0.0, 0.0, 0.0, 0.15 };
    GLfloat mat_specular[] = { 1.0, 1.0, 1.0, 0.15 };
    GLfloat mat_shininess[] = { 15.0 };

    glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient);
    glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
    glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);

    glEnable (GL_LIGHTING);
    glEnable (GL_LIGHT0);
    glDepthFunc(GL_LESS);
    glEnable(GL_DEPTH_TEST);
}

GLboolean eyePosition = GL_FALSE;

void toggleEye (AUX_EVENTREC *event)
{
    if (eyePosition)
	eyePosition = GL_FALSE;
    else
	eyePosition = GL_TRUE;
}

void display(void)
{
    GLfloat position[] = { 0.0, 0.0, 1.0, 1.0 };
    GLfloat mat_torus[] = { 0.75, 0.75, 0.0, 1.0 };
    GLfloat mat_cylinder[] = { 0.0, 0.75, 0.75, 0.15 };

    glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glLightfv (GL_LIGHT0, GL_POSITION, position);
    glPushMatrix ();
	if (eyePosition)
	    gluLookAt (0.0, 0.0, 9.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0); 
	else 
	    gluLookAt (0.0, 0.0, -9.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0); 
	glPushMatrix ();
	glTranslatef (0.0, 0.0, 1.0);    
	glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_torus);
	auxSolidTorus (0.275, 0.85);
	glPopMatrix ();

	glEnable (GL_BLEND);
	glDepthMask (GL_FALSE);
	glBlendFunc (GL_SRC_ALPHA, GL_ONE);
	glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_cylinder);
	glTranslatef (0.0, 0.0, -1.0);    
	auxSolidCylinder (1.0, 2.0);
	glDepthMask (GL_TRUE);
	glDisable (GL_BLEND);
    glPopMatrix ();

    glFlush ();
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(30.0, (GLfloat) w/(GLfloat) h, 1.0, 20.0);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB | AUX_DEPTH16);
    auxInitPosition (0, 0, 500, 500);
    auxInitWindow (argv[0]);
    auxMouseFunc (AUX_LEFTBUTTON, AUX_MOUSEDOWN, toggleEye);
    myinit();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\aim.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  aim.c
 *  This program calculates the fovy (field of view angle
 *  in the y direction), by using trigonometry, given the
 *  size of an object and its size.
 */
#include <windows.h>
#include <stdio.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include <math.h>
#include "glaux.h"

void myinit (void) {
    glShadeModel (GL_FLAT);
}

/*  Clear the screen.  Set the current color to white.
 *  Draw the wire frame cube and sphere.
 */
void display (void)
{
    glClear(GL_COLOR_BUFFER_BIT);
    glColor3f (1.0, 1.0, 1.0);

    glLoadIdentity ();
/*	glTranslatef() as viewing transformation	*/
    glTranslatef (0.0, 0.0, -5.0);
    auxWireCube(2.0);
    auxWireSphere(1.0);
    glFlush();
}

#define PI  3.1415926535

/*  atan2 () is a system math routine which calculates
 *  the arctangent of an angle, given length of the 
 *  opposite and adjacent sides of a right triangle.
 *  atan2 () is not an OpenGL routine.
 */
GLdouble calculateAngle (double size, double distance)
{
    GLdouble radtheta, degtheta;
    
    radtheta = 2.0 * atan2 (size/2.0, distance);
    degtheta = (180.0 * radtheta) / PI;
    printf ("degtheta is %lf\n", degtheta);
    return ((GLdouble) degtheta);
}

/*  Called when the window is first opened and whenever 
 *  the window is reconfigured (moved or resized).
 */
void myReshape(GLsizei w, GLsizei h)
{
    GLdouble theta;

    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    theta = calculateAngle (2.0, 5.0);
    gluPerspective(theta, (GLfloat) w/(GLfloat) h, 1.0, 20.0);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB);
    auxInitPosition (0, 0, 500, 500);
    auxInitWindow (argv[0]);
    myinit ();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\alpha.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  alpha.c
 *  This program draws several overlapping filled polygons
 *  to demonstrate the effect order has on alpha blending results.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

/*  Initialize alpha blending function.
 */
void myinit(void)
{
    glEnable (GL_BLEND);
    glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glShadeModel (GL_FLAT);
    glClearColor (0.0, 0.0, 0.0, 0.0);
}

void display(void)
{
    glClear(GL_COLOR_BUFFER_BIT);

    glColor4f (1.0, 1.0, 0.0, 0.75);
    glRectf (0.0, 0.0, 0.5, 1.0);

    glColor4f (0.0, 1.0, 1.0, 0.75);
    glRectf (0.0, 0.0, 1.0, 0.5);
/*	draw colored polygons in reverse order in upper right  */
    glColor4f (0.0, 1.0, 1.0, 0.75);
    glRectf (0.5, 0.5, 1.0, 1.0);

    glColor4f (1.0, 1.0, 0.0, 0.75);
    glRectf (0.5, 0.5, 1.0, 1.0);

    glFlush();
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (w <= h) 
	gluOrtho2D (0.0, 1.0, 0.0, 1.0*(GLfloat)h/(GLfloat)w);
    else 
	gluOrtho2D (0.0, 1.0*(GLfloat)w/(GLfloat)h, 0.0, 1.0);
    glMatrixMode(GL_MODELVIEW);
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB);
    auxInitPosition (0, 0, 500, 500);
    auxInitWindow (argv[0]);
    myinit();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\anti.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED
 * Permission to use, copy, modify, and distribute this software for
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission.
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * US Government Users Restricted Rights
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  anti.c
 *  This program draws antialiased lines in RGBA mode.
 */
#include <windows.h>
#include <stdio.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

/*  Initialize antialiasing for RGBA mode, including alpha
 *  blending, hint, and line width.  Print out implementation
 *  specific info on line width granularity and width.
 */
void myinit(void)
{
    GLfloat values[2];
    glGetFloatv (GL_LINE_WIDTH_GRANULARITY, values);
    printf ("GL_LINE_WIDTH_GRANULARITY value is %3.1f\n", values[0]);

    glGetFloatv (GL_LINE_WIDTH_RANGE, values);
    printf ("GL_LINE_WIDTH_RANGE values are %3.1f %3.1f\n",
        values[0], values[1]);

    glEnable (GL_LINE_SMOOTH);
    glEnable (GL_BLEND);
    glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glHint (GL_LINE_SMOOTH_HINT, GL_DONT_CARE);
    glLineWidth (1.5);

    glShadeModel(GL_FLAT);
    glClearColor(0.0, 0.0, 0.0, 0.0);
    glDepthFunc(GL_LESS);
    glEnable(GL_DEPTH_TEST);
}

/*  display() draws an icosahedron with a large alpha value, 1.0.
 */
void display(void)
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glColor4f (1.0, 1.0, 1.0, 1.0);
    auxWireIcosahedron(1.0);
    glFlush();
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective (45.0, (GLfloat) w/(GLfloat) h, 3.0, 5.0);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity ();
    glTranslatef (0.0, 0.0, -4.0);  /*  move object into view   */
}

/*  Main Loop
 *  Open window with initial window size, title bar,
 *  RGBA display mode, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB | AUX_DEPTH16);
    auxInitPosition (100, 50, 400, 400);
    auxInitWindow (argv[0]);
    myinit();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\auxsamp.c ===
/*
 *    bgammon.c
 *
 *    start easy, just have pieces...
 *
 */

#include <windows.h>
#include <gl.h>
#include <glu.h>
#include <glaux.h>

GLvoid	initialize(GLvoid);
GLvoid	drawScene(GLvoid);
GLvoid  resize(GLsizei, GLsizei);
GLvoid	drawLight(GLvoid);

void polarView( GLdouble, GLdouble, GLdouble, GLdouble);

GLfloat latitude, longitude, radius;

void __cdecl main(void)
{
    initialize();

    auxMainLoop( drawScene );
}

GLvoid resize( GLsizei width, GLsizei height )
{
    GLfloat aspect;

    glViewport( 0, 0, width, height );

    aspect = (GLfloat) width / height;

    glMatrixMode( GL_PROJECTION );
    glLoadIdentity();
    gluPerspective( 45.0, aspect, 3.0, 7.0 );
    glMatrixMode( GL_MODELVIEW );
}    

GLvoid initialize(GLvoid)
{
    GLfloat	maxObjectSize, aspect;
    GLdouble	near_plane, far_plane;
    GLsizei	width, height;

    GLfloat	ambientProperties[] = {2.0, 2.0, 2.0, 1.0};
    GLfloat	diffuseProperties[] = {0.8, 0.8, 0.8, 1.0};
    GLfloat	specularProperties[] = {1.0, 4.0, 4.0, 1.0};

    width = 1024.0;
    height = 768.0;

    auxInitPosition( width/4, height/4, width/2, height/2);

    auxInitDisplayMode( AUX_RGBA | AUX_DEPTH16 | AUX_DOUBLE );

    auxInitWindow( "Rotating Shapes" );

    auxIdleFunc( drawScene );

    auxReshapeFunc( resize );

    glClearColor( 0.0, 0.0, 0.0, 1.0 );
    glClearDepth( 1.0 );

    glEnable(GL_DEPTH_TEST);

    glEnable(GL_LIGHTING);
    
    glLightfv( GL_LIGHT0, GL_AMBIENT, ambientProperties);
    glLightfv( GL_LIGHT0, GL_DIFFUSE, diffuseProperties);
    glLightfv( GL_LIGHT0, GL_SPECULAR, specularProperties);
    glLightModelf(GL_LIGHT_MODEL_TWO_SIDE, 1.0);

    glEnable( GL_LIGHT0 );

    glMatrixMode( GL_PROJECTION );
    aspect = (GLfloat) width / height;
    gluPerspective( 45.0, aspect, 3.0, 7.0 );
    glMatrixMode( GL_MODELVIEW );

    near_plane = 3.0;
    far_plane = 7.0;
    maxObjectSize = 3.0;
    radius = near_plane + maxObjectSize/2.0;

    latitude = 0.0;
    longitude = 0.0;
}

void polarView(GLdouble radius, GLdouble twist, GLdouble latitude,
	       GLdouble longitude)
{
    glTranslated(0.0, 0.0, -radius);
    glRotated( -twist, 0.0, 0.0, 1.0 );
    glRotated( -latitude, 1.0, 0.0, 0.0);
    glRotated( longitude, 0.0, 0.0, 1.0);	 

}

GLvoid drawScene(GLvoid)
{
    static GLfloat	whiteAmbient[] = {0.3, 0.3, 0.3, 1.0};
    static GLfloat	redAmbient[] = {0.3, 0.1, 0.1, 1.0};
    static GLfloat	greenAmbient[] = {0.1, 0.3, 0.1, 1.0};
    static GLfloat	blueAmbient[] = {0.1, 0.1, 0.3, 1.0};
    static GLfloat	whiteDiffuse[] = {1.0, 1.0, 1.0, 1.0};
    static GLfloat	redDiffuse[] = {1.0, 0.0, 0.0, 1.0};
    static GLfloat	greenDiffuse[] = {0.0, 1.0, 0.0, 1.0};
    static GLfloat	blueDiffuse[] = {0.0, 0.0, 1.0, 1.0};
    static GLfloat	whiteSpecular[] = {1.0, 1.0, 1.0, 1.0};
    static GLfloat	redSpecular[] = {1.0, 0.0, 0.0, 1.0};
    static GLfloat	greenSpecular[] = {0.0, 1.0, 0.0, 1.0};
    static GLfloat	blueSpecular[] = {0.0, 0.0, 1.0, 1.0};

    static GLfloat	lightPosition0[] = {0.0, 0.0, 0.0, 1.0};
    static GLfloat	angle = 0.0;

    glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT );

    glPushMatrix();

    	latitude += 6.0;
    	longitude += 2.5;

    	polarView( radius, 0, latitude, longitude );

	glPushMatrix();
	    angle += 6.0;
	    glRotatef(angle, 1.0, 0.0, 1.0);
	    glTranslatef( 0.0, 1.5, 0.0);
	    glLightfv(GL_LIGHT0, GL_POSITION, lightPosition0);
	    drawLight();
	glPopMatrix();

	glPushAttrib(GL_LIGHTING_BIT);

	    glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, redAmbient);
	    glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, redDiffuse);
	    glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, whiteSpecular);
	    glMaterialf(GL_FRONT, GL_SHININESS, 100.0);

    	    auxSolidCone( 0.3, 0.6 );

	glPopAttrib();

	auxWireSphere(1.5);

	glPushAttrib(GL_LIGHTING_BIT);

	    glMaterialfv(GL_BACK, GL_AMBIENT, greenAmbient);
	    glMaterialfv(GL_BACK, GL_DIFFUSE, greenDiffuse);
	    glMaterialfv(GL_FRONT, GL_AMBIENT, blueAmbient);
	    glMaterialfv(GL_FRONT, GL_DIFFUSE, blueDiffuse);
	    glMaterialfv(GL_FRONT, GL_SPECULAR, blueSpecular);
	    glMaterialf(GL_FRONT, GL_SHININESS, 50.0);

    	    glPushMatrix();
    	    	glTranslatef(0.8, -0.65, 0.0);
    	    	glRotatef(30.0, 1.0, 0.5, 1.0);
    	    	auxSolidCylinder( 0.3, 0.6 );
    	    glPopMatrix();

	glPopAttrib();


    glPopMatrix();

    auxSwapBuffers();
}

GLvoid drawLight(GLvoid)
{
    glPushAttrib(GL_LIGHTING_BIT);
    	glDisable(GL_LIGHTING);
    	glColor3f(1.0, 1.0, 1.0);
    	auxSolidDodecahedron(0.1);
    glPopAttrib();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\antipnt.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  antipoint.c
 *  The program draws antialiased points, in RGBA mode.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

/*  Initialize point anti-aliasing for RGBA mode, including alpha 
 *  blending, hint, and point size.  These points are 3.0 pixels big.
 */
void myinit(void)
{
    glEnable (GL_POINT_SMOOTH);
    glEnable (GL_BLEND);
    glBlendFunc (GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glHint (GL_POINT_SMOOTH_HINT, GL_DONT_CARE);
    glPointSize (3.0);

    glClearColor(0.0, 0.0, 0.0, 0.0);
}

/*  display() draws several points.
 */
void display(void)
{
    int i;

    glClear (GL_COLOR_BUFFER_BIT);
    glColor4f (1.0, 1.0, 1.0, 1.0);
    glBegin (GL_POINTS);
	for (i = 1; i < 10; i++) {
	    glVertex2f ((GLfloat) i * 10.0, (GLfloat) i * 10.0);
	}
    glEnd ();
    glFlush();
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (w < h) 
	glOrtho (0.0, 100.0, 
	    0.0, 100.0*(GLfloat) h/(GLfloat) w, -1.0, 1.0);
    else
	glOrtho (0.0, 100.0*(GLfloat) w/(GLfloat) h, 
	    0.0, 100.0, -1.0, 1.0);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity ();
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB);
    auxInitPosition (0, 0, 100, 100);
    auxInitWindow (argv[0]);
    myinit();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\antipoly.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  antipoly.c
 *  This program draws filled polygons with antialiased
 *  edges.  The special GL_SRC_ALPHA_SATURATE blending 
 *  function is used.
 *  Pressing the left mouse button turns the antialiasing
 *  on and off.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

GLboolean polySmooth;

void myinit(void)
{
    GLfloat mat_ambient[] = { 0.0, 0.0, 0.0, 1.00 };
    GLfloat mat_specular[] = { 1.0, 1.0, 1.0, 1.00 };
    GLfloat mat_shininess[] = { 15.0 };

    glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient);
    glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
    glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);

    glEnable (GL_LIGHTING);
    glEnable (GL_LIGHT0);
    glEnable (GL_BLEND);
    glCullFace (GL_BACK);
    glEnable (GL_CULL_FACE);
    glEnable (GL_POLYGON_SMOOTH);
    polySmooth = GL_TRUE;

    glClearColor (0.0, 0.0, 0.0, 0.0);
}

void toggleSmooth (AUX_EVENTREC *event)
{
    if (polySmooth) {
	polySmooth = GL_FALSE;
	glDisable (GL_BLEND);
	glDisable (GL_POLYGON_SMOOTH);
	glEnable (GL_DEPTH_TEST);
    }
    else {
	polySmooth = GL_TRUE;
	glEnable (GL_BLEND);
	glEnable (GL_POLYGON_SMOOTH);
	glDisable (GL_DEPTH_TEST);
    }
}

/*  Note:  polygons must be drawn from front to back
 *  for proper blending.
 */
void display(void)
{
    GLfloat position[] = { 0.0, 0.0, 1.0, 0.0 };
    GLfloat mat_cube1[] = { 0.75, 0.75, 0.0, 1.0 };
    GLfloat mat_cube2[] = { 0.0, 0.75, 0.75, 1.0 };

    if (polySmooth)
	glClear (GL_COLOR_BUFFER_BIT);
    else 
	glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    glPushMatrix ();
	glTranslatef (0.0, 0.0, -8.0);    
	glLightfv (GL_LIGHT0, GL_POSITION, position);

	glBlendFunc (GL_SRC_ALPHA_SATURATE, GL_ONE);

	glPushMatrix ();
	glRotatef (30.0, 1.0, 0.0, 0.0);
	glRotatef (60.0, 0.0, 1.0, 0.0);
	glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_cube1);
	auxSolidCube (1.0);
	glPopMatrix ();

	glTranslatef (0.0, 0.0, -2.0);    
	glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_cube2);
	glRotatef (30.0, 0.0, 1.0, 0.0);
	glRotatef (60.0, 1.0, 0.0, 0.0);
	auxSolidCube (1.0);

    glPopMatrix ();

    glFlush ();
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(30.0, (GLfloat) w/(GLfloat) h, 1.0, 20.0);
    glMatrixMode(GL_MODELVIEW);
}

/*  Main Loop
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB | AUX_ALPHA | AUX_DEPTH16);
    auxInitPosition (0, 0, 200, 200);
    auxInitWindow (argv[0]);
    auxMouseFunc (AUX_LEFTBUTTON, AUX_MOUSEDOWN, toggleSmooth);
    myinit();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\chess.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*  chess.c
 *  This program texture maps a checkerboard image onto
 *  two rectangles.  The texture coordinates for the 
 *  rectangles are 0.0 to 3.0.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"
#include <math.h>

#define	checkImageWidth 64
#define	checkImageHeight 64
GLubyte checkImage[checkImageWidth][checkImageHeight][3];

void makecheckimage(void)
{
    int i, j, r, c;
    
    for (i = 0; i < checkImageWidth; i++) {
	for (j = 0; j < checkImageHeight; j++) {
	    c = ((((i&0x8)==0)^((j&0x8))==0))*255;
	    checkImage[i][j][0] = (GLubyte) c;
	    checkImage[i][j][1] = (GLubyte) c;
	    checkImage[i][j][2] = (GLubyte) c;
	}
    }
}

void myinit(void)
{
    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LESS);

    makecheckimage();
    glTexImage2D(GL_TEXTURE_2D, 0, 3, 
	checkImageWidth, checkImageHeight, 0,
	GL_RGB, GL_UNSIGNED_BYTE, &checkImage[0][0][0]);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL);
    glEnable(GL_TEXTURE_2D);
    glShadeModel(GL_FLAT);
}

void display(void)
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glBegin(GL_QUADS);
    glTexCoord2f(0.0, 0.0); glVertex3f(-2.0, -1.0, 0.0);
    glTexCoord2f(0.0, 3.0); glVertex3f(-2.0, 1.0, 0.0);
    glTexCoord2f(3.0, 3.0); glVertex3f(0.0, 1.0, 0.0);
    glTexCoord2f(3.0, 0.0); glVertex3f(0.0, -1.0, 0.0);

    glTexCoord2f(0.0, 0.0); glVertex3f(1.0, -1.0, 0.0);
    glTexCoord2f(0.0, 3.0); glVertex3f(1.0, 1.0, 0.0);
    glTexCoord2f(3.0, 3.0); glVertex3f(2.41421, 1.0, -1.41421);
    glTexCoord2f(3.0, 0.0); glVertex3f(2.41421, -1.0, -1.41421);
    glEnd();
    glFlush();
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(60.0, 1.0*(GLfloat)w/(GLfloat)h, 1.0, 30.0);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    glTranslatef(0.0, 0.0, -3.6);
}

int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB | AUX_DEPTH16);
    auxInitPosition (0, 0, 500, 500);
    auxInitWindow (argv[0]);
    myinit();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\bezcurve.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*  bezcurve.c			
 *  This program uses evaluators to draw a Bezier curve.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

GLfloat ctrlpoints[4][3] = {
	{ -4.0, -4.0, 0.0}, { -2.0, 4.0, 0.0}, 
	{2.0, -4.0, 0.0}, {4.0, 4.0, 0.0}};

void myinit(void)
{
    glClearColor(0.0, 0.0, 0.0, 1.0);
    glMap1f(GL_MAP1_VERTEX_3, 0.0, 1.0, 3, 4, &ctrlpoints[0][0]);
    glEnable(GL_MAP1_VERTEX_3);
    glShadeModel(GL_FLAT);
}

void display(void)
{
    int i;

    glClear(GL_COLOR_BUFFER_BIT);
    glColor3f(1.0, 1.0, 1.0);
    glBegin(GL_LINE_STRIP);
	for (i = 0; i <= 30; i++) 
	    glEvalCoord1f((GLfloat) i/30.0);
    glEnd();
    /* The following code displays the control points as dots. */
    glPointSize(5.0);
    glColor3f(1.0, 1.0, 0.0);
    glBegin(GL_POINTS);
	for (i = 0; i < 4; i++) 
	    glVertex3fv(&ctrlpoints[i][0]);
    glEnd();
    glFlush();
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (w <= h)
	glOrtho(-5.0, 5.0, -5.0*(GLfloat)h/(GLfloat)w, 
	    5.0*(GLfloat)h/(GLfloat)w, -5.0, 5.0);
    else
	glOrtho(-5.0*(GLfloat)w/(GLfloat)h, 
	    5.0*(GLfloat)w/(GLfloat)h, -5.0, 5.0, -5.0, 5.0);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
}

int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB);
    auxInitPosition (100, 50, 500, 500);
    auxInitWindow (argv[0]);
    myinit();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\checker.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*  checker.c
 *  This program texture maps a checkerboard image onto
 *  two rectangles.  This program clamps the texture, if
 *  the texture coordinates fall outside 0.0 and 1.0.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

/*	Create checkerboard texture	*/
#define	checkImageWidth 64
#define	checkImageHeight 64
GLubyte checkImage[checkImageWidth][checkImageHeight][3];

void makeCheckImage(void)
{
    int i, j, r, c;
    
    for (i = 0; i < checkImageWidth; i++) {
	for (j = 0; j < checkImageHeight; j++) {
	    c = ((((i&0x8)==0)^((j&0x8))==0))*255;
	    checkImage[i][j][0] = (GLubyte) c;
	    checkImage[i][j][1] = (GLubyte) c;
	    checkImage[i][j][2] = (GLubyte) c;
	}
    }
}

void myinit(void)
{    
    glClearColor (0.0, 0.0, 0.0, 0.0);
    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LESS);

    makeCheckImage();
    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
    glTexImage2D(GL_TEXTURE_2D, 0, 3, checkImageWidth, 
	checkImageHeight, 0, GL_RGB, GL_UNSIGNED_BYTE, 
	&checkImage[0][0][0]);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL);
    glEnable(GL_TEXTURE_2D);
    glShadeModel(GL_FLAT);
}

void display(void)
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glBegin(GL_QUADS);
    glTexCoord2f(0.0, 0.0); glVertex3f(-2.0, -1.0, 0.0);
    glTexCoord2f(0.0, 1.0); glVertex3f(-2.0, 1.0, 0.0);
    glTexCoord2f(1.0, 1.0); glVertex3f(0.0, 1.0, 0.0);
    glTexCoord2f(1.0, 0.0); glVertex3f(0.0, -1.0, 0.0);

    glTexCoord2f(0.0, 0.0); glVertex3f(1.0, -1.0, 0.0);
    glTexCoord2f(0.0, 1.0); glVertex3f(1.0, 1.0, 0.0);
    glTexCoord2f(1.0, 1.0); glVertex3f(2.41421, 1.0, -1.41421);
    glTexCoord2f(1.0, 0.0); glVertex3f(2.41421, -1.0, -1.41421);
    glEnd();
    glFlush();
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(60.0, 1.0*(GLfloat)w/(GLfloat)h, 1.0, 30.0);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    glTranslatef(0.0, 0.0, -3.6);
}

int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB | AUX_DEPTH16);
    auxInitPosition (100, 50, 500, 500);
    auxInitWindow (argv[0]);
    myinit();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\bezmesh.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*  bezsurf.c
 *  This program renders a lighted, filled Bezier surface,
 *  using two-dimensional evaluators.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

GLfloat ctrlpoints[4][4][3] = {
    {{-1.5, -1.5, 4.0}, {-0.5, -1.5, 2.0}, 
	{0.5, -1.5, -1.0}, {1.5, -1.5, 2.0}}, 
    {{-1.5, -0.5, 1.0}, {-0.5, -0.5, 3.0}, 
	{0.5, -0.5, 0.0}, {1.5, -0.5, -1.0}}, 
    {{-1.5, 0.5, 4.0}, {-0.5, 0.5, 0.0}, 
	{0.5, 0.5, 3.0}, {1.5, 0.5, 4.0}}, 
    {{-1.5, 1.5, -2.0}, {-0.5, 1.5, -2.0}, 
	{0.5, 1.5, 0.0}, {1.5, 1.5, -1.0}}
};

void initlights(void)
{
    GLfloat ambient[] = { 0.2, 0.2, 0.2, 1.0 };
    GLfloat position[] = { 0.0, 0.0, 2.0, 1.0 };
    GLfloat mat_diffuse[] = { 0.6, 0.6, 0.6, 1.0 };
    GLfloat mat_specular[] = { 1.0, 1.0, 1.0, 1.0 };
    GLfloat mat_shininess[] = { 50.0 };
    
    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);

    glLightfv(GL_LIGHT0, GL_AMBIENT, ambient);
    glLightfv(GL_LIGHT0, GL_POSITION, position);
    
    glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
    glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
    glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);
}

void display(void)
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glPushMatrix();
    glRotatef(85.0, 1.0, 1.0, 1.0);
    glEvalMesh2(GL_FILL, 0, 20, 0, 20);
    glPopMatrix();
    glFlush();
}

void myinit(void)
{
    glClearColor (0.0, 0.0, 0.0, 1.0);
    glEnable (GL_DEPTH_TEST);
    glMap2f(GL_MAP2_VERTEX_3, 0, 1, 3, 4,
	    0, 1, 12, 4, &ctrlpoints[0][0][0]);
    glEnable(GL_MAP2_VERTEX_3);
    glEnable(GL_AUTO_NORMAL);
    glEnable(GL_NORMALIZE);
    glMapGrid2f(20, 0.0, 1.0, 20, 0.0, 1.0);
    initlights();	/* for lighted version only */
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (w <= h)
	glOrtho(-4.0, 4.0, -4.0*(GLfloat)h/(GLfloat)w, 
	    4.0*(GLfloat)h/(GLfloat)w, -4.0, 4.0);
    else
	glOrtho(-4.0*(GLfloat)w/(GLfloat)h, 
	    4.0*(GLfloat)w/(GLfloat)h, -4.0, 4.0, -4.0, 4.0);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
}

int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB | AUX_DEPTH16);
    auxInitPosition (100, 50, 500, 500);
    auxInitWindow (argv[0]);
    myinit();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\checker2.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*  checker2.c
 *  This program texture maps a checkerboard image onto
 *  two rectangles.  This program repeats the texture, if
 *  the texture coordinates fall outside 0.0 and 1.0.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

/*	Create checkerboard texture	*/
#define	checkImageWidth 64
#define	checkImageHeight 64
GLubyte checkImage[checkImageWidth][checkImageHeight][3];

void makeCheckImage(void)
{
    int i, j, r, c;
    
    for (i = 0; i < checkImageWidth; i++) {
	for (j = 0; j < checkImageHeight; j++) {
	    c = ((((i&0x8)==0)^((j&0x8))==0))*255;
	    checkImage[i][j][0] = (GLubyte) c;
	    checkImage[i][j][1] = (GLubyte) c;
	    checkImage[i][j][2] = (GLubyte) c;
	}
    }
}

void myinit(void)
{    
    glClearColor (0.0, 0.0, 0.0, 0.0);
    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LESS);

    makeCheckImage();
    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
    glTexImage2D(GL_TEXTURE_2D, 0, 3, checkImageWidth, 
	checkImageHeight, 0, GL_RGB, GL_UNSIGNED_BYTE, 
	&checkImage[0][0][0]);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL);
    glEnable(GL_TEXTURE_2D);
    glShadeModel(GL_FLAT);
}

void display(void)
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glBegin(GL_QUADS);
    glTexCoord2f(0.0, 0.0); glVertex3f(-2.0, -1.0, 0.0);
    glTexCoord2f(0.0, 3.0); glVertex3f(-2.0, 1.0, 0.0);
    glTexCoord2f(3.0, 3.0); glVertex3f(0.0, 1.0, 0.0);
    glTexCoord2f(3.0, 0.0); glVertex3f(0.0, -1.0, 0.0);

    glTexCoord2f(0.0, 0.0); glVertex3f(1.0, -1.0, 0.0);
    glTexCoord2f(0.0, 3.0); glVertex3f(1.0, 1.0, 0.0);
    glTexCoord2f(3.0, 3.0); glVertex3f(2.41421, 1.0, -1.41421);
    glTexCoord2f(3.0, 0.0); glVertex3f(2.41421, -1.0, -1.41421);
    glEnd();
    glFlush();
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(60.0, 1.0*(GLfloat)w/(GLfloat)h, 1.0, 30.0);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    glTranslatef(0.0, 0.0, -3.6);
}

int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB | AUX_DEPTH16);
    auxInitPosition (100, 50, 500, 500);
    auxInitWindow (argv[0]);
    myinit();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\bezsurf.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*  bezmesh.c
 *  This program renders a wireframe Bezier surface,
 *  using two-dimensional evaluators.
 */

#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

GLfloat ctrlpoints[4][4][3] = {
    {{-1.5, -1.5, 4.0}, {-0.5, -1.5, 2.0}, 
	{0.5, -1.5, -1.0}, {1.5, -1.5, 2.0}}, 
    {{-1.5, -0.5, 1.0}, {-0.5, -0.5, 3.0}, 
	{0.5, -0.5, 0.0}, {1.5, -0.5, -1.0}}, 
    {{-1.5, 0.5, 4.0}, {-0.5, 0.5, 0.0}, 
	{0.5, 0.5, 3.0}, {1.5, 0.5, 4.0}}, 
    {{-1.5, 1.5, -2.0}, {-0.5, 1.5, -2.0}, 
	{0.5, 1.5, 0.0}, {1.5, 1.5, -1.0}}
};

void display(void)
{
    int i, j;

    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glColor3f(1.0, 1.0, 1.0);
    glPushMatrix ();
    glRotatef(85.0, 1.0, 1.0, 1.0);
    for (j = 0; j <= 8; j++) {
	glBegin(GL_LINE_STRIP);
        for (i = 0; i <= 30; i++)
	    glEvalCoord2f((GLfloat)i/30.0, (GLfloat)j/8.0);
	glEnd();
	glBegin(GL_LINE_STRIP);
        for (i = 0; i <= 30; i++)
	    glEvalCoord2f((GLfloat)j/8.0, (GLfloat)i/30.0);
	glEnd();
    }
    glPopMatrix ();
    glFlush();
}

void myinit(void)
{
    glClearColor (0.0, 0.0, 0.0, 1.0);
    glMap2f(GL_MAP2_VERTEX_3, 0, 1, 3, 4,
	    0, 1, 12, 4, &ctrlpoints[0][0][0]);
    glEnable(GL_MAP2_VERTEX_3);
    glMapGrid2f(20, 0.0, 1.0, 20, 0.0, 1.0);
    glEnable(GL_DEPTH_TEST);
    glShadeModel(GL_FLAT);
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (w <= h)
	glOrtho(-4.0, 4.0, -4.0*(GLfloat)h/(GLfloat)w, 
	    4.0*(GLfloat)h/(GLfloat)w, -4.0, 4.0);
    else
	glOrtho(-4.0*(GLfloat)w/(GLfloat)h, 
	    4.0*(GLfloat)w/(GLfloat)h, -4.0, 4.0, -4.0, 4.0);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
}

int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB | AUX_DEPTH16);
    auxInitPosition (0, 0, 500, 500);
    auxInitWindow (argv[0]);
    myinit();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\cirf.c ===
/* A simple program to build a circle with display lists */

#include <windows.h>
#include <stdio.h>
#include <math.h>
#include <GL/gl.h>
#include "glaux.h"

#define MY_CIRCLE_LIST	1
#define PI 3.1415926535897

void
buildCircle()
{
    GLint i;
    GLfloat cosine, sine;

    glNewList(MY_CIRCLE_LIST, GL_COMPILE);
        glBegin(GL_POLYGON);
            glColor3f(1.0F, 0.0F, 0.0F);
            for (i=0; i<100; i++) {
                cosine = cos(i*2*PI/100.0);
                sine = sin(i*2*PI/100.0);
                glVertex2f(cosine, sine);
            }
        glEnd();
    glEndList();
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
}

void display(void)
{
printf("display called\n");
    glClear(GL_COLOR_BUFFER_BIT);
    glCallList(MY_CIRCLE_LIST);
    glFlush();
}

void myinit(void)
{
    glClearColor(0.0F, 0.0F, 0.4F, 1.0F);
    glShadeModel(GL_FLAT);
    glDisable(GL_DEPTH_TEST);
    buildCircle();
}

void apressed(key, mask)
{
    printf("key is %d, mask is 0x%x\n", key, mask);
}

void LeftPressed(AUX_EVENTREC *event)
{
    printf("Left pressed (%d, %d)\n", event->data[AUX_MOUSEX],
		event->data[AUX_MOUSEY]);
}

void LeftReleased(AUX_EVENTREC *event)
{
    printf("Left released (%d, %d)\n", event->data[AUX_MOUSEX],
		event->data[AUX_MOUSEY]);
}

int main(int argc, char *argv[])
{
    auxInitDisplayMode(AUX_SINGLE | AUX_RGBA);
    auxInitPosition(100, 150, 300, 300);
    auxInitWindow("Tri");
    myinit();

    auxKeyFunc(AUX_a, apressed);
    auxMouseFunc(AUX_LEFTBUTTON, AUX_MOUSEDOWN, LeftPressed);
    auxMouseFunc(AUX_LEFTBUTTON, AUX_MOUSEUP, LeftReleased);
    auxReshapeFunc (myReshape);

    auxMainLoop(display);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\cir.c ===
/* A simple program to build a circle with display lists */

#include <windows.h>
#include <stdio.h>
#include <math.h>
#include <GL/gl.h>
#include "glaux.h"

#define MY_CIRCLE_LIST	1
#define PI 3.1415926535897

void
buildCircle()
{
    GLint i;
    GLfloat cosine, sine;

    glNewList(MY_CIRCLE_LIST, GL_COMPILE);
        glBegin(GL_LINE_STRIP);
            glColor3f(1.0F, 0.0F, 0.0F);
            for (i=0; i<100; i++) {
                cosine = cos(i*2*PI/100.0);
                sine = sin(i*2*PI/100.0);
                glVertex2f(cosine, sine);
            }
        glEnd();
    glEndList();
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
}

void display(void)
{
printf("display called\n");
    glClear(GL_COLOR_BUFFER_BIT);
    glCallList(MY_CIRCLE_LIST);
    glFlush();
}

void myinit(void)
{
    glClearColor(0.0F, 0.0F, 0.4F, 1.0F);
    glShadeModel(GL_FLAT);
    glDisable(GL_DEPTH_TEST);
    buildCircle();
}

void apressed(key, mask)
{
    printf("key is %d, mask is 0x%x\n", key, mask);
}

void LeftPressed(AUX_EVENTREC *event)
{
    printf("Left pressed (%d, %d)\n", event->data[AUX_MOUSEX],
		event->data[AUX_MOUSEY]);
}

void LeftReleased(AUX_EVENTREC *event)
{
    printf("Left released (%d, %d)\n", event->data[AUX_MOUSEX],
		event->data[AUX_MOUSEY]);
}

int main(int argc, char *argv[])
{
    auxInitDisplayMode(AUX_SINGLE | AUX_RGBA);
    auxInitPosition(100, 150, 300, 300);
    auxInitWindow("Tri");
    myinit();

    auxKeyFunc(AUX_a, apressed);
    auxMouseFunc(AUX_LEFTBUTTON, AUX_MOUSEDOWN, LeftPressed);
    auxMouseFunc(AUX_LEFTBUTTON, AUX_MOUSEUP, LeftReleased);
    auxReshapeFunc (myReshape);

    auxMainLoop(display);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\copyctx.c ===
#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

HGLRC ctx2;

void Initialize(void)
{
    ctx2 = wglCreateContext(auxGetHDC());
    if (ctx2 == NULL)
    {
        printf("Unable to create ctx2\n");
        exit(1);
    }
}

void TriangleAt(GLfloat x, GLfloat y, GLfloat z, BOOL colors)
{
    glPushMatrix();
    glTranslatef(x, y, z);
    
    glBegin (GL_TRIANGLES);
    if (colors)
    {
        glColor3f(1.0f, 0.0f, 0.0f);
    }
    glVertex2f (0.0f, 0.0f);
    if (colors)
    {
        glColor3f(0.0f, 1.0f, 0.0f);
    }
    glVertex2f (5.0f, 5.0f);
    if (colors)
    {
        glColor3f(0.0f, 0.0f, 1.0f);
    }
    glVertex2f (0.0f, 5.0f);
    glEnd ();
    
    glPopMatrix();
}

void Test(void)
{
    HGLRC old_ctx;

    old_ctx = wglGetCurrentContext();

    glColor3f(1.0f, 0.0f, 0.0f);
    TriangleAt(1.0f, 1.0f, 0.0f, FALSE);

    if (!wglCopyContext(old_ctx, ctx2, GL_CURRENT_BIT))
    {
        printf("Unable to copy context\n");
        exit(1);
    }

    wglMakeCurrent(auxGetHDC(), ctx2);

    // Should be red instead of white because current color is copied
    TriangleAt(7.0f, 1.0f, 0.0f, FALSE);

    wglMakeCurrent(auxGetHDC(), old_ctx);

    glEnable(GL_CULL_FACE);
    glCullFace(GL_FRONT);
    glDisable(GL_DITHER);

    // Should be culled
    TriangleAt(13.0f, 1.0f, 0.0f, TRUE);
    
    if (!wglCopyContext(old_ctx, ctx2, GL_COLOR_BUFFER_BIT))
    {
        printf("Unable to copy context\n");
        exit(1);
    }

    wglMakeCurrent(auxGetHDC(), ctx2);
    
    // Should be drawn but not dithered since we only copied the
    // color buffer state
    TriangleAt(19.0f, 1.0f, 0.0f, TRUE);
    
    wglMakeCurrent(auxGetHDC(), old_ctx);

    if (!wglCopyContext(old_ctx, ctx2, GL_POLYGON_BIT))
    {
        printf("Unable to copy context\n");
        exit(1);
    }

    wglMakeCurrent(auxGetHDC(), ctx2);
    
    // Should be culled now that the culling been copied
    TriangleAt(25.0f, 1.0f, 0.0f, TRUE);
    
    wglMakeCurrent(auxGetHDC(), old_ctx);
}

void display(void)
{
    glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    Test ();
    glFlush ();
}

void myReshape(GLsizei w, GLsizei h)
{
    HGLRC old_ctx;

    old_ctx = wglGetCurrentContext();
    
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (w <= h) 
	gluOrtho2D (0.0, 100.0, 0.0, 100.0 * (GLfloat) h/(GLfloat) w);
    else 
	gluOrtho2D (0.0, 100.0 * (GLfloat) w/(GLfloat) h, 0.0, 100.0);
    glMatrixMode(GL_MODELVIEW);

    wglMakeCurrent(auxGetHDC(), ctx2);
    
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (w <= h) 
	gluOrtho2D (0.0, 100.0, 0.0, 100.0 * (GLfloat) h/(GLfloat) w);
    else 
	gluOrtho2D (0.0, 100.0 * (GLfloat) w/(GLfloat) h, 0.0, 100.0);
    glMatrixMode(GL_MODELVIEW);
    
    wglMakeCurrent(auxGetHDC(), old_ctx);
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, and handle input events.
 */
int __cdecl main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB | AUX_DEPTH16);
    auxInitPosition (0, 0, 500, 500);
    auxInitWindow ("CopyContext Test");
    Initialize();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\copyback.c ===
#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

#define WIDTH 500
#define HEIGHT 500

void TriangleAt(GLfloat x, GLfloat y, GLfloat z, GLfloat size, BOOL colors)
{
    glPushMatrix();
    glTranslatef(x, y, z);
    
    glBegin (GL_TRIANGLES);
    if (colors)
    {
        glColor3f(1.0f, 0.0f, 0.0f);
    }
    glVertex2f (0.0f, 0.0f);
    if (colors)
    {
        glColor3f(0.0f, 1.0f, 0.0f);
    }
    glVertex2f (size, size);
    if (colors)
    {
        glColor3f(0.0f, 0.0f, 1.0f);
    }
    glVertex2f (0.0f, size);
    glEnd ();
    
    glPopMatrix();
}

void gl_copy(void)
{
   GLint    ix, iy;
   GLsizei  w, h;
   GLdouble rx1,ry1,rx2,ry2;
   GLint    mm, dm;

   ix  = 0;
   iy  = 0;
   w   = WIDTH;
   h   = HEIGHT;
   rx1 = 0.;
   ry1 = 0;
   rx2 = WIDTH;
   ry2 = HEIGHT;
   glViewport(ix, iy, w, h);
   glGetIntegerv(GL_MATRIX_MODE, &mm);
   glMatrixMode(GL_PROJECTION);
   glLoadIdentity();
   gluOrtho2D(rx1, rx2, ry1, ry2);
   glMatrixMode(mm);

   glScissor (ix, iy, w, h);
   glRasterPos2i (ix,iy);
#if 0
   glGetIntegerv(GL_DITHER, &dm);
   if (dm)
   {
       glDisable(GL_DITHER);
   }
#endif
   glCopyPixels (ix, iy, w, h, GL_COLOR);
#if 0
   if (dm)
   {
       glEnable(GL_DITHER);
   }
#endif
   glFlush();
}

void Test(void)
{
    glDrawBuffer(GL_FRONT);
    TriangleAt(1.0f, 1.0f, 0.0f, 98.0f, TRUE);
    glDrawBuffer(GL_BACK);
    glReadBuffer(GL_FRONT);
    gl_copy();
    TriangleAt(10.0f, 10.0f, 0.0f, 80.0f, TRUE);
    auxSwapBuffers();
}

void display(void)
{
    glClear (GL_COLOR_BUFFER_BIT);
    Test ();
    glFlush ();
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (w <= h) 
	gluOrtho2D (0.0, 100.0, 0.0, 100.0 * (GLfloat) h/(GLfloat) w);
    else 
	gluOrtho2D (0.0, 100.0 * (GLfloat) w/(GLfloat) h, 0.0, 100.0);
    glMatrixMode(GL_MODELVIEW);
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, and handle input events.
 */
int __cdecl main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_DOUBLE | AUX_RGB);
    auxInitPosition (15, 15, WIDTH, HEIGHT);
    auxInitWindow ("Copying Front Buffer to Back Buffer Test");
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\cone.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 * cone.c
 * This program demonstrates the use of the GL lighting model.
 * A sphere is drawn using a grey material characteristic. 
 * A single light source illuminates the object.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

/*  Initialize material property, light source, and lighting model.
 */
void myinit(void)
{
    GLfloat mat_ambient[] = { 0.2, 0.2, 0.2, 1.0 };
    GLfloat mat_diffuse[] = { 0.8, 0.8, 0.8, 1.0 };
/*	mat_specular and mat_shininess are NOT default values	*/
    GLfloat mat_specular[] = { 1.0, 1.0, 1.0, 1.0 };
    GLfloat mat_shininess[] = { 50.0 };

    GLfloat light_ambient[] = { 0.0, 0.0, 0.0, 1.0 };
    GLfloat light_diffuse[] = { 1.0, 1.0, 1.0, 1.0 };
    GLfloat light_specular[] = { 1.0, 1.0, 1.0, 1.0 };
/*	light_position is NOT default value	*/
    GLfloat light_position[] = { 1.0, 1.0, 1.0, 0.0 };

    GLfloat lmodel_ambient[] = { 0.2, 0.2, 0.2, 1.0 };

    glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
    glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
    glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);

    glLightfv(GL_LIGHT0, GL_AMBIENT, light_ambient);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, light_diffuse);
    glLightfv(GL_LIGHT0, GL_SPECULAR, light_specular);
    glLightfv(GL_LIGHT0, GL_POSITION, light_position);
    
    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_ambient);

    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);

    glDepthFunc(GL_LESS);
    glEnable(GL_DEPTH_TEST);
}

void display(void)
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glPushMatrix();
    glTranslatef (0.0, -1.0, 0.0); 
    glRotatef (250.0, 1.0, 0.0, 0.0);
    auxSolidCone(1.0, 2.0);
    glPopMatrix();
    glFlush();
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (w <= h) 
	glOrtho (-1.5, 1.5, -1.5*(GLfloat)h/(GLfloat)w, 
	    1.5*(GLfloat)h/(GLfloat)w, -10.0, 10.0);
    else 
	glOrtho (-1.5*(GLfloat)w/(GLfloat)h, 
	    1.5*(GLfloat)w/(GLfloat)h, -1.5, 1.5, -10.0, 10.0);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB | AUX_DEPTH16);
    auxInitPosition (0, 0, 500, 500);
    auxInitWindow (argv[0]);
    myinit();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\clip.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  clip.c
 *  This program demonstrates arbitrary clipping planes.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

void display(void)
{
    GLdouble eqn[4] = {0.0, 1.0, 0.0, 0.0};
    GLdouble eqn2[4] = {1.0, 0.0, 0.0, 0.0};

    glClear(GL_COLOR_BUFFER_BIT);

    glColor3f (1.0, 1.0, 1.0);
    glPushMatrix();
    glTranslatef (0.0, 0.0, -5.0);

/*    clip lower half -- y < 0		*/
    glClipPlane (GL_CLIP_PLANE0, eqn);
    glEnable (GL_CLIP_PLANE0);
/*    clip left half -- x < 0		*/
    glClipPlane (GL_CLIP_PLANE1, eqn2);
    glEnable (GL_CLIP_PLANE1);

    glRotatef (90.0, 1.0, 0.0, 0.0);
    auxWireSphere(1.0);
    glPopMatrix();
    glFlush();
}

void myinit (void) {
    glShadeModel (GL_FLAT);
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(60.0, (GLfloat) w/(GLfloat) h, 1.0, 20.0);
    glMatrixMode(GL_MODELVIEW);
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB);
    auxInitPosition (0, 0, 500, 500);
    auxInitWindow (argv[0]);
    myinit ();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\colormat.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  colormat.c
 *  After initialization, the program will be in 
 *  ColorMaterial mode.  Pressing the mouse buttons 
 *  will change the color of the diffuse reflection.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

GLfloat diffuseMaterial[4] = { 0.5, 0.5, 0.5, 1.0 };

/*  Initialize values for material property, light source, 
 *  lighting model, and depth buffer.  
 */
void myinit(void)
{
    GLfloat mat_specular[] = { 1.0, 1.0, 1.0, 1.0 };
    GLfloat light_position[] = { 1.0, 1.0, 1.0, 0.0 };

    glMaterialfv(GL_FRONT, GL_DIFFUSE, diffuseMaterial);
    glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
    glMaterialf(GL_FRONT, GL_SHININESS, 25.0);
    glLightfv(GL_LIGHT0, GL_POSITION, light_position);

    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);
    glDepthFunc(GL_LESS);
    glEnable(GL_DEPTH_TEST);

    glColorMaterial(GL_FRONT, GL_DIFFUSE);
    glEnable(GL_COLOR_MATERIAL);
}

void changeRedDiffuse (AUX_EVENTREC *event)
{
    diffuseMaterial[0] += 0.1;
    if (diffuseMaterial[0] > 1.0)
	diffuseMaterial[0] = 0.0;
    glColor4fv(diffuseMaterial);
}

void changeGreenDiffuse (AUX_EVENTREC *event)
{
    diffuseMaterial[1] += 0.1;
    if (diffuseMaterial[1] > 1.0)
	diffuseMaterial[1] = 0.0;
    glColor4fv(diffuseMaterial);
}

void changeBlueDiffuse (AUX_EVENTREC *event)
{
    diffuseMaterial[2] += 0.1;
    if (diffuseMaterial[2] > 1.0)
	diffuseMaterial[2] = 0.0;
    glColor4fv(diffuseMaterial);
}

void display(void)
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    auxSolidSphere(1.0);
    glFlush();
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (w <= h) 
	glOrtho (-1.5, 1.5, -1.5*(GLfloat)h/(GLfloat)w, 
	    1.5*(GLfloat)h/(GLfloat)w, -10.0, 10.0);
    else 
	glOrtho (-1.5*(GLfloat)w/(GLfloat)h, 
	    1.5*(GLfloat)w/(GLfloat)h, -1.5, 1.5, -10.0, 10.0);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
}

int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB | AUX_DEPTH16);
    auxInitPosition (0, 0, 500, 500);
    auxInitWindow (argv[0]);
    myinit();
    auxMouseFunc (AUX_LEFTBUTTON, AUX_MOUSEDOWN, changeRedDiffuse);
    auxMouseFunc (AUX_MIDDLEBUTTON, AUX_MOUSEDOWN, changeGreenDiffuse);
    auxMouseFunc (AUX_RIGHTBUTTON, AUX_MOUSEDOWN, changeBlueDiffuse);
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\cube.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  cube.c
 *  Draws a 3-D cube, viewed with perspective, stretched 
 *  along the y-axis.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

/*  Clear the screen.  Set the current color to white.
 *  Draw the wire frame cube.
 */
void display (void)
{
    glClear(GL_COLOR_BUFFER_BIT);
    glColor3f (1.0, 1.0, 1.0);
    glLoadIdentity ();	/*  clear the matrix	*/
    glTranslatef (0.0, 0.0, -5.0);	/*  viewing transformation	*/
    glScalef (1.0, 2.0, 1.0);	/*  modeling transformation	*/
    auxWireCube(1.0);	/*  draw the cube	*/
    glFlush();
}

void myinit (void) {
    glShadeModel (GL_FLAT);
}

/*  Called when the window is first opened and whenever 
 *  the window is reconfigured (moved or resized).
 */
void myReshape(GLsizei w, GLsizei h)
{
    glMatrixMode (GL_PROJECTION);	/*  prepare for and then  */ 
    glLoadIdentity ();	/*  define the projection  */
    glFrustum (-1.0, 1.0, -1.0, 1.0, 1.5, 20.0);	/*  transformation  */
    glMatrixMode (GL_MODELVIEW);	/*  back to modelview matrix	*/
    glViewport (0, 0, w, h);	/*  define the viewport	*/
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB);
    auxInitPosition (0, 0, 500, 500);
    auxInitWindow (argv[0]);
    myinit ();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\depthcue.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  depthcue.c
 *  This program draws a wireframe model, which uses 
 *  intensity (brightness) to give clues to distance.
 *  Fog is used to achieve this effect.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

/*  Initialize linear fog for depth cueing.
 */
void myinit(void)
{
    GLfloat fogColor[4] = {0.0, 0.0, 0.0, 1.0};

    glEnable(GL_FOG);
    glFogi (GL_FOG_MODE, GL_LINEAR);
    glHint (GL_FOG_HINT, GL_NICEST);  /*  per pixel   */
    glFogf (GL_FOG_START, 3.0);
    glFogf (GL_FOG_END, 5.0);
    glFogfv (GL_FOG_COLOR, fogColor);
    glClearColor(0.0, 0.0, 0.0, 1.0);

    glDepthFunc(GL_LESS);
    glEnable(GL_DEPTH_TEST);
    glShadeModel(GL_FLAT);
}

/*  display() draws an icosahedron.
 */
void display(void)
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glColor3f (1.0, 1.0, 1.0);
    auxWireIcosahedron(1.0);
    glFlush();
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective (45.0, (GLfloat) w/(GLfloat) h, 3.0, 5.0);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity ();
    glTranslatef (0.0, 0.0, -4.0);  /*  move object into view   */
}

/*  Main Loop
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB | AUX_DEPTH16);
    auxInitPosition (0, 0, 400, 400);
    auxInitWindow (argv[0]);
    myinit();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\curve.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  curve.c
 *  This program uses the Utility Library NURBS routines to
 *  draw a one-dimensional NURBS curve.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

GLUnurbsObj *theNurb;

void myinit(void)
{
    glShadeModel (GL_FLAT);
    theNurb = gluNewNurbsRenderer();
    gluNurbsProperty (theNurb, GLU_SAMPLING_TOLERANCE, 10.0);
}

/*  This routine draws a B-spline curve.  Try a different 
 *  knot sequence for a Bezier curve.  For example,
    GLfloat knots[8] = {0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0};
 */

void display(void)
{
    GLfloat ctlpoints[4][3] = {{-.75, -.75, 0.0}, 
	{-.5, .75, 0.0}, {.5, .75, 0.0}, {.75, -.75, 0.0}};
    GLfloat knots[8] = {0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0}; 

    glClear(GL_COLOR_BUFFER_BIT);
    glColor3f (1.0, 1.0, 1.0);
    gluBeginCurve(theNurb);
    gluNurbsCurve(theNurb, 
	    8, knots,
	    3,
	    &ctlpoints[0][0], 
	    4,
	    GL_MAP1_VERTEX_3);
    gluEndCurve(theNurb);
    glFlush();
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (w <= h)
	gluOrtho2D (-1.0, 1.0, -1.0 * (GLfloat) h/(GLfloat) w, 
	    1.0 * (GLfloat) h/(GLfloat) w);
    else
	gluOrtho2D (-1.0 * (GLfloat) w/(GLfloat) h,
	    1.0 * (GLfloat) w/(GLfloat) h, -1.0, 1.0);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
}

/*  Main Loop 
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB);
    auxInitPosition (0, 0, 500, 500);
    auxInitWindow (argv[0]);
    myinit();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\dof.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  dof.c
 *  This program demonstrates use of the accumulation buffer to
 *  create an out-of-focus depth-of-field effect.  The teapots
 *  are drawn several times into the accumulation buffer.  The
 *  viewing volume is jittered, except at the focal point, where
 *  the viewing volume is at the same position, each time.  In
 *  this case, the gold teapot remains in focus.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include <math.h>
#include "glaux.h"
#include "jitter.h"

#define PI_ 3.14159265358979323846

/*	accFrustum()
 *  The first 6 arguments are identical to the glFrustum() call.
 *  
 *  pixdx and pixdy are anti-alias jitter in pixels. 
 *  Set both equal to 0.0 for no anti-alias jitter.
 *  eyedx and eyedy are depth-of field jitter in pixels. 
 *  Set both equal to 0.0 for no depth of field effects.
 *
 *  focus is distance from eye to plane in focus. 
 *  focus must be greater than, but not equal to 0.0.
 *
 *  Note that accFrustum() calls glTranslatef().  You will 
 *  probably want to insure that your ModelView matrix has been 
 *  initialized to identity before calling accFrustum().
 */
void accFrustum(GLdouble left, GLdouble right, GLdouble bottom, 
    GLdouble top, GLdouble znear, GLdouble zfar, GLdouble pixdx, 
    GLdouble pixdy, GLdouble eyedx, GLdouble eyedy, GLdouble focus)
{
    GLdouble xwsize, ywsize; 
    GLdouble dx, dy;
    GLint viewport[4];

    glGetIntegerv (GL_VIEWPORT, viewport);
	
    xwsize = right - left;
    ywsize = top - bottom;
	
    dx = -(pixdx*xwsize/(GLdouble) viewport[2] + eyedx*znear/focus);
    dy = -(pixdy*ywsize/(GLdouble) viewport[3] + eyedy*znear/focus);
	
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glFrustum (left + dx, right + dx, bottom + dy, top + dy, znear, zfar);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    glTranslatef (-eyedx, -eyedy, 0.0);
}

/*  accPerspective()
 * 
 *  The first 4 arguments are identical to the gluPerspective() call.
 *  pixdx and pixdy are anti-alias jitter in pixels. 
 *  Set both equal to 0.0 for no anti-alias jitter.
 *  eyedx and eyedy are depth-of field jitter in pixels. 
 *  Set both equal to 0.0 for no depth of field effects.
 *
 *  focus is distance from eye to plane in focus. 
 *  focus must be greater than, but not equal to 0.0.
 *
 *  Note that accPerspective() calls accFrustum().
 */
void accPerspective(GLdouble fovy, GLdouble aspect, 
    GLdouble znear, GLdouble zfar, GLdouble pixdx, GLdouble pixdy, 
    GLdouble eyedx, GLdouble eyedy, GLdouble focus)
{
    GLdouble fov2,left,right,bottom,top;

    fov2 = ((fovy*PI_) / 180.0) / 2.0;

    top = znear / (cos(fov2) / sin(fov2));
    bottom = -top;

    right = top * aspect;
    left = -right;

    accFrustum (left, right, bottom, top, znear, zfar,
	pixdx, pixdy, eyedx, eyedy, focus);
}

void myinit(void)
{
    GLfloat ambient[] = { 0.0, 0.0, 0.0, 1.0 };
    GLfloat diffuse[] = { 1.0, 1.0, 1.0, 1.0 };
    GLfloat specular[] = { 1.0, 1.0, 1.0, 1.0 };
    GLfloat position[] = { 0.0, 3.0, 3.0, 0.0 };
    
    GLfloat lmodel_ambient[] = { 0.2, 0.2, 0.2, 1.0 };
    GLfloat local_view[] = { 0.0 };

    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LESS);

    glLightfv(GL_LIGHT0, GL_AMBIENT, ambient);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuse);
    glLightfv(GL_LIGHT0, GL_POSITION, position);
    
    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_ambient);
    glLightModelfv(GL_LIGHT_MODEL_LOCAL_VIEWER, local_view);

    glFrontFace (GL_CW);
    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);
    glEnable(GL_AUTO_NORMAL);
    glEnable(GL_NORMALIZE);

    glMatrixMode (GL_MODELVIEW);
    glLoadIdentity ();

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glClearAccum(0.0, 0.0, 0.0, 0.0);
}

void renderTeapot (GLfloat x, GLfloat y, GLfloat z, 
    GLfloat ambr, GLfloat ambg, GLfloat ambb, 
    GLfloat difr, GLfloat difg, GLfloat difb, 
    GLfloat specr, GLfloat specg, GLfloat specb, GLfloat shine)
{
    float mat[3];

    glPushMatrix();
    glTranslatef (x, y, z);
    mat[0] = ambr; mat[1] = ambg; mat[2] = ambb;	
    glMaterialfv (GL_FRONT, GL_AMBIENT, mat);
    mat[0] = difr; mat[1] = difg; mat[2] = difb;	
    glMaterialfv (GL_FRONT, GL_DIFFUSE, mat);
    mat[0] = specr; mat[1] = specg; mat[2] = specb;
    glMaterialfv (GL_FRONT, GL_SPECULAR, mat);
    glMaterialf (GL_FRONT, GL_SHININESS, shine*128.0);
    auxSolidTeapot(0.5);
    glPopMatrix();
}

/*  display() draws 5 teapots into the accumulation buffer 
 *  several times; each time with a jittered perspective.
 *  The focal point is at z = 5.0, so the gold teapot will 
 *  stay in focus.  The amount of jitter is adjusted by the
 *  magnitude of the accPerspective() jitter; in this example, 0.33.
 *  In this example, the teapots are drawn 8 times.  See jitter.h
 */
void display(void)
{
    int jitter;
    GLint viewport[4];

    glGetIntegerv (GL_VIEWPORT, viewport);
    glClear(GL_ACCUM_BUFFER_BIT);

    for (jitter = 0; jitter < 8; jitter++) {
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
	accPerspective (45.0, 
		(GLdouble) viewport[2]/(GLdouble) viewport[3], 
		1.0, 15.0, 0.0, 0.0,
		0.33*j8[jitter].x, 0.33*j8[jitter].y, 5.0);
/*	ruby, gold, silver, emerald, and cyan teapots	*/
	renderTeapot (-1.1, -0.5, -4.5, 0.1745, 0.01175, 0.01175,
	    0.61424, 0.04136, 0.04136, 0.727811, 0.626959, 0.626959, 0.6);
	renderTeapot (-0.5, -0.5, -5.0, 0.24725, 0.1995, 0.0745,
	    0.75164, 0.60648, 0.22648, 0.628281, 0.555802, 0.366065, 0.4);
	renderTeapot (0.2, -0.5, -5.5, 0.19225, 0.19225, 0.19225,
	    0.50754, 0.50754, 0.50754, 0.508273, 0.508273, 0.508273, 0.4);
	renderTeapot (1.0, -0.5, -6.0, 0.0215, 0.1745, 0.0215, 
	    0.07568, 0.61424, 0.07568, 0.633, 0.727811, 0.633, 0.6);
	renderTeapot (1.8, -0.5, -6.5, 0.0, 0.1, 0.06, 0.0, 0.50980392, 
	    0.50980392, 0.50196078, 0.50196078, 0.50196078, .25);
	glAccum (GL_ACCUM, 0.125);
    	glFlush();
	auxSwapBuffers();
    }

    glAccum (GL_RETURN, 1.0);
    glFlush();
    auxSwapBuffers();
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, depth buffer, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_DOUBLE | AUX_RGB
			| AUX_ACCUM | AUX_DEPTH16);
    auxInitPosition (0, 0, 400, 400);
    auxInitWindow (argv[0]);
    myinit();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\disk.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  disk.c
 *  This program demonstrates the use of the quadrics
 *  Utility Library routines to draw circles and arcs.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

GLUquadricObj * quadObj;

/*  Clear the screen.  For each triangle, set the current 
 *  color and modify the modelview matrix.
 */
void display(void)
{
    glClearColor (0.0, 0.0, 0.0, 1.0);
    glClear (GL_COLOR_BUFFER_BIT);

    glPushMatrix();
    gluQuadricDrawStyle (quadObj, GLU_FILL);
    glColor3f (1.0, 1.0, 1.0);
    glTranslatef (10.0, 10.0, 0.0);
    gluDisk (quadObj, 0.0, 5.0, 10, 2);
    glPopMatrix();

    glPushMatrix();
    glColor3f (1.0, 1.0, 0.0);
    glTranslatef (20.0, 20.0, 0.0);
    gluPartialDisk (quadObj, 0.0, 5.0, 10, 3, 30.0, 120.0);
    glPopMatrix();

    glPushMatrix();
    gluQuadricDrawStyle (quadObj, GLU_SILHOUETTE);
    glColor3f (0.0, 1.0, 1.0);
    glTranslatef (30.0, 30.0, 0.0);
    gluPartialDisk (quadObj, 0.0, 5.0, 10, 3, 135.0, 270.0);
    glPopMatrix();

    glPushMatrix();
    gluQuadricDrawStyle (quadObj, GLU_LINE);
    glColor3f (1.0, 0.0, 1.0);
    glTranslatef (40.0, 40.0, 0.0);
    gluDisk (quadObj, 2.0, 5.0, 10, 10);
    glPopMatrix();
    glFlush();
}

void myinit (void) {
    quadObj = gluNewQuadric ();
    glShadeModel(GL_FLAT);
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (w <= h) 
	glOrtho (0.0, 50.0, 
	    0.0, 50.0*(GLfloat)h/(GLfloat)w, -1.0, 1.0);
    else 
	glOrtho (0.0, 50.0*(GLfloat)w/(GLfloat)h, 
	    0.0, 50.0, -1.0, 1.0);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity ();
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB);
    auxInitPosition (100, 50, 500, 500);
    auxInitWindow (argv[0]);
    myinit ();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\double.c ===
/*
 *  double.c
 *  This program demonstrates double buffering for 
 *  flicker-free animation.  The left and middle mouse
 *  buttons start and stop the spinning motion of the square.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

static GLfloat spin = 0.0;

void display(void)
{
    glClear (GL_COLOR_BUFFER_BIT);

    glPushMatrix ();
    glRotatef (spin, 0.0, 0.0, 1.0);
    glRectf (-25.0, -25.0, 25.0, 25.0);
    glPopMatrix ();

    glFlush();
//    glXSwapBuffers (auxXDisplay(), auxXWindow());
    auxSwapBuffers();
}

void spinDisplay (void)
{
    spin = spin + 2.0;
    if (spin > 360.0)
	spin = spin - 360.0;
    display();
}

void startIdleFunc (AUX_EVENTREC *event)
{
    auxIdleFunc(spinDisplay);
}

void stopIdleFunc (AUX_EVENTREC *event)
{
    auxIdleFunc(0);
}

void myinit (void)
{
    glClearColor (0.0, 0.0, 0.0, 1.0);
    glColor3f (1.0, 1.0, 1.0);
    glShadeModel (GL_FLAT);
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (w <= h) 
	glOrtho (-50.0, 50.0, -50.0*(GLfloat)h/(GLfloat)w, 
	    50.0*(GLfloat)h/(GLfloat)w, -1.0, 1.0);
    else 
	glOrtho (-50.0*(GLfloat)w/(GLfloat)h, 
	    50.0*(GLfloat)w/(GLfloat)h, -50.0, 50.0, -1.0, 1.0);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity ();
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_DOUBLE | AUX_RGB);
    auxInitPosition (0, 0, 500, 500);
    auxInitWindow (argv[0]);
    myinit ();
    auxReshapeFunc (myReshape);
    auxIdleFunc (spinDisplay);
    auxMouseFunc (AUX_LEFTBUTTON, AUX_MOUSEDOWN, startIdleFunc);
    auxMouseFunc (AUX_MIDDLEBUTTON, AUX_MOUSEDOWN, stopIdleFunc);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\drawboth.c ===
#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

void Initialize(void)
{
    glDrawBuffer(GL_FRONT_AND_BACK);
}

void TriangleAt(GLfloat x, GLfloat y, GLfloat z, GLfloat size, BOOL colors)
{
    glPushMatrix();
    glTranslatef(x, y, z);
    
    glBegin (GL_TRIANGLES);
    if (colors)
    {
        glColor3f(1.0f, 0.0f, 0.0f);
    }
    glVertex2f (0.0f, 0.0f);
    if (colors)
    {
        glColor3f(0.0f, 1.0f, 0.0f);
    }
    glVertex2f (size, size);
    if (colors)
    {
        glColor3f(0.0f, 0.0f, 1.0f);
    }
    glVertex2f (0.0f, size);
    glEnd ();
    
    glPopMatrix();
}

void Test(void)
{
    TriangleAt(1.0f, 1.0f, 0.0f, 98.0f, TRUE);
    glFlush();
    Sleep(1000);
    auxSwapBuffers();
}

void display(void)
{
    glClear (GL_COLOR_BUFFER_BIT);
    Test ();
    glFlush ();
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (w <= h) 
	gluOrtho2D (0.0, 100.0, 0.0, 100.0 * (GLfloat) h/(GLfloat) w);
    else 
	gluOrtho2D (0.0, 100.0 * (GLfloat) w/(GLfloat) h, 0.0, 100.0);
    glMatrixMode(GL_MODELVIEW);
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, and handle input events.
 */
int __cdecl main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_DOUBLE | AUX_RGB);
    auxInitPosition (15, 15, 500, 500);
    auxInitWindow ("GL_FRONT_AND_BACK Test");
    Initialize();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\dofnot.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  dofnot.c
 *  This program demonstrates the same scene as dof.c, but
 *  without use of the accumulation buffer, so everything
 *  is in focus.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include <math.h>
#include "glaux.h"

void myinit(void)
{
    GLfloat ambient[] = { 0.0, 0.0, 0.0, 1.0 };
    GLfloat diffuse[] = { 1.0, 1.0, 1.0, 1.0 };
    GLfloat specular[] = { 1.0, 1.0, 1.0, 1.0 };
    GLfloat position[] = { 0.0, 3.0, 3.0, 0.0 };
    
    GLfloat lmodel_ambient[] = { 0.2, 0.2, 0.2, 1.0 };
    GLfloat local_view[] = { 0.0 };

    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LESS);

    glLightfv(GL_LIGHT0, GL_AMBIENT, ambient);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuse);
    glLightfv(GL_LIGHT0, GL_POSITION, position);
    
    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_ambient);
    glLightModelfv(GL_LIGHT_MODEL_LOCAL_VIEWER, local_view);

    glFrontFace (GL_CW);
    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);
    glEnable(GL_AUTO_NORMAL);
    glEnable(GL_NORMALIZE);

    glClearColor(0.0, 0.0, 0.0, 0.0);
}

void renderTeapot (GLfloat x, GLfloat y, GLfloat z, 
    GLfloat ambr, GLfloat ambg, GLfloat ambb, 
    GLfloat difr, GLfloat difg, GLfloat difb, 
    GLfloat specr, GLfloat specg, GLfloat specb, GLfloat shine)
{
    float mat[3];

    glPushMatrix();
    glTranslatef (x, y, z);
    mat[0] = ambr; mat[1] = ambg; mat[2] = ambb;	
    glMaterialfv (GL_FRONT, GL_AMBIENT, mat);
    mat[0] = difr; mat[1] = difg; mat[2] = difb;	
    glMaterialfv (GL_FRONT, GL_DIFFUSE, mat);
    mat[0] = specr; mat[1] = specg; mat[2] = specb;
    glMaterialfv (GL_FRONT, GL_SPECULAR, mat);
    glMaterialf (GL_FRONT, GL_SHININESS, shine*128.0);
    auxSolidTeapot(0.5);
    glPopMatrix();
}

/*  display() draws 5 teapots into the accumulation buffer 
 *  several times; each time with a jittered perspective.
 *  The focal point is at z = 5.0, so the gold teapot will 
 *  stay in focus.  The amount of jitter is adjusted by the
 *  magnitude of the accPerspective() jitter; in this example, 0.33.
 *  In this example, the teapots are drawn 8 times.  See jitter.h
 */
void display(void)
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    glPushMatrix ();
/*	ruby, gold, silver, emerald, and cyan teapots	*/
	renderTeapot (-1.1, -0.5, -4.5, 0.1745, 0.01175, 0.01175,
	    0.61424, 0.04136, 0.04136, 0.727811, 0.626959, 0.626959, 0.6);
	renderTeapot (-0.5, -0.5, -5.0, 0.24725, 0.1995, 0.0745,
	    0.75164, 0.60648, 0.22648, 0.628281, 0.555802, 0.366065, 0.4);
	renderTeapot (0.2, -0.5, -5.5, 0.19225, 0.19225, 0.19225,
	    0.50754, 0.50754, 0.50754, 0.508273, 0.508273, 0.508273, 0.4);
	renderTeapot (1.0, -0.5, -6.0, 0.0215, 0.1745, 0.0215, 
	    0.07568, 0.61424, 0.07568, 0.633, 0.727811, 0.633, 0.6);
	renderTeapot (1.8, -0.5, -6.5, 0.0, 0.1, 0.06, 0.0, 0.50980392, 
	    0.50980392, 0.50196078, 0.50196078, 0.50196078, .25);

    glPopMatrix ();
    glFlush();
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode (GL_PROJECTION);
    glLoadIdentity ();
    gluPerspective (45.0, (GLfloat) w/(GLfloat) h, 
		1.0, 15.0);
    glMatrixMode (GL_MODELVIEW);
    glLoadIdentity ();
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, depth buffer, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB | AUX_DEPTH16);
    auxInitPosition (0, 0, 400, 400);
    auxInitWindow (argv[0]);
    myinit();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\drawbuf.c ===
/*
 * "drawmode.c" - A test program demonstrating the use of glDepthFunc()
 *                and glDrawMode().
 *
 * Press the 'd' key to toggle between GL_LESS and GL_GREATER depth
 * tests.  Press the 'ESC' key to quit.
 */

#include <GL/glaux.h>

/*
 * These #define constants are provided for compatibility between MS Windows
 * and the rest of the world.
 *
 * CALLBACK and APIENTRY are function modifiers under MS Windows.
 */

#ifndef WIN32
#  define CALLBACK
#  define APIENTRY
#endif /* !WIN32 */


GLenum	depth_function = GL_LESS;	/* Current depth function */


/*
 * 'reshape_scene()' - Change the size of the scene...
 */

void CALLBACK
reshape_scene(GLsizei width,	/* I - Width of the window in pixels */
              GLsizei height)	/* I - Height of the window in pixels */
{
 /*
  * Reset the current viewport and perspective transformation...
  */

  glViewport(0, 0, width, height);

  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  gluPerspective(22.5, (float)width / (float)height, 0.1, 1000.0);

  glMatrixMode(GL_MODELVIEW);
}


/*
 * 'draw_scene()' - Draw a scene containing a cube with a sphere in front of
 *                  it.
 */

void CALLBACK
draw_scene(void)
{
  static float	red_light[4] = { 1.0, 0.0, 0.0, 1.0 };
  static float	red_pos[4] = { 1.0, 1.0, 1.0, 0.0 };
  static float	blue_light[4] = { 0.0, 0.0, 1.0, 1.0 };
  static float	blue_pos[4] = { -1.0, -1.0, -1.0, 0.0 };


 /*
  * Enable drawing features that we need...
  */

  glEnable(GL_DEPTH_TEST);
  glEnable(GL_LIGHTING);
  glEnable(GL_LIGHT0);
  glEnable(GL_LIGHT1);

  glDepthFunc(depth_function); 

 /*
  * Clear the color and depth buffers...
  */

  if (depth_function == GL_LESS)
    glClearDepth(1.0);
  else
    glClearDepth(0.0);

  glClearColor(0.0, 0.0, 0.0, 0.0);
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

 /*
  * Draw the cube and sphere in different colors...
  *
  * We have positioned two lights in this scene.  The first is red and
  * located above, to the right, and behind the viewer.  The second is blue
  * and located below, to the left, and in front of the viewer.
  */

  glLightfv(GL_LIGHT0, GL_DIFFUSE, red_light);
  glLightfv(GL_LIGHT0, GL_POSITION, red_pos);

  glLightfv(GL_LIGHT1, GL_DIFFUSE, blue_light);
  glLightfv(GL_LIGHT1, GL_POSITION, blue_pos);

  glDrawBuffer(GL_NONE);	/* Draw the cutting plane */

  glShadeModel(GL_FLAT);
  glBegin(GL_LINES);
    glVertex3f(-10.0, -10.0, -20.0);
    glVertex3f(10.0, 10.0, -20.0);
  glEnd();
  glShadeModel(GL_SMOOTH);

  glBegin(GL_POLYGON);
    glVertex3f(-10.0, -10.0, -20.0);
    glVertex3f(-10.0, 10.0, -20.0);
    glVertex3f(10.0, 10.0, -20.0);
    glVertex3f(10.0, -10.0, -20.0);
  glEnd();

  glDrawBuffer(GL_FRONT);

  glPushMatrix();
    glTranslatef(-1.0, 0.0, -20.0);
    auxSolidSphere(1.0);
  glPopMatrix();

  glPushMatrix();
    glTranslatef(1.0, 0.0, -20.0);
    glRotatef(15.0, 0.0, 1.0, 0.0);
    glRotatef(15.0, 0.0, 0.0, 1.0);
    auxSolidCube(2.0);
  glPopMatrix();

  glFlush();
}


/*
 * 'toggle_depth()' - Toggle the depth function between GL_LESS and GL_GREATER.
 */

void CALLBACK
toggle_depth(void)
{
  if (depth_function == GL_LESS)
    depth_function = GL_GREATER;
  else
    depth_function = GL_LESS;
}


/*
 * 'main()' - Initialize the window and display the scene until the user presses
 *            the ESCape key.
 */

void
main(void)
{
  auxInitDisplayMode(AUX_RGB | AUX_SINGLE | AUX_DEPTH16);
  auxInitWindow("Depth Function");

  auxKeyFunc(AUX_d, toggle_depth);
  auxReshapeFunc(reshape_scene);

  auxMainLoop(draw_scene);
}


/*
 * End of "depth.c".
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\drawf.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  drawf.c
 *  Draws the bitmapped letter F on the screen (several times).
 *  This demonstrates use of the glBitmap() call.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

GLubyte rasters[24] = {
    0xc0, 0x00, 0xc0, 0x00, 0xc0, 0x00, 0xc0, 0x00, 0xc0, 0x00,
    0xff, 0x00, 0xff, 0x00, 0xc0, 0x00, 0xc0, 0x00, 0xc0, 0x00,
    0xff, 0xc0, 0xff, 0xc0};

void myinit(void)
{
    glPixelStorei (GL_UNPACK_ALIGNMENT, 1);
    glClearColor (0.0, 0.0, 0.0, 0.0);
}

void display(void)
{
    glClear(GL_COLOR_BUFFER_BIT);
    glColor3f (1.0, 1.0, 1.0);
    glRasterPos2i (20.5, 20.5);
    glBitmap (10, 12, 0.0, 0.0, 12.0, 0.0, rasters);
    glBitmap (10, 12, 0.0, 0.0, 12.0, 0.0, rasters);
    glBitmap (10, 12, 0.0, 0.0, 12.0, 0.0, rasters);
    glFlush();
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho (0, w, 0, h, -1.0, 1.0);
    glMatrixMode(GL_MODELVIEW);
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB);
    auxInitPosition (0, 0, 500, 500);
    auxInitWindow (argv[0]);
    myinit();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\etex.c ===
#include <stdlib.h>
#include <stdio.h>

#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

#define WWIDTH (2*TWIDTH+GAP)
#define WHEIGHT (4*THEIGHT+3*GAP)
#define TWIDTH 128
#define THEIGHT 128
#define GAP 16

int wwidth = WWIDTH;
int wheight = WHEIGHT;
int twidth = TWIDTH;
int theight = THEIGHT;
int gap = GAP;

char *tex1_file = "1.rgb";
char *tex2_file = "2.rgb";
AUX_RGBImageRec *tex1, *tex2;

BYTE tex1d1[TWIDTH*3], tex1d2[TWIDTH*3];

#define NTEXID 3
GLuint texids[NTEXID+1];
GLboolean texres[NTEXID];
GLfloat texpri[NTEXID];

void TexPoly(int x, int y)
{
    glBegin(GL_POLYGON);
    glTexCoord2i(0, 0);
    glVertex2i(x, y);
    glTexCoord2i(1, 0);
    glVertex2i(x+twidth-1, y);
    glTexCoord2i(1, 1);
    glVertex2i(x+twidth-1, y+theight-1);
    glTexCoord2i(0, 1);
    glVertex2i(x, y+theight-1);
    glEnd();
}

void Test(void)
{
    int i;
    GLint res;
    GLfloat pri;
    GLboolean retval;
    int x1, x2, y;

    x2 = 0;
    x1 = x2+twidth+gap;
    y = 0;

    glGenTextures(NTEXID, texids);
    for (i = 0; i < NTEXID; i++)
    {
        printf("Texture id %d is %d\n", i, texids[i]);
    }

    // Should fail for all because none have been bound and last is invalid
    for (i = 0; i < NTEXID+1; i++)
    {
        printf("IsTexture %d is %d\n", i, glIsTexture(texids[i]));
    }

    // Should fail because these are all unbound right now
    retval = glAreTexturesResident(NTEXID, texids, texres);
    printf("AreTexturesResident %d\n", retval);
    
    glBindTexture(GL_TEXTURE_2D, texids[0]);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexImage2D(GL_TEXTURE_2D, 0, 3, tex1->sizeX, tex1->sizeY, 0, GL_RGB,
                 GL_UNSIGNED_BYTE, tex1->data);
    glEnable(GL_TEXTURE_2D);

    glGetTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_PRIORITY, &pri);
    printf("2D Priority is %f\n", pri);
    
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_PRIORITY, 0.5f);
    glGetTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_PRIORITY, &pri);
    printf("2D Priority is %f\n", pri);

    glGetTexParameteriv(GL_TEXTURE_2D, GL_TEXTURE_RESIDENT, &res);
    printf("2D Residency is %d\n", res);
    
    retval = glAreTexturesResident(1, texids, texres);
    printf("AreTexturesResident %d\n", retval);
    for (i = 0; i < 1; i++)
    {
        printf("Residency %d is %d\n", i, texres[i]);
    }
    
    glClear(GL_COLOR_BUFFER_BIT);

    TexPoly(x2, y);

    glDisable(GL_TEXTURE_2D);
    glBindTexture(GL_TEXTURE_1D, texids[1]);
    glTexParameteri(GL_TEXTURE_1D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexImage1D(GL_TEXTURE_1D, 0, 3, TWIDTH, 0, GL_RGB,
                 GL_UNSIGNED_BYTE, tex1d1);
    glEnable(GL_TEXTURE_1D);

    glGetTexParameterfv(GL_TEXTURE_1D, GL_TEXTURE_PRIORITY, &pri);
    printf("1D Priority is %f\n", pri);
    
    glTexParameterf(GL_TEXTURE_1D, GL_TEXTURE_PRIORITY, 0.5f);
    glGetTexParameterfv(GL_TEXTURE_1D, GL_TEXTURE_PRIORITY, &pri);
    printf("1D Priority is %f\n", pri);

    glGetTexParameteriv(GL_TEXTURE_1D, GL_TEXTURE_RESIDENT, &res);
    printf("1D Residency is %d\n", res);
    
    TexPoly(x1, y);
    
    retval = glAreTexturesResident(2, texids, texres);
    printf("AreTexturesResident %d\n", retval);
    for (i = 0; i < 2; i++)
    {
        printf("Residency %d is %d\n", i, texres[i]);
    }

    texpri[0] = 0.25f;
    texpri[1] = 0.4f;
    texpri[2] = 0.7f;
    glPrioritizeTextures(NTEXID, texids, texpri);

    glGetTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_PRIORITY, &pri);
    printf("2D Priority is %f\n", pri);
    glGetTexParameterfv(GL_TEXTURE_1D, GL_TEXTURE_PRIORITY, &pri);
    printf("1D Priority is %f\n", pri);

    retval = glAreTexturesResident(NTEXID, texids, texres);
    printf("AreTexturesResident %d\n", retval);
    for (i = 0; i < NTEXID; i++)
    {
        printf("Residency %d is %d\n", i, texres[i]);
    }

    glBindTexture(GL_TEXTURE_2D, texids[NTEXID-1]);
    // Should succeed for all
    for (i = 0; i < NTEXID; i++)
    {
        printf("IsTexture %d is %d\n", i, glIsTexture(texids[i]));
    }
    
    glDeleteTextures(1, &texids[NTEXID-1]);
    // Should fail for last
    for (i = 0; i < NTEXID; i++)
    {
        printf("IsTexture %d is %d\n", i, glIsTexture(texids[i]));
    }

    glBindTexture(GL_TEXTURE_2D, texids[0]);
    y += theight+gap;

    glPixelStorei(GL_UNPACK_ROW_LENGTH, tex2->sizeX);
    glDisable(GL_TEXTURE_1D);
    glEnable(GL_TEXTURE_2D);
    glTexSubImage2D(GL_TEXTURE_2D, 0, tex1->sizeX/4, tex1->sizeY/4,
                     tex1->sizeX/2, tex1->sizeY/2, GL_RGB, GL_UNSIGNED_BYTE,
                     tex2->data);
    TexPoly(x2, y);
    
    glDisable(GL_TEXTURE_2D);
    glEnable(GL_TEXTURE_1D);
    glTexSubImage1D(GL_TEXTURE_1D, 0, TWIDTH/4, TWIDTH/2,
                     GL_RGB, GL_UNSIGNED_BYTE, tex1d2);
    TexPoly(x1, y);

    y += theight+gap;
    
    glDisable(GL_TEXTURE_1D);
    glEnable(GL_TEXTURE_2D);
    glCopyTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, x2, 0,
                      tex1->sizeX, tex1->sizeY, 0);
    TexPoly(x2, y);
    
    glDisable(GL_TEXTURE_2D);
    glEnable(GL_TEXTURE_1D);
    glCopyTexImage1D(GL_TEXTURE_1D, 0, GL_RGB, x1, 0,
                      TWIDTH, 0);
    TexPoly(x1, y);

    y += theight+gap;
    
    glDisable(GL_TEXTURE_1D);
    glEnable(GL_TEXTURE_2D);
    glCopyTexSubImage2D(GL_TEXTURE_2D, 0, tex1->sizeX/4, tex1->sizeY/4,
                         x2+twidth/4, theight+theight/4+gap,
                         tex1->sizeX/2, tex1->sizeY/2);
    TexPoly(x2, y);
    
    glDisable(GL_TEXTURE_2D);
    glEnable(GL_TEXTURE_1D);
    glCopyTexSubImage1D(GL_TEXTURE_1D, 0, TWIDTH/4,
                         x1+TWIDTH/4, theight+gap,
                         TWIDTH/2);
    TexPoly(x1, y);

    glFlush();
    
    glDeleteTextures(NTEXID-1, texids);
}

void Display(void)
{
}

void Reshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(0, w, 0, h, -1, 1);
    glMatrixMode(GL_MODELVIEW);

    wwidth = w;
    wheight = h;
}

void __cdecl main(int argc, char** argv)
{
    int i;

    auxInitDisplayMode(AUX_SINGLE | AUX_RGB);
    auxInitPosition(10, 10, wwidth, wheight);
    auxInitWindow("Texture Enhancements Test");

    tex1 = auxRGBImageLoad(tex1_file);
    if (tex1 == NULL)
    {
        printf("Unable to load '%s'\n", tex1_file);
        exit(1);
    }
    printf("tex1 %d,%d\n", tex1->sizeX, tex1->sizeY);
    tex2 = auxRGBImageLoad(tex2_file);
    if (tex2 == NULL)
    {
        printf("Unable to load '%s'\n", tex2_file);
        exit(1);
    }
    printf("tex2 %d,%d\n", tex2->sizeX, tex2->sizeY);
    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);

    for (i = 0; i < TWIDTH; i++)
    {
        tex1d1[i*3+2] = (i*256/TWIDTH);
        tex1d2[i*3] = (i*256/TWIDTH);
    }
    
    // glDisable(GL_DITHER);
    
    Reshape(wwidth, wheight);
    Test();

    auxMainLoop(Display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\lclip.c ===
#include <stdio.h>
#include <windows.h>
#include <gl\gl.h>
#include <gl\glaux.h>

BOOL fDouble = FALSE;
int nIter = 128;

#define WIDTH 512
#define HEIGHT 512

double clip_val;
#define CLIP clip_val
#define CLIP_CENTER 1

void Draw(void)
{
    glLoadIdentity();
    
    glBegin(GL_LINES);
    glVertex2d(-CLIP, -CLIP);
    glVertex2d(CLIP, CLIP);
    
    glVertex2d(-CLIP, CLIP);
    glVertex2d(CLIP, -CLIP);
    glEnd();

    glBegin(GL_LINE_LOOP);
    glVertex2d(0, .25);
    glVertex2d(-CLIP, CLIP);
    glVertex2d(-.25, 0);
    glVertex2d(-CLIP, -CLIP);
    glVertex2d(0, -.25);
    glVertex2d(CLIP, -CLIP);
    glVertex2d(.25, 0);
    glVertex2d(CLIP, CLIP);
    glEnd();

    glBegin(GL_POLYGON);
    glVertex2d(0, .25);
    glVertex2d(0, CLIP);
    glVertex2d(-CLIP, CLIP);
    glVertex2d(-CLIP, 0);
    glVertex2d(-.25, 0);
    glEnd();

    glBegin(GL_POLYGON);
    glVertex2d(-.25, 0);
    glVertex2d(-CLIP, 0);
    glVertex2d(-CLIP, -CLIP);
    glVertex2d(0, -CLIP);
    glVertex2d(0, -.25);
    glEnd();

    glBegin(GL_POLYGON);
    glVertex2d(0, -.25);
    glVertex2d(0, -CLIP);
    glVertex2d(CLIP, -CLIP);
    glVertex2d(CLIP, 0);
    glVertex2d(.25, 0);
    glEnd();

    glBegin(GL_POLYGON);
    glVertex2d(.25, 0);
    glVertex2d(CLIP, 0);
    glVertex2d(CLIP, CLIP);
    glVertex2d(0, CLIP);
    glVertex2d(0, .25);
    glEnd();

    if (fDouble)
    {
	auxSwapBuffers();
    }
    else
    {
	glFinish();
    }
}

void TestClip(void)
{
    static GLboolean done = GL_FALSE;
    float eps, old;

    if (done)
    {
        return;
    }
    
    eps = .0001f;
    old = .0f;

    while (nIter-- > 0 && eps != old)
    {
        printf("TestClip %f\n", eps);
        
        clip_val = CLIP_CENTER+eps;
        Draw();

        clip_val = CLIP_CENTER-eps;
        Draw();

        old = eps;
        eps /= 10;
    }

    done = GL_TRUE;
}

void Nothing(void)
{
}

void __cdecl main(int argc, char **argv)
{
    GLenum mode;

    while (--argc > 0)
    {
	argv++;

	if (!strcmp(*argv, "-db"))
	{
	    fDouble = TRUE;
	}
	else if (!strcmp(*argv, "-it"))
	{
	    argv++;
	    argc--;
	    sscanf(*argv, "%d", &nIter);
	}
    }

    auxInitPosition(5, 5, WIDTH, HEIGHT);
    mode = AUX_RGB | AUX_DEPTH16;
    if (fDouble)
    {
	mode |= AUX_DOUBLE;
    }
    else
    {
	mode |= AUX_SINGLE;
    }
    auxInitDisplayMode(mode);
    auxInitWindow("OpenGL Line Clipping Test");

    glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
    glClear(GL_COLOR_BUFFER_BIT);

    auxIdleFunc(TestClip);
    
    auxMainLoop(Nothing);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\feedback.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  feedback.c
 *  This program demonstrates use of OpenGL feedback.  First,
 *  a lighting environment is set up and a few lines are drawn.
 *  Then feedback mode is entered, and the same lines are 
 *  drawn.  The results in the feedback buffer are printed.
 */
#include <windows.h>
#include <stdio.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

/*  Initialize lighting.
 */
void myinit(void)
{
    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);
}

/*  Draw a few lines and two points, one of which will 
 *  be clipped.  If in feedback mode, a passthrough token 
 *  is issued between the each primitive.
 */
void drawGeometry (GLenum mode)
{
    glBegin (GL_LINE_STRIP);
    glNormal3f (0.0, 0.0, 1.0);
    glVertex3f (30.0, 30.0, 0.0);
    glVertex3f (50.0, 60.0, 0.0);
    glVertex3f (70.0, 40.0, 0.0);
    glEnd ();
    if (mode == GL_FEEDBACK)
	glPassThrough (1.0);
    glBegin (GL_POINTS);
    glVertex3f (-100.0, -100.0, -100.0);    /*  will be clipped  */
    glEnd ();
    if (mode == GL_FEEDBACK)
	glPassThrough (2.0);
    glBegin (GL_POINTS);
    glNormal3f (0.0, 0.0, 1.0);
    glVertex3f (50.0, 50.0, 0.0);
    glEnd ();
}

/*  Write contents of one vertex to stdout.	*/
void print3DcolorVertex (GLint size, 
	GLint *count, GLfloat *buffer)
{
    int i;

    printf ("  ");
    for (i = 0; i < 7; i++) {
	printf ("%4.2f ", buffer[size-(*count)]);
	*count = *count - 1;
    }
    printf ("\n");
}

/*  Write contents of entire buffer.  (Parse tokens!)	*/
void printBuffer(GLint size, GLfloat *buffer)
{
    GLint count;
    GLfloat token;

    count = size;
    while (count) {
	token = buffer[size-count]; count--;
	if (token == GL_PASS_THROUGH_TOKEN) {
	    printf ("GL_PASS_THROUGH_TOKEN\n");
	    printf ("  %4.2f\n", buffer[size-count]);
	    count--;
	}
	else if (token == GL_POINT_TOKEN) {
	    printf ("GL_POINT_TOKEN\n");
	    print3DcolorVertex (size, &count, buffer);
	}
	else if (token == GL_LINE_TOKEN) {
	    printf ("GL_LINE_TOKEN\n");
	    print3DcolorVertex (size, &count, buffer);
	    print3DcolorVertex (size, &count, buffer);
	}
	else if (token == GL_LINE_RESET_TOKEN) {
	    printf ("GL_LINE_RESET_TOKEN\n");
	    print3DcolorVertex (size, &count, buffer);
	    print3DcolorVertex (size, &count, buffer);
	}
    }
}

void display(void)
{
    GLfloat feedBuffer[1024];
    GLint size;

    glMatrixMode (GL_PROJECTION);
    glLoadIdentity ();
    glOrtho (0.0, 100.0, 0.0, 100.0, 0.0, 1.0);

    glClearColor (0.0, 0.0, 0.0, 0.0);
    glClear(GL_COLOR_BUFFER_BIT);
    drawGeometry (GL_RENDER);

    glFeedbackBuffer (1024, GL_3D_COLOR, feedBuffer);
    (void) glRenderMode (GL_FEEDBACK);
    drawGeometry (GL_FEEDBACK);

    size = glRenderMode (GL_RENDER);
    printBuffer (size, feedBuffer);
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB);
    auxInitPosition (0, 0, 100, 100);
    auxInitWindow (argv[0]);
    myinit ();
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\font.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  font.c
 *
 *  Draws some text in a bitmapped font.  Uses glBitmap() 
 *  and other pixel routines.  Also demonstrates use of 
 *  display lists.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

GLubyte rasters[][13] = {
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18}, 
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x36, 0x36, 0x36, 0x36}, 
{0x00, 0x00, 0x00, 0x66, 0x66, 0xff, 0x66, 0x66, 0xff, 0x66, 0x66, 0x00, 0x00}, 
{0x00, 0x00, 0x18, 0x7e, 0xff, 0x1b, 0x1f, 0x7e, 0xf8, 0xd8, 0xff, 0x7e, 0x18}, 
{0x00, 0x00, 0x0e, 0x1b, 0xdb, 0x6e, 0x30, 0x18, 0x0c, 0x76, 0xdb, 0xd8, 0x70}, 
{0x00, 0x00, 0x7f, 0xc6, 0xcf, 0xd8, 0x70, 0x70, 0xd8, 0xcc, 0xcc, 0x6c, 0x38}, 
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x1c, 0x0c, 0x0e}, 
{0x00, 0x00, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x18, 0x0c}, 
{0x00, 0x00, 0x30, 0x18, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x18, 0x30}, 
{0x00, 0x00, 0x00, 0x00, 0x99, 0x5a, 0x3c, 0xff, 0x3c, 0x5a, 0x99, 0x00, 0x00}, 
{0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0xff, 0xff, 0x18, 0x18, 0x18, 0x00, 0x00}, 
{0x00, 0x00, 0x30, 0x18, 0x1c, 0x1c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0x00, 0x38, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x60, 0x60, 0x30, 0x30, 0x18, 0x18, 0x0c, 0x0c, 0x06, 0x06, 0x03, 0x03}, 
{0x00, 0x00, 0x3c, 0x66, 0xc3, 0xe3, 0xf3, 0xdb, 0xcf, 0xc7, 0xc3, 0x66, 0x3c}, 
{0x00, 0x00, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x38, 0x18}, 
{0x00, 0x00, 0xff, 0xc0, 0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x03, 0xe7, 0x7e}, 
{0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x07, 0x7e, 0x07, 0x03, 0x03, 0xe7, 0x7e}, 
{0x00, 0x00, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0xff, 0xcc, 0x6c, 0x3c, 0x1c, 0x0c}, 
{0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x07, 0xfe, 0xc0, 0xc0, 0xc0, 0xc0, 0xff}, 
{0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xc7, 0xfe, 0xc0, 0xc0, 0xc0, 0xe7, 0x7e}, 
{0x00, 0x00, 0x30, 0x30, 0x30, 0x30, 0x18, 0x0c, 0x06, 0x03, 0x03, 0x03, 0xff}, 
{0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xe7, 0x7e, 0xe7, 0xc3, 0xc3, 0xe7, 0x7e}, 
{0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x03, 0x7f, 0xe7, 0xc3, 0xc3, 0xe7, 0x7e}, 
{0x00, 0x00, 0x00, 0x38, 0x38, 0x00, 0x00, 0x38, 0x38, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0x30, 0x18, 0x1c, 0x1c, 0x00, 0x00, 0x1c, 0x1c, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06}, 
{0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x03, 0x06, 0x0c, 0x18, 0x30, 0x60}, 
{0x00, 0x00, 0x18, 0x00, 0x00, 0x18, 0x18, 0x0c, 0x06, 0x03, 0xc3, 0xc3, 0x7e}, 
{0x00, 0x00, 0x3f, 0x60, 0xcf, 0xdb, 0xd3, 0xdd, 0xc3, 0x7e, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xff, 0xc3, 0xc3, 0xc3, 0x66, 0x3c, 0x18}, 
{0x00, 0x00, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe}, 
{0x00, 0x00, 0x7e, 0xe7, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xe7, 0x7e}, 
{0x00, 0x00, 0xfc, 0xce, 0xc7, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc7, 0xce, 0xfc}, 
{0x00, 0x00, 0xff, 0xc0, 0xc0, 0xc0, 0xc0, 0xfc, 0xc0, 0xc0, 0xc0, 0xc0, 0xff}, 
{0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xfc, 0xc0, 0xc0, 0xc0, 0xff}, 
{0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xcf, 0xc0, 0xc0, 0xc0, 0xc0, 0xe7, 0x7e}, 
{0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xff, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3}, 
{0x00, 0x00, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7e}, 
{0x00, 0x00, 0x7c, 0xee, 0xc6, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06}, 
{0x00, 0x00, 0xc3, 0xc6, 0xcc, 0xd8, 0xf0, 0xe0, 0xf0, 0xd8, 0xcc, 0xc6, 0xc3}, 
{0x00, 0x00, 0xff, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0}, 
{0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xdb, 0xff, 0xff, 0xe7, 0xc3}, 
{0x00, 0x00, 0xc7, 0xc7, 0xcf, 0xcf, 0xdf, 0xdb, 0xfb, 0xf3, 0xf3, 0xe3, 0xe3}, 
{0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xe7, 0x7e}, 
{0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe}, 
{0x00, 0x00, 0x3f, 0x6e, 0xdf, 0xdb, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0x66, 0x3c}, 
{0x00, 0x00, 0xc3, 0xc6, 0xcc, 0xd8, 0xf0, 0xfe, 0xc7, 0xc3, 0xc3, 0xc7, 0xfe}, 
{0x00, 0x00, 0x7e, 0xe7, 0x03, 0x03, 0x07, 0x7e, 0xe0, 0xc0, 0xc0, 0xe7, 0x7e}, 
{0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xff}, 
{0x00, 0x00, 0x7e, 0xe7, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3}, 
{0x00, 0x00, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3}, 
{0x00, 0x00, 0xc3, 0xe7, 0xff, 0xff, 0xdb, 0xdb, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3}, 
{0x00, 0x00, 0xc3, 0x66, 0x66, 0x3c, 0x3c, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3}, 
{0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3}, 
{0x00, 0x00, 0xff, 0xc0, 0xc0, 0x60, 0x30, 0x7e, 0x0c, 0x06, 0x03, 0x03, 0xff}, 
{0x00, 0x00, 0x3c, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3c}, 
{0x00, 0x03, 0x03, 0x06, 0x06, 0x0c, 0x0c, 0x18, 0x18, 0x30, 0x30, 0x60, 0x60}, 
{0x00, 0x00, 0x3c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x3c}, 
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xc3, 0x66, 0x3c, 0x18}, 
{0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x38, 0x30, 0x70}, 
{0x00, 0x00, 0x7f, 0xc3, 0xc3, 0x7f, 0x03, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0xfe, 0xc3, 0xc3, 0xc3, 0xc3, 0xfe, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0}, 
{0x00, 0x00, 0x7e, 0xc3, 0xc0, 0xc0, 0xc0, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0x7f, 0xc3, 0xc3, 0xc3, 0xc3, 0x7f, 0x03, 0x03, 0x03, 0x03, 0x03}, 
{0x00, 0x00, 0x7f, 0xc0, 0xc0, 0xfe, 0xc3, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x30, 0x33, 0x1e}, 
{0x7e, 0xc3, 0x03, 0x03, 0x7f, 0xc3, 0xc3, 0xc3, 0x7e, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xfe, 0xc0, 0xc0, 0xc0, 0xc0}, 
{0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x18, 0x00}, 
{0x38, 0x6c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x00, 0x00, 0x0c, 0x00}, 
{0x00, 0x00, 0xc6, 0xcc, 0xf8, 0xf0, 0xd8, 0xcc, 0xc6, 0xc0, 0xc0, 0xc0, 0xc0}, 
{0x00, 0x00, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78}, 
{0x00, 0x00, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xfe, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xfc, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0x7c, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x7c, 0x00, 0x00, 0x00, 0x00}, 
{0xc0, 0xc0, 0xc0, 0xfe, 0xc3, 0xc3, 0xc3, 0xc3, 0xfe, 0x00, 0x00, 0x00, 0x00}, 
{0x03, 0x03, 0x03, 0x7f, 0xc3, 0xc3, 0xc3, 0xc3, 0x7f, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xe0, 0xfe, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0xfe, 0x03, 0x03, 0x7e, 0xc0, 0xc0, 0x7f, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0x1c, 0x36, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x30, 0x00}, 
{0x00, 0x00, 0x7e, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0xc6, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0x18, 0x3c, 0x3c, 0x66, 0x66, 0xc3, 0xc3, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0xc3, 0xe7, 0xff, 0xdb, 0xc3, 0xc3, 0xc3, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0xc3, 0x66, 0x3c, 0x18, 0x3c, 0x66, 0xc3, 0x00, 0x00, 0x00, 0x00}, 
{0xc0, 0x60, 0x60, 0x30, 0x18, 0x3c, 0x66, 0x66, 0xc3, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0xff, 0x60, 0x30, 0x18, 0x0c, 0x06, 0xff, 0x00, 0x00, 0x00, 0x00}, 
{0x00, 0x00, 0x0f, 0x18, 0x18, 0x18, 0x38, 0xf0, 0x38, 0x18, 0x18, 0x18, 0x0f}, 
{0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18}, 
{0x00, 0x00, 0xf0, 0x18, 0x18, 0x18, 0x1c, 0x0f, 0x1c, 0x18, 0x18, 0x18, 0xf0}, 
{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x8f, 0xf1, 0x60, 0x00, 0x00, 0x00} 
};

GLuint fontOffset;

void makeRasterFont(void)
{
    GLuint i;
    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);

    fontOffset = glGenLists (128);
    for (i = 32; i < 127; i++) {
	glNewList(i+fontOffset, GL_COMPILE);
	glBitmap(8, 13, 0.0, 2.0, 10.0, 0.0, rasters[i-32]);
	glEndList();
    }
}

void myinit(void)
{
    glShadeModel (GL_FLAT);
    makeRasterFont();
}

void printString(char *s)
{
    glPushAttrib (GL_LIST_BIT);
    glListBase(fontOffset);
    glCallLists(strlen(s), GL_UNSIGNED_BYTE, (GLubyte *) s);
    glPopAttrib ();
}

/* Everything above this line could be in a library that defines a font.
 * To make it work, you've got to call makeRasterFont() before you start
 * making calls to printString().
 */
void display(void)
{
    GLfloat white[3] = { 1.0, 1.0, 1.0 };
    int i, j;
    char teststring[33];

    glClear(GL_COLOR_BUFFER_BIT);
    glColor3fv(white);
    for (i = 32; i < 127; i += 32) {
	glRasterPos2i(20, 200 - 18*i/32);
	for (j = 0; j < 32; j++)
	    teststring[j] = (char) (i+j);
	teststring[32] = 0;
	printString(teststring);
    }
    glRasterPos2i(20, 100);
    printString("The quick brown fox jumps");
    glRasterPos2i(20, 82);
    printString("over a lazy dog.");
    glFlush ();
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho (0.0, w, 0.0, h, -1.0, 1.0);
    glMatrixMode(GL_MODELVIEW);
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB);
    auxInitPosition (0, 0, 500, 500);
    auxInitWindow (argv[0]);
    myinit();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\jitter.h ===
/*
jitter.h

This file contains jitter point arrays for 2,3,4,8,15,24 and 66 jitters.

The arrays are named j2, j3, etc. Each element in the array has the form,
for example, j8[0].x and j8[0].y

Values are floating point in the range -.5 < x < .5, -.5 < y < .5, and
have a gaussian distribution around the origin.

Use these to do model jittering for scene anti-aliasing and view volume
jittering for depth of field effects. Use in conjunction with the 
accwindow() routine.
*/

typedef struct 
{
	GLfloat x, y;
} jitter_point;

#define MAX_SAMPLES  66


/* 2 jitter points */
jitter_point j2[] =
{
	{ 0.246490,  0.249999},
	{-0.246490, -0.249999}
};


/* 3 jitter points */
jitter_point j3[] =
{
	{-0.373411, -0.250550},
	{ 0.256263,  0.368119},
	{ 0.117148, -0.117570}
};


/* 4 jitter points */
jitter_point j4[] =
{
	{-0.208147,  0.353730},
	{ 0.203849, -0.353780},
	{-0.292626, -0.149945},
	{ 0.296924,  0.149994}
};


/* 8 jitter points */
jitter_point j8[] =
{
	{-0.334818,  0.435331},
	{ 0.286438, -0.393495},
	{ 0.459462,  0.141540},
	{-0.414498, -0.192829},
	{-0.183790,  0.082102},
	{-0.079263, -0.317383},
	{ 0.102254,  0.299133},
	{ 0.164216, -0.054399}
};


/* 15 jitter points */
jitter_point j15[] =
{
	{ 0.285561,  0.188437},
	{ 0.360176, -0.065688},
	{-0.111751,  0.275019},
	{-0.055918, -0.215197},
	{-0.080231, -0.470965},
	{ 0.138721,  0.409168},
	{ 0.384120,  0.458500},
	{-0.454968,  0.134088},
	{ 0.179271, -0.331196},
	{-0.307049, -0.364927},
	{ 0.105354, -0.010099},
	{-0.154180,  0.021794},
	{-0.370135, -0.116425},
	{ 0.451636, -0.300013},
	{-0.370610,  0.387504}
};


/* 24 jitter points */
jitter_point j24[] =
{
	{ 0.030245,  0.136384},
	{ 0.018865, -0.348867},
	{-0.350114, -0.472309},
	{ 0.222181,  0.149524},
	{-0.393670, -0.266873},
	{ 0.404568,  0.230436},
	{ 0.098381,  0.465337},
	{ 0.462671,  0.442116},
	{ 0.400373, -0.212720},
	{-0.409988,  0.263345},
	{-0.115878, -0.001981},
	{ 0.348425, -0.009237},
	{-0.464016,  0.066467},
	{-0.138674, -0.468006},
	{ 0.144932, -0.022780},
	{-0.250195,  0.150161},
	{-0.181400, -0.264219},
	{ 0.196097, -0.234139},
	{-0.311082, -0.078815},
	{ 0.268379,  0.366778},
	{-0.040601,  0.327109},
	{-0.234392,  0.354659},
	{-0.003102, -0.154402},
	{ 0.297997, -0.417965}
};


/* 66 jitter points */
jitter_point j66[] =
{
	{ 0.266377, -0.218171},
	{-0.170919, -0.429368},
	{ 0.047356, -0.387135},
	{-0.430063,  0.363413},
	{-0.221638, -0.313768},
	{ 0.124758, -0.197109},
	{-0.400021,  0.482195},
	{ 0.247882,  0.152010},
	{-0.286709, -0.470214},
	{-0.426790,  0.004977},
	{-0.361249, -0.104549},
	{-0.040643,  0.123453},
	{-0.189296,  0.438963},
	{-0.453521, -0.299889},
	{ 0.408216, -0.457699},
	{ 0.328973, -0.101914},
	{-0.055540, -0.477952},
	{ 0.194421,  0.453510},
	{ 0.404051,  0.224974},
	{ 0.310136,  0.419700},
	{-0.021743,  0.403898},
	{-0.466210,  0.248839},
	{ 0.341369,  0.081490},
	{ 0.124156, -0.016859},
	{-0.461321, -0.176661},
	{ 0.013210,  0.234401},
	{ 0.174258, -0.311854},
	{ 0.294061,  0.263364},
	{-0.114836,  0.328189},
	{ 0.041206, -0.106205},
	{ 0.079227,  0.345021},
	{-0.109319, -0.242380},
	{ 0.425005, -0.332397},
	{ 0.009146,  0.015098},
	{-0.339084, -0.355707},
	{-0.224596, -0.189548},
	{ 0.083475,  0.117028},
	{ 0.295962, -0.334699},
	{ 0.452998,  0.025397},
	{ 0.206511, -0.104668},
	{ 0.447544, -0.096004},
	{-0.108006, -0.002471},
	{-0.380810,  0.130036},
	{-0.242440,  0.186934},
	{-0.200363,  0.070863},
	{-0.344844, -0.230814},
	{ 0.408660,  0.345826},
	{-0.233016,  0.305203},
	{ 0.158475, -0.430762},
	{ 0.486972,  0.139163},
	{-0.301610,  0.009319},
	{ 0.282245, -0.458671},
	{ 0.482046,  0.443890},
	{-0.121527,  0.210223},
	{-0.477606, -0.424878},
	{-0.083941, -0.121440},
	{-0.345773,  0.253779},
	{ 0.234646,  0.034549},
	{ 0.394102, -0.210901},
	{-0.312571,  0.397656},
	{ 0.200906,  0.333293},
	{ 0.018703, -0.261792},
	{-0.209349, -0.065383},
	{ 0.076248,  0.478538},
	{-0.073036, -0.355064},
	{ 0.145087,  0.221726}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\fog.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  fog.c
 *  This program draws 5 red teapots, each at a different 
 *  z distance from the eye, in different types of fog.  
 *  Pressing the left mouse button chooses between 3 types of 
 *  fog:  exponential, exponential squared, and linear.  
 *  In this program, there is a fixed density value, as well 
 *  as fixed start and end values for the linear fog.
 */
#include <windows.h>
#include <stdio.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include <math.h>
#include "glaux.h"

GLint fogMode;

void cycleFog (AUX_EVENTREC *event)
{
    if (fogMode == GL_EXP) {
	fogMode = GL_EXP2;
	printf ("Fog mode is GL_EXP2\n");
    }
    else if (fogMode == GL_EXP2) {
	fogMode = GL_LINEAR;
	printf ("Fog mode is GL_LINEAR\n");
	glFogf (GL_FOG_START, 1.0);
	glFogf (GL_FOG_END, 5.0);
    }
    else if (fogMode == GL_LINEAR) {
	fogMode = GL_EXP;
	printf ("Fog mode is GL_EXP\n");
    }
    glFogi (GL_FOG_MODE, fogMode);
}

/*  Initialize z-buffer, projection matrix, light source, 
 *  and lighting model.  Do not specify a material property here.
 */
void myinit(void)
{
    GLfloat position[] = { 0.0, 3.0, 3.0, 0.0 };
    GLfloat local_view[] = { 0.0 };

    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LESS);

    glLightfv(GL_LIGHT0, GL_POSITION, position);
    glLightModelfv(GL_LIGHT_MODEL_LOCAL_VIEWER, local_view);

    glFrontFace (GL_CW);
    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);
    glEnable(GL_AUTO_NORMAL);
    glEnable(GL_NORMALIZE);
    glEnable(GL_FOG);
    {
	GLfloat density;
	GLfloat fogColor[4] = {0.5, 0.5, 0.5, 1.0};

	fogMode = GL_EXP;
	glFogi (GL_FOG_MODE, fogMode);
	glFogfv (GL_FOG_COLOR, fogColor);
	glFogf (GL_FOG_DENSITY, 0.35);
	glHint (GL_FOG_HINT, GL_DONT_CARE);
	glClearColor(0.5, 0.5, 0.5, 1.0);
    }
}

void renderRedTeapot (GLfloat x, GLfloat y, GLfloat z)
{
    float mat[3];

    mat[3] = 1.0f;
    glPushMatrix();
    glTranslatef (x, y, z);
    mat[0] = 0.1745; mat[1] = 0.01175; mat[2] = 0.01175;	
    glMaterialfv (GL_FRONT, GL_AMBIENT, mat);
    mat[0] = 0.61424; mat[1] = 0.04136; mat[2] = 0.04136;	
    glMaterialfv (GL_FRONT, GL_DIFFUSE, mat);
    mat[0] = 0.727811; mat[1] = 0.626959; mat[2] = 0.626959;
    glMaterialfv (GL_FRONT, GL_SPECULAR, mat);
    glMaterialf (GL_FRONT, GL_SHININESS, 0.6*128.0);
    auxSolidTeapot(1.0);
    glPopMatrix();
}

/*  display() draws 5 teapots at different z positions.
 */
void display(void)
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    renderRedTeapot (-4.0, -0.5, -1.0);
    renderRedTeapot (-2.0, -0.5, -2.0);
    renderRedTeapot (0.0, -0.5, -3.0);
    renderRedTeapot (2.0, -0.5, -4.0);
    renderRedTeapot (4.0, -0.5, -5.0);
    glFlush();
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (w <= (h*3))
	glOrtho (-6.0, 6.0, -2.0*((GLfloat) h*3)/(GLfloat) w, 
	    2.0*((GLfloat) h*3)/(GLfloat) w, 0.0, 10.0);
    else
	glOrtho (-6.0*(GLfloat) w/((GLfloat) h*3), 
	    6.0*(GLfloat) w/((GLfloat) h*3), -2.0, 2.0, 0.0, 10.0);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity ();
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, depth buffer, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB | AUX_DEPTH16);
    auxInitPosition (0, 0, 450, 150);
    auxInitWindow (argv[0]);
    auxMouseFunc (AUX_LEFTBUTTON, AUX_MOUSEDOWN, cycleFog);
    myinit();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\light2.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  light.c
 *  This program demonstrates the use of the OpenGL lighting 
 *  model.  A sphere is drawn using a grey material characteristic. 
 *  A single light source illuminates the object.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

GLboolean dbl_buf = GL_FALSE;
GLboolean depth_buf = GL_TRUE;
GLboolean dlist = GL_TRUE;

double ang = 0.0;

GLuint display_list;

GLsizei win_w, win_h;

void SolidSphere (GLdouble radius)
{
    GLUquadricObj *quadObj;

    quadObj = gluNewQuadric ();
    gluQuadricDrawStyle (quadObj, GLU_FILL);
    gluQuadricNormals (quadObj, GLU_SMOOTH);
    gluSphere (quadObj, radius, 16, 16);
}

/*  Initialize material property, light source, lighting model, 
 *  and depth buffer.
 */
void myinit(void)
{
    GLfloat mat_specular[] = { (GLfloat)1.0, (GLfloat)1.0, (GLfloat)1.0, (GLfloat)1.0 };
    GLfloat mat_shininess[] = { (GLfloat)50.0 };
    GLfloat light_position[] = { (GLfloat)0.0, (GLfloat)0.0, (GLfloat)1.0, (GLfloat)0.0 };

    glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
    glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);
    glLightfv(GL_LIGHT0, GL_POSITION, light_position);

    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);
    if (depth_buf)
    {
	glDepthFunc(GL_LESS);
	glEnable(GL_DEPTH_TEST);
    }
    else
    {
	glEnable(GL_CULL_FACE);
    }

    if (dlist)
    {
        display_list = glGenLists(1);
        glNewList(display_list, GL_COMPILE);
        SolidSphere(1.0);
        glEndList();
    }
}

void display(void)
{
    if (depth_buf)
    {
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    }
    else
    {
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    }

    if (dlist)
    {
        glCallList(display_list);
    }
    else
    {
        SolidSphere(1.0);
    }

    if (dbl_buf)
    {
	auxSwapBuffers();
    }
    else
    {
	glFlush();
    }
}

void SetProj(GLsizei w, GLsizei h)
{
    double x, y, z;

    x = cos(ang)*2;
    y = 0;
    z = sin(ang)*2;

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (w <= h) 
    {
	glOrtho (-1.5, 1.5, -1.5*(GLfloat)h/(GLfloat)w, 
	    1.5*(GLfloat)h/(GLfloat)w, -10.0, 10.0);
    }
    else 
    {
	glOrtho (-1.5*(GLfloat)w/(GLfloat)h, 
	    1.5*(GLfloat)w/(GLfloat)h, -1.5, 1.5, -10.0, 10.0);
    }
    gluLookAt(x, y, z, 0, 0, 0, 0, 1, 0);
    glMatrixMode(GL_MODELVIEW);

    win_w = w;
    win_h = h;
}

#define PI 3.1415926535
#define DTOR(deg) ((deg)*PI/180.0)

void Idle(void)
{
    ang += DTOR(3);
    SetProj(win_w, win_h);
    display();
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    SetProj(w, h);
    glLoadIdentity();
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, and handle input events.
 */
void __cdecl main(int argc, char** argv)
{
    GLenum mode;
    int i;

    for (i = 1; i < argc; i++)
    {
	if (!strcmp(argv[i], "-db"))
	{
	    dbl_buf = GL_TRUE;
	}
	else if (!strcmp(argv[i], "-cull"))
	{
	    depth_buf = GL_FALSE;
	}
        else if (!strcmp(argv[i], "-nodlist"))
        {
            dlist = GL_FALSE;
        }
    }

    mode = AUX_RGB;
    mode |= dbl_buf ? AUX_DOUBLE : AUX_SINGLE;
    mode |= depth_buf ? AUX_DEPTH16 : 0;

    auxInitDisplayMode (mode);
    auxInitPosition (100, 50, 500, 500);
    auxInitWindow (argv[0]);
    myinit();
    auxReshapeFunc (myReshape);
    auxIdleFunc(Idle);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\linelist.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*  
 *  linelist.c  
 *  This program demonstrates using display lists to call 
 *  different line stipples.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

#define	drawOneLine(x1,y1,x2,y2) glBegin(GL_LINES); \
	glVertex2f ((x1),(y1)); glVertex2f ((x2),(y2)); glEnd();

GLuint offset;

void myinit (void)
{
/*  background to be cleared to black	*/
    glClearColor (0.0, 0.0, 0.0, 0.0);
    glShadeModel (GL_FLAT);

    offset = glGenLists (3);
    glNewList (offset, GL_COMPILE);
	glDisable (GL_LINE_STIPPLE);
    glEndList ();
    glNewList (offset+1, GL_COMPILE);
	glEnable (GL_LINE_STIPPLE);
	glLineStipple (1, 0x0F0F);
    glEndList ();
    glNewList (offset+2, GL_COMPILE);
	glEnable (GL_LINE_STIPPLE);
	glLineStipple (1, 0x1111);
    glEndList ();
}

void display(void)
{
    glClear (GL_COLOR_BUFFER_BIT);

/*  draw all lines in white	*/
    glColor3f (1.0, 1.0, 1.0);

    glCallList (offset);
    drawOneLine (50.0, 125.0, 350.0, 125.0);
    glCallList (offset+1);
    drawOneLine (50.0, 100.0, 350.0, 100.0);
    glCallList (offset+2);
    drawOneLine (50.0, 75.0, 350.0, 75.0);
    glCallList (offset+1);
    drawOneLine (50.0, 50.0, 350.0, 50.0);
    glCallList (offset);
    drawOneLine (50.0, 25.0, 350.0, 25.0);
    glFlush ();
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB);
    auxInitPosition (0, 0, 400, 150);
    auxInitWindow (argv[0]);
    myinit ();
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\light.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  light.c
 *  This program demonstrates the use of the OpenGL lighting 
 *  model.  A sphere is drawn using a grey material characteristic. 
 *  A single light source illuminates the object.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

/*  Initialize material property, light source, lighting model, 
 *  and depth buffer.
 */
void myinit(void)
{
    GLfloat mat_specular[] = { 1.0, 1.0, 1.0, 1.0 };
    GLfloat mat_shininess[] = { 50.0 };
    GLfloat light_position[] = { 1.0, 1.0, 1.0, 0.0 };

    glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
    glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);
    glLightfv(GL_LIGHT0, GL_POSITION, light_position);

    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);
    glDepthFunc(GL_LESS);
    glEnable(GL_DEPTH_TEST);
}

void display(void)
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    auxSolidSphere(1.0);
    glFlush();
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (w <= h) 
	glOrtho (-1.5, 1.5, -1.5*(GLfloat)h/(GLfloat)w, 
	    1.5*(GLfloat)h/(GLfloat)w, -10.0, 10.0);
    else 
	glOrtho (-1.5*(GLfloat)w/(GLfloat)h, 
	    1.5*(GLfloat)w/(GLfloat)h, -1.5, 1.5, -10.0, 10.0);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB | AUX_DEPTH16);
    auxInitPosition (100, 50, 500, 500);
    auxInitWindow (argv[0]);
    myinit();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\material.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 * material.c
 * This program demonstrates the use of the GL lighting model.
 * Several objects are drawn using different material characteristics.
 * A single light source illuminates the objects.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

/*  Initialize z-buffer, projection matrix, light source, 
 *  and lighting model.  Do not specify a material property here.
 */
void myinit(void)
{
    GLfloat ambient[] = { 0.0, 0.0, 0.0, 1.0 };
    GLfloat diffuse[] = { 1.0, 1.0, 1.0, 1.0 };
    GLfloat specular[] = { 1.0, 1.0, 1.0, 1.0 };
    GLfloat position[] = { 0.0, 3.0, 2.0, 0.0 };
    GLfloat lmodel_ambient[] = { 0.4, 0.4, 0.4, 1.0 };
    GLfloat local_view[] = { 0.0 };

    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LESS);

    glLightfv(GL_LIGHT0, GL_AMBIENT, ambient);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuse);
    glLightfv(GL_LIGHT0, GL_POSITION, position);
    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_ambient);
    glLightModelfv(GL_LIGHT_MODEL_LOCAL_VIEWER, local_view);

    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);

    glClearColor(0.0, 0.1, 0.1, 0.0);
}

/*  Draw twelve spheres in 3 rows with 4 columns.  
 *  The spheres in the first row have materials with no ambient reflection.
 *  The second row has materials with significant ambient reflection.
 *  The third row has materials with colored ambient reflection.
 *
 *  The first column has materials with blue, diffuse reflection only.
 *  The second column has blue diffuse reflection, as well as specular
 *  reflection with a low shininess exponent.
 *  The third column has blue diffuse reflection, as well as specular
 *  reflection with a high shininess exponent (a more concentrated highlight).
 *  The fourth column has materials which also include an emissive component.
 *
 *  glTranslatef() is used to move spheres to their appropriate locations.
 */

void display(void)
{
    GLfloat no_mat[] = { 0.0, 0.0, 0.0, 1.0 };
    GLfloat mat_ambient[] = { 0.7, 0.7, 0.7, 1.0 };
    GLfloat mat_ambient_color[] = { 0.8, 0.8, 0.2, 1.0 };
    GLfloat mat_diffuse[] = { 0.1, 0.5, 0.8, 1.0 };
    GLfloat mat_specular[] = { 1.0, 1.0, 1.0, 1.0 };
    GLfloat no_shininess[] = { 0.0 };
    GLfloat low_shininess[] = { 5.0 };
    GLfloat high_shininess[] = { 100.0 };
    GLfloat mat_emission[] = {0.3, 0.2, 0.2, 0.0};

    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

/*  draw sphere in first row, first column
 *  diffuse reflection only; no ambient or specular  
 */
    glPushMatrix();
    glTranslatef (-3.75, 3.0, 0.0);
    glMaterialfv(GL_FRONT, GL_AMBIENT, no_mat);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
    glMaterialfv(GL_FRONT, GL_SPECULAR, no_mat);
    glMaterialfv(GL_FRONT, GL_SHININESS, no_shininess);
    glMaterialfv(GL_FRONT, GL_EMISSION, no_mat);
    auxSolidSphere(1.0);
    glPopMatrix();

/*  draw sphere in first row, second column
 *  diffuse and specular reflection; low shininess; no ambient
 */
    glPushMatrix();
    glTranslatef (-1.25, 3.0, 0.0);
    glMaterialfv(GL_FRONT, GL_AMBIENT, no_mat);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
    glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
    glMaterialfv(GL_FRONT, GL_SHININESS, low_shininess);
    glMaterialfv(GL_FRONT, GL_EMISSION, no_mat);
    auxSolidSphere(1.0);
    glPopMatrix();

/*  draw sphere in first row, third column
 *  diffuse and specular reflection; high shininess; no ambient
 */
    glPushMatrix();
    glTranslatef (1.25, 3.0, 0.0);
    glMaterialfv(GL_FRONT, GL_AMBIENT, no_mat);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
    glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
    glMaterialfv(GL_FRONT, GL_SHININESS, high_shininess);
    glMaterialfv(GL_FRONT, GL_EMISSION, no_mat);
    auxSolidSphere(1.0);
    glPopMatrix();

/*  draw sphere in first row, fourth column
 *  diffuse reflection; emission; no ambient or specular reflection
 */
    glPushMatrix();
    glTranslatef (3.75, 3.0, 0.0);
    glMaterialfv(GL_FRONT, GL_AMBIENT, no_mat);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
    glMaterialfv(GL_FRONT, GL_SPECULAR, no_mat);
    glMaterialfv(GL_FRONT, GL_SHININESS, no_shininess);
    glMaterialfv(GL_FRONT, GL_EMISSION, mat_emission);
    auxSolidSphere(1.0);
    glPopMatrix();

/*  draw sphere in second row, first column
 *  ambient and diffuse reflection; no specular  
 */
    glPushMatrix();
    glTranslatef (-3.75, 0.0, 0.0);
    glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
    glMaterialfv(GL_FRONT, GL_SPECULAR, no_mat);
    glMaterialfv(GL_FRONT, GL_SHININESS, no_shininess);
    glMaterialfv(GL_FRONT, GL_EMISSION, no_mat);
    auxSolidSphere(1.0);
    glPopMatrix();

/*  draw sphere in second row, second column
 *  ambient, diffuse and specular reflection; low shininess
 */
    glPushMatrix();
    glTranslatef (-1.25, 0.0, 0.0);
    glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
    glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
    glMaterialfv(GL_FRONT, GL_SHININESS, low_shininess);
    glMaterialfv(GL_FRONT, GL_EMISSION, no_mat);
    auxSolidSphere(1.0);
    glPopMatrix();

/*  draw sphere in second row, third column
 *  ambient, diffuse and specular reflection; high shininess
 */
    glPushMatrix();
    glTranslatef (1.25, 0.0, 0.0);
    glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
    glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
    glMaterialfv(GL_FRONT, GL_SHININESS, high_shininess);
    glMaterialfv(GL_FRONT, GL_EMISSION, no_mat);
    auxSolidSphere(1.0);
    glPopMatrix();

/*  draw sphere in second row, fourth column
 *  ambient and diffuse reflection; emission; no specular
 */
    glPushMatrix();
    glTranslatef (3.75, 0.0, 0.0);
    glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
    glMaterialfv(GL_FRONT, GL_SPECULAR, no_mat);
    glMaterialfv(GL_FRONT, GL_SHININESS, no_shininess);
    glMaterialfv(GL_FRONT, GL_EMISSION, mat_emission);
    auxSolidSphere(1.0);
    glPopMatrix();

/*  draw sphere in third row, first column
 *  colored ambient and diffuse reflection; no specular  
 */
    glPushMatrix();
    glTranslatef (-3.75, -3.0, 0.0);
    glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient_color);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
    glMaterialfv(GL_FRONT, GL_SPECULAR, no_mat);
    glMaterialfv(GL_FRONT, GL_SHININESS, no_shininess);
    glMaterialfv(GL_FRONT, GL_EMISSION, no_mat);
    auxSolidSphere(1.0);
    glPopMatrix();

/*  draw sphere in third row, second column
 *  colored ambient, diffuse and specular reflection; low shininess
 */
    glPushMatrix();
    glTranslatef (-1.25, -3.0, 0.0);
    glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient_color);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
    glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
    glMaterialfv(GL_FRONT, GL_SHININESS, low_shininess);
    glMaterialfv(GL_FRONT, GL_EMISSION, no_mat);
    auxSolidSphere(1.0);
    glPopMatrix();

/*  draw sphere in third row, third column
 *  colored ambient, diffuse and specular reflection; high shininess
 */
    glPushMatrix();
    glTranslatef (1.25, -3.0, 0.0);
    glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient_color);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
    glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
    glMaterialfv(GL_FRONT, GL_SHININESS, high_shininess);
    glMaterialfv(GL_FRONT, GL_EMISSION, no_mat);
    auxSolidSphere(1.0);
    glPopMatrix();

/*  draw sphere in third row, fourth column
 *  colored ambient and diffuse reflection; emission; no specular
 */
    glPushMatrix();
    glTranslatef (3.75, -3.0, 0.0);
    glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient_color);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
    glMaterialfv(GL_FRONT, GL_SPECULAR, no_mat);
    glMaterialfv(GL_FRONT, GL_SHININESS, no_shininess);
    glMaterialfv(GL_FRONT, GL_EMISSION, mat_emission);
    auxSolidSphere(1.0);
    glPopMatrix();

    glFlush();
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (w <= (h * 2))
	glOrtho (-6.0, 6.0, -3.0*((GLfloat)h*2)/(GLfloat)w, 
	    3.0*((GLfloat)h*2)/(GLfloat)w, -10.0, 10.0);
    else
	glOrtho (-6.0*(GLfloat)w/((GLfloat)h*2), 
	    6.0*(GLfloat)w/((GLfloat)h*2), -3.0, 3.0, -10.0, 10.0);
    glMatrixMode(GL_MODELVIEW);
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB | AUX_DEPTH16);
    auxInitPosition (0, 0, 600, 450);
    auxInitWindow (argv[0]);
    myinit();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\lines.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*  
 *  lines.c  
 *  This program demonstrates different line stipples and widths.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

#define	drawOneLine(x1,y1,x2,y2) glBegin(GL_LINES); \
	glVertex2f ((x1),(y1)); glVertex2f ((x2),(y2)); glEnd();

void myinit (void) {
    /*  background to be cleared to black	*/
    glClearColor (0.0, 0.0, 0.0, 0.0);
    glShadeModel (GL_FLAT);
}

void display(void)
{
    int i;

    glClear (GL_COLOR_BUFFER_BIT);
/*  draw all lines in white	*/
    glColor3f (1.0, 1.0, 1.0);

/*  in 1st row, 3 lines drawn, each with a different stipple	*/
    glEnable (GL_LINE_STIPPLE);
    glLineStipple (1, 0x0101);	/*  dotted	*/
    drawOneLine (50.0, 125.0, 150.0, 125.0);
    glLineStipple (1, 0x00FF);	/*  dashed	*/
    drawOneLine (150.0, 125.0, 250.0, 125.0);
    glLineStipple (1, 0x1C47);	/*  dash/dot/dash	*/
    drawOneLine (250.0, 125.0, 350.0, 125.0);

/*  in 2nd row, 3 wide lines drawn, each with different stipple	*/
    glLineWidth (5.0);
    glLineStipple (1, 0x0101);
    drawOneLine (50.0, 100.0, 150.0, 100.0);
    glLineStipple (1, 0x00FF);
    drawOneLine (150.0, 100.0, 250.0, 100.0);
    glLineStipple (1, 0x1C47);
    drawOneLine (250.0, 100.0, 350.0, 100.0);
    glLineWidth (1.0);

/*  in 3rd row, 6 lines drawn, with dash/dot/dash stipple,	*/
/*  as part of a single connect line strip			*/
    glLineStipple (1, 0x1C47);
    glBegin (GL_LINE_STRIP);
    for (i = 0; i < 7; i++)
	glVertex2f (50.0 + ((GLfloat) i * 50.0), 75.0);
    glEnd ();

/*  in 4th row, 6 independent lines drawn,	*/
/*  with dash/dot/dash stipple			*/
    for (i = 0; i < 6; i++) {
	drawOneLine (50.0 + ((GLfloat) i * 50.0), 
	    50.0, 50.0 + ((GLfloat)(i+1) * 50.0), 50.0);
    }

/*  in 5th row, 1 line drawn, with dash/dot/dash stipple	*/
/*  and repeat factor of 5			*/
    glLineStipple (5, 0x1C47);
    drawOneLine (50.0, 25.0, 350.0, 25.0);
    glFlush ();
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB);
    auxInitPosition (0, 0, 400, 150);
    auxInitWindow (argv[0]);
    myinit ();
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\list2.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  list2.c
 *  This program demonstrates glGenList() and glPushAttrib().
 *  The matrix and color are restored, before the line is drawn.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

GLuint listName;

void myinit (void)
{
    GLfloat color_vector[3] = {1.0, 0.0, 0.0};

    listName = glGenLists (1);
    glNewList (listName, GL_COMPILE);
	glPushAttrib (GL_CURRENT_BIT);
	glColor3fv (color_vector);
	glBegin (GL_TRIANGLES);
	glVertex2f (0.0, 0.0);
	glVertex2f (1.0, 0.0);
	glVertex2f (0.0, 1.0);
	glEnd ();
	glTranslatef (1.5, 0.0, 0.0);
	glPopAttrib ();
    glEndList ();
    glShadeModel (GL_FLAT);
}

void drawLine (void)
{
    glBegin (GL_LINES);
    glVertex2f (0.0, 0.5);
    glVertex2f (15.0, 0.5);
    glEnd ();
}

void display(void)
{
    GLuint i;
    GLfloat new_color[3] = {0.0, 1.0, 0.0};

    glClear (GL_COLOR_BUFFER_BIT);
    glColor3fv (new_color);
    glPushMatrix ();
    for (i = 0; i < 10; i++)
	glCallList (listName);
    glPopMatrix ();
    drawLine ();
    glFlush ();
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (w <= h) 
	gluOrtho2D (0.0, 2.0, -0.5 * (GLfloat) h/(GLfloat) w, 
	    1.5 * (GLfloat) h/(GLfloat) w);
    else 
	gluOrtho2D (0.0, 2.0 * (GLfloat) w/(GLfloat) h, -0.5, 1.5); 
    glMatrixMode(GL_MODELVIEW);
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB);
    auxInitPosition (0, 0, 400, 50);
    auxInitWindow (argv[0]);
    myinit();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\list.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  list.c
 *  This program demonstrates how to make and execute a 
 *  display list.  Note that attributes, such as current 
 *  color and matrix, are changed.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

GLuint listName = 1;

void myinit (void)
{
    glNewList (listName, GL_COMPILE);
	glColor3f (1.0, 0.0, 0.0);
	glBegin (GL_TRIANGLES);
	glVertex2f (0.0, 0.0);
	glVertex2f (1.0, 0.0);
	glVertex2f (0.0, 1.0);
	glEnd ();
	glTranslatef (1.5, 0.0, 0.0);
    glEndList ();
    glShadeModel (GL_FLAT);
}

void drawLine (void)
{
    glBegin (GL_LINES);
    glVertex2f (0.0, 0.5);
    glVertex2f (15.0, 0.5);
    glEnd ();
}

void display(void)
{
    GLuint i;

    glClear (GL_COLOR_BUFFER_BIT);
    glColor3f (0.0, 1.0, 0.0);
    glPushMatrix();
    for (i = 0; i < 10; i++)
	glCallList (listName);
    drawLine ();
    glPopMatrix();
    glFlush ();
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (w <= h) 
	gluOrtho2D (0.0, 2.0, -0.5 * (GLfloat) h/(GLfloat) w, 
	    1.5 * (GLfloat) h/(GLfloat) w);
    else 
	gluOrtho2D (0.0, 2.0 * (GLfloat) w/(GLfloat) h, -0.5, 1.5); 
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB);
    auxInitPosition (0, 0, 400, 50);
    auxInitWindow (argv[0]);
    myinit ();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\mcube.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED
 * Permission to use, copy, modify, and distribute this software for
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission.
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * US Government Users Restricted Rights
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  mcube.c
 *  Use 3 mouse buttons
 */
#include <windows.h>
#include <stdio.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

#define MY_CUBE_LIST 1
GLfloat         xAngle = 42.0, yAngle = 82.0, zAngle = 112.0;

static int shoulder = 30, elbow = 0;

void recalcView(void)
{
printf("recalc\n");
    /* reset modelview matrix to the identity matrix */
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    /* move the camera back three units */
    glTranslatef(0.0, 0.0, -3.0);

    /* Rotate by X, Y, &z angles */
    glRotatef(xAngle, 0.1, 0.0, 0.0);
    glRotatef(yAngle, 0.0, 0.1, 0.0);
    glRotatef(zAngle, 0.0, 0.0, 1.0);

}

void xAdd (void)
{
printf("xadd\n");
    xAngle += 10.0F;
    recalcView();
}

void yAdd (void)
{
printf("yadd\n");
    yAngle += 10.0F;
    recalcView();
}

void zAdd (void)
{
printf("zadd\n");
    zAngle += 10.0F;
    recalcView();
}

void display(void)
{

    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glCallList(MY_CUBE_LIST);
    glFlush();

}

void myinit (void)
{
    glShadeModel (GL_FLAT);
    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LESS);
    glClearDepth(1.0);
    glClearColor(0.4, 0.1, 0.0, 1.0);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glFrustum(-1.0, 1.0, -1.0, 1.0, 1.0, 10.0);

    glNewList(MY_CUBE_LIST, GL_COMPILE);
        /* front face */
        glBegin(GL_QUADS);
        glColor3f(0.0, 0.7, 0.1);       /* green */
        glVertex3f(-1.0, 1.0, 1.0);
        glVertex3f(1.0, 1.0, 1.0);
        glVertex3f(1.0, -1.0, 1.0);
        glVertex3f(-1.0, -1.0, 1.0);
        /* back face */
        glColor3f(0.9, 1.0, 0.0);       /* yellow */
        glVertex3f(-1.0, 1.0, -1.0);
        glVertex3f(1.0, 1.0, -1.0);
        glVertex3f(1.0, -1.0, -1.0);
        glVertex3f(-1.0, -1.0, -1.0);
        /* top side face */
        glColor3f(0.0, 0.0, 0.8);       /* blue */
        glVertex3f(-1.0, 1.0, 1.0);
        glVertex3f(1.0, 1.0, 1.0);
        glVertex3f(1.0, 1.0, -1.0);
        glVertex3f(-1.0, 1.0, -1.0);
        /* bottom side face */
        glColor3f(0.7, 0.0, 0.1);       /* red */
        glVertex3f(-1.0, -1.0, 1.0);
        glVertex3f(1.0, -1.0, 1.0);
        glVertex3f(1.0, -1.0, -1.0);
        glVertex3f(-1.0, -1.0, -1.0);
        glEnd();
        glEndList();
}

void myReshape(GLsizei w, GLsizei h)
{
    recalcView();
    glViewport(0, 0, w, h);
}

/*  Main Loop
 *  Open window with initial window size, title bar,
 *  RGBA display mode, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB | AUX_DEPTH16);
    auxInitPosition (100, 50, 400, 400);
    auxInitWindow ("mcube");

    myinit ();

    auxKeyFunc (AUX_LEFT, xAdd);
    auxKeyFunc (AUX_RIGHT, yAdd);
    auxKeyFunc (AUX_DOWN, zAdd);
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\mipmap.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*  mipmap.c
 *  This program demonstrates using mipmaps for texture maps.
 *  To overtly show the effect of mipmaps, each mipmap reduction
 *  level has a solidly colored, contrasting texture image.
 *  Thus, the quadrilateral which is drawn is drawn with several
 *  different colors.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

GLubyte mipmapImage32[32][32][3];
GLubyte mipmapImage16[16][16][3];
GLubyte mipmapImage8[8][8][3];
GLubyte mipmapImage4[4][4][3];
GLubyte mipmapImage2[2][2][3];
GLubyte mipmapImage1[1][1][3];

void makeImages(void)
{
    int i, j;
    
    for (i = 0; i < 32; i++) {
	for (j = 0; j < 32; j++) {
	    mipmapImage32[i][j][0] = 255;
	    mipmapImage32[i][j][1] = 255;
	    mipmapImage32[i][j][2] = 0;
	}
    }
    for (i = 0; i < 16; i++) {
	for (j = 0; j < 16; j++) {
	    mipmapImage16[i][j][0] = 255;
	    mipmapImage16[i][j][1] = 0;
	    mipmapImage16[i][j][2] = 255;
	}
    }
    for (i = 0; i < 8; i++) {
	for (j = 0; j < 8; j++) {
	    mipmapImage8[i][j][0] = 255;
	    mipmapImage8[i][j][1] = 0;
	    mipmapImage8[i][j][2] = 0;
	}
    }
    for (i = 0; i < 4; i++) {
	for (j = 0; j < 4; j++) {
	    mipmapImage4[i][j][0] = 0;
	    mipmapImage4[i][j][1] = 255;
	    mipmapImage4[i][j][2] = 0;
	}
    }
    for (i = 0; i < 2; i++) {
	for (j = 0; j < 2; j++) {
	    mipmapImage2[i][j][0] = 0;
	    mipmapImage2[i][j][1] = 0;
	    mipmapImage2[i][j][2] = 255;
	}
    }
    mipmapImage1[0][0][0] = 255;
    mipmapImage1[0][0][1] = 255;
    mipmapImage1[0][0][2] = 255;
}

void myinit(void)
{    
    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LESS);
    glShadeModel(GL_FLAT);

    glTranslatef(0.0, 0.0, -3.6);
    makeImages();
    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
    glTexImage2D(GL_TEXTURE_2D, 0, 3, 32, 32, 0,
		 GL_RGB, GL_UNSIGNED_BYTE, &mipmapImage32[0][0][0]);
    glTexImage2D(GL_TEXTURE_2D, 1, 3, 16, 16, 0,
		 GL_RGB, GL_UNSIGNED_BYTE, &mipmapImage16[0][0][0]);
    glTexImage2D(GL_TEXTURE_2D, 2, 3, 8, 8, 0,
		 GL_RGB, GL_UNSIGNED_BYTE, &mipmapImage8[0][0][0]);
    glTexImage2D(GL_TEXTURE_2D, 3, 3, 4, 4, 0,
		 GL_RGB, GL_UNSIGNED_BYTE, &mipmapImage4[0][0][0]);
    glTexImage2D(GL_TEXTURE_2D, 4, 3, 2, 2, 0,
		 GL_RGB, GL_UNSIGNED_BYTE, &mipmapImage2[0][0][0]);
    glTexImage2D(GL_TEXTURE_2D, 5, 3, 1, 1, 0,
		 GL_RGB, GL_UNSIGNED_BYTE, &mipmapImage1[0][0][0]);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, 
	GL_NEAREST_MIPMAP_NEAREST);
    glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL);
    glEnable(GL_TEXTURE_2D);
}

void display(void)
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glBegin(GL_QUADS);
    glTexCoord2f(0.0, 0.0); glVertex3f(-2.0, -1.0, 0.0);
    glTexCoord2f(0.0, 8.0); glVertex3f(-2.0, 1.0, 0.0);
    glTexCoord2f(8.0, 8.0); glVertex3f(2000.0, 1.0, -6000.0);
    glTexCoord2f(8.0, 0.0); glVertex3f(2000.0, -1.0, -6000.0);
    glEnd();
    glFlush();
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(60.0, 1.0*(GLfloat)w/(GLfloat)h, 1.0, 30000.0);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
}

int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB | AUX_DEPTH16);
    auxInitPosition (0, 0, 500, 500);
    auxInitWindow (argv[0]);
    myinit();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\model.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  model.c
 *  This program demonstrates the use of OpenGL modeling 
 *  transformations.  Four triangles are drawn, each with 
 *  a different transformation.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

void draw_triangle(void)
{
    glBegin(GL_LINE_LOOP);
    glVertex2f(0.0, 25.0);
    glVertex2f(25.0, -25.0);
    glVertex2f(-25.0, -25.0);
    glEnd();
}

/*  Clear the screen.  For each triangle, set the current 
 *  color and modify the modelview matrix.
 */
void display(void)
{
    glClearColor (0.0, 0.0, 0.0, 1.0);
    glClear (GL_COLOR_BUFFER_BIT);

    glLoadIdentity ();
    glColor3f (1.0, 1.0, 1.0);
    draw_triangle ();

    glEnable (GL_LINE_STIPPLE);
    glLineStipple (1, 0xF0F0);
    glLoadIdentity ();
    glTranslatef (-20.0, 0.0, 0.0);
    draw_triangle ();

    glLineStipple (1, 0xF00F);
    glLoadIdentity ();
    glScalef (1.5, 0.5, 1.0);
    draw_triangle ();

    glLineStipple (1, 0x8888);
    glLoadIdentity ();
    glRotatef (90.0, 0.0, 0.0, 1.0);
    draw_triangle ();
    glDisable (GL_LINE_STIPPLE);

    glFlush();
}

void myinit (void)
{
    glShadeModel (GL_FLAT);
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (w <= h) 
	glOrtho (-50.0, 50.0, -50.0*(GLfloat)h/(GLfloat)w, 
	    50.0*(GLfloat)h/(GLfloat)w, -1.0, 1.0);
    else 
	glOrtho (-50.0*(GLfloat)w/(GLfloat)h, 
	    50.0*(GLfloat)w/(GLfloat)h, -50.0, 50.0, -1.0, 1.0);
    glMatrixMode(GL_MODELVIEW);
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB);
    auxInitPosition (0, 0, 500, 500);
    auxInitWindow (argv[0]);
    myinit ();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\movelght.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  movelight.c
 *  This program demonstrates when to issue lighting and 
 *  transformation commands to render a model with a light 
 *  which is moved by a modeling transformation (rotate or 
 *  translate).  The light position is reset after the modeling 
 *  transformation is called.  The eye position does not change.
 *
 *  A sphere is drawn using a grey material characteristic. 
 *  A single light source illuminates the object.
 *
 *  Interaction:  pressing the left or middle mouse button
 *  alters the modeling transformation (x rotation) by 30 degrees.  
 *  The scene is then redrawn with the light in a new position.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

static int spin = 0;

void movelight (AUX_EVENTREC *event)
{
    spin = (spin + 30) % 360;
}

void myinit (void)
{
    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);

    glDepthFunc(GL_LESS);
    glEnable(GL_DEPTH_TEST);
}

/*  Here is where the light position is reset after the modeling
 *  transformation (glRotated) is called.  This places the 
 *  light at a new position in world coordinates.  The cube
 *  represents the position of the light.
 */
void display(void)
{
    GLfloat position[] = { 0.0, 0.0, 1.5, 1.0 };

    glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glPushMatrix ();
    glTranslatef (0.0, 0.0, -5.0); 

    glPushMatrix ();
    glRotated ((GLdouble) spin, 1.0, 0.0, 0.0);
    glRotated (0.0, 1.0, 0.0, 0.0);
    glLightfv (GL_LIGHT0, GL_POSITION, position);

    glTranslated (0.0, 0.0, 1.5);
    glDisable (GL_LIGHTING);
    glColor3f (0.0, 1.0, 1.0);
    auxWireCube (0.1);
    glEnable (GL_LIGHTING);
    glPopMatrix ();

    auxSolidTorus (0.275, 0.85);
    glPopMatrix ();
    glFlush ();
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(40.0, (GLfloat) w/(GLfloat) h, 1.0, 20.0);
    glMatrixMode(GL_MODELVIEW);
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB | AUX_DEPTH16);
    auxInitPosition (0, 0, 500, 500);
    auxInitWindow (argv[0]);
    myinit();
    auxMouseFunc (AUX_LEFTBUTTON, AUX_MOUSEDOWN, movelight);
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\pickline.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  pickline.c
 *  Picking is demonstrated here.  Press the left mouse button
 *  is enter picking mode.  You get two hits if you press the
 *  mouse, while the cursor is where the lines intersect.
 */
#include <windows.h>
#include <stdio.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

void drawLine(GLenum mode)
{
    if (mode == GL_SELECT)
	glLoadName (1);
    glBegin (GL_LINES);
    glColor3f (1.0, 1.0, 1.0);
    glVertex3f (30.0, 30.0, 0.0);
    glVertex3f (50.0, 60.0, 0.0);
    glEnd (); 

    if (mode == GL_SELECT)
	glLoadName (2);
    glBegin (GL_LINES);
    glColor3f (1.0, 1.0, 1.0);
    glVertex3f (50.0, 60.0, 0.0);
    glVertex3f (70.0, 40.0, 0.0);
    glEnd (); 
}

/*  pickline() is called when the mouse is pressed.
 *  The projection matrix is reloaded to include the
 *  picking matrix.  The line is "redrawn" during
 *  selection mode, and names are sent to the buffer.
 */
#define BUFSIZE 512

void pickLine(AUX_EVENTREC *event)
{
    GLuint selectBuf[BUFSIZE];
    GLint hits;
    GLint viewport[4];
    int x, y;

    x = event->data[AUX_MOUSEX];
    y = event->data[AUX_MOUSEY];
    glGetIntegerv (GL_VIEWPORT, viewport);

    glSelectBuffer (BUFSIZE, selectBuf);
    (void) glRenderMode (GL_SELECT);

    glInitNames();
    glPushName(-1);

    glMatrixMode (GL_PROJECTION);
    glPushMatrix ();
    glLoadIdentity ();
    gluPickMatrix ((GLdouble) x, (GLdouble) (viewport[3] - y), 
	5.0, 5.0, viewport);
    gluOrtho2D (0.0, (GLdouble) viewport[2], 
	0.0, (GLdouble) viewport[3]);
    drawLine (GL_SELECT);
    glPopMatrix ();
    glFlush ();

    hits = glRenderMode (GL_RENDER);
    printf ("hits is %d\n", hits);
} 

void myinit (void) 
{
    glShadeModel (GL_FLAT);
    glClearColor (0.0, 0.0, 0.0, 0.0);
}

void display(void)
{
    glClear(GL_COLOR_BUFFER_BIT);
    drawLine (GL_RENDER);
    glFlush();
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluOrtho2D (0.0, (GLdouble) w, 0.0, (GLdouble) h);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB);
    auxInitPosition (0, 0, 100, 100);
    auxInitWindow (argv[0]);
    myinit ();
    auxMouseFunc (AUX_LEFTBUTTON, AUX_MOUSEDOWN, pickLine);
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\picksqu.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  picksquare.c
 *  Use of multiple names and picking are demonstrated.  
 *  A 3x3 grid of squares is drawn.  When the left mouse 
 *  button is pressed, all squares under the cursor position 
 *  have their color changed.
 */
#include <windows.h>
#include <stdio.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

int board[3][3];	/*  amount of color for each square	*/

/*	Clear color value for every square on the board	    */
void myinit(void)
{
    int i, j;
    for (i = 0; i < 3; i++) 
	for (j = 0; j < 3; j ++)
	    board[i][j] = 0;
    glClearColor (0.0, 0.0, 0.0, 0.0);
}

/*  The nine squares are drawn.  In selection mode, each 
 *  square is given two names:  one for the row and the 
 *  other for the column on the grid.  The color of each 
 *  square is determined by its position on the grid, and 
 *  the value in the board[][] array.
 */
void drawSquares(GLenum mode)
{
    GLuint i, j;
    for (i = 0; i < 3; i++) {
	if (mode == GL_SELECT)
	    glLoadName (i);
	for (j = 0; j < 3; j ++) {
	    if (mode == GL_SELECT)
		glPushName (j);
	    glColor3f ((GLfloat) i/3.0, (GLfloat) j/3.0, 
		    (GLfloat) board[i][j]/3.0);
	    glRecti (i, j, i+1, j+1);
	    if (mode == GL_SELECT)
		glPopName ();
	}
    }
}

/*  processHits() prints out the contents of the 
 *  selection array.
 */
void processHits (GLint hits, GLuint buffer[])
{
    unsigned int i, j;
    GLuint ii, jj, names, *ptr;

    printf ("hits = %d\n", hits);
    ptr = (GLuint *) buffer;
    for (i = 0; i < hits; i++) {	/*  for each hit  */
	names = *ptr;
	printf (" number of names for this hit = %d\n", names);	ptr++;
	printf ("  z1 is %u;", *ptr); ptr++;
	printf (" z2 is %u\n", *ptr); ptr++;
	printf ("   names are ");
	for (j = 0; j < names; j++) {	/*  for each name */
	    printf ("%d ", *ptr);
	    if (j == 0)	/*  set row and column  */
		ii = *ptr;
	    else if (j == 1)
		jj = *ptr;
	    ptr++;
	}
	printf ("\n");
	board[ii][jj] = (board[ii][jj] + 1) % 3;
    }
}

/*  pickSquares() sets up selection mode, name stack, 
 *  and projection matrix for picking.  Then the 
 *  objects are drawn.
 */
#define BUFSIZE 512

void pickSquares(AUX_EVENTREC *event)
{
    GLuint selectBuf[BUFSIZE];
    GLint hits;
    GLint viewport[4];
    int x, y;

    x = event->data[AUX_MOUSEX];
    y = event->data[AUX_MOUSEY];
    glGetIntegerv (GL_VIEWPORT, viewport);

    glSelectBuffer (BUFSIZE, selectBuf);
    (void) glRenderMode (GL_SELECT);

    glInitNames();
    glPushName(-1);

    glMatrixMode (GL_PROJECTION);
    glPushMatrix ();
    glLoadIdentity ();
/*  create 5x5 pixel picking region near cursor location	*/
    gluPickMatrix ((GLdouble) x, (GLdouble) (viewport[3] - y), 
	5.0, 5.0, viewport);
    gluOrtho2D (0.0, 3.0, 0.0, 3.0);
    drawSquares (GL_SELECT);

    glMatrixMode (GL_PROJECTION);
    glPopMatrix ();
    glFlush ();

    hits = glRenderMode (GL_RENDER);
    processHits (hits, selectBuf);
} 

void display(void)
{
    glClear(GL_COLOR_BUFFER_BIT);
    drawSquares (GL_RENDER);
    glFlush();
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluOrtho2D (0.0, 3.0, 0.0, 3.0);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB);
    auxInitPosition (0, 0, 100, 100);
    auxInitWindow (argv[0]);
    myinit ();
    auxMouseFunc (AUX_LEFTBUTTON, AUX_MOUSEDOWN, pickSquares);
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\pickdpth.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  pickdepth.c
 *  Picking is demonstrated in this program.  In 
 *  rendering mode, three overlapping rectangles are 
 *  drawn.  When the left mouse button is pressed, 
 *  selection mode is entered with the picking matrix.  
 *  Rectangles which are drawn under the cursor position
 *  are "picked."  Pay special attention to the depth 
 *  value range, which is returned.
 */
#include <windows.h>
#include <stdio.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

void myinit(void)
{
    glClearColor (0.0, 0.0, 0.0, 0.0);
    glDepthFunc(GL_LESS);
    glEnable(GL_DEPTH_TEST);
    glShadeModel(GL_FLAT);
    glDepthRange (0.0, 1.0);	/*  The default z mapping	*/
}

/*  The three rectangles are drawn.  In selection mode, 
 *  each rectangle is given the same name.  Note that 
 *  each rectangle is drawn with a different z value.
 */
void drawRects(GLenum mode)
{
    if (mode == GL_SELECT)
	glLoadName (1);
    glBegin (GL_QUADS);
	glColor3f (1.0, 1.0, 0.0);
	glVertex3i (2, 0, 0);
	glVertex3i (2, 6, 0);
	glVertex3i (6, 6, 0);
	glVertex3i (6, 0, 0);
	glColor3f (0.0, 1.0, 1.0);
	glVertex3i (3, 2, -1);
	glVertex3i (3, 8, -1);
	glVertex3i (8, 8, -1);
	glVertex3i (8, 2, -1);
	glColor3f (1.0, 0.0, 1.0);
	glVertex3i (0, 2, -2);
	glVertex3i (0, 7, -2);
	glVertex3i (5, 7, -2);
	glVertex3i (5, 2, -2);
    glEnd ();
}

/*  processHits() prints out the contents of the 
 *  selection array.
 */
void processHits (GLint hits, GLuint buffer[])
{
    unsigned int i, j;
    GLuint names, *ptr;

    printf ("hits = %d\n", hits);
    ptr = (GLuint *) buffer;
    for (i = 0; i < hits; i++) {	/*  for each hit  */
	names = *ptr;
	printf (" number of names for hit = %d\n", names); ptr++;
	printf ("  z1 is %u;", *ptr); ptr++;
	printf (" z2 is %u\n", *ptr); ptr++;
	printf ("   the name is ");
	for (j = 0; j < names; j++) {	/*  for each name */
	    printf ("%d ", *ptr); ptr++;
	}
	printf ("\n");
    }
}

/*  pickRects() sets up selection mode, name stack, 
 *  and projection matrix for picking.  Then the objects 
 *  are drawn.
 */
#define BUFSIZE 512

void pickRects(AUX_EVENTREC *event)
{
    GLuint selectBuf[BUFSIZE];
    GLint hits;
    GLint viewport[4];
    int x, y;

    x = event->data[AUX_MOUSEX];
    y = event->data[AUX_MOUSEY];
    glGetIntegerv (GL_VIEWPORT, viewport);

    glSelectBuffer (BUFSIZE, selectBuf);
    (void) glRenderMode (GL_SELECT);

    glInitNames();
    glPushName(-1);

    glMatrixMode (GL_PROJECTION);
    glPushMatrix ();
    glLoadIdentity ();
/*  create 5x5 pixel picking region near cursor location	*/
    gluPickMatrix ((GLdouble) x, (GLdouble) (viewport[3] - y), 
	5.0, 5.0, viewport);
    glOrtho (0.0, 8.0, 0.0, 8.0, -0.5, 2.5);
    drawRects (GL_SELECT);
    glPopMatrix ();
    glFlush ();

    hits = glRenderMode (GL_RENDER);
    processHits (hits, selectBuf);
} 

void display(void)
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    drawRects (GL_RENDER);
    glFlush();
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho (0.0, 8.0, 0.0, 8.0, 0.0, 2.0);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, depth buffer, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB | AUX_DEPTH16);
    auxInitPosition (0, 0, 100, 100);
    auxInitWindow (argv[0]);
    myinit ();
    auxMouseFunc (AUX_LEFTBUTTON, AUX_MOUSEDOWN, pickRects);
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\npts.c ===
/* A simple triangle program */

#include <windows.h>
#include <stdlib.h>
#include <GL/gl.h>
#include "glaux.h"

#define WIDTH 300
#define HEIGHT 300

void display(void)
{
    int i;
    GLfloat r, g, b, x, y;

//printf("display called\n");
    glClear(GL_COLOR_BUFFER_BIT);

    glColor3f(1.0F, 0.0F, 0.0F);
    glBegin(GL_POINTS);
        for (i=0; i< 2000; i++) {
            r = (rand() % 10) / 10.0;
            g = (rand() % 10) / 10.0;
            b = (rand() % 10) / 10.0;
            x = rand() % WIDTH;
            y = rand() % HEIGHT;
            
            glColor3f(r, g, b);
            glVertex2f(x, y);
        }

    glEnd();

//printf("sleep 10\n");
Sleep(10*1000);
//printf("Flush\n");
    glFlush();
}

void myinit(void)
{
    glClearColor(0.0F, 0.0F, 0.4F, 1.0F);
    glShadeModel(GL_SMOOTH);
}

void apressed(key, mask)
{
//    printf("key is %d, mask is 0x%x\n", key, mask);
}

void LeftPressed(AUX_EVENTREC *event)
{
    //printf("Left pressed (%d, %d)\n", event->data[AUX_MOUSEX],
    //            event->data[AUX_MOUSEY]);
}

void LeftReleased(AUX_EVENTREC *event)
{
    //printf("Left released (%d, %d)\n", event->data[AUX_MOUSEX],
    //            event->data[AUX_MOUSEY]);
}

int main(int argc, char *argv[])
{
    auxInitDisplayMode(AUX_SINGLE | AUX_RGBA);
    auxInitPosition(100, 150, WIDTH, HEIGHT);
    auxInitWindow("Tri");
    myinit();

    auxKeyFunc(AUX_a, apressed);
    auxMouseFunc(AUX_LEFTBUTTON, AUX_MOUSEDOWN, LeftPressed);
    auxMouseFunc(AUX_LEFTBUTTON, AUX_MOUSEUP, LeftReleased);

    auxMainLoop(display);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\plane.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  plane.c
 *  This program demonstrates the use of local versus 
 *  infinite lighting on a flat plane.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

/*  Initialize material property, light source, and lighting model.
 */
void myinit(void)
{
    GLfloat mat_ambient[] = { 0.0, 0.0, 0.0, 1.0 };
/*   mat_specular and mat_shininess are NOT default values	*/
    GLfloat mat_diffuse[] = { 0.4, 0.4, 0.4, 1.0 };
    GLfloat mat_specular[] = { 1.0, 1.0, 1.0, 1.0 };
    GLfloat mat_shininess[] = { 15.0 };

    GLfloat light_ambient[] = { 0.0, 0.0, 0.0, 1.0 };
    GLfloat light_diffuse[] = { 1.0, 1.0, 1.0, 1.0 };
    GLfloat light_specular[] = { 1.0, 1.0, 1.0, 1.0 };
    GLfloat lmodel_ambient[] = { 0.2, 0.2, 0.2, 1.0 };

    glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
    glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
    glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);
    glLightfv(GL_LIGHT0, GL_AMBIENT, light_ambient);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, light_diffuse);
    glLightfv(GL_LIGHT0, GL_SPECULAR, light_specular);
    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_ambient);

    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);
    glDepthFunc(GL_LESS);
    glEnable(GL_DEPTH_TEST);
}

void drawPlane(void)
{
    glBegin (GL_QUADS);
    glNormal3f (0.0, 0.0, 1.0);
    glVertex3f (-1.0, -1.0, 0.0);
    glVertex3f (0.0, -1.0, 0.0);
    glVertex3f (0.0, 0.0, 0.0);
    glVertex3f (-1.0, 0.0, 0.0);

    glNormal3f (0.0, 0.0, 1.0);
    glVertex3f (0.0, -1.0, 0.0);
    glVertex3f (1.0, -1.0, 0.0);
    glVertex3f (1.0, 0.0, 0.0);
    glVertex3f (0.0, 0.0, 0.0);

    glNormal3f (0.0, 0.0, 1.0);
    glVertex3f (0.0, 0.0, 0.0);
    glVertex3f (1.0, 0.0, 0.0);
    glVertex3f (1.0, 1.0, 0.0);
    glVertex3f (0.0, 1.0, 0.0);

    glNormal3f (0.0, 0.0, 1.0);
    glVertex3f (0.0, 0.0, 0.0);
    glVertex3f (0.0, 1.0, 0.0);
    glVertex3f (-1.0, 1.0, 0.0);
    glVertex3f (-1.0, 0.0, 0.0);
    glEnd();
}

void display (void)
{
    GLfloat infinite_light[] = { 1.0, 1.0, 1.0, 0.0 };
    GLfloat local_light[] = { 1.0, 1.0, 1.0, 1.0 };

    glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    glPushMatrix ();
    glTranslatef (-1.5, 0.0, 0.0);
    glLightfv (GL_LIGHT0, GL_POSITION, infinite_light);
    drawPlane ();
    glPopMatrix ();

    glPushMatrix ();
    glTranslatef (1.5, 0.0, 0.0);
    glLightfv (GL_LIGHT0, GL_POSITION, local_light);
    drawPlane ();
    glPopMatrix ();
    glFlush ();
}

void myReshape (GLsizei w, GLsizei h)
{
    glViewport (0, 0, w, h);
    glMatrixMode (GL_PROJECTION);
    glLoadIdentity ();
    if (w <= h) 
	glOrtho (-1.5, 1.5, -1.5*(GLdouble)h/(GLdouble)w, 
	    1.5*(GLdouble)h/(GLdouble)w, -10.0, 10.0);
    else 
	glOrtho (-1.5*(GLdouble)w/(GLdouble)h, 
	    1.5*(GLdouble)w/(GLdouble)h, -1.5, 1.5, -10.0, 10.0);
    glMatrixMode (GL_MODELVIEW);
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB | AUX_DEPTH16);
    auxInitPosition (0, 0, 500, 200);
    auxInitWindow (argv[0]);
    myinit();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\nurbs.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  nurbs.c
 *  This program shows a NURBS (Non-uniform rational B-splines)
 *  surface, shaped like a heart.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

#define S_NUMPOINTS 13
#define S_ORDER     3   
#define S_NUMKNOTS  (S_NUMPOINTS + S_ORDER)
#define T_NUMPOINTS 3
#define T_ORDER     3 
#define T_NUMKNOTS  (T_NUMPOINTS + T_ORDER)
#define SQRT2    1.41421356237309504880

/* initialized local data */

GLfloat sknots[S_NUMKNOTS] =
    {-1.0, -1.0, -1.0, 0.0, 1.0, 2.0, 3.0, 4.0,
      4.0,  5.0,  6.0, 7.0, 8.0, 9.0, 9.0, 9.0};
GLfloat tknots[T_NUMKNOTS] = {1.0, 1.0, 1.0, 2.0, 2.0, 2.0};

GLfloat ctlpoints[S_NUMPOINTS][T_NUMPOINTS][4] = {
{   {4.,2.,2.,1.},{4.,1.6,2.5,1.},{4.,2.,3.0,1.}    },
{   {5.,4.,2.,1.},{5.,4.,2.5,1.},{5.,4.,3.0,1.} },
{   {6.,5.,2.,1.},{6.,5.,2.5,1.},{6.,5.,3.0,1.} },
{   {SQRT2*6.,SQRT2*6.,SQRT2*2.,SQRT2},
    {SQRT2*6.,SQRT2*6.,SQRT2*2.5,SQRT2},
    {SQRT2*6.,SQRT2*6.,SQRT2*3.0,SQRT2}  },
{   {5.2,6.7,2.,1.},{5.2,6.7,2.5,1.},{5.2,6.7,3.0,1.}   },
{   {SQRT2*4.,SQRT2*6.,SQRT2*2.,SQRT2},
    {SQRT2*4.,SQRT2*6.,SQRT2*2.5,SQRT2},
    {SQRT2*4.,SQRT2*6.,SQRT2*3.0,SQRT2}  },
{   {4.,5.2,2.,1.},{4.,4.6,2.5,1.},{4.,5.2,3.0,1.}  },
{   {SQRT2*4.,SQRT2*6.,SQRT2*2.,SQRT2},
    {SQRT2*4.,SQRT2*6.,SQRT2*2.5,SQRT2},
    {SQRT2*4.,SQRT2*6.,SQRT2*3.0,SQRT2}  },
{   {2.8,6.7,2.,1.},{2.8,6.7,2.5,1.},{2.8,6.7,3.0,1.}   },
{   {SQRT2*2.,SQRT2*6.,SQRT2*2.,SQRT2},
    {SQRT2*2.,SQRT2*6.,SQRT2*2.5,SQRT2},
    {SQRT2*2.,SQRT2*6.,SQRT2*3.0,SQRT2}  },
{   {2.,5.,2.,1.},{2.,5.,2.5,1.},{2.,5.,3.0,1.} },
{   {3.,4.,2.,1.},{3.,4.,2.5,1.},{3.,4.,3.0,1.} },
{   {4.,2.,2.,1.},{4.,1.6,2.5,1.},{4.,2.,3.0,1.}    }
};

GLUnurbsObj *theNurb;

/*  Initialize material property, light source, lighting model, 
 *  and depth buffer.
 */
void myinit(void)
{
    GLfloat mat_ambient[] = { 1.0, 1.0, 1.0, 1.0 };
    GLfloat mat_diffuse[] = { 1.0, 0.2, 1.0, 1.0 };
    GLfloat mat_specular[] = { 1.0, 1.0, 1.0, 1.0 };
    GLfloat mat_shininess[] = { 50.0 };

    GLfloat light0_position[] = { 1.0, 0.1, 1.0, 0.0 };
    GLfloat light1_position[] = { -1.0, 0.1, 1.0, 0.0 };

    GLfloat lmodel_ambient[] = { 0.3, 0.3, 0.3, 1.0 };

    glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
    glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
    glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);
    glLightfv(GL_LIGHT0, GL_POSITION, light0_position);
    glLightfv(GL_LIGHT1, GL_POSITION, light1_position);
    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_ambient);

    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);
    glEnable(GL_LIGHT1);
    glDepthFunc(GL_LESS);
    glEnable(GL_DEPTH_TEST);
    glEnable(GL_AUTO_NORMAL);

    theNurb = gluNewNurbsRenderer();

    glNewList (1, GL_COMPILE);
    gluBeginSurface(theNurb);
/*  gluNurbsProperty(theNurb, GLU_SAMPLING_TOLERANCE, 5.0); */
    gluNurbsProperty(theNurb, GLU_DISPLAY_MODE, GLU_FILL);
    gluNurbsSurface(theNurb, 
	    S_NUMKNOTS, sknots,
	    T_NUMKNOTS, tknots,
	    4 * T_NUMPOINTS,
	    4,
	    &ctlpoints[0][0][0], 
	    S_ORDER, T_ORDER,
	    GL_MAP2_VERTEX_4);
    gluEndSurface(theNurb);
    glEndList ();

}

void display(void)
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glColor3f(1.0, 1.0, 1.0);

    glPushMatrix();
    glTranslatef (4., 4.5, 2.5);
    glRotatef (220.0, 1., 0., 0.);
    glRotatef (115.0, 0., 1., 0.);
    glTranslatef (-4., -4.5, -2.5);
    glCallList (1);
    glPopMatrix();
    glFlush();
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glFrustum(-2.0, 2.0, -2.0, 2.0, 0.8, 10.0);
    gluLookAt(7.0,4.5,4.0, 4.5,4.5,2.0, 6.0,-3.0,2.0);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB | AUX_DEPTH16);
    auxInitPosition (0, 0, 500, 500);
    auxInitWindow (argv[0]);
    myinit();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\planet.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  planet.c
 *  This program shows how to composite modeling transformations
 *  to draw translated and rotated models.
 *  Interaction:  pressing the left, right, up, and down 
 *  arrow keys alters the rotation of the planet around the sun.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

static int year = 0, day = 0;

void dayAdd (void)
{
    day = (day + 10) % 360;
}

void daySubtract (void)
{
    day = (day - 10) % 360;
}

void yearAdd (void)
{
    year = (year + 5) % 360;
}

void yearSubtract (void)
{
    year = (year - 5) % 360;
}

void display(void)
{
    glClear(GL_COLOR_BUFFER_BIT);

    glColor3f (1.0, 1.0, 1.0);
    glPushMatrix();
/*	draw sun	*/
    auxWireSphere(1.0);
/*	draw smaller planet	*/
    glRotatef ((GLfloat) year, 0.0, 1.0, 0.0);
    glTranslatef (2.0, 0.0, 0.0);
    glRotatef ((GLfloat) day, 0.0, 1.0, 0.0);
    auxWireSphere(0.2);
    glPopMatrix();
    glFlush();
}

void myinit (void) {
    glShadeModel (GL_FLAT);
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(60.0, (GLfloat) w/(GLfloat) h, 1.0, 20.0);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    glTranslatef (0.0, 0.0, -5.0);
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB);
    auxInitPosition (0, 0, 500, 500);
    auxInitWindow (argv[0]);
    myinit ();
    auxKeyFunc (AUX_LEFT, yearSubtract);
    auxKeyFunc (AUX_RIGHT, yearAdd);
    auxKeyFunc (AUX_UP, dayAdd);
    auxKeyFunc (AUX_DOWN, daySubtract);
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\robot2.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED
 * Permission to use, copy, modify, and distribute this software for
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission.
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 * US Government Users Restricted Rights
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  robot.c
 *  This program shows how to composite modeling transformations
 *  to draw translated and rotated hierarchical models.
 *  Interaction:  pressing the arrow keys alters the rotation
 *  of robot arm.
 */
#include <windows.h>
#include <stdio.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

#define WIDTH 400
#define HEIGHT 400

static int shoulder = 30, elbow = 0;

void elbowAdd (void)
{
    elbow = (elbow + 5) % 360;
}

void elbowSubtract (void)
{
    elbow = (elbow - 5) % 360;
}

void shoulderAdd (void)
{
    shoulder = (shoulder + 5) % 360;
}

void shoulderSubtract (void)
{
    shoulder = (shoulder - 5) % 360;
}

void display(void)
{

    glClear(GL_COLOR_BUFFER_BIT);
    glBegin(GL_TRIANGLES);
        glColor3f(1.0F, 0.0F, 0.0F);
        glVertex3f(0.0F, 0.6F, 1.0F);

        glColor3f(0.0F, 1.0F, 0.0F);
        glVertex3f(-0.7F, -0.5F, 0.0F);

        glColor3f(0.0F, 0.0F, 1.0F);
        glVertex3f(0.4F, -0.4F, -1.0F);
    glEnd();

    glFlush();
}

void myReshape(GLsizei w, GLsizei h)
{
printf("Robot2:myReshape\n");
    glViewport(0, 0, w, h);
glFlush();
printf("Robot2:mmode\n");
    glMatrixMode(GL_PROJECTION);
glFlush();
printf("Robot2:loadid\n");
    glLoadIdentity();
glFlush();
printf("Robot2:perspective\n");
    gluPerspective(65.0, (GLfloat) w/(GLfloat) h, 1.0, 20.0);
glFlush();
printf("Robot2:mmode2\n");
    glMatrixMode(GL_MODELVIEW);
glFlush();
printf("Robot2:loadid2\n");
    glLoadIdentity();
glFlush();
printf("Robot2:xlate\n");
    glTranslatef (0.0, 0.0, -5.0);  /* viewing transform  */
glFlush();
}

void myinit (void)
{
    glShadeModel (GL_FLAT);
    myReshape(WIDTH, HEIGHT);
}


/*  Main Loop
 *  Open window with initial window size, title bar,
 *  RGBA display mode, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB);
    auxInitPosition (100, 100, WIDTH, HEIGHT);
    auxInitWindow (argv[0]);

    myinit ();

    auxKeyFunc (AUX_LEFT, shoulderSubtract);
    auxKeyFunc (AUX_RIGHT, shoulderAdd);
    auxKeyFunc (AUX_UP, elbowAdd);
    auxKeyFunc (AUX_DOWN, elbowSubtract);
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\planetup.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  planetup.c
 *  The planets (from planet.c) have been rotated so their 
 *  polar regions are north/south.  
 *  Interaction:  pressing the left, right, up, and down 
 *  arrow keys alters the rotation of the planet around the sun.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

static int year = 0, day = 0;

void dayAdd (void)
{
    day = (day + 10) % 360;
}

void daySubtract (void)
{
    day = (day - 10) % 360;
}

void yearAdd (void)
{
    year = (year + 5) % 360;
}

void yearSubtract (void)
{
    year = (year - 5) % 360;
}

void display(void)
{
    glClear(GL_COLOR_BUFFER_BIT);

    glColor3f (1.0, 1.0, 1.0);
    glPushMatrix();
/*	draw sun	*/
    glPushMatrix();
    glRotatef (90.0, 1.0, 0.0, 0.0);  /*  rotate it upright  */
    auxWireSphere(1.0);
    glPopMatrix();
/*	draw smaller planet	*/
    glRotatef ((GLfloat) year, 0.0, 1.0, 0.0);
    glTranslatef (2.0, 0.0, 0.0);
    glRotatef ((GLfloat) day, 0.0, 1.0, 0.0);
    glRotatef (90.0, 1.0, 0.0, 0.0);  /*  rotate it upright  */
    auxWireSphere(0.2);
    glPopMatrix();
    glFlush();
}

void myinit (void) {
    glShadeModel (GL_FLAT);
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(60.0, (GLfloat) w/(GLfloat) h, 1.0, 20.0);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    glTranslatef (0.0, 0.0, -5.0);
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB);
    auxInitPosition (0, 0, 500, 500);
    auxInitWindow (argv[0]);
    myinit ();
    auxKeyFunc (AUX_LEFT, yearSubtract);
    auxKeyFunc (AUX_RIGHT, yearAdd);
    auxKeyFunc (AUX_UP, dayAdd);
    auxKeyFunc (AUX_DOWN, daySubtract);
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\scene.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  scene.c
 *  This program demonstrates the use of the GL lighting model.
 *  Objects are drawn using a grey material characteristic. 
 *  A single light source illuminates the objects.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

/*  Initialize material property and light source.
 */
void myinit (void)
{
    GLfloat light_ambient[] = { 0.0, 0.0, 0.0, 1.0 };
    GLfloat light_diffuse[] = { 1.0, 1.0, 1.0, 1.0 };
    GLfloat light_specular[] = { 1.0, 1.0, 1.0, 1.0 };
/*	light_position is NOT default value	*/
    GLfloat light_position[] = { 1.0, 1.0, 1.0, 0.0 };

    glLightfv (GL_LIGHT0, GL_AMBIENT, light_ambient);
    glLightfv (GL_LIGHT0, GL_DIFFUSE, light_diffuse);
    glLightfv (GL_LIGHT0, GL_SPECULAR, light_specular);
    glLightfv (GL_LIGHT0, GL_POSITION, light_position);
    
    glEnable (GL_LIGHTING);
    glEnable (GL_LIGHT0);
    glDepthFunc(GL_LESS);
    glEnable(GL_DEPTH_TEST);
}

void display (void)
{
    glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    glPushMatrix ();
    glRotatef (20.0, 1.0, 0.0, 0.0);

    glPushMatrix ();
    glTranslatef (-0.75, 0.5, 0.0); 
    glRotatef (90.0, 1.0, 0.0, 0.0);
    auxSolidTorus (0.275, 0.85);
    glPopMatrix ();

    glPushMatrix ();
    glTranslatef (-0.75, -0.5, 0.0); 
    glRotatef (270.0, 1.0, 0.0, 0.0);
    auxSolidCone (1.0, 2.0);
    glPopMatrix ();

    glPushMatrix ();
    glTranslatef (0.75, 0.0, -1.0); 
    auxSolidSphere (1.0);
    glPopMatrix ();

    glPopMatrix ();
    glFlush ();
}

void myReshape (GLsizei w, GLsizei h)
{
    glViewport (0, 0, w, h);
    glMatrixMode (GL_PROJECTION);
    glLoadIdentity ();
    if (w <= h) 
	glOrtho (-2.5, 2.5, -2.5*(GLfloat)h/(GLfloat)w, 
	    2.5*(GLfloat)h/(GLfloat)w, -10.0, 10.0);
    else 
	glOrtho (-2.5*(GLfloat)w/(GLfloat)h, 
	    2.5*(GLfloat)w/(GLfloat)h, -2.5, 2.5, -10.0, 10.0);
    glMatrixMode (GL_MODELVIEW);
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB | AUX_DEPTH16);
    auxInitPosition (100, 50, 500, 500);
    auxInitWindow (argv[0]);
    myinit ();
    auxReshapeFunc (myReshape);
    auxMainLoop (display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\rgbrop.c ===
#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

GLboolean single = GL_FALSE;
GLboolean no_op = GL_FALSE;

int width = 512;
int height = 512;

void TriangleAt(GLfloat x, GLfloat y, GLfloat z,
                GLfloat w, GLfloat h,
                BOOL colors)
{
    glPushMatrix();
    glTranslatef(x, y, z);
    
    glBegin (GL_TRIANGLES);
    if (colors)
    {
        glColor3f(1.0f, 0.0f, 0.0f);
    }
    glVertex2f (0.0f, 0.0f);
    if (colors)
    {
        glColor3f(0.0f, 1.0f, 0.0f);
    }
    glVertex2f (w, h);
    if (colors)
    {
        glColor3f(0.0f, 0.0f, 1.0f);
    }
    glVertex2f (0.0f, h);
    glEnd ();
    
    glPopMatrix();
}

void SquareAt(GLfloat x, GLfloat y, GLfloat z,
              GLfloat w, GLfloat h,
              BOOL colors)
{
    glPushMatrix();
    glTranslatef(x, y, z);
    
    glBegin (GL_POLYGON);
    if (colors)
    {
        glColor3f(1.0f, 0.0f, 0.0f);
    }
    glVertex2f (0.0f, 0.0f);
    if (colors)
    {
        glColor3f(0.0f, 1.0f, 0.0f);
    }
    glVertex2f (w, 0.0f);
    if (colors)
    {
        glColor3f(0.0f, 0.0f, 1.0f);
    }
    glVertex2f (w, h);
    if (colors)
    {
        glColor3f(1.0f, 0.0f, 1.0f);
    }
    glVertex2f (0.0f, h);
    glEnd ();
    
    glPopMatrix();
}

void Test(void)
{
    int x, y;

    for (y = 0; y < 4; y++)
    {
        for (x = 0; x < 4; x++)
        {
            glDisable(GL_COLOR_LOGIC_OP);
            
            glColor3ub(255, 0, 0);
            TriangleAt(-1.0f+x*0.5f, -1.0f+y*0.5f, 0.0f, 0.5f, 0.5f, FALSE);

            if (!no_op)
            {
                glEnable(GL_COLOR_LOGIC_OP);
                glLogicOp(GL_CLEAR+x+y*4);
            
                glColor3ub(255, 255, 0);
                SquareAt(-1.0f+x*0.5f, -1.0f+y*0.5f, 0.0f, 0.5f, 0.5f, FALSE);
            }
        }
    }
}

void Display(void)
{
    glClear(GL_COLOR_BUFFER_BIT);
    Test();
    if (single)
    {
        glFlush();
    }
    else
    {
        auxSwapBuffers();
    }
}

void Reshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    width = w;
    height = h;
}

int __cdecl main(int argc, char** argv)
{
    GLenum mode;
    
    while (--argc > 0)
    {
        argv++;

        if (!strcmp(*argv, "-sb"))
        {
            single = GL_TRUE;
        }
        else if (!strcmp(*argv, "-noop"))
        {
            no_op = GL_TRUE;
        }
    }

    mode = AUX_RGB | (single ? AUX_SINGLE : AUX_DOUBLE);
    auxInitDisplayMode(mode);
    auxInitPosition(10, 10, width, height);
    auxInitWindow("RGB Logic Op Test");
    auxReshapeFunc(Reshape);
    auxMainLoop(Display);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\polys.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  polys.c
 *  This program demonstrates polygon stippling.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

void display(void)
{
    GLubyte fly[] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x03, 0x80, 0x01, 0xC0, 0x06, 0xC0, 0x03, 0x60, 0x04, 0x60, 0x06, 0x20,
0x04, 0x30, 0x0C, 0x20, 0x04, 0x18, 0x18, 0x20, 0x04, 0x0C, 0x30, 0x20,
0x04, 0x06, 0x60, 0x20, 0x44, 0x03, 0xC0, 0x22, 0x44, 0x01, 0x80, 0x22,
0x44, 0x01, 0x80, 0x22, 0x44, 0x01, 0x80, 0x22, 0x44, 0x01, 0x80, 0x22,
0x44, 0x01, 0x80, 0x22, 0x44, 0x01, 0x80, 0x22, 0x66, 0x01, 0x80, 0x66,
0x33, 0x01, 0x80, 0xCC, 0x19, 0x81, 0x81, 0x98, 0x0C, 0xC1, 0x83, 0x30,
0x07, 0xe1, 0x87, 0xe0, 0x03, 0x3f, 0xfc, 0xc0, 0x03, 0x31, 0x8c, 0xc0,
0x03, 0x33, 0xcc, 0xc0, 0x06, 0x64, 0x26, 0x60, 0x0c, 0xcc, 0x33, 0x30,
0x18, 0xcc, 0x33, 0x18, 0x10, 0xc4, 0x23, 0x08, 0x10, 0x63, 0xC6, 0x08,
0x10, 0x30, 0x0c, 0x08, 0x10, 0x18, 0x18, 0x08, 0x10, 0x00, 0x00, 0x08};

    GLubyte halftone[] = {
0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55, 0xAA, 0xAA, 0xAA, 0xAA,
0x55, 0x55, 0x55, 0x55, 0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55, 0xAA, 0xAA, 0xAA, 0xAA,
0x55, 0x55, 0x55, 0x55, 0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55, 0xAA, 0xAA, 0xAA, 0xAA,
0x55, 0x55, 0x55, 0x55, 0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55, 0xAA, 0xAA, 0xAA, 0xAA,
0x55, 0x55, 0x55, 0x55, 0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55, 0xAA, 0xAA, 0xAA, 0xAA,
0x55, 0x55, 0x55, 0x55, 0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55,
0xAA, 0xAA, 0xAA, 0xAA, 0x55, 0x55, 0x55, 0x55};

    glClear (GL_COLOR_BUFFER_BIT);

/*  draw all polygons in white	*/
    glColor3f (1.0, 1.0, 1.0);

/*  draw one solid, unstippled rectangle,	*/	
/*  then two stippled rectangles		*/
    glRectf (25.0, 25.0, 125.0, 125.0);
    glEnable (GL_POLYGON_STIPPLE);
    glPolygonStipple (fly);
    glRectf (125.0, 25.0, 225.0, 125.0);
    glPolygonStipple (halftone);
    glRectf (225.0, 25.0, 325.0, 125.0);
    glDisable (GL_POLYGON_STIPPLE);

    glFlush ();
}

void myinit (void) 
{
/*  clear background to black	*/
    glClearColor (0.0, 0.0, 0.0, 0.0);
    glShadeModel (GL_FLAT);    
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB);
    auxInitPosition (0, 0, 350, 150);
    auxInitWindow (argv[0]);
    myinit ();
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\robot.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  robot.c
 *  This program shows how to composite modeling transformations
 *  to draw translated and rotated hierarchical models.
 *  Interaction:  pressing the arrow keys alters the rotation 
 *  of robot arm.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

static int shoulder = 0, elbow = 0;

void elbowAdd (void)
{
    elbow = (elbow + 5) % 360;
}

void elbowSubtract (void)
{
    elbow = (elbow - 5) % 360;
}

void shoulderAdd (void)
{
    shoulder = (shoulder + 5) % 360;
}

void shoulderSubtract (void)
{
    shoulder = (shoulder - 5) % 360;
}

void display(void)
{

    glClear(GL_COLOR_BUFFER_BIT);
    glColor3f (1.0, 1.0, 1.0);

    glPushMatrix();
    glTranslatef (-1.0, 0.0, 0.0);
    glRotatef ((GLfloat) shoulder, 0.0, 0.0, 1.0);
    glTranslatef (1.0, 0.0, 0.0);
    auxWireBox(2.0, 0.4, 1.0);

    glTranslatef (1.0, 0.0, 0.0);
    glRotatef ((GLfloat) elbow, 0.0, 0.0, 1.0);
    glTranslatef (1.0, 0.0, 0.0);
    auxWireBox(2.0, 0.4, 1.0);

    glPopMatrix();
    glFlush();
}

void myinit (void) 
{
    glShadeModel (GL_FLAT);
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(65.0, (GLfloat) w/(GLfloat) h, 1.0, 20.0);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    glTranslatef (0.0, 0.0, -5.0);  /* viewing transform  */
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB | AUX_DIRECT);
    auxInitPosition (100, 100, 400, 400);
    auxInitWindow (argv[0]);

    myinit ();

    auxKeyFunc (AUX_LEFT, shoulderSubtract);
    auxKeyFunc (AUX_RIGHT, shoulderAdd);
    auxKeyFunc (AUX_UP, elbowAdd);
    auxKeyFunc (AUX_DOWN, elbowSubtract);
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\scclrlt.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  sccolorlight.c
 *  This program demonstrates the use of a colored 
 *  (magenta, in this example) light source.  Objects 
 *  are drawn using a grey material characteristic.  
 *  A single light source illuminates the objects.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

/*  Initialize material property and light source.
 */
void myinit(void)
{
    GLfloat light_ambient[] = { 0.0, 0.0, 0.0, 1.0 };
    GLfloat light_diffuse[] = { 1.0, 0.0, 1.0, 1.0 };
    GLfloat light_specular[] = { 1.0, 0.0, 1.0, 1.0 };
/*	light_position is NOT default value	*/
    GLfloat light_position[] = { 1.0, 1.0, 1.0, 0.0 };

    glLightfv(GL_LIGHT0, GL_AMBIENT, light_ambient);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, light_diffuse);
    glLightfv(GL_LIGHT0, GL_SPECULAR, light_specular);
    glLightfv(GL_LIGHT0, GL_POSITION, light_position);
    
    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);
    glDepthFunc(GL_LESS);
    glEnable(GL_DEPTH_TEST);
}

void display(void)
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glPushMatrix ();
    glRotatef (20.0, 1.0, 0.0, 0.0);

    glPushMatrix ();
    glTranslatef (-0.75, 0.5, 0.0); 
    glRotatef (90.0, 1.0, 0.0, 0.0);
    auxSolidTorus (0.275, 0.85);
    glPopMatrix ();

    glPushMatrix ();
    glTranslatef (-0.75, -0.5, 0.0); 
    glRotatef (270.0, 1.0, 0.0, 0.0);
    auxSolidCone (1.0, 2.0);
    glPopMatrix ();

    glPushMatrix ();
    glTranslatef (0.75, 0.0, -1.0); 
    auxSolidSphere (1.0);
    glPopMatrix ();

    glPopMatrix ();
    glFlush();
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (w <= h) 
	glOrtho (-2.5, 2.5, -2.5*(GLfloat)h/(GLfloat)w, 
	    2.5*(GLfloat)h/(GLfloat)w, -10.0, 10.0);
    else 
	glOrtho (-2.5*(GLfloat)w/(GLfloat)h, 
	    2.5*(GLfloat)w/(GLfloat)h, -2.5, 2.5, -10.0, 10.0);
    glMatrixMode(GL_MODELVIEW);
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB | AUX_DEPTH16);
    auxInitPosition (0, 0, 500, 500);
    auxInitWindow (argv[0]);
    myinit();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\sceneflt.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  sceneflat.c
 *  This program draws lighted objects with flat shading.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

/*  Initialize light source and shading model (GL_FLAT).
 */
void myinit(void)
{
    GLfloat light_ambient[] = { 0.0, 0.0, 0.0, 1.0 };
    GLfloat light_diffuse[] = { 1.0, 1.0, 1.0, 1.0 };
    GLfloat light_specular[] = { 1.0, 1.0, 1.0, 1.0 };
/*	light_position is NOT default value	*/
    GLfloat light_position[] = { 1.0, 1.0, 1.0, 0.0 };

    glLightfv(GL_LIGHT0, GL_AMBIENT, light_ambient);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, light_diffuse);
    glLightfv(GL_LIGHT0, GL_SPECULAR, light_specular);
    glLightfv(GL_LIGHT0, GL_POSITION, light_position);
    
    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);
    glDepthFunc(GL_LESS);
    glEnable(GL_DEPTH_TEST);
    glShadeModel (GL_FLAT);
}

void display(void)
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    glPushMatrix ();
    glRotatef (20.0, 1.0, 0.0, 0.0);

    glPushMatrix ();
    glTranslatef (-0.75, 0.5, 0.0); 
    glRotatef (90.0, 1.0, 0.0, 0.0);
    auxSolidTorus (0.275, 0.85);
    glPopMatrix ();

    glPushMatrix ();
    glTranslatef (-0.75, -0.5, 0.0); 
    glRotatef (270.0, 1.0, 0.0, 0.0);
    auxSolidCone (1.0, 2.0);
    glPopMatrix ();

    glPushMatrix ();
    glTranslatef (0.75, 0.0, -1.0); 
    auxSolidSphere (1.0);
    glPopMatrix ();

    glPopMatrix ();
    glFlush();
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (w <= h) 
	glOrtho (-2.5, 2.5, -2.5*(GLfloat)h/(GLfloat)w, 
	    2.5*(GLfloat)h/(GLfloat)w, -10.0, 10.0);
    else 
	glOrtho (-2.5*(GLfloat)w/(GLfloat)h, 
	    2.5*(GLfloat)w/(GLfloat)h, -2.5, 2.5, -10.0, 10.0);
    glMatrixMode(GL_MODELVIEW);
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB | AUX_DEPTH16);
    auxInitPosition (0, 0, 500, 500);
    auxInitWindow (argv[0]);
    myinit();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\select.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  select.c
 *  This is an illustration of the selection mode and 
 *  name stack, which detects whether objects which collide 
 *  with a viewing volume.  First, four triangles and a 
 *  rectangular box representing a viewing volume are drawn 
 *  (drawScene routine).  The green triangle and yellow 
 *  triangles appear to lie within the viewing volume, but 
 *  the red triangle appears to lie outside it.  Then the 
 *  selection mode is entered (selectObjects routine).  
 *  Drawing to the screen ceases.  To see if any collisions 
 *  occur, the four triangles are called.  In this example, 
 *  the green triangle causes one hit with the name 1, and 
 *  the yellow triangles cause one hit with the name 3.
 */
#include <windows.h>
#include <stdio.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

/*	draw a triangle with vertices at (x1, y1), (x2, y2) 
 *	and (x3, y3) at z units away from the origin.
 */
void drawTriangle (GLfloat x1, GLfloat y1, GLfloat x2, 
    GLfloat y2, GLfloat x3, GLfloat y3, GLfloat z)
{
    glBegin (GL_TRIANGLES);
    glVertex3f (x1, y1, z);
    glVertex3f (x2, y2, z);
    glVertex3f (x3, y3, z);
    glEnd ();
}

/*  draw a rectangular box with these outer x, y, and z values	*/
void drawViewVolume (GLfloat x1, GLfloat x2, GLfloat y1, 
    GLfloat y2, GLfloat z1, GLfloat z2)
{
    glColor3f (1.0, 1.0, 1.0);
    glBegin (GL_LINE_LOOP);
    glVertex3f (x1, y1, -z1);
    glVertex3f (x2, y1, -z1);
    glVertex3f (x2, y2, -z1);
    glVertex3f (x1, y2, -z1);
    glEnd ();

    glBegin (GL_LINE_LOOP);
    glVertex3f (x1, y1, -z2);
    glVertex3f (x2, y1, -z2);
    glVertex3f (x2, y2, -z2);
    glVertex3f (x1, y2, -z2);
    glEnd ();

    glBegin (GL_LINES);	/*  4 lines	*/
    glVertex3f (x1, y1, -z1);
    glVertex3f (x1, y1, -z2);
    glVertex3f (x1, y2, -z1);
    glVertex3f (x1, y2, -z2);
    glVertex3f (x2, y1, -z1);
    glVertex3f (x2, y1, -z2);
    glVertex3f (x2, y2, -z1);
    glVertex3f (x2, y2, -z2);
    glEnd ();
}

/*  drawScene() draws 4 triangles and a wire frame
 *  which represents the viewing volume.
 */
void drawScene (void)
{
    glMatrixMode (GL_PROJECTION);
    glLoadIdentity ();
    gluPerspective (40.0, 4.0/3.0, 0.01, 100.0);

    glMatrixMode (GL_MODELVIEW);
    glLoadIdentity ();
    gluLookAt (7.5, 7.5, 12.5, 2.5, 2.5, -5.0, 0.0, 1.0, 0.0);
    glColor3f (0.0, 1.0, 0.0);	/*  green triangle	*/
    drawTriangle (2.0, 2.0, 3.0, 2.0, 2.5, 3.0, -5.0);
    glColor3f (1.0, 0.0, 0.0);	/*  red triangle	*/
    drawTriangle (2.0, 7.0, 3.0, 7.0, 2.5, 8.0, -5.0);
    glColor3f (1.0, 1.0, 0.0);	/*  yellow triangles	*/
    drawTriangle (2.0, 2.0, 3.0, 2.0, 2.5, 3.0, 0.0);
    drawTriangle (2.0, 2.0, 3.0, 2.0, 2.5, 3.0, -10.0);
    drawViewVolume (0.0, 5.0, 0.0, 5.0, 0.0, 10.0);
}

/*  processHits() prints out the contents of the selection array.
 */
void processHits (GLint hits, GLuint buffer[])
{
    unsigned int i, j;
    GLuint names, *ptr;

    printf ("hits = %d\n", hits);
    ptr = (GLuint *) buffer;
    for (i = 0; i < hits; i++) {	/*  for each hit  */
	names = *ptr;
	printf (" number of names for hit = %d\n", names); ptr++;
	printf ("  z1 is %u;", *ptr); ptr++;
	printf (" z2 is %u\n", *ptr); ptr++;
	printf ("   the name is ");
	for (j = 0; j < names; j++) {	/*  for each name */
	    printf ("%d ", *ptr); ptr++;
	}
	printf ("\n");
    }
}

/*  selectObjects() "draws" the triangles in selection mode, 
 *  assigning names for the triangles.  Note that the third
 *  and fourth triangles share one name, so that if either 
 *  or both triangles intersects the viewing/clipping volume, 
 *  only one hit will be registered.
 */
#define BUFSIZE 512

void selectObjects(void)
{
    GLuint selectBuf[BUFSIZE];
    GLint hits, viewport[4];

    glSelectBuffer (BUFSIZE, selectBuf);
    (void) glRenderMode (GL_SELECT);

    glInitNames();
    glPushName(-1);

    glPushMatrix ();
    glMatrixMode (GL_PROJECTION);
    glLoadIdentity ();
    glOrtho (0.0, 5.0, 0.0, 5.0, 0.0, 10.0);
    glMatrixMode (GL_MODELVIEW);
    glLoadIdentity ();
    glLoadName(1);
    drawTriangle (2.0, 2.0, 3.0, 2.0, 2.5, 3.0, -5.0);
    glLoadName(2);
    drawTriangle (2.0, 7.0, 3.0, 7.0, 2.5, 8.0, -5.0);
    glLoadName(3);
    drawTriangle (2.0, 2.0, 3.0, 2.0, 2.5, 3.0, 0.0);
    drawTriangle (2.0, 2.0, 3.0, 2.0, 2.5, 3.0, -10.0);
    glPopMatrix ();
    glFlush ();

    hits = glRenderMode (GL_RENDER);
    processHits (hits, selectBuf);
} 

void myinit (void) 
{
    glDepthFunc(GL_LESS);
    glEnable(GL_DEPTH_TEST);
    glShadeModel(GL_FLAT);
}

void display(void)
{
    glClearColor (0.0, 0.0, 0.0, 0.0);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    drawScene ();
    selectObjects ();
    glFlush();
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, depth buffer, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB | AUX_DEPTH16);
    auxInitPosition (0, 0, 200, 200);
    auxInitWindow (argv[0]);
    myinit ();
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\scene2.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  scene.c
 *  This program demonstrates the use of the GL lighting model.
 *  Objects are drawn using a grey material characteristic. 
 *  A single light source illuminates the objects.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

/*  Initialize material property and light source.
 */
void myinit (void)
{
    GLfloat light_ambient[] = { 0.0, 0.0, 0.0, 1.0 };

    GLfloat rlight_diffuse[] =  { 0.9, 0.0, 0.0, 1.0 };
    GLfloat rlight_specular[] = { 0.9, 0.0, 0.0, 1.0 };
    GLfloat glight_diffuse[] =  { 0.0, 0.7, 0.0, 1.0 };
    GLfloat glight_specular[] = { 0.0, 0.7, 0.0, 1.0 };
    GLfloat blight_diffuse[] =  { 0.0, 0.0, 0.5, 1.0 };
    GLfloat blight_specular[] = { 0.0, 0.0, 0.5, 1.0 };

/*	light_position is NOT default value	*/
    GLfloat light_position[] = { 1.0, 1.0, 1.0, 0.0 };

    glLightfv (GL_LIGHT0, GL_AMBIENT, light_ambient);
    glLightfv (GL_LIGHT0, GL_DIFFUSE, rlight_diffuse);
    glLightfv (GL_LIGHT0, GL_SPECULAR, rlight_specular);
    glLightfv (GL_LIGHT0, GL_POSITION, light_position);
    
    glLightfv (GL_LIGHT1, GL_AMBIENT, light_ambient);
    glLightfv (GL_LIGHT1, GL_DIFFUSE, glight_diffuse);
    glLightfv (GL_LIGHT1, GL_SPECULAR, glight_specular);
    glLightfv (GL_LIGHT1, GL_POSITION, light_position);
    
    glLightfv (GL_LIGHT2, GL_AMBIENT, light_ambient);
    glLightfv (GL_LIGHT2, GL_DIFFUSE, blight_diffuse);
    glLightfv (GL_LIGHT2, GL_SPECULAR, blight_specular);
    glLightfv (GL_LIGHT2, GL_POSITION, light_position);
    
    glEnable (GL_LIGHTING);
    glDepthFunc(GL_LESS);
    glEnable(GL_DEPTH_TEST);
}

void display (void)
{
    glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    glPushMatrix ();
    glRotatef (20.0, 1.0, 0.0, 0.0);

    glEnable (GL_LIGHT0);
    glPushMatrix ();
    glTranslatef (-0.75, 0.5, 0.0); 
    glRotatef (90.0, 1.0, 0.0, 0.0);
    auxSolidTorus (0.275, 0.85);
    glPopMatrix ();

    glDisable (GL_LIGHT0);
    glEnable (GL_LIGHT1);
    glPushMatrix ();
    glTranslatef (-0.75, -0.5, 0.0); 
    glRotatef (270.0, 1.0, 0.0, 0.0);
    auxSolidCone (1.0, 2.0);
    glPopMatrix ();

    glDisable (GL_LIGHT1);
    glEnable (GL_LIGHT2);
    glPushMatrix ();
    glTranslatef (0.75, 0.0, -1.0); 
    auxSolidSphere (1.0);
    glPopMatrix ();
    glDisable (GL_LIGHT2);

    glPopMatrix ();
    glFlush ();
}

void myReshape (GLsizei w, GLsizei h)
{
    glViewport (0, 0, w, h);
    glMatrixMode (GL_PROJECTION);
    glLoadIdentity ();
    if (w <= h) 
	glOrtho (-2.5, 2.5, -2.5*(GLfloat)h/(GLfloat)w, 
	    2.5*(GLfloat)h/(GLfloat)w, -10.0, 10.0);
    else 
	glOrtho (-2.5*(GLfloat)w/(GLfloat)h, 
	    2.5*(GLfloat)w/(GLfloat)h, -2.5, 2.5, -10.0, 10.0);
    glMatrixMode (GL_MODELVIEW);
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB | AUX_DEPTH16);
    auxInitPosition (100, 50, 500, 500);
    auxInitWindow (argv[0]);
    myinit ();
    auxReshapeFunc (myReshape);
    auxMainLoop (display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\simple.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  simple.c
 *  This program draws a white rectangle on a black background.
 */
#include <windows.h>
#include <stdlib.h>
#include <GL/gl.h>
#include "glaux.h"

int main(int argc, char** argv)
{
        auxInitDisplayMode (AUX_SINGLE | AUX_RGB);
	auxInitPosition (0, 0, 500, 500);
	auxInitWindow (argv[0]);

	glClearColor (0.0, 0.0, 0.0, 0.0);
	glClear(GL_COLOR_BUFFER_BIT);
	glColor3f(1.0, 1.0, 1.0);
	glMatrixMode (GL_PROJECTION);
	glLoadIdentity ();
	glOrtho(-1.0, 1.0, -1.0, 1.0, -1.0, 1.0);
	glBegin(GL_POLYGON);
	 	glVertex2f(-0.5, -0.5);
	 	glVertex2f(-0.5, 0.5);
	 	glVertex2f(0.5, 0.5);
	 	glVertex2f(0.5, -0.5);
	glEnd();
	glFlush();
        _sleep (10000);

        auxQuit();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\sphere.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  sphere.c
 *  This program draws a wire frame sphere.  It uses 
 *  glTranslatef() as a viewing transformation.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

void display (void)
{
    glClear(GL_COLOR_BUFFER_BIT);
    glColor3f (1.0, 1.0, 1.0);
    glPushMatrix();
/*	glTranslatef() as viewing transformation	*/
    glTranslatef (0.0, 0.0, -5.0);
    auxWireSphere(1.0);
    glPopMatrix();
    glFlush();
}

void myinit (void) 
{
    glShadeModel (GL_FLAT);
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(60.0, (GLfloat) w/(GLfloat) h, 1.0, 20.0);
    glMatrixMode(GL_MODELVIEW);
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB);
    auxInitPosition (0, 0, 400, 400);
    auxInitWindow (argv[0]);
    myinit ();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\scenebmb.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  scenebamb.c
 *  This program demonstrates use of a blue ambient light 
 *  source.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

/*  Initialize light source and lighting.
 */
void myinit(void)
{
    GLfloat light_ambient[] = { 0.0, 0.0, 1.0, 1.0 };
    GLfloat light_diffuse[] = { 1.0, 1.0, 1.0, 1.0 };
    GLfloat light_specular[] = { 1.0, 1.0, 1.0, 1.0 };
/*	light_position is NOT default value	*/
    GLfloat light_position[] = { 1.0, 1.0, 1.0, 0.0 };

    glLightfv(GL_LIGHT0, GL_AMBIENT, light_ambient);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, light_diffuse);
    glLightfv(GL_LIGHT0, GL_SPECULAR, light_specular);
    glLightfv(GL_LIGHT0, GL_POSITION, light_position);
    
    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);
    glDepthFunc(GL_LESS);
    glEnable(GL_DEPTH_TEST);
}

void display(void)
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    glPushMatrix ();
    glRotatef (20.0, 1.0, 0.0, 0.0);

    glPushMatrix ();
    glTranslatef (-0.75, 0.5, 0.0); 
    glRotatef (90.0, 1.0, 0.0, 0.0);
    auxSolidTorus (0.275, 0.85);
    glPopMatrix ();

    glPushMatrix ();
    glTranslatef (-0.75, -0.5, 0.0); 
    glRotatef (270.0, 1.0, 0.0, 0.0);
    auxSolidCone (1.0, 2.0);
    glPopMatrix ();

    glPushMatrix ();
    glTranslatef (0.75, 0.0, -1.0); 
    auxSolidSphere (1.0);
    glPopMatrix ();

    glPopMatrix ();
    glFlush();
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (w <= h) 
	glOrtho (-2.5, 2.5, -2.5*(GLfloat)h/(GLfloat)w, 
	    2.5*(GLfloat)h/(GLfloat)w, -10.0, 10.0);
    else 
	glOrtho (-2.5*(GLfloat)w/(GLfloat)h, 
	    2.5*(GLfloat)w/(GLfloat)h, -2.5, 2.5, -10.0, 10.0);
    glMatrixMode(GL_MODELVIEW);
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB | AUX_DEPTH16);
    auxInitPosition (0, 0, 500, 500);
    auxInitWindow (argv[0]);
    myinit();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\smooth.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 * smooth.c
 * This program demonstrates smooth shading.
 * A smooth shaded polygon is drawn in a 2-D projection.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

/*  GL_SMOOTH is actually the default shading model.  */
void myinit (void)
{
    glShadeModel (GL_SMOOTH);
}

void triangle(void)
{
    glBegin (GL_TRIANGLES);
    glColor3f (1.0, 0.0, 0.0);
    glVertex2f (5.0, 5.0);
    glColor3f (0.0, 1.0, 0.0);
    glVertex2f (25.0, 5.0);
    glColor3f (0.0, 0.0, 1.0);
    glVertex2f (5.0, 25.0);
    glEnd ();
}

void display(void)
{
    glClear (GL_COLOR_BUFFER_BIT);
    triangle ();
    glFlush ();
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (w <= h) 
	gluOrtho2D (0.0, 30.0, 0.0, 30.0 * (GLfloat) h/(GLfloat) w);
    else 
	gluOrtho2D (0.0, 30.0 * (GLfloat) w/(GLfloat) h, 0.0, 30.0);
    glMatrixMode(GL_MODELVIEW);
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB);
    auxInitPosition (0, 0, 500, 500);
    auxInitWindow (argv[0]);
    myinit();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\stencil.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*  stencil.c
 *  This program draws two rotated tori in a window.  
 *  A diamond in the center of the window masks out part 
 *  of the scene.  Within this mask, a different model 
 *  (a sphere) is drawn in a different color.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

#define YELLOWMAT   1
#define BLUEMAT 2

void myinit (void) 
{
    GLfloat yellow_diffuse[] = { 0.7, 0.7, 0.0, 1.0 };
    GLfloat yellow_specular[] = { 1.0, 1.0, 1.0, 1.0 };

    GLfloat blue_diffuse[] = { 0.1, 0.1, 0.7, 1.0 };
    GLfloat blue_specular[] = { 0.1, 1.0, 1.0, 1.0 };

    GLfloat position_one[] = { 1.0, 1.0, 1.0, 0.0 };

    glNewList(YELLOWMAT, GL_COMPILE);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, yellow_diffuse);
    glMaterialfv(GL_FRONT, GL_SPECULAR, yellow_specular);
    glMaterialf(GL_FRONT, GL_SHININESS, 64.0);
    glEndList();

    glNewList(BLUEMAT, GL_COMPILE);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, blue_diffuse);
    glMaterialfv(GL_FRONT, GL_SPECULAR, blue_specular);
    glMaterialf(GL_FRONT, GL_SHININESS, 45.0);
    glEndList();

    glLightfv(GL_LIGHT0, GL_POSITION, position_one);

    glEnable(GL_LIGHT0);
    glEnable(GL_LIGHTING);
    glDepthFunc(GL_LESS);
    glEnable(GL_DEPTH_TEST);

    glClearStencil(0x0);
    glEnable(GL_STENCIL_TEST);

}

/*  Draw a sphere in a diamond-shaped section in the
 *  middle of a window with 2 tori.
 */
void display(void)
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

/* draw blue sphere where the stencil is 1 */
    glStencilFunc (GL_EQUAL, 0x1, 0x1);
    glCallList (BLUEMAT);
    auxSolidSphere (0.5);

/* draw the tori where the stencil is not 1 */
    glStencilFunc (GL_NOTEQUAL, 0x1, 0x1);
    glStencilOp (GL_KEEP, GL_KEEP, GL_KEEP);
    glPushMatrix();
	glRotatef (45.0, 0.0, 0.0, 1.0);
	glRotatef (45.0, 0.0, 1.0, 0.0);
	glCallList (YELLOWMAT);
	auxSolidTorus (0.275, 0.85);
	glPushMatrix();
	    glRotatef (90.0, 1.0, 0.0, 0.0);
	    auxSolidTorus (0.275, 0.85);
	glPopMatrix();
    glPopMatrix();
    glFlush();

}

/*  Whenever the window is reshaped, redefine the 
 *  coordinate system and redraw the stencil area.
 */
void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);

    glClear(GL_STENCIL_BUFFER_BIT);
/* create a diamond shaped stencil area */
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(-3.0, 3.0, -3.0, 3.0, -1.0, 1.0);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    glStencilFunc (GL_ALWAYS, 0x1, 0x1);
    glStencilOp (GL_REPLACE, GL_REPLACE, GL_REPLACE);
    glBegin(GL_QUADS);
	glVertex3f (-1.0, 0.0, 0.0);
	glVertex3f (0.0, 1.0, 0.0);
	glVertex3f (1.0, 0.0, 0.0);
	glVertex3f (0.0, -1.0, 0.0);
    glEnd();

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(45.0, (GLfloat) w/(GLfloat) h, 3.0, 7.0);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    glTranslatef(0.0, 0.0, -5.0);
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB 
	| AUX_DEPTH16 | AUX_STENCIL);
    auxInitPosition (0, 0, 400, 400);
    auxInitWindow (argv[0]);
    myinit ();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\teaambient.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  teaambient.c
 *  This program renders three lighted, shaded teapots, with
 *  different ambient values.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

/*  Initialize light source and lighting model.
 */
void myinit(void)
{
#ifdef LIGHTS
    GLfloat light_ambient[] = { 0.0, 0.0, 0.0, 1.0 };
    GLfloat light_diffuse[] = { 1.0, 1.0, 1.0, 1.0 };
    GLfloat light_specular[] = { 1.0, 1.0, 1.0, 1.0 };
/*	light_position is NOT default value	*/
    GLfloat light_position[] = { 1.0, 0.0, 0.0, 0.0 };
    GLfloat global_ambient[] = { 0.75, 0.75, 0.75, 1.0 };

    glLightfv(GL_LIGHT0, GL_AMBIENT, light_ambient);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, light_diffuse);
    glLightfv(GL_LIGHT0, GL_SPECULAR, light_specular);
    glLightfv(GL_LIGHT0, GL_POSITION, light_position);
    
    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, global_ambient);
#endif
    
    glFrontFace (GL_CW);
#ifdef LIGHTS
    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);
#endif
    glEnable(GL_AUTO_NORMAL);
    glEnable(GL_NORMALIZE);
    glDepthFunc(GL_LESS);
    glEnable(GL_DEPTH_TEST);
}

void display(void)
{
    GLfloat low_ambient[] = { 0.1, 0.1, 0.1, 1.0 };
    GLfloat more_ambient[] = { 0.4, 0.4, 0.4, 1.0 };
    GLfloat most_ambient[] = { 1.0, 1.0, 1.0, 1.0 };

    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    glMaterialf(GL_FRONT, GL_SHININESS, 40.0);

#ifdef MULTIPOT
	/*  material has small ambient reflection	*/
    glMaterialfv(GL_FRONT, GL_AMBIENT, low_ambient);
    glPushMatrix ();
    glTranslatef (0.0, 2.0, 0.0);
    auxSolidTeapot(1.0);
    glPopMatrix ();
#endif

	/*  material has moderate ambient reflection	*/
    glColor3f(1.0, 0.0, 0.0);
    //glMaterialfv(GL_FRONT, GL_AMBIENT, more_ambient);
    //glPushMatrix ();
    glTranslatef (0.0, 0.0, 0.0);
    auxSolidTeapot(1.0);
    //glPopMatrix ();

#ifdef MULTIPOT
	/*  material has large ambient reflection	*/
    glMaterialfv(GL_FRONT, GL_AMBIENT, most_ambient);
    glPushMatrix ();
    glTranslatef (0.0, -2.0, 0.0);
    auxSolidTeapot(1.0);
    glPopMatrix ();
#endif
    glFlush();
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (w <= h) 
	glOrtho (-4.0, 4.0, -4.0*(GLfloat)h/(GLfloat)w, 
	    4.0*(GLfloat)h/(GLfloat)w, -10.0, 10.0);
    else 
	glOrtho (-4.0*(GLfloat)w/(GLfloat)h, 
	    4.0*(GLfloat)w/(GLfloat)h, -4.0, 4.0, -10.0, 10.0);
    glMatrixMode(GL_MODELVIEW);
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB | AUX_DEPTH16);
    auxInitPosition (100, 100, 400, 400);
    auxInitWindow (argv[0]);
    myinit();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\teaamb.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  teaambient.c
 *  This program renders three lighted, shaded teapots, with
 *  different ambient values.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

/*  Initialize light source and lighting model.
 */
void myinit(void)
{
    GLfloat light_ambient[] = { 0.0, 0.0, 0.0, 1.0 };
    GLfloat light_diffuse[] = { 0.0, 1.0, 1.0, 1.0 };
    GLfloat light_specular[] = { 0.0, 1.0, 1.0, 1.0 };
/*	light_position is NOT default value	*/
    GLfloat light_position[] = { 1.0, 0.0, 0.0, 0.0 };
    GLfloat global_ambient[] = { 0.75, 0.75, 0.75, 1.0 };

    glLightfv(GL_LIGHT0, GL_AMBIENT, light_ambient);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, light_diffuse);
    glLightfv(GL_LIGHT0, GL_SPECULAR, light_specular);
    glLightfv(GL_LIGHT0, GL_POSITION, light_position);
    
    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, global_ambient);
    
    glFrontFace (GL_CW);
    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);
    glEnable(GL_AUTO_NORMAL);
    glEnable(GL_NORMALIZE);
    glDepthFunc(GL_LESS);
    glEnable(GL_DEPTH_TEST);
}

void display(void)
{
    GLfloat low_ambient[] = { 0.0, 0.1, 0.1, 1.0 };
    GLfloat more_ambient[] = { 0.0, 0.4, 0.4, 1.0 };
    GLfloat most_ambient[] = { 0.0, 1.0, 1.0, 1.0 };

    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

	/*  material has small ambient reflection	*/
    glMaterialfv(GL_FRONT, GL_AMBIENT, low_ambient);
    glMaterialf(GL_FRONT, GL_SHININESS, 40.0);
    glPushMatrix ();
    glTranslatef (0.0, 2.0, 0.0);
    auxSolidTeapot(1.0);
    glPopMatrix ();

	/*  material has moderate ambient reflection	*/
    glMaterialfv(GL_FRONT, GL_AMBIENT, more_ambient);
    glPushMatrix ();
    glTranslatef (0.0, 0.0, 0.0);
    auxSolidTeapot(1.0);
    glPopMatrix ();

	/*  material has large ambient reflection	*/
    glMaterialfv(GL_FRONT, GL_AMBIENT, most_ambient);
    glPushMatrix ();
    glTranslatef (0.0, -2.0, 0.0);
    auxSolidTeapot(1.0);
    glPopMatrix ();
    glFlush();
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (w <= h) 
	glOrtho (-4.0, 4.0, -4.0*(GLfloat)h/(GLfloat)w, 
	    4.0*(GLfloat)h/(GLfloat)w, -10.0, 10.0);
    else 
	glOrtho (-4.0*(GLfloat)w/(GLfloat)h, 
	    4.0*(GLfloat)w/(GLfloat)h, -4.0, 4.0, -10.0, 10.0);
    glMatrixMode(GL_MODELVIEW);
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB | AUX_DEPTH16);
    auxInitPosition (100, 50, 500, 500);
    auxInitWindow (argv[0]);
    myinit();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\surface.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  surface.c
 *  This program draws a NURBS surface in the shape of a 
 *  symmetrical hill.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

GLfloat ctlpoints[4][4][3];

GLUnurbsObj *theNurb;

/*
 *  Initializes the control points of the surface to a small hill.
 *  The control points range from -3 to +3 in x, y, and z
 */
void init_surface(void)
{
    int u, v;
    for (u = 0; u < 4; u++) {
	for (v = 0; v < 4; v++) {
	    ctlpoints[u][v][0] = 2.0*((GLfloat)u - 1.5);
	    ctlpoints[u][v][1] = 2.0*((GLfloat)v - 1.5);

	    if ( (u == 1 || u == 2) && (v == 1 || v == 2))
		ctlpoints[u][v][2] = 3.0;
	    else
		ctlpoints[u][v][2] = -3.0;
	}
    }				
}				
			
/*  Initialize material property and depth buffer.
 */
void myinit(void)
{
    GLfloat mat_diffuse[] = { 0.7, 0.7, 0.7, 1.0 };
    GLfloat mat_specular[] = { 1.0, 1.0, 1.0, 1.0 };
    GLfloat mat_shininess[] = { 100.0 };

    glClearColor (0.0, 0.0, 0.0, 1.0);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
    glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
    glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);

    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);
    glDepthFunc(GL_LESS);
    glEnable(GL_DEPTH_TEST);
    glEnable(GL_AUTO_NORMAL);
    glEnable(GL_NORMALIZE);

    init_surface();

    theNurb = gluNewNurbsRenderer();
    gluNurbsProperty(theNurb, GLU_SAMPLING_TOLERANCE, 25.0);
    gluNurbsProperty(theNurb, GLU_DISPLAY_MODE, GLU_FILL);
}

void display(void)
{
    GLfloat knots[8] = {0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0};

    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    glPushMatrix();
    glRotatef(330.0, 1.,0.,0.);
    glScalef (0.5, 0.5, 0.5);

    gluBeginSurface(theNurb);
    gluNurbsSurface(theNurb, 
	    8, knots,
	    8, knots,
	    4 * 3,
	    3,
	    &ctlpoints[0][0][0], 
	    4, 4,
	    GL_MAP2_VERTEX_3);
    gluEndSurface(theNurb);
        
    glPopMatrix();
    glFlush();
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective (45.0, (GLdouble)w/(GLdouble)h, 3.0, 8.0);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    glTranslatef (0.0, 0.0, -5.0);
}

/*  Main Loop 
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB | AUX_DEPTH16);
    auxInitPosition (0, 0, 500, 500);
    auxInitWindow (argv[0]);
    myinit();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\stroke.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  stroke.c 
 *  This program demonstrates some characters of a 
 *  stroke (vector) font.  The characters are represented
 *  by display lists, which are given numbers which 
 *  correspond to the ASCII values of the characters.
 *  Use of glCallLists() is demonstrated.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

#define PT 1
#define STROKE 2
#define END 3

typedef struct charpoint {
    GLfloat   x, y;
    int    type;
} CP;

CP Adata[] = {
    { 0, 0, PT}, {0, 9, PT}, {1, 10, PT}, {4, 10, PT}, 
    {5, 9, PT}, {5, 0, STROKE}, {0, 5, PT}, {5, 5, END}
};

CP Edata[] = {
    {5, 0, PT}, {0, 0, PT}, {0, 10, PT}, {5, 10, STROKE},
    {0, 5, PT}, {4, 5, END}
};

CP Pdata[] = {
    {0, 0, PT}, {0, 10, PT},  {4, 10, PT}, {5, 9, PT}, {5, 6, PT}, 
    {4, 5, PT}, {0, 5, END}
};

CP Rdata[] = {
    {0, 0, PT}, {0, 10, PT},  {4, 10, PT}, {5, 9, PT}, {5, 6, PT}, 
    {4, 5, PT}, {0, 5, STROKE}, {3, 5, PT}, {5, 0, END}
};

CP Sdata[] = {
    {0, 1, PT}, {1, 0, PT}, {4, 0, PT}, {5, 1, PT}, {5, 4, PT}, 
    {4, 5, PT}, {1, 5, PT}, {0, 6, PT}, {0, 9, PT}, {1, 10, PT}, 
    {4, 10, PT}, {5, 9, END}
};

/*  drawLetter() interprets the instructions from the array
 *  for that letter and renders the letter with line segments.
 */
void drawLetter(CP *l)
{
    glBegin(GL_LINE_STRIP);
    while (1) {
	switch (l->type) {
	    case PT:
		glVertex2fv(&l->x);
		break;
	    case STROKE:
		glVertex2fv(&l->x);
		glEnd();
		glBegin(GL_LINE_STRIP);
		break;
	    case END:
		glVertex2fv(&l->x);
		glEnd();
		glTranslatef(8.0, 0.0, 0.0);
		return;
	}
	l++;
    }
}

/*  Create a display list for each of 6 characters	*/
void myinit (void)
{
    GLuint base;

    glShadeModel (GL_FLAT);

    base = glGenLists (128);
    glListBase(base);
    glNewList(base+'A', GL_COMPILE); drawLetter(Adata); glEndList();
    glNewList(base+'E', GL_COMPILE); drawLetter(Edata); glEndList();
    glNewList(base+'P', GL_COMPILE); drawLetter(Pdata); glEndList();
    glNewList(base+'R', GL_COMPILE); drawLetter(Rdata); glEndList();
    glNewList(base+'S', GL_COMPILE); drawLetter(Sdata); glEndList();
    glNewList(base+' ', GL_COMPILE); glTranslatef(8.0, 0.0, 0.0); glEndList();
}

char *test1 = "A SPARE SERAPE APPEARS AS";
char *test2 = "APES PREPARE RARE PEPPERS";

void printStrokedString(char *s)
{
    GLsizei len = strlen(s);
    glCallLists(len, GL_BYTE, (GLbyte *)s);
}

void display(void)
{
    glClear(GL_COLOR_BUFFER_BIT);
    glColor3f(1.0, 1.0, 1.0);
    glPushMatrix();
    glScalef(2.0, 2.0, 2.0);
    glTranslatef(10.0, 30.0, 0.0);
    printStrokedString(test1);
    glPopMatrix();
    glPushMatrix();
    glScalef(2.0, 2.0, 2.0);
    glTranslatef(10.0, 13.0, 0.0);
    printStrokedString(test2);
    glPopMatrix();
    glFlush();
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB);
    auxInitPosition (0, 0, 440, 120);
    auxInitWindow (argv[0]);
    myinit ();
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\tea.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  tea.c
 *  This program demonstrates two-sided lighting and compares
 *  it with one-sided lighting.  Three teapots are drawn, with
 *  a clipping plane to expose the interior of the objects.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

/*  Initialize light source.
 */
void myinit(void)
{
    GLfloat light_ambient[] = { 0.0, 0.0, 0.0, 1.0 };
    GLfloat light_diffuse[] = { 1.0, 1.0, 1.0, 1.0 };
    GLfloat light_specular[] = { 1.0, 1.0, 1.0, 1.0 };
/*	light_position is NOT default value	*/
    GLfloat light_position[] = { 1.0, 1.0, 1.0, 0.0 };

    glLightfv(GL_LIGHT0, GL_AMBIENT, light_ambient);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, light_diffuse);
    glLightfv(GL_LIGHT0, GL_SPECULAR, light_specular);
    glLightfv(GL_LIGHT0, GL_POSITION, light_position);
    
    glFrontFace (GL_CW);
    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);
    glEnable(GL_AUTO_NORMAL);
    glEnable(GL_NORMALIZE);
    glDepthFunc(GL_LESS);
    glEnable(GL_DEPTH_TEST);
}

void display(void)
{
    GLdouble eqn[4] = {1.0, 0.0, -1.0, 1.0};
    GLfloat two_side_on[] = { GL_TRUE };
    GLfloat two_side_off[] = { GL_FALSE };
    GLfloat mat_diffuse[] = { 0.8, 0.8, 0.8, 1.0 };
    GLfloat back_diffuse[] = { 0.8, 0.2, 0.8, 1.0 };

    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

    glPushMatrix ();
    glClipPlane (GL_CLIP_PLANE0, eqn);	/*  slice objects   */
    glEnable (GL_CLIP_PLANE0); 

    glPushMatrix ();
    glTranslatef (0.0, 2.0, 0.0);
    auxSolidTeapot(1.0);	/*  one-sided lighting	*/
    glPopMatrix ();

	/*  two-sided lighting, but same material	*/
    glLightModelf (GL_LIGHT_MODEL_TWO_SIDE, GL_TRUE);
    glMaterialfv (GL_FRONT_AND_BACK, GL_DIFFUSE, mat_diffuse);
    glPushMatrix ();
    glTranslatef (0.0, 0.0, 0.0);
    auxSolidTeapot(1.0);
    glPopMatrix ();

	/*  two-sided lighting, two different materials	*/
    glMaterialfv (GL_FRONT, GL_DIFFUSE, mat_diffuse);
    glMaterialfv (GL_BACK, GL_DIFFUSE, back_diffuse);
    glPushMatrix ();
    glTranslatef (0.0, -2.0, 0.0);
    auxSolidTeapot(1.0);
    glPopMatrix ();

    glLightModelf (GL_LIGHT_MODEL_TWO_SIDE, GL_FALSE);
    glDisable (GL_CLIP_PLANE0);
    glPopMatrix ();
    glFlush();
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (w <= h) 
	glOrtho (-4.0, 4.0, -4.0*(GLfloat)h/(GLfloat)w, 
	    4.0*(GLfloat)h/(GLfloat)w, -10.0, 10.0);
    else 
	glOrtho (-4.0*(GLfloat)w/(GLfloat)h, 
	    4.0*(GLfloat)w/(GLfloat)h, -4.0, 4.0, -10.0, 10.0);
    glMatrixMode(GL_MODELVIEW);
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB | AUX_DEPTH16);
    auxInitPosition (0, 0, 500, 500);
    auxInitWindow (argv[0]);
    myinit();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\surfgrid.c ===
/*
 * surfgrid.c - simple test of polygon offset
 *
 *  $Revision: 1.3 $
 *
 * usage:
 *	surfgrid [-f]
 *
 * options:
 *	-f	run on full screen
 *
 * keys:
 *	p	toggle polygon offset
 *	m	toggle multisampling
 *      S       increase polygon offset factor
 *      s       decrease polygon offset factor
 *      B       increase polygon offset bias
 *      b       decrease polygon offset bias
 *	g	toggle grid drawing
 *      t       toggle surface drawing
 *	f	toggle smooth/flat shading
 *	n	toggle whether to use GL evaluators or GLU nurbs
 *	u	decr number of segments in U direction
 *	U	incr number of segments in U direction
 *	v	decr number of segments in V direction
 *	V	incr number of segments in V direction
 *	escape	quit
 */
#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include <gl\gl.h>
#include <glaux.h>

#define W 600
#define H 600

static GLfloat controlpts[] =
{
    4.0f, 0.0f, 0.0f, 4.0f, 2.0f, 0.0f, 1.0f, 2.0f, 3.0f, 0.0f, 1.0f, 2.0f,
    3.0f, 0.0f, 1.0f, 2.0f, 4.0f, 0.0f, 1.0f, 2.0f, 8.0f, 0.0f, 0.0f, 4.0f,
    8.0f, 0.0f, 0.0f, 4.0f, 4.0f, 0.0f,-1.0f, 2.0f, 3.0f, 0.0f,-1.0f, 2.0f,
    3.0f, 0.0f,-1.0f, 2.0f, 2.0f, 0.0f,-1.0f, 2.0f, 4.0f, 0.0f, 0.0f, 4.0f,
    2.0f,-2.0f, 0.0f, 2.0f, 1.0f,-1.0f, 0.5f, 1.0f, 1.5f,-1.5f, 0.5f, 1.0f,
    1.5f,-1.5f, 0.5f, 1.0f, 2.0f,-2.0f, 0.5f, 1.0f, 4.0f,-4.0f, 0.0f, 2.0f,
    4.0f,-4.0f, 0.0f, 2.0f, 2.0f,-2.0f,-0.5f, 1.0f, 1.5f,-1.5f,-0.5f, 1.0f,
    1.5f,-1.5f,-0.5f, 1.0f, 1.0f,-1.0f,-0.5f, 1.0f, 2.0f,-2.0f, 0.0f, 2.0f,
    0.0f,-2.0f, 0.0f, 2.0f, 0.0f,-1.0f, 0.5f, 1.0f, 0.0f,-1.5f, 0.5f, 1.0f,
    0.0f,-1.5f, 0.5f, 1.0f, 0.0f,-2.0f, 0.5f, 1.0f, 0.0f,-4.0f, 0.0f, 2.0f,
    0.0f,-4.0f, 0.0f, 2.0f, 0.0f,-2.0f,-0.5f, 1.0f, 0.0f,-1.5f,-0.5f, 1.0f,
    0.0f,-1.5f,-0.5f, 1.0f, 0.0f,-1.0f,-0.5f, 1.0f, 0.0f,-2.0f, 0.0f, 2.0f,
    0.0f,-2.0f, 0.0f, 2.0f, 0.0f,-1.0f, 0.5f, 1.0f, 0.0f,-1.5f, 0.5f, 1.0f,
    0.0f,-1.5f, 0.5f, 1.0f, 0.0f,-2.0f, 0.5f, 1.0f, 0.0f,-4.0f, 0.0f, 2.0f,
    0.0f,-4.0f, 0.0f, 2.0f, 0.0f,-2.0f,-0.5f, 1.0f, 0.0f,-1.5f,-0.5f, 1.0f,
    0.0f,-1.5f,-0.5f, 1.0f, 0.0f,-1.0f,-0.5f, 1.0f, 0.0f,-2.0f, 0.0f, 2.0f,
   -2.0f,-2.0f, 0.0f, 2.0f,-1.0f,-1.0f, 0.5f, 1.0f,-1.5f,-1.5f, 0.5f, 1.0f,
   -1.5f,-1.5f, 0.5f, 1.0f,-2.0f,-2.0f, 0.5f, 1.0f,-4.0f,-4.0f, 0.0f, 2.0f,
   -4.0f,-4.0f, 0.0f, 2.0f,-2.0f,-2.0f,-0.5f, 1.0f,-1.5f,-1.5f,-0.5f, 1.0f,
   -1.5f,-1.5f,-0.5f, 1.0f,-1.0f,-1.0f,-0.5f, 1.0f,-2.0f,-2.0f, 0.0f, 2.0f,
   -4.0f, 0.0f, 0.0f, 4.0f,-2.0f, 0.0f, 1.0f, 2.0f,-3.0f, 0.0f, 1.0f, 2.0f,
   -3.0f, 0.0f, 1.0f, 2.0f,-4.0f, 0.0f, 1.0f, 2.0f,-8.0f, 0.0f, 0.0f, 4.0f,
   -8.0f, 0.0f, 0.0f, 4.0f,-4.0f, 0.0f,-1.0f, 2.0f,-3.0f, 0.0f,-1.0f, 2.0f,
   -3.0f, 0.0f,-1.0f, 2.0f,-2.0f, 0.0f,-1.0f, 2.0f,-4.0f, 0.0f, 0.0f, 4.0f,
   -4.0f, 0.0f, 0.0f, 4.0f,-2.0f, 0.0f, 1.0f, 2.0f,-3.0f, 0.0f, 1.0f, 2.0f,
   -3.0f, 0.0f, 1.0f, 2.0f,-4.0f, 0.0f, 1.0f, 2.0f,-8.0f, 0.0f, 0.0f, 4.0f,
   -8.0f, 0.0f, 0.0f, 4.0f,-4.0f, 0.0f,-1.0f, 2.0f,-3.0f, 0.0f,-1.0f, 2.0f,
   -3.0f, 0.0f,-1.0f, 2.0f,-2.0f, 0.0f,-1.0f, 2.0f,-4.0f, 0.0f, 0.0f, 4.0f,
   -2.0f, 2.0f, 0.0f, 2.0f,-1.0f, 1.0f, 0.5f, 1.0f,-1.5f, 1.5f, 0.5f, 1.0f,
   -1.5f, 1.5f, 0.5f, 1.0f,-2.0f, 2.0f, 0.5f, 1.0f,-4.0f, 4.0f, 0.0f, 2.0f,
   -4.0f, 4.0f, 0.0f, 2.0f,-2.0f, 2.0f,-0.5f, 1.0f,-1.5f, 1.5f,-0.5f, 1.0f,
   -1.5f, 1.5f,-0.5f, 1.0f,-1.0f, 1.0f,-0.5f, 1.0f,-2.0f, 2.0f, 0.0f, 2.0f,
    0.0f, 2.0f, 0.0f, 2.0f, 0.0f, 1.0f, 0.5f, 1.0f, 0.0f, 1.5f, 0.5f, 1.0f,
    0.0f, 1.5f, 0.5f, 1.0f, 0.0f, 2.0f, 0.5f, 1.0f, 0.0f, 4.0f, 0.0f, 2.0f,
    0.0f, 4.0f, 0.0f, 2.0f, 0.0f, 2.0f,-0.5f, 1.0f, 0.0f, 1.5f,-0.5f, 1.0f,
    0.0f, 1.5f,-0.5f, 1.0f, 0.0f, 1.0f,-0.5f, 1.0f, 0.0f, 2.0f, 0.0f, 2.0f,
    0.0f, 2.0f, 0.0f, 2.0f, 0.0f, 1.0f, 0.5f, 1.0f, 0.0f, 1.5f, 0.5f, 1.0f,
    0.0f, 1.5f, 0.5f, 1.0f, 0.0f, 2.0f, 0.5f, 1.0f, 0.0f, 4.0f, 0.0f, 2.0f,
    0.0f, 4.0f, 0.0f, 2.0f, 0.0f, 2.0f,-0.5f, 1.0f, 0.0f, 1.5f,-0.5f, 1.0f,
    0.0f, 1.5f,-0.5f, 1.0f, 0.0f, 1.0f,-0.5f, 1.0f, 0.0f, 2.0f, 0.0f, 2.0f,
    2.0f, 2.0f, 0.0f, 2.0f, 1.0f, 1.0f, 0.5f, 1.0f, 1.5f, 1.5f, 0.5f, 1.0f,
    1.5f, 1.5f, 0.5f, 1.0f, 2.0f, 2.0f, 0.5f, 1.0f, 4.0f, 4.0f, 0.0f, 2.0f,
    4.0f, 4.0f, 0.0f, 2.0f, 2.0f, 2.0f,-0.5f, 1.0f, 1.5f, 1.5f,-0.5f, 1.0f,
    1.5f, 1.5f,-0.5f, 1.0f, 1.0f, 1.0f,-0.5f, 1.0f, 2.0f, 2.0f, 0.0f, 2.0f,
    4.0f, 0.0f, 0.0f, 4.0f, 2.0f, 0.0f, 1.0f, 2.0f, 3.0f, 0.0f, 1.0f, 2.0f,
    3.0f, 0.0f, 1.0f, 2.0f, 4.0f, 0.0f, 1.0f, 2.0f, 8.0f, 0.0f, 0.0f, 4.0f,
    8.0f, 0.0f, 0.0f, 4.0f, 4.0f, 0.0f,-1.0f, 2.0f, 3.0f, 0.0f,-1.0f, 2.0f,
    3.0f, 0.0f,-1.0f, 2.0f, 2.0f, 0.0f,-1.0f, 2.0f, 4.0f, 0.0f, 0.0f, 4.0f,
};

static GLfloat nurbctlpts[] = {
    4.0f, 0.0f, 0.0f, 4.0f, 2.0f, 0.0f, 1.0f, 2.0f, 4.0f, 0.0f, 1.0f, 2.0f,
    8.0f, 0.0f, 0.0f, 4.0f, 4.0f, 0.0f,-1.0f, 2.0f, 2.0f, 0.0f,-1.0f, 2.0f,
    4.0f, 0.0f, 0.0f, 4.0f, 2.0f,-2.0f, 0.0f, 2.0f, 1.0f,-1.0f, 0.5f, 1.0f,
    2.0f,-2.0f, 0.5f, 1.0f, 4.0f,-4.0f, 0.0f, 2.0f, 2.0f,-2.0f,-0.5f, 1.0f,
    1.0f,-1.0f,-0.5f, 1.0f, 2.0f,-2.0f, 0.0f, 2.0f,-2.0f,-2.0f, 0.0f, 2.0f,
   -1.0f,-1.0f, 0.5f, 1.0f,-2.0f,-2.0f, 0.5f, 1.0f,-4.0f,-4.0f, 0.0f, 2.0f,
   -2.0f,-2.0f,-0.5f, 1.0f,-1.0f,-1.0f,-0.5f, 1.0f,-2.0f,-2.0f, 0.0f, 2.0f,
   -4.0f, 0.0f, 0.0f, 4.0f,-2.0f, 0.0f, 1.0f, 2.0f,-4.0f, 0.0f, 1.0f, 2.0f,
   -8.0f, 0.0f, 0.0f, 4.0f,-4.0f, 0.0f,-1.0f, 2.0f,-2.0f, 0.0f,-1.0f, 2.0f,
   -4.0f, 0.0f, 0.0f, 4.0f,-2.0f, 2.0f, 0.0f, 2.0f,-1.0f, 1.0f, 0.5f, 1.0f,
   -2.0f, 2.0f, 0.5f, 1.0f,-4.0f, 4.0f, 0.0f, 2.0f,-2.0f, 2.0f,-0.5f, 1.0f,
   -1.0f, 1.0f,-0.5f, 1.0f,-2.0f, 2.0f, 0.0f, 2.0f, 2.0f, 2.0f, 0.0f, 2.0f,
    1.0f, 1.0f, 0.5f, 1.0f, 2.0f, 2.0f, 0.5f, 1.0f, 4.0f, 4.0f, 0.0f, 2.0f,
    2.0f, 2.0f,-0.5f, 1.0f, 1.0f, 1.0f,-0.5f, 1.0f, 2.0f, 2.0f, 0.0f, 2.0f,
    4.0f, 0.0f, 0.0f, 4.0f, 2.0f, 0.0f, 1.0f, 2.0f, 4.0f, 0.0f, 1.0f, 2.0f,
    8.0f, 0.0f, 0.0f, 4.0f, 4.0f, 0.0f,-1.0f, 2.0f, 2.0f, 0.0f,-1.0f, 2.0f,
    4.0f, 0.0f, 0.0f, 4.0f,
};

/*
 * Misc vector op routines.
 */

float x_axis[] = { 1.0f, 0.0f, 0.0f };
float y_axis[] = { 0.0f, 1.0f, 0.0f };
float z_axis[] = { 0.0f, 0.0f, 1.0f };
float nx_axis[] = { -1.0f, 0.0f, 0.0f };
float ny_axis[] = { 0.0f, -1.0f, 0.0f };
float nz_axis[] = { 0.0f, 0.0f, -1.0f };

void norm(float v[3])
{
    float r;

    r = (float)sqrt( v[0]*v[0] + v[1]*v[1] + v[2]*v[2] );

    v[0] /= r;
    v[1] /= r;
    v[2] /= r;
}

float dot(float a[3], float b[3])
{
    return (a[0]*b[0] + a[1]*b[1] + a[2]*b[2]);
}

void cross(float v1[3], float v2[3], float result[3])
{
    result[0] = v1[1]*v2[2] - v1[2]*v2[1];
    result[1] = v1[2]*v2[0] - v1[0]*v2[2];
    result[2] = v1[0]*v2[1] - v1[1]*v2[0];
}

float length(float v[3])
{
    float r = (float)sqrt( v[0]*v[0] + v[1]*v[1] + v[2]*v[2] );
    return r;
}

static long winwidth = W, winheight = H;
GLUnurbsObj *nobj;
GLuint surflist, gridlist;

int useglunurbs = 0;
int smooth = 1;
int tracking = 0;
int showgrid = 1;
int showsurf = 1;
int fullscreen = 0;
int multisampling = 0;
float modelmatrix[16];
float scale = 0.5f;
float bias = 0.002f;
int usegments = 4;
int vsegments = 4;

int spindx, spindy;
int startx, starty;
int curx, cury;

void redraw(void);
void createlists(void);

float torusnurbpts[];
float torusbezierpts[];

void key_n(void)
{
    useglunurbs = !useglunurbs;
}
   
void key_p(void)
{
#ifdef GL_POLYGON_OFFSET_EXT
    if (glIsEnabled( GL_POLYGON_OFFSET_EXT ))
    {
        glDisable( GL_POLYGON_OFFSET_EXT );
        printf("disabling polygon offset\n");
    }
    else
    {
        glEnable( GL_POLYGON_OFFSET_EXT );
        printf("enabling polygon offset\n");
    }
#endif
}
        
void key_m(void)
{
#ifdef GL_MULTISAMPLE_SGIS
    if (multisampling)
    {
        if (glIsEnabled( GL_MULTISAMPLE_SGIS ))
        {
            glDisable( GL_MULTISAMPLE_SGIS );
        }
        else
        {
            glEnable( GL_MULTISAMPLE_SGIS );
        }
    }
#endif
}
        
void key_g(void)
{
    showgrid = !showgrid;
}
        
void key_t(void)
{
    showsurf = !showsurf;
}
        
void key_f(void)
{
    smooth = !smooth;
    if (smooth)
    {
        glShadeModel( GL_SMOOTH );
    }
    else
    {
        glShadeModel( GL_FLAT );
    }
}
        
void key_S(void)
{
    scale += 0.1f;
    printf( "scale: %8.4f\n", scale);
}
        
void key_s(void)
{
    scale -= 0.1f;
    printf( "scale: %8.4f\n", scale);
}
        
void key_B(void)
{
    bias += 0.0001f;
    printf( "bias:  %8.4f\n", bias);
}
        
void key_b(void)
{
    bias -= 0.0001f;
    printf( "bias:  %8.4f\n", bias);
}
        
void key_u(void)
{
    usegments = (usegments < 2 ? 1 : usegments-1);
    createlists();
}
        
void key_U(void)
{
    usegments++;
    createlists();
}
        
void key_v(void)
{
    vsegments = (vsegments < 2 ? 1 : vsegments-1);
    createlists();
}
        
void key_V(void)
{
    vsegments++;
    createlists();
}

void reshape_proc(GLsizei w, GLsizei h)
{
    int size;
    
    winwidth = w;
    winheight = h;
    size = (winwidth < winheight ? winwidth : winheight);
    glViewport((winwidth-size)/2, (winheight-size)/2, size, size);
}

void mouse_ldown(AUX_EVENTREC *mouse)
{
    curx = startx = mouse->data[AUX_MOUSEX];
    cury = starty = mouse->data[AUX_MOUSEY];
    spindx = 0;
    spindy = 0;
    tracking = 1;
}

void mouse_lup(AUX_EVENTREC *mouse)
{
    /*
     * If user released the button while moving the mouse, keep
     * spinning.
     */
    if (mouse->data[AUX_MOUSEX] != curx || mouse->data[AUX_MOUSEY] != cury)
    {
        spindx = mouse->data[AUX_MOUSEX] - curx;
        spindy = mouse->data[AUX_MOUSEY] - cury;
    }
    tracking = 0;
}

void mouse_lloc(AUX_EVENTREC *mouse)
{
    if (!tracking)
    {
        return;
    }
        
    curx = mouse->data[AUX_MOUSEX];
    cury = mouse->data[AUX_MOUSEY];
    if (curx != startx || cury != starty)
    {
        redraw();
        startx = curx;
        starty = cury;
    }
}

void idle_proc(void)
{
    if (!tracking && (spindx != 0 || spindy != 0))
    {
        redraw();
    }
}

void gridmaterials(void)
{
    static float front_mat_diffuse[] = { 1.0f, 1.0f, 0.4f, 1.0f };
    static float front_mat_ambient[] = { 0.1f, 0.1f, 0.1f, 1.0f };
    static float back_mat_diffuse[] = { 1.0f, 0.0f, 0.0f, 1.0f };
    static float back_mat_ambient[] = { 0.1f, 0.1f, 0.1f, 1.0f };

    glMaterialfv(GL_FRONT, GL_DIFFUSE, front_mat_diffuse);
    glMaterialfv(GL_FRONT, GL_AMBIENT, front_mat_ambient);
    glMaterialfv(GL_BACK, GL_DIFFUSE, back_mat_diffuse);
    glMaterialfv(GL_BACK, GL_AMBIENT, back_mat_ambient);
}

void surfacematerials(void)
{
    static float front_mat_diffuse[] = { 0.2f, 0.7f, 0.4f, 1.0f };
    static float front_mat_ambient[] = { 0.1f, 0.1f, 0.1f, 1.0f };
    static float back_mat_diffuse[] = { 1.0f, 1.0f, 0.2f, 1.0f };
    static float back_mat_ambient[] = { 0.1f, 0.1f, 0.1f, 1.0f };

    glMaterialfv(GL_FRONT, GL_DIFFUSE, front_mat_diffuse);
    glMaterialfv(GL_FRONT, GL_AMBIENT, front_mat_ambient);
    glMaterialfv(GL_BACK, GL_DIFFUSE, back_mat_diffuse);
    glMaterialfv(GL_BACK, GL_AMBIENT, back_mat_ambient);
}

void init(void)
{
    static float ambient[] = { 0.0f, 0.0f, 0.0f, 1.0f };
    static float diffuse[] = { 1.0f, 1.0f, 1.0f, 1.0f };
    static float position[] = { 90.0f, 90.0f, -150.0f, 0.0f };
    static float lmodel_ambient[] = { 1.0f, 1.0f, 1.0f, 1.0f };
    static float lmodel_twoside[] = { (float)GL_TRUE };

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective( 40.0, 1.0, 2.0, 200.0 );
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    glGetFloatv(GL_MODELVIEW_MATRIX, modelmatrix);

    glLightfv(GL_LIGHT0, GL_AMBIENT, ambient);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuse);
    glLightfv(GL_LIGHT0, GL_POSITION, position);
    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_ambient);

    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);
    glEnable(GL_DEPTH_TEST);
    glEnable(GL_AUTO_NORMAL);
#ifdef GL_POLYGON_OFFSET_EXT
    glEnable(GL_POLYGON_OFFSET_EXT);
#endif
    glFrontFace(GL_CCW);

    glEnable( GL_MAP2_VERTEX_4 );
    glClearColor(0.25f, 0.25f, 0.5f, 0.0f);

#ifdef GL_POLYGON_OFFSET_EXT
    glPolygonOffsetEXT( scale, bias );
#endif

    nobj = gluNewNurbsRenderer();
    gluNurbsProperty(nobj, GLU_SAMPLING_METHOD, (float)GLU_DOMAIN_DISTANCE );

    surflist = glGenLists(1);
    gridlist = glGenLists(1);
    createlists();
}

void drawmesh(void)
{
    int i, j;
    float *p;

    int up2p = 4;
    int uorder = 3, vorder = 3;
    int nu = 4, nv = 4;
    int vp2p = up2p * uorder * nu;

    for (j=0; j < nv; j++) {
	for (i=0; i < nu; i++) {
	    p = torusbezierpts + (j * vp2p * vorder) + (i * up2p * uorder);
#ifdef GL_POLYGON_OFFSET_EXT
	    glPolygonOffsetEXT( scale, bias );
#endif
	    glMap2f( GL_MAP2_VERTEX_4, 0.0f, 1.0f, up2p, 3, 0.0f, 1.0f, vp2p, 3,
		     (void*)p );
	    if (showsurf) {
		surfacematerials();
		glEvalMesh2( GL_FILL, 0, usegments, 0, vsegments );
	    }
	    if (showgrid) {
                gridmaterials();
	        glEvalMesh2( GL_LINE, 0, usegments, 0, vsegments );
            }
	}
    }
}

void redraw(void)
{
    static int i=0;
    int dx, dy;
    float v[3], rot[3];
    float len, ang;
    static GLuint vcount;

    glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
    glColor3f( 1.0f, 0.0f, 0.0f);

    if (tracking) {
	dx = curx - startx;
	dy = cury - starty;
    } else {
	dx = spindx;
	dy = spindy;
    }
    if (dx || dy) {
	dy = -dy;
	v[0] = (float)dx;
	v[1] = (float)dy;
	v[2] = 0.0f;

	len = length(v);
	ang = -len / 600 * 360;
	norm( v );
	cross( v, z_axis, rot );

	/*
	** This is certainly not recommended for programs that care
	** about performance or numerical stability: we concatenate
	** the rotation onto the current modelview matrix and read the
	** matrix back, thus saving ourselves from writing our own
	** matrix manipulation routines.
	*/
	glLoadIdentity();
	glRotatef(ang, rot[0], rot[1], rot[2]);
	glMultMatrixf(modelmatrix);
	glGetFloatv(GL_MODELVIEW_MATRIX, modelmatrix);
    }
    glLoadIdentity();
    glTranslatef( 0.0f, 0.0f, -10.0f );
    glMultMatrixf(modelmatrix);

    if (useglunurbs) {
	if (showsurf) glCallList(surflist);
	if (showgrid) glCallList(gridlist);
    } else {
	glMapGrid2f( usegments, 0.0f, 1.0f, vsegments, 0.0f, 1.0f );
	drawmesh();
    }

    auxSwapBuffers();
}

static void usage(void)
{
    printf("usage: surfgrid [-f]\n");
    exit(-1);
}

/*
 *  pass the name of the desired extension.
 *  this will return 1 if the extension is supported, 0 otherwise.
 */
int
getextension(char *e)
{
const GLubyte *s;

    s = glGetString(GL_EXTENSIONS);
    if (!s)
	return 0;
    if (*s == '\0')
	 return 0;
    return (strstr(s,e) == 0) ? 0 : 1;
}

int __cdecl main(int argc, char **argv)
{
    int i;

    for (i=1; i<argc; i++) {
	if (argv[i][0] == '-') {
	    switch (argv[i][1]) {
	      case 'f':
		fullscreen = 1;
		break;
	      default:
		usage();
		break;
	    }
	} else {
	    usage();
	}
    }

#ifdef GL_POLYGON_OFFSET_EXT
    if (!getextension("GL_EXT_polygon_offset"))
    {
	printf("Warning: GL_EXT_polygon_offset not supported on this "
               "machine.. trying anyway\n");
    }
#endif

    auxInitPosition(50, 50, winwidth, winheight);
    auxInitDisplayMode(AUX_RGB | AUX_DOUBLE | AUX_DEPTH16);
    auxInitWindow("SurfGrid");

    auxReshapeFunc(reshape_proc);
    auxIdleFunc(idle_proc);
    auxKeyFunc(AUX_n, key_n);
    auxKeyFunc(AUX_p, key_p);
    auxKeyFunc(AUX_m, key_m);
    auxKeyFunc(AUX_g, key_g);
    auxKeyFunc(AUX_t, key_t);
    auxKeyFunc(AUX_f, key_f);
    auxKeyFunc(AUX_S, key_S);
    auxKeyFunc(AUX_s, key_s);
    auxKeyFunc(AUX_B, key_B);
    auxKeyFunc(AUX_b, key_b);
    auxKeyFunc(AUX_u, key_u);
    auxKeyFunc(AUX_U, key_U);
    auxKeyFunc(AUX_v, key_v);
    auxKeyFunc(AUX_V, key_V);
    auxMouseFunc(AUX_LEFTBUTTON, AUX_MOUSEDOWN, mouse_ldown);
    auxMouseFunc(AUX_LEFTBUTTON, AUX_MOUSEUP, mouse_lup);
    auxMouseFunc(AUX_LEFTBUTTON, AUX_MOUSELOC, mouse_lloc);

    init();
    
    auxMainLoop(redraw);
    
    return 0;
}

/****************************************************************************/

float circleknots[] = { 0.0f, 0.0f, 0.0f, 0.25f, 0.50f, 0.50f, 0.75f, 1.0f,
1.0f, 1.0f };

void createlists(void)
{
    gluNurbsProperty(nobj, GLU_U_STEP, (usegments-1)*4.0f );
    gluNurbsProperty(nobj, GLU_V_STEP, (vsegments-1)*4.0f );

    gluNurbsProperty(nobj, GLU_DISPLAY_MODE, (float)GLU_FILL);
    glNewList(surflist, GL_COMPILE);
    	surfacematerials();
    	gluBeginSurface(nobj);
    	gluNurbsSurface(nobj, 10, circleknots, 10, circleknots,
		    	4, 28, torusnurbpts, 3, 3, GL_MAP2_VERTEX_4);
    	gluEndSurface(nobj);
    glEndList();

    gluNurbsProperty(nobj, GLU_DISPLAY_MODE, (float)GLU_OUTLINE_POLYGON);
    glNewList(gridlist, GL_COMPILE);
    	gridmaterials();
    	gluBeginSurface(nobj);
    	gluNurbsSurface(nobj, 10, circleknots, 10, circleknots,
		    	4, 28, torusnurbpts, 3, 3, GL_MAP2_VERTEX_4);
    	gluEndSurface(nobj);
    glEndList();
}

/****************************************************************************/

/*
 * Control points of the torus in Bezier form.  Can be rendered
 * using OpenGL evaluators.
 */
static GLfloat torusbezierpts[] = {
    4.0f, 0.0f, 0.0f, 4.0f, 2.0f, 0.0f, 1.0f, 2.0f, 3.0f, 0.0f, 1.0f, 2.0f,
    3.0f, 0.0f, 1.0f, 2.0f, 4.0f, 0.0f, 1.0f, 2.0f, 8.0f, 0.0f, 0.0f, 4.0f,
    8.0f, 0.0f, 0.0f, 4.0f, 4.0f, 0.0f,-1.0f, 2.0f, 3.0f, 0.0f,-1.0f, 2.0f,
    3.0f, 0.0f,-1.0f, 2.0f, 2.0f, 0.0f,-1.0f, 2.0f, 4.0f, 0.0f, 0.0f, 4.0f,
    2.0f,-2.0f, 0.0f, 2.0f, 1.0f,-1.0f, 0.5f, 1.0f, 1.5f,-1.5f, 0.5f, 1.0f,
    1.5f,-1.5f, 0.5f, 1.0f, 2.0f,-2.0f, 0.5f, 1.0f, 4.0f,-4.0f, 0.0f, 2.0f,
    4.0f,-4.0f, 0.0f, 2.0f, 2.0f,-2.0f,-0.5f, 1.0f, 1.5f,-1.5f,-0.5f, 1.0f,
    1.5f,-1.5f,-0.5f, 1.0f, 1.0f,-1.0f,-0.5f, 1.0f, 2.0f,-2.0f, 0.0f, 2.0f,
    0.0f,-2.0f, 0.0f, 2.0f, 0.0f,-1.0f, 0.5f, 1.0f, 0.0f,-1.5f, 0.5f, 1.0f,
    0.0f,-1.5f, 0.5f, 1.0f, 0.0f,-2.0f, 0.5f, 1.0f, 0.0f,-4.0f, 0.0f, 2.0f,
    0.0f,-4.0f, 0.0f, 2.0f, 0.0f,-2.0f,-0.5f, 1.0f, 0.0f,-1.5f,-0.5f, 1.0f,
    0.0f,-1.5f,-0.5f, 1.0f, 0.0f,-1.0f,-0.5f, 1.0f, 0.0f,-2.0f, 0.0f, 2.0f,
    0.0f,-2.0f, 0.0f, 2.0f, 0.0f,-1.0f, 0.5f, 1.0f, 0.0f,-1.5f, 0.5f, 1.0f,
    0.0f,-1.5f, 0.5f, 1.0f, 0.0f,-2.0f, 0.5f, 1.0f, 0.0f,-4.0f, 0.0f, 2.0f,
    0.0f,-4.0f, 0.0f, 2.0f, 0.0f,-2.0f,-0.5f, 1.0f, 0.0f,-1.5f,-0.5f, 1.0f,
    0.0f,-1.5f,-0.5f, 1.0f, 0.0f,-1.0f,-0.5f, 1.0f, 0.0f,-2.0f, 0.0f, 2.0f,
   -2.0f,-2.0f, 0.0f, 2.0f,-1.0f,-1.0f, 0.5f, 1.0f,-1.5f,-1.5f, 0.5f, 1.0f,
   -1.5f,-1.5f, 0.5f, 1.0f,-2.0f,-2.0f, 0.5f, 1.0f,-4.0f,-4.0f, 0.0f, 2.0f,
   -4.0f,-4.0f, 0.0f, 2.0f,-2.0f,-2.0f,-0.5f, 1.0f,-1.5f,-1.5f,-0.5f, 1.0f,
   -1.5f,-1.5f,-0.5f, 1.0f,-1.0f,-1.0f,-0.5f, 1.0f,-2.0f,-2.0f, 0.0f, 2.0f,
   -4.0f, 0.0f, 0.0f, 4.0f,-2.0f, 0.0f, 1.0f, 2.0f,-3.0f, 0.0f, 1.0f, 2.0f,
   -3.0f, 0.0f, 1.0f, 2.0f,-4.0f, 0.0f, 1.0f, 2.0f,-8.0f, 0.0f, 0.0f, 4.0f,
   -8.0f, 0.0f, 0.0f, 4.0f,-4.0f, 0.0f,-1.0f, 2.0f,-3.0f, 0.0f,-1.0f, 2.0f,
   -3.0f, 0.0f,-1.0f, 2.0f,-2.0f, 0.0f,-1.0f, 2.0f,-4.0f, 0.0f, 0.0f, 4.0f,
   -4.0f, 0.0f, 0.0f, 4.0f,-2.0f, 0.0f, 1.0f, 2.0f,-3.0f, 0.0f, 1.0f, 2.0f,
   -3.0f, 0.0f, 1.0f, 2.0f,-4.0f, 0.0f, 1.0f, 2.0f,-8.0f, 0.0f, 0.0f, 4.0f,
   -8.0f, 0.0f, 0.0f, 4.0f,-4.0f, 0.0f,-1.0f, 2.0f,-3.0f, 0.0f,-1.0f, 2.0f,
   -3.0f, 0.0f,-1.0f, 2.0f,-2.0f, 0.0f,-1.0f, 2.0f,-4.0f, 0.0f, 0.0f, 4.0f,
   -2.0f, 2.0f, 0.0f, 2.0f,-1.0f, 1.0f, 0.5f, 1.0f,-1.5f, 1.5f, 0.5f, 1.0f,
   -1.5f, 1.5f, 0.5f, 1.0f,-2.0f, 2.0f, 0.5f, 1.0f,-4.0f, 4.0f, 0.0f, 2.0f,
   -4.0f, 4.0f, 0.0f, 2.0f,-2.0f, 2.0f,-0.5f, 1.0f,-1.5f, 1.5f,-0.5f, 1.0f,
   -1.5f, 1.5f,-0.5f, 1.0f,-1.0f, 1.0f,-0.5f, 1.0f,-2.0f, 2.0f, 0.0f, 2.0f,
    0.0f, 2.0f, 0.0f, 2.0f, 0.0f, 1.0f, 0.5f, 1.0f, 0.0f, 1.5f, 0.5f, 1.0f,
    0.0f, 1.5f, 0.5f, 1.0f, 0.0f, 2.0f, 0.5f, 1.0f, 0.0f, 4.0f, 0.0f, 2.0f,
    0.0f, 4.0f, 0.0f, 2.0f, 0.0f, 2.0f,-0.5f, 1.0f, 0.0f, 1.5f,-0.5f, 1.0f,
    0.0f, 1.5f,-0.5f, 1.0f, 0.0f, 1.0f,-0.5f, 1.0f, 0.0f, 2.0f, 0.0f, 2.0f,
    0.0f, 2.0f, 0.0f, 2.0f, 0.0f, 1.0f, 0.5f, 1.0f, 0.0f, 1.5f, 0.5f, 1.0f,
    0.0f, 1.5f, 0.5f, 1.0f, 0.0f, 2.0f, 0.5f, 1.0f, 0.0f, 4.0f, 0.0f, 2.0f,
    0.0f, 4.0f, 0.0f, 2.0f, 0.0f, 2.0f,-0.5f, 1.0f, 0.0f, 1.5f,-0.5f, 1.0f,
    0.0f, 1.5f,-0.5f, 1.0f, 0.0f, 1.0f,-0.5f, 1.0f, 0.0f, 2.0f, 0.0f, 2.0f,
    2.0f, 2.0f, 0.0f, 2.0f, 1.0f, 1.0f, 0.5f, 1.0f, 1.5f, 1.5f, 0.5f, 1.0f,
    1.5f, 1.5f, 0.5f, 1.0f, 2.0f, 2.0f, 0.5f, 1.0f, 4.0f, 4.0f, 0.0f, 2.0f,
    4.0f, 4.0f, 0.0f, 2.0f, 2.0f, 2.0f,-0.5f, 1.0f, 1.5f, 1.5f,-0.5f, 1.0f,
    1.5f, 1.5f,-0.5f, 1.0f, 1.0f, 1.0f,-0.5f, 1.0f, 2.0f, 2.0f, 0.0f, 2.0f,
    4.0f, 0.0f, 0.0f, 4.0f, 2.0f, 0.0f, 1.0f, 2.0f, 3.0f, 0.0f, 1.0f, 2.0f,
    3.0f, 0.0f, 1.0f, 2.0f, 4.0f, 0.0f, 1.0f, 2.0f, 8.0f, 0.0f, 0.0f, 4.0f,
    8.0f, 0.0f, 0.0f, 4.0f, 4.0f, 0.0f,-1.0f, 2.0f, 3.0f, 0.0f,-1.0f, 2.0f,
    3.0f, 0.0f,-1.0f, 2.0f, 2.0f, 0.0f,-1.0f, 2.0f, 4.0f, 0.0f, 0.0f, 4.0f,
};

/*
 * Control points of a torus in NURBS form.  Can be rendered using
 * the GLU NURBS routines.
 */
static GLfloat torusnurbpts[] = {
    4.0f, 0.0f, 0.0f, 4.0f, 2.0f, 0.0f, 1.0f, 2.0f, 4.0f, 0.0f, 1.0f, 2.0f,
    8.0f, 0.0f, 0.0f, 4.0f, 4.0f, 0.0f,-1.0f, 2.0f, 2.0f, 0.0f,-1.0f, 2.0f,
    4.0f, 0.0f, 0.0f, 4.0f, 2.0f,-2.0f, 0.0f, 2.0f, 1.0f,-1.0f, 0.5f, 1.0f,
    2.0f,-2.0f, 0.5f, 1.0f, 4.0f,-4.0f, 0.0f, 2.0f, 2.0f,-2.0f,-0.5f, 1.0f,
    1.0f,-1.0f,-0.5f, 1.0f, 2.0f,-2.0f, 0.0f, 2.0f,-2.0f,-2.0f, 0.0f, 2.0f,
   -1.0f,-1.0f, 0.5f, 1.0f,-2.0f,-2.0f, 0.5f, 1.0f,-4.0f,-4.0f, 0.0f, 2.0f,
   -2.0f,-2.0f,-0.5f, 1.0f,-1.0f,-1.0f,-0.5f, 1.0f,-2.0f,-2.0f, 0.0f, 2.0f,
   -4.0f, 0.0f, 0.0f, 4.0f,-2.0f, 0.0f, 1.0f, 2.0f,-4.0f, 0.0f, 1.0f, 2.0f,
   -8.0f, 0.0f, 0.0f, 4.0f,-4.0f, 0.0f,-1.0f, 2.0f,-2.0f, 0.0f,-1.0f, 2.0f,
   -4.0f, 0.0f, 0.0f, 4.0f,-2.0f, 2.0f, 0.0f, 2.0f,-1.0f, 1.0f, 0.5f, 1.0f,
   -2.0f, 2.0f, 0.5f, 1.0f,-4.0f, 4.0f, 0.0f, 2.0f,-2.0f, 2.0f,-0.5f, 1.0f,
   -1.0f, 1.0f,-0.5f, 1.0f,-2.0f, 2.0f, 0.0f, 2.0f, 2.0f, 2.0f, 0.0f, 2.0f,
    1.0f, 1.0f, 0.5f, 1.0f, 2.0f, 2.0f, 0.5f, 1.0f, 4.0f, 4.0f, 0.0f, 2.0f,
    2.0f, 2.0f,-0.5f, 1.0f, 1.0f, 1.0f,-0.5f, 1.0f, 2.0f, 2.0f, 0.0f, 2.0f,
    4.0f, 0.0f, 0.0f, 4.0f, 2.0f, 0.0f, 1.0f, 2.0f, 4.0f, 0.0f, 1.0f, 2.0f,
    8.0f, 0.0f, 0.0f, 4.0f, 4.0f, 0.0f,-1.0f, 2.0f, 2.0f, 0.0f,-1.0f, 2.0f,
    4.0f, 0.0f, 0.0f, 4.0f,
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\teapots.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  teapots.c
 *  This program demonstrates lots of material properties.
 *  A single light source illuminates the objects.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

/*  Initialize depth buffer, projection matrix, light source, 
 *  and lighting model.  Do not specify a material property here.
 */
void myinit(void)
{
    GLfloat ambient[] = { 0.0, 0.0, 0.0, 1.0 };
    GLfloat diffuse[] = { 1.0, 1.0, 1.0, 1.0 };
    GLfloat specular[] = { 1.0, 1.0, 1.0, 1.0 };
    GLfloat position[] = { 0.0, 3.0, 3.0, 0.0 };
    
    GLfloat lmodel_ambient[] = { 0.2, 0.2, 0.2, 1.0 };
    GLfloat local_view[] = { 0.0 };

    glLightfv(GL_LIGHT0, GL_AMBIENT, ambient);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuse);
    glLightfv(GL_LIGHT0, GL_POSITION, position);
    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_ambient);
    glLightModelfv(GL_LIGHT_MODEL_LOCAL_VIEWER, local_view);

    glFrontFace (GL_CW);
    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);
    glEnable(GL_AUTO_NORMAL);
    glEnable(GL_NORMALIZE);
    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LESS);
}

/*  Move object into position.  Use 3rd through 12th parameters
 *  to specify the material property.  Draw a teapot.
 */
void renderTeapot (GLfloat x, GLfloat y, 
    GLfloat ambr, GLfloat ambg, GLfloat ambb, 
    GLfloat difr, GLfloat difg, GLfloat difb, 
    GLfloat specr, GLfloat specg, GLfloat specb, GLfloat shine)
{
    float mat[3];

    glPushMatrix();
    glTranslatef (x, y, 0.0);
    mat[0] = ambr; mat[1] = ambg; mat[2] = ambb;	
    glMaterialfv (GL_FRONT, GL_AMBIENT, mat);
    mat[0] = difr; mat[1] = difg; mat[2] = difb;	
    glMaterialfv (GL_FRONT, GL_DIFFUSE, mat);
    mat[0] = specr; mat[1] = specg; mat[2] = specb;
    glMaterialfv (GL_FRONT, GL_SPECULAR, mat);
    glMaterialf (GL_FRONT, GL_SHININESS, shine*128.0);
    auxSolidTeapot(1.0);
    glPopMatrix();
}

/*  First column:  emerald, jade, obsidian, pearl, ruby, turquoise
 *  2nd column:  brass, bronze, chrome, copper, gold, silver
 *  3rd column:  black, cyan, green, red, white, yellow plastic
 *  4th column:  black, cyan, green, red, white, yellow rubber
 */
void display(void)
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    renderTeapot (2.0, 17.0, 0.0215, 0.1745, 0.0215, 
	0.07568, 0.61424, 0.07568, 0.633, 0.727811, 0.633, 0.6);
    renderTeapot (2.0, 14.0, 0.135, 0.2225, 0.1575,
	0.54, 0.89, 0.63, 0.316228, 0.316228, 0.316228, 0.1);
    renderTeapot (2.0, 11.0, 0.05375, 0.05, 0.06625,
	0.18275, 0.17, 0.22525, 0.332741, 0.328634, 0.346435, 0.3);
    renderTeapot (2.0, 8.0, 0.25, 0.20725, 0.20725,
	1, 0.829, 0.829, 0.296648, 0.296648, 0.296648, 0.088);
    renderTeapot (2.0, 5.0, 0.1745, 0.01175, 0.01175,
	0.61424, 0.04136, 0.04136, 0.727811, 0.626959, 0.626959, 0.6);
    renderTeapot (2.0, 2.0, 0.1, 0.18725, 0.1745,
	0.396, 0.74151, 0.69102, 0.297254, 0.30829, 0.306678, 0.1);
    renderTeapot (6.0, 17.0, 0.329412, 0.223529, 0.027451,
	0.780392, 0.568627, 0.113725, 0.992157, 0.941176, 0.807843,
	0.21794872);
    renderTeapot (6.0, 14.0, 0.2125, 0.1275, 0.054,
	0.714, 0.4284, 0.18144, 0.393548, 0.271906, 0.166721, 0.2);
    renderTeapot (6.0, 11.0, 0.25, 0.25, 0.25, 
	0.4, 0.4, 0.4, 0.774597, 0.774597, 0.774597, 0.6);
    renderTeapot (6.0, 8.0, 0.19125, 0.0735, 0.0225,
	0.7038, 0.27048, 0.0828, 0.256777, 0.137622, 0.086014, 0.1);
    renderTeapot (6.0, 5.0, 0.24725, 0.1995, 0.0745,
	0.75164, 0.60648, 0.22648, 0.628281, 0.555802, 0.366065, 0.4);
    renderTeapot (6.0, 2.0, 0.19225, 0.19225, 0.19225,
	0.50754, 0.50754, 0.50754, 0.508273, 0.508273, 0.508273, 0.4);
    renderTeapot (10.0, 17.0, 0.0, 0.0, 0.0, 0.01, 0.01, 0.01,
	0.50, 0.50, 0.50, .25);
    renderTeapot (10.0, 14.0, 0.0, 0.1, 0.06, 0.0, 0.50980392, 0.50980392,
	0.50196078, 0.50196078, 0.50196078, .25);
    renderTeapot (10.0, 11.0, 0.0, 0.0, 0.0, 
	0.1, 0.35, 0.1, 0.45, 0.55, 0.45, .25);
    renderTeapot (10.0, 8.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0,
	0.7, 0.6, 0.6, .25);
    renderTeapot (10.0, 5.0, 0.0, 0.0, 0.0, 0.55, 0.55, 0.55,
	0.70, 0.70, 0.70, .25);
    renderTeapot (10.0, 2.0, 0.0, 0.0, 0.0, 0.5, 0.5, 0.0,
	0.60, 0.60, 0.50, .25);
    renderTeapot (14.0, 17.0, 0.02, 0.02, 0.02, 0.01, 0.01, 0.01,
	0.4, 0.4, 0.4, .078125);
    renderTeapot (14.0, 14.0, 0.0, 0.05, 0.05, 0.4, 0.5, 0.5,
	0.04, 0.7, 0.7, .078125);
    renderTeapot (14.0, 11.0, 0.0, 0.05, 0.0, 0.4, 0.5, 0.4,
	0.04, 0.7, 0.04, .078125);
    renderTeapot (14.0, 8.0, 0.05, 0.0, 0.0, 0.5, 0.4, 0.4,
	0.7, 0.04, 0.04, .078125);
    renderTeapot (14.0, 5.0, 0.05, 0.05, 0.05, 0.5, 0.5, 0.5,
	0.7, 0.7, 0.7, .078125);
    renderTeapot (14.0, 2.0, 0.05, 0.05, 0.0, 0.5, 0.5, 0.4, 
	0.7, 0.7, 0.04, .078125);
    glFlush();
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (w <= h)
	glOrtho (0.0, 16.0, 0.0, 16.0*(GLfloat)h/(GLfloat)w, 
		-10.0, 10.0);
    else
	glOrtho (0.0, 16.0*(GLfloat)w/(GLfloat)h, 0.0, 16.0, 
		-10.0, 10.0);
    glMatrixMode(GL_MODELVIEW);
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB | AUX_DEPTH16);
    auxInitPosition (10, 10, 500, 590);
    auxInitWindow (argv[0]);
    myinit();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\tea6.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  teapots.c
 *  This program demonstrates lots of material properties.
 *  A single light source illuminates the objects.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

/*  Initialize depth buffer, projection matrix, light source, 
 *  and lighting model.  Do not specify a material property here.
 */
void myinit(void)
{
    GLfloat ambient[] = { 0.0, 0.0, 0.0, 1.0 };
    GLfloat diffuse[] = { 1.0, 1.0, 1.0, 1.0 };
    GLfloat specular[] = { 1.0, 1.0, 1.0, 1.0 };
    GLfloat position[] = { 0.0, 3.0, 3.0, 0.0 };
    
    GLfloat lmodel_ambient[] = { 0.2, 0.2, 0.2, 1.0 };
    GLfloat local_view[] = { 0.0 };

    glLightfv(GL_LIGHT0, GL_AMBIENT, ambient);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuse);
    glLightfv(GL_LIGHT0, GL_POSITION, position);
    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_ambient);
    glLightModelfv(GL_LIGHT_MODEL_LOCAL_VIEWER, local_view);

    glFrontFace (GL_CW);
    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);
    glEnable(GL_AUTO_NORMAL);
    glEnable(GL_NORMALIZE);
    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LESS);
    glEnable(GL_DITHER);
}

/*  Move object into position.  Use 3rd through 12th parameters
 *  to specify the material property.  Draw a teapot.
 */
void renderTeapot (GLfloat x, GLfloat y, 
    GLfloat ambr, GLfloat ambg, GLfloat ambb, 
    GLfloat difr, GLfloat difg, GLfloat difb, 
    GLfloat specr, GLfloat specg, GLfloat specb, GLfloat shine)
{
    float mat[3];

    glPushMatrix();
    glTranslatef (x, y, 0.0);
    mat[0] = ambr; mat[1] = ambg; mat[2] = ambb;	
    glMaterialfv (GL_FRONT, GL_AMBIENT, mat);
    mat[0] = difr; mat[1] = difg; mat[2] = difb;	
    glMaterialfv (GL_FRONT, GL_DIFFUSE, mat);
    mat[0] = specr; mat[1] = specg; mat[2] = specb;
    glMaterialfv (GL_FRONT, GL_SPECULAR, mat);
    glMaterialf (GL_FRONT, GL_SHININESS, shine*128.0);
    auxSolidTeapot(1.0);
    glPopMatrix();
}

/*  First column:  emerald, jade, obsidian, pearl, ruby, turquoise
 *  2nd column:  brass, bronze, chrome, copper, gold, silver
 *  3rd column:  black, cyan, green, red, white, yellow plastic
 *  4th column:  black, cyan, green, red, white, yellow rubber
 */
void display(void)
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    renderTeapot (2.0, 8.0, 0.0215, 0.1745, 0.0215, 
	0.07568, 0.61424, 0.07568, 0.633, 0.727811, 0.633, 0.6);
    renderTeapot (2.0, 5.0, 0.135, 0.2225, 0.1575,
	0.54, 0.89, 0.63, 0.316228, 0.316228, 0.316228, 0.1);
    renderTeapot (2.0, 2.0, 0.05375, 0.05, 0.06625,
	0.18275, 0.17, 0.22525, 0.332741, 0.328634, 0.346435, 0.3);
    renderTeapot (6.0, 8.0, 0.25, 0.20725, 0.20725,
	1, 0.829, 0.829, 0.296648, 0.296648, 0.296648, 0.088);
    renderTeapot (6.0, 5.0, 0.1745, 0.01175, 0.01175,
	0.61424, 0.04136, 0.04136, 0.727811, 0.626959, 0.626959, 0.6);
    renderTeapot (6.0, 2.0, 0.1, 0.18725, 0.1745,
	0.396, 0.74151, 0.69102, 0.297254, 0.30829, 0.306678, 0.1);
glFlush();
return;
    renderTeapot (6.0, 17.0, 0.329412, 0.223529, 0.027451,
	0.780392, 0.568627, 0.113725, 0.992157, 0.941176, 0.807843,
	0.21794872);
    renderTeapot (6.0, 14.0, 0.2125, 0.1275, 0.054,
	0.714, 0.4284, 0.18144, 0.393548, 0.271906, 0.166721, 0.2);
    renderTeapot (6.0, 11.0, 0.25, 0.25, 0.25, 
	0.4, 0.4, 0.4, 0.774597, 0.774597, 0.774597, 0.6);
    renderTeapot (6.0, 8.0, 0.19125, 0.0735, 0.0225,
	0.7038, 0.27048, 0.0828, 0.256777, 0.137622, 0.086014, 0.1);
    renderTeapot (6.0, 5.0, 0.24725, 0.1995, 0.0745,
	0.75164, 0.60648, 0.22648, 0.628281, 0.555802, 0.366065, 0.4);
    renderTeapot (6.0, 2.0, 0.19225, 0.19225, 0.19225,
	0.50754, 0.50754, 0.50754, 0.508273, 0.508273, 0.508273, 0.4);
    renderTeapot (10.0, 17.0, 0.0, 0.0, 0.0, 0.01, 0.01, 0.01,
	0.50, 0.50, 0.50, .25);
    renderTeapot (10.0, 14.0, 0.0, 0.1, 0.06, 0.0, 0.50980392, 0.50980392,
	0.50196078, 0.50196078, 0.50196078, .25);
    renderTeapot (10.0, 11.0, 0.0, 0.0, 0.0, 
	0.1, 0.35, 0.1, 0.45, 0.55, 0.45, .25);
    renderTeapot (10.0, 8.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0,
	0.7, 0.6, 0.6, .25);
    renderTeapot (10.0, 5.0, 0.0, 0.0, 0.0, 0.55, 0.55, 0.55,
	0.70, 0.70, 0.70, .25);
    renderTeapot (10.0, 2.0, 0.0, 0.0, 0.0, 0.5, 0.5, 0.0,
	0.60, 0.60, 0.50, .25);
    renderTeapot (14.0, 17.0, 0.02, 0.02, 0.02, 0.01, 0.01, 0.01,
	0.4, 0.4, 0.4, .078125);
    renderTeapot (14.0, 14.0, 0.0, 0.05, 0.05, 0.4, 0.5, 0.5,
	0.04, 0.7, 0.7, .078125);
    renderTeapot (14.0, 11.0, 0.0, 0.05, 0.0, 0.4, 0.5, 0.4,
	0.04, 0.7, 0.04, .078125);
    renderTeapot (14.0, 8.0, 0.05, 0.0, 0.0, 0.5, 0.4, 0.4,
	0.7, 0.04, 0.04, .078125);
    renderTeapot (14.0, 5.0, 0.05, 0.05, 0.05, 0.5, 0.5, 0.5,
	0.7, 0.7, 0.7, .078125);
    renderTeapot (14.0, 2.0, 0.05, 0.05, 0.0, 0.5, 0.5, 0.4, 
	0.7, 0.7, 0.04, .078125);
    glFlush();
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (w <= h)
	glOrtho (0.0, 8.0, 0.0, 8.0*(GLfloat)h/(GLfloat)w, 
		-10.0, 10.0);
    else
	glOrtho (0.0, 8.0*(GLfloat)w/(GLfloat)h, 0.0, 8.0, 
		-10.0, 10.0);
    glMatrixMode(GL_MODELVIEW);
}

/*  Main Loop
 *  Open window with initial window size, title bar, 
 *  RGBA display mode, and handle input events.
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB | AUX_DEPTH16);
    auxInitPosition (10, 10, 250, 300);
    auxInitWindow (argv[0]);
    myinit();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\vasphere.cxx ===
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <time.h>
#include <assert.h>

#include <windows.h>
#include <gl\gl.h>
#include <gl\glu.h>
#include <gl\glaux.h>

#define PI ((float)3.14159265358979323846)

#define WIDTH 512
#define HEIGHT 512

#define TESS_MIN 5
#define TESS_MAX 100
int tessLevel = TESS_MAX / 2; // corresponds to # of rings/sections in object
int tessInc = 5;

typedef struct
{
    float fX, fY, fZ;
    float fNx, fNy, fNz;
    DWORD dwColor;
} VERTEX;

typedef struct
{
    int iV1;
    int iV2;
    int iV3;
} TRIANGLE;


enum {
    OBJECT_TYPE_SPHERE = 0,
    OBJECT_TYPE_TORUS,
    OBJECT_TYPE_CYLINDER
};

class OBJECT {
public:
    OBJECT(     int rings, int sections );
    ~OBJECT( );
    int         VertexCount() { return nVerts; }
    int         TriangleCount() { return nTris; }
    VERTEX      *VertexData() { return pVertData; }
    TRIANGLE    *TriangleData() { return pTriData; }
    int         NumRings() { return nRings; }
    int         NumSections() { return nSections; }

protected:
    int         iType;  // object type
    int         nVerts, nTris;
    int         nRings, nSections;
    VERTEX      *pVertData;
    TRIANGLE    *pTriData;
};

class SPHERE : public OBJECT {
public:
    SPHERE(     int rings, int sections );

private:
    void        GenerateData( float fRadius );
    int         CalcNVertices();
    int         CalcNTriangles();
};

enum {
    DRAW_METHOD_VERTEX_ARRAY = 0,
    DRAW_METHOD_DREE,
    DRAW_METHOD_TRIANGLES,
    DRAW_METHOD_TRISTRIPS,
    NUM_DRAW_METHODS
};

// Draw method names
char *pszListType[NUM_DRAW_METHODS] =
{
    "Vertex Array", "DrawRangeElements", "Direct Triangles", "Direct Strips"
};

class DRAW_CONTROLLER {
public:
    DRAW_CONTROLLER::DRAW_CONTROLLER();
    DRAW_CONTROLLER::~DRAW_CONTROLLER();
    void        InitGL();
    void        CycleDrawMethod();
    void        ToggleDisplayListDraw() {bDisplayList = !bDisplayList; }
    void        ToggleLighting() {bLighting = !bLighting; SetLighting(); }
    void        Draw();
    OBJECT      *GetDrawObject() {return pObject;}
    void        SetDrawObject( OBJECT *pObj, int objectType );
    char        *GetDrawMethodName();

private:
    int         iDrawMethod;
    BOOL        bDisplayList;
    BOOL        bLighting;
    BOOL        bDREE;  // if DrawRangeElements extension available or not
    BOOL        bDREE_Disabled;  // DREE can be temporarily disabled if not
                                 // practical to use (e.g. high tesselation)
    int         nDREE_MaxVertices;
    int         nDREE_MaxIndices;
    PFNGLDRAWRANGEELEMENTSWINPROC pfnDrawRangeElementsWIN;
    OBJECT      *pObject;  // Draw object
    int         iObjectType;
    GLint       dlList[NUM_DRAW_METHODS];
    char        **pszDrawMethodNames;
    char        szNameBuf[80];

    void        SetLighting();
    void        NewList();
    void        DeleteLists();
    void        DeleteList(int iList);
    void        DrawObject(); 

    // Draw methods
    void        DrawVertexArray ();
    void        DrawRangeElements(); 
    void        DrawTriangles(); 
    void        DrawStrips();

    void        Vertex(int iVert);
    void        CheckDREE_Existence();
    BOOL        CheckDREE_Usable();
};

class SCENE {
public:
    SCENE();
    ~SCENE();
    void        Draw();
    void        NewObject( int tessLevel );
    DRAW_CONTROLLER drawController;
private:
    GLfloat fXr, fYr, fZr;
    GLfloat fDXr, fDYr, fDZr;
};

enum {
    TIMER_METHOD_SINGLE = 0,  // single-shot timer
    TIMER_METHOD_AVERAGE,     // average time for past n results
};

#define MAX_RESULTS 10

class TIMER {
public:
    TIMER( int timerMethodArg );
    void    Start() { dwMillis = GetTickCount(); }
    BOOL    Stop( int numItems, float *fRate );
    void    Reset();
private:
    int     timerMethod;
    int     nItems;
    int     nTotalItems; // total # triangles accumulated
    DWORD   dwMillis;
    DWORD   dwTotalMillis;
    DWORD   updateInterval;  // interval between timer updates

    // These variables are for result averaging
    float   fResults[MAX_RESULTS];
    int     nResults; // current # of results
    int     nMaxResults; // max # of results for averaging
    int     iOldestResult; // index of oldest result
    float   fSummedResults; // current sum of results
};

// Global objects
SCENE *scene;
SPHERE *sphere;
TIMER timer( TIMER_METHOD_AVERAGE );

#define RGB_COLOR(red, green, blue) \
    (((DWORD)(BYTE)(red) << 0) | \
     ((DWORD)(BYTE)(green) << 8) | \
     ((DWORD)(BYTE)(blue) << 16))
    
#define FRANDOM(x) (((float)rand() / RAND_MAX) * (x))

#define DROT 10.0f

BOOL fSingle = FALSE;


/****** OBJECT *******************************************************/


OBJECT::OBJECT( int rings, int sections )
: nRings( rings ), nSections( sections )
{
    pTriData = NULL;
    pVertData = NULL;
}

OBJECT::~OBJECT()
{
    // These ptrs alloc'd in inheriting classes...
    if( pVertData )
        free( pVertData );
    if( pTriData )
        free( pTriData );
}

/****** SPHERE *******************************************************/

SPHERE::SPHERE( 
    int rings, int sections )
    : OBJECT( rings, sections )
{
    iType = OBJECT_TYPE_SPHERE;

    nVerts = CalcNVertices();
    nTris = CalcNTriangles();

    // Allocate memory for the sphere data (freed by the base OBJECT class)

    // Vertex data
    pVertData = (VERTEX *) malloc( nVerts * sizeof(VERTEX) );
    assert( pVertData != NULL );

    // Triangle indices
    pTriData = (TRIANGLE *) malloc( nTris * sizeof(TRIANGLE) );
    assert( pTriData != NULL );

    GenerateData(1.0f);
}

int
SPHERE::CalcNVertices()
{
    return (((nRings)+1)*(nSections)+2);
}

int
SPHERE::CalcNTriangles()
{
    return (((nRings)+1)*(nSections)*2);
}


void 
SPHERE::GenerateData( float fRadius )
{
    float fTheta, fPhi;             /* Angles used to sweep around sphere */
    float fDTheta, fDPhi;           /* Angle between each section and ring */
    float fX, fY, fZ, fV, fRSinTheta;  /* Temporary variables */
    int   i, j, n, m;               /* counters */
    VERTEX *pvtx = pVertData;
    TRIANGLE *ptri = pTriData;

    /*
     * Generate vertices at the top and bottom points.
     */
    pvtx[0].fX = 0.0f;
    pvtx[0].fY = fRadius;
    pvtx[0].fZ = 0.0f;
    pvtx[0].fNx = 0.0f;
    pvtx[0].fNy = 1.0f;
    pvtx[0].fNz = 0.0f;
    pvtx[0].dwColor = RGB_COLOR(0, 0, 255);
    pvtx[nVerts - 1].fX = 0.0f;
    pvtx[nVerts - 1].fY = -fRadius;
    pvtx[nVerts - 1].fZ = 0.0f;
    pvtx[nVerts - 1].fNx = 0.0f;
    pvtx[nVerts - 1].fNy = -1.0f;
    pvtx[nVerts - 1].fNz = 0.0f;
    pvtx[nVerts - 1].dwColor = RGB_COLOR(0, 255, 0);

    /*
     * Generate vertex points for rings
     */
    fDTheta = PI / (float) (nRings + 2);
    fDPhi = 2.0f * PI / (float) nSections;
    n = 1; /* vertex being generated, begins at 1 to skip top point */
    fTheta = fDTheta;

    for (i = 0; i <= nRings; i++)
    {
        fY = (float)(fRadius * cos(fTheta)); /* y is the same for each ring */
        fV = fTheta / PI; /* v is the same for each ring */
        fRSinTheta = (float)(fRadius * sin(fTheta));
        fPhi = 0.0f;
	
        for (j = 0; j < nSections; j++)
        {
            fX = (float)(fRSinTheta * sin(fPhi));
            fZ = (float)(fRSinTheta * cos(fPhi));
            pvtx[n].fX = fX;
            pvtx[n].fZ = fZ;
            pvtx[n].fY = fY;
            pvtx[n].fNx = fX / fRadius;
            pvtx[n].fNy = fY / fRadius;
            pvtx[n].fNz = fZ / fRadius;
            if (n & 1)
            {
                pvtx[n].dwColor = RGB_COLOR(0, 0, 255);
            }
            else
            {
                pvtx[n].dwColor = RGB_COLOR(0, 255, 0);
            }
            fPhi += fDPhi;
            n++;
        }
	
        fTheta += fDTheta;
    }

    /*
     * Generate triangles for top and bottom caps.
     */
    for (i = 0; i < nSections; i++)
    {
        ptri[i].iV1 = 0;
        ptri[i].iV2 = i + 1;
        ptri[i].iV3 = 1 + ((i + 1) % nSections);
        ptri[nTris - nSections + i].iV1 = nVerts - 1;
        ptri[nTris - nSections + i].iV2 = nVerts - 2 - i;
        ptri[nTris - nSections + i].iV3 = nVerts - 2 - ((1 + i) % nSections);
    }

    /*
     * Generate triangles for the rings
     */
    m = 1; /* first vertex in current ring, begins at 1 to skip top point*/
    n = nSections; /* triangle being generated, skip the top cap */
	
    for (i = 0; i < nRings; i++)
    {
        for (j = 0; j < nSections; j++)
        {
            ptri[n].iV1 = m + j;
            ptri[n].iV2 = m + nSections + j;
            ptri[n].iV3 = m + nSections + ((j + 1) % nSections);
            ptri[n + 1].iV1 = ptri[n].iV1;
            ptri[n + 1].iV2 = ptri[n].iV3;
            ptri[n + 1].iV3 = m + ((j + 1) % nSections);
            n += 2;
        }
	
        m += nSections;
    }
}

/****** DRAW_CONTROLLER *********************************************/

DRAW_CONTROLLER::DRAW_CONTROLLER( )
{
    iDrawMethod = 0;
    bDisplayList = FALSE;
    bLighting = TRUE;

    // check out if DREE exists
    CheckDREE_Existence();

    pszDrawMethodNames = pszListType;

    // Set display list indices to 0 (so they will be filled later)
    for( int i = 0; i < NUM_DRAW_METHODS; i++ )
        dlList[i] = 0;

    // Init GL state
    InitGL();
}

DRAW_CONTROLLER::~DRAW_CONTROLLER( )
{
    DeleteLists();
}

void
DRAW_CONTROLLER::DeleteLists()
{
    for( int i = 0; i < NUM_DRAW_METHODS; i ++ )
        DeleteList( i );
}

void
DRAW_CONTROLLER::DeleteList( int iList )
{
    if( dlList[iList] ) {
        glDeleteLists( dlList[iList], 1 );
        dlList[iList] = 0;
    }
}

void
DRAW_CONTROLLER::CheckDREE_Existence()
{
    // Check for DrawRangeElements extension
 
    pfnDrawRangeElementsWIN = (PFNGLDRAWRANGEELEMENTSWINPROC)
        wglGetProcAddress("glDrawRangeElementsWIN");
    if (pfnDrawRangeElementsWIN == NULL) {
        bDREE = FALSE;
        bDREE_Disabled = TRUE;
        return;
    }

    // Extension exists - find out its limits
    bDREE = TRUE;
    glGetIntegerv( GL_MAX_ELEMENTS_VERTICES_WIN, &nDREE_MaxVertices );
    glGetIntegerv( GL_MAX_ELEMENTS_INDICES_WIN, &nDREE_MaxIndices );
}

BOOL
DRAW_CONTROLLER::CheckDREE_Usable( )
{
    // Cancel DrawRangeElements if vertex structure makes it impractical :
    // - Vertex range too great to fit in call, or
    // - Too many indices
    // (I add 1 here to account for top or bottom vertices in a batch)
    if( ( (2*pObject->NumSections() + 1) > nDREE_MaxVertices ) ||
        ( (2*pObject->NumSections()*3) > nDREE_MaxIndices ) 
      ) 
        bDREE_Disabled = TRUE;
    else
        bDREE_Disabled = FALSE;
    return !bDREE_Disabled;
}

char *
DRAW_CONTROLLER::GetDrawMethodName()
{
    // Returns name of current drawing method.  If in dlist mode, then this is
    // prepended to the name.
    sprintf(szNameBuf, "%s%s",
            bDisplayList ? "Display List " : "",
            pszDrawMethodNames[iDrawMethod] );
    return szNameBuf;
}

void
DRAW_CONTROLLER::CycleDrawMethod()
{
    iDrawMethod++;
    if( bDREE_Disabled && (iDrawMethod == DRAW_METHOD_DREE) )    
        iDrawMethod++;

    if( iDrawMethod >= NUM_DRAW_METHODS )
        iDrawMethod = 0;
}

void
DRAW_CONTROLLER::NewList( )
{
    // Create new list for the current draw method

    if( ! dlList[iDrawMethod] ) {
        dlList[iDrawMethod] = glGenLists(1);
    }
    glNewList(dlList[iDrawMethod], GL_COMPILE);
        DrawObject();
    glEndList();
}

void
DRAW_CONTROLLER::SetDrawObject( OBJECT *pObj, int objectType )
{
    iObjectType = objectType;
    pObject = pObj;

    // Delete all current lists
    DeleteLists();

    // Check if DREE can be used - and if not go on to next method if
    // current method is DREE
    if( !CheckDREE_Usable() && (iDrawMethod == DRAW_METHOD_DREE) )
        CycleDrawMethod();
}


void
DRAW_CONTROLLER::Draw()
{
    // Draws display list or immediate mode

    // Display list draw
    if( bDisplayList ) {
        // Create dlist if necessary
        if( !dlList[iDrawMethod] )
            NewList();
        glCallList( dlList[iDrawMethod] );
        return;
    }

    // Immediate mode draw
    DrawObject();
}

void
DRAW_CONTROLLER::DrawObject()
{
    // Issues draw commands

    switch( iDrawMethod ) {
        case DRAW_METHOD_VERTEX_ARRAY :
            DrawVertexArray();
            break;
        case DRAW_METHOD_DREE :
            DrawRangeElements(); 
            break;
        case DRAW_METHOD_TRIANGLES :
            DrawTriangles(); 
            break;
        case DRAW_METHOD_TRISTRIPS :
            DrawStrips();
            break;
    }
}


void
DRAW_CONTROLLER::DrawVertexArray()
{
    glDrawElements(GL_TRIANGLES, 
                   pObject->TriangleCount()*3, 
                   GL_UNSIGNED_INT, 
                   pObject->TriangleData() );
}

void
DRAW_CONTROLLER::DrawRangeElements()
{
    GLint *pTriIndices;
    GLint nVerts, nTris;
    GLenum type = GL_UNSIGNED_INT;

    nVerts = pObject->VertexCount();
    nTris = pObject->TriangleCount();
    pTriIndices = (int *) pObject->TriangleData();

    // Check for trivial case requiring no batching

    if( (nVerts <= nDREE_MaxVertices) &&
        (nTris*3 <= nDREE_MaxIndices) ) {
        pfnDrawRangeElementsWIN(GL_TRIANGLES, 
                                0, 
                                nVerts-1, 
                                nTris*3, 
                                type, 
                                pTriIndices );
        return;
    }

    // Have to batch : Since the vertex ordering of the sphere is along rings,
    // we will batch by groups of rings, according to the vertex index ranges
    // allowed by the DrawRangeElements call.
    //

    // Need some more variables:
    GLuint start, end; 
    GLsizei count;
    GLuint nRingsPerBatch, nTrisPerBatch, nElemsPerBatch,
           nVerticesPerBatch, elemsLeft;
    int sections = pObject->NumSections();
    int rings    = pObject->NumRings();

    nRingsPerBatch = nDREE_MaxVertices / (sections);
    nTrisPerBatch = (nRingsPerBatch-1)*sections*2;
    nElemsPerBatch = nTrisPerBatch*3;
    nVerticesPerBatch = nRingsPerBatch*sections;
    elemsLeft = nTris*3;
    
    // Special case first batch with top vertex

    start = 0;
    end = nVerticesPerBatch - sections; 
    count = nElemsPerBatch - (sections*3); // top row only has half the tris of
                                           // a 'normal' row
    pfnDrawRangeElementsWIN(GL_TRIANGLES, 
                            start, 
                            end, 
                            count, 
                            type, 
                            pTriIndices);

    // Batch groups of rings around sphere

    pTriIndices += count;
    start = (end - sections + 1);
    elemsLeft -= count;
    
    while( elemsLeft >= nElemsPerBatch )
    {
        pfnDrawRangeElementsWIN(GL_TRIANGLES, 
                                start, 
                                start + nVerticesPerBatch - 1, 
                                nElemsPerBatch, 
                                type,
                                pTriIndices);

        start += (nVerticesPerBatch - sections);
        pTriIndices += nElemsPerBatch;
        elemsLeft -= nElemsPerBatch;
    }

    // Do last batch, including bottom vertex

    if( elemsLeft ) {
        pfnDrawRangeElementsWIN(GL_TRIANGLES, 
                                start, 
                                nVerts-1, 
                                elemsLeft, 
                                type,
                                pTriIndices);
    }
}

void
DRAW_CONTROLLER::Vertex(int iVert)
{
    VERTEX *pvtx;

    pvtx = pObject->VertexData() + iVert;
    glColor3ubv((GLubyte *)&pvtx->dwColor);
    glNormal3fv(&pvtx->fNx);
    glVertex3fv(&pvtx->fX);
}

void
DRAW_CONTROLLER::DrawTriangles()
{
    int iVert, *pidx;
    
    glBegin(GL_TRIANGLES);
    pidx = (int *) pObject->TriangleData();
    for (iVert = 0; iVert < pObject->TriangleCount()*3; iVert++)
    {
        Vertex(*pidx++);
    }
    glEnd();
}

void
DRAW_CONTROLLER::DrawStrips()
{
    int iIdxBase;
    int iRing, iSection;
    int sections = pObject->NumSections();
    int rings    = pObject->NumRings();

    // Triangle fans for top and bottom caps
    glBegin(GL_TRIANGLE_FAN);
    
    Vertex(0);
    iIdxBase = 1;
    for (iSection = 0; iSection <= sections; iSection++)
    {
        Vertex(iIdxBase+(iSection % sections));
    }
    
    glEnd();

    glBegin(GL_TRIANGLE_FAN);

    Vertex(pObject->VertexCount() - 1);
    iIdxBase = pObject->VertexCount() - sections - 1;
    for (iSection = sections; iSection >= 0 ; iSection--)
    {
        Vertex(iIdxBase+(iSection % sections));
    }

    glEnd();

    // Triangle strips for each ring
    iIdxBase = 1;
    for (iRing = 0; iRing < rings; iRing++)
    {
        glBegin(GL_TRIANGLE_STRIP);
        
        for (iSection = 0; iSection <= sections; iSection++)
        {
            Vertex(iIdxBase+(iSection % sections));
            Vertex(iIdxBase+(iSection % sections)+sections);
        }

        glEnd();

        iIdxBase += sections;
    }
}

void
DRAW_CONTROLLER::InitGL(void)
{
    float fv4[4];
    int iv1[1];
    int i;
    
    fv4[0] = 0.05f;
    fv4[1] = 0.05f;
    fv4[2] = 0.05f;
    fv4[3] = 1.0f;
    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, fv4);
    
    fv4[0] = 0.0f;
    fv4[1] = 1.0f;
    fv4[2] = 1.0f;
    fv4[3] = 0.0f;
    glLightfv(GL_LIGHT0, GL_POSITION, fv4);
    fv4[0] = 0.9f;
    fv4[1] = 0.9f;
    fv4[2] = 0.9f;
    fv4[3] = 1.0f;
    glLightfv(GL_LIGHT0, GL_DIFFUSE, fv4);
    glEnable(GL_LIGHT0);
    glEnable(GL_LIGHTING);
    
    fv4[0] = 0.6f;
    fv4[1] = 0.6f;
    fv4[2] = 0.6f;
    fv4[3] = 1.0f;
    glMaterialfv(GL_FRONT, GL_SPECULAR, fv4);
    iv1[0] = 40;
    glMaterialiv(GL_FRONT, GL_SHININESS, iv1);
    
    glEnable(GL_CULL_FACE);

    glEnableClientState(GL_VERTEX_ARRAY);
    glEnableClientState(GL_NORMAL_ARRAY);
    glEnableClientState(GL_COLOR_ARRAY);
    
    glColorMaterial(GL_FRONT, GL_AMBIENT_AND_DIFFUSE);
    glEnable(GL_COLOR_MATERIAL);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(45, 1, .01, 15);
    gluLookAt(0, 0, 10, 0, 0, 0, 0, 1, 0);
    glMatrixMode(GL_MODELVIEW);

    SetLighting();
}

void
DRAW_CONTROLLER::SetLighting(void)
{
    if( bLighting ) {
        glEnable( GL_LIGHTING );
    } else {
        glDisable( GL_LIGHTING );
    }
}


/****** SCENE *******************************************************/


SCENE::SCENE()
{
    srand(time(NULL));

    // Create sphere draw object for the scene
    NewObject( tessLevel );
}

void
SCENE::NewObject( int tessLevel )
{
    // Only one object allowed for now - delete any previous object
    if( sphere )
        delete sphere;

    // Create new sphere for the scene
    sphere = new SPHERE( tessLevel, tessLevel );
    assert( sphere != NULL );

    // Inform DRAW_CONTROLLER about new object
    drawController.SetDrawObject( sphere, OBJECT_TYPE_SPHERE );

    // Initialize array pointer data
    VERTEX *pVertData = sphere->VertexData();
    glVertexPointer(3, GL_FLOAT, sizeof(VERTEX), &pVertData->fX);
    glNormalPointer(GL_FLOAT, sizeof(VERTEX), &pVertData->fNx);
    glColorPointer(3, GL_UNSIGNED_BYTE, sizeof(VERTEX), &pVertData->dwColor);

    // Init scene rotation and motion
    fXr = 0.0f;
    fYr = 0.0f;
    fZr = 0.0f;
    fDXr = DROT - FRANDOM(2 * DROT);
    fDYr = DROT - FRANDOM(2 * DROT);
    fDZr = DROT - FRANDOM(2 * DROT);
}

SCENE::~SCENE()
{
    // Delete any scene objects
    if( sphere )
        delete sphere;
}

void
SCENE::Draw()
{
    glClear(GL_COLOR_BUFFER_BIT);

    glLoadIdentity();

    glRotatef(fXr, 1.0f, 0.0f, 0.0f);
    glRotatef(fYr, 0.0f, 1.0f, 0.0f);
    glRotatef(fZr, 0.0f, 0.0f, 1.0f);

    drawController.Draw();

    // next rotation...
    fXr += fDXr;
    fYr += fDYr;
    fZr += fDZr;
}


/****** TIMER *******************************************************/


TIMER::TIMER( int timerMethodArg )
: timerMethod( timerMethodArg )
{
    updateInterval = 2000; // in milliseconds
    Reset();
}

void
TIMER::Reset()
{
    dwTotalMillis = 0;
    nTotalItems = 0;

    // Parameters for result averaging
    nResults = 0;
    nMaxResults = MAX_RESULTS; // number of most recent results to average
    fSummedResults = 0.0f;
    iOldestResult = 0; // index of oldest result
}

BOOL    
TIMER::Stop( int numItems, float *fRate )
{
    dwMillis = GetTickCount()-dwMillis;
    dwTotalMillis += dwMillis;
    nTotalItems += numItems;

    // If total elapsed time is greater than the update interval, send back
    // timing information

    if (dwTotalMillis > updateInterval )
    {
        float fItemsPerSecond; 
        int iNewResult;

        fItemsPerSecond = (float) nTotalItems*1000.0f/dwTotalMillis;

        switch( timerMethod ) {

          case TIMER_METHOD_AVERAGE :

            // Average last n results (they are kept in a circular buffer)
                
            if( nResults < nMaxResults ) {
                // Haven't filled the buffer yet
                iNewResult = nResults;
                nResults++;
            } else {
                // Full buffer : replace oldest entry with new value
                fSummedResults -= fResults[iOldestResult];
                iNewResult = iOldestResult;
                iOldestResult = (iOldestResult == (nMaxResults - 1)) ?
                                    0 :
                                    (iOldestResult + 1);
                                
            }

            // Add new result, maintain sum to simplify calculations
            fResults[iNewResult] = fItemsPerSecond;
            fSummedResults += fItemsPerSecond;

            // average the result
            fItemsPerSecond = fSummedResults / (float) nResults;

            break;
        }

        // Set running totals back to 0
        dwTotalMillis = 0;
        nTotalItems = 0;

        *fRate = fItemsPerSecond;
        return TRUE;
    } else
        return FALSE; // no new information yet

}

/********************************************************************/

void Reset()
{
    // Called when display changes

    // Remove any timing info from title bar, and reset the timer
    SetWindowText(auxGetHWND(), scene->drawController.GetDrawMethodName() );
    timer.Reset();
}

void NewTessLevel( int tessLevel )
{
    static int oldTessLevel = 0; // to avoid unnecessary work

    // retesselate scene's object
    if( tessLevel == oldTessLevel )
        return;
    scene->NewObject( tessLevel );

    Reset();

    oldTessLevel = tessLevel;
}

void Redraw(void)
{
    DRAW_CONTROLLER *pDrawControl = &scene->drawController;
    float trianglesPerSecond;
    
    timer.Start();

    // Draw the scene

    scene->Draw();

    if (fSingle)
        glFlush();
    else
        auxSwapBuffers();
    
    // Print timing information if Stop returns TRUE

    if( timer.Stop( pDrawControl->GetDrawObject()->TriangleCount(), 
                       &trianglesPerSecond ) ) {
        char szMsg[80];
        sprintf(szMsg, "%s: %.0lf tri/sec",
                pDrawControl->GetDrawMethodName(),
                trianglesPerSecond );

        // Print timing info in title bar
        SetWindowText(auxGetHWND(), szMsg);
    }
}

void Reshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    Reset();
}

void Keyd(void)
{
    scene->drawController.ToggleDisplayListDraw();
    Reset();
}

void Keyl(void)
{
    scene->drawController.ToggleLighting();
    Reset();
}

void KeySPACE(void)
{
    scene->drawController.CycleDrawMethod();
    Reset();
}
    
void KeyUp(void)
{
    // increase tesselation
    tessLevel += tessInc;
    if( tessLevel > TESS_MAX )
        tessLevel = TESS_MAX;
    NewTessLevel( tessLevel );
}

void KeyDown(void)
{
    // decrease tesselation
    tessLevel -= tessInc;
    if( tessLevel < TESS_MIN )
        tessLevel = TESS_MIN;
    NewTessLevel( tessLevel );
}

void __cdecl main(int argc, char **argv)
{
    GLenum eMode;
    
    while (--argc > 0)
    {
        argv++;

        if (!strcmp(*argv, "-sb"))
            fSingle = TRUE;
    }
    
    auxInitPosition(10, 10, WIDTH, HEIGHT);
    eMode = AUX_RGB;
    if (!fSingle)
    {
        eMode |= AUX_DOUBLE;
    }
    auxInitDisplayMode(eMode);
    auxInitWindow("Vertex Array/Direct Comparison");

    auxReshapeFunc(Reshape);
    auxIdleFunc(Redraw);

    auxKeyFunc(AUX_l, Keyl);
    auxKeyFunc(AUX_d, Keyd);
    auxKeyFunc(AUX_SPACE, KeySPACE);
    auxKeyFunc(AUX_UP, KeyUp);
    auxKeyFunc(AUX_DOWN, KeyDown);

    // Create scene, with object(s)
    scene = new SCENE;

    // Start drawing
    auxMainLoop(Redraw);

    // Party's over
    delete scene;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\texsurf.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*  texturesurf.c
 *  This program uses evaluators to generate a curved
 *  surface and automatically generated texture coordinates.
 */

#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"
#include <math.h>

GLfloat ctrlpoints[4][4][3] = {
    {{ -1.5, -1.5, 4.0}, { -0.5, -1.5, 2.0}, 
	{0.5, -1.5, -1.0}, {1.5, -1.5, 2.0}}, 
    {{ -1.5, -0.5, 1.0}, { -0.5, -0.5, 3.0}, 
	{0.5, -0.5, 0.0}, {1.5, -0.5, -1.0}}, 
    {{ -1.5, 0.5, 4.0}, { -0.5, 0.5, 0.0}, 
	{0.5, 0.5, 3.0}, {1.5, 0.5, 4.0}}, 
    {{ -1.5, 1.5, -2.0}, { -0.5, 1.5, -2.0}, 
	{0.5, 1.5, 0.0}, {1.5, 1.5, -1.0}}
};

GLfloat texpts[2][2][2] = {{{0.0, 0.0}, {0.0, 1.0}}, 
			{{1.0, 0.0}, {1.0, 1.0}}};

void display(void)
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glColor3f(1.0, 1.0, 1.0);
    glEvalMesh2(GL_FILL, 0, 20, 0, 20);
    glFlush();
}

#define	imageWidth 64
#define	imageHeight 64
GLubyte image[3*imageWidth*imageHeight];

void makeImage(void)
{
    int i, j;
    float ti, tj;
    
    for (i = 0; i < imageWidth; i++) {
	ti = 2.0*3.14159265*i/imageWidth;
	for (j = 0; j < imageHeight; j++) {
	    tj = 2.0*3.14159265*j/imageHeight;

	    image[3*(imageHeight*i+j)] = (GLubyte) 127*(1.0+sin(ti));
	    image[3*(imageHeight*i+j)+1] = (GLubyte) 127*(1.0+cos(2*tj));
	    image[3*(imageHeight*i+j)+2] = (GLubyte) 127*(1.0+cos(ti+tj));
	}
    }
}

void myinit(void)
{
    glMap2f(GL_MAP2_VERTEX_3, 0, 1, 3, 4,
	    0, 1, 12, 4, &ctrlpoints[0][0][0]);
    glMap2f(GL_MAP2_TEXTURE_COORD_2, 0, 1, 2, 2, 
	    0, 1, 4, 2, &texpts[0][0][0]);
    glEnable(GL_MAP2_TEXTURE_COORD_2);
    glEnable(GL_MAP2_VERTEX_3);
    glMapGrid2f(20, 0.0, 1.0, 20, 0.0, 1.0);
    makeImage();
    glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexImage2D(GL_TEXTURE_2D, 0, 3, imageWidth, imageHeight, 0,
		 GL_RGB, GL_UNSIGNED_BYTE, image);
    glEnable(GL_TEXTURE_2D);
    glEnable(GL_DEPTH_TEST);
    glEnable(GL_NORMALIZE);
    glShadeModel (GL_FLAT);
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (w <= h)
	glOrtho(-4.0, 4.0, -4.0*(GLfloat)h/(GLfloat)w, 
	    4.0*(GLfloat)h/(GLfloat)w, -4.0, 4.0);
    else
	glOrtho(-4.0*(GLfloat)w/(GLfloat)h, 
	    4.0*(GLfloat)w/(GLfloat)h, -4.0, 4.0, -4.0, 4.0);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    glRotatef(85.0, 1.0, 1.0, 1.0);
}

int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB | AUX_DEPTH16);
    auxInitPosition (100, 50, 300, 300);
    auxInitWindow (argv[0]);
    myinit();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\vtxtime.c ===
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <time.h>

#include <windows.h>
#include <gl\gl.h>
#include <gl\glu.h>
#include <gl\glaux.h>

#define PI ((float)3.14159265358979323846)

#define WIDTH 512
#define HEIGHT 512

BOOL fSingle = FALSE;
BOOL fRotate = FALSE;
BOOL fColor = FALSE;
BOOL fNormal = FALSE;
BOOL fTexture = FALSE;

DWORD dwTotalMillis = 0;
int iTotalPoints = 0;

#define DEF_PRIM_POINTS         250
#define DEF_PRIMS               250

int iPrims = DEF_PRIMS;
int iPrimPoints = DEF_PRIM_POINTS;
int iPoints = DEF_PRIMS*DEF_PRIM_POINTS;

float fRotAngle = 0.0f;

#define MAX_COLOR (3*3)
float afColors[MAX_COLOR] =
{
    1.0f, 0.0f, 0.0f,
    0.0f, 1.0f, 0.0f,
    0.0f, 0.0f, 1.0f
};
float *pfCurColor;

void Init(void)
{
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective(45, 1, .01, 15);
    gluLookAt(0, 0, 3, 0, 0, 0, 0, 1, 0);
    glMatrixMode(GL_MODELVIEW);
}

void ResetTotals(void)
{
    dwTotalMillis = 0;
    iTotalPoints = 0;
}

void Redraw(void)
{
    DWORD dwMillis;
    char szMsg[80];
    int iPt, iPrim;
    float fX, fY, fDx, fDy;
    
    dwMillis = GetTickCount();

    glClear(GL_COLOR_BUFFER_BIT);

    if (fRotate)
    {
        glLoadIdentity();
        glRotatef(fRotAngle, 0.0f, 0.0f, 1.0f);
        fRotAngle += 2.0f;
    }
    
    fDx = 2.0f/(iPrimPoints-1);
    fDy = 2.0f/(iPrims-1);
    
    fY = -1.0f;

    pfCurColor = afColors;
    for (iPrim = 0; iPrim < iPrims; iPrim++)
    {
        fX = -1.0f;

        glBegin(GL_POINTS);
        for (iPt = 0; iPt < iPrimPoints; iPt++)
        {
            if (fColor)
            {
                glColor3fv(pfCurColor);
                pfCurColor += 3;
                if (pfCurColor >= afColors+MAX_COLOR)
                {
                    pfCurColor = afColors;
                }
            }
            if (fNormal)
            {
                glNormal3f(0.0f, 0.0f, 1.0f);
            }
            if (fTexture)
            {
                glTexCoord2f(0.5f, 0.5f);
            }
            glVertex3f(fX, fY, 0.0f);
            fX += fDx;
        }
        glEnd();

        fY += fDy;
    }
    
    if (fSingle)
    {
        glFlush();
    }
    else
    {
        auxSwapBuffers();
    }
    
    dwMillis = GetTickCount()-dwMillis;

    dwTotalMillis += dwMillis;
    iTotalPoints += iPoints;

    if (dwTotalMillis > 1000)
    {
        sprintf(szMsg, "%.3lf pts/sec",
                (double)iTotalPoints*1000.0/dwTotalMillis);
        SetWindowText(auxGetHWND(), szMsg);

        ResetTotals();
    }
}

void Reshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
}

void Keyc(void)
{
    ResetTotals();
    fColor = !fColor;
}

void Keyn(void)
{
    ResetTotals();
    fNormal = !fNormal;
}

void KeyP(void)
{
    int iv1[1];

    ResetTotals();
    glGetIntegerv(GL_CLIP_VOLUME_CLIPPING_HINT_EXT, &iv1[0]);
    if (iv1[0] == GL_FASTEST)
    {
	glHint(GL_CLIP_VOLUME_CLIPPING_HINT_EXT, GL_DONT_CARE);
    }
    else
    {
	glHint(GL_CLIP_VOLUME_CLIPPING_HINT_EXT, GL_FASTEST);
    }
}

void Keyt(void)
{
    ResetTotals();
    fTexture = !fTexture;
}

void __cdecl main(int argc, char **argv)
{
    GLenum eMode;
    
    while (--argc > 0)
    {
        argv++;

        if (!strcmp(*argv, "-sb"))
        {
            fSingle = TRUE;
        }
        else if (!strcmp(*argv, "-rotate"))
        {
            fRotate = TRUE;
        }
    }
    
    auxInitPosition(10, 10, WIDTH, HEIGHT);
    eMode = AUX_RGB;
    if (!fSingle)
    {
        eMode |= AUX_DOUBLE;
    }
    auxInitDisplayMode(eMode);
    auxInitWindow("Vertex API Timing");

    auxReshapeFunc(Reshape);
    auxIdleFunc(Redraw);

    auxKeyFunc(AUX_c, Keyc);
    auxKeyFunc(AUX_n, Keyn);
    auxKeyFunc(AUX_P, KeyP);
    auxKeyFunc(AUX_t, Keyt);
    
    Init();
    auxMainLoop(Redraw);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\trim.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*
 *  trim.c
 *  This program draws a NURBS surface in the shape of a 
 *  symmetrical hill, using both a NURBS curve and pwl
 *  (piecewise linear) curve to trim part of the surface.
 */
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

GLfloat ctlpoints[4][4][3];

GLUnurbsObj *theNurb;

/*
 *  Initializes the control points of the surface to a small hill.
 *  The control points range from -3 to +3 in x, y, and z
 */
void init_surface(void)
{
    int u, v;
    for (u = 0; u < 4; u++) {
	for (v = 0; v < 4; v++) {
	    ctlpoints[u][v][0] = 2.0*((GLfloat)u - 1.5);
	    ctlpoints[u][v][1] = 2.0*((GLfloat)v - 1.5);

	    if ( (u == 1 || u == 2) && (v == 1 || v == 2))
		ctlpoints[u][v][2] = 3.0;
	    else
		ctlpoints[u][v][2] = -3.0;
	}
    }				
}				
			
/*  Initialize material property and depth buffer.
 */
void myinit(void)
{
    GLfloat mat_diffuse[] = { 0.6, 0.6, 0.6, 1.0 };
    GLfloat mat_specular[] = { 0.9, 0.9, 0.9, 1.0 };
    GLfloat mat_shininess[] = { 128.0 };

    glClearColor (0.0, 0.0, 0.0, 1.0);
    glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
    glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
    glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);

    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);
    glDepthFunc(GL_LESS);
    glEnable(GL_DEPTH_TEST);
    glEnable(GL_AUTO_NORMAL);
    glEnable(GL_NORMALIZE);

    init_surface();

    theNurb = gluNewNurbsRenderer();
    gluNurbsProperty(theNurb, GLU_SAMPLING_TOLERANCE, 50.0);
    gluNurbsProperty(theNurb, GLU_DISPLAY_MODE, GLU_FILL);
}

void display(void)
{
    GLfloat knots[8] = {0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0};
    GLfloat edgePt[5][2] = /* counter clockwise */
    {{0.0, 0.0}, {1.0, 0.0}, {1.0, 1.0}, {0.0, 1.0}, {0.0, 0.0}};
    GLfloat curvePt[4][2] = /* clockwise */ 
    {{0.25, 0.5}, {0.25, 0.75}, {0.75, 0.75}, {0.75, 0.5}};
    GLfloat curveKnots[8] = 
	{0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0};
    GLfloat pwlPt[4][2] = /* clockwise */ 
	{{0.75, 0.5}, {0.5, 0.25}, {0.25, 0.5}};

    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glPushMatrix();
    glRotatef(330.0, 1.,0.,0.);
    glScalef (0.5, 0.5, 0.5);

    gluBeginSurface(theNurb);
    gluNurbsSurface(theNurb, 
	    8, knots,
	    8, knots,
	    4 * 3,
	    3,
	    &ctlpoints[0][0][0], 
	    4, 4,
	    GL_MAP2_VERTEX_3);
    gluBeginTrim (theNurb);
	gluPwlCurve (theNurb, 5, &edgePt[0][0], 2, GLU_MAP1_TRIM_2);
    gluEndTrim (theNurb);
    gluBeginTrim (theNurb);
	gluNurbsCurve (theNurb, 8, curveKnots, 2, 
		&curvePt[0][0], 4, GLU_MAP1_TRIM_2);
	gluPwlCurve (theNurb, 3, &pwlPt[0][0], 2, GLU_MAP1_TRIM_2);
    gluEndTrim (theNurb);
    gluEndSurface(theNurb);
        
    glPopMatrix();
    glFlush();
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluPerspective (45.0, (GLdouble)w/(GLdouble)h, 3.0, 8.0);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    glTranslatef (0.0, 0.0, -5.0);
}

/*  Main Loop 
 */
int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB | AUX_DEPTH16);
    auxInitPosition (0, 0, 500, 500);
    auxInitWindow (argv[0]);
    myinit();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\tri2.c ===
/* A simple triangle program */

#include <windows.h>
#include <stdio.h>
#include <GL/gl.h>
#include "glaux.h"

void display(void)
{
printf("display called\n");
    glClear(GL_COLOR_BUFFER_BIT);

    glBegin(GL_TRIANGLES);
        glColor3f(1.0F, 0.0F, 0.0F);
        glVertex2f(10.0F, 10.0F);

        glColor3f(0.0F, 1.0F, 0.0F);
        glVertex2f(250.0F, 50.0F);

        glColor3f(0.0F, 0.0F, 1.0F);
        glVertex2f(105.0F, 280.0F);
    glEnd();

    glFlush();
}

void myinit(void)
{
    glClearColor(0.0F, 0.0F, 0.4F, 1.0F);
    glShadeModel(GL_SMOOTH);
    glDisable(GL_DITHER);
}

void apressed(key, mask)
{
    printf("key is %d, mask is 0x%x\n", key, mask);
}

void LeftPressed(AUX_EVENTREC *event)
{
    printf("Left pressed (%d, %d)\n", event->data[AUX_MOUSEX],
		event->data[AUX_MOUSEY]);
}

void LeftReleased(AUX_EVENTREC *event)
{
    printf("Left released (%d, %d)\n", event->data[AUX_MOUSEX],
		event->data[AUX_MOUSEY]);
}

int main(int argc, char *argv[])
{
    auxInitDisplayMode(AUX_SINGLE | AUX_RGBA | AUX_FIXED_332_PAL);
    auxInitPosition(100, 150, 300, 300);
    auxInitWindow("Tri w/ fixed 332 pal");
    myinit();

    auxKeyFunc(AUX_a, apressed);
    auxMouseFunc(AUX_LEFTBUTTON, AUX_MOUSEDOWN, LeftPressed);
    auxMouseFunc(AUX_LEFTBUTTON, AUX_MOUSEUP, LeftReleased);

    auxMainLoop(display);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\tri.c ===
/* A simple triangle program */

#include <windows.h>
#include <stdio.h>
#include <GL/gl.h>
#include "glaux.h"

void display(void)
{
printf("display called\n");
    glClear(GL_COLOR_BUFFER_BIT);

    glBegin(GL_TRIANGLES);
        glColor3f(1.0F, 0.0F, 0.0F);
        glVertex2f(10.0F, 10.0F);

        glColor3f(0.0F, 1.0F, 0.0F);
        glVertex2f(250.0F, 50.0F);

        glColor3f(0.0F, 0.0F, 1.0F);
        glVertex2f(105.0F, 280.0F);
    glEnd();

    glFlush();
}

void myinit(void)
{
    glClearColor(0.0F, 0.0F, 0.4F, 1.0F);
    glShadeModel(GL_SMOOTH);
    glDisable(GL_DITHER);
}

void apressed(key, mask)
{
    printf("key is %d, mask is 0x%x\n", key, mask);
}

void LeftPressed(AUX_EVENTREC *event)
{
    printf("Left pressed (%d, %d)\n", event->data[AUX_MOUSEX],
		event->data[AUX_MOUSEY]);
}

void LeftReleased(AUX_EVENTREC *event)
{
    printf("Left released (%d, %d)\n", event->data[AUX_MOUSEX],
		event->data[AUX_MOUSEY]);
}

int main(int argc, char *argv[])
{
    auxInitDisplayMode(AUX_SINGLE | AUX_RGBA);
    auxInitPosition(100, 150, 300, 300);
    auxInitWindow("Tri");
    myinit();

    auxKeyFunc(AUX_a, apressed);
    auxMouseFunc(AUX_LEFTBUTTON, AUX_MOUSEDOWN, LeftPressed);
    auxMouseFunc(AUX_LEFTBUTTON, AUX_MOUSEUP, LeftReleased);

    auxMainLoop(display);

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\vaperf.c ===
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <time.h>
#include <float.h>

#include <windows.h>
#include <gl\gl.h>
#include <gl\glu.h>
#include <gl\glaux.h>

// #define PROFILE 1
#ifdef PROFILE
#include <icapexp.h>
#endif

typedef struct
{
    float x, y, z;
    float nx, ny, nz;
    float tu, tv;
    DWORD color;
} D3DVERTEX;
typedef D3DVERTEX *LPD3DVERTEX;

typedef struct
{
    int v1;
    int v2;
    int v3;
} D3DTRIANGLE;
typedef D3DTRIANGLE *LPD3DTRIANGLE;

#define D3DVAL(f) ((float)(f))
#define RGB_MAKE(r, g, b) \
    (((DWORD)((r) & 0xff) <<  0) | \
     ((DWORD)((g) & 0xff) <<  8) | \
     ((DWORD)((b) & 0xff) << 16) | \
     ((DWORD)(0xff)       << 24))

typedef float __GLfloat;

typedef struct
{
    __GLfloat matrix[4][4];
} __GLmatrix;

__GLmatrix identity =
{
    1.0f, 0.0f, 0.0f, 0.0f,
    0.0f, 1.0f, 0.0f, 0.0f,
    0.0f, 0.0f, 1.0f, 0.0f,
    0.0f, 0.0f, 0.0f, 1.0f
};

void __glMultMatrix(__GLmatrix *r, const __GLmatrix *a, const __GLmatrix *b)
{
    __GLfloat b00, b01, b02, b03;
    __GLfloat b10, b11, b12, b13;
    __GLfloat b20, b21, b22, b23;
    __GLfloat b30, b31, b32, b33;
    GLint i;

    b00 = b->matrix[0][0]; b01 = b->matrix[0][1];
        b02 = b->matrix[0][2]; b03 = b->matrix[0][3];
    b10 = b->matrix[1][0]; b11 = b->matrix[1][1];
        b12 = b->matrix[1][2]; b13 = b->matrix[1][3];
    b20 = b->matrix[2][0]; b21 = b->matrix[2][1];
        b22 = b->matrix[2][2]; b23 = b->matrix[2][3];
    b30 = b->matrix[3][0]; b31 = b->matrix[3][1];
        b32 = b->matrix[3][2]; b33 = b->matrix[3][3];

    for (i = 0; i < 4; i++) {
	r->matrix[i][0] = a->matrix[i][0]*b00 + a->matrix[i][1]*b10
	    + a->matrix[i][2]*b20 + a->matrix[i][3]*b30;
	r->matrix[i][1] = a->matrix[i][0]*b01 + a->matrix[i][1]*b11
	    + a->matrix[i][2]*b21 + a->matrix[i][3]*b31;
	r->matrix[i][2] = a->matrix[i][0]*b02 + a->matrix[i][1]*b12
	    + a->matrix[i][2]*b22 + a->matrix[i][3]*b32;
	r->matrix[i][3] = a->matrix[i][0]*b03 + a->matrix[i][1]*b13
	    + a->matrix[i][2]*b23 + a->matrix[i][3]*b33;
    }
}

void MakePosMatrix(__GLmatrix *lpM, float x, float y, float z)
{
    memcpy(lpM, &identity, sizeof(__GLmatrix));
    lpM->matrix[3][0] = D3DVAL(x);
    lpM->matrix[3][1] = D3DVAL(y);
    lpM->matrix[3][2] = D3DVAL(z);
}

void MakeRotMatrix(__GLmatrix *lpM, float rx, float ry, float rz)
{
    float ct, st;
    __GLmatrix My, Mx, Mz, T;
    memcpy(&My, &identity, sizeof(__GLmatrix));
    ct = D3DVAL(cos(ry));
    st = D3DVAL(sin(ry));
    My.matrix[0][0] = ct;
    My.matrix[0][2] = -st;
    My.matrix[2][0] = st;
    My.matrix[2][2] = ct;
    memcpy(&Mx, &identity, sizeof(__GLmatrix));
    ct = D3DVAL(cos(rx));
    st = D3DVAL(sin(rx));
    Mx.matrix[1][1] = ct;
    Mx.matrix[1][2] = st;
    Mx.matrix[2][1] = -st;
    Mx.matrix[2][2] = ct;
    memcpy(&Mz, &identity, sizeof(__GLmatrix));
    ct = D3DVAL(cos(rz));
    st = D3DVAL(sin(rz));
    Mz.matrix[0][0] = ct;
    Mz.matrix[0][1] = st;
    Mz.matrix[1][0] = -st;
    Mz.matrix[1][1] = ct;
    __glMultMatrix(&T, &My, &Mx);
    __glMultMatrix(lpM, &T, &Mz);
}

void *Malloc(size_t bytes)
{
    void *pv;

    pv = malloc(bytes);
    if (pv == NULL)
    {
        printf("Unable to alloc %d bytes\n", bytes);
        exit(1);
    }
    return pv;
}

#define PI ((float)3.14159265358979323846)

#define WIDTH 400
#define HEIGHT 400

#define SPWIDTH 140
#define SPHEIGHT 140

#define MAWIDTH 90
#define MAHEIGHT 75

#define LAWIDTH 230
#define LAHEIGHT 190

int iSwapWidth, iSwapHeight;

#define SRADIUS 0.4f
#define DMINUSR 0.6
#define DV 0.05
#define DR 0.3
#define DEPTH 0.6f
#define random(x) (((float)rand() / RAND_MAX) * (x))

#define FILL_TRIANGLES 50

#define MEDIUM_AREA     3000
#define LARGE_AREA      20000

#define FRONT_TO_BACK   0
#define BACK_TO_FRONT   1
#define ORDER_COUNT     2
int iOrder = FRONT_TO_BACK;
char *pszOrders[] =
{
    "front-to-back",
    "back-to-front"
};

#define AREA_LARGE      0
#define AREA_MEDIUM     1
#define AREA_COUNT      2
int iFillSize = AREA_MEDIUM;

int iTriangleArea;

typedef struct _Sphere
{
    GLfloat xrv, yrv, zrv;
    __GLmatrix pos, dpos;
    __GLmatrix rot, drot;
} Sphere;

#define NSPHERES 8
Sphere spheres[NSPHERES];

BOOL fSingle = FALSE;
BOOL fRotate = TRUE;
BOOL fBounce = TRUE;
BOOL fSwap = TRUE;
BOOL fPaused = FALSE;
BOOL fUseScissor = TRUE;
BOOL fSpread = FALSE;
BOOL fExit = FALSE;
BOOL fSingleColor = TRUE;
BOOL fVerbose = FALSE;
BOOL fDisplayList = TRUE;
int iMultiLoop = 1;

int nRings = 30;
int nSections = 30;

GLint iDlist;

#define TEXOBJ

#ifdef TEXOBJ
GLuint uiTexObj;
#endif

PFNGLADDSWAPHINTRECTWINPROC glAddSwapHintRectWIN;

#define TEST_FILL       0
#define TEST_POLYS      1
#define TEST_COUNT      2

int iTest = TEST_POLYS;

AUX_RGBImageRec *pTexture;

#define TEXMODE_REPLACE         0
#define TEXMODE_DECAL           1
#define TEXMODE_MODULATE        2
#define TEXMODE_COUNT           3
int iTexMode = TEXMODE_REPLACE;
char *pszTexModes[] =
{
    "replace", "decal", "modulate"
};
GLenum eTexModes[] =
{
    GL_REPLACE, GL_DECAL, GL_MODULATE
};

BOOL fPerspective = TRUE;

//--------------------------------------------------------------------------;
//
//  FunctionName: GenerateSphere()
//
//  Purpose:
//      Generate the geometry of a sphere.
//
//  Returns BOOL
//
//  History:
//       11/17/95    RichGr
//
//--------------------------------------------------------------------------;
/*
 * Generates a sphere around the y-axis centered at the origin including
 * normals and texture coordinates.  Returns TRUE on success and FALSE on
 * failure.
 *     sphere_r     Radius of the sphere.
 *     num_rings    Number of full rings not including the top and bottom
 *		    caps.
 *     num_sections Number of sections each ring is divided into.  Each
 *		    section contains two triangles on full rings and one 
 *		    on top and bottom caps.
 *     sx, sy, sz   Scaling along each axis.  Set each to 1.0 for a 
 *		    perfect sphere. 
 *     plpv         On exit points to the vertices of the sphere.  The
 *		    function allocates this space.  Not allocated if
 *		    function fails.
 *     plptri       On exit points to the triangles of the sphere which 
 *		    reference vertices in the vertex list.  The function
 *		    allocates this space. Not allocated if function fails.
 *     pnum_v       On exit contains the number of vertices.
 *     pnum_tri     On exit contains the number of triangles.
 */
BOOL GenerateSphere(float sphere_r, int num_rings, int num_sections,
                    float sx, float sy, float sz, LPD3DVERTEX* plpv, 
                    LPD3DTRIANGLE* plptri, int* pnum_v, int* pnum_tri)
{
    float               theta, phi;             /* Angles used to sweep around sphere */
    float               dtheta, dphi;           /* Angle between each section and ring */
    float               x, y, z, v, rsintheta;  /* Temporary variables */
    int                 i, j, n, m;             /* counters */
    int                 num_v, num_tri;         /* Internal vertex and triangle count */
    LPD3DVERTEX         lpv;                    /* Internal pointer for vertices */
    LPD3DTRIANGLE       lptri;                  /* Internal pointer for trianlges */

    /*
     * Check the parameters to make sure they are valid.
     */
    if ((sphere_r <= 0)
        || (num_rings < 1)
        || (num_sections < 3)
        || (sx <= 0) || (sy <= 0) || (sz <= 0))
        return FALSE;
   
    /*
     * Generate space for the required triangles and vertices.
     */
    num_tri = (num_rings + 1) * num_sections * 2;
    num_v = (num_rings + 1) * num_sections + 2;
    *plpv = (LPD3DVERTEX)Malloc(sizeof(D3DVERTEX) * num_v);
    *plptri = (LPD3DTRIANGLE)Malloc(sizeof(D3DTRIANGLE) * num_tri);
    lpv = *plpv;
    lptri = *plptri;
    *pnum_v = num_v;
    *pnum_tri = num_tri;

    /*
     * Generate vertices at the top and bottom points.
     */
    lpv[0].x = D3DVAL(0.0f);
    lpv[0].y = D3DVAL(sy * sphere_r);
    lpv[0].z = D3DVAL(0.0f);
    lpv[0].nx = D3DVAL(0.0f);
    lpv[0].ny = D3DVAL(1.0f);
    lpv[0].nz = D3DVAL(0.0f);
    lpv[0].color = RGB_MAKE(0, 0, 255);
    lpv[0].tu = D3DVAL(0.0f);
    lpv[0].tv = D3DVAL(0.0f);
    lpv[num_v - 1].x = D3DVAL(0.0f);
    lpv[num_v - 1].y = D3DVAL(sy * -sphere_r);
    lpv[num_v - 1].z = D3DVAL(0.0f);
    lpv[num_v - 1].nx = D3DVAL(0.0f);
    lpv[num_v - 1].ny = D3DVAL(-1.0f);
    lpv[num_v - 1].nz = D3DVAL(0.0f);
    lpv[num_v - 1].tu = D3DVAL(0.0f);
    lpv[num_v - 1].tv = D3DVAL(1.0f);
    lpv[num_v - 1].color = RGB_MAKE(0, 255, 0);

    /*
     * Generate vertex points for rings
     */
    dtheta = PI / (float) (num_rings + 2);
    dphi = 2.0f * PI / (float) num_sections;
    n = 1; /* vertex being generated, begins at 1 to skip top point */
    theta = dtheta;

    for (i = 0; i <= num_rings; i++)
    {
	    y = (float)(sphere_r * cos(theta)); /* y is the same for each ring */
	    v = theta / PI; 	   /* v is the same for each ring */
	    rsintheta = (float)(sphere_r * sin(theta));
	    phi = 0.0f;
	
        for (j = 0; j < num_sections; j++)
        {
	        x = (float)(rsintheta * sin(phi));
	        z = (float)(rsintheta * cos(phi));
	        lpv[n].x = D3DVAL(sx * x);
	        lpv[n].z = D3DVAL(sz * z);
	        lpv[n].y = D3DVAL(sy * y);
	        lpv[n].nx = D3DVAL(x / sphere_r);
	        lpv[n].ny = D3DVAL(y / sphere_r);
	        lpv[n].nz = D3DVAL(z / sphere_r);
	        lpv[n].tv = D3DVAL(v);
	        lpv[n].tu = D3DVAL(1.0f - phi / (2.0f * PI));
                if (n & 1)
                {
                    lpv[n].color = RGB_MAKE(0, 0, 255);
                }
                else
                {
                    lpv[n].color = RGB_MAKE(0, 255, 0);
                }
	        phi += dphi;
	        ++n;
	    }
	
        theta += dtheta;
    }

    /*
     * Generate triangles for top and bottom caps.
     */
    for (i = 0; i < num_sections; i++)
    {
	    lptri[i].v1 = 0;
	    lptri[i].v2 = i + 1;
	    lptri[i].v3 = 1 + ((i + 1) % num_sections);
	    // lptri[i].flags = D3D_EDGE_ENABLE_TRIANGLE;
	    lptri[num_tri - num_sections + i].v1 = num_v - 1;
	    lptri[num_tri - num_sections + i].v2 = num_v - 2 - i;
	    lptri[num_tri - num_sections + i].v3 = num_v - 2 - ((1 + i) % num_sections);
	    // lptri[num_tri - num_sections + i].flags= D3D_EDGE_ENABLE_TRIANGLE;
    }

    /*
     * Generate triangles for the rings
     */
    m = 1; /* first vertex in current ring,begins at 1 to skip top point*/
    n = num_sections; /* triangle being generated, skip the top cap */
	
    for (i = 0; i < num_rings; i++)
    {
	    for (j = 0; j < num_sections; j++)
        {
	        lptri[n].v1 = m + j;
	        lptri[n].v2 = m + num_sections + j;
	        lptri[n].v3 = m + num_sections + ((j + 1) % num_sections);
	        // lptri[n].flags = D3D_EDGE_ENABLE_TRIANGLE;
	        lptri[n + 1].v1 = lptri[n].v1;
	        lptri[n + 1].v2 = lptri[n].v3;
	        lptri[n + 1].v3 = m + ((j + 1) % num_sections);
	        // lptri[n + 1].flags = D3D_EDGE_ENABLE_TRIANGLE;
	        n += 2;
	    }
	
        m += num_sections;
    }
    
    return TRUE;
}

// Creates triangle and quad strip index sets for vertex data generated
// by GenerateSphere.  The top and bottom triangle fans are omitted because
// they're degenerate cases for strips
int CreateStrip(int nSections, int **ppiStrip)
{
    int nPts;
    int *piIdx, iIdxBase;
    int iRing, iSection;

    // Stick to a single strip for now
    nRings = 1;
    
    nPts = nRings*(nSections+1)*2;

    *ppiStrip = (int *)Malloc(sizeof(int)*nPts);

    piIdx = *ppiStrip;
    iIdxBase = 1;
    for (iRing = 0; iRing < nRings; iRing++)
    {
        for (iSection = 0; iSection <= nSections; iSection++)
        {
            *piIdx++ = iIdxBase+(iSection % nSections);
            *piIdx++ = iIdxBase+(iSection % nSections)+nSections;
        }

        iIdxBase += nSections;
    }

    return nPts;
}

float fltCenter[NSPHERES][2] =
{
    -SRADIUS, 0.0f,
    0.0f, SRADIUS,
    SRADIUS, 0.0f,
    0.0f, -SRADIUS
};

void InitSpheres(void)
{
    int i;
    Sphere *sp;
    float x, y, z;

#if 0
    srand(time(NULL));
#else
    srand( (unsigned)8269362521);
#endif
    for (i = 0; i < NSPHERES; i++)
    {
        sp = &spheres[i];

        if (fBounce)
        {
            x = (float)DMINUSR - (float)random(2 * DMINUSR);
            y = (float)DMINUSR - (float)random(2 * DMINUSR);
            z = (float)-DEPTH + (float)random(2 * DEPTH);
        }
        else
        {
            x = fltCenter[i][0];
            y = fltCenter[i][1];
            z = 0.0f;
        }
        MakePosMatrix(&sp->pos, x, y, z);
        x = (float)DV - (float)random(2 * DV);
        y = (float)DV - (float)random(2 * DV);
        z = (float)DV - (float)random(2 * DV);
        MakePosMatrix(&sp->dpos, x, y, z);

        MakeRotMatrix(&sp->rot, 0.0f, 0.0f, 0.0f);
        sp->xrv = (float)DR - (float)random(2 * DR);
        sp->yrv = (float)DR - (float)random(2 * DR);
        sp->zrv = (float)DR - (float)random(2 * DR);
        MakeRotMatrix(&sp->drot, sp->xrv, sp->yrv, sp->zrv);
    }
}

void UpdateSphere(Sphere *sp)
{
    GLboolean newRot;
    
    if (fBounce)
    {
        newRot = GL_FALSE;
        if (sp->pos.matrix[3][0] > DMINUSR || sp->pos.matrix[3][0] < -DMINUSR)
        {
            sp->dpos.matrix[3][0] = -sp->dpos.matrix[3][0];
            sp->zrv = -sp->zrv;
            sp->yrv = -sp->yrv;
            newRot = GL_TRUE;
        }
        if (sp->pos.matrix[3][1] > DMINUSR || sp->pos.matrix[3][1] < -DMINUSR)
        {
            sp->dpos.matrix[3][1] = -sp->dpos.matrix[3][1];
            sp->zrv = -sp->zrv;
            sp->xrv = -sp->xrv;
            newRot = GL_TRUE;
        }
        if (sp->pos.matrix[3][2] > DEPTH || sp->pos.matrix[3][2] < -DEPTH)
        {
            sp->dpos.matrix[3][2] = -sp->dpos.matrix[3][2];
            sp->xrv = -sp->xrv;
            sp->yrv = -sp->yrv;
            newRot = GL_TRUE;
        }

        if (newRot)
        {
            MakeRotMatrix(&sp->drot, sp->xrv, sp->yrv, sp->zrv);
        }
        
        __glMultMatrix(&sp->pos, &sp->dpos, &sp->pos);
    }
    
    if (fRotate)
    {
        __glMultMatrix(&sp->rot, &sp->drot, &sp->rot);
    }
}

#define TAN_60 1.732

void SetTriangleVertices(LPD3DVERTEX v, float z, UINT ww, UINT wh, float a,
                         int ox, int oy)
{
    float dx, dy;
    float b = (float)sqrt((4 * a) / TAN_60);
    float h = (2 * a) / b;
    float x = (float)((b / 2) * (TAN_60 / 2));
    float cx, cy;
    
    dx = (float)ww;
    dy = (float)wh;
    
    cx = dx / 2 + ox;
    cy = dy / 2 + oy;
    
    /* V 0 */
    v[0].x = cx;
    v[0].y = cy + (h - x);
    v[0].z = z;
    v[0].color = RGB_MAKE(255, 0, 0);
    v[0].tu = D3DVAL(0.5);
    v[0].tv = D3DVAL(0.0);
    /* V 1 */
    v[1].x = cx + (b / 2);
    v[1].y = cy - x;
    v[1].z = z;
    v[1].color = RGB_MAKE(255, 255, 255);
    v[1].tu = D3DVAL(1.0);
    v[1].tv = D3DVAL(1.0);
    /* V 2 */
    v[2].x = cx - (b / 2);
    v[2].y = cy - x;
    v[2].z = z;
    v[2].color = RGB_MAKE(255, 255, 0);
    v[2].tu = D3DVAL(0.0);
    v[2].tv = D3DVAL(1.0);
}

void InitFill(LPD3DVERTEX *ppVertices, LPD3DTRIANGLE *ppTriangles)
{
    *ppVertices = (LPD3DVERTEX)Malloc(3 * FILL_TRIANGLES * sizeof(D3DVERTEX));
    *ppTriangles = (LPD3DTRIANGLE)Malloc(FILL_TRIANGLES * sizeof(D3DTRIANGLE));
}

D3DVERTEX *pPolyVertices;
D3DTRIANGLE *pPolyTriangles;
int nNumVertices, nNumFaces;
int *pPolyStrip;
int nStripIndices;

D3DVERTEX *pFillVertices;
D3DTRIANGLE *pFillTriangles;

int *pIndices;
int nIndices;
int nTriangles;

#define POLYMODE_POINT          0
#define POLYMODE_LINE           1
#define POLYMODE_FILL           2
#define POLYMODE_COUNT          3

GLenum ePolygonModes[] =
{
    GL_POINT, GL_LINE, GL_FILL
};
int iPolygonMode = POLYMODE_FILL;

#define SMODEL_SMOOTH           0
#define SMODEL_FLAT             1
#define SMODEL_COUNT            2

GLenum eShadeModels[] =
{
    GL_SMOOTH, GL_FLAT
};
char *pszShadeModels[] =
{
    "smooth", "flat"
};
int iShadeModel = SMODEL_SMOOTH;

#define PRIM_TRIANGLES          0
#define PRIM_TSTRIP             1
#define PRIM_QSTRIP             2
#define PRIM_COUNT              3

GLenum ePrimTypes[] =
{
    GL_TRIANGLES, GL_TRIANGLE_STRIP, GL_QUAD_STRIP
};
char *pszPrimTypes[] =
{
    "Tris",
    "TStrip",
    "QStrip"
};
int iPrimType = PRIM_TRIANGLES;

int total_ms = 0;
int total_tris = 0 ;

double peak_tri = 0, peak_fill = 0, avg_tri = 0, avg_fill = 0;
int avg_cnt = 0;

void ModeChange(void)
{
    total_ms = 0;
    total_tris = 0;
    avg_tri = 0;
    avg_fill = 0;
    avg_cnt = 0;
}

void SetPrim(int iNew)
{
    ModeChange();
    
    iPrimType = iNew;
    switch(iTest)
    {
    case TEST_POLYS:
        switch(iPrimType)
        {
        case PRIM_TRIANGLES:
            pIndices = (int *)pPolyTriangles;
            nIndices = nNumFaces*3;
            nTriangles = nNumFaces;
            break;
        case PRIM_TSTRIP:
        case PRIM_QSTRIP:
            pIndices = pPolyStrip;
            nIndices = nStripIndices;
            nTriangles = nSections*2;
            break;
        }
        nTriangles *= NSPHERES;
        break;

    case TEST_FILL:
        pIndices = (int *)pFillTriangles;
        nIndices = FILL_TRIANGLES*3;
        nTriangles = FILL_TRIANGLES;
        break;
    }
}

void SetVertexArrayVertices(LPD3DVERTEX pVertices)
{
    glVertexPointer(3, GL_FLOAT, sizeof(D3DVERTEX), &pVertices[0].x);
    glNormalPointer(GL_FLOAT, sizeof(D3DVERTEX), &pVertices[0].nx);
    glTexCoordPointer(2, GL_FLOAT, sizeof(D3DVERTEX), &pVertices[0].tu);
    glColorPointer(4, GL_UNSIGNED_BYTE, sizeof(D3DVERTEX),
                   &pVertices[0].color);
}

void SetFill(int iNewSize, int iNewOrder)
{
    int i;
    float z;
    int NumTri;
    LPD3DVERTEX pVert;
    LPD3DTRIANGLE pTri;
    UINT w, h;
    float area;
    int ox, oy, dox, doy;
    RECT rct;
    
    ModeChange();
    
    iFillSize = iNewSize;
    iOrder = iNewOrder;
    
    switch(iFillSize)
    {
    case AREA_LARGE:
        iTriangleArea = LARGE_AREA;
        iSwapWidth = LAWIDTH;
        iSwapHeight = LAHEIGHT;
        break;
    case AREA_MEDIUM:
        iTriangleArea = MEDIUM_AREA;
        iSwapWidth = MAWIDTH;
        iSwapHeight = MAHEIGHT;
        break;
    }
    glScissor((WIDTH-iSwapWidth)/2, (HEIGHT-iSwapHeight)/2,
              iSwapWidth, iSwapHeight);
        
    w = WIDTH;
    h = HEIGHT;
    NumTri = FILL_TRIANGLES;

    pVert = pFillVertices;
    if (fSpread)
    {
        ox = -NumTri*2;
        oy = -NumTri*2;
        dox = 4;
        doy = 4;
    }
    else
    {
        ox = 0;
        oy = 0;
        dox = 0;
        doy = 0;
    }
    if (iOrder == FRONT_TO_BACK)
    {
	for (i = 0, z = (float)0.0; i < NumTri; i++, z -= (float)0.9 / NumTri)
        {
	    SetTriangleVertices(pVert, z, w, h, (float)iTriangleArea,
                                ox, oy);
            pVert += 3;
            ox += dox;
            oy += doy;
        }
    }
    else
    {
	for (i = 0, z = (float)-0.9; i < NumTri; i++, z += (float)0.9 / NumTri)
        {
	    SetTriangleVertices(pVert, z, w, h, (float)iTriangleArea,
                                ox, oy);
            pVert += 3;
            ox += dox;
            oy += doy;
        }
    }

    pTri = pFillTriangles;
    for (i = 0; i < NumTri; i++)
    {
        pTri->v1 = i*3;
        pTri->v2 = i*3+1;
        pTri->v3 = i*3+2;
        pTri++;
    }

    GetClientRect(auxGetHWND(), &rct);
    FillRect(auxGetHDC(), &rct, GetStockObject(BLACK_BRUSH));
}

static __GLmatrix proj = {
    D3DVAL(2.0), D3DVAL(0.0), D3DVAL(0.0), D3DVAL(0.0),
    D3DVAL(0.0), D3DVAL(2.0), D3DVAL(0.0), D3DVAL(0.0),
    D3DVAL(0.0), D3DVAL(0.0), D3DVAL(1.0), D3DVAL(1.0),
    D3DVAL(0.0), D3DVAL(0.0), D3DVAL(-1.0), D3DVAL(0.0)
};
static __GLmatrix view = {
    D3DVAL(1.0), D3DVAL(0.0), D3DVAL(0.0), D3DVAL(0.0),
    D3DVAL(0.0), D3DVAL(1.0), D3DVAL(0.0), D3DVAL(0.0),
    D3DVAL(0.0), D3DVAL(0.0), D3DVAL(1.0), D3DVAL(0.0),
    D3DVAL(0.0), D3DVAL(0.0), D3DVAL(7.0), D3DVAL(1.0)
};

void SetTest(int iNew)
{
    RECT rct;

    ModeChange();
    
    iTest = iNew;
    switch(iTest)
    {
    case TEST_POLYS:
        glDisableClientState(GL_COLOR_ARRAY);
        glEnable(GL_LIGHTING);
        glEnable(GL_CULL_FACE);
        iTexMode = TEXMODE_REPLACE;
        glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, eTexModes[iTexMode]);
        glMatrixMode(GL_PROJECTION);
        glLoadIdentity();
#if 0
        gluPerspective(45, 1, .01, 15);
        gluLookAt(0, 0, 8, 0, 0, 0, 0, 1, 0);
#else
        glLoadMatrixf((float *)&proj);
        glMultMatrixf((float *)&view);
        glDepthRange(1, 0);
#endif
        glMatrixMode(GL_MODELVIEW);
        SetVertexArrayVertices(pPolyVertices);
        iSwapWidth = SPWIDTH;
        iSwapHeight = SPHEIGHT;
        glScissor((WIDTH-iSwapWidth)/2, (HEIGHT-iSwapHeight)/2,
                  iSwapWidth, iSwapHeight);
        break;

    case TEST_FILL:
        glEnableClientState(GL_COLOR_ARRAY);
        glDisable(GL_LIGHTING);
        glDisable(GL_CULL_FACE);
        iTexMode = TEXMODE_MODULATE;
        glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, eTexModes[iTexMode]);
        glMatrixMode(GL_PROJECTION);
        glLoadIdentity();
        glOrtho(0, WIDTH, 0, HEIGHT, 0.0f, 1.0f);
        glMatrixMode(GL_MODELVIEW);
        glLoadIdentity();
        SetVertexArrayVertices(pFillVertices);
        SetFill(iFillSize, iOrder);
        break;
    }

    SetPrim(iPrimType);

    GetClientRect(auxGetHWND(), &rct);
    FillRect(auxGetHDC(), &rct, GetStockObject(BLACK_BRUSH));
}

void Init(void)
{
    float fv4[4];
    int iPrim, iOldPrim;
    
    if (!GenerateSphere(SRADIUS, nRings, nSections, 1.0f, 1.0f, 1.0f,
                        &pPolyVertices, &pPolyTriangles,
                        &nNumVertices, &nNumFaces))
    {
        printf("Unable to generate sphere data\n");
        exit(1);
    }
    nStripIndices = CreateStrip(nSections, &pPolyStrip);

    InitSpheres();

    InitFill(&pFillVertices, &pFillTriangles);
    
    fv4[0] = 0.05f;
    fv4[1] = 0.05f;
    fv4[2] = 0.05f;
    fv4[3] = 1.0f;
    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, fv4);
    
    fv4[0] = 0.0f;
    fv4[1] = 1.0f;
    fv4[2] = 1.0f;
    fv4[3] = 0.0f;
    glLightfv(GL_LIGHT0, GL_POSITION, fv4);
    fv4[0] = 0.9f;
    fv4[1] = 0.9f;
    fv4[2] = 0.9f;
    fv4[3] = 1.0f;
    glLightfv(GL_LIGHT0, GL_DIFFUSE, fv4);
    glEnable(GL_LIGHT0);
    
    glEnable(GL_LIGHTING);
    
    glEnableClientState(GL_VERTEX_ARRAY);
    glEnableClientState(GL_NORMAL_ARRAY);
    glEnableClientState(GL_TEXTURE_COORD_ARRAY);

    if (!fSingleColor)
    {
        glEnableClientState(GL_COLOR_ARRAY);
        glColorMaterial(GL_FRONT, GL_AMBIENT_AND_DIFFUSE);
        glEnable(GL_COLOR_MATERIAL);
    }

    glEnable(GL_CULL_FACE);

    glEnable(GL_DEPTH_TEST);

#ifdef TEXOBJ
    glGenTextures(1, &uiTexObj);
    glBindTexture(GL_TEXTURE_2D, uiTexObj);
#endif
    
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
    glTexImage2D(GL_TEXTURE_2D, 0, 3, pTexture->sizeX, pTexture->sizeY, 0,
                 GL_RGB, GL_UNSIGNED_BYTE, pTexture->data);

    glEnable(GL_TEXTURE_2D);

    glDisable(GL_DITHER);
#ifdef GL_EXT_clip_volume
    glHint(GL_CLIP_VOLUME_CLIPPING_HINT_EXT, GL_FASTEST);
#endif
    
    SetTest(iTest);

    glClear(GL_COLOR_BUFFER_BIT);

    if (fDisplayList)
    {
        iDlist = glGenLists(3);
        iOldPrim = iPrimType;
        for (iPrim = 0; iPrim < PRIM_COUNT; iPrim++)
        {
            SetPrim(iPrim);
            glNewList(iDlist+iPrim, GL_COMPILE);
            glDrawElements(ePrimTypes[iPrim], nIndices,
                           GL_UNSIGNED_INT, pIndices);
            glEndList();
        }
        SetPrim(iOldPrim);
    }
}

void Redraw(void)
{
    DWORD ms;
    int i;
    Sphere *sp;
    float fv4[4];
    int iv1[1];
    int loop;
    __GLmatrix xform;

    ms = GetTickCount();

    for (loop = 0; loop < iMultiLoop; loop++)
    {
#if PROFILE
        if (loop > 0)
        {
            StartCAP();
        }
#endif
    
        if (fUseScissor)
        {
            glEnable(GL_SCISSOR_TEST);
            
            if (glAddSwapHintRectWIN != NULL)
            {
                glAddSwapHintRectWIN((WIDTH-iSwapWidth)/2,
                                     (HEIGHT-iSwapHeight)/2,
                                     iSwapWidth, iSwapHeight);
            }
        }
    
        if (glIsEnabled(GL_DEPTH_TEST))
        {
            glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
        }
        else
        {
            glClear(GL_COLOR_BUFFER_BIT);
        }

        if (fUseScissor)
        {
            glDisable(GL_SCISSOR_TEST);
        }

        if (fSingleColor && iTest == TEST_POLYS)
        {
            fv4[0] = 1.0f;
            fv4[1] = 1.0f;
            fv4[2] = 1.0f;
            fv4[3] = 1.0f;
            glMaterialfv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, fv4);
        }

        fv4[0] = 0.6f;
        fv4[1] = 0.6f;
        fv4[2] = 0.6f;
        fv4[3] = 1.0f;
        glMaterialfv(GL_FRONT, GL_SPECULAR, fv4);
        iv1[0] = 40;
        glMaterialiv(GL_FRONT, GL_SHININESS, iv1);
    
        switch(iTest)
        {
        case TEST_POLYS:
            sp = &spheres[0];
            for (i = 0; i < NSPHERES; i++)
            {
                UpdateSphere(sp);
        
                // Always done to even out timings
#if 1
                __glMultMatrix(&xform, &sp->rot, &sp->pos);
#else
                __glMultMatrix(&xform, &sp->pos, &sp->rot);
#endif
                if (fBounce && fRotate)
                {
                    glLoadMatrixf(&xform.matrix[0][0]);
                }
                else if (fRotate)
                {
                    glLoadMatrixf(&sp->rot.matrix[0][0]);
                }
                else
                {
                    glLoadMatrixf(&sp->pos.matrix[0][0]);
                }

#if 1
    glVertexPointer(3, GL_FLOAT, sizeof(D3DVERTEX), &pPolyVertices[0].x);
    glNormalPointer(GL_FLOAT, sizeof(D3DVERTEX), &pPolyVertices[0].nx);
    glTexCoordPointer(2, GL_FLOAT, sizeof(D3DVERTEX), &pPolyVertices[0].tu);
                fv4[0] = 1.0f;
                fv4[1] = 1.0f;
                fv4[2] = 1.0f;
                fv4[3] = 1.0f;
                glMaterialfv(GL_FRONT, GL_AMBIENT_AND_DIFFUSE, fv4);
                fv4[0] = 0.6f;
                fv4[1] = 0.6f;
                fv4[2] = 0.6f;
                fv4[3] = 1.0f;
                glMaterialfv(GL_FRONT, GL_SPECULAR, fv4);
                iv1[0] = 40;
                glMaterialiv(GL_FRONT, GL_SHININESS, iv1);
                glBindTexture(GL_TEXTURE_2D, uiTexObj);
                glTexParameteri(GL_TEXTURE_2D,
                                GL_TEXTURE_MIN_FILTER, GL_NEAREST);
                glTexParameteri(GL_TEXTURE_2D,
                                GL_TEXTURE_MAG_FILTER, GL_NEAREST);
                glEnable(GL_TEXTURE_2D);
                glDepthRange(1, 0);
                glEnableClientState(GL_NORMAL_ARRAY);
                glDisableClientState(GL_COLOR_ARRAY);
                glEnable(GL_LIGHTING);
#endif
                
                if (fDisplayList)
                {
                    glCallList(iDlist+iPrimType);
                }
                else
                {
                    glDrawElements(ePrimTypes[iPrimType], nIndices,
                                   GL_UNSIGNED_INT, pIndices);
                }

                sp++;
            }
            break;

        case TEST_FILL:
            glDrawElements(GL_TRIANGLES, nIndices, GL_UNSIGNED_INT, pIndices);
            break;
        }
    
        if (fSwap && !fSingle)
        {
            auxSwapBuffers();
        }
        else
        {
            glFinish();
        }
    }

#ifdef PROFILE
    if (iMultiLoop > 1)
    {
        StopCAP();
    }
#endif
    
    ms = GetTickCount()-ms;

    total_ms += ms;
    total_tris += nTriangles*iMultiLoop;
    if (total_ms > 2000)
    {
        double val;

        switch(iTest)
        {
        case TEST_POLYS:
            val = (double)total_tris*1000.0/total_ms;
            if (val > peak_tri)
            {
                peak_tri = val;
            }
            avg_tri += val;
            break;
        case TEST_FILL:
            val = (double)iTriangleArea*total_tris*1000.0/total_ms;
            if (val > peak_fill)
            {
                peak_fill = val;
            }
            avg_fill += val;
            break;
        }
        avg_cnt++;

        if (fVerbose)
        {
            printf("%s, %s", pszPrimTypes[iPrimType],
                   pszShadeModels[iShadeModel]);
            if (glIsEnabled(GL_CULL_FACE))
            {
                printf(", cull");
            }
            if (glIsEnabled(GL_LIGHTING))
            {
                printf(", lit");
            }
            if (glIsEnabled(GL_TEXTURE_2D))
            {
                printf(", %s", pszTexModes[iTexMode]);
            }
            if (glIsEnabled(GL_DITHER))
            {
                printf(", dither");
            }
            if (glIsEnabled(GL_DEPTH_TEST))
            {
                printf(", z");
            }
#ifdef GL_EXT_clip_volume
            glGetIntegerv(GL_CLIP_VOLUME_CLIPPING_HINT_EXT, &iv1[0]);
            if (iv1[0] != GL_FASTEST)
#endif
            {
                printf(", clip");
            }
            if (fSwap)
            {
                printf(", swap");
            }
            if (fRotate)
            {
                printf(", rotate");
            }
            if (fBounce)
            {
                printf(", bounce");
            }
            if (fPerspective)
            {
                printf(", persp");
            }
            printf(", %d tri/frame\n", nTriangles);
            
            switch(iTest)
            {
            case TEST_POLYS:
                printf("%d ms, %d tri, %.3lf tri/sec, %.3lf peak, %.3lf avg\n",
                       total_ms, total_tris, val, peak_tri,
                       avg_tri/avg_cnt);
                break;
            case TEST_FILL:
                printf("%d ms, %s, area %d, %.3lf pix/sec, "
                       "%.3lf peak, %.3lf avg\n",
                       total_ms, pszOrders[iOrder], iTriangleArea,
                       val, peak_fill, avg_fill/avg_cnt);
                break;
            }
        }
        else
        {
            char msg[80];
            
            switch(iTest)
            {
            case TEST_POLYS:
                sprintf(msg, "%.3lf tri/sec, %.3lf peak, %.3lf avg",
                        val, peak_tri, avg_tri/avg_cnt);
                break;
            case TEST_FILL:
                sprintf(msg, "%.3lf pix/sec, %.3lf peak, %.3lf avg",
                        val, peak_fill, avg_fill/avg_cnt);
                break;
            }
            
            SetWindowText(auxGetHWND(), msg);
        }
        
        total_ms = 0;
        total_tris = 0;
    }
}

void Reshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
}

void Step(void)
{
    Redraw();
}

void KeyB(void)
{
    ModeChange();
    fBounce = !fBounce;
}

void Keyc(void)
{
    ModeChange();
    if (glIsEnabled(GL_CULL_FACE))
    {
        glDisable(GL_CULL_FACE);
    }
    else
    {
        glEnable(GL_CULL_FACE);
    }
}

void KeyC(void)
{
    ModeChange();
    fUseScissor = !fUseScissor;
}

void Keyh(void)
{
    ModeChange();
    if (glIsEnabled(GL_DITHER))
    {
        glDisable(GL_DITHER);
    }
    else
    {
        glEnable(GL_DITHER);
    }
}

void Keyi(void)
{
    iFillSize = (iFillSize+1) % AREA_COUNT;
    SetFill(iFillSize, iOrder);
}

void Keyl(void)
{
    ModeChange();
    if (glIsEnabled(GL_LIGHTING))
    {
        glDisable(GL_LIGHTING);
    }
    else
    {
        glEnable(GL_LIGHTING);
    }
}

void Keym(void)
{
    ModeChange();
    iPolygonMode = (iPolygonMode+1) % POLYMODE_COUNT;
    glPolygonMode(GL_FRONT_AND_BACK, ePolygonModes[iPolygonMode]);
}

void Keyo(void)
{
    iOrder = (iOrder+1) % ORDER_COUNT;
    SetFill(iFillSize, iOrder);
}

void Keyp(void)
{
    ModeChange();
    fPerspective = !fPerspective;
    glHint(GL_PERSPECTIVE_CORRECTION_HINT,
           fPerspective ? GL_NICEST : GL_FASTEST);
}

void KeyP(void)
{
#ifdef GL_EXT_clip_volume
    int iv1[1];

    ModeChange();
    glGetIntegerv(GL_CLIP_VOLUME_CLIPPING_HINT_EXT, &iv1[0]);
    if (iv1[0] == GL_FASTEST)
    {
	glHint(GL_CLIP_VOLUME_CLIPPING_HINT_EXT, GL_DONT_CARE);
    }
    else
    {
	glHint(GL_CLIP_VOLUME_CLIPPING_HINT_EXT, GL_FASTEST);
    }
#endif
}

void KeyR(void)
{
    ModeChange();
    fRotate = !fRotate;
}

void Keys(void)
{
    ModeChange();
    iShadeModel = (iShadeModel+1) % SMODEL_COUNT;
    glShadeModel(eShadeModels[iShadeModel]);
}

void KeyS(void)
{
    fSpread = !fSpread;
    SetFill(iFillSize, iOrder);
}

void Keyt(void)
{
    SetPrim((iPrimType+1) % PRIM_COUNT);
}

void KeyT(void)
{
    iTest = (iTest+1) % TEST_COUNT;
    SetTest(iTest);
}

void Keyw(void)
{
    ModeChange();
    fSwap = !fSwap;
}

void Keyx(void)
{
    ModeChange();
    if (glIsEnabled(GL_TEXTURE_2D))
    {
        glDisable(GL_TEXTURE_2D);
    }
    else
    {
        glEnable(GL_TEXTURE_2D);
    }
}

void KeyX(void)
{
    ModeChange();
    iTexMode = (iTexMode+1) % TEXMODE_COUNT;
    glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, eTexModes[iTexMode]);
}

void Keyz(void)
{
    ModeChange();
    if (glIsEnabled(GL_DEPTH_TEST))
    {
        glDisable(GL_DEPTH_TEST);
    }
    else
    {
        glEnable(GL_DEPTH_TEST);
    }
}

void KeySPACE(void)
{
    fPaused = !fPaused;
    if (fPaused)
    {
        auxIdleFunc(NULL);
    }
    else
    {
        auxIdleFunc(Step);
    }
}

void __cdecl main(int argc, char **argv)
{
    int mode;
    int wd, ht;
    char szWinDir[256];
    int l;

    wd = WIDTH;
    ht = HEIGHT;
    
    while (--argc > 0)
    {
        argv++;

        if (!strcmp(*argv, "-sb"))
        {
            fSingle = TRUE;
        }
        else if (!strcmp(*argv, "-paused"))
        {
            fPaused = TRUE;
        }
        else if (!strcmp(*argv, "-exit"))
        {
            fExit = TRUE;
        }
        else if (!strcmp(*argv, "-cols"))
        {
            fSingleColor = FALSE;
        }
        else if (!strcmp(*argv, "-v"))
        {
            fVerbose = TRUE;
        }
        else if (!strcmp(*argv, "-nodlist"))
        {
            fDisplayList = FALSE;
        }
        else if (!strcmp(*argv, "-norotate"))
        {
            fRotate = FALSE;
        }
        else if (!strcmp(*argv, "-nobounce"))
        {
            fBounce = FALSE;
        }
        else if (!strcmp(*argv, "-noscissor"))
        {
            fUseScissor = FALSE;
        }
        else if (!strncmp(*argv, "-multi", 6))
        {
            sscanf(*argv+6, "%d", &iMultiLoop);
        }
        else if (!strncmp(*argv, "-wd", 3))
        {
            sscanf(*argv+3, "%d", &wd);
        }
        else if (!strncmp(*argv, "-ht", 3))
        {
            sscanf(*argv+3, "%d", &ht);
        }
        else if (!strncmp(*argv, "-rings", 6))
        {
            sscanf(*argv+6, "%d", &nRings);
        }
        else if (!strncmp(*argv, "-sections", 9))
        {
            sscanf(*argv+9, "%d", &nSections);
        }
        else if (!strncmp(*argv, "-tst", 4))
        {
            sscanf(*argv+4, "%d", &iTest);
        }
        else if (!strncmp(*argv, "-fsz", 4))
        {
            sscanf(*argv+4, "%d", &iFillSize);
        }
    }
    
    auxInitPosition(10, 10, wd, ht);
    mode = AUX_RGB | AUX_DEPTH16;
    if (!fSingle)
    {
        mode |= AUX_DOUBLE;
    }
    auxInitDisplayMode(mode);
    auxInitWindow("DrawElements Performance Test");

    auxReshapeFunc(Reshape);
    if (!fPaused)
    {
        auxIdleFunc(Step);
    }

    l = GetWindowsDirectory(szWinDir, sizeof(szWinDir));
    if (l == 0)
    {
        printf("Unable to get windows directory\n");
        exit(1);
    }
    strcpy(szWinDir+l, "\\cover8.bmp");
    pTexture = auxDIBImageLoad(szWinDir);
    if (pTexture == NULL)
    {
        printf("Unable to load texture\n");
        exit(1);
    }

    auxKeyFunc(AUX_B, KeyB);
    auxKeyFunc(AUX_c, Keyc);
    auxKeyFunc(AUX_C, KeyC);
    auxKeyFunc(AUX_h, Keyh);
    auxKeyFunc(AUX_i, Keyi);
    auxKeyFunc(AUX_l, Keyl);
    auxKeyFunc(AUX_m, Keym);
    auxKeyFunc(AUX_o, Keyo);
    auxKeyFunc(AUX_p, Keyp);
    auxKeyFunc(AUX_P, KeyP);
    auxKeyFunc(AUX_R, KeyR);
    auxKeyFunc(AUX_s, Keys);
    auxKeyFunc(AUX_S, KeyS);
    auxKeyFunc(AUX_t, Keyt);
    auxKeyFunc(AUX_T, KeyT);
    auxKeyFunc(AUX_w, Keyw);
    auxKeyFunc(AUX_x, Keyx);
    auxKeyFunc(AUX_X, KeyX);
    auxKeyFunc(AUX_z, Keyz);
    auxKeyFunc(AUX_SPACE, KeySPACE);

    SetPriorityClass(GetCurrentProcess(), HIGH_PRIORITY_CLASS);

    glAddSwapHintRectWIN = (PFNGLADDSWAPHINTRECTWINPROC)
        wglGetProcAddress("glAddSwapHintRectWIN");

#if 0
    _controlfp((unsigned int)
               (~(_EM_ZERODIVIDE | _EM_OVERFLOW | _EM_UNDERFLOW)), _MCW_EM);
#endif

    Init();

    if (fExit)
    {
        Redraw();
    }
    else
    {
        auxMainLoop(Redraw);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\texgen.c ===
/*
 * (c) Copyright 1993, Silicon Graphics, Inc.
 * ALL RIGHTS RESERVED 
 * Permission to use, copy, modify, and distribute this software for 
 * any purpose and without fee is hereby granted, provided that the above
 * copyright notice appear in all copies and that both the copyright notice
 * and this permission notice appear in supporting documentation, and that 
 * the name of Silicon Graphics, Inc. not be used in advertising
 * or publicity pertaining to distribution of the software without specific,
 * written prior permission. 
 *
 * THE MATERIAL EMBODIED ON THIS SOFTWARE IS PROVIDED TO YOU "AS-IS"
 * AND WITHOUT WARRANTY OF ANY KIND, EXPRESS, IMPLIED OR OTHERWISE,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY OR
 * FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL SILICON
 * GRAPHICS, INC.  BE LIABLE TO YOU OR ANYONE ELSE FOR ANY DIRECT,
 * SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY
 * KIND, OR ANY DAMAGES WHATSOEVER, INCLUDING WITHOUT LIMITATION,
 * LOSS OF PROFIT, LOSS OF USE, SAVINGS OR REVENUE, OR THE CLAIMS OF
 * THIRD PARTIES, WHETHER OR NOT SILICON GRAPHICS, INC.  HAS BEEN
 * ADVISED OF THE POSSIBILITY OF SUCH LOSS, HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE
 * POSSESSION, USE OR PERFORMANCE OF THIS SOFTWARE.
 * 
 * US Government Users Restricted Rights 
 * Use, duplication, or disclosure by the Government is subject to
 * restrictions set forth in FAR 52.227.19(c)(2) or subparagraph
 * (c)(1)(ii) of the Rights in Technical Data and Computer Software
 * clause at DFARS 252.227-7013 and/or in similar or successor
 * clauses in the FAR or the DOD or NASA FAR Supplement.
 * Unpublished-- rights reserved under the copyright laws of the
 * United States.  Contractor/manufacturer is Silicon Graphics,
 * Inc., 2011 N.  Shoreline Blvd., Mountain View, CA 94039-7311.
 *
 * OpenGL(TM) is a trademark of Silicon Graphics, Inc.
 */
/*  texgen.c
 *  This program draws a texture mapped teapot with 
 *  automatically generated texture coordinates.  The
 *  texture is rendered as stripes on the teapot.
 */

#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include "glaux.h"

#define	stripeImageWidth 32
GLubyte stripeImage[3*stripeImageWidth];

void makeStripeImage(void)
{
    int j;
    
    for (j = 0; j < stripeImageWidth; j++) {
	    stripeImage[3*j] = (j<=4) ? 255 : 0;
	    stripeImage[3*j+1] = (j>4) ? 255 : 0;
	    stripeImage[3*j+2] = 0;
    }
}

/* glTexGen stuff: */

GLfloat sgenparams[] = {1.0, 1.0, 1.0, 0.0};

void myinit(void)
{
    glClearColor (0.0, 0.0, 0.0, 0.0);

    makeStripeImage();
    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
    glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
    glTexParameterf(GL_TEXTURE_1D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameterf(GL_TEXTURE_1D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameterf(GL_TEXTURE_1D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexImage1D(GL_TEXTURE_1D, 0, 3, stripeImageWidth, 0,
		 GL_RGB, GL_UNSIGNED_BYTE, stripeImage);

    glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_OBJECT_LINEAR);
    glTexGenfv(GL_S, GL_OBJECT_PLANE, sgenparams);

    glEnable(GL_DEPTH_TEST);
    glDepthFunc(GL_LESS);
    glEnable(GL_TEXTURE_GEN_S);
    glEnable(GL_TEXTURE_1D);
    glEnable(GL_CULL_FACE);
    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);
    glEnable(GL_AUTO_NORMAL);
    glEnable(GL_NORMALIZE);
    glFrontFace(GL_CW);
    glCullFace(GL_BACK);
    glMaterialf (GL_FRONT, GL_SHININESS, 64.0);
}

void display(void)
{
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    glPushMatrix ();
    glRotatef(45.0, 0.0, 0.0, 1.0);
    auxSolidTeapot(2.0);
    glPopMatrix ();
    glFlush();
}

void myReshape(GLsizei w, GLsizei h)
{
    glViewport(0, 0, w, h);
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    if (w <= h)
	glOrtho (-3.5, 3.5, -3.5*(GLfloat)h/(GLfloat)w, 
	    3.5*(GLfloat)h/(GLfloat)w, -3.5, 3.5);
    else
	glOrtho (-3.5*(GLfloat)w/(GLfloat)h, 
	    3.5*(GLfloat)w/(GLfloat)h, -3.5, 3.5, -3.5, 3.5);
    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
}

int main(int argc, char** argv)
{
    auxInitDisplayMode (AUX_SINGLE | AUX_RGB | AUX_DEPTH16);
    auxInitPosition (0, 0, 200, 200);
    auxInitWindow (argv[0]);
    myinit();
    auxReshapeFunc (myReshape);
    auxMainLoop(display);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\appl.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"


applRec appl = {
    "OpenGL Conformance",
    "Conform",
    "1.0.15"
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\bcorner.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** bcorner.c
** Buffer Corner Test.
**
** Description -
**    For each available color buffer, a point is drawn at each
**    corner. The color buffer is read and examined to verify
**    that the corner points are at the correct location.
**
** Error Explanation -
**    Failure occurs if any of the corner points cannot be read
**    correctly (implying that the color buffer's width and
**    height or the rendering coordinates are not correct).
**
** Technical Specification -
**    Buffer requirements:
**        This test will be performed on all available buffers.
**    Color requirements:
**        RGBA or color index mode. 2 colors.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**        Color epsilon.
**    Paths:
**        Allowed = Alpha, Blend, Depth, Fog, Logicop, Shade, Stencil, Stipple.
**        Not allowed = Alias, Dither.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"


static char errStr[160];
static char errStrFmt[] = "Mismatch at the %s corner in the %s buffer.";


static long Test(GLenum srcBuf, GLfloat *buf)
{
    char tmp[40];

    GetEnumName(srcBuf, tmp);

    glDrawBuffer(srcBuf);
    glReadBuffer(srcBuf);

    glClear(GL_COLOR_BUFFER_BIT);

    glBegin(GL_POINTS);
	glVertex2f(0.5, 0.5);
	glVertex2f(WINDSIZEX-0.5, 0.5);
	glVertex2f(0.5, WINDSIZEY-0.5);
	glVertex2f(WINDSIZEX-0.5, WINDSIZEY-0.5);
    glEnd();

    ReadScreen(0, 0, WINDSIZEX, WINDSIZEY, GL_AUTO_COLOR, buf);

    /*
    ** Lower left corner.
    */
    if (AutoColorCompare(buf[0], COLOR_ON) == GL_FALSE) {
	StrMake(errStr, errStrFmt, "lower left", tmp);
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }

    /*
    ** Lower right corner.
    */
    if (AutoColorCompare(buf[WINDSIZEX-1], COLOR_ON) == GL_FALSE) {
	StrMake(errStr, errStrFmt, "lower right", tmp);
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }

    /*
    ** Upper left corner.
    */
    if (AutoColorCompare(buf[WINDSIZEX*(WINDSIZEY-1)], COLOR_ON) == GL_FALSE) {
	StrMake(errStr, errStrFmt, "upper left", tmp);
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }

    /*
    ** Upper right corner.
    */
    if (AutoColorCompare(buf[WINDSIZEX*WINDSIZEY-1], COLOR_ON) == GL_FALSE) {
	StrMake(errStr, errStrFmt, "upper right", tmp);
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }

    return NO_ERROR;
}

long BCornerExec(void)
{
    GLfloat *buf;
    GLint save; 
    GLenum i;

    save = buffer.doubleBuf;
    buffer.doubleBuf = GL_FALSE;

    buf = (GLfloat *)MALLOC(WINDSIZEX*WINDSIZEY*sizeof(GLfloat));

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    AutoClearColor(COLOR_OFF);
    AutoColor(COLOR_ON);
    glDisable(GL_DITHER);

    if (buffer.doubleBuf == GL_FALSE && buffer.stereoBuf == GL_FALSE) {
	if (Test(GL_FRONT, buf) == ERROR) {
	    FREE(buf);
	    buffer.doubleBuf = save;
	    return ERROR;
	}
    } else if (buffer.doubleBuf == GL_TRUE && buffer.stereoBuf == GL_FALSE) {
	if (Test(GL_FRONT, buf) == ERROR) {
	    FREE(buf);
	    buffer.doubleBuf = save;
	    return ERROR;
	}
	if (Test(GL_BACK, buf) == ERROR) {
	    FREE(buf);
	    buffer.doubleBuf = save;
	    return ERROR;
	}
    } else if (buffer.doubleBuf == GL_FALSE && buffer.stereoBuf == GL_TRUE) {
	if (Test(GL_LEFT, buf) == ERROR) {
	    FREE(buf);
	    buffer.doubleBuf = save;
	    return ERROR;
	}
	if (Test(GL_RIGHT, buf) == ERROR) {
	    FREE(buf);
	    buffer.doubleBuf = save;
	    return ERROR;
	}
    } else if (buffer.doubleBuf == GL_TRUE && buffer.stereoBuf == GL_TRUE) {
	if (Test(GL_FRONT_LEFT, buf) == ERROR) {
	    FREE(buf);
	    buffer.doubleBuf = save;
	    return ERROR;
	}
	if (Test(GL_FRONT_RIGHT, buf) == ERROR) {
	    FREE(buf);
	    buffer.doubleBuf = save;
	    return ERROR;
	}
	if (Test(GL_BACK_LEFT, buf) == ERROR) {
	    FREE(buf);
	    buffer.doubleBuf = save;
	    return ERROR;
	}
	if (Test(GL_BACK_RIGHT, buf) == ERROR) {
	    FREE(buf);
	    buffer.doubleBuf = save;
	    return ERROR;
	}
    }
    for (i = 0; i < buffer.auxBuf; i++) {
	if (Test(GL_AUX0+i, buf) == ERROR) {
	    FREE(buf);
	    buffer.doubleBuf = save;
	    return ERROR;
	}
    }

    FREE(buf);
    buffer.doubleBuf = save;
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\apfunc.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** apfunc.c
** Alpha Plane Function Test.
**
** Description -
**    Three points are drawn at location (0.0, 0.0), (1.0, 0.0)
**    and (2.0, 0.0). The first point has a random alpha value
**    between 0.0 and 0.4, the second point has an alpha value of
**    0.5 and the third point has a random alpha value between
**    0.6 and 1.0. Each alpha function is tested by setting the
**    alpha reference value to 0.5, drawing the three points and
**    comparing the rendered result to the expected result.
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer, alpha plane.
**    Color requirements:
**        RGBA mode. Full color.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**        Zero epsilon.
**    Paths:
**        Allowed = Blend, Depth, Fog, Logicop, Shade, Stencil, Stipple.
**        Not allowed = Alias, Alpha, Dither.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"


static long errPattern[3];
static GLfloat errAlphas[3];
static char errStr[320];
static char errStrFmt[] = "The behavior of the alpha function %s is not correct. The alpha value of the test points are %1.1f, %1.1f, %1.1f. The reference alpha value is 0.5. The test points pattern is %s, %s, %s, should be %s.\n";


static void ClearDrawRead(GLenum func, GLfloat *buf)
{

    glClear(GL_COLOR_BUFFER_BIT);

    glAlphaFunc(func, 0.5);
    glBegin(GL_POINTS);
	errAlphas[0] = Random(0.0, 0.4);
	glColor4f(1.0, 1.0, 1.0, errAlphas[0]);
	glVertex2f(0.5, 0.5);

	errAlphas[1] = 0.5;
	glColor4f(1.0, 1.0, 1.0, errAlphas[1]);
	glVertex2f(1.5, 0.5);

	errAlphas[2] = Random(0.6, 1.0);
	glColor4f(1.0, 1.0, 1.0, errAlphas[2]);
	glVertex2f(2.5, 0.5);
    glEnd();

    ReadScreen(0, 0, 3, 1, GL_RGB, buf);
}

static long Test(long a, long b, long c, GLfloat *buf)
{
    long i;

    for (i = 0; i < 3; i++) {
	if (buf[i*3] < epsilon.zero &&
	    buf[i*3+1] < epsilon.zero &&
	    buf[i*3+2] < epsilon.zero) {     /* no color. */
	    errPattern[i] = GL_FALSE;
	} else {                             /* color. */
	    errPattern[i] = GL_TRUE;
	}
    }

    if (a == GL_TRUE) {     /* should have color. */
	if (buf[0] < epsilon.zero &&
	    buf[1] < epsilon.zero &&
	    buf[2] < epsilon.zero) {     /* no color. */
	    return ERROR;
	}
    } else {             /* should not have color. */
	if (buf[0] > epsilon.zero &&
	    buf[1] > epsilon.zero &&
	    buf[2] > epsilon.zero) {     /* color. */
	    return ERROR;
	}
    }

    if (b == GL_TRUE) {     /* should have color. */
	if (buf[3] < epsilon.zero &&
	    buf[4] < epsilon.zero &&
	    buf[5] < epsilon.zero) {     /* no color. */
	    return ERROR;
	}
    } else {             /* should not have color. */
	if (buf[3] > epsilon.zero &&
	    buf[4] > epsilon.zero &&
	    buf[5] > epsilon.zero) {     /* color. */
	    return ERROR;
	}
    }

    if (c == GL_TRUE) {     /* should have color. */
	if (buf[6] < epsilon.zero &&
	    buf[7] < epsilon.zero &&
	    buf[8] < epsilon.zero) {     /* no color. */
	    return ERROR;
	}
    } else {             /* should not have color. */
	if (buf[6] > epsilon.zero &&
	    buf[7] > epsilon.zero &&
	    buf[8] > epsilon.zero) {     /* color. */
	    return ERROR;
	}
    }

    return NO_ERROR;
}

static void MakeErrorStr(char *funcName, char *result)
{

    StrMake(errStr, errStrFmt, funcName, errAlphas[0], errAlphas[1],
	    errAlphas[2], (errPattern[0] == GL_TRUE) ? "DRAWN" : "NOT-DRAWN",
	    (errPattern[1] == GL_TRUE) ? "DRAWN" : "NOT-DRAWN",
	    (errPattern[2] == GL_TRUE) ? "DRAWN" : "NOT-DRAWN", result);
}

long APFuncExec(void)
{
    GLfloat buf[9];

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glDisable(GL_DITHER);
    glEnable(GL_ALPHA_TEST);

    ClearDrawRead(GL_ALWAYS, buf);
    if (Test(GL_TRUE, GL_TRUE, GL_TRUE, buf) == ERROR) {
	MakeErrorStr("GL_ALWAYS", "DRAWN, DRAWN, DRAWN");
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }

    ClearDrawRead(GL_NEVER, buf);
    if (Test(GL_FALSE, GL_FALSE, GL_FALSE, buf) == ERROR) {
	MakeErrorStr("GL_NEVER", "NOT-DRAWN, NOT-DRAWN, NOT-DRAWN");
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }

    ClearDrawRead(GL_LESS, buf);
    if (Test(GL_TRUE, GL_FALSE, GL_FALSE, buf) == ERROR) {
	MakeErrorStr("GL_LESS", "DRAWN, NOT-DRAWN, NOT-DRAWN");
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }

    ClearDrawRead(GL_LEQUAL, buf);
    if (Test(GL_TRUE, GL_TRUE, GL_FALSE, buf) == ERROR) {
	MakeErrorStr("GL_LEQUAL", "DRAWN, DRAWN, NOT-DRAWN");
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }

    ClearDrawRead(GL_GREATER, buf);
    if (Test(GL_FALSE, GL_FALSE, GL_TRUE, buf) == ERROR) {
	MakeErrorStr("GL_GREATER", "NOT-DRAWN, NOT-DRAWN, DRAWN");
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }

    ClearDrawRead(GL_GEQUAL, buf);
    if (Test(GL_FALSE, GL_TRUE, GL_TRUE, buf) == ERROR) {
	MakeErrorStr("GL_GEQUAL", "NOT-DRAWN, DRAWN, DRAWN");
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }

    ClearDrawRead(GL_EQUAL, buf);
    if (Test(GL_FALSE, GL_TRUE, GL_FALSE, buf) == ERROR) {
	MakeErrorStr("GL_EQUAL", "NOT-DRAWN, DRAWN, NOT-DRAWN");
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }

    ClearDrawRead(GL_NOTEQUAL, buf);
    if (Test(GL_TRUE, GL_FALSE, GL_TRUE, buf) == ERROR) {
	MakeErrorStr("GL_NOTEQUAL", "DRAWN, NOT-DRAWN, DRAWN");
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\auxprogs\rgb\wfperf.c ===
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>

#include <windows.h>
#include <gl\gl.h>
#include <gl\glu.h>
#include <gl\glaux.h>

#define PI 3.14159265358979323846

#define WIDTH 800
#define HEIGHT 600

GLfloat xr = 0.0f;
GLfloat yr = 0.0f;
GLfloat intensity = 0.1f;

#define DRAW_TEAPOT		0x00000001
#define DRAW_TORUS		0x00000002
#define DRAW_SPHERE		0x00000004
#define DRAW_GRID		0x00000008
#define DRAW_CIRCLE		0x00000010
#define DRAW_SINE		0x00000020

DWORD dwDraw = 0xffffffff;

BOOL fSingle = FALSE;
BOOL fClipViewport = FALSE;
BOOL fSmooth = FALSE;
BOOL fPause = FALSE;
BOOL fLargeView = FALSE;
BOOL fLargeZ = FALSE;
BOOL fColor = TRUE;

int line_width = 1;
int steps = 20;

void Init(void)
{
    double xyf, zf;

    xyf = fLargeView ? 2.0 : 1.0;
    zf = fLargeZ ? 2.0 : 1.0;
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    glOrtho(-xyf, xyf, -xyf, xyf, -zf, zf);
    glMatrixMode(GL_MODELVIEW);

    glShadeModel(fSmooth ? GL_SMOOTH : GL_FLAT);
    glLineWidth((GLfloat)line_width);
}

void Redraw(void)
{
    DWORD ms;
    int i;
    float x1, y1, dx1, dy1;
    float x2, y2, dx2, dy2;
    float col, dcol;
    float ang, dang;

    ms = GetTickCount();

    glClear(GL_COLOR_BUFFER_BIT);

    glLoadIdentity();

    glRotatef(xr, 1.0f, 0.0f, 0.0f);
    glRotatef(yr, 0.0f, 1.0f, 0.0f);

    if (fColor)
    {
	glColor3f(intensity, 0.0f, 0.0f);
    }
    if (dwDraw & DRAW_SPHERE)
    {
	auxWireSphere(1.0);
    }
    if (dwDraw & DRAW_TORUS)
    {
	auxWireTorus(0.5, 1.0);
    }
    if (dwDraw & DRAW_TEAPOT)
    {
	auxWireTeapot(1.0);
    }

    if (dwDraw & DRAW_GRID)
    {
	x1 = -2.0f;
	y1 = 0.0f;
	dx1 = -x1/(steps-1);
	dy1 = 2.0f/(steps-1);
	x2 = -2.0f;
	y2 = 0.0f;
	dx2 = -x2/(steps-1);
	dy2 = -2.0f/(steps-1);
	col = 0.5f;
	dcol = 0.5f/(steps-1);

	glBegin(GL_LINES);
	for (i = 0; i < steps; i++)
	{
	    if (fColor)
	    {
		glColor3f(col, 0.0f, 0.0f);
	    }
	    glVertex2f(x1, y1);
	    if (fColor)
	    {
		glColor3f(0.0f, col, 0.0f);
	    }
	    glVertex2f(x1+2.0f, y1-2.0f);
	    if (fColor)
	    {
		glColor3f(1.5f-col, 0.0f, 0.0f);
	    }
	    glVertex2f(x2, y2);
	    if (fColor)
	    {
		glColor3f(0.0f, 1.5f-col, 0.0f);
	    }
	    glVertex2f(x2+2.0f, y2+2.0f);

	    x1 += dx1;
	    y1 += dy1;
	    x2 += dx2;
	    y2 += dy2;
	    col += dcol;
	}
	glEnd();
    }

    if (dwDraw & DRAW_CIRCLE)
    {
	if (fColor)
	{
	    glColor3f(0.0f, intensity, 0.0f);
	}

	ang = 0.0f;
        dang = (float)((PI*2.0)/steps);

        glBegin(GL_LINE_LOOP);
	for (i = 0; i < steps; i++)
	{
	    x1 = (float)(cos(ang)*1.5);
	    y1 = (float)(sin(ang)*1.5);
	    glVertex2f(x1, y1);
	    ang += dang;
	}
	glEnd();
    }

    if (dwDraw & DRAW_SINE)
    {
	if (fColor)
	{
	    glColor3f(0.0f, 0.0f, intensity);
	}

	ang = 0.0f;
        dang = (float)((PI*2.0)/(steps-1));
	x1 = -1.5f;
	dx1 = 3.0f/(steps-1);

	glBegin(GL_LINE_STRIP);
	for (i = 0; i < steps; i++)
	{
	    y1 = (float)(sin(ang)*1.5);
	    glVertex2f(x1, y1);
	    ang += dang;
	    x1 += dx1;
	}
	glEnd();
    }

    glFinish();

    ms = GetTickCount()-ms;

    printf("%d ms\n", ms);

    if (!fSingle)
    {
        auxSwapBuffers();
    }
}

void Reshape(GLsizei w, GLsizei h)
{
    if (!fClipViewport)
    {
        glViewport(0, 0, w, h);
    }
    else
    {
        glViewport(WIDTH, 0, w, h);
    }
}

void Step(void)
{
    xr += 2.0f;
    yr += 2.0f;
    
    intensity += 0.1f;
    if (intensity > 1.0f)
    {
        intensity = 0.1f;
    }
    
    Redraw();
}

void KeySpace(void)
{
    Step();
}

char *draw_names[] =
{
    "teapot",
    "torus",
    "sphere",
    "grid",
    "circle",
    "sine"
};
#define DRAW_COUNT (sizeof(draw_names)/sizeof(draw_names[0]))

DWORD DrawBit(char *name)
{
    int i;
    DWORD bit;

    bit = 1;
    for (i = 0; i < DRAW_COUNT; i++)
    {
	if (!strcmp(name, draw_names[i]))
	{
	    return bit;
	}

	bit <<= 1;
    }

    if (strlen(name) == 0)
    {
	return 0xffffffff;
    }
    else
    {
	printf("No draw option '%s'\n", name);
	return 0;
    }
}

void __cdecl main(int argc, char **argv)
{
    int mode;

    while (--argc > 0)
    {
        argv++;

        if (!strcmp(*argv, "-sb"))
        {
            fSingle = TRUE;
        }
        else if (!strcmp(*argv, "-clip"))
        {
            fClipViewport = TRUE;
        }
	else if (!strncmp(*argv, "-lw", 3))
	{
	    sscanf(*argv+3, "%d", &line_width);
	}
	else if (!strcmp(*argv, "-smooth"))
	{
	    fSmooth = TRUE;
	}
	else if (!strcmp(*argv, "-pause"))
	{
	    fPause = TRUE;
        }
	else if (!strncmp(*argv, "-draw", 5))
	{
	    dwDraw &= ~DrawBit(*argv+5);
	}
	else if (!strncmp(*argv, "+draw", 5))
	{
	    dwDraw |= DrawBit(*argv+5);
	}
	else if (!strcmp(*argv, "-nocolor"))
	{
	    fColor = FALSE;
        }
	else if (!strcmp(*argv, "-largeview"))
	{
	    fLargeView = TRUE;
	}
	else if (!strcmp(*argv, "-largez"))
	{
	    fLargeZ = TRUE;
	}
    }
    
    auxInitPosition(10, 10, WIDTH, HEIGHT);
    mode = AUX_RGB | AUX_DEPTH16;
    if (!fSingle)
    {
        mode |= AUX_DOUBLE;
    }
    auxInitDisplayMode(mode);
    auxInitWindow("Wireframe Performance Test");

    auxReshapeFunc(Reshape);
    if (!fPause)
    {
	auxIdleFunc(Step);
    }
    auxKeyFunc(AUX_SPACE, KeySpace);

    Init();
    
    auxMainLoop(Redraw);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\accum.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** accum.c
** Accumulation Buffer Test.
**
** Description -
**    Tests the five operations of the accumulation buffer:
**    GL_LOAD, GL_ADD, GL_MULT, GL_ACCUM and GL_RETURN. Also
**    checks for proper clamping of values sent to and returned
**    from the buffer. AccumMaskTest() checks that the color mask
**    is applied on GL_RETURN, and does not affect the other
**    accumulation ops.
**    
**    For each operation, the entire color buffer and
**    accumulation buffer are cleared with a different value in
**    each color component. The color buffer is read back so that
**    the actual value is taken to be the current color buffer
**    value, to minimize error later on. The value parameter is
**    set by Random(), with a range chosen to keep the resulting
**    buffer values mostly within range.
**    
**    The operation (GL_LOAD, GL_ADD, GL_MULT, GL_ACCUM) is then
**    repeated a number of times (currently 10) before a
**    GL_RETURN operation is executed, and the color buffer value
**    is compared against the expected value. The OpenGL
**    specification says that the accumulation buffer values are
**    in the range [-1,1] and if they go out of this range, the
**    result is undefined. After each glAccum() call the
**    expected value for the accumulation buffer is calculated
**    and, if at any time it goes out of range, the result of
**    that series of calls is ignored.
**    
**    Alpha values are included in the color components that are
**    set and read. If there is no alpha buffer, the returned
**    alpha values are expected to alway be 1.0.
**
** Error Explanation -
**    One color error margin is allowed. The initial color from
**    the color buffer is taken to be the actual color read, not
**    the color written, to eliminate that variation from the
**    accumulated error.
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer, accumulation buffer.
**    Color requirements:
**        RGBA mode. Full color.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**        For clears, reads color back from buffer for clear value to
**        minimize error accumulation. Otherwise uses color epsilons plus
**        accum epsilon times number of operations.
**    Paths:
**        Allowed = Alpha, Blend, Depth, Fog, Logicop, Shade, Stencil, Stipple.
**        Not allowed = Alias, Dither.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"


static GLsizei W = 10;
static GLsizei H = 10;


static char errStr[240];
static char errStrFmt[] = "Expected accum RETURN value is (%1.1f, %1.1f, %1.1f, %1.1f). Actual value is (%1.1f, %1.1f, %1.1f, %1.1f).";


static long TestBuffer(GLfloat *buf, GLfloat *ev, long n)
{
    long i;

    if (buffer.accumBits[3] > 0) {
        ReadScreen(0, 0, W, H, GL_RGBA, buf);

        for (i = 0; i < W*H*4; i += 4) {
	    if (ABS(buf[i]-ev[0]) > (epsilon.color[0]+2*n*epsilon.accum[0]) ||
	        ABS(buf[i+1]-ev[1]) > (epsilon.color[1]+2*n*epsilon.accum[1]) ||
	        ABS(buf[i+2]-ev[2]) > (epsilon.color[2]+2*n*epsilon.accum[2]) ||
	        ABS(buf[i+3]-ev[3]) > (epsilon.color[3]+2*n*epsilon.accum[3])) {
	        StrMake(errStr, errStrFmt, ev[0], ev[1], ev[2], ev[3],
		        buf[i], buf[i+1], buf[i+2], buf[i+3]);
	        return ERROR;
	    }
        }
    } else {
        ReadScreen(0, 0, W, H, GL_RGB, buf);

        for (i = 0; i < W*H*3; i += 3) {
	    if (ABS(buf[i]-ev[0]) > (epsilon.color[0]+2*n*epsilon.accum[0]) ||
	        ABS(buf[i+1]-ev[1]) > (epsilon.color[1]+2*n*epsilon.accum[1]) ||
	        ABS(buf[i+2]-ev[2]) > (epsilon.color[2]+2*n*epsilon.accum[2])) {
	        StrMake(errStr, errStrFmt, ev[0], ev[1], ev[2], ev[3],
		        buf[i], buf[i+1], buf[i+2], buf[i+3]);
	        return ERROR;
	    }
        }
    }

    return NO_ERROR;
}

static long ExpectedAccumValue(long op, GLfloat value, GLfloat *current,
			       GLfloat *colBuf)
{
    long outOfRange, i;

    switch (op) {
      case GL_ACCUM:
        current[0] += colBuf[0] * value;
        current[1] += colBuf[1] * value;
        current[2] += colBuf[2] * value;
        current[3] += colBuf[3] * value;
	break;
      case GL_LOAD:
        current[0] = colBuf[0] * value;
        current[1] = colBuf[1] * value;
        current[2] = colBuf[2] * value;
        current[3] = colBuf[3] * value;
    	break;
      case GL_ADD:
        current[0] += value;
	current[1] += value;
	current[2] += value;
	current[3] += value;
	break;
      case GL_MULT:
	current[0] *= value;
	current[1] *= value;
	current[2] *= value;
	current[3] *= value;
	break;
      case GL_RETURN:
        colBuf[0] = (current[0] > 1.0) ? 1.0 : current[0];
        colBuf[0] = (colBuf[0] < 0.0) ? 0.0 : colBuf[0];
        colBuf[1] = (current[1] > 1.0) ? 1.0 : current[1];
        colBuf[1] = (colBuf[1] < 0.0) ? 0.0 : colBuf[1];
        colBuf[2] = (current[2] > 1.0) ? 1.0 : current[2];
        colBuf[2] = (colBuf[2] < 0.0) ? 0.0 : colBuf[2];
	/*
	** If there is no alpha buffer, always return 1.0.
	*/
	if (buffer.colorBits[3] == 0) {
	    colBuf[3] = 1.0;
	} else {
	    colBuf[3] = (current[3] > 1.0) ? 1.0 : current[3];
	    colBuf[3] = (colBuf[3] < 0.0) ? 0.0 : colBuf[3];
	}
        break;
    }
    outOfRange = 0;
    for (i = 0; i < 3; i++) {
	if (current[i] < -1 || current[i] > 1) {
	    outOfRange |= GL_TRUE;
	}
    }
    return outOfRange;
}

static void SetupClearValues(long op, GLfloat *clearColor, GLfloat *clearAccum)
{

    switch (op) {
      case GL_LOAD:
      case GL_MULT:
      case GL_RETURN:
	clearColor[0] = 1.0;
	clearColor[1] = 0.1;
	clearColor[2] = 0.6;
	clearColor[3] = 1.0;

	clearAccum[0] = 0.7;
	clearAccum[1] = 1.0;
	clearAccum[2] = 0.1;
	clearAccum[3] = 0.2;
	break;
      case GL_ACCUM:
      case GL_ADD:
	clearColor[0] = 0.1;
	clearColor[1] = 0.4;
	clearColor[2] = 0.3;
	clearColor[3] = 0.3;

	clearAccum[0] = 0.4;
	clearAccum[1] = 0.0;
	clearAccum[2] = -0.2;
	clearAccum[3] = 0.0;
	break;
    }
}

static void SetupData(long op, GLfloat *values, long count)
{
    long i;

    switch (op) {
      case GL_ACCUM:
        for (i = 0; i < count; i++) {
	    values[i] = Random(-0.3, 0.5);
	}
	break;
      case GL_LOAD:
	for (i = 0; i < count; i++) {
	    values[i] = Random(0.0, 1.0);
	}
	break;
      case GL_ADD:
	for (i = 0; i < count; i++) {
	    values[i] = Random(-0.4, 0.4);
	}
	break;
      case GL_MULT:
	for (i = 0; i < count; i++) {
	    values[i] = Random(0.1, 1.5);
        }
	break;
    }
}

static long AccumTest(GLfloat *buf, GLenum op)
{
    GLfloat values[100];
    GLfloat current[4], retColor[4], clearColor[4], clearAccum[4];
    long count = 3, repeat, vIndex = 0;
    long outOfRange;
    long i, j;

    repeat = (machine.pathLevel == 0) ? 10 : 3;

    /*
    ** For each operation, this test executes the Accum operation a
    ** number of time (count), before reading the result, since
    ** most of the operations have a cumulative effect.
    ** The test is repeated several times (repeat) using different
    ** values.
    */
    SetupClearValues(op, clearColor, clearAccum);
    glClearColor(clearColor[0], clearColor[1], clearColor[2], clearColor[3]);
    glClear(GL_COLOR_BUFFER_BIT);

    /*
    ** Use the color read from the buffer as the initial color, to eliminate
    ** that variation from the accumulated error.
    */
    ReadScreen(0, 0, 1, 1, GL_RGBA, clearColor);

    glClearAccum(clearAccum[0], clearAccum[1], clearAccum[2], clearAccum[3]);

    SetupData(op, values, count*repeat);

    for (i = 0; i < repeat; i++) {
	glClear(GL_COLOR_BUFFER_BIT|GL_ACCUM_BUFFER_BIT);
	outOfRange = GL_FALSE;
	current[0] = clearAccum[0];
	current[1] = clearAccum[1];
	current[2] = clearAccum[2];
	current[3] = clearAccum[3];
	for (j = 0; j < count; j++) {
	    outOfRange |= ExpectedAccumValue(op, values[vIndex], current,
					     clearColor);

	    glAccum(op, values[vIndex++]);
	}

	/*
	**  The spec states that if buffer values goes out of range [-1, 1]
	**  then they are undefined. Since test values are randomly generated,
	**  the value may go out of range. Test for this and ignore the
	**  results.
	*/
	if (outOfRange) {
	    continue;
	}

	ExpectedAccumValue(GL_RETURN, 1.0, current, retColor);
	glAccum(GL_RETURN, 1.0);
	if (TestBuffer(buf, retColor, count) == ERROR) {
	    return ERROR;
	}
    }
    return NO_ERROR;
}

static long AccumMaskTest(GLfloat *buf)
{
    GLfloat current[4], retColor[4], clearColor[4], clearAccum[4];
    long i; 
    GLboolean mask[4];

    clearColor[0] = clearColor[1] = clearColor[2] = clearColor[3] = 1.0;
    current[0] = current[1] = current[2] = current[3] = 0.0;
    clearAccum[0] = clearAccum[1] = clearAccum[2] = clearAccum[3] = 0.0;

    for (i = 0; i < 4; i++) {
	mask[0] = mask[1] = mask[2] = mask[3] = GL_TRUE;
	mask[i] = GL_FALSE;

	glClearAccum(clearAccum[0], clearAccum[1], clearAccum[2],
		     clearAccum[3]);
	glClearColor(clearColor[0], clearColor[1], clearColor[2],
		     clearColor[3]);
	glClear(GL_COLOR_BUFFER_BIT | GL_ACCUM_BUFFER_BIT);

	/*
	** Test each operation with a mask component off, checking that
	** the component is not affected by the mask.
	*/

	glColorMask(mask[0], mask[1], mask[2], mask[3]);
	ExpectedAccumValue(GL_LOAD, 1.0, current, clearColor);
	glAccum(GL_LOAD, 1.0);

	ExpectedAccumValue(GL_ADD, -0.2, current, clearColor);
	glAccum(GL_ADD, -0.2);

	ExpectedAccumValue(GL_MULT, 0.5, current, clearColor);
	glAccum(GL_MULT, 0.5);

	ExpectedAccumValue(GL_ACCUM, 0.2, current, clearColor);
	glAccum(GL_ACCUM, 0.2);

	glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
	ExpectedAccumValue(GL_RETURN, 0.2, current, retColor);
	glAccum(GL_RETURN, 1.0);
	if (TestBuffer(buf, retColor, 1) == ERROR) {
	    return ERROR;
	}

	/*
	** Test RETURN with a mask component off, checking that the mask
	** is applied, leaving the color buffer unchanged.
	*/
	glClear(GL_COLOR_BUFFER_BIT);
	glColorMask(mask[0], mask[1], mask[2], mask[3]);
	current[i] = clearColor[i];
	ExpectedAccumValue(GL_RETURN, 1.0, current, retColor);
	glAccum(GL_RETURN, 1.0);
	if (TestBuffer(buf, retColor, 1) == ERROR) {
	    return ERROR;
	}
    }
    glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
    return NO_ERROR;
}

long AccumExec(void)
{
    GLfloat *buf;
    GLfloat values[100];
    char errStrOut[200];

    /*
    ** If there is no accumulation buffer, just return.
    */
    if ((buffer.accumBits[0]+buffer.accumBits[1]+buffer.accumBits[2]+
	buffer.accumBits[3]) == 0) {
	return NO_ERROR;
    }

    buf = (GLfloat *)MALLOC(W*H*4*sizeof(GLfloat));

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glClearAccum(0.0, 0.0, 0.0, 0.0);
    glDisable(GL_DITHER);

    glClear(GL_ACCUM_BUFFER_BIT);

    if (AccumTest(buf, GL_LOAD) == ERROR) {
	StrMake(errStrOut, "Testing operation GL_LOAD. %s", errStr);
	ErrorReport(__FILE__, __LINE__, errStrOut);
	FREE(buf);
	return ERROR;
    }

    if (AccumTest(buf, GL_ADD) == ERROR) {
	StrMake(errStrOut, "Testing operation GL_ADD. %s", errStr);
	ErrorReport(__FILE__, __LINE__, errStrOut);
	FREE(buf);
	return ERROR;
    }

    if (AccumTest(buf, GL_MULT) == ERROR) {
	StrMake(errStrOut, "Testing operation GL_MULT. %s", errStr);
	ErrorReport(__FILE__, __LINE__, errStrOut);
	FREE(buf);
	return ERROR;
    }

    if (AccumTest(buf, GL_ACCUM) == ERROR) {
	StrMake(errStrOut, "Testing operation GL_ACCUM. %s", errStr);
	ErrorReport(__FILE__, __LINE__, errStrOut);
	FREE(buf);
	return ERROR;
    }

    if (AccumMaskTest(buf) == ERROR) {
	StrMake(errStrOut, "Testing masking of accum values. %s", errStr);
	ErrorReport(__FILE__, __LINE__, errStrOut);
	FREE(buf);
	return ERROR;
    }

    FREE(buf);
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\bcolor.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** bcolor.c
** Buffer Color Test.
**
** Description -
**    Tests the color stability of color buffers. Since a color
**    buffer may have limited color capacity, a point drawn with
**    a requested color may render in a different color. However,
**    if this rendered color is then used to draw a second point,
**    the rendered color of the second point must match the
**    rendered color of the first point.
**
** Error Explanation -
**    Failure occurs if the rendered color from a point, when
**    used as the request color for a second point, does not
**    match the rendered color of this second point.
**
** Technical Specification -
**    Buffer requirements:
**        This test will be performed on all available buffers.
**    Color requirements:
**        RGBA or color index mode. Full color.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**        Color and zero epsilons.
**    Paths:
**        Allowed = Alpha, Blend, Depth, Fog, Logicop, Shade, Stencil, Stipple.
**        Not allowed = Alias, Dither.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"
#include "utilru.h"


typedef struct _bColorRec {
    GLenum buffer; 
    long component;
    GLfloat step;
    GLfloat color[4];
    GLfloat index, maxIndex;
} bColorRec;


static char errBuf[40];
static char errStr[240];
static char errStrFmt[][160] = {
    "Buffer %s. Color is (%g, %g, %g, %g). Red, green and blue components should be 0.0.",
    "Buffer %s. Color is (%g, %g, %g, %g). Green and blue components should be 0.0.",
    "Buffer %s. Color is (%g, %g, %g, %g). Red and blue components should be 0.0.",
    "Buffer %s. Color is (%g, %g, %g, %g). Red and green components should be 0.0.",
    "Buffer %s. Color is (%g, %g, %g, %g). Alpha component should 0.0.",
    "Buffer %s. Color is (%g, %g, %g, %g). Alpha component should 1.0.",
    "Buffer %s. Color is (%g, %g, %g, %g). Red component should be 0.0.",
    "Buffer %s. Color is (%g, %g, %g, %g). Red component should be 1.0.",
    "Buffer %s. Color is (%g, %g, %g, %g). Green component should be 0.0.",
    "Buffer %s. Color is (%g, %g, %g, %g). Green component should be 1.0.",
    "Buffer %s. Color is (%g, %g, %g, %g). Blue component should be 0.0.",
    "Buffer %s. Color is (%g, %g, %g, %g). Blue component should be 1.0.",
    "Buffer %s. Color is (%g, %g, %g, %g), should be %g, %g, %g, %g.",
    "Buffer %s. Color index is %1.1f, should be %1.1f."
};


/*****************************************************************************/

static void InitRGB(void *data)
{
    bColorRec *ptr = (bColorRec *)data;
    GLfloat step;

    GetEnumName(ptr->buffer, errBuf);

    glDrawBuffer(ptr->buffer);
    glReadBuffer(ptr->buffer);

    step = (machine.pathLevel == 0) ? 16.0 : 2.0;
    if (buffer.colorBits[ptr->component] > 0) {
	ptr->step = 1.0 / (POW(2.0, (float)buffer.colorBits[ptr->component]) -
		    1.0) / step;
    } else {
	ptr->step = 1.0 / 7.0;
    }

    ptr->color[0] = 0.0;
    ptr->color[1] = 0.0;
    ptr->color[2] = 0.0;
    ptr->color[3] = 0.0;
}

static void SetRGB(void *data, float *ref)
{
    bColorRec *ptr = (bColorRec *)data;

    ptr->color[ptr->component] = *ref;
    glColor4fv(ptr->color);

    glBegin(GL_POINTS);
	glVertex2f(0.5, 0.5);
    glEnd();

    *ref += ptr->step;
}

static long TestRGB(void *data, float ref)
{
    bColorRec *ptr = (bColorRec *)data;
    GLfloat buf1[4], buf2[4];

    ReadScreen(0, 0, 1, 1, GL_RGBA, buf1);
    glColor4fv(buf1);

    glBegin(GL_POINTS);
	glVertex2f(0.5, 0.5);
    glEnd();

    ReadScreen(0, 0, 1, 1, GL_RGBA, buf2);

    switch (ptr->component) {
      case 0:
	if (buf2[1] != 0.0 || buf2[2] != 0.0) {
	    StrMake(errStr, errStrFmt[1], errBuf, buf2[0], buf2[1], buf2[2],
		    buf2[3]);
	    ErrorReport(__FILE__, __LINE__, errStr);
	    return ERROR;
	}
	if (buffer.colorBits[3] > 0) {
	    if (buf2[3] != 0.0) {
		StrMake(errStr, errStrFmt[4], errBuf, buf2[0], buf2[1], buf2[2],
			buf2[3]);
		ErrorReport(__FILE__, __LINE__, errStr);
		return ERROR;
	    }
	} else  {
	    if (ABS(buf2[3]-1.0) > epsilon.zero) {
		StrMake(errStr, errStrFmt[5], errBuf, buf2[0], buf2[1], buf2[2],
			buf2[3]);
		ErrorReport(__FILE__, __LINE__, errStr);
		return ERROR;
	    }
	}
	if (ref == 0.0) {
	    if (buf2[0] != 0.0) {
		StrMake(errStr, errStrFmt[6], errBuf, buf2[0], buf2[1], buf2[2],
			buf2[3]);
		ErrorReport(__FILE__, __LINE__, errStr);
		return ERROR;
	    }
	} else if (ref == 1.0) {
	    if (ABS(buf2[0]-1.0) > epsilon.zero) {
		StrMake(errStr, errStrFmt[7], errBuf, buf2[0], buf2[1], buf2[2],
			buf2[3]);
		ErrorReport(__FILE__, __LINE__, errStr);
		return ERROR;
	    }
	} else {
	    if (ABS(buf1[0]-buf2[0]) > epsilon.color[0]) {
		StrMake(errStr, errStrFmt[12], errBuf, buf2[0], buf2[1],
			buf2[2], buf2[3], buf1[0], buf1[1], buf1[2], buf1[3]);
		ErrorReport(__FILE__, __LINE__, errStr);
		return ERROR;
	    }
	}
	break;
      case 1:
	if (buf2[0] != 0.0 || buf2[2] != 0.0) {
	    StrMake(errStr, errStrFmt[2], errBuf, buf2[0], buf2[1], buf2[2],
		    buf2[3]);
	    ErrorReport(__FILE__, __LINE__, errStr);
	    return ERROR;
	}
	if (buffer.colorBits[3] > 0) {
	    if (buf2[3] != 0.0) {
		StrMake(errStr, errStrFmt[4], errBuf, buf2[0], buf2[1], buf2[2],
			buf2[3]);
		ErrorReport(__FILE__, __LINE__, errStr);
		return ERROR;
	    }
	} else  {
	    if (ABS(buf2[3]-1.0) > epsilon.zero) {
		StrMake(errStr, errStrFmt[5], errBuf, buf2[0], buf2[1], buf2[2],
			buf2[3]);
		ErrorReport(__FILE__, __LINE__, errStr);
		return ERROR;
	    }
	}
	if (ref == 0.0) {
	    if (buf2[1] != 0.0) {
		StrMake(errStr, errStrFmt[8], errBuf, buf2[0], buf2[1], buf2[2],
			buf2[3]);
		ErrorReport(__FILE__, __LINE__, errStr);
		return ERROR;
	    }
	} else if (ref == 1.0) {
	    if (ABS(buf2[1]-1.0) > epsilon.zero) {
		StrMake(errStr, errStrFmt[9], errBuf, buf2[0], buf2[1], buf2[2],
			buf2[3]);
		ErrorReport(__FILE__, __LINE__, errStr);
		return ERROR;
	    }
	} else {
	    if (ABS(buf1[1]-buf2[1]) > epsilon.color[1]) {
		StrMake(errStr, errStrFmt[12], errBuf, buf2[0], buf2[1],
			buf2[2], buf2[3], buf1[0], buf1[1], buf1[2], buf1[3]);
		ErrorReport(__FILE__, __LINE__, errStr);
		return ERROR;
	    }
	}
	break;
      case 2:
	if (buf2[0] != 0.0 || buf2[1] != 0.0) {
	    StrMake(errStr, errStrFmt[3], errBuf, buf2[0], buf2[1], buf2[2],
		    buf2[3]);
	    ErrorReport(__FILE__, __LINE__, errStr);
	    return ERROR;
	}
	if (buffer.colorBits[3] > 0) {
	    if (buf2[3] != 0.0) {
		StrMake(errStr, errStrFmt[4], errBuf, buf2[0], buf2[1], buf2[2],
			buf2[3]);
		ErrorReport(__FILE__, __LINE__, errStr);
		return ERROR;
	    }
	} else  {
	    if (ABS(buf2[3]-1.0) > epsilon.zero) {
		StrMake(errStr, errStrFmt[5], errBuf, buf2[0], buf2[1], buf2[2],
		        buf2[3]);
		ErrorReport(__FILE__, __LINE__, errStr);
		return ERROR;
	    }
	}
	if (ref == 0.0) {
	    if (buf2[2] != 0.0) {
		StrMake(errStr, errStrFmt[10], errBuf, buf2[0], buf2[1],
			buf2[2], buf2[3]);
		ErrorReport(__FILE__, __LINE__, errStr);
		return ERROR;
	    }
	} else if (ref == 1.0) {
	    if (ABS(buf2[2]-1.0) > epsilon.zero) {
		StrMake(errStr, errStrFmt[11], errBuf, buf2[0], buf2[1],
			buf2[2], buf2[3]);
		ErrorReport(__FILE__, __LINE__, errStr);
		return ERROR;
	    }
	} else {
	    if (ABS(buf1[2]-buf2[2]) > epsilon.color[2]) {
		StrMake(errStr, errStrFmt[12], errBuf, buf2[0], buf2[1],
			buf2[2], buf2[3], buf1[0], buf1[1], buf1[2], buf1[3]);
		ErrorReport(__FILE__, __LINE__, errStr);
		return ERROR;
	    }
	}
	break;
      case 3:
	if (buf2[0] != 0.0 || buf2[1] != 0.0 || buf2[2] != 0.0) {
	    StrMake(errStr, errStrFmt[0], errBuf, buf2[0], buf2[1], buf2[2],
		    buf2[3]);
	    ErrorReport(__FILE__, __LINE__, errStr);
	    return ERROR;
	}
	if (buffer.colorBits[3] > 0) {
	    if (ref == 0.0) {
		if (buf2[3] != 0.0) {
		    StrMake(errStr, errStrFmt[4], errBuf, buf2[0], buf2[1],
			    buf2[2], buf2[3]);
		    ErrorReport(__FILE__, __LINE__, errStr);
		    return ERROR;
		}
	    } else if (ref == 1.0) {
		if (ABS(buf2[3]-1.0) > epsilon.zero) {
		    StrMake(errStr, errStrFmt[5], errBuf, buf2[0], buf2[1],
			    buf2[2], buf2[3]);
		    ErrorReport(__FILE__, __LINE__, errStr);
		    return ERROR;
		}
	    } else {
		if (ABS(buf1[3]-buf2[3]) > epsilon.color[3]) {
		    StrMake(errStr, errStrFmt[12], errBuf, buf2[0], buf2[1],
			    buf2[2], buf2[3], buf1[0], buf1[1], buf1[2],
			    buf1[3]);
		    ErrorReport(__FILE__, __LINE__, errStr);
		    return ERROR;
		}
	    }
	} else {
	    if (ABS(buf2[3]-1.0) > epsilon.zero) {
		StrMake(errStr, errStrFmt[5], buf2[0], buf2[1], buf2[2],
			buf2[3]);
		ErrorReport(__FILE__, __LINE__, errStr);
		return ERROR;
	    }
	}
	break;
    }

    return NO_ERROR;
}

long BColorRGBExec(void)
{
    bColorRec data;
    GLint max, save; 
    GLenum i;

    save = buffer.doubleBuf;
    buffer.doubleBuf = GL_FALSE;

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    glClearColor(0.0, 0.0, 0.0, 1.0);
    glDisable(GL_DITHER);

    max = (machine.pathLevel == 0) ? 4 : 1;
    if (buffer.doubleBuf == GL_FALSE && buffer.stereoBuf == GL_FALSE) {
	data.buffer = GL_FRONT;
	for (data.component = 0; data.component < max; data.component++) {
	    if (RampUtil(0.0, 1.0, InitRGB, SetRGB, TestRGB, &data) == ERROR) {
		buffer.doubleBuf = save;
		return ERROR;
	    }
	}
    } else if (buffer.doubleBuf == GL_TRUE && buffer.stereoBuf == GL_FALSE) {
	data.buffer = GL_FRONT;
	for (data.component = 0; data.component < max; data.component++) {
	    if (RampUtil(0.0, 1.0, InitRGB, SetRGB, TestRGB, &data) == ERROR) {
		buffer.doubleBuf = save;
		return ERROR;
	    }
	}
	data.buffer = GL_BACK;
	for (data.component = 0; data.component < max; data.component++) {
	    if (RampUtil(0.0, 1.0, InitRGB, SetRGB, TestRGB, &data) == ERROR) {
		buffer.doubleBuf = save;
		return ERROR;
	    }
	}
    } else if (buffer.doubleBuf == GL_FALSE && buffer.stereoBuf == GL_TRUE) {
	data.buffer = GL_LEFT;
	for (data.component = 0; data.component < max; data.component++) {
	    if (RampUtil(0.0, 1.0, InitRGB, SetRGB, TestRGB, &data) == ERROR) {
		buffer.doubleBuf = save;
		return ERROR;
	    }
	}
	data.buffer = GL_RIGHT;
	for (data.component = 0; data.component < max; data.component++) {
	    if (RampUtil(0.0, 1.0, InitRGB, SetRGB, TestRGB, &data) == ERROR) {
		buffer.doubleBuf = save;
		return ERROR;
	    }
	}
    } else if (buffer.doubleBuf == GL_TRUE && buffer.stereoBuf == GL_TRUE) {
	data.buffer = GL_FRONT_LEFT;
	for (data.component = 0; data.component < max; data.component++) {
	    if (RampUtil(0.0, 1.0, InitRGB, SetRGB, TestRGB, &data) == ERROR) {
		buffer.doubleBuf = save;
		return ERROR;
	    }
	}
	data.buffer = GL_FRONT_RIGHT;
	for (data.component = 0; data.component < max; data.component++) {
	    if (RampUtil(0.0, 1.0, InitRGB, SetRGB, TestRGB, &data) == ERROR) {
		buffer.doubleBuf = save;
		return ERROR;
	    }
	}
	data.buffer = GL_BACK_LEFT;
	for (data.component = 0; data.component < max; data.component++) {
	    if (RampUtil(0.0, 1.0, InitRGB, SetRGB, TestRGB, &data) == ERROR) {
		buffer.doubleBuf = save;
		return ERROR;
	    }
	}
	data.buffer = GL_BACK_RIGHT;
	for (data.component = 0; data.component < max; data.component++) {
	    if (RampUtil(0.0, 1.0, InitRGB, SetRGB, TestRGB, &data) == ERROR) {
		buffer.doubleBuf = save;
		return ERROR;
	    }
	}
    }
    for (i = 0; i < buffer.auxBuf; i++) {
	data.buffer = GL_AUX0 + i;
	for (data.component = 0; data.component < max; data.component++) {
	    if (RampUtil(0.0, 1.0, InitRGB, SetRGB, TestRGB, &data) == ERROR) {
		buffer.doubleBuf = save;
		return ERROR;
	    }
	}
    }

    buffer.doubleBuf = save;
    return NO_ERROR;
}

/*****************************************************************************/

static void InitCI(void *data)
{
    bColorRec *ptr = (bColorRec *)data;

    GetEnumName(ptr->buffer, errBuf);

    glDrawBuffer(ptr->buffer);
    glReadBuffer(ptr->buffer);

    ptr->step = (machine.pathLevel == 0) ? 1.0 : 8.0;

    ptr->index = 0.0;
}

static void SetCI(void *data, float *ref)
{
    bColorRec *ptr = (bColorRec *)data;

    ptr->index = *ref;
    glIndexf(ptr->index);

    glBegin(GL_POINTS);
	glVertex2f(0.5, 0.5);
    glEnd();

    *ref += ptr->step;
}

static long TestCI(void *data, float ref)
{
    bColorRec *ptr = (bColorRec *)data;
    GLfloat buf1, buf2;

    ReadScreen(0, 0, 1, 1, GL_COLOR_INDEX, &buf1);
    glIndexf(buf1);

    glBegin(GL_POINTS);
	glVertex2f(0.5, 0.5);
    glEnd();

    ReadScreen(0, 0, 1, 1, GL_COLOR_INDEX, &buf2);

    if (ref == 0.0) {
        if (buf2 != 0.0) {
	    StrMake(errStr, errStrFmt[13], errBuf, buf2, 0.0);
	    ErrorReport(__FILE__, __LINE__, errStr);
            return ERROR;
        }
    } else if (ref == ptr->maxIndex) {
        if (buf2 != ptr->maxIndex) {
	    StrMake(errStr, errStrFmt[13], errBuf, buf2, ptr->maxIndex);
	    ErrorReport(__FILE__, __LINE__, errStr);
            return ERROR;
        }
    } else if (buf1 != buf2) {
	StrMake(errStr, errStrFmt[13], errBuf, buf1, buf2);
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }
    return NO_ERROR;
}

long BColorCIExec(void)
{
    bColorRec data;
    GLint save; 
    GLenum i;

    save = buffer.doubleBuf;
    buffer.doubleBuf = GL_FALSE;

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    glClearIndex(0);
    glDisable(GL_DITHER);

    data.maxIndex = POW(2.0, (float)buffer.ciBits) - 1.0;
    if (buffer.doubleBuf == GL_FALSE && buffer.stereoBuf == GL_FALSE) {
	data.buffer = GL_FRONT;
	if (RampUtil(0.0, data.maxIndex, InitCI, SetCI, TestCI,
                     &data) == ERROR) {
	    buffer.doubleBuf = save;
	    return ERROR;
	}
    } else if (buffer.doubleBuf == GL_TRUE && buffer.stereoBuf == GL_FALSE) {
	data.buffer = GL_FRONT;
	if (RampUtil(0.0, data.maxIndex, InitCI, SetCI, TestCI,
                     &data) == ERROR) {
	    buffer.doubleBuf = save;
	    return ERROR;
	}
	data.buffer = GL_BACK;
	if (RampUtil(0.0, data.maxIndex, InitCI, SetCI, TestCI,
                     &data) == ERROR) {
	    buffer.doubleBuf = save;
	    return ERROR;
	}
    } else if (buffer.doubleBuf == GL_FALSE && buffer.stereoBuf == GL_TRUE) {
	data.buffer = GL_LEFT;
	if (RampUtil(0.0, data.maxIndex, InitCI, SetCI, TestCI,
                     &data) == ERROR) {
	    buffer.doubleBuf = save;
	    return ERROR;
	}
	data.buffer = GL_RIGHT;
	if (RampUtil(0.0, data.maxIndex, InitCI, SetCI, TestCI,
                     &data) == ERROR) {
	    buffer.doubleBuf = save;
	    return ERROR;
	}
    } else if (buffer.doubleBuf == GL_TRUE && buffer.stereoBuf == GL_TRUE) {
	data.buffer = GL_FRONT_LEFT;
	if (RampUtil(0.0, data.maxIndex, InitCI, SetCI, TestCI,
                     &data) == ERROR) {
	    buffer.doubleBuf = save;
	    return ERROR;
	}
	data.buffer = GL_FRONT_RIGHT;
	if (RampUtil(0.0, data.maxIndex, InitCI, SetCI, TestCI,
                     &data) == ERROR) {
	    buffer.doubleBuf = save;
	    return ERROR;
	}
	data.buffer = GL_BACK_LEFT;
	if (RampUtil(0.0, data.maxIndex, InitCI, SetCI, TestCI,
                     &data) == ERROR) {
	    buffer.doubleBuf = save;
	    return ERROR;
	}
	data.buffer = GL_BACK_RIGHT;
	if (RampUtil(0.0, data.maxIndex, InitCI, SetCI, TestCI,
                     &data) == ERROR) {
	    buffer.doubleBuf = save;
	    return ERROR;
	}
    }
    for (i = 0; i < buffer.auxBuf; i++) {
	data.buffer = GL_AUX0 + i;
	if (RampUtil(0.0, data.maxIndex, InitCI, SetCI, TestCI,
                     &data) == ERROR) {
	    buffer.doubleBuf = save;
	    return ERROR;
	}
    }

    buffer.doubleBuf = save;
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\bclear.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** bclear.c
** Buffer Clear Test.
**
** Description -
**    For each available color buffer, a clear to both the
**    minimum and maximum color values are performed and
**    verified. The minimum and maximum color values for the
**    particular color buffer are determined by the number of
**    color bits.
**
** Error Explanation -
**    The color read back from a color buffer must match the
**    clear color (within a floating point zero epsilon only).
**
** Technical Specification -
**    Buffer requirements:
**        This test will be performed on all available buffers.
**    Color requirements:
**        RGBA or color index mode. Full color.
**    States requirements:
**        No state restrictions.
**    Error epsilon:
**        Zero epsilons.
**    Paths:
**        Allowed = Alias, Alpha, Blend, Depth, Dither, Fog, Logicop, Shade,
**                  Stencil, Stipple.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"


static char errBuf[40];
static char errStr[240];
static char errStrFmt[][160] = {
    "Buffer %s. Location (%d, %d). Color is (%1.1f, %1.1f, %1.1f), should be (%1.1f, %1.1f, %1.1f).",
    "Buffer %s. Location (%d, %d). Color index is %1.1f, should be %1.1f."
};


static long TestRGB(GLfloat *testColor, GLfloat *buf)
{
    GLfloat *ptr;
    long i, j;

    glClearColor(testColor[0], testColor[1], testColor[2], 1.0);
    glClear(GL_COLOR_BUFFER_BIT);

    ReadScreen(0, 0, WINDSIZEX, WINDSIZEY, GL_RGB, buf);

    ptr = buf;
    for (i = 0; i < WINDSIZEY; i++) {
	for (j = 0; j < WINDSIZEX; j++) {
	    if (ABS(ptr[0]-testColor[0]) > epsilon.zero ||
		ABS(ptr[1]-testColor[1]) > epsilon.zero ||
		ABS(ptr[2]-testColor[2]) > epsilon.zero) {
		StrMake(errStr, errStrFmt[0], errBuf, j, i, ptr[0], ptr[1],
			ptr[2], testColor[0], testColor[0], testColor[0]);
		ErrorReport(__FILE__, __LINE__, errStr);
		return ERROR;
	    }
	    ptr += 3;
	}
    }
    return NO_ERROR;
}

static long TestCI(GLfloat testColor, GLfloat *buf)
{
    GLfloat *ptr;
    long i, j;

    glClearIndex(testColor);
    glClear(GL_COLOR_BUFFER_BIT);

    ReadScreen(0, 0, WINDSIZEX, WINDSIZEY, GL_COLOR_INDEX, buf);

    ptr = buf;
    for (i = 0; i < WINDSIZEY; i++) {
	for (j = 0; j < WINDSIZEX; j++) {
	    if (ABS(*ptr-testColor) > epsilon.zero) {
		StrMake(errStr, errStrFmt[1], errBuf, j, i, *ptr, testColor);
		ErrorReport(__FILE__, __LINE__, errStr);
		return ERROR;
	    }
	    ptr++;
	}
    }
    return NO_ERROR;
}

static long Test(GLenum srcBuf, GLfloat *buf)
{
    static GLfloat minRGB[] = {
	0.0, 0.0, 0.0
    };
    static GLfloat maxRGB[] = {
	1.0, 1.0, 1.0
    };

    GetEnumName(srcBuf, errBuf);

    glDrawBuffer(srcBuf);
    glReadBuffer(srcBuf);

    if (buffer.colorMode == GL_RGB) {
	if (TestRGB(minRGB, buf)) {
	    return ERROR;
	}
	if (TestRGB(maxRGB, buf)) {
	    return ERROR;
	}
    } else {
	if (TestCI(0, buf)) {
	    return ERROR;
	}
	if (TestCI((long)POW(2.0, (GLfloat)buffer.ciBits)-1, buf)) {
	    return ERROR;
	}
    }

    return NO_ERROR;
}

long BClearExec(void)
{
    GLfloat *buf;
    GLint save, i;

    save = buffer.doubleBuf;
    buffer.doubleBuf = GL_FALSE;

    buf = (GLfloat *)MALLOC(WINDSIZEX*WINDSIZEY*3*sizeof(GLfloat));

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    if (buffer.doubleBuf == GL_FALSE && buffer.stereoBuf == GL_FALSE) {
	if (Test(GL_FRONT, buf) == ERROR) {
	    FREE(buf);
	    buffer.doubleBuf = save;
	    return ERROR;
	}
    } else if (buffer.doubleBuf == GL_TRUE && buffer.stereoBuf == GL_FALSE) {
	if (Test(GL_FRONT, buf) == ERROR) {
	    FREE(buf);
	    buffer.doubleBuf = save;
	    return ERROR;
	}
	if (Test(GL_BACK, buf) == ERROR) {
	    FREE(buf);
	    buffer.doubleBuf = save;
	    return ERROR;
	}
    } else if (buffer.doubleBuf == GL_FALSE && buffer.stereoBuf == GL_TRUE) {
	if (Test(GL_LEFT, buf) == ERROR) {
	    FREE(buf);
	    buffer.doubleBuf = save;
	    return ERROR;
	}
	if (Test(GL_RIGHT, buf) == ERROR) {
	    FREE(buf);
	    buffer.doubleBuf = save;
	    return ERROR;
	}
    } else if (buffer.doubleBuf == GL_TRUE && buffer.stereoBuf == GL_TRUE) {
	if (Test(GL_FRONT_LEFT, buf) == ERROR) {
	    FREE(buf);
	    buffer.doubleBuf = save;
	    return ERROR;
	}
	if (Test(GL_FRONT_RIGHT, buf) == ERROR) {
	    FREE(buf);
	    buffer.doubleBuf = save;
	    return ERROR;
	}
	if (Test(GL_BACK_LEFT, buf) == ERROR) {
	    FREE(buf);
	    buffer.doubleBuf = save;
	    return ERROR;
	}
	if (Test(GL_BACK_RIGHT, buf) == ERROR) {
	    FREE(buf);
	    buffer.doubleBuf = save;
	    return ERROR;
	}
    }
    for (i = 0; i < buffer.auxBuf; i++) {
	if (Test(GL_AUX0+(GLenum)i, buf) == ERROR) {
	    FREE(buf);
	    buffer.doubleBuf = save;
	    return ERROR;
	}
    }

    FREE(buf);
    buffer.doubleBuf = save;
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\bexact.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** bexact.c
** Buffer Invariance Test.
**
** Description -
**    Tests the primitive invariance between color buffers. A
**    primitive is drawn in the front color buffer (which must
**    exist) and read back. The same primitive is then drawn
**    into any other available color buffers (back, auxiliary,
**    stereo) and compared to the saved image. To insure
**    thorough testing, many different primitives are used.
**
** Error Explanation -
**    Failure occurs if primitives do not match pixel-exact
**    between all available color buffers.
**
** Technical Specification -
**    Buffer requirements:
**        This test will be performed on all available buffers.
**    Color requirements:
**        RGBA or color index mode. Full color.
**    States requirements:
**        No state restrictions.
**    Error epsilon:
**        Zero epsilon.
**    Paths:
**        Allowed = Alias, Alpha, Blend, Depth, Dither, Fog, Logicop, Shade,
**                  Stencil, Stipple.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"


static long errX, errY;
static char errPrim[40];
static char errStr[240];
static char errStrFmt[][160] = {
    "Primitive %s did not render into source buffer %s.",
    "Mismatch at (%d, %d) with primitive %s. Source buffer is %s, destination buffer is %s."
};


static void Point(void)
{

    GetEnumName(GL_POINTS, errPrim);
    glBegin(GL_POINTS);
	SETCOLOR(RED);
	glVertex2i(WINDSIZEX/2, WINDSIZEY/2);
    glEnd();
}

static void Line(void)
{

    GetEnumName(GL_LINES, errPrim);
    glBegin(GL_LINES);
	SETCOLOR(GREEN);
	glVertex2i(WINDSIZEX/3, WINDSIZEY/3);
	SETCOLOR(BLUE);
	glVertex2i(WINDSIZEX*2/3, WINDSIZEY*2/3);
    glEnd();
}

static void LineStrip(void)
{

    GetEnumName(GL_LINE_STRIP, errPrim);
    glBegin(GL_LINE_STRIP);
	SETCOLOR(RED);
	glVertex2i(WINDSIZEX/4, WINDSIZEY/4);
	SETCOLOR(GREEN);
	glVertex2i(WINDSIZEX/4, WINDSIZEY*3/4);
	SETCOLOR(BLUE);
	glVertex2i(WINDSIZEX*3/4, WINDSIZEY*3/4);
	SETCOLOR(RED);
	glVertex2i(WINDSIZEX*3/4, WINDSIZEY/4);
	SETCOLOR(GREEN);
	glVertex2i(WINDSIZEX/4, WINDSIZEY/4);
    glEnd();
}

static void LineLoop(void)
{

    GetEnumName(GL_LINE_LOOP, errPrim);
    glBegin(GL_LINE_LOOP);
	SETCOLOR(BLUE);
	glVertex2i(WINDSIZEX/4, WINDSIZEY/4);
	SETCOLOR(RED);
	glVertex2i(WINDSIZEX/4, WINDSIZEY*3/4);
	SETCOLOR(GREEN);
	glVertex2i(WINDSIZEX*3/4, WINDSIZEY*3/4);
	SETCOLOR(BLUE);
	glVertex2i(WINDSIZEX*3/4, WINDSIZEY/4);
    glEnd();
}

static void Tri(void)
{

    GetEnumName(GL_TRIANGLES, errPrim);
    glBegin(GL_TRIANGLES);
	SETCOLOR(RED);
	glVertex2i(WINDSIZEX/4, WINDSIZEY/4);
	SETCOLOR(GREEN);
	glVertex2i(WINDSIZEX/2, WINDSIZEY*3/4);
	SETCOLOR(BLUE);
	glVertex2i(WINDSIZEX*3/4, WINDSIZEY/4);
    glEnd();
}

static void TriStrip(void)
{

    GetEnumName(GL_TRIANGLE_STRIP, errPrim);
    glBegin(GL_TRIANGLE_STRIP);
	SETCOLOR(RED);
	glVertex2i(WINDSIZEX/4, WINDSIZEY/4);
	SETCOLOR(GREEN);
	glVertex2i(WINDSIZEX/2, WINDSIZEY*3/4);
	SETCOLOR(BLUE);
	glVertex2i(WINDSIZEX/2, WINDSIZEY/4);
	SETCOLOR(RED);
	glVertex2i(WINDSIZEX*3/4, WINDSIZEY*3/4);
    glEnd();
}

static void TriFan(void)
{

    GetEnumName(GL_TRIANGLE_FAN, errPrim);
    glBegin(GL_TRIANGLE_FAN);
	SETCOLOR(GREEN);
	glVertex2i(WINDSIZEX/4, WINDSIZEY/4);
	SETCOLOR(BLUE);
	glVertex2i(WINDSIZEX*3/4, WINDSIZEY/4);
	SETCOLOR(RED);
	glVertex2i(WINDSIZEX*3/4, WINDSIZEY*3/4);
	SETCOLOR(GREEN);
	glVertex2i(WINDSIZEX/4, WINDSIZEY*3/4);
    glEnd();
}

static void Quad(void)
{

    GetEnumName(GL_QUADS, errPrim);
    glBegin(GL_QUADS);
	SETCOLOR(BLUE);
	glVertex2i(WINDSIZEX/4, WINDSIZEY/4);
	SETCOLOR(RED);
	glVertex2i(WINDSIZEX/2, WINDSIZEY*3/4);
	SETCOLOR(GREEN);
	glVertex2i(WINDSIZEX*3/4, WINDSIZEY*3/4);
	SETCOLOR(BLUE);
	glVertex2i(WINDSIZEX/2, WINDSIZEY/4);
    glEnd();
}

static void QuadStrip(void)
{

    GetEnumName(GL_QUAD_STRIP, errPrim);
    glBegin(GL_QUAD_STRIP);
	SETCOLOR(RED);
	glVertex2i(WINDSIZEX/5, WINDSIZEY/4);
	SETCOLOR(GREEN);
	glVertex2i(WINDSIZEX*2/5, WINDSIZEY*3/4);
	SETCOLOR(BLUE);
	glVertex2i(WINDSIZEX*2/5, WINDSIZEY/4);
	SETCOLOR(RED);
	glVertex2i(WINDSIZEX*3/5, WINDSIZEY*3/4);
	SETCOLOR(GREEN);
	glVertex2i(WINDSIZEX*3/5, WINDSIZEY/4);
	SETCOLOR(BLUE);
	glVertex2i(WINDSIZEX*4/5, WINDSIZEY*3/4);
    glEnd();
}

static void Rect(void)
{

    STRCOPY(errPrim, "Rectangles");
    SETCOLOR(RED);
    glRects(WINDSIZEX/4, WINDSIZEY/4, WINDSIZEX*3/4, WINDSIZEY*3/4);
}

static void PolyPoint(void)
{

    STRCOPY(errPrim, "Polygons (point mode)");
    glPolygonMode(GL_FRONT_AND_BACK, GL_POINT);
    glBegin(GL_POLYGON);
	SETCOLOR(GREEN);
	glVertex2i(WINDSIZEX/4, WINDSIZEY*2/5);
	SETCOLOR(BLUE);
	glVertex2i(WINDSIZEX/4, WINDSIZEY*3/5);
	SETCOLOR(RED);
	glVertex2i(WINDSIZEX/2, WINDSIZEY*4/5);
	SETCOLOR(GREEN);
	glVertex2i(WINDSIZEX*3/4, WINDSIZEY*3/5);
	SETCOLOR(BLUE);
	glVertex2i(WINDSIZEX*3/4, WINDSIZEY*2/5);
	SETCOLOR(RED);
	glVertex2i(WINDSIZEX/2, WINDSIZEY/5);
    glEnd();
}

static void PolyLine(void)
{

    STRCOPY(errPrim, "Polygons (line mode)");
    glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
    glBegin(GL_POLYGON);
	SETCOLOR(GREEN);
	glVertex2i(WINDSIZEX/4, WINDSIZEY*2/5);
	SETCOLOR(BLUE);
	glVertex2i(WINDSIZEX/4, WINDSIZEY*3/5);
	SETCOLOR(RED);
	glVertex2i(WINDSIZEX/2, WINDSIZEY*4/5);
	SETCOLOR(GREEN);
	glVertex2i(WINDSIZEX*3/4, WINDSIZEY*3/5);
	SETCOLOR(BLUE);
	glVertex2i(WINDSIZEX*3/4, WINDSIZEY*2/5);
	SETCOLOR(RED);
	glVertex2i(WINDSIZEX/2, WINDSIZEY/5);
    glEnd();
}

static void PolyFill(void)
{

    STRCOPY(errPrim, "Polygons (fill mode)");
    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
    glBegin(GL_POLYGON);
	SETCOLOR(GREEN);
	glVertex2i(WINDSIZEX/4, WINDSIZEY*2/5);
	SETCOLOR(BLUE);
	glVertex2i(WINDSIZEX/4, WINDSIZEY*3/5);
	SETCOLOR(RED);
	glVertex2i(WINDSIZEX/2, WINDSIZEY*4/5);
	SETCOLOR(GREEN);
	glVertex2i(WINDSIZEX*3/4, WINDSIZEY*3/5);
	SETCOLOR(BLUE);
	glVertex2i(WINDSIZEX*3/4, WINDSIZEY*2/5);
	SETCOLOR(RED);
	glVertex2i(WINDSIZEX/2, WINDSIZEY/5);
    glEnd();
}

static long CheckNonZero(GLfloat *buf)
{
    long i;

    if (buffer.colorMode == GL_RGB) {
	ReadScreen(0, 0, WINDSIZEX, WINDSIZEY, GL_RGB, buf);
	for (i = 0; i < WINDSIZEX*WINDSIZEY*3; i++) {
	    if (buf[i] > epsilon.zero) {
		return NO_ERROR;
	    }
	}
    } else {
	ReadScreen(0, 0, WINDSIZEX, WINDSIZEY, GL_COLOR_INDEX, buf);
	for (i = 0; i < WINDSIZEX*WINDSIZEY; i++) {
	    if (buf[i] > epsilon.zero) {
		return NO_ERROR;
	    }
	}
    }
    return ERROR;
}

static long CheckSame(GLfloat *buf1, GLfloat *buf2)
{
    long i, j, k;

    if (buffer.colorMode == GL_RGB) {
	ReadScreen(0, 0, WINDSIZEX, WINDSIZEY, GL_RGB, buf2);
	for (i = 0; i < WINDSIZEY; i++) {
	    for (j = 0; j < WINDSIZEX; j++) {
		k = (i * WINDSIZEX + j) * 3;
		if (ABS(buf1[k]-buf2[k]) > epsilon.zero ||
		    ABS(buf1[k+1]-buf2[k+1]) > epsilon.zero ||
		    ABS(buf1[k+2]-buf2[k+2]) > epsilon.zero) {
		    errX = j;
		    errY = i;
		    return ERROR;
		}
	    }
	}
    } else {
	ReadScreen(0, 0, WINDSIZEX, WINDSIZEY, GL_COLOR_INDEX, buf2);
	for (i = 0; i < WINDSIZEY; i++) {
	    for (j = 0; j < WINDSIZEX; j++) {
		k = i * WINDSIZEX + j;
		if (ABS(buf1[k]-buf2[k]) > epsilon.zero) {
		    errX = j;
		    errY = i;
		    return ERROR;
		}
	    }
	}
    }

    return NO_ERROR;
}

static long Compare(GLenum srcBuf, GLenum destBuf, void (*Func)(void), 
		    GLfloat *buf1, GLfloat *buf2)
{
    char tmp1[40], tmp2[40];

    GetEnumName(srcBuf, tmp1);
    GetEnumName(destBuf, tmp2);

    glDrawBuffer(srcBuf);
    glReadBuffer(srcBuf);

    glClear(GL_COLOR_BUFFER_BIT);
    (*Func)();
    if (CheckNonZero(buf1) == ERROR) {
	StrMake(errStr, errStrFmt[0], errPrim, tmp1);
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }

    glDrawBuffer(destBuf);
    glReadBuffer(destBuf);

    glClear(GL_COLOR_BUFFER_BIT);
    (*Func)();
    if (CheckSame(buf1, buf2) == ERROR) {
	StrMake(errStr, errStrFmt[1], errX, errY, errPrim, tmp1, tmp2);
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }

    return NO_ERROR;
}

static long Test1(GLenum *list, GLfloat *buf1, GLfloat *buf2)
{
    long i;

    for (i = 1; list[i] != GL_NULL; i++) {
	if (Compare(list[0], list[i], Point, buf1, buf2) == ERROR) {
	    return ERROR;
	}
	if (Compare(list[0], list[i], Line, buf1, buf2) == ERROR) {
	    return ERROR;
	}
	if (Compare(list[0], list[i], LineStrip, buf1, buf2) == ERROR) {
	    return ERROR;
	}
	if (Compare(list[0], list[i], LineLoop, buf1, buf2) == ERROR) {
	    return ERROR;
	}
	if (Compare(list[0], list[i], Tri, buf1, buf2) == ERROR) {
	    return ERROR;
	}
	if (Compare(list[0], list[i], TriStrip, buf1, buf2) == ERROR) {
	    return ERROR;
	}
	if (Compare(list[0], list[i], TriFan, buf1, buf2) == ERROR) {
	    return ERROR;
	}
	if (Compare(list[0], list[i], Quad, buf1, buf2) == ERROR) {
	    return ERROR;
	}
	if (Compare(list[0], list[i], QuadStrip, buf1, buf2) == ERROR) {
	    return ERROR;
	}
	if (Compare(list[0], list[i], Rect, buf1, buf2) == ERROR) {
	    return ERROR;
	}
	if (Compare(list[0], list[i], PolyPoint, buf1, buf2) == ERROR) {
	    return ERROR;
	}
	if (Compare(list[0], list[i], PolyLine, buf1, buf2) == ERROR) {
	    return ERROR;
	}
	if (Compare(list[0], list[i], PolyFill, buf1, buf2) == ERROR) {
	    return ERROR;
	}
    }
    return NO_ERROR;
}

static long Test2(GLenum *list, GLfloat *buf1, GLfloat *buf2)
{
    long i;

    for (i = 1; list[i] != GL_NULL; i++) {
	if (Compare(list[0], list[i], PolyPoint, buf1, buf2) == ERROR) {
	    return ERROR;
	}
	if (Compare(list[0], list[i], PolyLine, buf1, buf2) == ERROR) {
	    return ERROR;
	}
	if (Compare(list[0], list[i], PolyFill, buf1, buf2) == ERROR) {
            #ifdef LATER
            Sleep(1000);
            tkSwapBuffers();
            Sleep(5000);
            #endif
	    return ERROR;
	}
    }
    return NO_ERROR;
}

long BExactExec(void)
{
    GLfloat *buf1, *buf2;
    GLenum list[10], i, j; 
    GLint save;
    long flag;

    buf1 = (GLfloat *)MALLOC(WINDSIZEX*WINDSIZEY*3*sizeof(GLfloat));
    buf2 = (GLfloat *)MALLOC(WINDSIZEX*WINDSIZEY*3*sizeof(GLfloat));
    flag = NO_ERROR;

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    SETCLEARCOLOR(BLACK);

    i = 0;
    if (buffer.doubleBuf == GL_FALSE && buffer.stereoBuf == GL_FALSE) {
	list[i++] = GL_FRONT;
	for (j = 0; j < buffer.auxBuf; j++) {
	    list[i++] = GL_AUX0+j;
	}
    } else if (buffer.doubleBuf == GL_TRUE && buffer.stereoBuf == GL_FALSE) {
	list[i++] = GL_FRONT;
	list[i++] = GL_BACK;
	for (j = 0; j < buffer.auxBuf; j++) {
	    list[i++] = GL_AUX0+j;
	}
    } else if (buffer.doubleBuf == GL_FALSE && buffer.stereoBuf == GL_TRUE) {
	list[i++] = GL_LEFT;
	list[i++] = GL_RIGHT;
	for (j = 0; j < buffer.auxBuf; j++) {
	    list[i++] = GL_AUX0+j;
	}
    } else if (buffer.doubleBuf == GL_TRUE && buffer.stereoBuf == GL_TRUE) {
	list[i++] = GL_FRONT_LEFT;
	list[i++] = GL_FRONT_RIGHT;
	list[i++] = GL_BACK_LEFT;
	list[i++] = GL_BACK_RIGHT;
	for (j = 0; j < buffer.auxBuf; j++) {
	    list[i++] = GL_AUX0+j;
	}
    }
    list[i++] = GL_NULL;

    save = buffer.doubleBuf;
    buffer.doubleBuf = GL_FALSE;
    if (machine.pathLevel == 0) {
	if (Test1(list, buf1, buf2) == ERROR) {
	    flag = ERROR;
	}
    } else {
	if (Test2(list, buf1, buf2) == ERROR) {
	    flag = ERROR;
	}
    }
    buffer.doubleBuf = save;

    FREE(buf1);
    FREE(buf2);
    return flag;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\bitmap.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** bitmap.c
** Bitmap Test.
**
** Description -
**    A bitmap is made. It's image pattern, size, x and y
**    location, x and y offsets and x and y increments are
**    randomly chosen. It is drawn and verified by checking both
**    the rendered image and a surrounding rectangle area (for
**    correct size). A second bitmap is made. It's image pattern,
**    size, x and y offsets and x and y increments are randomly
**    chosen but its x and y location is determined by the
**    previous bitmap (initial raster position plus x and y
**    increments). The second bitmap is drawn and verified in the
**    same way as the first bitmap.
**
** Error Explanation -
**    Failure occurs if the rendered bitmaps do not match their
**    original bit pattern images, if the first bitmap is not
**    rendered at the initial raster position or if the second
**    bitmap is not rendered at the final raster position.
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer.
**    Color requirements:
**        RGBA or color index mode. 2 colors.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**    Paths:
**        Allowed = Alpha, Blend, Depth, Fog, Logicop, Shade, Stencil, Stipple.
**        Not allowed = Alias, Dither.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"


static char errStr[160];
static char errStrFmt[][80] = {
    "Bitmap was rendered to large along the %s edge.",
    "Bitmap was rendered incorrectly at bitmap position (%d, %d).",
};


static void MakeMap(GLubyte *map)
{
    long i;

    for (i = 0; i < WINDSIZEX*WINDSIZEY; i++) {
	map[i] = (GLubyte)Random(0.0, 255.0);
    }
}

static long Check(GLint destX, GLint destY, GLsizei sizeX, GLsizei sizeY,
		  GLubyte *map, GLfloat *buf)
{
    GLubyte mapByte=0, mask;
    GLfloat *ptr;
    long shift, i, j;

    ReadScreen(destX-1, destY-1, sizeX+2, sizeY+2, GL_AUTO_COLOR, buf);

    ptr = buf;

    /*
    ** Check outside bottom.
    */
    for (i = 0; i < sizeX+2; i++) {
	if (AutoColorCompare(*ptr, COLOR_OFF) == GL_FALSE) {
	    StrMake(errStr, errStrFmt[0], "lower");
	    ErrorReport(__FILE__, __LINE__, errStr);
	    return ERROR;
	}
	ptr++;
    }

    /*
    ** Check Bitmap.
    */
    for (i = 0; i < sizeY; i++) {
	/*
	** Check outside left.
	*/
	if (AutoColorCompare(*ptr, COLOR_OFF) == GL_FALSE) {
	    StrMake(errStr, errStrFmt[0], "left");
	    ErrorReport(__FILE__, __LINE__, errStr);
	    return ERROR;
	}
	ptr++;

	/*
	** Check inside.
	*/
	shift = 8;
	for (j = 0; j < sizeX; j++) {
	    if (shift == 8) {
		shift = 0;
		mapByte = *map++;
	    }
	    mask = 0x80 >> shift;
	    if (mapByte & mask) {
		if (AutoColorCompare(*ptr, COLOR_ON) == GL_FALSE) {
		    StrMake(errStr, errStrFmt[1], j, i);
		    ErrorReport(__FILE__, __LINE__, errStr);
		    return ERROR;
		}
		ptr++;
	    } else {
		if (AutoColorCompare(*ptr, COLOR_OFF) == GL_FALSE) {
		    StrMake(errStr, errStrFmt[1], j, i);
		    ErrorReport(__FILE__, __LINE__, errStr);
		    return ERROR;
		}
		ptr++;
	    }
	    shift++;
	}

	/*
	** Check outside right.
	*/
	if (AutoColorCompare(*ptr, COLOR_OFF) == GL_FALSE) {
	    StrMake(errStr, errStrFmt[0], "right");
	    ErrorReport(__FILE__, __LINE__, errStr);
	    return ERROR;
	}
	ptr++;
    }

    /*
    ** Check outside top.
    */
    for (i = 0; i < sizeX+2; i++) {
	if (AutoColorCompare(*ptr, COLOR_OFF) == GL_FALSE) {
	    StrMake(errStr, errStrFmt[0], "top");
	    ErrorReport(__FILE__, __LINE__, errStr);
	    return ERROR;
	}
	ptr++;
    }

    return NO_ERROR;
}

static long Test(GLubyte *map, GLfloat *buf)
{
    GLfloat rastX, rastY, offsetX, offsetY, incX, incY;
    GLsizei sizeX, sizeY; 
    GLint x, y, max, i;

    max = (machine.pathLevel == 0) ? 10 : 5;
    for (i = 0; i < max; i++) {
	glClear(GL_COLOR_BUFFER_BIT);

	MakeMap(map);
	sizeX = (GLsizei)Random(1.0, WINDSIZEX/16.0);
	sizeY = (GLsizei)Random(1.0, WINDSIZEY/16.0);
	offsetX = (GLfloat)((GLint)Random(-sizeX, sizeX)) + Random(0.1, 0.9);
	offsetY = (GLfloat)((GLint)Random(-sizeY, sizeY)) + Random(0.1, 0.9);
	incX = (GLfloat)((GLint)Random(-WINDSIZEX/16.0, WINDSIZEX/16.0)) +
	       Random(0.1, 0.9);
	incY = (GLfloat)((GLint)Random(-WINDSIZEY/16.0, WINDSIZEY/16.0)) +
	       Random(0.1, 0.9);

	rastX = (GLfloat)((GLint)Random(WINDSIZEX/4.0, WINDSIZEX*3.0/4.0));
	rastY = (GLfloat)((GLint)Random(WINDSIZEY/4.0, WINDSIZEY*3.0/4.0));
	glRasterPos2f(rastX, rastY);

	glBitmap(sizeX, sizeY, offsetX, offsetY, incX, incY, map);

	x = (GLint)(rastX - offsetX);
	y = (GLint)(rastY - offsetY);

	if (Check(x, y, sizeX, sizeY, map, buf) == ERROR) {
	    return ERROR;
	}

	glClear(GL_COLOR_BUFFER_BIT);

	MakeMap(map);
	sizeX = (GLsizei)Random(1.0, WINDSIZEX/16.0);
	sizeY = (GLsizei)Random(1.0, WINDSIZEY/16.0);
	offsetX = (GLfloat)((GLint)Random(-sizeX, sizeX)) + Random(0.1, 0.9);
	offsetY = (GLfloat)((GLint)Random(-sizeY, sizeY)) + Random(0.1, 0.9);

	rastX += incX;
	rastY += incY;

	glBitmap(sizeX, sizeY, offsetX, offsetY, 0.0, 0.0, map);

	x = (GLint)(rastX - offsetX);
	y = (GLint)(rastY - offsetY);

	/*
	** If randomly chosen values cause position to fall near
	** a pixel borderline, don't test it.
	*/
	if ( ABS((rastX - offsetX) - (float)x) > 0.95 ||
	     ABS((rastX - offsetX) - (float)x) < 0.05 ||
	     ABS((rastY - offsetY) - (float)y) > 0.95 ||
	     ABS((rastY - offsetY) - (float)y) < 0.05) {
	    continue;
        }
	if (Check(x, y, sizeX, sizeY, map, buf) == ERROR) {
	    return ERROR;
	}
    }
    return NO_ERROR;
}

long BitmapExec(void)
{
    GLubyte *map;
    GLfloat *buf; 
    long flag;

    map = (GLubyte *)MALLOC(WINDSIZEX*WINDSIZEY*sizeof(GLubyte));
    buf = (GLfloat *)MALLOC(WINDSIZEX*WINDSIZEY*sizeof(GLfloat));
    flag = NO_ERROR;

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    AutoClearColor(COLOR_OFF);
    AutoColor(COLOR_ON);
    glDisable(GL_DITHER);
    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);

    if (Test(map, buf) == ERROR) {
	flag = ERROR;
    }

    glPixelStorei(GL_UNPACK_ALIGNMENT, 4);
    FREE(map);
    FREE(buf);
    return flag;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\colramp.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** colramp.c
** Color Ramp Test.
**
** Description -
**    Tests the RGB color ramp. Three tests are performed on each
**    color component (red, green and blue); monotonicity,
**    consistency between individual color shades and total
**    number of color shades. Given the number of bits for a
**    color component, the minimum increment from one color shade
**    to another can be calculated. By stepping from one color
**    shade to the next with an increment smaller then this
**    minimum increment, individual color shades can be isolated.
**    The monotonicity of the color component can be checked. The
**    granularity of the colors can be checked for consistency,
**    and the total number of individual color shades can be
**    counted.
**
** Error Explanation -
**    Failure occurs if any of the color components is not
**    monotonic increasing, if the color granularity is not
**    constant over the entire color range or if the total number
**    of individual color shades does not match the number
**    calculated from the given number of bits per color
**    component.
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer.
**    Color requirements:
**        RGBA mode. Full color.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**    Paths:
**        Allowed = Alpha, Blend, Depth, Fog, Logicop, Shade, Stencil, Stipple.
**        Not allowed = Alias, Dither.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"
#include "utilru.h"


typedef struct _colRampRec {
    long component;
    float step, lastValue, lastDelta;
    GLfloat color[3];
    long maxColor, colorCount;
} colRampRec;


static void Init(void *data)
{
    colRampRec *ptr = (colRampRec *)data;
    float step;

    ptr->lastValue = -1.0;
    ptr->lastDelta = -2.0;

    ptr->colorCount = 0;
    ptr->maxColor = 1 << buffer.colorBits[ptr->component];

    step = (machine.pathLevel == 0) ? 16.0 : 2.0;
    ptr->step = (1.0 / (float)(ptr->maxColor - 1)) / step;

    ptr->color[0] = 0.0;
    ptr->color[1] = 0.0;
    ptr->color[2] = 0.0;
}

static void Set(void *data, float *ref)
{
    colRampRec *ptr = (colRampRec *)data;

    ptr->color[ptr->component] = *ref;
    glColor3fv(ptr->color);

    glBegin(GL_POINTS);
	glVertex2f(0.5, 0.5);
    glEnd();

    *ref += ptr->step;
}

static long Test(void *data, float ref)
{
    colRampRec *ptr = (colRampRec *)data;
    char str[240];
    GLfloat buf[3]; 
    float value, delta;
    long i;

    ReadScreen(0, 0, 1, 1, GL_RGB, buf);

    for (i = 0; i < 3; i++) {
	if (buf[i] != 0.0 && i != ptr->component) {
	    ColorError_RGBZero(str, ptr->component, buf);
	    ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
    }

    value = buf[ptr->component];
    if (ptr->lastDelta == -2.0) {
	ptr->lastDelta = -1.0;
	ptr->lastValue = value;
	ptr->colorCount++;
    } else if (ptr->lastDelta == -1.0) {
	if (value < ptr->lastValue) {
	    ColorError_RGBMonotonic(str, ptr->component, value, ptr->lastValue);
	    ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	if (ABS(delta) > epsilon.zero) {
	    if (ABS(delta-ptr->step) > epsilon.color[ptr->component]) {
		ColorError_RGBStep(str, ptr->component, delta, ptr->step);
		ErrorReport(__FILE__, __LINE__, str);
		return ERROR;
	    }
	    ptr->lastDelta = delta;
	    ptr->colorCount++;
	}
    } else {
	if (value < ptr->lastValue) {
	    ColorError_RGBMonotonic(str, ptr->component, value, ptr->lastValue);
	    ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	if (ABS(delta) > epsilon.zero) {
	    if (ABS(delta-ptr->step) > epsilon.color[ptr->component]) {
		ColorError_RGBStep(str, ptr->component, delta, ptr->step);
		ErrorReport(__FILE__, __LINE__, str);
		return ERROR;
	    }
	    if (ABS(delta-ptr->lastDelta) > epsilon.zero) {
		ColorError_RGBDelta(str, ptr->component, delta, ptr->lastDelta);
		ErrorReport(__FILE__, __LINE__, str);
		return ERROR;
	    }
	    ptr->lastDelta = delta;
	    ptr->colorCount++;
	}
    }

    if (ref >= 1.0 && value < (1.0 - epsilon.zero)) {
	ColorError_RGBClamp(str, ptr->component, value);
	ErrorReport(__FILE__, __LINE__, str);
	return ERROR;
    }

    return NO_ERROR;
}

long ColRampExec(void)
{
    colRampRec data;
    char str[240];
    long max;

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glDisable(GL_DITHER);

    max = (machine.pathLevel == 0) ? 3 : 1;
    for (data.component = 0; data.component < max; data.component++) {
	if (RampUtil(0.0, 1.0, Init, Set, Test, &data) == ERROR) {
	    return ERROR;
	}
	if (data.colorCount != data.maxColor) {
	    ColorError_RGBCount(str, data.component, data.colorCount,
				data.maxColor);
	    ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\dither.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** dither.c
** Dither Test.
**
** Description -
**    Tests dithering by drawing rectangles of various shades
**    with both dithering enabled and disabled, and comparing
**    results to ensure that corresponding fragments differ by no
**    more than one shade. Since dithering may depend upon x and
**    y window coordinates, fragments compared must come from the
**    same window location. For visuals with up to 256 colors,
**    the tests uses each color. For deeper visuals, it skips
**    over some to test up to 256 shades.
**
** Error Explanation -
**    Failure occurs if the comparison between the original
**    fragment color and the dithered fragment color varies by
**    more then one shade of color.
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer.
**    Color requirements:
**        RGBA or color index mode. 4 colors.
**    States requirements:
**    Error epsilon:
**        color epsilon.
**    Paths:
**        Allowed = Alias, Alpha, Blend, Depth, Dither, Fog, Logicop, Shade,
**                  Stencil, Stipple.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"


static char errStr[240];
static char errStrFmt[][160] = {
    "Undithered color is (%1.1f, %1.1f, %1.1f). Dithered color is (%1.1f, %1.1f, %1.1f).",
    "Undithered color index is %1.0f. Dithered color index is %1.0f."
};


long DitherCIExec(void)
{
    GLfloat *buf, *ref, deltaX, deltaY;
    GLint i, j, k, max, step, nRects, row, col, maxSteps;
    GLint ci;

    buf = (GLfloat *)MALLOC(WINDSIZEX*WINDSIZEY*sizeof(GLfloat));
    ref = (GLfloat *)MALLOC(WINDSIZEX*WINDSIZEY*sizeof(GLfloat));

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    /*
    ** Test up to 256 colors, evenly spaced in ramp.
    */
    max = 1 << buffer.ciBits;
    maxSteps = (machine.pathLevel == 0) ? 256 : 23;
    step = (max > maxSteps) ? (max / maxSteps) : 1;
    nRects = (max < 10) ? max : 10;
    deltaX = WINDSIZEX / (float)nRects;
    deltaY = WINDSIZEY / (float)nRects;

    /*
    ** Draw a 10x10 grid of colors (or up to the number of colors in existing).
    ** First draw without dithering, then repeat with dithering.
    */
    i = 0;
    while (i < max) {
	glDisable(GL_DITHER);
	k = 0;
	ci = i;
	while ((k < nRects*nRects) && (ci < max)) {
	    glIndexi(ci);
	    row = k / 10;
	    col = k % 10;
	    glRectf(col*deltaX, row*deltaY, (col+1)*deltaX, (row+1)*deltaY);
	    k++;
	    ci += step;
	}
	ReadScreen(0, 0, WINDSIZEX, WINDSIZEY, GL_COLOR_INDEX, ref);

	glEnable(GL_DITHER);
	k = 0;
	ci = i;
	while ((k < nRects*nRects) && (ci < max)) {
	    glIndexi(ci);
	    row = k / 10;
	    col = k % 10;
	    glRectf(col*deltaX, row*deltaY, (col+1)*deltaX, (row+1)*deltaY);
	    k++;
	    ci += step;
	}
	i += k * step;

	ReadScreen(0, 0, WINDSIZEX, WINDSIZEY, GL_COLOR_INDEX, buf);
	
	/*
	** Compare undithered with dithered fragments.  Results should
	** differ by no more than 1.0.
	*/

	for (j = 0; j < WINDSIZEX*WINDSIZEY; j++) {
	    if (ABS(ref[j]-buf[j]) > 1.0) {
		StrMake(errStr, errStrFmt[1], ref[j], buf[j]);
		ErrorReport(__FILE__, __LINE__, errStr);
		FREE(buf);
		FREE(ref);
		return ERROR;
	    }
	}
    }

    FREE(buf);
    FREE(ref);
    return NO_ERROR;
}

long DitherRGBExec(void)
{
    GLfloat *buf, *ref, deltaX, deltaY;
    GLfloat deltaR, deltaG, deltaB;
    long j, r, g, b, maxShades, steps, maxSteps;

    buf = (GLfloat *)MALLOC(3*WINDSIZEX*WINDSIZEY*sizeof(GLfloat));
    ref = (GLfloat *)MALLOC(3*WINDSIZEX*WINDSIZEY*sizeof(GLfloat));

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    maxShades = 1 << buffer.maxRGBBit;
    maxSteps = (machine.pathLevel == 0) ? 8 : 2;
    steps = (maxShades > maxSteps) ? maxSteps : maxShades;
    deltaR = 1.0 / steps;
    deltaG = 1.0 / steps;
    deltaB = 1.0 / steps;
    deltaX = WINDSIZEX / steps;
    deltaY = WINDSIZEY / steps;

    for (r = 0; r <= steps; r++) {
	glDisable(GL_DITHER);
	for (g = 0; g <= steps; g++) {
	    for (b = 0; b <= steps; b++) {
		glColor3f(r*deltaR, g*deltaG, b*deltaB);
		glRectf(g*deltaX, b*deltaY, (g+1)*deltaX, (b+1)*deltaY);
	    }
	}
	ReadScreen(0, 0, WINDSIZEX, WINDSIZEY, GL_RGB, ref);

	glEnable(GL_DITHER);
	for (g = 0; g <= steps; g++) {
	    for (b = 0; b <= steps; b++) {
		glColor3f(r*deltaR, g*deltaG, b*deltaB);
		glRectf(g*deltaX, b*deltaY, (g+1)*deltaX, (b+1)*deltaY);
	    }
	}
	ReadScreen(0, 0, WINDSIZEX, WINDSIZEY, GL_RGB, buf);

	for (j = 0; j < WINDSIZEX*WINDSIZEY; j += 3) {
	    if (ABS(ref[j]-buf[j]) > epsilon.color[0] ||
		ABS(ref[j+1]-buf[j+1]) > epsilon.color[1] ||
		ABS(ref[j+2]-buf[j+2]) > epsilon.color[2]) {

		StrMake(errStr, errStrFmt[0], ref[j], ref[j+1], ref[j+2],
			buf[j], buf[j+1], buf[j+2]);
		ErrorReport(__FILE__, __LINE__, errStr);
		FREE(buf);
		FREE(ref);
		return ERROR;
	    }
	}
    }

    FREE(buf);
    FREE(ref);
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\divzero.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** divzero.c
** Divide By Zero Test.
**
** Description -
**    This tests many situations where an implementation might
**    divide by zero. We try to assure, that division by zero
**    does "not lead to GL interruption or termination" as
**    specified by the OpenGL Specificaton. In two cases we test
**    that a proper error is generated. Error generation is
**    checked in the case of a viewport of zero width, and in the
**    case of evaluators with a trivial domain. (The evaluator
**    test is currently unfinished.) We currently test 24
**    different situations and there are more coming. These
**    situations are summarized in the comments at the bottom of
**    this file.
**
** Error Explanation -
**    Failure occurs if an implementation interrupts or
**    terminates during this test. Failure also occurs if a
**    parameter value which could cause a divide by zero should
**    generate an GL_INVALID_VALUE error and does not.
**
** Technical Specification -
**    Buffer requirements:
**        No buffer requirements.
**    Color requirements:
**        No color requirements.
**    States requirements:
**        No state restrictions.
**    Error epsilon:
**    Paths:
**        Allowed = Alias, Alpha, Blend, Depth, Dither, Fog, Logicop, Shade,
**                  Stencil, Stipple.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"


static GLubyte bMap[] = {
    255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255
};

static GLfloat safeColors[] = {
    1.0, 0.0, 0.0, 1.0,
    0.0, 1.0, 0.0, 1.0,
    0.0, 0.0, 1.0, 1.0,
    1.0, 1.0, 0.0, 1.0,
    1.0, 1.0, 1.0, 1.0
};

static GLfloat safeIndices[] = {
    1.0, 0.0, 0.0, 0.0,
    2.0, 0.0, 0.0, 0.0,
    3.0, 0.0, 0.0, 0.0,
    4.0, 0.0, 0.0, 0.0,
    5.0, 0.0, 0.0, 0.0
};

static GLfloat safeVertices[] = {
    10.0, 10.0, 0.0, 1.0,
    10.0, 1.0, 0.0, 1.0,
    1.0, 1.0, 0.0, 1.0,
    1.0, 10.0, 0.0, 1.0,
    5.0, 15.0, 0.0, 1.0
};

static GLfloat safeLitVertices[] = {
    10.0, 10.0, 0.5, 1.0,
    10.0, 1.0, 0.5, 1.0,
    1.0, 1.0, 0.5, 1.0,
    1.0, 10.0, 0.5, 1.0,
    5.0, 15.0, 0.5, 1.0
};

static GLfloat safeTexture[] = {
    0.0, 0.0, 0.0, 1.0,
    1.0, 0.0, 0.0, 1.0,
    1.0, 1.0, 0.0, 1.0,
    0.0, 1.0, 0.0, 1.0,
    0.5, 0.5, 0.0, 1.0
};

static GLfloat safeNormals[] = {
    1.0, 0.0, 0.0, 1.0,
    1.0, 1.0, 0.0, 1.0,
    1.0, 0.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 0.0, 1.0
};

static GLfloat singularMatrix[] = {
    1.0, 1.0, 1.0, 0.0,
    1.0, 1.0, 1.0, 0.0,
    0.0, 0.0, 1.0, 0.0,
    0.0, 0.0, 0.0, 1.0
};

static GLfloat identMatrix[] = {
    1.0, 0.0, 0.0, 0.0,
    0.0, 1.0, 0.0, 0.0,
    0.0, 0.0, 1.0, 0.0,
    0.0, 0.0, 0.0, 1.0
};

static GLfloat trivialMatrix[] = {
    0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0
};

static GLfloat trivialNormals[] = {
    0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0,
    0.0, 0.0, 0.0, 0.0
};

static float texBuf[300];


static void RenderPrims(void (*Func1)(const GLfloat *),
			void (*Func2)(const GLfloat *), GLfloat *ntic,
			GLfloat *v)
{

    glBegin(GL_POINTS);
	if (Func1) {
	    (*Func1)(&ntic[0]);
	}
	if (Func2) {
	    (*Func2)(&v[0]);
	}
	if (Func1) {
	    (*Func1)(&ntic[4]);
	}
	if (Func2) {
	    (*Func2)(&v[4]);
	}
    glEnd();

    glBegin(GL_LINES);
	if (Func1) {
	    (*Func1)(&ntic[0]);
	}
	if (Func2) {
	    (*Func2)(&v[0]);
	}
	if (Func1) {
	    (*Func1)(&ntic[4]);
	}
	if (Func2) {
	    (*Func2)(&v[4]);
	}
    glEnd();

    glBegin(GL_LINE_LOOP);
	if (Func1) {
	    (*Func1)(&ntic[0]);
	}
	if (Func2) {
	    (*Func2)(&v[0]);
	}
	if (Func1) {
	    (*Func1)(&ntic[4]);
	}
	if (Func2) {
	    (*Func2)(&v[4]);
	}
	if (Func1) {
	    (*Func1)(&ntic[8]);
	}
	if (Func2) {
	    (*Func2)(&v[8]);
	}
    glEnd();

    glBegin(GL_LINE_STRIP);
	if (Func1) {
	    (*Func1)(&ntic[0]);
	}
	if (Func2) {
	    (*Func2)(&v[0]);
	}
	if (Func1) {
	    (*Func1)(&ntic[4]);
	}
	if (Func2) {
	    (*Func2)(&v[4]);
	}
	if (Func1) {
	    (*Func1)(&ntic[8]);
	}
	if (Func2) {
	    (*Func2)(&v[8]);
	}
    glEnd();

    glBegin(GL_TRIANGLES);
	if (Func1) {
	    (*Func1)(&ntic[0]);
	}
	if (Func2) {
	    (*Func2)(&v[0]);
	}
	if (Func1) {
	    (*Func1)(&ntic[4]);
	}
	if (Func2) {
	    (*Func2)(&v[4]);
	}
	if (Func1) {
	    (*Func1)(&ntic[8]);
	}
	if (Func2) {
	    (*Func2)(&v[8]);
	}
    glEnd();

    glBegin(GL_TRIANGLE_STRIP);
	if (Func1) {
	    (*Func1)(&ntic[0]);
	}
	if (Func2) {
	    (*Func2)(&v[0]);
	}
	if (Func1) {
	    (*Func1)(&ntic[4]);
	}
	if (Func2) {
	    (*Func2)(&v[4]);
	}
	if (Func1) {
	    (*Func1)(&ntic[8]);
	}
	if (Func2) {
	    (*Func2)(&v[8]);
	}
    glEnd();

    glBegin(GL_TRIANGLE_FAN);
	if (Func1) {
	    (*Func1)(&ntic[0]);
	}
	if (Func2) {
	    (*Func2)(&v[0]);
	}
	if (Func1) {
	    (*Func1)(&ntic[4]);
	}
	if (Func2) {
	    (*Func2)(&v[4]);
	}
	if (Func1) {
	    (*Func1)(&ntic[8]);
	}
	if (Func2) {
	    (*Func2)(&v[8]);
	}
    glEnd();

    glBegin(GL_QUADS);
	if (Func1) {
	    (*Func1)(&ntic[0]);
	}
	if (Func2) {
	    (*Func2)(&v[0]);
	}
	if (Func1) {
	    (*Func1)(&ntic[4]);
	}
	if (Func2) {
	    (*Func2)(&v[4]);
	}
	if (Func1) {
	    (*Func1)(&ntic[8]);
	}
	if (Func2) {
	    (*Func2)(&v[8]);
	}
	if (Func1) {
	    (*Func1)(&ntic[12]);
	}
	if (Func2) {
	    (*Func2)(&v[12]);
	}
    glEnd();

    glBegin(GL_QUAD_STRIP);
	if (Func1) {
	    (*Func1)(&ntic[0]);
	}
	if (Func2) {
	    (*Func2)(&v[0]);
	}
	if (Func1) {
	    (*Func1)(&ntic[4]);
	}
	if (Func2) {
	    (*Func2)(&v[4]);
	}
	/*
	** Note reversal of the next two vertices
	*/
	if (Func1) {
	    (*Func1)(&ntic[12]);
	}
	if (Func2) {
	    (*Func2)(&v[12]);
	}
	if (Func1) {
	    (*Func1)(&ntic[8]);
	}
	if (Func2) {
	    (*Func2)(&v[8]);
	}
    glEnd();

    glBegin(GL_POLYGON);
	if (Func1) {
	    (*Func1)(&ntic[0]);
	}
	if (Func2) {
	    (*Func2)(&v[0]);
	}
	if (Func1) {
	    (*Func1)(&ntic[4]);
	}
	if (Func2) {
	    (*Func2)(&v[4]);
	}
	if (Func1) {
	    (*Func1)(&ntic[8]);
	}
	if (Func2) {
	    (*Func2)(&v[8]);
	}
	if (Func1) {
	    (*Func1)(&ntic[12]);
	}
	if (Func2) {
	    (*Func2)(&v[12]);
	}
	if (Func1) {
	    (*Func1)(&ntic[16]);
	}
	if (Func2) {
	    (*Func2)(&v[16]);
	}
    glEnd();

    /*
    ** Restore default values.
    */
    if (Func1 == glNormal3fv) {
	glNormal3f(0.0, 0.0, 1.0);
    } else if (Func1 == glColor4fv) {
	glColor4f(1.0, 1.0, 1.0, 1.0);
    } else if (Func1 == glIndexfv) {
	glIndexf(1.0);
    } else if (Func1 == glTexCoord4fv) {
	glTexCoord4f(0.0, 0.0, 0.0, 1.0);
    }
}

static void Render2DPrims(void (*Func1)(const GLfloat *),
			  void (*Func2)(const GLfloat *), GLfloat *ntic,
			  GLfloat *v)
{

    glBegin(GL_TRIANGLES);
	if (Func1) {
	    (*Func1)(&ntic[0]);
	}
	if (Func2) {
	    (*Func2)(&v[0]);
	}
	if (Func1) {
	    (*Func1)(&ntic[4]);
	}
	if (Func2) {
	    (*Func2)(&v[4]);
	}
	if (Func1) {
	    (*Func1)(&ntic[8]);
	}
	if (Func2) {
	    (*Func2)(&v[8]);
	}
    glEnd();

    glBegin(GL_TRIANGLE_STRIP);
	if (Func1) {
	    (*Func1)(&ntic[0]);
	}
	if (Func2) {
	    (*Func2)(&v[0]);
	}
	if (Func1) {
	    (*Func1)(&ntic[4]);
	}
	if (Func2) {
	    (*Func2)(&v[4]);
	}
	if (Func1) {
	    (*Func1)(&ntic[8]);
	}
	if (Func2) {
	    (*Func2)(&v[8]);
	}
    glEnd();

    glBegin(GL_TRIANGLE_FAN);
	if (Func1) {
	    (*Func1)(&ntic[0]);
	}
	if (Func2) {
	    (*Func2)(&v[0]);
	}
	if (Func1) {
	    (*Func1)(&ntic[4]);
	}
	if (Func2) {
	    (*Func2)(&v[4]);
	}
	if (Func1) {
	    (*Func1)(&ntic[8]);
	}
	if (Func2) {
	    (*Func2)(&v[8]);
	}
    glEnd();

    glBegin(GL_QUADS);
	if (Func1) {
	    (*Func1)(&ntic[0]);
	}
	if (Func2) {
	    (*Func2)(&v[0]);
	}
	if (Func1) {
	    (*Func1)(&ntic[4]);
	}
	if (Func2) {
	    (*Func2)(&v[4]);
	}
	if (Func1) {
	    (*Func1)(&ntic[8]);
	}
	if (Func2) {
	    (*Func2)(&v[8]);
	}
	if (Func1) {
	    (*Func1)(&ntic[12]);
	}
	if (Func2) {
	    (*Func2)(&v[12]);
	}
    glEnd();

    glBegin(GL_QUAD_STRIP);
	if (Func1) {
	    (*Func1)(&ntic[0]);
	}
	if (Func2) {
	    (*Func2)(&v[0]);
	}
	if (Func1) {
	    (*Func1)(&ntic[4]);
	}
	if (Func2) {
	    (*Func2)(&v[4]);
	}
	/*
	** Note reversal of the next two vertices
	*/
	if (Func1) {
	    (*Func1)(&ntic[12]);
	}
	if (Func2) {
	    (*Func2)(&v[12]);
	}
	if (Func1) {
	    (*Func1)(&ntic[8]);
	}
	if (Func2) {
	    (*Func2)(&v[8]);
	}
    glEnd();

    glBegin(GL_POLYGON);
	if (Func1) {
	    (*Func1)(&ntic[0]);
	}
	if (Func2) {
	    (*Func2)(&v[0]);
	}
	if (Func1) {
	    (*Func1)(&ntic[4]);
	}
	if (Func2) {
	    (*Func2)(&v[4]);
	}
	if (Func1) {
	    (*Func1)(&ntic[8]);
	}
	if (Func2) {
	    (*Func2)(&v[8]);
	}
	if (Func1) {
	    (*Func1)(&ntic[12]);
	}
	if (Func2) {
	    (*Func2)(&v[12]);
	}
	if (Func1) {
	    (*Func1)(&ntic[16]);
	}
	if (Func2) {
	    (*Func2)(&v[16]);
	}
    glEnd();

    /*
    ** Restore default values.
    */
    if (Func1 == glNormal3fv) {
	glNormal3f(0.0, 0.0, 1.0);
    } else if (Func1 == glColor4fv) {
	glColor4f(1.0, 1.0, 1.0, 1.0);
    } else if (Func1 == glIndexfv) {
	glIndexf(1.0);
    } else if (Func1 == glTexCoord4fv) {
	glTexCoord4f(0.0, 0.0, 0.0, 1.0);
    }
}

static void RenderBitmap(void (*Func)(const GLfloat *), GLfloat *ntic,
			 GLfloat *v, GLfloat *bInfo)
{

    if (Func) {
	(*Func)(&ntic[0]);
    }
    glRasterPos4fv(&v[0]);
    glBitmap((GLsizei)bInfo[0], (GLsizei)bInfo[1], bInfo[2], bInfo[3], bInfo[4],
								bInfo[5], bMap);

    /*
    ** Restore Default Values.
    */
    if (Func == glTexCoord4fv) {
	glTexCoord4f(0.0, 0.0, 0.0, 1.0);
    }
    glRasterPos4f(0.0, 0.0, 0.0, 1.0);
}

static void InitTexture(float *t, GLenum dim)
{

    switch (dim) {
      case GL_TEXTURE_2D:
	glTexImage2D(dim, 0, 3, 8, 8, 0, GL_RGB, GL_FLOAT, (unsigned char *)t);
	glTexImage2D(dim, 1, 3, 4, 4, 0, GL_RGB, GL_FLOAT, (unsigned char *)t);
	glTexImage2D(dim, 2, 3, 2, 2, 0, GL_RGB, GL_FLOAT, (unsigned char *)t);
	glTexImage2D(dim, 3, 3, 1, 1, 0, GL_RGB, GL_FLOAT, (unsigned char *)t);
	glTexImage2D(dim, 4, 3, 0, 0, 0, GL_RGB, GL_FLOAT, (unsigned char *)t);
	break;
      case GL_TEXTURE_1D:
	glTexImage1D(dim, 0, 3, 8, 0, GL_RGB, GL_FLOAT, (unsigned char *)t);
	glTexImage1D(dim, 1, 3, 4, 0, GL_RGB, GL_FLOAT, (unsigned char *)t);
	glTexImage1D(dim, 2, 3, 2, 0, GL_RGB, GL_FLOAT, (unsigned char *)t);
	glTexImage1D(dim, 3, 3, 1, 0, GL_RGB, GL_FLOAT, (unsigned char *)t);
	glTexImage1D(dim, 4, 3, 0, 0, GL_RGB, GL_FLOAT, (unsigned char *)t);
	break;
    }
}

static void ResetTextureToDefault(GLenum dim)
{
    float t;

    t = 0.0;
    switch (dim) {
      case GL_TEXTURE_2D:
	glTexImage2D(dim, 0, 3, 0, 0, 0, GL_RGB, GL_FLOAT, (unsigned char *)&t);
	break;
      case GL_TEXTURE_1D:
	glTexImage1D(dim, 0, 3, 0, 0, GL_RGB, GL_FLOAT, (unsigned char *)&t);
	break;
    }
}

static void ExerciseNormals(GLfloat *n, GLfloat *v)
{

    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);
    RenderPrims(glNormal3fv, glVertex4fv, n, v);

    /*
    ** Restore default values.
    */
    glDisable(GL_LIGHTING);
    glDisable(GL_LIGHT0);

    if (buffer.colorMode == GL_RGB) {
	InitTexture(texBuf, GL_TEXTURE_2D);
	glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_SPHERE_MAP);
	glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_SPHERE_MAP);
	glEnable(GL_TEXTURE_GEN_S);
	glEnable(GL_TEXTURE_GEN_T);
	glEnable(GL_TEXTURE_2D);

	/*
	** Default TexEnv should be modulate. Default color should be white.
	*/

	RenderPrims(glNormal3fv, glVertex4fv, n, v);

	/*
	** Restore default values.
	*/
	glTexGeni(GL_S, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR);
	glTexGeni(GL_T, GL_TEXTURE_GEN_MODE, GL_EYE_LINEAR);
	glDisable(GL_TEXTURE_GEN_S);
	glDisable(GL_TEXTURE_GEN_T);
	glDisable(GL_TEXTURE_2D);
	ResetTextureToDefault(GL_TEXTURE_2D);
    }
}

static void SetMatrix(GLenum mode, GLfloat *m)
{
    GLint save;

    glGetIntegerv(GL_MATRIX_MODE, &save);
    glMatrixMode(mode);
    glLoadMatrixf(m);
    glMatrixMode((GLenum)save);
}

/*
** This is not actually used but it makes debugging easier.
*/
void Blank(void)
{
     glClearColor(0.0, 0.0, 0.0, 1.0);
     glClear(GL_COLOR_BUFFER_BIT);
}

/*
** This just calls glBegin()/glEnd() with nothing in between.
*/
static long PrimNoVertex(void)
{

    RenderPrims(NULL, NULL, NULL, NULL);
    glBitmap(0, 0, 0, 0, 0, 0, bMap);

    return NO_ERROR;
}

static long PrimWEqualsZero(void)
{
    static GLfloat v[] = {
	10.0, 10.0, 0.0, 0.0,
	10.0, 1.0, 0.0, 1.0,
	1.0, 1.0, 0.0, 1.0,
	1.0, 10.0, 0.0, 1.0,
	5.0, 15.0, 0.0, 1.0
    };
    static GLfloat pos1[] = {
	3.0, 3.0, -1.0, 0.0
    };
    static GLfloat pos2[] = {
	1.0, 1.0, 0.0, 0.0
    };

    /*
    ** To test this routine, use safeVertices and call Blank() between draws.
    */

    RenderPrims(NULL, glVertex4fv, NULL, v);
    glRectfv(pos1, pos2);

    glBitmap(1, 1, 0, 0, 0, 0, bMap);

    /*
    ** The homogeneous coordinate is used as a divisor to form one
    ** component of the eye-normal.
    */
    ExerciseNormals(safeNormals, v);

    /*
    ** It is very likely that a singular modelview matrix
    ** will demand that a different computational path be used
    ** to deal with normals, so we test the interaction of a singular
    ** modelview matrix with a zero homogeneous coordinate.
    */
    SetMatrix(GL_MODELVIEW, singularMatrix);

    /*
    ** Previous call to ExerciseNormals() tests this (with correct v[0][3]).
    */
    ExerciseNormals(safeNormals, v);

    /*
    ** Reset default values.
    */
    SetMatrix(GL_MODELVIEW, identMatrix);

    return NO_ERROR;
}

/*
** This checks that none of the primitives has any difficulty if it is
** rendered as a point. It checks if the 2D primitives can render as a line.
*/
static long TrivialPrims(void)
{
    static GLfloat pos[] = {
	1.0, 1.0, 0.0, 1.0
    };
    static GLfloat v1[] = {
	10.0, 10.0, 0.0, 1.0,
	10.0, 10.0, 0.0, 1.0,
	10.0, 10.0, 0.0, 1.0,
	10.0, 10.0, 0.0, 1.0,
	10.0, 10.0, 0.0, 1.0
    };
    static GLfloat v2[] = {
	1.0, 1.0, 0.0, 1.0,
	1.0, 1.0, 0.0, 1.0,
	1.0, 3.0, 0.0, 1.0,
	1.0, 3.0, 0.0, 1.0,
	3.0, 3.0, 0.0, 1.0
    };

    /*
    ** Test this with safeVertices instead of v1.
    */
    RenderPrims(NULL, glVertex4fv, NULL, v1);
    glRectfv(pos, pos);
    glRasterPos4f(1.0, 1.0, 0.0, 1.0);
    glBitmap(0, 0, 1, 1, 1, 1, bMap);

    /*
    ** Trivial 2d objects still could have two vertices.
    */
    Render2DPrims(NULL, glVertex4fv, NULL, v2);
    glRectfv(pos, pos);
    glRasterPos4f(1.0, 1.0, 0.0, 1.0);
    glBitmap(1, 1, 0, 0, 0, 0, bMap);

    glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
    Render2DPrims(NULL, glVertex4fv, NULL, v2);
    glRectfv(pos, pos);

    glPolygonMode(GL_FRONT_AND_BACK, GL_POINT);
    Render2DPrims(NULL, glVertex4fv, NULL, v2);
    glRectfv(pos, pos);

    /*
    ** Restore default values.
    */
    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
    glRasterPos4f(0.0, 0.0, 0.0, 1.0);

    return NO_ERROR;
}

/*
** With the texture coordinate's q set equal to zero, the texture
** coordinate interpolation could divide by zero.
*/
static long TexQOrWEqualsZero(void)
{
    static GLfloat bInfo[] = {
	0, 0, 1, 1, 1, 1
    };
    static GLfloat texCoord[] = {
	0.0, 0.0, 0.0, 0.0,
	1.0, 0.0, 0.0, 0.0,
	1.0, 1.0, 0.0, 0.0,
	0.0, 1.0, 0.0, 0.0,
	0.5, 0.5, 0.0, 0.0
    };
    static GLfloat v[] = {
	10.0, 10.0, 0.0, 0.0,
	10.0, 1.0, 0.0, 0.0,
	1.0, 1.0, 0.0, 0.0,
	1.0, 10.0, 0.0, 0.0,
	5.0, 15.0, 0.0, 0.0
    };

    /*
    ** To test this, use change texCoord to have 1.0 for q coordinate
    ** and v to have 1.0 in w coordinate. Call Blank().
    */
    InitTexture(texBuf, GL_TEXTURE_2D);
    glEnable(GL_TEXTURE_2D);

    RenderPrims(glTexCoord4fv, glVertex4fv, texCoord, safeVertices);

    /*
    ** Check textured Bitmap.
    */
    RenderBitmap(glTexCoord4fv, texCoord, safeVertices, bInfo);

    RenderPrims(glTexCoord4fv, glVertex4fv, safeTexture, v);
    RenderBitmap(glTexCoord4fv, texCoord, v, bInfo);

    /*
    ** Restore default values.
    */
    ResetTextureToDefault(GL_TEXTURE_2D);
    glDisable(GL_TEXTURE_2D);

    InitTexture(texBuf, GL_TEXTURE_1D);
    glEnable(GL_TEXTURE_1D);
    RenderPrims(glTexCoord4fv, glVertex4fv, texCoord, safeVertices);
    RenderBitmap(glTexCoord4fv, texCoord, safeVertices, bInfo);

    RenderPrims(glTexCoord4fv, glVertex4fv, (GLfloat *)safeTexture, 
								(GLfloat *)v);
    RenderBitmap(glTexCoord4fv, texCoord, v, bInfo);

    /*
    ** Restore default values.
    */

    glDisable(GL_TEXTURE_1D);
    ResetTextureToDefault(GL_TEXTURE_1D);

    return NO_ERROR;
}

/*
** A primitive with equal vertices would theoretically divide by its length
** when interpolating the texture coordinates.
*/
static long TexTrivialPrim(void)
{
    static GLfloat bInfo[] = {
	0, 0, 1, 1, 1, 1
    };
    static GLfloat v[] = {
	10.0, 10.0, 0.0, 1.0,
	10.0, 10.0, 0.0, 1.0,
	10.0, 10.0, 0.0, 1.0,
	10.0, 10.0, 0.0, 1.0,
	10.0, 10.0, 0.0, 1.0
    };

    /*
    ** Test this using safeVertices.
    */
    InitTexture(texBuf, GL_TEXTURE_2D);
    glEnable(GL_TEXTURE_2D);
    RenderPrims(glTexCoord4fv, glVertex4fv, safeTexture, v);
    RenderBitmap(glTexCoord4fv, safeTexture, v, bInfo);

    /*
    ** Restore default values.
    */
    glDisable(GL_TEXTURE_2D);
    ResetTextureToDefault(GL_TEXTURE_2D);

    InitTexture(texBuf, GL_TEXTURE_1D);
    glEnable(GL_TEXTURE_1D);
    RenderPrims(glTexCoord4fv, glVertex4fv, safeTexture, v);
    RenderBitmap(glTexCoord4fv, safeTexture, v, bInfo);

    /*
    ** Restore default values.
    */
    glDisable(GL_TEXTURE_1D);
    ResetTextureToDefault(GL_TEXTURE_1D);

    return NO_ERROR;
}

/*
** If the primitive becomes trivial after clipping it may divide by zero.
*/
static long ClipToTrivialPrim(void)
{

    /*
    ** XXX
    ** Include a singular modelview matrix here for double Whammy.
    */
    return NO_ERROR;
}

/*
** A primitive with equal vertices would theoretically divide by zero length
** when interpolating the shade.
*/
static long ShadedTrivialPrim(void)
{
    static GLfloat v[] = {
	10.0, 10.0, 0.0, 1.0,
	10.0, 10.0, 0.0, 1.0,
	10.0, 10.0, 0.0, 1.0,
	10.0, 10.0, 0.0, 1.0,
	10.0, 10.0, 0.0, 1.0
    };

    /*
    ** To test this use safeVertices.
    */

    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
    if (buffer.colorMode == GL_RGB) {
	RenderPrims(glColor4fv, glVertex4fv, safeColors, v);
    } else {
	RenderPrims(glIndexfv, glVertex4fv, safeIndices, v);
    }

    glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
    if (buffer.colorMode == GL_RGB) {
	Render2DPrims(glColor4fv, glVertex4fv, safeColors, v);
    } else {
	Render2DPrims(glIndexfv, glVertex4fv, safeIndices, v);
    }

    glPolygonMode(GL_FRONT_AND_BACK, GL_POINT);
    if (buffer.colorMode == GL_RGB) {
	Render2DPrims(glColor4fv, glVertex4fv, safeColors, v);
    } else {
	Render2DPrims(glIndexfv, glVertex4fv, safeIndices, v);
    }

    /*
    ** Restore default values.
    */
    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);

    return NO_ERROR;
}

/*
** A primitive with equal vertices would theoretically divide by zero length
** when interpolating the depth.
*/
static long ZTrivialPrim(void)
{
    static GLfloat v[] = {
	10.0, 10.0, 0.0, 1.0,
	10.0, 10.0, 0.0, 1.0,
	10.0, 10.0, 0.0, 1.0,
	10.0, 10.0, 0.0, 1.0,
	10.0, 10.0, 0.0, 1.0
    };

    /*
    ** To test this, use safeVertices.
    */

    glClearDepth(0.0);
    glClear(GL_DEPTH_BUFFER_BIT);
    glEnable(GL_DEPTH_TEST);
    RenderPrims(NULL, glVertex4fv, NULL, v);
    glRectfv(&v[0], &v[0]);
    glRasterPos4f(1.0, 1.0, 0.0, 1.0);
    glBitmap(1, 1, 1, 1, 10, 10, bMap);

    /*
    ** Restore default values.
    */
    glRasterPos4f(0.0, 0.0, 0.0, 1.0);
    glDisable(GL_DEPTH_TEST);
    glClearDepth(1.0);

    return NO_ERROR;
}

static long ZFarEqualsZNear(void)
{
    float maxZ;

    /*
    ** To test this, remove glDepthRange(0.0, 0.0).
    */
    glDepthRange(0.0, 0.0);

    glClearDepth(1.0);
    glClear(GL_DEPTH_BUFFER_BIT);
    glEnable(GL_DEPTH_TEST);
    RenderPrims(NULL, glVertex4fv, NULL, safeVertices);

    glRectfv(&safeVertices[0], &safeVertices[8]);
    glRasterPos4f(1.0, 1.0, 0.0, 1.0);
    glBitmap(1, 1, 1, 1, 10, 10, bMap);

    maxZ = (float)((1 << buffer.zBits) - 1);
    glDepthRange(0.0, maxZ);
    glDisable(GL_DEPTH_TEST);

    return NO_ERROR;
}

/*
** A linear fog function with end equal to start might divide by (end - start).
*/
static long FogEndEqualsFogStart(void)
{
    static GLfloat defaultFogColor[] = {
	0.0, 0.0, 0.0, 0.0
    };
    static float end = 0.0, linear = GL_LINEAR;

    /*
    ** Test by not calling glFog(GL_FOG_END, end);
    */
    glFogf(GL_FOG_MODE, linear);
    glFogf(GL_FOG_END, end);

    /*
    ** Default start is 0.0.
    */

    if (buffer.colorMode == GL_RGB) {
	glFogfv(GL_FOG_COLOR, &safeColors[16]);
	glEnable(GL_FOG);
	RenderPrims(glColor4fv, glVertex4fv, safeColors, safeVertices);
    } else {
	float index = (1 << buffer.ciBits) - 1;

	glFogf(GL_FOG_INDEX, index);
	glEnable(GL_FOG);
	RenderPrims(glIndexfv, glVertex4fv, safeColors, safeVertices);
    }

    /*
    ** Restore default values.
    */
    glFogf(GL_FOG_MODE, GL_EXP);
    glFogf(GL_FOG_END, 1.0);
    if (buffer.colorMode == GL_RGB) {
	glFogfv(GL_FOG_COLOR, defaultFogColor);
    } else {
	glFogf(GL_FOG_INDEX, 0.0);
    }
    glDisable(GL_FOG);
    return NO_ERROR;
}

static long ViewPortIsTrivial(void)
{

    glViewport(0, 0, 0, 0);
    RenderPrims(NULL, glVertex4fv, NULL, safeVertices);

    /*
    ** Restore default values.
    */
    glViewport(0, 0, WINDSIZEX, WINDSIZEY);

    return NO_ERROR;
}

static long SingularModelViewMatrix(void)
{

    /*
    ** To test this, take out the following call.
    */
    SetMatrix(GL_MODELVIEW, singularMatrix);
    RenderPrims(NULL, glVertex4fv, NULL, safeVertices);

    ExerciseNormals(safeNormals, safeVertices);

    /*
    ** XXX
    ** This also should exercise eye linear TexGen and user defined clipping.
    */

    SetMatrix(GL_MODELVIEW, identMatrix);
    return NO_ERROR;
}

static long SingularScaleMatrix(void)
{
    static GLfloat badScale[] = {
	1.0, 0.0, 1.0
    };
    GLint mode;

    glGetIntegerv(GL_MATRIX_MODE, &mode);
    glMatrixMode(GL_MODELVIEW);

    /*
    ** To test, leave out the following line.
    */
    glScalef(badScale[0], badScale[1], badScale[2]);
    glMatrixMode(mode);

    RenderPrims(NULL, glVertex4fv, NULL, safeVertices);
    ExerciseNormals(safeNormals, safeVertices);

    /*
    ** XXX
    ** Also should exercise eye linear TexGen and user defined clipping.
    */

    SetMatrix(GL_MODELVIEW, identMatrix);
    return NO_ERROR;
}

static long SingularTextureMatrix(void)
{

    SetMatrix(GL_TEXTURE, singularMatrix);
    glEnable(GL_TEXTURE_2D);
    InitTexture(texBuf, GL_TEXTURE_2D);
    RenderPrims(glTexCoord4fv, glVertex4fv, safeTexture, safeVertices);

    /*
    ** Restore default values.
    */
    ResetTextureToDefault(GL_TEXTURE_2D);
    glDisable(GL_TEXTURE_2D);
    SetMatrix(GL_TEXTURE, identMatrix);
    return NO_ERROR;
}

static long SingularFrustum(void)
{
    GLfloat saveMatrix[16];
    GLint mode;

    glGetIntegerv(GL_MATRIX_MODE, &mode);
    glGetFloatv(GL_PROJECTION_MATRIX, (GLfloat *)saveMatrix);
    glMatrixMode(GL_PROJECTION);

    /*
    ** Remove the following line to test this code.
    */
    /*
    ** XXX
    ** This call generates an GL_INVALID_VALUE error, awaiting spec
    ** clarification.
    */
    glFrustum(1.0, 1.0, 0.0, 1.0, 1.0, 2.0);

    RenderPrims(NULL, glVertex4fv, NULL, safeVertices);
  
    /*
    ** Remove the following line to test this code.
    */
    glFrustum(0.0, 1.0, 0.0, 1.0, 0.0, 1.0);
    RenderPrims(NULL, glVertex4fv, NULL, safeVertices);

    glLoadMatrixf(saveMatrix);
    glMatrixMode(mode);
    return NO_ERROR;
}

static long TrivialNormal(void)
{

    glEnable(GL_NORMALIZE);

    /*
    ** Test this with the default normal (0.0, 0.0, 0.0, 1.0),
    ** or use the following line.
    ** ExerciseNormals(safeNormals, safeVertices);
    */

    ExerciseNormals(safeNormals, safeVertices);
    glDisable(GL_NORMALIZE);
    ExerciseNormals(safeNormals, safeVertices);
    /*
    ** Disable(GL_NORMALIZE) is the default.
    */
    return NO_ERROR;
}

static long ScissorNothing(void)
{

    /*
    ** To test this, remove the following line.
    */
    glScissor(WINDSIZEX/2, WINDSIZEY/2, 0, 0);
    glEnable(GL_SCISSOR_TEST);
    RenderPrims(NULL, glVertex4fv, NULL, safeVertices);

    glRasterPos4f(1.0, 1.0, 0.0, 1.0);

    glBitmap(1, 1, 1, 1, 10, 10, bMap);

    /*
    ** Reset default scissor.
    */
    glDisable(GL_SCISSOR_TEST);
    glScissor(0, 0, WINDSIZEX, WINDSIZEY);
    return NO_ERROR;
}

/*
** All three Attenuation Constants are set to zero.
*/
static long AttenuationConstants(void)
{
    GLfloat tmp[4];

    glLightf(GL_LIGHT0, GL_CONSTANT_ATTENUATION, 0.0);

    /*
    ** The following are default values.
    */
    glLightf(GL_LIGHT0, GL_LINEAR_ATTENUATION, 0.0);
    glLightf(GL_LIGHT0, GL_QUADRATIC_ATTENUATION, 0.0);
    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);

    if (buffer.colorMode == GL_RGB) {
	tmp[0] = 1.0;
	tmp[1] = 1.0;
	tmp[2] = 1.0;
	tmp[3] = 1.0;
	glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, tmp);
	glLightfv(GL_LIGHT0, GL_AMBIENT, tmp);

	/*
	**  To verify test, include this. It should render a white pentagon.
	**  glLightf(GL_LIGHT0, GL_CONSTANT_ATTENUATION, 1.0);
	**  glClearColor(0.0, 0.0, 0.0, 1.0);
	**  glClear(GL_COLOR_BUFFER_BIT);
	*/

	RenderPrims(NULL, glVertex4fv, NULL, safeVertices);

	/*
	** Restore default ambient values.
	*/
	tmp[0] = 0.2;
	tmp[1] = 0.2;
	tmp[2] = 0.2;
	tmp[3] = 1.0;
	glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, tmp);

	tmp[0] = 0.0;
	tmp[1] = 0.0;
	tmp[2] = 0.0;
	glLightfv(GL_LIGHT0, GL_AMBIENT, tmp);

	/*
	** Second test uses default normal and diffuse.
	*/

	tmp[0] = 1.0;
	tmp[1] = 1.0;
	tmp[2] = 1.0;
	glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, tmp);

	glClearColor(0.0, 0.0, 0.0, 1.0);
	glClear(GL_COLOR_BUFFER_BIT);
	glColor4f(0.0, 0.0, 0.0, 1.0);
	RenderPrims(NULL, glVertex4fv, NULL, safeLitVertices);

	/*
	** Restore default diffuse parameters.
	*/
	tmp[0] = 0.8;
	tmp[1] = 0.8;
	tmp[2] = 0.8;
	glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, tmp);
    } else {
	tmp[0] = 0.0;
	tmp[1] = 1.0;
	tmp[2] = 1.0;
	glMaterialfv(GL_FRONT_AND_BACK, GL_COLOR_INDEXES, tmp);
	glClearColor(0.0, 0.0, 0.0, 1.0);
	glClear(GL_COLOR_BUFFER_BIT);
	glColor4f(0.0, 0.0, 0.0, 1.0);
	RenderPrims(NULL, glVertex4fv, NULL, safeLitVertices);

	/*
	** Restore default diffuse parameters.
	*/

	tmp[0] = 0.0;
	tmp[1] = 1.0;
	tmp[2] = 1.0;
	glMaterialfv(GL_FRONT_AND_BACK, GL_COLOR_INDEXES, tmp);
    }

    /*
    ** Restore default values.
    */
    glColor4f(1.0, 1.0, 1.0, 1.0);
    glLightf(GL_LIGHT0, GL_CONSTANT_ATTENUATION, 1.0);
    glDisable(GL_LIGHTING);
    glDisable(GL_LIGHT0);
    return NO_ERROR;
}

/*
** Normalization of light position may bust this.
*/
static long LightPositionEqualsZero(void)
{

    return NO_ERROR;
}

/*
** Normalization of spot direction may bust this.
*/
static long SpotDirectionEqualsZero(void)
{

    return NO_ERROR;
}

/*
** Normalization of the half angle code may bust this.
*/
static long HalfAngleEqualsZero(void)
{

    return NO_ERROR;
}

/*
** XXX
** The vertex is at the eye position, division by zero occurs when
** normalizing for use in half angle computation.
*/
static long LightVertexIsAtEye(void)
{

    return NO_ERROR;
}

/*
** If a glMap1f(target, 0, 0, stride, order) is called there
** could be a divide by zero. Similarly if glMapGrid() is called with
** 0 grid points there could be a divide by zero.
**
** XXX
** All target types should be tried.
** Also there should be a check to verify that GL_INVALID_VALUE is returned
** as is the case with TrivialViewport().
** Code can be stolen from teval():
*/
static long EvalGridIsTrivial(void)
{

    return NO_ERROR;
}

long DivZeroExec(void)
{
    long i, clearError;

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    for (i = 0; i < 300; i++) {
	texBuf[i] = 1.0;
    }

    /*
    ** Does any interruption occur if a glBegin, glEnd occurs without a vertex
    ** call in between.
    */
    PrimNoVertex();
    clearError = glGetError();

    /*
    ** Does any interruption occur if a primitive is rendered with a vertex
    ** whose fourth coordinate is 0.0.
    */
    PrimWEqualsZero();
    clearError = glGetError();

    /*
    ** Does any interruption occur if any primitive type is rendered flat, with
    ** two coinciding vertices.
    */
    TrivialPrims();
    clearError = glGetError();

    /*
    ** Does any interruption occur if any primitive type is rendered smooth, 
    **  with two coinciding vertices.
    */
    ShadedTrivialPrim();
    clearError = glGetError();

    /*
    ** Does any interruption occur if any primitive type is rendered with 
    ** two coinciding vertices, and with depth test is enabled.
    */
    ZTrivialPrim();
    clearError = glGetError();

    /*
    ** Does any interruption occur if any primitive type is rendered with 
    ** the depth range set so that near = far.
    */
    ZFarEqualsZNear();
    clearError = glGetError();

    /*
    ** Does any interruption occur if any primitive type is rendered with 
    ** the linear fog parameters set so that fog_end = fog_start.
    */
    FogEndEqualsFogStart();
    clearError = glGetError();
  
    /*
    ** Does any interruption occur if any primitive type is rendered with 
    ** the viewport set to zero width or zero height.
    */
    ViewPortIsTrivial();
    clearError = glGetError();

    /*
    ** Does any interruption occur if any textured primitive is rendered with
    ** a singular modelview matrix.
    */
    SingularModelViewMatrix();
    clearError = glGetError();

    /*
    ** Does any interruption occur if any textured primitive is rendered with
    ** a singular modelview matrix, set by glScale.
    */
    SingularScaleMatrix();
    clearError = glGetError();

    /*
    ** Does any interruption occur if any textured primitive is rendered with
    ** a singular texture matrix.
    */
    SingularTextureMatrix();
    clearError = glGetError();

    /*
    ** Does any interruption occur if any primitive is rendered with
    ** the singular perspective matrix set by glFrustum.
    */
    SingularFrustum();
    clearError = glGetError();

    /*
    ** Does any interruption occur if any primitive is rendered with
    ** scissor defining a window of 0 width or 0 height.
    */
    ScissorNothing();
    clearError = glGetError();

    /*
    ** Does any interruption occur if any primitive is rendered lit or 
    ** spheremapped with a normal vector = (0.0,0.0,0.0):
    */
    TrivialNormal();
    clearError = glGetError();

    /*
    ** Does any interruption occur if any primitive is rendered lit with
    ** attenuationa constants = (0.0,0.0,0.0);
    */

    AttenuationConstants();
    clearError = glGetError();

    /*
    ** Does any interruption occur if any primitive is rendered lit at 
    ** with a light position vector = (0.0,0.0,0.0,1.0);
    */
    LightPositionEqualsZero();
    clearError = glGetError();

    /*
    ** Does any interruption occur if any primitive is rendered lit with a 
    ** spot Direction vector which can't be normalized because it is zero
    ** length.
    */
    SpotDirectionEqualsZero();
    clearError = glGetError();

    /*
    ** Does any interruption occur if any primitive is rendered lit at 
    ** eye-coordinates = (0.0,0.0,0.0,1.0);
    */
    LightVertexIsAtEye();
    clearError = glGetError();

    /*
    ** Does any interruption occur if any primitive is rendered lit with a 
    ** half angle vector which has zero length. (can't be normalized)
    */
    HalfAngleEqualsZero();
    clearError = glGetError();

    /*
    ** Does any interruption occur if an object is rendered using a
    ** map with no width or no height in its domain.
    */
    EvalGridIsTrivial();
    clearError = glGetError();

    if (buffer.colorMode == GL_RGB) {
	/*
	** Does any interruption occur if any primitive type is rendered 
	** textured with a vertex whose 4th coordinate is 0.0;
	*/
	TexQOrWEqualsZero();
	clearError = glGetError();

	/*
	** Does any interruption occur if any primitive type is rendered 
	** textured with two coinciding vertices.
	*/
	TexTrivialPrim();
	clearError = glGetError();
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\blend.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** blend.c
** Blend Test.
**
** Description -
**    Two random colors are picked. They are verified to exist in
**    the color buffer by drawing points with these colors then
**    reading back the rendered colors. With blending disabled, a
**    point is now drawn at a random location using one of the
**    colors (destination color). Blending is then enabled and
**    another point is drawn to the same location using the other
**    color (source color). The resulting blended color is read
**    and compared to a correct result calculated by the test.
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer.
**    Color requirements:
**        RGBA mode. Full color.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**        Color and zero epsilons.
**    Paths:
**        Allowed = Alpha, Depth, Fog, Logicop, Shade, Stencil, Stipple.
**        Not allowed = Alias, Blend, Dither.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"


static char errStr[320];
static char errStrFmt[][240] = {
    "Source blend op is %s, destination blend op is %s. Could not get a valid source color.",
    "Source blend op is %s, destination blend op is %s. Could not get a valid destination color.",
    "Source blend op is %s, destination blend op is %s. Source color is (%g, %g, %g, %g). Destination color is (%g, %g, %g, %g). Result is (%g, %g, %g, %g), should be (%g, %g, %g, %g)."
};


static long GetColor(GLfloat *result)
{
    GLfloat buf[4];
    long i;

    for (i = 0; i < 4; i++) {
	buf[i] = Random(0.0, 1.0);
    }

    glBegin(GL_POINTS);
	glColor4fv(buf);
	glVertex2f(0.5, 0.5);
    glEnd();

    ReadScreen(0, 0, 1, 1, GL_RGBA, result);

    if (ABS(result[0]-buf[0]) > epsilon.color[0]) {
	return ERROR;
    }
    if (ABS(result[1]-buf[1]) > epsilon.color[1]) {
	return ERROR;
    }
    if (ABS(result[2]-buf[2]) > epsilon.color[2]) {
	return ERROR;
    }
    if (ABS(result[3]-buf[3]) > epsilon.color[3]) {
	if (buffer.colorBits[3] == 0) {
	    if (ABS(result[3]-1.0) > epsilon.zero) {
		return ERROR;
	    }
	} else {
	    return ERROR;
	}
    }
    return NO_ERROR;
}

static GLenum SrcOp(long index)
{

    switch (index) {
      case 0:
	return GL_ZERO;
      case 1:
	return GL_ONE;
      case 2:
	return GL_DST_COLOR;
      case 3:
	return GL_ONE_MINUS_DST_COLOR;
      case 4:
	return GL_SRC_ALPHA;
      case 5:
	return GL_ONE_MINUS_SRC_ALPHA;
      case 6:
	return GL_DST_ALPHA;
      case 7:
	return GL_ONE_MINUS_DST_ALPHA;
      case 8:
	return GL_SRC_ALPHA_SATURATE;
    }
    return -1;
}

static GLenum DestOp(long index)
{

    switch (index) {
      case 0:
	return GL_ZERO;
      case 1:
	return GL_ONE;
      case 2:
	return GL_SRC_COLOR;
      case 3:
	return GL_ONE_MINUS_SRC_COLOR;
      case 4:
	return GL_SRC_ALPHA;
      case 5:
	return GL_ONE_MINUS_SRC_ALPHA;
      case 6:
	return GL_DST_ALPHA;
      case 7:
	return GL_ONE_MINUS_DST_ALPHA;
    }
    return -1;
}

/*
** These errors account for moderate non-conformant optimizations likely to be
** used in Alpha Blending. These optimizations yield small errors if the
** color channels and the alpha channels have approximately the same
** depth. They will not work if the red channel has many bits and the alpha
** channel has only a couple. In this case the optimizations are likely 
** to cause errors so large that ISV's would be surprised by the behavior.
** In this case the implementor should avoid these optimizations.
*/

static GLfloat GetAlphaOpError(GLenum srcOp, GLenum destOp)
{
    long multCount; 

    multCount = 0;

    switch (srcOp) {
      case GL_ZERO: case GL_ONE:
	break;
      case GL_DST_COLOR: case GL_ONE_MINUS_DST_COLOR:
      case GL_SRC_ALPHA: case GL_ONE_MINUS_SRC_ALPHA:
      case GL_DST_ALPHA: case GL_ONE_MINUS_DST_ALPHA:
      case GL_SRC_ALPHA_SATURATE:
	multCount++;
	break;
    }

    switch (destOp) {
      case GL_ZERO: case GL_ONE:
	break;
      case GL_SRC_COLOR: case GL_ONE_MINUS_SRC_COLOR:
      case GL_SRC_ALPHA: case GL_ONE_MINUS_SRC_ALPHA:
      case GL_DST_ALPHA: case GL_ONE_MINUS_DST_ALPHA:
	multCount++;
	break;
    }

    switch (multCount) {
      case 0:
	return 0.0;
      case 1:
	return 0.05;
      case 2:
	return 0.15;
    }
    return 0.15;
}

static void TrueResult(GLenum srcOp, GLenum destOp, GLfloat *src, GLfloat *dest,
		       GLfloat *result)
{
    GLfloat srcResult[4], destResult[4];
    long i;

    if (buffer.colorBits[3] == 0) {
	dest[3] = 1.0;
    }

    switch (srcOp) {
      case GL_ZERO:
	for (i = 0; i < 4; i++) {
	    srcResult[i] = 0.0;
	}
	break;
      case GL_ONE:
	for (i = 0; i < 4; i++) {
	    srcResult[i] = 1.0;
	}
	break;
      case GL_DST_COLOR:
	for (i = 0; i < 4; i++) {
	    srcResult[i] = dest[i];
	}
	break;
      case GL_ONE_MINUS_DST_COLOR:
	for (i = 0; i < 4; i++) {
	    srcResult[i] = 1.0 - dest[i];
	}
	break;
      case GL_SRC_ALPHA:
	for (i = 0; i < 4; i++) {
	    srcResult[i] = src[3];
	}
	break;
      case GL_ONE_MINUS_SRC_ALPHA:
	for (i = 0; i < 4; i++) {
	    srcResult[i] = 1.0 - src[3];
	}
	break;
      case GL_DST_ALPHA:
	for (i = 0; i < 4; i++) {
	    srcResult[i] = dest[3];
	}
	break;
      case GL_ONE_MINUS_DST_ALPHA:
	for (i = 0; i < 4; i++) {
	    srcResult[i] = 1.0 - dest[3];
	}
	break;
      case GL_SRC_ALPHA_SATURATE:
	for (i = 0; i < 3; i++) {
	    srcResult[i] = (src[3] <= 1.0-dest[3]) ? src[3] : (1.0 - dest[3]);
	}
	srcResult[3] = 1.0;
	break;
    }

    switch (destOp) {
      case GL_ZERO:
	for (i = 0; i < 4; i++) {
	    destResult[i] = 0.0;
	}
	break;
      case GL_ONE:
	for (i = 0; i < 4; i++) {
	    destResult[i] = 1.0;
	}
	break;
      case GL_SRC_COLOR:
	for (i = 0; i < 4; i++) {
	    destResult[i] = src[i];
	}
	break;
      case GL_ONE_MINUS_SRC_COLOR:
	for (i = 0; i < 4; i++) {
	    destResult[i] = 1.0 - src[i];
	}
	break;
      case GL_SRC_ALPHA:
	for (i = 0; i < 4; i++) {
	    destResult[i] = src[3];
	}
	break;
      case GL_ONE_MINUS_SRC_ALPHA:
	for (i = 0; i < 4; i++) {
	    destResult[i] = 1.0 - src[3];
	}
	break;
      case GL_DST_ALPHA:
	for (i = 0; i < 4; i++) {
	    destResult[i] = dest[3];
	}
	break;
      case GL_ONE_MINUS_DST_ALPHA:
	for (i = 0; i < 4; i++) {
	    destResult[i] = 1.0 - dest[3];
	}
	break;
    }

    for (i = 0; i < 4; i++) {
	result[i] = (srcResult[i] * src[i]) + (destResult[i] * dest[i]);
    }
    for (i = 0; i < 4; i++) {
	if (result[i] < 0.0) {
	    result[i] = 0.0;
	}
	if (result[i] > 1.0) {
	    result[i] = 1.0;
	}
    }
}

static long Test(GLfloat *buf, GLfloat *result, GLfloat opError)
{

    if (ABS(buf[0]-result[0]) > opError+epsilon.color[0]) {
	return ERROR;
    }
    if (ABS(buf[1]-result[1]) > opError+epsilon.color[1]) {
	return ERROR;
    }
    if (ABS(buf[2]-result[2]) > opError+epsilon.color[2]) {
	return ERROR;
    }
    if (ABS(buf[3]-result[3]) > opError+epsilon.color[3]) {
	if (buffer.colorBits[3] == 0) {
	    if (ABS(buf[3]-1.0) > epsilon.zero) {
		return ERROR;
	    }
	} else {
	    return ERROR;
	}
    }
    return NO_ERROR;
}

long BlendExec(void)
{
    char tmp1[40], tmp2[40];
    GLfloat srcColor[4], destColor[4], buf[4], result[4], opError;
    GLint x, y, i, j;

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    glDisable(GL_DITHER);

    for (i = 0; i < 9; i++) {
	for (j = 0; j < 8; j++) {
	    GetEnumName(SrcOp(i), tmp1);
	    GetEnumName(DestOp(j), tmp2);

	    glDisable(GL_BLEND);

	    if (GetColor(srcColor) == ERROR) {
		StrMake(errStr, errStrFmt[0], tmp1, tmp2);
		ErrorReport(__FILE__, __LINE__, errStr);
		return ERROR;
	    }

	    if (GetColor(destColor) == ERROR) {
		StrMake(errStr, errStrFmt[1], tmp1, tmp2);
		ErrorReport(__FILE__, __LINE__, errStr);
		return ERROR;
	    }

	    TrueResult(SrcOp(i), DestOp(j), srcColor, destColor, result);

	    x = (GLint)Random(0.0, WINDSIZEX-1.0);
	    y = (GLint)Random(0.0, WINDSIZEY-1.0);

	    if (buffer.colorBits[3] == 0) {
		destColor[3] = 1.0;
		glBegin(GL_POINTS);
		    glColor4fv(result);
		    glVertex2f((GLfloat)x+0.5, (GLfloat)y+0.5);
		glEnd();
		ReadScreen(x, y, 1, 1, GL_RGBA, result);
	    }

	    glBegin(GL_POINTS);
		glColor4fv(destColor);
		glVertex2f((GLfloat)x+0.5, (GLfloat)y+0.5);
	    glEnd();

	    glEnable(GL_BLEND);
	    glBlendFunc(SrcOp(i), DestOp(j));

	    glBegin(GL_POINTS);
		glColor4fv(srcColor);
		glVertex2f((GLfloat)x+0.5, (GLfloat)y+0.5);
	    glEnd();

	    ReadScreen(x, y, 1, 1, GL_RGBA, buf);

	    opError = GetAlphaOpError(SrcOp(i), DestOp(j));
            if (Test(buf, result, opError) == ERROR) {
		StrMake(errStr, errStrFmt[2], tmp1, tmp2, srcColor[0],
			srcColor[1], srcColor[2], srcColor[3], destColor[0],
			destColor[1], destColor[2], destColor[3], buf[0],
			buf[1], buf[2], buf[3], result[0], result[1],
			result[2], result[3]);
		ErrorReport(__FILE__, __LINE__, errStr);
		return ERROR;
	    }
	}
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\copypix.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** copypix.c
** CopyPixels Test.
**
** Description -
**    This test examines glCopyPixels() results for the three
**    allowable pixel types: color, stencil and depth. In each
**    case, it draws a reference image in the middle of the
**    window, reads and saves this image, then uses
**    glCopyPixels() to redraw the image offset in each of four
**    directions (towards the corners, but overlapping the
**    original image). It then compares the copied image with the
**    original reference image. For depth and stencil types, the
**    image is created so that only half of the image drawn by
**    glCopyPixels() should be visible.
**    
**    For type GL_COLOR, the test draws two rectangles, one
**    inside the other. To get visible results for GL_STENCIL, we
**    draw to the stencil buffer with ones to the lower half of
**    the area, zeros to the top half. A rectangle drawn over
**    this area with stenciling enabled should then have only its
**    lower half visible. After copying the stencil values to
**    the new location, a rectangle is again drawn at the new
**    location.
**    
**    Similarly, for type GL_DEPTH, we draw to the depth buffer
**    with max values in the lower half and zeros in the upper
**    half. The depth function is set so that a rectangle drawn
**    over this area will be visible only in the lower half.
**    There is one extra step, redrawing the reference area depth
**    values before copying them, since they were altered by
**    drawing the rectangle over them.
**    
**    The GL_DEPTH and/or GL_STENCIL sections are skipped if the
**    corresponding buffer does not exist.
**
** Error Explanation -
**    Since we are comparing the results of drawing to the same
**    buffer twice using the same color, we expect the values to
**    be the same, within the floating point tolerance
**    (epsilon.zero).
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer, stencil plane, depth buffer.
**    Color requirements:
**        RGBA or color index mode. 4 colors.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**    Paths:
**        Allowed = Alpha, Blend, Depth, Fog, Logicop, Shade, Stencil, Stipple.
**        Not allowed = Alias, Dither.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"


#define W 40
#define H 40
#define FREE_AND_RETURN(err) {			\
    glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);	\
    FREE(refBuf); 				\
    FREE(buf);					\
    FREE(drawBuf);				\
    return(err);				\
}


static char errStr[160];
static char errStrFmt[] = "Copypix type is %s, copying to location (%1.1f, %1.1f)";


static long CompareBuf(GLfloat *refBuf, GLfloat *buf, long w, long h)
{
    long flag, i;

    flag = ERROR;
    for (i = 0; i < w*h*3; i++) {
	if (refBuf[i] > epsilon.zero) {
	    flag = NO_ERROR;
	    break;
	}
    }

    if (flag == ERROR) {
	return ERROR;
    }

    for (i = 0; i < w*h*3; i++) {
	if (ABS(refBuf[i]-buf[i]) > epsilon.zero) {
	    return ERROR;
	}
    }
    return NO_ERROR;
}

static void SetUpData(GLubyte *drawBuf, long type)
{
    long i;

    switch (type) {
      case GL_COLOR:
	break;
      case GL_STENCIL:
	for (i = 0; i < W*H; i++) {
	    drawBuf[i] = (i < W*H/2) ? 1 : 0;
	}
	break;
      case GL_DEPTH:
	for (i = 0; i < W*H; i++) {
	    drawBuf[i] = (i < W*H/2) ? 0xFF : 0;
	}
	break;
    }
}

static void DrawReference(GLubyte *drawBuf, GLenum type)
{
    GLfloat outerX, outerY;

    outerX = (float)(WINDSIZEX - W) / 2.0;
    outerY = (float)(WINDSIZEY - H) / 2.0;

    switch (type) {
      case GL_COLOR:
	SETCOLOR(RED);
	glRectf(outerX, outerY, outerX+W, outerY+H);
	SETCOLOR(GREEN);
	glRectf(outerX+5.0, outerY+5.0, outerX+W-5.0, outerY+H-5.0);
	break;
      case GL_STENCIL:
	glEnable(GL_STENCIL_TEST);
	glStencilFunc(GL_LESS, 0, ~0);

	glDrawPixels(W, H, GL_STENCIL_INDEX, GL_UNSIGNED_BYTE, drawBuf);
	SETCOLOR(BLUE);
	glRectf(outerX, outerY, outerX+W, outerY+H);

	glDisable(GL_STENCIL_TEST);
	break;
      case GL_DEPTH:
	glEnable(GL_DEPTH_TEST);
	glClear(GL_DEPTH_BUFFER_BIT);
	glDepthFunc(GL_ALWAYS);
	glDrawPixels(W, H, GL_DEPTH_COMPONENT, GL_UNSIGNED_BYTE, drawBuf);

	SETCOLOR(RED);
	glDepthFunc(GL_LESS);
	glRectf(outerX, outerY, outerX+W, outerY+H);

	/*
	** Redraw depth pixels for copy, since they were altered by Rect.
	*/
	if (buffer.colorMode == GL_RGB) {
	    glColorMask(GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE);
	} else {
	    glIndexMask(0);
	}
	glDepthFunc(GL_ALWAYS);
	glDrawPixels(W, H, GL_DEPTH_COMPONENT, GL_UNSIGNED_BYTE, drawBuf);
	if (buffer.colorMode == GL_RGB) {
	    glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
	} else {
	    glIndexMask(~0);
	}
	break;
    }
}

static void DrawCopy(long type, float x, float y)
{

    switch (type) {
      case GL_COLOR:
	break;
      case GL_STENCIL:
	glClear(GL_COLOR_BUFFER_BIT);
	glEnable(GL_STENCIL_TEST);
	SETCOLOR(BLUE);
	glRectf(x, y, x+W, y+H);
	glDisable(GL_STENCIL_TEST);
	break;
      case GL_DEPTH:
	glClear(GL_COLOR_BUFFER_BIT);
	glDepthFunc(GL_LESS);
	SETCOLOR(RED);
	glRectf(x, y, x+W, y+H);
	glDisable(GL_DEPTH_TEST);
	break;
    }
}

long CopyPixelsExec(void)
{
    static GLenum types[] = {
	GL_COLOR, GL_STENCIL, GL_DEPTH
    };
    static float rDir[4][2] = {
	0.5, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.0
    };
    GLfloat *refBuf, *buf;
    long type, pos;
    unsigned size;
    GLubyte *drawBuf;
    GLint refX, refY;
    GLfloat x, y;
    char typeStr[40];

    size = W * H;
    refX = (WINDSIZEX - W) / 2;
    refY = (WINDSIZEY - H) / 2;

    refBuf = (GLfloat *)MALLOC(size*4*sizeof(GLfloat));
    drawBuf = (GLubyte *)MALLOC(size*sizeof(GLubyte ));
    buf = (GLfloat *)MALLOC(size*4*sizeof(GLfloat));

    glOrtho(0, WINDSIZEX, 0, WINDSIZEY, -1.0, 1.0);

    SETCLEARCOLOR(BLACK);
    glClearStencil(0);
    glClearDepth(1.0);
    glDisable(GL_DITHER);

    glPixelStorei(GL_UNPACK_ROW_LENGTH, W);

    for (type = 0; type < 3; type++) {

	/*
	** If given buffers don't exist, skip this part of the test.
	*/
	if ((types[type] == GL_STENCIL && buffer.stencilBits == 0) ||
	    (types[type] == GL_DEPTH && buffer.zBits == 0)) {
	    continue;
	}
        SetUpData(drawBuf, types[type]);

   	for (pos = 0; pos < 4; pos++) {
	    glClear(GL_COLOR_BUFFER_BIT);
	    x = rDir[pos][0] * WINDSIZEX;
	    y = rDir[pos][1] * WINDSIZEY;

	    /*
	    ** Draw reference rectangle.
	    */
	    SETCOLOR(BLACK);
	    glRasterPos2i(refX, refY);
	    DrawReference(drawBuf, types[type]);
	    ReadScreen(refX, refY, W, H, GL_RGB, refBuf);

	    /*
	    ** Draw copy of rectangle.
	    */
	    glRasterPos2f(x, y);
	    glCopyPixels(refX, refY, W, H, types[type]);
	    DrawCopy(types[type], x, y);
	    ReadScreen((GLint)x, (GLint)y, W, H, GL_RGB, buf);

	    if (CompareBuf(refBuf, buf, W, H) == ERROR) {
		GetEnumName(types[type], typeStr);
		StrMake(errStr, errStrFmt, typeStr, x, y);
		ErrorReport(__FILE__, __LINE__, errStr);
		FREE_AND_RETURN(ERROR);
	    }
	}
    }
    FREE_AND_RETURN(NO_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\drawpix.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** drawpix.c
** DrawPixels Test.
**
** Description -
**    Draws a rectangle in the lower left hand corner of the
**    window using glDrawPixels() for every pixel format and type
**    allowed. If the pixel format is one which draws to a color
**    buffer, then a solid rectangle appears. For alpha, stencil
**    and depth formats, values are set so that when a rectangle
**    is drawn, only half of the rectangle should pass the
**    {alpha, stencil, depth} test.
**    
**    Rectangles are drawn with fully saturated colors. The
**    outcome of each glDrawPixels() is checked by examining one
**    pixel in the interior of the upper half of the rectangle,
**    and one in the lower half. The results should either be
**    the color set in the initial data or the background color,
**    for the non-passing sections of rectangles in alpha,
**    stencil and depth tests.
**    
**    The test is structured as follows:
**        For each data type:
**            For each pixel format:
**                SetupData() - create raw image data.
**                ConvertCompData() - convert image data.
**                glDrawPixels().
**                TestPixRGB() or TestPixCI().
**        For bitmap type:
**            For formats GL_COLOR_INDEX and GL_STENCIL_INDEX:
**                {repeat above procedure}
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer, alpha plane, stencil plane, depth buffer.
**    Color requirements:
**        RGBA or color index mode. Full color.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**    Paths:
**        Allowed = Alpha, Blend, Depth, Fog, Logicop, Shade, Stencil, Stipple.
**        Not allowed = Alias, Dither.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"


#define W 40
#define H 40
#define FREE_AND_RETURN(err) {			    \
    glPixelStorei(GL_UNPACK_ALIGNMENT, 4);	    \
    glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);	    \
    glPixelMapfv(GL_PIXEL_MAP_I_TO_R, 1, resetMap); \
    glPixelMapfv(GL_PIXEL_MAP_I_TO_G, 1, resetMap); \
    glPixelMapfv(GL_PIXEL_MAP_I_TO_B, 1, resetMap); \
    glPixelMapfv(GL_PIXEL_MAP_I_TO_A, 1, resetMap); \
    FREE(dataBuf);			   	    \
    FREE(convertBuf);				    \
    FREE(buf);					    \
    return(err);				    \
}
#define MAKE_ERROR_STRING(t, f) {			\
    GetEnumName(t, typeStr);				\
    GetEnumName(f, formatStr);				\
    StrMake(errStr, errStrFmt, typeStr, formatStr);	\
}


static GLfloat pixMap[] = {
    0.0, 0.3, 0.6, 1.0
};
static GLfloat resetMap[] = {
    0.0
};
static char errStr[160];
static char errStrFmt[] = "DrawPixels type is %s, format is %s.";

static long TestPixRGB(GLfloat *buf, float r, float g, float b, long split)
{
    float midX, lowY, hiY;
    long i;

    /*
    ** Test one pixel in the center of the lower half of the region drawn.
    ** Split indicates that the other half should remain black (for alpha,
    ** depth tests, etc).
    */

    lowY = 0.25 * H;
    hiY = 0.75 * H;
    midX = 0.5 * W;

    ReadScreen(0, 0, W, H, GL_RGB, buf);

    i = (W * lowY + midX) * 3;
    if (!(ABS(buf[i]-r) < epsilon.color[0] &&
	  ABS(buf[i+1]-g) < epsilon.color[1] &&
          ABS(buf[i+2]-b) < epsilon.color[2])) {
        return ERROR;
    }
    if (split == GL_TRUE) {
	i = (W * hiY + midX) * 3;
	if (!(buf[i] < epsilon.color[0] &&
	      buf[i+1] < epsilon.color[1] &&
              buf[i+2] < epsilon.color[2])) {
            return ERROR;
        }
    }
    return NO_ERROR;
}

static long TestPixCI(GLfloat *buf, long index, long split)
{
    float midX, lowY, hiY;
    long i;

    /*
    ** Test one pixel in the center of the lower half of the region drawn.
    ** Split indicates that the other half should remain black (for alpha,
    ** depth tests, etc).
    */

    lowY = 0.25 * H;
    hiY = 0.75 * H;
    midX = 0.5 * W;

    ReadScreen(0, 0, W, H, GL_COLOR_INDEX, buf);

    i = W * lowY + midX;
    if (!(ABS(buf[i]-index) < epsilon.ci)) {
        return ERROR;
    }
    if (split == GL_TRUE) {
	i = W * hiY + midX;
	if (!(ABS(buf[i]) < epsilon.ci)) {
            return ERROR;
        }
    }
    return NO_ERROR;
}

static void SetupData(GLfloat *fPtr, long format)
{
    float max;
    long size, i;

    size = W * H;
    switch (format) {
      case GL_COLOR_INDEX:
	for (i = 0; i < size; i++) {
	     *fPtr++ = 2.0;
	}
	break;
      case GL_STENCIL_INDEX:
        max = POW(2, (float)buffer.stencilBits) - 1.0;
        for (i = 0; i < size; i++) {
             *fPtr++ = (i < size/2) ? max : 0.0;
        }
	break;
      case GL_DEPTH_COMPONENT:
      case GL_ALPHA:
	for (i = 0; i < size; i++) {
	     *fPtr++ = (i < size/2) ? 1.0 : 0.0;
	}
	break;
      case GL_RED:
      case GL_GREEN:
      case GL_BLUE:
      case GL_LUMINANCE:
	for (i = 0; i < size; i++) {
	     *fPtr++ = 1.0;
	}
	break;
      case GL_RGB:
	for (i = 0; i < size; i++) {
	     *fPtr++ = 0.9;
	     *fPtr++ = 0.1;
	     *fPtr++ = 0.5;
	}
	break;
      case GL_RGBA:
	for (i = 0; i < size; i++) {
	     *fPtr++ = 0.9;
	     *fPtr++ = 0.1;
	     *fPtr++ = 0.5;
	     *fPtr++ = (i < size/2) ? 1.0 : 0.0;
	}
	break;
      case GL_LUMINANCE_ALPHA:
	for (i = 0; i < size; i++) {
	     *fPtr++ = 1.0; 
	     *fPtr++ = (i < size/2) ? 1.0 : 0.0; 
	}
	break;
    }
}

static void ConvertCompData(GLfloat *inPtr, GLubyte *outPtr, long type,
			    long count)
{
    GLubyte *ucPtr;
    GLbyte *cPtr;
    GLushort *usPtr;
    GLshort *sPtr;
    GLuint *uiPtr;
    GLint *iPtr;
    GLfloat *fPtr;
    long i;
    double factor;
 
    switch (type) {
      case GL_UNSIGNED_BYTE:
	ucPtr = (GLubyte *)outPtr;
	for (i = 0; i < count; i++) {
	    *ucPtr++ = (GLubyte)(*inPtr++ * 255.0);
	}
	break;
      case GL_BYTE:
	cPtr = (GLbyte *)outPtr;
	for (i = 0; i < count; i++) {
	    *cPtr++ = (GLbyte)(*inPtr++ * 127.0);
	}
	break;
      case GL_UNSIGNED_SHORT:
	usPtr = (GLushort *)outPtr;
	for (i = 0; i < count; i++) {
	    *usPtr++ = (GLushort)(*inPtr++ * 65535.0);
	}
	break;
      case GL_SHORT:
	sPtr = (GLshort *)outPtr;
	for (i = 0; i < count; i++) {
	    *sPtr++ = (GLshort)(*inPtr++ * 32767.0);
	}
	break;
      case GL_UNSIGNED_INT:
	uiPtr = (GLuint *)outPtr;
	factor = (double)POW(2, 32) - 1;
	for (i = 0; i < count; i++) {
	    *uiPtr++ = (GLuint)(*inPtr++ * factor);
	}
	break;
      case GL_INT:
	iPtr = (GLint *)outPtr;
	factor = (double)POW(2, 31) - 1;
	for (i = 0; i < count; i++) {
	    *iPtr++ = (GLint)(*inPtr++ * factor);
	}
	break;
      case GL_FLOAT:
	fPtr = (GLfloat *)outPtr;
	for (i = 0; i < count; i++) {
	    *fPtr++ = *inPtr++;
	}
	break;
    }
}

static void ConvertIndexData(GLfloat *inPtr, GLubyte *outPtr, long type,
			     long count)
{
    GLubyte *ucPtr;
    GLbyte *cPtr;
    GLushort *usPtr;
    GLshort *sPtr;
    GLuint *uiPtr;
    GLint *iPtr;
    GLfloat *fPtr;
    long i;
 
    switch (type) {
      case GL_UNSIGNED_BYTE:
	ucPtr = (GLubyte *)outPtr;
	for (i = 0; i < count; i++) {
	    *ucPtr++ = (GLubyte)*inPtr++;
	}
	break;
      case GL_BYTE:
	cPtr = (GLbyte *)outPtr;
	for (i = 0; i < count; i++) {
	    *cPtr++ = (GLbyte)*inPtr++;
	}
	break;
      case GL_UNSIGNED_SHORT:
	usPtr = (GLushort *)outPtr;
	for (i = 0; i < count; i++) {
	    *usPtr++ = (GLushort)*inPtr++;
	}
	break;
      case GL_SHORT:
	sPtr = (GLshort *)outPtr;
	for (i = 0; i < count; i++) {
	    *sPtr++ = (GLshort)*inPtr++;
	}
	break;
      case GL_UNSIGNED_INT:
	uiPtr = (GLuint *)outPtr;
	for (i = 0; i < count; i++) {
	    *uiPtr++ = (GLuint)*inPtr++;
	}
	break;
      case GL_INT:
	iPtr = (GLint *)outPtr;
	for (i = 0; i < count; i++) {
	    *iPtr++ = (GLint)*inPtr++;
	}
	break;
      case GL_FLOAT:
	fPtr = (GLfloat *)outPtr;
	for (i = 0; i < count; i++) {
	    *fPtr++ = (GLfloat)*inPtr++;
	}
	break;
    }
}

static void ConvertToF(GLubyte *inPtr, GLfloat *outPtr, long type)
{
    GLubyte *ucPtr;
    GLbyte *cPtr;
    GLushort *usPtr;
    GLshort *sPtr;
    GLuint *uiPtr;
    GLint *iPtr;
    GLfloat *fPtr;
    long i;
    double factor;

    for (i = 0; i < 3; i++) {
	switch (type) {
	  case GL_UNSIGNED_BYTE:
	    ucPtr = (GLubyte *)inPtr;
	    outPtr[i] = (GLfloat)(ucPtr[i] / 255.0);
	    break;
	  case GL_BYTE:
	    cPtr = (GLbyte *)inPtr;
	    outPtr[i] = (GLfloat)((2.0 * cPtr[i] + 1) / 255.0);
	    break;
	  case GL_UNSIGNED_SHORT:
	    usPtr = (GLushort *)inPtr;
	    outPtr[i] = (GLfloat)(usPtr[i] / 65535.0);
	    break;
	  case GL_SHORT:
	    sPtr = (GLshort *)inPtr;
	    outPtr[i] = (GLfloat)((2.0 * sPtr[i] + 1) / 65535.0);
	    break;
	  case GL_UNSIGNED_INT:
	    uiPtr = (GLuint *)inPtr;
	    factor = (double)POW(2, 32) - 1;
	    outPtr[i] = (GLfloat)(uiPtr[i] / factor);
	    break;
	  case GL_INT:
	    iPtr = (GLint *)inPtr;
	    factor = (double)POW(2, 32) - 1;
	    outPtr[i] = (GLfloat)((2.0 * iPtr[i] + 1) / factor);
	    break;
	  case GL_FLOAT:
	    fPtr = (GLfloat *)inPtr;
	    outPtr[i] = (GLfloat)fPtr[i];
	    break;
	}
    }
}

long DrawPixelsRGBExec(void)
{
    static GLenum types[] = {
	GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT,
	GL_UNSIGNED_INT, GL_INT, GL_FLOAT
    };
    GLfloat *dataBuf, *buf;
    GLubyte *convertBuf;
    GLfloat color[3], polyWidth;
    long type, i;
    unsigned size;
    char typeStr[40], formatStr[40];

    size = W * H;
    dataBuf = (GLfloat *)MALLOC(size*4*sizeof(GLfloat));
    convertBuf = (GLubyte *)MALLOC(size*4*sizeof(GLfloat));
    buf = (GLfloat *)MALLOC(size*4*sizeof(GLfloat));

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glColor3f(0.0, 0.0, 0.0);
    glDisable(GL_DITHER);

    glRasterPos2f(-1.0, -1.0);

    polyWidth = W * 2.0 / WINDSIZEX;
    glPixelStorei(GL_UNPACK_ROW_LENGTH, W);
    glPixelMapfv(GL_PIXEL_MAP_I_TO_R, 4, pixMap);
    glPixelMapfv(GL_PIXEL_MAP_I_TO_G, 4, pixMap);
    glPixelMapfv(GL_PIXEL_MAP_I_TO_B, 4, pixMap);
    glPixelMapfv(GL_PIXEL_MAP_I_TO_A, 4, pixMap);

    for (type = 0; type < 7; type++) {
	/*
	** Test single component formats.
	*/

	SetupData(dataBuf, GL_RED);
	ConvertCompData(dataBuf, convertBuf, types[type], W*H);

	glClear(GL_COLOR_BUFFER_BIT);
	glDrawPixels(W, H, GL_RED, types[type], convertBuf);
	if (TestPixRGB(buf, 1.0, 0.0, 0.0, GL_FALSE) == ERROR) {
	    MAKE_ERROR_STRING(types[type], GL_RED);
	    ErrorReport(__FILE__, __LINE__, errStr);
	    FREE_AND_RETURN(ERROR);
	}

	glClear(GL_COLOR_BUFFER_BIT);
	glDrawPixels(W, H, GL_GREEN, types[type], convertBuf);
	if (TestPixRGB(buf, 0.0, 1.0, 0.0, GL_FALSE) == ERROR) {
	    MAKE_ERROR_STRING(types[type], GL_GREEN);
	    ErrorReport(__FILE__, __LINE__, errStr);
	    FREE_AND_RETURN(ERROR);
	}

	glClear(GL_COLOR_BUFFER_BIT);
	glDrawPixels(W, H, GL_BLUE, types[type], convertBuf);
	if (TestPixRGB(buf, 0.0, 0.0, 1.0, GL_FALSE) == ERROR) {
	    MAKE_ERROR_STRING(types[type], GL_BLUE);
	    ErrorReport(__FILE__, __LINE__, errStr);
	    FREE_AND_RETURN(ERROR);
	}

	glClear(GL_COLOR_BUFFER_BIT);
	glDrawPixels(W, H, GL_LUMINANCE, types[type], convertBuf);
	if (TestPixRGB(buf, 1.0, 1.0, 1.0, GL_FALSE) == ERROR) {
	    MAKE_ERROR_STRING(types[type], GL_LUMINANCE);
	    ErrorReport(__FILE__, __LINE__, errStr);
	    FREE_AND_RETURN(ERROR);
	}

	/*
	** Test RGB.
	*/

	SetupData(dataBuf, GL_RGB);
	ConvertCompData(dataBuf, convertBuf, types[type], W*H*3);
	ConvertToF(convertBuf, color, types[type]);
	glClear(GL_COLOR_BUFFER_BIT);
	glDrawPixels(W, H, GL_RGB, types[type], convertBuf);
	if (TestPixRGB(buf, color[0], color[1], color[2], GL_FALSE) == ERROR) {
	    MAKE_ERROR_STRING(types[type], GL_RGB);
	    ErrorReport(__FILE__, __LINE__, errStr);
	    FREE_AND_RETURN(ERROR);
	}

	/*
	** Test Alpha.
	** R, G, B are set to black, so draw background polygon for contrast.
	*/

	glClearColor(0.0, 1.0, 0.0, 0.0);
	glEnable(GL_ALPHA_TEST);
	glAlphaFunc(GL_LESS, 0.5);

	SetupData(dataBuf, GL_ALPHA);
	ConvertCompData(dataBuf, convertBuf, types[type], W*H);
	glClear(GL_COLOR_BUFFER_BIT);
	glDrawPixels(W, H, GL_ALPHA, types[type], convertBuf);
	if (TestPixRGB(buf, 0.0, 1.0, 0.0, GL_TRUE) == ERROR) {
	    MAKE_ERROR_STRING(types[type], GL_ALPHA);
	    ErrorReport(__FILE__, __LINE__, errStr);
	    FREE_AND_RETURN(ERROR);
	}

	glDisable(GL_ALPHA_TEST);
	glClearColor(0.0, 0.0, 0.0, 0.0);

	/*
	** Test RGBA.
	*/

	glEnable(GL_ALPHA_TEST);
	glAlphaFunc(GL_GREATER, 0.5);

	SetupData(dataBuf, GL_RGBA);
	ConvertCompData(dataBuf, convertBuf, types[type], W*H*4);
	ConvertToF(convertBuf, color, types[type]);
	glClear(GL_COLOR_BUFFER_BIT);
	glDrawPixels(W, H, GL_RGBA, types[type], convertBuf);
	if (TestPixRGB(buf, color[0], color[1], color[2], GL_TRUE) == ERROR) {
	    MAKE_ERROR_STRING(types[type], GL_RGBA);
	    ErrorReport(__FILE__, __LINE__, errStr);
	    FREE_AND_RETURN(ERROR);
	}
	glDisable(GL_ALPHA_TEST);

	/*
	** Test Luminance_ALPHA.
	*/

	glEnable(GL_ALPHA_TEST);
	glAlphaFunc(GL_GREATER, 0.5);

	SetupData(dataBuf, GL_LUMINANCE_ALPHA);
	ConvertCompData(dataBuf, convertBuf, types[type], 2*W*H);
	glClear(GL_COLOR_BUFFER_BIT);
	glDrawPixels(W, H, GL_LUMINANCE_ALPHA, types[type], convertBuf);
	if (TestPixRGB(buf, 1.0, 1.0, 1.0, GL_TRUE) == ERROR) {
	    MAKE_ERROR_STRING(types[type], GL_LUMINANCE_ALPHA);
	    ErrorReport(__FILE__, __LINE__, errStr);
	    FREE_AND_RETURN(ERROR);
	}
	glDisable(GL_ALPHA_TEST);

	/*
	** Test Color Index format.
	*/

	SetupData(dataBuf, GL_COLOR_INDEX);
	ConvertIndexData(dataBuf, convertBuf, types[type], W*H);
	glClear(GL_COLOR_BUFFER_BIT);
	glDrawPixels(W, H, GL_COLOR_INDEX, types[type], convertBuf);
	if (TestPixRGB(buf, pixMap[2], pixMap[2], pixMap[2],
		       GL_FALSE) == ERROR) {
	    MAKE_ERROR_STRING(types[type], GL_COLOR_INDEX);
	    ErrorReport(__FILE__, __LINE__, errStr);
	    FREE_AND_RETURN(ERROR);
	}

	/*
	** Test Depth.
	*/

        if (buffer.zBits > 0) {
	    glEnable(GL_DEPTH_TEST);
	    glClearDepth(1.0);
	    glDepthFunc(GL_LESS);

	    SetupData(dataBuf, GL_DEPTH_COMPONENT);
	    ConvertCompData(dataBuf, convertBuf, types[type], W*H);
	    glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
	    glDrawPixels(W, H, GL_DEPTH_COMPONENT, types[type], convertBuf);
	    glColor3f(1.0, 0.0, 0.0);
	    glRectf(-1.0, -1.0+polyWidth, -1.0+polyWidth, -1.0);
	    if (TestPixRGB(buf, 1.0, 0.0, 0.0, GL_TRUE) == ERROR) {
		MAKE_ERROR_STRING(types[type], GL_DEPTH_COMPONENT);
		ErrorReport(__FILE__, __LINE__, errStr);
		FREE_AND_RETURN(ERROR);
	    }
            glDisable(GL_DEPTH_TEST);

        }

        /*
        ** Test Stencil.
        */

        if (buffer.stencilBits > 0) {
            glEnable(GL_STENCIL_TEST);
            glClearStencil(0);
            glStencilFunc(GL_LESS, 1, ~0);
            glStencilOp(GL_ZERO, GL_KEEP, GL_KEEP);

            SetupData(dataBuf, GL_STENCIL_INDEX);
            ConvertIndexData(dataBuf, convertBuf, types[type], W*H);
            glClear(GL_COLOR_BUFFER_BIT|GL_STENCIL_BUFFER_BIT);
            glDrawPixels(W, H, GL_STENCIL_INDEX, types[type], convertBuf);
            glColor3f(0.0, 0.0, 1.0);
            glRectf(-1.0, -1.0+polyWidth, -1.0+polyWidth, -1.0);
            if (TestPixRGB(buf, 0.0, 0.0, 1.0, GL_TRUE) == ERROR) {
                MAKE_ERROR_STRING(types[type], GL_STENCIL_INDEX);
                ErrorReport(__FILE__, __LINE__, errStr);
                FREE_AND_RETURN(ERROR);
            }
            glDisable(GL_STENCIL_TEST);
        }
    }

    /*
    ** Test Bitmap type.
    ** Only allowable formats are COLOR_INDEX and STENCIL_INDEX.
    */

    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
    if (buffer.stencilBits > 0) {
	glEnable(GL_STENCIL_TEST);
	glClearStencil(0);
	glStencilFunc(GL_LESS, 0, ~0);
	glStencilOp(GL_ZERO, GL_KEEP, GL_KEEP);

	for (i = 0; i < size/16; i++) {
	     convertBuf[i] = 0xFF;
	}
	for (; i < size/8; i++) {
	     convertBuf[i] = 0x0;
	}
	glClear(GL_COLOR_BUFFER_BIT|GL_STENCIL_BUFFER_BIT);
	glDrawPixels(W, H, GL_STENCIL_INDEX, GL_BITMAP, convertBuf);
	glColor3f(0.0, 0.0, 1.0);
	glRectf(-1.0, -1.0+polyWidth, -1.0+polyWidth, -1.0);
	if (TestPixRGB(buf, 0.0, 0.0, 1.0, GL_TRUE) == ERROR) {
	    MAKE_ERROR_STRING(GL_BITMAP, GL_STENCIL_INDEX);
	    ErrorReport(__FILE__, __LINE__, errStr);
	    FREE_AND_RETURN(ERROR);
	}
	glDisable(GL_STENCIL_TEST);
    }

    for (i = 0; i < size/8; i++) {
	 convertBuf[i] = 0xFF;
    }
    glClear(GL_COLOR_BUFFER_BIT);
    glDrawPixels(W, H, GL_COLOR_INDEX, GL_BITMAP, convertBuf);
    if (TestPixRGB(buf, pixMap[1], pixMap[1], pixMap[1], GL_FALSE) == ERROR) {
	MAKE_ERROR_STRING(types[type], GL_COLOR_INDEX);
	ErrorReport(__FILE__, __LINE__, errStr);
	FREE_AND_RETURN(ERROR);
    }

    glPixelStorei(GL_UNPACK_ALIGNMENT, 4);
    FREE_AND_RETURN(NO_ERROR);
}

long DrawPixelsCIExec(void)
{
    static GLenum types[] = {
	GL_UNSIGNED_BYTE, GL_BYTE, GL_UNSIGNED_SHORT, GL_SHORT,
	GL_UNSIGNED_INT, GL_INT, GL_FLOAT
    };
    GLfloat *dataBuf, *buf;
    GLubyte *convertBuf;
    float color[3], polyWidth;
    long type, i; 
    GLint index;
    unsigned size;
    char typeStr[40], formatStr[40];

    size = W * H;
    dataBuf = (GLfloat *)MALLOC(size*4*sizeof(GLfloat));
    convertBuf = (GLubyte *)MALLOC(size*4*sizeof(GLfloat));
    buf = (GLfloat *)MALLOC(size*4*sizeof(GLfloat));
    glPixelStorei(GL_UNPACK_ROW_LENGTH, W);

    glDisable(GL_DITHER);
    glClearIndex(0.0);
    polyWidth = W * 2.0 / WINDSIZEX;

    glIndexi(0);
    glRasterPos2f(-1.0, -1.0);

    for (type = 0; type < 7; type++) {
	/*
	** Test Color Index format.
	*/

	SetupData(dataBuf, GL_COLOR_INDEX);
	ConvertIndexData(dataBuf, convertBuf, types[type], W*H);
	glClear(GL_COLOR_BUFFER_BIT);
	glDrawPixels(W, H, GL_COLOR_INDEX, types[type], convertBuf);
	ConvertIndexData(dataBuf, (GLubyte *)&index, GL_INT, 1);
	if (TestPixCI(buf, index, GL_FALSE) == ERROR) {
	    MAKE_ERROR_STRING(types[type], GL_COLOR_INDEX);
	    ErrorReport(__FILE__, __LINE__, errStr);
	    FREE_AND_RETURN(ERROR);
	}

	/*
	** Test Depth.
	*/

        if (buffer.zBits > 0) {
	    glEnable(GL_DEPTH_TEST);
	    glClearDepth(1.0);
	    glDepthFunc(GL_LESS);

	    SetupData(dataBuf, GL_DEPTH_COMPONENT);
	    ConvertCompData(dataBuf, convertBuf, types[type], W*H);
	    glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
	    glDrawPixels(W, H, GL_DEPTH_COMPONENT, types[type], convertBuf);
	    glIndexi(RED);
	    glRectf(-1.0, -1.0+polyWidth, -1.0+polyWidth, -1.0);
	    if (TestPixCI(buf, RED, GL_TRUE) == ERROR) {
		MAKE_ERROR_STRING(types[type], GL_DEPTH_COMPONENT);
		ErrorReport(__FILE__, __LINE__, errStr);
		FREE_AND_RETURN(ERROR);
	    }
            glDisable(GL_DEPTH_TEST);
        }

        /*
        ** Test Stencil.
        */

        if (buffer.stencilBits > 0) {
            glEnable(GL_STENCIL_TEST);
            glClearStencil(0);
            glStencilFunc(GL_LESS, 1, ~0);
            glStencilOp(GL_ZERO, GL_KEEP, GL_KEEP);

            SetupData(dataBuf, GL_STENCIL_INDEX);
            ConvertIndexData(dataBuf, convertBuf, types[type], W*H);
            glClear(GL_COLOR_BUFFER_BIT|GL_STENCIL_BUFFER_BIT);
            glDrawPixels(W, H, GL_STENCIL_INDEX, types[type], convertBuf);

            glIndexi(BLUE);
            glRectf(-1.0, -1.0+polyWidth, -1.0+polyWidth, -1.0);
            if (TestPixCI(buf, BLUE, GL_TRUE) == ERROR) {
                MAKE_ERROR_STRING(types[type], GL_STENCIL_INDEX);
                ErrorReport(__FILE__, __LINE__, errStr);
                FREE_AND_RETURN(ERROR);
            }
            glDisable(GL_STENCIL_TEST);
        }
    }

    /*
    ** Test Bitmap type.
    ** Only allowable formats are COLOR_INDEX and STENCIL_INDEX.
    */

    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
    if (buffer.stencilBits > 0) {
	glEnable(GL_STENCIL_TEST);
	glClearStencil(0);
	glStencilFunc(GL_LESS, 0, ~0);
	glStencilOp(GL_ZERO, GL_KEEP, GL_KEEP);

	for (i = 0; i < size/16; i++) {
	     convertBuf[i] = 0xFF;
	}
	for (; i < size/8; i++) {
	     convertBuf[i] = 0x0;
	}
	glClear(GL_COLOR_BUFFER_BIT|GL_STENCIL_BUFFER_BIT);
	glDrawPixels(W, H, GL_STENCIL_INDEX, GL_BITMAP, convertBuf);
	glIndexi(RED);
	glRectf(-1.0, -1.0+polyWidth, -1.0+polyWidth, -1.0);
	if (TestPixCI(buf, RED, GL_TRUE) == ERROR) {
	    MAKE_ERROR_STRING(GL_BITMAP, GL_STENCIL_INDEX);
	    ErrorReport(__FILE__, __LINE__, errStr);
	    FREE_AND_RETURN(ERROR);
	}
	glDisable(GL_STENCIL_TEST);
    }

    for (i = 0; i < size/8; i++) {
	 convertBuf[i] = 0xFF;
    }
    glClear(GL_COLOR_BUFFER_BIT);
    glDrawPixels(W, H, GL_COLOR_INDEX, GL_BITMAP, convertBuf);
    if (TestPixCI(buf, 1, GL_FALSE) == ERROR) {
	MAKE_ERROR_STRING(GL_BITMAP, GL_COLOR_INDEX);
	ErrorReport(__FILE__, __LINE__, errStr);
	FREE_AND_RETURN(ERROR);
    }

    glPixelStorei(GL_UNPACK_ALIGNMENT, 4);
    FREE_AND_RETURN(NO_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\dlist.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** dlist.c
** Display List Test.
**
** Description -
**    Creates four display lists:
**        Draws a polygon, triangle, and four points, and calls list 2.
**        draws a polygon, triangle strip and triangle fan.
**        draws lines using line strip, line loop, and lines.
**        calls glDrawPixels() with pixel zoom.
**
**    The lists are used to test the following:
**        - A simple display list works, i.e. it can draw a
**        few primitives.
**        - One display list can call a second display list.
**        - The called (second) display list can be deleted and a new
**        display list with the same name can be created, which should
**        be executed when the first list is called.
**        - The COMPILE_AND_EXECUTE mode renders upon calling
**        glNewList. A display list can store user data.
**    
**    To accomplish the above, the test does the following:
**        - Creates lists 1, 2, and 4 using COMPILE mode.
**        - Calls list 1 and tests results.
**        - Deletes list 2, and creates a new list 2.
**        - Call list 1, which calls the new list 2, tests results.
**        - Deletes list 1, and recreates it with
**        COMPILE_AND_EXECUTE mode.
**        - Tests results both after list creation and after calling
**        the list.
**        - Calls list 4 and tests results by examining corners of
**        zoomed image.
**
**    Note that color maps are used in the DrawPixels so that the
**    same data is used for both RGB and CI modes.
**    
**    The test has calls to glGenLists, glDeleteLists, glNewList,
**    glEndList, glCallList.
**
** Error Explanation -
**    After each rendering, it samples a point from each
**    primitive to indicate that it was drawn in the chosen
**    color. For the glDrawPixels() call, it samples several
**    points from the different color bands in the image to check
**    that it was positioned and zoomed correctly.
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer.
**    Color requirements:
**        RGBA or color index mode. 4 colors.
**    States requirements:
**        No state restrictions.
**    Error epsilon:
**        Color epsilon.
**    Paths:
**        Allowed = Alpha, Blend, Depth, Fog, Logicop, Shade, Stencil, Stipple.
**        Not allowed = Alias, Dither.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"


#define CLEANUP_AND_RETURN(err) {                     \
    glPixelMapfv(GL_PIXEL_MAP_I_TO_R, 1, mapReset);   \
    glPixelMapfv(GL_PIXEL_MAP_I_TO_G, 1, mapReset);   \
    glPixelMapfv(GL_PIXEL_MAP_I_TO_B, 1, mapReset);   \
    glDeleteLists(firstList, 3);                      \
    FREE(buf);                                        \
    return(err);                                      \
}


typedef struct _dlPrim {
    GLenum type;
    long vertices;
    GLint ci;
    GLfloat color[3];
    GLint data[10];
    GLint interior[2];
} dlPrim;


dlPrim prims[] = {
    {
	GL_POLYGON, 5, 
	BLUE, 0.0, 0.0, 1.0,
	0, 70, 50, 95, 90, 50, 50, 5, 0, 30,
	1, 68
    },
    {
	GL_TRIANGLES, 3, 
	RED, 1.0, 0.0, 0.0,
	0, 50, 70, 60, 70, 30, 0, 0, 0, 0,
	68, 50
    },
    {
	GL_POINTS, 4, 
	GREEN, 0.0, 1.0, 0.0,
	16, 50, 17, 50, 16, 51, 17, 51, 0, 0,
	16, 50
    },
    {
	GL_POLYGON, 3, 
	GREEN, 0.0, 1.0, 0.0,
	50, 80, 70, 80, 55, 60, 0, 0, 0, 0,
	52, 78
    },
    {
	GL_TRIANGLE_STRIP, 5,
	BLUE, 0.0, 0.0, 1.0,
	50, 40, 50, 50, 55, 40, 55, 50, 60, 35,
	55, 45
    },
    {
	GL_TRIANGLE_FAN, 4, 
	BLUE, 0.0, 0.0, 1.0,
	80, 20, 90, 20, 90, 15, 86, 10, 0, 0,
	86, 12
    },
    {
	GL_LINE_STRIP, 5, 
	RED, 1.0, 0.0, 0.0,
	95, 3, 50, 95, 50, 0, 51, 0, 51, 95,
	50, 30
    },
    {
	GL_LINE_LOOP, 5,
	GREEN, 0.0, 1.0, 0.0,
	95, 15, 95, 95, 60, 95, 94, 20, 94, 15,
	94, 17
    },
    {
	GL_LINES, 4, 
	BLUE, 0.0, 0.0, 1.0,
	50, 3, 95, 3, 70, 4, 98, 4, 0, 0,
	90, 3
    },
    /*
    ** These entries hold data for DrawPixels test.
    */
    {
	0, 1, 
	1, 0.0, 1.0, 0.0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	10, 10
    },
    {
	0, 1, 
	1, 0.0, 1.0, 0.0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	18, 30
    },
    {
	0, 1, 
	3, 1.0, 1.0, 0.0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	22, 40
    },
    {
	0, 1, 
	2, 0.0, 0.0, 1.0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	28, 30
    },
    {
	0, 1, 
	0, 1.0, 0.0, 0.0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	10, 80
    }
};
static char errStr[160];
static char errStrFmt[][80] = {
    "Failure calling display list %d.",
    "Failure calling display list %d. %s",
};


static long TestBuffer(GLfloat *buf, dlPrim *prim, long n)
{
    dlPrim *pp;
    long i, bi;

    pp = prim;

    if (buffer.colorMode == GL_RGB) {
	for (i = 0; i < n; i++) {
	    bi = 3 * (WINDSIZEX * pp->interior[1] + pp->interior[0]);
	    if (ABS(buf[bi]-pp->color[0]) > epsilon.color[0] ||
		ABS(buf[bi+1]-pp->color[1]) > epsilon.color[1] ||
		ABS(buf[bi+2]-pp->color[2]) > epsilon.color[2]) {
		return ERROR;
	    }
	    pp++;
	}
    } else {
	for (i = 0; i < n; i++) {
	    bi = WINDSIZEX * pp->interior[1] + pp->interior[0];
	    if (ABS(buf[bi]-pp->ci) > epsilon.ci) {
		return ERROR;
	    }
	    pp++;
	}
    }
    return NO_ERROR;
}

static void DrawPrim(dlPrim prim)
{
    long i;

    if (buffer.colorMode == GL_RGB) {
	glColor3f(prim.color[0], prim.color[1], prim.color[2]);
    } else {
	glIndexi(prim.ci);
    }

    glBegin(prim.type);
	for (i = 0; i < 2*prim.vertices; i += 2) {
	    glVertex2i(prim.data[i], prim.data[i+1]);
	}
    glEnd();
}

static void CreateList(long whichList, GLuint listNum, GLenum mode)
{
    GLint *image;
    long i, j;

    switch (whichList) {
      case 1:
	glNewList(listNum, mode);
	    DrawPrim(prims[0]);
	    DrawPrim(prims[1]);
	    glPointSize(30.0); 
	    DrawPrim(prims[2]);
	    glCallList(listNum+1);
	glEndList();
	break;

      case 2:
	glNewList(listNum, mode);
	    DrawPrim(prims[3]);
	    DrawPrim(prims[4]);
	    DrawPrim(prims[5]);
	glEndList();
	break;

      case 3:
	glNewList(listNum, mode);
	    glLineWidth(5.0); 
	    DrawPrim(prims[6]);
	    DrawPrim(prims[7]);
	    DrawPrim(prims[8]);
	glEndList();
	break;

      case 4:
	image = (GLint *)MALLOC(WINDSIZEX*WINDSIZEY*sizeof(GLint));
	for (j = 0; j < 5; j++) {
	    for (i = 0; i < 30; i++) {
		image[j*30+i] = (i < 5) ? 1 : 2;
	    }
	}
	for (; j < 30; j++) {
	    for (i = 0; i < 30; i++) {
		image[j*30+i] = (i < 5) ? 0 : 3;
	    }
	}

	glNewList(listNum, mode);
	    glClear(GL_COLOR_BUFFER_BIT);
	    glRasterPos2f(10.0, 10.0);
	    glPixelZoom(2.0, 5.0);
	    glDrawPixels(30, 30, GL_COLOR_INDEX, GL_INT, image);
	    glPixelZoom(1.0, 1.0);
	glEndList();
	FREE(image);
	break;
    }
}

long DisplayListExec(void)
{
    GLfloat *buf;
    GLenum readFormat;
    GLuint firstList;
    GLsizei listSize = 3;
    static GLfloat mapItoR[4] = {1.0, 0.0, 0.0, 1.0};
    static GLfloat mapItoG[4] = {0.0, 1.0, 0.0, 1.0};
    static GLfloat mapItoB[4] = {0.0, 0.0, 1.0, 0.0};
    static GLfloat mapReset[1] = {0.0};

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);
    if (buffer.colorMode == GL_RGB) {
	glClearColor(0.0, 0.0, 0.0, 0.0);
	buf = (GLfloat *)MALLOC(WINDSIZEX*WINDSIZEY*3*sizeof(GLfloat));
	glPixelMapfv(GL_PIXEL_MAP_I_TO_R, 4, mapItoR);
	glPixelMapfv(GL_PIXEL_MAP_I_TO_G, 4, mapItoG);
	glPixelMapfv(GL_PIXEL_MAP_I_TO_B, 4, mapItoB);
	readFormat = GL_RGB;
    } else {
	glClearIndex(0);
	buf = (GLfloat *)MALLOC(WINDSIZEX*WINDSIZEY*sizeof(GLfloat));
	readFormat = GL_COLOR_INDEX;
    }

    firstList = glGenLists(listSize);
    CreateList(1, firstList, GL_COMPILE);
    CreateList(2, firstList+1, GL_COMPILE);
    CreateList(4, firstList+2, GL_COMPILE);

    /*
    ** Call first diplay list, which in turn calls second display list.
    */
    glClear(GL_COLOR_BUFFER_BIT);
    glCallList(firstList);
    ReadScreen(0, 0, WINDSIZEX, WINDSIZEY, readFormat, buf);
    if (TestBuffer(buf, &prims[0], 3) == ERROR ||
	TestBuffer(buf, &prims[3], 3) == ERROR) {
	StrMake(errStr, errStrFmt[0], firstList);
	ErrorReport(__FILE__, __LINE__, errStr);
	CLEANUP_AND_RETURN(ERROR);
    }

    /*
    ** Replace second list with a new list, and call first list again.
    */
    glClear(GL_COLOR_BUFFER_BIT);
    glDeleteLists(firstList+1, 1);
    CreateList(3, firstList+1, GL_COMPILE);
    glCallList(firstList);
    ReadScreen(0, 0, WINDSIZEX, WINDSIZEY, readFormat, buf);
    if (TestBuffer(buf, &prims[0], 3) == ERROR ||
	TestBuffer(buf, &prims[6], 3) == ERROR) {
	StrMake(errStr, errStrFmt[0], firstList);
	ErrorReport(__FILE__, __LINE__, errStr);
	CLEANUP_AND_RETURN(ERROR);
    }

    /*
    ** Test Compile and Execute mode. Check output after creation and
    ** again after calling list explicitly.
    */
    glClear(GL_COLOR_BUFFER_BIT);
    glDeleteLists(firstList, 1);
    CreateList(1, firstList, GL_COMPILE_AND_EXECUTE);
    ReadScreen(0, 0, WINDSIZEX, WINDSIZEY, readFormat, buf);
    if (TestBuffer(buf, &prims[0], 3) == ERROR ||
	TestBuffer(buf, &prims[6], 3) == ERROR) {
	StrMake(errStr, errStrFmt[1], firstList, 
		"Failed to execute using COMPILE_AND_EXECUTE mode.");
	ErrorReport(__FILE__, __LINE__, errStr);
	CLEANUP_AND_RETURN(ERROR);
    }

    glClear(GL_COLOR_BUFFER_BIT);
    glCallList(firstList);
    ReadScreen(0, 0, WINDSIZEX, WINDSIZEY, readFormat, buf);
    if (TestBuffer(buf, &prims[0], 3) == ERROR ||
	TestBuffer(buf, &prims[6], 3) == ERROR) {
	StrMake(errStr, errStrFmt[1], firstList, 
		"Failed CallList using COMPILE_AND_EXECUTE mode.");
	ErrorReport(__FILE__, __LINE__, errStr);
	CLEANUP_AND_RETURN(ERROR);
    }

    /*
    ** Call a list which requires user-supplied data.
    */
    glCallList(firstList+2); 
    ReadScreen(0, 0, WINDSIZEX, WINDSIZEY, readFormat, buf);
    if (TestBuffer(buf, &prims[9], 5) == ERROR) {
	StrMake(errStr, errStrFmt[1], firstList+2, 
		"Failed using list with DrawPixels.");
	ErrorReport(__FILE__, __LINE__, errStr);
	CLEANUP_AND_RETURN(ERROR);
    }


    CLEANUP_AND_RETURN(NO_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\foglin.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** foglin.c
** Fog Linear Test.
**
** Description -
**    This file contains two tests, one for the RGB and one for
**    CI fog equations. Only the linear fog computation is tested
**    in this test. This test examines the effect which varying
**    the z eye coordinate has on the color of the point. The
**    test repeats itself with different fog start and fog end
**    values.
**    
**    In RGB mode it only tests one color channel at a time.
**    First it examines the effect of the fog weighting on the
**    current color, and then it examines the effect on fog
**    color. When the current color is being examined the fog
**    color is set to black, and one channel of the current color
**    is set to 1.0. When the fog color is being examined the
**    current color is set to black, and one channel of the fog
**    color is set to 1.0. In CI mode only the fog index is
**    examined and the current index is set to 0.
**    
**    The test repeatedly renders a point in the lower left
**    corner of the window and reads back the color of that
**    point. At each iteration the reference value is moved away
**    from the fogEnd value and toward the fogStart value. The z
**    value of the rendered point is the negative of this value.
**    Since implementations could conceivable use the distance of
**    the object from the eye to calculate the fog, the point is
**    positioned so that it's distance from the eye is equal to
**    it's z coordinate.
**    
**    By uniformly incrementing the point from the fogEnd value
**    to the fogStart value the fogWeighting, f, is uniformly
**    incremented. This should uniformly increment the color if
**    we are testing the current color and decrement the color if
**    we are testing the fog color. In the case of CI mode it
**    will always decrement the index.
**    
**    In RGB mode the observed color of the point is examined.
**    An implementation fails if a color channel is non-zero,
**    when it should be zero, or if it is not 1.0 when it should
**    be 1.0. The observed values are also examined for
**    monotonocity. An implementation fails if the results which
**    should increment/decrement monotonically fail to do so.
**    Finally an implementation will fail if the observed color
**    is more than 1.5 shades from the expected color.
**    
**    In CI mode the observed value is checked to be
**    monotonically decreasing. It is confirmed to be an
**    integer, and it is checked to reach maxIndex when the z
**    value is equal to the fogStart value. The implementation
**    fails if the observed index is more than 2 away from the
**    theoretically correct index. It will also fail if the
**    difference between two consecutive observations is larger
**    than 2 (delta > 2).
**
** Error Explanation -
**    RGB mode: other_color > 0.0.
**    RGB mode: value < lastValue when it should be greater.
**    RGB mode: maxObserved < 1.0.
**    RGB mode: (observed - expected) > 1.5*epsilon.color.
**    CI mode: (fractional index) != 0.0.
**    CI mode: (observed - expected) > 2.0.
**    CI mode: observedMax < numColor.
**    CI mode: delta > 2.0.
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer.
**    Color requirements:
**        RGBA or color index mode. Full color.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**        Color, ci and zero epsilon.
**    Paths:
**        Allowed = Alpha, Blend, Depth, Logicop, Stencil, Stipple.
**        Not allowed = Alias, Dither, Fog, Shade.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"
#include "utilru.h"


typedef struct _fogLinRec {
    long color;
    float step, lastValue, lastDelta;
    long useFog;
    float numColor, e, s, z;
} fogLinRec;


static char errStr[320];
static char errStrFmt[][240] = {
    "Observed RGBA = (%g, %g, %g, %g). Expected %s to be 0.0. Fog start = %g, fog end = %g, z = %g fog RGBA = (%g, %g, %g, %g), color RGBA = (%g, %g, %g, %g).",
    "Observed RGB = (%g, %g, %g) differs too much from expected RGB = (%g, %g, %g). Fog start = %g, fog end = %g, z = %g, fog RGBA = (%g, %g, %g, %g), color RGBA = (%g, %g, %g, %g).",
    "Non-monotic color. Fog start = %g, fog end = %g, z = %g, fog RGBA = (%g, %g, %g, %g), color RGBA = (%g, %g, %g, %g).",
    "Expected fully saturated color. Observed RGB = (%g, %g, %g), fog start = %g, fog end = %g, z = %g, fog RGBA = (%g, %g, %g, %g), color RGBA = (%g, %g, %g, %g).",
    "Observed color index of %g is not an integer, fog start = %g, fog end = %g, z = %g, fogindex = %g.",
    "Observed color index of %g is not monotonically decreasing, last value was %g, fog start = %g, fog end = %g, z = %g, fog index = %g.",
    "Observed color index of %g differs by too much from the expected value of %g, fog start = %g, fog end = %g, z = %g, fog index = %g.",
    "Observed color index of %g differs from last value of %g by more than 2.0, fog start = %g, fog end = %g, z = %g, fog index = %g.",
    "Observed color index of %g should be fully black fog Index of 0.0, fog start = %g, fog end = %g, z = %g, fog index = %g."
};


static char *ErrIndexToColorName(long i)
{

    switch (i) {
      case 0:
	return "RED";
      case 1:
	return "GREEN";
      case 2:
	return "BLUE";
      case 3:
	return "ALPHA";
    }
    return "NO_SUCH_COLOR";
}

/******************************************************************************/

static void Set(void *data, float *ref)
{
    static float one = 1.0;
    fogLinRec *ptr = (fogLinRec *)data;

    ptr->z = ((1.0 - *ref) * ptr->e + *ref * ptr->s);

    /*
    ** z value and distance in eye space are the same magnitude.
    */
    glBegin(GL_POINTS);
	glVertex3f(0.0, 0.0, -ptr->z);
    glEnd();

    *ref += ptr->step;
}

/******************************************************************************/

static void InitToBlack(float color[4])
{

    color[0] = 0.0;
    color[1] = 0.0;
    color[2] = 0.0;
    color[3] = 1.0;
}

static void InitRGB(void *data)
{
    fogLinRec *ptr = (fogLinRec *)data;
    GLfloat buf[4];

    ptr->lastValue = -1.0;
    ptr->lastDelta = -2.0;

    if (machine.pathLevel == 0) {
	ptr->step = 0.5 / ptr->numColor;
    } else {
	ptr->step = 0.25;
    }

    /*
    ** Both the fog and the current color must have alpha = 1.0;
    */
    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = 0.0;
    buf[3] = 1.0;
    (ptr->useFog == GL_TRUE) ? glColor4fv(buf) : glFogfv(GL_FOG_COLOR, buf);

    buf[ptr->color] = 1.0;
    (ptr->useFog == GL_TRUE) ? glFogfv(GL_FOG_COLOR, buf) : glColor4fv(buf);

    glFogf(GL_FOG_MODE, (float)GL_LINEAR);
    glFogf(GL_FOG_END, ptr->e);
    glFogf(GL_FOG_START, ptr->s);
}

static long TestRGB(void *data, float ref)
{
    fogLinRec *ptr = (fogLinRec *)data;
    GLfloat buf[3];
    float value, delta;
    long i;

    ReadScreen(0, 0, 1, 1, GL_RGB, buf);

    for (i = 0; i < 3; i++) {
	if (buf[i] != 0.0 && i != ptr->color) {
	    /*
	    ** Only Error Mesg. stuff.
	    */
	    float fog[4], color[4];
	    InitToBlack(color);
	    InitToBlack(fog);
	    (ptr->useFog == GL_TRUE) ? (fog[ptr->color] = 1.0) :
				       (color[ptr->color] = 1.0);
	    StrMake(errStr, errStrFmt[0], buf[0], buf[1], buf[2], 1.0,
		    ErrIndexToColorName(i), ptr->s, ptr->e, -ptr->z, color[0],
		    color[1], color[2], color[3], fog[0], fog[1], fog[2],
		    fog[3]);
	    ErrorReport(__FILE__, __LINE__, errStr);
	    return ERROR;
	}
    }

    value = buf[ptr->color];
    if (ptr->useFog == GL_TRUE) {
	value = 1.0 - value;
    }

    if (ABS(value-ref) > 1.5*epsilon.color[ptr->color]) {
	/*
	** Only Error Mesg Stuff.
	*/
	float fog[4], color[4], expected[4];
	InitToBlack(color);
	InitToBlack(fog);
	InitToBlack(expected);
	(ptr->useFog == GL_TRUE) ? (fog[ptr->color] = 1.0) :
				   (color[ptr->color] = 1.0);
	expected[ptr->color] = (ptr->useFog == GL_TRUE) ? (1.0 - ref) : ref;
	StrMake(errStr, errStrFmt[1], buf[0], buf[1], buf[2], expected[0],
		expected[1], expected[2], ptr->s, ptr->e, -ptr->z, color[0],
		color[1], color[2], color[3], fog[0], fog[1], fog[2], fog[3]);
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }

    /*
    ** The linearity test is disabled, but due to variable sample spacing
    ** delta should be approximately constant.
    */
    if (ptr->lastDelta == -2.0) {
	ptr->lastDelta = -1.0;
	ptr->lastValue = value;
    } else if (ptr->lastDelta == -1.0) {
	if (value < ptr->lastValue) {
	    /*
	    ** Only Error Mesg Stuff.
	    */
	    float fog[4], color[4];
	    InitToBlack(color);
	    InitToBlack(fog);
	    (ptr->useFog == GL_TRUE) ? (fog[ptr->color] = 1.0 ) : 
				       (color[ptr->color] = 1.0);
	    StrMake(errStr, errStrFmt[2], ptr->s, ptr->e, -ptr->z, color[0],
		    color[1], color[2], color[3], fog[0], fog[1], fog[2],
		    fog[3]);
	    ErrorReport(__FILE__, __LINE__, errStr);
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	if (ABS(delta) > epsilon.zero) {
	    ptr->lastDelta = delta;
	}
    } else {
	if (value < ptr->lastValue) {
	    /*
	    ** Only Error Mesg Stuff.
	    */
	    float fog[4], color[4];
	    InitToBlack(color);
	    InitToBlack(fog);
	    (ptr->useFog == GL_TRUE) ? (fog[ptr->color] = 1.0) : 
				       (color[ptr->color] = 1.0);
	    StrMake(errStr, errStrFmt[2], ptr->s, ptr->e, -ptr->z, color[0],
		    color[1], color[2], color[3], fog[0], fog[1], fog[2],
		    fog[3]);
	    ErrorReport(__FILE__, __LINE__, errStr);
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	/*
	** Enable this if you want to check uniformity of change.
	*/
	if (ABS(delta) > epsilon.zero) {
	    ptr->lastDelta = delta;
	}
    }
    if (ref >= 1.0 && ABS(value-1.0) > epsilon.zero) {
	/*
	** Only Error Mesg Stuff.
	*/
	float fog[4], color[4];
	InitToBlack(color);
	InitToBlack(fog);
	(ptr->useFog == GL_TRUE) ? (fog[ptr->color] = 1.0) : 
				   (color[ptr->color] = 1.0);
	StrMake(errStr, errStrFmt[3], buf[0], buf[1], buf[0], ptr->s, ptr->e,
		-ptr->z, color[0], color[1], color[2], color[3], fog[0],
		fog[1], fog[2], fog[3]);
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }

    return NO_ERROR;
}

long FogLinRGBExec(void)
{
    static float endPoints[11][2] = {
	{
	    0.0, 1.0
	},
	{
	    0.0, 10.0
	},
	{
	    0.0, 100.0
	},
	{
	    0.0, 1000.0
	},
	{
	    1.0, 2.0
	},
	{
	    1.0, 10.0
	},
	{
	    1.0, 1000.0
	},
	{
	    3.0, 3.5
	},
	{
	    3.5, 1000.0
	},
	{
	    1.0, 0.0
	},
	{
	    10.0, 1.0
	}
    };
    fogLinRec data;
    GLfloat m[4][4];
    float start, unscale, tmp;
    long i;

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glDisable(GL_DITHER);
    glEnable(GL_FOG);

    for (i = 0; i < 11; i++) {
	data.e = endPoints[i][0];
	data.s = endPoints[i][1];

	/*
	** Since the eye-coordinates are used for calculating the distance
	** or zfog value, we have to do a little transformation hocus-pocus
	** to allow for a large homogeneous clip coordinate and to allow z
	** and distance to be equal in eye coordinates.
	*/
	unscale = ABS(data.e);
	if ((tmp = ABS(data.s)) > unscale) {
	    unscale = tmp;
	}

	Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);
	glMatrixMode(GL_PROJECTION);
	glTranslatef(0.5, 0.5, 0.0);
	MakeIdentMatrix(&m[0][0]);
	m[0][0] = unscale;
	m[1][1] = unscale;
	m[3][3] = unscale;
	glMultMatrixf(&m[0][0]);
	glMatrixMode(GL_MODELVIEW);

	for (data.useFog = GL_FALSE; data.useFog <= GL_TRUE; data.useFog++) {
	    for (data.color = 0; data.color < 3; data.color++) {
		data.numColor = POW(2.0, (float)buffer.colorBits[data.color]) - 1.0;
		start = 0.5 / data.numColor;
		if (RampUtil(start, 1.0, InitRGB, Set, TestRGB,
			     &data) == ERROR) {
		    return ERROR;
		}
	    }
	}
    }
    return NO_ERROR;
}

/******************************************************************************/

static void InitCI(void *data)
{
    fogLinRec *ptr = (fogLinRec *)data;
    GLfloat buf[4];

    ptr->lastValue = -1.0;
    ptr->lastDelta = -2.0;

    /*
    ** This should work for a 16 bit color Index. If anybody has a larger map
    ** this could need tuning.
    */
    if (machine.pathLevel == 0) {
	ptr->step = 0.5 / ptr->numColor;
    } else {
	ptr->step = 0.25;
    }

    buf[0] = ptr->numColor;
    glFogfv(GL_FOG_INDEX, buf);

    glIndexf(0.0);

    buf[0] = GL_LINEAR;
    glFogf(GL_FOG_MODE, GL_LINEAR);
    glFogf(GL_FOG_END, ptr->e);
    glFogf(GL_FOG_START, ptr->s);
}

/*
** In Color Index mode we check the following:
** 1) Is the value an integer?
** 2) Is the ramp monotonic?
** 3) Does it round approximately correctly?
** 4) Does it skip any possible indices?
** 5) Does it ever reach the top index?
*/
static long TestCI(void *data, float ref)
{
    fogLinRec *ptr = (fogLinRec *)data;
    float expected, value, frac, delta;
    GLfloat buf;

    ReadScreen(0, 0, 1, 1, GL_COLOR_INDEX, &buf);
    value = buf;

    value = ptr->numColor - value;
    frac = ABS(value-(float)((int)value));
    if (frac > epsilon.zero && ABS(frac-1.0) > epsilon.zero) {
	StrMake(errStr, errStrFmt[4], ptr->numColor-value, ptr->s, ptr->e,
		-ptr->z, ptr->numColor);
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }

    if (ptr->lastValue == -1.0) {
	ptr->lastValue = value;
    } else {
	if (value < ptr->lastValue) {
	    StrMake(errStr, errStrFmt[5], ptr->numColor-value,
		    ptr->numColor-ptr->lastValue, ptr->s, ptr->e, -ptr->z,
		    ptr->numColor);
	    ErrorReport(__FILE__, __LINE__, errStr);
	    return ERROR;
	}
	expected = (float)Round(2.0*ref*ptr->numColor) / 2.0;
	if (ABS(value-expected) > 2.0*epsilon.ci+epsilon.zero) {
	    StrMake(errStr, errStrFmt[6], ptr->numColor-value,
		    ptr->numColor-expected, ptr->s, ptr->e, -ptr->z,
		    ptr->numColor);
	    ErrorReport(__FILE__, __LINE__, errStr);
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	if (ABS(delta) > epsilon.zero) {
	    if (ABS(delta) >= 2.0 && machine.pathLevel == 0) {
		StrMake(errStr, errStrFmt[7], ptr->numColor-value,
			ptr->numColor-expected, ptr->s, ptr->e, -ptr->z,
			ptr->numColor);
		ErrorReport(__FILE__, __LINE__, errStr);
		return ERROR;
	    }
	}
    }

    if (ref >= 1.0 && value < ptr->numColor-epsilon.zero) {
	StrMake(errStr, errStrFmt[8], ptr->numColor-value, ptr->s, ptr->e, 
		-ptr->z, ptr->numColor);
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }
    return NO_ERROR;
}

long FogLinCIExec(void)
{
    static float endPoints[5][2] = {
	{
	    0.0, 1.0
	},
	{
	    0.0, 10.0
	},
	{
	    0.0, 1000.0
	},
	{
	    1.0, 2.0
	},
	{
	    10.0, 1.0
	}
    };
    fogLinRec data;
    float unscale, tmp, start, end, frac;
    GLfloat m[4][4];
    long i;

    /*
    ** Since the eye coordinates are used to calculate the distance or zfog
    ** value, we have to do a little transformation hocus pocus to allow for
    ** a large homogeneous clip coordinate and to allow z and distance to be
    ** equal in eye coordinates. 12.0 is chosen as it is bigger than ln(65536)
    ** which is hopefully the largest number of color indices available.
    */
    glClearIndex(0.0);
    glDisable(GL_DITHER);
    glEnable(GL_FOG);

    data.numColor = POW(2.0, (float)buffer.ciBits) - 1.0;
    for (i = 0; i < 5; i++) {
	data.e = endPoints[i][0];
	data.s = endPoints[i][1];

	unscale = ABS(data.e);
	if ((tmp = ABS(data.s)) > unscale) {
	    unscale = tmp;
	}

	Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);
	glMatrixMode(GL_PROJECTION);
	glTranslatef(0.5, 0.5, 0.0);
	MakeIdentMatrix(&m[0][0]);
	m[0][0] = unscale;
	m[1][1] = unscale;
	m[3][3] = unscale;
	glMultMatrixf(&m[0][0]);
	glMatrixMode(GL_MODELVIEW);

	if (data.numColor < 4096.0 || machine.pathLevel != 0) {
	    start = 0.5 / data.numColor;
	    if (RampUtil(start, 1.0, InitCI, Set, TestCI, &data) == ERROR) {
		return ERROR;
	    }
	} else {
	    start = 0.5 / data.numColor;
	    frac = POW(2.0, (float)(8-buffer.ciBits));
	    if (RampUtil(start, frac, InitCI, Set, TestCI, &data) == ERROR) {
		return ERROR;
	    }
	    start = 0.5 - frac;
	    end = 0.5 + frac;
	    if (RampUtil(start, end, InitCI, Set, TestCI, &data) == ERROR) {
		return ERROR;
	    }
	    start = 1.0 - frac;
	    if (RampUtil(start, 1.0, InitCI, Set, TestCI, &data) == ERROR) {
		return ERROR;
	    }
	}
    }
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\linehv.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** linehv.c
** Horizontal And Vertical Line Test.
**
** Description -
**    Tests the rasterization of horizontal and vertical lines.
**    Even though the OpenGL specification is very lacks on
**    defining exact fragment location for lines, an
**    implementation that does not properly handle horizontal or
**    vertical with well behaved endpoints would be a poor OpenGL
**    library. The lines are integer widths, within LINE_WIDTH_RANGE. 
**    The vertices of the lines are pixel centered. The lines are
**    tested at exact pixel locations.
**
**    There is an allowance for half-open lines (for left or right
**    ends but not both ends).
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer.
**    Color requirements:
**        RGBA or color index mode. 2 colors.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**        Color epsilon.
**    Paths:
**        Allowed = Alpha, Blend, Depth, Fog, Logicop, Shade, Stencil, Stipple.
**        Not allowed = Alias, Dither.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"


static char errStr[160];
static char srrStrFmt[] = "Line (%d, %d) (%d, %d) (width of %d) is not %s.";


static void ClearDraw(GLint *v1, GLint *v2)
{

    glClear(GL_COLOR_BUFFER_BIT);

    glBegin(GL_LINES);
	glVertex2f((GLfloat)v1[0]+0.5, (GLfloat)v1[1]+0.5);
	glVertex2f((GLfloat)v2[0]+0.5, (GLfloat)v2[1]+0.5);
    glEnd();
}

static long XLines(GLint *v1, GLint *v2, GLsizei len, GLsizei width,
		   GLfloat *buf)
{
    GLfloat *ptr;
    GLint endPoints[2], x, y, i, j;

    ClearDraw(v1, v2);

    if (v1[0] <= v2[0]) {
	x = v1[0] - 1;
    } else {
	x = v2[0];
    }
    if (width % 2) {
	y = v1[1] - (width / 2) - 1;
    } else {
	y = v1[1] - (width / 2 - 1) - 1;
    }
    ReadScreen(x, y, len+2, width+2, GL_AUTO_COLOR, buf);

    ptr = buf;
    for (i = 0; i < len+2; i++) {
	if (AutoColorCompare(*ptr++, COLOR_OFF) == GL_FALSE) {
	    return ERROR;
	}
    }
    for (i = 0; i < width; i++) {
	if (AutoColorCompare(*ptr++, COLOR_OFF) == GL_FALSE) {
	    return ERROR;
	}
	if (AutoColorCompare(*ptr++, COLOR_ON) == GL_TRUE) {
	    endPoints[0] = GL_TRUE;
	} else {
	    endPoints[0] = GL_FALSE;
	}
	for (j = 1; j < len-1; j++) {
	    if (AutoColorCompare(*ptr++, COLOR_ON) == GL_FALSE) {
		return ERROR;
	    }
	}
	if (AutoColorCompare(*ptr++, COLOR_ON) == GL_TRUE) {
	    endPoints[1] = GL_TRUE;
	} else {
	    endPoints[1] = GL_FALSE;
	}
	if (AutoColorCompare(*ptr++, COLOR_OFF) == GL_FALSE) {
	    return ERROR;
	}
    }
    for (i = 0; i < len+2; i++) {
	if (AutoColorCompare(*ptr++, COLOR_OFF) == GL_FALSE) {
	    return ERROR;
	}
    }

    if (endPoints[0] == GL_FALSE && endPoints[1] == GL_FALSE) {
	return ERROR;
    }

    return NO_ERROR;
}

static long YLines(GLint *v1, GLint *v2, GLsizei len, GLsizei width,
		   GLfloat *buf)
{
    GLfloat *ptr;
    GLint *endPoints, x, y, i, j;

    ClearDraw(v1, v2);

    if (width % 2) {
	x = v1[0] - (width / 2) - 1;
    } else {
	x = v1[0] - (width / 2 - 1) - 1;
    }
    if (v1[1] <= v2[1]) {
	y = v1[1] - 1;
    } else {
	y = v2[1];
    }
    ReadScreen(x, y, width+2, len+2, GL_AUTO_COLOR, buf);

    ptr = buf;
    for (i = 0; i < width+2; i++) {
	if (AutoColorCompare(*ptr++, COLOR_OFF) == GL_FALSE) {
	    return ERROR;
	}
    }
    endPoints = (GLint *)MALLOC(width*sizeof(GLint));
    if (AutoColorCompare(*ptr++, COLOR_OFF) == GL_FALSE) {
	FREE(endPoints);
	return ERROR;
    }
    for (i = 0; i < width; i++) {
	if (AutoColorCompare(*ptr++, COLOR_ON) == GL_TRUE) {
	    endPoints[i] = GL_TRUE;
	} else {
	    endPoints[i] = GL_FALSE;
	}
    }
    if (AutoColorCompare(*ptr++, COLOR_OFF) == GL_FALSE) {
	FREE(endPoints);
	return ERROR;
    }
    for (i = 1; i < len-1; i++) {
	if (AutoColorCompare(*ptr++, COLOR_OFF) == GL_FALSE) {
	    FREE(endPoints);
	    return ERROR;
	}
	for (j = 0; j < width; j++) {
	    if (AutoColorCompare(*ptr++, COLOR_ON) == GL_FALSE) {
		FREE(endPoints);
		return ERROR;
	    }
	}
	if (AutoColorCompare(*ptr++, COLOR_OFF) == GL_FALSE) {
	    FREE(endPoints);
	    return ERROR;
	}
    }
    if (AutoColorCompare(*ptr++, COLOR_OFF) == GL_FALSE) {
	FREE(endPoints);
	return ERROR;
    }
    for (i = 0; i < width; i++) {
	if (AutoColorCompare(*ptr++, COLOR_OFF) == GL_TRUE) {
	    if (endPoints[i] == GL_FALSE) {
		FREE(endPoints);
		return ERROR;
	    }
	}
    }
    if (AutoColorCompare(*ptr++, COLOR_OFF) == GL_FALSE) {
	FREE(endPoints);
	return ERROR;
    }
    FREE(endPoints);
    for (i = 0; i < width+2; i++) {
	if (AutoColorCompare(*ptr++, COLOR_OFF) == GL_FALSE) {
	    return ERROR;
	}
    }

    return NO_ERROR;
}

long LineHVExec(void)
{
    GLfloat *buf, widthRange[2];
    long max;
    GLint v1[2], v2[2];
    GLsizei len, i;

    buf = (GLfloat *)MALLOC(WINDSIZEX*WINDSIZEY*sizeof(GLfloat));

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    AutoClearColor(COLOR_OFF);
    AutoColor(COLOR_ON);
    glDisable(GL_DITHER);

    glGetFloatv(GL_LINE_WIDTH_RANGE, widthRange);
    max = (machine.pathLevel == 0) ? (long)widthRange[1] : 1;

    for (i = 1; i <= max; i++) {
	glLineWidth((GLfloat)i);

	len = (GLsizei)Random(3.0, WINDSIZEX/8.0);
	v1[0] = (GLint)Random(WINDSIZEX/4.0, WINDSIZEX*3.0/4.0);
	v1[1] = (GLint)Random(WINDSIZEY/4.0, WINDSIZEY*3.0/4.0);
	v2[0] = v1[0] + len;
	v2[1] = v1[1];
	if (XLines(v1, v2, len, i, buf) == ERROR) {
	    StrMake(errStr, srrStrFmt, v1[0], v1[1], v2[0], v2[1], i,
		    "horizontal");
	    ErrorReport(__FILE__, __LINE__, errStr);
	    FREE(buf);
	    return ERROR;
	}

	len = (GLsizei)Random(3.0, WINDSIZEX/8.0);
	v1[0] = (GLint)Random(WINDSIZEX/4.0, WINDSIZEX*3.0/4.0);
	v1[1] = (GLint)Random(WINDSIZEY/4.0, WINDSIZEY*3.0/4.0);
	v2[0] = v1[0];
	v2[1] = v1[1] + len;
	if (YLines(v1, v2, len, i, buf) == ERROR) {
	    StrMake(errStr, srrStrFmt, v1[0], v1[1], v2[0], v2[1], i,
		    "vertical");
	    ErrorReport(__FILE__, __LINE__, errStr);
	    FREE(buf);
	    return ERROR;
	}

	len = (GLsizei)Random(3.0, WINDSIZEX/8.0);
	v1[0] = (GLint)Random(WINDSIZEX/4.0, WINDSIZEX*3.0/4.0);
	v1[1] = (GLint)Random(WINDSIZEY/4.0, WINDSIZEY*3.0/4.0);
	v2[0] = v1[0] - len;
	v2[1] = v1[1];
	if (XLines(v1, v2, len, i, buf) == ERROR) {
	    StrMake(errStr, srrStrFmt, v1[0], v1[1], v2[0], v2[1], i,
		    "horizontal");
	    ErrorReport(__FILE__, __LINE__, errStr);
	    FREE(buf);
	    return ERROR;
	}

	len = (GLsizei)Random(3.0, WINDSIZEX/8.0);
	v1[0] = (GLint)Random(WINDSIZEX/4.0, WINDSIZEX*3.0/4.0);
	v1[1] = (GLint)Random(WINDSIZEY/4.0, WINDSIZEY*3.0/4.0);
	v2[0] = v1[0];
	v2[1] = v1[1] - len;
	if (YLines(v1, v2, len, i, buf) == ERROR) {
	    StrMake(errStr, srrStrFmt, v1[0], v1[1], v2[0], v2[1], i,
		    "vertical");
	    ErrorReport(__FILE__, __LINE__, errStr);
	    FREE(buf);
	    return ERROR;
	}
    }

    FREE(buf);
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\evalc.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** evalv.c
** Evaluator Vertex Test.
**
** Description -
**    An evaluator surface is rendered covereing the screen and
**    parallel to the viewport. A 2d x 4d color evaluator map is
**    initialized. The surface is rendered with glEvalCoord() and
**    then again with glMapMesh(GL_POINTS, ...). Single pixel
**    points are used to render the surface as their shape and
**    coloring is more well defined than other primitives. The
**    results are read using glReadPixels(), and compared to the
**    theoretical values. Some of the generated evaluator values
**    are greater tnan 1.0. This checks if the colors are
**    correctly clamped. If the rendered image and the
**    theoretical values differ by more than one shade the
**    implementation fails. For the surface itself the u, v
**    coordinates chosen should yield x and y values exactly on
**    pixel centers.
**
** Error Explanation -
**    Failure occurs if the point rendered is more than one shade
**    different from the internally calculated theoretical
**    result.
**
** Technical Specification -
**    Buffer requirements:
**        RGB Color buffer.
**    Color requirements:
**        No color restrictions.
**    States requirements:
**        Disabled = GL_DITHER.
**        Enabled = GL_MAP2_VERTEX_4.
**        Non-default control points and orders of Bernstein polynomials.
**    Error epsilon:
**        We use color epsilon (one shade of color) to distinguish between
**        points which are have been shaded correctly by the evaluator code
**        and those with incorrect evaluator color code. Implementations with
**        more than 6 bits of color resolution for any given color channel 
**        are allowed an of 0.01 for those color channels.
**    Paths:
**        Allowed = Alpha, Blend, Depth, Fog, Logicop, Shade, Stencil, Stipple.
**        Not allowed = Alias, Dither.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"
#include "utile.h"


#define VMAJOR_ORDER 2
#define VMINOR_ORDER 2
#define VDIM 4
#define CMAJOR_ORDER 2
#define CMINOR_ORDER 3
#define CDIM 4
#define EVAL 3
#define MESH 4
#define FRAG_ERROR 0.52


static float point2f[VMAJOR_ORDER*VMINOR_ORDER*VDIM] = {
    -1.0, -1.0, 1.0, 1.0,
     1.0, -1.0, 1.0, 1.0,
    -1.0,  1.0, 1.0, 1.0,
     1.0,  1.0, 1.0, 1.0
};

/*
** Use these control points to test color clamping.
**
static float color2f[CMAJOR_ORDER*CMINOR_ORDER*CDIM] = {
     1.0,  0.0,  1.0, 1.0,
     0.0,  3.0,  1.0, 1.0,
     1.0,  0.0,  1.0, 1.0,
     1.0,  3.0,  1.0, 1.0,
     0.0,  0.0,  1.0, 1.0,
     1.0,  3.0,  1.0, 1.0
};
*/

static float color2f[CMAJOR_ORDER*CMINOR_ORDER*CDIM] = {
     1.0,  0.0,  0.0, 1.0,
     0.0,  1.5,  1.0, 1.0,
     1.0,  0.0,  0.0, 1.0,
     1.0,  1.5,  1.0, 1.0,
     0.0,  0.0,  1.0, 1.0,
     1.0,  1.5,  1.0, 1.0
};
static char errStr[320];
static char errStrFmt[][240] = {
    "Evaluator GL_MAP2_COLOR_4. The color of the pixel (%d, %d) is different from the expected color. For u = %g v = %g the expected color is RGBA = (%g, %g, %g, %g). The color observed was (%g, %g, %g, %g)."
};


static void InitMap2(eval2Rec *e2, evalDomainRec *map, evalDomainRec *grid)
{

/*
** XXX With the fancy new-fangled compilers we can't call *2f and *2d with
** out explicit cast.
**  Here the variables left as floats do not show an error since GLdouble
** has been typedef'd to type float. even though the function is prototyped
** for GLdoubles.
*/
    glMap2f(e2->dataTypeEnum, map->uStart, map->uEnd, e2->minorOrder*e2->dim,
	    e2->majorOrder, map->vStart, map->vEnd, e2->dim, e2->minorOrder, 
	    e2->controls);
    glMapGrid2d(grid->uCount, grid->uStart, grid->uEnd, grid->vCount, 
		grid->vStart, grid->vEnd);
    glEnable(e2->dataTypeEnum);
}

static void DrawMapEvalColor(long gridType, evalDomainRec *d) 
{
    float u, v;
    long i, j; 

    switch (gridType) {
      case EVAL:
	glBegin(GL_POINTS);
	for (i = 0; i < 100; i++) {
	    u = d->uStart + i * d->du;
	    for (j = 0; j < 100; j++) {
		v = d->vStart + j * d->dv;
		glEvalCoord2d(u, v);
	    }
	    glEvalCoord2d(u, d->uEnd);
	}
	glEnd();
	glFlush();
	break;
      case MESH:
	glEvalMesh2(GL_POINT, 0, d->uCount, 0, d->vCount);
	glFlush();
	break;
    }
}

static long TestEvalColor(long gridType, eval2Rec *eC, evalDomainRec *grid, 
			  GLfloat *buf)
{
    float u, v;
    GLfloat *ptr; 
    float c[4];
    float colorErr[3];
    long i, j;

    glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
    DrawMapEvalColor(gridType, grid);
    ReadScreen(0, 0, WINDSIZEX, WINDSIZEY, GL_RGBA, buf);
    ptr = buf;
    colorErr[0] = (epsilon.color[0] > 0.01) ? epsilon.color[0] : 0.01;
    colorErr[1] = (epsilon.color[1] > 0.01) ? epsilon.color[1] : 0.01;
    colorErr[2] = (epsilon.color[2] > 0.01) ? epsilon.color[2] : 0.01;
    for (j = 0; j < 100; j++) {
	u = grid->uStart + j * grid->du;
	for (i = 0; i < 100; i++) {
	    v = grid->vStart + i * grid->dv;
	    Evaluate2(eC, u, v, c);
	    ClampArray(c, 0.0, 1.0, 4);
	    if (ABS(ptr[0]-c[0]) > colorErr[0] || 
	        ABS(ptr[1]-c[1]) > colorErr[1] ||
	        ABS(ptr[2]-c[2]) > colorErr[2]) {
		StrMake(errStr, errStrFmt[0], i, j, u, v, c[0], c[1], 
		        c[2], c[3], ptr[0], ptr[1], ptr[2], ptr[3]);
		ErrorReport(__FILE__, __LINE__, errStr);
		return ERROR;
	    }
	    ptr += 4;
	}
    }
    return NO_ERROR;
}

long EvalColorExec(void)
{
    eval2Rec *eV, *eC;
    evalDomainRec *fn, *grid;
    long gridType, flag = NO_ERROR;
    GLfloat *buf;

    glDisable(GL_DITHER);

    buf = (GLfloat *)MALLOC(4*WINDSIZEX*WINDSIZEY*sizeof(GLfloat));
    eV = MakeEval2(VMAJOR_ORDER, VMINOR_ORDER, VDIM, GL_MAP2_VERTEX_4, point2f);
    eC = MakeEval2(CMAJOR_ORDER, CMINOR_ORDER, CDIM, GL_MAP2_COLOR_4, color2f);
    fn = MakeDomain(0.0, 1.0, 100, 0.0, 1.0, 100);
    grid = MakeDomain(0.005, 0.995, 99, 0.005, 0.995, 99);
    InitMap2(eV, fn, grid);
    InitMap2(eC, fn, grid);

    for (gridType = EVAL; gridType < MESH; gridType++) {
	if (TestEvalColor(gridType, eC, grid, buf) == ERROR) {
	    flag = ERROR;
	    break;
	}
    }

    ResetEvalToDefault();

    FreeEval2(eV);
    FreeDomain(fn);
    FreeDomain(grid);
    FREE(buf);

    return flag;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\feedback.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** feedback.c
** Feedback Test.
**
** Description -
**    All primitives, glCopyPixels(), glDrawPixels() and
**    glPassThrough() are rendered in feedback mode. The returned
**    value from glRenderMode() is check to see if the correct
**    amount of information was placed in the feedback buffer.
**    The feedback buffer is then checked for correct information
**    (vertex coordinates, color and texture coordinates). The
**    test is repeated for all feedback modes.
**
** Technical Specification -
**    Buffer requirements:
**        Feedback buffer.
**    Color requirements:
**        RGBA or color index mode. 2 colors.
**    States requirements:
**        No state restrictions.
**    Error epsilon:
**        Zero and color epsilon.
**    Paths:
**        Allowed = Alias, Alpha, Blend, Depth, Dither, Fog, Logicop, Shade,
**                  Stencil, Stipple.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"


static char errPrim[40], errType[40];
static char errStr[240];
static char errStrFmt[][160] = {
    "Primitive %s. Feedback type %s. Could not match feedback vertex.",
    "Primitive %s. Feedback type %s. Could not match feedback colors.",
    "Primitive %s. Feedback type %s. Could not match feedback texture coordinates.",
    "Primitive %s. Feedback type %s. glRenderMode() did not return correct feedback buffer content size.",
    "Primitive %s. Feedback type %s. Could not match feedback token.",
    "Primitive %s. Feedback type %s. Could not match feedback polygon vertex count.",
    "Primitive %s. Feedback type %s. Could not match feedback passthrough token."
};

static GLfloat vt[][8] = {
    {
	WINDSIZEX/4.0, WINDSIZEY/4.0, 15.0, 1.0,
	1.0, 0.0, 0.0, 1.0
    },
    {
	WINDSIZEX/2.0, WINDSIZEY*3.0/4.0, 15.0, 1.0,
	0.0, 1.0, 0.0, 1.0
    },
    {
	WINDSIZEX*3.0/4.0, WINDSIZEY/4.0, 15.0, 1.0,
	0.0, 0.0, 1.0, 1.0
    }
};


static long GetDataSize(long type)
{
    long total=0;

    switch (type) {
      case GL_2D:
	  total = 2;
	  break;
      case GL_3D:
	  total = 3;
	  break;
      case GL_3D_COLOR:
	  if (buffer.colorMode == GL_RGB) {
	      total = 3 + 4;
	  } else {
	      total = 3 + 1;
	  }
	  break;
      case GL_3D_COLOR_TEXTURE:
	  if (buffer.colorMode == GL_RGB) {
	      total = 3 + 4 + 4;
	  } else {
	      total = 3 + 1 + 4;
	  }
	  break;
      case GL_4D_COLOR_TEXTURE:
	  if (buffer.colorMode == GL_RGB) {
	      total = 4 + 4 + 4;
	  } else {
	      total = 4 + 1 + 4;
	  }
	  break;
    }
    return total;
}

static long TestData(long type, GLfloat *buf)
{
    long i;
    GLfloat z, zError, coordError;

    z = 0.5;
    zError = 0.001 * z;
    /*
    ** Implementations which only have 2^-1 error in feedback coords
    ** will not increase the amount of tolerance which ISV's will
    ** have to build into their programs to account for sub-pixel
    ** positioning.
    */
    coordError = 1.0 / 128.0; 

    switch (type) {
      case GL_2D:
	for (i = 0; i < 3; i++) {
	    if (ABS(buf[0]-vt[i][0]) < coordError &&
		ABS(buf[1]-vt[i][1]) < coordError) {
		return NO_ERROR;
	    }
	}
	StrMake(errStr, errStrFmt[0], errPrim, errType);
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
      case GL_3D:
	for (i = 0; i < 3; i++) {
	    if (ABS(buf[0]-vt[i][0]) < coordError &&
		ABS(buf[1]-vt[i][1]) < coordError &&
		ABS(buf[2]-z) < zError) {
		return NO_ERROR;
	    }
	}
	StrMake(errStr, errStrFmt[0], errPrim, errType);
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
      case GL_3D_COLOR:
	for (i = 0; i < 3; i++) {
	    if (ABS(buf[0]-vt[i][0]) < coordError &&
		ABS(buf[1]-vt[i][1]) < coordError &&
		ABS(buf[2]-z) < zError) {
		if (buffer.colorMode == GL_RGB) {
		    if (ABS(buf[3]-colorMap[GREEN][0]) > epsilon.color[0] ||
			ABS(buf[4]-colorMap[GREEN][1]) > epsilon.color[1] ||
			ABS(buf[5]-colorMap[GREEN][2]) > epsilon.color[2] ||
			ABS(buf[6]-colorMap[GREEN][3]) > epsilon.color[3]) {
			StrMake(errStr, errStrFmt[1], errPrim, errType);
			ErrorReport(__FILE__, __LINE__, errStr);
			return ERROR;
		    } else {
			return NO_ERROR;
		    }
		} else {
		    if (ABS(buf[3]-GREEN) > epsilon.ci) {
			StrMake(errStr, errStrFmt[1], errPrim, errType);
			ErrorReport(__FILE__, __LINE__, errStr);
			return ERROR;
		    } else {
			return NO_ERROR;
		    }
		}
	    }
	}
	StrMake(errStr, errStrFmt[0], errPrim, errType);
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
      case GL_3D_COLOR_TEXTURE:
	for (i = 0; i < 3; i++) {
	    if (ABS(buf[0]-vt[i][0]) < coordError &&
		ABS(buf[1]-vt[i][1]) < coordError &&
		ABS(buf[2]-z) < zError) {
		if (buffer.colorMode == GL_RGB) {
		    if (ABS(buf[3]-colorMap[GREEN][0]) > epsilon.color[0] ||
			ABS(buf[4]-colorMap[GREEN][1]) > epsilon.color[1] ||
			ABS(buf[5]-colorMap[GREEN][2]) > epsilon.color[2] ||
			ABS(buf[6]-colorMap[GREEN][3]) > epsilon.color[3]) {
			StrMake(errStr, errStrFmt[1], errPrim, errType);
			ErrorReport(__FILE__, __LINE__, errStr);
			return ERROR;
		    } else {
			if (ABS(buf[7]-vt[i][4]) > epsilon.zero ||
			    ABS(buf[8]-vt[i][5]) > epsilon.zero ||
			    ABS(buf[9]-vt[i][6]) > epsilon.zero ||
			    ABS(buf[10]-vt[i][7]) > epsilon.zero) {
			    StrMake(errStr, errStrFmt[2], errPrim, errType);
			    ErrorReport(__FILE__, __LINE__, errStr);
			    return ERROR;
			} else {
			    return NO_ERROR;
			}
		    }
		} else {
		    if (ABS(buf[3]-GREEN) > epsilon.ci) {
			StrMake(errStr, errStrFmt[1], errPrim, errType);
			ErrorReport(__FILE__, __LINE__, errStr);
			return ERROR;
		    } else {
			if (ABS(buf[4]-vt[i][4]) > epsilon.zero ||
			    ABS(buf[5]-vt[i][5]) > epsilon.zero ||
			    ABS(buf[6]-vt[i][6]) > epsilon.zero ||
			    ABS(buf[7]-vt[i][7]) > epsilon.zero) {
			    StrMake(errStr, errStrFmt[2], errPrim, errType);
			    ErrorReport(__FILE__, __LINE__, errStr);
			    return ERROR;
			} else {
			    return NO_ERROR;
			}
		    }
		}
	    }
	}
	StrMake(errStr, errStrFmt[0], errPrim, errType);
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
      case GL_4D_COLOR_TEXTURE:
	for (i = 0; i < 3; i++) {
	    if (ABS(buf[0]-vt[i][0]) < coordError &&
		ABS(buf[1]-vt[i][1]) < coordError &&
		ABS(buf[2]-z) < zError &&
		ABS(buf[3]-vt[i][3]) < epsilon.zero) {
		if (buffer.colorMode == GL_RGB) {
		    if (ABS(buf[4]-colorMap[GREEN][0]) > epsilon.color[0] ||
			ABS(buf[5]-colorMap[GREEN][1]) > epsilon.color[1] ||
			ABS(buf[6]-colorMap[GREEN][2]) > epsilon.color[2] ||
			ABS(buf[7]-colorMap[GREEN][3]) > epsilon.color[3]) {
			StrMake(errStr, errStrFmt[1], errPrim, errType);
			ErrorReport(__FILE__, __LINE__, errStr);
			return ERROR;
		    } else {
			if (ABS(buf[8]-vt[i][4]) > epsilon.zero ||
			    ABS(buf[9]-vt[i][5]) > epsilon.zero ||
			    ABS(buf[10]-vt[i][6]) > epsilon.zero ||
			    ABS(buf[11]-vt[i][7]) > epsilon.zero) {
			    StrMake(errStr, errStrFmt[2], errPrim, errType);
			    ErrorReport(__FILE__, __LINE__, errStr);
			    return ERROR;
			} else {
			    return NO_ERROR;
			}
		    }
		} else {
		    if (ABS(buf[4]-GREEN) > epsilon.ci) {
			StrMake(errStr, errStrFmt[1], errPrim, errType);
			ErrorReport(__FILE__, __LINE__, errStr);
			return ERROR;
		    } else {
			if (ABS(buf[5]-vt[i][4]) > epsilon.zero ||
			    ABS(buf[6]-vt[i][5]) > epsilon.zero ||
			    ABS(buf[7]-vt[i][6]) > epsilon.zero ||
			    ABS(buf[8]-vt[i][7]) > epsilon.zero) {
			    StrMake(errStr, errStrFmt[2], errPrim, errType);
			    ErrorReport(__FILE__, __LINE__, errStr);
			    return ERROR;
			} else {
			    return NO_ERROR;
			}
		    }
		}
	    }
	}
	StrMake(errStr, errStrFmt[0], errPrim, errType);
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }
    ErrorReport(__FILE__, __LINE__, 0);
    return ERROR;
}

/******************************************************************************/

static void PointRender(void)
{

    GetEnumName(GL_POINTS, errPrim);
    glBegin(GL_POINTS);
	glTexCoord4fv(&vt[0][4]);
	glVertex4fv(vt[0]);
    glEnd();
}

static long PointTest(long type, long count, GLfloat *buf)
{
    long total;

    total = GetDataSize(type);
    if (count != 1+total) {
	StrMake(errStr, errStrFmt[3], errPrim, errType);
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }
    if (*buf++ != GL_POINT_TOKEN) {
	StrMake(errStr, errStrFmt[4], errPrim, errType);
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }
    if (TestData(type, buf) == ERROR) {
	return ERROR;
    }
    return NO_ERROR;
}

/******************************************************************************/

static void LineRender(void)
{

    GetEnumName(GL_LINES, errPrim);
    glBegin(GL_LINES);
	glTexCoord4fv(&vt[0][4]);
	glVertex4fv(vt[0]);
	glTexCoord4fv(&vt[1][4]);
	glVertex4fv(vt[1]);
    glEnd();
}

static void LineStripRender(void)
{

    GetEnumName(GL_LINE_STRIP, errPrim);
    glBegin(GL_LINE_STRIP);
	glTexCoord4fv(&vt[0][4]);
	glVertex4fv(vt[0]);
	glTexCoord4fv(&vt[1][4]);
	glVertex4fv(vt[1]);
    glEnd();
}

static void LineLoopRender(void)
{

    GetEnumName(GL_LINE_LOOP, errPrim);
    glBegin(GL_LINE_LOOP);
	glTexCoord4fv(&vt[0][4]);
	glVertex4fv(vt[0]);
	glTexCoord4fv(&vt[1][4]);
	glVertex4fv(vt[1]);
    glEnd();
}

static long LineTest(long type, long count, GLfloat *buf)
{
    long total;

    total = GetDataSize(type);
    if (count != 1+total*2) {
	StrMake(errStr, errStrFmt[3], errPrim, errType);
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }
    if (*buf != GL_LINE_TOKEN && *buf != GL_LINE_RESET_TOKEN) {
	StrMake(errStr, errStrFmt[4], errPrim, errType);
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }
    buf++;
    if (TestData(type, buf) == ERROR) {
	return ERROR;
    }
    buf += total;
    if (TestData(type, buf) == ERROR) {
	return ERROR;
    }
    return NO_ERROR;
}

static long LineLoopTest(long type, long count, GLfloat *buf)
{
    long total, i;

    total = GetDataSize(type);
    if (count != (1+total*2)*2) {
	StrMake(errStr, errStrFmt[3], errPrim, errType);
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }
    for (i = 0; i < 2; i++) {
	if (*buf != GL_LINE_TOKEN && *buf != GL_LINE_RESET_TOKEN) {
	    StrMake(errStr, errStrFmt[4], errPrim, errType);
	    ErrorReport(__FILE__, __LINE__, errStr);
	    return ERROR;
	}
	buf++;
	if (TestData(type, buf) == ERROR) {
	    return ERROR;
	}
	buf += total;
	if (TestData(type, buf) == ERROR) {
	    return ERROR;
	}
	buf += total;
    }
    return NO_ERROR;
}

/******************************************************************************/

static void TriRender(void)
{

    GetEnumName(GL_TRIANGLES, errPrim);
    glBegin(GL_TRIANGLES);
	glTexCoord4fv(&vt[0][4]);
	glVertex4fv(vt[0]);
	glTexCoord4fv(&vt[1][4]);
	glVertex4fv(vt[1]);
	glTexCoord4fv(&vt[2][4]);
	glVertex4fv(vt[2]);
    glEnd();
}

static void TriStripRender(void)
{

    GetEnumName(GL_TRIANGLE_STRIP, errPrim);
    glBegin(GL_TRIANGLE_STRIP);
	glTexCoord4fv(&vt[0][4]);
	glVertex4fv(vt[0]);
	glTexCoord4fv(&vt[1][4]);
	glVertex4fv(vt[1]);
	glTexCoord4fv(&vt[2][4]);
	glVertex4fv(vt[2]);
    glEnd();
}

static void TriFanRender(void)
{

    GetEnumName(GL_TRIANGLE_FAN, errPrim);
    glBegin(GL_TRIANGLE_FAN);
	glTexCoord4fv(&vt[0][4]);
	glVertex4fv(vt[0]);
	glTexCoord4fv(&vt[1][4]);
	glVertex4fv(vt[1]);
	glTexCoord4fv(&vt[2][4]);
	glVertex4fv(vt[2]);
    glEnd();
}

static void PolyPointRender(void)
{

    STRCOPY(errPrim, "Polygons (point mode)");
    glPolygonMode(GL_FRONT_AND_BACK, GL_POINT);
    glBegin(GL_POLYGON);
	glTexCoord4fv(&vt[0][4]);
	glVertex4fv(vt[0]);
	glTexCoord4fv(&vt[1][4]);
	glVertex4fv(vt[1]);
	glTexCoord4fv(&vt[2][4]);
	glVertex4fv(vt[2]);
    glEnd();
}

static void PolyLineRender(void)
{

    STRCOPY(errPrim, "Polygons (line mode)");
    glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
    glBegin(GL_POLYGON);
	glTexCoord4fv(&vt[0][4]);
	glVertex4fv(vt[0]);
	glTexCoord4fv(&vt[1][4]);
	glVertex4fv(vt[1]);
	glTexCoord4fv(&vt[2][4]);
	glVertex4fv(vt[2]);
    glEnd();
}

static void PolyFillRender(void)
{

    STRCOPY(errPrim, "Polygons (fill mode)");
    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
    glBegin(GL_POLYGON);
	glTexCoord4fv(&vt[0][4]);
	glVertex4fv(vt[0]);
	glTexCoord4fv(&vt[1][4]);
	glVertex4fv(vt[1]);
	glTexCoord4fv(&vt[2][4]);
	glVertex4fv(vt[2]);
    glEnd();
}

static long PolyTest(long type, long count, GLfloat *buf)
{
    long total;

    total = GetDataSize(type);
    if (count != 1+1+total*3) {
	StrMake(errStr, errStrFmt[3], errPrim, errType);
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }
    if (*buf++ != GL_POLYGON_TOKEN) {
	StrMake(errStr, errStrFmt[4], errPrim, errType);
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }
    if (*buf++ != 3) {
	StrMake(errStr, errStrFmt[5], errPrim, errType);
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }
    if (TestData(type, buf) == ERROR) {
	return ERROR;
    }
    buf += total;
    if (TestData(type, buf) == ERROR) {
	return ERROR;
    }
    buf += total;
    if (TestData(type, buf) == ERROR) {
	return ERROR;
    }
    return NO_ERROR;
}

static long PolyPointTest(long type, long count, GLfloat *buf)
{
    long total, i;

    total = GetDataSize(type);
    if (count != (1+total)*3) {
	StrMake(errStr, errStrFmt[3], errPrim, errType);
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }
    for (i = 0; i < 3; i++) {
	if (*buf++ != GL_POINT_TOKEN) {
	    StrMake(errStr, errStrFmt[4], errPrim, errType);
	    ErrorReport(__FILE__, __LINE__, errStr);
	    return ERROR;
	}
	if (TestData(type, buf) == ERROR) {
	    return ERROR;
	}
	buf += total;
    }
    return NO_ERROR;
}

static long PolyLineTest(long type, long count, GLfloat *buf)
{
    long total, i;

    total = GetDataSize(type);
    if (count != (1+total*2)*3) {
	StrMake(errStr, errStrFmt[3], errPrim, errType);
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }
    for (i = 0; i < 3; i++) {
	if (*buf != GL_LINE_TOKEN && *buf != GL_LINE_RESET_TOKEN) {
	    StrMake(errStr, errStrFmt[4], errPrim, errType);
	    ErrorReport(__FILE__, __LINE__, errStr);
	    return ERROR;
	}
	buf++;
	if (TestData(type, buf) == ERROR) {
	    return ERROR;
	}
	buf += total;
	if (TestData(type, buf) == ERROR) {
	    return ERROR;
	}
	buf += total;
    }
    return NO_ERROR;
}

/******************************************************************************/

static void BitmapRender(void)
{
    GLubyte *map;
    long i;

    STRCOPY(errPrim, "Bitmap");
    map = (GLubyte *)MALLOC(32*32*sizeof(GLubyte));
    for (i = 0; i < 32*32; i++) {
	map[i] = (GLubyte)Random(0.0, 255.0);
    }
    glTexCoord4fv(&vt[0][4]);
    glRasterPos4fv(vt[0]);
    glBitmap(32, 32, 0, 0, 0, 0, map);
    FREE(map);
}

static long BitmapTest(long type, long count, GLfloat *buf)
{
    long total;

    total = GetDataSize(type);
    if (count != 1+total) {
	StrMake(errStr, errStrFmt[3], errPrim, errType);
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }
    if (*buf++ != GL_BITMAP_TOKEN) {
	StrMake(errStr, errStrFmt[4], errPrim, errType);
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }
    if (TestData(type, buf) == ERROR) {
	return ERROR;
    }
    return NO_ERROR;
}

/******************************************************************************/

static void CopyPixelsRender(void)
{

    STRCOPY(errPrim, "CopyPixels()");
    glTexCoord4fv(&vt[0][4]);
    glRasterPos4fv(vt[0]);
    glCopyPixels((GLint)vt[1][0], (GLint)vt[1][1], 10, 10, GL_COLOR);
}

static long CopyPixelsTest(long type, long count, GLfloat *buf)
{
    long total;

    total = GetDataSize(type);
    if (count != 1+total) {
	StrMake(errStr, errStrFmt[3], errPrim, errType);
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }
    if (*buf++ != GL_COPY_PIXEL_TOKEN) {
	StrMake(errStr, errStrFmt[4], errPrim, errType);
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }
    if (TestData(type, buf) == ERROR) {
	return ERROR;
    }
    return NO_ERROR;
}

/******************************************************************************/

static void DrawPixelsRender(void)
{
    GLfloat *buf;
    long i;

    STRCOPY(errPrim, "DrawPixels()");
    buf = (GLfloat *)MALLOC(10*10*3*sizeof(GLfloat));
    for (i = 0; i < 10*10*3; i++) {
	buf[i] = Random(0.0, 1.0);
    }
    glTexCoord4fv(&vt[0][4]);
    glRasterPos4fv(vt[0]);
    if (buffer.colorMode == GL_RGB) {
	glDrawPixels(10, 10, GL_RGB, GL_FLOAT, buf);
    } else {
	glDrawPixels(10, 10, GL_COLOR_INDEX, GL_FLOAT, buf);
    }
    FREE(buf);
}

static long DrawPixelsTest(long type, long count, GLfloat *buf)
{
    long total;

    total = GetDataSize(type);
    if (count != 1+total) {
	StrMake(errStr, errStrFmt[3], errPrim, errType);
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }
    if (*buf++ != GL_DRAW_PIXEL_TOKEN) {
	StrMake(errStr, errStrFmt[4], errPrim, errType);
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }
    if (TestData(type, buf) == ERROR) {
	return ERROR;
    }
    return NO_ERROR;
}

/******************************************************************************/

static void PassThroughRender(void)
{

    STRCOPY(errPrim, "PassThrough()");
    glPassThrough(99.0);
}

static long PassThroughTest(long type, long count, GLfloat *buf)
{

    if (count != 1+1) {
	StrMake(errStr, errStrFmt[3], errPrim, errType);
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }
    if (*buf++ != GL_PASS_THROUGH_TOKEN) {
	StrMake(errStr, errStrFmt[4], errPrim, errType);
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }
    if (*buf++ != 99.0) {
	StrMake(errStr, errStrFmt[6], errPrim, errType);
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }
    return NO_ERROR;
}

/******************************************************************************/

static long Test(void (*Render)(void), long (*Tester)(long, long, GLfloat *),
		 GLfloat *buf)
{
    static GLenum type[] = {
	GL_2D, GL_3D, GL_3D_COLOR, GL_3D_COLOR_TEXTURE, GL_4D_COLOR_TEXTURE
    };
    long i, j, total;

    //
    // 27-Oct-1994
    //
    for (i = 0; i < 5; i++) {
	GetEnumName(type[i], errType);
        total = GetDataSize(type[i]);
        if (Render == PassThroughRender) {
            total = 2;
        }

        //
        // specifying a size which is smaller than actual
        //
        glFeedbackBuffer(total-1, type[i], buf);

	j = glRenderMode(GL_FEEDBACK);
	(*Render)();
	j = glRenderMode(GL_RENDER);

        //
        // The feedback data should require more room, thus we expect
        // it to return a negative value.
        //
        if (j >= 0) {
            StrMake(errStr,
            "Primitive %s. Feedback type %s. Ret val = %d. Expected -ve Size returned.",
            errPrim, errType, j);
            ErrorReport(__FILE__, __LINE__, errStr);
            return ERROR;
        }
    }

    for (i = 0; i < 5; i++) {
	GetEnumName(type[i], errType);

	glFeedbackBuffer(1000, type[i], buf);

	j = glRenderMode(GL_FEEDBACK);
	(*Render)();
	j = glRenderMode(GL_RENDER);

	if ((*Tester)(type[i], j, buf) == ERROR) {
	    return ERROR;
	}
    }

    return NO_ERROR;
}

long FeedbackExec(void)
{
    GLfloat *buf;

    buf = (GLfloat *)MALLOC(1000*sizeof(GLfloat));

    Ortho3D(0, WINDSIZEX, 0, WINDSIZEY, -10, -20);
    SETCOLOR(GREEN);

    if (Test(PointRender, PointTest, buf) == ERROR) {
	FREE(buf);
	return ERROR;
    }
    if (Test(LineRender, LineTest, buf) == ERROR) {
	FREE(buf);
	return ERROR;
    }
    if (Test(LineStripRender, LineTest, buf) == ERROR) {
	FREE(buf);
	return ERROR;
    }
    if (Test(LineLoopRender, LineLoopTest, buf) == ERROR) {
	FREE(buf);
	return ERROR;
    }
    if (Test(TriRender, PolyTest, buf) == ERROR) {
	FREE(buf);
	return ERROR;
    }
    if (Test(TriStripRender, PolyTest, buf) == ERROR) {
	FREE(buf);
	return ERROR;
    }
    if (Test(TriFanRender, PolyTest, buf) == ERROR) {
	FREE(buf);
	return ERROR;
    }
    if (Test(PolyPointRender, PolyPointTest, buf) == ERROR) {
	FREE(buf);
	return ERROR;
    }
    if (Test(PolyLineRender, PolyLineTest, buf) == ERROR) {
	FREE(buf);
	return ERROR;
    }
    if (Test(PolyFillRender, PolyTest, buf) == ERROR) {
	FREE(buf);
	return ERROR;
    }
    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
    if (Test(BitmapRender, BitmapTest, buf) == ERROR) {
	glPixelStorei(GL_UNPACK_ALIGNMENT, 4);
	FREE(buf);
	return ERROR;
    }
    glPixelStorei(GL_UNPACK_ALIGNMENT, 4);
    if (Test(CopyPixelsRender, CopyPixelsTest, buf) == ERROR) {
	FREE(buf);
	return ERROR;
    }
    if (Test(DrawPixelsRender, DrawPixelsTest, buf) == ERROR) {
	FREE(buf);
	return ERROR;
    }

    if (Test(PassThroughRender, PassThroughTest, buf) == ERROR) {
	FREE(buf);
	return ERROR;
    }

    FREE(buf);
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\evalv.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** evalv.c
** Evaluator Vertex Test.
**
** Description -
**    A 3d x 8d polynomial evaluator surface is set-up using the
**    control values in the array point2f below. Cross-sections
**    through the surface are rendered at carefully chosen grid
**    points using glEvalCoords() or glMapMesh(). Single pixel
**    points are used to render the sections as their shape is
**    more well defined than other primitives. The u, v
**    coordinates chosen yield x values exactly on pixel centers.
**    This is possible since the evaluator is linear in x. For
**    each column, the height, y coordinate, is compared to an
**    internally calculated floating point number scaled and
**    biased to correspond to screen coordinates. If the the
**    fragment rendered is more than 2 pixels lower or higher
**    than the ideal point the implementation fails.
**
** Error Explanation -
**    Failure occurs if the point rendered is two pixels higher
**    or lower than the internally calculated result or if a
**    column renders with no pixels in it.
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer.
**    Color requirements:
**        One color channel which is at least 2 bits deep is required. Or a 
**        2 bit color index.
**    States requirements:
**        Disabled = GL_DITHER.
**        Enabled = GL_MAP2_VERTEX_4.
**        Non-default control points and orders of Bernstein polynomials.
**    Error epsilon:
**        Points which differ by more than 2 pixels are judged incorrect
**        This would occur if the point at which a polynomial is evaluated
**        is off by more than a half a pixel given the slope of this surface
**        (or if the polynomial is evaluated badly).
**    Paths:
**        Allowed = Alpha, Blend, Depth, Fog, Logicop, Shade, Stencil, Stipple.
**        Not allowed = Alias, Dither.
*/


#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"
#include "utile.h"


#define VMAJOR_ORDER 3
#define VMINOR_ORDER 8
#define VDIM 4
#define EVAL 3
#define MESH 4
#define FRAG_ERROR 2.0


static float point2f[VMAJOR_ORDER*VMINOR_ORDER*VDIM] = {
    -1.0,       0.0,  0.99, 1.0,
    -0.714285,  3.0,  0.99, 1.0,
    -0.428571, -2.0,  0.99, 1.0,
    -0.142857,  1.0,  0.99, 1.0,
     0.142857, -1.0,  0.99, 1.0,
     0.428571,  2.0,  0.99, 1.0,
     0.714285, -3.0,  0.99, 1.0,
     1.0,       0.0,  0.99, 1.0,
    -1.0,       0.0,  0.0, 1.0,
    -0.714285, -3.0,  0.0, 1.0,
    -0.428571,  2.0,  0.0, 1.0,
    -0.142857, -1.0,  0.0, 1.0,
     0.142857,  1.0,  0.0, 1.0,
     0.428571, -2.0,  0.0, 1.0,
     0.714285,  3.0,  0.0, 1.0,
     1.0,       0.0,  0.0, 1.0,
    -1.0,       0.0, -0.99, 1.0,
    -0.714285,  3.0, -0.99, 1.0,
    -0.428571, -2.0, -0.99, 1.0,
    -0.142857,  1.0, -0.99, 1.0,
     0.142857, -1.0, -0.99, 1.0,
     0.428571,  2.0, -0.99, 1.0,
     0.714285, -3.0, -0.99, 1.0,
     1.0,       0.0, -0.99, 1.0
};
static char errStr[400];
static char errStrFmt[][320] = {
    "Evaluator GL_MAP2_VERTEX_4. The height of the observed pixel is too far from the expected height or it is not rendered. For u = %g v = %g the expected result is %g. In screen coordinates this would be %g. The pixel height observed is %g for pixel column is %d."
};


static void InitMap2(eval2Rec *e2)
{

    glMap2f(e2->dataTypeEnum, 0.0, 1.0, (e2->minorOrder)*(e2->dim), 
	    e2->majorOrder, 0.0, 1.0, e2->dim, 
	    e2->minorOrder, e2->controls);
    glMapGrid2d(100, 0.0, 1.0, 99, 0.005, 0.995);
    glEnable(e2->dataTypeEnum);
}

static void DrawMapEval0(long mapType, float u, long p1) 
{
    float v, vStart, dv = 0.01;
    long i; 

    switch (mapType) {
      case EVAL:
	glBegin(GL_POINTS);
	    vStart = 0.005;
	    for (i = 0; i < 100; i++) {
		v = vStart + i * dv;
		glEvalCoord2d(u, v);
	    }
	glEnd();
	glFlush();
	break;
      case MESH:
	glEvalMesh2(GL_POINT, (GLint)p1, (GLint)p1, 0, 99);
	glFlush();
	break;
    }
}

static void GetDrawnPixel(float *out, GLfloat *buf, long column)
{
    long i;

    for (i = 0; i < WINDSIZEY; i++) {
	if (AutoColorCompare(buf[(i*WINDSIZEX+column)], COLOR_ON) == GL_TRUE) {
	    *out = i + 0.5;
	    break;
	}
    }
}

static long TestEvalPoint(eval2Rec *eV, GLfloat *buf)
{
    float u, v, uStart, vStart, du, dv;
    float drawn, y, e[4];
    long i, j, jIncr, type = EVAL;

    uStart = 0.0;
    vStart = 0.005;
    du = 0.01;
    dv = 0.01;
    jIncr = (machine.pathLevel == 0) ? 4 : 20;
    for (j = 0; j <= 100; j += jIncr) {
	glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
	u = uStart + j * du;
	DrawMapEval0(type, u, j);
	ReadScreen(0, 0, WINDSIZEX, WINDSIZEY, GL_AUTO_COLOR, buf);
	for (i = 0; i < 100; i++) {
	    GetDrawnPixel(&drawn, buf, i);
	    v = vStart + i * dv;
	    Evaluate2(eV, u, v, e);
	    y = (e[1] + 1.0) * 50.0;
	    if (ABS(y-drawn) > FRAG_ERROR) { 
		StrMake(errStr, errStrFmt[0], u, v, e[1], y, drawn, i);
		ErrorReport(__FILE__, __LINE__, errStr);
		return ERROR;
	    }
	}
	type = (type == EVAL) ? MESH : EVAL;
    }
    return NO_ERROR;
}

long EvalVertexExec(void)
{
    GLfloat *buf;
    long flag = NO_ERROR;
    eval2Rec *eV;

    AutoClearColor(COLOR_OFF);
    AutoColor(COLOR_ON);

    /*
    ** Until AutoColor is fixed for implementations with less than 2 bits of 
    ** color.
    */
    glDisable(GL_DITHER);

    buf = (GLfloat *)MALLOC(WINDSIZEX*WINDSIZEY*sizeof(GLfloat));
    eV = MakeEval2(VMAJOR_ORDER, VMINOR_ORDER, VDIM, GL_MAP2_VERTEX_4, point2f);
    InitMap2(eV);

    if (TestEvalPoint(eV, buf) == ERROR) {
	flag = ERROR;
    }

    ResetEvalToDefault();

    FreeEval2(eV);
    FREE(buf);

    return flag;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\fogexp.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** fogexp.c
** Fog Exponential Test.
**
** Description -
**    This file contains two tests, one for the RGB and one for
**    CI fog equations. Both the GL_FOGEXP and GL_FOGEXP2 are
**    tested in this test. This test examines the effect which
**    varying the z eye coordinate and the density, d, has on the
**    color of the point. When the density value is being tested
**    z is set to -1.0 and the third coordinate of the vertex is
**    set to a referance value, r. When z is being examined it is
**    set to -r and d is set to 1.0. In other tests involving the
**    exponential function we use huge errors. This is for
**    exponents as large as 128. In this test the exponents are
**    bounded between 0 and 1. So error bounds are tighter.
**    
**    In RGB mode the test only examines one color channel at a
**    time. First it examines the effect of the fog weighting on
**    the current color, and then it examines the effect on fog
**    color. When the current color is being examined the fog
**    color is set to black, and one channel of the current color
**    is set to 1.0. When the fog color is being examined the
**    current color is set to black, and one channel of the fog
**    color is set to 1.0. In CI mode only the fog index is
**    examined and the current index is set to 0.
**    
**    The test repeatedly renders a point in the lower left
**    corner of the window, increments r, and reads back the
**    color of the point. Since implementations could
**    conceivable use the distance of the object from the eye to
**    calculate f, the point is positioned so that it's distance
**    from the eye is equal to it's z coordinate.
**    
**    r is incremented in such a way that f, should theoretically
**    increment uniformly. The color should therefore also
**    increment uniformly, if we are testing the current color,
**    and decrement uniformly, if we are testing the fog color.
**    In the case of CI mode it will always decrement the index.
**    
**    In RGB mode the observed color of the point is examined. An
**    implementation fails if a color channel is non-zero, when
**    it should be zero, or if it is not 1.0, when it should be
**    1.0. The observed values are also examined for
**    monotonocity. An implementation fails if the results which
**    should increment or decrement monotonically fail to do so.
**    Finally an implementation will fail if the observed color
**    is more than 1.5 shades from the expected color.
**    
**    In CI mode the observed value is checked to be
**    monotonically decreasing. It is confirmed to be an integer,
**    and it is checked to reach maxIndex when the z value is
**    equal to the fogStart value. The implementation fails if
**    the observed index is more than 2 away from the
**    theoretically correct index. It will also fail if the
**    difference between two consecutive observations is larger
**    than 2 (delta > 2).
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer.
**    Color requirements:
**        RGBA or color index mode. Full color.
**    States requirements:
**        No state restrictions.
**    Error epsilon:
**       Color, ci and zero epsilon.
**    Paths:
**        Allowed = Alpha, Blend, Depth, Logicop, Stencil, Stipple.
**        Not allowed = Alias, Dither, Fog, Shade.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"
#include "utilru.h"


typedef struct _fogExpRec {
    long color;
    float step, lastValue, lastDelta;
    long useFog, useZ, isSquared;
    float numColor, dz;
} fogExpRec;


static char errStr[320];
static char errStrFmt[][240] = {
    "RGB observed = (%g, %g, %g, %g). Expected %s to be 0.0, Fog_density = %g, z = %g, model = %s, fog RGBA = (%g, %g, %g, %g), color RGBA = (%g, %g, %g, %g).",
    "Observed RGB = (%g, %g, %g, %g), %s differs too much from expected, %g. Fog density = %g, z = %g, fog model = %s, fog RGBA = (%g, %g, %g, %g), color RGBA = (%g, %g, %g, %g).",
    "Non-monotic change in %s color. Observed %s = %g, last value was %g. It should %s! Fog density = %g, z = %g, fog model = %s, fog RGBA = (%g, %g, %g, %g), color RGBA = (%g, %g, %g, %g).",
    "Expected fully saturated %s. Observed RGBA = (%g, %g, %g, %g), fog density = %g, z = %g, fog model = %s, fog RGBA = (%g, %g, %g, %g), color RGBA = (%g, %g, %g, %g).",
    "Observed color index of %g is not an integer, fog density = %g, z = %g, fog model = %s, fog index = %g.", 
    "Observed color index of %g is not monotonically decreasing, last value was %g, fog density = %g, z = %g, fog model = %s, fog index = %g.", 
    "Observed color index of %g differs by too much from the expected value of %g, fog density = %g, z = %g, fog model = %s, fog index = %g.", 
    "Observed color index of %g differs from last value of %g by more than 2.0, fog density = %g, z = %g, fog model = %s, fog index = %g.", 
    "Observed color index of %g should be fully black fog Index of 0.0, fog density = %g, z = %g, fog model = %s, fog index = %g." 
};


static char *ErrIndexToColorName(long i)
{

    switch (i) {
      case 0:
	return "RED";
      case 1:
	return "GREEN";
      case 2:
	return "BLUE";
      case 3:
	return "ALPHA";
      case 4:
	return "COLOR INDEX";
      default:
	return "UNKNOWN COLOR";
    }
}

static char *MakeErrorString(long errType, long wrongColor, GLfloat *buf,
			     fogExpRec *ptr, float ref)
{
    float fog[4], color[4];
    float d, z, lastValue; 
    char *model, *colorDirection="";

    color[0] = 0.0; color[1] = 0.0; color[2] = 0.0; color[3] = 1.0;
    fog[0]   = 0.0; fog[1]   = 0.0; fog[2]   = 0.0; fog[3]   = 1.0;
    if (ptr->useZ == GL_TRUE) {
	d = 1.0;
	z = -ptr->dz;
    } else {
	d = ptr->dz;
	z = -1.0;
    }

    model = (ptr->isSquared == GL_TRUE) ? "GL_EXP2" : "GL_EXP";
    if (buffer.colorMode == GL_RGB) {
	if (ptr->useFog == GL_TRUE) {
	    ref = 1.0 - ref;
	    lastValue = 1.0 - ptr->lastValue;
	    fog[ptr->color] = 1.0;
	    colorDirection = "decrease";
	} else { 
	    color[ptr->color] = 1.0;
	    lastValue = ptr->lastValue;
	    colorDirection = "increase";
	}
    }

    switch (errType) {
      case 0:
	StrMake(errStr, errStrFmt[errType], buf[0], buf[1], buf[2], 1.0,
		ErrIndexToColorName(wrongColor), d, z, model, color[0],
		color[1], color[2], color[3], fog[0], fog[1], fog[2], fog[3]);
	break;
      case 1:
	StrMake(errStr, errStrFmt[errType], buf[0], buf[1], buf[2], 1.0,
		ErrIndexToColorName(wrongColor), ref, d, z, model, color[0],
		color[1], color[2], color[3], fog[0], fog[1], fog[2], fog[3]);
	break;
      case 2:
	StrMake(errStr, errStrFmt[2], ErrIndexToColorName(wrongColor),
		ErrIndexToColorName(wrongColor), buf[ptr->color],
		ptr->lastValue, colorDirection, d, z, model, color[0],
		color[1], color[2], color[3], fog[0], fog[1], fog[2], fog[3]);
	break;
      case 3:
        StrMake(errStr, errStrFmt[3], ErrIndexToColorName(wrongColor), buf[0],
		buf[1], buf[2], 1.0, d, z, model, color[0], color[1], color[2],
		color[3], fog[0], fog[1], fog[2], fog[3]);
	break;

      /*
      ** CI Tests.
      */
      case 4:
        StrMake(errStr, errStrFmt[4], ptr->numColor-buf[0], d, z, model,
		ptr->numColor);
	break;
      case 5:
        StrMake(errStr, errStrFmt[5], ptr->numColor-buf[0],
		ptr->numColor-ptr->lastValue, d, z, model, ptr->numColor);
	break;
      case 6:
        StrMake(errStr, errStrFmt[6], ptr->numColor-buf[0], ptr->numColor-ref,
		d, z, model, ptr->numColor);
	break;
      case 7:
        StrMake(errStr, errStrFmt[7], ptr->numColor-buf[0], 
	    ptr->numColor-ptr->lastValue, d, z, model, ptr->numColor);
	break;
      case 8:
        StrMake(errStr, errStrFmt[8], ptr->numColor-buf[0], d, z, model, 
	    ptr->numColor);
	break;
    }
    return errStr;
}

/*****************************************************************************/

static void Set(void *data, float *ref)
{
    static float one = 1.0, minusOne = -1.0;
    fogExpRec *ptr = (fogExpRec *)data;

    ptr->dz = -LOG(*ref);
    if (ptr->isSquared == GL_TRUE) {
	ptr->dz = SQRT(ptr->dz);
    }

    /*
    ** z value and distance in eye space are the same.
    */
    if (ptr->useZ == GL_TRUE) {
	glFogf(GL_FOG_DENSITY, one);
	glBegin(GL_POINTS);
	    glVertex3f(0.0, 0.0, -ptr->dz);
	glEnd();
    } else {
	glFogf(GL_FOG_DENSITY, ptr->dz);
	glBegin(GL_POINTS);
	    glVertex3f(0.0, 0.0, minusOne);
	glEnd();
    }

    *ref += ptr->step;
}

/*****************************************************************************/

static void InitRGB(void *data)
{
    fogExpRec *ptr = (fogExpRec *)data;
    GLfloat buf[4];
    float tmp;

    ptr->lastValue = -1.0;
    ptr->lastDelta = -2.0;

    if (machine.pathLevel == 0) {
	ptr->step = 0.5 / ptr->numColor;
    } else {
	ptr->step = 0.25;
    }

    /*
    ** If there were 16 bits of color, log() may be unstable enough 
    ** near zero to cause this test to be inaccurate.
    */
    tmp = LOG(ptr->step);
    if (ptr->isSquared == GL_TRUE) {
	tmp = SQRT(-tmp);
	tmp = -tmp * tmp;
    }
    if (ABS(ptr->step-EXP(tmp)) > epsilon.zero) {
	ptr->step = 1.0 / 8096.0;
    }

    /*
    ** Both the fog and the current color must have alpha = 1.0;
    */
    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = 0.0;
    buf[3] = 1.0;
    (ptr->useFog == GL_TRUE) ? glColor4fv(buf) : glFogfv(GL_FOG_COLOR, buf);

    buf[ptr->color] = 1.0;
    (ptr->useFog == GL_TRUE) ? glFogfv(GL_FOG_COLOR, buf) : glColor4fv(buf);

    buf[0] = (ptr->isSquared == GL_TRUE) ? GL_EXP2 : GL_EXP;
    glFogfv(GL_FOG_MODE, buf);
}

static long TestRGB(void *data, float ref)
{
    fogExpRec *ptr = (fogExpRec *)data;
    float value, delta;
    GLfloat buf[3];
    long i;

    ReadScreen(0, 0, 1, 1, GL_RGB, buf);

    for (i = 0; i < 3; i++) {
	if (buf[i] != 0.0 && i != ptr->color) {
	    MakeErrorString(0, i, buf, ptr, ref);
            ErrorReport(__FILE__, __LINE__, errStr);
	    return ERROR;
	}
    }

    value = buf[ptr->color];
    if (ptr->useFog == GL_TRUE) {
	value = 1.0 - value;
    }

    /*
    ** Exponentials are far more stable for values less than 0.0,
    ** so we do not allow as large an error as we do for lighting.
    */
    if (ABS(value-ref) > 1.5*epsilon.color[ptr->color]) {
	MakeErrorString(1, ptr->color, buf, ptr, ref);
        ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }

    /*
    ** The linearity test is disabled, but due to variable sample spacing,
    ** delta should be approximately constant.
    */
    if (ptr->lastDelta == -2.0) {
	ptr->lastDelta = -1.0;
	ptr->lastValue = value;
    } else if (ptr->lastDelta == -1.0) {
	if (value < ptr->lastValue) {
	    MakeErrorString(2, ptr->color, buf, ptr, ref); 
	    ErrorReport(__FILE__, __LINE__, errStr);
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	/*
	** This is only left here for people who want to
	** use it to debug.
	*/
	if (ABS(delta) > epsilon.zero) {
	    ptr->lastDelta = delta;
	}
    } else {
	if (value < ptr->lastValue) {
	    MakeErrorString(2, ptr->color, buf, ptr, ref);
            ErrorReport(__FILE__, __LINE__, errStr);
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	/*
	** This is only left here for people who want to
	** use it to debug.
	*/
	if (ABS(delta) > epsilon.zero) {
	    ptr->lastDelta = delta;
	}
    }
    if (ref >= 1.0 && ABS(value-1.0) > epsilon.zero) {
	MakeErrorString(3, ptr->color, buf, ptr, ref);
        ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }
    return NO_ERROR;
}

long FogExpRGBExec(void)
{
    fogExpRec data;
    float start;
    GLfloat m[4][4];

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    /*
    ** Since the eye coordinates are used to calculate the distance or zfog
    ** value, we have to do a little transformation hocus-pocus to allow for
    ** a large homogeneous clip coordinate and to allow z and distance to be
    ** equal in eye coordinates. 10.0 is chosen as it is bigger than ln(8196)
    ** which is likely to be the largest number of shades of any one color.
    */

    glMatrixMode(GL_PROJECTION);
    glTranslatef(0.5, 0.5, 0.0);
    MakeIdentMatrix(&m[0][0]);
    m[0][0] = 10.0;
    m[1][1] = 10.0;
    m[2][2] =  1.0;
    m[3][3] = 10.0;
    glMultMatrixf(&m[0][0]);
    glMatrixMode(GL_MODELVIEW);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glDisable(GL_DITHER);
    glEnable(GL_FOG);

    for (data.useZ = GL_FALSE; data.useZ <= GL_TRUE; data.useZ++) {
	for (data.isSquared = GL_FALSE; data.isSquared <= GL_TRUE;
	     data.isSquared++) {
	    for (data.useFog = GL_FALSE; data.useFog <= GL_TRUE;
		 data.useFog++) {
		for (data.color = 0; data.color < 3; data.color++) {
		    data.numColor = POW(2.0, (float)buffer.colorBits[data.color]) - 1.0;
		    start = 0.5 / data.numColor;
		    if (RampUtil(start, 1.0, InitRGB, Set, TestRGB,
			         &data) == ERROR) {
			return ERROR;
		    }
		}
	    }
	}
    }
    return NO_ERROR;
}

/******************************************************************************/

static void InitCI(void *data)
{
    fogExpRec *ptr = (fogExpRec *)data;
    GLfloat buf[1];

    ptr->lastValue = -1.0;
    ptr->lastDelta = -2.0;

    /*
    ** This should work for a 16 bit color Index. If anybody has a larger map
    ** this could need tuning.
    */
    if (machine.pathLevel == 0) {
	ptr->step = 0.5 / ptr->numColor;
    } else {
	ptr->step = 0.25;
    }

    buf[0] = ptr->numColor;
    glFogfv(GL_FOG_INDEX, buf);

    glIndexf(0.0);

    buf[0] = (ptr->isSquared == GL_TRUE) ? GL_EXP2 : GL_EXP;
    glFogfv(GL_FOG_MODE, buf);
}

/*
** In Color Index mode we check the following:
** 1) Is the value an integer?
** 2) Is the ramp monotonic?
** 3) Does it round correctly?
** 4) Does it skip any possible indices?
** 5) Does it ever reach the top index?
*/
static long TestCI(void *data, float ref)
{
    fogExpRec *ptr = (fogExpRec *)data;
    float expected=0.0f, value, frac, delta;
    GLfloat buf;

    ReadScreen(0, 0, 1, 1, GL_COLOR_INDEX, &buf);
    value = buf;

    value = ptr->numColor - value;
    frac = ABS(value-(float)((long)value));
    if (frac > epsilon.zero && ABS(frac-1.0) > epsilon.zero) {
	MakeErrorString(4, 4, &buf, ptr, ref);
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }

    if (ptr->lastValue == -1.0) {
	ptr->lastValue = value;
    } else {
	if (value < ptr->lastValue) {
	    MakeErrorString(5, 4, &buf, ptr, ref);
	    ErrorReport(__FILE__, __LINE__, errStr);
	    return ERROR;
	}
	expected = (float)Round(2.0*ref*ptr->numColor) / 2.0;
	if (ABS(value-expected) > 2.0*epsilon.ci+epsilon.zero) {
	    MakeErrorString(6, 4, &buf, ptr, expected);
	    ErrorReport(__FILE__, __LINE__, errStr);
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	if (ABS(delta) > epsilon.zero) {
	    if ((ABS(delta) >= 2.0) && (machine.pathLevel == 0)) {
		MakeErrorString(7, 4, &buf, ptr, expected);
		ErrorReport(__FILE__, __LINE__, errStr);
		return ERROR;
	    }
	}
    }

    if (ref >= 1.0  && value < ptr->numColor) {
	MakeErrorString(8, 4, &buf, ptr, expected);
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }
    return NO_ERROR;
}

long FogExpCIExec(void)
{
    fogExpRec data;
    float start, end, frac;
    GLfloat m[4][4];

    /*
    ** Since the eye coordinates are used to calculate the distance or zfog
    ** value, we have to do a little transformation hocus pocus to allow for a
    ** large homogeneous clip coordinate and to allow z and distance to be
    ** equal in eye coordinates. 12.0 is chosen as it is bigger than ln(65536)
    ** which is hopefully the largest number of color indices available.
    */
    data.numColor = POW(2.0, (float)buffer.ciBits) - 1.0;
    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);
    glMatrixMode(GL_PROJECTION);
    glTranslatef(0.5, 0.5, 0.0);
    MakeIdentMatrix(&m[0][0]);
    m[0][0] = 12.0;
    m[1][1] = 12.0;
    m[3][3] = 12.0;
    glMultMatrixf(&m[0][0]);
    glMatrixMode(GL_MODELVIEW);

    glClearIndex(0.0);
    glDisable(GL_DITHER);
    glEnable(GL_FOG);

    for (data.useZ = GL_FALSE; data.useZ <= GL_TRUE; data.useZ++) {
	for (data.isSquared = GL_FALSE; data.isSquared <= GL_TRUE;
	     data.isSquared++) {
	    if (data.numColor < 4096.0 || machine.pathLevel != 0) {
		start = 0.5 / data.numColor;
		if (RampUtil(start, 1.0, InitCI, Set, TestCI,
			     &data) == ERROR) {
		    return ERROR;
		}
	    } else {
		start = 0.5 / data.numColor;
		frac = POW(2.0, (float)(10-buffer.ciBits));
		if (RampUtil(start, frac, InitCI, Set, TestCI,
			     &data) == ERROR) {
		    return ERROR;
		}
		start = 0.5 - frac;
		end = 0.5 + frac;
		if (RampUtil(start, end, InitCI, Set, TestCI,
			     &data) == ERROR) {
		    return ERROR;
		}
		start = 1.0 - frac;
		if (RampUtil(start, 1.0, InitCI, Set, TestCI,
			     &data) == ERROR) {
		    return ERROR;
		}
	    }
	}
    }
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\linerast.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** linerast.c
** Line Rasterization Test.
**
** Description -
**    Tests the rasterization of single width lines. A
**    specification of the OpenGL states that there can be only
**    one pixel per column for an X-major line and one pixel per
**    row for a Y-major line. This test will draw a series of
**    lines of random lengths and directions to verify this.
**    Special code for checking near the endpoints of the line is
**    used since the endpoints may stray up to one pixel in any
**    direction from their calculated locations.
**
** Error Explanation -
**    Failure occurs if there is more than one pixel in the
**    cross-section of the line. Also, an error will result if an
**    endpoint strays more than one pixel from its calculated
**    location.
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer.
**    Color requirements:
**        RGBA or color index mode. 2 colors.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**        Color epsilon.
**    Paths:
**        Allowed = Alpha, Blend, Depth, Fog, Logicop, Shade, Stencil, Stipple.
**        Not allowed = Alias, Dither.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"


static char errStr[240];
static char errStrFmt[][160] = {
    "Line (%d, %d) (%d, %d) (%s-major line) has bad endpoints.",
    "Line (%d, %d) (%d, %d) (%s-major line) has more then one pixel per minor axis.",
    "Line (%d, %d) (%d, %d) (%s-major line) has missing pixels per minor axis."
};


static void ClearSetRead(GLint *v1, GLint *v2, GLint len, GLfloat *buf)
{

    glClear(GL_COLOR_BUFFER_BIT);

    glBegin(GL_LINES);
	glVertex2f((float)v1[0]+0.5, (float)v1[1]+0.5);
	glVertex2f((float)v2[0]+0.5, (float)v2[1]+0.5);
    glEnd();

    ReadScreen((v2[0]>=v1[0])?(v1[0]-2):(v2[0]-2),
	       (v2[1]>=v1[1])?(v1[1]-2):(v2[1]-2),
	       len+4, len+4, GL_AUTO_COLOR, buf);
}

static long XLines(GLint *v1, GLint *v2, GLint len, GLfloat *buf)
{
    long i, j, count;

    ClearSetRead(v1, v2, len, buf);

    for (i = 0; i < len+4; i++) {
	if (AutoColorCompare(buf[i*(len+4)], COLOR_OFF) == GL_FALSE) {
	    StrMake(errStr, errStrFmt[0], v1[0], v1[1], v2[0], v2[1], "x");
	    ErrorReport(__FILE__, __LINE__, errStr);
	    return ERROR;
	}
    }

    for (i = 1; i <= len+2; i++) {
	count = 0;
	for (j = 0; j < len+4; j++) {
	    if (AutoColorCompare(buf[j*(len+4)+i], COLOR_ON) == GL_TRUE) {
		count++;
	    }
	}
	if (i <= 3 || i >= len) {
	    if (count > 1) {
		StrMake(errStr, errStrFmt[0], v1[0], v1[1], v2[0], v2[1], "x");
		ErrorReport(__FILE__, __LINE__, errStr);
		return ERROR;
	    }
	} else {
	    if (count > 1) {
		StrMake(errStr, errStrFmt[1], v1[0], v1[1], v2[0], v2[1], "x");
		ErrorReport(__FILE__, __LINE__, errStr);
		return ERROR;
	    } else if (count == 0) {
		StrMake(errStr, errStrFmt[2], v1[0], v1[1], v2[0], v2[1], "x");
		ErrorReport(__FILE__, __LINE__, errStr);
		return ERROR;
	    }
	}
    }

    for (i = 0; i < len+4; i++) {
	if (AutoColorCompare(buf[i*(len+4)+(len+3)], COLOR_OFF) == GL_FALSE) {
	    StrMake(errStr, errStrFmt[0], v1[0], v1[1], v2[0], v2[1], "x");
	    ErrorReport(__FILE__, __LINE__, errStr);
	    return ERROR;
	}
    }

    return NO_ERROR;
}

static long YLines(GLint *v1, GLint *v2, GLint len, GLfloat *buf)
{
    long i, j, count;

    ClearSetRead(v1, v2, len, buf);

    for (i = 0; i < len+4; i++) {
	if (AutoColorCompare(buf[i], COLOR_OFF) == GL_FALSE) {
	    StrMake(errStr, errStrFmt[0], v1[0], v1[1], v2[0], v2[1], "y");
	    ErrorReport(__FILE__, __LINE__, errStr);
	    return ERROR;
	}
    }

    for (i = 1; i <= len+2; i++) {
	count = 0;
	for (j = 0; j < len+4; j++) {
	    if (AutoColorCompare(buf[i*(len+4)+j], COLOR_ON) == GL_TRUE) {
		count++;
	    }
	}
	if (i <= 3 || i >= len) {
	    if (count > 1) {
		StrMake(errStr, errStrFmt[0], v1[0], v1[1], v2[0], v2[1], "y");
		ErrorReport(__FILE__, __LINE__, errStr);
		return ERROR;
	    }
	} else {
	    if (count > 1) {
		StrMake(errStr, errStrFmt[1], v1[0], v1[1], v2[0], v2[1], "y");
		ErrorReport(__FILE__, __LINE__, errStr);
		return ERROR;
	    } else if (count == 0) {
		StrMake(errStr, errStrFmt[2], v1[0], v1[1], v2[0], v2[1], "y");
		ErrorReport(__FILE__, __LINE__, errStr);
		return ERROR;
	    }
	}
    }

    for (i = 0; i < len+4; i++) {
	if (AutoColorCompare(buf[(len+3)*(len+4)+i], COLOR_OFF) == GL_FALSE) {
	    StrMake(errStr, errStrFmt[0], v1[0], v1[1], v2[0], v2[1], "y");
	    ErrorReport(__FILE__, __LINE__, errStr);
	    return ERROR;
	}
    }

    return NO_ERROR;
}

long LineRasterExec(void)
{
    GLfloat *buf;
    GLint v1[2], v2[2], len, max, i;

    buf = (GLfloat *)MALLOC(WINDSIZEX*WINDSIZEY*sizeof(GLfloat));

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    AutoClearColor(COLOR_OFF);
    AutoColor(COLOR_ON);
    glDisable(GL_DITHER);

    len = (GLint)Random(3.0, WINDSIZEX/8.0);
    max = (machine.pathLevel == 0) ? len : 1;
    for (i = 0; i < max; i++) {
	v1[0] = (GLint)Random(WINDSIZEX/4.0, WINDSIZEX*3.0/4.0);
	v1[1] = (GLint)Random(WINDSIZEY/4.0, WINDSIZEY*3.0/4.0);
	v2[0] = v1[0] + len;
	v2[1] = v1[1] + i;
        if (XLines(v1, v2, len, buf) == ERROR) {
	    FREE(buf);
	    return ERROR;
	}
    }
    len = (GLint)Random(3.0, WINDSIZEX/8.0);
    max = (machine.pathLevel == 0) ? len : 1;
    for (i = 0; i < max; i++) {
	v1[0] = (GLint)Random(WINDSIZEX/4.0, WINDSIZEX*3.0/4.0);
	v1[1] = (GLint)Random(WINDSIZEY/4.0, WINDSIZEY*3.0/4.0);
	v2[0] = v1[0] + i;
	v2[1] = v1[1] + len;
        if (YLines(v1, v2, len, buf) == ERROR) {
	    FREE(buf);
	    return ERROR;
	}
    }
    len = (GLint)Random(3.0, WINDSIZEX/8.0);
    max = (machine.pathLevel == 0) ? len : 1;
    for (i = 0; i < max; i++) {
	v1[0] = (GLint)Random(WINDSIZEX/4.0, WINDSIZEX*3.0/4.0);
	v1[1] = (GLint)Random(WINDSIZEY/4.0, WINDSIZEY*3.0/4.0);
	v2[0] = v1[0] - len;
	v2[1] = v1[1] + i;
        if (XLines(v1, v2, len, buf) == ERROR) {
	    FREE(buf);
	    return ERROR;
	}
    }
    len = (GLint)Random(3.0, WINDSIZEX/8.0);
    max = (machine.pathLevel == 0) ? len : 1;
    for (i = 0; i < max; i++) {
	v1[0] = (GLint)Random(WINDSIZEX/4.0, WINDSIZEX*3.0/4.0);
	v1[1] = (GLint)Random(WINDSIZEY/4.0, WINDSIZEY*3.0/4.0);
	v2[0] = v1[0] - i;
	v2[1] = v1[1] + len;
        if (YLines(v1, v2, len, buf) == ERROR) {
	    FREE(buf);
	    return ERROR;
	}
    }
    len = (GLint)Random(3.0, WINDSIZEX/8.0);
    max = (machine.pathLevel == 0) ? len : 1;
    for (i = 0; i < max; i++) {
	v1[0] = (GLint)Random(WINDSIZEX/4.0, WINDSIZEX*3.0/4.0);
	v1[1] = (GLint)Random(WINDSIZEY/4.0, WINDSIZEY*3.0/4.0);
	v2[0] = v1[0] - len;
	v2[1] = v1[1] - i;
        if (XLines(v1, v2, len, buf) == ERROR) {
	    FREE(buf);
	    return ERROR;
	}
    }
    len = (GLint)Random(3.0, WINDSIZEX/8.0);
    max = (machine.pathLevel == 0) ? len : 1;
    for (i = 0; i < max; i++) {
	v1[0] = (GLint)Random(WINDSIZEX/4.0, WINDSIZEX*3.0/4.0);
	v1[1] = (GLint)Random(WINDSIZEY/4.0, WINDSIZEY*3.0/4.0);
	v2[0] = v1[0] - i;
	v2[1] = v1[1] - len;
        if (YLines(v1, v2, len, buf) == ERROR) {
	    FREE(buf);
	    return ERROR;
	}
    }
    len = (GLint)Random(3.0, WINDSIZEX/8.0);
    max = (machine.pathLevel == 0) ? len : 1;
    for (i = 0; i < max; i++) {
	v1[0] = (GLint)Random(WINDSIZEX/4.0, WINDSIZEX*3.0/4.0);
	v1[1] = (GLint)Random(WINDSIZEY/4.0, WINDSIZEY*3.0/4.0);
	v2[0] = v1[0] + len;
	v2[1] = v1[1] - i;
        if (XLines(v1, v2, len, buf) == ERROR) {
	    FREE(buf);
	    return ERROR;
	}
    }
    len = (GLint)Random(3.0, WINDSIZEX/8.0);
    max = (machine.pathLevel == 0) ? len : 1;
    for (i = 0; i < max; i++) {
	v1[0] = (GLint)Random(WINDSIZEX/4.0, WINDSIZEX*3.0/4.0);
	v1[1] = (GLint)Random(WINDSIZEY/4.0, WINDSIZEY*3.0/4.0);
	v2[0] = v1[0] + i;
	v2[1] = v1[1] - len;
        if (YLines(v1, v2, len, buf) == ERROR) {
	    FREE(buf);
	    return ERROR;
	}
    }

    FREE(buf);
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\lineaa.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** lineaa.c
** Line Anti-Aliasing Test.
**
** Description -
**    The first part tests position independence of anti-aliased
**    lines. The coverage of a random length line is calculated.
**    This line is then translated. Regardless of its new
**    position, the coverage should remain the same, modulo
**    difference resulting from subpixel positioning. The test
**    is repeated for a several line lengths, each taken through
**    a several randomly generated translations. Lines of width
**    start at 1.0 and are incremented by implementation dependent
**    granularity up to the implementation range maximum.
**    
**    The second part tests the subsetting restriction for
**    anti-aliasing. A line is drawn at a fixed position with a
**    series of decreasing lengths and widths. The coverage for
**    each successive line should be less than or equal to the
**    coverage for the previous, longer or wider, line.
**
** Error Explanation -
**    For the first section of the test:
**        The error allowance is based on a minimum of 4
**        subpixel sampling. This yields 0.125 per pixel.
**        One half of a color epsilon is added per pixel to
**        account for the rounding from a coverage value to
**        a shade. This sum is multiplied by the number of
**        pixels along the perimeter (twice width for ends,
**        plus twice length).
**    
**    For the second section of the test:
**        The error allowance is epsilon.zero times line length.
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer.
**    Color requirements:
**        RGBA mode. Full color.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**        (under error explanation above).
**    Paths:
**        Allowed = Depth, Fog, Logicop, Shade, Stencil, Stipple.
**        Not allowed = Alias, Alpha, Blend, Dither.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"


static char errStr[160];
static char errStrFmt[][80] = {
    "Line primitive did not draw.",
    "Coverage is %g, initial coverage was %g. Error margin is %g.",
    "Failure in subset test. Coverage for line is %g, should be less than %g."
};


long LineAntiAliasExec(void)
{
    GLfloat *buf;
    GLfloat v1[2], v2[2];
    GLfloat angle, shiftX, shiftY, sum, saveSum=0.0f, errorMargin;
    GLfloat width;
    GLfloat widthRange[2], widthGranularity;
    long i, j, k, max;

    /*
    ** There is no specified coverage computation for anti-aliasing,
    ** therefore we test that the sum of the coverage values is
    ** fairly constant, independent of translation in the window. 
    */

    buf = (GLfloat *)MALLOC(WINDSIZEX*WINDSIZEY*3*sizeof(GLfloat));

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glColor3f(1.0, 0.0, 0.0);
    glDisable(GL_DITHER);
    glEnable(GL_LINE_SMOOTH);
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE);

    glGetFloatv(GL_LINE_WIDTH_RANGE, widthRange);
    glGetFloatv(GL_LINE_WIDTH_GRANULARITY, &widthGranularity);
    width = 1.0;

    max = (machine.pathLevel == 0) ? 9.0 : 2.0;

    for (i = 0; i < max; i++) {
	v1[0] = 0.0;
	v1[1] = 0.0;
	v2[0] = Random(1.0, WINDSIZEX/3.0);
	v2[1] = 0.0;
	angle = Random(0.0, 360.0);

	width = (width + widthGranularity < widthRange[1]) ?
	         width + widthGranularity : 1.0;
	glLineWidth(width);

	for (k = 0; k < 8; k++) {
	    glClear(GL_COLOR_BUFFER_BIT);

	    glPushMatrix();

	    shiftX = Random(WINDSIZEX/3.0, WINDSIZEX*2.0/3.0);
	    shiftY = Random(WINDSIZEY/3.0, WINDSIZEY*2.0/3.0);
	    glTranslatef(shiftX, shiftY, 0.0);
	    glRotatef(angle, 0, 0, 1);

	    glBegin(GL_LINES);
		glVertex2fv(v1);
		glVertex2fv(v2);
	    glEnd();

	    glPopMatrix();
	    glFlush();

	    ReadScreen(0, 0, WINDSIZEX, WINDSIZEY, GL_RGB, buf);

	    sum = 0;
	    for (j = 0; j < WINDSIZEY*WINDSIZEY*3; j += 3) {
		sum += buf[j];
	    }

	    if (k == 0) {
		saveSum = sum;
	    } else {
		if (sum == 0.0) {
		    ErrorReport(__FILE__, __LINE__, errStrFmt[0]);
		    FREE(buf);
		    return ERROR;
		}

		/*
		**  Error allowance based on minimum of 4 subpixel sampling.
		**  The error margin is multiplied by the number of pixels
		**  on the perimeter of the primitive.
		*/

		errorMargin = 2.0 * (0.125 + epsilon.color[0] / 2.0) *
			      (v2[0] + width);
		if (ABS(saveSum-sum) > errorMargin) {
		    StrMake(errStr, errStrFmt[1], sum, saveSum, errorMargin);
		    ErrorReport(__FILE__, __LINE__, errStr);
		    FREE(buf);
		    return ERROR;
		}
	    }
	}
    }

    /*
    ** Test subsetting rule.
    */

    width = 1.0;
    for (i = 0; i < max; i++) {
	v1[0] = 0.0;
	v1[1] = 0.0;
	v2[0] = Random(15.0, WINDSIZEX-10.0);
	v2[1] = 0.0;
	angle = Random(0.0, 90.0);

	width = (width + 6*widthGranularity < widthRange[1]) ?
	         width + 6*widthGranularity : 1.0;
	glLineWidth(width);

	for (k = 0; k < 8; k++) {
	    glClear(GL_COLOR_BUFFER_BIT);

	    glPushMatrix();
	    /*
	    ** Translate away from corner so wide lines don't get clipped.
	    */
	    glTranslatef(5.0, 5.0, 0.0);
	    glRotatef(angle, 0, 0, 1);

	    /*
	    ** Decrease length or width with each iteration.
	    */
	    if (k%2 == 0) {
		v2[0] -= 1.1;
	    } else {
		width = (width > 1.0 + widthGranularity) ? 
			(width - widthGranularity) : 1.0;
	    }
	    glLineWidth(width);

	    glBegin(GL_LINES);
		glVertex2fv(v1);
		glVertex2fv(v2);
	    glEnd();

	    glPopMatrix();
	    glFlush();

	    ReadScreen(0, 0, WINDSIZEX, WINDSIZEY, GL_RGB, buf);

	    sum = 0;
	    for (j = 0; j < WINDSIZEY*WINDSIZEY*3; j += 3) {
		sum += buf[j];
	    }

	    if (k == 0) {
		saveSum = sum;
	    } else {
		if (sum == 0.0) {
		    ErrorReport(__FILE__, __LINE__, errStrFmt[0]);
		    FREE(buf);
		    return ERROR;
		}

		/*
		**  The line coverage must be a subset of the
		**  coverage of the previous (longer or wider) line.
		**  Allow numerical error proportional to line length.
		*/
		if ((sum-saveSum) > v2[0]*epsilon.zero) {
		    StrMake(errStr, errStrFmt[2], sum, saveSum);
		    ErrorReport(__FILE__, __LINE__, errStr);
		    FREE(buf);
		    return ERROR;
		}
	    }
	    saveSum = sum;
	}
    }

    FREE(buf);
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\l_al.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** l_al.c
** Light - Ambient Light Test.
**
** Description -
**    This lighting test analyses the effect that varying the
**    Ambient_Light has on the color produced by lighting. This
**    is the parameter set with glLightfv(i, GL_AMBIENT, color).
**    A single lit point is rendered in the lower left corner of
**    the screen, and the color of this point is read using
**    glReadPixels().
**    
**    To analyse only this one parameter, other lighting
**    parameters are chosen so that the Emmissive, Diffuse, and
**    Specular summands of the RGB lighting function are set to
**    zero. The Ambient_Scene is also set to zero. The
**    Ambient_Material parameter is set to (1, 1, 1, 1). The
**    Attenuation and Spot parameters are left at their default
**    values, leaving the factors involving these parameters at
**    1.0. This forms a restriction of the lighting function to a
**    function of Ambient_Light f(Ambient_Light) -> color. This
**    function is analysed for monotonicity, endpoint's values,
**    and variation.
**    
**    All color channels are tested one at a time. The
**    implementation fails if any color channel other than the
**    one being tested is not observed to be black. One light is
**    enabled at a time. The first 8 individual lights are
**    tested.
**    
**    The test repeatedly renders and reads the same point,
**    uniformly incrementing Ambient_Light so that the colors
**    resulting from lighting should vary by a uniform amount on
**    every 16th iterate. This controls the linearity of this
**    restriction of the lighting function to Ambient_Light. The
**    uniformity of this change is tested and the implementation
**    fails if consecutive changes are too different. (thisDelta
**    - lastDelta) > 1/4 shade. The observed restriction is also
**    checked for monotonicity.
**    
**    When Ambient_Light reaches its max/min the color is checked
**    to insure that it is rendered with a saturation of 1.0.
**
** Error Explanation -
**    Non_tested color channel not black. Ambient_Light fully
**    saturated, but output not fully saturated. Color decreased as
**    Ambient_Light is increased. (thisDelta - lastDelta) > 1/4
**    shade.
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer.
**    Color requirements:
**        RGBA mode. Full color. Full color.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**        Color, ci and zero epsilons, 0.25*color_epsilon.
**    Paths:
**        Allowed = Alpha, Blend, Depth, Logicop, Stencil, Stipple.
**        Not allowed = Alias, Dither, Fog, Shade.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"
#include "utilru.h"


typedef struct _ambLightRec {
    long color;
    float step, lastValue, lastDelta, delta;
    GLenum light;
    GLfloat light_ambient[4];
} ambLightRec;


static void Init(void *data)
{
    ambLightRec *ptr = (ambLightRec *)data;
    GLfloat buf[4];
    float step;
    GLenum i;

    ptr->lastValue = -1.0;
    ptr->lastDelta = -2.0;

    step = (machine.pathLevel == 0) ? 4.0 : 2.0;
    ptr->delta = 1.0 / (POW(2.0, (float)buffer.colorBits[ptr->color]) - 1.0);
    ptr->step = ptr->delta / step;

    for (i = GL_LIGHT0; i <= GL_LIGHT7; i++) {
	glDisable(i);
    }
    glEnable(ptr->light);

    ptr->light_ambient[0] = 0.0;
    ptr->light_ambient[1] = 0.0;
    ptr->light_ambient[2] = 0.0;
    ptr->light_ambient[3] = 1.0;

    buf[0] = 1.0;
    buf[1] = 1.0;
    buf[2] = 1.0;
    buf[3] = 1.0;
    glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, buf);

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = 0.0;
    buf[3] = 1.0;
    glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, buf);

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = 0.0;
    buf[3] = 0.0;
    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, buf);

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = 0.0;
    buf[3] = 1.0;
    glLightfv(ptr->light, GL_DIFFUSE, buf);
}

static void Set(void *data, float *ref)
{
    ambLightRec *ptr = (ambLightRec *)data;

    ptr->light_ambient[ptr->color] = *ref;
    glLightfv(ptr->light, GL_AMBIENT, ptr->light_ambient);

    glBegin(GL_POINTS);
	glVertex2f(0.5, 0.5);
    glEnd();

    *ref += ptr->step;
}

static long Test(void *data, float ref)
{
    ambLightRec *ptr = (ambLightRec *)data;
    char str[240];
    GLfloat buf[3]; 
    float value, delta;
    long i;

    ReadScreen(0, 0, 1, 1, GL_RGB, buf);

    for (i = 0; i < 3; i++) {
	if (buf[i] != 0.0 && i != ptr->color) {
	    ColorError_RGBZero(str, ptr->color, buf);
	    ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
    }

    value = buf[ptr->color];
    if (ptr->lastDelta == -2.0) {
	ptr->lastDelta = -1.0;
	ptr->lastValue = value;
    } else if (ptr->lastDelta == -1.0) {
	if (value < ptr->lastValue) {
	    ColorError_RGBMonotonic(str, ptr->color, value, ptr->lastValue);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	if (ABS(delta) > epsilon.zero) {
	    if (ABS(delta-ptr->delta) > 0.25*epsilon.color[ptr->color]) {
		ColorError_RGBStep(str, ptr->color, delta, ptr->delta);
                ErrorReport(__FILE__, __LINE__, str);
		return ERROR;
	    }
	    ptr->lastDelta = delta;
	}
    } else {
	if (value < ptr->lastValue) {
	    ColorError_RGBMonotonic(str, ptr->color, value, ptr->lastValue);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	if (ABS(delta) > epsilon.zero) {
	    if (ABS(delta-ptr->delta) > 0.25*epsilon.color[ptr->color]) {
		ColorError_RGBStep(str, ptr->color, delta, ptr->delta);
                ErrorReport(__FILE__, __LINE__, str);
		return ERROR;
	    }
	    if (ABS(delta-ptr->lastDelta) > epsilon.zero) {
		ColorError_RGBDelta(str, ptr->color, delta, ptr->lastDelta);
                ErrorReport(__FILE__, __LINE__, str);
		return ERROR;
	    }
	    ptr->lastDelta = delta;
	}
    }

    if (ref >= 1.0 && ABS(value-1.0) > epsilon.zero) {
	ColorError_RGBClamp(str, ptr->color, value);
        ErrorReport(__FILE__, __LINE__, str);
	return ERROR;
    }

    return NO_ERROR;
}

long AmbLightExec(void)
{
    ambLightRec data;
    long max1, max2;

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glDisable(GL_DITHER);
    glEnable(GL_LIGHTING);

    max1 = (machine.pathLevel == 0) ? GL_LIGHT7 : GL_LIGHT0;
    max2 = (machine.pathLevel == 0) ? 3 : 1;
    for (data.light = GL_LIGHT0; data.light <= max1; data.light++) {
	for (data.color = 0; data.color < max2; data.color++) {
	    if (RampUtil(0.0, 1.0, Init, Set, Test, &data) == ERROR) {
		return ERROR;
	    }
	}
    }
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\l_am.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** l_am.c
** Light - Ambient Material Test.
**
** Description -
**    This lighting test analyses the effect that varying
**    Ambient_Material has on the color produced by lighting.
**    (This parameter is set with glMaterialfv(GL_FRONT_AND_BACK,
**    GL_AMBIENT, ... ). CI lighting differs from RGB lighting.
**    This file contains code for both tests. A single lit point
**    is rendered in the lower left corner of the screen and the
**    color or color index of this point is retrieved using
**    glReadPixels(). To analyse only this one parameter,
**    lighting parameters are chosen so that the summands of the
**    RGB or CI lighting equation which do not contain
**    Ambient_Material are set to zero. In RGB mode Ambient_Scene
**    is set to 1.0, and in both modes the individual lights are
**    disabled.
**    
**    This forms a restriction of the lighting equation to a
**    function of Ambient_Material f(Ambient_Material) -> color.
**    This function is analysed for monotonicity, endpoints, and
**    variation. In CI mode a theoretical result is directly
**    compared to the result read from the framebuffer. In RGB
**    mode all color channels are tested one at a time. The
**    implementation fails if any color channel which is not
**    being tested is not zero.
**    
**    The test repeatedly renders and reads the same point,
**    uniformly increment Ambient_Material so that the colors
**    resulting from lighting vary by a uniform amount. This
**    helps to analyze the concavity of this restriction of the
**    lighting function.
**    
**    In RGB mode uniformity of change is tested, and the
**    implementation fails if consecutive changes are too
**    different. (thisDelta - lastDelta) > 1/4 shade. The
**    observed results are also checked for monotonicity. When
**    Ambient_Material reaches its max the color is checked to
**    insure that it is rendered with a saturation of 1.0.
**    
**    In CI mode a check is made to ensure that the observed
**    index reaches its max. The observed shade is compared to
**    the theoretical value expected for each setting of
**    Ambient_Material. If the theoretical value is more than 2
**    indices away from the observed index the test fails. The
**    observed value must be an integer, and the difference
**    between successive observances must be less than 2.
**
** Error Explanation -
**    RGB mode: other_color > 0.0.
**    RGB mode: value < lastValue.
**    RGB mode: maxObserved < 1.0.
**    RGB mode: (thisDelta - lastDelta) > 1/4 shade.
**    CI mode: (fractional index) != 0.0.
**    CI mode: (observed - expected) > 3.0.
**    CI mode: observedMax < numColor.
**    CI mode: delta > 2.0.
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer.
**    Color requirements:
**        RGBA or color index mode. Full color.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**        Color, ci and zero epsilons, 0.25*color_epsilon.
**    Paths:
**        Allowed = Alpha, Blend, Depth, Logicop, Stencil, Stipple.
**        Not allowed = Alias, Dither, Fog, Shade.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"
#include "utilru.h"


typedef struct _ambMatRec {
    long color, light;
    float step, numColor, lastValue, lastDelta, delta;
    GLfloat material_ambient[4];
} ambMatRec;


/****************************************************************************/

static void InitRGB(void *data)
{
    ambMatRec *ptr = (ambMatRec *)data;
    GLfloat buf[4];
    float step;
    GLenum i;

    ptr->lastValue = -1.0;
    ptr->lastDelta = -2.0;

    step = (machine.pathLevel == 0) ? 4.0 : 2.0;
    ptr->delta = 1.0 / (POW(2.0, (float)buffer.colorBits[ptr->color]) - 1.0);
    ptr->step = ptr->delta / step;

    for (i = GL_LIGHT0; i <= GL_LIGHT7; i++) {
	glDisable(i);
    }

    ptr->material_ambient[0] = 0.0;
    ptr->material_ambient[1] = 0.0;
    ptr->material_ambient[2] = 0.0;
    ptr->material_ambient[3] = 1.0;

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = 0.0;
    buf[3] = 0.0;
    glMaterialfv(GL_FRONT_AND_BACK, GL_EMISSION, buf);

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = 0.0;
    buf[3] = 1.0;
    glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, buf);

    buf[0] = 1.0;
    buf[1] = 1.0;
    buf[2] = 1.0;
    buf[3] = 1.0;
    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, buf);

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = 0.0;
    buf[3] = 0.0;
    glLightfv(GL_LIGHT0, GL_DIFFUSE, buf);
}

static void SetRGB(void *data, float *ref)
{
    ambMatRec *ptr = (ambMatRec *)data;

    ptr->material_ambient[ptr->color] = *ref;
    glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, ptr->material_ambient);

    glBegin(GL_POINTS);
	glVertex2f(0.5, 0.5);
    glEnd();

    *ref += ptr->step;
}

static long TestRGB(void *data, float ref)
{
    ambMatRec *ptr = (ambMatRec *)data;
    char str[240];
    GLfloat buf[3]; 
    float value, delta;
    long i;

    ReadScreen(0, 0, 1, 1, GL_RGB, buf);

    for (i = 0; i < 3; i++) {
	if (buf[i] != 0.0 && i != ptr->color) {
            ColorError_RGBZero(str, ptr->color, buf);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
    }

    value = buf[ptr->color];
    if (ptr->lastDelta == -2.0) {
	ptr->lastDelta = -1.0;
	ptr->lastValue = value;
    } else if (ptr->lastDelta == -1.0) {
	if (value < ptr->lastValue) {
            ColorError_RGBMonotonic(str, ptr->color, value, ptr->lastValue);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	if (ABS(delta) > epsilon.zero) {
	    if (ABS(delta-ptr->delta) > 0.25*epsilon.color[ptr->color]) {
                ColorError_RGBStep(str, ptr->color, delta, ptr->delta);
                ErrorReport(__FILE__, __LINE__, str);
		return ERROR;
	    }
	    ptr->lastDelta = delta;
	}
    } else {
	if (value < ptr->lastValue) {
            ColorError_RGBMonotonic(str, ptr->color, value, ptr->lastValue);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	if (ABS(delta) > epsilon.zero) {
	    if (ABS(delta-ptr->delta) > 0.25*epsilon.color[ptr->color]) {
                ColorError_RGBStep(str, ptr->color, delta, ptr->delta);
                ErrorReport(__FILE__, __LINE__, str);
		return ERROR;
	    }
	    if (ABS(delta-ptr->lastDelta) > epsilon.zero) {
                ColorError_RGBDelta(str, ptr->color, delta, ptr->lastDelta);
                ErrorReport(__FILE__, __LINE__, str);
		return ERROR;
	    }
	    ptr->lastDelta = delta;
	}
    }

    if (ref >= 1.0 && ABS(value-1.0) > epsilon.zero) {
        ColorError_RGBClamp(str, ptr->color, value);
        ErrorReport(__FILE__, __LINE__, str);
	return ERROR;
    }

    return NO_ERROR;
}

long AmbMatRGBExec(void)
{
    ambMatRec data;
    long max;

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glDisable(GL_DITHER);
    glEnable(GL_LIGHTING);

    max = (machine.pathLevel == 0) ? 3 : 1;
    for (data.color = 0; data.color < max; data.color++) {
	if (RampUtil(0.0, 1.0, InitRGB, SetRGB, TestRGB, &data) == ERROR) {
	    return ERROR;
	}
    }
    return NO_ERROR;
}

/*****************************************************************************/

static void InitCI(void *data)
{
    ambMatRec *ptr = (ambMatRec *)data;
    GLfloat buf[4];
    GLenum i;

    ptr->lastValue = -1.0;

    ptr->step = (machine.pathLevel == 0) ? 0.5 : ((ptr->numColor + 1.0) / 8.0);

    for (i = GL_LIGHT0; i <= GL_LIGHT7; i++) {
	glDisable(i);
    }

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = ptr->numColor;
    glMaterialfv(GL_FRONT_AND_BACK, GL_COLOR_INDEXES, buf);
}

static void SetCI(void *data, float *ref)
{
    ambMatRec *ptr = (ambMatRec *)data;
    GLfloat buf[3];

    buf[0] = *ref;
    /*
    ** These values should have no deleterious effects since the
    ** the individual lights are disabled.
    */
    buf[1] = ptr->numColor;
    buf[2] = ptr->numColor;

    glMaterialfv(GL_FRONT_AND_BACK, GL_COLOR_INDEXES, buf);

    glBegin(GL_POINTS);
	glVertex2f(0.5, 0.5);
    glEnd();

    *ref += ptr->step;
}

/*
** In Color Index mode we check the following:
** 1) Is the value an integer?
** 2) Is the ramp monotonic?
** 3) Does it round correctly?
** 4) Does it skip any possible Indexes?
** 5) Does it ever reach the top index?
*/
static long TestCI(void *data, float ref)
{
    ambMatRec *ptr = (ambMatRec *)data;
    char str[240];
    GLfloat value;
    float expected, frac, delta;

    ReadScreen(0, 0, 1, 1, GL_COLOR_INDEX, &value);

    frac = ABS(value-(float)((int)value));
    if (frac > epsilon.zero && ABS(frac-1.0) > epsilon.zero) {
        ColorError_CIFrac(str, value);
        ErrorReport(__FILE__, __LINE__, str);
	return ERROR;
    }

    expected = (float)Round(2.0*ref) / 2.0;

    if (ptr->lastValue == -1.0) {
	ptr->lastValue = value;
    } else {
	if (value < ptr->lastValue) {
            ColorError_CIMonotonic(str, value, ptr->lastValue);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
	if (ABS(value-expected) > epsilon.ci+epsilon.zero) {
	    ColorError_CIBad(str, value, expected);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	if (ABS(delta) > epsilon.zero) {
	    if (ABS(delta) >= 2.0) {
                ColorError_CIStep(str, delta);
                ErrorReport(__FILE__, __LINE__, str);
		return ERROR;
	    }
	}
    }

    if (ref >= ptr->numColor && value < ptr->numColor) {
        ColorError_CIClamp(str, ptr->numColor, value);
        ErrorReport(__FILE__, __LINE__, str);
	return ERROR;
    }
    return NO_ERROR;
}

long AmbMatCIExec(void)
{
    ambMatRec data;
    float start, end;

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glDisable(GL_DITHER);
    glEnable(GL_LIGHTING);

    data.numColor = (float)POW(2.0, (float)buffer.ciBits) - 1;
    if (data.numColor < 4096.0 || (machine.pathLevel != 0)) {
	if (RampUtil(0.0, 1.0, InitCI, SetCI, TestCI, &data) == ERROR) {
	    return ERROR;
	}
    } else {
	start = 0.5;
	end = 256.5;
	if (RampUtil(start, end, InitCI, SetCI, TestCI, &data) == ERROR) {
	    return ERROR;
	}
	start = (data.numColor + 1) / 2.0 - 256.0;
	end = (data.numColor + 1) / 2.0 + 256.0;
	if (RampUtil(start, end, InitCI, SetCI, TestCI, &data) == ERROR) {
	    return ERROR;
	}
	start = data.numColor - 256.0;
	end = data.numColor;
	if (RampUtil(start, end, InitCI, SetCI, TestCI, &data) == ERROR) {
	    return ERROR;
	}
    }
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\logicop.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** logicop.c
** Logicop Test.
**
** Description -
**    Tests the functionality of logical operations. There are 16
**    logicop functions: GL_AND, GL_AND_INVERTED, GL_AND_REVERSE,
**    GL_CLEAR, GL_COPY, GL_COPY_INVERTED, GL_EQUIV, GL_INVERT,
**    GL_NAND, GL_NOOP, GL_NOR, GL_OR, GL_OR_INVERTED,
**    GL_OR_REVERSE, GL_SET and GL_XOR. Each one is tested by
**    choosing a random source and destination color, drawing a
**    point using the destination color with logicop disabled,
**    drawing the same point using the source color with logicop
**    enabled, then reading the resulting color and comparing it
**    to a calculated value.
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer.
**    Color requirements:
**        Color index mode. Full color.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**        Since logical operations are bitwise operations, no epsilon is used.
**    Paths:
**        Allowed = Alpha, Blend, Depth, Fog, Shade, Stencil, Stipple.
**        Not allowed = Alias, Dither, Logicop.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"


static char errStr[240];
static char errStrFmt[] = "Logic Op is %s. Source color index is %d, destination color index is %d. Result is %d, should be %d.";


static GLuint TrueResult(GLenum op, GLuint srcColor, GLuint destColor,
			   GLuint mask)
{
    GLuint result=0;

    switch (op) {
      case GL_CLEAR:
	result = 0;
	break;
      case GL_AND:
	result = srcColor & destColor;
	break;
      case GL_AND_REVERSE:
	result = srcColor & (~destColor);
	break;
      case GL_COPY:
	result = srcColor;
	break;
      case GL_AND_INVERTED:
	result = (~srcColor) & destColor;
	break;
      case GL_NOOP:
	result = destColor;
	break;
      case GL_XOR:
	result = srcColor ^ destColor;
	break;
      case GL_OR:
	result = srcColor | destColor;
	break;
      case GL_NOR:
	result = ~(srcColor | destColor);
	break;
      case GL_EQUIV:
	result = ~(srcColor ^ destColor);
	break;
      case GL_INVERT:
	result = ~destColor;
	break;
      case GL_OR_REVERSE:
	result = srcColor | (~destColor);
	break;
      case GL_COPY_INVERTED:
	result = ~srcColor;
	break;
      case GL_OR_INVERTED:
	result = (~srcColor) | destColor;
	break;
      case GL_NAND:
	result = ~(srcColor & destColor);
	break;
      case GL_SET:
	result = ~0;
	break;
    }
    return result & mask;
}

static long Test(GLfloat max, GLenum op)
{
    char tmp[40];
    GLfloat buf;
    GLuint trueResult, result, mask;
    GLint srcColor, destColor; 
    GLint x, y, m;

    glGetIntegerv(GL_INDEX_BITS, &m);
    mask = (1 << m) - 1;

    glDisable(GL_LOGIC_OP);

    srcColor = (GLint)Random(0.0, max);
    destColor = (GLint)Random(0.0, max);

    glBegin(GL_POINTS);
	glIndexi(srcColor);
	glVertex2f(0.5, 0.5);
	glIndexi(destColor);
	glVertex2f(1.5, 0.5);
    glEnd();

    ReadScreen(0, 0, 1, 1, GL_COLOR_INDEX, &buf);
    srcColor = (GLint)buf;
    ReadScreen(1, 0, 1, 1, GL_COLOR_INDEX, &buf);
    destColor = (GLint)buf;

    trueResult = TrueResult(op, srcColor, destColor, mask);

    x = (GLint)Random(0.0, WINDSIZEX-1.0);
    y = (GLint)Random(0.0, WINDSIZEY-1.0);

    glBegin(GL_POINTS);
	glIndexi(destColor);
	glVertex2f((GLfloat)x+0.5, (GLfloat)y+0.5);
    glEnd();

    glEnable(GL_LOGIC_OP);
    glLogicOp(op);

    glBegin(GL_POINTS);
	glIndexi(srcColor);
	glVertex2f((GLfloat)x+0.5, (GLfloat)y+0.5);
    glEnd();

    ReadScreen(x, y, 1, 1, GL_COLOR_INDEX, &buf);
    result = (GLuint)buf;

    if (result != trueResult) {
	GetEnumName(op, tmp);
	StrMake(errStr, errStrFmt, tmp, srcColor, destColor, result,
		trueResult);
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }
    return NO_ERROR;
}

long LogicOpExec(void)
{
    GLfloat max;

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    glDisable(GL_DITHER);

    max = POW(2.0, (GLfloat)buffer.ciBits) - 1.0;
    if (Test(max, GL_AND) == ERROR) {
	return ERROR;
    }
    if (Test(max, GL_AND_INVERTED) == ERROR) {
	return ERROR;
    }
    if (Test(max, GL_AND_REVERSE) == ERROR) {
	return ERROR;
    }
    if (Test(max, GL_CLEAR) == ERROR) {
	return ERROR;
    }
    if (Test(max, GL_COPY) == ERROR) {
	return ERROR;
    }
    if (Test(max, GL_COPY_INVERTED) == ERROR) {
	return ERROR;
    }
    if (Test(max, GL_EQUIV) == ERROR) {
	return ERROR;
    }
    if (Test(max, GL_INVERT) == ERROR) {
	return ERROR;
    }
    if (Test(max, GL_NAND) == ERROR) {
	return ERROR;
    }
    if (Test(max, GL_NOOP) == ERROR) {
	return ERROR;
    }
    if (Test(max, GL_NOR) == ERROR) {
	return ERROR;
    }
    if (Test(max, GL_OR) == ERROR) {
	return ERROR;
    }
    if (Test(max, GL_OR_INVERTED) == ERROR) {
	return ERROR;
    }
    if (Test(max, GL_OR_REVERSE) == ERROR) {
	return ERROR;
    }
    if (Test(max, GL_SET) == ERROR) {
	return ERROR;
    }
    if (Test(max, GL_XOR) == ERROR) {
	return ERROR;
    }
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\linestip.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** linestip.c
** Line Stipple Test.
**
** Description -
**    Tests line stipple, in particular examining whether correct
**    fragments are hit with different factor values, whether
**    factor is properly clamped, whether the stipple resets with
**    a new line, and whether the stipple does not reset with
**    connected lines. The test include a polygon drawn in line
**    mode, checking that the stipple behaves as it would with a
**    series of connected lines.
**    
**    IMPORTANT ASSUMPTION: Even though the line specification
**    gives a lot of leeway, we assume horizontal and vertical
**    lines are straight. Endpoints are chosen to be on
**    the pixel center to allow for numerical errors yet still
**    hit the same fragment. Lines may be null-beginning or null-
**    terminated.  The test requires that first bit of the
**    stipple pattern be 'on' to test which type of line they are.
**    Data for loops are chosen so that the beginning of each
**    segment hits an 'on' bit.
**    
**    For all but one section of the test, all the lines are
**    horizontal or vertical. The one section of the test which
**    uses diagonal lines allows the full leeway provided by the
**    line rasterization description in the OpenGL
**    specification. The test searches for the first endpoint
**    within one fragment of the given endpoint coordinates, and
**    begins the stipple at the found point. From then on, it
**    searches for one line fragment per column (for x-major
**    lines).
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer.
**    Color requirements:
**        RGBA or color index mode. 2 colors.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**    Paths:
**        Allowed = Alpha, Blend, Depth, Fog, Logicop, Shade, Stencil, Stipple.
**        Not allowed = Alias.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"


static char errStr[160];
static char errStrFmt[160] = {
    "Error at position %d in the line from (%1.1f, %1.1f) to (%1.1f, %1.1f); expecting bit %d in pattern 0x%x."
};


static void FindEndpoint(GLint x, GLint y, GLint *newX, GLint *newY)
{
    GLfloat square[9];
    GLint i, j;

    /*
    ** Assumptions for this algorithm:
    **    The first bit of the stipple is on.
    **	  The first endpoint is to the lower left of the second endpoint.
    */
    ReadScreen(x-1, y-1, 3, 3, GL_AUTO_COLOR, square);
    if (AutoColorCompare(square[4], COLOR_ON) == GL_TRUE) {
	*newX = x;
	*newY = y;
	return;
    }
    for (i = 0; i < 3; i++) {
	for (j = 0; j < 3; j++) {
	    if (AutoColorCompare(square[3*i+j], COLOR_ON) == GL_TRUE) {
		*newX = x + j - 1;
		*newY = y + i - 1;
		return;
	    }
	}
    }
}

static long TestBuffer(GLfloat *buf, GLint x1, GLint y1, GLint x2, GLint y2,
		       long factor, GLushort pattern, long offset)
{
    long i, j, k, nBit, pos;
    GLint lowLeftX, lowLeftY, newX, newY;
    GLsizei dx, dy;
    long b, stippleOn;

    dx = (GLint)ABS(x2-x1);
    dy = (GLint)ABS(y2-y1);

    /*
    ** Handle horizontal and vertical lines.
    */
    if (dy < epsilon.zero) {
	/*
	** Check whether line has null beginning or null end.
	*/
	ReadScreen(x1, y1, 1, 1, GL_AUTO_COLOR, buf);
 	if (AutoColorCompare(buf[0], COLOR_ON) == GL_TRUE) {
	    lowLeftX = (x1 <= x2) ? x1 : (x2+1);
	} else {
	    lowLeftX = (x1 <= x2) ? (x1 + 1) : x2;
	}

	ReadScreen(lowLeftX, y1, dx, 1, GL_AUTO_COLOR, buf);
	for (i = 0; i < dx-1; i++) {
	    pos = (x1 <= x2) ? i : (dx - i - 1) + offset;
	    nBit = (pos / factor) % 16;
	    b = (pattern & (1 << nBit)) ? GL_TRUE : GL_FALSE;
	    if (b != AutoColorCompare(buf[i], COLOR_ON)) {
		StrMake(errStr, errStrFmt, pos, x1, y1, x2, y2, nBit, pattern);
		return ERROR;
	    }
	}
	return NO_ERROR;
    }

    if (dx < epsilon.zero) {
	/*
	** Check whether line has null beginning or null end.
	*/
	ReadScreen(x1, y1, 1, 1, GL_AUTO_COLOR, buf);
 	if (AutoColorCompare(buf[0], COLOR_ON) == GL_TRUE) {
	    lowLeftY = (y1 <= y2) ? y1 : (y2 + 1);
	} else {
	    lowLeftY = (y1 <= y2) ? (y1 + 1) : y2;
	}

	ReadScreen(x1, lowLeftY, 1, dy, GL_AUTO_COLOR, buf);
	for (i = 0; i < dy-1; i++) {
	    pos = (y1 <= y2) ? i : (dy - i - 1) + offset;
	    nBit = (pos / factor) % 16;
	    b = (pattern & (1 << nBit)) ? GL_TRUE : GL_FALSE;
	    if (b != AutoColorCompare(buf[i], COLOR_ON)) {
		StrMake(errStr, errStrFmt, x1, y1, x2, y2, pos, nBit, pattern);
		return ERROR;
	    }
	}
	return NO_ERROR;
    }

    /*
    ** First, find the endpoint which begins the stipple.
    ** Since rasterization allows some leeway, but requires one fragment
    ** per column (for x-major lines), we examine the entire column (or row)
    ** for the fragment of this line. Similarly, since the endpoints may
    ** be off by one, so the last fragment is not checked.
    */

    if (dx >= dy) {		
	FindEndpoint(x1, y1, &newX, &newY);
	x1 = newX;
	y1 = newY;

	lowLeftX = (x1 <= x2) ? x1 : (x2+1);
	lowLeftY = (y1 <= y2) ? y1 : y2;
	ReadScreen(lowLeftX, lowLeftY, dx, dy+1, GL_AUTO_COLOR, buf);
	for (i = 0; i < dx-1; i++) {
	    pos = (x1 <= x2) ? i : (dx - i - 1) + offset;
	    nBit = (pos / factor) % 16;
	    b = (pattern & (1 << nBit)) ? 1 : 0;

	    stippleOn = 0;
	    for (j = 0; j <= dy; j++) {
		k = j * dx + i;
		stippleOn |= AutoColorCompare(buf[k], COLOR_ON);
	    }
	    if (b != stippleOn) {
		StrMake(errStr, errStrFmt, x1, y1, x2, y2, pos, nBit, pattern);
		return ERROR;
	    }
	}
    } else {
	FindEndpoint(x1, y1, &newX, &newY);
	x1 = newX; y1 = newY;

	lowLeftX = (x1 <= x2) ? x1 : x2;
	lowLeftY = (y1 <= y2) ? y1 : (y2+1);
	ReadScreen(lowLeftX, lowLeftY, dx+1, dy, GL_AUTO_COLOR, buf);
	for (i = 0; i < dy-1; i++) {
	    pos = (y1 <= y2) ? i : (dy - i - 1) + offset;
	    nBit = (pos / factor) % 16;
	    b = (pattern & (1 << nBit)) ? 1 : 0;

	    stippleOn = 0;
	    for (j = 0; j <= dx; j++) {
		k = i * (dx + 1) + j;
		stippleOn |= AutoColorCompare(buf[k], COLOR_ON);
	    }
	    if (b != stippleOn) {
		StrMake(errStr, errStrFmt, x1, y1, x2, y2, pos, nBit, pattern);
		return ERROR;
	    }
	}
    }
    return NO_ERROR;
}

long LineStippleExec(void)
{
    GLfloat *buf;
    GLushort pattern;
    GLint x1, y1, x2, y2, x3, y3, x4, y4;
    GLint i, offset;

    buf = (GLfloat *)MALLOC(WINDSIZEX*WINDSIZEY*sizeof(GLfloat));

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    AutoClearColor(COLOR_OFF);
    AutoColor(COLOR_ON);
    glDisable(GL_DITHER);

    glClear(GL_COLOR_BUFFER_BIT);
    pattern = 0x550F;
    glEnable(GL_LINE_STIPPLE);
    x1 = 10;
    x2 = 90;

    /*
    ** Test different factor values.
    */

    for (i = 1; i < 9; i++) {
	glLineStipple(i, pattern);
	y1 = y2 = 10 + 10 * i;
	glBegin(GL_LINES);
	    glVertex2f(x1+0.5, y1+0.5);
	    glVertex2f(x2+0.5, y2+0.5);
	glEnd();
	if (TestBuffer(buf, x1, y1, x2, y2, i, pattern, 0) == ERROR) {
	    ErrorReport(__FILE__, __LINE__, errStr);
	    FREE(buf);
	    return ERROR;
	}
    }
    glFlush();

    /*
    ** Test x-major line at different angles, avoiding 45 degrees, since
    ** x/y major may be ambiguous. In order to find the beginning of the
    ** line, the test routine assumes that the first vertex is to the lower
    ** left of the second, and that the first bit of the stipple is on.
    */

    pattern = 0x550f;
    glLineStipple(1, pattern);
    for (i = 0; i < 9; i++) {
	x1 = (GLint)Round(Random(1.0, 50.0));
	y1 = (GLint)Round(Random(1.0, 50.0));
	x2 = (GLint)Round(Random(50.0, 99.0));
	y2 = (GLint)Round(Random(50.0, 99.0));
	glClear(GL_COLOR_BUFFER_BIT);
	glBegin(GL_LINES);
	    glVertex2f(x1+0.5, y1+0.5);
	    glVertex2f(x2+0.5, y2+0.5);
	glEnd();
	if (ABS((x2-x1)-(y2-y1)) < 1.0) {
	    continue;
	}
	if (TestBuffer(buf, x1, y1, x2, y2, 1, pattern, 0) == ERROR) {
	    ErrorReport(__FILE__, __LINE__, errStr);
	    FREE(buf);
	    return ERROR;
	}
    }

    /*
    ** Test that factor is clamped to (0, 256).
    */

    x1 = 5;
    x2 = 95;
    y1 = y2 = 5;
    glClear(GL_COLOR_BUFFER_BIT);
    glLineStipple(0, pattern);
    glBegin(GL_LINES);
	glVertex2f(x1+0.5, y1+0.5);
	glVertex2f(x2+0.5, y2+0.5);
    glEnd();
    if (TestBuffer(buf, x1, y1, x2, y2, 1, pattern, 0) == ERROR) {
	ErrorReport(__FILE__, __LINE__, errStr);
	FREE(buf);
	return ERROR;
    }
    glClear(GL_COLOR_BUFFER_BIT);
    glLineStipple(259, pattern);
    glBegin(GL_LINES);
	glVertex2f(x1+0.5, y1+0.5);
	glVertex2f(x2+0.5, y2+0.5);
    glEnd();
    if (TestBuffer(buf, x1, y1, x2, y2, 256, pattern, 0) == ERROR) {
	ErrorReport(__FILE__, __LINE__, errStr);
	FREE(buf);
	return ERROR;
    }

    /*
    ** Test that pattern restarts with new line.
    */

    glClear(GL_COLOR_BUFFER_BIT);
    glLineStipple(1, pattern);
    glBegin(GL_LINES);
	for (i = 0; i < 9; i++) {
	    glVertex2f(x1+0.5, y1+0.5+i*10.0);
	    glVertex2f(x2+0.5, y2+0.5+i*10.0);
	}
    glEnd();

    for (i = 0; i < 9; i++) {
	if (TestBuffer(buf, x1, y1+i*10, x2, y2+i*10, 1, pattern, 0) == ERROR) {
	    ErrorReport(__FILE__, __LINE__, errStr);
	    FREE(buf);
	    return ERROR;
	}
    }

    /*
    ** Test that pattern is not reset with connected lines.
    **
    ** The last segment is not tested, since lines may overwrite an
    ** end pixel if they change from x-major to y-major.
    **
    ** By testing the first segment, we also check that the stipple runs
    ** correctly from right to left.
    **
    ** Data are chosen so that each new segment starts with an 'on'
    ** stipple bit.  The TestBuffer routine require this.
    */

    x1 = 80; y1 = 80;
    x2 = 22; y2 = 80;
    x3 = 22; y3 = 56;
    x4 = 22; y4 = 8;
    glClear(GL_COLOR_BUFFER_BIT);
    glLineStipple(1, pattern);
    glBegin(GL_LINE_LOOP);
	glVertex2f(x1+0.5, y1+0.5);
	glVertex2f(x2+0.5, y2+0.5);
	glVertex2f(x3+0.5, y3+0.5);
	glVertex2f(x4+0.5, y4+0.5);
    glEnd();

    if (TestBuffer(buf, x1, y1, x2, y2, 1, pattern, 0) == ERROR) {
	ErrorReport(__FILE__, __LINE__, errStr);
	FREE(buf);
	return ERROR;
    }

    offset = (GLint)ABS(x2-x1);
    if (TestBuffer(buf, x2, y2, x3, y3, 1, pattern, offset) == ERROR) {
	ErrorReport(__FILE__, __LINE__, errStr);
	FREE(buf);
	return ERROR;
    }

    offset += (GLint)ABS(y3-y2);
    if (TestBuffer(buf, x3, y3, x4, y4, 1, pattern, offset) == ERROR) {
	ErrorReport(__FILE__, __LINE__, errStr);
	FREE(buf);
	return ERROR;
    }

    /*
    ** Repeat the connected lines test using a polygon. The behavior
    ** should be the same.
    */

    x1 = 80; y1 = 80;
    x2 = 22; y2 = 80;
    x3 = 22; y3 = 56;
    x4 = 44; y4 = 8;
    glClear(GL_COLOR_BUFFER_BIT);
    glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
    glLineStipple(1, pattern);
    glBegin(GL_POLYGON);
	glVertex2f(x1+0.5, y1+0.5);
	glVertex2f(x2+0.5, y2+0.5);
	glVertex2f(x3+0.5, y3+0.5);
	glVertex2f(x4+0.5, y4+0.5);
    glEnd();

    if (TestBuffer(buf, x1, y1, x2, y2, 1, pattern, 0) == ERROR) {
	ErrorReport(__FILE__, __LINE__, errStr);
	FREE(buf);
	return ERROR;
    }

    offset = (GLint)ABS(x2-x1);
    if (TestBuffer(buf, x2, y2, x3, y3, 1, pattern, offset) == ERROR) {
	ErrorReport(__FILE__, __LINE__, errStr);
	FREE(buf);
	return ERROR;
    }

    offset += (GLint)ABS(y3-y2);
    if (TestBuffer(buf, x3, y3, x4, y4, 1, pattern, offset) == ERROR) {
	ErrorReport(__FILE__, __LINE__, errStr);
	FREE(buf);
	return ERROR;
    }

    FREE(buf);
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\l_ac.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** l_ac.c
** Light - Attenuation Constant Test.
**
** Description -
**    This test examines the effect which varying the
**    Attenuation_Constants has on the color produced by
**    lighting. CI lighting differs from RGB lighting. This file
**    contains code for both tests. 8 lights and all 3
**    Attenuation_Constants are tested one at a time. The
**    distance of the object from the origin in eye-coordinates
**    is exactly 1.0. At each iteration the reciprocal of an
**    Attenuation_Constant is uniformly incremented, and the red
**    component or color index of a lit point is read and
**    stored.
**    
**    In RGB mode Ambient, Emissive, and Specular summands of the
**    equation are set to black, and the diffuse parameters are
**    set to fully saturated red. Successive results should
**    differ by 1.0 / nR where nR is the number of red shades.
**    Theoretically the differance between successive results
**    should be constant. If successive observed differences
**    differ by more than 0.25 / nR, the implementation is judged
**    to differ by too much from the correct graph of the
**    attenuation function.
**    
**    In color index mode the Ambient and Diffuse indices are set
**    to zero, and the Specular index is set to the largest color
**    index allowed by the implementation. Successive colors
**    should fall on integer values, should increase and should
**    differ from the theoretical value by no more than 3
**    indices. The difference between successive differences
**    should be more than 2.
**
** Error Explanation -
**    In RGB mode this test issues an error if the blue or green
**    channels are not completely "off", or if an expected
**    lighting result of (1, 0, 0) does not result in a
**    fully-saturated red object. An error is also issued if a
**    smaller Attenuation_Constant results in a less saturated
**    red, or if the differences between the results of two
**    successive attenuation settings differ by more than 0.25 /
**    nR.
**    
**    In color index mode this test issues an error if the value
**    read back is not an integer, if successive values decrease,
**    or if the difference between a value and the theoretical
**    result is more than 3 or if two successive differences
**    differ by more than 2.
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer.
**    Color requirements:
**        RGBA or color index mode. Full color.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**        Color, ci and zero epsilons, 0.25*color_epsilon.
**    Paths:
**        Allowed = Alpha, Blend, Depth, Logicop, Stencil, Stipple.
**        Not allowed = Alias, Dither, Fog, Shade.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"
#include "utilru.h"


typedef struct _atnConstRec {
    float step, numColor, lastValue, lastDelta, delta;
    GLenum light;
    long kIndex;
    GLfloat k[3], position[4];
} atnConstRec;


/******************************************************************************/

static void Set(void *data, float *ref)
{
    atnConstRec *ptr = (atnConstRec *)data;
    long i;

    for (i = 0; i < 3; i++) {
	ptr->k[i] = 0.0;
    }
    ptr->k[ptr->kIndex] = (*ref == 0.0) ? (1.0 / ptr->step) : (1.0 / *ref);

    glLightfv(ptr->light, GL_CONSTANT_ATTENUATION, &ptr->k[0]);
    glLightfv(ptr->light, GL_LINEAR_ATTENUATION, &ptr->k[1]);
    glLightfv(ptr->light, GL_QUADRATIC_ATTENUATION, &ptr->k[2]);

    glBegin(GL_POINTS);
	glVertex2f(0.5, 0.5);
    glEnd();

    *ref += ptr->step;
}

/******************************************************************************/

static void InitRGB(void *data)
{
    atnConstRec *ptr = (atnConstRec *)data;
    GLfloat buf[4];
    float step;
    GLenum i;

    ptr->lastValue = -1.0;
    ptr->lastDelta = -2.0;

    step = (machine.pathLevel == 0) ? 4.0 : 2.0;
    ptr->delta = 1.0 / (POW(2.0, (float)buffer.colorBits[0]) - 1.0);
    ptr->step = ptr->delta / step;

    for (i = GL_LIGHT0; i <= GL_LIGHT7; i++) {
	glDisable(i);
    }
    glEnable(ptr->light);

    ptr->position[0] = 0.5;
    ptr->position[1] = 0.5;
    ptr->position[2] = 1.0;
    ptr->position[3] = 1.0;
    glLightfv(ptr->light, GL_POSITION, ptr->position);

    ptr->k[0] = 0.0;
    ptr->k[1] = 0.0;
    ptr->k[2] = 0.0;

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = 1.0;
    glNormal3fv(buf);

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = 0.0;
    buf[3] = 1.0;
    glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, buf);

    buf[0] = 1.0;
    buf[1] = 0.0;
    buf[2] = 0.0;
    buf[3] = 1.0;
    glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, buf);

    buf[0] = 1.0;
    buf[1] = 1.0;
    buf[2] = 1.0;
    buf[3] = 1.0;
    glLightfv(ptr->light, GL_DIFFUSE, buf);
}

static long TestRGB(void *data, float ref)
{
    atnConstRec *ptr = (atnConstRec *)data;
    char str[240];
    GLfloat buf[3]; 
    float value, delta;
    long i;

    ReadScreen(0, 0, 1, 1, GL_RGB, buf);

    for (i = 1; i < 3; i++) {
	if (buf[i] != 0.0) {
	    ColorError_RGBZero(str, 0, buf);
	    ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
    }

    value = buf[0];
    if (ptr->lastDelta == -2.0) {
	ptr->lastDelta = -1.0;
	ptr->lastValue = value;
    } else if (ptr->lastDelta == -1.0) {
	if (value < ptr->lastValue) {
	    ColorError_RGBMonotonic(str, 0, value, ptr->lastValue);
	    ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	if (ABS(delta) > epsilon.zero) {
	    if (ABS(delta-ptr->delta) > 0.25*epsilon.color[0]) {
		ColorError_RGBStep(str, 0, delta, ptr->delta);
		ErrorReport(__FILE__, __LINE__, str);
		return ERROR;
	    }
	    ptr->lastDelta = delta;
	}
    } else {
	if (value < ptr->lastValue) {
	    ColorError_RGBMonotonic(str, 0, value, ptr->lastValue);
	    ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	if (ABS(delta) > epsilon.zero) {
	    if (ABS(delta-ptr->delta) >  0.25*epsilon.color[0]) {
		ColorError_RGBStep(str, 0, delta, ptr->delta);
		ErrorReport(__FILE__, __LINE__, str);
		return ERROR;
	    }
	    if (ABS(delta-ptr->lastDelta) > epsilon.zero) {
		ColorError_RGBDelta(str, 0, delta, ptr->lastDelta);
		ErrorReport(__FILE__, __LINE__, str);
		return ERROR;
	    }
	    ptr->lastDelta = delta;
	}
    }

    if (ref >= 1.0 && ABS(value-1.0) > epsilon.zero) {
	ColorError_RGBClamp(str, 0, value);
	ErrorReport(__FILE__, __LINE__, str);
	return ERROR;
    }

    return NO_ERROR;
}

long AtnConstRGBExec(void)
{
    atnConstRec data;
    long max;

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glDisable(GL_DITHER);
    glEnable(GL_LIGHTING);

    max = (machine.pathLevel == 0) ? GL_LIGHT7 : GL_LIGHT0;
    for (data.light = GL_LIGHT0; data.light <= max; data.light++) {
	for (data.kIndex = 0; data.kIndex < 3; data.kIndex++) {
	    if (RampUtil(0.0, 1.0, InitRGB, Set, TestRGB, &data) == ERROR) {
		return ERROR;
	    }
	}
    }
    return NO_ERROR;
}

/*****************************************************************************/

static void InitCI(void *data)
{
    atnConstRec *ptr = (atnConstRec *)data;
    GLfloat buf[4];
    GLenum i;

    ptr->lastValue = -1.0;
    ptr->lastDelta = -2.0;

    if (machine.pathLevel == 0) {
	ptr->step = 0.5 / ptr->numColor;
    } else {
	ptr->step = 0.25;
    }

    for (i = GL_LIGHT0; i <= GL_LIGHT7; i++) {
	glDisable(i);
    }
    glEnable(ptr->light);

    ptr->position[0] = 0.5;
    ptr->position[1] = 0.5;
    ptr->position[2] = 1.0;
    ptr->position[3] = 1.0;
    glLightfv(ptr->light, GL_POSITION, ptr->position);

    ptr->k[0] = 0.0;
    ptr->k[1] = 0.0;
    ptr->k[2] = 0.0;

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = 1.0;
    glNormal3fv(buf);

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = ptr->numColor;
    glMaterialfv(GL_FRONT_AND_BACK, GL_COLOR_INDEXES, buf);

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = 0.0;
    buf[3] = 0.0;
    glLightfv(ptr->light, GL_DIFFUSE, buf);

    buf[0] = 1.0;
    buf[1] = 1.0;
    buf[2] = 1.0;
    buf[3] = 0.0;
    glLightfv(ptr->light, GL_SPECULAR, buf);
}

static long TestCI(void *data, float ref)
{
    atnConstRec *ptr = (atnConstRec *)data;
    char str[240];
    GLfloat value;
    float expected, frac, delta;

    ReadScreen(0, 0, 1, 1, GL_COLOR_INDEX, &value);

    frac = ABS(value-(float)((int)value));
    if (frac > epsilon.zero && ABS(frac-1.0) > epsilon.zero) {
	ColorError_CIFrac(str, value);
	ErrorReport(__FILE__, __LINE__, str);
	return ERROR;
    }

    if (ptr->lastValue == -1.0) {
	ptr->lastValue = value;
    } else {
	if (value < ptr->lastValue) {
	    ColorError_CIMonotonic(str, value, ptr->lastValue);
	    ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
	expected = (float)Round(2.0*ref*ptr->numColor) / 2.0;

	if (ABS(value-expected) > (3.0*epsilon.ci+epsilon.zero)) {
	    ColorError_CIBad(str, value, expected);
	    ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	if (ABS(delta) > epsilon.zero) {
	    if (ABS(delta) >= 2.0 && machine.pathLevel == 0) {
		ColorError_CIStep(str, delta);
		ErrorReport(__FILE__, __LINE__, str);
		return ERROR;
	    }
	}
    }

    if (ref >= 1.0 && value < ptr->numColor) {
	ColorError_CIClamp(str, ptr->numColor, value);
	ErrorReport(__FILE__, __LINE__, str);
	return ERROR;
    }
    return NO_ERROR;
}

long AtnConstCIExec(void)
{
    atnConstRec data;
    float start, end, frac;
    long max;

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glDisable(GL_DITHER);
    glEnable(GL_LIGHTING);

    data.numColor = POW(2.0, (float)buffer.ciBits) - 1.0;
    max = (machine.pathLevel == 0) ? GL_LIGHT7 : GL_LIGHT0;
    for (data.light = GL_LIGHT0; data.light <= max; data.light++) {
	for (data.kIndex = 0; data.kIndex < 3; data.kIndex++) {
	    if (data.numColor < 4096.0 || (machine.pathLevel != 0)) {
		if (RampUtil(0.0, 1.0, InitCI, Set, TestCI, &data) == ERROR) {
		    return ERROR;
		}
	    } else {
		start = 0.5 / data.numColor;
                frac = POW(2.0, (float)(8-buffer.ciBits));
                if (RampUtil(start, frac, InitCI, Set, TestCI,
                             &data) == ERROR) {
                    return ERROR;
                }
                start = 0.5 - frac;
                end = 0.5 + frac;
                if (RampUtil(start, end, InitCI, Set, TestCI, &data) == ERROR) {
                    return ERROR;
                }
                start = 1.0 - frac;
                if (RampUtil(start, 1.0, InitCI, Set, TestCI, &data) == ERROR) {
                    return ERROR;
                }
	    }
	}
    }
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\l_ap.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** l_ap.c
** Light - Attenuation Position Test.
**
** Description -
**    This test analyses the effect that varying the
**    Light_Position has on the color produced by lighting, by
**    way of its effect on the Attenuation factor. CI lighting
**    differs from RGB lighting. This file contains code for both
**    tests. To analyse only this one parameter, the Specular
**    lighting factor is set to a completely saturated red. Other
**    lighting parameters are chosen so that the Diffuse,
**    Ambient, and Emissive summands of the RGB or CI lighting
**    are set to zero. The linear and attenuation constants are
**    set so that one is zero and the other is 1.0, and then the
**    test is repeated with the constant's settings switched. The
**    constant Attenuation_Constant, k0, is always 0.0.
**    
**    These settings form a restriction of the lighting equation
**    to a function of Light_Position. f(Light_Position) ->
**    color. This function is analysed for monotonicity,
**    endpoints, and variation. In RGB mode only the red color
**    channel is tested. The implementation fails if any other
**    color channel is not black. In both modes one light is
**    enabled at a time, all individual lights are tested.
**    
**    The test repeatedly renders and reads the same point at the
**    lower left corner of the screen, decrementing the third
**    component of the Light_Position in such a way that the
**    attenuation factor should increase by a uniform amount. The
**    other two components are set equal to the corresponding
**    coordinates of the eye position of the rendered point. This
**    controls the concavity of this restriction of the lighting
**    function to Light_Position.
**    
**    In RGB mode the uniformity of this change is tested, and
**    the implementation fails if consecutive changes are too
**    different. (thisDelta - lastDelta) > 1/4 shade. The
**    observed results are also checked for monotonicity. When
**    Light_Position[2] reaches 1.0, the color is finally checked
**    to insure that the point has rendered with a fully
**    saturated red.
**    
**    In CI mode a check is made to ensure that the observed
**    index reaches its max. The observed shade is compared to
**    the theoretical value expected for each setting of
**    Light_Position. If the theoretical value is more than 4
**    indices away from the observed index, the test fails. The
**    observed value must be an integer, and the difference
**    between successive observances must be less than 2.
**
** Error Explanation -
**    RGB mode: other_color > 0.0.
**    RGB mode: value < lastValue.
**    RGB mode: maxObserved < 1.0.
**    RGB mode: (thisDelta - lastDelta) > 1/4 shade.
**    CI mode: index not an integer.
**    CI mode: (observed - expected) > 4.0.
**    CI mode: observedMax < numColor.
**    CI mode: delta > 2.0.
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer.
**    Color requirements:
**        RGBA or color index mode. Full color.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**        Color, ci and zero epsilons, 0.25*color_epsilon.
**    Paths:
**        Allowed = Alpha, Blend, Depth, Logicop, Stencil, Stipple.
**        Not allowed = Alias, Dither, Fog, Shade.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"
#include "utilru.h"


typedef struct _atnPosRec {
    float step, numColor, lastValue, lastDelta, delta;
    GLenum light;
    long kIndex;
    GLfloat k[3], position[4];
} atnPosRec;


/*****************************************************************************/

static void Set(void *data, float *ref)
{
    atnPosRec *ptr = (atnPosRec *)data;

    ptr->position[0] = 0.5;
    ptr->position[1] = 0.5;

    switch (ptr->kIndex) {
      case 1:
	ptr->position[2] = (*ref == 0.0) ? (1.0 / ptr->step) : (1.0 / *ref);
	ptr->k[1] = 1.0;
	ptr->k[2] = 0.0;
	break;
      case 2:
	ptr->position[2] = (*ref == 0.0) ? (1.0 / SQRT(ptr->step)) :
					   (1.0 / SQRT(*ref));
	ptr->k[1] = 0.0;
	ptr->k[2] = 1.0;
	break;
    }

    glLightfv(ptr->light, GL_POSITION, ptr->position);
    glLightfv(ptr->light, GL_LINEAR_ATTENUATION, &ptr->k[1]);
    glLightfv(ptr->light, GL_QUADRATIC_ATTENUATION, &ptr->k[2]);

    glBegin(GL_POINTS);
	glVertex2f(0.5, 0.5);
    glEnd();

    *ref += ptr->step;
}

/******************************************************************************/

static void InitRGB(void *data)
{
    atnPosRec *ptr = (atnPosRec *)data;
    GLfloat buf[4];
    float step;
    GLenum i;

    for (i = GL_LIGHT0; i <= GL_LIGHT7; i++) {
	glDisable(i);
    }
    glEnable(ptr->light);

    step = (machine.pathLevel == 0) ? 4.0 : 2.0;
    ptr->delta = 1.0 / (POW(2.0, (float)buffer.colorBits[0]) - 1.0);
    ptr->step = ptr->delta / step;
    ptr->lastValue = -1.0;
    ptr->lastDelta = -2.0;

    ptr->position[0] = 0.5;
    ptr->position[1] = 0.5;
    ptr->position[2] = 1.0;
    ptr->position[3] = 1.0;

    ptr->k[0] = 0.0;
    ptr->k[1] = 0.0;
    ptr->k[2] = 0.0;

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = 1.0;
    glNormal3fv(buf);

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = 0.0;
    buf[3] = 1.0;
    glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, buf);

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = 0.0;
    buf[3] = 1.0;
    glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, buf);

    buf[0] = 1.0;
    buf[1] = 0.0;
    buf[2] = 0.0;
    buf[3] = 1.0;
    glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, buf);

    buf[0] = 1.0;
    buf[1] = 1.0;
    buf[2] = 1.0;
    buf[3] = 1.0;
    glLightfv(ptr->light, GL_SPECULAR, buf);

    buf[0] = 0.0;
    glLightfv(ptr->light, GL_CONSTANT_ATTENUATION, buf);
}

static long TestRGB(void *data, float ref)
{
    atnPosRec *ptr = (atnPosRec *)data;
    char str[240];
    GLfloat buf[3]; 
    float value, delta;
    long i;

    ReadScreen(0, 0, 1, 1, GL_RGB, buf);

    for (i = 1; i < 3; i++) {
	if (buf[i] != 0.0) {
            ColorError_RGBZero(str, 0, buf);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
    }

    value = buf[0];
    if (ptr->lastDelta == -2.0) {
	ptr->lastDelta = -1.0;
	ptr->lastValue = value;
    } else if (ptr->lastDelta == -1.0) {
	if (value < ptr->lastValue) {
            ColorError_RGBMonotonic(str, 0, value, ptr->lastValue);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	if (ABS(delta) > epsilon.zero) {
	    if (ABS(delta-ptr->delta) > 0.25*epsilon.color[0]) {
                ColorError_RGBStep(str, 0, delta, ptr->delta);
                ErrorReport(__FILE__, __LINE__, str);
		return ERROR;
	    }
	    ptr->lastDelta = delta;
	}
    } else {
	if (value < ptr->lastValue) {
            ColorError_RGBMonotonic(str, 0, value, ptr->lastValue);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	if (ABS(delta) > epsilon.zero) {
	    if (ABS(delta-ptr->delta) > 0.25*epsilon.color[0]) {
                ColorError_RGBStep(str, 0, delta, ptr->delta);
                ErrorReport(__FILE__, __LINE__, str);
		return ERROR;
	    }
	    if (ABS(delta-ptr->lastDelta) > epsilon.zero) {
                ColorError_RGBDelta(str, 0, delta, ptr->lastDelta);
                ErrorReport(__FILE__, __LINE__, str);
		return ERROR;
	    }
	    ptr->lastDelta = delta;
	}
    }

    if (ref >= 1.0 && ABS(value-1.0) > epsilon.zero) {
        ColorError_RGBClamp(str, 0, value);
        ErrorReport(__FILE__, __LINE__, str);
	return ERROR;
    }

    return NO_ERROR;
}

long AtnPosRGBExec(void)
{
    atnPosRec data;
    long max;

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glDisable(GL_DITHER);
    glEnable(GL_LIGHTING);

    max = (machine.pathLevel == 0) ? GL_LIGHT7 : GL_LIGHT0;
    for (data.light = GL_LIGHT0; data.light <= max; data.light++) {
	for (data.kIndex = 1; data.kIndex < 3; data.kIndex++) {
	    if (RampUtil(0.0, 1.0, InitRGB, Set, TestRGB, &data) == ERROR) {
		return ERROR;
	    }
	}
    }
    return NO_ERROR;
}

/******************************************************************************/

static void InitCI(void *data)
{
    atnPosRec *ptr = (atnPosRec *)data;
    GLfloat buf[4];
    GLenum i;

    ptr->lastValue = -1.0;
    ptr->lastDelta = -2.0;

    if (machine.pathLevel == 0) {
	ptr->step = 0.5 / ptr->numColor;
    } else {
	ptr->step = 0.25;
    }

    for (i = GL_LIGHT0; i <= GL_LIGHT7; i++) {
	glDisable(i);
    }
    glEnable(ptr->light);

    ptr->position[0] = 0.5;
    ptr->position[1] = 0.5;
    ptr->position[2] = 1.0;
    ptr->position[3] = 1.0;

    ptr->k[0] = 0.0;
    ptr->k[1] = 0.0;
    ptr->k[2] = 0.0;

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = 1.0;
    glNormal3fv(buf);

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = ptr->numColor;
    glMaterialfv(GL_FRONT_AND_BACK, GL_COLOR_INDEXES, buf);

    buf[0] = 1.0;
    buf[1] = 1.0;
    buf[2] = 1.0;
    buf[3] = 0.0;
    glLightfv(ptr->light, GL_SPECULAR, buf);

    buf[0] = 0.0;
    glLightfv(ptr->light, GL_CONSTANT_ATTENUATION, buf);
}

static long TestCI(void *data, float ref)
{
    atnPosRec *ptr = (atnPosRec *)data;
    char str[240];
    GLfloat value;
    float expected, frac, delta;

    ReadScreen(0, 0, 1, 1, GL_COLOR_INDEX, &value);

    frac = ABS(value-(float)((int)value));
    if (frac > epsilon.zero && ABS(frac-1.0) > epsilon.zero) {
        ColorError_CIFrac(str, value);
        ErrorReport(__FILE__, __LINE__, str);
	return ERROR;
    }

    if (ptr->lastValue == -1.0) {
	ptr->lastValue = value;
    } else {
	if (value < ptr->lastValue) {
            ColorError_CIMonotonic(str, value, ptr->lastValue);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
	expected = (float)Round(2.0 * ref * ptr->numColor) / 2.0;

	if (ABS(value-expected) > (4.0*epsilon.ci+epsilon.zero)) {
            ColorError_CIBad(str, value, expected);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	if (ABS(delta) > epsilon.zero) {
	    if (ABS(delta) >= 2.0 && machine.pathLevel == 0) {
                ColorError_CIStep(str, delta);
                ErrorReport(__FILE__, __LINE__, str);
		return ERROR;
	    }
	}
    }

    if (ref >= 1.0 && value < ptr->numColor) {
        ColorError_CIClamp(str, ptr->numColor, value);
        ErrorReport(__FILE__, __LINE__, str);
	return ERROR;
    }
    return NO_ERROR;
}

long AtnPosCIExec(void)
{
    atnPosRec data;
    float start, end, frac;
    long max;

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glDisable(GL_DITHER);
    glEnable(GL_LIGHTING);

    max = (machine.pathLevel == 0) ? GL_LIGHT7 : GL_LIGHT0;
    data.numColor = POW(2.0, (float)buffer.ciBits) - 1.0;
    for (data.light = GL_LIGHT0; data.light <= max; data.light++) {
	for (data.kIndex = 1; data.kIndex < 3; data.kIndex++) {
	    if (data.numColor < 4096.0 || (machine.pathLevel != 0)) {
		if (RampUtil(0.0, 1.0, InitCI, Set, TestCI, &data) == ERROR) {
		    return ERROR;
		}
	    } else {
		start = 0.5 / data.numColor;
                frac = POW(2.0, (float)(8-buffer.ciBits));
                if (RampUtil(start, frac, InitCI, Set, TestCI,
                             &data) == ERROR) {
                    return ERROR;
                }
                start = 0.5 - frac;
                end = 0.5 + frac;
                if (RampUtil(start, end, InitCI, Set, TestCI, &data) == ERROR) {
                    return ERROR;
                }
                start = 1.0 - frac;
                if (RampUtil(start, 1.0, InitCI, Set, TestCI, &data) == ERROR) {
                    return ERROR;
                }
	    }
	}
    }
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\l_as.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** l_as.c
** Light - Ambient Scene Test.
**
** Description -
**    This test analyses the effect that varying the
**    Ambient_Scene parameter has on the color produced by
**    lighting. This parameter is set with
**    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, ... ). It is only
**    tested in RGB mode. A single lit point is rendered in the
**    lower left corner of the screen, and the color of this
**    point is retrieved using glReadPixels(). To analyse only
**    this one parameter the Emissive color is set to (0, 0, 0,
**    1), and all of the lights are disabled. The
**    Ambient_Material is set to (1, 1, 1, 1). This forms a
**    restriction of the lighting equation to a function of the
**    Ambient_Scene f(Ambient_scene) -> color. Except for the
**    quantization of color this restriction should be the
**    identity. This function is analysed for monotonicity,
**    endpoints values, and variation. All color channels are
**    tested one at a time. The implementation fails if any
**    channel other than the one being tested is non-zero.
**    
**    The test repeatedly renders and reads the same point,
**    uniformly incrementing the one color channel being tested
**    of the Ambient_Scene parameter. This controls the linearity
**    of this restriction of the lighting function. he uniformity
**    of change is tested and the implementation fails if
**    consecutive changes are too different. (thisDelta -
**    lastDelta) > 1/4 shade. The observed restricted function
**    is also checked for monotonicity. When the Ambient_Scene
**    reaches 1.0, the tested color channel is checked to insure
**    that the point has been rendered with a saturation of 1.0.
**
** Error Explanation -
**    other_color > 0.0.
**    value < lastValue.
**    maxObserved < 1.0.
**    (thisDelta - lastDelta) > 1/4 shade.
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer.
**    Color requirements:
**        RGBA mode. Full color.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**        Color and zero epsilons, 0.25*color_epsilon.
**    Paths:
**        Allowed = Alpha, Blend, Depth, Logicop, Stencil, Stipple.
**        Not allowed = Alias, Dither, Fog, Shade.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"
#include "utilru.h"


typedef struct _ambSceneRec {
    long color;
    float step, lastValue, lastDelta, delta;
    GLfloat light_ambient[4];
} ambSceneRec;


static void Init(void *data)
{
    ambSceneRec *ptr = (ambSceneRec *)data;
    GLfloat buf[4];
    float step;
    GLenum i;

    ptr->lastValue = -1.0;
    ptr->lastDelta = -2.0;

    step = (machine.pathLevel == 0) ? 4.0 : 2.0;
    ptr->delta = 1.0 / (POW(2.0, (float)buffer.colorBits[ptr->color]) - 1.0); 
    ptr->step = ptr->delta / step;

    for (i = GL_LIGHT0; i <= GL_LIGHT7; i++) {
	glDisable(i);
    }

    ptr->light_ambient[0] = 0.0;
    ptr->light_ambient[1] = 0.0;
    ptr->light_ambient[2] = 0.0;
    ptr->light_ambient[3] = 1.0;

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = 0.0;
    buf[3] = 1.0;
    glLightfv(GL_LIGHT0, GL_DIFFUSE, buf);

    buf[0] = 1.0;
    buf[1] = 1.0;
    buf[2] = 1.0;
    buf[3] = 1.0;
    glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, buf);

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = 0.0;
    buf[3] = 1.0;
    glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, buf);
}

static void Set(void *data, float *ref)
{
    ambSceneRec *ptr = (ambSceneRec *)data;

    ptr->light_ambient[ptr->color] = *ref;
    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, ptr->light_ambient);

    glBegin(GL_POINTS);
	glVertex2f(0.5, 0.5);
    glEnd();

    *ref += ptr->step;
}

static long Test(void *data, float ref)
{
    ambSceneRec *ptr = (ambSceneRec *)data;
    char str[240];
    GLfloat buf[3]; 
    float value, delta;
    long i;

    ReadScreen(0, 0, 1, 1, GL_RGB, buf);

    for (i = 0; i < 3; i++) {
        if (buf[i] != 0.0 && i != ptr->color) {
            ColorError_RGBZero(str, ptr->color, buf);
            ErrorReport(__FILE__, __LINE__, str);
            return ERROR;
	}
    }

    value = buf[ptr->color];
    if (ptr->lastDelta == -2.0) {
	ptr->lastDelta = -1.0;
	ptr->lastValue = value;
    } else if (ptr->lastDelta == -1.0) {
	if (value < ptr->lastValue) {
            ColorError_RGBMonotonic(str, ptr->color, value, ptr->lastValue);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	if (ABS(delta) > epsilon.zero) {
	    if (ABS(delta-ptr->delta) > 0.25*epsilon.color[ptr->color]) {
                ColorError_RGBStep(str, ptr->color, delta, ptr->delta);
                ErrorReport(__FILE__, __LINE__, str);
		return ERROR;
	    }
	    ptr->lastDelta = delta;
	}
    } else {
	if (value < ptr->lastValue) {
            ColorError_RGBMonotonic(str, ptr->color, value, ptr->lastValue);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	if (ABS(delta) > epsilon.zero) {
	    if (ABS(delta-ptr->delta) > 0.25*epsilon.color[ptr->color]) {
                ColorError_RGBStep(str, ptr->color, delta, ptr->delta);
                ErrorReport(__FILE__, __LINE__, str);
		return ERROR;
	    }
	    if (ABS(delta-ptr->lastDelta) > epsilon.zero) {
                ColorError_RGBDelta(str, ptr->color, delta, ptr->lastDelta);
                ErrorReport(__FILE__, __LINE__, str);
		return ERROR;
	    }
	    ptr->lastDelta = delta;
	}
    }

    if (ref >= 1.0 && ABS(value-1.0) > epsilon.zero) {
        ColorError_RGBClamp(str, ptr->color, value);
        ErrorReport(__FILE__, __LINE__, str);
	return ERROR;
    }

    return NO_ERROR;
}

long AmbSceneExec(void)
{
    ambSceneRec data;
    long max;

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glDisable(GL_DITHER);
    glEnable(GL_LIGHTING);

    max = (machine.pathLevel == 0) ? 3 : 1;
    for (data.color = 0; data.color < max; data.color++) {
	if (RampUtil(0.0, 1.0, Init, Set, Test, &data) == ERROR) {
	    return ERROR;
	}
    }
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\l_dl.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** l_dl.c
** Light - Diffuse Light Test.
**
** Description -
**    This test analyses the effect that varying the
**    Diffuse_Light parameter has on the color produced by
**    lighting. CI lighting differs from RGB lighting. This file
**    contains code for both tests. A single lit point is
**    rendered in the lower left corner of the screen and the
**    color or color index of this point is retrieved using
**    glReadPixels(). To analyse only this one parameter,
**    parameters are chosen so that the Attenuation factor, the
**    SpotLight factor, the Light_Direction factor are all 1.0.
**    In RGB mode the Specular, Emissive, and Ambient summands in
**    the lighting equation are 0.0 and the Diffuse_Material is
**    set to (1, 1, 1, 1). In CI mode s_prime is set to 0.0, and
**    the Ambient_Material is set to 0.0.
**    
**    This forms a restriction of the lighting equation so that
**    the output color is equal to a multiple of the
**    Diffuse_Light setting. In Ci mode this is done by setting
**    all three colors of Diffuse_Light to the same value. This
**    function's output is analysed for monotonicity, endpoints,
**    and variation. In RGB mode all color channels are tested
**    one at a time. The implementation fails if any color
**    channel, besides the one being tested, is not 0.0. In both
**    modes at most one light is enabled at a time. All
**    individual lights are tested.
**    
**    The test repeatedly renders and reads the same point,
**    linearly incrementing Diffuse_Light. In RGB mode the
**    uniformity of this change in observed color is tested, and
**    the implementation fails if consecutive changes are too
**    different. (thisDelta - lastDelta) > 1/4 shade. The
**    observed results are also checked for monotonicity. When
**    Diffuse_Light reaches 1.0, the observed color is checked to
**    insure that it is rendered with a saturation of 1.0.
**    
**    In CI mode a check is made to ensure that the observed
**    index reaches maxIndex. The observed shade is compared to
**    the theoretical value expected for each setting of
**    Diffuse_Light. The observed value must be an integer, and
**    the difference between successive observances must be less
**    than 2. The observed index is also compared to the
**    theoretical value expected for each setting of
**    Diffuse_Light. If the theoretical value is more than 3
**    indices away from the observed index the test fails.
**
** Error Explanation -
**    RGB mode: other_color > 0.0.
**    RGB mode: value < lastValue.
**    RGB mode: maxObserved < 1.0. 
**    RGB mode: (thisDelta - lastDelta) > 1/4 shade.
**    CI mode: (fractional index) != 0.0.
**    CI mode: (observed - expected) > 3.0.
**    CI mode: observedMax < numColor.
**    CI mode: delta > 2.0.
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer.
**    Color requirements:
**        RGBA or color index mode. Full color.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**        Color, ci and zero epsilons, 0.25*color_epsilon.
**    Paths:
**        Allowed = Alpha, Blend, Depth, Logicop, Stencil, Stipple.
**        Not allowed = Alias, Dither, Fog, Shade.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"
#include "utilru.h"


typedef struct _difLightRec {
    long color;
    float step, lastValue, lastDelta, numColor, delta;
    GLenum light;
    GLfloat light_diffuse[4], position[4];
} difLightRec;


/******************************************************************************/

static void InitRGB(void *data)
{
    difLightRec *ptr = (difLightRec *)data;
    GLfloat buf[4];
    float step;
    GLenum i;

    ptr->lastValue = -1.0;
    ptr->lastDelta = -2.0;

    step = (machine.pathLevel == 0) ? 4.0 : 2.0;
    ptr->delta = 1.0 / (POW(2.0, (float)buffer.colorBits[ptr->color]) - 1.0);
    ptr->step = ptr->delta / step;

    for (i = GL_LIGHT0; i <= GL_LIGHT7; i++) {
	glDisable(i);
    }
    glEnable(ptr->light);

    glNormal3f(0.0, 0.0, 1.0);

    ptr->light_diffuse[0] = 0.0;
    ptr->light_diffuse[1] = 0.0;
    ptr->light_diffuse[2] = 0.0;
    ptr->light_diffuse[3] = 1.0;

    ptr->position[0] = 0.5;
    ptr->position[1] = 0.5;
    ptr->position[2] = 1.0;
    ptr->position[3] = 1.0;
    glLightfv(ptr->light, GL_POSITION, ptr->position);

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = 0.0;
    buf[3] = 1.0;
    glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, buf);

    buf[0] = 1.0;
    buf[1] = 1.0;
    buf[2] = 1.0;
    buf[3] = 1.0;
    glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, buf);
}

static void SetRGB(void *data, float *ref)
{
    difLightRec *ptr = (difLightRec *)data;

    ptr->light_diffuse[ptr->color] = *ref;
    glLightfv(ptr->light, GL_DIFFUSE, ptr->light_diffuse);

    glBegin(GL_POINTS);
	glVertex2f(0.5, 0.5);
    glEnd();

    *ref += ptr->step;
}

static long TestRGB(void *data, float ref)
{
    difLightRec *ptr = (difLightRec *)data;
    char str[240];
    GLfloat buf[3]; 
    float value, delta;
    long i;

    ReadScreen(0, 0, 1, 1, GL_RGB, buf);

    for (i = 0; i < 3; i++) {
        if (buf[i] != 0.0 && i != ptr->color) {
            ColorError_RGBZero(str, ptr->color, buf);
            ErrorReport(__FILE__, __LINE__, str);
            return ERROR;
	}
    }

    value = buf[ptr->color];
    if (ptr->lastDelta == -2.0) {
	ptr->lastDelta = -1.0;
	ptr->lastValue = value;
    } else if (ptr->lastDelta == -1.0) {
	if (value < ptr->lastValue) {
            ColorError_RGBMonotonic(str, ptr->color, value, ptr->lastValue);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	if (ABS(delta) > epsilon.zero) {
	    if (ABS(delta-ptr->delta) > 0.25*epsilon.color[ptr->color]) {
                ColorError_RGBStep(str, ptr->color, delta, ptr->delta);
                ErrorReport(__FILE__, __LINE__, str);
		return ERROR;
	    }
	    ptr->lastDelta = delta;
	}
    } else {
	if (value < ptr->lastValue) {
            ColorError_RGBMonotonic(str, ptr->color, value, ptr->lastValue);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	if (ABS(delta) > epsilon.zero) {
	    if (ABS(delta-ptr->delta) > 0.25*epsilon.color[ptr->color]) {
                ColorError_RGBStep(str, ptr->color, delta, ptr->delta);
                ErrorReport(__FILE__, __LINE__, str);
		return ERROR;
	    }
	    if (ABS(delta-ptr->lastDelta) > epsilon.zero) {
                ColorError_RGBDelta(str, ptr->color, delta, ptr->lastDelta);
                ErrorReport(__FILE__, __LINE__, str);
		return ERROR;
	    }
	    ptr->lastDelta = delta;
	}
    }

    if (ref >= 1.0 && ABS(value-1.0) > epsilon.zero) {
        ColorError_RGBClamp(str, ptr->color, value);
        ErrorReport(__FILE__, __LINE__, str);
	return ERROR;
    }

    return NO_ERROR;
}

long DifLightRGBExec(void)
{
    difLightRec data;
    long max1, max2;

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glDisable(GL_DITHER);
    glEnable(GL_LIGHTING);

    max1 = (machine.pathLevel == 0) ? GL_LIGHT7 : GL_LIGHT0;
    max2 = (machine.pathLevel == 0) ? 3 : 1;
    for (data.light = GL_LIGHT0; data.light <= max1; data.light++) {
	for (data.color = 0; data.color < max2; data.color++) {
	    if (RampUtil(0.0, 1.0, InitRGB, SetRGB, TestRGB, &data) == ERROR) {
		return ERROR;
	    }
	}
    }
    return NO_ERROR;
}

/******************************************************************************/

static void InitCI(void *data)
{
    difLightRec *ptr = (difLightRec *)data;
    GLfloat buf[4];
    GLenum i;

    ptr->lastValue = -1.0;
    ptr->lastDelta = -2.0;

    if (machine.pathLevel == 0) {
	ptr->step = 0.5 / ptr->numColor;
    } else {
	ptr->step = 0.25;
    }

    for (i = GL_LIGHT0; i <= GL_LIGHT7; i++) {
	glDisable(i);
    }
    glEnable(ptr->light);

    ptr->light_diffuse[0] = 0.0;
    ptr->light_diffuse[1] = 0.0;
    ptr->light_diffuse[2] = 0.0;
    ptr->light_diffuse[3] = 1.0;

    /*
    ** Default spot angle is 180.0 so spot should be constant one.
    ** Default attenuation constants are 1.0, 0.0, 0.0 so att should be 1.0.
    */
    ptr->position[0] = 0.5;
    ptr->position[1] = 0.5;
    ptr->position[2] = 1.0;
    ptr->position[3] = 1.0;
    glLightfv(ptr->light, GL_POSITION, ptr->position);


    buf[0] = 0.0;
    buf[1] = ptr->numColor;
    buf[2] = ptr->numColor;
    glMaterialfv(GL_FRONT_AND_BACK, GL_COLOR_INDEXES, buf);

    /*
    ** The values below should make s' equal to 0.0.
    ** Alpha for specular light is not used. See if wierd
    ** value breaks something.
    */

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = 0.0;
    buf[3] = PI;
    glLightfv(ptr->light, GL_SPECULAR, buf);

    glNormal3f(0.0, 0.0, 1.0);
}

static void SetCI(void *data, float *ref)
{
    difLightRec *ptr = (difLightRec *)data;
    long i;

    for (i = 0; i < 3; i++) {
	ptr->light_diffuse[i] = *ref;
    }
    glLightfv(ptr->light, GL_DIFFUSE, ptr->light_diffuse);

    glBegin(GL_POINTS);
	glVertex2f(0.5, 0.5);
    glEnd();

    *ref += ptr->step;
}

static long TestCI(void *data, float ref)
{
    difLightRec *ptr = (difLightRec *)data;
    char str[240];
    GLfloat value;
    float expected, frac, delta;

    ReadScreen(0, 0, 1, 1, GL_COLOR_INDEX, &value);

    frac = ABS(value-(float)((int)value));
    if (frac > epsilon.zero && ABS(frac-1.0) > epsilon.zero) {
        ColorError_CIFrac(str, value);
        ErrorReport(__FILE__, __LINE__, str);
	return ERROR;
    }

    if (ptr->lastValue == -1.0) {
	ptr->lastValue = value;
    } else {
	if (value < ptr->lastValue) {
            ColorError_CIMonotonic(str, value, ptr->lastValue);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
	expected = (float)Round(2.0 * ref * ptr->numColor) / 2.0;

	if (ABS(value-expected) > (3.0*epsilon.ci+epsilon.zero)) {
            ColorError_CIBad(str, value, expected);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	if (ABS(delta) > epsilon.zero) {
	    if (ABS(delta) >= 2.0 && machine.pathLevel == 0) {
                ColorError_CIStep(str, delta);
                ErrorReport(__FILE__, __LINE__, str);
		return ERROR;
	    }
	}
    }

    if (ref >= 1.0 && value < ptr->numColor) {
        ColorError_CIClamp(str, ptr->numColor, value);
        ErrorReport(__FILE__, __LINE__, str);
	return ERROR;
    }
    return NO_ERROR;
}

long DifLightCIExec(void)
{
    difLightRec data;
    long max1;
    float start, end, frac;

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glDisable(GL_DITHER);
    glEnable(GL_LIGHTING);

    max1 = (machine.pathLevel == 0) ? GL_LIGHT7 : GL_LIGHT0;
    data.numColor = POW(2.0, (float)buffer.ciBits) - 1.0;
    for (data.light = GL_LIGHT0; data.light <= max1; data.light++) {
	if (data.numColor < 4096.0 || (machine.pathLevel != 0)) {
	    if (RampUtil(0.0, 1.0, InitCI, SetCI, TestCI, &data) == ERROR) {
		return ERROR;
	    }
	} else {
	    start = 0.5 / data.numColor;
	    frac = POW(2.0, (float)(8-buffer.ciBits));
	    if (RampUtil(start, frac, InitCI, SetCI, TestCI, &data) == ERROR) {
		return ERROR;
	    }
	    start = 0.5 - frac;
	    end = 0.5 + frac;
	    if (RampUtil(start, end, InitCI, SetCI, TestCI, &data) == ERROR) {
		return ERROR;
	    }
	    start = 1.0 - frac;
	    if (RampUtil(start, 1.0, InitCI, SetCI, TestCI, &data) == ERROR) {
		return ERROR;
	    }
	}
    }
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\l_em.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** l_em.c
** Light - Emissive Material Test.
**
** Description -
**    This test analyses the effect that varying the
**    Emissive_Material parameter has on the color produced by
**    lighting. This parameter is set with
**    glMaterial(GL_FRONT_AND_BACK, GL_EMISSION, ... ). It is
**    only used in RGB mode. A single lit point is rendered in
**    the lower left corner of the screen, and the color of this
**    point is retrieved using glReadPixels(). To analyse only
**    this one parameter the Ambient_Material color is set to (0,
**    0, 0, 1), and all of the lights are disabled. This forms a
**    restriction of the lighting equation to a function of the
**    Emissive_Material (color = Emissive_Material). This
**    function is analysed for monotonicity, endpoints values,
**    and variation. All color channels are tested one at a
**    time. The implementation fails if any channel other than
**    the one being tested is non-zero.
**    
**    The test repeatedly renders and reads the same point,
**    uniformly incrementing the one color channel being tested
**    of the Emissive_Material parameter. This controls the
**    linearity of this restriction of the lighting function to
**    the Ambient_Scene. The uniformity of change is tested and
**    the implementation fails if consecutive changes are too
**    different. (thisDelta - lastDelta) > 1/4 shade. The
**    observed, restricted function is also checked for
**    monotonicity. When the Emissive_Material reaches 1.0, the
**    tested color channel is checked to insure that the point
**    has been rendered with a saturation of 1.0.
**
** Error Explanation -
**    other_color > 0.0.
**    value < lastValue.
**    maxObserved < 1.0.
**    (thisDelta - lastDelta) > 1/4 shade.
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer.
**    Color requirements:
**        RGBA mode. Full color.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**        Color, zero epsilons, 0.25*color_epsilon.
**    Paths:
**        Allowed = Alpha, Blend, Depth, Logicop, Stencil, Stipple.
**        Not allowed = Alias, Dither, Fog, Shade.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"
#include "utilru.h"


typedef struct _emitMatRec {
    long color;
    float step, lastValue, delta, lastDelta;
    GLfloat emissive[4];
} emitMatRec;


static void Init(void *data)
{
    emitMatRec *ptr = (emitMatRec *)data;
    GLfloat buf[4];
    float step;
    GLenum i;

    ptr->lastValue = -1.0;
    ptr->lastDelta = -2.0;

    step = (machine.pathLevel == 0) ? 4.0 : 2.0;
    ptr->delta = 1.0 / (POW(2.0, (float)buffer.colorBits[ptr->color]) - 1.0);
    ptr->step = ptr->delta / step;

    for (i = GL_LIGHT0; i <= GL_LIGHT7; i++) {
	glDisable(i);
    }

    ptr->emissive[0] = 0.0;
    ptr->emissive[1] = 0.0;
    ptr->emissive[2] = 0.0;
    ptr->emissive[3] = 1.0;

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = 0.0;
    buf[3] = 1.0;
    glLightfv(GL_LIGHT0, GL_DIFFUSE, buf);

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = 0.0;
    buf[3] = 0.0;
    glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, buf);

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = 0.0;
    buf[3] = 1.0;
    glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, buf);
}

static void Set(void *data, float *ref)
{
    emitMatRec *ptr = (emitMatRec *)data;

    ptr->emissive[ptr->color] = *ref;
    glMaterialfv(GL_FRONT_AND_BACK, GL_EMISSION, ptr->emissive);

    glBegin(GL_POINTS);
	glVertex2f(0.5, 0.5);
    glEnd();

    *ref += ptr->step;
}

static long Test(void *data, float ref)
{
    emitMatRec *ptr = (emitMatRec *)data;
    char str[240];
    GLfloat buf[3]; 
    float value, delta;
    long i;

    ReadScreen(0, 0, 1, 1, GL_RGB, buf);

    for (i = 0; i < 3; i++) {
        if (buf[i] != 0.0 && i != ptr->color) {
            ColorError_RGBZero(str, ptr->color, buf);
            ErrorReport(__FILE__, __LINE__, str);
            return ERROR;
	}
    }

    value = buf[ptr->color];
    if (ptr->lastDelta == -2.0) {
	ptr->lastDelta = -1.0;
	ptr->lastValue = value;
    } else if (ptr->lastDelta == -1.0) {
	if (value < ptr->lastValue) {
            ColorError_RGBMonotonic(str, ptr->color, value, ptr->lastValue);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	if (ABS(delta) > epsilon.zero) {
	    if (ABS(delta-ptr->delta) > 0.25*epsilon.color[ptr->color]) {
                ColorError_RGBStep(str, ptr->color, delta, ptr->delta);
                ErrorReport(__FILE__, __LINE__, str);
		return ERROR;
	    }
	    ptr->lastDelta = delta;
	}
    } else {
	if (value < ptr->lastValue) {
            ColorError_RGBMonotonic(str, ptr->color, value, ptr->lastValue);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	if (ABS(delta) > epsilon.zero) {
	    if (ABS(delta-ptr->delta) > 0.25*epsilon.color[ptr->color]) {
                ColorError_RGBStep(str, ptr->color, delta, ptr->delta);
                ErrorReport(__FILE__, __LINE__, str);
		return ERROR;
	    }
	    if (ABS(delta-ptr->lastDelta) > epsilon.zero) {
                ColorError_RGBDelta(str, ptr->color, delta, ptr->lastDelta);
                ErrorReport(__FILE__, __LINE__, str);
		return ERROR;
	    }
	    ptr->lastDelta = delta;
	}
    }

    if (ref >= 1.0 && ABS(value-1.0) > epsilon.zero) {
        ColorError_RGBClamp(str, ptr->color, value);
        ErrorReport(__FILE__, __LINE__, str);
	return ERROR;
    }

    return NO_ERROR;
}

long EmitMatExec(void)
{
    emitMatRec data;
    long max;

    glViewport(0, 0, WINDSIZEX, WINDSIZEY);
    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glDisable(GL_DITHER);
    glEnable(GL_LIGHTING);

    max = (machine.pathLevel == 0) ? 3 : 1;
    for (data.color = 0; data.color < max; data.color++) {
	if (RampUtil(0.0, 1.0, Init, Set, Test, &data) == ERROR) {
	    return ERROR;
	}
    }
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\l_se.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** l_se.c
** Light - Specular Exponent Test.
**
** Description -
**    This test analyses the effect that varying the Normal and
**    the Specular Exponent together have on lighting. The file
**    contains code for both CI and RGB tests. To analyse only
**    these parameters, the Specular_Material and Specular_Light
**    are set to red. In CI mode the Specular_Light is set to (1,
**    1, 1) and the Specular_Material is set to maxIndex. Other
**    lighting parameters are chosen so that the Diffuse,
**    Ambient, and Emissive summands of the RGB or CI lighting
**    are set to zero. Values are chosen so the Attenuation and
**    the Spotlight factor are both 1.0.
**    
**    The test repeatedly renders and reads the same point at the
**    lower left corner of the screen. The third component of the
**    Normal and the Specular Exponent are both incremented in
**    such a way as to create a uniform change in the theoretical
**    Specular Exponent factor within the Specular summand.
**    (This controlled incrementation takes place in the routine
**    called Set() below). The other two components of the Normal
**    are set so that the total length of the Normal is 1. The
**    eye position and the light position are set so that the
**    Half_Angle vector, H_hat, is (0, 0, 1), with these settings
**    (Normal dot H_hat) = Normal[2].
**    
**    In RGB mode the implementation fails if blue or green are
**    not 0.0. In both modes one light is enabled at a time, all
**    individual lights are tested. The observed results are also
**    checked for monotonicity, and the change is checked for
**    uniformity. The observed change should be less than 1 shade
**    from the theoretical change (delta - trueDelta) < delta.
**    When the expected value reaches 1.0 the observed color is
**    checked to insure that the point has rendered with a fully
**    saturated red.
**    
**    In CI mode a check is made to ensure that the observed
**    index reaches its max. The observed shade is compared to
**    the theoretical value expected for each setting of
**    Light_Position. If the theoretical value is more than 5
**    indices away from the observed index the test fails. The
**    observed value must be an integer, and the difference
**    between successive observances must be less than or equal
**    to 2.
**
** Error Explanation -
**    RGB mode: other_color > 0.0.
**    RGB mode: value < lastValue.
**    RGB mode: maxObserved < 1.0.
**    RGB mode: (thisDelta - correctDelta) > 1 shade.
**    RGB mode: (thisDelta - lastDelta) > 1 shade.
**    CI mode: (fractional index) != 0.0.
**    CI mode: (observed - expected) > 3.0.
**    CI mode: observedMax < numColor.
**    CI mode: delta > 2.0.
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer.
**    Color requirements:
**        RGBA or color index mode. Full color.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**        Color, ci and zero epsilons, 0.25*color_epsilon.
**    Paths:
**        Allowed = Alpha, Blend, Depth, Logicop, Stencil, Stipple.
**        Not allowed = Alias, Dither, Fog, Shade.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"
#include "utilru.h"


typedef struct _specExpRec {
    float step, numColor, lastValue, lastDelta, delta;
    GLenum light;
    GLfloat normal[3], position[4]; 
} specExpRec;


/*****************************************************************************/

static void Set(void *data, float *ref)
{
    specExpRec *ptr = (specExpRec *)data;
    GLfloat exponent;
    float tmp; 

    tmp = (*ref > 0.0) ? *ref : ptr->step;
    tmp = (tmp <= 1.0) ? tmp : 1.0;
    exponent = 128.0 * tmp;
    glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, &exponent);

    tmp = LOG(tmp) / exponent;
    ptr->normal[2] = EXP(tmp);
    tmp = ptr->normal[2]; 
    ptr->normal[0] = SQRT(1.0-tmp*tmp);
    glNormal3fv(ptr->normal);

    glBegin(GL_POINTS);
	glVertex2f(0.5, 0.5);
    glEnd();

    *ref += ptr->step;
}

/****************************************************************************/

static void InitRGB(void *data)
{
    specExpRec *ptr = (specExpRec *)data;
    GLfloat buf[4];
    float step;
    GLenum i;

    ptr->lastValue = -1.0;
    ptr->lastDelta = -2.0;

    step = (machine.pathLevel == 0) ? 4.0 : 2.0;
    ptr->delta = 1.0 / (POW(2.0, (float)buffer.colorBits[0]) - 1.0); 
    ptr->step = ptr->delta / step;

    for (i = GL_LIGHT0; i <= GL_LIGHT7; i++) {
	glDisable(i);
    }
    glEnable(ptr->light);

    ptr->normal[0] = 0.0;
    ptr->normal[1] = 0.0;
    ptr->normal[2] = 0.0;

    ptr->position[0] = 0.5;
    ptr->position[1] = 0.5;
    ptr->position[2] = 1.0;
    ptr->position[3] = 1.0;
    glLightfv(ptr->light, GL_POSITION, ptr->position);

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = 0.0;
    buf[3] = 1.0;
    glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, buf);

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = 0.0;
    buf[3] = 1.0;
    glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, buf);

    buf[0] = 1.0;
    glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, buf);

    buf[0] = 1.0;
    buf[1] = 0.0;
    buf[2] = 0.0;
    buf[3] = 1.0;
    glLightfv(ptr->light, GL_SPECULAR, buf);
    glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, buf);

    buf[0] = 1.0;
    buf[1] = 1.0;
    buf[2] = 1.0;
    buf[3] = 1.0;
    glLightfv(ptr->light, GL_DIFFUSE, buf);
}

static long TestRGB(void *data, float ref)
{
    specExpRec *ptr = (specExpRec *)data;
    char str[240];
    GLfloat buf[3]; 
    float value, delta;
    long i;

    ReadScreen(0, 0, 1, 1, GL_RGB, buf);

    for (i = 1; i < 3; i++) {
	if (buf[i] != 0.0) {
            ColorError_RGBZero(str, 0, buf);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
    }

    value = buf[0];
    if (ptr->lastDelta == -2.0) {
	ptr->lastDelta = -1.0;
	ptr->lastValue = value;
    } else if (ptr->lastDelta == -1.0) {
	if (value < ptr->lastValue) {
            ColorError_RGBMonotonic(str, 0, value, ptr->lastValue);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	if (ABS(delta) > epsilon.zero) {
	    if (ABS(delta-ptr->delta) > epsilon.color[0]) {
                ColorError_RGBStep(str, 0, delta, ptr->delta);
                ErrorReport(__FILE__, __LINE__, str);
		return ERROR;
	    }
	    ptr->lastDelta = delta;
	}
    } else {
	if (value < ptr->lastValue) {
            ColorError_RGBMonotonic(str, 0, value, ptr->lastValue);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	if (ABS(delta) > epsilon.zero) {
	    if (ABS(delta-ptr->delta) > epsilon.color[0]) {
                ColorError_RGBStep(str, 0, delta, ptr->delta);
                ErrorReport(__FILE__, __LINE__, str);
		return ERROR;
	    }
	    if (ABS(delta-ptr->lastDelta) > epsilon.zero) {
                ColorError_RGBDelta(str, 0, delta, ptr->lastDelta);
                ErrorReport(__FILE__, __LINE__, str);
		return ERROR;
	    }
	    ptr->lastDelta = delta;
	}
    }

    if (ref >= 1.0 && ABS(value-1.0) > epsilon.zero) {
        ColorError_RGBClamp(str, 0, value);
        ErrorReport(__FILE__, __LINE__, str);
	return ERROR;
    }

    return NO_ERROR;
}

long SpecExpRGBExec(void)
{
    specExpRec data;
    long max;

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glDisable(GL_DITHER);
    glEnable(GL_LIGHTING);

    max = (machine.pathLevel == 0) ? GL_LIGHT7 : GL_LIGHT0;
    /*
    ** The exponentials in this test may not work well for 12 bit deep lights 
    ** with weak math libraries.
    */
    for (data.light = GL_LIGHT0; data.light <= max; data.light++) {
	if (RampUtil(0.0, 1.0, InitRGB, Set, TestRGB, &data) == ERROR) {
	    return ERROR;
	}
    }
    return NO_ERROR;
}

/****************************************************************************/

static void InitCI(void *data)
{
    specExpRec *ptr = (specExpRec *)data;
    GLfloat buf[4];
    GLenum i;

    ptr->lastValue = -1.0;

    if (machine.pathLevel == 0) {
	ptr->step = 0.5 / ptr->numColor;
    } else {
	ptr->step = 0.25;
    }

    for (i = GL_LIGHT0; i <= GL_LIGHT7; i++) {
	glDisable(i);
    }
    glEnable(ptr->light);

    ptr->normal[0] = 0.0;
    ptr->normal[1] = 0.0;
    ptr->normal[2] = 0.0;

    ptr->position[0] = 0.5;
    ptr->position[1] = 0.5;
    ptr->position[2] = 1.0;
    ptr->position[3] = 1.0;
    glLightfv(ptr->light, GL_POSITION, ptr->position);

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = 1.0;
    glNormal3fv(buf);

    buf[0] = 0.0;
    buf[1] = ptr->numColor;
    buf[2] = ptr->numColor;
    glMaterialfv(GL_FRONT_AND_BACK, GL_COLOR_INDEXES, buf);

    buf[0] = 1.0;
    buf[1] = 1.0;
    buf[2] = 1.0;
    buf[3] = PI;
    glLightfv(ptr->light, GL_SPECULAR, buf);

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = 0.0;
    buf[3] = PI;
    glLightfv(ptr->light, GL_DIFFUSE, buf);
}

static long TestCI(void *data, float ref)
{
    specExpRec *ptr = (specExpRec *)data;
    char str[240];
    GLfloat value;
    float expected, frac, delta;

    ReadScreen(0, 0, 1, 1, GL_COLOR_INDEX, &value);

    frac = ABS(value-(float)((int)value));
    if (frac > epsilon.zero && ABS(frac-1.0) > epsilon.zero) {
        ColorError_CIFrac(str, value);
        ErrorReport(__FILE__, __LINE__, str);
	return ERROR;
    }

    if (ptr->lastValue == -1.0) {
	ptr->lastValue = value;
    } else {
	if (value < ptr->lastValue) {
            ColorError_CIMonotonic(str, value, ptr->lastValue);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
	expected = (float)Round(2.0*ref*ptr->numColor) / 2.0;

	/*
	** Large Exponentials often have large errors.
	*/
	if (ABS(value-expected) > (4.0+epsilon.ci+epsilon.zero)) {
            ColorError_CIBad(str, value, expected);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	if (ABS(delta) > epsilon.zero) {
	    if (ABS(delta) >= 2.0 && machine.pathLevel == 0) {
                ColorError_CIStep(str, delta);
                ErrorReport(__FILE__, __LINE__, str);
		return ERROR;
	    }
	}
    }

    if (ref >= 1.0 && value < ptr->numColor) {
        ColorError_CIClamp(str, ptr->numColor, value);
        ErrorReport(__FILE__, __LINE__, str);
	return ERROR;
    }
    return NO_ERROR;
}

long SpecExpCIExec(void)
{
    specExpRec data;
    float start, end, frac;
    long max;

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glDisable(GL_DITHER);
    glEnable(GL_LIGHTING);

    max = (machine.pathLevel == 0) ? GL_LIGHT7 : GL_LIGHT0;
    data.numColor = POW(2.0, (float)buffer.ciBits) - 1.0;
    for (data.light = GL_LIGHT0; data.light <= max; data.light++) {
	if (data.numColor < 4096.0 || (machine.pathLevel != 0)) {
	    start = 1.0 / 256.0;
	    if (RampUtil(start, 1.0, InitCI, Set, TestCI, &data) == ERROR) {
		return ERROR;
	    }
	} else {
	    start = 0.5 / data.numColor;
	    frac = POW(2.0, (float)(8-buffer.ciBits));
	    /*
	    ** The exponentials and logs used by this test aren't accurate
	    ** with extremely small numbers.
	    */
	    start = 1.0 / 256.0;
	    end = start + frac;
	    if (RampUtil(start, end, InitCI, Set, TestCI, &data) == ERROR) {
		return ERROR;
	    }
	    start = 0.5 - frac;
	    end = 0.5 + frac;
	    if (RampUtil(start, end, InitCI, Set, TestCI, &data) == ERROR) {
		return ERROR;
	    }
	    start = 1.0 - frac;
	    if (RampUtil(start, 1.0, InitCI, Set, TestCI, &data) == ERROR) {
		return ERROR;
	    }
	}
    }
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\l_sed.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** l_sed.c
** Light - Spot Exponent And Direction Test.
**
** Description -
**    This test analyses the effect that varying the
**    Spotlight_Direction has on the color produced by lighting.
**    This file contains code for both CI and RGB tests. To
**    analyse only this one parameter, the RGB test uses a
**    different analysis from that of the CI test. In RGB mode
**    the Ambient summand is used, and in CI mode the Specular
**    summand is used. In both modes the test repeats itself with
**    different Spot_Exponents, and different Cutoff_Angles.
**    
**    In RGB mode the Ambient_Material is set so that one color
**    channel is fully saturated, and the other channels are set
**    to zero. All three channels are tested. The implementation
**    fails if any color channel not being tested is not observed
**    to be 0.0. The Ambient_Light is set to (1, 1, 1, 1). Other
**    lighting parameters are chosen so that the Diffuse,
**    Specular, and Emissive summands of the RGB lighting are set
**    to 0.0.
**    
**    In CI mode the Specular_Light is set to (1, 1, 1, 1) and
**    the Specular_Material is set to maxIndex. The Diffuse and
**    Ambient summands are zero. Values are chosen so the
**    Attenuation factor is 1.0.
**    
**    The test repeatedly renders and reads the same point at the
**    lower left corner of the screen. The third component of the
**    Spotlight_Direction is incremented by a an amount sensitive
**    to the Spotlight_Exponent being tested. The increment is
**    controlled so that the observed resulting color would
**    theoretically increment uniformly. (This controlled
**    incrementing takes place in the routine called Set()
**    below). The other two components of the Spotlight_Direction
**    are adjusted so that the total length of the
**    Spotlight_Direction vector is 1. The rendered point's eye
**    position and the Spotlight_Position are set so that the
**    vector from the Spotlight_Position to the rendered point's
**    eye position, PV, is (0, 0, 1). With these settings
**    (SpotDirection dot PV) = SpotDirection[2]).
**    
**    In both modes if the theoretically calculated Spot_Exponent
**    factor indicates that the Cutoff_Angle would cause the
**    object to render black, the implementation fails if the
**    observed color is not black. If the expected value
**    indicates that the observed color should not be "cutoff"
**    the implementation fails if the color is more than 5% away
**    from the theoretical correct value. A margin around the
**    cutoff angle of 1% is used. In both modes one light is
**    enabled at a time, all individual lights are tested. The
**    observed results are compared to the theoretical value.
**    The error here is 10% for bright shades or one colorEpsilon
**    for dark shades. This test will not run with less than 3
**    bits of color per channel. When Spotlight_Position[2]
**    reaches 1.0, the color is finally checked to insure that
**    the point has rendered with a fully saturated color. The
**    observed results are also checked for monoticity.
**    
**    In CI mode a check is made to ensure that the observed
**    index reaches its max. The observed shade is compared to
**    the theoretical value expected for each setting of
**    Light_Position. For high indices if the theoretical value
**    is more than .05*maxIndex away from the observed index the
**    test fails. Darker colors must be within 1 indices. The
**    observed value must be an integer, and the difference
**    between successive observances must be less than 2.
**
** Error Explanation -
**    RGB mode: other_color > 0.0.
**    RGB mode: value < lastValue.
**    RGB mode: maxObserved < 1.0.
**    RGB mode: ABS(observed - expected) > 0.1.
**    CI mode: index not an integer.
**    CI mode: (observed - expected) > 3.0.
**    CI mode: observedMax < numColor.
**    CI mode: delta > 2.0.
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer.
**    Color requirements:
**        RGBA or color index mode. Full color.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**        Color, ci and zero epsilons, 0.25*color_epsilon.
**    Paths:
**        Allowed = Alpha, Blend, Depth, Logicop, Stencil, Stipple.
**        Not allowed = Alias, Dither, Fog, Shade.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"
#include "utilru.h"


typedef struct _spotExpDirRec {
    long color;
    float step, numColor, lastValue, lastDelta, firstDelta;
    GLenum light, expIndex; 
    float cosCutoff, cutoffMargin;
    GLfloat exp, angle, position[4], direction[3];
    float errConst;
} spotExpDirRec;


/*****************************************************************************/

static void Set(void *data, float *ref)
{
    spotExpDirRec *ptr = (spotExpDirRec *)data;

    ptr->direction[0] = SQRT(1.0-(*ref)*(*ref));
    ptr->direction[2] = *ref;
    glLightfv(ptr->light, GL_SPOT_DIRECTION, ptr->direction);

    glBegin(GL_POINTS);
	glVertex2f(0.5, 0.5);
    glEnd();

    /*
    ** This incrementing is sensitive to the different functions
    ** which result from using different Spotlight_Exponents.
    */
    *ref = POW(*ref, ptr->exp);
    *ref += ptr->step;
    *ref = POW(*ref, 1.0/ptr->exp);
}

/****************************************************************************/

static void InitRGB(void *data)
{
    spotExpDirRec *ptr = (spotExpDirRec *)data;
    GLfloat buf[4];
    float tmp;
    GLenum i;

    ptr->lastValue = -1.0;
    ptr->lastDelta = -2.0;

    if (machine.pathLevel == 0) {
	ptr->step = 0.125 / ptr->numColor;
    } else {
	ptr->step = 0.25;
    }

    ptr->errConst = 0.1;

    ptr->light = GL_LIGHT0 + (ptr->expIndex % 8);
    for (i = GL_LIGHT0; i <= GL_LIGHT7; i++) {
	glDisable(i);
    }
    glEnable(ptr->light);

    ptr->angle = Random(0.0, 90.0);
    glLightfv(ptr->light, GL_SPOT_CUTOFF, &ptr->angle);
    tmp = ptr->angle;
    ptr->cosCutoff = COS(tmp*PI/180.0);
    ptr->cutoffMargin = 0.01;

    ptr->direction[0] = 0.0;
    ptr->direction[1] = 0.0;
    ptr->direction[2] = 0.0;

    ptr->position[0] = 0.5;
    ptr->position[1] = 0.5;
    ptr->position[2] = -1.0;
    ptr->position[3] = 1.0;
    glLightfv(ptr->light, GL_POSITION, ptr->position);

    glLightfv(ptr->light, GL_SPOT_EXPONENT, &ptr->exp);

    buf[0] = 1.0;
    buf[1] = 1.0;
    buf[2] = 1.0;
    buf[3] = 1.0;
    glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, buf);

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = 0.0;
    buf[3] = 1.0;
    buf[ptr->color] = 1.0;
    glLightfv(ptr->light, GL_AMBIENT, buf);

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = 0.0;
    buf[3] = 1.0;
    glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, buf);
    glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, buf);
    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, buf);
}

static long TestRGB(void *data, float ref)
{
    spotExpDirRec *ptr = (spotExpDirRec *)data;
    GLfloat buf[3]; 
    float value, expected, delta, error;
    long i, cutoff, noCutoff;

    ReadScreen(0, 0, 1, 1, GL_RGB, buf);

    for (i = 1; i < 3; i++) {
	if (buf[i] != 0.0 && i != ptr->color) {
	    return ERROR;
	}
    }

    expected = POW(ref, ptr->exp);

    /*
    ** These errors will not work for a badly implemented lookup table.
    */
    if (ptr->numColor > 0) {
	if (expected < (1.0/ptr->numColor)) {
	    error = epsilon.color[ptr->color];
	} else {
	    error = ptr->errConst;
	    if (epsilon.color[ptr->color] > error) {
		error = epsilon.color[ptr->color];
	    }
	}
    } else {
	error = epsilon.color[ptr->color];
    }

    /*
    ** The monotonicity requirement may be too stringent for machines
    ** with extreme color granularity, but I doubt it.
    */
    value = buf[ptr->color];

    cutoff = (ref < ptr->cosCutoff-ptr->cutoffMargin);
    noCutoff = (ref > ptr->cosCutoff+ptr->cutoffMargin);
    if (cutoff) {
	if (value > 0.5*epsilon.color[ptr->color]) {
	    return ERROR;
	}
    } else {
	if (noCutoff) {
	    if (ABS(value-expected) > error) {
		return ERROR;
	    }
	}
    }

    /*
    ** The linearity test may be relaxed, but due to variable sampling
    ** this should be linear.
    */
    if (ptr->lastDelta == -2.0) {
	ptr->lastDelta = -1.0;
	ptr->lastValue = value;
    } else if (ptr->lastDelta == -1.0) {
	if (value < ptr->lastValue) {
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	if (ABS(delta) > epsilon.zero) {
	    ptr->lastDelta = delta;
	}
    } else {
	if (value < ptr->lastValue) {
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	if (ABS(delta) > epsilon.zero) {
	    ptr->lastDelta = delta;
	}
    }
    if (ref >= 1.0 && ABS(value-1.0) > epsilon.zero) {
	return ERROR;
    }
    return NO_ERROR;
}

long SpotExpDirRGBExec(void)
{
    static float expSlow[] = {
	1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 12.0, 15.0, 19.0, 26.0, 37.0, 49.0,
	64.0, 81.0, 107.0, 116.0, 125.0, 126.0, 127.0, 128.0
    };
    static float expFast[] = {
	1.0, 64.0, 128.0
    };
    spotExpDirRec data;
    float start, *expPtr;
    long max;

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glDisable(GL_DITHER);
    glEnable(GL_LIGHTING);

    max = (machine.pathLevel == 0) ? 21 : 3;
    expPtr = (machine.pathLevel == 0) ? expSlow : expFast;
    for (data.expIndex = 0; data.expIndex < max; data.expIndex++) {
	data.color = data.expIndex % 3;
	data.exp = expPtr[data.expIndex];
	data.numColor = POW(2.0, (float)buffer.colorBits[data.color]) - 1.0;
	start = POW(0.5/data.numColor, 1.0/data.exp);
	if (RampUtil(0.0, 1.0, InitRGB, Set, TestRGB, &data) == ERROR) {
	    ErrorReport(__FILE__, __LINE__, 0);
	    return ERROR;
	}
    }
    return NO_ERROR;
}

/****************************************************************************/

static void InitCI(void *data)
{
    spotExpDirRec *ptr = (spotExpDirRec *)data;
    GLfloat buf[4];
    GLenum i;

    ptr->lastValue = -1.0;
    ptr->firstDelta = -1.0;

    if (machine.pathLevel == 0) {
	ptr->step = 0.5 / ptr->numColor;
    } else {
	ptr->step = 0.25;
    }

    ptr->light = GL_LIGHT0 + (ptr->expIndex % 8);
    for (i = GL_LIGHT0; i <= GL_LIGHT7; i++) {
	glDisable(i);
    }
    glEnable(ptr->light);

    ptr->angle = Random(0.0, 90.0);
    glLightfv(ptr->light, GL_SPOT_CUTOFF, &ptr->angle);
    ptr->cosCutoff = COS(ptr->angle*PI/180.0);
    ptr->cutoffMargin = 0.01;

    ptr->direction[0] = 0.0;
    ptr->direction[1] = 0.0;
    ptr->direction[2] = 0.0;

    ptr->position[0] = 0.5;
    ptr->position[1] = 0.5;
    ptr->position[2] = -1.0;
    ptr->position[3] = 1.0;
    glLightfv(ptr->light, GL_POSITION, ptr->position);

    glLightfv(ptr->light, GL_SPOT_EXPONENT, &ptr->exp);

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = ptr->numColor;
    glMaterialfv(GL_FRONT_AND_BACK, GL_COLOR_INDEXES, buf);

    buf[0] = 1.0;
    buf[1] = 1.0;
    buf[2] = 1.0;
    buf[3] = PI;
    glLightfv(ptr->light, GL_SPECULAR, buf);
    /*
    ** Diffuse values should have no affect in CI mode,
    ** as should specular alpha.
    */
    glLightfv(ptr->light, GL_DIFFUSE, buf);
    glNormal3f(0.0, 0.0, -1.0);
}

static long TestCI(void *data, float ref)
{
    spotExpDirRec *ptr = (spotExpDirRec *)data;
    GLfloat value;
    float expected, frac, delta, error;
    long cutoff, noCutoff;

    ReadScreen(0, 0, 1, 1, GL_COLOR_INDEX, &value);

    frac = ABS(value-(float)((int)value));
    if (frac > epsilon.zero && ABS(frac-1.0) > epsilon.zero) {
	return ERROR;
    }

    if (ptr->lastValue == -1.0) {
	ptr->lastValue = value;
    } else {
	if (value < ptr->lastValue) {
	    return ERROR;
	}
	expected = (float)Round(2.0*POW(ref, ptr->exp)*ptr->numColor) / 2.0;

	/*
	** These errors will not work for large exponents for
	** badly implemented look-up tables.
	*/
	if (ptr->numColor > 0) {
	    if (expected < (1.0/ptr->numColor)) {
		error = epsilon.ci;
	    } else {
		error = 0.05 * ptr->numColor;
		if (2.0*epsilon.ci > error) {
		    error = 2.0 * epsilon.ci;
		}
	    }
	} else {
	    error = epsilon.ci;
	}
	error = (error < 5.0) ? 5.0 : error;

	cutoff = (ref < ptr->cosCutoff-ptr->cutoffMargin);
	noCutoff = (ref > ptr->cosCutoff+ptr->cutoffMargin);
	if (cutoff) {
	    if (value > epsilon.ci) {
		return ERROR;
	    }
	} else {
	    if (noCutoff) {
		if (ABS(value-expected) >= error) {
		    return ERROR;
		}
	    }
	}

	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	if (ABS(delta) > epsilon.zero) {
	    if (ptr->firstDelta == -1.0) {
		ptr->firstDelta = 1.0;
	    } else {
		if (ABS(delta) >= error && machine.pathLevel == 0) {
		    return ERROR;
		}
	    }
	}
    }

    if (ref >= 1.0 && value < ptr->numColor) {
	return ERROR;
    }
    return NO_ERROR;
}

long SpotExpDirCIExec(void)
{
    static float expSlow[] = {
	1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 12.0, 15.0, 19.0, 26.0, 37.0, 49.0,
	64.0, 81.0, 107.0, 116.0, 125.0, 126.0, 127.0, 128.0
    };
    static float expFast[] = {
	1.0, 66.0, 128.0
    };
    spotExpDirRec data;
    float start, end, frac, *exp_ptr;
    long max;

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glDisable(GL_DITHER);
    glEnable(GL_LIGHTING);

    max = (machine.pathLevel == 0) ? 21 : 3;
    exp_ptr = (machine.pathLevel == 0) ? expSlow : expFast;
    data.numColor = POW(2.0, (float)buffer.ciBits) - 1.0;
    frac = POW(2.0, (float)(8-buffer.ciBits));
    for (data.expIndex = 0; data.expIndex < max; data.expIndex++) {
	data.exp = exp_ptr[data.expIndex];
	if (data.numColor < 4096.0 || machine.pathLevel != 0) {
	    start = POW(0.5/data.numColor, 1.0/data.exp);
	    if (RampUtil(start, 1.0, InitCI, Set, TestCI, &data) == ERROR) {
		ErrorReport(__FILE__, __LINE__, 0);
		return ERROR;
	    }
	} else {
	    start = POW(0.5/data.numColor, 1.0/data.exp);
	    end = POW(frac, 1.0/data.exp);
	    if (RampUtil(start, end, InitCI, Set, TestCI, &data) == ERROR) {
		ErrorReport(__FILE__, __LINE__, 0);
		return ERROR;
	    }
	    start = POW(0.5-frac, 1.0/data.exp);
	    end = POW(0.5+frac, 1.0/ data.exp);
	    if (RampUtil(start, end, InitCI, Set, TestCI, &data) == ERROR) {
		ErrorReport(__FILE__, __LINE__, 0);
		return ERROR;
	    }
	    start = POW(1.0-frac, 1.0/data.exp);
	    if (RampUtil(start, 1.0, InitCI, Set, TestCI, &data) == ERROR) {
		ErrorReport(__FILE__, __LINE__, 0);
		return ERROR;
	    }
	}
    }
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\l_sen.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** l_sen.c
** Light - Specular Exponent Normal Test.
**
** Description -
**    This test analyses the effect that varying the Normal has
**    on the color produced by lighting, by way of its effect on
**    the Specular summand. This file contains code for both CI
**    and RGB tests. To analyse only this one parameter, the
**    Specular_Material is set to color channel at a time, and
**    Specular_Light is set to (1, 1, 1, 1). In CI mode the
**    Specular_Material is set to maxIndex and the Specular_Light
**    is set to (1, 1, 1, 1). Other lighting parameters are
**    chosen so that the Diffuse, Ambient, and Emissive summands
**    of the RGB or CI lighting are set to 0.0. Values are chosen
**    so the Attenuation and the Spotlight factor are both 1.0.
**    This test repeats itself with different Specular_Exponents
**    (GL_SHININESS), and with different color channels.
**    
**    The test repeatedly renders and reads the same point at the
**    lower left corner of the screen. The third component of the
**    Normal is incremented by a an amount sensitive to whichever
**    Specular_Exponent is being tested. The increment is
**    controlled so that the observed resulting color would
**    theoretically increment uniformly. (This controlled
**    incrementation takes place in the routine called Set()
**    below). The other two components of the Normal are set so
**    that the total length of the Normal is 1. The eye position
**    and the light position are set so that the Half_Angle
**    vector, H_hat, is (0, 0, 1), with these settings (Normal
**    dot H_hat) = Normal[2].
**    
**    In RGB mode the implementation fails if any color channel
**    not being tested is not 0.0. In both modes one light is
**    enabled at a time, all individual lights are tested. The
**    observed results are compared to the theoretical value.
**    The error here is 5% for bright colors and 1% for dark
**    shades. This test will not run with less than 3 bits of
**    color per channel. When Light_Position[2] reaches 1.0, the
**    color is finally checked to insure that the point has
**    rendered with a fully saturated color.
**    
**    In CI mode a check is made to ensure that the observed
**    index reaches its max. The observed shade is compared to
**    the theoretical value expected for each setting of
**    Light_Position. For high indices if the theoretical value
**    is more than 5 indices away from the observed index the
**    test fails. Darker colors must be within 2 indices. The
**    observed value must be an integer, and the difference
**    between successive observances must be less than 2.
**
** Error Explanation -
**    RGB mode: other_color > 0.0.
**    RGB mode: value < lastValue.
**    RGB mode: maxObserved < 1.0.
**    RGB mode: ABS(observed - expected) > 0.05 for highly saturated colors.
**    RGB mode: ABS(observed - expected) > 0.01 for dark shades.
**    CI mode: index not an integer
**    CI mode: (observed - expected) > 5.0 for highly saturated colors.
**    CI mode: (observed - expected) > 2.0 for dark shades or shallow buffers.
**    CI mode: observedMax < numColor.
**    CI mode: delta > 2.0.
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer.
**    Color requirements:
**        RGBA or color index mode. Full color.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**        Color, ci and zero epsilons, 0.25*color_epsilon.
**    Paths:
**        Allowed = Alpha, Blend, Depth, Logicop, Stencil, Stipple.
**        Not allowed = Alias, Dither, Fog, Shade.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"
#include "utilru.h"


typedef struct _specExpNormRec {
    long  color;
    float step, lastValue, lastDelta;
    GLenum  light, expIndex;
    GLfloat exp, normal[3];
    float numColor, errConstSat, errConstDark;
} specExpNormRec;


/*****************************************************************************/

static void Set(void *data, float *ref)
{
    specExpNormRec *ptr = (specExpNormRec *)data;

    ptr->normal[0] = SQRT(1.0-(*ref)*(*ref));
    ptr->normal[2] = *ref;
    glNormal3fv(ptr->normal);

    glBegin(GL_POINTS);
	glVertex2f(0.5, 0.5);
    glEnd();

    /*
    ** This increment controls that the theoretical increment of the
    ** observed color should be uniform.
    */
    *ref = POW(*ref, (double)ptr->exp);

    *ref += ptr->step;
    *ref = POW(*ref, 1.0/ptr->exp);
}

/****************************************************************************/

static void InitRGB(void *data)
{
    specExpNormRec *ptr = (specExpNormRec *)data;
    GLfloat buf[4];
    GLenum i;

    ptr->lastValue = -1.0;
    ptr->lastDelta = -2.0;

    if (machine.pathLevel == 0) {
	ptr->step = 0.5 / ptr->numColor;
    } else {
	ptr->step = 0.25;
    }

    i = 1;
    do {
	ptr->errConstSat = (float)i / ptr->numColor;
	i++;
    } while (ptr->errConstSat < 0.05 && i < 1000);

    i = 1;
    do {
	ptr->errConstDark = (float)i / ptr->numColor;
	i++;
    } while (ptr->errConstDark < 0.01 && i < 1000);

    ptr->light = GL_LIGHT0 + (ptr->expIndex % 8);
    for (i = GL_LIGHT0; i <= GL_LIGHT7; i++) {
	glDisable(i);
    }
    glEnable(ptr->light);

    ptr->normal[0] = 0.0;
    ptr->normal[1] = 0.0;
    ptr->normal[2] = 0.0;

    buf[0] = 0.5;
    buf[1] = 0.5;
    buf[2] = 1.0;
    buf[3] = 1.0;
    glLightfv(ptr->light, GL_POSITION, buf);

    glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, &ptr->exp);

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = 0.0;
    buf[3] = 1.0;
    glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, buf);

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = 0.0;
    buf[3] = 1.0;
    glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, buf);

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = 0.0;
    buf[3] = 1.0;
    buf[ptr->color] = 1.0;
    glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, buf);

    buf[0] = 1.0;
    buf[1] = 1.0;
    buf[2] = 1.0;
    buf[3] = 1.0;
    glLightfv(ptr->light, GL_SPECULAR, buf);
}

static long TestRGB(void *data, float ref)
{
    specExpNormRec *ptr = (specExpNormRec *)data;
    GLfloat buf[3]; 
    float value, expected,  delta, error;
    long i;

    ReadScreen(0, 0, 1, 1, GL_RGB, buf);

    for (i = 1; i < 3; i++) {
	if (buf[i] != 0.0 && i != ptr->color) {
	    return ERROR;
	}
    }

    value = buf[ptr->color];
    expected = POW(ref, ptr->exp);

    /*
    ** We should observe colors within 5% of the expected value
    ** for the numbers reflecting some saturation, and we expect only 
    ** color resolution error near 0;
    ** another possibility error = expected * ptr->errConst;
    */
    if (ref == 0.0 || ptr->exp == 0.0) {
	error = ptr->errConstDark + epsilon.zero;
    } else if (expected/ref < 0.01/ptr->exp) {
	error = ptr->errConstDark + epsilon.zero;
    } else {
	error = ptr->errConstSat + epsilon.zero;
    }

    if (ABS(value-expected) > error) {
	return ERROR;
    }
    /*
    ** The monotonicity requirement may be too stringent for machines
    ** with extreme color granularity. I doubt it, but we don't include it.
    ** Also due to variable sampling this should be linear, but we do not
    ** test for uniform delta.
    */
    if (ptr->lastDelta == -2.0) {
	ptr->lastDelta = -1.0;
	ptr->lastValue = value;
    } else if (ptr->lastDelta == -1.0) {
	if (value < ptr->lastValue) {
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	if (ABS(delta) > epsilon.zero) {
	    ptr->lastDelta = delta;
	}
    } else {
	if (value < ptr->lastValue) {
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	if (ABS(delta) > epsilon.zero) {
	    ptr->lastDelta = delta;
	}
    }
    if (ref >= 1.0 && ABS(value-1.0) > epsilon.zero) {
	return ERROR;
    }
    return NO_ERROR;
}

long SpecExpNormRGBExec(void)
{
    static float expSlow[] = {
	1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 12.0, 15.0, 19.0, 26.0, 37.0, 49.0,
	64.0, 81.0, 107.0, 116.0, 125.0, 126.0, 127.0, 128.0
    };
    static float expFast[] = {
	1.0, 66.0, 128.0
    };
    specExpNormRec data;
    float start, *expPtr;
    long max;

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glDisable(GL_DITHER);
    glEnable(GL_LIGHTING);

    max = (machine.pathLevel == 0) ? 21 : 3;
    expPtr = (machine.pathLevel == 0) ? expSlow : expFast;
    for (data.expIndex = 0; data.expIndex < max; data.expIndex++) {
	data.color = data.expIndex % 3;
	data.numColor = POW(2.0, (float)buffer.colorBits[data.color]) - 1.0;
	data.exp = expPtr[data.expIndex];
	start = POW(0.5/data.numColor, 1.0/data.exp);
	if (RampUtil(0.0, 1.0, InitRGB, Set, TestRGB, &data) == ERROR) {
	    ErrorReport(__FILE__, __LINE__, 0);
	    return ERROR;
	}
    }
    return NO_ERROR;
}

/****************************************************************************/

static void InitCI(void *data)
{
    specExpNormRec *ptr = (specExpNormRec *)data;
    GLfloat buf[4];
    GLenum i;

    ptr->lastValue = -1.0;
    ptr->lastDelta = -2.0;

    if (machine.pathLevel == 0) {
	ptr->step = 0.5 / ptr->numColor;
    } else {
	ptr->step = 0.25;
    }

    /*
    ** The values in the exp arrays are chosen to give a variety of lights
    ** modulo 8.
    */
    ptr->light = GL_LIGHT0 + (ptr->expIndex % 8);
    for (i = GL_LIGHT0; i <= GL_LIGHT7; i++) {
	glDisable(i);
    }
    glEnable(ptr->light);

    ptr->normal[0] = 0.0;
    ptr->normal[1] = 0.0;
    ptr->normal[2] = 0.0;

    buf[0] = 0.5;
    buf[1] = 0.5;
    buf[2] = 1.0;
    buf[3] = 1.0;
    glLightfv(ptr->light, GL_POSITION, buf);

    glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, &ptr->exp);

    buf[0] = 0.0;
    buf[1] = ptr->numColor;
    buf[2] = ptr->numColor;
    glMaterialfv(GL_FRONT_AND_BACK, GL_COLOR_INDEXES, buf);

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = 0.0;
    buf[3] = PI;
    glLightfv(ptr->light, GL_DIFFUSE, buf);

    buf[0] = 1.0;
    buf[1] = 1.0;
    buf[2] = 1.0;
    buf[3] = PI;
    glLightfv(ptr->light, GL_SPECULAR, buf);
}

static long TestCI(void *data, float ref)
{
    specExpNormRec *ptr = (specExpNormRec *)data;
    GLfloat value;
    float expected, frac, delta, error;

    ReadScreen(0, 0, 1, 1, GL_COLOR_INDEX, &value);

    frac = ABS(value-(float)((int)value));
    if (frac > epsilon.zero && ABS(frac-1.0) > epsilon.zero) {
	return ERROR;
    }

    if (ptr->lastValue == -1.0) {
	ptr->lastValue = value;
    } else {
	if (value < ptr->lastValue) {
	    return ERROR;
	}
	expected = (float)Round(2.0*POW(ref, (double)ptr->exp)*ptr->numColor)
									  / 2.0;

	error = ptr->exp * (expected / ref);      /*  dy =  fprime * dx */
	error *= (1.0 - exp (log(0.5 / ptr->numColor) / ptr->exp)) / 64.0; 
	error += 3.0;                           /* error = dy + fudge */ 
	error += epsilon.zero;

	if (ABS(value-expected) > error) {
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	if (ABS(delta) > epsilon.zero) {
	    if (ABS(delta) > error && machine.pathLevel == 0) {
		return ERROR;
	    }
	}
    }

    if (ref >= 1.0 && value < ptr->numColor) {
	return ERROR;
    }
    return NO_ERROR;
}

long SpecExpNormCIExec(void)
{
    static float expSlow[] = {
	1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 12.0, 15.0, 19.0, 26.0, 37.0, 49.0,
	64.0, 81.0, 107.0, 116.0, 125.0, 126.0, 127.0, 128.0
    };
    static float expFast[] = {
	1.0, 66.0, 128.0
    };
    specExpNormRec data;
    float start, end, *expPtr;
    long max;

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glDisable(GL_DITHER);
    glEnable(GL_LIGHTING);

    max = (machine.pathLevel == 0) ? 21 : 3;
    /*
    ** The values in the expSlow array are chosen to give a variety of lights
    ** mod 8.
    */
    expPtr = (machine.pathLevel == 0) ? expSlow : expFast;
    data.numColor = POW(2.0, (float)buffer.ciBits) - 1.0;
    for (data.expIndex = 0; data.expIndex < max; data.expIndex++) {
	data.exp = expPtr[data.expIndex];
	start = POW(0.5/data.numColor, 1.0/data.exp);
	if (data.numColor < 4096.0 || machine.pathLevel != 0) {
	    if (RampUtil(start, 1.0, InitCI, Set, TestCI, &data) == ERROR) {
		ErrorReport(__FILE__, __LINE__, 0);
		return ERROR;
	    }
	} else {
	    end = POW(256.0/data.numColor, 1.0/data.exp);
	    if (RampUtil(start, end, InitCI, Set, TestCI, &data) == ERROR) {
		ErrorReport(__FILE__, __LINE__, 0);
		return ERROR;
	    }
	    start = POW(0.5-(256.0/data.numColor), 1.0/data.exp);
	    end = POW(0.5+(256.0/data.numColor), 1.0/data.exp);
	    if (RampUtil(start, end, InitCI, Set, TestCI, &data) == ERROR) {
		ErrorReport(__FILE__, __LINE__, 0);
		return ERROR;
	    }
	    start = POW(1.0-(256.0/data.numColor), 1.0/data.exp);
	    if (RampUtil(start, 1.0, InitCI, Set, TestCI, &data) == ERROR) {
		ErrorReport(__FILE__, __LINE__, 0);
		return ERROR;
	    }
	}
    }
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\l_dm.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** l_dm.c
** Light - Diffuse Material Test.
**
** Description -
**    This test analyses the effect that varying the
**    Diffuse_Material parameter has on the color produced by
**    lighting. CI lighting differs from RGB lighting. This file
**    contains code for both tests. To analyse only this one
**    parameter, parameter values are chosen so that the
**    Attenuation factor, the SpotLight factor, and the
**    Light_Position factor are all 1.0. In RGB mode the
**    Specular, Emissive, and Ambient summands in the lighting
**    equation are 0.0, and the Diffuse_Light is set to (1, 1, 1,
**    1). In CI mode s_prime is set to 0.0, and the
**    Ambient_Material is set to (0, 0, 0, 1).
**    
**    This forms a restriction of the lighting equation so that
**    the output color is equal to a multiple of the
**    Diffuse_Material setting (color ~= Diffuse_Material). This
**    function's output is analysed for monotonicity, endpoints,
**    and variation. In RGB modes one light is enabled at a time.
**    All individual lights are tested. In CI mode all three
**    color channels of Specular_Light are set to 0.125 for the
**    first 8 lights and all the lights are enabled.
**    
**    The test repeatedly renders and reads the same point in the
**    lower left corner of the screen, uniformly incrementing
**    Diffuse_Material. In RGB mode the uniformity of the change
**    in observed color is tested, and the implementation fails
**    if consecutive changes are too different. (thisDelta -
**    lastDelta) > 1/4 shade. The observed results are also
**    checked for monotonicity. When Diffuse_Material reaches
**    1.0, the observed color is checked to insure that it is
**    rendered with a saturation of 1.0. All color channels are
**    tested one at a time, and the implementation fails if any
**    color channel, besides the one being tested, is not 0.0.
**    
**    In CI mode a check is made to ensure that the observed
**    index reaches its max. The observed shade is compared to
**    the theoretical value expected for each setting of
**    Diffuse_Material. The observed value must be an integer,
**    and the difference between successive observances must be
**    less than 2. The observed index is also compared to the
**    theoretical value expected for each setting of
**    Diffuse_Material. If the theoretical value is more than 3
**    indices away from the observed index the test fails.
**
** Error Explanation -
**    RGB mode: other_color > 0.0.
**    RGB mode: value < lastValue.
**    RGB mode: maxObserved < 1.0.
**    RGB mode: (thisDelta - lastDelta) > 1/4 shade.
**    CI mode: (fractional index) != 0.0.
**    CI mode: (observed - expected) > 3.0.
**    CI mode: observedMax < numColor.
**    CI mode: delta > 2.0.
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer.
**    Color requirements:
**        RGBA or color index mode. Full color.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**        Color, ci and zero epsilons, 0.25*color_epsilon.
**    Paths:
**        Allowed = Alpha, Blend, Depth, Logicop, Stencil, Stipple.
**        Not allowed = Alias, Dither, Fog, Shade.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"
#include "utilru.h"


typedef struct _difMatRec {
    long color;
    float step, numColor, delta, lastValue, lastDelta;
    GLfloat material_diffuse[4], position[4];
} difMatRec;


/****************************************************************************/

static void InitRGB(void *data)
{
    difMatRec *ptr = (difMatRec *)data;
    GLfloat buf[4];
    float step;
    GLenum i;

    ptr->lastValue = -1.0;
    ptr->lastDelta = -2.0;

    step = (machine.pathLevel == 0) ? 4.0 : 2.0;
    ptr->delta = 1.0 / (POW(2.0, (float)buffer.colorBits[ptr->color]) - 1.0);
    ptr->step = ptr->delta / step;

    for (i = GL_LIGHT0; i <= GL_LIGHT7; i++) {
	glEnable(i);
    }
    glNormal3f(0.0, 0.0, 1.0);

    ptr->material_diffuse[0] = 0.0;
    ptr->material_diffuse[1] = 0.0;
    ptr->material_diffuse[2] = 0.0;
    ptr->material_diffuse[3] = 1.0;

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = 0.0;
    buf[3] = 1.0;
    glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, buf);

    buf[0] = 1.0 / 8.0;
    buf[1] = 1.0 / 8.0;
    buf[2] = 1.0 / 8.0;
    buf[3] = 1.0;

    ptr->position[0] = 0.5;
    ptr->position[1] = 0.5;
    ptr->position[2] = 1.0;
    ptr->position[3] = 1.0;

    for (i = GL_LIGHT0; i <= GL_LIGHT7; i++) {
	glLightfv(i, GL_DIFFUSE, buf);
	glLightfv(i, GL_POSITION, ptr->position);
    }
}

static void SetRGB(void *data, float *ref)
{
    difMatRec *ptr = (difMatRec *)data;

    ptr->material_diffuse[ptr->color] = *ref;
    glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, ptr->material_diffuse);

    glBegin(GL_POINTS);
	glVertex2f(0.5, 0.5);
    glEnd();

    *ref += ptr->step;
}

static long TestRGB(void *data, float ref)
{
    difMatRec *ptr = (difMatRec *)data;
    char str[240];
    GLfloat buf[3]; 
    float value, delta;
    long i;

    ReadScreen(0, 0, 1, 1, GL_RGB, buf);

    for (i = 0; i < 3; i++) {
        if (buf[i] != 0.0 && i != ptr->color) {
            ColorError_RGBZero(str, ptr->color, buf);
            ErrorReport(__FILE__, __LINE__, str);
            return ERROR;
	}
    }

    value = buf[ptr->color];
    if (ptr->lastDelta == -2.0) {
	ptr->lastDelta = -1.0;
	ptr->lastValue = value;
    } else if (ptr->lastDelta == -1.0) {
	if (value < ptr->lastValue) {
            ColorError_RGBMonotonic(str, ptr->color, value, ptr->lastValue);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	if (ABS(delta) > epsilon.zero) {
	    if (ABS(delta-ptr->delta) > 0.25*epsilon.color[ptr->color]) {
                ColorError_RGBStep(str, ptr->color, delta, ptr->delta);
                ErrorReport(__FILE__, __LINE__, str);
		return ERROR;
	    }
	    ptr->lastDelta = delta;
	}
    } else {
	if (value < ptr->lastValue) {
            ColorError_RGBMonotonic(str, ptr->color, value, ptr->lastValue);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	if (ABS(delta) > epsilon.zero) {
	    if (ABS(delta-ptr->delta) > 0.25*epsilon.color[ptr->color]) {
                ColorError_RGBStep(str, ptr->color, delta, ptr->delta);
                ErrorReport(__FILE__, __LINE__, str);
		return ERROR;
	    }
	    if (ABS(delta-ptr->lastDelta) > epsilon.zero) {
                ColorError_RGBDelta(str, ptr->color, delta, ptr->lastDelta);
                ErrorReport(__FILE__, __LINE__, str);
		return ERROR;
	    }
	    ptr->lastDelta = delta;
	}
    }

    if (ref >= 1.0 && ABS(value-1.0) > epsilon.zero) {
        ColorError_RGBClamp(str, ptr->color, value);
        ErrorReport(__FILE__, __LINE__, str);
	return ERROR;
    }

    return NO_ERROR;
}

long DifMatRGBExec(void)
{
    difMatRec data;
    long max;

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glDisable(GL_DITHER);
    glEnable(GL_LIGHTING);

    max = (machine.pathLevel == 0) ? 3 : 1;
    for (data.color = 0; data.color < max; data.color++) {
	if (RampUtil(0.0, 1.0, InitRGB, SetRGB, TestRGB, &data) == ERROR) {
	    return ERROR;
	}
    }
    return NO_ERROR;
}

/****************************************************************************/

static void InitCI(void *data)
{
    difMatRec *ptr = (difMatRec *)data;
    GLfloat buf[4];
    GLenum i;

    ptr->lastValue = -1.0;
    ptr->lastDelta = -2.0;

    if (machine.pathLevel == 0) {
	ptr->step = 0.5 / ptr->numColor;
    } else {
	ptr->step = 0.25;
    }

    glNormal3f(0.0, 0.0, 1.0);

    for (i = GL_LIGHT0; i <= GL_LIGHT7; i++) {
	glEnable(i);

	buf[0] = 0.5;
	buf[1] = 0.5;
	buf[2] = 1.0;
	buf[3] = 1.0;
        glLightfv(i, GL_POSITION, buf);
	
	buf[0] = 1.0 / 8.0;
	buf[1] = 1.0 / 8.0;
	buf[2] = 1.0 / 8.0;
	buf[3] = 1.0;
	glLightfv(i, GL_DIFFUSE, buf);

	/*
	** The values below should make s' equal to 0.0.
	** Alpha for specular light is not used. See if wierd value
	** breaks something.
	*/

	buf[0] = 0.0;
	buf[1] = 0.0;
	buf[2] = 0.0;
	buf[3] = PI;
	glLightfv(i, GL_SPECULAR, buf);
    }
}

static void SetCI(void *data, float *ref)
{
    difMatRec *ptr = (difMatRec *)data;
    GLfloat index[3];

    index[0] = 0.0;
    index[1] = *ref * ptr->numColor;
    index[2] = ptr->numColor;
    glMaterialfv(GL_FRONT_AND_BACK, GL_COLOR_INDEXES, index);

    glBegin(GL_POINTS);
	glVertex2f(0.5, 0.5);
    glEnd();

    *ref += ptr->step;
}

static long TestCI(void *data, float ref)
{
    difMatRec *ptr = (difMatRec *)data;
    char str[240];
    GLfloat value;
    float expected, frac, delta;

    ReadScreen(0, 0, 1, 1, GL_COLOR_INDEX, &value);

    frac = ABS(value-(float)((int)value));
    if (frac > epsilon.zero && ABS(frac-1.0) > epsilon.zero) {
        ColorError_CIFrac(str, value);
        ErrorReport(__FILE__, __LINE__, str);
	return ERROR;
    }

    if (ptr->lastValue == -1.0) {
	ptr->lastValue = value;
    } else {
	if (value < ptr->lastValue) {
            ColorError_CIMonotonic(str, value, ptr->lastValue);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
	expected = (float)Round(2.0*ref*ptr->numColor) / 2.0;

	if (ABS(value-expected) > (3.0*epsilon.ci+epsilon.zero)) {
            ColorError_CIBad(str, value, expected);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	if (ABS(delta) > epsilon.zero) {
	    if (ABS(delta) >= 2.0 && machine.pathLevel == 0) {
                ColorError_CIStep(str, delta);
                ErrorReport(__FILE__, __LINE__, str);
		return ERROR;
	    }
	}
    }

    if (ref >= 1.0 && value < ptr->numColor) {
        ColorError_CIClamp(str, ptr->numColor, value);
        ErrorReport(__FILE__, __LINE__, str);
	return ERROR;
    }
    return NO_ERROR;
}

long DifMatCIExec(void)
{
    difMatRec data;
    float start, end, frac;

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glDisable(GL_DITHER);
    glEnable(GL_LIGHTING);

    data.numColor = POW(2.0, (float)buffer.ciBits) - 1.0;
    if (data.numColor < 4096.0 || (machine.pathLevel != 0)) {
	if (RampUtil(0.0, 1.0, InitCI, SetCI, TestCI, &data) == ERROR) {
	    return ERROR;
	}
    } else {
	start = 0.5 / data.numColor;
	frac = POW(2.0, (float)(8-buffer.ciBits));
	if (RampUtil(start, frac, InitCI, SetCI, TestCI, &data) == ERROR) {
	    return ERROR;
	}
	start = 0.5 - frac;
	end = 0.5 + frac;
	if (RampUtil(start, end, InitCI, SetCI, TestCI, &data) == ERROR) {
	    return ERROR;
	}
	start = 1.0 - frac;
	if (RampUtil(start, 1.0, InitCI, SetCI, TestCI, &data) == ERROR) {
	    return ERROR;
	}
    }
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\l_sep.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** l_sep.c
** Light - Spot Exponent Position Test.
**
** Description -
**    This test analyses the effect that varying the
**    Spotlight_Direction has on the color produced by lighting.
**    This file contains code for both CI and RGB tests. To
**    analyse only this one parameter, the RGB test uses a
**    different analysis from that of the CI test. In RGB mode
**    the Ambient summand is used, and in CI mode the Specular
**    summand is used. In both modes the test repeats itself with
**    different Spot_Exponents and Cutoff_Angles.
**    
**    In RGB mode the Ambient_Material is set so that one color
**    channel is fully saturated, and the other channels are set
**    to 0.0. All three channels are tested. The implementation
**    fails if any color channel not being tested is not observed
**    to be 0.0. The Ambient_Light is set to (1, 1, 1, 1). Other
**    lighting parameters are chosen so that the Diffuse,
**    Specular, and Emissive summands of the RGB lighting are set
**    to zero.
**    
**    In CI mode the Specular_Light is set to (1, 1, 1, 1) and
**    the Specular_Material is set to maxIndex. The Diffuse and
**    Ambient summands are 0.0. Values are chosen so the
**    Attenuation factor is 1.0.
**    
**    The test repeatedly renders and reads the same point at the
**    lower left corner of the screen. The third component of the
**    Spotlight_Direction is incremented by a an amount sensitive
**    to the Spotlight_Exponent being tested. The increment is
**    controlled so that the observed resulting color would
**    theoretically increment uniformly. (This controlled
**    incrementation takes place in the routine called Set()
**    below). The other two components of the Spotlight_Direction
**    are adjusted so that the total length of the
**    Spotlight_Direction vector is 1. The rendered point's eye
**    position and the Spotlight_Position are set so that the
**    vector from the Spotlight_Position to rendered point's eye
**    position, PV, is (0, 0, 1). With these settings
**    (SpotDirection dot PV) = SpotDirection[2].
**    
**    In both modes if the theoretically calculated Spot_Exponent
**    factor indicates that the Cutoff_Angle would cause the
**    object to render black, the implementation fails if the
**    observed color is not black. If the expected value
**    indicates that the observed color should not be "cutoff"
**    the implementation fails if the color is more than 5% away
**    from the theoretical correct value. A margin around the
**    cutoff angle of 1% is used. In both modes one light is
**    enabled at a time, all lights are individually tested. The
**    observed results are compared to the theoretical value.
**    The error here is 5% for bright shades and one colorEpsilon
**    for dark shades. This test will not run with less than 3
**    bits of color per channel. When Spotlight_Position[2]
**    reaches 1.0, the color is finally checked to insure that
**    the point has rendered with a fully saturated color. The
**    observed results are also checked for monoticity.
**    
**    In CI mode a check is made to ensure that the observed
**    index reaches its max. The observed shade is compared to
**    the theoretical value expected for each setting of
**    Light_Position. For high indices if the theoretical value
**    is more than 0.05 * max index away from the observed index
**    the test fails. Darker colors must be within 1 indices.
**    The observed value must be an integer, and the difference
**    between successive observances must be less than 2.
**
** Error Explanation -
**    RGB mode: other_color > 0.0.
**    RGB mode: value < lastValue.
**    RGB mode: maxObserved < 1.0.
**    RGB mode: ABS(value - expected) > 0.05.
**    RGB mode: ABS(thisDelta - lastDelta) > 1/4 shade.
**    CI mode: index not an integer.
**    CI mode: (observed - expected) > 3.0.
**    CI mode: observedMax < maxIndex.
**    CI mode: delta > 2.0.
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer.
**    Color requirements:
**        RGBA or color index mode. Full color.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**        Color, ci and zero epsilons, 0.25*color_epsilon.
**    Paths:
**        Allowed = Alpha, Blend, Depth, Logicop, Stencil, Stipple.
**        Not allowed = Alias, Dither, Fog, Shade.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"
#include "utilru.h"


typedef struct _spotExpPosRec {
    long color;
    float step, numColor, lastValue, lastDelta, firstDelta;
    GLenum light, expIndex;
    float angle, cosCutoff, cutoffMargin;
    GLfloat exp, position[4], direction[3];
    float errConst;
} spotExpPosRec;


/*****************************************************************************/

static void Set(void *data, float *ref)
{
    spotExpPosRec *ptr = (spotExpPosRec *)data;

    ptr->position[0] = 0.5 + SQRT(1.0-(*ref)*(*ref));
    ptr->position[1] = 0.5;
    ptr->position[2] = *ref;
    glLightfv(ptr->light, GL_POSITION, ptr->position);

    glBegin(GL_POINTS);
	glVertex2f(0.5, 0.5);
    glEnd();

    *ref = POW(*ref, (double)ptr->exp);
    *ref += ptr->step;
    *ref = POW(*ref, 1.0/ptr->exp);
}

/****************************************************************************/

static void InitRGB(void *data)
{
    spotExpPosRec *ptr = (spotExpPosRec *)data;
    GLfloat buf[4];
    GLenum i;

    ptr->lastValue = -1.0;
    ptr->lastDelta = -2.0;

    if (machine.pathLevel == 0) {
	ptr->step = 0.5 / ptr->numColor;
    } else {
	ptr->step = 0.25;
    }

    ptr->errConst = (ptr->exp < 8) ? 0.05 : 0.1;

    ptr->light = GL_LIGHT0 + (ptr->expIndex % 8);
    for (i = GL_LIGHT0; i <= GL_LIGHT7; i++) {
	glDisable(i);
    }
    glEnable(ptr->light);

    ptr->angle = Random(0.0, 90.0);
    glLightf(ptr->light, GL_SPOT_CUTOFF, ptr->angle);
    ptr->cosCutoff = COS(ptr->angle*PI/180.0);
    ptr->cutoffMargin = 0.01;

    ptr->direction[0] = 0.0;
    ptr->direction[1] = 0.0;
    ptr->direction[2] = -1.0;
    glLightfv(ptr->light, GL_SPOT_DIRECTION, ptr->direction);

    ptr->position[0] = 0.0;
    ptr->position[1] = 0.0;
    ptr->position[2] = 0.0;
    ptr->position[3] = 1.0;

    glLightf(ptr->light, GL_SPOT_EXPONENT, ptr->exp);

    buf[0] = 1.0;
    buf[1] = 1.0;
    buf[2] = 1.0;
    buf[3] = 1.0;
    glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, buf);

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = 0.0;
    buf[3] = 1.0;
    buf[ptr->color] = 1.0;
    glLightfv(ptr->light, GL_AMBIENT, buf);

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = 0.0;
    buf[3] = 1.0;
    glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, buf);
    glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, buf);
    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, buf);
}

static long TestRGB(void *data, float ref)
{
    spotExpPosRec *ptr = (spotExpPosRec *)data;
    GLfloat buf[3]; 
    float value, expected, delta, error;
    long i, cutoff, noCutoff;

    ReadScreen(0, 0, 1, 1, GL_RGB, buf);

    for (i = 1; i < 3; i++) {
	if (buf[i] != 0.0 && i != ptr->color) {
	    return ERROR;
	}
    }

    expected = POW(ref, (double)ptr->exp);
   
    /*
    ** These errors will not work for a badly implemented lookup table.
    */
    if (ptr->numColor > 0) {
	if (expected < (1.0/ptr->numColor)) {
	    error = epsilon.color[ptr->color];
	} else {
	    error = ptr->errConst;
	    if (epsilon.color[ptr->color] > error) {
		error = epsilon.color[ptr->color];
	    }
	}
    } else {
	error = epsilon.color[ptr->color];
    }

    value = buf[ptr->color];

    cutoff = (ref < ptr->cosCutoff-ptr->cutoffMargin);
    noCutoff = (ref > ptr->cosCutoff+ptr->cutoffMargin);
    if (cutoff) {
	if (value > 0.5*epsilon.color[ptr->color]) {
	    return ERROR;
	}
    } else {
	if (noCutoff) {
	    if (ABS(value-expected) > error) {
		return ERROR;
	    }
	}
    }

    /*
    ** The input would create output with constant delta, but
    ** this will not work with lookup tables.
    */
    if (ptr->lastDelta == -2.0) {
	ptr->lastDelta = -1.0;
	ptr->lastValue = value;
    } else if (ptr->lastDelta == -1.0) {
	if (value < ptr->lastValue) {
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	if (ABS(delta) > epsilon.zero) {
	    ptr->lastDelta = delta;
	}
    } else {
	if (value < ptr->lastValue) {
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	if (ABS(delta) > epsilon.zero) {
	    ptr->lastDelta = delta;
	}
    }
    if (ref >= 1.0 && ABS(value-1.0) > epsilon.zero) {
	return ERROR;
    }
    return NO_ERROR;
}

long SpotExpPosRGBExec(void)
{
    static float expSlow[] = {
	1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 12.0, 15.0, 19.0, 26.0, 37.0, 49.0,
	64.0, 81.0, 107.0, 116.0, 125.0, 126.0, 127.0, 128.0
    };
    static float expFast[] = {
	1.0, 66.0, 128.0
    };
    spotExpPosRec data;
    float start, *exp_ptr;
    long max;

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glDisable(GL_DITHER);
    glEnable(GL_LIGHTING);

    max = (machine.pathLevel == 0) ? 21 : 3;
    exp_ptr = (machine.pathLevel == 0) ? expSlow : expFast;
    for (data.expIndex = 0; data.expIndex < max; data.expIndex++) {
	data.color = data.expIndex % 3;
	data.exp = exp_ptr[data.expIndex];
	data.numColor = POW(2.0, (float)buffer.colorBits[data.color]) - 1.0;
	start = POW(0.5/data.numColor, 1.0/data.exp);
	if (RampUtil(0.0, 1.0, InitRGB, Set, TestRGB, &data) == ERROR) {
	    ErrorReport(__FILE__, __LINE__, 0);
	    return ERROR;
	}
    }
    return NO_ERROR;
}

/****************************************************************************/

static void InitCI(void *data)
{
    spotExpPosRec *ptr = (spotExpPosRec *)data;
    GLfloat buf[4];
    GLenum i;

    ptr->lastValue = -1.0;
    ptr->firstDelta = -1.0;

    if (machine.pathLevel == 0) {
	ptr->step = 0.5 / ptr->numColor;
    } else {
	ptr->step = 0.25;
    }

    ptr->light = GL_LIGHT0 + (ptr->expIndex % 8);
    for (i = GL_LIGHT0; i <= GL_LIGHT7; i++) {
	glDisable(i);
    }
    glEnable(ptr->light);

    ptr->angle = Random(0.0, 90.0);
    glLightf(ptr->light, GL_SPOT_CUTOFF, ptr->angle);
    ptr->cosCutoff = COS(ptr->angle*PI/180.0);
    ptr->cutoffMargin = 0.01;

    ptr->direction[0] = 0.0;
    ptr->direction[1] = 0.0;
    ptr->direction[2] = -1.0;
    glLightfv(ptr->light, GL_SPOT_DIRECTION, ptr->direction);
  
    ptr->position[0] = 0.0;
    ptr->position[1] = 0.0;
    ptr->position[2] = 0.0;
    ptr->position[3] = 1.0;

    glLightfv(ptr->light, GL_SPOT_EXPONENT, &ptr->exp);
   
    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = ptr->numColor;
    glMaterialfv(GL_FRONT_AND_BACK, GL_COLOR_INDEXES, buf);

    buf[0] = 1.0;
    buf[1] = 1.0;
    buf[2] = 1.0;
    buf[3] = PI;
    glLightfv(ptr->light, GL_SPECULAR, buf);
    /*
    ** Diffuse values should have no affect in CI mode,
    ** as should specular alpha.
    */
    glLightfv(ptr->light, GL_DIFFUSE, buf);
}

static long TestCI(void *data, float ref)
{
    spotExpPosRec *ptr = (spotExpPosRec *)data;
    GLfloat value;
    float expected, frac, delta, error;
    long cutoff, noCutoff;

    ReadScreen(0, 0, 1, 1, GL_COLOR_INDEX, &value);

    frac = ABS(value-(float)((int)value));
    if (frac > epsilon.zero && ABS(frac-1.0) > epsilon.zero) {
	return ERROR;
    }

    if (ptr->lastValue == -1.0) {
	ptr->lastValue = value;
    } else {
	if (value < ptr->lastValue) {
	    return ERROR;
	}

	expected = (float)Round(2.0*POW(ref, ptr->exp)*ptr->numColor) / 2.0;

	/*
	** These errors will cause implementations to fail if they use look-up
	** tables which only return a couple of values for high exponents.
	*/
	if (ptr->numColor > 0) {
	    if (expected < (1.0/ptr->numColor)) {
		error = 2.0 * epsilon.ci;
	    } else {
		error = 0.05 * ptr->numColor;
		if (2.0*epsilon.ci > error) {
		    error = 2.0 * epsilon.ci;
		}
	    }
	} else {
	    error = epsilon.ci;
	}

	cutoff = (ref < ptr->cosCutoff-ptr->cutoffMargin);
	noCutoff = (ref > ptr->cosCutoff+ptr->cutoffMargin);
	if (cutoff) {
	    if (value > epsilon.ci) {
		return ERROR;
	    }
	} else {
	    if (noCutoff) {
		if (ABS(value-expected) >= error) {
		    return ERROR;
		}
	    }
	}

	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	if (ABS(delta) > epsilon.zero) {
	    if (ptr->firstDelta == -1.0) {
		ptr->firstDelta = 1.0;
	    } else {
		if (ABS(delta) > ((error > 2.0) ? error : 2.0) &&
			       machine.pathLevel == 0) {
		    return ERROR;
		}
	    }
	}
    }

    if (ref >= 1.0 && value < ptr->numColor) {
	return ERROR;
    }
    return NO_ERROR;
}

long SpotExpPosCIExec(void)
{
    static float expSlow[] = {
	1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 12.0, 15.0, 19.0, 26.0, 37.0, 49.0,
	64.0, 81.0, 107.0, 116.0, 125.0, 126.0, 127.0, 128.0
    };
    static float expFast[] = {
	1.0, 66.0, 128.0
    };
    spotExpPosRec data;
    float start, end, frac, *exp_ptr;
    long max;

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glDisable(GL_DITHER);
    glEnable(GL_LIGHTING);

    max = (machine.pathLevel == 0) ? 21 : 3;
    exp_ptr = (machine.pathLevel == 0) ? expSlow : expFast;
    data.numColor = POW(2.0, (float)buffer.ciBits) - 1.0;
    frac = POW(2.0, (float)(8-buffer.ciBits));
    for (data.expIndex = 0; data.expIndex < max; data.expIndex++) {
	data.exp = exp_ptr[data.expIndex];
	if (data.numColor < 4096.0 || machine.pathLevel != 0) {
	    start = POW(0.5/data.numColor, 1.0/data.exp);
	    if (RampUtil(start, 1.0, InitCI, Set, TestCI, &data) == ERROR) {
		ErrorReport(__FILE__, __LINE__, 0);
		return ERROR;
	    }
	} else {
	    start = POW(0.5/data.numColor, 1.0/data.exp);
	    end = POW(frac, 1.0/data.exp);
	    if (RampUtil(start, end, InitCI, Set, TestCI, &data) == ERROR) {
		ErrorReport(__FILE__, __LINE__, 0);
		return ERROR;
	    }
	    start = POW(0.5-frac, 1.0/data.exp);
	    end = POW(0.5+frac, 1.0/ data.exp);
	    if (RampUtil(start, end, InitCI, Set, TestCI, &data) == ERROR) {
		ErrorReport(__FILE__, __LINE__, 0);
		return ERROR;
	    }
	    start = POW(1.0-frac, 1.0/data.exp);
	    if (RampUtil(start, 1.0, InitCI, Set, TestCI, &data) == ERROR) {
		ErrorReport(__FILE__, __LINE__, 0);
		return ERROR;
	    }
	}
    }
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\l_dmn.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** l_dmn.c
** Light - Diffuse Material Normal Test.
**
** Description -
**    This file contains code for CI and RGB tests. This test
**    analyses the effect that varying the Normal has on the
**    color produced by lighting, by way of its effect on the
**    Diffuse summand. To analyse only this one parameter, the
**    Diffuse_Lighting factor is set to a completely saturated
**    red in RGB mode and max index in CI mode. In RGB mode
**    lighting parameters are chosen so that the Specular,
**    Ambient, and Emissive summands of the lighting equation are
**    set to 0.0, and the Attenuation and the Spotlight factor
**    are both 1.0. In CI mode s_prime is 0, Diffuse_Material is
**    maxIndex, Diffuse_Light is (1, 1, 1, 1). The SpotLight and
**    Attenuation factors are 1.0.
**    
**    The test repeatedly renders and reads the same point at the
**    lower left corner of the screen. The third component of the
**    Normal is incremented by a uniform amount. The other two
**    components of Normal are set so that the total length of
**    the Normal is 1. The Light_Position is set so that the
**    vector, PV, from the eye position of the rendered point to
**    the Light_Position is (0, 0, 1, 1). (Normal dot PV) =
**    Normal[2]). The lighting equation is reduced to color = red
**    * Normal[2] in RGB mode, or colorIndex = max index *
**    Normal[2] in CI mode.
**    
**    In RGB mode only the red color channel is tested. The
**    implementation fails if any other color channel is not
**    black. In both modes one light is enabled at a time, all
**    individual lights are tested.
**    
**    In RGB mode the uniformity of the change is tested, and the
**    implementation fails if consecutive changes are too
**    different. (thisDelta - lastDelta) > 1/4 shade. The
**    observed results are also checked for monotonicity. When
**    Normal[2] reaches 1.0 the color is finally checked to
**    insure that the point has rendered with a fully saturated
**    red.
**    
**    In CI mode a check is made to ensure that the observed
**    index reaches its max. The observed shade is compared to
**    the theoretical value expected for each setting of
**    Light_Position. If the theoretical value is more than 3
**    indices away from the observed index the test fails. The
**    observed value must be an integer, and the difference
**    between successive observances must be less than 2.
**
** Error Explanation -
**    RGB mode: other_color > 0.0.
**    RGB mode: value < lastValue.
**    RGB mode: maxObserved < 1.0.
**    RGB mode: (thisDelta - lastDelta) > 1/4 shade.
**    CI mode: (fractional index) != 0.0.
**    CI mode: (observed - expected) > 3.0.
**    CI mode: observedMax < numColor.
**    CI mode: delta > 2.0.
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer.
**    Color requirements:
**        RGBA or color index mode. Full color.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**        Color, ci and zero epsilons, 0.25*color_epsilon.
**    Paths:
**        Allowed = Alpha, Blend, Depth, Logicop, Stencil, Stipple.
**        Not allowed = Alias, Dither, Fog, Shade.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"
#include "utilru.h"


typedef struct _difMatNormRec {
    float step, numColor, lastValue, lastDelta, delta;
    GLenum light;
    GLfloat normal[3], position[4];
} difMatNormRec;


/*****************************************************************************/

static void Set(void *data, float *ref)
{
    difMatNormRec *ptr = (difMatNormRec *)data;

    ptr->normal[2] = *ref;
    ptr->normal[0] = SQRT(1.0-(ptr->normal[2]*ptr->normal[2]));
    glNormal3fv(ptr->normal);

    glBegin(GL_POINTS);
	glVertex2f(0.5, 0.5);
    glEnd();

    *ref += ptr->step;
}

/****************************************************************************/

static void InitRGB(void *data)
{
    difMatNormRec *ptr = (difMatNormRec *)data;
    GLfloat buf[4];
    float step;
    GLenum i;

    ptr->lastValue = -1.0;
    ptr->lastDelta = -2.0;

    step = (machine.pathLevel == 0) ? 4.0 : 2.0;
    ptr->delta = 1.0 / (POW(2.0, (float)buffer.colorBits[0]) - 1.0);
    ptr->step = ptr->delta / step;

    for (i = GL_LIGHT0; i <= GL_LIGHT7; i++) {
	glDisable(i);
    }
    glEnable(ptr->light);

    ptr->normal[0] = 0.0;
    ptr->normal[1] = 0.0;
    ptr->normal[2] = 0.0;

    ptr->position[0] = 0.5;
    ptr->position[1] = 0.5;
    ptr->position[2] = 1.0;
    ptr->position[3] = 1.0;
    glLightfv(ptr->light, GL_POSITION, ptr->position);

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = 0.0;
    buf[3] = 1.0;
    glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, buf);

    buf[0] = 1.0;
    buf[1] = 0.0;
    buf[2] = 0.0;
    buf[3] = 1.0;
    glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, buf);

    buf[0] = 1.0;
    buf[1] = 1.0;
    buf[2] = 1.0;
    buf[3] = 1.0;
    glLightfv(ptr->light, GL_DIFFUSE, buf);
}

static long TestRGB(void *data, float ref)
{
    difMatNormRec *ptr = (difMatNormRec *)data;
    char str[240];
    GLfloat buf[3]; 
    float value, delta;
    long i;

    ReadScreen(0, 0, 1, 1, GL_RGB, buf);

    for (i = 1; i < 3; i++) {
	if (buf[i] != 0.0) {
            ColorError_RGBZero(str, 0, buf);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
    }

    value = buf[0];
    if (ptr->lastDelta == -2.0) {
	ptr->lastDelta = -1.0;
	ptr->lastValue = value;
    } else if (ptr->lastDelta == -1.0) {
	if (value < ptr->lastValue) {
            ColorError_RGBMonotonic(str, 0, value, ptr->lastValue);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	if (ABS(delta) > epsilon.zero) {
	    if (ABS(delta-ptr->delta) > 0.25*epsilon.color[0]) {
                ColorError_RGBStep(str, 0, delta, ptr->delta);
                ErrorReport(__FILE__, __LINE__, str);
		return ERROR;
	    }
	    ptr->lastDelta = delta;
	}
    } else {
	if (value < ptr->lastValue) {
            ColorError_RGBMonotonic(str, 0, value, ptr->lastValue);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	if (ABS(delta) > epsilon.zero) {
	    if (ABS(delta-ptr->delta) > 0.25*epsilon.color[0]) {
                ColorError_RGBStep(str, 0, delta, ptr->delta);
                ErrorReport(__FILE__, __LINE__, str);
		return ERROR;
	    }
	    if (ABS(delta-ptr->lastDelta) > epsilon.zero) {
                ColorError_RGBDelta(str, 0, delta, ptr->lastDelta);
                ErrorReport(__FILE__, __LINE__, str);
		return ERROR;
	    }
	    ptr->lastDelta = delta;
	}
    }

    if (ref >= 1.0 && ABS(value-1.0) > epsilon.zero) {
        ColorError_RGBClamp(str, 0, value);
        ErrorReport(__FILE__, __LINE__, str);
	return ERROR;
    }

    return NO_ERROR;
}

long DifMatNormRGBExec(void)
{
    difMatNormRec data;
    long max;

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glDisable(GL_DITHER);
    glEnable(GL_LIGHTING);

    max = (machine.pathLevel == 0) ? GL_LIGHT7 : GL_LIGHT0;
    for (data.light = GL_LIGHT0; data.light <= max; data.light++) {
	if (RampUtil(0.0, 1.0, InitRGB, Set, TestRGB, &data) == ERROR) {
	    return ERROR;
	}
    }
    return NO_ERROR;
}

/****************************************************************************/

static void InitCI(void *data)
{
    difMatNormRec *ptr = (difMatNormRec *)data;
    GLfloat buf[4];
    GLenum i;

    ptr->lastValue = -1.0;

    if (machine.pathLevel == 0) {
	ptr->step = 0.5 / ptr->numColor;
    } else {
	ptr->step = 0.25;
    }

    for (i = GL_LIGHT0; i <= GL_LIGHT7; i++) {
	glDisable(i);
    }
    glEnable(ptr->light);

    ptr->normal[0] = 0.0;
    ptr->normal[1] = 0.0;
    ptr->normal[2] = 0.0;

    ptr->position[0] = 0.5;
    ptr->position[1] = 0.5;
    ptr->position[2] = 1.0;
    ptr->position[3] = 1.0;
    glLightfv(ptr->light, GL_POSITION, ptr->position);

    buf[0] = 0.0;
    buf[1] = ptr->numColor;
    buf[2] = ptr->numColor;
    glMaterialfv(GL_FRONT_AND_BACK, GL_COLOR_INDEXES, buf);

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = 0.0;
    buf[3] = PI;
    glLightfv(ptr->light, GL_SPECULAR, buf);

    buf[0] = 1.0;
    buf[1] = 1.0;
    buf[2] = 1.0;
    buf[3] = PI;
    glLightfv(ptr->light, GL_DIFFUSE, buf);
}

static long TestCI(void *data, float ref)
{
    difMatNormRec *ptr = (difMatNormRec *)data;
    char str[240];
    GLfloat value;
    float expected, frac, delta;

    ReadScreen(0, 0, 1, 1, GL_COLOR_INDEX, &value);

    frac = ABS(value-(float)((int)value));
    if (frac > epsilon.zero && ABS(frac-1.0) > epsilon.zero) {
        ColorError_CIFrac(str, value);
        ErrorReport(__FILE__, __LINE__, str);
	return ERROR;
    }

    if (ptr->lastValue == -1.0) {
	ptr->lastValue = value;
    } else {
	if (value < ptr->lastValue) {
            ColorError_CIMonotonic(str, value, ptr->lastValue);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
	expected = (float)Round(2.0*ref*ptr->numColor) / 2.0;

	if (ABS(value-expected) > 3.0*epsilon.ci+epsilon.zero) {
            ColorError_CIBad(str, value, expected);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	if (ABS(delta) > epsilon.zero) {
	    if (ABS(delta) >= 2.0 && machine.pathLevel == 0) {
                ColorError_CIStep(str, delta);
                ErrorReport(__FILE__, __LINE__, str);
		return ERROR;
	    }
	}
    }

    if (ref >= 1.0 && value < ptr->numColor) {
        ColorError_CIClamp(str, ptr->numColor, value);
        ErrorReport(__FILE__, __LINE__, str);
	return ERROR;
    }
    return NO_ERROR;
}

long DifMatNormCIExec(void)
{
    difMatNormRec data;
    float frac, start, end;
    long max;

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glDisable(GL_DITHER);
    glEnable(GL_LIGHTING);

    max = (machine.pathLevel == 0) ? GL_LIGHT7 : GL_LIGHT0;
    data.numColor = POW(2.0, (float)buffer.ciBits) - 1.0;
    for (data.light = GL_LIGHT0; data.light <= max; data.light++) {
	if (data.numColor < 4096.0 || (machine.pathLevel != 0)) {
	    if (RampUtil(0.0, 1.0, InitCI, Set, TestCI, &data) == ERROR) {
		return ERROR;
	    }
	} else {
	    start = 0.5 / data.numColor;
	    frac = POW(2.0, (float)(8-buffer.ciBits));
	    if (RampUtil(start, frac, InitCI, Set, TestCI, &data) == ERROR) {
		return ERROR;
	    }
	    start = 0.5 - frac;
	    end = 0.5 + frac;
	    if (RampUtil(start, end, InitCI, Set, TestCI, &data) == ERROR) {
		return ERROR;
	    }
	    start = 1.0 - frac;
	    if (RampUtil(start, 1.0, InitCI, Set, TestCI, &data) == ERROR) {
		return ERROR;
	    }
	}
    }
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\l_dmp.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** l_dmp.c
** Light - Diffuse Material Position Test.
**
** Description -
**    This test analyses the effect that varying the
**    Light_Position has on the color produced by lighting, by
**    way of its effect on the Diffuse summand. CI lighting
**    differs from RGB lighting. This file contains code for both
**    tests. To analyse only this one parameter, the Diffuse
**    lighting factor is set to a completely saturated red, other
**    lighting parameters are chosen so that the Specular,
**    Ambient, and Emissive summands of the RGB or CI lighting
**    are set to zero, and values are chosen so the Attenuation
**    and the Spotlight factor are both 1.0.
**    
**    The test repeatedly renders and reads the same point at the
**    lower left corner of the screen. The third component of the
**    Light_Position is iterated by a uniform amount. The other
**    two components of Light_Position are set so that the total
**    length of the vector, V, which is the difference between
**    the rendered point's eye position and the Light_Position is
**    1. The Normal vector is set to (0, 0, 1) so the
**    Light_Position factor is V[2], (Normal dot V) = V[2]). The
**    lighting equation becomes either color = red * V[2] or
**    colorIndex = max index * V[2].
**    
**    In RGB mode only the red color channel is tested. The
**    implementation fails if any other color channel is not
**    black. In both modes one light is enabled at a time, all
**    individual lights are tested.
**    
**    In RGB mode the uniformity of the change is tested, and the
**    implementation fails if consecutive changes are too
**    different. (thisDelta - lastDelta) > 1/4 shade. The
**    observed results are also checked for monotonicity. When
**    Light_Position[2] reaches 1.0 the color is finally checked
**    to insure that the point has rendered with a fully
**    saturated red.
**    
**    In CI mode a check is made to ensure that the observed
**    index reaches its max. The observed shade is compared to
**    the theoretical value expected for each setting of
**    Light_Position. If the theoretical value is more than 3
**    indices away from the observed index the test fails. The
**    observed value must be an integer, and the difference
**    between successive observances must be less than 2.
**
** Error Explanation -
**    RGB mode: other_color > 0.0.
**    RGB mode: value < lastValue.
**    RGB mode: maxObserved < 1.0.
**    RGB mode: (thisDelta - lastDelta) > 1/4 shade.
**    CI mode: (fractional index) != 0.0.
**    CI mode: (observed - expected) > 3.0.
**    CI mode: observedMax < numColor.
**    CI mode: delta > 2.0.
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer.
**    Color requirements:
**        RGBA or color index mode. Full color.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**        Color, ci and zero epsilons, 0.25*color_epsilon.
**    Paths:
**        Allowed = Alpha, Blend, Depth, Logicop, Stencil, Stipple.
**        Not allowed = Alias, Dither, Fog, Shade.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"
#include "utilru.h"


typedef struct _difMatPosRec {
    float step, numColor, lastValue, lastDelta, delta;
    GLenum light;
    GLfloat position[4];
} difMatPosRec;


/*****************************************************************************/

static void Set(void *data, float *ref)
{
    difMatPosRec *ptr = (difMatPosRec *)data;

    ptr->position[2] = (*ref <= 1.0) ? *ref : 1.0;
    ptr->position[1] = 0.5;
    ptr->position[0] = 0.5 + SQRT(1.0-ptr->position[2]*ptr->position[2]);
    glLightfv(ptr->light, GL_POSITION, ptr->position);

    glBegin(GL_POINTS);
	glVertex2f(0.5, 0.5);
    glEnd();

    *ref += ptr->step;
}

/****************************************************************************/

static void InitRGB(void *data)
{
    difMatPosRec *ptr = (difMatPosRec *)data;
    GLfloat buf[4];
    float step;
    GLenum i;

    ptr->lastValue = -1.0;
    ptr->lastDelta = -2.0;

    step = (machine.pathLevel == 0) ? 4.0 : 2.0;
    ptr->delta = 1.0 / (POW(2.0, (float)buffer.colorBits[0]) - 1.0);
    ptr->step = ptr->delta / step;

    for (i = GL_LIGHT0; i <= GL_LIGHT7; i++) {
	glDisable(i);
    }
    glEnable(ptr->light);

    ptr->position[0] = 0.0;
    ptr->position[1] = 0.0;
    ptr->position[2] = 0.0;
    ptr->position[3] = 1.0;

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = 1.0;
    glNormal3fv(buf);

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = 0.0;
    buf[3] = 1.0;
    glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, buf);

    buf[0] = 1.0;
    buf[1] = 0.0;
    buf[2] = 0.0;
    buf[3] = 1.0;
    glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, buf);

    buf[0] = 1.0;
    buf[1] = 1.0;
    buf[2] = 1.0;
    buf[3] = 1.0;
    glLightfv(ptr->light, GL_DIFFUSE, buf);
}

static long TestRGB(void *data, float ref)
{
    difMatPosRec *ptr = (difMatPosRec *)data;
    char str[240];
    GLfloat buf[3]; 
    float value, delta;
    long i;

    ReadScreen(0, 0, 1, 1, GL_RGB, buf);

    for (i = 1; i < 3; i++) {
	if (buf[i] != 0.0) {
            ColorError_RGBZero(str, 0, buf);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
    }

    value = buf[0];
    if (ptr->lastDelta == -2.0) {
	ptr->lastDelta = -1.0;
	ptr->lastValue = value;
    } else if (ptr->lastDelta == -1.0) {
	if (value < ptr->lastValue) {
            ColorError_RGBMonotonic(str, 0, value, ptr->lastValue);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	if (ABS(delta) > epsilon.zero) {
	    if (ABS(delta-ptr->delta) > 0.25*epsilon.color[0]) {
                ColorError_RGBStep(str, 0, delta, ptr->delta);
                ErrorReport(__FILE__, __LINE__, str);
		return ERROR;
	    }
	    ptr->lastDelta = delta;
	}
    } else {
	if (value < ptr->lastValue) {
            ColorError_RGBMonotonic(str, 0, value, ptr->lastValue);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	if (ABS(delta) > epsilon.zero) {
	    if (ABS(delta-ptr->delta) > 0.25*epsilon.color[0]) {
                ColorError_RGBStep(str, 0, delta, ptr->delta);
                ErrorReport(__FILE__, __LINE__, str);
		return ERROR;
	    }
	    if (ABS(delta-ptr->lastDelta) > epsilon.zero) {
                ColorError_RGBDelta(str, 0, delta, ptr->lastDelta);
                ErrorReport(__FILE__, __LINE__, str);
		return ERROR;
	    }
	    ptr->lastDelta = delta;
	}
    }

    if (ref >= 1.0 && ABS(value-1.0) > epsilon.zero) {
        ColorError_RGBClamp(str, 0, value);
        ErrorReport(__FILE__, __LINE__, str);
	return ERROR;
    }

    return NO_ERROR;
}

long DifMatPosRGBExec(void)
{
    difMatPosRec data;
    long max;

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glDisable(GL_DITHER);
    glEnable(GL_LIGHTING);

    max = (machine.pathLevel == 0) ? GL_LIGHT7 : GL_LIGHT0;
    for (data.light = GL_LIGHT0; data.light <= max; data.light++) {
	if (RampUtil(0.0, 1.0, InitRGB, Set, TestRGB, &data) == ERROR) {
	    return ERROR;
	}
    }
    return NO_ERROR;
}

/***************************************************************************/

static void InitCI(void *data)
{
    difMatPosRec *ptr = (difMatPosRec *)data;
    GLfloat buf[4];
    GLenum i;

    ptr->lastValue = -1.0;

    if (machine.pathLevel == 0) {
	ptr->step = 0.5 / ptr->numColor;
    } else {
	ptr->step = 0.25;
    }

    for (i = GL_LIGHT0; i <= GL_LIGHT7; i++) {
	glDisable(i);
    }
    glEnable(ptr->light);

    ptr->position[0] = 0.0;
    ptr->position[1] = 0.0;
    ptr->position[2] = 0.0;
    ptr->position[3] = 1.0;

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = 1.0;
    glNormal3fv(buf);

    buf[0] = 0.0;
    buf[1] = ptr->numColor;
    buf[2] = ptr->numColor;
    glMaterialfv(GL_FRONT_AND_BACK, GL_COLOR_INDEXES, buf);

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = 0.0;
    buf[3] = PI;
    glLightfv(ptr->light, GL_SPECULAR, buf);

    buf[0] = 1.0;
    buf[1] = 1.0;
    buf[2] = 1.0;
    buf[3] = PI;
    glLightfv(ptr->light, GL_DIFFUSE, buf);
}

static long TestCI(void *data, float ref)
{
    difMatPosRec *ptr = (difMatPosRec *)data;
    char str[240];
    GLfloat value;
    float expected, frac, delta;

    ReadScreen(0, 0, 1, 1, GL_COLOR_INDEX, &value);

    frac = ABS(value-(float)((int)value));
    if (frac > epsilon.zero && ABS(frac-1.0) > epsilon.zero) {
        ColorError_CIFrac(str, value);
        ErrorReport(__FILE__, __LINE__, str);
	return ERROR;
    }

    if (ptr->lastValue == -1.0) {
	ptr->lastValue = value;
    } else {
	if (value < ptr->lastValue) {
            ColorError_CIMonotonic(str, value, ptr->lastValue);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
	expected = (float)Round(2.0*ref*ptr->numColor) / 2.0;

	if (ABS(value-expected) > 3.0*epsilon.ci+epsilon.zero) {
            ColorError_CIBad(str, value, expected);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	if (ABS(delta) > epsilon.zero) {
	    if (ABS(delta) >= 2.0 && machine.pathLevel == 0) {
                ColorError_CIStep(str, delta);
                ErrorReport(__FILE__, __LINE__, str);
		return ERROR;
	    }
	}
    }

    if (ref >= 1.0 && value < ptr->numColor) {
        ColorError_CIClamp(str, ptr->numColor, value);
        ErrorReport(__FILE__, __LINE__, str);
	return ERROR;
    }
    return NO_ERROR;
}

long DifMatPosCIExec(void)
{
    difMatPosRec data;
    float start, end, frac;
    long max;

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glDisable(GL_DITHER);
    glEnable(GL_LIGHTING);

    max = (machine.pathLevel == 0) ? GL_LIGHT7 : GL_LIGHT0;
    data.numColor = POW(2.0, (float)buffer.ciBits) - 1.0;
    for (data.light = GL_LIGHT0; data.light <= max; data.light++) {
	if (data.numColor < 4096.0 || (machine.pathLevel != 0)) {
	    if (RampUtil(0.0, 1.0, InitCI, Set, TestCI, &data) == ERROR) {
		return ERROR;
	    }
	} else {
	    start = 0.5 / data.numColor;
	    frac = POW(2.0, (float)(8-buffer.ciBits));
	    if (RampUtil(start, frac, InitCI, Set, TestCI, &data) == ERROR) {
		return ERROR;
	    }
	    start = 0.5 - frac;
	    end = 0.5 + frac;
	    if (RampUtil(start, end, InitCI, Set, TestCI, &data) == ERROR) {
		return ERROR;
	    }
	    start = 1.0 - frac;
	    if (RampUtil(start, 1.0, InitCI, Set, TestCI, &data) == ERROR) {
		return ERROR;
	    }
	}
    }
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\l_sp.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** l_sp.c
** Light - Spot Position Test.
**
** Description -
**    This test analyses the effect that varying the
**    SpotLight_Position. has on the color produced by lighting,
**    by way of its effect on the Specular summand. CI lighting
**    differs from RGB lighting. This file contains code for both
**    tests. To analyse only this one parameter, the
**    Specular_Light Parameter is set to (1, 1, 1, 1). In RGB
**    mode the Specular_Material is set to Red, and in CI mode
**    the Specular_Material is set to maxIndex. Other lighting
**    parameters are chosen so that the Diffuse, Ambient, and
**    Emissive summands of the RGB or CI lighting are (0, 0, 0,
**    1). Similarly values are chosen so the Attenuation and the
**    Specular_Half_Angle factor are both 1.0. The
**    SpotLight_Exponent is always set to 1.0, and the
**    Cutoff_Angle is 90 degrees. In RGB mode only the red color
**    channel is tested. The implementation fails if any other
**    color channel is not black. In both modes one light is
**    enabled at a time, all individual lights are tested.
**    
**    The test repeatedly renders and reads the same point at the
**    lower left corner of the screen. The third component of the
**    SpotLight_Position is uniformly incremented. The other two
**    components of the SpotLight_Position are set so that the
**    total length of the vector, PV, which is the difference
**    between the SpotLight_Position and the rendered point's eye
**    position, is 1. The Normal vector is set to (0, 0, 1) so
**    the Spot_Position factor becomes PV[2], (Normal dot PV) =
**    PV[2]. With these settings the lighting equation reduces to
**    color = red * PV[2] or colorIndex = max index * PV[2].
**    
**    In RGB mode the uniformity of the observed change is
**    tested, and the implementation fails if consecutive changes
**    are too different. (thisDelta - lastDelta) > 1/4 shade.
**    The observed results are also checked for monotonicity.
**    When Light_Position[2] reaches 1.0 the color is finally
**    checked to insure that the point has rendered with a fully
**    saturated red.
**    
**    In CI mode a check is made to ensure that the observed
**    index reaches maxIndex. The observed shade is compared to
**    the theoretical value expected for each setting of
**    SpotLight_Position If the theoretical value is more than 4
**    indices away from the observed index the test fails. The
**    observed value must be an integer, and the difference
**    between successive observances must be less than 2.
**
** Error Explanation -
**    RGB mode: other_color > 0.0.
**    RGB mode: value < lastValue.
**    RGB mode: maxObserved < 1.0.
**    RGB mode: ABS(thisDelta - lastDelta) > 1/4 shade.
**    CI mode: observed Index not an integer
**    CI mode: ABS(observed - expected) > 4.0.
**    CI mode: observedMax < numColor.
**    CI mode: delta > 2.0.
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer.
**    Color requirements:
**        RGBA or color index mode. Full color.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**        Color, ci and zero epsilons, 0.25*color_epsilon.
**    Paths:
**        Allowed = Alpha, Blend, Depth, Logicop, Stencil, Stipple.
**        Not allowed = Alias, Dither, Fog, Shade.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"
#include "utilru.h"


typedef struct _spotPosRec {
    float step, numColor, lastValue, lastDelta, delta;
    GLenum light;
    GLfloat position[4];
} spotPosRec;


/*****************************************************************************/

static void Set(void *data, float *ref)
{
    spotPosRec *ptr = (spotPosRec *)data;

    ptr->position[0] = 0.5 + SQRT(1.0-(*ref)*(*ref));
    ptr->position[1] = 0.5;
    ptr->position[2] = *ref;
    glLightfv(ptr->light, GL_POSITION, ptr->position);

    glBegin(GL_POINTS);
	glVertex2f(0.5, 0.5);
    glEnd();

    *ref += ptr->step;
}

/****************************************************************************/

static void InitRGB(void *data)
{
    spotPosRec *ptr = (spotPosRec *)data;
    GLfloat buf[4];
    float step;
    GLenum i;

    ptr->lastValue = -1.0;
    ptr->lastDelta = -2.0;

    step = (machine.pathLevel == 0) ? 4.0 : 2.0;
    ptr->delta = 1.0 / (POW(2.0, (float)buffer.colorBits[0]) - 1.0);
    ptr->step = ptr->delta / step;

    for (i = GL_LIGHT0; i <= GL_LIGHT7; i++) {
	glDisable(i);
    }
    glEnable(ptr->light);

    ptr->position[0] = 0.0;
    ptr->position[1] = 0.0;
    ptr->position[2] = 1.0;
    ptr->position[3] = 1.0;

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = 1.0;
    glNormal3fv(buf);

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = 0.0;
    buf[3] = 1.0;
    glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, buf);

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = 0.0;
    buf[3] = 1.0;
    glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, buf);

    buf[0] = 1.0;
    buf[1] = 0.0;
    buf[2] = 0.0;
    buf[3] = 1.0;
    glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, buf);

    buf[0] = 1.0;
    buf[1] = 1.0;
    buf[2] = 1.0;
    buf[3] = 1.0;
    glLightfv(ptr->light, GL_SPECULAR, buf);

    buf[0] = 1.0;
    glLightfv(ptr->light, GL_SPOT_EXPONENT, buf);

    buf[0] = 90.0;
    glLightfv(ptr->light, GL_SPOT_CUTOFF, buf);

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = -1.0;
    buf[3] = 1.0;
    glLightfv(ptr->light, GL_SPOT_DIRECTION, buf);
}

static long TestRGB(void *data, float ref)
{
    spotPosRec *ptr = (spotPosRec *)data;
    char str[240];
    GLfloat buf[3]; 
    float value, delta;
    long i;

    ReadScreen(0, 0, 1, 1, GL_RGB, buf);

    for (i = 1; i < 3; i++) {
	if (buf[i] != 0.0) {
            ColorError_RGBZero(str, 0, buf);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
    }

    value = buf[0];
    if (ptr->lastDelta == -2.0) {
	ptr->lastDelta = -1.0;
	ptr->lastValue = value;
    } else if (ptr->lastDelta == -1.0) {
	if (value < ptr->lastValue) {
            ColorError_RGBMonotonic(str, 0, value, ptr->lastValue);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	if (ABS(delta) > epsilon.zero) {
	    ptr->lastDelta = delta;
	}
    } else {
	if (value < ptr->lastValue) {
            ColorError_RGBMonotonic(str, 0, value, ptr->lastValue);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	if (ABS(delta) > epsilon.zero) {
	    ptr->lastDelta = delta;
	}
    }

    if (ref >= 1.0 && ABS(value-1.0) > epsilon.zero) {
        ColorError_RGBClamp(str, 0, value);
        ErrorReport(__FILE__, __LINE__, str);
	return ERROR;
    }

    return NO_ERROR;
}

long SpotPosRGBExec(void)
{
    spotPosRec data;
    long max;

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glDisable(GL_DITHER);
    glEnable(GL_LIGHTING);

    max = (machine.pathLevel == 0) ? GL_LIGHT7 : GL_LIGHT0;
    for (data.light = GL_LIGHT0; data.light <= max; data.light++) {
	if (RampUtil(0.0, 1.0, InitRGB, Set, TestRGB, &data) == ERROR) {
	    return ERROR;
	}
    }
    return NO_ERROR;
}

/****************************************************************************/

static void InitCI(void *data)
{
    spotPosRec *ptr = (spotPosRec *)data;
    GLfloat buf[4];
    GLenum i;

    ptr->lastValue = -1.0;

    if (machine.pathLevel == 0) {
	ptr->step = 0.5 / ptr->numColor;
    } else {
	ptr->step = 0.25;
    }

    for (i = GL_LIGHT0; i <= GL_LIGHT7; i++) {
	glDisable(i);
    }
    glEnable(ptr->light);

    ptr->position[0] = 0.0;
    ptr->position[1] = 0.0;
    ptr->position[2] = 1.0;
    ptr->position[3] = 1.0;

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = ptr->numColor;
    glMaterialfv(GL_FRONT_AND_BACK, GL_COLOR_INDEXES, buf);

    buf[0] = 1.0;
    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = 1.0;
    glNormal3fv(buf);

    buf[0] = 1.0;
    buf[1] = 1.0;
    buf[2] = 1.0;
    buf[3] = PI;
    glLightfv(ptr->light, GL_SPECULAR, buf);

    /*
    ** Diffuse values should have no affect in CI mode,
    ** as should specular alpha.
    */
    glLightfv(ptr->light, GL_DIFFUSE, buf);

    buf[0] = 1.0;
    glLightfv(ptr->light, GL_SPOT_EXPONENT, buf);

    buf[0] = 90.0;
    glLightfv(ptr->light, GL_SPOT_CUTOFF, buf);

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = -1.0;
    buf[3] = 1.0;
    glLightfv(ptr->light, GL_SPOT_DIRECTION, buf);
}

static long TestCI(void *data, float ref)
{
    spotPosRec *ptr = (spotPosRec *)data;
    char str[240];
    GLfloat value;
    float expected, frac, delta, error;

    ReadScreen(0, 0, 1, 1, GL_COLOR_INDEX, &value);

    frac = ABS(value-(float)((int)value));
    if (frac > epsilon.zero && ABS(frac-1.0) > epsilon.zero) {
        ColorError_CIFrac(str, value);
        ErrorReport(__FILE__, __LINE__, str);
	return ERROR;
    }

    if (ptr->lastValue == -1.0) {
	ptr->lastValue = value;
    } else {
	if (value < ptr->lastValue) {
            ColorError_CIMonotonic(str, value, ptr->lastValue);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
	expected = (float)Round(2.0 * ref * ptr->numColor) / 2.0;

	/*
	** Since we only use an exponent of 1.0 this should remain small.
	*/
	error = 2.0 * epsilon.ci + (ptr->numColor / 64.0);
	error = (error > 4.0 * epsilon.ci) ?  error : 4.0 * epsilon.ci;

	if (ABS(value-expected) > error + epsilon.zero) {
            ColorError_CIBad(str, value, expected);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	if (ABS(delta) > epsilon.zero) {
	    /* 
	    ** Implementors may round or truncate.
	    */
	    if (ABS(delta) >= error && machine.pathLevel == 0) {
                ColorError_CIStep(str, delta);
                ErrorReport(__FILE__, __LINE__, str);
		return ERROR;
	    }
	}
    }

    if (ref >= 1.0 && value < ptr->numColor) {
        ColorError_CIClamp(str, ptr->numColor, value);
        ErrorReport(__FILE__, __LINE__, str);
	return ERROR;
    }
    return NO_ERROR;
}

long SpotPosCIExec(void)
{
    spotPosRec data;
    float start, end, frac;
    long max;

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glDisable(GL_DITHER);
    glEnable(GL_LIGHTING);

    max = (machine.pathLevel == 0) ? GL_LIGHT7 : GL_LIGHT0;
    data.numColor = POW(2.0, (float)buffer.ciBits) - 1.0;
    frac = POW(2.0, (float)(8-buffer.ciBits));
    for (data.light = GL_LIGHT0; data.light <= max; data.light++) {
	if (data.numColor < 4096.0 || machine.pathLevel != 0) {
	    start = 0.5 / data.numColor;
	    if (RampUtil(start, 1.0, InitCI, Set, TestCI, &data) == ERROR) {
		return ERROR;
	    }
	} else {
	    start = 0.5 / data.numColor;
	    end = frac;
	    if (RampUtil(start, end, InitCI, Set, TestCI, &data) == ERROR) {
		return ERROR;
	    }
	    start = 0.5 - frac;
	    end = 0.5 + frac;
	    if (RampUtil(start, end, InitCI, Set, TestCI, &data) == ERROR) {
		return ERROR;
	    }
	    start = 1.0 - frac;
	    if (RampUtil(start, 1.0, InitCI, Set, TestCI, &data) == ERROR) {
		return ERROR;
	    }
	}
    }
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\l_sm.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** l_sm.c
** Light - Specular Material Test.
**
** Description -
**    This test analyses the effect that varying the
**    Specular_Material parameter values has on the color
**    produced by lighting. This file contains code for both CI
**    and RGB tests. To analyse only this one parameter,
**    parameter values are chosen so that the Attenuation factor,
**    the SpotLight factor, and the Half_Angle factor are all
**    1.0. In RGB mode the Diffuse, Emissive, and Ambient
**    summands in the lighting equation are 0.0 and the
**    Specular_Light is set to (1, 1, 1, 1). In CI mode
**    Diffuse_Material, and Ambient_Material are set to 0.0, and
**    values are chosen so that s_prime is equal to 1.0.
**    
**    This forms a restriction of the lighting equation so that
**    the output color is equal to the Specular_Material's
**    setting. (color = Specular_Material). This observed color
**    is analysed for monotonicity, endpoints, and variation.
**    
**    The test repeatedly renders and reads the same point in the
**    lower left corner of the screen, uniformly incrementing
**    Specular_Material. In RGB mode the uniformity of the change
**    in observed color is tested, and the implementation fails
**    if consecutive changes are too different. (thisDelta -
**    lastDelta) > 1/4 shade. The observed results are also
**    checked for monotonicity. When Specular_Material reaches
**    1.0, the observed color is checked to insure that it is
**    rendered with a saturation of 1.0. All color channels are
**    tested one at a time, and the implementation fails if any
**    color channel, besides the one being tested, is not 0.0.
**    One light is enabled at a time. All individual lights are
**    tested.
**    
**    In CI mode the first 8 lights are enabled with all three
**    Specular_Light color channels set to 0.125. A check is made
**    to ensure that the observed index reaches maxIndex. The
**    observed shade is compared to the theoretical value
**    expected for each setting of Specular_Material. The
**    observed value must be an integer, and the difference
**    between successive observances must be less than 2. The
**    observed index is also compared to the theoretical value
**    expected for each setting of Specular_Material. If the
**    theoretical value is more than 3 indices away from the
**    observed index the test fails.
**
** Error Explanation -
**    RGB mode: other_color > 0.0.
**    RGB mode: value < lastValue.
**    RGB mode: maxObserved < 1.0.
**    RGB mode: ABS(thisDelta - lastDelta) > 1/4 shade.
**    CI mode: Index not a fraction
**    CI mode: (observed - expected) > 3.0.
**    CI mode: observedMax < numColor.
**    CI mode: delta > 2.0.
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer.
**    Color requirements:
**        RGBA or color index mode. Full color.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**        Color, ci and zero epsilons, 0.25*color_epsilon.
**    Paths:
**        Allowed = Alpha, Blend, Depth, Logicop, Stencil, Stipple.
**        Not allowed = Alias, Dither, Fog, Shade.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"
#include "utilru.h"


typedef struct _specMatRec {
    long color;
    float step, numColor, lastValue, lastDelta, delta;
    GLfloat material_specular[4], position[4];
} specMatRec;


/****************************************************************************/

static void InitRGB(void *data)
{
    specMatRec *ptr = (specMatRec *)data;
    GLfloat buf[4];
    float step;
    GLenum i;

    ptr->lastValue = -1.0;
    ptr->lastDelta = -2.0;

    step = (machine.pathLevel == 0) ? 4.0 : 2.0;
    ptr->delta = 1.0 / (POW(2.0, (float)buffer.colorBits[ptr->color]) - 1.0); 
    ptr->step = ptr->delta / step;

    for (i = GL_LIGHT0; i <= GL_LIGHT7; i++) {
	glEnable(i);
    }

    ptr->material_specular[0] = 0.0;
    ptr->material_specular[1] = 0.0;
    ptr->material_specular[2] = 0.0;
    ptr->material_specular[3] = 1.0;

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = 0.0;
    buf[3] = 1.0;
    glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, buf);

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = 0.0;
    buf[3] = 1.0;
    glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, buf);

    buf[0] = 1.0 / 8.0;
    buf[1] = 1.0 / 8.0;
    buf[2] = 1.0 / 8.0;
    buf[3] = 1.0;
    ptr->position[0] = 0.5;
    ptr->position[1] = 0.5;
    ptr->position[2] = 1.0;
    ptr->position[3] = 1.0;
    for (i = GL_LIGHT0; i <= GL_LIGHT7; i++) {
	glLightfv(i, GL_SPECULAR, buf);
	glLightfv(i, GL_POSITION, ptr->position);
    }
    glNormal3f(0.0, 0.0, 1.0);
}

static void SetRGB(void *data, float *ref)
{
    specMatRec *ptr = (specMatRec *)data;

    ptr->material_specular[ptr->color] = *ref;
    glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, ptr->material_specular);

    glBegin(GL_POINTS);
	glVertex2f(0.5, 0.5);
    glEnd();

    *ref += ptr->step;
}

static long TestRGB(void *data, float ref)
{
    specMatRec *ptr = (specMatRec *)data;
    char str[240];
    GLfloat buf[3]; 
    float value, delta;
    long i;

    ReadScreen(0, 0, 1, 1, GL_RGB, buf);

    for (i = 0; i < 3; i++) {
        if (buf[i] != 0.0 && i != ptr->color) {
            ColorError_RGBZero(str, ptr->color, buf);
            ErrorReport(__FILE__, __LINE__, str);
            return ERROR;
	}
    }

    value = buf[ptr->color];
    if (ptr->lastDelta == -2.0) {
	ptr->lastDelta = -1.0;
	ptr->lastValue = value;
    } else if (ptr->lastDelta == -1.0) {
	if (value < ptr->lastValue) {
            ColorError_RGBMonotonic(str, ptr->color, value, ptr->lastValue);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	if (ABS(delta) > epsilon.zero) {
	    if (ABS(delta-ptr->delta) > 0.25*epsilon.color[ptr->color]) {
                ColorError_RGBStep(str, ptr->color, delta, ptr->delta);
                ErrorReport(__FILE__, __LINE__, str);
		return ERROR;
	    }
	    ptr->lastDelta = delta;
	}
    } else {
	if (value < ptr->lastValue) {
            ColorError_RGBMonotonic(str, ptr->color, value, ptr->lastValue);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	if (ABS(delta) > epsilon.zero) {
	    if (ABS(delta-ptr->delta) > 0.25*epsilon.color[ptr->color]) {
                ColorError_RGBStep(str, ptr->color, delta, ptr->delta);
                ErrorReport(__FILE__, __LINE__, str);
		return ERROR;
	    }
	    if (ABS(delta-ptr->lastDelta) > epsilon.zero) {
                ColorError_RGBDelta(str, ptr->color, delta, ptr->lastDelta);
                ErrorReport(__FILE__, __LINE__, str);
		return ERROR;
	    }
	    ptr->lastDelta = delta;
	}
    }

    if (ref >= 1.0 && ABS(value-1.0) > epsilon.zero) {
        ColorError_RGBClamp(str, ptr->color, value);
        ErrorReport(__FILE__, __LINE__, str);
	return ERROR;
    }

    return NO_ERROR;
}

long SpecMatRGBExec(void)
{
    specMatRec data;
    long max;

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glDisable(GL_DITHER);
    glEnable(GL_LIGHTING);

    max = (machine.pathLevel == 0) ? 3 : 1;
    for (data.color = 0; data.color < max; data.color++) {
	if (RampUtil(0.0, 1.0, InitRGB, SetRGB, TestRGB, &data) == ERROR) {
	    return ERROR;
	}
    }
    return NO_ERROR;
}

/****************************************************************************/

static void InitCI(void *data)
{
    specMatRec *ptr = (specMatRec *)data;
    GLfloat buf[4];
    GLenum i;

    ptr->lastValue = -1.0;

    if (machine.pathLevel == 0) {
	ptr->step = 0.5 / ptr->numColor;
    } else {
	ptr->step = 0.25;
    }

    glNormal3f(0.0, 0.0, 1.0);

    for (i = GL_LIGHT0; i <= GL_LIGHT7; i++) {
	glEnable(i);
	buf[0] = 0.5;
	buf[1] = 0.5;
	buf[2] = 1.0;
	buf[3] = 1.0;
	
	buf[0] = 1.0 / 8.0;
	buf[1] = 1.0 / 8.0;
	buf[2] = 1.0 / 8.0;
	buf[3] = 1.0;
	glLightfv(i, GL_SPECULAR, buf);

	/*
	** The values below should make s' equal to 0.0.
	** Alpha for specular light is not used. See if wierd value
	** breaks something.
	*/

	buf[0] = 0.0;
	buf[1] = 0.0;
	buf[2] = 0.0;
	buf[3] = PI;
	glLightfv(i, GL_DIFFUSE, buf);
    }
}

static void SetCI(void *data, float *ref)
{
    specMatRec *ptr = (specMatRec *)data;
    GLfloat index[3];

    index[0] = 0.0;
    index[1] = ptr->numColor;
    index[2] = *ref * ptr->numColor;
    glMaterialfv(GL_FRONT_AND_BACK, GL_COLOR_INDEXES, index);

    glBegin(GL_POINTS);
	glVertex2f(0.5, 0.5);
    glEnd();

    *ref += ptr->step;
}

static long TestCI(void *data, float ref)
{
    specMatRec *ptr = (specMatRec *)data;
    char str[240];
    GLfloat value;
    float expected, frac, delta;

    ReadScreen(0, 0, 1, 1, GL_COLOR_INDEX, &value);

    frac = ABS(value-(float)((int)value));
    if (frac > epsilon.zero && ABS(frac-1.0) > epsilon.zero) {
        ColorError_CIFrac(str, value);
        ErrorReport(__FILE__, __LINE__, str);
	return ERROR;
    }

    if (ptr->lastValue == -1.0) {
	ptr->lastValue = value;
    } else {
	if (value < ptr->lastValue) {
            ColorError_CIMonotonic(str, value, ptr->lastValue);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
	expected = (float)Round(2.0*ref*ptr->numColor) / 2.0;

	if (ABS(value-expected) > 3.0*epsilon.ci+epsilon.zero) {
            ColorError_CIBad(str, value, expected);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	if (ABS(delta) > epsilon.zero) {
	    if (ABS(delta) >= 2.0 && machine.pathLevel == 0) {
                ColorError_CIStep(str, delta);
                ErrorReport(__FILE__, __LINE__, str);
		return ERROR;
	    }
	}
    }

    if (ref >= 1.0 && value < ptr->numColor) {
        ColorError_CIClamp(str, ptr->numColor, value);
        ErrorReport(__FILE__, __LINE__, str);
	return ERROR;
    }
    return NO_ERROR;
}

long SpecMatCIExec(void)
{
    specMatRec data;
    float start, end, frac;

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glDisable(GL_DITHER);
    glEnable(GL_LIGHTING);

    data.numColor = POW(2.0, (float)buffer.ciBits) - 1.0;
    if (data.numColor < 4096.0 || machine.pathLevel != 0) {
	if (RampUtil(0.0, 1.0, InitCI, SetCI, TestCI, &data) == ERROR) {
	    return ERROR;
	}
    } else {
	start = 0.5 / data.numColor;
	frac = POW(2.0, (float)(8-buffer.ciBits));
	if (RampUtil(start, frac, InitCI, SetCI, TestCI, &data) == ERROR) {
	    return ERROR;
	}
	start = 0.5 - frac;
	end = 0.5 + frac;
	if (RampUtil(start, end, InitCI, SetCI, TestCI, &data) == ERROR) {
	    return ERROR;
	}
	start = 1.0 - frac;
	if (RampUtil(start, 1.0, InitCI, SetCI, TestCI, &data) == ERROR) {
	    return ERROR;
	}
    }
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\mipsel.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** mipsel.c
** Mipmap Selection Test.
**
** Description -
**    Tests the selection of levels with various magnification
**    and minification filters. An eight level deep mipmap is set
**    up, each level distinguished by a different color. A series
**    of shrinking square polygons are drawn with texture
**    coordinates set so that each polygon uses a different level
**    of the mipmap. This is done by matching the number of
**    fragments of a particular polygon to the number of texels
**    in the corresponding level. The rendered polygon is read
**    back and compared to the correct mipmap level color.
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer.
**    Color requirements:
**        RGBA mode. Full color.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**    Paths:
**        Allowed = Alpha, Blend, Depth, Fog, Logicop, Shade, Stencil, Stipple.
**        Not allowed = Alias, Dither.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"


#define LOG2(x) (LOG(x)/0.69314718)


static long errSizeX, errSizeY;
static char errMagFilter[40], errMinFilter[40];
static char errStr[240];
static char errStrFmt[] = "Map size is %d by %d. Magnification filter is %s. Minification filter is %s. Color is (%g, %g, %g), should be (%g, %g, %g).";


static void Make(GLfloat *buf)
{
    GLfloat *ptr;
    GLint level, size, i;

    level = 0;
    for (size = 64; size > 0; size /= 2) {
	ptr = buf;
	for (i = 0; i < 64*64; i++) {
	    *ptr++ = colorMap[level+1][0];
	    *ptr++ = colorMap[level+1][1];
	    *ptr++ = colorMap[level+1][2];
	}
	glTexImage2D(GL_TEXTURE_2D, level++, 3, size, size, 0, GL_RGB,
		     GL_FLOAT, (unsigned char *)buf);
    }
}

static long Compare(GLsizei size, GLsizei color, GLfloat *buf, GLfloat levelErr)
{
    long i;

    ReadScreen(0, 0, size, size, GL_RGB, buf);

    for (i = 0; i < size*size*3; i += 3) {
	if (ABS(buf[i]-colorMap[color][0]) > levelErr+epsilon.color[0] ||
	    ABS(buf[i+1]-colorMap[color][1]) > levelErr+epsilon.color[1] ||
	    ABS(buf[i+2]-colorMap[color][2]) > levelErr+epsilon.color[2]) {
	    StrMake(errStr, errStrFmt, errSizeX, errSizeY, errMagFilter,
		    errMinFilter, buf[i], buf[i+1], buf[i+2],
		    colorMap[color][0], colorMap[color][1], colorMap[color][2]);
	    ErrorReport(__FILE__, __LINE__, errStr);
	    return ERROR;
	}
    }

    return NO_ERROR;
}

/*
** OpenGL implementations are allowed some latitude in the method they use
** to determine rho, as long as max(m1, m2) <= rho <= m1 + m2. 
** In this test m1 = |du/dx| and m2 = |dv/dy|. This means that for
** GL_*_MIPMAP_LINEAR filters, the color observed may actually be 
** result from interpolation between two levels.
*/

static GLfloat GetRhoMipMapLevelError(GLfloat s, GLfloat t, GLfloat size,
				      GLint filter)
{
    GLfloat error=0.0f, m1, m2;

    switch (filter) {
      case GL_NEAREST_MIPMAP_NEAREST:
      case GL_LINEAR_MIPMAP_NEAREST:
	error = 0.0;
	break;
      case GL_NEAREST_MIPMAP_LINEAR:
      case GL_LINEAR_MIPMAP_LINEAR:
	m1 = 64.0 * s / size;
	m2 = 64.0 * t / size;
	error = LOG2(m1+m2) - LOG2(m2);
	break;
    }
    return error;
}

static long Test(GLint filter, GLfloat *buf)
{
    GLint size, i;
    GLfloat levelErr, s, t;

    GetEnumName(filter, errMinFilter);

    glTexParameteriv(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, &filter);

    s = 0.0625;
    t = 1.0;
    size = 64;
    for (i = 1; i <= 7; i++) {
	errSizeX = size;
	errSizeY = size;
	levelErr = GetRhoMipMapLevelError(s, t, 64.0, filter);
	glBegin(GL_POLYGON);
	    glTexCoord2f(0.0, 0.0);
	    glVertex2i(0, 0);
	    glTexCoord2f(0.0, t);
	    glVertex2i(0, size);
	    glTexCoord2f(s, t);
	    glVertex2i(size, size);
	    glTexCoord2f(s, 0.0);
	    glVertex2i(size, 0);
	glEnd();

	if (Compare(size, i, buf, levelErr) == ERROR) {
	    return ERROR;
	}

	/*
	** This choice of size and s fixes m1 = 1.0 / 16.0, 
	** up to representational and floating point error.
	*/
        size /= 2;
	s /= 2.0;
    }

    return NO_ERROR;
}

long MipSelectExec(void)
{
    GLfloat *buf, x;

    buf = (GLfloat *)MALLOC(WINDSIZEX*WINDSIZEY*3*sizeof(GLfloat));

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    glDisable(GL_DITHER);
    glEnable(GL_TEXTURE_2D);
    x = GL_DECAL;
    glTexEnvfv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, &x);
    Make(buf);

    x = GL_NEAREST;
    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, &x);
    GetEnumName(x, errMagFilter);
    if (Test(GL_NEAREST_MIPMAP_NEAREST, buf) == ERROR) {
	FREE(buf);
	return ERROR;
    }
    if (Test(GL_LINEAR_MIPMAP_NEAREST, buf) == ERROR) {
	FREE(buf);
	return ERROR;
    }
    if (Test(GL_NEAREST_MIPMAP_LINEAR, buf) == ERROR) {
	FREE(buf);
	return ERROR;
    }
    if (Test(GL_LINEAR_MIPMAP_LINEAR, buf) == ERROR) {
	FREE(buf);
	return ERROR;
    }

    x = GL_LINEAR;
    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, &x);
    GetEnumName(x, errMagFilter);
    if (Test(GL_NEAREST_MIPMAP_NEAREST, buf) == ERROR) {
	FREE(buf);
	return ERROR;
    }
    if (Test(GL_LINEAR_MIPMAP_NEAREST, buf) == ERROR) {
	FREE(buf);
	return ERROR;
    }
    if (Test(GL_NEAREST_MIPMAP_LINEAR, buf) == ERROR) {
	FREE(buf);
	return ERROR;
    }
    if (Test(GL_LINEAR_MIPMAP_LINEAR, buf) == ERROR) {
	FREE(buf);
	return ERROR;
    }

    FREE(buf);
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\mask.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** mask.c
** Mask Test.
**
** Description -
**    In RGB mode a point is rendered using a mask and a color.
**    The rendered result is read back and compared to the
**    expected result. The implementation fails if the color read
**    back differs from the expected color. The individual color
**    channels of any color used are either 0.0 or 1.0. All
**    possible combinations of color channels are tested, each
**    using all possible masks.
**    
**    In CI mode a point is rendered with the highest index. A
**    mask is applied to this color, and the resulting color is
**    read back. This value is compared to the mask, and if it
**    differs the implementation fails. The masks used start at 0
**    and increment by 1 until they reach the highest possible
**    index.
** 
** Technical Specification -
**    Buffer requirements:
**        Color buffer.
**    Color requirements:
**        RGBA or color index mode. 4 colors.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**        epsilon.zero
**    Paths:
**        Allowed = Alpha, Blend, Depth, Fog, Logicop, Shade, Stencil, Stipple.
**        Not allowed = Alias, Dither.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"


#define REDBIT   1
#define GREENBIT 2
#define BLUEBIT  4
#define ALPHABIT 8


static GLfloat errColorExpected[4], errColorObserved[4];
static long errIndexObserved;
static long errIndexMask;
static char errStr[160];
static char errStrFmt[][80] = {
    "RGBA expected = (%g %g %g %g), RGBA observed = (%g %g %g %g). Mask %x.",
    "In Color Index mode, rendered %x with mask %x, observed %x."
};


/*****************************************************************************/

static void SaveErrColor(GLfloat from[4], GLfloat to[4])
{

    to[0] = from[0];
    to[1] = from[1];
    to[2] = from[2];
    to[3] = from[3];
}

static void DrawRGB(long componentMask, long RGBMask, GLfloat shade)
{
    GLboolean rMask, gMask, bMask, aMask;
    GLfloat color[4];

    glClear(GL_COLOR_BUFFER_BIT);

    color[0] = (componentMask & REDBIT) ? shade : 0.0;
    color[1] = (componentMask & GREENBIT) ? shade : 0.0;
    color[2] = (componentMask & BLUEBIT) ? shade : 0.0;
    color[3] = (componentMask & ALPHABIT) ? shade : 0.0;
    glColor4fv(color);

    rMask = (REDBIT & RGBMask) ? GL_TRUE : GL_FALSE;
    gMask = (GREENBIT & RGBMask) ? GL_TRUE : GL_FALSE;
    bMask = (BLUEBIT & RGBMask) ? GL_TRUE : GL_FALSE;
    aMask = (ALPHABIT & RGBMask) ? GL_TRUE : GL_FALSE;
    glColorMask(rMask, gMask, bMask, aMask);

    glBegin(GL_POINTS);
	glVertex2f(0.5, 0.5);
    glEnd();

    SaveErrColor(color, errColorExpected);
}

static long Check(long drawn, GLfloat color)
{

    if (drawn == GL_FALSE) {
	if (ABS(color) > epsilon.zero) {
	    return ERROR;
	}
    } else {
	if (ABS(color) < epsilon.zero) {
	    return ERROR;
	}
    }
    return NO_ERROR;
}

static long TestRGB(long componentMask, long RGBMask)
{
    GLfloat buf[4];
    long shouldDrawMask;

    ReadScreen(0, 0, 1, 1, GL_RGBA, buf);

    shouldDrawMask = componentMask & RGBMask;

    if (Check(shouldDrawMask&REDBIT, buf[0]) == ERROR) {
	SaveErrColor(buf, errColorObserved);
	return ERROR;
    }
    if (Check(shouldDrawMask&GREENBIT, buf[1]) == ERROR) {
	SaveErrColor(buf, errColorObserved);
	return ERROR;
    }
    if (Check(shouldDrawMask&BLUEBIT, buf[2]) == ERROR) {
	SaveErrColor(buf, errColorObserved);
	return ERROR;
    }

    /*
    ** Check alpha, if the machine supports alpha planes.
    */
    if (buffer.colorBits[3] == 0) {
	if (ABS(buf[3]-1.0) > epsilon.zero) {
	    errColorExpected[3] = 1.0;
	    SaveErrColor(buf, errColorObserved);
	    return ERROR;
	} else {
	    return NO_ERROR;
	}
    } else if (Check(shouldDrawMask&ALPHABIT, buf[3]) == ERROR) {
	SaveErrColor(buf, errColorObserved);
	return ERROR;
    }

    return NO_ERROR;
}

long MaskRGBExec(void)
{
    long componentMask, RGBMask;

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glDisable(GL_DITHER);

    for (componentMask = 0; componentMask < 16; componentMask++) {
	for (RGBMask = 0; RGBMask < 16; RGBMask++) {
	    DrawRGB(componentMask, RGBMask, 1.0);
	    if (TestRGB(componentMask, RGBMask) == ERROR) {
		StrMake(errStr, errStrFmt[0], errColorExpected[0], 
			errColorExpected[1], errColorExpected[2], 
			errColorExpected[3], errColorObserved[0], 
			errColorObserved[1], errColorObserved[2], 
			errColorObserved[3], RGBMask);
		ErrorReport(__FILE__, __LINE__, errStr);
		return ERROR;
	    }
	}
    }
    return NO_ERROR;
}

/*****************************************************************************/

static void DrawCI(GLuint mask, GLuint allBitsOn)
{

    /*
    ** The object is rendered using the highest color index.
    ** But it is masked to a lower number, so all that is left
    ** is the lower number.
    */
    glIndexMask(allBitsOn);

    glBegin(GL_POINTS);
	glIndexi(0);
	glVertex2f(0.5, 0.5);
    glEnd();

    glIndexMask(mask);

	glBegin(GL_POINTS);
	    glIndexi(allBitsOn);
	    glVertex2f(0.5, 0.5);
	glEnd();
    }

static long TestCI(long mask, GLint isDitherOn)
{
    GLfloat buf;

    ReadScreen(0, 0, 1, 1, GL_COLOR_INDEX, &buf);

    if ((long)buf != mask) {
	/*
	** Re-check buf against the other value which could 
	** result from masking a dithered index.
	*/
	if ((isDitherOn == GL_FALSE) || ((mask & ~1) != (long) buf )) {
	    errIndexObserved = (long)buf;
	    errIndexMask = mask;
	    return ERROR;
	}
    }

    return NO_ERROR;
}

long MaskCIExec(void)
{
    GLuint allBitsOn, i;
    GLint isDitherOn;

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    glClearIndex(0);

    glGetIntegerv(GL_DITHER, &isDitherOn);
    allBitsOn = (1 << buffer.ciBits) - 1;
    for (i = 0; i <= allBitsOn; ) {
	DrawCI(i, allBitsOn);
	if (TestCI(i, isDitherOn) == ERROR) {
	    StrMake(errStr, errStrFmt[1], allBitsOn, errIndexMask, 
		    errIndexObserved); 
	    ErrorReport(__FILE__, __LINE__, errStr);
	    return ERROR;
	}
	if (machine.pathLevel == 0 || i == 0) {
	    i++;
	} else {
	    i <<= 1;
	}
    }
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\l_sl.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** l_sl.c
** Light - Specular Light Test.
**
** Description -
**    This test analyses the effect that varying the
**    Specular_Light parameter has on the color produced by
**    lighting. CI lighting differs from RGB lighting. This file
**    contains code for both tests. A single lit point is
**    rendered in the lower left corner of the screen and the
**    color or color index of this point is retrieved using
**    glReadPixels(). To analyse only this one parameter,
**    parameter values are chosen so that the Attenuation factor,
**    the SpotLight factor, and the Half_Angle factor are all
**    1.0. In RGB mode the Diffuse, Ambient, and Emissive
**    summands in the lighting equation set to 0.0 and the
**    Specular_Material is set to (1, 1, 1, 1). In CI mode the
**    Diffuse_Material is set to 0.0, and the Ambient_Material is
**    set to 0.0.
**    
**    This forms a restriction of the lighting equation so that
**    the output color is equal to a multiple of the
**    Specular_Light setting. In CI mode all three colors of
**    Specular_Light are set to the same value. This function's
**    output is analysed for monotonicity, endpoints, and
**    variation. In RGB mode all color channels are tested one at
**    a time. The implementation fails if any color channel,
**    besides the one being tested, is not 0.0. In both modes at
**    most one light is enabled at a time. All individual lights
**    are tested.
**    
**    The test repeatedly renders and reads the same point,
**    uniformly incrementing Specular_Light. In RGB mode the
**    uniformity of the change in observed color is tested, and
**    the implementation fails if consecutive changes are too
**    different. (thisDelta - lastDelta) > 1/4 colorEpsilon. The
**    observed results are also checked for monotonicity. When
**    Specular_Light reaches 1.0, the observed color is checked
**    to insure that it is rendered with a saturation of 1.0.
**    
**    In CI mode a check is made to ensure that the observed
**    index reaches its max. The observed shade is compared to
**    the theoretical value expected for each setting of
**    Specular_Light. The observed value must be an integer, and
**    the difference between successive observances must be less
**    than 2. The observed index is also compared to the
**    theoretical value expected for each setting of
**    Specular_Light. If the theoretical value is more than 3
**    indices away from the observed index the test fails.
**
** Error Explanation -
**    RGB mode: other_color > 0.0.
**    RGB mode: value < lastValue.
**    RGB mode: maxObserved < 1.0.
**    RGB mode: ABS(thisDelta - lastDelta) > 1/4 shade.
**    CI mode: index not an integer
**    CI mode: ABS(observed - expected) > 3.0.
**    CI mode: observedMax < numColor.
**    CI mode: delta > 2.0.
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer.
**    Color requirements:
**        RGBA or color index mode. Full color.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**        Color, ci and zero epsilons, 0.25*color_epsilon.
**    Paths:
**        Allowed = Alpha, Blend, Depth, Logicop, Stencil, Stipple.
**        Not allowed = Alias, Dither, Fog, Shade.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"
#include "utilru.h"


typedef struct _specLightRec {
    long color;
    float step, numColor, lastValue, lastDelta, delta;
    GLenum light;
    GLfloat light_specular[4], position[4];
} specLightRec;


/******************************************************************************/

static void InitRGB(void *data)
{
    specLightRec *ptr = (specLightRec *)data;
    GLfloat buf[4];
    float step;
    GLenum i;

    ptr->lastValue = -1.0;
    ptr->lastDelta = -2.0;

    step = (machine.pathLevel == 0) ? 4.0 : 2.0;
    ptr->delta = 1.0 / (POW(2.0, (float)buffer.colorBits[ptr->color]) - 1.0);
    ptr->step = ptr->delta / step;

    for (i = GL_LIGHT0; i <= GL_LIGHT7; i++) {
	glDisable(i);
    }
    glEnable(ptr->light);

    ptr->light_specular[0] = 0.0;
    ptr->light_specular[1] = 0.0;
    ptr->light_specular[2] = 0.0;
    ptr->light_specular[3] = 1.0;

    glNormal3f(0.0, 0.0, 1.0);

    ptr->position[0] = 0.5;
    ptr->position[1] = 0.5;
    ptr->position[2] = 1.0;
    ptr->position[3] = 1.0;
    glLightfv(ptr->light, GL_POSITION, ptr->position);

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = 0.0;
    buf[3] = 1.0;
    glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, buf);

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = 0.0;
    buf[3] = 1.0;
    glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, buf);

    buf[0] = 1.0;
    buf[1] = 1.0;
    buf[2] = 1.0;
    buf[3] = 1.0;
    glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, buf);
}

static void SetRGB(void *data, float *ref)
{
    specLightRec *ptr = (specLightRec *)data;

    ptr->light_specular[ptr->color] = *ref;
    glLightfv(ptr->light, GL_SPECULAR, ptr->light_specular);

    glBegin(GL_POINTS);
	glVertex2f(0.5, 0.5);
    glEnd();

    *ref += ptr->step;
}

static long TestRGB(void *data, float ref)
{
    specLightRec *ptr = (specLightRec *)data;
    char str[240];
    GLfloat buf[3]; 
    float value, delta;
    long i;

    ReadScreen(0, 0, 1, 1, GL_RGB, buf);

    for (i = 0; i < 3; i++) {
        if (buf[i] != 0.0 && i != ptr->color) {
            ColorError_RGBZero(str, ptr->color, buf);
            ErrorReport(__FILE__, __LINE__, str);
            return ERROR;
	}
    }

    value = buf[ptr->color];
    if (ptr->lastDelta == -2.0) {
	ptr->lastDelta = -1.0;
	ptr->lastValue = value;
    } else if (ptr->lastDelta == -1.0) {
	if (value < ptr->lastValue) {
            ColorError_RGBMonotonic(str, ptr->color, value, ptr->lastValue);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	if (ABS(delta) > epsilon.zero) {
	    if (ABS(delta-ptr->delta) > 0.25*epsilon.color[ptr->color]) {
                ColorError_RGBStep(str, ptr->color, delta, ptr->delta);
                ErrorReport(__FILE__, __LINE__, str);
		return ERROR;
	    }
	    ptr->lastDelta = delta;
	}
    } else {
	if (value < ptr->lastValue) {
            ColorError_RGBMonotonic(str, ptr->color, value, ptr->lastValue);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	if (ABS(delta) > epsilon.zero) {
	    if (ABS(delta-ptr->delta) > 0.25*epsilon.color[ptr->color]) {
                ColorError_RGBStep(str, ptr->color, delta, ptr->delta);
                ErrorReport(__FILE__, __LINE__, str);
		return ERROR;
	    }
	    if (ABS(delta-ptr->lastDelta) > epsilon.zero) {
                ColorError_RGBDelta(str, ptr->color, delta, ptr->lastDelta);
                ErrorReport(__FILE__, __LINE__, str);
		return ERROR;
	    }
	    ptr->lastDelta = delta;
	}
    }

    if (ref >= 1.0 && ABS(value-1.0) > epsilon.zero) {
        ColorError_RGBClamp(str, ptr->color, value);
        ErrorReport(__FILE__, __LINE__, str);
	return ERROR;
    }

    return NO_ERROR;
}

long SpecLightRGBExec(void)
{
    specLightRec data;
    long max1, max2;

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glDisable(GL_DITHER);
    glEnable(GL_LIGHTING);

    max1 = (machine.pathLevel == 0) ? GL_LIGHT7 : GL_LIGHT0;
    max2 = (machine.pathLevel == 0) ? 3 : 1;
    for (data.light = GL_LIGHT0; data.light <= max1; data.light++) {
	for (data.color = 0; data.color < max2; data.color++) {
	    if (RampUtil(0.0, 1.0, InitRGB, SetRGB, TestRGB, &data) == ERROR) {
		return ERROR;
	    }
	}
    }
    return NO_ERROR;
}

/******************************************************************************/

static void InitCI(void *data)
{
    specLightRec *ptr = (specLightRec *)data;
    GLfloat buf[4];
    GLenum i;

    ptr->lastValue = -1.0;
    ptr->lastDelta = -2.0;

    if (machine.pathLevel == 0) {
	ptr->step = 0.5 / ptr->numColor;
    } else {
	ptr->step = 0.25;
    }

    for (i = GL_LIGHT0; i <= GL_LIGHT7; i++) {
	glDisable(i);
    }
    glEnable(ptr->light);

    ptr->light_specular[0] = 0.0;
    ptr->light_specular[1] = 0.0;
    ptr->light_specular[2] = 0.0;
    ptr->light_specular[3] = 1.0;

    /*
    ** Default spot angle is 180.0 so spot should be constant one.
    ** Default attenuation constants are 1.0, 0.0, 0.0 so attenuation
    ** should be 1.0.
    */
    ptr->position[0] = 0.5;
    ptr->position[1] = 0.5;
    ptr->position[2] = 1.0;
    ptr->position[3] = 1.0;
    glLightfv(ptr->light, GL_POSITION, ptr->position);

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = ptr->numColor;
    glMaterialfv(GL_FRONT_AND_BACK, GL_COLOR_INDEXES, buf);

    /*
    ** The values below should make s' equal to 0.0.
    ** Alpha for specular light is not used. See if wierd value
    ** breaks something.
    */

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = 0.0;
    buf[3] = PI;
    glLightfv(ptr->light, GL_SPECULAR, buf);

    /*
    ** This should be unused, if diffuse and ambient light color indices are
    ** set to 0.
    */

    buf[0] = 1.0;
    buf[1] = 1.0;
    buf[2] = 1.0;
    buf[3] = PI;
    glLightfv(ptr->light, GL_DIFFUSE, buf);

    glNormal3f(0.0, 0.0, 1.0);
}

static void SetCI(void *data, float *ref)
{
    specLightRec *ptr = (specLightRec *)data;
    long i;

    for (i = 0; i < 3; i++) {
	ptr->light_specular[i] = *ref;
    }
    glLightfv(ptr->light, GL_SPECULAR, ptr->light_specular);

    glBegin(GL_POINTS);
	glVertex2f(0.5, 0.5);
    glEnd();

    *ref += ptr->step;
}

static long TestCI(void *data, float ref)
{
    specLightRec *ptr = (specLightRec *)data;
    char str[240];
    GLfloat value;
    float expected, frac, delta;

    ReadScreen(0, 0, 1, 1, GL_COLOR_INDEX, &value);

    frac = ABS(value-(float)((int)value));
    if (frac > epsilon.zero && ABS(frac-1.0) > epsilon.zero) {
        ColorError_CIFrac(str, value);
        ErrorReport(__FILE__, __LINE__, str);
	return ERROR;
    }

    if (ptr->lastValue == -1.0) {
	ptr->lastValue = value;
    } else {
	if (value < ptr->lastValue) {
            ColorError_CIMonotonic(str, value, ptr->lastValue);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
	expected = (float)Round(2.0*ref*ptr->numColor) / 2.0;

	if (ABS(value-expected) > 3.0*epsilon.ci+epsilon.zero) {
            ColorError_CIBad(str, value, expected);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	if (ABS(delta) > epsilon.zero) {
	    if (ABS(delta) >= 2.0 && machine.pathLevel == 0) {
                ColorError_CIStep(str, delta);
                ErrorReport(__FILE__, __LINE__, str);
		return ERROR;
	    }
	}
    }

    if (ref >= 1.0 && value < ptr->numColor) {
        ColorError_CIClamp(str, ptr->numColor, value);
        ErrorReport(__FILE__, __LINE__, str);
	return ERROR;
    }
    return NO_ERROR;
}

long SpecLightCIExec(void)
{
    specLightRec data;
    float start, end, frac;
    long max1;

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glDisable(GL_DITHER);
    glEnable(GL_LIGHTING);

    max1 = (machine.pathLevel == 0) ? GL_LIGHT7 : GL_LIGHT0;
    data.numColor = POW(2.0, (float)buffer.ciBits) - 1.0;
    for (data.light = GL_LIGHT0; data.light <= max1; data.light++) {
	if (data.numColor < 4096.0 || (machine.pathLevel != 0)) {
	    if (RampUtil(0.0, 1.0, InitCI, SetCI, TestCI, &data) == ERROR) {
		return ERROR;
	    }
	} else {
	    start = 0.5 / data.numColor;
	    frac = POW(2.0, (float)(8-buffer.ciBits));
	    if (RampUtil(start, frac, InitCI, SetCI, TestCI, &data) == ERROR) {
		return ERROR;
	    }
	    start = 0.5 - frac;
	    end = 0.5 + frac;
	    if (RampUtil(start, end, InitCI, SetCI, TestCI, &data) == ERROR) {
		return ERROR;
	    }
	    start = 1.0 - frac;
	    if (RampUtil(start, 1.0, InitCI, SetCI, TestCI, &data) == ERROR) {
		return ERROR;
	    }
	}
    }
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\miplin.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** miplin.c
** Mipmap Linear Test.
**
** Description -
**    Tests the interpolation between mipmap levels. An eight
**    level deep mipmap is set up, each level distinguished by a
**    different color. A polygon is drawn with texture
**    coordinates set so that the level used for each fragment
**    will ramp from a starting level to the next consecutive
**    level. The starting and ending color is checked to see that
**    the correct levels were used. Monotonicity between each
**    fragment texel is also checked.
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer.
**    Color requirements:
**        RGBA mode. Full color.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**    Paths:
**        Allowed = Alpha, Blend, Depth, Fog, Logicop, Shade, Stencil, Stipple.
**        Not allowed = Alias, Dither.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"


#define STEP 20
#define LOG2(x) (LOG(x)/0.69314718)


static long errSizeX, errSizeY;
static char errFilter[40];
static char errStr[240];
static char errStrFmt[][160] = {
    "Map size is %d by %d. Minification filter is %s. Color is (%g, %g, %g), should be (%g, %g, %g).",
    "Map size is %d by %d. Minification filter is %s. Color is not monotonic. Current color is (%g, %g, %g), last color was (%g, %g, %g)."
};


static void Make(GLsizei sizeX, GLsizei sizeY, GLfloat *buf)
{
    GLfloat *ptr;
    GLint level, i;

    level = 0;
    while (sizeX > 0 || sizeY > 0) {
	ptr = buf;
	for (i = 0; i < 64*64; i++) {
	    *ptr++ = colorMap[level+1][0];
	    *ptr++ = colorMap[level+1][1];
	    *ptr++ = colorMap[level+1][2];
	}
	glTexImage2D(GL_TEXTURE_2D, level++, 3, (sizeX==0)?1:sizeX,
		     (sizeY==0)?1:sizeY, 0, GL_RGB, GL_FLOAT,
		     (unsigned char *)buf);
	sizeX /= 2;
	sizeY /= 2;
    }
}

static long Draw(GLfloat sizeX, GLfloat sizeY, GLfloat baseSizeX,
		 GLfloat baseSizeY)
{
    GLfloat x, y, i, dvShrink, dudx, dvdy;
    long drawnCount;

    dvShrink = 16.0 * (baseSizeY / sizeY); 
    drawnCount = 0;
    for (i = 0.0; i <= STEP; i += 1.0) {
	x = ((1.0 - (1.0 / STEP * i)) * (1.0 / sizeX)) + ((1.0 / STEP * i) *
	    (1.0 / sizeX * 2.0));
	y = (((1.0 - (1.0 / STEP * i)) * (1.0 / sizeY)) + (1.0 / STEP * i) *
	    (1.0 / sizeY * 2.0)) / dvShrink;
	dudx = baseSizeX * x;
	dvdy = baseSizeY * y;
	if (dudx+dvdy <= 1.99*baseSizeX/sizeX) {
	    glBegin(GL_POLYGON);
		glTexCoord2f(0.0, 0.0);
		glVertex2f(i, 0);
		glTexCoord2f(x, 0.0);
		glVertex2f(i+1.0, 0);
		glTexCoord2f(x, y);
		glVertex2f(i+1.0, 1.0);
		glTexCoord2f(0.0, y);
		glVertex2f(i, 1.0);
	    glEnd();
	    drawnCount += 1;
	}
    }
    return drawnCount;
}

static long Compare(GLfloat *buf, long index, long drawCount)
{
    GLfloat last[3], rhoNormError, x;
    long i;

    ReadScreen(0, 0, STEP+1, 1, GL_RGB, buf);

    x = (GLfloat)(index - 1);
    rhoNormError = LOG2(POW(2.0, x)+0.0625) - x; 

    if (ABS(buf[0]-colorMap[index][0]) > rhoNormError+1.5*epsilon.color[0] ||
        ABS(buf[1]-colorMap[index][1]) > rhoNormError+1.5*epsilon.color[1] ||
        ABS(buf[2]-colorMap[index][2]) > rhoNormError+1.5*epsilon.color[2]) {
	StrMake(errStr, errStrFmt[0], errSizeX, errSizeY, errFilter,
		buf[0], buf[1], buf[2], colorMap[index][0], colorMap[index][1],
		colorMap[index][2]);
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }
    last[0] = buf[0];
    last[1] = buf[1];
    last[2] = buf[2];
    for (i = 3; i < drawCount*3; i += 3) {
	if (colorMap[index][0] > colorMap[index+1][0]) {
	    if (buf[i]-last[0] > epsilon.color[0]) {
		StrMake(errStr, errStrFmt[1], errSizeX, errSizeY, errFilter,
			buf[0], buf[1], buf[2], last[0], last[1], last[2]);
		ErrorReport(__FILE__, __LINE__, errStr);
		return ERROR;
	    }
	} else if (colorMap[index][0] < colorMap[index+1][0]) {
	    if (buf[i]-last[0] < -epsilon.color[0]) {
		StrMake(errStr, errStrFmt[1], errSizeX, errSizeY, errFilter,
			buf[0], buf[1], buf[2], last[0], last[1], last[2]);
		ErrorReport(__FILE__, __LINE__, errStr);
		return ERROR;
	    }
	}
	if (colorMap[index][1] > colorMap[index+1][1]) {
	    if (buf[i+1]-last[1] > epsilon.color[1]) {
		StrMake(errStr, errStrFmt[1], errSizeX, errSizeY, errFilter,
			buf[0], buf[1], buf[2], last[0], last[1], last[2]);
		ErrorReport(__FILE__, __LINE__, errStr);
		return ERROR;
	    }
	} else if (colorMap[index][1] < colorMap[index+1][1]) {
	    if (buf[i+1]-last[1] < -epsilon.color[1]) {
		StrMake(errStr, errStrFmt[1], errSizeX, errSizeY, errFilter,
			buf[0], buf[1], buf[2], last[0], last[1], last[2]);
		ErrorReport(__FILE__, __LINE__, errStr);
		return ERROR;
	    }
	}
	if (colorMap[index][2] > colorMap[index+1][2]) {
	    if (buf[i+2]-last[2] > epsilon.color[2]) {
		StrMake(errStr, errStrFmt[1], errSizeX, errSizeY, errFilter,
			buf[0], buf[1], buf[2], last[0], last[1], last[2]);
		ErrorReport(__FILE__, __LINE__, errStr);
		return ERROR;
	    }
	} else if (colorMap[index][2] < colorMap[index+1][2]) {
	    if (buf[i+2]-last[2] < -epsilon.color[2]) {
		StrMake(errStr, errStrFmt[1], errSizeX, errSizeY, errFilter,
			buf[0], buf[1], buf[2], last[0], last[1], last[2]);
		ErrorReport(__FILE__, __LINE__, errStr);
		return ERROR;
	    }
	}
	last[0] = buf[i];
	last[1] = buf[i+1];
	last[2] = buf[i+2];
    }

    return NO_ERROR;
}

static long Test(GLint filter, long sizeX, long sizeY, GLfloat *buf)
{
    GLfloat baseSizeX, baseSizeY;
    long i, drawCount;

    GetEnumName(filter, errFilter);

    glTexParameteriv(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, &filter);

    baseSizeX = sizeX;
    baseSizeY = sizeY;
    i = 1;
    while (sizeX > 1 && sizeY > 1) {
	errSizeX = sizeX;
	errSizeY = sizeY;

	glClear(GL_COLOR_BUFFER_BIT);

	drawCount = Draw((GLfloat)sizeX, (GLfloat)sizeY, baseSizeX, baseSizeY);

	if (Compare(buf, i++, drawCount) == ERROR) {
	    return ERROR;
	}

	sizeX /= 2;
	sizeY /= 2;
    }

    return NO_ERROR;
}

long MipLinExec(void)
{
    GLfloat *buf, x;
    long max; 
    GLsizei i, j;

    buf = (GLfloat *)MALLOC(WINDSIZEX*WINDSIZEY*3*sizeof(GLfloat));

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    glDisable(GL_DITHER);
    glEnable(GL_TEXTURE_2D);
    x = GL_DECAL;
    glTexEnvfv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, &x);

    max = (machine.pathLevel == 0) ? 2 : 32;
    for (i = 64; i > 2; i /= 2) {
	for (j = 64; j > max; j /= 2) {
	    Make(i, j, buf);
	    if (Test(GL_NEAREST_MIPMAP_LINEAR, i, j, buf) == ERROR) {
		FREE(buf);
		return ERROR;
	    }
	    if (Test(GL_LINEAR_MIPMAP_LINEAR, i, j, buf) == ERROR) {
		FREE(buf);
		return ERROR;
	    }
	}
    }

    FREE(buf);
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\l_sleha.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** l_sleha.c
** Light - Specular Light Eye Half Angle Test.
**
** Description -
**    This test is different from the other light tests in that
**    it moves the point being rendered rather than just changing
**    the settings of lighting parameters. The test only examines
**    RGB lighting although a similar test could easily be
**    written for CI mode. Most of the lighting summands are set
**    to 0.0. The Attenuation factor and the Spotlight factor are
**    set to 1.0. The Specular_Light is set to (1, 1, 1, 1) and
**    the Specular_Material is set to (1, 0, 0, 1). Finally the
**    Normal vector is set to (0, -1, 0) so the red component of
**    the light should be equal to the y component of the point's
**    normalized position. The color resulting from lighting is
**    compared to the results which are observed when the same
**    point is rendered with lighting disabled and the color of
**    (y/length, 0, 0, 1). These values should be equal even if
**    dithering is enabled. A difference of more than 1 shade
**    results in an implementation's failure.
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer.
**    Color requirements:
**        RGBA mode. Full color.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**        color epsilon.
**    Paths:
**        Allowed = Alpha, Blend, Depth, Logicop, Stencil, Stipple.
**        Not allowed = Alias, Dither, Fog, Shade.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"


static void Init(GLenum light)
{
    GLfloat buf[4];
    GLenum i;

    for (i = GL_LIGHT0; i <= GL_LIGHT7; i++) {
	glDisable(i);
    }
    glEnable(light);

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = 0.0;
    buf[3] = 1.0;
    glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, buf);

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = 0.0;
    buf[3] = 1.0;
    glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, buf);

    buf[0] = 1.0;
    buf[1] = 0.0;
    buf[2] = 0.0;
    buf[3] = 1.0;
    glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, buf);

    buf[0] = 1.0;
    buf[1] = 1.0;
    buf[2] = 1.0;
    buf[3] = 1.0;
    glLightfv(light, GL_SPECULAR, buf);

    buf[0] = 1.0;
    glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, buf);

    buf[0] = 0.0;
    buf[1] = -1.0;
    buf[2] = 0.0;
    buf[3] = 1.0;
    glNormal3fv(buf);

    buf[0] = 1.0;
    glLightModelfv(GL_LIGHT_MODEL_LOCAL_VIEWER, buf);

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = 0.0;
    buf[3] = 1.0;
    glLightfv(light, GL_POSITION, buf);
}

static long Test(GLenum light)
{
    GLfloat lightBuf[3], colorBuf[3]; 
    float length, size, x, y;

    Init(light);

    size = WINDSIZEX;
    if (size > WINDSIZEY) {
	size = WINDSIZEY;
    }

    for (y = 0.5; y <= size; y += 1.0) {
	x = SQRT(1.0-y*y/(size*size));
	x = FLOOR(size*x) + 0.5;

	glEnable(GL_LIGHTING);
	glBegin(GL_POINTS);
	    glVertex2f(x, y);
	glEnd();
	glDisable(GL_LIGHTING);

	ReadScreen((GLint)x, (GLint)y, 1, 1, GL_RGB, lightBuf);

	length = SQRT(x*x+y*y);
	glBegin(GL_POINTS);
	    glColor4f(y/length, 0.0, 0.0, 1.0);
	    glVertex2f(x, y);
	glEnd();

	ReadScreen((GLint)x, (GLint)y, 1, 1, GL_RGB, colorBuf);

	if (ABS(colorBuf[0]-lightBuf[0]) > (1.0 / 64.0) + 1.5*epsilon.color[0]) {
	    return ERROR;
	}
	if (ABS(colorBuf[1]-lightBuf[1]) > (1.0 / 64.0) + 1.5*epsilon.color[1]) {
	    return ERROR;
	}
	if (ABS(colorBuf[2]-lightBuf[2]) > (1.0 / 64.0) + 1.5*epsilon.color[2]) {
	    return ERROR;
	}
    }

    if (lightBuf[0] < 0.66) {
	return ERROR;
    }

    return NO_ERROR;
}

long SpecLEHAExec(void)
{
    long max;
    GLenum i;

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glClear(GL_COLOR_BUFFER_BIT);
    /*
    ** This test should be fine with dither enabled as well.
    */
    glDisable(GL_DITHER);

    max = (machine.pathLevel == 0) ? GL_LIGHT7 : GL_LIGHT0;
    for (i = GL_LIGHT0; i <= max; i++) {
	if (Test(i) == ERROR) {
	    ErrorReport(__FILE__, __LINE__, 0);
	    return ERROR;
	}
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\l_sn.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** l_sn.c
** Light - Specular Normal Test.
**
** Description -
**    This file contains code for CI and RGB tests. This test
**    analyses the effect that varying the Normal has on the
**    color produced by lighting, by way of its effect on the
**    Specular summand. To analyse only this one parameter, the
**    Specular_Lighting factor is set to a completely saturated
**    red in RGB mode and max_index in CI mode. In RGB mode
**    lighting parameters are chosen so that the Diffuse,
**    Ambient, and Emissive summands of the lighting equation are
**    set to zero and the Attenuation and the Spotlight factor
**    are both 1.0. In CI mode Ambient and Diffuse Material
**    Indices are set to zero so only the Specular summand is
**    non-zero. Specular_Material is set to maxIndex,
**    Specular_Light is (1, 1, 1, 1), and the SpotLight and
**    Attenuation factors are 1.0. The Specular_Exponent is
**    always set to 1.0.
**    
**    The test repeatedly renders and reads the same point at the
**    lower left corner of the screen. The third component of the
**    Normal is incremented by a uniform amount. The other two
**    components of the Normal are set so that the total length
**    of the Normal is 1. The Light_Position is set so that the
**    vector from the eye position of the rendered point to the
**    Light_position is (0, 0, 1). With the viewer set at
**    infinity. With these settings the normalized Half_Angle
**    vector is (0, 0, 1) so (Normal dot H_hat) = Normal[2]. The
**    lighting equation is reduced to color = red * Normal[2] in
**    RGB mode, or colorIndex = max index * Normal[2] in CI
**    mode.
**    
**    In RGB mode only the red color channel is tested. The
**    implementation fails if any other color channel is not
**    black. In both modes one light is enabled at a time, all
**    individual lights are tested.
**    
**    In RGB mode the uniformity of the change is tested, and the
**    implementation fails if consecutive changes are too
**    different. (thisDelta - lastDelta) > 1/4 shade. The
**    observed results are also checked for monotonicity. When
**    Normal[2] reaches 1.0 the color is finally checked to
**    insure that the point has rendered with a fully saturated
**    red.
**    
**    In CI mode a check is made to ensure that the observed
**    index reaches its max. The observed shade is compared to
**    the theoretical value expected for each setting of
**    Light_Position If the theoretical value is more than 3
**    indices away from the observed index the test fails. The
**    observed value must be an integer, and the difference
**    between successive observances must be less than 2.
**
** Error Explanation -
**    RGB mode: other_color > 0.0.
**    RGB mode: value < lastValue.
**    RGB mode: maxObserved < 1.0.
**    RGB mode: ABS(thisDelta - lastDelta) > 1/4 shade.
**    CI mode: observed index not an integer.
**    CI mode: (observed - expected) > 4.0.
**    CI mode: observedMax < numColor.
**    CI mode: delta > 2.0.
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer.
**    Color requirements:
**        RGBA or color index mode. Full color.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**        Color, ci and zero epsilons, 0.25*color_epsilon.
**    Paths:
**        Allowed = Alpha, Blend, Depth, Logicop, Stencil, Stipple.
**        Not allowed = Alias, Dither, Fog, Shade.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"
#include "utilru.h"


typedef struct _specNormRec {
    float step, numColor, lastValue, lastDelta, delta;
    GLenum light;
    GLfloat normal[3];
} specNormRec;


/*****************************************************************************/

static void Set(void *data, float *ref)
{
    specNormRec *ptr = (specNormRec *)data;

    ptr->normal[0] = SQRT(1.0-(*ref)*(*ref));
    ptr->normal[2] = *ref;
    glNormal3fv(ptr->normal);

    glBegin(GL_POINTS);
	glVertex2f(0.5, 0.5);
    glEnd();

    *ref += ptr->step;
}

/****************************************************************************/

static void InitRGB(void *data)
{
    specNormRec *ptr = (specNormRec *)data;
    GLfloat buf[4];
    float step;
    GLenum i;

    ptr->lastValue = -1.0;
    ptr->lastDelta = -2.0;

    step = (machine.pathLevel == 0) ? 4.0 : 2.0;
    ptr->delta = 1.0 / (POW(2.0, (float)buffer.colorBits[0]) - 1.0);
    ptr->step = ptr->delta / step;

    for (i = GL_LIGHT0; i <= GL_LIGHT7; i++) {
	glDisable(i);
    }
    glEnable(ptr->light);

    ptr->normal[0] = 0.0;
    ptr->normal[1] = 0.0;
    ptr->normal[2] = 0.0;

    buf[0] = 0.5;
    buf[1] = 0.5;
    buf[2] = 1.0;
    buf[3] = 1.0;
    glLightfv(ptr->light, GL_POSITION, buf);

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = 0.0;
    buf[3] = 1.0;
    glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, buf);

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = 0.0;
    buf[3] = 1.0;
    glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE, buf);

    buf[0] = 1.0;
    glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, buf);

    buf[0] = 1.0;
    buf[1] = 0.0;
    buf[2] = 0.0;
    buf[3] = 1.0;
    glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, buf);

    buf[0] = 1.0;
    buf[1] = 1.0;
    buf[2] = 1.0;
    buf[3] = 1.0;
    glLightfv(ptr->light, GL_SPECULAR, buf);
}

static long TestRGB(void *data, float ref)
{
    specNormRec *ptr = (specNormRec *)data;
    char str[240];
    GLfloat buf[3]; 
    float value, delta;
    long i;

    ReadScreen(0, 0, 1, 1, GL_RGB, buf);

    for (i = 1; i < 3; i++) {
	if (buf[i] != 0.0) {
            ColorError_RGBZero(str, 0, buf);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
    }

    value = buf[0];
    if (ptr->lastDelta == -2.0) {
	ptr->lastDelta = -1.0;
	ptr->lastValue = value;
    } else if (ptr->lastDelta == -1.0) {
	if (value < ptr->lastValue) {
            ColorError_RGBMonotonic(str, 0, value, ptr->lastValue);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	if (ABS(delta) > epsilon.zero) {
	    ptr->lastDelta = delta;
	}
    } else {
	if (value < ptr->lastValue) {
            ColorError_RGBMonotonic(str, 0, value, ptr->lastValue);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	if (ABS(delta) > epsilon.zero) {
	    ptr->lastDelta = delta;
	}
    }

    if (ref >= 1.0 && ABS(value-1.0) > epsilon.zero) {
        ColorError_RGBClamp(str, 0, value);
        ErrorReport(__FILE__, __LINE__, str);
	return ERROR;
    }

    return NO_ERROR;
}

long SpecNormRGBExec(void)
{
    specNormRec data;
    long max;

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glDisable(GL_DITHER);
    glEnable(GL_LIGHTING);

    max = (machine.pathLevel == 0) ? GL_LIGHT7 : GL_LIGHT0;
    for (data.light = GL_LIGHT0; data.light <= max; data.light++) {
	if (RampUtil(0.0, 1.0, InitRGB, Set, TestRGB, &data) == ERROR) {
	    return ERROR;
	}
    }
    return NO_ERROR;
}

/****************************************************************************/

static void InitCI(void *data)
{
    specNormRec *ptr = (specNormRec *)data;
    GLfloat buf[4];
    GLenum i;

    ptr->lastValue = -1.0;

    if (machine.pathLevel == 0) {
	ptr->step = 0.5 / ptr->numColor;
    } else {
	ptr->step = 0.25;
    }

    for (i = GL_LIGHT0; i <= GL_LIGHT7; i++) {
	glDisable(i);
    }
    glEnable(ptr->light);

    ptr->normal[0] = 0.0;
    ptr->normal[1] = 0.0;
    ptr->normal[2] = 0.0;

    buf[0] = 0.5;
    buf[1] = 0.5;
    buf[2] = 1.0;
    buf[3] = 1.0;
    glLightfv(ptr->light, GL_POSITION, buf);

    buf[0] = 1.0;
    glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, buf);

    /*
    ** The diffuse values are meaningless, hopefully.
    */
    buf[0] = 1.0;
    buf[1] = 1.0;
    buf[2] = 1.0;
    buf[3] = PI;
    glLightfv(ptr->light, GL_DIFFUSE, buf);

    buf[0] = 0.0;
    buf[1] = 0.0;
    buf[2] = ptr->numColor;
    glMaterialfv(GL_FRONT_AND_BACK, GL_COLOR_INDEXES, buf);

    buf[0] = 1.0;
    buf[1] = 1.0;
    buf[2] = 1.0;
    buf[3] = PI;
    glLightfv(ptr->light, GL_SPECULAR, buf);
}

static long TestCI(void *data, float ref)
{
    specNormRec *ptr = (specNormRec *)data;
    char str[240];
    GLfloat value;
    float expected, frac, delta, error;

    ReadScreen(0, 0, 1, 1, GL_COLOR_INDEX, &value);

    frac = ABS(value-(float)((int)value));
    if (frac > epsilon.zero && ABS(frac-1.0) > epsilon.zero) {
        ColorError_CIFrac(str, value);
        ErrorReport(__FILE__, __LINE__, str);
	return ERROR;
    }


    if (ptr->lastValue == -1.0) {
	ptr->lastValue = value;
    } else {
	if (value < ptr->lastValue) {
            ColorError_CIMonotonic(str, value, ptr->lastValue);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
	expected = (float)Round(2.0*ref*ptr->numColor) / 2.0;

	/*
	** Since we only use an exponent of 1.0 this should remain small.
	*/
	error = 2.0 * epsilon.ci + (ptr->numColor / 64.0);
	error = (error > 4.0 * epsilon.ci) ?  error : 4.0 * epsilon.ci;

	if (ABS(value-expected) > error + epsilon.zero) {
            ColorError_CIBad(str, value, expected);
            ErrorReport(__FILE__, __LINE__, str);
	    return ERROR;
	}
	delta = value - ptr->lastValue;
	ptr->lastValue = value;
	if (ABS(delta) > epsilon.zero) {
	    if (ABS(delta) >= error && machine.pathLevel == 0) {
                ColorError_CIStep(str, delta);
                ErrorReport(__FILE__, __LINE__, str);
		return ERROR;
	    }
	}
    }

    if (ref >= 1.0 && value < ptr->numColor) {
        ColorError_CIClamp(str, ptr->numColor, value);
        ErrorReport(__FILE__, __LINE__, str);
	return ERROR;
    }
    return NO_ERROR;
}

long SpecNormCIExec(void)
{
    specNormRec data;
    float start, end, frac;
    long max;

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glDisable(GL_DITHER);
    glEnable(GL_LIGHTING);

    max = (machine.pathLevel == 0) ? GL_LIGHT7 : GL_LIGHT0;
    data.numColor = POW(2.0, (float)buffer.ciBits) - 1.0;
    frac = POW(2.0, (float)(8-buffer.ciBits));
    for (data.light = GL_LIGHT0; data.light <= max; data.light++) {
	if (data.numColor < 4096.0 || machine.pathLevel != 0) {
	    start = 0.5 / data.numColor;
	    if (RampUtil(start, 1.0, InitCI, Set, TestCI, &data) == ERROR) {
		return ERROR;
	    }
	} else {
	    start = 0.5 / data.numColor;
	    end = frac;
	    if (RampUtil(start, end, InitCI, Set, TestCI, &data) == ERROR) {
		return ERROR;
	    }
	    start = 0.5 - frac;
	    end = 0.5 + frac;
	    if (RampUtil(start, end, InitCI, Set, TestCI, &data) == ERROR) {
		return ERROR;
	    }
	    start = 1.0 - frac;
	    if (RampUtil(start, 1.0, InitCI, Set, TestCI, &data) == ERROR) {
		return ERROR;
	    }
	}
    }
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\polyedge.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** polyedge.c
** Polygon Edge Test.
**
** Description -
**    Tests the edging of butting polygons. Two polygons are
**    drawn so that they share an edge. This edge is checked for
**    fragment duplication or dropout. Various edge slopes are
**    checked to insure correctness.
**
** Error Explanation -
**    Failure occurs if fragment duplication or dropout occurs
**    anywhere along the polygons' edge.
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer.
**    Color requirements:
**        RGBA or color index mode. Full color.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**    Paths:
**        Allowed = Alpha, Blend, Depth, Fog, Logicop, Shade, Stencil, Stipple.
**        Not allowed = Alias, Dither.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"


static char errStr[240];
static char errStrFmt[][160] = {
    "Polygon 1 is (%d.0, %d.0), (0.0, 0.0), (0.0, %d.0). Polygon 2 is (%d.0, %d.0), (%d.0, 0.0), (0.0, 0.0).",
    "Polygon 1 is (%d.0, %d.0), (%d.0, 0.0), (0.0, 0.0). Polygon 2 is (%d.0, %d.0), (0.0, %d.0), (0.0, 0.0)."
};


static long Test(GLsizei w, GLsizei h, GLfloat *buf)
{
    long i;

    if (buffer.colorMode == GL_RGB) {
	ReadScreen(0, 0, w, h, GL_RGB, buf);
	for (i = 0; i < w*h*3; i += 3) {
	    if (buf[i] < 0.4 || buf[i] > 0.6) {
		return ERROR;
	    }
	    if (buf[i+1] != 1.0) {
		return ERROR;
	    }
	    if (buf[i+2] != 1.0) {
		return ERROR;
	    }
	}
    } else {
	ReadScreen(0, 0, w, h, GL_COLOR_INDEX, buf);
	for (i = 0; i < w*h; i++) {
	    if (buf[i] != 3.0) {
		return ERROR;
	    }
	}
    }

    return NO_ERROR;
}

long PolyEdgeExec(void)
{
    GLfloat *buf;
    GLint step, i;

    buf = (GLfloat *)MALLOC(WINDSIZEX*WINDSIZEY*3*sizeof(GLfloat));

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);
    glDisable(GL_DITHER);

    if (buffer.colorMode == GL_RGB) {
	glClearColor(0.0, 0.0, 0.0, 0.0);
	glColor3f(0.5, 1.0, 1.0);
	glEnable(GL_BLEND);
	glBlendFunc(GL_ONE, GL_ONE);
    } else {
	glClearIndex(1);
	glIndexi(2);
	glEnable(GL_LOGIC_OP);
	glLogicOp(GL_XOR);
    }

    step = (machine.pathLevel == 0) ? 1 : (WINDSIZEX / 8);
    for (i = 1; i < WINDSIZEX-1; i += step) {
	glClear(GL_COLOR_BUFFER_BIT);

	glBegin(GL_POLYGON);
	    glVertex2i(i, WINDSIZEY);
	    glVertex2i(0, 0);
	    glVertex2i(0, WINDSIZEY);
	glEnd();
	glBegin(GL_POLYGON);
	    glVertex2i(i, WINDSIZEY);
	    glVertex2i(i, 0);
	    glVertex2i(0, 0);
	glEnd();

	if (Test(i, WINDSIZEY, buf) == ERROR) {
	    StrMake(errStr, errStrFmt[0], i, WINDSIZEY, WINDSIZEY, i,
		    WINDSIZEY);
	    ErrorReport(__FILE__, __LINE__, errStr);
	    FREE(buf);
	    return ERROR;
	}
    }

    step = (machine.pathLevel == 0) ? 1 : (WINDSIZEY / 8);
    for (i = 1; i < WINDSIZEY-1; i += step) {
	glClear(GL_COLOR_BUFFER_BIT);

	glBegin(GL_POLYGON);
	    glVertex2i(WINDSIZEX, i);
	    glVertex2i(WINDSIZEX, 0);
	    glVertex2i(0, 0);
	glEnd();
	glBegin(GL_POLYGON);
	    glVertex2i(WINDSIZEX, i);
	    glVertex2i(0, i);
	    glVertex2i(0, 0);
	glEnd();

	if (Test(WINDSIZEX, i, buf) == ERROR) {
	    StrMake(errStr, errStrFmt[0], WINDSIZEX, i, WINDSIZEX, WINDSIZEX,
		    i, i);
	    ErrorReport(__FILE__, __LINE__, errStr);
	    FREE(buf);
	    return ERROR;
	}
    }

    FREE(buf);
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\mustpass.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** mustpass.c
** Must Pass Test.
**
** Description -
**     Minimum OpenGL conformance tests:
**        Accumulation test.
**        Alpha plane test.
**        Bitmap test.
**        Blend test.
**        Color buffer clear test.
**        Clip test.
**        Color buffer color test.
**        Depth buffer test.
**        DisplayList test.
**        Evaluator test.
**        Feedback test.
**        Fog test.
**        Homogeneous coordinate test.
**        Lighting test.
**        LogicOp test.
**        Pixel transfer test.
**        Scissor test.
**        Select test.
**        Stencil test.
**        Stipple test.
**        Texture test.
**        WriteMask test.
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer, depth buffer, stencil plane, alpha buffer.
**    Color requirements:
**        No color requirements.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**    Paths:
**        Not allowed = Alias, Alpha, Blend, Depth, Dither, Fog, Logicop,
**                      Shade, Stencil, Stipple.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"


static long TestBuffer(GLint, GLint, GLfloat, GLfloat, GLfloat, GLfloat);
static long Accum(void);
static long Alpha(void);
static long Bitmap(void);
static long Blend(void);
static long Clear(void);
static long Clip(void);
static long Color(void);
static long Depth(void);
static long DisplayList(void);
static long Eval(void);
static long Feedback(void);
static long Fog(void);
static long Homogeneous(void);
static long Light(void);
static long LogicOp(void);
static long PixelTransfer(void);
static long Scissor(void);
static long Select(void);
static long Stencil(void);
static long Stipple(void);
static long Texture(void);
static long WriteMask(void);


long MustPassExec(void)
{

    glDisable(GL_DITHER);

    if (buffer.colorMode == GL_RGB) {
	if (Accum() == ERROR) {
	    return ERROR;
	}
	if (Alpha() == ERROR) {
	    return ERROR;
	}
    }
    if (Bitmap() == ERROR) {
	return ERROR;
    }
    if (buffer.colorMode == GL_RGB) {
	if (Blend() == ERROR) {
	    return ERROR;
	}
    }
    if (Clear() == ERROR) {
	return ERROR;
    }
    if (Clip() == ERROR) {
	return ERROR;
    }
    if (Color() == ERROR) {
	return ERROR;
    }
    if (buffer.zBits > 0) {
	if (Depth() == ERROR) {
	    return ERROR;
	}
    }
    if (DisplayList() == ERROR) {
	return ERROR;
    }
    if (Eval() == ERROR) {
	return ERROR;
    }
    if (Feedback() == ERROR) {
	return ERROR;
    }
    if (Fog() == ERROR) {
	return ERROR;
    }
    if (Homogeneous() == ERROR) {
	return ERROR;
    }
    if (Light() == ERROR) {
	return ERROR;
    }
    if (buffer.colorMode == GL_COLOR_INDEX) {
	if (LogicOp() == ERROR) {
	    return ERROR;
	}
    }
    if (PixelTransfer() == ERROR) {
	return ERROR;
    }
    if (Scissor() == ERROR) {
	return ERROR;
    }
    if (Select() == ERROR) {
	return ERROR;
    }
    if (buffer.stencilBits > 0) {
	if (Stencil() == ERROR) {
	    return ERROR;
	}
    }
    if (Stipple() == ERROR) {
	return ERROR;
    }
    if (buffer.colorMode == GL_RGB) {
	if (Texture() == ERROR) {
	    return ERROR;
	}
    }
    if (WriteMask() == ERROR) {
	return ERROR;
    }

    return NO_ERROR;
}

static long TestBuffer(GLint x, GLint y, GLfloat r, GLfloat g, GLfloat b,
		       GLfloat ci)
{
    GLfloat buf[3];

    if (buffer.colorMode == GL_RGB) {
	GLfloat errorRGB[3];
	errorRGB[0] = 0.49;
	errorRGB[1] = 0.49;
	errorRGB[2] = 0.49;
	glReadPixels(x, y, 1, 1, GL_RGB, GL_FLOAT, buf);
	if (ABS(buf[0]-r) > errorRGB[0] ||
	    ABS(buf[1]-g) > errorRGB[1] ||
	    ABS(buf[2]-b) > errorRGB[2]) {
	    return ERROR;
	}
    } else {
	GLfloat errorCI;
	errorCI = 0.49;
	glReadPixels(x, y, 1, 1, GL_COLOR_INDEX, GL_FLOAT, buf);
	if (ABS(buf[0]-ci) > errorCI) {
	    return ERROR;
	}
    }
    return NO_ERROR;
}

/*
** Accumulation Buffer Test.
** Clear framebuffer to one color, and clear accumulation buffer to
** zeros. Accum with a multiplier of one, clear the
** framebuffer, and then return accumulation buffer contents
** to framebuffer. Check that the framebuffer contains the
** original color.
*/
static long Accum(void)
{


    /*
    ** If there is no accumulation buffer, just return.
    */
    if ((buffer.accumBits[0]+buffer.accumBits[1]+buffer.accumBits[2]) == 0) {
        return NO_ERROR;
    }

    glClearColor(1.0, 0.0, 0.0, 0.0);
    glClearAccum(0.0, 0.0, 0.0, 0.0);
    glClear(GL_COLOR_BUFFER_BIT|GL_ACCUM_BUFFER_BIT);

    glAccum(GL_ACCUM, 1.0);

    glClearColor(0.0, 0.0, 1.0, 0.0);
    glClear(GL_COLOR_BUFFER_BIT);

    glAccum(GL_RETURN, 1.0);

    if (TestBuffer(50, 50, 1.0, 0.0, 0.0, 0.0) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Accumulation test.");
	return ERROR;
    }
    return NO_ERROR;
}

/*
** Alpha Test.
** Set up alpha function and alpha reference value. Draw primitive
** with alpha values such that the alpha function should not pass.
** Draw primitive again with alpha values such that the alpha
** function will pass.
*/
static long Alpha(void)
{

    Ortho2D(0.0, WINDSIZEX, 0.0, WINDSIZEY);

    /*
    ** Clear screen.
    */
    glClearColor(0.0, 0.0, 0.0, 0.0);
    glClear(GL_COLOR_BUFFER_BIT);

    /*
    ** Set up alpha function.
    */
    glEnable(GL_ALPHA_TEST);
    glAlphaFunc(GL_NOTEQUAL, 0.0);

    /*
    ** Draw a polygon with a alpha value of 0.0.
    ** Polygon should not render.
    */
    glColor4f(1.0, 1.0, 1.0, 0.0);
    glBegin(GL_POLYGON);
	glVertex2i(WINDSIZEX/4, WINDSIZEY/4);
	glVertex2i(WINDSIZEX*3/4, WINDSIZEY/4);
	glVertex2i(WINDSIZEX*3/4, WINDSIZEY*3/4);
	glVertex2i(WINDSIZEX/4, WINDSIZEY*3/4);
    glEnd();

    /*
    ** Check if polygon did not render.
    */
    if (TestBuffer(WINDSIZEX/2, WINDSIZEY/2, 0.0, 0.0, 0.0, 0) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Alpha test.");
	return ERROR;
    }

    /*
    ** Draw a polygon with a alpha value of 1.0.
    ** Polygon should render.
    */
    glColor4f(1.0, 1.0, 1.0, 1.0);
    glBegin(GL_POLYGON);
	glVertex2i(WINDSIZEX/4, WINDSIZEY/4);
	glVertex2i(WINDSIZEX*3/4, WINDSIZEY/4);
	glVertex2i(WINDSIZEX*3/4, WINDSIZEY*3/4);
	glVertex2i(WINDSIZEX/4, WINDSIZEY*3/4);
    glEnd();

    /*
    ** Check if polygon rendered.
    */
    if (TestBuffer(WINDSIZEX/2, WINDSIZEY/2, 1.0, 1.0, 1.0, 1) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Alpha test.");
	return ERROR;
    }

    glDisable(GL_ALPHA_TEST);
    return NO_ERROR;
}

/*
** Bitmap Test.
** Set up and draw a solid pattern bitmap. Check that it rendered.
*/
static long Bitmap(void)
{
    GLubyte bitMap[32*32];
    GLfloat rastX, rastY, offsetX, offsetY, incX, incY;
    GLsizei sizeX, sizeY;
    GLint x, y, i;

    Ortho2D(0.0, WINDSIZEX, 0.0, WINDSIZEY);

    if (buffer.colorMode == GL_RGB) {
	glClearColor(0.0, 0.0, 0.0, 0.0);
	glColor3f(1.0, 1.0, 1.0);
    } else {
	glClearIndex(0.0);
	glIndexi(1);
    }

    glClear(GL_COLOR_BUFFER_BIT);

    /*
    ** Set up current raster position.
    */
    rastX = 50.0;
    rastY = 50.0;
    glRasterPos2f(rastX, rastY);

    /*
    ** Set up bitmap.
    */
    for (i = 0; i < 32*32; i++) {
	bitMap[i] = 0xFF;
    }
    sizeX = 32;
    sizeY = 32;
    offsetX = 0;
    offsetY = 0;
    incX = 0;
    incY = 0;

    /*
    ** Draw bitmap.
    */
    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
    glBitmap(sizeX, sizeY, offsetX, offsetY, incX, incY, bitMap);
    glPixelStorei(GL_UNPACK_ALIGNMENT, 4);

    /*
    ** Calculate center of bitmap location.
    */
    x = (GLint)(rastX - offsetX) + 16;
    y = (GLint)(rastY - offsetY) + 16;

    /*
    ** Check if bitmap rendered.
    */
    if (TestBuffer(x, y, 1.0, 1.0, 1.0, 1) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Bitmap test.");
	return ERROR;
    }

    return NO_ERROR;
}

/*
** Blend Test.
** Draw primitive with known color (setting blend destination
** color). Enable blending. Draw same primitive in another
** known color (setting blend source color). Compare rendered
** color to calculated results.
*/
static long Blend(void)
{

    Ortho2D(0.0, WINDSIZEX, 0.0, WINDSIZEY);

    /*
    ** Set destination color to zeros.
    */
    glDisable(GL_BLEND);
    glBegin(GL_POINTS);
	glColor3f(0.0, 0.0, 0.0);
	glVertex2f(0.5, 0.5);
    glEnd();

    /*
    ** Set blend function.
    */
    glBlendFunc(GL_ZERO, GL_ONE);

    /*
    ** Set source color to ones.
    */
    glEnable(GL_BLEND);
    glBegin(GL_POINTS);
	glColor3f(1.0, 1.0, 1.0);
	glVertex2f(0.5, 0.5);
    glEnd();

    /*
    ** Check that the blended color is the destination color.
    */
    if (TestBuffer(0, 0, 0.0, 0.0, 0.0, 0) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Blend test.");
	return ERROR;
    }

    /*
    ** Set destination color to zeros.
    */
    glDisable(GL_BLEND);
    glBegin(GL_POINTS);
	glColor3f(0.0, 0.0, 0.0);
	glVertex2f(0.5, 0.5);
    glEnd();

    /*
    ** Set blend function.
    */
    glBlendFunc(GL_ONE, GL_ZERO);

    /*
    ** Set source color to ones.
    */
    glEnable(GL_BLEND);
    glBegin(GL_POINTS);
	glColor3f(1.0, 1.0, 1.0);
	glVertex2f(0.5, 0.5);
    glEnd();

    /*
    ** Check that the blended color is the source color.
    */
    if (TestBuffer(0, 0, 1.0, 1.0, 1.0, 1) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Blend test.");
	return ERROR;
    }

    glDisable(GL_BLEND);
    return NO_ERROR;
}

/*
** Clear Test.
** Set the clear value. Check that the screen cleared to the
** correct value. Repeat test with a different clear value.
*/
static long Clear(void)
{

    glClearColor(0.0, 0.0, 0.0, 1.0);
    glClearIndex(1);
    glClear(GL_COLOR_BUFFER_BIT);
    if (TestBuffer(10, 10, 0.0, 0.0, 0.0, 1) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Clear test.");
	return ERROR;
    }

    glClearColor(1.0, 1.0, 1.0, 1.0);
    glClearIndex(0);
    glClear(GL_COLOR_BUFFER_BIT);
    if (TestBuffer(30, 30, 1.0, 1.0, 1.0, 0) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Clear test.");
	return ERROR;
    }

    return NO_ERROR;
}

/*
** Clipping Test.
** Initialize clip plane #5 to non-default values, but don't
** enable it. Enable plane #0 with the default (0, 0, 0, 0).
** Check that it has no effect. Enable clip plane #5. Check
** that it clips the bottom half of a primitive. (The bottom
** half should be gone while the top half remains).
*/
static long Clip(void)
{
    static GLdouble planeEqn[] = {
	0.0, 1.0, 0.0, -50.0, 
    };
    static GLfloat identity[16] = {
	1.0, 0.0, 0.0, 0.0,
	0.0, 1.0, 0.0, 0.0,
	0.0, 0.0, 1.0, 0.0,
	0.0, 0.0, 0.0, 1.0
    };
    GLint mode;

    glGetIntegerv(GL_MATRIX_MODE, &mode);
    glMatrixMode(GL_PROJECTION);
    glPushMatrix();
    glLoadMatrixf(identity);
    glOrtho(0.0, WINDSIZEX, 0.0, WINDSIZEY, -0.01, 0.99);

		    
    glClearColor(0.0, 0.0, 0.0, 1.0);
    glClearIndex(0);
    glColor3f(0.0, 1.0, 0.0);
    glIndexi(2);

    /*
    ** Note we set these parameters to the clip plane 5 which stays disabled 
    ** in case some clip planes are not working.
    */
    glClipPlane(GL_CLIP_PLANE5, planeEqn);

    glEnable(GL_CLIP_PLANE0);
    glClear(GL_COLOR_BUFFER_BIT);
    glBegin(GL_POLYGON);
	glVertex3f(25.0, 25.0, 0.0);
	glVertex3f(25.0, 75.0, 0.0);
	glVertex3f(75.0, 75.0, 0.0);
	glVertex3f(75.0, 25.0, 0.0);
    glEnd();
    if (TestBuffer(35, 35, 0.0, 1.0, 0.0, 2.0) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Clip test.");
	return ERROR;
    }
    if (TestBuffer(35, 65, 0.0, 1.0, 0.0, 2.0) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Clip test.");
	return ERROR;
    }

    glEnable(GL_CLIP_PLANE5);
    glClear(GL_COLOR_BUFFER_BIT);
    glBegin(GL_POLYGON);
	glVertex3f(25.0, 25.0, 0.0);
	glVertex3f(25.0, 75.0, 0.0);
	glVertex3f(75.0, 75.0, 0.0);
	glVertex3f(75.0, 25.0, 0.0);
    glEnd();
    if (TestBuffer(35, 35, 0.0, 0.0, 0.0, 0.0) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Clip test.");
	return ERROR;
    }
    if (TestBuffer(35, 65, 0.0, 1.0, 0.0, 2.0) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Clip test.");
	return ERROR;
    }

    glDisable(GL_CLIP_PLANE5);
    glDisable(GL_CLIP_PLANE0);
    glPopMatrix();
    glMatrixMode(mode);

    return NO_ERROR;
}

/*
** RGB / Color Index Test.
** Draw primitive with know color. Check that the primitive
** rendered in the correct color.
*/
static long Color(void)
{

    Ortho2D(0.0, WINDSIZEX, 0.0, WINDSIZEY);

    glClearColor(0.0, 0.0, 0.0, 1.0);
    glClearIndex(0);
    glClear(GL_COLOR_BUFFER_BIT);

    glColor3f(0.0, 1.0, 0.0);
    glIndexi(2);

    glBegin(GL_TRIANGLES);
	glVertex2f(25.0, 25.0);
	glVertex2f(25.0, 75.0);
	glVertex2f(75.0, 25.0);
    glEnd();
    if (TestBuffer(10, 10, 0.0, 0.0, 0.0, 0) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Color test.");
	return ERROR;
    }
    if (TestBuffer(30, 30, 0.0, 1.0, 0.0, 2) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Color test.");
	return ERROR;
    }

    return NO_ERROR;
}

/*
** Depth Test.
** Draw a green polygon. Draw an intersecting red
** polygon. Check that the whole image is red (since the red
** polygon came second and depth is not enabled.) Clear,
** enable the depth-test, and then redraw the green polygon
** and check two points are green. Draw the intersecting red
** polygon, Check that one of the above two points is now red,
** and the other is still green.
*/
static long Depth(void)
{
    static GLfloat identity[16] = {
	1.0, 0.0, 0.0, 0.0,
	0.0, 1.0, 0.0, 0.0,
	0.0, 0.0, 1.0, 0.0,
	0.0, 0.0, 0.0, 1.0
    };
    GLint mode;

    glClearColor(0.0, 0.0, 0.0, 1.0);
    glClearIndex(0);
    glClear(GL_COLOR_BUFFER_BIT);

    glGetIntegerv(GL_MATRIX_MODE, &mode);
    glMatrixMode(GL_PROJECTION);
    glPushMatrix();
    glLoadMatrixf(identity);
    glOrtho(0.0, WINDSIZEX, 0.0, WINDSIZEY, 1.0, -1.0);

    /*
    ** Check that second object drawn is visible if depth test off.
    */
    glColor3f(0.0, 1.0, 0.0);
    glIndexi(2);
    glBegin(GL_POLYGON);
	glVertex3f(25.0, 25.0, -1.00);
	glVertex3f(25.0, 75.0, -1.00);
	glVertex3f(75.0, 75.0,  0.00);
	glVertex3f(75.0, 25.0,  0.00);
    glEnd();

    glColor3f(1.0, 0.0, 0.0);
    glIndexi(1);
    glBegin(GL_POLYGON);
	glVertex3f(25.0, 25.0,  0.00);
	glVertex3f(25.0, 75.0,  0.00);
	glVertex3f(75.0, 75.0, -1.00);
	glVertex3f(75.0, 25.0, -1.00);
    glEnd();
    if (TestBuffer(10, 10, 0.0, 0.0, 0.0, 0.0) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Depth test.");
	return ERROR;
    }
    if (TestBuffer(30, 50, 1.0, 0.0, 0.0, 1.0) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Depth test.");
	return ERROR;
    }
    if (TestBuffer(65, 50, 1.0, 0.0, 0.0, 1.0) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Depth test.");
	return ERROR;
    }

    /*
    ** Check that green object is visible when depth test first turned on.
    */
    glDepthRange(-1.0, 1.0);
    glEnable(GL_DEPTH_TEST);
    glClear(GL_DEPTH_BUFFER_BIT);

    glColor3f(0.0, 1.0, 0.0);
    glIndexi(2);
    glBegin(GL_POLYGON);
	glVertex3f(25.0, 25.0, -1.00);
	glVertex3f(25.0, 75.0, -1.00);
	glVertex3f(75.0, 75.0,  0.00);
	glVertex3f(75.0, 25.0,  0.00);
    glEnd();
    if (TestBuffer(30, 50, 0.0, 1.0, 0.0, 2.0) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Depth test.");
	return ERROR;
    }
    if (TestBuffer(65, 50, 0.0, 1.0, 0.0, 2.0) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Depth test.");
	return ERROR;
    }

    /*
    ** Check that half red and half green object is visible when depth test on
    ** after first drawing.
    */
    glColor3f(1.0, 0.0, 0.0);
    glIndexi(1);
    glBegin(GL_POLYGON);
	glVertex3f(25.0, 25.0,  0.00);
	glVertex3f(25.0, 75.0,  0.00);
	glVertex3f(75.0, 75.0, -1.00);
	glVertex3f(75.0, 25.0, -1.00);
    glEnd();
    if (TestBuffer(30, 50, 0.0, 1.0, 0.0, 2.0) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Depth test.");
	return ERROR;
    }
    if (TestBuffer(65, 50, 1.0, 0.0, 0.0, 1.0) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Depth test.");
	return ERROR;
    }

    glDisable(GL_DEPTH_TEST);
    glPopMatrix();
    glMatrixMode(mode);
    return NO_ERROR;
}

/*
** Display List Test.
** Create a display list to draw a triangle fan using
** GL_COMPILE. Check that the primitive did not render during
** the creation of the list. Call the list and check that the
** primitive was rendered.
*/
static long DisplayList(void)
{
    GLuint n;

    Ortho2D(0.0, WINDSIZEX, 0.0, WINDSIZEY);
    
    glClearColor(0.0, 0.0, 0.0, 0.0);
    glClearIndex(0);
    glClear(GL_COLOR_BUFFER_BIT);

    n = glGenLists(1);
    glNewList(n, GL_COMPILE);
	glColor3f(0.0, 1.0, 0.0);
	glIndexf(2.0);
	glBegin(GL_TRIANGLE_FAN);
	    glVertex2f(25.0, 50.0);
	    glVertex2f(50.0, 90.0);
	    glVertex2f(80.0, 30.0);
	    glVertex2f(50.0, 0.0);
	glEnd();
    glEndList();

    if (TestBuffer(50, 50, 0.0, 0.0, 0.0, 0.0) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Display list test.");
	return ERROR;
    }

    glCallList(n);

    glDeleteLists(n, 1);

    if (TestBuffer(50, 50, 0.0, 1.0, 0.0, 2.0) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Display list test.");
	return ERROR;
    }

    return NO_ERROR;
}

/*
** Evaluator Test.
** Draw a quad in the center of the viewport with vertices
** resulting from the evaluation of an 8 x 7 set of control
** points. Check that a point in the quad is colored
** correctly and that a point outside of the polygon is the
** clear color/index.
*/
static long Eval(void)
{
    static GLfloat defaultBuf[4] = {
	0.0, 0.0, 0.0, 1.0
    };
    static GLfloat point2f[7*8*4] = {
	0.0,      0.0, 0.0, 1.0,
	14.28571, 0.0, 0.0, 1.0,
	28.57143, 0.0, 0.0, 1.0,
	42.85714, 0.0, 0.0, 1.0,
	57.14286, 0.0, 0.0, 1.0,
	71.42857, 0.0, 0.0, 1.0,
	85.71429, 0.0, 0.0, 1.0,
	100.0,    0.0, 0.0, 1.0,

	0.0,      16.666667, 0.0, 1.0,
	14.28571, 16.666667, 0.0, 1.0,
	28.57143, 16.666667, 0.0, 1.0,
	42.85714, 16.666667, 0.0, 1.0,
	57.14286, 16.666667, 0.0, 1.0,
	71.42857, 16.666667, 0.0, 1.0,
	85.71429, 16.666667, 0.0, 1.0,
	100.0,    16.666667, 0.0, 1.0,

	0.0,      33.333333, 0.0, 1.0,
	14.28571, 33.333333, 0.0, 1.0,
	28.57143, 33.333333, 0.0, 1.0,
	42.85714, 33.333333, 0.0, 1.0,
	57.14286, 33.333333, 0.0, 1.0,
	71.42857, 33.333333, 0.0, 1.0,
	85.71429, 33.333333, 0.0, 1.0,
	100.0,    33.333333, 0.0, 1.0,

	0.0,      50.0, 0.0, 1.0,
	14.28571, 50.0, 0.0, 1.0,
	28.57143, 50.0, 0.0, 1.0,
	42.85714, 50.0, 0.0, 1.0,
	57.14286, 50.0, 0.0, 1.0,
	71.42857, 50.0, 0.0, 1.0,
	85.71429, 50.0, 0.0, 1.0,
	100.0,    50.0, 0.0, 1.0,

	0.0,      66.666667, 0.0, 1.0,
	14.28571, 66.666667, 0.0, 1.0,
	28.57143, 66.666667, 0.0, 1.0,
	42.85714, 66.666667, 0.0, 1.0,
	57.14286, 66.666667, 0.0, 1.0,
	71.42857, 66.666667, 0.0, 1.0,
	85.71429, 66.666667, 0.0, 1.0,
	100.0,    66.666667, 0.0, 1.0,

	0.0,      83.333333, 0.0, 1.0,
	14.28571, 83.333333, 0.0, 1.0,
	28.57143, 83.333333, 0.0, 1.0,
	42.85714, 83.333333, 0.0, 1.0,
	57.14286, 83.333333, 0.0, 1.0,
	71.42857, 83.333333, 0.0, 1.0,
	85.71429, 83.333333, 0.0, 1.0,
	100.0,    83.333333, 0.0, 1.0,

	0.0,      100.0, 0.0, 1.0,
	14.28571, 100.0, 0.0, 1.0,
	28.57143, 100.0, 0.0, 1.0,
	42.85714, 100.0, 0.0, 1.0,
	57.14286, 100.0, 0.0, 1.0,
	71.42857, 100.0, 0.0, 1.0,
	85.71429, 100.0, 0.0, 1.0,
	100.0,    100.0, 0.0, 1.0
    };

    Ortho2D(0.0, WINDSIZEX, 0.0, WINDSIZEY);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glClearIndex(0);
    glClear(GL_COLOR_BUFFER_BIT);

    glMap2f(GL_MAP2_VERTEX_4, 0.0, 1.0, 8*4, 7, 0.0, 1.0, 4, 8, point2f);
    glEnable(GL_MAP2_VERTEX_4);

    glColor3f(0.0, 1.0, 0.0);
    glIndexf(2.0);
    glBegin(GL_QUADS);
	glEvalCoord2d(0.25, 0.25);
	glEvalCoord2d(0.25, 0.75);
	glEvalCoord2d(0.75, 0.75);
	glEvalCoord2d(0.75, 0.25);
    glEnd();
    if (TestBuffer(20, 20, 0.0, 0.0, 0.0, 0.0) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Evaluator test.");
	return ERROR;
    }
    if (TestBuffer(30, 30, 0.0, 1.0, 0.0, 2.0) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Evaluator test.");
	return ERROR;
    }

    glMap2f(GL_MAP2_VERTEX_4, 0.0, 1.0, 4, 1, 0.0, 1.0, 4, 1, defaultBuf);
    glDisable(GL_MAP2_VERTEX_4);

    return NO_ERROR;
}

/*
** Feedback Test.
** Draw primitive in feedback mode. Check feedback buffer for correct
** size and data.
*/
static long Feedback(void)
{
    GLfloat *feedBackBuf, *ptr, coordError;
    GLint totalSize, returnSize;

    coordError = 1.0 / 128.0;

    Ortho2D(0.0, WINDSIZEX, 0.0, WINDSIZEY);

    /*
    ** Set up feedback buffer.
    */
    feedBackBuf = ptr = (GLfloat *)MALLOC(1000*sizeof(GLfloat));
    glFeedbackBuffer(1000, GL_4D_COLOR_TEXTURE, feedBackBuf);

    /*
    ** Enter feedback mode.
    */
    returnSize = glRenderMode(GL_FEEDBACK);

    /*
    ** Draw simple primitive with position, color and texture data.
    */
    glBegin(GL_POINTS);
	(buffer.colorMode == GL_RGB) ? glColor4f(1.0, 1.0, 1.0, 1.0) :
				       glIndexi(1);
	glTexCoord4f(1.0, 1.0, 1.0, 1.0);
	glVertex4f(1.0, 1.0, 0.0, 1.0);
    glEnd();

    /*
    ** Exit feedback mode, get feedback buffer size.
    */
    returnSize = glRenderMode(GL_RENDER);

    /*
    ** Check returned feedback buffer size.
    */
    if (buffer.colorMode == GL_RGB) {
	totalSize = 1 + 4 + 4 + 4;
    } else {
	totalSize = 1 + 4 + 1 + 4;
    }
    if (returnSize != totalSize) {
	ErrorReport(__FILE__, __LINE__, "Feedback test.");
	FREE(feedBackBuf);
	return ERROR;
    }

    /*
    ** Check feedback token.
    */
    if (*ptr++ != GL_POINT_TOKEN) {
	ErrorReport(__FILE__, __LINE__, "Feedback test.");
	FREE(feedBackBuf);
	return ERROR;
    }

    /*
    ** Check feedback vertex info.
    */
    if (ABS(*(ptr+0)-1.0) > coordError ||
	ABS(*(ptr+1)-1.0) > coordError ||
	ABS(*(ptr+3)-1.0) > coordError) {
	ErrorReport(__FILE__, __LINE__, "Feedback test.");
	FREE(feedBackBuf);
	return ERROR;
    }
    ptr += 4;

    /*
    ** Check feedback color info.
    */
    if (buffer.colorMode == GL_RGB) {
	if (ABS(*(ptr+0)-1.0) > epsilon.color[0]/2.0 ||
	    ABS(*(ptr+1)-1.0) > epsilon.color[1]/2.0 ||
	    ABS(*(ptr+2)-1.0) > epsilon.color[2]/2.0 ||
	    ABS(*(ptr+3)-1.0) > epsilon.color[3]/2.0) {
	    ErrorReport(__FILE__, __LINE__, "Feedback test.");
	    FREE(feedBackBuf);
	    return ERROR;
	}
	ptr += 4;
    } else {
	if (ABS(*ptr-1.0) > epsilon.ci) {
	    ErrorReport(__FILE__, __LINE__, "Feedback test.");
	    FREE(feedBackBuf);
	    return ERROR;
	}
	ptr++;
    }

    /*
    ** Check feedback texture coordinate info.
    */
    if (ABS(*(ptr+0)-1.0) > coordError ||
	ABS(*(ptr+1)-1.0) > coordError ||
	ABS(*(ptr+3)-1.0) > coordError) {
	ErrorReport(__FILE__, __LINE__, "Feedback test.");
	FREE(feedBackBuf);
	return ERROR;
    }

    FREE(feedBackBuf);
    return NO_ERROR;
}

/*
** Fog Test.
** In RGB mode check that a primitive which is well beyond the
** linear fog end value is entirely the current color when fog
** is disabled, and is entirely the fog color when fog is
** enabled. In CI mode check that the same primitive is the
** current index when fog is disabled and is the sum of the
** fog index and the current index when fog is enabled.
*/
static long Fog(void)
{
    static GLfloat red[4] = {
	1.0, 0.0, 0.0, 1.0
    };
    static GLfloat identity[16] = {
	1.0, 0.0, 0.0, 0.0,
	0.0, 1.0, 0.0, 0.0,
	0.0, 0.0, 1.0, 0.0,
	0.0, 0.0, 0.0, 1.0
    };
    GLint mode;

    glGetIntegerv(GL_MATRIX_MODE, &mode);
    glMatrixMode(GL_PROJECTION);
    glPushMatrix();
    glLoadMatrixf(identity);
    glOrtho(0.0, WINDSIZEX, 0.0, WINDSIZEY, 1.0, -1.0);
		    
    /*
    ** Choose z, fogEnd and fogStart values so that fog factor will 
    ** clamp to zero for all known fog algorithms.  
    ** (z, z-interpolation from vertex z, distance, distance-interpolation)
    */
    glClearColor(0.0, 0.0, 0.0, 1.0);
    glClearIndex(0);
    glClear(GL_COLOR_BUFFER_BIT);

    glColor3f(0.0, 1.0, 0.0);
    glIndexi(2);

    glFogfv(GL_FOG_COLOR, red);
    glFogi(GL_FOG_INDEX, 1);
    glFogf(GL_FOG_START, 0.0);
    glFogf(GL_FOG_END, 0.5);
    glFogi(GL_FOG_MODE, GL_LINEAR);

    /*
    ** Check that object drawn is colored since fog is disabled.
    */  
    glBegin(GL_TRIANGLE_FAN);
	glVertex3f(25.0, 25.0, -0.75);
	glVertex3f(25.0, 75.0, -0.75);
	glVertex3f(75.0, 75.0, -0.75);
	glVertex3f(75.0, 25.0, -0.75);
    glEnd();
    if (TestBuffer(10, 10, 0.0, 0.0, 0.0, 0.0) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Fog test.");
	return ERROR;
    }
    if (TestBuffer(30, 30, 0.0, 1.0, 0.0, 2.0) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Fog test.");
	return ERROR;
    }
    if (TestBuffer(65, 65, 0.0, 1.0, 0.0, 2.0) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Fog test.");
	return ERROR;
    }

    /*
    ** Check that object drawn is fogged now that fog enabled.
    */
    glEnable(GL_FOG);
    glBegin(GL_TRIANGLE_FAN);
	glVertex3f(25.0, 25.0, -0.75);
	glVertex3f(25.0, 75.0, -0.75);
	glVertex3f(75.0, 75.0, -0.75);
	glVertex3f(75.0, 25.0, -0.75);
    glEnd();
    /*
    ** In RGB mode the object should be only the fog color, in color index
    ** mode it should be the fog index plus the current color index.
    */
    if (TestBuffer(10, 10, 0.0, 0.0, 0.0, 0.0) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Fog test.");
	return ERROR;
    }
    if (TestBuffer(30, 30, 1.0, 0.0, 0.0, 3.0) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Fog test.");
	return ERROR;
    }
    if (TestBuffer(65, 65, 1.0, 0.0, 0.0, 3.0) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Fog test.");
	return ERROR;
    }

    glDisable(GL_FOG);
    glPopMatrix();
    glMatrixMode(mode);

    return NO_ERROR;
}

/*
** Homogeneous Coordinate Test.
** Draw a polygon with 4th coordinates clamped to 1.0.
** Check that a point outside of the polygon is clear and that
** points near the vertices of the polygon are the current
** color/index. Multiply all of the vertex coordinates by
** 10.0 (including the 4th coordinate). Examine the same points
** checked previously. There should be no observable effect.
** Multiply all of the vertex coordinates by 1/10 (including
** the 4th coordinate). Repeat the above tests.
*/
static long Homogeneous(void)
{

    Ortho3D(0.0, WINDSIZEX, 0.0, WINDSIZEY, 10.0, -10.0);

    glClearColor(0.0, 0.0, 0.0, 1.0);
    glClearIndex(0);

    glColor3f(0.0, 1.0, 0.0);
    glIndexi(2);
    glClear(GL_COLOR_BUFFER_BIT);
    glBegin(GL_POLYGON);
	glVertex4f(25.0, 25.0, 0.0, 1.0);
	glVertex4f(25.0, 75.0, 0.0, 1.0);
	glVertex4f(75.0, 75.0, 0.0, 1.0);
	glVertex4f(75.0, 25.0, 0.0, 1.0);
    glEnd();
    /*
    ** Outside.
    */
    if (TestBuffer(10, 10, 0.0, 0.0, 0.0, 0) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Homogeneous test.");
	return ERROR;
    }
    /*
    ** Inside.
    */
    if (TestBuffer(30, 30, 0.0, 1.0, 0.0, 2) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Homogeneous test.");
	return ERROR;
    }
    if (TestBuffer(30, 70, 0.0, 1.0, 0.0, 2) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Homogeneous test.");
	return ERROR;
    }
    if (TestBuffer(70, 70, 0.0, 1.0, 0.0, 2) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Homogeneous test.");
	return ERROR;
    }
    if (TestBuffer(70, 30, 0.0, 1.0, 0.0, 2) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Homogeneous test.");
	return ERROR;
    }

    glColor3f(1.0, 0.0, 0.0);
    glIndexi(1);
    glClear(GL_COLOR_BUFFER_BIT);
    glBegin(GL_POLYGON);
	glVertex4f(250.0, 250.0, 0.0, 10.0);
	glVertex4f(250.0, 750.0, 0.0, 10.0);
	glVertex4f(750.0, 750.0, 0.0, 10.0);
	glVertex4f(750.0, 250.0, 0.0, 10.0);
    glEnd();
    /*
    ** Outside.
    */
    if (TestBuffer(10, 10, 0.0, 0.0, 0.0, 0) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Homogeneous test.");
	return ERROR;
    }
    /*
    ** Inside.
    */
    if (TestBuffer(30, 30, 1.0, 0.0, 0.0, 1) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Homogeneous test.");
	return ERROR;
    }
    if (TestBuffer(30, 70, 1.0, 0.0, 0.0, 1) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Homogeneous test.");
	return ERROR;
    }
    if (TestBuffer(70, 70, 1.0, 0.0, 0.0, 1) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Homogeneous test.");
	return ERROR;
    }
    if (TestBuffer(70, 30, 1.0, 0.0, 0.0, 1) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Homogeneous test.");
	return ERROR;
    }

    glColor3f(0.0, 1.0, 0.0);
    glIndexi(2);
    glClear(GL_COLOR_BUFFER_BIT);
    glBegin(GL_POLYGON);
	glVertex4f(2.5, 2.5, 0.0, 0.1);
	glVertex4f(2.5, 7.5, 0.0, 0.1);
	glVertex4f(7.5, 7.5, 0.0, 0.1);
	glVertex4f(7.5, 2.5, 0.0, 0.1);
    glEnd();
    /*
    ** Outside.
    */
    if (TestBuffer(10, 10, 0.0, 0.0, 0.0, 0) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Homogeneous test.");
	return ERROR;
    }
    /*
    ** Inside.
    */
    if (TestBuffer(30, 30, 0.0, 1.0, 0.0, 2) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Homogeneous test.");
	return ERROR;
    }
    if (TestBuffer(30, 70, 0.0, 1.0, 0.0, 2) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Homogeneous test.");
	return ERROR;
    }
    if (TestBuffer(70, 70, 0.0, 1.0, 0.0, 2) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Homogeneous test.");
	return ERROR;
    }
    if (TestBuffer(70, 30, 0.0, 1.0, 0.0, 2) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Homogeneous test.");
	return ERROR;
    }

    return NO_ERROR;
}

/*
** Lighting Test.
** Initialize lighting parameters to green ambient light. Set
** current color to red. Draw with light disabled. Check
** that the primitive is red. Enable lighting and redraw
** the same primitive. Check that the primitive is green.
*/
static long Light(void)
{
    GLfloat buf[4];

    Ortho2D(0.0, WINDSIZEX, 0.0, WINDSIZEY);

    glClearColor(0.0, 0.0, 0.0, 1.0);
    glClearIndex(0);
    glClear(GL_COLOR_BUFFER_BIT);

    /*
    ** In RGB mode, set ambient to red.
    */
    buf[0] = 1.0; 
    buf[1] = 0.0; 
    buf[2] = 0.0; 
    buf[3] = 1.0; 
    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, buf);
    glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, buf);

    /*
    ** In color index mode, set ambient, diffuse, and specular material to red.
    */
    buf[0] = 1.0;
    buf[1] = 1.0;
    buf[2] = 1.0;
    glMaterialfv(GL_FRONT_AND_BACK, GL_COLOR_INDEXES, buf);

    glColor3f(0.0, 1.0, 0.0);
    glIndexi(2);

    /*
    ** Check that object drawn is colored green since light is disabled.
    */  
    glBegin(GL_QUAD_STRIP);
	glVertex2f(25.0, 25.0);
	glVertex2f(25.0, 75.0);
	glVertex2f(75.0, 25.0);
	glVertex2f(75.0, 75.0);
    glEnd();
    if (TestBuffer(30, 30, 0.0, 1.0, 0.0, 2) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Light test.");
	return ERROR;
    }

    /*
    ** Check that object drawn is lit, now that lighting is enabled.
    */
    glEnable(GL_LIGHTING);
    glBegin(GL_QUAD_STRIP);
	glVertex2f(25.0, 25.0);
	glVertex2f(25.0, 75.0);
	glVertex2f(75.0, 25.0);
	glVertex2f(75.0, 75.0);
    glEnd();
    glDisable(GL_LIGHTING);
    if (TestBuffer(10, 10, 0.0, 0.0, 0.0, 0) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Light test.");
	return ERROR;
    }
    if (TestBuffer(30, 30, 1.0, 0.0, 0.0, 1) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Light test.");
	return ERROR;
    }

    return NO_ERROR;
}

/*
** Logic Op Test.
** Draw primitive with known color (setting logicop destination
** color). Enable logicop. Draw same primitive in another
** known color (setting logicop source color). Compare rendered
** color to calculated results.
*/
static long LogicOp(void)
{

    Ortho2D(0.0, WINDSIZEX, 0.0, WINDSIZEY);

    /*
    ** Set logic op.
    */
    glLogicOp(GL_XOR);

    /*
    ** Draw destination color index.
    */
    glDisable(GL_LOGIC_OP);
    glBegin(GL_POINTS);
	glIndexi(0);
	glVertex2f(0.5, 0.5);
    glEnd();

    /*
    ** Draw source color index.
    */
    glEnable(GL_LOGIC_OP);
    glBegin(GL_POINTS);
	glIndexi(0);
	glVertex2f(0.5, 0.5);
    glEnd();

    /*
    ** 0 (source color index) XOR 0 (destination color index) -> 0
    */
    if (TestBuffer(0, 0, 0.0, 0.0, 0.0, 0) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Logic op test.");
	return ERROR;
    }

    /*
    ** Draw destination color index.
    */
    glDisable(GL_LOGIC_OP);
    glBegin(GL_POINTS);
	glIndexi(0);
	glVertex2f(0.5, 0.5);
    glEnd();

    /*
    ** Draw source color index.
    */
    glEnable(GL_LOGIC_OP);
    glBegin(GL_POINTS);
	glIndexi(1);
	glVertex2f(0.5, 0.5);
    glEnd();

    /*
    ** !0 (source color index) XOR 0 (destination color index) -> !0
    */
    if (TestBuffer(0, 0, 1.0, 1.0, 1.0, 1) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Logic op test.");
	return ERROR;
    }

    /*
    ** Draw destination color index.
    */
    glDisable(GL_LOGIC_OP);
    glBegin(GL_POINTS);
	glIndexi(1);
	glVertex2f(0.5, 0.5);
    glEnd();

    /*
    ** Draw source color index.
    */
    glEnable(GL_LOGIC_OP);
    glBegin(GL_POINTS);
	glIndexi(0);
	glVertex2f(0.5, 0.5);
    glEnd();

    /*
    ** 0 (source color index) XOR !0 (destination color index) -> !0
    */
    if (TestBuffer(0, 0, 1.0, 1.0, 1.0, 1) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Logic op test.");
	return ERROR;
    }

    /*
    ** Draw destination color index.
    */
    glDisable(GL_LOGIC_OP);
    glBegin(GL_POINTS);
	glIndexi(1);
	glVertex2f(0.5, 0.5);
    glEnd();

    /*
    ** Draw source color index.
    */
    glEnable(GL_LOGIC_OP);
    glBegin(GL_POINTS);
	glIndexi(1);
	glVertex2f(0.5, 0.5);
    glEnd();

    /*
    ** !0 (source color index) XOR !0 (destination color index) -> 0
    */
    if (TestBuffer(0, 0, 0.0, 0.0, 0.0, 0) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Logic op test.");
	return ERROR;
    }

    glDisable(GL_LOGIC_OP);
    return NO_ERROR;
}

/*
** Pixel Transfer Test.
** For RGB, fill an image with (0.2, 0.2, 0.2) and set scale
** factors to (5, 0, 0). For color index, fill image with 1's,
** set set GL_INDEX_SHIFT to 1. Call glDrawPixels() and look
** for RGB result of (1.0, 0.0, 0.0) or color index of 2.
*/
static long PixelTransfer(void)
{
    GLint i, *imagei;
    GLfloat *imagef;

    Ortho2D(0.0, WINDSIZEX, 0.0, WINDSIZEY);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glClearIndex(0);
    glClear(GL_COLOR_BUFFER_BIT);

    glRasterPos2f(0.0, 0.0);

    if (buffer.colorMode == GL_RGB) {
	glPixelTransferf(GL_RED_SCALE, 5.0);
	glPixelTransferf(GL_GREEN_SCALE, 0.0);
	glPixelTransferf(GL_BLUE_SCALE, 0.0);

	imagef = (GLfloat *)MALLOC(9*3*sizeof(GLfloat));
	for (i = 0; i < 27; i++) {
	    imagef[i] = 0.2;
	}

	glDrawPixels(3, 3, GL_RGB, GL_FLOAT, imagef);
	glPixelTransferf(GL_RED_SCALE, 1.0);
	glPixelTransferf(GL_GREEN_SCALE, 1.0);
	glPixelTransferf(GL_BLUE_SCALE, 1.0);
	FREE(imagef);

	if (TestBuffer(1, 1, 1.0, 0.0, 0.0, 0.0) == ERROR) {
	    ErrorReport(__FILE__, __LINE__, "Pixel transfer test.");
	    return ERROR;
	}
    } else {
	glPixelTransferi(GL_INDEX_SHIFT, 1);

	imagei = (GLint *)MALLOC(9*sizeof(GLint));
	for (i = 0; i < 9; i++) {
	    imagei[i] = 1;
	}

	glDrawPixels(3, 3, GL_COLOR_INDEX, GL_INT, imagei);

	glPixelTransferi(GL_INDEX_SHIFT, 0);
	FREE(imagei);

	if (TestBuffer(1, 1, 0.0, 0.0, 0.0, 2.0) == ERROR) {
	    ErrorReport(__FILE__, __LINE__, "Pixel transfer test.");
	    return ERROR;
	}
    }
    return NO_ERROR;
}

/*
** Scissor Test.
** Set up scissor box. Draw primitive. Check that primitive only
** rendered in scissor box.
*/
static long Scissor(void)
{

    Ortho2D(0.0, WINDSIZEX, 0.0, WINDSIZEY);

    if (buffer.colorMode == GL_RGB) {
	glClearColor(0.0, 0.0, 0.0, 0.0);
	glColor3f(1.0, 1.0, 1.0);
    } else {
	glClearIndex(0.0);
	glIndexi(1);
    }

    glScissor(10, 10, 10, 10);

    /*
    ** Clear screen.
    */
    glDisable(GL_SCISSOR_TEST);
    glClear(GL_COLOR_BUFFER_BIT);

    /*
    ** Draw polygon over entire screen.
    */
    glEnable(GL_SCISSOR_TEST);
    glBegin(GL_POLYGON);
	glVertex2f(0.0, 0.0);
	glVertex2f(WINDSIZEX, 0.0);
	glVertex2f(WINDSIZEX, WINDSIZEY);
	glVertex2f(0.0, WINDSIZEY);
    glEnd();

    /*
    ** Check if polygon rendered in scissor area.
    */
    if (TestBuffer(15, 15, 1.0, 1.0, 1.0, 1) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Scissor test.");
	return ERROR;
    }

    /*
    ** Check if polygon did not rendered outside scissor area.
    */
    if (TestBuffer(5, 5, 0.0, 0.0, 0.0, 0) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Scissor test.");
	return ERROR;
    }

    glDisable(GL_SCISSOR_TEST);
    return NO_ERROR;
}

/*
** Select Test.
** Draw primitive in select mode. Check select buffer for correct
** size and data.
*/
static long Select(void)
{
    GLuint *selectBuf;
    GLint returnTotal;

    Ortho3D(0.0, WINDSIZEX, 0.0, WINDSIZEY, 0.0, -10.0);

    /*
    ** Set up select buffer.
    */
    selectBuf = (GLuint *)MALLOC(100*sizeof(GLuint));
    glSelectBuffer(100, selectBuf);

    /*
    ** Enter select mode.
    */
    returnTotal = glRenderMode(GL_SELECT);

    glInitNames();

    glPushName(1);

    glBegin(GL_POINTS);
	glVertex3i(WINDSIZEX/2, WINDSIZEY/2, 5);
    glEnd();

    glPopName();

    /*
    ** Exit select mode, get number of select hits.
    */
    returnTotal = glRenderMode(GL_RENDER);

    /*
    ** Check for correct number of select hits.
    */
    if (returnTotal != 1) {
	ErrorReport(__FILE__, __LINE__, "Select test.");
	FREE(selectBuf);
	return ERROR;
    }

    /*
    ** Check for correct select name stack size.
    */
    if (selectBuf[0] != 1) {
	ErrorReport(__FILE__, __LINE__, "Select test.");
	FREE(selectBuf);
	return ERROR;
    }

    /* Check select name stack.
    */
    if (selectBuf[3] != 1) {
	ErrorReport(__FILE__, __LINE__, "Select test.");
	FREE(selectBuf);
	return ERROR;
    }

    FREE(selectBuf);
    return NO_ERROR;
}

/* 
** Stencil Test.
** Set the stencil function so that a primitive should fail
** the stencil test. Clear the screen, draw the primitive,
** and check that it did not render. Change the function so
** that the primitive should pass. Draw the primitive and
** check that it did render.
*/
static long Stencil(void)
{

    Ortho2D(0.0, WINDSIZEX, 0.0, WINDSIZEY);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glClearIndex(0);
    glClearStencil(1);
    glClear(GL_COLOR_BUFFER_BIT|GL_STENCIL_BUFFER_BIT);

    glColor3f(0.0, 0.0, 1.0);
    glIndexf(3.0);

    glEnable(GL_STENCIL_TEST);
    glStencilOp(GL_KEEP, GL_KEEP, GL_KEEP);

    glStencilFunc(GL_GREATER, 0, ~0);
    glBegin(GL_TRIANGLE_STRIP);
	glVertex2f(20.0, 20.0);
	glVertex2f(30.0, 80.0);
	glVertex2f(80.0, 30.0);
	glVertex2f(70.0, 80.0);
    glEnd();
    if (TestBuffer(50, 50, 0.0, 0.0, 0.0, 0.0) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Stencil test.");
	return ERROR;
    }

    glStencilFunc(GL_LEQUAL, 0, ~0);
    glBegin(GL_TRIANGLE_STRIP);
	glVertex2f(20.0, 20.0);
	glVertex2f(30.0, 80.0);
	glVertex2f(80.0, 30.0);
	glVertex2f(70.0, 80.0);
    glEnd();

    if (TestBuffer(50, 50, 0.0, 0.0, 1.0, 3.0) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Stencil test.");
	return ERROR;
    }

    glDisable(GL_STENCIL_TEST);
    return NO_ERROR;
}

/*
** Stipple Test.
** Draw a large polygon with opaque stipple, and test that the
** center is the current color. Clear. Draw the same polygon
** with a stipple pattern of all zeros, and check that the
** center is the clear color.
*/
static long Stipple(void)
{
    long i;
    GLubyte fillPattern[128];

    Ortho2D(0.0, WINDSIZEX, 0.0, WINDSIZEY);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glClearIndex(0.0);
    glClear(GL_COLOR_BUFFER_BIT);

    glColor3f(0.0, 1.0, 0.0);
    glIndexf(2.0);

    glEnable(GL_POLYGON_STIPPLE);
    for (i = 0; i < 128; i++) {
        fillPattern[i] = 0xFF;
    }
    glPolygonStipple(fillPattern);
    glBegin(GL_POLYGON);
	glVertex4f(1.0, 50.0, 0.0, 1.0);
	glVertex4f(70.0, 99.0, 0.0, 1.0);
	glVertex4f(80.0, 1.0, 0.0, 1.0);
    glEnd();
    if (TestBuffer(50, 50, 0.0, 1.0, 0.0, 2.0) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Stipple test.");
	return ERROR;
    }

    glClear(GL_COLOR_BUFFER_BIT);

    for (i = 0; i < 128; i++) {
        fillPattern[i] = 0x00;
    }
    glPolygonStipple(fillPattern);
    glBegin(GL_POLYGON);
	glVertex4f(1.0, 50.0, 0.0, 1.0);
	glVertex4f(70.0, 99.0, 0.0, 1.0);
	glVertex4f(80.0, 1.0, 0.0, 1.0);
    glEnd();
    if (TestBuffer(50, 50, 0.0, 0.0, 0.0, 0.0) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Stipple test.");
	return ERROR;
    }

    glDisable(GL_POLYGON_STIPPLE);
    return NO_ERROR;
}

/*
** Texture Test.
** Initialize a texture 1/2 green and 1/2 magenta. Draw an
** object with texture disabled. Check that it is rendered the
** current color, white.  Enable texture. Draw the same
** object. Check that the object is green on the left and
** magenta on the right.
*/
static long Texture(void)
{
    static GLfloat t[] = {
	0.0, 1.0, 0.0,
	1.0, 0.0, 1.0
    };

    Ortho2D(0.0, WINDSIZEX, 0.0, WINDSIZEY);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glClear(GL_COLOR_BUFFER_BIT);

    glTexImage2D(GL_TEXTURE_2D, 0, 3, 2, 1, 0, GL_RGB, GL_FLOAT, 
	         (unsigned char *)t);
    glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP);

    glColor3f(1.0, 1.0, 1.0);
    glBegin(GL_QUAD_STRIP);
	glTexCoord2f(0.25, 0.25);
	glVertex2i(25, 25);
	glTexCoord2f(0.25, 0.75);
	glVertex2i(25, 75);
	glTexCoord2f(0.75, 0.25);
	glVertex2i(75, 25);
	glTexCoord2f(0.75, 0.75);
	glVertex2i(75, 75);
    glEnd();
    if (TestBuffer(10, 10, 0.0, 0.0, 0.0, 0.0) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Texture test.");
	return ERROR;
    }
    if (TestBuffer(35, 50, 1.0, 1.0, 1.0, 0.0) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Texture test.");
	return ERROR;
    }
    if (TestBuffer(65, 50, 1.0, 1.0, 1.0, 0.0) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Texture test.");
	return ERROR;
    }

    glEnable(GL_TEXTURE_2D);
    glBegin(GL_QUAD_STRIP);
	glTexCoord2f(0.25, 0.25);
	glVertex2i(25, 25);
	glTexCoord2f(0.25, 0.75);
	glVertex2i(25, 75);
	glTexCoord2f(0.75, 0.25);
	glVertex2i(75, 25);
	glTexCoord2f(0.75, 0.75);
	glVertex2i(75, 75);
    glEnd();
    if (TestBuffer(10, 10, 0.0, 0.0, 0.0, 0.0) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Texture test.");
	return ERROR;
    }
    if (TestBuffer(35, 50, 0.0, 1.0, 0.0, 0.0) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Texture test.");
	return ERROR;
    }
    if (TestBuffer(65, 50, 1.0, 0.0, 1.0, 0.0) == ERROR) {
	ErrorReport(__FILE__, __LINE__, "Texture test.");
	return ERROR;
    }

    glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    glDisable(GL_TEXTURE_2D);

    return NO_ERROR;
}

/*
** WriteMask Test.
** Disable all writing, make sure nothing gets written. 
** Enable all writing, make sure everything gets written.
*/
static long WriteMask(void)
{
    long allBits;

    Ortho2D(0.0, WINDSIZEX, 0.0, WINDSIZEY);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glClearIndex(0.0);
    glClear(GL_COLOR_BUFFER_BIT);

    if (buffer.colorMode == GL_RGB) {
	glColor3f(1.0, 1.0, 1.0);
	glColorMask(GL_FALSE, GL_FALSE, GL_FALSE, GL_FALSE);
	glRecti(20, 20, 70, 70);
	if (TestBuffer(50, 50, 0.0, 0.0, 0.0, 0.0) == ERROR) {
	    ErrorReport(__FILE__, __LINE__, "Write mask test.");
	    return ERROR;
        }

	glColorMask(GL_TRUE, GL_TRUE, GL_TRUE, GL_TRUE);
	glRecti(20, 20, 70, 70);
	if (TestBuffer(50, 50, 1.0, 1.0, 1.0, 0.0) == ERROR) {
	    ErrorReport(__FILE__, __LINE__, "Write mask test.");
	    return ERROR;
        }
    } else {
	glIndexf(1.0);
	glIndexMask(0);
	glRecti(20, 20, 70, 70);
	if (TestBuffer(50, 50, 0.0, 0.0, 0.0, 0.0) == ERROR) {
	    ErrorReport(__FILE__, __LINE__, "Write mask test.");
	    return ERROR;
        }

	allBits = (1 << buffer.ciBits) - 1;
	glIndexMask((GLuint)allBits);
	glRecti(20, 20, 70, 70);
	if (TestBuffer(50, 50, 0.0, 0.0, 0.0, 1.0) == ERROR) {
	    ErrorReport(__FILE__, __LINE__, "Write mask test.");
	    return ERROR;
	}
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\pntrast.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** pntrast.c
** Point Rasterization Test.
**
** Description -
**    Points of increasing size (both odd and even sizes) are
**    drawn then checked for correctness.
**    Point size tested are limited to half the window size, in this case 50.
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer.
**    Color requirements:
**        RGBA or color index mode. 2 colors.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**    Paths:
**        Allowed = Alpha, Blend, Depth, Fog, Logicop, Shade, Stencil, Stipple.
**        Not allowed = Alias, Dither.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"


static char errStr[160];
static char errStrFmt[][80] = {
    "Point did not draw correctly along the %s edge. Size = %d.",
    "Point did not draw correctly. Size = %d.",
};


long PointRasterExec(void)
{
    GLfloat *buf, *ptr;
    GLint size, x, i, j;
    GLfloat count, pntRange[2], maxSize;

    buf = (GLfloat *)MALLOC(WINDSIZEX*WINDSIZEY*sizeof(GLfloat));

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    AutoClearColor(COLOR_OFF);
    AutoColor(COLOR_ON);
    glDisable(GL_DITHER);

    glGetFloatv(GL_POINT_SIZE_RANGE, pntRange);
    /* 
    ** Limit point sizes tested to half the window size.
    */
    maxSize = (pntRange[1] > WINDSIZEX/2) ? WINDSIZEX/2 : pntRange[1];

    for (count = 1.0; count <= maxSize; count += 1.0) {
	size = (GLint)count;

	glClear(GL_COLOR_BUFFER_BIT);

        glPointSize((GLfloat)size);
	glBegin(GL_POINTS);
	    x = (size + 1) / 2;
	    glVertex2f((GLfloat)x+0.5, (GLfloat)x+0.5);
	glEnd();

	ReadScreen(0, 0, size+2, size+2, GL_AUTO_COLOR, buf);

	ptr = buf;
	for (i = 0; i < size+2; i++) {
	    if (AutoColorCompare(*ptr++, COLOR_OFF) == GL_FALSE) {
		StrMake(errStr, errStrFmt[0], "bottom", size);
		ErrorReport(__FILE__, __LINE__, errStr);
		FREE(buf);
		return ERROR;
	    }
	}
	for (i = 0; i < size; i++) {
	    if (AutoColorCompare(*ptr++, COLOR_OFF) == GL_FALSE) {
		StrMake(errStr, errStrFmt[0], "left", size);
		ErrorReport(__FILE__, __LINE__, errStr);
		FREE(buf);
		return ERROR;
	    }

	    for (j = 0; j < size; j++) {
		if (AutoColorCompare(*ptr++, COLOR_ON) == GL_FALSE) {
		    StrMake(errStr, errStrFmt[1], size);
		    ErrorReport(__FILE__, __LINE__, errStr);
		    FREE(buf);
		    return ERROR;
		}
	    }

	    if (AutoColorCompare(*ptr++, COLOR_OFF) == GL_FALSE) {
		StrMake(errStr, errStrFmt[0], "rigth", size);
		ErrorReport(__FILE__, __LINE__, errStr);
		FREE(buf);
		return ERROR;
	    }
	}
	for (i = 0; i < size+2; i++) {
	    if (AutoColorCompare(*ptr++, COLOR_OFF) == GL_FALSE) {
		StrMake(errStr, errStrFmt[0], "top", size);
		ErrorReport(__FILE__, __LINE__, errStr);
		FREE(buf);
		return ERROR;
	    }
	}
    }

    FREE(buf);
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\polycull.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** polycull.c
** Polygon Culling Test.
**
** Description -
**    First, with culling disabled, a polygon is drawn both
**    clockwise and counter-clockwise. The polygon should render
**    in both cases. Culling is then enabled. With culling
**    direction set to GL_FRONT, a polygon is drawn both
**    clockwise and counter-clockwise. Only the polygon drawn in
**    the clockwise direction should render. With culling
**    direction is set to GL_BACK, a polygon is drawn both
**    clockwise and counter-clockwise. Only the polygon drawn in
**    the counter-clockwise direction should render.
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer.
**    Color requirements:
**        RGBA or color index mode. 2 colors.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**    Paths:
**        Allowed = Alpha, Blend, Depth, Fog, Logicop, Shade, Stencil, Stipple.
**        Not allowed = Alias, Dither.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"


static char errStr[][160] = {
    "GL_CULL_FACE is disabled. Polygon was drawn counter-clockwise. Polygon was not rendered, should have rendered.",
    "GL_CULL_FACE is disabled. Polygon was drawn clockwise. Polygon was not rendered, should have rendered.",
    "GL_CULL_FACE is enabled. glCullFace is GL_FRONT. Polygon was drawn clockwise. Polygon was not rendered, should have rendered.",
    "GL_CULL_FACE is enabled. glCullFace is GL_FRONT. Polygon was drawn counter-clockwise. Polygon was rendered, should not have rendered.",
    "GL_CULL_FACE is enabled. glCullFace is GL_BACK. Polygon was drawn clockwise. Polygon was rendered, should not have rendered.",
    "GL_CULL_FACE is enabled. glCullFace is GL_BACK. Polygon was drawn counter-clockwise. Polygon was not rendered, should have rendered.",
};


static long CheckZero(GLfloat *buf)
{
    long i;

    ReadScreen(0, 0, WINDSIZEX, WINDSIZEY, GL_AUTO_COLOR, buf);
    for (i = 0; i < WINDSIZEX*WINDSIZEY; i++) {
	if (AutoColorCompare(buf[i], COLOR_OFF) == GL_FALSE) {
	    return ERROR;
	}
    }
    return NO_ERROR;
}

static long CheckNonZero(GLfloat *buf)
{
    long i;

    ReadScreen(0, 0, WINDSIZEX, WINDSIZEY, GL_AUTO_COLOR, buf);
    for (i = 0; i < WINDSIZEX*WINDSIZEY; i++) {
	if (AutoColorCompare(buf[i], COLOR_ON) == GL_FALSE) {
	    return ERROR;
	}
    }
    return NO_ERROR;
}

static void Draw(long dir)
{

    glClear(GL_COLOR_BUFFER_BIT);
    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
    glBegin(GL_POLYGON);
	if (dir == GL_CCW) {
	    glVertex2i(0, 0);
	    glVertex2i(WINDSIZEX, 0);
	    glVertex2i(WINDSIZEX, WINDSIZEY);
	    glVertex2i(0, WINDSIZEY);
	} else {
	    glVertex2i(0, 0);
	    glVertex2i(0, WINDSIZEY);
	    glVertex2i(WINDSIZEX, WINDSIZEY);
	    glVertex2i(WINDSIZEX, 0);
	}
    glEnd();
}

long PolyCullExec(void)
{
    GLfloat *buf;

    buf = (GLfloat *)MALLOC(WINDSIZEX*WINDSIZEY*sizeof(GLfloat));

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    AutoClearColor(COLOR_OFF);
    AutoColor(COLOR_ON);
    glDisable(GL_DITHER);

    glDisable(GL_CULL_FACE);

    Draw(GL_CCW);
    if (CheckNonZero(buf) == ERROR) {
	ErrorReport(__FILE__, __LINE__, errStr[0]);
	FREE(buf);
	return ERROR;
    }
    Draw(GL_CW);
    if (CheckNonZero(buf) == ERROR) {
	ErrorReport(__FILE__, __LINE__, errStr[1]);
	FREE(buf);
	return ERROR;
    }

    glEnable(GL_CULL_FACE);

    glCullFace(GL_FRONT);
    Draw(GL_CW);
    if (CheckNonZero(buf) == ERROR) {
	ErrorReport(__FILE__, __LINE__, errStr[2]);
	FREE(buf);
	return ERROR;
    }
    Draw(GL_CCW);
    if (CheckZero(buf) == ERROR) {
	ErrorReport(__FILE__, __LINE__, errStr[3]);
	FREE(buf);
	return ERROR;
    }

    glCullFace(GL_BACK);
    Draw(GL_CW);
    if (CheckZero(buf) == ERROR) {
	ErrorReport(__FILE__, __LINE__, errStr[4]);
	FREE(buf);
	return ERROR;
    }
    Draw(GL_CCW);
    if (CheckNonZero(buf) == ERROR) {
	ErrorReport(__FILE__, __LINE__, errStr[5]);
	FREE(buf);
	return ERROR;
    }

    FREE(buf);
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\pntaa.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** pntaa.c
** Point Anti-Aliasing Test.
**
** Description -
**    Tests position independence of anti-aliased points. It
**    chooses a point of random size from the implementation dependent
**    range, and computes the resulting coverage.
**    The point is then drawn at various offsets, each time a new
**    coverage is computed and compared with the original value.
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer.
**    Color requirements:
**        RGBA mode. Full color.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**        The error allowance is based on a minimum of 4 subpixel sampling.
**        This yields 0.25 per pixel on the circumference of the point.
**        Thus 0.25 is multiplied by 2*pi*r or 2*pointsize, to create the
**        allowable error margin.
**    Paths:
**        Allowed = Depth, Fog, Logicop, Shade, Stencil, Stipple.
**        Not allowed = Alias, Alpha, Blend, Dither.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"


static char errStr[240];
static char errStrFmt[][80] = {
    "Point primative did not draw.",
    "Coverage is %g, should be %g. Error margin is %g."
};


static long Test(float dirX, float dirY, GLfloat *buf, float errorMargin)
{
    GLfloat sum, saveSum=0.0f, size, offset, step, x, y;
    GLfloat sizeRange[2]; 
    long i;

    glGetFloatv(GL_POINT_SIZE_RANGE, sizeRange);
    size = Random(sizeRange[0], sizeRange[1]);
    glPointSize(size);

    errorMargin *= PI * size;

    x = Random(size+10.0, WINDSIZEX-1.0-size-10.0);
    y = Random(size+10.0, WINDSIZEY-1.0-size-10.0);

    step = (machine.pathLevel == 0) ? 0.055 : 0.5;
    for (offset = 0.0; offset <= 2.0; offset += step) {
	glClear(GL_COLOR_BUFFER_BIT);

	glBegin(GL_POINTS);
	    if (dirX == 0.0) {
		glVertex2f(x, offset*dirY+y);
	    } else {
		glVertex2f(offset*dirX+x, y);
	    }
	glEnd();

	ReadScreen(0, 0, WINDSIZEX, WINDSIZEY, GL_RGB, buf);

	sum = 0.0;
	for (i = 0; i < WINDSIZEX*WINDSIZEY*3; i += 3) {
	    sum += buf[i];
	}

	if (offset < step) {
	    saveSum = sum;
	} else {
	    if (sum == 0.0) {
		ErrorReport(__FILE__, __LINE__, errStrFmt[0]);
		return ERROR;
	    } else if (ABS(saveSum-sum) > errorMargin) {
		StrMake(errStr, errStrFmt[1], sum, saveSum, errorMargin);
		ErrorReport(__FILE__, __LINE__, errStr);
		return ERROR;
	    }
	}
    }

    return NO_ERROR;
}

long PointAntiAliasExec(void)
{
    GLfloat *buf;

    buf = (GLfloat *)MALLOC(WINDSIZEX*WINDSIZEY*3*sizeof(GLfloat));

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glColor3f(1.0, 0.0, 0.0);
    glDisable(GL_DITHER);
    glEnable(GL_POINT_SMOOTH);
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE);

    if (Test(1.0, 0.0, buf, 0.25) == ERROR) {
	FREE(buf);
	return ERROR;
    }
    if (Test(-1.0, 0.0, buf, 0.25) == ERROR) {
	FREE(buf);
	return ERROR;
    }
    if (Test(0.0, 1.0, buf, 0.25) == ERROR) {
	FREE(buf);
	return ERROR;
    }
    if (Test(0.0, -1.0, buf, 0.25) == ERROR) {
	FREE(buf);
	return ERROR;
    }

    FREE(buf);
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\polyface.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** polyface.c
** Polygon Face Test.
**
** Description -
**    Tests the functionality of glFrontFace() with
**    glPolygonMode(). glFrontFace() and glPolygonMode() are set
**    so that when a polygon is drawn, the frame of the polygon
**    should render but the body should not. Both clockwise and
**    counter-clockwise directions for glFrontFace() are
**    checked.
**    
**    Note that the corners of the polygon are skipped since the
**    OpenGL specification allows polygons drawn in line mode to
**    be off by one pixels. Therefore, there could be missing
**    pixels at the polygon corners.
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer.
**    Color requirements:
**        RGBA or color index mode. 2 colors.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**    Paths:
**        Allowed = Alpha, Blend, Depth, Fog, Logicop, Shade, Stencil, Stipple.
**        Not allowed = Alias, Dither.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"


static char errDir[40];
static char errStr[160];
static char errStrFmt[][80] = {
    "glFrontFace is %s. Polygon frame was not rendered, should have rendered.",
    "glFrontFace is %s. Polygon body was rendered, should not have rendered."
};


static long Check(GLfloat *ptr)
{
    long i, j;

    /*
    ** Check bottom.
    */
    ptr++;
    for (i = 1; i < WINDSIZEX-1; i++) {
	if (AutoColorCompare(*ptr++, COLOR_ON) == GL_FALSE) {
	    StrMake(errStr, errStrFmt[0], errDir);
	    ErrorReport(__FILE__, __LINE__, errStr);
	    return ERROR;
	}
    }
    ptr++;

    for (i = 0; i < WINDSIZEY-2; i++) {
	/*
	** Check left.
	*/
	if (AutoColorCompare(*ptr++, COLOR_ON) == GL_FALSE) {
	    StrMake(errStr, errStrFmt[0], errDir);
	    ErrorReport(__FILE__, __LINE__, errStr);
	    return ERROR;
	}

        /*
	** Check inside.
	*/
	for (j = 0; j < WINDSIZEX-2; j++) {
	    if (AutoColorCompare(*ptr++, COLOR_OFF) == GL_FALSE) {
		StrMake(errStr, errStrFmt[1], errDir);
		ErrorReport(__FILE__, __LINE__, errStr);
		return ERROR;
	    }
	}

	/*
	** Check right.
	*/
	if (AutoColorCompare(*ptr++, COLOR_ON) == GL_FALSE) {
	    StrMake(errStr, errStrFmt[0], errDir);
	    ErrorReport(__FILE__, __LINE__, errStr);
	    return ERROR;
	}
    }

    /*
    ** Check top.
    */
    ptr++;
    for (i = 1; i < WINDSIZEX-1; i++) {
	if (AutoColorCompare(*ptr++, COLOR_ON) == GL_FALSE) {
	    StrMake(errStr, errStrFmt[0], errDir);
	    ErrorReport(__FILE__, __LINE__, errStr);
	    return ERROR;
	}
    }
    ptr++;

    return NO_ERROR;
}

static long Test(GLenum dir, GLfloat *buf)
{

    glClear(GL_COLOR_BUFFER_BIT);

    GetEnumName(dir, errDir);
    glFrontFace(dir);

    if (dir == GL_CCW) {
	glPolygonMode(GL_FRONT, GL_FILL);
	glPolygonMode(GL_BACK, GL_LINE);
    } else {
	glPolygonMode(GL_FRONT, GL_LINE);
	glPolygonMode(GL_BACK, GL_FILL);
    }

    glBegin(GL_POLYGON);
	glVertex2f(0.5, 0.5);
	glVertex2f(0.5, WINDSIZEY-0.5);
	glVertex2f(WINDSIZEX-0.5, WINDSIZEY-0.5);
	glVertex2f(WINDSIZEX-0.5, 0.5);
    glEnd();

    ReadScreen(0, 0, WINDSIZEX, WINDSIZEY, GL_AUTO_COLOR, buf);

    if (Check(buf) == ERROR) {
	return ERROR;
    }

    return NO_ERROR;
}

long PolyFaceExec(void)
{
    GLfloat *buf;

    buf = (GLfloat *)MALLOC(WINDSIZEX*WINDSIZEY*sizeof(GLfloat));

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    AutoClearColor(COLOR_OFF);
    AutoColor(COLOR_ON);
    glDisable(GL_DITHER);

    if (Test(GL_CCW, buf) == ERROR) {
	FREE(buf);
	return ERROR;
    }
    if (Test(GL_CW, buf) == ERROR) {
	FREE(buf);
	return ERROR;
    }

    FREE(buf);
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\mstack.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** mstack.c
** Matrix Stack Test.
**
** Description -
**    Test the functionality of glPushMatrix() and glPopMatrix()
**    on the three matrix modes (GL_MODELVIEW_MATRIX,
**    GL_PROJECTION_MATRIX and GL_TEXTURE_MATRIX). Each matrix
**    stack is pushed and popped to their maximum depth with
**    unique matrices. Each matrix popped off the stack is
**    checked to verify stack ordering.
**
** Technical Specification -
**    Buffer requirements:
**        No buffer requirements.
**    Color requirements:
**        No color requirements.
**    States requirements:
**        No state restrictions.
**    Error epsilon:
**    Paths:
**       Allowed = Alias, Alpha, Blend, Depth, Dither, Fog, Logicop, Shade,
**                 Stencil, Stipple.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"


static char errStr[320];
static char errStrFmt[] = "Matrix mode is %s.\n%1.1f %1.1f %1.1f %1.1f <-> %1.1f 0.0 0.0 0.0\n%1.1f %1.1f %1.1f %1.1f <-> 0.0 %1.1f 0.0 0.0\n%1.1f %1.1f %1.1f %1.1f <-> 0.0 0.0 %1.1f 0.0\n%1.1f %1.1f %1.1f %1.1f <-> 0.0 0.0 0.0 %1.1f";


static void MakeMatrix(GLfloat value, GLfloat *buf)
{
    long i;

    for (i = 0; i < 16; i++) {
	buf[i] = 0.0;
    }
    for (i = 0; i < 4; i++) {
	buf[i*4+i] = value;
    }
}

static long Compare(GLfloat value, GLfloat *buf)
{
    long i, j;

    for (i = 0; i < 4; i++) {
	for (j = 0; j < 4; j++) {
	    if (i == j) {
		if (buf[i*4+j] != value) {
		    return ERROR;
		}
	    } else {
		if (buf[i*4+j] != 0.0) {
		    return ERROR;
		}
	    }
	}
    }
    return NO_ERROR;
}

static long Test(GLenum mode, GLenum stack, GLfloat max)
{
    char tmp[40];
    GLfloat buf[16], i;

    glMatrixMode(mode);
    GetEnumName(mode, tmp);

    for (i = 1.0; i < max; i += 1.0) {
	MakeMatrix(i, buf);
	glLoadMatrixf(buf);
	glGetFloatv(stack, buf);
	if (Compare(i, buf) == ERROR) {
	    StrMake(errStr, errStrFmt, tmp, buf[0], buf[1], buf[2], buf[3], i,
		    buf[4], buf[5], buf[6], buf[7], i, buf[8], buf[9], buf[10],
		    buf[11], i, buf[12], buf[13], buf[14], buf[15], i);
	    ErrorReport(__FILE__, __LINE__, errStr);
	    return ERROR;
	}
	glPushMatrix();
    }

    glGetFloatv(stack, buf);
    if (Compare(max-1, buf) == ERROR) {
	StrMake(errStr, errStrFmt, tmp, buf[0], buf[1], buf[2], buf[3], max-1,
		buf[4], buf[5], buf[6], buf[7], max-1, buf[8], buf[9], buf[10],
		buf[11], max-1, buf[12], buf[13], buf[14], buf[15], max-1);
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }

    for (i = max-1.0; i >= 1.0; i -= 1.0) {
	glPopMatrix();
	glGetFloatv(stack, buf);
	if (Compare(i, buf) == ERROR) {
	    StrMake(errStr, errStrFmt, tmp, buf[0], buf[1], buf[2], buf[3], i,
		    buf[4], buf[5], buf[6], buf[7], i, buf[8], buf[9], buf[10],
		    buf[11], i, buf[12], buf[13], buf[14], buf[15], i);
	    ErrorReport(__FILE__, __LINE__, errStr);
	    return ERROR;
	}
    }

    return NO_ERROR;
}

long MatrixStackExec(void)
{
    GLfloat max;

    if (machine.pathLevel == 0) {
	glGetFloatv(GL_MAX_MODELVIEW_STACK_DEPTH, &max);
    } else {
	max = 2.0;
    }
    if (Test(GL_MODELVIEW, GL_MODELVIEW_MATRIX, max) == ERROR) {
	return ERROR;
    }

    if (machine.pathLevel == 0) {
	glGetFloatv(GL_MAX_PROJECTION_STACK_DEPTH, &max);
    } else {
	max = 2.0;
    }
    if (Test(GL_PROJECTION, GL_PROJECTION_MATRIX, max) == ERROR) {
	return ERROR;
    }

    if (machine.pathLevel == 0) {
	glGetFloatv(GL_MAX_TEXTURE_STACK_DEPTH, &max);
    } else {
	max = 2.0;
    }
    if (Test(GL_TEXTURE, GL_TEXTURE_MATRIX, max) == ERROR) {
	return ERROR;
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\polystip.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** polystip.c
** Polygon Stipple Test.
**
** Description -
**    Tests polygon stipple, checking if correct fragments are
**    on. To determine which fragments are in the polygon, a
**    reference polygon is drawn with a stipple pattern that has
**    all bits on. The same polygon is drawn with a varied
**    stipple pattern, and each fragment is compared with the
**    reference polygon and the stipple bit for that window
**    coordinate.
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer.
**    Color requirements:
**        RGBA or color index mode. 2 colors.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**        Color epsilon.
**    Paths:
**        Allowed = Alpha, Blend, Depth, Fog, Logicop, Shade, Stencil, Stipple.
**        Not allowed = Alias, Dither.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"


static char errStr[240];
static char errStrFmt[] = "Error at location (%d, %d), stipple postion (%d, %d); expecting stipple bit = %d.";


static long TestBuffer(GLfloat *buf, GLfloat *ref, GLubyte *pattern)
{
    GLubyte c;
    long i, j, b, xStip, yStip, bufIndex;

    ReadScreen(0, 0, WINDSIZEX, WINDSIZEY, GL_AUTO_COLOR, buf);

    for (j = 0; j < WINDSIZEY; j++) {
	for (i = 0; i < WINDSIZEX; i++) {
	    xStip = i % 32;
	    yStip = j % 32;

	    /*
	    ** Locate the character within the pattern corresponding to
	    ** the window position, then find the bit within that character
	    ** and determine if it is on.
	    */

	    c = pattern[(yStip*32+xStip)/8];
	    b = (c & (0x1 << (7 - (xStip % 8)))) ? GL_TRUE : GL_FALSE;

	    bufIndex = j * WINDSIZEX + i;
	    if (GL_TRUE == AutoColorCompare(ref[bufIndex], COLOR_ON)) {
		if (b != AutoColorCompare(buf[bufIndex], COLOR_ON)) {
		    StrMake(errStr, errStrFmt, i, j, xStip, yStip, b);
		    return ERROR;
		}
	    }
	}
    }
    return NO_ERROR;
}

long PolyStippleExec(void)
{
    static GLubyte pattern[128] = {
	0xAA, 0xAA, 0xAA, 0xAA, 0xCC, 0xCC, 0xCC, 0xCC, 0xE3, 0x8E, 0x38, 0xE3, 
	0xF0, 0xF0, 0xF0, 0xF0, 0xF8, 0xE3, 0x0F, 0x8E, 0xFC, 0x0F, 0xC0, 0xFC, 
	0xFE, 0x03, 0xFC, 0x07, 0xFF, 0x00, 0xFf, 0x00, 0xFF, 0x00, 0xFF, 0x00, 
	0xFE, 0x03, 0xFC, 0x07, 0xFC, 0x0F, 0xC0, 0xFC, 0xF8, 0xE3, 0x0F, 0x8E,
	0xF0, 0xF0, 0xF0, 0xF0, 0xE3, 0x8E, 0x38, 0xE3, 0xCC, 0xCC, 0xCC, 0xCC, 
	0xAA, 0xAA, 0xAA, 0xAA, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
	0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0x0F, 0x0F, 0x0F, 0x0F, 
	0x0F, 0x0F, 0x0F, 0x0F, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 
	0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F
    };
    GLfloat *buf, *ref;
    GLubyte fillPattern[128];
    GLfloat x1, y1, z1, w1, x2, y2, z2, w2, x3, y3, z3, w3;
    long i, n = 10;

    buf = (GLfloat *)MALLOC(WINDSIZEX*WINDSIZEY*sizeof(GLfloat));
    ref = (GLfloat *)MALLOC(WINDSIZEX*WINDSIZEY*sizeof(GLfloat));

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    AutoClearColor(COLOR_OFF);
    AutoColor(COLOR_ON);
    glDisable(GL_DITHER);

    for (i = 0; i < 128; i++) {
	fillPattern[i] = 0xFF;
    }
    glEnable(GL_POLYGON_STIPPLE);

    /*
    ** To determine polygon rasterization, first draw an unstippled polygon,
    ** and save the reference polygon. Next, redraw with stippling and check
    ** the stipple pattern only on the fragments also drawn in the reference.
    */
    for (i = 1; i < n; i++) {
	x1 = 5.0 + i;
	y1 = 5.0 + 6.0 * i;
	z1 = Random(0.0, 0.5);
	w1 = Random(0.2, 4.0);

	x2 = 60.0;
	y2 = 5.0;
	z2 = Random(0.0, 0.5);
	w2 = Random(0.2, 4.0);

	x3 = 5.0 + 8.0 * i;
	y3 = 99.0 - 5.0 * i;
	z3 = Random(0.0, 0.5);
	w3 = Random(0.2, 4.0);

	glPolygonStipple(fillPattern);
	glClear(GL_COLOR_BUFFER_BIT);
	glBegin(GL_POLYGON);
	    glVertex4f(x1, y1, z1, w1);
	    glVertex4f(x2, y2, z2, w2);
	    glVertex4f(x3, y3, z3, w3);
	glEnd();

	ReadScreen(0, 0, WINDSIZEX, WINDSIZEY, GL_AUTO_COLOR, ref);

	glPolygonStipple(pattern);
	glClear(GL_COLOR_BUFFER_BIT);
	glBegin(GL_POLYGON);
	    glVertex4f(x1, y1, z1, w1);
	    glVertex4f(x2, y2, z2, w2);
	    glVertex4f(x3, y3, z3, w3);
	glEnd();
	if (TestBuffer(buf, ref, pattern) == ERROR) {
	    ErrorReport(__FILE__, __LINE__, errStr);
	    FREE(buf);
	    FREE(ref);
	    return ERROR;
	}
    }

    FREE(buf);
    FREE(ref);
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\spcorner.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** spcorner.c
** Stencil Plane Corner Test.
**
** Description -
**    The stencil function is set to GL_NEVER, the stencil
**    operation is set to GL_INCR and the stencil plane is
**    cleared to zero. A point is drawn at each corner of the
**    color buffer. Because of the stencil settings, the corners
**    of the stencil plane should be set to one. The stencil
**    plane is read and examined to verify that the corner points
**    are at the correct location.
**
** Error Explanation -
**    Failure occurs if any of the corner points cannot be read
**    correctly (implying that the stencil plane's width and
**    height or the rendering coordinates are not correct).
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer, stencil plane.
**    Color requirements:
**        No color requirements.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**    Paths:
**        Allowed = Alpha, Blend, Depth, Fog, Logicop, Shade, Stipple.
**        Not allowed = Alias, Dither, Stencil.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"


static char errStr[160];
static char errStrFmt[] = "Mismatch at the %s corner.";


long SPCornerExec(void)
{
    GLfloat *buf;

    if (buffer.stencilBits == 0) {
	return NO_ERROR;
    }

    buf = (GLfloat *)MALLOC(WINDSIZEX*WINDSIZEY*sizeof(GLfloat));

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    glEnable(GL_STENCIL_TEST);
    glClearStencil(0);
    glStencilFunc(GL_NEVER, 0, ~0);
    glStencilOp(GL_INCR, GL_KEEP, GL_KEEP);

    glClear(GL_STENCIL_BUFFER_BIT);
    glBegin(GL_POINTS);
	glVertex2f(0.5, 0.5);
	glVertex2f(WINDSIZEX-0.5, 0.5);
	glVertex2f(0.5, WINDSIZEY-0.5);
	glVertex2f(WINDSIZEX-0.5, WINDSIZEY-0.5);
    glEnd();

    ReadScreen(0, 0, WINDSIZEX, WINDSIZEY, GL_STENCIL_INDEX, buf);

    if (buf[0] == 0.0) {
	StrMake(errStr, errStrFmt, "lower left");
	ErrorReport(__FILE__, __LINE__, errStr);
	FREE(buf);
	return ERROR;
    }
    if (buf[WINDSIZEX-1] == 0.0) {
	StrMake(errStr, errStrFmt, "lower right");
	ErrorReport(__FILE__, __LINE__, errStr);
	FREE(buf);
	return ERROR;
    }
    if (buf[WINDSIZEX*(WINDSIZEY-1)] == 0.0) {
	StrMake(errStr, errStrFmt, "upper left");
	ErrorReport(__FILE__, __LINE__, errStr);
	FREE(buf);
	return ERROR;
    }
    if (buf[WINDSIZEX*WINDSIZEY-1] == 0.0) {
	StrMake(errStr, errStrFmt, "upper right");
	ErrorReport(__FILE__, __LINE__, errStr);
	FREE(buf);
	return ERROR;
    }

    FREE(buf);
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\spclear.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** spclear.c
** Stencil Plane Clear Test.
**
** Description -
**    A clear to zero and a clear to one is performed on the
**    stencil plane and verified. If stencil plane is not
**    available, a clear to one should behave as a clear to
**    zero.
**
** Technical Specification -
**    Buffer requirements:
**        Stencil plane.
**    Color requirements:
**        No color requirements.
**    States requirements:
**        No state requirements.
**    Error epsilon:
**    Paths:
**        Allowed = Alias, Alpha, Blend, Depth, Dither, Fog, Logicop,
**                  Shade, Stipple.
**        Not allowed = Stencil.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"


static char errStr[240];
static char errStrFmt[] = "Location (%d, %d). Stencil value is %1.1f, should be %1.1f.";


static Test(GLfloat value, GLfloat *buf)
{
    long i, j, k;

    ReadScreen(0, 0, WINDSIZEX, WINDSIZEY, GL_STENCIL_INDEX, buf);

    if (buffer.stencilBits == 0) {
	if (glGetError() != GL_INVALID_OPERATION) {
	    return ERROR;
	} else {
	    return NO_ERROR;
	}
    }

    for (i = 0; i < WINDSIZEY; i++) {
	for (j = 0; j < WINDSIZEX; j++) {
	    k = i * WINDSIZEX + j;
	    if (ABS(buf[k]-value) > epsilon.zero) {
		StrMake(errStr, errStrFmt, j, i, buf[k], value);
		ErrorReport(__FILE__, __LINE__, errStr);
		return ERROR;
	    }
	}
    }
    return NO_ERROR;
}

long SPClearExec(void)
{
    GLfloat *buf;
    GLint i;

    buf = (GLfloat *)MALLOC(WINDSIZEX*WINDSIZEY*sizeof(GLfloat));

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    glClearStencil(0);
    glClear(GL_STENCIL_BUFFER_BIT);
    if (Test(0.0, buf) == ERROR) {
	FREE(buf);
	return ERROR;
    }

    i = (GLint)POW(2.0, (GLfloat)buffer.stencilBits) - 1;
    glClearStencil(i);
    glClear(GL_STENCIL_BUFFER_BIT);
    if (Test((GLfloat)i, buf) == ERROR) {
	FREE(buf);
	return ERROR;
    }

    FREE(buf);
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\scissor.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** scissor.c
** Scissor Test.
**
** Description -
**    A scissor box is set up with a glScissor() call. A large
**    polygon is then drawn over the box. Only the region defined
**    by the box should render. Scissor boxes of various sizes
**    (including zero width and height) are used to insure
**    completeness of the test.
**
** Error Explanation -
**    Failure occurs if the scissor box does not scissor to the
**    correct size. Special attention is paid along the bottom
**    and right edges.
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer.
**    Color requirements:
**        RGBA or color index mode. 2 colors.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**    Paths:
**        Allowed = Alpha, Blend, Depth, Fog, Logicop, Shade, Stencil, Stipple.
**        Not allowed = Alias, Dither.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"


static char errStr[240];
static char errStrFmt[][160] = {
    "Scissor box with zero width and height did not scissor out polygon.",
    "glScissor(%d, %d, %d, %d) did not scissor correctly along the %s edge.",
    "glScissor(%d, %d, %d, %d) did not scissor correctly within the scissor box.",
};


static long TestClear(GLfloat *buf)
{
    long i;

    ReadScreen(0, 0, WINDSIZEX, WINDSIZEY, GL_AUTO_COLOR, buf);

    for (i = 0; i < WINDSIZEX*WINDSIZEY; i++) {
	if (AutoColorCompare(buf[i], COLOR_OFF) == GL_FALSE) {
	    return ERROR;
	}
    }
    return NO_ERROR;
}

static long Test(GLint x, GLint y, GLsizei sizeX, GLsizei sizeY, GLfloat *buf)
{
    GLfloat *ptr;
    long i, j;

    ReadScreen(x-1, y-1, sizeX+2, sizeY+2, GL_AUTO_COLOR, buf);

    ptr = buf;
    for (i = 0; i < sizeX+2; i++) {
	if (AutoColorCompare(*ptr++, COLOR_OFF) == GL_FALSE) {
	    StrMake(errStr, errStrFmt[1], x, y, sizeX, sizeY, "bottom");
	    ErrorReport(__FILE__, __LINE__, errStr);
	    return ERROR;
	}
    }
    for (i = 0; i < sizeY; i++) {
	if (AutoColorCompare(*ptr++, COLOR_OFF) == GL_FALSE) {
	    StrMake(errStr, errStrFmt[1], x, y, sizeX, sizeY, "left");
	    ErrorReport(__FILE__, __LINE__, errStr);
	    return ERROR;
	}

	for (j = 0; j < sizeX; j++) {
	    if (AutoColorCompare(*ptr++, COLOR_ON) == GL_FALSE) {
		StrMake(errStr, errStrFmt[2], x, y, sizeX, sizeY);
		ErrorReport(__FILE__, __LINE__, errStr);
		return ERROR;
	    }
	}

	if (AutoColorCompare(*ptr++, COLOR_OFF) == GL_FALSE) {
	    StrMake(errStr, errStrFmt[1], x, y, sizeX, sizeY, "right");
	    ErrorReport(__FILE__, __LINE__, errStr);
	    return ERROR;
	}
    }
    for (i = 0; i < sizeX+2; i++) {
	if (AutoColorCompare(*ptr++, COLOR_OFF) == GL_FALSE) {
	    StrMake(errStr, errStrFmt[1], x, y, sizeX, sizeY, "top");
	    ErrorReport(__FILE__, __LINE__, errStr);
	    return ERROR;
	}
    }

    return NO_ERROR;
}

long ScissorExec(void)
{
    GLfloat *buf;
    GLint x, y, max, i;

    buf = (GLfloat *)MALLOC(WINDSIZEX*WINDSIZEY*sizeof(GLfloat));

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    AutoClearColor(COLOR_OFF);
    AutoColor(COLOR_ON);
    glDisable(GL_DITHER);

    glDisable(GL_SCISSOR_TEST);
    glClear(GL_COLOR_BUFFER_BIT);

    x = (GLint)Random(WINDSIZEX/4.0, WINDSIZEX*3.0/4.0);
    y = (GLint)Random(WINDSIZEY/4.0, WINDSIZEY*3.0/4.0);
    glScissor(x, y, 0, 0);
    glEnable(GL_SCISSOR_TEST);
    glBegin(GL_POLYGON);
	glVertex2f(0.0, 0.0);
	glVertex2f(WINDSIZEX, 0.0);
	glVertex2f(WINDSIZEX, WINDSIZEY);
	glVertex2f(0.0, WINDSIZEY);
    glEnd();

    if (TestClear(buf) == ERROR) {
	ErrorReport(__FILE__, __LINE__, errStrFmt[0]);
	FREE(buf);
	return ERROR;
    }

    max = (machine.pathLevel == 0) ? (WINDSIZEX / 8) : 2;
    for (i = 1; i < max; i++) {
	glDisable(GL_SCISSOR_TEST);
	glClear(GL_COLOR_BUFFER_BIT);

	x = (GLint)Random(WINDSIZEX/4.0, WINDSIZEX*3.0/4.0);
	y = (GLint)Random(WINDSIZEY/4.0, WINDSIZEY*3.0/4.0);
	glScissor(x, y, WINDSIZEX/8, i);
	glEnable(GL_SCISSOR_TEST);
	glBegin(GL_POLYGON);
	    glVertex2f(0.0, 0.0);
	    glVertex2f(WINDSIZEX, 0.0);
	    glVertex2f(WINDSIZEX, WINDSIZEY);
	    glVertex2f(0.0, WINDSIZEY);
	glEnd();

        if (Test(x, y, WINDSIZEX/8, i, buf) == ERROR) {
	    FREE(buf);
	    return ERROR;
	}
    }

    max = (machine.pathLevel == 0) ? (WINDSIZEY / 8) : 2;
    for (i = 1; i < max; i++) {
	glDisable(GL_SCISSOR_TEST);
	glClear(GL_COLOR_BUFFER_BIT);

	x = (GLint)Random(WINDSIZEX/4.0, WINDSIZEX*3.0/4.0);
	y = (GLint)Random(WINDSIZEY/4.0, WINDSIZEY*3.0/4.0);
	glScissor(x, y, i, WINDSIZEX/8);
	glEnable(GL_SCISSOR_TEST);
	glBegin(GL_POLYGON);
	    glVertex2f(0.0, 0.0);
	    glVertex2f(WINDSIZEX, 0.0);
	    glVertex2f(WINDSIZEX, WINDSIZEY);
	    glVertex2f(0.0, WINDSIZEY);
	glEnd();

        if (Test(x, y, i, WINDSIZEY/8, buf) == ERROR) {
	    FREE(buf);
	    return ERROR;
	}
    }

    FREE(buf);
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\select.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** select.c
** Selection Test.
**
** Description -
**    A clip volume is set up with a near z value of 10.0 and a
**    far z value of 20.0. A primitive is first rendered outside
**    the selection clip volume (by using a z value of 5.0), then
**    inside the clip volume (by using a z value of 15.0). The
**    number of selection hits returned from glRenderMode() is
**    checked as well as the information in the select buffer.
**    Many different primitives are used to insure thorough
**    testing.
**
** Technical Specification -
**    Buffer requirements:
**        Selection buffer.
**    Color requirements:
**        RGBA or color index mode. 2 colors.
**    States requirements:
**        No state restrictions.
**    Error epsilon:
**    Paths:
**        Allowed = Alias, Alpha, Blend, Depth, Dither, Fog, Logicop, Shade,
**                  Stencil, Stipple.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"


static char errPrim[40];
static char errStr[240];
static char errStrFmt[][160] = {
    "Primitive %s. Did not register correct number of select hits. glRenderMode() returned %d, should be 1.",
    "Primitive %s. Did not record correct number of select names. Select record shows %d, should be 2.",
    "Primitive %s. Did not record correct select name. Select record shows select name number %d to be %d, should be %d.",
};


static void Point(GLint z)
{

    GetEnumName(GL_POINTS, errPrim);
    glBegin(GL_POINTS);
	glVertex3i(WINDSIZEX/2, WINDSIZEY/2, z);
    glEnd();
}

static void Line(GLint z)
{

    GetEnumName(GL_LINES, errPrim);
    glBegin(GL_LINES);
	glVertex3i(WINDSIZEX/3, WINDSIZEY/3, z);
	glVertex3i(WINDSIZEX*2/3, WINDSIZEY*2/3, z);
    glEnd();
}

static void LineStrip(GLint z)
{

    GetEnumName(GL_LINE_STRIP, errPrim);
    glBegin(GL_LINE_STRIP);
	glVertex3i(WINDSIZEX/4, WINDSIZEY/4, z);
	glVertex3i(WINDSIZEX/4, WINDSIZEY*3/4, z);
	glVertex3i(WINDSIZEX*3/4, WINDSIZEY*3/4, z);
	glVertex3i(WINDSIZEX*3/4, WINDSIZEY/4, z);
	glVertex3i(WINDSIZEX/4, WINDSIZEY/4, z);
    glEnd();
}

static void LineLoop(GLint z)
{

    GetEnumName(GL_LINE_LOOP, errPrim);
    glBegin(GL_LINE_LOOP);
	glVertex3i(WINDSIZEX/4, WINDSIZEY/4, z);
	glVertex3i(WINDSIZEX/4, WINDSIZEY*3/4, z);
	glVertex3i(WINDSIZEX*3/4, WINDSIZEY*3/4, z);
	glVertex3i(WINDSIZEX*3/4, WINDSIZEY/4, z);
    glEnd();
}

static void Tri(GLint z)
{

    GetEnumName(GL_TRIANGLES, errPrim);
    glBegin(GL_TRIANGLES);
	glVertex3i(WINDSIZEX/4, WINDSIZEY/4, z);
	glVertex3i(WINDSIZEX/2, WINDSIZEY*3/4, z);
	glVertex3i(WINDSIZEX*3/4, WINDSIZEY/4, z);
    glEnd();
}

static void TriStrip(GLint z)
{

    GetEnumName(GL_TRIANGLE_STRIP, errPrim);
    glBegin(GL_TRIANGLE_STRIP);
	glVertex3i(WINDSIZEX/4, WINDSIZEY/4, z);
	glVertex3i(WINDSIZEX/2, WINDSIZEY*3/4, z);
	glVertex3i(WINDSIZEX/2, WINDSIZEY/4, z);
	glVertex3i(WINDSIZEX*3/4, WINDSIZEY*3/4, z);
    glEnd();
}

static void TriFan(GLint z)
{

    GetEnumName(GL_TRIANGLE_FAN, errPrim);
    glBegin(GL_TRIANGLE_FAN);
	glVertex3i(WINDSIZEX/4, WINDSIZEY/4, z);
	glVertex3i(WINDSIZEX*3/4, WINDSIZEY/4, z);
	glVertex3i(WINDSIZEX*3/4, WINDSIZEY*3/4, z);
	glVertex3i(WINDSIZEX/4, WINDSIZEY*3/4, z);
    glEnd();
}

static void Quad(GLint z)
{

    GetEnumName(GL_QUADS, errPrim);
    glBegin(GL_QUADS);
	glVertex3i(WINDSIZEX/4, WINDSIZEY/4, z);
	glVertex3i(WINDSIZEX/2, WINDSIZEY*3/4, z);
	glVertex3i(WINDSIZEX*3/4, WINDSIZEY*3/4, z);
	glVertex3i(WINDSIZEX/2, WINDSIZEY/4, z);
    glEnd();
}

static void QuadStrip(GLint z)
{

    GetEnumName(GL_QUAD_STRIP, errPrim);
    glBegin(GL_QUAD_STRIP);
	glVertex3i(WINDSIZEX/5, WINDSIZEY/4, z);
	glVertex3i(WINDSIZEX*2/5, WINDSIZEY*3/4, z);
	glVertex3i(WINDSIZEX*2/5, WINDSIZEY/4, z);
	glVertex3i(WINDSIZEX*3/5, WINDSIZEY*3/4, z);
	glVertex3i(WINDSIZEX*3/5, WINDSIZEY/4, z);
	glVertex3i(WINDSIZEX*4/5, WINDSIZEY*3/4, z);
    glEnd();
}

static void PolyPoint(GLint z)
{

    STRCOPY(errPrim, "Polygons (point mode)");
    glPolygonMode(GL_FRONT_AND_BACK, GL_POINT);
    glBegin(GL_POLYGON);
	glVertex3i(WINDSIZEX/4, WINDSIZEY*2/5, z);
	glVertex3i(WINDSIZEX/4, WINDSIZEY*3/5, z);
	glVertex3i(WINDSIZEX/2, WINDSIZEY*4/5, z);
	glVertex3i(WINDSIZEX*3/4, WINDSIZEY*3/5, z);
	glVertex3i(WINDSIZEX*3/4, WINDSIZEY*2/5, z);
	glVertex3i(WINDSIZEX/2, WINDSIZEY/5, z);
    glEnd();
}

static void PolyLine(GLint z)
{

    STRCOPY(errPrim, "Polygons (line mode)");
    glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
    glBegin(GL_POLYGON);
	glVertex3i(WINDSIZEX/4, WINDSIZEY*2/5, z);
	glVertex3i(WINDSIZEX/4, WINDSIZEY*3/5, z);
	glVertex3i(WINDSIZEX/2, WINDSIZEY*4/5, z);
	glVertex3i(WINDSIZEX*3/4, WINDSIZEY*3/5, z);
	glVertex3i(WINDSIZEX*3/4, WINDSIZEY*2/5, z);
	glVertex3i(WINDSIZEX/2, WINDSIZEY/5, z);
    glEnd();
}

static void PolyFill(GLint z)
{

    STRCOPY(errPrim, "Polygons (fill mode)");
    glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
    glBegin(GL_POLYGON);
	glVertex3i(WINDSIZEX/4, WINDSIZEY*2/5, z);
	glVertex3i(WINDSIZEX/4, WINDSIZEY*3/5, z);
	glVertex3i(WINDSIZEX/2, WINDSIZEY*4/5, z);
	glVertex3i(WINDSIZEX*3/4, WINDSIZEY*3/5, z);
	glVertex3i(WINDSIZEX*3/4, WINDSIZEY*2/5, z);
	glVertex3i(WINDSIZEX/2, WINDSIZEY/5, z);
    glEnd();
}

static void RasterPos(GLint z)
{

    STRCOPY(errPrim, "Raster position");
    glRasterPos3i(WINDSIZEX/2, WINDSIZEY/2, z);
}

static long Test(void (*Func)(GLint), GLuint *buf)
{
    static GLuint name[3] = {
	1, 2, 3
    };
    GLint i;

    i = glRenderMode(GL_SELECT);

    glInitNames();

    /*
    ** Should not hit select.
    */
    glPushName(name[0]);
    (*Func)(5);

    /*
    ** Should hit select.
    */
    glPushName(name[1]);
    glLoadName(name[2]);
    (*Func)(15);

    glPopName();
    glPopName();

    i = glRenderMode(GL_RENDER);

    if (i != 1) {
	StrMake(errStr, errStrFmt[0], errPrim, i);
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    } else {
	if (buf[0] != 2) {
	    StrMake(errStr, errStrFmt[1], errPrim, buf[0]);
	    ErrorReport(__FILE__, __LINE__, errStr);
	    return ERROR;
	}
	if (buf[3] != name[0]) {
	    StrMake(errStr, errStrFmt[2], errPrim, 1, buf[3], name[0]);
	    ErrorReport(__FILE__, __LINE__, errStr);
	    return ERROR;
	}
	if (buf[4] != name[2]) {
	    StrMake(errStr, errStrFmt[2], errPrim, 2, buf[4], name[2]);
	    ErrorReport(__FILE__, __LINE__, errStr);
	    return ERROR;
	}
    }

    return NO_ERROR;
}

long SelectExec(void)
{
    GLuint *buf;

    buf = (GLuint *)MALLOC(100*sizeof(GLuint));

    Ortho3D(0, WINDSIZEX, 0, WINDSIZEY, -10, -20);
    SETCOLOR(COLOR_ON);
    glDisable(GL_DITHER);

    glSelectBuffer(100, buf);

    if (Test(Point, buf) == ERROR) {
	FREE(buf);
	return ERROR;
    }
    if (Test(Line, buf) == ERROR) {
	FREE(buf);
	return ERROR;
    }
    if (Test(LineStrip, buf) == ERROR) {
	FREE(buf);
	return ERROR;
    }
    if (Test(LineLoop, buf) == ERROR) {
	FREE(buf);
	return ERROR;
    }
    if (Test(Tri, buf) == ERROR) {
	FREE(buf);
	return ERROR;
    }
    if (Test(TriStrip, buf) == ERROR) {
	FREE(buf);
	return ERROR;
    }
    if (Test(TriFan, buf) == ERROR) {
	FREE(buf);
	return ERROR;
    }
    if (Test(Quad, buf) == ERROR) {
	FREE(buf);
	return ERROR;
    }
    if (Test(QuadStrip, buf) == ERROR) {
	FREE(buf);
	return ERROR;
    }
    if (Test(PolyPoint, buf) == ERROR) {
	FREE(buf);
	return ERROR;
    }
    if (Test(PolyLine, buf) == ERROR) {
	FREE(buf);
	return ERROR;
    }
    if (Test(PolyFill, buf) == ERROR) {
	FREE(buf);
	return ERROR;
    }
    if (Test(RasterPos, buf) == ERROR) {
	FREE(buf);
	return ERROR;
    }

    FREE(buf);
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\spfunc.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** spfunc.c
** Stencil Plane Function Test.
**
** Description -
**    Each stencil function is tested by clearing the stencil
**    buffer to 1, drawing three points with different stencil
**    values (the first point has a stencil value of 0, the
**    second point has a stencil value of 1 and the third point
**    has stencil value of 2) and comparing the rendered result
**    to the expected result.
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer, stencil plane.
**    Color requirements:
**        RGBA or color index mode. 2 colors.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**    Paths:
**        Allowed = Alpha, Blend, Depth, Fog, Logicop, Shade, Stipple.
**        Not allowed = Alias, Dither, Stencil.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"


static long errPattern[3];
static char errStr[320];
static char errStrFmt[] = "The behavior of the stencil function %s is not correct. The stencil value of the test points are 0, 1, 2. The reference stencil value is 1. The test points pattern is %s, %s, %s, should be %s.\n";


static void ClearDrawRead(GLenum func, GLfloat *buf)
{
    GLint i;

    glClear(GL_STENCIL_BUFFER_BIT|GL_COLOR_BUFFER_BIT);

    for (i = 0; i < 3; i++) {
	glStencilFunc(func, i, ~0);
	glBegin(GL_POINTS);
	    glVertex2f((GLfloat)i+0.5, 0.5);
	glEnd();
    }

    ReadScreen(0, 0, 3, 1, GL_AUTO_COLOR, buf);
}

static long Test(long a, long b, long c, GLfloat *buf)
{
    long i;

    for (i = 0; i < 3; i++) {
	if (AutoColorCompare(buf[i], COLOR_OFF) == GL_TRUE) {  /* no color. */
	    errPattern[i] = GL_FALSE;
	} else {                                               /* color. */
	    errPattern[i] = GL_TRUE;
	}
    }

    if (a == GL_TRUE) {     /* should have color. */
	if (AutoColorCompare(buf[0], COLOR_OFF) == GL_TRUE) {  /* no color. */
	    return ERROR;
	}
    } else {             /* should not have color. */
	if (AutoColorCompare(buf[0], COLOR_ON) == GL_TRUE) {   /* color. */
	    return ERROR;
	}
    }

    if (b == GL_TRUE) {     /* should have color. */
	if (AutoColorCompare(buf[1], COLOR_OFF) == GL_TRUE) {  /* no color. */
	    return ERROR;
	}
    } else {             /* should not have color. */
	if (AutoColorCompare(buf[1], COLOR_ON) == GL_TRUE) {   /* color. */
	    return ERROR;
	}
    }

    if (c == GL_TRUE) {     /* should have color. */
	if (AutoColorCompare(buf[2], COLOR_OFF) == GL_TRUE) {  /* no color. */
	    return ERROR;
	}
    } else {             /* should not have color. */
	if (AutoColorCompare(buf[2], COLOR_ON) == GL_TRUE) {   /* color. */
	    return ERROR;
	}
    }

    return NO_ERROR;
}

static void MakeErrorStr(char *funcName, char *result)
{

    StrMake(errStr, errStrFmt, funcName,
	    (errPattern[0] == GL_TRUE) ? "DRAWN" : "NOT-DRAWN",
	    (errPattern[1] == GL_TRUE) ? "DRAWN" : "NOT-DRAWN",
	    (errPattern[2] == GL_TRUE) ? "DRAWN" : "NOT-DRAWN", result);
}

long SPFuncExec(void)
{
    GLfloat buf[3];

    if (buffer.stencilBits < 2) {
	return NO_ERROR;
    }

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    AutoClearColor(COLOR_OFF);
    AutoColor(COLOR_ON);

    glDisable(GL_DITHER);
    glEnable(GL_STENCIL_TEST);
    glClearStencil(1);
    glStencilOp(GL_KEEP, GL_KEEP, GL_KEEP);

    ClearDrawRead(GL_ALWAYS, buf);
    if (Test(GL_TRUE, GL_TRUE, GL_TRUE, buf) == ERROR) {
	MakeErrorStr("GL_ALWAYS", "DRAWN, DRAWN, DRAWN");
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }
   
    ClearDrawRead(GL_NEVER, buf);
    if (buffer.stencilBits == 0) {
	if (Test(GL_TRUE, GL_TRUE, GL_TRUE, buf) == ERROR) {
	    MakeErrorStr("GL_NEVER", "NOT-DRAWN, NOT-DRAWN, NOT-DRAWN");
	    ErrorReport(__FILE__, __LINE__, errStr);
	    return ERROR;
	}
	return NO_ERROR;
    } else {
	if (Test(GL_FALSE, GL_FALSE, GL_FALSE, buf) == ERROR) {
	    MakeErrorStr("GL_NEVER", "DRAWN, DRAWN, DRAWN");
	    ErrorReport(__FILE__, __LINE__, errStr);
	    return ERROR;
	}
    }

    ClearDrawRead(GL_LESS, buf);
    if (Test(GL_TRUE, GL_FALSE, GL_FALSE, buf) == ERROR) {
	MakeErrorStr("GL_LESS", "DRAWN, NOT-DRAWN, NOT-DRAWN");
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }

    ClearDrawRead(GL_LEQUAL, buf);
    if (Test(GL_TRUE, GL_TRUE, GL_FALSE, buf) == ERROR) {
	MakeErrorStr("GL_LEQUAL", "DRAWN, DRAWN, NOT-DRAWN");
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }

    ClearDrawRead(GL_GREATER, buf);
    if (Test(GL_FALSE, GL_FALSE, GL_TRUE, buf) == ERROR) {
	MakeErrorStr("GL_GREATER", "NOT-DRAWN, NOT-DRAWN, DRAWN");
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }

    ClearDrawRead(GL_GEQUAL, buf);
    if (Test(GL_FALSE, GL_TRUE, GL_TRUE, buf) == ERROR) {
	MakeErrorStr("GL_GEQUAL", "NOT-DRAWN, DRAWN, DRAWN");
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }

    ClearDrawRead(GL_EQUAL, buf);
    if (Test(GL_FALSE, GL_TRUE, GL_FALSE, buf) == ERROR) {
	MakeErrorStr("GL_EQUAL", "NOT-DRAWN, DRAWN, NOT-DRAWN");
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }

    ClearDrawRead(GL_NOTEQUAL, buf);
    if (Test(GL_TRUE, GL_FALSE, GL_TRUE, buf) == ERROR) {
	MakeErrorStr("GL_NOTEQUAL", "DRAWN, NOT-DRAWN, DRAWN");
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\spop.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** spop.c
** Stencil Plane Operation Test.
**
** Description -
**    Tests the conformance of glStencilOp(). Each stencil
**    operation (GL_KEEP, GL_REPLACE, GL_ZERO, GL_INCR, GL_DECR,
**    GL_INVERT) is tested by initializing the stencil plane to a
**    known value, performing the stencil operation (by setting
**    up the stencil and depth functions and rendering a point)
**    and comparing the stencil plane result to an expected
**    value. The sfail operation is tested by setting the
**    stencil function to GL_NEVER. The dpfail operation is
**    tested by setting the stencil function to GL_ALWAYS and the
**    depth function to GL_NEVER. The dppass operation is tested
**    by setting both the stencil function and depth function to
**    GL_ALWAYS.
**
** Technical Specification -
**    Buffer requirements:
**        Stencil plane.
**    Color requirements:
**        No color requirements.
**    States requirements:
**        No state requirements.
**    Error epsilon:
**    Paths:
**        Allowed = Alias, Alpha, Blend, Depth, Dither, Fog, Logicop,
**                  Shade, Stipple.
**        Not allowed = Stencil.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"


static char errStr[160];
static char errStrFmt[] = "glStencilOp(%s). Stencil value is %d, should be %d.";


static GLuint Setup(GLenum func, GLenum op)
{
    GLuint minValue, maxValue, refValue, testValue, value=0;

    minValue = 0;
    maxValue = (1 << buffer.stencilBits) - 1;

    refValue = minValue + 1;
    testValue = maxValue - 1;

    glStencilFunc(func, refValue, ~0);
    glClearStencil(testValue);

    switch (op) {
      case GL_KEEP:
	value = testValue;
	break;
      case GL_ZERO:
	value = minValue;
	break;
      case GL_REPLACE:
	value = refValue;
	break;
      case GL_INCR:
	value = testValue + 1;
	break;
      case GL_DECR:
	value = (testValue >= 1) ? (testValue - 1) : 0;
	break;
      case GL_INVERT:
	value = ~testValue;
	break;
    }

    value &= maxValue;

    if (value < minValue) {
	value = minValue;
    } else if (value > maxValue) {
	value = maxValue;
    }

    return value;
}

static GLuint Test(GLenum op1, GLenum op2, GLenum op3)
{
    GLfloat buf;
    GLint x, y;

    glClear(GL_STENCIL_BUFFER_BIT);
    glStencilOp(op1, op2, op3);
    glBegin(GL_POINTS);
	x = (GLint)Random(0.0, WINDSIZEX-1.0);
	y = (GLint)Random(0.0, WINDSIZEY-1.0);
	glVertex2f((GLfloat)x+0.5, (GLfloat)y+0.5);
    glEnd();

    ReadScreen(x, y, 1, 1, GL_STENCIL_INDEX, &buf);
    return (GLuint)buf;
}

long SPOpExec(void)
{
    GLuint value, trueValue;

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    glEnable(GL_STENCIL_TEST);

    trueValue = Setup(GL_NEVER, GL_KEEP);
    if (buffer.stencilBits == 0) {
	return NO_ERROR;
    }

    value = Test(GL_KEEP, GL_KEEP, GL_KEEP);
    if (value != trueValue) {
        StrMake(errStr, errStrFmt, "GL_KEEP, GL_KEEP, GL_KEEP", value,
		trueValue);
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }
    trueValue = Setup(GL_NEVER, GL_ZERO);
    value = Test(GL_ZERO, GL_KEEP, GL_KEEP);
    if (value != trueValue) {
        StrMake(errStr, errStrFmt, "GL_ZERO, GL_KEEP, GL_KEEP", value,
		trueValue);
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }
    trueValue = Setup(GL_NEVER, GL_REPLACE);
    value = Test(GL_REPLACE, GL_KEEP, GL_KEEP);
    if (value != trueValue) {
        StrMake(errStr, errStrFmt, "GL_REPLACE, GL_KEEP, GL_KEEP", value,
		trueValue);
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }
    trueValue = Setup(GL_NEVER, GL_INCR);
    value = Test(GL_INCR, GL_KEEP, GL_KEEP);
    if (value != trueValue) {
        StrMake(errStr, errStrFmt, "GL_INCR, GL_KEEP, GL_KEEP", value,
		trueValue);
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }
    trueValue = Setup(GL_NEVER, GL_DECR);
    value = Test(GL_DECR, GL_KEEP, GL_KEEP);
    if (value != trueValue) {
        StrMake(errStr, errStrFmt, "GL_DECR, GL_KEEP, GL_KEEP", value,
		trueValue);
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }
    trueValue = Setup(GL_NEVER, GL_INVERT);
    value = Test(GL_INVERT, GL_KEEP, GL_KEEP);
    if (value != trueValue) {
        StrMake(errStr, errStrFmt, "GL_INVERT, GL_KEEP, GL_KEEP", value,
		trueValue);
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }

    glEnable(GL_DEPTH_TEST);

    glDepthFunc(GL_NEVER);

//
//!!!XXX -- This is a conformance fix that is awaiting approval by the ARB.
//
#define _CONFORMANCE_FIX_
#ifdef _CONFORMANCE_FIX_
    if (buffer.zBits) {
#endif
        trueValue = Setup(GL_ALWAYS, GL_KEEP);
        value = Test(GL_KEEP, GL_KEEP, GL_KEEP);
        if (value != trueValue) {
            StrMake(errStr, errStrFmt, "GL_KEEP, GL_KEEP, GL_KEEP", value,
                    trueValue);
            ErrorReport(__FILE__, __LINE__, errStr);
            return ERROR;
        }
        trueValue = Setup(GL_ALWAYS, GL_ZERO);
        value = Test(GL_KEEP, GL_ZERO, GL_KEEP);
        if (value != trueValue) {
            StrMake(errStr, errStrFmt, "GL_KEEP, GL_ZERO, GL_KEEP", value,
                    trueValue);
            ErrorReport(__FILE__, __LINE__, errStr);
            return ERROR;
        }
        trueValue = Setup(GL_ALWAYS, GL_REPLACE);
        value = Test(GL_KEEP, GL_REPLACE, GL_KEEP);
        if (value != trueValue) {
            StrMake(errStr, errStrFmt, "GL_KEEP, GL_REPLACE, GL_KEEP", value,
                    trueValue);
            ErrorReport(__FILE__, __LINE__, errStr);
            return ERROR;
        }
        trueValue = Setup(GL_ALWAYS, GL_INCR);
        value = Test(GL_KEEP, GL_INCR, GL_KEEP);
        if (value != trueValue) {
            StrMake(errStr, errStrFmt, "GL_KEEP, GL_INCR, GL_KEEP", value,
                    trueValue);
            ErrorReport(__FILE__, __LINE__, errStr);
            return ERROR;
        }
        trueValue = Setup(GL_ALWAYS, GL_DECR);
        value = Test(GL_KEEP, GL_DECR, GL_KEEP);
        if (value != trueValue) {
            StrMake(errStr, errStrFmt, "GL_KEEP, GL_DECR, GL_KEEP", value,
                    trueValue);
            ErrorReport(__FILE__, __LINE__, errStr);
            return ERROR;
        }
        trueValue = Setup(GL_ALWAYS, GL_INVERT);
        value = Test(GL_KEEP, GL_INVERT, GL_KEEP);
        if (value != trueValue) {
            StrMake(errStr, errStrFmt, "GL_KEEP, GL_INVERT, GL_KEEP", value,
                    trueValue);
            ErrorReport(__FILE__, __LINE__, errStr);
            return ERROR;
        }
#ifdef _CONFORMANCE_FIX_
    }
    //
    //!!!XXX -- It is not clear how the ARB will vote to fix the
    //!!!XXX    test.  We can choose run the test but use GL_ALWAYS
    //!!!XXX    results.  But some might regard that as redundant
    //!!!XXX    so we could simply disable it if there is no zbuf.
    //!!!XXX    Chris Frazier @ SGI thinks it could go either way,
    //!!!XXX    so lets be conservative and run the test.
    //
    #define _RUN_FOR_EXTRA_INSURANCE_
    #ifdef _RUN_FOR_EXTRA_INSURANCE_
    else {
        trueValue = Setup(GL_ALWAYS, GL_KEEP);
        value = Test(GL_KEEP, GL_KEEP, GL_KEEP);
        if (value != trueValue) {
            StrMake(errStr, errStrFmt, "GL_KEEP, GL_KEEP, GL_KEEP", value,
                    trueValue);
            ErrorReport(__FILE__, __LINE__, errStr);
            return ERROR;
        }
        trueValue = Setup(GL_ALWAYS, GL_ZERO);
        value = Test(GL_KEEP, GL_KEEP, GL_ZERO);
        if (value != trueValue) {
            StrMake(errStr, errStrFmt, "GL_KEEP, GL_KEEP, GL_ZERO", value,
                    trueValue);
            ErrorReport(__FILE__, __LINE__, errStr);
            return ERROR;
        }
        trueValue = Setup(GL_ALWAYS, GL_REPLACE);
        value = Test(GL_KEEP, GL_KEEP, GL_REPLACE);
        if (value != trueValue) {
            StrMake(errStr, errStrFmt, "GL_KEEP, GL_KEEP, GL_REPLACE", value,
                    trueValue);
            ErrorReport(__FILE__, __LINE__, errStr);
            return ERROR;
        }
        trueValue = Setup(GL_ALWAYS, GL_INCR);
        value = Test(GL_KEEP, GL_KEEP, GL_INCR);
        if (value != trueValue) {
            StrMake(errStr, errStrFmt, "GL_KEEP, GL_KEEP, GL_INCR", value,
                    trueValue);
            ErrorReport(__FILE__, __LINE__, errStr);
            return ERROR;
        }
        trueValue = Setup(GL_ALWAYS, GL_DECR);
        value = Test(GL_KEEP, GL_KEEP, GL_DECR);
        if (value != trueValue) {
            StrMake(errStr, errStrFmt, "GL_KEEP, GL_KEEP, GL_DECR", value,
                    trueValue);
            ErrorReport(__FILE__, __LINE__, errStr);
            return ERROR;
        }
        trueValue = Setup(GL_ALWAYS, GL_INVERT);
        value = Test(GL_KEEP, GL_KEEP, GL_INVERT);
        if (value != trueValue) {
            StrMake(errStr, errStrFmt, "GL_KEEP, GL_KEEP, GL_INVERT", value,
                    trueValue);
            ErrorReport(__FILE__, __LINE__, errStr);
            return ERROR;
        }
    }
    #endif
#endif

    glDepthFunc(GL_ALWAYS);

    trueValue = Setup(GL_ALWAYS, GL_KEEP);
    value = Test(GL_KEEP, GL_KEEP, GL_KEEP);
    if (value != trueValue) {
        StrMake(errStr, errStrFmt, "GL_KEEP, GL_KEEP, GL_KEEP", value,
		trueValue);
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }
    trueValue = Setup(GL_ALWAYS, GL_ZERO);
    value = Test(GL_KEEP, GL_KEEP, GL_ZERO);
    if (value != trueValue) {
        StrMake(errStr, errStrFmt, "GL_KEEP, GL_KEEP, GL_ZERO", value,
		trueValue);
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }
    trueValue = Setup(GL_ALWAYS, GL_REPLACE);
    value = Test(GL_KEEP, GL_KEEP, GL_REPLACE);
    if (value != trueValue) {
        StrMake(errStr, errStrFmt, "GL_KEEP, GL_KEEP, GL_REPLACE", value,
		trueValue);
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }
    trueValue = Setup(GL_ALWAYS, GL_INCR);
    value = Test(GL_KEEP, GL_KEEP, GL_INCR);
    if (value != trueValue) {
        StrMake(errStr, errStrFmt, "GL_KEEP, GL_KEEP, GL_INCR", value,
		trueValue);
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }
    trueValue = Setup(GL_ALWAYS, GL_DECR);
    value = Test(GL_KEEP, GL_KEEP, GL_DECR);
    if (value != trueValue) {
        StrMake(errStr, errStrFmt, "GL_KEEP, GL_KEEP, GL_DECR", value,
		trueValue);
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }
    trueValue = Setup(GL_ALWAYS, GL_INVERT);
    value = Test(GL_KEEP, GL_KEEP, GL_INVERT);
    if (value != trueValue) {
        StrMake(errStr, errStrFmt, "GL_KEEP, GL_KEEP, GL_INVERT", value,
		trueValue);
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\tests.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <GL/gl.h>
#include "path.h"
#include "tproto.h"
#include "driver.h"


driverRec driver[] = {

    /*
    ** Required.
    */
    {
	"Must Pass", "mustpass.c", 0,
	MustPassExec, MustPassExec,
	COLOR_NONE,
	PATH_NONE
    },

    /*
    ** General.
    */
    {
	"Divide By Zero", "divzero.c", 1,
	DivZeroExec, DivZeroExec,
	COLOR_NONE,
	PATH_ALIAS|PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_DITHER|PATH_FOG|
	PATH_LOGICOP|PATH_SHADE|PATH_STENCIL|PATH_STIPPLE
    },
    {
	"Viewport Clamp", "vpclamp.c", 2,
	ViewportClampExec, ViewportClampExec,
	COLOR_NONE,
	PATH_ALIAS|PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_DITHER|PATH_FOG|
	PATH_LOGICOP|PATH_SHADE|PATH_STENCIL|PATH_STIPPLE
    },
    {
	"Matrix Stack", "mstack.c", 3,
	MatrixStackExec, MatrixStackExec,
	COLOR_NONE,
	PATH_ALIAS|PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_DITHER|PATH_FOG|
	PATH_LOGICOP|PATH_SHADE|PATH_STENCIL|PATH_STIPPLE
    },
    {
	"Matrix Stack Mixing", "xformmix.c", 4,
	XFormMixExec, XFormMixExec,
	COLOR_AUTO,
	PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_FOG|PATH_LOGICOP|PATH_SHADE|
	PATH_STENCIL|PATH_STIPPLE
    },
    {
	"Vertex Order", "vorder.c", 5,
	VertexOrderExec, VertexOrderExec,
	COLOR_MIN,
	PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_FOG|PATH_LOGICOP|PATH_SHADE|
	PATH_STENCIL|PATH_STIPPLE
    },

    /*
    ** Transform.
    */
    {
	"Transformations", "xform.c", 6,
	XFormExec, XFormExec,
	COLOR_AUTO,
	PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_FOG|PATH_LOGICOP|PATH_SHADE|
	PATH_STENCIL|PATH_STIPPLE
    },
    {
	"Transformation Normal", "xformn.c", 7,
	XFormNormalExec, XFormNormalExec,
	COLOR_FULL,
	PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_LOGICOP|PATH_STENCIL|PATH_STIPPLE
    },
    {
	"Viewport Transformation", "xformvp.c", 8,
	XFormViewportExec, XFormViewportExec,
	COLOR_AUTO,
	PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_FOG|PATH_LOGICOP|PATH_SHADE|
	PATH_STENCIL|PATH_STIPPLE
    },

    /*
    ** Buffer.
    */
    {
	"Buffer Clear", "bclear.c", 9,
	BClearExec, BClearExec,
	COLOR_FULL,
	PATH_ALIAS|PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_DITHER|PATH_FOG|
	PATH_LOGICOP|PATH_SHADE|PATH_STENCIL|PATH_STIPPLE
    },
    {
	"Buffer Corners", "bcorner.c", 10,
	BCornerExec, BCornerExec,
	COLOR_AUTO,
	PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_FOG|PATH_LOGICOP|PATH_SHADE|
	PATH_STENCIL|PATH_STIPPLE
    },
    {
	"Buffer Color", "bcolor.c", 11,
	BColorRGBExec, BColorCIExec,
	COLOR_FULL,
	PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_FOG|PATH_LOGICOP|PATH_SHADE|
	PATH_STENCIL|PATH_STIPPLE
    },
    {
	"Color Ramp", "colramp.c", 12,
	ColRampExec, NO_TEST,
	COLOR_FULL,
	PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_FOG|PATH_LOGICOP|PATH_SHADE|
	PATH_STENCIL|PATH_STIPPLE
    },
    {
	"Mask", "mask.c", 13,
	MaskRGBExec, MaskCIExec,
	COLOR_MIN,
	PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_FOG|PATH_LOGICOP|PATH_SHADE|
	PATH_STENCIL|PATH_STIPPLE
    },
    {
	"Buffer Invariance", "bexact.c", 14,
	BExactExec, BExactExec,
	COLOR_FULL,
	PATH_ALIAS|PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_DITHER|PATH_FOG|
	PATH_LOGICOP|PATH_SHADE|PATH_STENCIL|PATH_STIPPLE
    },
    {
	"Accumulation Buffer", "accum.c", 15,
	AccumExec, NO_TEST,
	COLOR_FULL,
	PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_FOG|PATH_LOGICOP|PATH_SHADE|
	PATH_STENCIL|PATH_STIPPLE
    },
    {
	"Select", "select.c", 16,
	SelectExec, SelectExec, 
	COLOR_AUTO,
	PATH_ALIAS|PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_DITHER|PATH_FOG|
	PATH_LOGICOP|PATH_SHADE|PATH_STENCIL|PATH_STIPPLE
    },
    {
	"Feedback", "feedback.c", 17,
	FeedbackExec, FeedbackExec, 
	COLOR_AUTO,
	PATH_ALIAS|PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_DITHER|PATH_FOG|
	PATH_LOGICOP|PATH_SHADE|PATH_STENCIL|PATH_STIPPLE
    },

    /*
    ** Per-pixel.
    */
    {
	"Scissor", "scissor.c", 18,
	ScissorExec, ScissorExec,
	COLOR_AUTO,
	PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_FOG|PATH_LOGICOP|PATH_SHADE|
	PATH_STENCIL|PATH_STIPPLE
    },
    {
	"Alpha Plane Function", "apfunc.c", 19,
	APFuncExec, NO_TEST,
	COLOR_FULL,
	PATH_BLEND|PATH_DEPTH|PATH_FOG|PATH_LOGICOP|PATH_SHADE|PATH_STENCIL|
	PATH_STIPPLE
    },
    {
	"Stencil Plane Clear", "spclear.c", 20,
	SPClearExec, SPClearExec,
	COLOR_NONE,
	PATH_ALIAS|PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_DITHER|PATH_FOG|
	PATH_LOGICOP|PATH_SHADE|PATH_STIPPLE
    },
    {
	"Stencil Plane Corners", "spcorner.c", 21,
	SPCornerExec, SPCornerExec,
	COLOR_NONE,
	PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_FOG|PATH_LOGICOP|PATH_SHADE|
	PATH_STIPPLE
    },
    {
	"Stencil Plane Operation", "spop.c", 22,
	SPOpExec, SPOpExec,
	COLOR_NONE,
	PATH_ALIAS|PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_DITHER|PATH_FOG|
	PATH_LOGICOP|PATH_SHADE|PATH_STIPPLE
    },
    {
	"Stencil Plane Function", "spfunc.c", 23,
	SPFuncExec, SPFuncExec,
	COLOR_AUTO,
	PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_FOG|PATH_LOGICOP|PATH_SHADE|
	PATH_STIPPLE
    },
    {
	"Depth Buffer Clear", "zbclear.c", 24,
	ZBClearExec, ZBClearExec,
	COLOR_NONE,
	PATH_ALIAS|PATH_ALPHA|PATH_BLEND|PATH_DITHER|PATH_FOG|PATH_LOGICOP|
	PATH_SHADE|PATH_STENCIL|PATH_STIPPLE
    },
    {
	"Depth Buffer Function", "zbfunc.c", 25,
	ZBFuncExec, ZBFuncExec,
	COLOR_AUTO,
	PATH_ALPHA|PATH_BLEND|PATH_FOG|PATH_LOGICOP|PATH_SHADE|PATH_STENCIL|
	PATH_STIPPLE
    },
    {
	"Blend", "blend.c", 26,
	BlendExec, NO_TEST,
	COLOR_FULL,
	PATH_ALPHA|PATH_DEPTH|PATH_FOG|PATH_LOGICOP|PATH_SHADE|PATH_STENCIL|
	PATH_STIPPLE
    },
    {
	"Dither", "dither.c", 27,
	DitherRGBExec, DitherCIExec,
	COLOR_MIN,
	PATH_ALIAS|PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_DITHER|PATH_FOG|
	PATH_LOGICOP|PATH_SHADE|PATH_STENCIL|PATH_STIPPLE
    },
    {
	"LogicOp Function", "logicop.c", 28,
	NO_TEST, LogicOpExec,
	COLOR_FULL,
	PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_FOG|PATH_SHADE|PATH_STENCIL|
	PATH_STIPPLE
    },

    /*
    ** Pixel operation.
    */
    {
	"DrawPixels", "drawpix.c", 29,
	DrawPixelsRGBExec, DrawPixelsCIExec,
	COLOR_FULL,
	PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_FOG|PATH_LOGICOP|PATH_SHADE|
	PATH_STENCIL|PATH_STIPPLE
    },
    {
	"CopyPixels", "copypix.c", 30,
	CopyPixelsExec, CopyPixelsExec,
	COLOR_MIN,
	PATH_ALPHA|PATH_BLEND|PATH_FOG|PATH_LOGICOP|PATH_SHADE|PATH_STIPPLE
    },

    /*
    ** Primitive.
    */
    {
	"Bitmap Rasterization", "bitmap.c", 31,
	BitmapExec, BitmapExec,
	COLOR_AUTO,
	PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_FOG|PATH_LOGICOP|PATH_SHADE|
	PATH_STENCIL|PATH_STIPPLE
    },
    {
	"Point Rasterization", "pntrast.c", 32,
	PointRasterExec, PointRasterExec,
	COLOR_AUTO,
	PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_FOG|PATH_LOGICOP|PATH_SHADE|
	PATH_STENCIL|PATH_STIPPLE
    },
    {
	"Anti-aliased Point", "pntaa.c", 33,
	PointAntiAliasExec, NO_TEST,
	COLOR_FULL,
	PATH_DEPTH|PATH_FOG|PATH_LOGICOP|PATH_SHADE|PATH_STENCIL|PATH_STIPPLE
    },
    {
	"Line Rasterization", "linerast.c", 34,
	LineRasterExec, LineRasterExec,
	COLOR_AUTO,
	PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_FOG|PATH_LOGICOP|PATH_SHADE|
	PATH_STENCIL|PATH_STIPPLE
    },
    {
	"Line Stipple", "linestip.c", 35,
	LineStippleExec, LineStippleExec,
	COLOR_AUTO,
	PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_FOG|PATH_LOGICOP|PATH_SHADE|
	PATH_STENCIL
    },
    {
	"Anti-aliased Line", "lineaa.c", 36,
	LineAntiAliasExec, NO_TEST,
	COLOR_FULL,
	PATH_DEPTH|PATH_FOG|PATH_LOGICOP|PATH_SHADE|PATH_STENCIL|PATH_STIPPLE
    },
    {
	"Horizontal and Vertical Line", "linehv.c", 37,
	LineHVExec, LineHVExec,
	COLOR_AUTO,
	PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_FOG|PATH_LOGICOP|PATH_SHADE|
	PATH_STENCIL|PATH_STIPPLE
    },
    {
	"Triangle Rasterization", "trirast.c", 38,
	TriRasterExec, TriRasterExec,
	COLOR_AUTO,
	PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_FOG|PATH_LOGICOP|PATH_SHADE|
	PATH_STENCIL|PATH_STIPPLE
    },
    {
	"Triangle Tile", "tritile.c", 39,
	TriTileExec, TriTileExec,
	COLOR_FULL,
	PATH_ALPHA|PATH_DEPTH|PATH_FOG|PATH_LOGICOP|PATH_SHADE|PATH_STENCIL|
	PATH_STIPPLE
    },
    {
	"Triangle Stipple", "tristip.c", 40,
	TriStippleExec, TriStippleExec,
	COLOR_AUTO,
	PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_FOG|PATH_LOGICOP|PATH_SHADE|
	PATH_STENCIL
    },
    {
	"Anti-aliased Triangles", "triaa.c", 41,
	TriAntiAliasExec, NO_TEST,
	COLOR_FULL,
	PATH_DEPTH|PATH_FOG|PATH_LOGICOP|PATH_SHADE|PATH_STENCIL|PATH_STIPPLE
    },
    {
	"Quad Rasterization", "quadrast.c", 42,
	QuadRasterExec, QuadRasterExec,
	COLOR_AUTO,
	PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_FOG|PATH_LOGICOP|PATH_SHADE|
	PATH_STENCIL|PATH_STIPPLE
    },
    {
	"Polygon Face", "polyface.c", 43,
	PolyFaceExec, PolyFaceExec,
	COLOR_AUTO,
	PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_FOG|PATH_LOGICOP|PATH_SHADE|
	PATH_STENCIL|PATH_STIPPLE
    },
    {
	"Polygon Cull", "polycull.c", 44,
	PolyCullExec, PolyCullExec,
	COLOR_AUTO,
	PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_FOG|PATH_LOGICOP|PATH_SHADE|
	PATH_STENCIL|PATH_STIPPLE
    },
    {
	"Polygon Stipple", "polystip.c", 45,
	PolyStippleExec, PolyStippleExec,
	COLOR_AUTO,
	PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_FOG|PATH_LOGICOP|PATH_SHADE|
	PATH_STENCIL
    },
    {
	"Polygon Edge", "polyedge.c", 46,
	PolyEdgeExec, PolyEdgeExec,
	COLOR_FULL,
	PATH_ALPHA|PATH_DEPTH|PATH_FOG|PATH_LOGICOP|PATH_STENCIL|PATH_STIPPLE
    },

    /*
    ** Lighting.
    */
    {
	"Ambient Light", "l_al.c", 47,
	AmbLightExec, NO_TEST,
	COLOR_FULL,
	PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_LOGICOP|PATH_STENCIL|PATH_STIPPLE
    },
    {
	"Ambient Material", "l_am.c", 48,
	AmbMatRGBExec, AmbMatCIExec,
	COLOR_FULL,
	PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_LOGICOP|PATH_STENCIL|PATH_STIPPLE
    },
    {
	"Ambient Scene", "l_as.c", 49,
	AmbSceneExec, NO_TEST,
	COLOR_FULL,
	PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_LOGICOP|PATH_STENCIL|PATH_STIPPLE
    },
    {
	"Attenuation Constants", "l_ac.c", 50,
	AtnConstRGBExec, AtnConstCIExec,
	COLOR_FULL,
	PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_LOGICOP|PATH_STENCIL|PATH_STIPPLE
    },
    {
	"Attenuation Position", "l_ap.c", 51,
	AtnPosRGBExec, AtnPosCIExec,
	COLOR_FULL,
	PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_LOGICOP|PATH_STENCIL|PATH_STIPPLE
    },
    {
	"Diffuse Light", "l_dl.c", 52,
	DifLightRGBExec, DifLightCIExec,
	COLOR_FULL,
	PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_LOGICOP|PATH_STENCIL|PATH_STIPPLE
    },
    {
	"Diffuse Material", "l_dm.c", 53,
	DifMatRGBExec, DifMatCIExec,
	COLOR_FULL,
	PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_LOGICOP|PATH_STENCIL|PATH_STIPPLE
    },
    {
	"Diffuse Material Normal", "l_dmn.c", 54,
	DifMatNormRGBExec, DifMatNormCIExec,
	COLOR_FULL,
	PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_LOGICOP|PATH_STENCIL|PATH_STIPPLE
    },
    {
	"Diffuse Material Positioning", "l_dmp.c", 55,
	DifMatPosRGBExec, DifMatPosCIExec,
	COLOR_FULL,
	PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_LOGICOP|PATH_STENCIL|PATH_STIPPLE
    },
    {
	"Emissive Material", "l_em.c", 56,
	EmitMatExec, NO_TEST,
	COLOR_FULL,
	PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_LOGICOP|PATH_STENCIL|PATH_STIPPLE
    },
    {
	"Specular Exponent", "l_se.c", 57,
	SpecExpRGBExec, SpecExpCIExec,
	COLOR_FULL,
	PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_LOGICOP|PATH_STENCIL|PATH_STIPPLE
    },
    {
	"Specular Exponent Normal", "l_sen.c", 58,
	SpecExpNormRGBExec, SpecExpNormCIExec,
	COLOR_FULL,
	PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_LOGICOP|PATH_STENCIL|PATH_STIPPLE
    },
    {
	"Specular Local Eye Half Angle", "l_sleha.c", 59,
	SpecLEHAExec, NO_TEST,
	COLOR_FULL,
	PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_LOGICOP|PATH_STENCIL|PATH_STIPPLE
    },
    {
	"Specular Light", "l_sl.c", 60,
	SpecLightRGBExec, SpecLightCIExec,
	COLOR_FULL,
	PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_LOGICOP|PATH_STENCIL|PATH_STIPPLE
    },
    {
	"Specular Material", "l_sm.c", 61,
	SpecMatRGBExec, SpecMatCIExec,
	COLOR_FULL,
	PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_LOGICOP|PATH_STENCIL|PATH_STIPPLE
    },
    {
	"Specular Normal", "l_sn.c", 62,
	SpecNormRGBExec, SpecNormCIExec,
	COLOR_FULL,
	PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_LOGICOP|PATH_STENCIL|PATH_STIPPLE
    },
    {
	"Spot Positioning", "l_sp.c", 63,
	SpotPosRGBExec, SpotPosCIExec,
	COLOR_FULL,
	PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_LOGICOP|PATH_STENCIL|PATH_STIPPLE
    },
    {
	"Spot Exponent and Positioning", "l_sep.c", 64,
	SpotExpPosRGBExec, SpotExpPosCIExec,
	COLOR_FULL,
	PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_LOGICOP|PATH_STENCIL|PATH_STIPPLE
    },
    {
	"Spot Exponent and Direction", "l_sed.c", 65,
	SpotExpDirRGBExec, SpotExpDirCIExec,
	COLOR_FULL,
	PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_LOGICOP|PATH_STENCIL|PATH_STIPPLE
    },

    /*
    ** Fog.
    */
    {
	"Fog Exponential", "fogexp.c", 66,
	FogExpRGBExec, FogExpCIExec,
	COLOR_FULL,
	PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_LOGICOP|PATH_STENCIL|PATH_STIPPLE
    },
    {
	"Fog Linear", "foglin.c", 67,
	FogLinRGBExec, FogLinCIExec,
	COLOR_FULL,
	PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_LOGICOP|PATH_STENCIL|PATH_STIPPLE
    },

    /*
    ** Texture.
    */
    {
	"Texture Decal", "texdecal.c", 68,
	TexDecalExec, NO_TEST,
	COLOR_FULL,
	PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_FOG|PATH_LOGICOP|PATH_SHADE|
	PATH_STENCIL|PATH_STIPPLE
    },
    {
	"Texture Border", "texbc.c", 69,
	TexBorderColorExec, NO_TEST,
	COLOR_FULL,
	PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_FOG|PATH_LOGICOP|PATH_SHADE|
	PATH_STENCIL|PATH_STIPPLE
    },
    {
	"Mipmaps Selection", "mipsel.c", 70,
	MipSelectExec, NO_TEST,
	COLOR_FULL,
	PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_FOG|PATH_LOGICOP|PATH_SHADE|
	PATH_STENCIL|PATH_STIPPLE
    },
    {
	"Mipmaps Interpolation", "miplin.c", 71,
	MipLinExec, NO_TEST,
	COLOR_FULL,
	PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_FOG|PATH_LOGICOP|PATH_SHADE|
	PATH_STENCIL|PATH_STIPPLE
    },

    /*
    ** Display list.
    */
    {
        "Display Lists", "dlist.c", 72,
        DisplayListExec, DisplayListExec,
        COLOR_MIN,
        PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_FOG|PATH_LOGICOP|PATH_SHADE|
	PATH_STENCIL|PATH_STIPPLE
    },

    /*
    ** Evaluator.
    */
    {
        "Evaluator", "evalv.c", 73,
        EvalVertexExec, EvalVertexExec,
        COLOR_AUTO,
        PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_FOG|PATH_LOGICOP|PATH_SHADE|
        PATH_STENCIL|PATH_STIPPLE
    },
    {
        "Evaluator Color", "evalc.c", 74,
        EvalColorExec, NO_TEST,
        COLOR_NONE,
        PATH_ALPHA|PATH_BLEND|PATH_DEPTH|PATH_FOG|PATH_LOGICOP|PATH_SHADE|
        PATH_STENCIL|PATH_STIPPLE
    },

    {
	"End of List"
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\quadrast.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** quadrast.c
** Quad Rasterization Test.
**
** Description - 
**    This test renders GL_QUADS and GL_QUAD_STRIPS. It checks if
**    those fragments which are colored the primitive's color
**    have centers which are within the convex hull formed by the
**    vertices, and if those fragments which are colored the
**    background color are outside the convex hull of formed by
**    the vertices.
**    
** Error Explanation - 
**    Those fragments which are found to be in error are then
**    checked to determine their distance from the nearest
**    primitive edge. If this distance is less than 1/2 of a
**    pixel width the error is ignored.
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer.
**    Color requirements:
**        RGBA or color index mode. 2 colors.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**    Paths:
**        Allowed = Alpha, Blend, Depth, Fog, Logicop, Shade, Stencil, Stipple.
**        Not allowed = Alias, Dither.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"
#include "utilg.h"


typedef struct _edgeEqnRec {
    slopeRec slope;
    interceptRec intercept;
    vertexRec vOp0, vOp1;
    long (*Inequality)(float, float, slopeRec *, interceptRec *);
    float length;
} edgeEqnRec;

typedef struct _quadRec {
    edgeEqnRec edge01, edge12, edge23, edge30;
    vertexRec v0, v1, v2, v3;
} quadRec;


static float errX, errY;
static char *errExpectedDrawn, *errObservedDrawn;
static char errStr[320];
static char errStrFmt[] = "While rendering a %s with vertices (%g, %g), (%g, %g), (%g, %g), (%g, %g), the fragment at (%g, %g) should be the %s color, but is the %s color.";


static long IsOuter(vertexRec *vEdge0, vertexRec *vEdge1,
		    vertexRec *vOp0, vertexRec *vOp1)
{
    interceptRec i;
    slopeRec s;

    GetSlope(&s, vEdge0, vEdge1);
    GetIntercept(&i, vEdge0, &s);

    if (LessThan(vOp0->x, vOp0->y, &s, &i)) {
	if (LessThan(vOp1->x, vOp1->y, &s, &i)) {
	    return GL_TRUE;
	} else {
	    return GL_FALSE;
	}
    } else {
	if (!LessThan(vOp1->x, vOp1->y, &s, &i)) {
	    return GL_TRUE;
	} else {
	    return GL_FALSE;
	}
    }
}

static void SwapVertices(vertexRec *v1, vertexRec *v2)
{
    float tmpX, tmpY, tmpZ;

    tmpX = v1->x;   
    tmpY = v1->y;   
    tmpZ = v1->z;

    v1->x = v2->x;
    v1->y = v2->y;
    v1->z = v2->z;

    v2->x = tmpX;  
    v2->y = tmpY;   
    v2->z = tmpZ;
}

static long IsConvex(vertexRec *v)
{

    if (!IsOuter(&v[0], &v[1], &v[2], &v[3])) {
	SwapVertices(&v[1], &v[3]);
	if (!IsOuter(&v[0], &v[1], &v[2], &v[3])) {
	    return GL_FALSE;
	}
    }

    if (!IsOuter(&v[1], &v[2], &v[3], &v[0])) {
	SwapVertices(&v[2], &v[3]);
	if (!IsOuter(&v[1], &v[2], &v[3], &v[0])) {
	    return GL_FALSE;
	}
    }

    if (!IsOuter(&v[2], &v[3], &v[0], &v[1])) {
	    return GL_FALSE;
    }

    return GL_TRUE;
}

static long MakeEdge(edgeEqnRec *e, vertexRec *v0, vertexRec *v1,
		     vertexRec *vOp0, vertexRec *vOp1)
{

    GetSlope(&e->slope, v0, v1);
    GetIntercept(&e->intercept, v0, &e->slope);

    e->length = SQRT(e->slope.dx*e->slope.dx+e->slope.dy*e->slope.dy);

    e->vOp0.x = vOp0->x;
    e->vOp0.y = vOp0->y;
    e->vOp0.z = vOp0->z;

    e->vOp1.x = vOp1->x;
    e->vOp1.y = vOp1->y;
    e->vOp1.z = vOp1->z;

    if (LessThan(vOp0->x, vOp0->y, &e->slope, &e->intercept)) {
	e->Inequality = LessThan;
    } else {
	e->Inequality = MoreThan;
    }

    /*
    ** Hopefully an unnecessary check for debugging purposes.
    */
    if (e->Inequality(vOp1->x, vOp1->y, &e->slope, &e->intercept)) {
	return GL_TRUE;
    } else {
	return GL_FALSE;
    }
}

static void MakeVertices(vertexRec *v)
{
    long i;

    for (i = 0; i < 4; i++) {
	v[i].x = Random(2.0, WINDSIZEX-2.0);
	v[i].y = Random(2.0, WINDSIZEY-2.0);
	v[i].z = Random(-1.0, 1.0);
    }
}

static long MakeQuad(quadRec *q, vertexRec *v)
{
    long flag = GL_FALSE;

    if (MakeEdge(&q->edge01, &v[0], &v[1], &v[2], &v[3]) &&
	MakeEdge(&q->edge12, &v[1], &v[2], &v[3], &v[0]) &&
	MakeEdge(&q->edge23, &v[2], &v[3], &v[0], &v[1]) &&
	MakeEdge(&q->edge30, &v[3], &v[0], &v[1], &v[2])) {
	flag = GL_TRUE;

	q->v0.x = v[0].x;
	q->v0.y = v[0].y;
	q->v0.z = v[0].z;

	q->v1.x = v[1].x;
	q->v1.y = v[1].y;
	q->v1.z = v[1].z;

	q->v2.x = v[2].x;
	q->v2.y = v[2].y;
	q->v2.z = v[2].z;

	q->v3.x = v[3].x;
	q->v3.y = v[3].y;
	q->v3.z = v[3].z;
    }
    return flag;
}

static void RenderQuadSeperate(quadRec *q)
{

    glBegin(GL_QUADS);
	glVertex3f(q->v0.x, q->v0.y, q->v0.z);
	glVertex3f(q->v1.x, q->v1.y, q->v1.z);
	glVertex3f(q->v2.x, q->v2.y, q->v2.z);
	glVertex3f(q->v3.x, q->v3.y, q->v3.z);
    glEnd();
}

static void RenderQuadStrip(quadRec *q)
{

    /*
    ** Note the vertex order swap between the 3rd and 4th vertex.
    */

    glBegin(GL_QUAD_STRIP);
	glVertex3f(q->v0.x, q->v0.y, q->v0.z);
	glVertex3f(q->v1.x, q->v1.y, q->v1.z);
	glVertex3f(q->v3.x, q->v3.y, q->v3.z);
	glVertex3f(q->v2.x, q->v2.y, q->v2.z);
    glEnd();
}

static float Error(edgeEqnRec *e, float x, float y)
{
    float offBy;

    offBy = y * e->slope.dx - x * e->slope.dy;
    offBy = e->intercept.bDx - offBy;

    if (e->length != 0.0) {
	offBy /= e->length;
    } else {
	/*
	**  Everything is on the correct side of a trivial line.
	*/
	offBy = 0.0;
    }
    offBy = ABS(offBy);
    return offBy;
}

static long CheckIfIn(float x, float y, quadRec *q, float error)
{
    long e1, e2, e3, e4;
    float offBy1, offBy2, offBy3, offBy4;

    e1 = q->edge01.Inequality(x, y, &q->edge01.slope, &q->edge01.intercept);
    e2 = q->edge12.Inequality(x, y, &q->edge12.slope, &q->edge12.intercept);
    e3 = q->edge23.Inequality(x, y, &q->edge23.slope, &q->edge23.intercept);
    e4 = q->edge30.Inequality(x, y, &q->edge30.slope, &q->edge30.intercept);

    if (e1 && e2 && e3 && e4) {
	return GL_TRUE;
    } else if (error == 0.0) {
	return GL_FALSE;
    } else {
	if (!e1) {
	    offBy1 = Error(&q->edge01, x, y);
	    if (offBy1 >= error) {
		return GL_FALSE;
	    }
	}
	if (!e2) {
	    offBy2 = Error(&q->edge12, x, y);
	    if (offBy2 >= error) {
		return GL_FALSE;
	    }
	}
	if (!e3) {
	    offBy3 = Error(&q->edge23, x, y);
	    if (offBy3 >= error) {
		return GL_FALSE;
	    }
	}
	if (!e4) {
	    offBy4 = Error(&q->edge30, x, y);
	    if (offBy4 >= error) {
		return GL_FALSE;
	    }
	}
    }
    return GL_TRUE;
}

static long CheckIfOut(float x, float y, quadRec *q, float error)
{
    long e1, e2, e3, e4;
    float offBy1, offBy2, offBy3, offBy4, minError;

    minError = 0.0;

    e1 = !q->edge01.Inequality(x, y, &q->edge01.slope, &q->edge01.intercept);
    e2 = !q->edge12.Inequality(x, y, &q->edge12.slope, &q->edge12.intercept);
    e3 = !q->edge23.Inequality(x, y, &q->edge23.slope, &q->edge23.intercept);
    e4 = !q->edge30.Inequality(x, y, &q->edge30.slope, &q->edge30.intercept);

    if (e1 || e2 || e3 || e4) {
	return GL_TRUE;
    } else if (error == 0.0) {
	return GL_FALSE;
    } else {
	/*
	** Error is always positive
	*/
	offBy1 = Error(&q->edge01, x, y);
	offBy2 = Error(&q->edge12, x, y);
	offBy3 = Error(&q->edge23, x, y);
	offBy4 = Error(&q->edge30, x, y);

	minError = offBy1;
	minError = (offBy2 < minError) ? offBy2 : minError;
	minError = (offBy3 < minError) ? offBy3 : minError;
	minError = (offBy4 < minError) ? offBy4 : minError;
    }
    return (minError < error);
}

static long Compare(quadRec *q, GLfloat *buf)
{
    long flag, i, j;

    flag = NO_ERROR;
    for (i = 0; i < WINDSIZEY; i++) {
	for (j = 0; j < WINDSIZEX; j++) {
	    /*
	    ** If it is rendered, is it close to the ideal quad?
	    ** If it is not rendered, is it sufficiently outside the
	    ** ideal quad?
	    */
	    if (AutoColorCompare(buf[i*WINDSIZEX+j], COLOR_OFF) == GL_TRUE) {
		if (CheckIfOut(j+0.5, i+0.5, q, 0.5) == GL_FALSE) {
		    errX = j + 0.5;
		    errY = i + 0.5;
		    errExpectedDrawn = "primitive";
		    errObservedDrawn = "background";
		    flag = ERROR;
		}
	    } else {
		if (CheckIfIn(j+0.5, i+0.5, q, 0.5) == GL_FALSE) {
		    errX = j + 0.5;
		    errY = i + 0.5;
		    errExpectedDrawn = "background";
		    errObservedDrawn = "primitive";
		    flag = ERROR;
		}
	    }
	}
    }
    return flag;
}

long QuadRasterExec(void)
{
    GLfloat *buf;
    quadRec q;
    vertexRec v[4];
    long max, flag, i;

    buf = (GLfloat *) MALLOC(WINDSIZEX*WINDSIZEY*sizeof(GLfloat));
    flag = NO_ERROR;

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    AutoClearColor(COLOR_OFF);
    AutoColor(COLOR_ON);
    glDisable(GL_DITHER);

    max = (machine.pathLevel == 0) ? 50 : 5;
    for (i = 0; i < max; i++) {
	do {
	    MakeVertices(v);
	} while (!IsConvex(v));

	if (MakeQuad(&q, v)) {
	    glClear(GL_COLOR_BUFFER_BIT);
	    RenderQuadSeperate(&q);
	    ReadScreen(0, 0, WINDSIZEX, WINDSIZEY, GL_AUTO_COLOR, buf);
	    if (Compare(&q, buf) == ERROR) {
		StrMake(errStr, errStrFmt, "GL_QUADS", q.v0.x, q.v0.y, q.v1.x,
			q.v1.y, q.v2.x, q.v2.y, q.v3.x, q.v3.y, errX, errY,
			errExpectedDrawn, errObservedDrawn);
		ErrorReport(__FILE__, __LINE__, errStr);
		flag = ERROR;
		break;
	    }
	    glClear(GL_COLOR_BUFFER_BIT);
	    RenderQuadStrip(&q);
	    ReadScreen(0, 0, WINDSIZEX, WINDSIZEY, GL_AUTO_COLOR, buf);
	    if (Compare(&q, buf) == ERROR) {
		StrMake(errStr, errStrFmt, "GL_QUAD_STRIP", q.v0.x, q.v0.y,
			q.v1.x, q.v1.y, q.v2.x, q.v2.y, q.v3.x, q.v3.y, errX,
			errY, errExpectedDrawn, errObservedDrawn);
		ErrorReport(__FILE__, __LINE__, errStr);
		flag = ERROR;
		break;
	    }
	}
    }

    FREE(buf);
    return flag;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\texbc.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** texbc.c
** Texture Border Color Test.
**
** Description -
**    Tests texture borders. Both border-included and no-border
**    texture maps are tested. For a no-border texture map, the
**    texture coordinates match the texture image. For a
**    border-included texture map, the texture coordinates are
**    adjusted to accommodate for the extra border pixels in the
**    texture image. In either case, the body of the texture has
**    no color while the texture border does. The presence of the
**    texture border can then be verifies.
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer.
**    Color requirements:
**        RGBA mode. Full color.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**    Paths:
**        Allowed = Alpha, Blend, Depth, Fog, Logicop, Shade, Stencil, Stipple.
**        Not allowed = Alias, Dither.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"


static char errEnv[40], errWrap[40], errMagFilter[40], errMinFilter[40];
static long errBorder;
static char errStr[320];
static char errStrFmt[][240] = {
    "Polygon was rendered without a border along the %s edge. Texture environment mode is %s. S and T wrap mode is %s. Magnification filter is %s, minification filter is %s. Border color is (1.0, 0.0, 0.0, 0.0). Texture was made %s a border.",
    "The interior of the polygon was rendered incorrectly. Texture environment mode is %s. S and T wrap mode is %s. Magnification filter is %s, minification filter is %s. Border color is (1.0, 0.0, 0.0, 0.0). Texture was made %s a border."
};


static void MakeWithoutBorder(GLfloat *buf)
{
    GLfloat *ptr;
    GLint level, i;
    GLsizei size;

    level = 0;
    for (size = 64; size > 0; size /= 2) {
	ptr = buf;
	for (i = 0; i < 64*64*3; i++) {
	    *ptr++ = 0.0;
	}
	glTexImage2D(GL_TEXTURE_2D, level++, 3, size, size, 0, GL_RGB,
		     GL_FLOAT, (unsigned char *)buf);
    }
}

static void MakeWithBorder(GLfloat *buf)
{
    GLfloat *ptr;
    GLint level, i, j;
    GLsizei size;

    level = 0;
    for (size = 64; size > 0; size /= 2) {
	ptr = buf;
	for (i = 0; i < size+2; i++) {
	    *ptr++ = 1.0;
	    *ptr++ = 1.0;
	    *ptr++ = 1.0;
	}
	for (i = 0; i < size; i++) {
	    *ptr++ = 1.0;
	    *ptr++ = 1.0;
	    *ptr++ = 1.0;
	    for (j = 0; j < size; j++) {
		*ptr++ = 0.0;
		*ptr++ = 0.0;
		*ptr++ = 0.0;
	    }
	    *ptr++ = 1.0;
	    *ptr++ = 1.0;
	    *ptr++ = 1.0;
	}
	for (i = 0; i < size+2; i++) {
	    *ptr++ = 1.0;
	    *ptr++ = 1.0;
	    *ptr++ = 1.0;
	}
	glTexImage2D(GL_TEXTURE_2D, level++, 3, size+2, size+2, 1, GL_RGB,
		     GL_FLOAT, (unsigned char *)buf);
    }
}

static void Draw(GLint size)
{
    GLint trueSize;

    trueSize = size + 2;

    glClear(GL_COLOR_BUFFER_BIT);
    glBegin(GL_POLYGON);
	glTexCoord2f(-1.0/(GLfloat)size, -1.0/(GLfloat)size);
	glVertex2i(0, 0);
	glTexCoord2f(-1.0/(GLfloat)size, 1.0+1.0/(GLfloat)size);
	glVertex2i(0, trueSize);
	glTexCoord2f(1.0+1.0/(GLfloat)size, 1.0+1.0/(GLfloat)size);
	glVertex2i(trueSize, trueSize);
	glTexCoord2f(1.0+1.0/(GLfloat)size, -1.0/(GLfloat)size);
	glVertex2i(trueSize, 0);
    glEnd();
}

static long TestColor(long a, GLfloat *buf)
{

    if (a == GL_TRUE) {     /* should have color. */
	if (buf[0] < epsilon.zero &&
	    buf[1] < epsilon.zero &&
	    buf[2] < epsilon.zero) {     /* no color. */
	    return ERROR;
	}
    } else {             /* should not have color. */
	if (buf[0] > epsilon.zero &&
	    buf[1] > epsilon.zero &&
	    buf[2] > epsilon.zero) {     /* color. */
	    return ERROR;
	}
    }

    return NO_ERROR;
}

static long Compare(GLsizei size, GLfloat *buf)
{
    GLfloat *ptr;
    long i, j;

    ReadScreen(0, 0, size+2, size+2, GL_RGB, buf);

    ptr = buf;

    /*
    ** Bottom edge.
    */
    for (i = 0; i < size+2; i++) {
	if (TestColor(GL_TRUE, ptr) == ERROR) {
	    StrMake(errStr, errStrFmt[0], "bottom", errEnv, errWrap,
	            errMagFilter, errMinFilter,
	            (errBorder == GL_TRUE) ? "with" : "without");
	    ErrorReport(__FILE__, __LINE__, errStr);
	    return ERROR;
	}
	ptr += 3;
    }

    for (i = 0; i < size; i++) {
	/*
	** Left edge.
	*/
	if (TestColor(GL_TRUE, ptr) == ERROR) {
	    StrMake(errStr, errStrFmt[0], "left", errEnv, errWrap,
		    errMagFilter, errMinFilter,
		    (errBorder == GL_TRUE) ? "with" : "without");
	    ErrorReport(__FILE__, __LINE__, errStr);
	    return ERROR;
	}
	ptr += 3;

        /*
	** Inside.
	*/
	for (j = 0; j < size; j++) {
	    if (i != 0 && i != (size - 1) && j != 0 && j != (size - 1)) {
		/*
		** Since the Spec allows for different formulae in the calculation of 
		** the level of detail.  The pixels adjacent to the outermost pixels
		** should not be examined.
		*/
		if (TestColor(GL_FALSE, ptr) == ERROR) {
		    StrMake(errStr, errStrFmt[1], errEnv, errWrap, errMagFilter,
			    errMinFilter,
			    (errBorder == GL_TRUE) ? "with" : "without");
		    ErrorReport(__FILE__, __LINE__, errStr);
		    return ERROR;
		}
	    }
	    ptr += 3;
	}

	/*
	** Right edge.
	*/
	if (TestColor(GL_TRUE, ptr) == ERROR) {
	    StrMake(errStr, errStrFmt[0], "right", errEnv, errWrap,
		    errMagFilter, errMinFilter,
		    (errBorder == GL_TRUE) ? "with" : "without");
	    ErrorReport(__FILE__, __LINE__, errStr);
	    return ERROR;
	}
	ptr += 3;
    }

    /*
    ** Top edge.
    */
    for (i = 0; i < size+2; i++) {
	if (TestColor(GL_TRUE, ptr) == ERROR) {
	    StrMake(errStr, errStrFmt[0], "top", errEnv, errWrap, errMagFilter,
		    errMinFilter, (errBorder == GL_TRUE) ? "with" : "without");
	    ErrorReport(__FILE__, __LINE__, errStr);
	    return ERROR;
	}
	ptr += 3;
    }

    return NO_ERROR;
}

static long Test(GLfloat *buf)
{
    GLsizei size;

    errBorder = GL_TRUE;
    MakeWithBorder(buf);
    for (size = 64; size > 0; size /= 2) {
	Draw(size);
	if (Compare(size, buf) == ERROR) {
	    return ERROR;
	}
    }

    errBorder = GL_FALSE;
    MakeWithoutBorder(buf);
    for (size = 64; size > 0; size /= 2) {
	Draw(size);
	if (Compare(size, buf) == ERROR) {
	    return ERROR;
	}
    }

    return NO_ERROR;
}

long TexBorderColorExec(void)
{
    static GLfloat color[] = {
	1.0, 1.0, 1.0, 0.0
    };
    GLfloat *buf, x;

    buf = (GLfloat *)MALLOC(WINDSIZEX*WINDSIZEY*3*sizeof(GLfloat));

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glDisable(GL_DITHER);

    glEnable(GL_TEXTURE_2D);

    x = GL_DECAL;
    glTexEnvfv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, &x);
    GetEnumName(x, errEnv);

    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, color);

    x = GL_CLAMP;
    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, &x);
    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, &x);
    GetEnumName(x, errWrap);

    x = GL_LINEAR;
    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, &x);
    GetEnumName(x, errMagFilter);

    x = GL_LINEAR;
    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, &x);
    GetEnumName(x, errMinFilter);
    if (Test(buf) == ERROR) {
	FREE(buf);
	return ERROR;
    }

    x = GL_LINEAR_MIPMAP_LINEAR;
    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, &x);
    GetEnumName(x, errMinFilter);
    if (Test(buf) == ERROR) {
	FREE(buf);
	return ERROR;
    }

    x = GL_LINEAR_MIPMAP_NEAREST;
    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, &x);
    GetEnumName(x, errMinFilter);
    if (Test(buf) == ERROR) {
	FREE(buf);
	return ERROR;
    }

    FREE(buf);
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\vorder.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** vorder.c
** Vertex Order Test.
**
** Description -
**    Test that triangle strips, triangle fans and quad strips
**    preserve proper vertex order when folded back on
**    themselves. Front and back are assigned different colors
**    and drawn counter-clockwise. Test is repeated for each
**    polygon mode.
**    
**    The test algorithm:
**        - Use glLightModel to assign different colors to
**        front and back.
**        - For each of GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN,
**        GL_QUAD_STRIP:
**            - Generate vertices of a strip/fan which folds
**            back on itself. Each primitive consists of
**            approximately 16 vertices. The folded-back region
**            is constructed so as to not obscure front-facing
**            vertices, except on the crease edge.
**        - For each polygon mode (GL_POINT, GL_LINE, GL_FILL):
**            - Draw the strip/fan.
**            - Examine framebuffer at vertices to be sure
**            appropriate front or back color appeared. Since
**            vertex location may be on pixel boundaries, an
**            allowance is made for the vertex to be off one
**            pixel in any direction.
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer.
**    Color requirements:
**        RGBA or color index mode. 4 colors.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**        Color and zero epsilons.
**    Paths:
**        Allowed = Alpha, Blend, Depth, Fog, Logicop, Shade, Stencil, Stipple.
**        Not allowed = Alias, Dither.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"


static char errStr[240];
static char errStrFmt[] = "Polymode is %s, primitive type %s. Error at vertex %i at (%1.1f, %1.1f).";


static long Compare(long x, long y, long color, GLfloat *buf)
{
    long i;
    long cmp;

    i = 3 * (WINDSIZEX * y + x);
    cmp = (ABS(buf[i]-colorMap[color][0]) <= epsilon.color[0] &&
	   ABS(buf[i+1]-colorMap[color][1]) <= epsilon.color[1] &&
	   ABS(buf[i+2]-colorMap[color][2]) <= epsilon.color[2]);
    return cmp;
}

static long TestBuf(GLfloat *buf, GLfloat *point, long index, long polyMode)
{
    long i=0, j=0;

    switch (polyMode) {
      case GL_POINT:
	i = (1.0 + point[0]) * WINDSIZEX / 2.0;
	j = (1.0 + point[1]) * WINDSIZEY / 2.0;
	break;
      case GL_LINE:
	i = Round((1.0+point[0])*WINDSIZEX/2.0);
	j = Round((1.0+point[1])*WINDSIZEY/2.0);
	break;
      case GL_FILL:
	i = ((1.0 + point[0]) * WINDSIZEX / 2.0) - 0.5;
	j = ((1.0 + point[1]) * WINDSIZEY / 2.0) - 0.5;
	break;
    }

    /*
    **  Test the 9 pixels around the target.
    */
    if (!(Compare(i  , j  , index, buf) ||
          Compare(i-1, j+1, index, buf) ||
          Compare(i  , j+1, index, buf) ||
          Compare(i+1, j+1, index, buf) ||
          Compare(i-1, j  , index, buf) ||
          Compare(i+1, j  , index, buf) ||
          Compare(i-1, j-1, index, buf) ||
          Compare(i  , j-1, index, buf) ||
          Compare(i+1, j-1, index, buf))) {
        return ERROR;
    }
    return NO_ERROR;
}

static void GeneratePoints(GLfloat points[10][4], long primType)
{
    GLfloat deltaX, deltaY, rad;
    long i;

    switch (primType) {
      case GL_TRIANGLE_STRIP:
	deltaX = 6.0 * (2.0 / WINDSIZEX);
	deltaY = 30.0 * (2.0 / WINDSIZEY);
	for (i = 0; i < 8; i += 2) {
	    points[i][0] = deltaX * (i + 1) - 1.0;
	    points[i][1] = 0.0;
	    points[i][2] = 0.0;
	    points[i][3] = 1.0;
	    points[i+1][0] = deltaX * (i + 1) - 1.0;
	    points[i+1][1] = -deltaY;
	    points[i+1][2] = 0.0;
	    points[i+1][3] = 1.0;
	}
	deltaY = 6 * (2.0 / WINDSIZEY);
	for (; i < 16; i += 2) {
	    points[i][0] = (-1.0 + deltaX) + 8.0 * deltaX;
	    points[i][1] = (i - 8) * deltaY;
	    points[i][2] = 0.0;
	    points[i][3] = 1.0;
	    points[i+1][0] = (-1.0 + deltaX) + 6.0 * deltaX;
	    points[i+1][1] = (i - 8) * deltaY;
	    points[i+1][2] = 0.0;
	    points[i+1][3] = 1.0;
	}
	break;
      case GL_QUAD_STRIP:
	deltaX = 6.0 * (2.0 / WINDSIZEX);
	deltaY = 30.0 * (2.0 / WINDSIZEY);
	for (i = 0; i < 8; i += 2) {
	    points[i][0] = deltaX * (i + 1) - 1.0;
	    points[i][1] = 0.0;
	    points[i][2] = 0.0;
	    points[i][3] = 1.0;
	    points[i+1][0] = deltaX * (i + 1) - 1.0;
	    points[i+1][1] = -deltaY;
	    points[i+1][2] = 0.0;
	    points[i+1][3] = 1.0;
	}
	deltaX /= 2.0;
	for (; i < 16; i += 2) {
	    points[i][0] = 1.0 - deltaX * (i - 6);
	    points[i][1] = 0.0;
	    points[i][2] = 0.0;
	    points[i][3] = 1.0;
	    points[i+1][0] = 1.0 - deltaX * (i - 6);
	    points[i+1][1] = -deltaY;
	    points[i+1][2] = 0.0;
	    points[i+1][3] = 1.0;
	}
	break;
      case GL_TRIANGLE_FAN:
	rad = 0.5;
	points[0][0] = 0.0;
	points[0][1] = 0.0;
	points[0][2] = 0.0;
	points[0][3] = 1.0;
	for (i = 1; i < 8; i++) {
	    points[i][0] = rad * COS((i-1)*50.0*PI/180.0);
	    points[i][1] = rad * SIN((i-1)*50.0*PI/180.0);
	}
	rad = 0.8;
	for (; i < 16; i++) {
	    points[i][0] = rad * COS((350.0-i*6)*PI/180.0);
	    points[i][1] = rad * SIN((350.0-i*6)*PI/180.0);
	}
	break;
    }
}

long VertexOrderExec(void)
{
    static GLenum primType[3] = {
	GL_TRIANGLE_STRIP, GL_TRIANGLE_FAN, GL_QUAD_STRIP
    };
    static GLenum polyMode[3] = {
	GL_POINT, GL_LINE, GL_FILL
    };
    GLfloat *buf, bufRGB[4];
    GLfloat points[20][4];
    GLint bufCI[3], mode, type, i;
    char modeStr[10], typeStr[20];

    /*
    ** Test that triangle strips, triangle fans and quad strips preserve
    ** proper vertex order when folded back on themselves. Front and
    ** back are assigned different colors and drawn counter-clockwise.
    ** Test is repeated under each PolygonMode.
    */

    buf = (GLfloat *)MALLOC(3*WINDSIZEX*WINDSIZEY*sizeof(GLfloat));

    SETCLEARCOLOR(BLACK);
    glDisable(GL_DITHER);
    glEnable(GL_LIGHTING);

    glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, (GLint)GL_TRUE);
    if (buffer.colorMode == GL_RGB) {
	bufRGB[0] = colorMap[RED][0];
	bufRGB[1] = colorMap[RED][1];
	bufRGB[2] = colorMap[RED][2];
	bufRGB[3] = 1.0;
        glMaterialfv(GL_FRONT, GL_EMISSION, bufRGB);
	bufRGB[0] = colorMap[GREEN][0];
	bufRGB[1] = colorMap[GREEN][1];
	bufRGB[2] = colorMap[GREEN][2];
	bufRGB[3] = 1.0;
        glMaterialfv(GL_BACK, GL_EMISSION, bufRGB);
	bufRGB[0] = 0.0;
	bufRGB[1] = 0.0;
	bufRGB[2] = 0.0;
	bufRGB[3] = 1.0;
        glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT, bufRGB);
    } else {
        bufCI[0] = RED;
        bufCI[1] = RED;
        bufCI[2] = RED;
        glMaterialiv(GL_FRONT, GL_COLOR_INDEXES, bufCI);
        bufCI[0] = GREEN;
        bufCI[1] = GREEN;
        bufCI[2] = GREEN;
        glMaterialiv(GL_BACK, GL_COLOR_INDEXES, bufCI);
    }

    for (type = 0; type < 3; type++) {
	GeneratePoints(points, primType[type]);
 
	for (mode = 0; mode < 3; mode++) {
	    glClear(GL_COLOR_BUFFER_BIT);

	    glPolygonMode(GL_FRONT_AND_BACK, polyMode[mode]);
	    glBegin(primType[type]);
		for (i = 0; i < 16; i += 2) {
		    glVertex2f(points[i][0], points[i][1]);
		    glVertex2f(points[i+1][0], points[i+1][1]);
		}
	    glEnd();

	    ReadScreen(0, 0, WINDSIZEX, WINDSIZEY, GL_RGB, buf);

	    /*
	    ** Some crease vertices (and the trifan center) will be overwritten
	    ** by back facing polygons, so don't test them for front color.
	    */

	    for (i = 1; i < 6; i++) {
		if (TestBuf(buf, &points[i][0], RED, polyMode[mode]) == ERROR) {
		    GetEnumName(polyMode[mode], modeStr);
		    GetEnumName(primType[mode], typeStr);
		    StrMake(errStr, errStrFmt, modeStr, typeStr, i,
		     	    points[i][0], points[i][1]);
		    ErrorReport(__FILE__, __LINE__, errStr);
		    FREE(buf);
		    return ERROR;
		}
	    }
	    for (i = 8; i < 16; i++) {
		if (TestBuf(buf, &points[i][0], GREEN,
		            polyMode[mode]) == ERROR) {
		    GetEnumName(polyMode[mode], modeStr);
		    GetEnumName(primType[mode], typeStr);
		    StrMake(errStr, errStrFmt, modeStr, typeStr, i,
		     	    points[i][0], points[i][1]);
		    ErrorReport(__FILE__, __LINE__, errStr);
		    FREE(buf);
		    return ERROR;
		}
	    }
	}
    }

    FREE(buf);
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\triaa.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** triaa.c
** Triangle Anti-Aliasing Test.
**
** Description -
**    Tests position independence of anti-aliased triangles. It
**    choses a triangle and computes its coverage. The triangle
**    is then translated and rotated, each time a new coverage is
**    computed and compared with the original value.
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer.
**    Color requirements:
**        RGBA mode. Full color.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**        The error allowance is based on a minimum of 4 subpixel sampling.
**        This yields 0.5 per pixel, multiplied by the number of pixels
**        along the perimeter, estimated by the bounding box perimeter.
**        The 0.5 is the max size of an elongated triangle intersecting with
**        a pixel square, yet missing the subpixels.
**    Paths:
**        Allowed = Depth, Fog, Logicop, Shade, Stencil, Stipple.
**        Not allowed = Alias, Alpha, Blend, Dither.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"


static char errStr[160];
static char errStrFmt[][80] = {
    "Triangle primitive did not draw.",
    "Coverage is %g, should be %g. Error margin is %g."
};


long TriAntiAliasExec(void)
{
    GLfloat *buf;
    GLfloat v1[2], v2[2], v3[2];
    GLfloat angle, shiftX, shiftY, sum, saveSum=0.0f, step, errorMargin;
    long i, j;

    buf = (GLfloat *)MALLOC(WINDSIZEX*WINDSIZEY*3*sizeof(GLfloat));

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glColor3f(1.0, 0.0, 0.0);
    glDisable(GL_DITHER);
    glEnable(GL_POLYGON_SMOOTH);
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE);

    step = (machine.pathLevel == 0) ? 17.0 : 45.0;

    for (i = 0; i < 9; i++) {
	v1[0] = 0.0;
	v1[1] = 0.0;
	v2[0] = Random(1.0, WINDSIZEX/4.0);
	v2[1] = 0.0;
	v3[0] = Random(1.0, WINDSIZEX/3.0);
	v3[1] = Random(1.0, WINDSIZEY/3.0);

	for (angle = 0.0; angle < 360.0; angle += step) {
	    glClear(GL_COLOR_BUFFER_BIT);

	    glPushMatrix();

	    shiftX = Random(WINDSIZEX/3.0, WINDSIZEX*2.0/3.0);
	    shiftY = Random(WINDSIZEY/3.0, WINDSIZEY*2.0/3.0);
	    glTranslatef(shiftX, shiftY, 0.0);
	    glRotatef(angle, 0, 0, 1);

	    glBegin(GL_POLYGON);
		glVertex2fv(v1);
		glVertex2fv(v2);
		glVertex2fv(v3);
	    glEnd();

	    glPopMatrix();

	    ReadScreen(0, 0, WINDSIZEX, WINDSIZEY, GL_RGB, buf);

	    sum = 0;
	    for (j = 0; j < WINDSIZEY*WINDSIZEY*3; j += 3) {
		sum += buf[j];
	    }

	    if (angle < step) {
		saveSum = sum;
	    } else {
		if (sum == 0.0) {
		    ErrorReport(__FILE__, __LINE__, errStrFmt[0]);
		    FREE(buf);
		    return ERROR;
		}

		errorMargin = (0.5 * 2.0 * (v2[0] + v3[1]));
		if (ABS(saveSum-sum) > errorMargin) {
		    StrMake(errStr, errStrFmt[1], sum, saveSum, errorMargin);
		    ErrorReport(__FILE__, __LINE__, errStr);
		    FREE(buf);
		    return ERROR;
		}
	    }
	}
    }

    FREE(buf);
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\trirast.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** trirast.c
** Triangle Rasterization Test.
**
** Description - 
**    This test renders GL_TRIANGLES, and GL_TRIANGLE_STRIPS, and
**    GL_TRIANGLE_FANS. It checks if those fragments which are
**    colored the primitive's color have centers which are within
**    the convex hull formed by the vertices, and if those
**    fragments which are colored the background color are
**    outside the convex hull of formed by the vertices.
**    
** Error Explanation - 
**    Those fragments which are found to be in error are then
**    checked to determine their distance from the nearest
**    primitive edge. If this distance is less than 1/2 of a
**    pixel width the error is ignored.
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer.
**    Color requirements:
**        RGBA or color index mode. 2 colors.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**    Paths:
**        Allowed = Alpha, Blend, Depth, Fog, Logicop, Shade, Stencil, Stipple.
**        Not allowed = Alias, Dither.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"
#include "utilg.h"


typedef struct _edgeEqnRec {
    slopeRec slope;
    interceptRec intercept;
    vertexRec vOp;
    long (*Inequality)(float, float, slopeRec *, interceptRec *);
    float length;
} edgeEqnRec;

typedef struct _triRec {
    edgeEqnRec edge01, edge02, edge12;
    vertexRec v0, v1, v2;
} triRec;


static float errX, errY;
static char *errExpectedDrawn, *errObservedDrawn;
static char errStr[320];
static char errStrFmt[] = "While rendering a %s with vertices (%g, %g), (%g, %g), (%g, %g), pixel at (%g, %g) should be the %s color, but is rendered the %s color.";


static void MakeEdge(edgeEqnRec *e, vertexRec *v0, vertexRec *v1,
		     vertexRec *vOp)
{

    GetSlope(&e->slope, v0, v1);
    GetIntercept(&e->intercept, v0, &e->slope);

    e->length = SQRT(e->slope.dx*e->slope.dx+e->slope.dy*e->slope.dy);

    e->vOp.x = vOp->x;
    e->vOp.y = vOp->y;
    e->vOp.z = vOp->z;

    if (LessThan(vOp->x, vOp->y, &e->slope, &e->intercept)) {
	e->Inequality = LessThan;
    } else {
	e->Inequality = MoreThan;
    }
}

static void MakeVertices(vertexRec *v)
{
    long i;

    for (i = 0; i < 3; i++) {
	v[i].x = Random(2.0, WINDSIZEX-2.0);
	v[i].y = Random(2.0, WINDSIZEY-2.0);
	v[i].z = Random(-1.0, 1.0);
    }
}

static void MakeTri(triRec *t, vertexRec *v)
{

    MakeEdge(&t->edge01, &v[0], &v[1], &v[2]);
    MakeEdge(&t->edge02, &v[0], &v[2], &v[1]);
    MakeEdge(&t->edge12, &v[1], &v[2], &v[0]);

    t->v0.x = v[0].x;
    t->v0.y = v[0].y;
    t->v0.z = v[0].z;

    t->v1.x = v[1].x;
    t->v1.y = v[1].y;
    t->v1.z = v[1].z;

    t->v2.x = v[2].x;
    t->v2.y = v[2].y;
    t->v2.z = v[2].z;
}

static void RenderTriSeperate(triRec *t)
{

    glBegin(GL_TRIANGLES);
	glVertex3f(t->v0.x, t->v0.y, t->v0.z);
	glVertex3f(t->v1.x, t->v1.y, t->v1.z);
	glVertex3f(t->v2.x, t->v2.y, t->v2.z);
    glEnd();
}

static void RenderTriStrip(triRec *t)
{

    glBegin(GL_TRIANGLE_STRIP);
	glVertex3f(t->v0.x, t->v0.y, t->v0.z);
	glVertex3f(t->v1.x, t->v1.y, t->v1.z);
	glVertex3f(t->v2.x, t->v2.y, t->v2.z);
    glEnd();
}

static void RenderTriFan(triRec *t)
{

    glBegin(GL_TRIANGLE_FAN);
	glVertex3f(t->v0.x, t->v0.y, t->v0.z);
	glVertex3f(t->v1.x, t->v1.y, t->v1.z);
	glVertex3f(t->v2.x, t->v2.y, t->v2.z);
    glEnd();
}

static float Error(edgeEqnRec *e, float x, float y)
{
    float offBy;

    offBy = y * e->slope.dx - x * e->slope.dy;
    offBy = e->intercept.bDx - offBy;

    if (e->length != 0.0) {
	offBy /= e->length;
    } else {
	/*
	**  Everything is on the correct side of a trivial line.
	*/
	offBy = 0.0;
    }
    offBy = ABS(offBy);
    return offBy;
}

static long CheckIfIn(float x, float y, triRec *t, float error)
{
    long e1, e2, e3;
    float offBy1, offBy2, offBy3;

    e1 = t->edge01.Inequality(x, y, &t->edge01.slope, &t->edge01.intercept);
    e2 = t->edge02.Inequality(x, y, &t->edge02.slope, &t->edge02.intercept);
    e3 = t->edge12.Inequality(x, y, &t->edge12.slope, &t->edge12.intercept);

    if (e1 && e2 && e3) {
	return GL_TRUE;
    } else if (error == 0.0) {
	return GL_FALSE;
    } else {
	if (!e1) {
	    offBy1 = Error(&t->edge01, x, y);
	    if (offBy1 >= error) {
		return GL_FALSE;
	    }
	}
	if (!e2) {
	    offBy2 = Error(&t->edge02, x, y);
	    if (offBy2 >= error) {
		return GL_FALSE;
	    }
	
	}
	if (!e3) {
	    offBy3 = Error(&t->edge12, x, y);
	    if (offBy3 >= error) {
		return GL_FALSE;
	    }
	}
    }
    return GL_TRUE;
}

static long CheckIfOut(float x, float y, triRec *t, float error)
{
    long e1, e2, e3;
    float offBy1, offBy2, offBy3, minError;

    minError = 0.0;

    e1 = !t->edge01.Inequality(x, y, &t->edge01.slope, &t->edge01.intercept);
    e2 = !t->edge02.Inequality(x, y, &t->edge02.slope, &t->edge02.intercept);
    e3 = !t->edge12.Inequality(x, y, &t->edge12.slope, &t->edge12.intercept);

    if (e1 || e2 || e3) {
	return GL_TRUE;
    } else if (error == 0.0) {
	return GL_FALSE;
    } else {
	/*
	** Error is always positive
	*/
	offBy1 = Error(&t->edge01, x, y);
	offBy2 = Error(&t->edge02, x, y);
	offBy3 = Error(&t->edge12, x, y);

	minError = offBy1;
	minError = (offBy2 < minError) ? offBy2 : minError;
	minError = (offBy3 < minError) ? offBy3 : minError;
    }
    return (minError < error);
}

static long Compare(triRec *t, GLfloat *buf)
{
    long flag, i, j;

    flag = NO_ERROR;
    for (i = 0; i < WINDSIZEY; i++) {
	for (j = 0; j < WINDSIZEX; j++) {
	    /*
	    ** If it is rendered, is it close to the ideal triangle?
	    ** If it is not rendered, is it sufficiently outside the
	    ** ideal triangle?
	    */
	    if (AutoColorCompare(buf[i*WINDSIZEX+j], COLOR_OFF) == GL_TRUE) {
		if (CheckIfOut(j+0.5, i+0.5, t, 0.5) == GL_FALSE) {
		    errX = j + 0.5; 
		    errY = i + 0.5;
		    errExpectedDrawn = "primitive";
		    errObservedDrawn = "background";
		    flag = ERROR; } 
	    } else {
		if (CheckIfIn(j+0.5, i+0.5, t, 0.5) == GL_FALSE) {
		    errX = j + 0.5; 
		    errY = i + 0.5;
		    errExpectedDrawn = "background";
		    errObservedDrawn = "primitive";
		    flag = ERROR;
		}
	    }
	}
    }
    return flag;
}

long TriRasterExec(void)
{
    GLfloat *buf;
    triRec t;
    vertexRec v[3];
    long max, flag, i;

    buf = (GLfloat *)MALLOC(WINDSIZEX*WINDSIZEY*sizeof(GLfloat));
    flag = NO_ERROR;

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    AutoClearColor(COLOR_OFF);
    AutoColor(COLOR_ON);
    glDisable(GL_DITHER);

    max = (machine.pathLevel == 0) ? 50 : 5;
    for (i = 0; i < max; i++) {
	glClear(GL_COLOR_BUFFER_BIT);
	MakeVertices(v);
	MakeTri(&t, v);
	RenderTriSeperate(&t);
	ReadScreen(0, 0, WINDSIZEX, WINDSIZEY, GL_AUTO_COLOR, buf);
	if (Compare(&t, buf) == ERROR) {
	    StrMake(errStr, errStrFmt, "GL_TRIANGLES", t.v0.x, t.v0.y, t.v1.x,
		    t.v1.y, t.v2.x, t.v2.y, errX, errY, errExpectedDrawn,
		    errObservedDrawn);
	    ErrorReport(__FILE__, __LINE__, errStr);
	    flag = ERROR;
	    break;
	}

	glClear(GL_COLOR_BUFFER_BIT);
	RenderTriStrip(&t);
	ReadScreen(0, 0, WINDSIZEX, WINDSIZEY, GL_AUTO_COLOR, buf);
	if (Compare(&t, buf) == ERROR) {
	    StrMake(errStr, errStrFmt, "GL_TRIANGLE_STRIP", t.v0.x, t.v0.y,
		    t.v1.x, t.v1.y, t.v2.x, t.v2.y, errX, errY,
		    errExpectedDrawn, errObservedDrawn);
	    ErrorReport(__FILE__, __LINE__, errStr);
	    flag = ERROR;
	    break;
	}

	glClear(GL_COLOR_BUFFER_BIT);
	RenderTriFan(&t);
	ReadScreen(0, 0, WINDSIZEX, WINDSIZEY, GL_AUTO_COLOR, buf);
	if (Compare(&t, buf) == ERROR) {
	    StrMake(errStr, errStrFmt, "GL_TRIANGLE_FAN", t.v0.x, t.v0.y,
		    t.v1.x, t.v1.y, t.v2.x, t.v2.y, errX, errY,
		    errExpectedDrawn, errObservedDrawn);
	    ErrorReport(__FILE__, __LINE__, errStr);
	    flag = ERROR;
	    break;
	}
    }

    FREE(buf);
    return flag;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\texdecal.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** texdecal.c
** Texture Decal Test.
**
** Description -
**    Simple texture test. A polygon is drawn with a texture. The
**    texture coordinates are set so that the texture should
**    appear on the polygon with no distortion. The rendered
**    polygon is read back and compared to the texture pattern.
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer.
**    Color requirements:
**        RGBA mode. Full color.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**    Paths:
**        Allowed = Alpha, Blend, Depth, Fog, Logicop, Shade, Stencil, Stipple.
**        Not allowed = Alias, Dither.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"


static char errEnv[40], errMagFilter[40], errMinFilter[40];
static char errStr[320];
static char errStrFmt[] = "Location (%d, %d). Texture environment mode is %s. Magnification filter is %s, minification filter is %s. Color is (%1.1f, %1.1f, %1.1f), should be (%1.1f, %1.1f, %1.1f.)";


static void Make(GLsizei size, GLfloat *buf)
{
    GLint level, i;

    for (i = 0; i < 64*64*3; i++) {
	buf[i] = Random(0.0, 1.0);
    }

    level = 0;
    while (size > 0) {
	glTexImage2D(GL_TEXTURE_2D, level++, 3, size, size, 0, GL_RGB,
		     GL_FLOAT, (unsigned char *)buf);
	size /= 2;
    }
}

long TexDecalExec(void)
{
    GLfloat *textureBuf, *workBuf, x;
    long i, j, k;

    textureBuf = (GLfloat *)MALLOC(64*64*3*sizeof(GLfloat));
    workBuf = (GLfloat *)MALLOC(WINDSIZEX*WINDSIZEY*3*sizeof(GLfloat));

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    glClearColor(0.0, 0.0, 0.0, 0.0);
    glClear(GL_COLOR_BUFFER_BIT);
    glDisable(GL_DITHER);

    glEnable(GL_TEXTURE_2D);

    x = GL_DECAL;
    glTexEnvfv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, &x);
    GetEnumName(x, errEnv);

    x = GL_NEAREST;
    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, &x);
    GetEnumName(x, errMinFilter);

    x = GL_NEAREST;
    glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, &x);
    GetEnumName(x, errMagFilter);

    Make(64, textureBuf);

    glBegin(GL_POLYGON);
	glTexCoord2f(0.0, 0.0);
	glVertex2i(0, 0);
	glTexCoord2f(0.0, 1.0);
	glVertex2i(0, 64);
	glTexCoord2f(1.0, 1.0);
	glVertex2i(64, 64);
	glTexCoord2f(1.0, 0.0);
	glVertex2i(64, 0);
    glEnd();

    ReadScreen(0, 0, 64, 64, GL_RGB, workBuf);

    for (i = 0; i < 64; i++) {
	for (j = 0; j < 64; j++) {
	    k = (i * 64 + j) * 3;
	    if (ABS(workBuf[k]-textureBuf[k]) > 2.0 * epsilon.color[0] ||
		ABS(workBuf[k+1]-textureBuf[k+1]) > 2.0 * epsilon.color[1] ||
		ABS(workBuf[k+2]-textureBuf[k+2]) > 2.0 * epsilon.color[2]) {
		StrMake(errStr, errStrFmt, i, j, errEnv, errMagFilter,
			errMinFilter, workBuf[k], workBuf[k+1],
			workBuf[k+2], textureBuf[k], textureBuf[k+1],
			textureBuf[k+2]);
		ErrorReport(__FILE__, __LINE__, errStr);
		FREE(textureBuf);
		FREE(workBuf);
		return ERROR;
	    }
	}
    }

    FREE(textureBuf);
    FREE(workBuf);
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\tproto.h ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

extern long AccumExec(void);
extern long AmbLightExec(void);
extern long AmbMatCIExec(void);
extern long AmbMatRGBExec(void);
extern long AmbSceneExec(void);
extern long APFuncExec(void);
extern long AtnConstCIExec(void);
extern long AtnConstRGBExec(void);
extern long AtnPosCIExec(void);
extern long AtnPosRGBExec(void);
extern long BClearExec(void);
extern long BColorCIExec(void);
extern long BColorRGBExec(void);
extern long BCornerExec(void);
extern long BExactExec(void);
extern long BlendExec(void);
extern long BitmapExec(void);
extern long CopyPixelsExec(void);
extern long ColRampExec(void);
extern long DifLightCIExec(void);
extern long DifLightRGBExec(void);
extern long DifMatCIExec(void);
extern long DifMatRGBExec(void);
extern long DifMatNormCIExec(void);
extern long DifMatNormRGBExec(void);
extern long DifMatPosCIExec(void);
extern long DifMatPosRGBExec(void);
extern long DitherCIExec(void);
extern long DitherRGBExec(void);
extern long DivZeroExec(void);
extern long DisplayListExec(void);
extern long DrawPixelsCIExec(void);
extern long DrawPixelsRGBExec(void);
extern long EmitMatExec(void);
extern long EvalColorExec(void);
extern long EvalVertexExec(void);
extern long FeedbackExec(void);
extern long FogExpCIExec(void);
extern long FogExpRGBExec(void);
extern long FogLinCIExec(void);
extern long FogLinRGBExec(void);
extern long LineAntiAliasExec(void);
extern long LineHVExec(void);
extern long LineRasterExec(void);
extern long LineStippleExec(void);
extern long LogicOpExec(void);
extern long MipLinExec(void);
extern long MipSelectExec(void);
extern long MaskCIExec(void);
extern long MaskRGBExec(void);
extern long MatrixStackExec(void);
extern long MustPassExec(void);
extern long PointAntiAliasExec(void);
extern long PointRasterExec(void);
extern long PolyCullExec(void);
extern long PolyEdgeExec(void);
extern long PolyFaceExec(void);
extern long PolyStippleExec(void);
extern long QuadRasterExec(void);
extern long ScissorExec(void);
extern long SelectExec(void);
extern long SPClearExec(void);
extern long SPCornerExec(void);
extern long SpecExpCIExec(void);
extern long SpecExpRGBExec(void);
extern long SpecExpNormCIExec(void);
extern long SpecExpNormRGBExec(void);
extern long SpecLEHAExec(void);
extern long SpecLightCIExec(void);
extern long SpecLightRGBExec(void);
extern long SpecMatCIExec(void);
extern long SpecMatRGBExec(void);
extern long SpecNormCIExec(void);
extern long SpecNormRGBExec(void);
extern long SPFuncExec(void);
extern long SPOpExec(void);
extern long SpotPosCIExec(void);
extern long SpotPosRGBExec(void);
extern long SpotExpPosCIExec(void);
extern long SpotExpPosRGBExec(void);
extern long SpotExpDirCIExec(void);
extern long SpotExpDirRGBExec(void);
extern long TexBorderColorExec(void);
extern long TexDecalExec(void);
extern long TriAntiAliasExec(void);
extern long TriRasterExec(void);
extern long TriStippleExec(void);
extern long TriTileExec(void);
extern long VertexOrderExec(void);
extern long ViewportClampExec(void);
extern long XFormExec(void);
extern long XFormMixExec(void);
extern long XFormNormalExec(void);
extern long XFormViewportExec(void);
extern long ZBClearExec(void);
extern long ZBFuncExec(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\tristip.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** tristip.c
** Triangle Stipple Test.
**
** Description -
**    Tests triangle stippling, checking if correct fragments are
**    on. To determine which fragments are in the triangle, a
**    reference primitive is drawn with a solid stipple pattern.
**    The same primitive is drawn with a varied stipple pattern,
**    and each fragment is compared with the reference primitive
**    and the stipple bit for that window coordinate.
**    
**    Triangles are drawn using GL_TRIANGLE_STRIP,
**    GL_TRIANGLE_FAN and GL_TRIANGLES.
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer.
**    Color requirements:
**        RGBA or color index mode. 2 colors.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**        Color epsilon.
**    Paths:
**        Allowed = Alpha, Blend, Depth, Fog, Logicop, Shade, Stencil, Stipple.
**        Not allowed = Alias, Dither.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"


static long errEmptyScreen;
static char errStr[240];
static char errStrFmt[] = "Error at location (%d, %d), stipple postion (%d, %d); expecting stipple bit = %d.";


static long TestBuffer(GLfloat *buf, GLfloat *ref, GLubyte *pattern)
{
    GLubyte c;
    long i, j, b, xStip, yStip, bufIndex;

    ReadScreen(0, 0, WINDSIZEX, WINDSIZEY, GL_AUTO_COLOR, buf);

    for (j = 0; j < WINDSIZEY; j++) {
	for (i = 0; i < WINDSIZEX; i++) {
	    xStip = i % 32;
	    yStip = j % 32;

	    /*
	    ** Locate the character within the pattern corresponding to
	    ** the window position, then find the bit within that character
	    ** and determine if it is on.
	    */

	    c = pattern[(yStip*32+xStip)/8];
	    b = (c & (0x1 << (7 - (xStip % 8)))) ? GL_TRUE : GL_FALSE;

	    bufIndex = j * WINDSIZEX + i;
	    if (GL_TRUE == AutoColorCompare(ref[bufIndex], COLOR_ON)) {
		errEmptyScreen = GL_FALSE;
		if (b != AutoColorCompare(buf[bufIndex], COLOR_ON)) {
		    StrMake(errStr, errStrFmt, i, j, xStip, yStip, b);
		    return ERROR;
		}
	    }
	}
    }
    return NO_ERROR;
}

static void SetupData(long primitive, long n, GLfloat *data)
{
    long i;
    GLfloat delta, rad;

    switch (primitive) {
      case GL_TRIANGLE_STRIP:
	for (i = 0; i < n; i += 2) {
	    data[4*i] = i * 100.0 / n;
	    data[4*i+1] = Random(0.0, 50.0);
	    data[4*i+2] = 0.0;
	    data[4*i+3] = 1.0;

	    data[4*i+4] = i * 100.0 / n;
	    data[4*i+5] = Random(50.0, 99.0);
	    data[4*i+6] = 0.0;
	    data[4*i+7] = 1.0;
	}
	break;
      case GL_TRIANGLE_FAN:
	data[0] = 50.0;
	data[1] = 50.0;
	data[2] = 0.0;
	data[3] = 1.0;
	delta = 2.0 * PI / n;

	for (i = 1; i < n; i++) {
	    rad = Random(0.0, 50.0);
	    data[4*i] = data[0] + COS(i*delta) * rad;
	    data[4*i+1] = data[1] + SIN(i*delta) * rad;
	    data[4*i+2] = 0.0;
	    data[4*i+3] = 1.0;
	}
	break;
      case GL_TRIANGLES:
	for (i = 0; i < n; i++) {
	    data[4*i] = Random(0.0, 100.0);
	    data[4*i+1] = Random(0.0, 100.0);
	    data[4*i+2] = Random(0.0, 0.4);
	    data[4*i+3] = Random(0.7, 3.0);
	}
	break;
    }
}

static long TriStippleTest(GLfloat *buf, GLfloat *ref, long n, GLfloat *data,
			   GLenum prim)
{
    static GLubyte pattern[128] = {
        0xAA, 0xAA, 0xAA, 0xAA, 0xCC, 0xCC, 0xCC, 0xCC, 0xE3, 0x8E, 0x38, 0xE3,
        0xF0, 0xF0, 0xF0, 0xF0, 0xF8, 0xE3, 0x0F, 0x8E, 0xFC, 0x0F, 0xC0, 0xFC,
        0xFE, 0x03, 0xFC, 0x07, 0xFF, 0x00, 0xFf, 0x00, 0xFF, 0x00, 0xFF, 0x00,
        0xFE, 0x03, 0xFC, 0x07, 0xFC, 0x0F, 0xC0, 0xFC, 0xF8, 0xE3, 0x0F, 0x8E,
        0xF0, 0xF0, 0xF0, 0xF0, 0xE3, 0x8E, 0x38, 0xE3, 0xCC, 0xCC, 0xCC, 0xCC,
        0xAA, 0xAA, 0xAA, 0xAA, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
        0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
        0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC,
        0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0x0F, 0x0F, 0x0F, 0x0F,
        0x0F, 0x0F, 0x0F, 0x0F, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
        0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F
    };
    static GLubyte fillPattern[128] = {
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
    };
    long i;

    /*
    ** Draw the primitives once with a fill pattern, and save the
    ** results as the reference primitives.
    */
    glPolygonStipple(fillPattern);
    glClear(GL_COLOR_BUFFER_BIT);
    glBegin(prim);
	for (i = 0; i < n; i++) {
	    glVertex4fv(data+4*i);
	}
    glEnd();

    ReadScreen(0, 0, WINDSIZEX, WINDSIZEY, GL_AUTO_COLOR, ref);

    /*
    ** Redraw with an interesting pattern.
    */
    glPolygonStipple(pattern);
    glClear(GL_COLOR_BUFFER_BIT);
    glBegin(prim);
	for (i = 0; i < n; i++) {
	    glVertex4fv(data+4*i);
	}
    glEnd();

    if (TestBuffer(buf, ref, pattern) == ERROR) {
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }
    return NO_ERROR;
}

long TriStippleExec(void)
{
    GLfloat *buf, *ref, data[200];
    long i, n = 12;

    buf = (GLfloat *)MALLOC(WINDSIZEX*WINDSIZEY*sizeof(GLfloat));
    ref = (GLfloat *)MALLOC(WINDSIZEX*WINDSIZEY*sizeof(GLfloat));

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);

    AutoClearColor(COLOR_OFF);
    AutoColor(COLOR_ON);
    glDisable(GL_DITHER);

    glEnable(GL_POLYGON_STIPPLE);
    errEmptyScreen = GL_TRUE;

    /*
    ** Triangle Strips.
    */

    SetupData(GL_TRIANGLE_STRIP, n, data);
    if (TriStippleTest(buf, ref, n, data, GL_TRIANGLE_STRIP) == ERROR) {
	FREE(buf);
	FREE(ref);
	return ERROR;
    }

    /*
    ** Triangle Fans.
    */
    SetupData(GL_TRIANGLE_FAN, n, data);
    if (TriStippleTest(buf, ref, n, data, GL_TRIANGLE_FAN) == ERROR) {
	FREE(buf);
	FREE(ref);
	return ERROR;
    }

    /*
    ** Independent Triangles.
    */
    for (i = 0; i < n; i++) {
	SetupData(GL_TRIANGLES, 3, data);
	if (TriStippleTest(buf, ref, 3, data, GL_TRIANGLES) == ERROR) {
	    FREE(buf);
	    FREE(ref);
	    return ERROR;
	}
    }

    FREE(buf);
    FREE(ref);

    if (errEmptyScreen == GL_TRUE) {
        StrMake(errStr, "%s", "Triangle with opaque stipple did not render.");
	ErrorReport(__FILE__, __LINE__, errStr);
        return ERROR;
    } else {
	return NO_ERROR;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\tritile.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** tritile.c
** Triangle Tiling Test.
**
** Description -
**    Tests the edging of triangles (GL_TRIANGLES,
**    GL_TRIANGLE_FAN, GL_TRIANGLE_STRIP). A series of triangles
**    are drawn and their edges are checked for fragment
**    duplication or dropout. Fragment duplication can be
**    detected with blending.
**
** Error Explanation -
**    Failure occurs if fragment duplication or dropout is
**    detected.
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer.
**    Color requirements:
**        RGBA or color index mode. Full color.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**    Paths:
**        Allowed = Alpha, Blend, Depth, Fog, Logicop, Shade, Stencil, Stipple.
**        Not allowed = Alias, Dither.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"


static long errX, errY;
static char errStr[240];
static char errStrFmt[] = "Triangle primitive is %s. Incorrect triangle edge at (%d, %d).";


static long Test(GLint size, GLfloat *buf)
{
    long i, j, k;

    if (buffer.colorMode == GL_RGB) {
	ReadScreen(0, 0, (GLsizei)size, (GLsizei)size, GL_RGB, buf);
	for (i = 0; i < size; i++) {
	    for (j = 0; j < size; j++) {
		k = (i * size + j) * 3;
		if (ABS(buf[k]-0.5) > epsilon.color[0] ||
		    ABS(buf[k+1]-0.5) > epsilon.color[1] ||
		    ABS(buf[k+2]-0.5) > epsilon.color[2]) {
		    errX = j;
		    errY = i;
		    return ERROR;
		}
	    }
	}
    } else {
	ReadScreen(0, 0, size, size, GL_COLOR_INDEX, buf);
	for (i = 0; i < size; i++) {
	    for (j = 0; j < size; j++) {
		k = i * size + j;
		if (ABS(buf[k]-3.0) > epsilon.ci) {
		    errX = j;
		    errY = i;
		    return ERROR;
		}
	    }
	}
    }
    return NO_ERROR;
}

long TriTileExec(void)
{
    GLfloat *buf;
    GLint size, i;

    buf = (GLfloat *)MALLOC(WINDSIZEX*WINDSIZEY*3*sizeof(GLfloat));

    Ortho2D(0, WINDSIZEX, 0, WINDSIZEY);
    glDisable(GL_DITHER);

    if (buffer.colorMode == GL_RGB) {
	glClearColor(0.0, 0.0, 0.0, 0.0);
	glColor3f(0.5, 0.5, 0.5);
	glEnable(GL_BLEND);
	glBlendFunc(GL_ONE, GL_ONE);
    } else {
	glClearIndex(1);
	glIndexi(2);
	glEnable(GL_LOGIC_OP);
	glLogicOp(GL_XOR);
    }

    size = (machine.pathLevel == 0) ? WINDSIZEX : (GLint)(WINDSIZEX / 8.0);

    glClear(GL_COLOR_BUFFER_BIT);
    glBegin(GL_TRIANGLES);
	for (i = 0; i < size; i++) {
	    glVertex2i(0, i);
	    glVertex2i(size, i);
	    glVertex2i(size, i+1);
	    glVertex2i(0, i);
	    glVertex2i(0, i+1);
	    glVertex2i(size, i+1);
	}
    glEnd();
    if (Test(size, buf) == ERROR) {
	StrMake(errStr, errStrFmt, "GL_TRIANGLES", errX, errY);
	ErrorReport(__FILE__, __LINE__, errStr);
	FREE(buf);
	return ERROR;
    }

    glClear(GL_COLOR_BUFFER_BIT);
    glBegin(GL_TRIANGLE_STRIP);
	for (i = 0; i <= size; i++) {
	    glVertex2i(0, i);
	    glVertex2i(size, i);
	}
    glEnd();
    if (Test(size, buf) == ERROR) {
	StrMake(errStr, errStrFmt, "GL_TRIANGLE_STRIP", errX, errY);
	ErrorReport(__FILE__, __LINE__, errStr);
	FREE(buf);
	return ERROR;
    }

    glClear(GL_COLOR_BUFFER_BIT);
    glBegin(GL_TRIANGLE_FAN);
	glVertex2i(0, 0);
	for (i = 0; i <= size; i++) {
	    glVertex2i(size, i);
	}
	for (i = size-1; i >= 0; i--) {
	    glVertex2i(i, size);
	}
    glEnd();
    if (Test(size, buf) == ERROR) {
	StrMake(errStr, errStrFmt, "GL_TRIANGLE_FAN", errX, errY);
	ErrorReport(__FILE__, __LINE__, errStr);
	FREE(buf);
	return ERROR;
    }

    FREE(buf);
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\vpclamp.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** vpclamp.c
** Viewport Clamp Test.
**
** Description -
**    Test the behavior of glViewport() when bad values are
**    given. Out of range and negative width and height values
**    should be clamped. A negative width or height value should
**    also set an error condition.
**
** Error Explanation -
**    Failure occurs if the implementation fails to clamp out of
**    range viewport values or set an error condition for a
**    negative viewport size.
**
** Technical Specification -
**    Buffer requirements:
**        No buffer requirements.
**    Color requirements:
**        No color requirements.
**    States requirements:
**        No state restrictions.
**    Error epsilon:
**    Paths:
**        Allowed = Alias, Alpha, Blend, Depth, Dither, Fog, Logicop, Shade,
**                  Stencil, Stipple.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"


static char errStr[160];
static char errStrFmt[][80] = {
    "glGetError() did not catch bad viewport width and height values.",
    "Viewport size not clamped to %d, %d."
};


long ViewportClampExec(void)
{
    GLfloat max[2], buf[4];
    long x;

    glGetFloatv(GL_MAX_VIEWPORT_DIMS, max);

    glViewport(-99999, -99999, 99999, 99999);
    x = glGetError();

    glGetFloatv(GL_VIEWPORT, buf);
    if (ABS(buf[2]-max[0]) > epsilon.zero ||
	ABS(buf[3]-max[1]) > epsilon.zero) {
	StrMake(errStr, errStrFmt[1], (long)max[0], (long)max[1]);
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }

    glViewport(0, 0, -99999, -99999);
    if (glGetError() != GL_INVALID_VALUE) {
	ErrorReport(__FILE__, __LINE__, errStrFmt[0]);
	return ERROR;
    }

    glGetFloatv(GL_VIEWPORT, buf);
    if (ABS(buf[2]-max[0]) > epsilon.zero ||
	ABS(buf[3]-max[1]) > epsilon.zero) {
	StrMake(errStr, errStrFmt[1], (long)max[0], (long)max[1]);
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\zbclear.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** zbclear.c
** Depth buffer Clear Test.
**
** Description -
**    A clear to zero and a clear to one is performed on the
**    depth buffer and verified. If depth buffer is not
**    available, a clear to one should behave as a clear to
**    zero.
**
** Technical Specification -
**    Buffer requirements:
**        depth buffer.
**    Color requirements:
**        No color restrictions.
**    States requirements:
**        No state restrictions.
**    Error epsilon:
**    Paths:
**        Allowed = Alias, Alpha, Blend, Dither, Fog, Logicop, Shade, Stencil,
**                  Stipple.
**        Not allowed = Depth.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"


static char errStr[240];
static char errStrFmt[] = "Location (%d, %d). Depth value is %1.1f, should be %1.1f.";


static Test(GLfloat value, GLfloat *buf)
{
    long i, j, k;
    long x;

    ReadScreen(0, 0, WINDSIZEX, WINDSIZEY, GL_DEPTH_COMPONENT, buf);

    if (buffer.zBits == 0) {
	if (glGetError() != GL_INVALID_OPERATION) {
	    return ERROR;
	} else {
	    return NO_ERROR;
	}
    }

    for (i = 0; i < WINDSIZEY; i++) {
	for (j = 0; j < WINDSIZEX; j++) {
	    k = i * WINDSIZEX + j;
	    if (ABS(buf[k]-value) > epsilon.zero) {
		StrMake(errStr, errStrFmt, j, i, buf[k], value);
		ErrorReport(__FILE__, __LINE__, errStr);
		return ERROR;
	    }
	}
    }
    return NO_ERROR;
}

long ZBClearExec(void)
{
    GLfloat *buf;

    buf = (GLfloat *)MALLOC(WINDSIZEX*WINDSIZEY*sizeof(GLfloat));

    Ortho3D(0, WINDSIZEX, 0, WINDSIZEY, 0, -1);

    glClearDepth(0.0);
    glClear(GL_DEPTH_BUFFER_BIT);
    if (Test(0.0, buf) == ERROR) {
	FREE(buf);
	return ERROR;
    }

    glClearDepth(1.0);
    glClear(GL_DEPTH_BUFFER_BIT);
    if (Test(1.0, buf) == ERROR) {
	FREE(buf);
	return ERROR;
    }

    FREE(buf);
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\xformvp.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** xformvp.c
** Viewport Transformation Test.
**
** Description -
**    Tests that viewport computations are correct. The test
**    randomly selects values to define a viewport within the
**    window. A point is drawn with this new viewport and its
**    position in the window is examined.
**
** Error Explanation -
**    An allowance is made for the point position to be off by
**    one pixel in any direction.
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer.
**    Color requirements:
**        RGBA or color index mode. Full color.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**        The routine looks for the transformed point in a 3x3 grid of pixels
**        around the expected location, to allow a margin for matrix
**        operations.
**    Paths:
**        Allowed = Alpha, Blend, Depth, Fog, Logicop, Shade, Stencil, Stipple.
**        Not allowed = Alias, Dither.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"
#include "utilm.h"


static char errStr[240];
static char errStrFmt[] = "Error during test iteration %d, with glViewport parameters x = %d, y = %d, w = %d, h = %d.";


typedef struct _vpDataRec {
    GLint x, y, w, h;
    GLfloat n, f;
} vpDataRec;


static long Compare(long x, long y, GLint index, GLfloat *buf)
{
    long i;

    i = WINDSIZEX * y + x;
    return AutoColorCompare(buf[i], index);
}

static long TestBuf(GLfloat *buf, GLfloat *point)
{
    long i, j;

    i = point[0];
    j = point[1];

    /*
    **  Test the 9 pixels around the target.
    */
    if (!(Compare(i  , j  , COLOR_ON, buf) ||
	  Compare(i-1, j+1, COLOR_ON, buf) ||
          Compare(i  , j+1, COLOR_ON, buf) ||
          Compare(i+1, j+1, COLOR_ON, buf) ||
          Compare(i-1, j  , COLOR_ON, buf) ||
          Compare(i+1, j  , COLOR_ON, buf) ||
          Compare(i-1, j-1, COLOR_ON, buf) ||
          Compare(i  , j-1, COLOR_ON, buf) ||
          Compare(i+1, j-1, COLOR_ON, buf))) {
        return ERROR;
    }
    return NO_ERROR;
}

static void ViewportXForm(GLfloat *point, GLfloat *xformPoint, vpDataRec *data)
{
    double maxZ;
    GLfloat midX, midY, zNear, zFar;

    midX = data->x + data->w / 2.0;
    midY = data->y + data->h / 2.0;

    maxZ = POW(2.0, (double)(buffer.zBits-2)) - 1.0;

    zFar = (GLfloat)(maxZ * (double)data->f);
    zNear = (GLfloat)(maxZ * (double)data->n);
    xformPoint[0] = (data->w / 2.0) * point[0] + midX;
    xformPoint[1] = (data->h / 2.0) * point[1] + midY;
    xformPoint[2] = ((zFar - zNear) / 2.0) * point[2] + (zFar + zNear) / 2.0;
}

long XFormViewportExec(void)
{
    GLfloat *buf;
    vpDataRec data;
    GLfloat point[4], xformPoint[4];
    long flag, max, i;

    buf = (GLfloat *)MALLOC(WINDSIZEX*WINDSIZEY*sizeof(GLfloat));
    flag = NO_ERROR;

    AutoClearColor(COLOR_OFF);
    AutoColor(COLOR_ON);
    glDisable(GL_DITHER);

    max = (machine.pathLevel == 0) ? 20 : 1;
    for (i = 0; i < max; i++) {
	glClear(GL_COLOR_BUFFER_BIT);

	data.x = (GLint)Random(1.1, WINDSIZEX - 2.1);
	data.y = (GLint)Random(1.1, WINDSIZEY - 2.1);
	data.w = (GLint)Random(1.1, WINDSIZEX-data.x);
	data.h = (GLint)Random(1.1, WINDSIZEY-data.y);
	data.n = 0.0;
	data.f = 1.0;

	point[0] = Random(-1.0, 1.0);
	point[1] = Random(-1.0, 1.0);
	point[2] = Random(-1.0, 1.0);
	point[3] = Random(1.0, 10.0);

	glViewport(data.x, data.y, data.w, data.h);

	glBegin(GL_POINTS);
	    glVertex4fv(point);
	glEnd();

	/*
	** Create normalized device coordinates.
	*/
	point[0] /= point[3];
	point[1] /= point[3];
	point[2] /= point[3];

	ReadScreen(0, 0, WINDSIZEX, WINDSIZEY, GL_AUTO_COLOR, buf);

	ViewportXForm(point, xformPoint, &data);
	if (TestBuf(buf, xformPoint) == ERROR) {
	    StrMake(errStr, errStrFmt, i, data.x, data.y, data.w, data.h); 
	    ErrorReport(__FILE__, __LINE__, errStr);
	    flag = ERROR;
	    break;
	}
    }

    FREE(buf);
    return flag;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\xformn.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** xformn.c
** Transform Normal Test.
**
** Description -
**    Tests that the normal vector is correctly multiplied by the
**    inverse of the modelview matrix. To test this, a polygon is
**    drawn with lighting parameters set in such a way that most
**    values drop out and the resulting pixel color is a function
**    of the normal vector.
**    
**    In RGB mode, the equation reduces to c = max(0, n dot VP)
**    and (n dot VP) reduces to cos(theta). In CI mode, the
**    equation reduces to s'sm which becomes cos(theta)sm.
**    
**    The polygon is rotated around various axes. Initially the
**    light is fixed while the polygon rotates. At each rotation,
**    the color of the fragment at the center of the window
**    (position 0, 0, 0) is read and compared with expected
**    results, from the equations above. In the second section,
**    the light source rotated about an axis, always at a
**    distance of 1.0 from the origin. This section is repeated,
**    taking both the light and the primitive through rotations
**    about different axes.
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer.
**    Color requirements:
**        RGBA or color index mode. 2 colors.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**        Color epsilon for RGB, 2*epsilon.ci to allow a full shade.
**    Paths:
**        Allowed = Alpha, Blend, Depth, Fog, Logicop, Shade, Stencil, Stipple.
**        Not allowed = Alias, Dither.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"


static char errStr[240];
static char errStrFmtRGB[] = "Angle between normal and light is %4.2f. Expected color is (%1.2f, %1.2f, %1.2f).";
static char errStrFmtCI[] = "Angle between normal and light is %4.2f. Expected color is %4.1f.";


static long TestNormalRGB(GLfloat angle, GLfloat *buf)
{
    GLfloat cosine;
    long midX, midY, i;

    midX = WINDSIZEX / 2.0;
    midY = WINDSIZEY / 2.0;
   
    i = WINDSIZEX * midY * 3 + midX * 3;
    cosine = COS(angle*PI/180.0);
    cosine = (cosine < 0.0) ? 0.0 : cosine;

    if (ABS(buf[i]-cosine) < epsilon.color[0] &&
	ABS(buf[i+1]-cosine) < epsilon.color[1] &&
	ABS(buf[i+2]-cosine) < epsilon.color[2]) {
	return NO_ERROR;
    }
    StrMake(errStr, errStrFmtRGB, angle, cosine, cosine, cosine);
    return ERROR;
}

static long TestNormalCI(GLfloat angle, GLfloat *buf, long specular)
{
    float cosine;
    long midX, midY, i;
    GLfloat color;

    midX = WINDSIZEX / 2.0;
    midY = WINDSIZEY / 2.0;
   
    i = WINDSIZEX * midY + midX;
    cosine = COS(angle*PI/180.0);
    cosine = (cosine < 0.0) ? 0.0 : cosine;
    color = cosine * specular;

    if (ABS(buf[i]-color) <= 2.0*epsilon.ci) {
	return NO_ERROR;
    }
    StrMake(errStr, errStrFmtCI, angle, color);
    return ERROR;
}

long XFormNormalExec(void)
{
    static GLfloat front_mat_ambient[] = {0.0, 0.0, 0.0, 1.0};
    static GLfloat front_mat_diffuse[] = {1.0, 1.0, 1.0, 1.0};
    static GLfloat front_mat_specular[] = {0.0, 0.0, 0.0, 1.0};
    static GLfloat light0_specular[] = {0.0, 0.0, 0.0, 1.0};
    static GLfloat position[] = {0.0, 0.0, 1.0, 0.0};
    GLfloat *buf;
    GLfloat polyAngle, lightAngle, step;
    GLint i, matCI[3], shine;

    buf = (GLfloat *)MALLOC(WINDSIZEX*WINDSIZEY*3*sizeof(GLfloat));

    glViewport(0, 0, WINDSIZEX, WINDSIZEY);

    SETCLEARCOLOR(BLACK);
    glDisable(GL_DITHER);

    /*
    ** To test value of normal, set lighting equation parameters so that
    ** most values drop out.  In RGB mode, the equation reduces to
    **	    c = max(0, n dot VP)
    **      and (n dot VP) reduces to cos(theta),
    ** where theta is the angle  between the normal and the vector from
    ** the vertex to the light.
    **
    ** In CI mode, the equation reduces to s'sm, which becomes cos(theta)sm.
    ** The reduced CI equation relies up the light position being on the
    ** z-axis, so only the first set of iterations is used.
    */
    if (buffer.colorMode == GL_RGB) {
	glMaterialfv(GL_FRONT, GL_AMBIENT, front_mat_ambient);
	glMaterialfv(GL_FRONT, GL_SPECULAR, front_mat_specular);
	glMaterialfv(GL_FRONT, GL_DIFFUSE, front_mat_diffuse);
    } else {
	matCI[0] = 0;
	matCI[2] = (buffer.ciBits >= 8) ? 255 : ((1 << buffer.ciBits) - 1);
	matCI[1] = (buffer.ciBits >= 8) ? 255 : ((1 << buffer.ciBits) - 1);
	glMaterialiv(GL_FRONT, GL_COLOR_INDEXES, matCI);
	shine = 1;
	glMaterialiv(GL_FRONT, GL_SHININESS, &shine);
	glLightfv(GL_LIGHT0, GL_SPECULAR,light0_specular);
    }

    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);

    /*
    ** Test the normal after rotation by rotating the polygon about the
    ** y-axis and examining the resulting color of at a point on the y-axis.
    */
    step = (machine.pathLevel == 0) ? 12.0 : 45.0;
    for (polyAngle = -89.0; polyAngle < 89.0; polyAngle += step) {
	glClear(GL_COLOR_BUFFER_BIT);

	glPushMatrix();

	glRotatef(polyAngle, 0.0, 1.0, 0.0);
	glBegin(GL_POLYGON);
	    glVertex2f(-0.7, 0.6);
	    glVertex2f(-0.7, -0.6);
	    glVertex2f(0.7, 0.0);
	glEnd();

	glPopMatrix();

	if (buffer.colorMode == GL_RGB) {
	    ReadScreen(0, 0, WINDSIZEX, WINDSIZEY, GL_RGB, buf);
	    if (TestNormalRGB(polyAngle, buf) == ERROR) {
		ErrorReport(__FILE__, __LINE__, errStr);
	 	FREE(buf);
		return ERROR;
	    }
	} else {
	    ReadScreen(0, 0, WINDSIZEX, WINDSIZEY, GL_COLOR_INDEX, buf);
 	    if (TestNormalCI(polyAngle, buf, matCI[2]) == ERROR) {
		ErrorReport(__FILE__, __LINE__, errStr);
		FREE(buf);
		return ERROR;
	    }
	}
    }

    if (buffer.colorMode == GL_COLOR_INDEX) {
	FREE(buf);
	return NO_ERROR;
    }

    /*
    ** Move the light source to locations on a circle of radius one in the xz
    ** plane. Rotate the polygon around the y-axis.
    */
    for (i = 0; i < 4; i++) {
	lightAngle = Random(-89.0, 89.0);
	position[0] = SIN(lightAngle*PI/180.0);
	position[1] = 0.0;
	position[2] = COS(lightAngle*PI/180.0);
	glLightfv(GL_LIGHT0, GL_POSITION, position);

	step = (machine.pathLevel == 0) ? 12.0 : 45.0;
	for (polyAngle = -89.0; polyAngle < 89.0; polyAngle += step) {
	    glClear(GL_COLOR_BUFFER_BIT);

	    glPushMatrix();

	    glRotatef(polyAngle, 0.0, 1.0, 0.0);
	    glBegin(GL_POLYGON);
		glVertex2f(-0.7, 0.6);
		glVertex2f(-0.7, -0.6);
		glVertex2f(0.7, 0.0);
	    glEnd();

	    glPopMatrix();

	    ReadScreen(0, 0, WINDSIZEX, WINDSIZEY, GL_RGB, buf);
	    if (TestNormalRGB(lightAngle-polyAngle, buf) == ERROR) {
		ErrorReport(__FILE__, __LINE__, errStr);
		FREE(buf);
		return ERROR;
	    }
	}
    }

    /*
    ** Move the light source to locations on a circle of radius one in the yz
    ** plane. Rotate the polygon around the x-axis.
    */
    for (i = 0; i < 4; i++) {
	lightAngle = Random(-89.0, 89.0);
	position[0] = 0.0;
	position[1] = -SIN(lightAngle*PI/180.0);
	position[2] = COS(lightAngle*PI/180.0);
	glLightfv(GL_LIGHT0, GL_POSITION, position);

	step = (machine.pathLevel == 0) ? 12.0 : 45.0;
	for (polyAngle = -89.0; polyAngle < 89.0; polyAngle += step) {
	    glClear(GL_COLOR_BUFFER_BIT);

	    glPushMatrix();

	    glRotatef(polyAngle, 1.0, 0.0, 0.0);
	    glBegin(GL_POLYGON);
		glVertex2f(-0.7, 0.7);
		glVertex2f(0.7, 0.7);
		glVertex2f(0.7, -0.7);
		glVertex2f(-0.7, -0.7);
	    glEnd();

	    glPopMatrix();

	    ReadScreen(0, 0, WINDSIZEX, WINDSIZEY, GL_RGB, buf);
	    if (TestNormalRGB(lightAngle-polyAngle, buf) == ERROR) {
		ErrorReport(__FILE__, __LINE__, errStr);
		FREE(buf);
		return ERROR;
	    }
	}
    }

    /*
    ** Repeat the test on a 45 degree axis.
    ** The light is fixed at a distance 1 from the origin, tilted 45 degrees
    ** down in the yz plane. The polygon is a rectangle tilted 45 degrees about
    ** the x-axis, rotating about the (0, 1, 1) axis.
    */
    position[0] = 0.0;
    position[1] = -SIN(45.0*PI/180.0);
    position[2] = COS(45.0*PI/180.0);
    glLightfv(GL_LIGHT0, GL_POSITION, position);

    step = (machine.pathLevel == 0) ? 12.0 : 45.0;
    for (polyAngle = -60.0; polyAngle < 60.0; polyAngle += step) {
	glClear(GL_COLOR_BUFFER_BIT);

	glPushMatrix();

	glRotatef(polyAngle, 0.0, 1.0, 1.0);
	glNormal3fv(position);
	glBegin(GL_POLYGON);
	    glVertex3f(0.5, 0.3, 0.5);
	    glVertex3f(-0.5, 0.3, 0.5);
	    glVertex3f(-0.5, -0.3, -0.5);
	    glVertex3f(0.5, -0.3, -0.5);
	glEnd();

	glPopMatrix();

	ReadScreen(0, 0, WINDSIZEX, WINDSIZEY, GL_RGB, buf);
	if (TestNormalRGB(polyAngle, buf) == ERROR) {
	    ErrorReport(__FILE__, __LINE__, errStr);
	    FREE(buf);
	    return ERROR;
	}
    }

    FREE(buf);
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\xformmix.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** xformmix.c
** Matrix Stack Mixing Test.
**
** Description -
**    Tests that matrix stacks can be mixed. A series of
**    transformations are applied while the matrix mode is
**    switched with each glPushMatrix() and glPopMatrix(). After
**    a series of transformations, a small quad is drawn and its
**    position is checked.
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer.
**    Color requirements:
**        RGBA or color index mode. 2 colors.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**        The routine looks for the transformed point in a 3x3 grid of pixels
**        around the expected location, to allow a margin for matrix
**        operations.
**    Paths:
**        Allowed = Alpha, Blend, Depth, Fog, Logicop, Shade, Stencil, Stipple.
**        Not allowed = Alias, Dither.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"


static char errStr[240];
static char errStrFmt[] = "Tranformation matrix has diagonals set to %2.2f, and internal variable (pattern) for matrices applied is %d.";


static void Make(GLfloat value, GLfloat *buf)
{
    long i;

    for (i = 0; i < 16; i++) {
	buf[i] = 0.0;
    }
    for (i = 0; i < 3; i++) {
	buf[i*4+i] = value;
    }
    buf[15] = 1.0;
}

static long Compare(long x, long y, GLint index, GLfloat *buf)
{
    long i;

    i = WINDSIZEX * y + x;
    return !AutoColorCompare(buf[i], index);
}

static long TestBuffer(long size, GLfloat *buf)
{
    long midX, midY;

    ReadScreen(0, 0, WINDSIZEX, WINDSIZEY, GL_AUTO_COLOR, buf);

    midX = WINDSIZEX / 2.0;
    midY = WINDSIZEY / 2.0;

    if (Compare(midX-size-2, midY-size-2, COLOR_OFF, buf) ||
	Compare(midX-size-2, midY-size+2, COLOR_OFF, buf) ||
	Compare(midX-size+2, midY-size+2, COLOR_ON,  buf) ||
	Compare(midX-size+2, midY-size-2, COLOR_OFF, buf)) {
	return ERROR;
    }
    if (Compare(midX-size-2, midY+size-2, COLOR_OFF, buf) ||
	Compare(midX-size-2, midY+size+2, COLOR_OFF, buf) ||
	Compare(midX-size+2, midY+size+2, COLOR_OFF, buf) ||
	Compare(midX-size+2, midY+size-2, COLOR_ON,  buf)) {
	return ERROR;
    }
    if (Compare(midX+size-2, midY+size-2, COLOR_ON,  buf) ||
	Compare(midX+size-2, midY+size+2, COLOR_OFF, buf) ||
	Compare(midX+size+2, midY+size+2, COLOR_OFF, buf) ||
	Compare(midX+size+2, midY+size-2, COLOR_OFF, buf)) {
	return ERROR;
    }
    if (Compare(midX+size-2, midY-size-2, COLOR_OFF, buf) ||
	Compare(midX+size-2, midY-size+2, COLOR_ON,  buf) ||
	Compare(midX+size+2, midY-size+2, COLOR_OFF, buf) ||
	Compare(midX+size+2, midY-size-2, COLOR_OFF, buf)) {
	return ERROR;
    }

    return NO_ERROR;
}

static long MixAndCompare(long pattern, GLenum *mode, GLfloat *buf)
{
    GLfloat matrix[16], x;

    glClear(GL_COLOR_BUFFER_BIT);

    glMatrixMode(GL_MODELVIEW);
    x = (GLfloat)Random(4.0, 30.0);
    Make(x, matrix);
    glLoadMatrixf(matrix);

    if (pattern & 1) {
	glMatrixMode(mode[0]);
	Make(Random(1.0, 50.0), matrix);
	glPushMatrix();
	glLoadMatrixf(matrix);
    }
    if (pattern & 2) {
	glMatrixMode(mode[1]);
	Make(Random(1.0, 50.0), matrix);
	glPushMatrix();
	glLoadMatrixf(matrix);
    }
    if (pattern & 4) {
	glMatrixMode(mode[2]);
	Make(Random(1.0, 50.0), matrix);
	glPushMatrix();
	glLoadMatrixf(matrix);
    }
    if (pattern & 1) {
	glMatrixMode(mode[0]);
	glPopMatrix();
    }
    if (pattern & 2) {
	glMatrixMode(mode[1]);
	glPopMatrix();
    }
    if (pattern & 4) {
	glMatrixMode(mode[2]);
	glPopMatrix();
    }

    glMatrixMode(GL_MODELVIEW);
    glBegin(GL_QUADS);
	glVertex2f(2.0/WINDSIZEX, 2.0/WINDSIZEY);
	glVertex2f(-2.0/WINDSIZEX, 2.0/WINDSIZEY);
	glVertex2f(-2.0/WINDSIZEX, -2.0/WINDSIZEY);
	glVertex2f(2.0/WINDSIZEX, -2.0/WINDSIZEY);
    glEnd();
    if (TestBuffer(x, buf) == ERROR) {
	StrMake(errStr, errStrFmt, x, pattern);
	return ERROR;
    }

    return NO_ERROR;
}

static long Test(GLenum *mode, GLfloat *buf)
{
    GLfloat matrix[16];
    long i;

    if (machine.pathLevel == 0) {
	for (i = 1; i <= 7; i++) {
	    if (MixAndCompare(i, mode, buf) == ERROR) {
		return ERROR;
	    }
	}
    } else {
	if (MixAndCompare((long)Random(1.0, 7.0), mode, buf) == ERROR) {
	    return ERROR;
	}
    }

    return NO_ERROR;
}

long XFormMixExec(void)
{
    GLfloat *buf;
    GLenum mode[3];

    buf = (GLfloat *)MALLOC(WINDSIZEX*WINDSIZEY*sizeof(GLfloat));

    AutoClearColor(COLOR_OFF);
    AutoColor(COLOR_ON);
    glDisable(GL_DITHER);

    mode[0] = GL_MODELVIEW;
    mode[1] = GL_PROJECTION;
    mode[2] = GL_TEXTURE;
    if (Test(mode, buf) == ERROR) {
	ErrorReport(__FILE__, __LINE__, errStr);
	FREE(buf);
	return ERROR;
    }

    mode[0] = GL_PROJECTION;
    mode[1] = GL_MODELVIEW;
    mode[2] = GL_TEXTURE;
    if (Test(mode, buf) == ERROR) {
	ErrorReport(__FILE__, __LINE__, errStr);
	FREE(buf);
	return ERROR;
    }

    mode[0] = GL_MODELVIEW;
    mode[1] = GL_TEXTURE;
    mode[2] = GL_PROJECTION;
    if (Test(mode, buf) == ERROR) {
	ErrorReport(__FILE__, __LINE__, errStr);
	FREE(buf);
	return ERROR;
    }

    mode[0] = GL_TEXTURE;
    mode[1] = GL_PROJECTION;
    mode[2] = GL_MODELVIEW;
    if (Test(mode, buf) == ERROR) {
	ErrorReport(__FILE__, __LINE__, errStr);
	FREE(buf);
	return ERROR;
    }

    FREE(buf);
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\xform.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** xform.c
** Transform Test.
**
** Description -
**    Tests glRotate(), glScale() and glTranslate(). A single
**    point is drawn under various transformations and its new
**    position checked. The order of matrix multiplication is
**    also checked by executing pairs of rotates and translates.
**    The test also verifies that no assumption of matrix mode
**    GL_PROJECTION are tied to glOrtho() and glFrustum(); they
**    should be applied with the current matrix mode. Similarly,
**    glRotate(), glTranslate() and glScale() should not assume
**    GL_MODELVIEW.
**    
**    The sections of the test contain the following:
**    
**        Tests single tranformations. In each iteration of a loop,
**        creates either a translation, rotation, or scale call using
**        random data then checks resulting point location.
**    
**        Tests the order of matrix multiplications.
**        Calls a translation then a scale, checks results,
**        then calls a scale followed by a translation and
**        checks results.
**    
**        Test that glOrtho() and glFrustum() do not assume
**        GL_PROJECTION transformation. In GL_MODELVIEW mode, make
**        calls to glOrtho() and glFrumtum(). Check that glGet()
**        returns tranformed GL_MODELVIEW matrix. Check that
**        glGet() shows GL_PROJECTION is still identity. For
**        glOrtho(), overwrite GL_PROJECTION matrix identity and
**        verify the point drawn correctly demonstrates the
**        GL_MODELVIEW transform.
**    
**        Test that glScale(), glTranlate() and glRotate() do not
**        assume GL_MODELVIEW transformation. In GL_PROJECTION
**        mode, make calls to translate, rotate and scale. Check
**        that Get returns proper GL_PROJECTION matrix. Check that
**        Get shows GL_MODELVIEW matrix is still identity. For each
**        transformation, overwrite GL_MODELVIEW matrix with
**        identity and verify that the drawn point demonstrates new
**        GL_PROJECTION matrix.
**
** Error Explanation -
**    Since values may fall on pixel boundaries, and
**    transformations have numerical error, allowance is made for
**    pixel to be off by one in any direction from expected
**    location.
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer.
**    Color requirements:
**        RGBA or color index mode. 2 colors.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**        The routine looks for the transformed point in a 3x3 grid of pixels
**        around the expected location, to allow a margin for matrix
**        operations.
**    Paths:
**        Allowed = Alpha, Blend, Depth, Fog, Logicop, Shade, Stencil, Stipple.
**        Not allowed = Alias, Dither.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"
#include "utilm.h"


static char errStr[240];
static char errStrFmt[] = "Original point at (%1.2f, %1.2f), transformed point expected at (%1.2f, %1.2f).";


long XFormExec(void)
{
    static GLfloat xformData[3][4] = {
	0.1, 0.2, 0.0, 0.0,  /* translate */
	3.0, 2.0, 1.0, 0.0,  /* scale     */
	0.0, 0.0, 1.0, 37.0  /* rotate    */
    };
    GLfloat *buf;
    xFormRec data, translateData, scaleData;
    GLfloat matrix[4][4], tMatrix[4][4], iMatrix[4][4];
    GLfloat point[4], xFormPoint[4], info[13];
    GLfloat primWidth, midX, midY;
    long i, type, max;

    buf = (GLfloat *)MALLOC(WINDSIZEX*WINDSIZEY*sizeof(GLfloat));

    AutoClearColor(COLOR_OFF);
    AutoColor(COLOR_ON);
    glDisable(GL_DITHER);

    glMatrixMode(GL_MODELVIEW);

    primWidth = 2.0 / WINDSIZEX;
    midX = WINDSIZEX / 2.0;
    midY = WINDSIZEY / 2.0;

    /*
    ** Test position of point after various transformations.
    */

    point[0] = Random(-0.25, 0.25);
    point[1] = Random(-0.25, 0.25);
    point[2] = 0.0;
    point[3] = 1.0;

    max = (machine.pathLevel == 0) ? 40 : 2;
    for (i = 1; i < max; i++) {
	glClear(GL_COLOR_BUFFER_BIT);

	glPushMatrix();

	XFormMake(&type, &data);
	if (XFormValid(type, &data) == ERROR) {
	    continue;
	}
	XFormCalcGL(type, &data);

	glBegin(GL_POINTS);
	    glVertex2fv(point);
	glEnd();

	glPopMatrix();

	ReadScreen(0, 0, WINDSIZEX, WINDSIZEY, GL_AUTO_COLOR, buf);

	XFormCalcTrue(type, &data, point, xFormPoint);

	if (XFormTestBuf(buf, xFormPoint, COLOR_ON, GL_POINT) == ERROR) {
	    StrMake(errStr, errStrFmt, point[0], point[1],
	            xFormPoint[0], xFormPoint[1]);
	    ErrorReport(__FILE__, __LINE__, errStr);
	    FREE(buf);
	    return ERROR;
	}
    }

    /*
    ** Test order of matrix multiplication.
    */

    glClear(GL_COLOR_BUFFER_BIT);

    glPushMatrix();

    point[0] = primWidth;
    point[1] = primWidth;

    translateData.x = 10.0 * primWidth;
    translateData.y = 10.0 * primWidth;
    translateData.z = 0.0;
    XFormCalcGL(XFORM_TRANSLATE, &translateData);

    scaleData.x = 1.0;
    scaleData.y = 2.0;
    scaleData.z = 1.0;
    XFormCalcGL(XFORM_SCALE, &scaleData);

    glBegin(GL_POINTS);
	glVertex2fv(point);
    glEnd();

    glPopMatrix();

    ReadScreen(0, 0, WINDSIZEX, WINDSIZEY, GL_AUTO_COLOR, buf);
    XFormCalcTrue(XFORM_SCALE, &scaleData, point, xFormPoint);
    XFormCalcTrue(XFORM_TRANSLATE, &translateData, xFormPoint, xFormPoint);
    if (XFormTestBuf(buf, xFormPoint, COLOR_ON, GL_POINT) == ERROR) {
	StrMake(errStr, errStrFmt, point[0], point[1],
		xFormPoint[0], xFormPoint[1]);
	ErrorReport(__FILE__, __LINE__, errStr);
	FREE(buf);
	return ERROR;
    }

    glClear(GL_COLOR_BUFFER_BIT);

    glPushMatrix();

    point[0] = primWidth;
    point[1] = primWidth;

    scaleData.x = 1.0;
    scaleData.y = 2.0;
    scaleData.z = 1.0;
    XFormCalcGL(XFORM_SCALE, &scaleData);

    translateData.x = 10.0 * primWidth;
    translateData.y = 10.0 * primWidth;
    translateData.z = 0.0;
    XFormCalcGL(XFORM_TRANSLATE, &translateData);

    glBegin(GL_POINTS);
	glVertex2fv(point);
    glEnd();

    glPopMatrix();

    ReadScreen(0, 0, WINDSIZEX, WINDSIZEY, GL_AUTO_COLOR, buf);
    XFormCalcTrue(XFORM_TRANSLATE, &translateData, point, xFormPoint);
    XFormCalcTrue(XFORM_SCALE, &scaleData, xFormPoint, xFormPoint);
    if (XFormTestBuf(buf, xFormPoint, COLOR_ON, GL_POINT) == ERROR) {
	StrMake(errStr, errStrFmt, point[0], point[1],
		xFormPoint[0], xFormPoint[1]);
	ErrorReport(__FILE__, __LINE__, errStr);
	FREE(buf);
	return ERROR;
    }

    /*
    ** Make sure that Ortho and Frustum do not assume PROJECTION transformation:
    ** - Check that Get returns tranformed ModelView matrix.
    ** - Check that Get shows Projection is still identity.
    ** - For Ortho, overwrite Projection matrix identity and verify
    **   the point drawn correctly demonstrates the ModelView transform.
    */

    glClear(GL_COLOR_BUFFER_BIT);

    MakeIdentMatrix((GLfloat *)iMatrix);
    glMatrixMode(GL_MODELVIEW);
    glLoadMatrixf((GLfloat *)iMatrix);

    glPushMatrix();

    data.d1 = 33.0;
    data.d2 = 7.0;
    data.d3 = 40.0;

    XFormCalcGL(XFORM_ORTHO, &data);

    glGetFloatv(GL_PROJECTION_MATRIX, (GLfloat *)matrix);
    if (XFormCompareMatrix((GLfloat *)matrix, (GLfloat *)iMatrix) == ERROR) {
	ErrorReport(__FILE__, __LINE__, errStr);
	FREE(buf);
	return ERROR;
    }

    glGetFloatv(GL_MODELVIEW_MATRIX, (GLfloat *)matrix);
    XFormMakeMatrix(XFORM_ORTHO, &data, (GLfloat *)tMatrix);
    if (XFormCompareMatrix((GLfloat *)matrix, (GLfloat *)tMatrix) == ERROR) {
	ErrorReport(__FILE__, __LINE__, errStr);
	FREE(buf);
	return ERROR;
    }

    glMatrixMode(GL_PROJECTION);
    glLoadMatrixf((GLfloat *)iMatrix);

    glBegin(GL_POINTS);
	glVertex2fv(point);
    glEnd();

    ReadScreen(0, 0, WINDSIZEX, WINDSIZEY, GL_AUTO_COLOR, buf);
    XFormCalcTrue(XFORM_ORTHO, &data, point, xFormPoint);
    if (XFormTestBuf(buf, xFormPoint, COLOR_ON, GL_POINT) == ERROR) {
	StrMake(errStr, errStrFmt, point[0], point[1],
		xFormPoint[0], xFormPoint[1]);
	ErrorReport(__FILE__, __LINE__, errStr);
	FREE(buf);
	return ERROR;
    }

    glMatrixMode(GL_MODELVIEW);

    glPopMatrix();
    glPushMatrix();

    data.d1 = -4.0;
    data.d2 = 3.0;
    data.d3 = -1.0;
    data.d4 = 3.0;
    data.d5 = 1.0;
    data.d6 = 6.0;

    XFormCalcGL(XFORM_FRUSTUM, &data);
    glGetFloatv(GL_PROJECTION_MATRIX, (GLfloat *)matrix);
    if (XFormCompareMatrix((GLfloat *)matrix, (GLfloat *)iMatrix) == ERROR) {
	ErrorReport(__FILE__, __LINE__, errStr);
	FREE(buf);
	return ERROR;
    }

    glGetFloatv(GL_MODELVIEW_MATRIX, (GLfloat *)matrix);
    XFormMakeMatrix(XFORM_FRUSTUM, &data, (GLfloat *)tMatrix);
    if (XFormCompareMatrix((GLfloat *)matrix, (GLfloat *)tMatrix) == ERROR) {
	ErrorReport(__FILE__, __LINE__, errStr);
	FREE(buf);
	return ERROR;
    }
    glPopMatrix();

    /*
    ** Make sure Scale, Tranlate and Rotate do not assume MODELVIEW
    ** transformation:
    ** - Check that Get returns proper Projection matrix.
    ** - Check that Get shows ModelView matrix is still identity.
    ** - For each transformation, overwrite ModelView matrix with identity
    **   and verify that the drawn point demonstrates new Projection matrix.
    */
   
    for (type = XFORM_TRANSLATE; type < XFORM_ORTHO; type++) {
	glClear(GL_COLOR_BUFFER_BIT);

	glMatrixMode(GL_PROJECTION);
	glPushMatrix();

	data.x = xformData[type][0];
	data.y = xformData[type][1];
	data.z = xformData[type][2];
	data.angle = xformData[type][3];

	XFormCalcGL(type, &data);

	glGetFloatv(GL_MODELVIEW_MATRIX, (GLfloat *)matrix);
	if (XFormCompareMatrix((GLfloat *)matrix, (GLfloat *)iMatrix) == ERROR) {
	    ErrorReport(__FILE__, __LINE__, errStr);
	    FREE(buf);
	    return ERROR;
	}

	glGetFloatv(GL_PROJECTION_MATRIX, (GLfloat *)matrix);
	XFormMakeMatrix(type, &data, (GLfloat *)tMatrix);
	if (XFormCompareMatrix((GLfloat *)matrix, (GLfloat *)tMatrix) == ERROR) {
	    ErrorReport(__FILE__, __LINE__, errStr);
	    FREE(buf);
	    return ERROR;
	}

	glMatrixMode(GL_MODELVIEW);
	glLoadMatrixf((GLfloat *)iMatrix);

	glBegin(GL_POINTS);
	    glVertex2fv(point);
	glEnd();

	ReadScreen(0, 0, WINDSIZEX, WINDSIZEY, GL_AUTO_COLOR, buf);
	XFormCalcTrue(type, &data, point, xFormPoint);
	if (XFormTestBuf(buf, xFormPoint, COLOR_ON, GL_POINT) == ERROR) {
	    StrMake(errStr, errStrFmt, point[0], point[1],
		    xFormPoint[0], xFormPoint[1]);
	    ErrorReport(__FILE__, __LINE__, errStr);
	    FREE(buf);
	    return ERROR;
	}

	glMatrixMode(GL_PROJECTION);
	glPopMatrix();
    }

    glMatrixMode(GL_MODELVIEW);

    FREE(buf);
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\confshel\conform.h ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#ifdef NT

// Added these pragmas to suppress OGLCFM warnings.
//
#pragma warning(disable : 4136)  //PPC  (conversion between floating types)
#pragma warning(disable : 4005)  //Mips (macro redefinition)
#pragma warning(disable : 4018)  //Mips (signed/unsigned mismatch)
#pragma warning(disable : 4101)  //Mips (unrefed local var)
#pragma warning(disable : 4244)  //Mips (conversion of double/float)
#pragma warning(disable : 4245)  //Mips (conversion of signed/unsigned)
#pragma warning(disable : 4007)  //x86  (main must be _cdecl)
#pragma warning(disable : 4236)  //x86
#pragma warning(disable : 4051)  //Alpha

#endif


#define WINDSIZEX 100
#define WINDSIZEY 100

#define GL_NULL 101001		/* secret enum. */
#define GL_AUTO_COLOR 101002    /* secret enum. */

enum {
    BLACK = 0,
    RED,
    GREEN,
    BLUE
};

#define COLOR_OFF 0     /* should be black. */
#define COLOR_ON 2      /* should be green (doublebuffer Indigo = 1,2,1). */

#define NO_ERROR 0
#define ERROR -1

#define PI 3.14159265358979323846


typedef struct _applRecRec {
    char title[80], name[80], version[80];
} applRec;

typedef struct _machineRec {
    unsigned int randSeed;
    long pathLevel, verboseLevel, stateCheckFlag, failMode;
} machineRec;

typedef struct _bufferRec {
    GLint visualID, render;
    GLint colorMode, doubleBuf, auxBuf, stereoBuf;
    GLint colorBits[4], ciBits, zBits, stencilBits, accumBits[4];
    GLint minIndex, maxIndex;
    GLfloat minRGB[3], maxRGB[3];
    GLint minRGBBit, maxRGBBit, maxRGBComponent;
} bufferRec;

typedef struct _epsilonRec {
    GLfloat color[4], ci, z, stencil, accum[4];
    GLfloat zero;
} epsilonRec;


extern applRec appl;
extern machineRec machine;
extern bufferRec buffer;
extern epsilonRec epsilon;
extern GLfloat colorMap[][3];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\conform\zbfunc.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** zbfunc.c
** Depth Buffer Function Test.
**
** Description -
**    Each depth function is tested by initializing the depth
**    buffer to known values (with the depth function set to
**    GL_ALWAYS, three points are drawn with vertices (0.0, 0.0,
**    0.5), (1.0, 0.0, 0.5) and (2.0, 0.0, 0.5)), drawing three
**    points with different z values (the first point has vertex
**    (0.0, 0.0, 0.0), the second point has vertex (1.0, 0.0,
**    0.5) and the third point has vertex of (2.0, 0.0, 1.0)) and
**    comparing the rendered result to the expected result. The
**    initialization of the depth buffer was done this way to
**    avoid floating point inaccuracies.
**
** Technical Specification -
**    Buffer requirements:
**        Color buffer, depth buffer.
**    Color requirements:
**        RGBA or color index mode. 2 colors.
**    States requirements:
**        Disabled = GL_DITHER.
**    Error epsilon:
**    Paths:
**        Allowed = Alpha, Blend, Fog, Logicop, Shade, Stencil, Stipple.
**        Not allowed = Alias, Dither, Depth.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"


static long errPattern[3];
static char errStr[320];
static char errStrFmt[] = "The behavior of the depth function %s is not correct. The depth value of the test points are 0.0, 0.5, 1.0. The reference depth value is 0.5. The test points pattern is %s, %s, %s, should be %s.\n";


static void DrawRead(GLenum op, GLfloat *buf)
{

    glDepthFunc(GL_ALWAYS);
    AutoColor(COLOR_OFF);
    glBegin(GL_POINTS);
	glVertex3f(0.5, 0.5, 0.5);
	glVertex3f(1.5, 0.5, 0.5);
	glVertex3f(2.5, 0.5, 0.5);
    glEnd();

    glDepthFunc(op);
    AutoColor(COLOR_ON);
    glBegin(GL_POINTS);
	glVertex3f(0.5, 0.5, 0.0);
	glVertex3f(1.5, 0.5, 0.5);
	glVertex3f(2.5, 0.5, 1.0);
    glEnd();

    ReadScreen(0, 0, 3, 1, GL_AUTO_COLOR, buf);
}

static long Test(long a, long b, long c, GLfloat *buf)
{
    long i;

    for (i = 0; i < 3; i++) {
	if (AutoColorCompare(buf[i], COLOR_OFF) == GL_TRUE) {  /* no color. */
	    errPattern[i] = GL_FALSE;
	} else {                                               /* color. */
	    errPattern[i] = GL_TRUE;
	}
    }

    if (a == GL_TRUE) {     /* should have color. */
	if (AutoColorCompare(buf[0], COLOR_OFF) == GL_TRUE) {  /* no color. */
	    return ERROR;
	}
    } else {             /* should not have color. */
	if (AutoColorCompare(buf[0], COLOR_ON) == GL_TRUE) {   /* color. */
	    return ERROR;
	}
    }

    if (b == GL_TRUE) {     /* should have color. */
	if (AutoColorCompare(buf[1], COLOR_OFF) == GL_TRUE) {  /* no color. */
	    return ERROR;
	}
    } else {             /* should not have color. */
	if (AutoColorCompare(buf[1], COLOR_ON) == GL_TRUE) {   /* color. */
	    return ERROR;
	}
    }

    if (c == GL_TRUE) {     /* should have color. */
	if (AutoColorCompare(buf[2], COLOR_OFF) == GL_TRUE) {  /* no color. */
	    return ERROR;
	}
    } else {             /* should not have color. */
	if (AutoColorCompare(buf[2], COLOR_ON) == GL_TRUE) {   /* color. */
	    return ERROR;
	}
    }

    return NO_ERROR;
}

static void MakeErrorStr(char *funcName, char *result)
{

    StrMake(errStr, errStrFmt, funcName,
	    (errPattern[0] == GL_TRUE) ? "DRAWN" : "NOT-DRAWN",
	    (errPattern[1] == GL_TRUE) ? "DRAWN" : "NOT-DRAWN",
	    (errPattern[2] == GL_TRUE) ? "DRAWN" : "NOT-DRAWN", result);
}

long ZBFuncExec(void)
{
    GLfloat buf[3];

    Ortho3D(0, WINDSIZEX, 0, WINDSIZEY, 0.5, -1.5);

    glDisable(GL_DITHER);
    glEnable(GL_DEPTH_TEST);

    DrawRead(GL_ALWAYS, buf);
    if (Test(GL_TRUE, GL_TRUE, GL_TRUE, buf) == ERROR) {
	MakeErrorStr("GL_ALWAYS", "DRAWN, DRAWN, DRAWN");
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }

    DrawRead(GL_NEVER, buf);
    if (buffer.zBits == 0) {
	if (Test(GL_TRUE, GL_TRUE, GL_TRUE, buf) == ERROR) {
	    MakeErrorStr("GL_NEVER", "NOT-DRAWN, NOT-DRAWN, NOT-DRAWN");
	    ErrorReport(__FILE__, __LINE__, errStr);
	    return ERROR;
	}
	return NO_ERROR;
    } else {
	if (Test(GL_FALSE, GL_FALSE, GL_FALSE, buf) == ERROR) {
	    MakeErrorStr("GL_NEVER", "DRAWN, DRAWN, DRAWN");
	    ErrorReport(__FILE__, __LINE__, errStr);
	    return ERROR;
	}
    }

    DrawRead(GL_LESS, buf);
    if (Test(GL_TRUE, GL_FALSE, GL_FALSE, buf) == ERROR) {
	MakeErrorStr("GL_LESS", "DRAWN, NOT-DRAWN, NOT-DRAWN");
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }

    DrawRead(GL_LEQUAL, buf);
    if (Test(GL_TRUE, GL_TRUE, GL_FALSE, buf) == ERROR) {
	MakeErrorStr("GL_LEQUAL", "DRAWN, DRAWN, NOT-DRAWN");
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }

    DrawRead(GL_GREATER, buf);
    if (Test(GL_FALSE, GL_FALSE, GL_TRUE, buf) == ERROR) {
	MakeErrorStr("GL_GREATER", "NOT-DRAWN, NOT-DRAWN, DRAWN");
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }

    DrawRead(GL_GEQUAL, buf);
    if (Test(GL_FALSE, GL_TRUE, GL_TRUE, buf) == ERROR) {
	MakeErrorStr("GL_GEQUAL", "NOT-DRAWN, DRAWN, DRAWN");
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }

    DrawRead(GL_EQUAL, buf);
    if (Test(GL_FALSE, GL_TRUE, GL_FALSE, buf) == ERROR) {
	MakeErrorStr("GL_EQUAL", "NOT-DRAWN, DRAWN, NOT-DRAWN");
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }

    DrawRead(GL_NOTEQUAL, buf);
    if (Test(GL_TRUE, GL_FALSE, GL_TRUE, buf) == ERROR) {
	MakeErrorStr("GL_NOTEQUAL", "DRAWN, NOT-DRAWN, DRAWN");
	ErrorReport(__FILE__, __LINE__, errStr);
	return ERROR;
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\confshel\driver.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"
#include "utils.h"
#include "pathdata.h"
#include "path.h"
#include "driver.h"


static long testList[1000];


static long FindTestIndex(char *id)
{
    long i;

    for (i = 0; !STREQ(driver[i].name, "End of List"); i++) {
	if (STREQ(driver[i].id, id)) {
	    return i;
	}
    }
    return -1;
}

void DriverInit(void)
{
    long i;

    for (i = 0; !STREQ(driver[i].name, "End of List"); i++) {
	testList[i] = i;
    }
    testList[i] = GL_NULL;
}

long DriverSetup1(char *id)
{
    long index;

    index = FindTestIndex(id);
    if (index == -1) {
	return ERROR;
    } else {
	testList[0] = index;
	testList[1] = GL_NULL;
	return NO_ERROR;
    }
}

long DriverSetup2(char *fileName)
{
    FILE *file;
    char buf[82];
    long index, i;

    file = fopen(fileName, "r");
    if (file != NULL) {
	i = 0;
	while (!feof(file)) {
	    fscanf(file, "%[^\n]", buf);
	    if (buf[0] != '#') {
		index = FindTestIndex(buf);
		if (index == -1) {
		    fclose(file);
		    return ERROR;
		} else {
		    testList[i++] = index;
		}
	    }
	    fscanf(file, "%[\n]", buf);
	}
	testList[i] = GL_NULL;
	fclose(file);
	return NO_ERROR;
    } else {
	return ERROR;
    }
}

static long CheckColor(long requirement)
{
    long bitsNeeded = 0;

    switch (requirement) {
      case COLOR_NONE:
	bitsNeeded = 0;
	break;
      case COLOR_AUTO:
	bitsNeeded = 1;
	break;
      case COLOR_MIN:
	bitsNeeded = 2;
	break;
      case COLOR_FULL:
	bitsNeeded = 3;
	break;
    }
    if (buffer.colorMode == GL_RGB) {
	if (buffer.maxRGBBit >= bitsNeeded) {
	    return GL_TRUE;
	} else {
	    return GL_FALSE;
	}
    } else {
	if (buffer.ciBits >= bitsNeeded) {
	    return GL_TRUE;
	} else {
	    return GL_FALSE;
	}
    }
}

static long DriverExec(long (*Func)(void))
{
    long x;
    char buf[40];

    if ((*Func)() == ERROR) {
	while ((x = glGetError()) != GL_NO_ERROR) {
	    GetEnumName(x, buf);
	    Output(2, "    GL Error - %s.\n", buf);
	}
	return ERROR_TEST;
    } else {
	if (GLErrorReport() == ERROR) {
	    return ERROR_GL;
	} else {
	    return NO_ERROR;
	}
    }
}

void Driver(void)
{
    driverRec *ptr;
    long error, pass, index, i;

    if (machine.stateCheckFlag == GL_TRUE) {
	Output(1, "Default State test");
	error = StateCheck();
	if (StateInit() == ERROR) {
	    error |= ERROR_STATE;
	}

	if (error == NO_ERROR) {
	    Output(1, " passed.\n");
	} else {
	    Output(1, " failed.\n");
	    StateReport();
	    Output(1, "Cannot continue until default state test passes.\n\n");
	    Output(0, "%s failed.\n", appl.name);
	    return;
	}
    }

    pass = INDIFFERENT;
    for (ptr = &driver[0]; !STREQ(ptr->name, "End of List"); ptr++) {
	ptr->error = NO_ERROR;
    }

    for (index = 0; testList[index] != GL_NULL; index++) {
	ptr = &driver[testList[index]];
	Output(1, "%s test", ptr->name);

	if (CheckColor(ptr->colorRequirement) == GL_FALSE) {
	    Output(1, " cannot run for current visual.\n");
	} else if (buffer.colorMode == GL_RGB && ptr->TestRGB == NO_TEST) {
	    Output(1, " does not exist for an RGB visual.\n");
	} else if (buffer.colorMode == GL_COLOR_INDEX &&
		   ptr->TestCI == NO_TEST) {
	    Output(1, " does not exist for a color index visual.\n");
	} else {
	    RANDSEED(machine.randSeed);
	    switch (machine.pathLevel) {
	      case 0:
		StateSave();
		if (buffer.colorMode == GL_RGB) {
		    error = DriverExec(ptr->TestRGB);
		} else {
		    error = DriverExec(ptr->TestCI);
		}
		error |= StateReset();
		break;
	      case 1:
		StateSave();
		PathInit1(ptr->pathMask);
		if (buffer.colorMode == GL_RGB) {
		    error = DriverExec(ptr->TestRGB);
		} else {
		    error = DriverExec(ptr->TestCI);
		}
		error |= StateReset();
		break;
	      case 2:
		for (i = 0; i < PATH_TOTAL; i++) {
		    StateSave();
		    PathInit2(i, ptr->pathMask);
		    if (buffer.colorMode == GL_RGB) {
			error = DriverExec(ptr->TestRGB);
		    } else {
			error = DriverExec(ptr->TestCI);
		    }
		    error |= StateReset();
		    if (error != NO_ERROR) {
			break;
		    }
		}
		break;
	      case 3:
		for (i = 0; i < PATH_TOTAL; i++) {
		    StateSave();
		    PathInit3(i, ptr->pathMask);
		    if (buffer.colorMode == GL_RGB) {
			error = DriverExec(ptr->TestRGB);
		    } else {
			error = DriverExec(ptr->TestCI);
		    }
		    error |= StateReset();
		    if (error != NO_ERROR) {
			break;
		    }
		}
		break;
	      case 4:
		StateSave();
		PathInit4();
		if (buffer.colorMode == GL_RGB) {
		    error = DriverExec(ptr->TestRGB);
		} else {
		    error = DriverExec(ptr->TestCI);
		}
		error |= StateReset();
		break;
	    }
	    if (error == NO_ERROR) {
		if (pass == INDIFFERENT) {
		    pass = GL_TRUE;
		}
		Output(1, " passed.\n");
	    } else if (error & ERROR_STATE) {
		if (error == ERROR_STATE) {
		    Output(1, " passed.\n");
		}
		Output(1, "\nState not restored to default condition.\n");
		StateReport();
		Output(1, "Cannot continue until state is reset.\n");
		pass = GL_FALSE;
		break;
	    } else {
		pass = GL_FALSE;
		ptr->error = ERROR;
	    }
	}
    }

    Output(1, "\n");

    if (pass == GL_TRUE) {
	Output(0, "%s passed.\n", appl.name);
    } else if (pass == GL_FALSE) {
	Output(0, "%s failed.\n", appl.name);
    } else {
	Output(0, "%s subset passed.\n", appl.name);
    }

    for (index = 0; testList[index] != GL_NULL; index++) {
	ptr = &driver[testList[index]];
	if (ptr->error == ERROR) {
	    Output(0, "    %s test (Test number #%d) failed.\n", ptr->name, ptr->number);
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\confshel\driver.h ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#define NO_TEST 0
#define INDIFFERENT (GL_TRUE+1)
#define ERROR_TEST  1
#define ERROR_GL    2
#define ERROR_STATE 4

enum {
    COLOR_NONE = 1,     /* no color needed. */
    COLOR_AUTO,         /* 2 colors needed. */
    COLOR_MIN,          /* 4 colors needed. */
    COLOR_FULL          /* full color range. */
};


typedef struct _driverRec {
    char name[80], id[16];
    long number;
    long (*TestRGB)(void), (*TestCI)(void);
    long colorRequirement;
    unsigned long pathMask;
    long error;
} driverRec;


extern driverRec driver[];


extern void Driver(void);
extern void DriverInit(void);
extern long DriverSetup1(char *);
extern long DriverSetup2(char *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\confshel\pathdata.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "pathdata.h"


/*****************************************************************************/

aliasPathCustomRec aliasPath0 = {
    PATHTEST_DEFAULT
};

aliasPathCustomRec aliasPath1 = {
    PATHTEST_GARBAGE
};

aliasPathCustomRec aliasPath2 = {
    PATHTEST_CUSTOM,
    PATHDATA_ENABLE
};

/*****************************************************************************/

alphaPathCustomRec alphaPath0 = {
    PATHTEST_DEFAULT
};

alphaPathCustomRec alphaPath1 = {
    PATHTEST_GARBAGE
};

alphaPathCustomRec alphaPath2 = {
    PATHTEST_CUSTOM,
    PATHDATA_ENABLE,
    GL_GEQUAL,
    0.0
};

/*****************************************************************************/

blendPathCustomRec blendPath0 = {
    PATHTEST_DEFAULT
};

blendPathCustomRec blendPath1 = {
    PATHTEST_GARBAGE
};

blendPathCustomRec blendPath2 = {
    PATHTEST_CUSTOM,
    PATHDATA_ENABLE,
    GL_ONE, GL_ZERO
};

/*****************************************************************************/

depthPathCustomRec depthPath0 = {
    PATHTEST_DEFAULT
};

depthPathCustomRec depthPath1 = {
    PATHTEST_GARBAGE
};

depthPathCustomRec depthPath2 = {
    PATHTEST_CUSTOM,
    PATHDATA_ENABLE,
    0.0,
    0.0, 1.0,
    GL_ALWAYS
};

/*****************************************************************************/

ditherPathCustomRec ditherPath0 = {
    PATHTEST_DEFAULT
};

ditherPathCustomRec ditherPath1 = {
    PATHTEST_GARBAGE
};

ditherPathCustomRec ditherPath2 = {
    PATHTEST_CUSTOM,
    PATHDATA_DISABLE
};

/*****************************************************************************/

fogPathCustomRec fogPath0 = {
    PATHTEST_DEFAULT
};

fogPathCustomRec fogPath1 = {
    PATHTEST_GARBAGE
};

fogPathCustomRec fogPath2 = {
    PATHTEST_DEFAULT,
    PATHDATA_ENABLE,
    1.0, 1.0, 1.0, 1.0,
    0.0,
    0.0,
    0.0, 1.0,
    GL_EXP2
};

/*****************************************************************************/

logicOpPathCustomRec logicOpPath0 = {
    PATHTEST_DEFAULT
};

logicOpPathCustomRec logicOpPath1 = {
    PATHTEST_GARBAGE
};

logicOpPathCustomRec logicOpPath2 = {
    PATHTEST_CUSTOM,
    PATHDATA_ENABLE,
    GL_COPY
};

/*****************************************************************************/

shadePathCustomRec shadePath0 = {
    PATHTEST_DEFAULT
};

shadePathCustomRec shadePath1 = {
    PATHTEST_GARBAGE
};

shadePathCustomRec shadePath2 = {
    PATHTEST_CUSTOM,
    GL_FLAT
};

shadePathCustomRec shadePath3 = {
    PATHTEST_CUSTOM,
    GL_SMOOTH
};

/*****************************************************************************/

stencilPathCustomRec stencilPath0 = {
    PATHTEST_DEFAULT
};

stencilPathCustomRec stencilPath1 = {
    PATHTEST_GARBAGE
};

stencilPathCustomRec stencilPath2 = {
    PATHTEST_CUSTOM,
    PATHDATA_ENABLE,
    0,
    0xFF,
    GL_GEQUAL, 1, 0,
    GL_KEEP, GL_KEEP, GL_KEEP
};

/*****************************************************************************/

stipplePathCustomRec stipplePath0 = {
    PATHTEST_DEFAULT
};

stipplePathCustomRec stipplePath1 = {
    PATHTEST_GARBAGE
};

stipplePathCustomRec stipplePath2 = {
    PATHTEST_CUSTOM,
    PATHDATA_ENABLE,
    10,
    0xFFFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};

/*****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\confshel\path.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"
#include "utils.h"
#include "pathdata.h"
#include "path.h"
#include "driver.h"


pathStateRec paths =  {
    {
	PathAlias,
	PathAlpha,
	PathBlend,
	PathDepth,
	PathDither,
	PathFog,
	PathLogicOp,
	PathShade,
	PathStencil,
	PathStipple
    },
    {
	{
	    {
		PATHDATA_ENABLE, PATHDATA_DISABLE
	    }
	}
    },
    {
	{
	    {
		PATHDATA_ENABLE, PATHDATA_DISABLE
	    },
	    {
		GL_EQUAL,
		GL_NOTEQUAL,
		GL_LESS,
		GL_LEQUAL,
		GL_GREATER,
		GL_GEQUAL,
		GL_ALWAYS,
		GL_NEVER,
		GL_NULL
	    },
	    {
		0.0, 1.0
	    }
	}
    },
    {
	{
	    {
		PATHDATA_ENABLE, PATHDATA_DISABLE
	    },
	    {
		GL_ZERO,
		GL_ONE,
		GL_DST_COLOR,
		GL_ONE_MINUS_DST_COLOR,
		GL_SRC_ALPHA,
		GL_ONE_MINUS_SRC_ALPHA,
		GL_DST_ALPHA,
		GL_ONE_MINUS_DST_ALPHA,
		GL_SRC_ALPHA_SATURATE,
		GL_NULL
	    },
	    {
		GL_ZERO,
		GL_ONE,
		GL_SRC_COLOR,
		GL_ONE_MINUS_SRC_COLOR,
		GL_SRC_ALPHA,
		GL_ONE_MINUS_SRC_ALPHA,
		GL_DST_ALPHA,
		GL_ONE_MINUS_DST_ALPHA,
		GL_NULL
	    }
	}
    },
    {
	{
	    {
		PATHDATA_ENABLE, PATHDATA_DISABLE
	    },
	    {
		0.0, 1.0
	    },
	    {
		0.0, 1.0
	    },
	    {
		0.0, 1.0
	    },
	    {
		GL_EQUAL,
		GL_NOTEQUAL,
		GL_LESS,
		GL_LEQUAL,
		GL_GREATER,
		GL_GEQUAL,
		GL_ALWAYS,
		GL_NEVER,
		GL_NULL
	    }
	}
    },
    {
	{
	    {
		PATHDATA_ENABLE, PATHDATA_DISABLE
	    }
        }
    },
    {
        {
	    {
		PATHDATA_ENABLE, PATHDATA_DISABLE
	    },
	    {
		{
		    0.0, 1.0
		},
		{
		    0.0, 1.0
		},
		{
		    0.0, 1.0
		},
		{
		    0.0, 1.0
		}
	    },
	    {
		0.0, 1.0
	    },
	    {
		0.0, 1.0
	    },
	    {
		0.0, 1.0
	    },
	    {
		0.0, 1.0
	    },
	    {
		GL_LINEAR,
		GL_EXP,
		GL_EXP2,
		GL_NULL
	    }
	}
    },
    {
	{
	    {
		PATHDATA_ENABLE, PATHDATA_DISABLE
	    },
	    {
		GL_NOOP,
		GL_SET,
		GL_EQUIV,
		GL_INVERT,
		GL_CLEAR,
		GL_COPY,
		GL_COPY_INVERTED,
		GL_AND,
		GL_AND_REVERSE,
		GL_AND_INVERTED,
		GL_OR,
		GL_OR_REVERSE,
		GL_OR_INVERTED,
		GL_NAND,
		GL_XOR,
		GL_NOR,
		GL_NULL
	    }
	}
    },
    {
	{
	    {
		GL_FLAT,
		GL_SMOOTH,
		GL_NULL
	    }
	}
    },
    {
	{
	    {
		PATHDATA_ENABLE, PATHDATA_DISABLE
	    },
	    {
		0, 0xFFFFFFFF
	    },
	    {
		0, 0xFFFFFFFF
	    },
	    {
		GL_EQUAL,
		GL_NOTEQUAL,
		GL_LESS,
		GL_LEQUAL,
		GL_GREATER,
		GL_GEQUAL,
		GL_ALWAYS,
		GL_NEVER,
		GL_NULL
	    },
	    {
		-10, 10
	    },
	    {
		0, 0xFFFFFFFF
	    },
	    {
		GL_KEEP,
		GL_REPLACE,
		GL_INCR,
		GL_DECR,
		GL_INVERT,
		GL_ZERO,
		GL_NULL
	    },
	    {
		GL_KEEP,
		GL_REPLACE,
		GL_INCR,
		GL_DECR,
		GL_INVERT,
		GL_ZERO,
		GL_NULL
	    },
	    {
		GL_KEEP,
		GL_REPLACE,
		GL_INCR,
		GL_DECR,
		GL_INVERT,
		GL_ZERO,
		GL_NULL
	    }
	}
    },
    {
	{
	    {
		PATHDATA_ENABLE, PATHDATA_DISABLE
	    },
	    {
		0, 255
	    },
	    {
		0, 0xFFFF
	    },
	    {
		0, 0xFF
	    }
	}
    }
};


/*****************************************************************************/

static void Set(void)
{
    long list[PATH_TOTAL], x, y, tmp, i;

    for (i = 0; i < PATH_TOTAL; i++) {
	list[i] = i;
    }
    for (i = 0; i < PATH_TOTAL*6; i++) {
	x = (long)Random(0.0, (float)(PATH_TOTAL-1));
	do {
	    y = (long)Random(0.0, (float)(PATH_TOTAL-1));
	} while (x == y);
	tmp = list[x];
	list[x] = list[y];
	list[y] = tmp;
    }

    paths.op = PATHOP_SET;
    for (i = 0; i < PATH_TOTAL; i++) {
	(*paths.Func[list[i]])();
    }
}

void PathInit1(unsigned long mask)
{
    unsigned long i;

    for (i = 0; i < PATH_TOTAL; i++) {
	if (mask & (1 << i)) {
	    paths.op = PATHOP_INIT_CUSTOM;
	} else {
	    paths.op = PATHOP_INIT_DEFAULT;
	}
	(*paths.Func[i])();
    }
    Set();
}

void PathInit2(long activePath, unsigned long mask)
{
    unsigned long i;

    for (i = 0; i < PATH_TOTAL; i++) {
	if (i == (unsigned long)activePath && mask & (1 << i)) {
	    paths.op = PATHOP_INIT_CUSTOM;
	} else {
	    paths.op = PATHOP_INIT_DEFAULT;
	}
	(*paths.Func[i])();
    }
    Set();
}

void PathInit3(long activePath, unsigned long mask)
{
    unsigned long i;

    for (i = 0; i < PATH_TOTAL; i++) {
	if (i != (unsigned long)activePath && mask & (1 << i)) {
	    paths.op = PATHOP_INIT_CUSTOM;
	} else {
	    paths.op = PATHOP_INIT_DEFAULT;
	}
	(*paths.Func[i])();
    }
    Set();
}

void PathInit4(void)
{
    long i;

    for (i = 0; i < PATH_TOTAL; i++) {
	paths.op = PATHOP_INIT_DEFAULT;
	(*paths.Func[i])();
	paths.op = PATHOP_SET;
	(*paths.Func[i])();
    }
}

/*****************************************************************************/

GLenum PathGetList(GLenum *list)
{
    long total, index;

    total = 0;
    while (list[total] != GL_NULL) {
	total++;
    }
    index = (long)Random(0.0, (float)total);
    return list[index];
}

GLubyte PathGetRange_uchar(GLubyte *range)
{

    return (GLubyte)Random((float)range[0], (float)range[1]);
}

GLbyte PathGetRange_char(GLbyte *range)
{

    return (GLbyte)Random((float)range[0], (float)range[1]);
}

GLushort PathGetRange_ushort(GLushort *range)
{

    return (GLushort)Random((float)range[0], (float)range[1]);
}

GLshort PathGetRange_short(GLshort *range)
{

    return (GLshort)Random((float)range[0], (float)range[1]);
}

GLuint PathGetRange_ulong(GLuint *range)
{
    double x;

    x = (double)RAND() / RAND_MAX;
    return (GLuint )(x * (double)(range[1] - range[0]) +
	   (double)range[0]);
}

GLint PathGetRange_long(GLint *range)
{
    double x;

    x = (double)RAND() / RAND_MAX;
    return (GLint)(x * (double)(range[1] - range[0]) + (double)range[0]);
}

GLfloat PathGetRange_float(GLfloat *range)
{

    return (GLfloat)Random(range[0], range[1]);
}

GLdouble PathGetRange_double(GLdouble *range)
{
    GLdouble x;

    x = (GLdouble)RAND() / RAND_MAX;
    return (x * (range[1] - range[0]) + range[0]);
}

long PathGetToggle(void)
{

    return (Random(0.0, 10.0) > 5.0) ? PATHDATA_ENABLE : PATHDATA_DISABLE;
}

void PathReport(void)
{
    long i;

    Output(2, "    Path Report.\n");

    paths.op = PATHOP_REPORT;
    for (i = 0; i < PATH_TOTAL; i++) {
	(*paths.Func[i])();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\confshel\path.h ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#define PATH_NONE    0
#define PATH_ALIAS   1
#define PATH_ALPHA   2
#define PATH_BLEND   4
#define PATH_DEPTH   8
#define PATH_DITHER  16
#define PATH_FOG     32
#define PATH_LOGICOP 64
#define PATH_SHADE   128
#define PATH_STENCIL 256
#define PATH_STIPPLE 512

#define PATH_TOTAL 10

enum {
    PATHOP_INIT_DEFAULT = 1,
    PATHOP_INIT_GARBAGE,
    PATHOP_INIT_CUSTOM,
    PATHOP_SET,
    PATHOP_REPORT
};

enum {
    PATHTEST_UNLOCKED = 1,
    PATHTEST_LOCKED
};


typedef struct _aliasPathStateRec {
    struct {
	long data1[2];
    } true;
    struct {
	long data1;	/* enable/disable */
    } current;
    long lock;
} aliasPathStateRec;

typedef struct _alphaPathStateRec {
    struct {
	GLenum data1[2];
	GLenum data2[20];
	GLfloat data3[2];
    } true;
    struct {
	GLenum data1;	/* enable/disable */
	GLenum data2;	/* function */
	GLfloat data3;	/* reference */
    } current;
    long lock;
} alphaPathStateRec;

typedef struct _blendPathStateRec {
    struct {
	GLenum data1[2];
	GLenum data2[20];
	GLenum data3[20];
    } true;
    struct {
	GLenum data1;	/* enable/disable */
	GLenum data2;	/* src function */
	GLenum data3;	/* dest function */
    } current;
    long lock;
} blendPathStateRec;

typedef struct _depthPathStateRec {
    struct {
	GLenum data1[2];
	GLdouble data2[2];
	GLdouble data3[2];
	GLdouble data4[2];
	GLenum data5[20];
    } true;
    struct {
	GLenum data1;	/* enable/disable */
	GLdouble data2;	/* clear value */
	GLdouble data3;	/* min range */
	GLdouble data4;	/* max range */
	GLenum data5;	/* function */
    } current;
    long lock;
} depthPathStateRec;

typedef struct _ditherPathStateRec {
    struct {
	GLenum data1[2];
    } true;
    struct {
	GLenum data1;	/* enable/disable */
    } current;
    long lock;
} ditherPathStateRec;

typedef struct _fogPathStateRec {
    struct {
	GLenum data1[2];
	GLfloat data2[4][2];
	GLfloat data3[2];
	GLfloat data4[2];
	GLfloat data5[2];
	GLfloat data6[2];
	GLenum data7[20];
    } true;
    struct {
	GLenum data1;		/* enable/disable */
	GLfloat data2[4];	/* color */
	GLfloat data3;		/* index */
	GLfloat data4;		/* density */
	GLfloat data5;		/* start */
	GLfloat data6;		/* end */
	GLenum data7;		/* mode */
    } current;
    long lock;
} fogPathStateRec;

typedef struct _logicOpPathStateRec {
    struct {
	GLenum data1[2];
	GLenum data2[20];
    } true;
    struct {
	GLenum data1;	/* enable/disable */
	GLenum data2;	/* function */
    } current;
    long lock;
} logicOpPathStateRec;

typedef struct _shadePathStateRec {
    struct {
	GLenum data1[20];
    } true;
    struct {
	GLenum data1;	/* mode */
    } current;
    long lock;
} shadePathStateRec;

typedef struct _stencilPathStateRec {
    struct {
	GLenum data1[2];
	GLint data2[2];
	GLuint data3[2];
	GLenum data4[20];
	GLint data5[2];
	GLuint data6[2];
	GLenum data7[20];
	GLenum data8[20];
	GLenum data9[20];
    } true;
    struct {
	GLenum data1;	/* enable/disable */
	GLint data2;	/* clear value */
	GLuint data3;	/* write mask */
	GLenum data4;	/* function */
	GLint data5;	/* reference */
	GLuint data6;	/* mask */
	GLenum data7;	/* op1 */
	GLenum data8;	/* op2 */
	GLenum data9;	/* op3 */
    } current;
    long lock;
} stencilPathStateRec;

typedef struct _stipplePathStateRec {
    struct {
	GLenum data1[2];
	GLint data2[2];
	GLushort data3[2];
	GLubyte data4[2];
    } true;
    struct {
	GLenum data1;			/* enable/disable */
	GLint data2;     		/* line repeat */
	GLushort data3;			/* line stipple */
	GLubyte data4[128];		/* polygon stipple */
    } current;
    long lock;
} stipplePathStateRec;

typedef struct _pathStateRec {
    void (*Func[PATH_TOTAL])(void);
    aliasPathStateRec alias;
    alphaPathStateRec alpha;
    blendPathStateRec blend;
    depthPathStateRec depth;
    ditherPathStateRec dither;
    fogPathStateRec fog;
    logicOpPathStateRec logicOp;
    shadePathStateRec shade;
    stencilPathStateRec stencil;
    stipplePathStateRec stipple;
    long op;
} pathStateRec;


extern pathStateRec paths;


extern void PathAlias(void);
extern void PathAlpha(void);
extern void PathBlend(void);
extern void PathDepth(void);
extern void PathDither(void);
extern void PathFog(void);
extern void PathLogicOp(void);
extern void PathShade(void);
extern void PathStencil(void);
extern void PathStipple(void);

extern GLenum PathGetList(GLenum *);
extern GLubyte PathGetRange_uchar(GLubyte *);
extern GLbyte PathGetRange_char(GLbyte *);
extern GLushort PathGetRange_ushort(GLushort *);
extern GLshort PathGetRange_short(GLshort *);
extern GLuint PathGetRange_ulong(GLuint *);
extern GLint PathGetRange_long(GLint *);
extern GLfloat PathGetRange_float(GLfloat *);
extern GLdouble PathGetRange_double(GLdouble *);
extern long PathGetToggle(void);
extern void PathInit1(unsigned long);
extern void PathInit2(long, unsigned long);
extern void PathInit3(long, unsigned long);
extern void PathInit4(void);
extern void PathReport(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\confshel\shell.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include "ctk.h"
#include "conform.h"
#include "util.h"
#include "utils.h"
#include "pathdata.h"
#include "driver.h"


TK_WindowRec wind;
machineRec machine;
bufferRec buffer;
epsilonRec epsilon;
GLfloat colorMap[][3] = {
    {
	0.0, 0.0, 0.0
    },
    {
	1.0, 0.0, 0.0
    },
    {
	0.0, 1.0, 0.0
    },
    {
	1.0, 1.0, 0.0
    },
    {
	0.0, 0.0, 1.0
    },
    {
	1.0, 0.0, 1.0
    },
    {
	0.0, 1.0, 1.0
    },
    {
	1.0, 1.0, 1.0
    }
};


static long Setup(int argc, char **argv)
{
    FILE *file;
    long i, j;

    machine.randSeed = 1;
    machine.pathLevel = 0;
    machine.verboseLevel = 1;
    machine.stateCheckFlag = GL_TRUE;
    machine.failMode = GL_FALSE;
    buffer.visualID = -99;
    DriverInit();

    for (i = 1; i < argc; i++) {
	if (STREQ(argv[i], "-1")) {  /* run single test. */
	    if (i+1 >= argc || argv[i+1][0] == '-') {
		Output(0, "-1 (No test name).\n\n");
		return GL_TRUE;
	    } else {
		if (DriverSetup1(argv[++i]) == ERROR) {
		    Output(0, "-1 (Bad test name).\n\n");
		    return GL_TRUE;
		}
	    }
	} else if (STREQ(argv[i], "-A")) {  /* all display+bitmap pixel formats. */
	    buffer.visualID = -99;
	} else if (STREQ(argv[i], "-S")) {  /* all display pixel formats. */
	    buffer.visualID = -98;
	} else if (STREQ(argv[i], "-B")) {  /* all bitmap pixel formats. */
	    buffer.visualID = -97;
	} else if (STREQ(argv[i], "-D")) {  /* display. */
	    if (i+1 >= argc || argv[i+1][0] == '-') {
		Output(0, "-D (No Display ID).\n\n");
		return GL_TRUE;
	    } else {
		buffer.visualID = ATOI(argv[++i]);
		if (buffer.visualID < 0 || buffer.visualID > 90) {
		    Output(0, "-D (Bad Display ID).\n\n");
		    return GL_TRUE;
		}
	    }
	} else if (STREQ(argv[i], "-d")) {  /* bitmap. */
	    if (i+1 >= argc || argv[i+1][0] == '-') {
		Output(0, "-d (No Bitmap ID).\n\n");
		return GL_TRUE;
	    } else {
		buffer.visualID = ATOI(argv[++i]);
		if (buffer.visualID < 0 || buffer.visualID > 90) {
		    Output(0, "-d (Bad Bitmap ID).\n\n");
		    return GL_TRUE;
		}
		buffer.visualID = -buffer.visualID;
	    }
	} else if (STREQ(argv[i], "-f")) {  /* use test set. */
	    if (i+1 >= argc || argv[i+1][0] == '-') {
		Output(0, "-f (No file name).\n\n");
		return GL_TRUE;
	    } else {
		if (DriverSetup2(argv[++i]) == ERROR) {
		    Output(0, "-f (Bad file).\n\n");
		    return GL_TRUE;
		}
	    }
	} else if (STREQ(argv[i], "-G")) {  /* generate test set. */
	    if (i+1 >= argc || argv[i+1][0] == '-') {
		Output(0, "-G (No file name).\n\n");
	    } else {
		file = fopen(argv[++i], "w");
		if (file != NULL) {
		    fprintf(file, "# %s Tests.\n", appl.title);
		    for (j = 0; !STREQ(driver[j].name, "End of List"); j++) {
			fprintf(file, "#%s\n", driver[j].id);
		    }
		    fclose(file);
		    Output(0, "Test file %s created.\n\n", argv[i]);
		} else {
		    Output(0, "-G (Bad file name).\n\n");
		}
	    }
	    return GL_TRUE;
	} else if (STREQ(argv[i], "-g")) {  /* generate test set. */
	    if (i+1 >= argc || argv[i+1][0] == '-') {
		Output(0, "-g (No file name).\n\n");
	    } else {
		file = fopen(argv[++i], "w");
		if (file != NULL) {
		    fprintf(file, "# %s Tests.\n", appl.title);
		    for (j = 0; !STREQ(driver[j].name, "End of List"); j++) {
			fprintf(file, "%s\n", driver[j].id);
		    }
		    fclose(file);
		    Output(0, "Test file %s created.\n\n", argv[i]);
		} else {
		    Output(0, "-g (Bad file name).\n\n");
		}
	    }
	    return GL_TRUE;
	} else if (STREQ(argv[i], "-h")) {  /* help. */
	    Output(0, "Options:\n");
	    Output(0, "\t-A\t\tRun tests on all pixel formats.\n");
	    Output(0, "\t-S\t\tRun tests on all display pixel formats.\n");
	    Output(0, "\t-B\t\tRun tests on all bitmap pixel formats.\n");
	    Output(0, "\t-1 \"test\"\tSingle test using \"test\" id.\n");
	    Output(0, "\t-D \"id\"\t\tUse display id.\n");
	    Output(0, "\t-d \"id\"\t\tUse bitmap id.\n");
	    Output(0, "\t-f \"file\"\tUse test set in \"file\".\n");
	    Output(0, "\t-g \"file\"\tGenerate test set in \"file\".\n");
	    Output(0, "\t-h\t\tPrint this help screen.\n");
	    Output(0, "\t-p [1-3]\tSet path level.\n");
	    Output(0, "\t-r \"seed\"\tSet random seed.\n");
	    Output(0, "\t-s\t\tSkip state check.\n");
	    Output(0, "\t-v [0-2]\tVerbose level.\n");
	    Output(0, "\t-x\t\tForce fail for visual tests.\n");
	    Output(0, "\n");
	    return GL_TRUE;
	} else if (STREQ(argv[i], "-p")) {  /* path options. */
	    if (i+1 >= argc || argv[i+1][0] == '-') {
		Output(0, "-p (No path number).\n\n");
		return GL_TRUE;
	    } else {
		machine.pathLevel = ATOI(argv[++i]);
		if (machine.pathLevel > 4) {
		    Output(0, "-p (Bad path number).\n\n");
		    return GL_TRUE;
		}
	    }
	} else if (STREQ(argv[i], "-r")) {  /* random seed. */
	    if (i+1 >= argc || argv[i+1][0] == '-') {
		Output(0, "-r (No random seed).\n\n");
		return GL_TRUE;
	    } else {
		machine.randSeed = (unsigned int)ATOI(argv[++i]);
	    }
	} else if (STREQ(argv[i], "-s")) {  /* skip state check. */
	    machine.stateCheckFlag = GL_FALSE;
	} else if (STREQ(argv[i], "-x")) {  /* force fail. */
	    machine.failMode = GL_TRUE;
	} else if (STREQ(argv[i], "-v")) {  /* verbose. */
	    if (i+1 >= argc || argv[i+1][0] == '-') {
		Output(0, "-v (No verbose level).\n\n");
		return GL_TRUE;
	    } else {
		machine.verboseLevel = ATOI(argv[++i]);
		if (machine.verboseLevel < 0 || machine.verboseLevel > 2) {
		    Output(0, "-v (Bad verbose level).\n\n");
		    return GL_TRUE;
		}
	    }
	} else {
	    Output(0, "%s (Bad option).\n\n", argv[i]);
	    return GL_TRUE;
	}
    }
    return GL_FALSE;
}

static void BufferSetup(void)
{
    long i;

    buffer.render = (GLint)wind.render;

    buffer.colorMode = (TK_WIND_IS_RGB(wind.info)) ? GL_RGB : GL_COLOR_INDEX;

    buffer.doubleBuf = (TK_WIND_IS_SB(wind.info)) ? GL_FALSE : GL_TRUE;
    glDrawBuffer(GL_FRONT);
    glReadBuffer(GL_FRONT);

    glGetIntegerv(GL_AUX_BUFFERS, &buffer.auxBuf);
    glGetIntegerv(GL_STEREO, &buffer.stereoBuf);

    glGetIntegerv(GL_RED_BITS, &buffer.colorBits[0]);
    glGetIntegerv(GL_GREEN_BITS, &buffer.colorBits[1]);
    glGetIntegerv(GL_BLUE_BITS, &buffer.colorBits[2]);
    glGetIntegerv(GL_ALPHA_BITS, &buffer.colorBits[3]);
    glGetIntegerv(GL_INDEX_BITS, &buffer.ciBits);
    glGetIntegerv(GL_DEPTH_BITS, &buffer.zBits);
    glGetIntegerv(GL_STENCIL_BITS, &buffer.stencilBits);
    glGetIntegerv(GL_ACCUM_RED_BITS, &buffer.accumBits[0]);
    glGetIntegerv(GL_ACCUM_GREEN_BITS, &buffer.accumBits[1]);
    glGetIntegerv(GL_ACCUM_BLUE_BITS, &buffer.accumBits[2]);
    glGetIntegerv(GL_ACCUM_ALPHA_BITS, &buffer.accumBits[3]);

    if (buffer.colorMode == GL_RGB) {
	buffer.maxRGBComponent = 0;
	if (buffer.colorBits[1] > buffer.colorBits[buffer.maxRGBComponent]) {
	    buffer.maxRGBComponent = 1;
	}
	if (buffer.colorBits[2] > buffer.colorBits[buffer.maxRGBComponent]) {
	    buffer.maxRGBComponent = 2;
	}
	for (i = 0; i < 3; i++) {
	    buffer.minRGB[i] = 0.0;
	    buffer.maxRGB[i] = 0.0;
	}
	buffer.maxRGB[buffer.maxRGBComponent] = 1.0;
	buffer.minRGBBit = MIN(buffer.colorBits[0], MIN(buffer.colorBits[1],
			       buffer.colorBits[2]));
	buffer.maxRGBBit = MAX(buffer.colorBits[0], MAX(buffer.colorBits[1],
			       buffer.colorBits[2]));
    } else {
	buffer.minIndex = 0;
	buffer.maxIndex = (GLint)POW(2.0, (float)buffer.ciBits) - 1;
    }
}

static float CalcEpsilon(long bits)
{
    float e;

    if (bits == 0) {
	e = epsilon.zero;
    } else {
	e = 1.0 / (POW(2.0, (float)bits) - 1.0) + epsilon.zero;
	if (e > 1.0) {
	    e = 1.0;
	}
    }
    return e;
}

static void EpsilonSetup(void)
{
    long i;

    epsilon.zero = 1.0 / POW(2.0, 13.0);

    for (i = 0; i < 4; i++) {
	epsilon.color[i] = CalcEpsilon(buffer.colorBits[i]);
    }

    epsilon.ci = 0.5;

    epsilon.z = CalcEpsilon(buffer.zBits);

    epsilon.stencil = CalcEpsilon(buffer.stencilBits);

    for (i = 0; i < 4; i++) {
	epsilon.accum[i] = CalcEpsilon(buffer.accumBits[i]);
    }
}

static void MachineReport(void)
{

    Output(0, "Setup Report.\n");

    if (machine.verboseLevel > 0) {
	Output(0, "    Verbose level = %d.\n", machine.verboseLevel);
    }

    Output(0, "    Random number seed = %d.\n", machine.randSeed);

    if (machine.pathLevel == 0) {
	Output(0, "    Path inactive.\n");
    } else if (machine.pathLevel == 99) {
	Output(0, "    Fast inert path.\n");
    } else {
	Output(0, "    Path level = %d.\n", machine.pathLevel);
    }

    if (machine.failMode == GL_TRUE) {
	Output(0, "    Fail mode on.\n");
    }

    Output(0, "\n");
}

static void VisualReport(void)
{

    Output(0, "Visual Report.\n");

    if (buffer.visualID != -99) {
	if (buffer.visualID > 0)
	    Output(0, "    Display ID = %d. ", buffer.visualID);
	else
	    Output(0, "    Bitmap ID = %d. ", -buffer.visualID);
	if (buffer.render == TK_WIND_DIRECT) {
	    Output(0, "Direct Rendering.\n");
	} else {
	    Output(0, "Indirect Rendering.\n");
	}
    }

    if (buffer.doubleBuf == GL_TRUE) {
	Output(0, "    Double Buffered.\n");
    } else {
	Output(0, "    Single Buffered.\n");
    }

    if (buffer.colorMode == GL_RGB) {
	Output(0, "    RGBA (%d, %d, %d, %d).\n", buffer.colorBits[0],
	       buffer.colorBits[1], buffer.colorBits[2], buffer.colorBits[3]);
    } else {
	Output(0, "    Color Index (%d).\n", buffer.ciBits);
    }

    if (buffer.stencilBits) {
	Output(0, "    Stencil (%d).\n", buffer.stencilBits);
    }

    if (buffer.zBits) {
	Output(0, "    Depth (%d).\n", buffer.zBits);
    }

    if (buffer.accumBits[0]) {
	Output(0, "    Accumulation (%d, %d, %d, %d).\n", buffer.accumBits[0],
	       buffer.accumBits[1], buffer.accumBits[2], buffer.accumBits[3]);
    }

    if (buffer.auxBuf > 0) {
	Output(0, "    %d Auxilary Buffer", buffer.auxBuf);
	if (buffer.auxBuf > 1) {
	    Output(0, "s.\n");
	} else {
	    Output(0, ".\n");
	}
    }

    Output(0, "\n");
}

static void EpsilonReport(void)
{

    Output(2, "Epsilon Report.\n");
    Output(2, "    zero error epsilon = %.3g.\n", epsilon.zero);
    if (buffer.colorMode == GL_RGB) {
	Output(2, "    RGBA error epsilon = %.3g, %.3g, %.3g, %.3g.\n",
	       epsilon.color[0], epsilon.color[1], epsilon.color[2],
	       epsilon.color[3]);
    } else {
	Output(2, "    Color index error epsilon = %.3g.\n", epsilon.ci);
    }
    Output(2, "    Depth buffer error epsilon = %.3g.\n", epsilon.z);
    Output(2, "    Stencil plane error epsilon = %.3g.\n", epsilon.stencil);
    Output(2, "    Accumulation error epsilon = %.3g, %.3g, %.3g, %.3g.\n",
	   epsilon.accum[0], epsilon.accum[1], epsilon.accum[2],
	   epsilon.accum[3]);
    Output(2, "\n");
}

long Exec(TK_EventRec *ptr)
{

    if (ptr->event == TK_EVENT_EXPOSE) {
	BufferSetup();
	EpsilonSetup();
	StateSetup();

	MachineReport();
	VisualReport();
	EpsilonReport();

	Driver();
	return 0;
    }
    return 1;
}

int main(int argc, char **argv)
{
    TK_VisualIDsRec list;
    long flags[100], i;
    BOOL bTestAll = FALSE;

    printf("%s Test\n", appl.title);
    printf("Version %s\n", appl.version);
    printf("\n");

    if (Setup(argc, argv) == GL_TRUE) {
	tkQuit();
	return 1;
    }

    StrMake(wind.name, "%s Test", appl.name);
    wind.x = CW_USEDEFAULT;
    wind.y = CW_USEDEFAULT;
    wind.width = WINDSIZEX;
    wind.height = WINDSIZEY;
    wind.eventMask = TK_EVENT_EXPOSE;

    switch (buffer.visualID) {

    case -99:   // test all display and bitmap pixel formats
	bTestAll = TRUE;
	// fall through

    case -98:   // test all display pixel formats
	tkGet(TK_VISUALIDS, (void *)&list);
	for (i = 0; i < list.count; i++) {
	    wind.type = TK_WIND_VISUAL;
	    buffer.visualID = (GLint)list.IDs[i];
	    wind.info = buffer.visualID;
	    wind.render = TK_WIND_DIRECT;
	    if (tkNewWindow(&wind)) {
		tkExec(Exec);
		tkCloseWindow();
	    } else {
		Output(0, "Display ID %d not found.\n", buffer.visualID);
	    }
	    Output(0, "\n");
	}
	if (!bTestAll)
	    break;
	// fall through

    case -97:   // test all bitmap pixel formats
	tkGet(TK_VISUALIDS, (void *)&list);
	for (i = 0; i < list.count; i++) {
	    wind.type = TK_WIND_VISUAL;
	    buffer.visualID = -(GLint)list.IDs[i];
	    wind.info = buffer.visualID;
	    wind.render = TK_WIND_DIRECT;
	    if (tkNewWindow(&wind)) {
		tkExec(Exec);
		tkCloseWindow();
	    } else {
		Output(0, "Bitmap ID %d not found.\n", -buffer.visualID);
	    }
	    Output(0, "\n");
	}
	break;

    default:
	wind.type = TK_WIND_VISUAL;
	wind.info = buffer.visualID;
	wind.render = TK_WIND_DIRECT;
	if (tkNewWindow(&wind)) {
	    tkExec(Exec);
	    Output(0, "\n");
	} else {
	    Output(0, "Requested ID %d not found.\n\n", abs(buffer.visualID));
	}
	break;
    }

    tkQuit();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\confshel\paths.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"
#include "pathdata.h"
#include "path.h"


void PathAlias(void)
{
    aliasPathStateRec *ptr = &paths.alias;

    switch (paths.op) {
      case PATHOP_INIT_DEFAULT:
	ptr->current.data1 = PATHDATA_DISABLE;
	ptr->lock = PATHTEST_UNLOCKED;
	break;
      case PATHOP_INIT_GARBAGE:
	ptr->current.data1 = PATHDATA_DISABLE;
	ptr->lock = PATHTEST_UNLOCKED;
	break;
      case PATHOP_INIT_CUSTOM:
	ptr->current.data1 = aliasPath2.state;
	ptr->lock = PATHTEST_UNLOCKED;
	break;
      case PATHOP_SET:
	if (ptr->lock != PATHTEST_LOCKED) {
	    if (ptr->current.data1 == PATHDATA_ENABLE) {
		glEnable(GL_POINT_SMOOTH);
		glEnable(GL_LINE_SMOOTH);
		glEnable(GL_POLYGON_SMOOTH);
		glEnable(GL_BLEND);
		glBlendFunc(GL_SRC_ALPHA, GL_ONE);

		glDisable(GL_ALPHA_TEST);
		paths.alpha.lock = PATHTEST_LOCKED;
		glDisable(GL_BLEND);
		paths.blend.lock = PATHTEST_LOCKED;
		glDisable(GL_DEPTH_TEST);
		paths.depth.lock = PATHTEST_LOCKED;
		glDisable(GL_DITHER);
		paths.dither.lock = PATHTEST_LOCKED;
		glDisable(GL_FOG);
		paths.fog.lock = PATHTEST_LOCKED;
	    } else {
		glDisable(GL_POINT_SMOOTH);
		glDisable(GL_LINE_SMOOTH);
		glDisable(GL_POLYGON_SMOOTH);
	    }
	}
	break;
      case PATHOP_REPORT:
	if (ptr->current.data1 == PATHDATA_ENABLE) {
	    Output(2, "        Alias Path active.\n");
	    Output(2, "            GL_POINT_SMOOTH = enabled.\n");
	    Output(2, "            GL_LINE_SMOOTH = enabled.\n");
	    Output(2, "            GL_POLYGON_SMOOTH = enabled.\n");
	    Output(2, "            Blend src function = GL_SRC_ALPHA, Blend dest function = GL_ONE.\n");
	} else {
	    Output(2, "        Alias Path inactive.\n");
	}
	break;
    }
}

void PathAlpha(void)
{
    alphaPathStateRec *ptr = &paths.alpha;
    char str[40];

    switch (paths.op) {
      case PATHOP_INIT_DEFAULT:
	ptr->current.data1 = PATHDATA_DISABLE;
	ptr->current.data2 = GL_ALWAYS;
	ptr->current.data3 = 0.0;
	ptr->lock = PATHTEST_UNLOCKED;
	break;
      case PATHOP_INIT_GARBAGE:
	ptr->current.data1 = PATHDATA_DISABLE;
	ptr->current.data2 = PathGetList(ptr->true.data2);
	ptr->current.data3 = PathGetRange_float(ptr->true.data3);
	ptr->lock = PATHTEST_UNLOCKED;
	break;
      case PATHOP_INIT_CUSTOM:
	ptr->current.data1 = alphaPath2.state;
	ptr->current.data2 = alphaPath2.func;
	ptr->current.data3 = alphaPath2.ref;
	ptr->lock = PATHTEST_UNLOCKED;
	break;
      case PATHOP_SET:
	if (ptr->lock != PATHTEST_LOCKED) {
	    if (ptr->current.data1 == PATHDATA_ENABLE) {
		glEnable(GL_ALPHA_TEST);

		glDisable(GL_POINT_SMOOTH);
		glDisable(GL_LINE_SMOOTH);
		glDisable(GL_POLYGON_SMOOTH);
		paths.alias.lock = PATHTEST_LOCKED;
	    } else {
		glDisable(GL_ALPHA_TEST);
	    }
	    glAlphaFunc(ptr->current.data2, ptr->current.data3);
	}
	break;
      case PATHOP_REPORT:
	if (ptr->current.data1 == PATHDATA_ENABLE) {
	    Output(2, "        Alpha Path active.\n");
	    GetEnumName(ptr->current.data2, str);
	    Output(2, "            Function = %s.\n", str);
	    Output(2, "            Reference = %f.\n", ptr->current.data3);
	} else {
	    Output(2, "        Alpha Path inactive.\n");
	}
	break;
    }
}

void PathBlend(void)
{
    blendPathStateRec *ptr = &paths.blend;
    char str[40];

    switch (paths.op) {
      case PATHOP_INIT_DEFAULT:
	ptr->current.data1 = PATHDATA_DISABLE;
	ptr->current.data2 = GL_ONE;
	ptr->current.data3 = GL_ZERO;
	ptr->lock = PATHTEST_UNLOCKED;
	break;
      case PATHOP_INIT_GARBAGE:
	ptr->current.data1 = PATHDATA_DISABLE;
	ptr->current.data2 = PathGetList(ptr->true.data2);
	ptr->current.data3 = PathGetList(ptr->true.data3);
	ptr->lock = PATHTEST_UNLOCKED;
	break;
      case PATHOP_INIT_CUSTOM:
	ptr->current.data1 = blendPath2.state;
	ptr->current.data2 = blendPath2.srcFunc;
	ptr->current.data3 = blendPath2.destFunc;
	ptr->lock = PATHTEST_UNLOCKED;
	break;
      case PATHOP_SET:
	if (ptr->lock != PATHTEST_LOCKED) {
	    if (ptr->current.data1 == PATHDATA_ENABLE) {
		glEnable(GL_BLEND);

		glDisable(GL_POINT_SMOOTH);
		glDisable(GL_LINE_SMOOTH);
		glDisable(GL_POLYGON_SMOOTH);
		paths.alias.lock = PATHTEST_LOCKED;
		glDisable(GL_ALPHA_TEST);
		paths.alpha.lock = PATHTEST_LOCKED;
	    } else {
		glDisable(GL_BLEND);
	    }
	    glBlendFunc(ptr->current.data2, ptr->current.data3);
	}
	break;
      case PATHOP_REPORT:
	if (ptr->current.data1 == PATHDATA_ENABLE) {
	    Output(2, "        Blend Path active.\n");
	    GetEnumName(ptr->current.data2, str);
	    Output(2, "            Src function = %s, ", str);
	    GetEnumName(ptr->current.data3, str);
	    Output(2, "Dest function = %s.\n", str);
	} else {
	    Output(2, "        Blend Path inactive.\n");
	}
	break;
    }
}

void PathDepth(void)
{
    depthPathStateRec *ptr = &paths.depth;
    char str[40];

    switch (paths.op) {
      case PATHOP_INIT_DEFAULT:
	ptr->current.data1 = PATHDATA_DISABLE;
	ptr->current.data2 = 1.0;
	ptr->current.data3 = 0.0;
	ptr->current.data4 = 1.0;
	ptr->current.data5 = GL_LESS;
	ptr->lock = PATHTEST_UNLOCKED;
	break;
      case PATHOP_INIT_GARBAGE:
	ptr->current.data1 = PATHDATA_DISABLE;
	ptr->current.data2 = PathGetRange_double(ptr->true.data2);
	ptr->current.data3 = PathGetRange_double(ptr->true.data3);
	ptr->current.data4 = PathGetRange_double(ptr->true.data4);
	ptr->current.data5 = PathGetList(ptr->true.data5);
	ptr->lock = PATHTEST_UNLOCKED;
	break;
      case PATHOP_INIT_CUSTOM:
	ptr->current.data1 = depthPath2.state;
	ptr->current.data2 = depthPath2.clear;
	ptr->current.data3 = depthPath2.min;
	ptr->current.data4 = depthPath2.max;
	ptr->current.data5 = depthPath2.func;
	ptr->lock = PATHTEST_UNLOCKED;
	break;
      case PATHOP_SET:
	if (ptr->lock != PATHTEST_LOCKED) {
	    if (ptr->current.data1 == PATHDATA_ENABLE) {
		glEnable(GL_DEPTH_TEST);

		glDisable(GL_POINT_SMOOTH);
		glDisable(GL_LINE_SMOOTH);
		glDisable(GL_POLYGON_SMOOTH);
		paths.alias.lock = PATHTEST_LOCKED;
		glDisable(GL_STENCIL_TEST);
		paths.stencil.lock = PATHTEST_LOCKED;
	    } else {
		glDisable(GL_DEPTH_TEST);
	    }
	    glDepthRange(ptr->current.data3, ptr->current.data4);
	    glClearDepth(ptr->current.data2);
	    glClear(GL_DEPTH_BUFFER_BIT);
	    glDepthFunc(ptr->current.data5);
	}
	break;
      case PATHOP_REPORT:
	if (ptr->current.data1 == PATHDATA_ENABLE) {
	    Output(2, "        Depth Path active.\n");
	    Output(2, "            Clear value = %f.\n", ptr->current.data2);
	    Output(2, "            Range = %f, %f.\n", ptr->current.data3,
		   ptr->current.data4);
	    GetEnumName(ptr->current.data5, str);
	    Output(2, "            Function = %s.\n", str);
	} else {
	    Output(2, "        Depth Path inactive.\n");
	}
	break;
    }
}

void PathDither(void)
{
    ditherPathStateRec *ptr = &paths.dither;

    switch (paths.op) {
      case PATHOP_INIT_DEFAULT:
	ptr->current.data1 = PATHDATA_ENABLE;
	ptr->lock = PATHTEST_UNLOCKED;
	break;
      case PATHOP_INIT_GARBAGE:
	ptr->current.data1 = PATHDATA_DISABLE;
	ptr->lock = PATHTEST_UNLOCKED;
	break;
      case PATHOP_INIT_CUSTOM:
	ptr->current.data1 = ditherPath2.state;
	ptr->lock = PATHTEST_UNLOCKED;
	break;
      case PATHOP_SET:
	if (ptr->lock != PATHTEST_LOCKED) {
	    if (ptr->current.data1 == PATHDATA_ENABLE) {
		glEnable(GL_DITHER);
	    } else {
		glDisable(GL_DITHER);
	    }
	}
	break;
      case PATHOP_REPORT:
	if (ptr->current.data1 == PATHDATA_ENABLE) {
	    Output(2, "        Dither Path active.\n");
	} else {
	    Output(2, "        Dither Path inactive.\n");
	}
	break;
    }
}

void PathFog(void)
{
    fogPathStateRec *ptr = &paths.fog;
    char str[40];
    long i;

    switch (paths.op) {
      case PATHOP_INIT_DEFAULT:
	ptr->current.data1 = PATHDATA_DISABLE;
	for (i = 0; i < 4; i++) {
	    ptr->current.data2[i] = 0.0;
	}
	ptr->current.data3 = 0.0;
	ptr->current.data4 = 1.0;
	ptr->current.data5 = 0.0;
	ptr->current.data6 = 1.0;
	ptr->current.data7 = GL_EXP;
	ptr->lock = PATHTEST_UNLOCKED;
	break;
      case PATHOP_INIT_GARBAGE:
	ptr->current.data1 = PATHDATA_DISABLE;
	for (i = 0; i < 4; i++) {
	    ptr->current.data2[i] = PathGetRange_float(ptr->true.data2[i]);
	}
	ptr->current.data3 = PathGetRange_float(ptr->true.data3);
	ptr->current.data4 = PathGetRange_float(ptr->true.data4);
	ptr->current.data5 = PathGetRange_float(ptr->true.data5);
	ptr->current.data6 = PathGetRange_float(ptr->true.data6);
	ptr->current.data7 = PathGetList(ptr->true.data7);
	ptr->lock = PATHTEST_UNLOCKED;
	break;
      case PATHOP_INIT_CUSTOM:
	ptr->current.data1 = fogPath2.state;
	for (i = 0; i < 4; i++) {
	    ptr->current.data2[i] = fogPath2.color[i];
	}
	ptr->current.data3 = fogPath2.index;
	ptr->current.data4 = fogPath2.density;
	ptr->current.data5 = fogPath2.start;
	ptr->current.data6 = fogPath2.end;
	ptr->current.data7 = fogPath2.mode;
	ptr->lock = PATHTEST_UNLOCKED;
	break;
      case PATHOP_SET:
	if (ptr->lock != PATHTEST_LOCKED) {
	    if (ptr->current.data1 == PATHDATA_ENABLE) {
		glEnable(GL_FOG);

		glDisable(GL_DEPTH_TEST);
		paths.depth.lock = PATHTEST_LOCKED;
	    } else {
		glDisable(GL_FOG);
	    }
	    glFogfv(GL_FOG_COLOR, ptr->current.data2);
	    glFogfv(GL_FOG_INDEX, &ptr->current.data3);
	    glFogfv(GL_FOG_DENSITY, &ptr->current.data4);
	    glFogfv(GL_FOG_START, &ptr->current.data5);
	    glFogfv(GL_FOG_END, &ptr->current.data6);
	    glFogi(GL_FOG_MODE, ptr->current.data7);
	}
	break;
      case PATHOP_REPORT:
	if (ptr->current.data1 == PATHDATA_ENABLE) {
	    Output(2, "        Fog Path active.\n");
	    Output(2, "            RGBA color = %f, %f, %f, %f.\n",
		   ptr->current.data2[0], ptr->current.data2[1],
		   ptr->current.data2[2], ptr->current.data2[3]);
	    Output(2, "            Color Index = %1.1f.\n", ptr->current.data3);
	    Output(2, "            Density = %f.\n", ptr->current.data4);
	    Output(2, "            Start and end values = %f, %f.\n",
		   ptr->current.data5, ptr->current.data6);
	    GetEnumName(ptr->current.data7, str);
	    Output(2, "            Mode = %s.\n", str);
	} else {
	    Output(2, "        Fog Path inactive.\n");
	}
	break;
    }
}

void PathLogicOp(void)
{
    logicOpPathStateRec *ptr = &paths.logicOp;
    char str[40];

    switch (paths.op) {
      case PATHOP_INIT_DEFAULT:
	ptr->current.data1 = PATHDATA_DISABLE;
	ptr->current.data2 = GL_COPY;
	ptr->lock = PATHTEST_UNLOCKED;
	break;
      case PATHOP_INIT_GARBAGE:
	ptr->current.data1 = PATHDATA_DISABLE;
	ptr->current.data2 = PathGetList(ptr->true.data2);
	ptr->lock = PATHTEST_UNLOCKED;
	break;
      case PATHOP_INIT_CUSTOM:
	ptr->current.data1 = logicOpPath2.state;
	ptr->current.data2 = logicOpPath2.func;
	ptr->lock = PATHTEST_UNLOCKED;
	break;
      case PATHOP_SET:
	if (ptr->lock != PATHTEST_LOCKED) {
	    if (ptr->current.data1 == PATHDATA_ENABLE) {
		glEnable(GL_LOGIC_OP);
	    } else {
		glDisable(GL_LOGIC_OP);
	    }
	    glLogicOp(ptr->current.data2);
	}
	break;
      case PATHOP_REPORT:
	if (ptr->current.data1 == PATHDATA_ENABLE) {
	    Output(2, "        LogicOp Path active.\n");
	    GetEnumName(ptr->current.data2, str);
	    Output(2, "            Function = %s.\n", str);
	} else {
	    Output(2, "        LogicOp Path inactive.\n");
	}
	break;
    }
}

void PathShade(void)
{
    shadePathStateRec *ptr = &paths.shade;
    char str[40];

    switch (paths.op) {
      case PATHOP_INIT_DEFAULT:
	ptr->current.data1 = GL_SMOOTH;
	ptr->lock = PATHTEST_UNLOCKED;
	break;
      case PATHOP_INIT_GARBAGE:
	ptr->current.data1 = GL_SMOOTH;
	ptr->lock = PATHTEST_UNLOCKED;
	break;
      case PATHOP_INIT_CUSTOM:
	ptr->current.data1 = shadePath2.mode;
	ptr->lock = PATHTEST_UNLOCKED;
	break;
      case PATHOP_SET:
	if (ptr->lock != PATHTEST_LOCKED) {
	    glShadeModel(ptr->current.data1);
	}
	break;
      case PATHOP_REPORT:
	GetEnumName(ptr->current.data1, str);
	Output(2, "        Shade model Path = %s.\n", str);
	break;
    }
}

void PathStencil(void)
{
    stencilPathStateRec *ptr = &paths.stencil;
    char str[40];

    switch (paths.op) {
      case PATHOP_INIT_DEFAULT:
	ptr->current.data1 = PATHDATA_DISABLE;
	ptr->current.data2 = 0;
	ptr->current.data3 = ~0;
	ptr->current.data4 = GL_ALWAYS;
	ptr->current.data5 = 0;
	ptr->current.data6 = ~0;
	ptr->current.data7 = GL_KEEP;
	ptr->current.data8 = GL_KEEP;
	ptr->current.data9 = GL_KEEP;
	ptr->lock = PATHTEST_UNLOCKED;
	break;
      case PATHOP_INIT_GARBAGE:
	ptr->current.data1 = PATHDATA_DISABLE;
	ptr->current.data2 = PathGetRange_long(ptr->true.data2);
	ptr->current.data3 = PathGetRange_ulong(ptr->true.data3);
	ptr->current.data4 = PathGetList(ptr->true.data4);
	ptr->current.data5 = PathGetRange_long(ptr->true.data5);
	ptr->current.data6 = PathGetRange_ulong(ptr->true.data6);
	ptr->current.data7 = PathGetList(ptr->true.data7);
	ptr->current.data8 = PathGetList(ptr->true.data8);
	ptr->current.data9 = PathGetList(ptr->true.data9);
	ptr->lock = PATHTEST_UNLOCKED;
	break;
      case PATHOP_INIT_CUSTOM:
	ptr->current.data1 = stencilPath2.state;
	ptr->current.data2 = stencilPath2.clear;
	ptr->current.data3 = stencilPath2.writeMask;
	ptr->current.data4 = stencilPath2.func;
	ptr->current.data5 = stencilPath2.ref;
	ptr->current.data6 = stencilPath2.mask;
	ptr->current.data7 = stencilPath2.op1;
	ptr->current.data8 = stencilPath2.op2;
	ptr->current.data9 = stencilPath2.op3;
	ptr->lock = PATHTEST_UNLOCKED;
	break;
      case PATHOP_SET:
	if (ptr->lock != PATHTEST_LOCKED) {
	    if (ptr->current.data1 == PATHDATA_ENABLE) {
		glEnable(GL_STENCIL_TEST);

		glDisable(GL_DEPTH_TEST);
		paths.depth.lock = PATHTEST_LOCKED;
	    } else {
		glDisable(GL_STENCIL_TEST);
	    }

	    glClearStencil(ptr->current.data2);
	    glClear(GL_STENCIL_BUFFER_BIT);
	    glStencilMask(ptr->current.data3);
	    glStencilFunc(ptr->current.data4, ptr->current.data5,
			  ptr->current.data6);
	    glStencilOp(ptr->current.data7, ptr->current.data8,
			ptr->current.data9);
        }
	break;
      case PATHOP_REPORT:
	if (ptr->current.data1 == PATHDATA_ENABLE) {
	    Output(2, "        Stencil Path active.\n");
	    Output(2, "            Clear value = %d.\n", ptr->current.data2);
	    Output(2, "            Mask value = %X.\n",
		   ptr->current.data3);
	    GetEnumName(ptr->current.data4, str);
	    Output(2, "            Function = %s, reference = %d, mask = %X.\n",
		   str, ptr->current.data5, ptr->current.data6);
	    GetEnumName(ptr->current.data7, str);
	    Output(2, "            Op1 = %s, ", str);
	    GetEnumName(ptr->current.data8, str);
	    Output(2, "op2 = %s, ", str);
	    GetEnumName(ptr->current.data9, str);
	    Output(2, "op3 = %s.\n", str);
	} else {
	    Output(2, "        Stencil Path inactive.\n");
	}
	break;
    }
}

void PathStipple(void)
{
    stipplePathStateRec *ptr = &paths.stipple;
    long i, j;

    switch (paths.op) {
      case PATHOP_INIT_DEFAULT:
	ptr->current.data1 = PATHDATA_DISABLE;
	ptr->current.data2 = 0;
	ptr->current.data3 = 0;
	for (i = 0; i < 128; i++) {
	    ptr->current.data4[i] = 0;
	}
	ptr->lock = PATHTEST_UNLOCKED;
	break;
      case PATHOP_INIT_GARBAGE:
	ptr->current.data1 = PATHDATA_DISABLE;
	ptr->current.data2 = PathGetRange_long(ptr->true.data2);
	ptr->current.data3 = PathGetRange_ushort(ptr->true.data3);
	for (i = 0; i < 128; i++) {
	    ptr->current.data4[i] = PathGetRange_uchar(ptr->true.data4);
	}
	ptr->lock = PATHTEST_UNLOCKED;
	break;
      case PATHOP_INIT_CUSTOM:
	ptr->current.data1 = stipplePath2.state;
	ptr->current.data2 = stipplePath2.lineRepeat;
	ptr->current.data3 = stipplePath2.lineStipple;
	for (i = 0; i < 128; i++) {
	    ptr->current.data4[i] = stipplePath2.polygonStipple[i];
	}
	ptr->lock = PATHTEST_UNLOCKED;
	break;
      case PATHOP_SET:
	if (ptr->lock != PATHTEST_LOCKED) {
	    if (ptr->current.data1 == PATHDATA_ENABLE) {
		glEnable(GL_LINE_STIPPLE);
		glEnable(GL_POLYGON_STIPPLE);
	    } else {
		glDisable(GL_LINE_STIPPLE);
		glDisable(GL_POLYGON_STIPPLE);
	    }
	    glLineStipple(ptr->current.data2, ptr->current.data3);
	    glPolygonStipple(ptr->current.data4);
	}
	break;
      case PATHOP_REPORT:
	if (ptr->current.data1 == PATHDATA_ENABLE) {
	    Output(2, "        Stipple Path active.\n");
	    Output(2, "            Line stipple = %X, repeat = %d.\n",
		   ptr->current.data3, ptr->current.data2);
	    Output(2, "            Polygon stipple = %X",
		   ptr->current.data4[0]);
	    for (i = 1; i < 8; i++) {
		    Output(2, ", %X", ptr->current.data4[i]);
	    }
	    Output(2, "\n");
	    for (i = 1; i < 16; i++) {
		Output(2, "                              %X",
		       ptr->current.data4[i*8]);
		for (j = 1; j < 8; j++) {
		    Output(2, ", %X", ptr->current.data4[i*8+j]);
		}
		Output(2, "\n");
	    }
	} else {
	    Output(2, "        Stipple Path inactive.\n");
	}
	break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\confshel\pathdata.h ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

enum {
    PATHTEST_DEFAULT = 1,
    PATHTEST_GARBAGE,
    PATHTEST_CUSTOM
};

enum {
    PATHDATA_DISABLE = 1,
    PATHDATA_ENABLE
};


typedef struct _aliasPathCustomRec {
    long testMode;
    GLenum state;
} aliasPathCustomRec;

typedef struct _alphaPathCustomRec {
    long testMode;
    GLenum state;
    GLenum func;
    GLfloat ref;
} alphaPathCustomRec;

typedef struct _blendPathCustomRec {
    long testMode;
    GLenum state;
    GLenum srcFunc, destFunc;
    GLfloat color[4];
} blendPathCustomRec;

typedef struct _depthPathCustomRec {
    long testMode;
    GLenum state;
    GLdouble clear;
    GLdouble min, max;
    GLenum func;
} depthPathCustomRec;

typedef struct _ditherPathCustomRec {
    long testMode;
    GLenum state;
} ditherPathCustomRec;

typedef struct _fogPathCustomRec {
    long testMode;
    GLenum state;
    GLfloat color[4], index;
    GLfloat density;
    GLfloat start, end;
    GLenum mode;
} fogPathCustomRec;

typedef struct _logicOpPathCustomRec {
    long testMode;
    GLenum state;
    GLenum func;
} logicOpPathCustomRec;

typedef struct _shadePathCustomRec {
    long testMode;
    GLenum mode;
} shadePathCustomRec;

typedef struct _stencilPathCustomRec {
    long testMode;
    GLenum state;
    GLint clear;
    GLuint writeMask;
    GLenum func; 
    GLint ref; 
    GLuint mask;
    GLuint op1, op2, op3;
} stencilPathCustomRec;

typedef struct _stipplePathCustomRec {
    long testMode;
    GLenum state;
    GLint lineRepeat;
    GLushort lineStipple;
    GLubyte polygonStipple[128];
} stipplePathCustomRec;


extern aliasPathCustomRec aliasPath0;
extern aliasPathCustomRec aliasPath1;
extern aliasPathCustomRec aliasPath2;
extern alphaPathCustomRec alphaPath0;
extern alphaPathCustomRec alphaPath1;
extern alphaPathCustomRec alphaPath2;
extern blendPathCustomRec blendPath0;
extern blendPathCustomRec blendPath1;
extern blendPathCustomRec blendPath2;
extern depthPathCustomRec depthPath0;
extern depthPathCustomRec depthPath1;
extern depthPathCustomRec depthPath2;
extern ditherPathCustomRec ditherPath0;
extern ditherPathCustomRec ditherPath1;
extern ditherPathCustomRec ditherPath2;
extern fogPathCustomRec fogPath0;
extern fogPathCustomRec fogPath1;
extern fogPathCustomRec fogPath2;
extern logicOpPathCustomRec logicOpPath0;
extern logicOpPathCustomRec logicOpPath1;
extern logicOpPathCustomRec logicOpPath2;
extern shadePathCustomRec shadePath0;
extern shadePathCustomRec shadePath1;
extern shadePathCustomRec shadePath2;
extern shadePathCustomRec shadePath3;
extern stencilPathCustomRec stencilPath0;
extern stencilPathCustomRec stencilPath1;
extern stencilPathCustomRec stencilPath2;
extern stipplePathCustomRec stipplePath0;
extern stipplePathCustomRec stipplePath1;
extern stipplePathCustomRec stipplePath2;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\confshel\util.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <stdarg.h>
#include <GL/gl.h>
#include "conform.h"
#include "pathdata.h"
#include "path.h"
#include "util.h"
#include "utils.h"


struct _enumInfoRec {
    char name[40];
    long value;
} enumInfo[] = {
    {
	"GL_2_BYTES", GL_2_BYTES
    },
    {
	"GL_3_BYTES", GL_3_BYTES
    },
    {
	"GL_4_BYTES", GL_4_BYTES
    },
    {
	"GL_2D", GL_2D
    },
    {
	"GL_3D", GL_3D
    },
    {
	"GL_3D_COLOR", GL_3D_COLOR
    },
    {
	"GL_3D_COLOR_TEXTURE", GL_3D_COLOR_TEXTURE
    },
    {
	"GL_4D_COLOR_TEXTURE", GL_4D_COLOR_TEXTURE
    },
    {
	"GL_ACCUM", GL_ACCUM
    },
    {
	"GL_ACCUM_ALPHA_BITS", GL_ACCUM_ALPHA_BITS
    },
    {
	"GL_ACCUM_BLUE_BITS", GL_ACCUM_BLUE_BITS
    },
    {
	"GL_ACCUM_CLEAR_VALUE", GL_ACCUM_CLEAR_VALUE
    },
    {
	"GL_ACCUM_GREEN_BITS", GL_ACCUM_GREEN_BITS
    },
    {
	"GL_ACCUM_RED_BITS", GL_ACCUM_RED_BITS
    },
    {
	"GL_ADD", GL_ADD
    },
    {
	"GL_ALL_ATTRIB_BITS", GL_ALL_ATTRIB_BITS
    },
    {
	"GL_ALPHA", GL_ALPHA
    },
    {
	"GL_ALPHA_BIAS", GL_ALPHA_BIAS
    },
    {
	"GL_ALPHA_BITS", GL_ALPHA_BITS
    },
    {
	"GL_ALPHA_SCALE", GL_ALPHA_SCALE
    },
    {
	"GL_ALPHA_TEST", GL_ALPHA_TEST
    },
    {
	"GL_ALPHA_TEST_FUNC", GL_ALPHA_TEST_FUNC
    },
    {
	"GL_ALPHA_TEST_REF", GL_ALPHA_TEST_REF
    },
    {
	"GL_ALWAYS", GL_ALWAYS
    },
    {
	"GL_AMBIENT", GL_AMBIENT
    },
    {
	"GL_AMBIENT_AND_DIFFUSE", GL_AMBIENT_AND_DIFFUSE
    },
    {
	"GL_AND", GL_AND
    },
    {
	"GL_AND_INVERTED", GL_AND_INVERTED
    },
    {
	"GL_AND_REVERSE", GL_AND_REVERSE
    },
    {
	"GL_ATTRIB_STACK_DEPTH", GL_ATTRIB_STACK_DEPTH
    },
    {
	"GL_AUTO_NORMAL", GL_AUTO_NORMAL
    },
    {
	"GL_AUX_BUFFERS", GL_AUX_BUFFERS
    },
    {
	"GL_AUX0", GL_AUX0
    },
    {
	"GL_AUX1", GL_AUX1
    },
    {
	"GL_AUX2", GL_AUX2
    },
    {
	"GL_AUX3", GL_AUX3
    },
    {
	"GL_BACK", GL_BACK
    },
    {
	"GL_BACK_LEFT", GL_BACK_LEFT
    },
    {
	"GL_BACK_RIGHT", GL_BACK_RIGHT
    },
    {
	"GL_BITMAP", GL_BITMAP
    },
    {
	"GL_BITMAP_TOKEN", GL_BITMAP_TOKEN
    },
    {
	"GL_BLEND", GL_BLEND
    },
    {
	"GL_BLEND_DST", GL_BLEND_DST
    },
    {
	"GL_BLEND_SRC", GL_BLEND_SRC
    },
    {
	"GL_BLUE", GL_BLUE
    },
    {
	"GL_BLUE_BIAS", GL_BLUE_BIAS
    },
    {
	"GL_BLUE_BITS", GL_BLUE_BITS
    },
    {
	"GL_BLUE_SCALE", GL_BLUE_SCALE
    },
    {
	"GL_BYTE", GL_BYTE
    },
    {
	"GL_CCW", GL_CCW
    },
    {
	"GL_CLAMP", GL_CLAMP
    },
    {
	"GL_CLEAR", GL_CLEAR
    },
    {
	"GL_CLIP_PLANE0", GL_CLIP_PLANE0
    },
    {
	"GL_CLIP_PLANE1", GL_CLIP_PLANE1
    },
    {
	"GL_CLIP_PLANE2", GL_CLIP_PLANE2
    },
    {
	"GL_CLIP_PLANE3", GL_CLIP_PLANE3
    },
    {
	"GL_CLIP_PLANE4", GL_CLIP_PLANE4
    },
    {
	"GL_CLIP_PLANE5", GL_CLIP_PLANE5
    },
    {
	"GL_COEFF", GL_COEFF
    },
    {
	"GL_COLOR", GL_COLOR
    },
    {
	"GL_COLOR_CLEAR_VALUE", GL_COLOR_CLEAR_VALUE
    },
    {
	"GL_COLOR_INDEX", GL_COLOR_INDEX
    },
    {
	"GL_COLOR_INDEXES", GL_COLOR_INDEXES
    },
    {
	"GL_COLOR_MATERIAL", GL_COLOR_MATERIAL
    },
    {
	"GL_COLOR_MATERIAL_FACE", GL_COLOR_MATERIAL_FACE
    },
    {
	"GL_COLOR_MATERIAL_PARAMETER", GL_COLOR_MATERIAL_PARAMETER
    },
    {
	"GL_COLOR_WRITEMASK", GL_COLOR_WRITEMASK
    },
    {
	"GL_COMPILE", GL_COMPILE
    },
    {
	"GL_COMPILE_AND_EXECUTE", GL_COMPILE_AND_EXECUTE
    },
    {
	"GL_CONSTANT_ATTENUATION", GL_CONSTANT_ATTENUATION
    },
    {
	"GL_COPY", GL_COPY
    },
    {
	"GL_COPY_INVERTED", GL_COPY_INVERTED
    },
    {
	"GL_COPY_PIXEL_TOKEN", GL_COPY_PIXEL_TOKEN
    },
    {
	"GL_CULL_FACE", GL_CULL_FACE
    },
    {
	"GL_CULL_FACE_MODE", GL_CULL_FACE_MODE
    },
    {
	"GL_CURRENT_COLOR", GL_CURRENT_COLOR
    },
    {
	"GL_CURRENT_INDEX", GL_CURRENT_INDEX
    },
    {
	"GL_CURRENT_NORMAL", GL_CURRENT_NORMAL
    },
    {
	"GL_CURRENT_RASTER_COLOR", GL_CURRENT_RASTER_COLOR
    },
    {
	"GL_CURRENT_RASTER_INDEX", GL_CURRENT_RASTER_INDEX
    },
    {
	"GL_CURRENT_RASTER_POSITION", GL_CURRENT_RASTER_POSITION
    },
    {
	"GL_CURRENT_RASTER_POSITION_VALID", GL_CURRENT_RASTER_POSITION_VALID
    },
    {
	"GL_CURRENT_RASTER_TEXTURE_COORDS", GL_CURRENT_RASTER_TEXTURE_COORDS
    },
    {
	"GL_CURRENT_TEXTURE_COORDS", GL_CURRENT_TEXTURE_COORDS
    },
    {
	"GL_CW", GL_CW
    },
    {
	"GL_DECAL", GL_DECAL
    },
    {
	"GL_DECR", GL_DECR
    },
    {
	"GL_DEPTH", GL_DEPTH
    },
    {
	"GL_DEPTH_BIAS", GL_DEPTH_BIAS
    },
    {
	"GL_DEPTH_BITS", GL_DEPTH_BITS
    },
    {
	"GL_DEPTH_CLEAR_VALUE", GL_DEPTH_CLEAR_VALUE
    },
    {
	"GL_DEPTH_COMPONENT", GL_DEPTH_COMPONENT
    },
    {
	"GL_DEPTH_FUNC", GL_DEPTH_FUNC
    },
    {
	"GL_DEPTH_RANGE", GL_DEPTH_RANGE
    },
    {
	"GL_DEPTH_SCALE", GL_DEPTH_SCALE
    },
    {
	"GL_DEPTH_TEST", GL_DEPTH_TEST
    },
    {
	"GL_DEPTH_WRITEMASK", GL_DEPTH_WRITEMASK
    },
    {
	"GL_DIFFUSE", GL_DIFFUSE
    },
    {
	"GL_DITHER", GL_DITHER
    },
    {
	"GL_DOMAIN", GL_DOMAIN
    },
    {
	"GL_DONT_CARE", GL_DONT_CARE
    },
    {
	"GL_DOUBLEBUFFER", GL_DOUBLEBUFFER
    },
    {
	"GL_DRAW_BUFFER", GL_DRAW_BUFFER
    },
    {
	"GL_DRAW_PIXEL_TOKEN", GL_DRAW_PIXEL_TOKEN
    },
    {
	"GL_DST_ALPHA", GL_DST_ALPHA
    },
    {
	"GL_DST_COLOR", GL_DST_COLOR
    },
    {
	"GL_EDGE_FLAG", GL_EDGE_FLAG
    },
    {
	"GL_EMISSION", GL_EMISSION
    },
    {
	"GL_EQUAL", GL_EQUAL
    },
    {
	"GL_EQUIV", GL_EQUIV
    },
    {
	"GL_EXP", GL_EXP
    },
    {
	"GL_EXP2", GL_EXP2
    },
    {
	"GL_EXTENSIONS", GL_EXTENSIONS
    },
    {
	"GL_EYE_LINEAR", GL_EYE_LINEAR
    },
    {
	"GL_EYE_PLANE", GL_EYE_PLANE
    },
    {
	"GL_FASTEST", GL_FASTEST
    },
    {
	"GL_FEEDBACK", GL_FEEDBACK
    },
    {
	"GL_FILL", GL_FILL
    },
    {
	"GL_FLAT", GL_FLAT
    },
    {
	"GL_FLOAT", GL_FLOAT
    },
    {
	"GL_FOG", GL_FOG
    },
    {
	"GL_FOG_COLOR", GL_FOG_COLOR
    },
    {
	"GL_FOG_DENSITY", GL_FOG_DENSITY
    },
    {
	"GL_FOG_END", GL_FOG_END
    },
    {
	"GL_FOG_HINT", GL_FOG_HINT
    },
    {
	"GL_FOG_INDEX", GL_FOG_INDEX
    },
    {
	"GL_FOG_MODE", GL_FOG_MODE
    },
    {
	"GL_FOG_START", GL_FOG_START
    },
    {
	"GL_FRONT", GL_FRONT
    },
    {
	"GL_FRONT_AND_BACK", GL_FRONT_AND_BACK
    },
    {
	"GL_FRONT_FACE", GL_FRONT_FACE
    },
    {
	"GL_FRONT_LEFT", GL_FRONT_LEFT
    },
    {
	"GL_FRONT_RIGHT", GL_FRONT_RIGHT
    },
    {
	"GL_GEQUAL", GL_GEQUAL
    },
    {
	"GL_GREATER", GL_GREATER
    },
    {
	"GL_GREEN", GL_GREEN
    },
    {
	"GL_GREEN_BIAS", GL_GREEN_BIAS
    },
    {
	"GL_GREEN_BITS", GL_GREEN_BITS
    },
    {
	"GL_GREEN_SCALE", GL_GREEN_SCALE
    },
    {
	"GL_INCR", GL_INCR
    },
    {
	"GL_INDEX_BITS", GL_INDEX_BITS
    },
    {
	"GL_INDEX_CLEAR_VALUE", GL_INDEX_CLEAR_VALUE
    },
    {
	"GL_INDEX_MODE", GL_INDEX_MODE
    },
    {
	"GL_INDEX_OFFSET", GL_INDEX_OFFSET
    },
    {
	"GL_INDEX_SHIFT", GL_INDEX_SHIFT
    },
    {
	"GL_INDEX_WRITEMASK", GL_INDEX_WRITEMASK
    },
    {
	"GL_INT", GL_INT
    },
    {
	"GL_INVALID_ENUM", GL_INVALID_ENUM
    },
    {
	"GL_INVALID_OPERATION", GL_INVALID_OPERATION
    },
    {
	"GL_INVALID_VALUE", GL_INVALID_VALUE
    },
    {
	"GL_INVERT", GL_INVERT
    },
    {
	"GL_KEEP", GL_KEEP
    },
    {
	"GL_LEFT", GL_LEFT
    },
    {
	"GL_LEQUAL", GL_LEQUAL
    },
    {
	"GL_LESS", GL_LESS
    },
    {
	"GL_LIGHT_MODEL_AMBIENT", GL_LIGHT_MODEL_AMBIENT
    },
    {
	"GL_LIGHT_MODEL_LOCAL_VIEWER", GL_LIGHT_MODEL_LOCAL_VIEWER
    },
    {
	"GL_LIGHT_MODEL_TWO_SIDE", GL_LIGHT_MODEL_TWO_SIDE
    },
    {
	"GL_LIGHT0", GL_LIGHT0
    },
    {
	"GL_LIGHT1", GL_LIGHT1
    },
    {
	"GL_LIGHT2", GL_LIGHT2
    },
    {
	"GL_LIGHT3", GL_LIGHT3
    },
    {
	"GL_LIGHT4", GL_LIGHT4
    },
    {
	"GL_LIGHT5", GL_LIGHT5
    },
    {
	"GL_LIGHT6", GL_LIGHT6
    },
    {
	"GL_LIGHT7", GL_LIGHT7
    },
    {
	"GL_LIGHTING", GL_LIGHTING
    },
    {
	"GL_LINE", GL_LINE
    },
    {
	"GL_LINE_LOOP", GL_LINE_LOOP
    },
    {
	"GL_LINE_RESET_TOKEN", GL_LINE_RESET_TOKEN
    },
    {
	"GL_LINE_SMOOTH", GL_LINE_SMOOTH
    },
    {
	"GL_LINE_SMOOTH_HINT", GL_LINE_SMOOTH_HINT
    },
    {
	"GL_LINE_STIPPLE", GL_LINE_STIPPLE
    },
    {
	"GL_LINE_STIPPLE_PATTERN", GL_LINE_STIPPLE_PATTERN
    },
    {
	"GL_LINE_STIPPLE_REPEAT", GL_LINE_STIPPLE_REPEAT
    },
    {
	"GL_LINE_STRIP", GL_LINE_STRIP
    },
    {
	"GL_LINE_TOKEN", GL_LINE_TOKEN
    },
    {
	"GL_LINE_WIDTH", GL_LINE_WIDTH
    },
    {
	"GL_LINE_WIDTH_GRANULARITY", GL_LINE_WIDTH_GRANULARITY
    },
    {
	"GL_LINE_WIDTH_RANGE", GL_LINE_WIDTH_RANGE
    },
    {
	"GL_LINEAR", GL_LINEAR
    },
    {
	"GL_LINEAR_ATTENUATION", GL_LINEAR_ATTENUATION
    },
    {
	"GL_LINEAR_MIPMAP_NEAREST", GL_LINEAR_MIPMAP_NEAREST
    },
    {
	"GL_LINEAR_MIPMAP_LINEAR", GL_LINEAR_MIPMAP_LINEAR
    },
    {
	"GL_LINES", GL_LINES
    },
    {
	"GL_LIST_BASE", GL_LIST_BASE
    },
    {
	"GL_LIST_INDEX", GL_LIST_INDEX
    },
    {
	"GL_LIST_MODE", GL_LIST_MODE
    },
    {
	"GL_LOAD", GL_LOAD
    },
    {
	"GL_LOGIC_OP", GL_LOGIC_OP
    },
    {
	"GL_LOGIC_OP_MODE", GL_LOGIC_OP_MODE
    },
    {
	"GL_LUMINANCE", GL_LUMINANCE
    },
    {
	"GL_LUMINANCE_ALPHA", GL_LUMINANCE_ALPHA
    },
    {
	"GL_MAP_COLOR", GL_MAP_COLOR
    },
    {
	"GL_MAP_STENCIL", GL_MAP_STENCIL
    },
    {
	"GL_MAP1_COLOR_4", GL_MAP1_COLOR_4
    },
    {
	"GL_MAP1_GRID_DOMAIN", GL_MAP1_GRID_DOMAIN
    },
    {
	"GL_MAP1_GRID_SEGMENTS", GL_MAP1_GRID_SEGMENTS
    },
    {
	"GL_MAP1_INDEX", GL_MAP1_INDEX
    },
    {
	"GL_MAP1_NORMAL", GL_MAP1_NORMAL
    },
    {
	"GL_MAP1_TEXTURE_COORD_1", GL_MAP1_TEXTURE_COORD_1
    },
    {
	"GL_MAP1_TEXTURE_COORD_2", GL_MAP1_TEXTURE_COORD_2
    },
    {
	"GL_MAP1_TEXTURE_COORD_3", GL_MAP1_TEXTURE_COORD_3
    },
    {
	"GL_MAP1_TEXTURE_COORD_4", GL_MAP1_TEXTURE_COORD_4
    },
    {
	"GL_MAP1_VERTEX_3", GL_MAP1_VERTEX_3
    },
    {
	"GL_MAP1_VERTEX_4", GL_MAP1_VERTEX_4
    },
    {
	"GL_MAP2_COLOR_4", GL_MAP2_COLOR_4
    },
    {
	"GL_MAP2_GRID_DOMAIN", GL_MAP2_GRID_DOMAIN
    },
    {
	"GL_MAP2_GRID_SEGMENTS", GL_MAP2_GRID_SEGMENTS
    },
    {
	"GL_MAP2_INDEX", GL_MAP2_INDEX
    },
    {
	"GL_MAP2_NORMAL", GL_MAP2_NORMAL
    },
    {
	"GL_MAP2_TEXTURE_COORD_1", GL_MAP2_TEXTURE_COORD_1
    },
    {
	"GL_MAP2_TEXTURE_COORD_2", GL_MAP2_TEXTURE_COORD_2
    },
    {
	"GL_MAP2_TEXTURE_COORD_3", GL_MAP2_TEXTURE_COORD_3
    },
    {
	"GL_MAP2_TEXTURE_COORD_4", GL_MAP2_TEXTURE_COORD_4
    },
    {
	"GL_MAP2_VERTEX_3", GL_MAP2_VERTEX_3
    },
    {
	"GL_MAP2_VERTEX_4", GL_MAP2_VERTEX_4
    },
    {
	"GL_MATRIX_MODE", GL_MATRIX_MODE
    },
    {
	"GL_MAX_ATTRIB_STACK_DEPTH", GL_MAX_ATTRIB_STACK_DEPTH
    },
    {
	"GL_MAX_CLIP_PLANES", GL_MAX_CLIP_PLANES
    },
    {
	"GL_MAX_EVAL_ORDER", GL_MAX_EVAL_ORDER
    },
    {
	"GL_MAX_LIGHTS", GL_MAX_LIGHTS
    },
    {
	"GL_MAX_LIST_NESTING", GL_MAX_LIST_NESTING
    },
    {
	"GL_MAX_MODELVIEW_STACK_DEPTH", GL_MAX_MODELVIEW_STACK_DEPTH
    },
    {
	"GL_MAX_NAME_STACK_DEPTH", GL_MAX_NAME_STACK_DEPTH
    },
    {
	"GL_MAX_PIXEL_MAP_TABLE", GL_MAX_PIXEL_MAP_TABLE
    },
    {
	"GL_MAX_PROJECTION_STACK_DEPTH", GL_MAX_PROJECTION_STACK_DEPTH
    },
    {
	"GL_MAX_TEXTURE_SIZE", GL_MAX_TEXTURE_SIZE
    },
    {
	"GL_MAX_TEXTURE_STACK_DEPTH", GL_MAX_TEXTURE_STACK_DEPTH
    },
    {
	"GL_MAX_VIEWPORT_DIMS", GL_MAX_VIEWPORT_DIMS
    },
    {
	"GL_MODELVIEW", GL_MODELVIEW
    },
    {
	"GL_MODELVIEW_MATRIX", GL_MODELVIEW_MATRIX
    },
    {
	"GL_MODELVIEW_STACK_DEPTH", GL_MODELVIEW_STACK_DEPTH
    },
    {
	"GL_MODULATE", GL_MODULATE
    },
    {
	"GL_MULT", GL_MULT
    },
    {
	"GL_NAME_STACK_DEPTH", GL_NAME_STACK_DEPTH
    },
    {
	"GL_NAND", GL_NAND
    },
    {
	"GL_NEAREST", GL_NEAREST
    },
    {
	"GL_NEAREST_MIPMAP_LINEAR", GL_NEAREST_MIPMAP_LINEAR
    },
    {
	"GL_NEAREST_MIPMAP_NEAREST", GL_NEAREST_MIPMAP_NEAREST
    },
    {
	"GL_NEVER", GL_NEVER
    },
    {
	"GL_NICEST", GL_NICEST
    },
    {
	"GL_NONE", GL_NONE
    },
    {
	"GL_NOOP", GL_NOOP
    },
    {
	"GL_NOR", GL_NOR
    },
    {
	"GL_NORMALIZE", GL_NORMALIZE
    },
    {
	"GL_NOTEQUAL", GL_NOTEQUAL
    },
    {
	"GL_OBJECT_LINEAR", GL_OBJECT_LINEAR
    },
    {
	"GL_OBJECT_PLANE", GL_OBJECT_PLANE
    },
    {
	"GL_ONE", GL_ONE
    },
    {
	"GL_ONE_MINUS_DST_ALPHA", GL_ONE_MINUS_DST_ALPHA
    },
    {
	"GL_ONE_MINUS_DST_COLOR", GL_ONE_MINUS_DST_COLOR
    },
    {
	"GL_ONE_MINUS_SRC_ALPHA", GL_ONE_MINUS_SRC_ALPHA
    },
    {
	"GL_ONE_MINUS_SRC_COLOR", GL_ONE_MINUS_SRC_COLOR
    },
    {
	"GL_OR", GL_OR
    },
    {
	"GL_OR_INVERTED", GL_OR_INVERTED
    },
    {
	"GL_OR_REVERSE", GL_OR_REVERSE
    },
    {
	"GL_ORDER", GL_ORDER
    },
    {
	"GL_OUT_OF_MEMORY", GL_OUT_OF_MEMORY
    },
    {
	"GL_PACK_ALIGNMENT", GL_PACK_ALIGNMENT
    },
    {
	"GL_PACK_LSB_FIRST", GL_PACK_LSB_FIRST
    },
    {
	"GL_PACK_ROW_LENGTH", GL_PACK_ROW_LENGTH
    },
    {
	"GL_PACK_SKIP_PIXELS", GL_PACK_SKIP_PIXELS
    },
    {
	"GL_PACK_SKIP_ROWS", GL_PACK_SKIP_ROWS
    },
    {
	"GL_PACK_SWAP_BYTES", GL_PACK_SWAP_BYTES
    },
    {
	"GL_PASS_THROUGH_TOKEN", GL_PASS_THROUGH_TOKEN
    },
    {
	"GL_PERSPECTIVE_CORRECTION_HINT", GL_PERSPECTIVE_CORRECTION_HINT
    },
    {
	"GL_PIXEL_MAP_A_TO_A", GL_PIXEL_MAP_A_TO_A
    },
    {
	"GL_PIXEL_MAP_A_TO_A_SIZE", GL_PIXEL_MAP_A_TO_A_SIZE
    },
    {
	"GL_PIXEL_MAP_B_TO_B", GL_PIXEL_MAP_B_TO_B
    },
    {
	"GL_PIXEL_MAP_B_TO_B_SIZE", GL_PIXEL_MAP_B_TO_B_SIZE
    },
    {
	"GL_PIXEL_MAP_G_TO_G", GL_PIXEL_MAP_G_TO_G
    },
    {
	"GL_PIXEL_MAP_G_TO_G_SIZE", GL_PIXEL_MAP_G_TO_G_SIZE
    },
    {
	"GL_PIXEL_MAP_I_TO_A", GL_PIXEL_MAP_I_TO_A
    },
    {
	"GL_PIXEL_MAP_I_TO_A_SIZE", GL_PIXEL_MAP_I_TO_A_SIZE
    },
    {
	"GL_PIXEL_MAP_I_TO_B", GL_PIXEL_MAP_I_TO_B
    },
    {
	"GL_PIXEL_MAP_I_TO_B_SIZE", GL_PIXEL_MAP_I_TO_B_SIZE
    },
    {
	"GL_PIXEL_MAP_I_TO_G", GL_PIXEL_MAP_I_TO_G
    },
    {
	"GL_PIXEL_MAP_I_TO_G_SIZE", GL_PIXEL_MAP_I_TO_G_SIZE
    },
    {
	"GL_PIXEL_MAP_I_TO_I", GL_PIXEL_MAP_I_TO_I
    },
    {
	"GL_PIXEL_MAP_I_TO_I_SIZE", GL_PIXEL_MAP_I_TO_I_SIZE
    },
    {
	"GL_PIXEL_MAP_I_TO_R", GL_PIXEL_MAP_I_TO_R
    },
    {
	"GL_PIXEL_MAP_I_TO_R_SIZE", GL_PIXEL_MAP_I_TO_R_SIZE
    },
    {
	"GL_PIXEL_MAP_R_TO_R", GL_PIXEL_MAP_R_TO_R
    },
    {
	"GL_PIXEL_MAP_R_TO_R_SIZE", GL_PIXEL_MAP_R_TO_R_SIZE
    },
    {
	"GL_PIXEL_MAP_S_TO_S", GL_PIXEL_MAP_S_TO_S
    },
    {
	"GL_PIXEL_MAP_S_TO_S_SIZE", GL_PIXEL_MAP_S_TO_S_SIZE
    },
    {
	"GL_POINT", GL_POINT
    },
    {
	"GL_POINT_SIZE", GL_POINT_SIZE
    },
    {
	"GL_POINT_SIZE_GRANULARITY", GL_POINT_SIZE_GRANULARITY
    },
    {
	"GL_POINT_SIZE_RANGE", GL_POINT_SIZE_RANGE
    },
    {
	"GL_POINT_SMOOTH", GL_POINT_SMOOTH
    },
    {
	"GL_POINT_SMOOTH_HINT", GL_POINT_SMOOTH_HINT
    },
    {
	"GL_POINT_TOKEN", GL_POINT_TOKEN
    },
    {
	"GL_POINTS", GL_POINTS
    },
    {
	"GL_POLYGON", GL_POLYGON
    },
    {
	"GL_POLYGON_MODE", GL_POLYGON_MODE
    },
    {
	"GL_POLYGON_SMOOTH", GL_POLYGON_SMOOTH
    },
    {
	"GL_POLYGON_SMOOTH_HINT", GL_POLYGON_SMOOTH_HINT
    },
    {
	"GL_POLYGON_STIPPLE", GL_POLYGON_STIPPLE
    },
    {
	"GL_POLYGON_TOKEN", GL_POLYGON_TOKEN
    },
    {
	"GL_POSITION", GL_POSITION
    },
    {
	"GL_PROJECTION", GL_PROJECTION
    },
    {
	"GL_PROJECTION_MATRIX", GL_PROJECTION_MATRIX
    },
    {
	"GL_PROJECTION_STACK_DEPTH", GL_PROJECTION_STACK_DEPTH
    },
    {
	"GL_Q", GL_Q
    },
    {
	"GL_QUAD_STRIP", GL_QUAD_STRIP
    },
    {
	"GL_QUADRATIC_ATTENUATION", GL_QUADRATIC_ATTENUATION
    },
    {
	"GL_QUADS", GL_QUADS
    },
    {
	"GL_R", GL_R
    },
    {
	"GL_READ_BUFFER", GL_READ_BUFFER
    },
    {
	"GL_RED", GL_RED
    },
    {
	"GL_RED_BIAS", GL_RED_BIAS
    },
    {
	"GL_RED_BITS", GL_RED_BITS
    },
    {
	"GL_RED_SCALE", GL_RED_SCALE
    },
    {
	"GL_RENDER", GL_RENDER
    },
    {
	"GL_RENDER_MODE", GL_RENDER_MODE
    },
    {
	"GL_RENDERER", GL_RENDERER
    },
    {
	"GL_REPEAT", GL_REPEAT
    },
    {
	"GL_REPLACE", GL_REPLACE
    },
    {
	"GL_RETURN", GL_RETURN
    },
    {
	"GL_RGB", GL_RGB
    },
    {
	"GL_RGBA", GL_RGBA
    },
    {
	"GL_RGBA_MODE", GL_RGBA_MODE
    },
    {
	"GL_RIGHT", GL_RIGHT
    },
    {
	"GL_S", GL_S
    },
    {
	"GL_SHININESS", GL_SHININESS
    },
    {
	"GL_SPECULAR", GL_SPECULAR
    },
    {
	"GL_SRC_ALPHA", GL_SRC_ALPHA
    },
    {
	"GL_SRC_ALPHA_SATURATE", GL_SRC_ALPHA_SATURATE
    },
    {
	"GL_SRC_COLOR", GL_SRC_COLOR
    },
    {
	"GL_SCISSOR_BOX", GL_SCISSOR_BOX
    },
    {
	"GL_SCISSOR_TEST", GL_SCISSOR_TEST
    },
    {
	"GL_SELECT", GL_SELECT
    },
    {
	"GL_SET", GL_SET
    },
    {
	"GL_SHADE_MODEL", GL_SHADE_MODEL
    },
    {
	"GL_SHORT", GL_SHORT
    },
    {
	"GL_SMOOTH", GL_SMOOTH
    },
    {
	"GL_SPHERE_MAP", GL_SPHERE_MAP
    },
    {
	"GL_SPOT_CUTOFF", GL_SPOT_CUTOFF
    },
    {
	"GL_SPOT_DIRECTION", GL_SPOT_DIRECTION
    },
    {
	"GL_SPOT_EXPONENT", GL_SPOT_EXPONENT
    },
    {
	"GL_STACK_OVERFLOW", GL_STACK_OVERFLOW
    },
    {
	"GL_STACK_UNDERFLOW", GL_STACK_UNDERFLOW
    },
    {
	"GL_STENCIL", GL_STENCIL
    },
    {
	"GL_STENCIL_BITS", GL_STENCIL_BITS
    },
    {
	"GL_STENCIL_CLEAR_VALUE", GL_STENCIL_CLEAR_VALUE
    },
    {
	"GL_STENCIL_FAIL", GL_STENCIL_FAIL
    },
    {
	"GL_STENCIL_FUNC", GL_STENCIL_FUNC
    },
    {
	"GL_STENCIL_INDEX", GL_STENCIL_INDEX
    },
    {
	"GL_STENCIL_PASS_DEPTH_FAIL", GL_STENCIL_PASS_DEPTH_FAIL
    },
    {
	"GL_STENCIL_PASS_DEPTH_PASS", GL_STENCIL_PASS_DEPTH_PASS
    },
    {
	"GL_STENCIL_REF", GL_STENCIL_REF
    },
    {
	"GL_STENCIL_TEST", GL_STENCIL_TEST
    },
    {
	"GL_STENCIL_VALUE_MASK", GL_STENCIL_VALUE_MASK
    },
    {
	"GL_STENCIL_WRITEMASK", GL_STENCIL_WRITEMASK
    },
    {
	"GL_STEREO", GL_STEREO
    },
    {
	"GL_SUBPIXEL_BITS", GL_SUBPIXEL_BITS
    },
    {
	"GL_T", GL_T
    },
    {
	"GL_TEXTURE", GL_TEXTURE
    },
    {
	"GL_TEXTURE_1D", GL_TEXTURE_1D
    },
    {
	"GL_TEXTURE_2D", GL_TEXTURE_2D
    },
    {
	"GL_TEXTURE_BORDER", GL_TEXTURE_BORDER
    },
    {
	"GL_TEXTURE_BORDER_COLOR", GL_TEXTURE_BORDER_COLOR
    },
    {
	"GL_TEXTURE_COMPONENTS", GL_TEXTURE_COMPONENTS
    },
    {
	"GL_TEXTURE_ENV", GL_TEXTURE_ENV
    },
    {
	"GL_TEXTURE_ENV_COLOR", GL_TEXTURE_ENV_COLOR
    },
    {
	"GL_TEXTURE_ENV_MODE", GL_TEXTURE_ENV_MODE
    },
    {
	"GL_TEXTURE_GEN_MODE", GL_TEXTURE_GEN_MODE
    },
    {
	"GL_TEXTURE_GEN_Q", GL_TEXTURE_GEN_Q
    },
    {
	"GL_TEXTURE_GEN_R", GL_TEXTURE_GEN_R
    },
    {
	"GL_TEXTURE_GEN_S", GL_TEXTURE_GEN_S
    },
    {
	"GL_TEXTURE_GEN_T", GL_TEXTURE_GEN_T
    },
    {
	"GL_TEXTURE_HEIGHT", GL_TEXTURE_HEIGHT
    },
    {
	"GL_TEXTURE_MAG_FILTER", GL_TEXTURE_MAG_FILTER
    },
    {
	"GL_TEXTURE_MATRIX", GL_TEXTURE_MATRIX
    },
    {
	"GL_TEXTURE_MIN_FILTER", GL_TEXTURE_MIN_FILTER
    },
    {
	"GL_TEXTURE_STACK_DEPTH", GL_TEXTURE_STACK_DEPTH
    },
    {
	"GL_TEXTURE_WIDTH", GL_TEXTURE_WIDTH
    },
    {
	"GL_TEXTURE_WRAP_S", GL_TEXTURE_WRAP_S
    },
    {
	"GL_TEXTURE_WRAP_T", GL_TEXTURE_WRAP_T
    },
    {
	"GL_TRIANGLES", GL_TRIANGLES
    },
    {
	"GL_TRIANGLE_FAN", GL_TRIANGLE_FAN
    },
    {
	"GL_TRIANGLE_STRIP", GL_TRIANGLE_STRIP
    },
    {
	"GL_UNPACK_ALIGNMENT", GL_UNPACK_ALIGNMENT
    },
    {
	"GL_UNPACK_LSB_FIRST", GL_UNPACK_LSB_FIRST
    },
    {
	"GL_UNPACK_ROW_LENGTH", GL_UNPACK_ROW_LENGTH
    },
    {
	"GL_UNPACK_SKIP_PIXELS", GL_UNPACK_SKIP_PIXELS
    },
    {
	"GL_UNPACK_SKIP_ROWS", GL_UNPACK_SKIP_ROWS
    },
    {
	"GL_UNPACK_SWAP_BYTES", GL_UNPACK_SWAP_BYTES
    },
    {
	"GL_UNSIGNED_BYTE", GL_UNSIGNED_BYTE
    },
    {
	"GL_UNSIGNED_INT", GL_UNSIGNED_INT
    },
    {
	"GL_UNSIGNED_SHORT", GL_UNSIGNED_SHORT
    },
    {
	"GL_VENDOR", GL_VENDOR
    },
    {
	"GL_VIEWPORT", GL_VIEWPORT
    },
    {
	"GL_XOR", GL_XOR
    },
    {
	"GL_ZERO", GL_ZERO
    },
    {
	"GL_ZOOM_X", GL_ZOOM_X
    },
    {
	"GL_ZOOM_Y", GL_ZOOM_Y
    },
    {
	"GL_VERSION", GL_VERSION
    },
    {
	"Bad enumeration", GL_NULL
    }
};


void AutoClearColor(GLint color)
{

    if (buffer.colorMode == GL_RGB) {
	glClearColor(colorMap[color][0], colorMap[color][1], colorMap[color][2],
		     1.0);
    } else {
	glClearIndex(color);
    }
}

void AutoColor(GLint color)
{

    if (buffer.colorMode == GL_RGB) {
	glColor4f(colorMap[color][0], colorMap[color][1], colorMap[color][2],
		  1.0);
    } else {
	glIndexi(color);
    }
}

long AutoColorCompare(GLfloat buf, GLint color)
{

    if (ABS(buf-(GLfloat)color) < epsilon.zero) {
	return GL_TRUE;
    } else {
	return GL_FALSE;
    }
}

void ErrorReport(char *fileName, long line, char *errStr)
{
    char buf[80];
    long flag, i, j, k, l;

    Output(1, " failed.\n");

    Output(2, "    File - %s, line - %d.\n", fileName, line);
    if (errStr) {
	i = 0;
	while (1) {
	    while (1) {
		if (errStr[i] == 0x0) {
		    flag = GL_TRUE;
		    break;
		} else if (errStr[i] != ' ' && errStr[i] != '\n') {
		    flag = GL_FALSE;
		    break;
		} else {
		    i++;
		}
	    }
	    if (flag == GL_TRUE) {
		break;
	    }
	    j = i;
	    k = i;
	    while (1) {
		while (1) {
		    if (errStr[j] == 0x0 || errStr[j] == '\n') {
			flag = GL_TRUE;
			break;
		    } else if (errStr[j] == ' ') {
			flag = GL_FALSE;
			break;
		    } else {
			j++;
		    }
		}
		if (j-i+1 > 80-10) {
		    if (k == i) {
			k = i + 60;
			for (l = 0; l < 80-10; l++, i++) {
			    buf[l] = errStr[i];
			}
			buf[l] = 0;
			Output(2, "        %s-\n", buf);
		    } else {
			for (l = 0; i != k; l++, i++) {
			    buf[l] = errStr[i];
			}
			buf[l] = 0;
			Output(2, "        %s\n", buf);
		    }
		    i = k;
		    break;
		} else {
		    if (flag == GL_TRUE) {
			for (l = 0; i != j; l++, i++) {
			    buf[l] = errStr[i];
			}
			buf[l] = 0;
			Output(2, "        %s\n", buf);
			i = j;
			break;
		    } else {
			k = j;
			j++;
		    }
		}
	    }
	}
    }
    StateReport();
    if (machine.pathLevel != 0) {
	PathReport();
    }
}

void GetEnumName(long value, char *str)
{
    long i;

    for (i = 0; enumInfo[i].value != GL_NULL; i++) {
	if (enumInfo[i].value == value) {
	    STRCOPY(str, enumInfo[i].name);
	    return;
	}
    }
    StrMake(str, "%d (%s)", value, enumInfo[i].name);
}

long GLErrorReport(void)
{
    char buf[40];
    long error;

    error = glGetError();
    if (error != GL_NO_ERROR) {
	Output(1, " failed.\n");
	GetEnumName(error, buf);
	Output(2, "    GL Error - %s.\n", buf);
	StateReport();
	if (machine.pathLevel != 0) {
	    PathReport();
	}
	while ((error = glGetError()) != GL_NO_ERROR) {
	    GetEnumName(error, buf);
	    Output(2, "    GL Error - %s.\n", buf);
	}
	return ERROR;
    } else {
	return NO_ERROR;
    }
}

void MakeIdentMatrix(GLfloat *buf)
{
    long i;

    for (i = 0; i < 16; i++) {
	buf[i] = 0.0;
    }
    for (i = 0; i < 4; i++) {
	buf[i*4+i] = 1.0;
    }
}

void Ortho2D(double left, double right, double bottom, double top)
{
    GLfloat m[4][4], deltaX, deltaY;
    GLint mode;

    MakeIdentMatrix(&m[0][0]);
    deltaX = right - left;
    deltaY = top - bottom;
    m[0][0] = 2.0 / deltaX;
    m[3][0] = -(right + left) / deltaX;
    m[1][1] = 2.0 / deltaY;
    m[3][1] = -(top + bottom) / deltaY;
    m[2][2] = -1.0;
    glGetIntegerv(GL_MATRIX_MODE, &mode);
    glMatrixMode(GL_PROJECTION);
    glLoadMatrixf(&m[0][0]);
    glMatrixMode(mode);
}

void Ortho3D(double left, double right, double bottom, double top,
	     double zNear, double zFar)
{
    GLfloat m[4][4], deltaX, deltaY, deltaZ;
    GLint mode;

    MakeIdentMatrix(&m[0][0]);
    deltaX = right - left;
    deltaY = top - bottom;
    deltaZ = zFar - zNear;
    m[0][0] = 2.0 / deltaX;
    m[3][0] = -(right + left) / deltaX;
    m[1][1] = 2.0 / deltaY;
    m[3][1] = -(top + bottom) / deltaY;
    m[2][2] = -2.0 / deltaZ;
    m[3][2] = -(zFar + zNear) / deltaZ;
    glGetIntegerv(GL_MATRIX_MODE, &mode);
    glMatrixMode(GL_PROJECTION);
    glLoadMatrixf(&m[0][0]);
    glMatrixMode((GLenum)mode);
}

void Output(long level, char *format, ...)
{
    va_list args;

    va_start(args, format);
    if (machine.verboseLevel >= level) {
	vprintf(format, args);
	fflush(stdout);
    }
    va_end(args);
}

GLfloat Random(GLfloat low, GLfloat hi)
{
    GLfloat x;

    x = (GLfloat)((double)RAND() / RAND_MAX);
    return (x * (hi - low) + low);
}

void ReadScreen(GLint x, GLint y, GLsizei w, GLsizei h, GLenum type,
		GLfloat *buf)
{
    long repeat=1, i, j;

    switch (type) {
      case GL_AUTO_COLOR:
      case GL_COLOR_INDEX:
      case GL_STENCIL_INDEX:
      case GL_DEPTH_COMPONENT:
      case GL_RED:
      case GL_GREEN:
      case GL_BLUE:
      case GL_ALPHA:
	repeat = 1;
	break;
      case GL_RGB:
      case GL_LUMINANCE:
	repeat = 3;
	break;
      case GL_RGBA:
      case GL_LUMINANCE_ALPHA:
	repeat = 4;
	break;
    }

    for (i = 0; i < w*h*repeat; i++) {
	buf[i] = 0.0;
    }

    if (machine.failMode == GL_TRUE) {
	return;
    }

    if (type == GL_AUTO_COLOR) {
	if (buffer.colorMode == GL_COLOR_INDEX) {
	    GLint *tmpBuf = (GLint *)MALLOC(w*h*sizeof(GLint));

	    glReadPixels(x, y, w, h, GL_COLOR_INDEX, GL_INT,
			 (GLvoid *)tmpBuf);
	    for (i = 0; i < w*h; i++) {
		if (tmpBuf[i] < 4) {
		    buf[i] = tmpBuf[i];
		}
	    }
	    FREE(tmpBuf);
	} else {
	    GLfloat *tmpBuf = (GLfloat *)MALLOC(w*h*3*sizeof(GLfloat));
	    GLfloat *ptr = buf;

	    glReadPixels(x, y, w, h, GL_RGB, GL_FLOAT, (GLvoid *)tmpBuf);
	    for (i = 0; i < w*h*3; i += 3) {
		for (j = 0; j < 4; j++) {
		    if (ABS(tmpBuf[i]-colorMap[j][0]) < epsilon.zero &&
			ABS(tmpBuf[i+1]-colorMap[j][1]) < epsilon.zero &&
			ABS(tmpBuf[i+2]-colorMap[j][2]) < epsilon.zero) {
			*ptr = (GLfloat)j;
			break;
		    }
		}
		ptr++;
	    }
	    FREE(tmpBuf);
	}
    } else {
	if (buffer.colorMode == GL_COLOR_INDEX) {
	    if (type == GL_RGB || type == GL_RGBA) {
		GLint *tmpBuf = (GLint *)MALLOC(w*h*sizeof(GLint));
		GLfloat *ptr = buf;
		long max = (long)POW(2.0, (float)buffer.ciBits) - 1;

		glReadPixels(x, y, w, h, GL_COLOR_INDEX, GL_INT,
			     (GLvoid *)tmpBuf);
		for (i = 0; i < w*h; i++) {
		    if (tmpBuf[i] < max) {
			*ptr++ = colorMap[tmpBuf[i]][0];
			*ptr++ = colorMap[tmpBuf[i]][1];
			*ptr++ = colorMap[tmpBuf[i]][2];
			if (type == GL_RGBA) {
			    *ptr++ = 1.0;
			}
		    } else {
			ptr += 3;
			if (type == GL_RGBA) {
			    ptr++;
			}
		    }
		}
		FREE(tmpBuf);
	    } else {
		glReadPixels(x, y, w, h, type, GL_FLOAT, (GLvoid *)buf);
	    }
	} else {
	    glReadPixels(x, y, w, h, type, GL_FLOAT, (GLvoid *)buf);
	}
    }
}

void ResetMatrix(void)
{
    GLfloat buf[16];

    MakeIdentMatrix(buf);
    glMatrixMode(GL_MODELVIEW);
    glLoadMatrixf(buf);
    glMatrixMode(GL_PROJECTION);
    glLoadMatrixf(buf);
    glMatrixMode(GL_TEXTURE);
    glLoadMatrixf(buf);
}

long Round(float x)
{

    return (long)(x + 0.5);
}

void StrMake(char *str, char *format, ...)
{
    va_list args;

    va_start(args, format);
    vsprintf(str, format, args);
    va_end(args);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\confshel\util.h ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>


#define ABS(x) (((x) < 0.0) ? -(x) : (x))
#define ATOI(x) atoi(x)
#define COS(x) (float)cos((double)(x))
#define EXP(x) (float)exp((double)(x))
#define FLOOR(x) floor((x))
#define FREE(x) free(x)
#define LOG(x) (float)log((double)(x))
#define MALLOC(x) malloc((x))
#define MIN(x, y) (((x) <= (y)) ? (x) : (y))
#define MAX(x, y) (((x) >= (y)) ? (x) : (y))
#define POW(x, y) (float)pow((double)(x), (double)(y))
#define RAND() rand()
#define RANDSEED(x) srand((x))
#define SETCLEARCOLOR(x) (buffer.colorMode == GL_RGB) ?                   \
			 glClearColor(colorMap[(x)][0], colorMap[(x)][1], \
				      colorMap[(x)][2], 0.0) :            \
			 glClearIndex((float)(x))
#define SETCOLOR(x) (buffer.colorMode == GL_RGB) ? glColor3fv(colorMap[(x)]) : \
						   glIndexi((x))
#define SIN(x) (float)sin((double)(x))
#define SQRT(x) sqrt((x))
#define STRCOPY(x, y) strcpy(x, y)
#define STREQ(x, y) (!strcmp(x, y))


extern void AutoClearColor(GLint);
extern void AutoColor(GLint);
extern long AutoColorCompare(GLfloat, GLint);
extern void ErrorReport(char *, long, char *);
extern void GetEnumName(long, char *);
extern long GLErrorReport(void);
extern void MakeIdentMatrix(GLfloat *);
extern void Ortho2D(double, double, double, double);
extern void Ortho3D(double, double, double, double, double, double);
extern void Output(long, char *, ...);
extern GLfloat Random(GLfloat, GLfloat);
extern void ReadScreen(GLint, GLint, GLsizei, GLsizei, GLenum, GLfloat *);
extern void ResetMatrix(void);
extern long Round(float);
extern void StrMake(char *, char *, ...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\confshel\utile.h ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/


typedef struct _evalDomainRec {
    float uStart, uEnd, vStart, vEnd, du, dv;
    GLint uCount, vCount;
} evalDomainRec;

typedef struct _eval2Rec {
    GLint majorOrder, minorOrder;
    GLint dim, dataTypeEnum;
    GLfloat *controls;
    float *cU, *cV;
    float *cUDeriv, *cVDeriv;
} eval2Rec;

typedef struct _eval1Rec {
    GLint order;
    GLint dim, dataTypeEnum;
    GLfloat *controls;
    float *cU;
} eval1Rec;


extern void ClampArray(float *, float, float, float);
extern void CRow(float, float, long, float *);
extern void CRowWithDeriv(float, float, long, float *, float *);
extern void Evaluate2(eval2Rec *, float, float, float *);
extern void FreeDomain(evalDomainRec *);
extern void FreeEval2(eval2Rec *);
extern long GetEvalDim(long);
extern eval2Rec *MakeEval2(long, long, long, long, float *);
extern evalDomainRec *MakeDomain(float, float, long, float, float, long);
extern void ResetEvalToDefault(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\confshel\utilg.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"
#include "utilg.h"


void GetSlope(slopeRec *s, vertexRec *v0, vertexRec *v1)
{

    s->dx = v1->x - v0->x;
    s->dy = v1->y - v0->y;
}

void GetIntercept(interceptRec *i, vertexRec *v, slopeRec *s)
{

    if (s->dx != 0.0) {
	i->b = v->y - v->x * s->dy / s->dx;
	i->bDx = v->y * s->dx - v->x * s->dy;
    } else {
	i->b = 1.0;
	i->bDx = v->y * s->dx - v->x * s->dy;
    }
}

long LessThan(float x, float y, slopeRec *s, interceptRec *i)
{

    return (y*s->dx <= x*s->dy+i->bDx);
}

long MoreThan(float x, float y, slopeRec *s, interceptRec *i)
{

    return (y*s->dx >= x*s->dy+i->bDx);
}

void SetVertex(vertexRec *v, float x, float y, float z)
{

    v->x = x;
    v->y = y;
    v->z = z;
}

void SetHVertex(hVertexRec *v, float x, float y, float z, float w)
{

    v->v.x = x;
    v->v.y = y;
    v->v.z = z;

    v->hx = x * w;
    v->hy = y * w;
    v->hz = z * w;
    v->hw = w;
}

void MakeDiag(diagEqnRec *d, vertexRec *v0, vertexRec *v1, vertexRec *vOp)
{

    GetSlope(&d->slope, v0, v1);
    GetIntercept(&d->intercept, v0, &d->slope);

    if (LessThan(vOp->x, vOp->y, &d->slope, &d->intercept)) {
	d->Inequality = LessThan;
    } else {
	d->Inequality = MoreThan;
    }
}

float SideLength(vertexRec *v0, vertexRec *v1)
{

    return SQRT((v0->x-v1->x)*(v0->x-v1->x)+(v0->y-v1->y)*(v0->y-v1->y));
}

float TriangleArea(vertexRec *v0, vertexRec *v1, vertexRec *v2)
{
    float length0, length1, length2, s;

    length0 = SideLength(v0, v1);
    length1 = SideLength(v1, v2);
    length2 = SideLength(v0, v2);

    s = 0.5 * (length0 + length1 + length2);
    s = s * (s - length0) * (s - length1) * (s - length2);

    /*
    ** Remember the triangle inequality is false for floating point numbers.
    ** This kills the possibility of dealing with anti-aliasing and
    ** means tnat only very simple primitives may be tested.
    */
    if (s >= 0.0) {
	return SQRT(s);
    } else {
	return 0.0;
    }
}

void ArrangeComponent(float max[4], float mid[4], float min[4],
		      float oneShade[3])
{
    GLint redBits, greenBits, blueBits, maxBits, minBits, midBits;
    GLint maxChannel, minChannel, midChannel, tmp;

    glGetIntegerv(GL_RED_BITS, &redBits);
    glGetIntegerv(GL_GREEN_BITS, &greenBits);
    glGetIntegerv(GL_BLUE_BITS, &blueBits);

    /*
    ** Sort without subroutines.
    */
    if (redBits > greenBits) {
	maxBits = redBits;
	minBits = greenBits;
	maxChannel = 0;
	minChannel = 1;
    } else {
	maxBits = greenBits;
	minBits = redBits;
	maxChannel = 1;
	minChannel = 0;
    }

    midBits = blueBits;
    midChannel = 2;

    if (maxBits < midBits) {
	tmp = maxBits;
	maxBits = midBits;
	midBits = tmp;

	tmp = maxChannel;
	maxChannel = midChannel;
	midChannel = tmp;
    }

    if (minBits > midBits) {
	tmp = midBits;
	midBits = minBits;
	minBits = tmp;

	tmp = midChannel;
	midChannel = minChannel;
	midChannel = tmp;
    }

    max[0] = 0.0;
    max[1] = 0.0;
    max[2] = 0.0;
    max[3] = 1.0;
    max[maxChannel] = 1.0;

    mid[0] = 0.0;
    mid[1] = 0.0;
    mid[2] = 0.0;
    mid[3] = 1.0;
    mid[midChannel] = 1.0;

    min[0] = 0.0;
    min[1] = 0.0;
    min[2] = 0.0;
    min[3] = 1.0;
    min[minChannel] = 1.0;

    oneShade[0]  = 1.0 / (POW(2.0, maxBits) - 1.0);
    oneShade[1]  = 1.0 / (POW(2.0, midBits) - 1.0);
    oneShade[2]  = 1.0 / (POW(2.0, minBits) - 1.0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\confshel\utile.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"
#include "utile.h"


eval2Rec *MakeEval2(long majorOrder, long minorOrder, long dim, long dataType,
		    float *controls)
{
    long i, controlArrayLength;

    eval2Rec *e = (eval2Rec *)MALLOC(sizeof(eval2Rec));
    e->majorOrder = majorOrder;
    e->minorOrder = minorOrder;
    e->dim = dim;
    e->dataTypeEnum = dataType;

    e->cU = (float *)MALLOC(e->majorOrder*sizeof(float));
    e->cV = (float *)MALLOC(e->minorOrder*sizeof(float));
    e->cUDeriv = (float *)MALLOC((e->majorOrder-1)*sizeof(float));
    e->cVDeriv = (float *)MALLOC((e->minorOrder-1)*sizeof(float));

    controlArrayLength = e->majorOrder * e->minorOrder * e->dim;
    e->controls = (GLfloat *)MALLOC(controlArrayLength*sizeof(GLfloat));
    for (i = 0; i < controlArrayLength; i++) {
	e->controls[i] = controls[i];
    }
    return e;
}

evalDomainRec *MakeDomain(float uStart, float uEnd, long uCount, float vStart, 
                          float vEnd, long vCount)
{
    evalDomainRec *d = (evalDomainRec *)MALLOC(sizeof(evalDomainRec));
    d->uStart = uStart;
    d->uEnd = uEnd;
    d->uCount = uCount;
    d->du = (uEnd - uStart) / (float)uCount;

    d->vStart = vStart;
    d->vEnd = vEnd;
    d->vCount = vCount;
    d->dv = (vEnd - vStart) / (float)vCount;
    return d;
}

void FreeDomain(evalDomainRec *d)
{
    FREE(d);
}

void FreeEval2(eval2Rec *e)
{

    FREE(e->cU);
    FREE(e->cV);
    FREE(e->cUDeriv);
    FREE(e->cVDeriv);
    FREE(e->controls);
    FREE(e);
}

void CRow(float a, float b, long n, float *c)
{
    float tmp1, tmp2;
    long i, m;

    c[0] = 1;
    for (m = 1; m <= n; m++) {
	tmp1 = c[0]; 
	c[0] *= a;
	for (i = 1; i < m; i++) {
	    tmp2 = c[i];
	    c[i] = a * tmp2 + b * tmp1;
	    tmp1 = tmp2;
	}
	c[m] = b * tmp1;
    } 
}

/*
** This routine returns an array containing 1/n * d(B_sub_ij)/da as 
** well as B_sub_i_j; since we are going to normalize the cross product 
** of the output B_subij * v. The 1/n factor drops out.
*/
void CRowWithDeriv(float a, float b, long n, float *c, float *cDeriv)
{
    long i, m;

    c[0] = 1;
    cDeriv[0] = 0;
    for (m = 1; m <= n; m++) {
	cDeriv[0] = c[0]; 
	c[0] *= a;
	for (i = 1; i < m; i++) {
	    cDeriv[i] = c[i];
	    c[i] = a * cDeriv[i] + b * cDeriv[i-1];
	}
	c[m] = b * cDeriv[m-1];
    } 
}

void Evaluate2(eval2Rec *e, float u, float v, float *out)
{
    long i, j, k, index;
    float coeff;

    for (k = 0; k < e->dim; k++) {
	out[k] = 0.0;
    }

    CRow(1.0-u, u, e->majorOrder-1, e->cU);
    CRow(1.0-v, v, e->minorOrder-1, e->cV);
    for (i = 0; i < e->majorOrder; i++) {
	for (j = 0; j < e->minorOrder; j++) {
	    index = e->dim * (e->minorOrder * i + j);
	    coeff = e->cU[i] * e->cV[j];
	    for (k = 0; k < e->dim; k++) {
		out[k] += coeff * e->controls[index+k];
	    }
	}
    }
}

/*
** This routine returns the cross product of two vectors if the normalize 
** flag is GL_TRUE, it normalizes the cross product if the vector has a 
** non-zero length, and returns FALSE if it has a length of zero. 'out' 
** can be either of the two 'in' addresses.
*/
long Cross(float *in1, float *in2, float *out, long normalize)
{ 
    float tmp[3], length;

    tmp[0] = in1[1] * in2[2] - in2[1] * in1[2];
    tmp[1] = in1[0] * in1[2] - in1[0] * in2[2];
    tmp[2] = in1[0] * in2[1] - in1[1] * in2[0];

    out[0] = tmp[0];
    out[1] = tmp[1];
    out[2] = tmp[2];

    if (normalize == GL_TRUE) {
	length = tmp[0] * tmp[0] + tmp[1] * tmp[1] + tmp[2] * tmp[2]; 
	if (length > 0.0) {
	    length = SQRT(length);
	    out[0] /= length;
	    out[1] /= length;
	    out[2] /= length;
	    return GL_TRUE;
	} else {
	    return GL_FALSE;
	}
    } else {
	return GL_TRUE;
    }
}

void ClampArray(float *array, float bottom, float top, float dim)
{
    long i;

    for (i = 0; i < dim; i++) {
        array[i] = (array[i] > bottom) ? array[i] : bottom;
        array[i] = (array[i] < top) ? array[i] : top;
    }
}

long GetEvalDim(long targetEnum)
{

    switch (targetEnum) {
      case GL_MAP1_TEXTURE_COORD_1:
      case GL_MAP2_TEXTURE_COORD_1:
      case GL_MAP1_INDEX:
      case GL_MAP2_INDEX:
	return 1;
      case GL_MAP1_TEXTURE_COORD_2:
      case GL_MAP2_TEXTURE_COORD_2:
	return 2;
      case GL_MAP1_VERTEX_3:
      case GL_MAP2_VERTEX_3:
      case GL_MAP1_NORMAL:
      case GL_MAP2_NORMAL:
      case GL_MAP1_TEXTURE_COORD_3:
      case GL_MAP2_TEXTURE_COORD_3:
	return 3;
      case GL_MAP1_VERTEX_4:
      case GL_MAP2_VERTEX_4:
      case GL_MAP1_COLOR_4:
      case GL_MAP2_COLOR_4:
      case GL_MAP1_TEXTURE_COORD_4:
      case GL_MAP2_TEXTURE_COORD_4:
	return 4;
      default:
	return 0;
    }
}

/*
** This is not necessarily a complete set, just one that works for
** everything that we use presently.
*/
void ResetEvalToDefault(void)
{
    float buf[4] = {
	0.0, 0.0, 0.0, 1.0
    };

    glMap1f(GL_MAP1_VERTEX_4, 0.0, 1.0, 4, 1, buf);
    glMap2f(GL_MAP2_VERTEX_4, 0.0, 1.0, 4, 1, 0.0, 1.0, 4, 1, buf);
    glMap1f(GL_MAP1_VERTEX_3, 0.0, 1.0, 3, 1, buf);
    glMap2f(GL_MAP2_VERTEX_3, 0.0, 1.0, 3, 1, 0.0, 1.0, 3, 1, buf);

    glMap1f(GL_MAP1_TEXTURE_COORD_4, 0.0, 1.0, 4, 1, buf);
    glMap2f(GL_MAP2_TEXTURE_COORD_4, 0.0, 1.0, 4, 1, 0.0, 1.0, 4, 1, buf);
    glMap1f(GL_MAP1_TEXTURE_COORD_3, 0.0, 1.0, 3, 1, buf);
    glMap2f(GL_MAP2_TEXTURE_COORD_3, 0.0, 1.0, 3, 1, 0.0, 1.0, 3, 1, buf);
    glMap1f(GL_MAP1_TEXTURE_COORD_2, 0.0, 1.0, 2, 1, buf);
    glMap2f(GL_MAP2_TEXTURE_COORD_2, 0.0, 1.0, 2, 1, 0.0, 1.0, 2, 1, buf);
    glMap1f(GL_MAP1_TEXTURE_COORD_1, 0.0, 1.0, 1, 1, buf);
    glMap2f(GL_MAP2_TEXTURE_COORD_1, 0.0, 1.0, 1, 1, 0.0, 1.0, 1, 1, buf);

    buf[2] = 1.0;
    glMap1f(GL_MAP1_NORMAL, 0.0, 1.0, 3, 1, buf);
    glMap2f(GL_MAP2_NORMAL, 0.0, 1.0, 3, 1, 0.0, 1.0, 3, 1, buf);

    buf[0] = 1.0;
    buf[1] = 1.0;
    glMap1f(GL_MAP1_COLOR_4, 0.0, 1.0, 4, 1, buf);
    glMap2f(GL_MAP2_COLOR_4, 0.0, 1.0, 4, 1, 0.0, 1.0, 4, 1, buf);

    glMap1f(GL_MAP1_INDEX, 0.0, 1.0, 1, 1, buf);
    glMap2f(GL_MAP2_INDEX, 0.0, 1.0, 1, 1, 0.0, 1.0, 1, 1, buf);

    glDisable(GL_AUTO_NORMAL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\confshel\utilg.h ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

typedef struct _slopeRec {
    float dx, dy;
} slopeRec;

typedef struct _interceptRec {
    float b;
    float bDx;
} interceptRec;

typedef struct _vertexRec {
    float x, y, z;
} vertexRec;

typedef struct _hVertexRec {
    vertexRec v;
    float hx, hy, hz, hw;
} hVertexRec;

typedef struct _diagEqnRec {
    slopeRec slope;
    interceptRec intercept;
    long (*Inequality)(float, float, slopeRec *, interceptRec *);
} diagEqnRec;


extern void ArrangeComponent(float *, float *, float *, float *);
extern void GetSlope(slopeRec *, vertexRec *, vertexRec *);
extern void GetIntercept(interceptRec *, vertexRec *, slopeRec *);
extern long LessThan(float, float, slopeRec *, interceptRec *);
extern long MoreThan(float, float, slopeRec *, interceptRec *);
extern void SetHVertex(hVertexRec *, float, float, float, float);
extern void MakeDiag(diagEqnRec *, vertexRec *, vertexRec *, vertexRec *);
extern float SideLength(vertexRec *, vertexRec *);
extern float TriangleArea(vertexRec *, vertexRec *, vertexRec *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\confshel\utilm.h ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

enum {
    XFORM_TRANSLATE = 0,
    XFORM_SCALE,
    XFORM_ROTATE,
    XFORM_ORTHO,
    XFORM_FRUSTUM
};


typedef struct _xformRec {
    GLfloat x, y, z;
    GLfloat angle;
    double d1, d2, d3, d4, d5, d6;
} xFormRec;


extern void XFormCalcGL(long, xFormRec *);
extern void XFormCalcTrue(long, xFormRec *, GLfloat *, GLfloat *);
extern long XFormCompareMatrix(GLfloat *, GLfloat *);
extern void XFormMake(long *, xFormRec *);
extern void XFormMakeMatrix(long, xFormRec *, GLfloat *);
extern long XFormTestBuf(GLfloat *, GLfloat *, GLint, GLenum);
extern long XFormValid(long, xFormRec *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\confshel\utilru.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"
#include "utilru.h"


static char componentName[][40] = {
    "Red",
    "Green",
    "Blue"
};
static char errStrFmtRGB[][160] = {
    "Color is (%g, %g, %g). Green and blue components should be 0.0.",
    "Color is (%g, %g, %g). Red and blue components should be 0.0.",
    "Color is (%g, %g, %g). Red and green components should be 0.0.",
    "%s component is not monotonic. Current value is %g, last value was %g.",
    "%s component increased by more than one color shade. Step is %g, should be %g.",
    "%s component is not increasing consistantly from one shade to the next. Current step delta is %g, last step delta was %g.",
    "%s component did not reach 1.0. Value is %g.",
    "%s component does not have correct number of shades. Count is %d, should be %d."
};
static char errStrFmtCI[][240] = {
    "Fractional part of the color index is not 0. Color index is %g.",
    "Color index is not monotonic. Current value is %1.1f, last value was %1.1f.",
    "Color index is %1.1f. Should be %1.1f.",
    "Color index increased by more than one color shade. Step is %g.",
    "Color index did not reach %1.1f. Value is %1.1f."
};


void ColorError_RGBClamp(char *str, long component, float value)
{

    StrMake(str, errStrFmtRGB[6], componentName[component], value);
}

void ColorError_RGBCount(char *str, long component, long curCount,
			 long trueCount)
{

    StrMake(str, errStrFmtRGB[7], componentName[component], curCount,
	    trueCount);
}

void ColorError_RGBDelta(char *str, long component, float delta,
			 float lastDelta)
{

    StrMake(str, errStrFmtRGB[5], componentName[component], delta, lastDelta);
}

void ColorError_RGBMonotonic(char *str, long component, float curValue,
			     float lastValue)
{

    StrMake(str, errStrFmtRGB[3], componentName[component], curValue,
	    lastValue);
}

void ColorError_RGBStep(char *str, long component, float delta, float step)
{

    StrMake(str, errStrFmtRGB[4], componentName[component], delta, step);
}

void ColorError_RGBZero(char *str, long component, GLfloat *color)
{

    switch (component) {
      case 0:
	StrMake(str, errStrFmtRGB[0], color[0], color[1], color[2]);
	break;
      case 1:
	StrMake(str, errStrFmtRGB[1], color[0], color[1], color[2]);
	break;
      case 2:
	StrMake(str, errStrFmtRGB[2], color[0], color[1], color[2]);
	break;
    }
}

void ColorError_CIBad(char *str, float goodValue, float badValue)
{

    StrMake(str, errStrFmtCI[2], goodValue, badValue);
}

void ColorError_CIClamp(char *str, float count, float value)
{

    StrMake(str, errStrFmtCI[4], count, value);
}

void ColorError_CIFrac(char *str, float value)
{

    StrMake(str, errStrFmtCI[0], value);
}

void ColorError_CIMonotonic(char *str, float curValue, float lastValue)
{

    StrMake(str, errStrFmtCI[1], curValue, lastValue);
}

void ColorError_CIStep(char *str, float step)
{

    StrMake(str, errStrFmtCI[3], step);
}

long RampUtil(float min, float max, void (*Init)(void *),
	      void (*Set)(void *, float *), long (*Test)(void *, float),
	      void *data)
{
    float ref, x;

    glClear(GL_COLOR_BUFFER_BIT);

    if (Init) {
	(*Init)(data);
    }

    ref = min;
    while (1) {
	x = ref;

	if (Set) {
	    (*Set)(data, &x);
	}

	if (Test) {
	    if ((*Test)(data, ref) == ERROR) {
		return ERROR;
	    }
	}

	if (ref == max) {
	    break;
	}

        if (x > max) {
	    ref = max;
	} else if (x < min) {
	    ref = min;
	} else {
	    ref = x;
	}
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\confshel\utilm.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"
#include "utilm.h"


static long Compare(GLint x, GLint y, GLint color, GLfloat *buf)
{
    long i;

    i = WINDSIZEX * y + x;
    return AutoColorCompare(buf[i], color);
}

long XFormTestBuf(GLfloat *buf, GLfloat *point, GLint index, GLenum polyMode)
{
    GLint i=0, j=0;

    switch (polyMode) {
      case GL_POINT:
	i = (GLint)((1.0 + point[0]) * WINDSIZEX / 2.0);
	j = (GLint)((1.0 + point[1]) * WINDSIZEY / 2.0);
	break;
      case GL_LINE:
	i = (GLint)Round((1.0+point[0])*WINDSIZEX/2.0);
	j = (GLint)Round((1.0+point[1])*WINDSIZEY/2.0);
	break;
      case GL_FILL:
	i = (GLint)(((1.0 + point[0]) * WINDSIZEX / 2.0) - 0.5);
	j = (GLint)(((1.0 + point[1]) * WINDSIZEY / 2.0) - 0.5);
	break;
    }

    /*
    **  Test the 9 pixels around the target.
    */
    if (!(Compare(i-1, j+1, index, buf) ||
          Compare(i  , j+1, index, buf) ||
          Compare(i+1, j+1, index, buf) ||
          Compare(i-1, j  , index, buf) ||
          Compare(i  , j  , index, buf) ||
          Compare(i+1, j  , index, buf) ||
          Compare(i-1, j-1, index, buf) ||
          Compare(i  , j-1, index, buf) ||
          Compare(i+1, j-1, index, buf))) {
        return ERROR;
    }
    return NO_ERROR;
}

static void Translate(xFormRec *data, GLfloat *in, GLfloat *out)
{

    out[0] = in[0] + data->x;
    out[1] = in[1] + data->y;
    out[2] = in[2] + data->z;
}

static void Scale(xFormRec *data, GLfloat *in, GLfloat *out)
{

    out[0] = in[0] * data->x;
    out[1] = in[1] * data->y;
    out[2] = in[2] * data->z;
}

static void Rotate(xFormRec *data, GLfloat *in, GLfloat *out)
{
    float angleCos, angleSin;
    float m[3][3], axis[3], len, tmp[3];

    angleCos = COS(data->angle*PI/180.0);
    angleSin = SIN(data->angle*PI/180.0);

    len = data->x * data->x + data->y * data->y + data->z * data->z;
    len = SQRT(len);

    axis[0] = data->x / len;
    axis[1] = data->y / len;
    axis[2] = data->z / len;

    m[0][0] = axis[0] * axis[0] * (1.0 - angleCos) + angleCos;
    m[0][1] = axis[0] * axis[1] * (1.0 - angleCos) - angleSin * axis[2]; 
    m[0][2] = axis[0] * axis[2] * (1.0 - angleCos) + angleSin * axis[1];

    m[1][0] = axis[1] * axis[0] * (1.0 - angleCos) + angleSin * axis[2];
    m[1][1] = axis[1] * axis[1] * (1.0 - angleCos) + angleCos;
    m[1][2] = axis[1] * axis[2] * (1.0 - angleCos) - angleSin * axis[0];

    m[2][0] = axis[2] * axis[0] * (1.0 - angleCos) - angleSin * axis[1];
    m[2][1] = axis[2] * axis[1] * (1.0 - angleCos) + angleSin * axis[0];
    m[2][2] = axis[2] * axis[2] * (1.0 - angleCos) + angleCos;

    tmp[0] = m[0][0] * in[0] + m[0][1] * in[1] + m[0][2] * in[2];
    tmp[1] = m[1][0] * in[0] + m[1][1] * in[1] + m[1][2] * in[2];
    tmp[2] = m[2][0] * in[0] + m[2][1] * in[1] + m[2][2] * in[2];

    out[0] = tmp[0];
    out[1] = tmp[1];
    out[2] = tmp[2];
}

static void Ortho(xFormRec *data, GLfloat *in, GLfloat *out)
{

    out[0] = in[0] * (GLfloat)(2.0 / data->d1);
    out[1] = in[1] * (GLfloat)(2.0 / data->d2);
    out[2] = in[2] * (GLfloat)(-2.0 / data->d3);
}

void XFormCalcTrue(long type, xFormRec *data, GLfloat *in, GLfloat *out)
{

    switch (type) {
      case XFORM_TRANSLATE:
	Translate(data, in, out);
	break;
      case XFORM_SCALE:
	Scale(data, in, out);
	break;
      case XFORM_ROTATE:
	Rotate(data, in, out);
	break;
      case XFORM_ORTHO:
	Ortho(data, in, out);
	break;
    }
}

void XFormCalcGL(long type, xFormRec *data)
{

    switch (type) {
      case XFORM_TRANSLATE:
	glTranslatef(data->x, data->y, data->z);
	break;
      case XFORM_SCALE:
	glScalef(data->x, data->y, data->z);
	break;
      case XFORM_ROTATE:
	glRotatef(data->angle, data->x, data->y, data->z);
	break;
      case XFORM_ORTHO:
	glOrtho(-data->d1/2.0, data->d1/2.0, -data->d2/2.0, data->d2/2.0,
		-data->d3/2.0, data->d3/2.0);
	break;
      case XFORM_FRUSTUM:
	glFrustum(data->d1, data->d2, data->d3, data->d4, data->d5, data->d6);
	break;
    }
}

void XFormMake(long *type, xFormRec *data)
{

    *type = Random(XFORM_TRANSLATE, XFORM_ROTATE+0.9);
    switch (*type) {
      case XFORM_TRANSLATE:
	data->x = Random(-0.75, 0.75);
	data->y = Random(-0.75, 0.75);
	data->z = 0.0;
	break;
      case XFORM_SCALE:
	data->x = Random(-4.0, 4.0);
	data->y = Random(-4.0, 4.0);
	data->z = 1.0;
	break;
      case XFORM_ROTATE:
	data->x = Random(-2.0, 2.0);
	data->y = Random(-2.0, 2.0);
	data->z = Random(-2.0, 2.0);
	data->angle = Random(-180.0, 180.0);
	break;
    }
}

void XFormMakeMatrix(long type, xFormRec *data, GLfloat *matrix)
{
    GLfloat sine, cosine;

    MakeIdentMatrix(matrix);

    /*
    ** Note - LoadMatrix takes matrices in COLUMN major order.
    ** These matrices will be expressed as ROW major, so the numbers
    ** will appear transposed.
    */
    switch (type) {
      case XFORM_TRANSLATE:
	matrix[12] = data->x;
	matrix[13] = data->y;
	matrix[14] = data->z;
	break;
      case XFORM_SCALE:
	matrix[0] = data->x;
	matrix[5] = data->y;
	matrix[10] = data->z;
	break;
      case XFORM_ROTATE:
	/*
	** Doing only rotations around z-axis.
	*/
	cosine = COS(data->angle*PI/180.0);
	sine = SIN(data->angle*PI/180.0);
	matrix[0] = cosine;
	matrix[1] = sine;
	matrix[4] = -sine;
	matrix[5] = cosine;
	break;
      case XFORM_ORTHO:
	matrix[0] = (GLfloat)(2.0 / data->d1);
	matrix[5] = (GLfloat)(2.0 / data->d2);
	matrix[10] = (GLfloat)(-2.0 / data->d3);
	break;
      case XFORM_FRUSTUM:
	matrix[0] = (GLfloat)((2.0 * data->d5) / (data->d2 - data->d1));
	matrix[5] = (GLfloat)((2.0 * data->d5) / (data->d4 - data->d3));
	matrix[10] = (GLfloat)(-(data->d6 + data->d5) / (data->d6 - data->d5));
	matrix[8] = (GLfloat)((data->d2 + data->d1) / (data->d2 - data->d1));
	matrix[9] = (GLfloat)((data->d4 + data->d3) / (data->d4 - data->d3));
	matrix[14] = (GLfloat)(-(2.0 * data->d5 * data->d6) / (data->d6 -
		     data->d5));
	matrix[11] = -1.0;
	matrix[15] = 0.0;
	break;
    }
    return;
}

long XFormValid(long type, xFormRec *data)
{

    switch (type) {
      case XFORM_TRANSLATE:
	return NO_ERROR;
      case XFORM_SCALE:
	if (data->x * data->y * data->z == 0.0) {
	    return ERROR;
	} else {
	    return NO_ERROR;
	}
	break;
      case XFORM_ROTATE:
	if ((data->x*data->x+data->y*data->y+data->z*data->z) == 0.0) {
	    return ERROR;
	} else {
	    return NO_ERROR;
	}
    }
    return NO_ERROR;
}

long XFormCompareMatrix(GLfloat *m1, GLfloat *m2)
{
    long i;

    for (i = 0; i < 16; i++) {
	 if (ABS(m1[i]-m2[i]) > epsilon.zero) {
	     return ERROR;
         }
    }
    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\confshel\utils.h ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

enum {
    STATEDATA_BOOLEAN = 1,
    STATEDATA_DATA,
    STATEDATA_ENUM,
    STATEDATA_MATRIX,
    STATEDATA_STIPPLE
};

enum {
    STATEDATA_LOCKED = 1,
    STATEDATA_DEPENDENT
};


typedef struct _stateRec {
    GLenum value[4], valueType;
    char title[40];
    void (*GetFunc)(struct _stateRec *);
    GLenum dataType;
    long dataCount;
    GLfloat dataTrue[256], dataCur[256];
    GLenum dataFlag;
} stateRec;


extern stateRec state[];


extern long StateCheck(void);
extern long StateInit(void);
extern void StateReport(void);
extern long StateReset(void);
extern void StateSave(void);
extern void StateSetup(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\covgl\a.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <GL/gl.h>
#include "shell.h"


void CallAccum(void)
{
    long i;

    Output("glAccum\n");
    for (i = 0; enum_AccumOp[i].value != -1; i++) {
	Output("\t%s\n", enum_AccumOp[i].name);
	glAccum(enum_AccumOp[i].value, 0.0);
	ProbeEnum();
    }
    Output("\n");
}

void CallAlphaFunc(void)
{
    long i;

    Output("glAlphaFunc\n");
    for (i = 0; enum_AlphaFunction[i].value != -1; i++) {
	Output("\t%s\n", enum_AlphaFunction[i].name);
	glAlphaFunc(enum_AlphaFunction[i].value, 0);
	ProbeEnum();
    }
    Output("\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\covgl\b.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <GL/gl.h>
#include "shell.h"


void CallBeginEnd(void)
{
    long i;

    Output("glBegin\n");
    for (i = 0; enum_BeginMode[i].value != -1; i++) {
	Output("\t%s\n", enum_BeginMode[i].name);
	glBegin(enum_BeginMode[i].value);
	glEnd();
	ProbeEnum();
    }
    Output("\n");

    Output("glEnd\n");
    Output("\n");
}

void CallBitmap(void)
{
    GLubyte buf[10];

    Output("glBitmap\n");
    glBitmap(0, 0, 0.0, 0.0, 0.0, 0.0, buf);
    Output("\n");
}

void CallBlendFunc(void)
{
    long i, j;

    Output("glBlendFunc\n");
    for (i = 0; enum_BlendingFactorSrc[i].value != -1; i++) {
	for (j = 0; enum_BlendingFactorDest[j].value != -1; j++) {
	    Output("\t%s, %s\n", enum_BlendingFactorSrc[i].name, enum_BlendingFactorDest[j].name);
	    glBlendFunc(enum_BlendingFactorSrc[i].value, enum_BlendingFactorDest[j].value);
	    ProbeEnum();
	}
    }
    Output("\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\confshel\utilru.h ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

extern void ColorError_RGBClamp(char *, long, float);
extern void ColorError_RGBCount(char *, long, long, long);
extern void ColorError_RGBDelta(char *, long, float, float);
extern void ColorError_RGBMonotonic(char *, long, float, float);
extern void ColorError_RGBStep(char *, long, float, float);
extern void ColorError_RGBZero(char *, long, GLfloat *);
extern void ColorError_CIBad(char *, float, float);
extern void ColorError_CIClamp(char *, float, float);
extern void ColorError_CIFrac(char *, float);
extern void ColorError_CIMonotonic(char *, float, float);
extern void ColorError_CIStep(char *, float);
extern long RampUtil(float, float, void (*)(void *), 
		     void (*)(void *, float *), 
		     long (*)(void *, float), void *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\test\conform\confshel\utils.c ===
/*
** Copyright 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <windows.h>
#include <GL/gl.h>
#include "conform.h"
#include "util.h"
#include "utils.h"
#include "pathdata.h"
#include "driver.h"


static void StateGetTarget(stateRec *);
static void StateGetClipPlane(stateRec *);
static void StateGetLight(stateRec *);
static void StateGetMap(stateRec *);
static void StateGetMaterial(stateRec *);
static void StateGetPixelMap(stateRec *);
static void StateGetPolygonStipple(stateRec *);
static void StateGetTexEnv(stateRec *);
static void StateGetTexGen(stateRec *);
static void StateGetTexParm(stateRec *);


stateRec state[] = {
    {
	{GL_ACCUM_ALPHA_BITS, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_DEPENDENT, 1
    },
    {
	{GL_ACCUM_BLUE_BITS, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_DEPENDENT, 1
    },
    {
	{GL_ACCUM_GREEN_BITS, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_DEPENDENT, 1
    },
    {
	{GL_ACCUM_RED_BITS, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_DEPENDENT, 1
    },
    {
	{GL_ACCUM_CLEAR_VALUE, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 4, {0.0, 0.0, 0.0, 0.0}
    },
    {
	{GL_ALPHA_BIAS, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_ALPHA_BITS, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_DEPENDENT, 1
    },
    {
	{GL_ALPHA_SCALE, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {1.0} 
    },
    {
	{GL_ALPHA_TEST, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_FALSE}
    },
    {
	{GL_ALPHA_TEST_FUNC, GL_NULL}, STATEDATA_ENUM,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_ALWAYS}
    },
    {
	{GL_ALPHA_TEST_REF, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_ATTRIB_STACK_DEPTH, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_AUTO_NORMAL, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_FALSE}
    },
    {
	{GL_AUX_BUFFERS, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_DEPENDENT, 1
    },
    {
	{GL_BLEND, GL_NULL}, STATEDATA_BOOLEAN,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_FALSE}
    },
    {
	{GL_BLEND_DST, GL_NULL}, STATEDATA_ENUM,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_ZERO}
    },
    {
	{GL_BLEND_SRC, GL_NULL}, STATEDATA_ENUM,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {GL_ONE}
    },
    {
	{GL_BLUE_BIAS, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {0.0}
    },
    {
	{GL_BLUE_BITS, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_DEPENDENT, 1
    },
    {
	{GL_BLUE_SCALE, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 1, {1.0}
    },
    {
	{GL_COLOR_CLEAR_VALUE, GL_NULL}, STATEDATA_DATA,
	"State Information",
	StateGetTarget,
	STATEDATA_LOCKED, 4, {0.0, 0