lidateVolumes...\n", 0);

    //
    //  Check for the correct security access.
    //  The caller must have the SeTcbPrivilege.
    //

    if (!SeSinglePrivilegeCheck(TcbPrivilege, Irp->RequestorMode)) {

        FatCompleteRequest( FatNull, Irp, STATUS_PRIVILEGE_NOT_HELD );

        DebugTrace(-1, Dbg, "FatInvalidateVolumes -> %08lx\n", STATUS_PRIVILEGE_NOT_HELD);
        return STATUS_PRIVILEGE_NOT_HELD;
    }

    //
    //  Try to get a pointer to the device object from the handle passed in.
    //

#if defined(_WIN64)
    if (IoIs32bitProcess( Irp )) {

        if (IrpSp->Parameters.FileSystemControl.InputBufferLength != sizeof(UINT32)) {
            
            FatCompleteRequest( FatNull, Irp, STATUS_INVALID_PARAMETER );

            DebugTrace(-1, Dbg, "FatInvalidateVolumes -> %08lx\n", STATUS_INVALID_PARAMETER);
            return STATUS_INVALID_PARAMETER;
        }

        Handle = (HANDLE) LongToHandle( (*(PUINT32)Irp->AssociatedIrp.SystemBuffer) );
    } else {
#endif
        if (IrpSp->Parameters.FileSystemControl.InputBufferLength != sizeof(HANDLE)) {

            FatCompleteRequest( FatNull, Irp, STATUS_INVALID_PARAMETER );

            DebugTrace(-1, Dbg, "FatInvalidateVolumes -> %08lx\n", STATUS_INVALID_PARAMETER);
            return STATUS_INVALID_PARAMETER;
        }

        Handle = *(PHANDLE)Irp->AssociatedIrp.SystemBuffer;
#if defined(_WIN64)
    }
#endif


    Status = ObReferenceObjectByHandle( Handle,
                                        0,
                                        *IoFileObjectType,
                                        KernelMode,
                                        &FileToMarkBad,
                                        NULL );

    if (!NT_SUCCESS(Status)) {

        FatCompleteRequest( FatNull, Irp, Status );

        DebugTrace(-1, Dbg, "FatInvalidateVolumes -> %08lx\n", Status);
        return Status;

    } else {

        //
        //  We only needed the pointer, not a reference.
        //

        ObDereferenceObject( FileToMarkBad );

        //
        //  Grab the DeviceObject from the FileObject.
        //

        DeviceToMarkBad = FileToMarkBad->DeviceObject;
    }

    RtlZeroMemory( &IrpContext, sizeof(IRP_CONTEXT) );

    SetFlag( IrpContext.Flags, IRP_CONTEXT_FLAG_WAIT );
    IrpContext.MajorFunction = IrpSp->MajorFunction;
    IrpContext.MinorFunction = IrpSp->MinorFunction;

    FatAcquireExclusiveGlobal( &IrpContext );

    //
    //  First acquire the FatData resource shared, then walk through all the
    //  mounted VCBs looking for candidates to mark BAD.
    //
    //  On volumes we mark bad, check for dismount possibility (which is
    //  why we have to get the next link early).
    //

    Links = FatData.VcbQueue.Flink;

    while (Links != &FatData.VcbQueue) {

        PVCB ExistingVcb;

        ExistingVcb = CONTAINING_RECORD(Links, VCB, VcbLinks);

        Links = Links->Flink;

        //
        //  If we get a match, mark the volume Bad, and also check to
        //  see if the volume should go away.
        //

        if (ExistingVcb->Vpb->RealDevice == DeviceToMarkBad) {

            //
            //  Here we acquire the Vcb exclusive and try to purge
            //  all the open files.  The idea is to have as little as
            //  possible stale data visible and to hasten the volume
            //  going away.
            //

            (VOID)FatAcquireExclusiveVcb( &IrpContext, ExistingVcb );

            if (ExistingVcb->Vpb == DeviceToMarkBad->Vpb) {

                KIRQL OldIrql;
                    
                IoAcquireVpbSpinLock( &OldIrql );
    
                if (FlagOn( DeviceToMarkBad->Vpb->Flags, VPB_MOUNTED )) {

                    PVPB NewVpb;

                    NewVpb = ExistingVcb->SwapVpb;
                    ExistingVcb->SwapVpb = NULL;
                    
                    RtlZeroMemory( NewVpb, sizeof( VPB ) );
                    NewVpb->Type = IO_TYPE_VPB;
                    NewVpb->Size = sizeof( VPB );
                    NewVpb->RealDevice = DeviceToMarkBad;
                    NewVpb->Flags = FlagOn( DeviceToMarkBad->Vpb->Flags, VPB_REMOVE_PENDING );

                    DeviceToMarkBad->Vpb = NewVpb;
                }

                ASSERT( DeviceToMarkBad->Vpb->DeviceObject == NULL );

                IoReleaseVpbSpinLock( OldIrql );
            }

            ExistingVcb->VcbCondition = VcbBad;

            FatMarkFcbCondition( &IrpContext, ExistingVcb->RootDcb, FcbBad, TRUE );

            FatPurgeReferencedFileObjects( &IrpContext,
                                           ExistingVcb->RootDcb,
                                           NoFlush );

            //
            //  If the volume was not deleted, drop the resource.
            //

            if (Links->Blink == &ExistingVcb->VcbLinks) {

                PVPB Vpb;

                FatReleaseVcb( &IrpContext, ExistingVcb );

                //
                //  If the volume does go away now, then we have to free
                //  up the Vpb as nobody else will.
                //

                Vpb = ExistingVcb->Vpb;
                
                if (FatCheckForDismount( &IrpContext, ExistingVcb, FALSE )) {

                    ExFreePool( Vpb );
                }
            }
        }
    }

    FatReleaseGlobal( &IrpContext );

    FatCompleteRequest( FatNull, Irp, STATUS_SUCCESS );

    DebugTrace(-1, Dbg, "FatInvalidateVolumes -> STATUS_SUCCESS\n", 0);

    return STATUS_SUCCESS;
}


//
//  Local Support routine
//

BOOLEAN
FatPerformVerifyDiskRead (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PVOID Buffer,
    IN LBO Lbo,
    IN ULONG NumberOfBytesToRead,
    IN BOOLEAN ReturnOnError
    )

/*++

Routine Description:

    This routine is used to read in a range of bytes from the disk.  It
    bypasses all of the caching and regular I/O logic, and builds and issues
    the requests itself.  It does this operation overriding the verify
    volume flag in the device object.

Arguments:

    Vcb - Supplies the target device object for this operation.

    Buffer - Supplies the buffer that will recieve the results of this operation

    Lbo - Supplies the byte offset of where to start reading

    NumberOfBytesToRead - Supplies the number of bytes to read, this must
        be in multiple of bytes units acceptable to the disk driver.

    ReturnOnError - Indicates that we should return on an error, instead
        of raising.

Return Value:

    BOOLEAN - TRUE if the operation succeded, FALSE otherwise.

--*/

{
    KEVENT Event;
    PIRP Irp;
    LARGE_INTEGER ByteOffset;
    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;

    DebugTrace(0, Dbg, "FatPerformVerifyDiskRead, Lbo = %08lx\n", Lbo );

    //
    //  Initialize the event we're going to use
    //

    KeInitializeEvent( &Event, NotificationEvent, FALSE );

    //
    //  Build the irp for the operation and also set the overrride flag
    //

    ByteOffset.QuadPart = Lbo;

    Irp = IoBuildSynchronousFsdRequest( IRP_MJ_READ,
                                        Vcb->TargetDeviceObject,
                                        Buffer,
                                        NumberOfBytesToRead,
                                        &ByteOffset,
                                        &Event,
                                        &Iosb );

    if ( Irp == NULL ) {

        FatRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES );
    }

    SetFlag( IoGetNextIrpStackLocation( Irp )->Flags, SL_OVERRIDE_VERIFY_VOLUME );

    //
    //  Call the device to do the read and wait for it to finish.
    //

    Status = IoCallDriver( Vcb->TargetDeviceObject, Irp );

    if (Status == STATUS_PENDING) {

        (VOID)KeWaitForSingleObject( &Event, Executive, KernelMode, FALSE, (PLARGE_INTEGER)NULL );

        Status = Iosb.Status;
    }

    ASSERT( Status != STATUS_VERIFY_REQUIRED );

    //
    //  Special case this error code because this probably means we used
    //  the wrong sector size and we want to reject STATUS_WRONG_VOLUME.
    //

    if (Status == STATUS_INVALID_PARAMETER) {

        return FALSE;
    }

    //
    //  If it doesn't succeed then either return or raise the error.
    //

    if (!NT_SUCCESS(Status)) {

        if (ReturnOnError) {

            return FALSE;

        } else {

            FatNormalizeAndRaiseStatus( IrpContext, Status );
        }
    }

    //
    //  And return to our caller
    //

    return TRUE;
}


//
//  Local Support Routine
//

NTSTATUS
FatQueryRetrievalPointers (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs the query retrieval pointers operation.
    It returns the retrieval pointers for the specified input
    file from the start of the file to the request map size specified
    in the input buffer.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;

    PIO_STACK_LOCATION IrpSp;

    PVCB Vcb;
    PFCB Fcb;
    PCCB Ccb;

    PLARGE_INTEGER RequestedMapSize;
    PLARGE_INTEGER *MappingPairs;

    ULONG Index;
    ULONG i;
    ULONG SectorCount;
    LBO Lbo;
    ULONG Vbo;
    ULONG MapSize;

    //
    //  Get the current stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Decode the file object and ensure that it is the paging file
    //
    //  Only Kernel mode clients may query retrieval pointer information about
    //  a file.  Ensure that this is the case for this caller.
    //

    (VOID)FatDecodeFileObject( IrpSp->FileObject, &Vcb, &Fcb, &Ccb );

    if (Irp->RequestorMode != KernelMode ||
        Fcb == NULL || 
        !FlagOn(Fcb->FcbState, FCB_STATE_PAGING_FILE) ) {

        FatCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Extract the input and output buffer information.  The input contains
    //  the requested size of the mappings in terms of VBO.  The output
    //  parameter will receive a pointer to nonpaged pool where the mapping
    //  pairs are stored.
    //

    ASSERT( IrpSp->Parameters.FileSystemControl.InputBufferLength == sizeof(LARGE_INTEGER) );
    ASSERT( IrpSp->Parameters.FileSystemControl.OutputBufferLength == sizeof(PVOID) );

    RequestedMapSize = IrpSp->Parameters.FileSystemControl.Type3InputBuffer;
    MappingPairs = Irp->UserBuffer;

    //
    //  Acquire exclusive access to the Fcb
    //

    if (!FatAcquireExclusiveFcb( IrpContext, Fcb )) {

        return FatFsdPostRequest( IrpContext, Irp );
    }

    try {

        //
        //  Verify the Fcb is still OK
        //

        FatVerifyFcb( IrpContext, Fcb );

        //
        //  Check if the mapping the caller requested is too large
        //

        if ((*RequestedMapSize).QuadPart > Fcb->Header.FileSize.QuadPart) {

            try_return( Status = STATUS_INVALID_PARAMETER );
        }

        //
        //  Now get the index for the mcb entry that will contain the
        //  callers request and allocate enough pool to hold the
        //  output mapping pairs
        //

        (VOID)FatLookupMcbEntry( Fcb->Vcb, &Fcb->Mcb, RequestedMapSize->LowPart - 1, &Lbo, NULL, &Index );

        *MappingPairs = FsRtlAllocatePoolWithTag( NonPagedPool,
                                                  (Index + 2) * (2 * sizeof(LARGE_INTEGER)),
                                                  TAG_OUTPUT_MAPPINGPAIRS );

        //
        //  Now copy over the mapping pairs from the mcb
        //  to the output buffer.  We store in [sector count, lbo]
        //  mapping pairs and end with a zero sector count.
        //

        MapSize = RequestedMapSize->LowPart;

        for (i = 0; i <= Index; i += 1) {

            (VOID)FatGetNextMcbEntry( Fcb->Vcb, &Fcb->Mcb, i, &Vbo, &Lbo, &SectorCount );

            if (SectorCount > MapSize) {
                SectorCount = MapSize;
            }

            (*MappingPairs)[ i*2 + 0 ].QuadPart = SectorCount;
            (*MappingPairs)[ i*2 + 1 ].QuadPart = Lbo;

            MapSize -= SectorCount;
        }

        (*MappingPairs)[ i*2 + 0 ].QuadPart = 0;

        Status = STATUS_SUCCESS;

    try_exit: NOTHING;
    } finally {

        DebugUnwind( FatQueryRetrievalPointers );

        //
        //  Release all of our resources
        //

        FatReleaseFcb( IrpContext, Fcb );

        //
        //  If this is an abnormal termination then undo our work, otherwise
        //  complete the irp
        //

        if (!AbnormalTermination()) {

            FatCompleteRequest( IrpContext, Irp, Status );
        }
    }

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
FatGetStatistics (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns the filesystem performance counters from the
    appropriate VCB.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    PIO_STACK_LOCATION IrpSp;
    NTSTATUS Status;
    PVCB Vcb;

    PFILE_SYSTEM_STATISTICS Buffer;
    ULONG BufferLength;
    ULONG StatsSize;
    ULONG BytesToCopy;

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "FatGetStatistics...\n", 0);

    //
    // Extract the buffer
    //

    Buffer = Irp->AssociatedIrp.SystemBuffer;
    BufferLength = IrpSp->Parameters.FileSystemControl.OutputBufferLength;

    //
    //  Get a pointer to the output buffer.
    //

    Buffer = Irp->AssociatedIrp.SystemBuffer;

    //
    //  Make sure the buffer is big enough for at least the common part.
    //

    if (BufferLength < sizeof(FILESYSTEM_STATISTICS)) {

        FatCompleteRequest( IrpContext, Irp, STATUS_BUFFER_TOO_SMALL );

        DebugTrace(-1, Dbg, "FatGetStatistics -> %08lx\n", STATUS_BUFFER_TOO_SMALL );

        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    //  Now see how many bytes we can copy.
    //

    StatsSize = sizeof(FILE_SYSTEM_STATISTICS) * KeNumberProcessors;

    if (BufferLength < StatsSize) {

        BytesToCopy = BufferLength;
        Status = STATUS_BUFFER_OVERFLOW;

    } else {

        BytesToCopy = StatsSize;
        Status =  STATUS_SUCCESS;
    }

    //
    //  Get the Vcb.
    //

    Vcb = &((PVOLUME_DEVICE_OBJECT)IrpSp->DeviceObject)->Vcb;

    //
    //  Fill in the output buffer
    //

    RtlCopyMemory( Buffer, Vcb->Statistics, BytesToCopy );

    Irp->IoStatus.Information = BytesToCopy;

    FatCompleteRequest( IrpContext, Irp, Status );

    DebugTrace(-1, Dbg, "FatGetStatistics -> %08lx\n", Status);

    return Status;
}

//
//  Local Support Routine
//

NTSTATUS
FatGetVolumeBitmap(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine returns the volume allocation bitmap.

        Input = the STARTING_LCN_INPUT_BUFFER data structure is passed in
            through the input buffer.
        Output = the VOLUME_BITMAP_BUFFER data structure is returned through
            the output buffer.

    We return as much as the user buffer allows starting the specified input
    LCN (trucated to a byte).  If there is no input buffer, we start at zero.

Arguments:

    Irp - Supplies the Irp being processed.

Return Value:

    NTSTATUS - The return status for the operation.

--*/
{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;

    PVCB Vcb;
    PFCB Fcb;
    PCCB Ccb;

    ULONG BytesToCopy;
    ULONG TotalClusters;
    ULONG DesiredClusters;
    ULONG StartingCluster;
    ULONG InputBufferLength;
    ULONG OutputBufferLength;
    LARGE_INTEGER StartingLcn;
    PVOLUME_BITMAP_BUFFER OutputBuffer;

    //
    //  Get the current Irp stack location and save some references.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "FatGetVolumeBitmap, FsControlCode = %08lx\n",
               IrpSp->Parameters.FileSystemControl.FsControlCode);

    //
    //  Extract and decode the file object and check for type of open.
    //

    if (FatDecodeFileObject( IrpSp->FileObject, &Vcb, &Fcb, &Ccb ) != UserVolumeOpen) {

        FatCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    if ((Ccb == NULL) || !FlagOn( Ccb->Flags, CCB_FLAG_MANAGE_VOLUME_ACCESS )) {

        FatCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

        DebugTrace(-1, Dbg, "FatGetVolumeBitmap -> %08lx\n", STATUS_INVALID_PARAMETER);
        return STATUS_INVALID_PARAMETER;
    }

    InputBufferLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;
    OutputBufferLength = IrpSp->Parameters.FileSystemControl.OutputBufferLength;

    OutputBuffer = (PVOLUME_BITMAP_BUFFER)FatMapUserBuffer( IrpContext, Irp );

    //
    //  Check for a minimum length on the input and output buffers.
    //

    if ((InputBufferLength < sizeof(STARTING_LCN_INPUT_BUFFER)) ||
        (OutputBufferLength < sizeof(VOLUME_BITMAP_BUFFER))) {

        FatCompleteRequest( IrpContext, Irp, STATUS_BUFFER_TOO_SMALL );
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    //  Check if a starting cluster was specified.
    //

    TotalClusters = Vcb->AllocationSupport.NumberOfClusters;

    //
    //  Check for valid buffers
    //

    try {

        if (Irp->RequestorMode != KernelMode) {

            ProbeForRead( IrpSp->Parameters.FileSystemControl.Type3InputBuffer,
                          InputBufferLength,
                          sizeof(UCHAR) );

            ProbeForWrite( OutputBuffer, OutputBufferLength, sizeof(UCHAR) );
        }

        StartingLcn = ((PSTARTING_LCN_INPUT_BUFFER)IrpSp->Parameters.FileSystemControl.Type3InputBuffer)->StartingLcn;

    } except( Irp->RequestorMode != KernelMode ? EXCEPTION_EXECUTE_HANDLER: EXCEPTION_CONTINUE_SEARCH ) {

          Status = GetExceptionCode();

          FatRaiseStatus( IrpContext,
                          FsRtlIsNtstatusExpected(Status) ?
                          Status : STATUS_INVALID_USER_BUFFER );
    }

    if (StartingLcn.HighPart || StartingLcn.LowPart >= TotalClusters) {

        FatCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;

    } else {

        StartingCluster = StartingLcn.LowPart & ~7;
    }

    //
    //  Acquire exclusive access to the Vcb and enqueue the Irp if we
    //  didn't get access.
    //

    if (!FatAcquireExclusiveVcb( IrpContext, Vcb )) {

        DebugTrace( 0, Dbg, "Cannot acquire Vcb\n", 0);

        ASSERT( Irp->RequestorMode == KernelMode );

        Status = FatFsdPostRequest( IrpContext, Irp );

        DebugTrace(-1, Dbg, "FatGetVolumeBitmap -> %08lx\n", Status);
        return Status;
    }

    //
    //  Only return what will fit in the user buffer.
    //

    OutputBufferLength -= FIELD_OFFSET(VOLUME_BITMAP_BUFFER, Buffer);
    DesiredClusters = TotalClusters - StartingCluster;

    if (OutputBufferLength < (DesiredClusters + 7) / 8) {

        BytesToCopy = OutputBufferLength;
        Status = STATUS_BUFFER_OVERFLOW;

    } else {

        BytesToCopy = (DesiredClusters + 7) / 8;
        Status = STATUS_SUCCESS;
    }

    //
    //  Use try/finally for cleanup.
    //

    try {

        try {

            //
            //  Verify the Vcb is still OK
            //

            FatQuickVerifyVcb( IrpContext, Vcb );

            //
            //  Fill in the fixed part of the output buffer
            //

            OutputBuffer->StartingLcn.QuadPart = StartingCluster;
            OutputBuffer->BitmapSize.QuadPart = DesiredClusters;

            if (Vcb->NumberOfWindows == 1) {

                //
                //  Just copy the volume bitmap into the user buffer.
                //

                ASSERT( Vcb->FreeClusterBitMap.Buffer != NULL );

                RtlCopyMemory( &OutputBuffer->Buffer[0],
                               (PUCHAR)Vcb->FreeClusterBitMap.Buffer + StartingCluster/8,
                               BytesToCopy );
            } else {

                //
                //  Call out to analyze the FAT.  We must bias by two to account for
                //  the zero base of this API and FAT's physical reality of starting
                //  the file heap at cluster 2.
                //
                //  Note that the end index is inclusive - we need to subtract one to
                //  calculcate it.
                //
                //  I.e.: StartingCluster 0 for one byte of bitmap means a start cluster
                //  of 2 and end cluster of 9, a run of eight clusters.
                //

                FatExamineFatEntries( IrpContext,
                                      Vcb,
                                      StartingCluster + 2,
                                      StartingCluster + BytesToCopy * 8 + 2 - 1,
                                      FALSE,
                                      NULL,
                                      (PULONG)&OutputBuffer->Buffer[0] );
            }

        } except( Irp->RequestorMode != KernelMode ? EXCEPTION_EXECUTE_HANDLER: EXCEPTION_CONTINUE_SEARCH ) {

            Status = GetExceptionCode();

            FatRaiseStatus( IrpContext,
                            FsRtlIsNtstatusExpected(Status) ?
                            Status : STATUS_INVALID_USER_BUFFER );
        }

    } finally {

        FatReleaseVcb( IrpContext, Vcb );
    }

    Irp->IoStatus.Information = FIELD_OFFSET(VOLUME_BITMAP_BUFFER, Buffer) +
                                BytesToCopy;

    FatCompleteRequest( IrpContext, Irp, Status );

    DebugTrace(-1, Dbg, "FatGetVolumeBitmap -> VOID\n", 0);

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
FatGetRetrievalPointers (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine scans the MCB and builds an extent list.  The first run in
    the output extent list will start at the begining of the contiguous
    run specified by the input parameter.

        Input = STARTING_VCN_INPUT_BUFFER;
        Output = RETRIEVAL_POINTERS_BUFFER.

Arguments:

    Irp - Supplies the Irp being processed.

Return Value:

    NTSTATUS - The return status for the operation.

--*/
{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;

    PVCB Vcb;
    PFCB FcbOrDcb;
    PCCB Ccb;
    TYPE_OF_OPEN TypeOfOpen;

    ULONG Index;
    ULONG ClusterShift;
    ULONG AllocationSize;

    ULONG Run;
    ULONG RunCount;
    ULONG StartingRun;
    LARGE_INTEGER StartingVcn;

    ULONG InputBufferLength;
    ULONG OutputBufferLength;

    PRETRIEVAL_POINTERS_BUFFER OutputBuffer;

    BOOLEAN FcbLocked;

    //
    // Get the current Irp stack location and save some references.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "FatGetRetrievalPointers, FsControlCode = %08lx\n",
               IrpSp->Parameters.FileSystemControl.FsControlCode);

    //
    // Extract and decode the file object and check for type of open.
    //

    TypeOfOpen = FatDecodeFileObject( IrpSp->FileObject, &Vcb, &FcbOrDcb, &Ccb );

    if ((TypeOfOpen != UserFileOpen) && (TypeOfOpen != UserDirectoryOpen)) {

        FatCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Get the input and output buffer lengths and pointers.
    //  Initialize some variables.
    //

    InputBufferLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;
    OutputBufferLength = IrpSp->Parameters.FileSystemControl.OutputBufferLength;

    OutputBuffer = (PRETRIEVAL_POINTERS_BUFFER)FatMapUserBuffer( IrpContext, Irp );

    //
    //  Check for a minimum length on the input and ouput buffers.
    //

    if ((InputBufferLength < sizeof(STARTING_VCN_INPUT_BUFFER)) ||
        (OutputBufferLength < sizeof(RETRIEVAL_POINTERS_BUFFER))) {

        FatCompleteRequest( IrpContext, Irp, STATUS_BUFFER_TOO_SMALL );
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    //  Acquire the Fcb and enqueue the Irp if we didn't get access.  Go for
    //  shared on read-only media so we can allow prototype XIP to get
    //  recursive, as well as recognizing this is safe anyway.
    //

    if (FlagOn( FcbOrDcb->Vcb->VcbState, VCB_STATE_FLAG_WRITE_PROTECTED )) {

        FcbLocked = FatAcquireSharedFcb( IrpContext, FcbOrDcb );

    } else {

        FcbLocked = FatAcquireExclusiveFcb( IrpContext, FcbOrDcb );
    }

    if (!FcbLocked) {

        DebugTrace( 0, Dbg, "Cannot acquire Vcb\n", 0);

        ASSERT( Irp->RequestorMode == KernelMode );

        Status = FatFsdPostRequest( IrpContext, Irp );

        DebugTrace(-1, Dbg, "FatGetRetrievalPointers -> %08lx\n", Status);
        return Status;
    }
    
    try {

        //
        //  Verify the Fcb is still OK
        //

        FatVerifyFcb( IrpContext, FcbOrDcb );

        //
        //  If we haven't yet set the correct AllocationSize, do so.
        //

        if (FcbOrDcb->Header.AllocationSize.QuadPart == FCB_LOOKUP_ALLOCATIONSIZE_HINT) {

            FatLookupFileAllocationSize( IrpContext, FcbOrDcb );

            //
            //  If this is a non-root directory, we have a bit more to
            //  do since it has not gone through FatOpenDirectoryFile().
            //

            if (NodeType(FcbOrDcb) == FAT_NTC_DCB ||
                (NodeType(FcbOrDcb) == FAT_NTC_ROOT_DCB && FatIsFat32(Vcb))) {

                FcbOrDcb->Header.FileSize.LowPart =
                    FcbOrDcb->Header.AllocationSize.LowPart;
            }
        }

        //
        //  Check if a starting cluster was specified.
        //

        ClusterShift = Vcb->AllocationSupport.LogOfBytesPerCluster;
        AllocationSize = FcbOrDcb->Header.AllocationSize.LowPart;

        try {

            if (Irp->RequestorMode != KernelMode) {

                ProbeForRead( IrpSp->Parameters.FileSystemControl.Type3InputBuffer,
                              InputBufferLength,
                              sizeof(UCHAR) );

                ProbeForWrite( OutputBuffer, OutputBufferLength, sizeof(UCHAR) );
            }

            StartingVcn = ((PSTARTING_VCN_INPUT_BUFFER)IrpSp->Parameters.FileSystemControl.Type3InputBuffer)->StartingVcn;

        } except( Irp->RequestorMode != KernelMode ? EXCEPTION_EXECUTE_HANDLER: EXCEPTION_CONTINUE_SEARCH ) {

              Status = GetExceptionCode();

              FatRaiseStatus( IrpContext,
                              FsRtlIsNtstatusExpected(Status) ?
                              Status : STATUS_INVALID_USER_BUFFER );
        }

        if (StartingVcn.HighPart ||
            StartingVcn.LowPart >= (AllocationSize >> ClusterShift)) {

            try_return( Status = STATUS_END_OF_FILE );

        } else {

            //
            //  If we don't find the run, something is very wrong.
            //

            LBO Lbo;

            if (!FatLookupMcbEntry( FcbOrDcb->Vcb, &FcbOrDcb->Mcb,
                                    StartingVcn.LowPart << ClusterShift,
                                    &Lbo,
                                    NULL,
                                    &StartingRun)) {

                FatBugCheck( (ULONG_PTR)FcbOrDcb, (ULONG_PTR)&FcbOrDcb->Mcb, StartingVcn.LowPart );
            }
        }

        //
        //  Now go fill in the ouput buffer with run information
        //

        RunCount = FsRtlNumberOfRunsInLargeMcb( &FcbOrDcb->Mcb );

        for (Index = 0, Run = StartingRun; Run < RunCount; Index++, Run++) {

            ULONG Vcn;
            LBO Lbo;
            ULONG ByteLength;

            //
            //  Check for an exhausted output buffer.
            //

            if ((ULONG)FIELD_OFFSET(RETRIEVAL_POINTERS_BUFFER, Extents[Index+1]) > OutputBufferLength) {


                //
                //  We've run out of space, so we won't be storing as many runs to the
                //  user's buffer as we had originally planned.  We need to return the
                //  number of runs that we did have room for.
                //

                try {

                    OutputBuffer->ExtentCount = Index;

                } except( Irp->RequestorMode != KernelMode ? EXCEPTION_EXECUTE_HANDLER: EXCEPTION_CONTINUE_SEARCH ) {

                    Status = GetExceptionCode();

                    FatRaiseStatus( IrpContext,
                                    FsRtlIsNtstatusExpected(Status) ?
                                    Status : STATUS_INVALID_USER_BUFFER );
                }

                Irp->IoStatus.Information = FIELD_OFFSET(RETRIEVAL_POINTERS_BUFFER, Extents[Index]);
                try_return( Status = STATUS_BUFFER_OVERFLOW );
            }

            //
            //  Get the extent.  If it's not there or malformed, something is very wrong.
            //

            if (!FatGetNextMcbEntry(Vcb, &FcbOrDcb->Mcb, Run, &Vcn, &Lbo, &ByteLength)) {
                FatBugCheck( (ULONG_PTR)FcbOrDcb, (ULONG_PTR)&FcbOrDcb->Mcb, Run );
            }

            //
            //  Fill in the next array element.
            //

            try {

                OutputBuffer->Extents[Index].NextVcn.QuadPart = (Vcn + ByteLength) >> ClusterShift;
                OutputBuffer->Extents[Index].Lcn.QuadPart = FatGetIndexFromLbo( Vcb, Lbo ) - 2;

                //
                //  If this is the first run, fill in the starting Vcn
                //

                if (Index == 0) {
                    OutputBuffer->ExtentCount = RunCount - StartingRun;
                    OutputBuffer->StartingVcn.QuadPart = Vcn >> ClusterShift;
                }

            } except( Irp->RequestorMode != KernelMode ? EXCEPTION_EXECUTE_HANDLER: EXCEPTION_CONTINUE_SEARCH ) {

                Status = GetExceptionCode();

                FatRaiseStatus( IrpContext,
                                FsRtlIsNtstatusExpected(Status) ?
                                Status : STATUS_INVALID_USER_BUFFER );
            }
        }

        //
        //  We successfully retrieved extent info to the end of the allocation.
        //

        Irp->IoStatus.Information = FIELD_OFFSET(RETRIEVAL_POINTERS_BUFFER, Extents[Index]);
        Status = STATUS_SUCCESS;

    try_exit: NOTHING;

    } finally {

        DebugUnwind( FatGetRetrievalPointers );

        //
        //  Release resources
        //

        FatReleaseFcb( IrpContext, FcbOrDcb );

        //
        //  If nothing raised then complete the irp.
        //

        if (!AbnormalTermination()) {

            FatCompleteRequest( IrpContext, Irp, Status );
        }

        DebugTrace(-1, Dbg, "FatGetRetrievalPointers -> VOID\n", 0);
    }

    return Status;
}


//
//  Local Support Routine
//

NTSTATUS
FatMoveFile (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    Routine moves a file to the requested Starting Lcn from Starting Vcn for the length
    of cluster count. These values are passed in through the the input buffer as a
    MOVE_DATA structure.

    The call must be made with a DASD handle.  The file to move is passed in as a
    parameter.

Arguments:

    Irp - Supplies the Irp being processed.

Return Value:

    NTSTATUS - The return status for the operation.

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;

    PFILE_OBJECT FileObject;
    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB FcbOrDcb;
    PCCB Ccb;

    ULONG InputBufferLength;
    PMOVE_FILE_DATA InputBuffer;

    ULONG ClusterShift;
    ULONG MaxClusters;

    ULONG FileOffset;
    LARGE_INTEGER LargeFileOffset;

    LBO TargetLbo;
    ULONG TargetCluster;
    LARGE_INTEGER LargeTargetLbo;

    ULONG ByteCount;
    ULONG BytesToWrite;
    ULONG BytesToReallocate;
    ULONG TargetAllocation;

    ULONG FirstSpliceSourceCluster;
    ULONG FirstSpliceTargetCluster;
    ULONG SecondSpliceSourceCluster;
    ULONG SecondSpliceTargetCluster;

    LARGE_MCB SourceMcb;
    LARGE_MCB TargetMcb;

    KEVENT StackEvent;

    PBCB Bcb = NULL;
    PMDL Mdl = NULL;
    PVOID Buffer;

    BOOLEAN SourceMcbInitialized = FALSE;
    BOOLEAN TargetMcbInitialized = FALSE;
    BOOLEAN CacheMapInitialized = FALSE;

    BOOLEAN FcbAcquired = FALSE;
    BOOLEAN LockedPages = FALSE;
    BOOLEAN EventArmed = FALSE;
    BOOLEAN DiskSpaceAllocated = FALSE;

    PDIRENT Dirent;
    PBCB DirentBcb = NULL;

#if defined(_WIN64)
    MOVE_FILE_DATA LocalMoveFileData;
    PMOVE_FILE_DATA32 MoveFileData32;
#endif

    ULONG LocalAbnormalTermination = 0;

    //
    //  Get the current Irp stack location and save some references.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "FatMoveFile, FsControlCode = %08lx\n",
               IrpSp->Parameters.FileSystemControl.FsControlCode);

    //
    //  Force WAIT to true.  We have a handle in the input buffer which can only
    //  be referenced within the originating process.
    //

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT );

    //
    //  Extract and decode the file object and check for type of open.
    //

    if (FatDecodeFileObject( IrpSp->FileObject, &Vcb, &FcbOrDcb, &Ccb ) != UserVolumeOpen) {

        FatCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

        DebugTrace(-1, Dbg, "FatMoveFile -> %08lx\n", STATUS_INVALID_PARAMETER);
        return STATUS_INVALID_PARAMETER;
    }

    if ((Ccb == NULL) || !FlagOn( Ccb->Flags, CCB_FLAG_MANAGE_VOLUME_ACCESS )) {

        FatCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

        DebugTrace(-1, Dbg, "FatMoveFile -> %08lx\n", STATUS_INVALID_PARAMETER);
        return STATUS_INVALID_PARAMETER;
    }

    InputBufferLength = IrpSp->Parameters.FileSystemControl.InputBufferLength;
    InputBuffer = (PMOVE_FILE_DATA)Irp->AssociatedIrp.SystemBuffer;

    //
    //  Do a quick check on the input buffer.
    //
    
#if defined(_WIN64)
    if (IoIs32bitProcess( Irp )) {

        if (InputBuffer == NULL || InputBufferLength < sizeof(MOVE_FILE_DATA32)) {

            FatCompleteRequest( IrpContext, Irp, STATUS_BUFFER_TOO_SMALL );
            return STATUS_BUFFER_TOO_SMALL;
        }

        MoveFileData32 = (PMOVE_FILE_DATA32) InputBuffer;

        LocalMoveFileData.FileHandle = (HANDLE) LongToHandle( MoveFileData32->FileHandle );
        LocalMoveFileData.StartingVcn = MoveFileData32->StartingVcn;
        LocalMoveFileData.StartingLcn = MoveFileData32->StartingLcn;
        LocalMoveFileData.ClusterCount = MoveFileData32->ClusterCount;

        InputBuffer = &LocalMoveFileData;

    } else {
#endif
        if (InputBuffer == NULL || InputBufferLength < sizeof(MOVE_FILE_DATA)) {

            FatCompleteRequest( IrpContext, Irp, STATUS_BUFFER_TOO_SMALL );
            return STATUS_BUFFER_TOO_SMALL;
        }
#if defined(_WIN64)
    }
#endif

    MaxClusters = Vcb->AllocationSupport.NumberOfClusters;
    TargetCluster = InputBuffer->StartingLcn.LowPart + 2;

    if (InputBuffer->StartingVcn.HighPart ||
        InputBuffer->StartingLcn.HighPart ||
        (TargetCluster < 2) ||
        (TargetCluster + InputBuffer->ClusterCount < TargetCluster) ||
        (TargetCluster + InputBuffer->ClusterCount > MaxClusters + 2) ||
        (InputBuffer->StartingVcn.LowPart >= MaxClusters)) {

        FatCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

        DebugTrace(-1, Dbg, "FatMoveFile -> %08lx\n", STATUS_INVALID_PARAMETER);
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Try to get a pointer to the file object from the handle passed in.
    //

    Status = ObReferenceObjectByHandle( InputBuffer->FileHandle,
                                        0,
                                        *IoFileObjectType,
                                        Irp->RequestorMode,
                                        &FileObject,
                                        NULL );

    if (!NT_SUCCESS(Status)) {

        FatCompleteRequest( IrpContext, Irp, Status );

        DebugTrace(-1, Dbg, "FatMoveFile -> %08lx\n", Status);
        return Status;
    }

    //
    //  There are three basic ways this could be an invalid attempt, so
    //  we need to
    //
    //    - check that this file object is opened on the same volume as the
    //      DASD handle used to call this routine.
    //
    //    - extract and decode the file object and check for type of open.
    //
    //    - if this is a directory, verify that it's not the root and that
    //      we are not trying to move the first cluster.  We cannot move the
    //      first cluster because sub-directories have this cluster number
    //      in them and there is no safe way to simultaneously update them
    //      all.
    //
    //  We'll allow movefile on the root dir if its fat32, since the root dir
    //  is a real chained file there.
    //

    if (FileObject->Vpb != Vcb->Vpb) {

        ObDereferenceObject( FileObject );
        FatCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

        DebugTrace(-1, Dbg, "FatMoveFile -> %08lx\n", STATUS_INVALID_PARAMETER);
        return STATUS_INVALID_PARAMETER;
    }

    TypeOfOpen = FatDecodeFileObject( FileObject, &Vcb, &FcbOrDcb, &Ccb );

    if ((TypeOfOpen != UserFileOpen &&
         TypeOfOpen != UserDirectoryOpen) ||

        ((TypeOfOpen == UserDirectoryOpen) &&
         ((NodeType(FcbOrDcb) == FAT_NTC_ROOT_DCB && !FatIsFat32(Vcb)) ||
          (InputBuffer->StartingVcn.QuadPart == 0)))) {

        ObDereferenceObject( FileObject );
        FatCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

        DebugTrace(-1, Dbg, "FatMoveFile -> %08lx\n", STATUS_INVALID_PARAMETER);
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Indicate we're getting to parents of this fcb by their child, and that
    //  this is a sufficient assertion of our ability to by synchronized
    //  with respect to the parent directory going away.
    //
    //  The defrag path is an example of one which arrives at an Fcb by
    //  a means which would be unreasonable to duplicate in the assertion
    //  code. See FatOpenDirectoryFile.
    //

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_PARENT_BY_CHILD );

    ClusterShift = Vcb->AllocationSupport.LogOfBytesPerCluster;

    try {

        //
        //  Initialize our state variables and the event.
        //

        FileOffset = InputBuffer->StartingVcn.LowPart << ClusterShift;
        LargeFileOffset.QuadPart = FileOffset;

        ByteCount = InputBuffer->ClusterCount << ClusterShift;

        TargetLbo = FatGetLboFromIndex( Vcb, TargetCluster );
        LargeTargetLbo.QuadPart = TargetLbo;

        //
        //  Do a quick check on parameters here
        //

        if (FileOffset + ByteCount < FileOffset) {

            try_return( Status = STATUS_INVALID_PARAMETER );
        }

        KeInitializeEvent( &StackEvent, NotificationEvent, FALSE );

        //
        //  Initialize two MCBs we will be using
        //

        FsRtlInitializeLargeMcb( &SourceMcb, PagedPool );
        SourceMcbInitialized = TRUE;

        FsRtlInitializeLargeMcb( &TargetMcb, PagedPool );
        TargetMcbInitialized = TRUE;

        //
        //  Ok, now if this is a directory open we need to switch to the internal
        //  stream fileobject since it is set up for caching.  The top-level
        //  fileobject has no section object pointers in order prevent folks from
        //  mapping it.
        //

        if (TypeOfOpen == UserDirectoryOpen) {

            PFILE_OBJECT DirStreamFileObject;

            //
            //  Open the stream fileobject if neccesary.  We must acquire the Fcb
            //  now to synchronize with other operations (such as dismount ripping
            //  apart the allocator).
            //

            (VOID)FatAcquireExclusiveFcb( IrpContext, FcbOrDcb );
            FcbAcquired = TRUE;

            FatVerifyFcb( IrpContext, FcbOrDcb );

            FatOpenDirectoryFile( IrpContext, FcbOrDcb );
            DirStreamFileObject = FcbOrDcb->Specific.Dcb.DirectoryFile;

            //
            //  Transfer our reference to the internal stream and proceed.  Note that
            //  if we dereferenced first, the user could sneak a teardown through since
            //  we'd have no references.
            //

            ObReferenceObject( DirStreamFileObject );
            ObDereferenceObject( FileObject );
            FileObject = DirStreamFileObject;
        }

        while (ByteCount) {

            VBO TempVbo;
            LBO TempLbo;
            ULONG TempByteCount;

            //
            //  We must throttle our writes.
            //

            CcCanIWrite( FileObject, 0x40000, TRUE, FALSE );

            //
            //  Aqcuire file resource exclusive to freeze FileSize and block
            //  user non-cached I/O.  Verify the integrity of the fcb - the
            //  media may have changed (or been dismounted) on us.
            //

            if (FcbAcquired == FALSE) {

                (VOID)FatAcquireExclusiveFcb( IrpContext, FcbOrDcb );
                FcbAcquired = TRUE;
                
                FatVerifyFcb( IrpContext, FcbOrDcb );
            }

            //
            //  Analyzes the range of file allocation we are moving
            //  and determines the actual amount of allocation to be
            //  moved and how much needs to be written.  In addition
            //  it guarantees that the Mcb in the file is large enough
            //  so that later MCB operations cannot fail.
            //

            FatComputeMoveFileParameter( IrpContext,
                                         FcbOrDcb,
                                         FileOffset,
                                         &ByteCount,
                                         &BytesToReallocate,
                                         &BytesToWrite );

            //
            //  If ByteCount comes back zero, break here.
            //

            if (ByteCount == 0) {
                break;
            }

            //
            //  At this point (before actually doing anything with the disk
            //  meta data), calculate the FAT splice clusters and build an
            //  MCB describing the space to be deallocated.
            //

            FatComputeMoveFileSplicePoints( IrpContext,
                                            FcbOrDcb,
                                            FileOffset,
                                            TargetCluster,
                                            BytesToReallocate,
                                            &FirstSpliceSourceCluster,
                                            &FirstSpliceTargetCluster,
                                            &SecondSpliceSourceCluster,
                                            &SecondSpliceTargetCluster,
                                            &SourceMcb );

            //
            //  Now attempt to allocate the new disk storage using the
            //  Target Lcn as a hint.
            //

            TempByteCount = BytesToReallocate;
            FatAllocateDiskSpace( IrpContext,
                                  Vcb,
                                  TargetCluster,
                                  &TempByteCount,
                                  TRUE,
                                  &TargetMcb );

            DiskSpaceAllocated = TRUE;

            //
            //  If we didn't get EXACTLY what we wanted, return immediately.
            //

            if ((FsRtlNumberOfRunsInLargeMcb( &TargetMcb ) != 1) ||
                !FatGetNextMcbEntry( Vcb, &TargetMcb, 0, &TempVbo, &TempLbo, &TempByteCount ) ||
                (FatGetIndexFromLbo( Vcb, TempLbo) != TargetCluster ) ||
                (TempByteCount != BytesToReallocate)) {

                //
                //  It would be nice if we could be more specific, but such is life.
                //
                try_return( Status = STATUS_INVALID_PARAMETER );
            }

#if DBG
            //
            //  We are going to attempt a move, note it.
            //

            if (FatMoveFileDebug) {
                DbgPrint("%lx: Vcn 0x%lx, Lcn 0x%lx, Count 0x%lx.\n",
                         PsGetCurrentThread(),
                         FileOffset >> ClusterShift,
                         TargetCluster,
                         BytesToReallocate >> ClusterShift );
            }
#endif

            //
            //  Now attempt to commit the new allocation to disk.  If this
            //  raises, the allocation will be deallocated.
            //

            FatFlushFatEntries( IrpContext,
                                Vcb,
                                TargetCluster,
                                BytesToReallocate >> ClusterShift );

            //
            //  If we are going to write, we have to lock the pages down BEFORE
            //  closing off the paging I/O path to avoid a deadlock from
            //  colided page faults.
            //

            if (BytesToWrite) {

                //
                //  Ensure the shared cache map is set up.
                //

                if (FileObject->PrivateCacheMap == NULL ) {

                    CcInitializeCacheMap( FileObject,
                                          (PCC_FILE_SIZES)&FcbOrDcb->Header.AllocationSize,
                                          TRUE,
                                          &FatData.CacheManagerCallbacks,
                                          FcbOrDcb );

                    CacheMapInitialized = TRUE;
                }

                //
                //  Map the next range of the file.
                //

                CcMapData( FileObject, &LargeFileOffset, BytesToWrite, TRUE, &Bcb, &Buffer );

                //
                //  Now attempt to allocate an Mdl to describe the mapped data.
                //

                Mdl = IoAllocateMdl( Buffer, (ULONG)BytesToWrite, FALSE, FALSE, NULL );

                if (Mdl == NULL) {
                    FatRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES );
                }

                //
                //  Lock the data into memory so that we can safely reallocate the
                //  space.
                //

                MmProbeAndLockPages( Mdl, KernelMode, IoReadAccess );
                LockedPages = TRUE;
            }

            //
            //  Aqcuire both resources exclusive now, guaranteeing that NOBODY
            //  is in either the read or write paths.
            //

            ExAcquireResourceExclusiveLite( FcbOrDcb->Header.PagingIoResource, TRUE );

            //
            //  This is the first part of some tricky synchronization.
            //
            //  Set the Event pointer in the FCB.  Any paging I/O will block on
            //  this event (if set in FCB) after acquiring the PagingIo resource.
            //
            //  This is how I keep ALL I/O out of this path without holding the
            //  PagingIo resource exclusive for an extended time.
            //

            FcbOrDcb->MoveFileEvent = &StackEvent;
            EventArmed = TRUE;

            ExReleaseResourceLite( FcbOrDcb->Header.PagingIoResource );

            //
            //  Now write out the data, but only if we have to.  We don't have
            //  to copy any file data if the range being reallocated is wholly
            //  beyond valid data length.
            //

            if (BytesToWrite) {

                PIRP IoIrp;
                KEVENT IoEvent;
                IO_STATUS_BLOCK Iosb;

                KeInitializeEvent( &IoEvent, NotificationEvent, FALSE );

                ASSERT( LargeTargetLbo.QuadPart >= Vcb->AllocationSupport.FileAreaLbo);

                IoIrp = IoBuildSynchronousFsdRequest( IRP_MJ_WRITE,
                                                      Vcb->TargetDeviceObject,
                                                      Buffer,
                                                      BytesToWrite,
                                                      &LargeTargetLbo,
                                                      &IoEvent,
                                                      &Iosb );

                if (!IoIrp) {
                    FatRaiseStatus( IrpContext, STATUS_INSUFFICIENT_RESOURCES );
                }

                //
                //  Set a flag indicating that we want to write through any
                //  cache on the controller.  This eliminates the need for
                //  an explicit flush-device after the write.
                //

                SetFlag( IoGetNextIrpStackLocation(IoIrp)->Flags, SL_WRITE_THROUGH );

                Status = IoCallDriver( Vcb->TargetDeviceObject, IoIrp );

                if (Status == STATUS_PENDING) {
                    (VOID)KeWaitForSingleObject( &IoEvent, Executive, KernelMode, FALSE, (PLARGE_INTEGER)NULL );
                    Status = Iosb.Status;
                }

                if (!NT_SUCCESS(Status)) {
                    FatNormalizeAndRaiseStatus( IrpContext, Status );
                }

                //
                //  Now we can get rid of this Mdl.
                //

                MmUnlockPages( Mdl );
                LockedPages = FALSE;
                IoFreeMdl( Mdl );
                Mdl = NULL;

                //
                //  Now we can safely unpin.
                //

                CcUnpinData( Bcb );
                Bcb = NULL;
            }

            //
            //  Now that the file data has been moved successfully, we'll go
            //  to fix up the links in the FAT table and perhaps change the
            //  entry in the parent directory.
            //
            //  First we'll do the second splice and commit it.  At that point,
            //  while the volume is in an inconsistent state, the file is
            //  still OK.
            //

            FatSetFatEntry( IrpContext,
                            Vcb,
                            SecondSpliceSourceCluster,
                            (FAT_ENTRY)SecondSpliceTargetCluster );

            FatFlushFatEntries( IrpContext, Vcb, SecondSpliceSourceCluster, 1 );

            //
            //  Now do the first splice OR update the dirent in the parent
            //  and flush the respective object.  After this flush the file
            //  now points to the new allocation.
            //

            if (FirstSpliceSourceCluster == 0) {

                ASSERT( NodeType(FcbOrDcb) == FAT_NTC_FCB );

                //
                //  We are moving the first cluster of the file, so we need
                //  to update our parent directory.
                //

                FatGetDirentFromFcbOrDcb( IrpContext, FcbOrDcb, &Dirent, &DirentBcb );
                Dirent->FirstClusterOfFile = (USHORT)FirstSpliceTargetCluster;

                if (FatIsFat32(Vcb)) {

                    Dirent->FirstClusterOfFileHi =
                        (USHORT)(FirstSpliceTargetCluster >> 16);

                }

                FatSetDirtyBcb( IrpContext, DirentBcb, Vcb, TRUE );

                FatUnpinBcb( IrpContext, DirentBcb );
                DirentBcb = NULL;

                FatFlushDirentForFile( IrpContext, FcbOrDcb );

                FcbOrDcb->FirstClusterOfFile = FirstSpliceTargetCluster;

            } else {

                FatSetFatEntry( IrpContext,
                                Vcb,
                                FirstSpliceSourceCluster,
                                (FAT_ENTRY)FirstSpliceTargetCluster );

                FatFlushFatEntries( IrpContext, Vcb, FirstSpliceSourceCluster, 1 );
            }

            //
            //  This was successfully committed.  We no longer want to free
            //  this allocation on error.
            //

            DiskSpaceAllocated = FALSE;

            //
            //  Now we just have to free the orphaned space.  We don't have
            //  to commit this right now as the integrity of the file doesn't
            //  depend on it.
            //

            FatDeallocateDiskSpace( IrpContext, Vcb, &SourceMcb );

            FatUnpinRepinnedBcbs( IrpContext );

            Status = FatHijackIrpAndFlushDevice( IrpContext,
                                                 Irp,
                                                 Vcb->TargetDeviceObject );

            if (!NT_SUCCESS(Status)) {
                FatNormalizeAndRaiseStatus( IrpContext, Status );
            }

            //
            //  Finally we must replace the old MCB extent information with
            //  the new.  If this fails from pool allocation, we fix it in
            //  the finally clause by resetting the file's Mcb.
            //

            FatRemoveMcbEntry( Vcb, &FcbOrDcb->Mcb,
                               FileOffset,
                               BytesToReallocate );

            FatAddMcbEntry( Vcb, &FcbOrDcb->Mcb,
                            FileOffset,
                            TargetLbo,
                            BytesToReallocate );

            //
            //  Now this is the second part of the tricky synchronization.
            //
            //  We drop the paging I/O here and signal the notification
            //  event which allows all waiters (present or future) to proceed.
            //  Then we block again on the PagingIo exclusive.  When
            //  we have it, we again know that there can be nobody in the
            //  read/write path and thus nobody touching the event, so we
            //  NULL the pointer to it and then drop the PagingIo resource.
            //
            //  This combined with our synchronization before the write above
            //  guarantees that while we were moving the allocation, there
            //  was no other I/O to this file and because we do not hold
            //  the paging resource across a flush, we are not exposed to
            //  a deadlock.
            //

            KeSetEvent( &StackEvent, 0, FALSE );

            ExAcquireResourceExclusiveLite( FcbOrDcb->Header.PagingIoResource, TRUE );

            FcbOrDcb->MoveFileEvent = NULL;
            EventArmed = FALSE;

            ExReleaseResourceLite( FcbOrDcb->Header.PagingIoResource );

            //
            //  Release the resources and let anyone else access the file before
            //  looping back.
            //

            FatReleaseFcb( IrpContext, FcbOrDcb );
            FcbAcquired = FALSE;

            //
            //  Advance the state variables.
            //

            TargetCluster += BytesToReallocate >> ClusterShift;

            FileOffset += BytesToReallocate;
            TargetLbo += BytesToReallocate;
            ByteCount -= BytesToReallocate;

            LargeFileOffset.LowPart += BytesToReallocate;
            LargeTargetLbo.QuadPart += BytesToReallocate;

            //
            //  Clear the two Mcbs
            //

            FatRemoveMcbEntry( Vcb, &SourceMcb, 0, 0xFFFFFFFF );
            FatRemoveMcbEntry( Vcb, &TargetMcb, 0, 0xFFFFFFFF );

            //
            //  Make the event blockable again.
            //

            KeClearEvent( &StackEvent );
        }

        Status = STATUS_SUCCESS;

    try_exit: NOTHING;

    } finally {

        DebugUnwind( FatMoveFile );

        LocalAbnormalTermination |= AbnormalTermination();

        ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_PARENT_BY_CHILD );

        //
        //  Cleanup the Mdl, Bcb, and cache map as appropriate.
        //

        if (Mdl != NULL) {
            ASSERT(LocalAbnormalTermination);
            if (LockedPages) {
                MmUnlockPages( Mdl );
            }
            IoFreeMdl( Mdl );
        }

        if (Bcb != NULL) {
            ASSERT(LocalAbnormalTermination);
            CcUnpinData( Bcb );
        }

        if (CacheMapInitialized) {
            CcUninitializeCacheMap( FileObject, NULL, NULL );
        }

        //
        //  Use a nested try-finally for cleanup if our unpinrepinned
        //  encounters write-through errors.  This may even be a re-raise.
        //

        try {

            //
            //  If we have some new allocation hanging around, remove it.  The
            //  pages needed to do this are guaranteed to be resident because
            //  we have already repinned them.
            //

            if (DiskSpaceAllocated) {
                FatDeallocateDiskSpace( IrpContext, Vcb, &TargetMcb );
                FatUnpinRepinnedBcbs( IrpContext );
            }

        } finally {

            LocalAbnormalTermination |= AbnormalTermination();

            //
            //  Check on the directory Bcb
            //

            if (DirentBcb != NULL) {
                FatUnpinBcb( IrpContext, DirentBcb );
            }

            //
            //  Uninitialize our MCBs
            //

            if (SourceMcbInitialized) {
                FsRtlUninitializeLargeMcb( &SourceMcb );
            }

            if (TargetMcbInitialized) {
                FsRtlUninitializeLargeMcb( &TargetMcb );
            }

            //
            //  If this is an abnormal termination then presumably something
            //  bad happened.  Set the Allocation size to unknown and clear
            //  the Mcb, but only if we still own the Fcb.
            //
            //  It is important to make sure we use a 64bit form of -1.  This is
            //  what will convince the fastIO path that it cannot extend the file
            //  in the cache until we have picked up the mapping pairs again.
            //
            //  Also, we have to do this while owning PagingIo or we can tear the
            //  Mcb down in the midst of the noncached IO path looking up extents
            //  (after we drop it and let them all in).
            //

            if (LocalAbnormalTermination && FcbAcquired) {

                FcbOrDcb->Header.AllocationSize.QuadPart = FCB_LOOKUP_ALLOCATIONSIZE_HINT;
                FatRemoveMcbEntry( Vcb, &FcbOrDcb->Mcb, 0, 0xFFFFFFFF );
            }

            //
            //  If we broke out of the loop with the Event armed, defuse it
            //  in the same way we do it after a write.
            //

            if (EventArmed) {
                KeSetEvent( &StackEvent, 0, FALSE );
                ExAcquireResourceExclusiveLite( FcbOrDcb->Header.PagingIoResource, TRUE );
                FcbOrDcb->MoveFileEvent = NULL;
                ExReleaseResourceLite( FcbOrDcb->Header.PagingIoResource );
            }

            //
            //  Finally release the main file resource.
            //

            if (FcbAcquired) {
                FatReleaseFcb( IrpContext, FcbOrDcb );
            }

            //
            //  Now dereference the fileobject.  If the user was a wacko they could have
            //  tried to nail us by closing the handle right after they threw this move
            //  down, so we had to keep the fileobject referenced across the entire
            //  operation.
            //

            ObDereferenceObject( FileObject );

        }
    }

    //
    //  Complete the irp if we terminated normally.
    //

    FatCompleteRequest( IrpContext, Irp, Status );

    return Status;
}


//
//  Local Support Routine
//

VOID
FatComputeMoveFileParameter (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB FcbOrDcb,
    IN ULONG FileOffset,
    IN OUT PULONG ByteCount,
    OUT PULONG BytesToReallocate,
    OUT PULONG BytesToWrite
)

/*++

Routine Description:

    This is a helper routine for FatMoveFile that analyses the range of
    file allocation we are moving and determines the actual amount
    of allocation to be moved and how much needs to be written.

Arguments:

    FcbOrDcb - Supplies the file and its various sizes.

    FileOffset - Supplies the beginning Vbo of the reallocation zone.

    ByteCount - Supplies the request length to reallocate.  This will
        be bounded by allocation size on return.

    BytesToReallocate - Receives ByteCount bounded by the file allocation size
        and a 0x40000 boundry.

    BytesToWrite - Receives BytesToReallocate bounded by ValidDataLength.

Return Value:

    VOID

--*/

{
    ULONG ClusterSize;

    ULONG AllocationSize;
    ULONG ValidDataLength;
    ULONG ClusterAlignedVDL;

    //
    //  If we haven't yet set the correct AllocationSize, do so.
    //

    if (FcbOrDcb->Header.AllocationSize.QuadPart == FCB_LOOKUP_ALLOCATIONSIZE_HINT) {

        FatLookupFileAllocationSize( IrpContext, FcbOrDcb );

        //
        //  If this is a non-root directory, we have a bit more to
        //  do since it has not gone through FatOpenDirectoryFile().
        //

        if (NodeType(FcbOrDcb) == FAT_NTC_DCB ||
            (NodeType(FcbOrDcb) == FAT_NTC_ROOT_DCB && FatIsFat32(FcbOrDcb->Vcb))) {

            FcbOrDcb->Header.FileSize.LowPart =
                FcbOrDcb->Header.AllocationSize.LowPart;
        }
    }

    //
    //  Get the number of bytes left to write and ensure that it does
    //  not extend beyond allocation size.  We return here if FileOffset
    //  is beyond AllocationSize which can happn on a truncation.
    //

    AllocationSize = FcbOrDcb->Header.AllocationSize.LowPart;
    ValidDataLength = FcbOrDcb->Header.ValidDataLength.LowPart;

    if (FileOffset + *ByteCount > AllocationSize) {

        if (FileOffset >= AllocationSize) {
            *ByteCount = 0;
            *BytesToReallocate = 0;
            *BytesToWrite = 0;

            return;
        }

        *ByteCount = AllocationSize - FileOffset;
    }

    //
    //  If there is more than our max, then reduce the byte count for this
    //  pass to our maximum. We must also align the file offset to a 0x40000
    //  byte boundary.
    //

    if ((FileOffset & 0x3ffff) + *ByteCount > 0x40000) {

        *BytesToReallocate = 0x40000 - (FileOffset & 0x3ffff);

    } else {

        *BytesToReallocate = *ByteCount;
    }

    //
    //  We may be able to skip some (or all) of the write
    //  if allocation size is significantly greater than valid data length.
    //

    ClusterSize = 1 << FcbOrDcb->Vcb->AllocationSupport.LogOfBytesPerCluster;

    ClusterAlignedVDL = (ValidDataLength + (ClusterSize - 1)) & ~(ClusterSize - 1);

    if ((NodeType(FcbOrDcb) == FAT_NTC_FCB) &&
        (FileOffset + *BytesToReallocate > ClusterAlignedVDL)) {

        if (FileOffset > ClusterAlignedVDL) {

            *BytesToWrite = 0;

        } else {

            *BytesToWrite = ClusterAlignedVDL - FileOffset;
        }

    } else {

        *BytesToWrite = *BytesToReallocate;
    }
}


//
//  Local Support Routine
//

VOID
FatComputeMoveFileSplicePoints (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB FcbOrDcb,
    IN ULONG FileOffset,
    IN ULONG TargetCluster,
    IN ULONG BytesToReallocate,
    OUT PULONG FirstSpliceSourceCluster,
    OUT PULONG FirstSpliceTargetCluster,
    OUT PULONG SecondSpliceSourceCluster,
    OUT PULONG SecondSpliceTargetCluster,
    IN OUT PLARGE_MCB SourceMcb
)

/*++

Routine Description:

    This is a helper routine for FatMoveFile that analyzes the range of
    file allocation we are moving and generates the splice points in the
    FAT table.

Arguments:

    FcbOrDcb - Supplies the file and thus Mcb.

    FileOffset - Supplies the beginning Vbo of the reallocation zone.

    TargetCluster - Supplies the beginning cluster of the reallocation target.

    BytesToReallocate - Suppies the length of the reallocation zone.

    FirstSpliceSourceCluster - Receives the last cluster in previous allocation
        or zero if we are reallocating from VBO 0.

    FirstSpliceTargetCluster - Receives the target cluster (i.e. new allocation)

    SecondSpliceSourceCluster - Receives the final target cluster.

    SecondSpliceTargetCluster - Receives the first cluster of the remaining
        source allocation or FAT_CLUSTER_LAST if the reallocation zone
        extends to the end of the file.

    SourceMcb - This supplies an MCB that will be filled in with run
        information describing the file allocation being replaced.  The Mcb
        must be initialized by the caller.

Return Value:

    VOID

--*/

{
    VBO SourceVbo;
    LBO SourceLbo;
    ULONG SourceIndex;
    ULONG SourceBytesInRun;
    ULONG SourceBytesRemaining;

    ULONG SourceMcbVbo;
    ULONG SourceMcbBytesInRun;

    PVCB Vcb;

    Vcb = FcbOrDcb->Vcb;

    //
    //  Get information on the final cluster in the previous allocation and
    //  prepare to enumerate it in the follow loop.
    //

    if (FileOffset == 0) {

        SourceIndex = 0;
        *FirstSpliceSourceCluster = 0;
        FatGetNextMcbEntry( Vcb, &FcbOrDcb->Mcb,
                            0,
                            &SourceVbo,
                            &SourceLbo,
                            &SourceBytesInRun );

    } else {

        FatLookupMcbEntry( Vcb, &FcbOrDcb->Mcb,
                           FileOffset-1,
                           &SourceLbo,
                           &SourceBytesInRun,
                           &SourceIndex);

        *FirstSpliceSourceCluster = FatGetIndexFromLbo( Vcb, SourceLbo );

        if (SourceBytesInRun == 1) {

            SourceIndex += 1;
            FatGetNextMcbEntry( Vcb, &FcbOrDcb->Mcb,
                                SourceIndex,
                                &SourceVbo,
                                &SourceLbo,
                                &SourceBytesInRun);

        } else {

            SourceVbo = FileOffset;
            SourceLbo += 1;
            SourceBytesInRun -= 1;
        }
    }

    //
    //  At this point the variables:
    //
    //  - SourceIndex - SourceLbo - SourceBytesInRun -
    //
    //  all correctly decribe the allocation to be removed.  In the loop
    //  below we will start here and continue enumerating the Mcb runs
    //  until we are finished with the allocation to be relocated.
    //

    *FirstSpliceTargetCluster = TargetCluster;

    *SecondSpliceSourceCluster =
         *FirstSpliceTargetCluster +
         (BytesToReallocate >> Vcb->AllocationSupport.LogOfBytesPerCluster) - 1;

    for (SourceBytesRemaining = BytesToReallocate, SourceMcbVbo = 0;

         SourceBytesRemaining > 0;

         SourceIndex += 1,
         SourceBytesRemaining -= SourceMcbBytesInRun,
         SourceMcbVbo += SourceMcbBytesInRun) {

        if (SourceMcbVbo != 0) {
            FatGetNextMcbEntry( Vcb, &FcbOrDcb->Mcb,
                                SourceIndex,
                                &SourceVbo,
                                &SourceLbo,
                                &SourceBytesInRun );
        }

        ASSERT( SourceVbo == SourceMcbVbo + FileOffset );

        SourceMcbBytesInRun =
            SourceBytesInRun < SourceBytesRemaining ?
            SourceBytesInRun : SourceBytesRemaining;

        FatAddMcbEntry( Vcb, SourceMcb,
                        SourceMcbVbo,
                        SourceLbo,
                        SourceMcbBytesInRun );
    }

    //
    //  Now compute the cluster of the target of the second
    //  splice.  If the final run in the above loop was
    //  more than we needed, then we can just do arithmetic,
    //  otherwise we have to look up the next run.
    //

    if (SourceMcbBytesInRun < SourceBytesInRun) {

        *SecondSpliceTargetCluster =
            FatGetIndexFromLbo( Vcb, SourceLbo + SourceMcbBytesInRun );

    } else {

        if (FatGetNextMcbEntry( Vcb, &FcbOrDcb->Mcb,
                                SourceIndex,
                                &SourceVbo,
                                &SourceLbo,
                                &SourceBytesInRun )) {

            *SecondSpliceTargetCluster = FatGetIndexFromLbo( Vcb, SourceLbo );

        } else {

            *SecondSpliceTargetCluster = FAT_CLUSTER_LAST;
        }
    }
}


NTSTATUS
FatAllowExtendedDasdIo(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine marks the CCB to indicate that the handle
    may be used to read past the end of the volume file.  The
    handle must be a dasd handle.

Arguments:

    Irp - Supplies the Irp being processed.

Return Value:

    NTSTATUS - The return status for the operation.

--*/
{
    PIO_STACK_LOCATION IrpSp;
    PVCB Vcb;
    PFCB Fcb;
    PCCB Ccb;

    //
    //  Get the current Irp stack location and save some references.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Extract and decode the file object and check for type of open.
    //

    if (FatDecodeFileObject( IrpSp->FileObject, &Vcb, &Fcb, &Ccb ) != UserVolumeOpen) {

        FatCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );
        return STATUS_INVALID_PARAMETER;
    }

    if ((Ccb == NULL) || !FlagOn( Ccb->Flags, CCB_FLAG_MANAGE_VOLUME_ACCESS )) {

        FatCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

        DebugTrace(-1, Dbg, "FatAllowExtendedDasdIo -> %08lx\n", STATUS_INVALID_PARAMETER);
        return STATUS_INVALID_PARAMETER;
    }

    SetFlag( Ccb->Flags, CCB_FLAG_ALLOW_EXTENDED_DASD_IO );

    FatCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
    return STATUS_SUCCESS;
}



VOID
FatFlushAndCleanVolume(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PVCB Vcb,
    IN FAT_FLUSH_TYPE FlushType
    )
/*++

Routine Description:

    This routine flushes and otherwise preparse a volume to be eligible
    for deletion.  The dismount and PNP paths share the need for this
    common work.

    The Vcb will always be valid on return from this function. It is the
    caller's responsibility to attempt the dismount/deletion, and to setup
    allocation support again if the volume will be brought back from the
    brink.

Arguments:

    Irp - Irp for the overlying request

    Vcb - the volume being operated on

    FlushType - specifies the kind of flushing desired

Return Value:

    NTSTATUS - The return status for the operation.

--*/
{
    //
    //  The volume must be held exclusive.
    //

    ASSERT( FatVcbAcquiredExclusive( IrpContext, Vcb ));

    //
    //  There is no fail, flush everything. If invalidating, it is important
    //  that we invalidate as we flush (eventually, w/ paging io held) so that we
    //  error out the maximum number of late writes.
    //

    if (FlushType != NoFlush) {

        (VOID) FatFlushVolume( IrpContext, Vcb, FlushType );
    }

    FatCloseEaFile( IrpContext, Vcb, FALSE );

    //
    //  Now, tell the device to flush its buffers.
    //

    if (FlushType != NoFlush) {

        (VOID)FatHijackIrpAndFlushDevice( IrpContext, Irp, Vcb->TargetDeviceObject );
    }

    //
    //  Now purge everything in sight.  We're trying to provoke as many closes as
    //  soon as possible, this volume may be on its way out.
    //

    if (FlushType != FlushWithoutPurge) {
        
        (VOID) FatPurgeReferencedFileObjects( IrpContext, Vcb->RootDcb, NoFlush );
    }

    //
    //  If the volume was dirty and we were allowed to flush, do the processing that
    //  the delayed callback would have done.
    //

    if (FlagOn(Vcb->VcbState, VCB_STATE_FLAG_VOLUME_DIRTY)) {

        //
        //  Cancel any pending clean volumes.
        //

        (VOID)KeCancelTimer( &Vcb->CleanVolumeTimer );
        (VOID)KeRemoveQueueDpc( &Vcb->CleanVolumeDpc );


        if (FlushType != NoFlush) {

            //
            //  The volume is now clean, note it.
            //

            if (!FlagOn(Vcb->VcbState, VCB_STATE_FLAG_MOUNTED_DIRTY)) {

                FatMarkVolume( IrpContext, Vcb, VolumeClean );
                ClearFlag( Vcb->VcbState, VCB_STATE_FLAG_VOLUME_DIRTY );
            }

            //
            //  Unlock the volume if it is removable.
            //

            if (FlagOn(Vcb->VcbState, VCB_STATE_FLAG_REMOVABLE_MEDIA) &&
                !FlagOn(Vcb->VcbState, VCB_STATE_FLAG_BOOT_OR_PAGING_FILE)) {

                FatToggleMediaEjectDisable( IrpContext, Vcb, FALSE );
            }
        }
    }

    //
    //  Uninitialize the volume file cache map.  Note that we cannot
    //  do a "FatSyncUninit" because of deadlock problems.  However,
    //  since this FileObject is referenced by us, and thus included
    //  in the Vpb residual count, it is OK to do a normal CcUninit.
    //

    if (FlushType != FlushWithoutPurge) {
        
        CcUninitializeCacheMap( Vcb->VirtualVolumeFile,
                                &FatLargeZero,
                                NULL );

        FatTearDownAllocationSupport( IrpContext, Vcb );
    }
}


NTSTATUS
FatSearchBufferForLabel(
    IN  PIRP_CONTEXT IrpContext,
    IN  PVPB  Vpb,
    IN  PVOID Buffer,
    IN  ULONG Size,
    OUT PBOOLEAN LabelFound
    )
/*++

Routine Description:

    Search a buffer (taken from the root directory) for a volume label
    matching the label in the

Arguments:

    IrpContext - Supplies our irp context
    Vpb        - Vpb supplying the volume label
    Buffer     - Supplies the buffer we'll search
    Size       - The size of the buffer in bytes.
    LabelFound - Returns whether a label was found.

Return Value:

    There are four interesting cases:

    1) Some random error occurred - that error returned as status, LabelFound
                                    is indeterminate.

    2) No label was found         - STATUS_SUCCESS returned, LabelFound is FALSE.

    3) A matching label was found - STATUS_SUCCESS returned, LabelFound is TRUE.

    4) A non-matching label found - STATUS_WRONG_VOLUME returned, LabelFound
                                    is indeterminate.

--*/

{
    NTSTATUS Status;
    WCHAR UnicodeBuffer[11];

    PDIRENT Dirent;
    PDIRENT TerminationDirent;
    ULONG VolumeLabelLength;
    OEM_STRING OemString;
    UNICODE_STRING UnicodeString;

    Dirent = Buffer;

    TerminationDirent = Dirent + Size / sizeof(DIRENT);

    while ( Dirent < TerminationDirent ) {

        if ( Dirent->FileName[0] == FAT_DIRENT_NEVER_USED ) {

            Dirent = TerminationDirent;
            break;
        }

        //
        //  If the entry is the non-deleted volume label break from the loop.
        //
        //  Note that all out parameters are already correctly set.
        //

        if (((Dirent->Attributes & ~FAT_DIRENT_ATTR_ARCHIVE) ==
             FAT_DIRENT_ATTR_VOLUME_ID) &&
            (Dirent->FileName[0] != FAT_DIRENT_DELETED)) {

            break;
        }

        Dirent += 1;
    }

    if (Dirent >= TerminationDirent) {

        //
        //  We've run out of buffer.
        //

        *LabelFound = FALSE;
        return STATUS_SUCCESS;
    }


    //
    //  Compute the length of the volume name
    //

    OemString.Buffer = &Dirent->FileName[0];
    OemString.MaximumLength = 11;

    for ( OemString.Length = 11;
          OemString.Length > 0;
          OemString.Length -= 1) {

        if ( (Dirent->FileName[OemString.Length-1] != 0x00) &&
             (Dirent->FileName[OemString.Length-1] != 0x20) ) { break; }
    }

    UnicodeString.MaximumLength = MAXIMUM_VOLUME_LABEL_LENGTH;
    UnicodeString.Buffer = &UnicodeBuffer[0];

    Status = RtlOemStringToCountedUnicodeString( &UnicodeString,
                                                 &OemString,
                                                 FALSE );

    if ( !NT_SUCCESS( Status ) ) {

        return Status;
    }

    VolumeLabelLength = UnicodeString.Length;

    if ( (VolumeLabelLength != (ULONG)Vpb->VolumeLabelLength) ||
         (!RtlEqualMemory(&UnicodeBuffer[0],
                          &Vpb->VolumeLabel[0],
                          VolumeLabelLength)) ) {

        return STATUS_WRONG_VOLUME;
    }

    //
    //  We found a matching label.
    //

    *LabelFound = TRUE;
    return STATUS_SUCCESS;
}


VOID
FatVerifyLookupFatEntry (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN ULONG FatIndex,
    IN OUT PULONG FatEntry
    )
{
    ULONG PageEntryOffset;
    ULONG OffsetIntoVolumeFile;
    PVOID Buffer;

    ASSERT(Vcb->AllocationSupport.FatIndexBitSize == 32);

    FatVerifyIndexIsValid( IrpContext, Vcb, FatIndex);

    Buffer = FsRtlAllocatePoolWithTag( NonPagedPoolCacheAligned,
                                       PAGE_SIZE,
                                       TAG_ENTRY_LOOKUP_BUFFER );

    OffsetIntoVolumeFile =  FatReservedBytes(&Vcb->Bpb) + FatIndex * sizeof(ULONG);
    PageEntryOffset = (OffsetIntoVolumeFile % PAGE_SIZE) / sizeof(ULONG);

    try {

        FatPerformVerifyDiskRead( IrpContext,
                                  Vcb,
                                  Buffer,
                                  OffsetIntoVolumeFile & ~(PAGE_SIZE - 1),
                                  PAGE_SIZE,
                                  TRUE );

        *FatEntry = ((PULONG)(Buffer))[PageEntryOffset];

    } finally {

        ExFreePool( Buffer );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fastfat\flush.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    Flush.c

Abstract:

    This module implements the File Flush buffers routine for Fat called by the
    dispatch driver.

// @@BEGIN_DDKSPLIT

Author:

    Gary Kimura     [GaryKi]    28-Dec-1989

Revision History:

// @@END_DDKSPLIT

--*/

#include "FatProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (FAT_BUG_CHECK_FLUSH)

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_FLUSH)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FatCommonFlushBuffers)
#pragma alloc_text(PAGE, FatFlushDirectory)
#pragma alloc_text(PAGE, FatFlushFat)
#pragma alloc_text(PAGE, FatFlushFile)
#pragma alloc_text(PAGE, FatFlushVolume)
#pragma alloc_text(PAGE, FatFsdFlushBuffers)
#pragma alloc_text(PAGE, FatFlushDirentForFile)
#pragma alloc_text(PAGE, FatFlushFatEntries)
#pragma alloc_text(PAGE, FatHijackIrpAndFlushDevice)
#endif

//
//  Local procedure prototypes
//

NTSTATUS
FatFlushCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    );

NTSTATUS
FatHijackCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    );


NTSTATUS
FatFsdFlushBuffers (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of Flush buffers.

Arguments:

    VolumeDeviceObject - Supplies the volume device object where the
        file being flushed exists

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The FSD status for the IRP

--*/

{
    NTSTATUS Status;
    PIRP_CONTEXT IrpContext = NULL;

    BOOLEAN TopLevel;

    PAGED_CODE();

    DebugTrace(+1, Dbg, "FatFsdFlushBuffers\n", 0);

    //
    //  Call the common Cleanup routine, with blocking allowed if synchronous
    //

    FsRtlEnterFileSystem();

    TopLevel = FatIsIrpTopLevel( Irp );

    try {

        IrpContext = FatCreateIrpContext( Irp, CanFsdWait( Irp ) );

        Status = FatCommonFlushBuffers( IrpContext, Irp );

    } except(FatExceptionFilter( IrpContext, GetExceptionInformation() )) {

        //
        //  We had some trouble trying to perform the requested
        //  operation, so we'll abort the I/O request with
        //  the error status that we get back from the
        //  execption code
        //

        Status = FatProcessException( IrpContext, Irp, GetExceptionCode() );
    }

    if (TopLevel) { IoSetTopLevelIrp( NULL ); }

    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "FatFsdFlushBuffers -> %08lx\n", Status);

    UNREFERENCED_PARAMETER( VolumeDeviceObject );

    return Status;
}


NTSTATUS
FatCommonFlushBuffers (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for flushing a buffer.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;

    PIO_STACK_LOCATION IrpSp;

    PFILE_OBJECT FileObject;

    TYPE_OF_OPEN TypeOfOpen;
    PVCB Vcb;
    PFCB Fcb;
    PCCB Ccb;

    BOOLEAN VcbAcquired = FALSE;
    BOOLEAN FcbAcquired = FALSE;

    PDIRENT Dirent;
    PBCB DirentBcb = NULL;

    PAGED_CODE();

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "FatCommonFlushBuffers\n", 0);
    DebugTrace( 0, Dbg, "Irp           = %08lx\n", Irp);
    DebugTrace( 0, Dbg, "->FileObject  = %08lx\n", IrpSp->FileObject);

    //
    //  Extract and decode the file object
    //

    FileObject = IrpSp->FileObject;
    TypeOfOpen = FatDecodeFileObject( FileObject, &Vcb, &Fcb, &Ccb );

    //
    //  CcFlushCache is always synchronous, so if we can't wait enqueue
    //  the irp to the Fsp.
    //

    if ( !FlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT) ) {

        Status = FatFsdPostRequest( IrpContext, Irp );

        DebugTrace(-1, Dbg, "FatCommonFlushBuffers -> %08lx\n", Status );
        return Status;
    }

    Status = STATUS_SUCCESS;

    try {

        //
        //  Case on the type of open that we are trying to flush
        //

        switch (TypeOfOpen) {

        case VirtualVolumeFile:
        case EaFile:
        case DirectoryFile:

            DebugTrace(0, Dbg, "Flush that does nothing\n", 0);
            break;

        case UserFileOpen:

            DebugTrace(0, Dbg, "Flush User File Open\n", 0);

            (VOID)FatAcquireExclusiveFcb( IrpContext, Fcb );

            FcbAcquired = TRUE;

            FatVerifyFcb( IrpContext, Fcb );

            //
            //  If the file is cached then flush its cache
            //

            Status = FatFlushFile( IrpContext, Fcb, Flush );

            //
            //  Also update and flush the file's dirent in the parent directory if the
            //  file flush worked.
            //

            if (NT_SUCCESS( Status )) {

                //
                //  Insure that we get the filesize to disk correctly.  This is
                //  benign if it was already good.
                //
                //  (why do we need to do this?)
                //

                SetFlag(FileObject->Flags, FO_FILE_SIZE_CHANGED);

                FatUpdateDirentFromFcb( IrpContext, FileObject, Fcb, Ccb );
                
                //
                //  Flush the volume file to get any allocation information
                //  updates to disk.
                //

                if (FlagOn(Fcb->FcbState, FCB_STATE_FLUSH_FAT)) {

                    Status = FatFlushFat( IrpContext, Vcb );

                    ClearFlag(Fcb->FcbState, FCB_STATE_FLUSH_FAT);
                }

                //
                //  Set the write through bit so that these modifications
                //  will be completed with the request.
                //

                SetFlag(IrpContext->Flags, IRP_CONTEXT_FLAG_WRITE_THROUGH);
            }

            break;

        case UserDirectoryOpen:

            //
            //  If the user had opened the root directory then we'll
            //  oblige by flushing the volume.
            //

            if (NodeType(Fcb) != FAT_NTC_ROOT_DCB) {

                DebugTrace(0, Dbg, "Flush a directory does nothing\n", 0);
                break;
            }

        case UserVolumeOpen:

            DebugTrace(0, Dbg, "Flush User Volume Open, or root dcb\n", 0);

            //
            //  Acquire exclusive access to the Vcb.
            //

            {
                BOOLEAN Finished;
                Finished = FatAcquireExclusiveVcb( IrpContext, Vcb );
                ASSERT( Finished );
            }

            VcbAcquired = TRUE;

            //
            //  Mark the volume clean and then flush the volume file,
            //  and then all directories
            //

            Status = FatFlushVolume( IrpContext, Vcb, Flush );

            //
            //  If the volume was dirty, do the processing that the delayed
            //  callback would have done.
            //

            if (FlagOn(Vcb->VcbState, VCB_STATE_FLAG_VOLUME_DIRTY)) {

                //
                //  Cancel any pending clean volumes.
                //

                (VOID)KeCancelTimer( &Vcb->CleanVolumeTimer );
                (VOID)KeRemoveQueueDpc( &Vcb->CleanVolumeDpc );

                //
                //  The volume is now clean, note it.
                //

                if (!FlagOn(Vcb->VcbState, VCB_STATE_FLAG_MOUNTED_DIRTY)) {

                    FatMarkVolume( IrpContext, Vcb, VolumeClean );
                    ClearFlag( Vcb->VcbState, VCB_STATE_FLAG_VOLUME_DIRTY );
                }

                //
                //  Unlock the volume if it is removable.
                //

                if (FlagOn(Vcb->VcbState, VCB_STATE_FLAG_REMOVABLE_MEDIA) &&
                    !FlagOn(Vcb->VcbState, VCB_STATE_FLAG_BOOT_OR_PAGING_FILE)) {

                    FatToggleMediaEjectDisable( IrpContext, Vcb, FALSE );
                }
            }

            break;

        default:

            FatBugCheck( TypeOfOpen, 0, 0 );
        }

        FatUnpinBcb( IrpContext, DirentBcb );

        FatUnpinRepinnedBcbs( IrpContext );

    } finally {

        DebugUnwind( FatCommonFlushBuffers );

        FatUnpinBcb( IrpContext, DirentBcb );

        if (VcbAcquired) { FatReleaseVcb( IrpContext, Vcb ); }

        if (FcbAcquired) { FatReleaseFcb( IrpContext, Fcb ); }

        //
        //  If this is a normal termination then pass the request on
        //  to the target device object.
        //

        if (!AbnormalTermination()) {

            NTSTATUS DriverStatus;
            PIO_STACK_LOCATION NextIrpSp;

            //
            //  Get the next stack location, and copy over the stack location
            //

            NextIrpSp = IoGetNextIrpStackLocation( Irp );

            *NextIrpSp = *IrpSp;

            //
            //  Set up the completion routine
            //

            IoSetCompletionRoutine( Irp,
                                    FatFlushCompletionRoutine,
                                    ULongToPtr( Status ),
                                    TRUE,
                                    TRUE,
                                    TRUE );

            //
            //  Send the request.
            //

            DriverStatus = IoCallDriver(Vcb->TargetDeviceObject, Irp);

            Status = (DriverStatus == STATUS_INVALID_DEVICE_REQUEST) ?
                     Status : DriverStatus;

            //
            //  Free the IrpContext and return to the caller.
            //

            FatCompleteRequest( IrpContext, FatNull, STATUS_SUCCESS );
        }

        DebugTrace(-1, Dbg, "FatCommonFlushBuffers -> %08lx\n", Status);
    }

    return Status;
}


NTSTATUS
FatFlushDirectory (
    IN PIRP_CONTEXT IrpContext,
    IN PDCB Dcb,
    IN FAT_FLUSH_TYPE FlushType
    )

/*++

Routine Description:

    This routine non-recursively flushes a dcb tree.

Arguments:

    Dcb - Supplies the Dcb being flushed

    FlushType - Specifies the kind of flushing to perform
    
Return Value:

    VOID

--*/

{
    PFCB Fcb;
    PVCB Vcb;
    PFCB NextFcb;

    PDIRENT Dirent;
    PBCB DirentBcb = NULL;

    NTSTATUS Status;
    NTSTATUS ReturnStatus = STATUS_SUCCESS;

    BOOLEAN ClearWriteThroughOnExit = FALSE;
    BOOLEAN ClearWaitOnExit = FALSE;

    PAGED_CODE();

    ASSERT( FatVcbAcquiredExclusive(IrpContext, Dcb->Vcb) );

    DebugTrace(+1, Dbg, "FatFlushDirectory, Dcb = %08lx\n", Dcb);

    //
    //  First flush all the files, then the directories, to make sure all the
    //  file sizes and times get sets correctly on disk.
    //
    //  We also have to check here if the "Ea Data. Sf" fcb really
    //  corressponds to an existing file.
    //

    if (!FlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WRITE_THROUGH)) {

        ClearWriteThroughOnExit = TRUE;
        SetFlag(IrpContext->Flags, IRP_CONTEXT_FLAG_WRITE_THROUGH);
    }

    if (!FlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT)) {

        ClearWaitOnExit = TRUE;
        SetFlag(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT);
    }

    Vcb = Dcb->Vcb;
    Fcb = Dcb;

    while (Fcb != NULL) {

        NextFcb = FatGetNextFcbTopDown(IrpContext, Fcb, Dcb);

        if ( (NodeType( Fcb ) == FAT_NTC_FCB) &&
             (Vcb->EaFcb != Fcb) &&
             !IsFileDeleted(IrpContext, Fcb)) {

            (VOID)FatAcquireExclusiveFcb( IrpContext, Fcb );

            ClearFlag( Vcb->VcbState, VCB_STATE_FLAG_DELETED_FCB );

            //
            //  Exception handler to catch and commute errors encountered
            //  doing the flush dance.  We may encounter corruption, and
            //  should continue flushing the volume as much as possible.
            //
            
            try {
                
                //
                //  Standard handler to release resources, etc.
                //
                
                try {
    
                    //
                    //  Make sure the Fcb is OK.
                    //
    
                    try {
    
                        FatVerifyFcb( IrpContext, Fcb );
    
                    } except( FsRtlIsNtstatusExpected(GetExceptionCode()) ?
                              EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH ) {
    
                        FatResetExceptionState( IrpContext );
                    }
    
                    //
                    //  If this Fcb is not good skip it.  Note that a 'continue'
                    //  here would be very expensive as we inside a try{} body.
                    //
    
                    if (Fcb->FcbCondition != FcbGood) {
    
                        goto NextFcb;
                    }
    
                    //
                    //  In case a handle was never closed and the FS and AS are more
                    //  than a cluster different, do this truncate.
                    //
    
                    if ( FlagOn(Fcb->FcbState, FCB_STATE_TRUNCATE_ON_CLOSE) ) {
    
                        FatTruncateFileAllocation( IrpContext,
                                                   Fcb,
                                                   Fcb->Header.FileSize.LowPart );
                    }
    
                    //
                    //  Also compare the file's dirent in the parent directory
                    //  with the size information in the Fcb and update
                    //  it if neccessary.  Note that we don't mark the Bcb dirty
                    //  because we will be flushing the file object presently, and
                    //  Mm knows what's really dirty.
                    //
    
                    FatGetDirentFromFcbOrDcb( IrpContext,
                                              Fcb,
                                              &Dirent,
                                              &DirentBcb );
    
                    if (Dirent->FileSize != Fcb->Header.FileSize.LowPart) {
    
                        Dirent->FileSize = Fcb->Header.FileSize.LowPart;
                    }
    
                    //
                    //  We must unpin the Bcb before the flush since we recursively tear up
                    //  the tree if Mm decides that the data section is no longer referenced
                    //  and the final close comes in for this file. If this parent has no
                    //  more children as a result, we will try to initiate teardown on it
                    //  and Cc will deadlock against the active count of this Bcb.
                    //
    
                    FatUnpinBcb( IrpContext, DirentBcb );
                    
                    //
                    //  Now flush the file.  Note that this may make the Fcb
                    //  go away if Mm dereferences its file object.
                    //
    
                    Status = FatFlushFile( IrpContext, Fcb, FlushType );
    
                    if (!NT_SUCCESS(Status)) {
    
                        ReturnStatus = Status;
                    }
    
                NextFcb: NOTHING;
                } finally {
    
                    FatUnpinBcb( IrpContext, DirentBcb );
    
                    //
                    //  Since we have the Vcb exclusive we know that if any closes
                    //  come in it is because the CcPurgeCacheSection caused the
                    //  Fcb to go away.
                    //
    
                    if ( !FlagOn(Vcb->VcbState, VCB_STATE_FLAG_DELETED_FCB) ) {
    
                        FatReleaseFcb( (IRPCONTEXT), Fcb );
                    }
                }
             
            } except( (ReturnStatus = FsRtlIsNtstatusExpected(GetExceptionCode())) ?
                       EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH ) {

                   FatResetExceptionState( IrpContext );
             }
        }

        Fcb = NextFcb;
    }

    //
    //  OK, now flush the directories.
    //

    Fcb = Dcb;

    while (Fcb != NULL) {

        NextFcb = FatGetNextFcbTopDown(IrpContext, Fcb, Dcb);

        if ( (NodeType( Fcb ) != FAT_NTC_FCB) &&
             !IsFileDeleted(IrpContext, Fcb) ) {

            //
            //  Make sure the Fcb is OK.
            //

            try {

                FatVerifyFcb( IrpContext, Fcb );

            } except( FsRtlIsNtstatusExpected(GetExceptionCode()) ?
                      EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH ) {

                FatResetExceptionState( IrpContext );
            }

            if (Fcb->FcbCondition == FcbGood) {

                Status = FatFlushFile( IrpContext, Fcb, FlushType );

                if (!NT_SUCCESS(Status)) {

                    ReturnStatus = Status;
                }
            }
        }

        Fcb = NextFcb;
    }

    try {

        FatUnpinRepinnedBcbs( IrpContext );

    } except(FatExceptionFilter( IrpContext, GetExceptionInformation() )) {

        ReturnStatus = IrpContext->ExceptionStatus;
    }

    if (ClearWriteThroughOnExit) {

        ClearFlag(IrpContext->Flags, IRP_CONTEXT_FLAG_WRITE_THROUGH);
    }
    if (ClearWaitOnExit) {

        ClearFlag(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT);
    }

    DebugTrace(-1, Dbg, "FatFlushDirectory -> 0x%08lx\n", ReturnStatus);

    return ReturnStatus;
}


NTSTATUS
FatFlushFat (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    The function carefully flushes the entire FAT for a volume.  It is
    nessecary to dance around a bit because of complicated synchronization
    reasons.

Arguments:

    Vcb - Supplies the Vcb whose FAT is being flushed
    
Return Value:

    VOID

--*/

{
    PBCB Bcb;
    PVOID DontCare;
    IO_STATUS_BLOCK Iosb;
    LARGE_INTEGER Offset;

    NTSTATUS ReturnStatus = STATUS_SUCCESS;

    PAGED_CODE();

    //
    //  If this volume is write protected, no need to flush.
    //

    if (FlagOn(Vcb->VcbState, VCB_STATE_FLAG_WRITE_PROTECTED)) {

        return STATUS_SUCCESS;
    }

    //
    //  Make sure the Vcb is OK.
    //

    try {

        FatVerifyVcb( IrpContext, Vcb );

    } except( FsRtlIsNtstatusExpected(GetExceptionCode()) ?
              EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH ) {

        FatResetExceptionState( IrpContext );
    }

    if (Vcb->VcbCondition != VcbGood) {

        return STATUS_FILE_INVALID;
    }

    //
    //  The only way we have to correctly synchronize things is to
    //  repin stuff, and then unpin repin it.
    //
    //  With NT 5.0, we can use some new cache manager support to make
    //  this a lot more efficient (important for FAT32).  Since we're
    //  only worried about ranges that are dirty - and since we're a
    //  modified-no-write stream - we can assume that if there is no
    //  BCB, there is no work to do in the range. I.e., the lazy writer
    //  beat us to it.
    //
    //  This is much better than reading the entire FAT in and trying
    //  to punch it out (see the test in the write path to blow
    //  off writes that don't correspond to dirty ranges of the FAT).
    //  For FAT32, this would be a *lot* of reading.
    //

    if (Vcb->AllocationSupport.FatIndexBitSize != 12) {

        //
        //  Walk through the Fat, one page at a time.
        //

        ULONG NumberOfPages;
        ULONG Page;

        NumberOfPages = ( FatReservedBytes(&Vcb->Bpb) +
                          FatBytesPerFat(&Vcb->Bpb) +
                          (PAGE_SIZE - 1) ) / PAGE_SIZE;


        for ( Page = 0, Offset.QuadPart = 0;
              Page < NumberOfPages;
              Page++, Offset.LowPart += PAGE_SIZE ) {

            try {

                if (CcPinRead( Vcb->VirtualVolumeFile,
                               &Offset,
                               PAGE_SIZE,
                               PIN_WAIT | PIN_IF_BCB,
                               &Bcb,
                               &DontCare )) {
                    
                    CcSetDirtyPinnedData( Bcb, NULL );
                    CcRepinBcb( Bcb );
                    CcUnpinData( Bcb );
                    CcUnpinRepinnedBcb( Bcb, TRUE, &Iosb );

                    if (!NT_SUCCESS(Iosb.Status)) {

                        ReturnStatus = Iosb.Status;
                    }
                }

            } except(FatExceptionFilter(IrpContext, GetExceptionInformation())) {

                ReturnStatus = IrpContext->ExceptionStatus;
                continue;
            }
        }

    } else {

        //
        //  We read in the entire fat in the 12 bit case.
        //

        Offset.QuadPart = FatReservedBytes( &Vcb->Bpb );

        try {

            if (CcPinRead( Vcb->VirtualVolumeFile,
                           &Offset,
                           FatBytesPerFat( &Vcb->Bpb ),
                           PIN_WAIT | PIN_IF_BCB,
                           &Bcb,
                           &DontCare )) {
                
                CcSetDirtyPinnedData( Bcb, NULL );
                CcRepinBcb( Bcb );
                CcUnpinData( Bcb );
                CcUnpinRepinnedBcb( Bcb, TRUE, &Iosb );

                if (!NT_SUCCESS(Iosb.Status)) {

                    ReturnStatus = Iosb.Status;
                }
            }

        } except(FatExceptionFilter(IrpContext, GetExceptionInformation())) {

            ReturnStatus = IrpContext->ExceptionStatus;
        }
    }

    return ReturnStatus;
}


NTSTATUS
FatFlushVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN FAT_FLUSH_TYPE FlushType
    )

/*++

Routine Description:

    The following routine is used to flush a volume to disk, including the
    volume file, and ea file.

Arguments:

    Vcb - Supplies the volume being flushed

    FlushType - Specifies the kind of flushing to perform
    
Return Value:

    NTSTATUS - The Status from the flush.

--*/

{
    NTSTATUS Status;
    NTSTATUS ReturnStatus = STATUS_SUCCESS;

    PAGED_CODE();

    //
    //  If this volume is write protected, no need to flush.
    //

    if (FlagOn(Vcb->VcbState, VCB_STATE_FLAG_WRITE_PROTECTED)) {

        return STATUS_SUCCESS;
    }

    //
    //  Flush all the files and directories.
    //

    Status = FatFlushDirectory( IrpContext, Vcb->RootDcb, FlushType );

    if (!NT_SUCCESS(Status)) {

        ReturnStatus = Status;
    }

    //
    //  Now Flush the FAT
    //

    Status = FatFlushFat( IrpContext, Vcb );

    if (!NT_SUCCESS(Status)) {

        ReturnStatus = Status;
    }

    //
    //  Unlock the volume if it is removable.
    //

    if (FlagOn(Vcb->VcbState, VCB_STATE_FLAG_REMOVABLE_MEDIA) &&
        !FlagOn(Vcb->VcbState, VCB_STATE_FLAG_BOOT_OR_PAGING_FILE)) {

        FatToggleMediaEjectDisable( IrpContext, Vcb, FALSE );
    }

    return ReturnStatus;
}


NTSTATUS
FatFlushFile (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN FAT_FLUSH_TYPE FlushType
    )

/*++

Routine Description:

    This routine simply flushes the data section on a file.

Arguments:

    Fcb - Supplies the file being flushed

    FlushType - Specifies the kind of flushing to perform
    
Return Value:

    NTSTATUS - The Status from the flush.

--*/

{
    IO_STATUS_BLOCK Iosb;
    PVCB Vcb = Fcb->Vcb;

    PAGED_CODE();

    CcFlushCache( &Fcb->NonPaged->SectionObjectPointers, NULL, 0, &Iosb );

    if ( !FlagOn( Vcb->VcbState, VCB_STATE_FLAG_DELETED_FCB )) {
    
        //
        //  Grab and release PagingIo to serialize ourselves with the lazy writer.
        //  This will work to ensure that all IO has completed on the cached
        //  data.
        //
        //  If we are to invalidate the file, now is the right time to do it.  Do
        //  it non-recursively so we don't thump children before their time.
        //
                
        ExAcquireResourceExclusiveLite( Fcb->Header.PagingIoResource, TRUE);
    
        if (FlushType == FlushAndInvalidate) {
    
            FatMarkFcbCondition( IrpContext, Fcb, FcbBad, FALSE );
        }
    
        ExReleaseResourceLite( Fcb->Header.PagingIoResource );
    }

    return Iosb.Status;
}


NTSTATUS
FatHijackIrpAndFlushDevice (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PDEVICE_OBJECT TargetDeviceObject
    )

/*++

Routine Description:

    This routine is called when we need to send a flush to a device but
    we don't have a flush Irp.  What this routine does is make a copy
    of its current Irp stack location, but changes the Irp Major code
    to a IRP_MJ_FLUSH_BUFFERS amd then send it down, but cut it off at
    the knees in the completion routine, fix it up and return to the
    user as if nothing had happened.

Arguments:

    Irp - The Irp to hijack

    TargetDeviceObject - The device to send the request to.

Return Value:

    NTSTATUS - The Status from the flush in case anybody cares.

--*/

{
    KEVENT Event;
    NTSTATUS Status;
    PIO_STACK_LOCATION NextIrpSp;

    PAGED_CODE();

    //
    //  Get the next stack location, and copy over the stack location
    //

    NextIrpSp = IoGetNextIrpStackLocation( Irp );

    *NextIrpSp = *IoGetCurrentIrpStackLocation( Irp );

    NextIrpSp->MajorFunction = IRP_MJ_FLUSH_BUFFERS;
    NextIrpSp->MinorFunction = 0;

    //
    //  Set up the completion routine
    //

    KeInitializeEvent( &Event, NotificationEvent, FALSE );

    IoSetCompletionRoutine( Irp,
                            FatHijackCompletionRoutine,
                            &Event,
                            TRUE,
                            TRUE,
                            TRUE );

    //
    //  Send the request.
    //

    Status = IoCallDriver( TargetDeviceObject, Irp );

    if (Status == STATUS_PENDING) {

        KeWaitForSingleObject( &Event, Executive, KernelMode, FALSE, NULL );

        Status = Irp->IoStatus.Status;
    }

    //
    //  If the driver doesn't support flushes, return SUCCESS.
    //

    if (Status == STATUS_INVALID_DEVICE_REQUEST) {
        Status = STATUS_SUCCESS;
    }

    Irp->IoStatus.Status = 0;
    Irp->IoStatus.Information = 0;

    return Status;
}


VOID
FatFlushFatEntries (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN ULONG Cluster,
    IN ULONG Count
)

/*++

Routine Description:

    This macro flushes the FAT page(s) containing the passed in run.

Arguments:

    Vcb - Supplies the volume being flushed

    Cluster - The starting cluster

    Count -  The number of FAT entries in the run

Return Value:

    VOID

--*/

{
    ULONG ByteCount;
    LARGE_INTEGER FileOffset;

    IO_STATUS_BLOCK Iosb;

    PAGED_CODE();

    FileOffset.HighPart = 0;
    FileOffset.LowPart = FatReservedBytes( &Vcb->Bpb );

    if (Vcb->AllocationSupport.FatIndexBitSize == 12) {

        FileOffset.LowPart += Cluster * 3 / 2;
        ByteCount = (Count * 3 / 2) + 1;

    } else if (Vcb->AllocationSupport.FatIndexBitSize == 32) {

        FileOffset.LowPart += Cluster * sizeof(ULONG);
        ByteCount = Count * sizeof(ULONG);

    } else {

        FileOffset.LowPart += Cluster * sizeof( USHORT );
        ByteCount = Count * sizeof( USHORT );

    }

    CcFlushCache( &Vcb->SectionObjectPointers,
                  &FileOffset,
                  ByteCount,
                  &Iosb );

    if (NT_SUCCESS(Iosb.Status)) {
        Iosb.Status = FatHijackIrpAndFlushDevice( IrpContext,
                                                  IrpContext->OriginatingIrp,
                                                  Vcb->TargetDeviceObject );
    }

    if (!NT_SUCCESS(Iosb.Status)) {
        FatNormalizeAndRaiseStatus(IrpContext, Iosb.Status);
    }
}


VOID
FatFlushDirentForFile (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
)

/*++

Routine Description:

    This macro flushes the page containing a file's DIRENT in its parent.

Arguments:

    Fcb - Supplies the file whose DIRENT is being flushed

Return Value:

    VOID

--*/

{
    LARGE_INTEGER FileOffset;
    IO_STATUS_BLOCK Iosb;

    PAGED_CODE();

    FileOffset.QuadPart = Fcb->DirentOffsetWithinDirectory;

    CcFlushCache( &Fcb->ParentDcb->NonPaged->SectionObjectPointers,
                  &FileOffset,
                  sizeof( DIRENT ),
                  &Iosb );

    if (NT_SUCCESS(Iosb.Status)) {
        Iosb.Status = FatHijackIrpAndFlushDevice( IrpContext,
                                                  IrpContext->OriginatingIrp,
                                                  Fcb->Vcb->TargetDeviceObject );
    }

    if (!NT_SUCCESS(Iosb.Status)) {
        FatNormalizeAndRaiseStatus(IrpContext, Iosb.Status);
    }
}


//
//  Local support routine
//

NTSTATUS
FatFlushCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    )

{
    NTSTATUS Status = (NTSTATUS) (ULONG_PTR) Contxt;
    
    //
    //  Add the hack-o-ramma to fix formats.
    //

    if ( Irp->PendingReturned ) {

        IoMarkIrpPending( Irp );
    }

    //
    //  If the Irp got STATUS_INVALID_DEVICE_REQUEST, normalize it
    //  to STATUS_SUCCESS.
    //

    if (Irp->IoStatus.Status == STATUS_INVALID_DEVICE_REQUEST) {

        Irp->IoStatus.Status = Status;
    }

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Contxt );

    return STATUS_SUCCESS;
}

//
//  Local support routine
//

NTSTATUS
FatHijackCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    )

{
    //
    //  Set the event so that our call will wake up.
    //

    KeSetEvent( (PKEVENT)Contxt, 0, FALSE );

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Irp );

    return STATUS_MORE_PROCESSING_REQUIRED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fastfat\lfn.h ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    Lfn.h

Abstract:

    This module defines the on-disk structure of long file names on FAT.

// @@BEGIN_DDKSPLIT

Author:

    David Goebel    [davidgoe]  16-Dec-1993

Revision History:

// @@END_DDKSPLIT

--*/

#ifndef _LFN_
#define _LFN_

//
//  This strucure defines the on disk format on long file name dirents.
//

typedef struct _PACKED_LFN_DIRENT {
    UCHAR     Ordinal;    //  offset =  0
    UCHAR     Name1[10];  //  offset =  1 (Really 5 chars, but not WCHAR aligned)
    UCHAR     Attributes; //  offset = 11
    UCHAR     Type;       //  offset = 12
    UCHAR     Checksum;   //  offset = 13
    WCHAR     Name2[6];   //  offset = 14
    USHORT    MustBeZero; //  offset = 26
    WCHAR     Name3[2];   //  offset = 28
} PACKED_LFN_DIRENT;      //  sizeof = 32
typedef PACKED_LFN_DIRENT *PPACKED_LFN_DIRENT;

#define FAT_LAST_LONG_ENTRY             0x40 // Ordinal field
#define FAT_LONG_NAME_COMP              0x0  // Type field

//
//  A packed lfn dirent is already quadword aligned so simply declare a
//  lfn dirent as a packed lfn dirent.
//

typedef PACKED_LFN_DIRENT LFN_DIRENT;
typedef LFN_DIRENT *PLFN_DIRENT;

//
//  This is the largest size buffer we would ever need to read an Lfn
//

#define MAX_LFN_CHARACTERS              260
#define MAX_LFN_DIRENTS                 20

#define FAT_LFN_DIRENTS_NEEDED(NAME) (((NAME)->Length/sizeof(WCHAR) + 12)/13)

#endif // _LFN_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fastfat\nodetype.h ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    NodeType.h

Abstract:

    This module defines all of the node type codes used in this development
    shell.  Every major data structure in the file system is assigned a node
    type code that is.  This code is the first CSHORT in the structure and is
    followed by a CSHORT containing the size, in bytes, of the structure.

// @@BEGIN_DDKSPLIT

Author:

    Gary Kimura     [GaryKi]    23-May-1989

Revision History:

// @@END_DDKSPLIT

--*/

#ifndef _FATNODETYPE_
#define _FATNODETYPE_

typedef CSHORT NODE_TYPE_CODE;
typedef NODE_TYPE_CODE *PNODE_TYPE_CODE;

#define NTC_UNDEFINED                    ((NODE_TYPE_CODE)0x0000)

#define FAT_NTC_DATA_HEADER              ((NODE_TYPE_CODE)0x0500)
#define FAT_NTC_VCB                      ((NODE_TYPE_CODE)0x0501)
#define FAT_NTC_FCB                      ((NODE_TYPE_CODE)0x0502)
#define FAT_NTC_DCB                      ((NODE_TYPE_CODE)0x0503)
#define FAT_NTC_ROOT_DCB                 ((NODE_TYPE_CODE)0x0504)
#define FAT_NTC_CCB                      ((NODE_TYPE_CODE)0x0507)
#define FAT_NTC_IRP_CONTEXT              ((NODE_TYPE_CODE)0x0508)

typedef CSHORT NODE_BYTE_SIZE;

#ifndef NodeType

//
//  So all records start with
//
//  typedef struct _RECORD_NAME {
//      NODE_TYPE_CODE NodeTypeCode;
//      NODE_BYTE_SIZE NodeByteSize;
//          :
//  } RECORD_NAME;
//  typedef RECORD_NAME *PRECORD_NAME;
//

#define NodeType(Ptr) (*((PNODE_TYPE_CODE)(Ptr)))
#endif


//
//  The following definitions are used to generate meaningful blue bugcheck
//  screens.  On a bugcheck the file system can output 4 ulongs of useful
//  information.  The first ulong will have encoded in it a source file id
//  (in the high word) and the line number of the bugcheck (in the low word).
//  The other values can be whatever the caller of the bugcheck routine deems
//  necessary.
//
//  Each individual file that calls bugcheck needs to have defined at the
//  start of the file a constant called BugCheckFileId with one of the
//  FAT_BUG_CHECK_ values defined below and then use FatBugCheck to bugcheck
//  the system.
//


#define FAT_BUG_CHECK_ACCHKSUP           (0x00010000)
#define FAT_BUG_CHECK_ALLOCSUP           (0x00020000)
#define FAT_BUG_CHECK_CACHESUP           (0x00030000)
#define FAT_BUG_CHECK_CLEANUP            (0x00040000)
#define FAT_BUG_CHECK_CLOSE              (0x00050000)
#define FAT_BUG_CHECK_CREATE             (0x00060000)
#define FAT_BUG_CHECK_DEVCTRL            (0x00070000)
#define FAT_BUG_CHECK_DEVIOSUP           (0x00080000)
#define FAT_BUG_CHECK_DIRCTRL            (0x00090000)
#define FAT_BUG_CHECK_DIRSUP             (0x000a0000)
#define FAT_BUG_CHECK_DUMPSUP            (0x000b0000)
#define FAT_BUG_CHECK_EA                 (0x000c0000)
#define FAT_BUG_CHECK_EASUP              (0x000d0000)
#define FAT_BUG_CHECK_FATDATA            (0x000e0000)
#define FAT_BUG_CHECK_FATINIT            (0x000f0000)
#define FAT_BUG_CHECK_FILEINFO           (0x00100000)
#define FAT_BUG_CHECK_FILOBSUP           (0x00110000)
#define FAT_BUG_CHECK_FLUSH              (0x00120000)
#define FAT_BUG_CHECK_FSCTRL             (0x00130000)
#define FAT_BUG_CHECK_FSPDISP            (0x00140000)
#define FAT_BUG_CHECK_LOCKCTRL           (0x00150000)
#define FAT_BUG_CHECK_NAMESUP            (0x00160000)
#define FAT_BUG_CHECK_PNP                (0x00170000)
#define FAT_BUG_CHECK_READ               (0x00180000)
#define FAT_BUG_CHECK_RESRCSUP           (0x00190000)
#define FAT_BUG_CHECK_SHUTDOWN           (0x001a0000)
#define FAT_BUG_CHECK_SPLAYSUP           (0x001b0000)
#define FAT_BUG_CHECK_STRUCSUP           (0x001c0000)
#define FAT_BUG_CHECK_TIMESUP            (0x001d0000)
#define FAT_BUG_CHECK_VERFYSUP           (0x001e0000)
#define FAT_BUG_CHECK_VOLINFO            (0x001f0000)
#define FAT_BUG_CHECK_WORKQUE            (0x00200000)
#define FAT_BUG_CHECK_WRITE              (0x00210000)

#define FatBugCheck(A,B,C) { KeBugCheckEx(FAT_FILE_SYSTEM, BugCheckFileId | __LINE__, A, B, C ); }


//
//  In this module we'll also define some globally known constants
//

#define UCHAR_NUL                        0x00
#define UCHAR_SOH                        0x01
#define UCHAR_STX                        0x02
#define UCHAR_ETX                        0x03
#define UCHAR_EOT                        0x04
#define UCHAR_ENQ                        0x05
#define UCHAR_ACK                        0x06
#define UCHAR_BEL                        0x07
#define UCHAR_BS                         0x08
#define UCHAR_HT                         0x09
#define UCHAR_LF                         0x0a
#define UCHAR_VT                         0x0b
#define UCHAR_FF                         0x0c
#define UCHAR_CR                         0x0d
#define UCHAR_SO                         0x0e
#define UCHAR_SI                         0x0f
#define UCHAR_DLE                        0x10
#define UCHAR_DC1                        0x11
#define UCHAR_DC2                        0x12
#define UCHAR_DC3                        0x13
#define UCHAR_DC4                        0x14
#define UCHAR_NAK                        0x15
#define UCHAR_SYN                        0x16
#define UCHAR_ETB                        0x17
#define UCHAR_CAN                        0x18
#define UCHAR_EM                         0x19
#define UCHAR_SUB                        0x1a
#define UCHAR_ESC                        0x1b
#define UCHAR_FS                         0x1c
#define UCHAR_GS                         0x1d
#define UCHAR_RS                         0x1e
#define UCHAR_US                         0x1f
#define UCHAR_SP                         0x20

#ifndef BUILDING_FSKDEXT

//
//  These are the tags we use to uniquely identify pool allocations.
//

#define TAG_CCB                         'CtaF'
#define TAG_FCB                         'FtaF'
#define TAG_FCB_NONPAGED                'NtaF'
#define TAG_ERESOURCE                   'EtaF'
#define TAG_IRP_CONTEXT                 'ItaF'

#define TAG_BCB                         'btaF'
#define TAG_DIRENT                      'DtaF'
#define TAG_DIRENT_BITMAP               'TtaF'
#define TAG_EA_DATA                     'dtaF'
#define TAG_EA_SET_HEADER               'etaF'
#define TAG_EVENT                       'vtaF'
#define TAG_FAT_BITMAP                  'BtaF'
#define TAG_FAT_CLOSE_CONTEXT           'xtaF'
#define TAG_FAT_IO_CONTEXT              'XtaF'
#define TAG_FAT_WINDOW                  'WtaF'
#define TAG_FILENAME_BUFFER             'ntaF'
#define TAG_IO_RUNS                     'itaF'
#define TAG_REPINNED_BCB                'RtaF'
#define TAG_STASHED_BPB                 'StaF'
#define TAG_VCB_STATS                   'VtaF'
#define TAG_DEFERRED_FLUSH_CONTEXT      'ftaF'

#define TAG_VPB                         'vtaF'

#define TAG_VERIFY_BOOTSECTOR           'staF'
#define TAG_VERIFY_ROOTDIR              'rtaF'

#define TAG_OUTPUT_MAPPINGPAIRS         'PtaF'

#define TAG_ENTRY_LOOKUP_BUFFER         'LtaF'

#define TAG_IO_BUFFER                   'OtaF'
#define TAG_IO_USER_BUFFER              'QtaF'

#define TAG_DYNAMIC_NAME_BUFFER         'ctaF'

#endif

#endif // _NODETYPE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fastfat\lockctrl.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    LockCtrl.c

Abstract:

    This module implements the Lock Control routines for Fat called
    by the dispatch driver.

// @@BEGIN_DDKSPLIT

Author:

    Gary Kimura     [GaryKi]    28-Dec-1989

Revision History:

// @@END_DDKSPLIT

--*/

#include "FatProcs.h"

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_LOCKCTRL)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FatCommonLockControl)
#pragma alloc_text(PAGE, FatFastLock)
#pragma alloc_text(PAGE, FatFastUnlockAll)
#pragma alloc_text(PAGE, FatFastUnlockAllByKey)
#pragma alloc_text(PAGE, FatFastUnlockSingle)
#pragma alloc_text(PAGE, FatFsdLockControl)
#endif


NTSTATUS
FatFsdLockControl (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of Lock control operations

Arguments:

    VolumeDeviceObject - Supplies the volume device object where the
        file exists

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The FSD status for the IRP

--*/

{
    NTSTATUS Status;
    PIRP_CONTEXT IrpContext = NULL;

    BOOLEAN TopLevel;

    DebugTrace(+1, Dbg, "FatFsdLockControl\n", 0);

    //
    //  Call the common Lock Control routine, with blocking allowed if
    //  synchronous
    //

    FsRtlEnterFileSystem();

    TopLevel = FatIsIrpTopLevel( Irp );

    try {

        IrpContext = FatCreateIrpContext( Irp, CanFsdWait( Irp ) );

        Status = FatCommonLockControl( IrpContext, Irp );

    } except(FatExceptionFilter( IrpContext, GetExceptionInformation() )) {

        //
        //  We had some trouble trying to perform the requested
        //  operation, so we'll abort the I/O request with
        //  the error status that we get back from the
        //  execption code
        //

        Status = FatProcessException( IrpContext, Irp, GetExceptionCode() );
    }

    if (TopLevel) { IoSetTopLevelIrp( NULL ); }

    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "FatFsdLockControl -> %08lx\n", Status);

    UNREFERENCED_PARAMETER( VolumeDeviceObject );

    return Status;
}


BOOLEAN
FatFastLock (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    BOOLEAN FailImmediately,
    BOOLEAN ExclusiveLock,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This is a call back routine for doing the fast lock call.

Arguments:

    FileObject - Supplies the file object used in this operation

    FileOffset - Supplies the file offset used in this operation

    Length - Supplies the length used in this operation

    ProcessId - Supplies the process ID used in this operation

    Key - Supplies the key used in this operation

    FailImmediately - Indicates if the request should fail immediately
        if the lock cannot be granted.

    ExclusiveLock - Indicates if this is a request for an exclusive or
        shared lock

    IoStatus - Receives the Status if this operation is successful

Return Value:

    BOOLEAN - TRUE if this operation completed and FALSE if caller
        needs to take the long route.

--*/

{
    BOOLEAN Results;
    PVCB Vcb;
    PFCB Fcb;
    PCCB Ccb;

    DebugTrace(+1, Dbg, "FatFastLock\n", 0);

    //
    //  Decode the type of file object we're being asked to process and make
    //  sure it is only a user file open.
    //

    if (FatDecodeFileObject( FileObject, &Vcb, &Fcb, &Ccb ) != UserFileOpen) {

        IoStatus->Status = STATUS_INVALID_PARAMETER;
        IoStatus->Information = 0;

        DebugTrace(-1, Dbg, "FatFastLock -> TRUE (STATUS_INVALID_PARAMETER)\n", 0);
        return TRUE;
    }

    //
    //  Acquire exclusive access to the Fcb this operation can always wait
    //

    FsRtlEnterFileSystem();

    try {

        //
        //  We check whether we can proceed
        //  based on the state of the file oplocks.
        //

        if (!FsRtlOplockIsFastIoPossible( &(Fcb)->Specific.Fcb.Oplock )) {

            try_return( Results = FALSE );
        }

        //
        //  Now call the FsRtl routine to do the actual processing of the
        //  Lock request
        //

        if (Results = FsRtlFastLock( &Fcb->Specific.Fcb.FileLock,
                                     FileObject,
                                     FileOffset,
                                     Length,
                                     ProcessId,
                                     Key,
                                     FailImmediately,
                                     ExclusiveLock,
                                     IoStatus,
                                     NULL,
                                     FALSE )) {

            //
            //  Set the flag indicating if Fast I/O is possible
            //

            Fcb->Header.IsFastIoPossible = FatIsFastIoPossible( Fcb );
        }

    try_exit:  NOTHING;
    } finally {

        DebugUnwind( FatFastLock );

        //
        //  Release the Fcb, and return to our caller
        //

        FsRtlExitFileSystem();

        DebugTrace(-1, Dbg, "FatFastLock -> %08lx\n", Results);
    }

    return Results;
}


BOOLEAN
FatFastUnlockSingle (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This is a call back routine for doing the fast unlock single call.

Arguments:

    FileObject - Supplies the file object used in this operation

    FileOffset - Supplies the file offset used in this operation

    Length - Supplies the length used in this operation

    ProcessId - Supplies the process ID used in this operation

    Key - Supplies the key used in this operation

    Status - Receives the Status if this operation is successful

Return Value:

    BOOLEAN - TRUE if this operation completed and FALSE if caller
        needs to take the long route.

--*/

{
    BOOLEAN Results;
    PVCB Vcb;
    PFCB Fcb;
    PCCB Ccb;

    DebugTrace(+1, Dbg, "FatFastUnlockSingle\n", 0);

    IoStatus->Information = 0;

    //
    //  Decode the type of file object we're being asked to process and make sure
    //  it is only a user file open
    //

    if (FatDecodeFileObject( FileObject, &Vcb, &Fcb, &Ccb ) != UserFileOpen) {

        IoStatus->Status = STATUS_INVALID_PARAMETER;

        DebugTrace(-1, Dbg, "FatFastUnlockSingle -> TRUE (STATUS_INVALID_PARAMETER)\n", 0);
        return TRUE;
    }

    //
    //  Acquire exclusive access to the Fcb this operation can always wait
    //

    FsRtlEnterFileSystem();

    try {

        //
        //  We check whether we can proceed based on the state of the file oplocks.
        //

        if (!FsRtlOplockIsFastIoPossible( &(Fcb)->Specific.Fcb.Oplock )) {

            try_return( Results = FALSE );
        }

        //
        //  Now call the FsRtl routine to do the actual processing of the
        //  Lock request.  The call will always succeed.
        //

        Results = TRUE;
        IoStatus->Status = FsRtlFastUnlockSingle( &Fcb->Specific.Fcb.FileLock,
                                                  FileObject,
                                                  FileOffset,
                                                  Length,
                                                  ProcessId,
                                                  Key,
                                                  NULL,
                                                  FALSE );

        //
        //  Set the flag indicating if Fast I/O is possible
        //

        Fcb->Header.IsFastIoPossible = FatIsFastIoPossible( Fcb );

    try_exit:  NOTHING;
    } finally {

        DebugUnwind( FatFastUnlockSingle );

        //
        //  Release the Fcb, and return to our caller
        //

        FsRtlExitFileSystem();

        DebugTrace(-1, Dbg, "FatFastUnlockSingle -> %08lx\n", Results);
    }

    return Results;
}


BOOLEAN
FatFastUnlockAll (
    IN PFILE_OBJECT FileObject,
    PEPROCESS ProcessId,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This is a call back routine for doing the fast unlock all call.

Arguments:

    FileObject - Supplies the file object used in this operation

    ProcessId - Supplies the process ID used in this operation

    Status - Receives the Status if this operation is successful

Return Value:

    BOOLEAN - TRUE if this operation completed and FALSE if caller
        needs to take the long route.

--*/

{
    BOOLEAN Results;
    PVCB Vcb;
    PFCB Fcb;
    PCCB Ccb;

    DebugTrace(+1, Dbg, "FatFastUnlockAll\n", 0);

    IoStatus->Information = 0;

    //
    //  Decode the type of file object we're being asked to process and make sure
    //  it is only a user file open.
    //

    if (FatDecodeFileObject( FileObject, &Vcb, &Fcb, &Ccb ) != UserFileOpen) {

        IoStatus->Status = STATUS_INVALID_PARAMETER;

        DebugTrace(-1, Dbg, "FatFastUnlockAll -> TRUE (STATUS_INVALID_PARAMETER)\n", 0);
        return TRUE;
    }

    //
    //  Acquire exclusive access to the Fcb this operation can always wait
    //

    FsRtlEnterFileSystem();

    (VOID) ExAcquireResourceSharedLite( Fcb->Header.Resource, TRUE );

    try {

        //
        //  We check whether we can proceed based on the state of the file oplocks.
        //

        if (!FsRtlOplockIsFastIoPossible( &(Fcb)->Specific.Fcb.Oplock )) {

            try_return( Results = FALSE );
        }

        //
        //  Now call the FsRtl routine to do the actual processing of the
        //  Lock request.  The call will always succeed.
        //

        Results = TRUE;
        IoStatus->Status = FsRtlFastUnlockAll( &Fcb->Specific.Fcb.FileLock,
                                               FileObject,
                                               ProcessId,
                                               NULL );

        //
        //  Set the flag indicating if Fast I/O is possible
        //

        Fcb->Header.IsFastIoPossible = FatIsFastIoPossible( Fcb );

    try_exit:  NOTHING;
    } finally {

        DebugUnwind( FatFastUnlockAll );

        //
        //  Release the Fcb, and return to our caller
        //

        ExReleaseResourceLite( (Fcb)->Header.Resource );

        FsRtlExitFileSystem();

        DebugTrace(-1, Dbg, "FatFastUnlockAll -> %08lx\n", Results);
    }

    return Results;
}


BOOLEAN
FatFastUnlockAllByKey (
    IN PFILE_OBJECT FileObject,
    PVOID ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This is a call back routine for doing the fast unlock all by key call.

Arguments:

    FileObject - Supplies the file object used in this operation

    ProcessId - Supplies the process ID used in this operation

    Key - Supplies the key used in this operation

    Status - Receives the Status if this operation is successful

Return Value:

    BOOLEAN - TRUE if this operation completed and FALSE if caller
        needs to take the long route.

--*/

{
    BOOLEAN Results;
    PVCB Vcb;
    PFCB Fcb;
    PCCB Ccb;

    DebugTrace(+1, Dbg, "FatFastUnlockAllByKey\n", 0);

    IoStatus->Information = 0;

    //
    //  Decode the type of file object we're being asked to process and make sure
    //  it is only a user file open.
    //

    if (FatDecodeFileObject( FileObject, &Vcb, &Fcb, &Ccb ) != UserFileOpen) {

        IoStatus->Status = STATUS_INVALID_PARAMETER;

        DebugTrace(-1, Dbg, "FatFastUnlockAll -> TRUE (STATUS_INVALID_PARAMETER)\n", 0);
        return TRUE;
    }

    //
    //  Acquire exclusive access to the Fcb this operation can always wait
    //

    FsRtlEnterFileSystem();

    (VOID) ExAcquireResourceSharedLite( Fcb->Header.Resource, TRUE );

    try {

        //
        //  We check whether we can proceed based on the state of the file oplocks.
        //

        if (!FsRtlOplockIsFastIoPossible( &(Fcb)->Specific.Fcb.Oplock )) {

            try_return( Results = FALSE );
        }

        //
        //  Now call the FsRtl routine to do the actual processing of the
        //  Lock request.  The call will always succeed.
        //

        Results = TRUE;
        IoStatus->Status = FsRtlFastUnlockAllByKey( &Fcb->Specific.Fcb.FileLock,
                                                    FileObject,
                                                    ProcessId,
                                                    Key,
                                                    NULL );

        //
        //  Set the flag indicating if Fast I/O is possible
        //

        Fcb->Header.IsFastIoPossible = FatIsFastIoPossible( Fcb );

    try_exit:  NOTHING;
    } finally {

        DebugUnwind( FatFastUnlockAllByKey );

        //
        //  Release the Fcb, and return to our caller
        //

        ExReleaseResourceLite( (Fcb)->Header.Resource );

        FsRtlExitFileSystem();

        DebugTrace(-1, Dbg, "FatFastUnlockAllByKey -> %08lx\n", Results);
    }

    return Results;
}


NTSTATUS
FatCommonLockControl (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for doing Lock control operations called
    by both the fsd and fsp threads

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;

    TYPE_OF_OPEN TypeOfOpen;

    PVCB Vcb;
    PFCB Fcb;
    PCCB Ccb;

    BOOLEAN OplockPostIrp = FALSE;

    //
    //  Get a pointer to the current Irp stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "FatCommonLockControl\n", 0);
    DebugTrace( 0, Dbg, "Irp           = %08lx\n", Irp);
    DebugTrace( 0, Dbg, "MinorFunction = %08lx\n", IrpSp->MinorFunction);

    //
    //  Decode the type of file object we're being asked to process
    //

    TypeOfOpen = FatDecodeFileObject( IrpSp->FileObject, &Vcb, &Fcb, &Ccb );

    //
    //  If the file is not a user file open then we reject the request
    //  as an invalid parameter
    //

    if (TypeOfOpen != UserFileOpen) {

        FatCompleteRequest( IrpContext, Irp, STATUS_INVALID_PARAMETER );

        DebugTrace(-1, Dbg, "FatCommonLockControl -> STATUS_INVALID_PARAMETER\n", 0);
        return STATUS_INVALID_PARAMETER;
    }

    //
    //  Acquire exclusive access to the Fcb and enqueue the Irp if we didn't
    //  get access
    //

    if (!FatAcquireSharedFcb( IrpContext, Fcb )) {

        Status = FatFsdPostRequest( IrpContext, Irp );

        DebugTrace(-1, Dbg, "FatCommonLockControl -> %08lx\n", Status);
        return Status;
    }

    try {

        //
        //  We check whether we can proceed
        //  based on the state of the file oplocks.
        //

        Status = FsRtlCheckOplock( &Fcb->Specific.Fcb.Oplock,
                                   Irp,
                                   IrpContext,
                                   FatOplockComplete,
                                   NULL );

        if (Status != STATUS_SUCCESS) {

            OplockPostIrp = TRUE;
            try_return( NOTHING );
        }

        //
        //  Now call the FsRtl routine to do the actual processing of the
        //  Lock request
        //

        Status = FsRtlProcessFileLock( &Fcb->Specific.Fcb.FileLock, Irp, NULL );

        //
        //  Set the flag indicating if Fast I/O is possible
        //

        Fcb->Header.IsFastIoPossible = FatIsFastIoPossible( Fcb );

    try_exit:  NOTHING;
    } finally {

        DebugUnwind( FatCommonLockControl );

        //
        //  Only if this is not an abnormal termination do we delete the
        //  irp context
        //

        if (!AbnormalTermination() && !OplockPostIrp) {

            FatCompleteRequest( IrpContext, FatNull, 0 );
        }

        //
        //  Release the Fcb, and return to our caller
        //

        FatReleaseFcb( IrpContext, Fcb );

        DebugTrace(-1, Dbg, "FatCommonLockControl -> %08lx\n", Status);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fastfat\namesup.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    NameSup.c

Abstract:

    This module implements the Fat Name support routines

// @@BEGIN_DDKSPLIT

Author:

    Gary Kimura [GaryKi] & Tom Miller [TomM]    20-Feb-1990

Revision History:

// @@END_DDKSPLIT

--*/

#include "FatProcs.h"

#define Dbg                              (DEBUG_TRACE_NAMESUP)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, Fat8dot3ToString)
#pragma alloc_text(PAGE, FatIsNameInExpression)
#pragma alloc_text(PAGE, FatStringTo8dot3)
#pragma alloc_text(PAGE, FatSetFullFileNameInFcb)
#pragma alloc_text(PAGE, FatGetUnicodeNameFromFcb)
#pragma alloc_text(PAGE, FatUnicodeToUpcaseOem)
#pragma alloc_text(PAGE, FatSelectNames)
#pragma alloc_text(PAGE, FatEvaluateNameCase)
#pragma alloc_text(PAGE, FatSpaceInName)
#endif


BOOLEAN
FatIsNameInExpression (
    IN PIRP_CONTEXT IrpContext,
    IN OEM_STRING Expression,
    IN OEM_STRING Name
    )

/*++

Routine Description:

    This routine compare a name and an expression and tells the caller if
    the name is equal to or not equal to the expression.  The input name
    cannot contain wildcards, while the expression may contain wildcards.

Arguments:

    Expression - Supplies the input expression to check against
                 The caller must have already upcased the Expression.

    Name - Supplies the input name to check for.  The caller must have
           already upcased the name.

Return Value:

    BOOLEAN - TRUE if Name is an element in the set of strings denoted
        by the input Expression and FALSE otherwise.

--*/

{
    //
    //  Call the appropriate FsRtl routine do to the real work
    //

    return FsRtlIsDbcsInExpression( &Expression,
                                    &Name );

    UNREFERENCED_PARAMETER( IrpContext );
}


VOID
FatStringTo8dot3 (
    IN PIRP_CONTEXT IrpContext,
    IN OEM_STRING InputString,
    OUT PFAT8DOT3 Output8dot3
    )

/*++

Routine Description:

    Convert a string into fat 8.3 format.  The string must not contain
    any wildcards.

Arguments:

    InputString - Supplies the input string to convert

    Output8dot3 - Receives the converted string, the memory must be supplied
        by the caller.

Return Value:

    None.

--*/

{
    ULONG i;
    ULONG j;

    DebugTrace(+1, Dbg, "FatStringTo8dot3\n", 0);
    DebugTrace( 0, Dbg, "InputString = %Z\n", &InputString);

    ASSERT( InputString.Length <= 12 );

    //
    //  Make the output name all blanks
    //

    RtlFillMemory( Output8dot3, 11, UCHAR_SP );

    //
    //  Copy over the first part of the file name.  Stop when we get to
    //  the end of the input string or a dot.
    //

    for (i = 0;
         (i < (ULONG)InputString.Length) && (InputString.Buffer[i] != '.');
         i += 1) {

        (*Output8dot3)[i] = InputString.Buffer[i];
    }

    //
    //  Check if we need to process an extension
    //

    if (i < (ULONG)InputString.Length) {

        //
        //  Make sure we have a dot and then skip over it.
        //

        ASSERT( (InputString.Length - i) <= 4 );
        ASSERT( InputString.Buffer[i] == '.' );

        i += 1;

        //
        //  Copy over the extension.  Stop when we get to the
        //  end of the input string.
        //

        for (j = 8; (i < (ULONG)InputString.Length); j += 1, i += 1) {

            (*Output8dot3)[j] = InputString.Buffer[i];
        }
    }

    //
    //  Before we return check if we should translate the first character
    //  from 0xe5 to 0x5.
    //

    if ((*Output8dot3)[0] == 0xe5) {

        (*Output8dot3)[0] = FAT_DIRENT_REALLY_0E5;
    }

    DebugTrace(-1, Dbg, "FatStringTo8dot3 -> (VOID)\n", 0);

    UNREFERENCED_PARAMETER( IrpContext );

    return;
}


VOID
Fat8dot3ToString (
    IN PIRP_CONTEXT IrpContext,
    IN PDIRENT Dirent,
    IN BOOLEAN RestoreCase,
    OUT POEM_STRING OutputString
    )

/*++

Routine Description:

    Convert fat 8.3 format into a string.  The 8.3 name must be well formed.

Arguments:

    Dirent - Supplies the input 8.3 name to convert

    RestoreCase - If TRUE, then the magic reserved bits are used to restore
        the original case.

    OutputString - Receives the converted name, the memory must be supplied
        by the caller.

Return Value:

    None

--*/

{
    ULONG DirentIndex, StringIndex;
    ULONG BaseLength, ExtensionLength;

    DebugTrace(+1, Dbg, "Fat8dot3ToString\n", 0);

    //
    //  First, find the length of the base component.
    //

    for (BaseLength = 8; BaseLength > 0; BaseLength -= 1) {

        if (Dirent->FileName[BaseLength - 1] != UCHAR_SP) {

            break;
        }
    }

    //
    //  Now find the length of the extension.
    //

    for (ExtensionLength = 3; ExtensionLength > 0; ExtensionLength -= 1) {

        if (Dirent->FileName[8 + ExtensionLength - 1] != UCHAR_SP) {

            break;
        }
    }

    //
    //  If there was a base part, copy it and check the case.  Don't forget
    //  if the first character needs to be changed from 0x05 to 0xe5.
    //

    if (BaseLength != 0) {

        RtlCopyMemory( OutputString->Buffer, Dirent->FileName, BaseLength );

        if (OutputString->Buffer[0] == FAT_DIRENT_REALLY_0E5) {

            OutputString->Buffer[0] = (CHAR)0xe5;
        }

        //
        //  Now if we are to restore case, look for A-Z
        //

        if (FatData.ChicagoMode &&
            RestoreCase &&
            FlagOn(Dirent->NtByte, FAT_DIRENT_NT_BYTE_8_LOWER_CASE)) {

            for (StringIndex = 0; StringIndex < BaseLength; StringIndex += 1) {

                //
                //  Depending on whether the media was built in a system that was
                //  running with "code page invariance" (see FatEvaluateNameCase),
                //  there could be double-byte OEM characters lying in wait here.
                //  Gotta skip them.
                //
                
                if (FsRtlIsLeadDbcsCharacter(OutputString->Buffer[StringIndex])) {

                    StringIndex += 1;
                    continue;
                }
                
                if ((OutputString->Buffer[StringIndex] >= 'A') &&
                    (OutputString->Buffer[StringIndex] <= 'Z')) {

                    OutputString->Buffer[StringIndex] += 'a' - 'A';
                }
            }
        }
    }

    //
    //  If there was an extension, copy that over.  Else we now know the
    //  size of the string.
    //

    if (ExtensionLength != 0) {

        PUCHAR o, d;

        //
        //  Now add the dot
        //

        OutputString->Buffer[BaseLength++] = '.';

        //
        //  Copy over the extension into the output buffer.
        //

        o = &OutputString->Buffer[BaseLength];
        d = &Dirent->FileName[8];

        switch (ExtensionLength) {
        case 3:
            *o++ = *d++;
        case 2:
            *o++ = *d++;
        case 1:
            *o++ = *d++;
        }

        //
        //  Set the output string length
        //

        OutputString->Length = (USHORT)(BaseLength + ExtensionLength);

        //
        //  Now if we are to restore case, look for A-Z
        //

        if (FatData.ChicagoMode &&
            RestoreCase &&
            FlagOn(Dirent->NtByte, FAT_DIRENT_NT_BYTE_3_LOWER_CASE)) {

            for (StringIndex = BaseLength;
                 StringIndex < OutputString->Length;
                 StringIndex++ ) {

                //
                //  Depending on whether the media was built in a system that was
                //  running with "code page invariance" (see FatEvaluateNameCase),
                //  there could be double-byte OEM characters lying in wait here.
                //  Gotta skip them.
                //
                
                if (FsRtlIsLeadDbcsCharacter(OutputString->Buffer[StringIndex])) {

                    StringIndex += 1;
                    continue;
                }
                
                if ((OutputString->Buffer[StringIndex] >= 'A') &&
                    (OutputString->Buffer[StringIndex] <= 'Z')) {

                    OutputString->Buffer[StringIndex] += 'a' - 'A';
                }
            }
        }

    } else {

        //
        //  Set the output string length
        //

        OutputString->Length = (USHORT)BaseLength;
    }

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "Fat8dot3ToString, OutputString = \"%Z\" -> VOID\n", OutputString);

    UNREFERENCED_PARAMETER( IrpContext );

    return;
}

VOID
FatGetUnicodeNameFromFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN OUT PUNICODE_STRING Lfn
    )

/*++

Routine Description:

    This routine will return the unicode name for a given Fcb.  If the
    file has an LFN, it will return this.  Otherwise it will return
    the UNICODE conversion of the Oem name, properly cased.

Arguments:

    Fcb - Supplies the Fcb to query.

    Lfn - Supplies a string that already has enough storage for the
        full unicode name.

Return Value:

    None

--*/

{
    PDIRENT Dirent;
    PBCB DirentBcb = NULL;
    ULONG DirentByteOffset;

    CCB LocalCcb;

    ASSERT((MAX_LFN_CHARACTERS * sizeof( WCHAR)) == Lfn->MaximumLength);
    
    //
    //  We'll start by locating the dirent for the name.
    //

    FatStringTo8dot3( IrpContext,
                      Fcb->ShortName.Name.Oem,
                      &LocalCcb.OemQueryTemplate.Constant );

    LocalCcb.Flags = 0;
    LocalCcb.UnicodeQueryTemplate.Length = 0;
    LocalCcb.ContainsWildCards = FALSE;

    FatLocateDirent( IrpContext,
                     Fcb->ParentDcb,
                     &LocalCcb,
                     Fcb->LfnOffsetWithinDirectory,
                     &Dirent,
                     &DirentBcb,
                     &DirentByteOffset,
                     NULL,
                     Lfn);
    try {

        //
        //  If we didn't find the Dirent, something is terribly wrong.
        //

        if ((DirentBcb == NULL) ||
            (DirentByteOffset != Fcb->DirentOffsetWithinDirectory)) {

            FatRaiseStatus( IrpContext, STATUS_FILE_INVALID );
        }

        //
        //  Check for the easy case.
        //

        if (Lfn->Length == 0) {

            NTSTATUS Status;
            OEM_STRING ShortName;
            UCHAR ShortNameBuffer[12];

            //
            //  If we thought that there was an LFN here and didn't find one,
            //  we're as dead.  This shouldn't happen in normal operation, but
            //  if someone scrambles a directory by hand ...
            //
            
            ASSERT( Fcb->LfnOffsetWithinDirectory == Fcb->DirentOffsetWithinDirectory );

            if (Fcb->LfnOffsetWithinDirectory != Fcb->DirentOffsetWithinDirectory) {

                FatRaiseStatus( IrpContext, STATUS_FILE_INVALID );
            }

            //
            //  There is no LFN, so manufacture a UNICODE name.
            //

            ShortName.Length = 0;
            ShortName.MaximumLength = 12;
            ShortName.Buffer = ShortNameBuffer;

            Fat8dot3ToString( IrpContext, Dirent, TRUE, &ShortName );

            //
            //  OK, now convert this string to UNICODE
            //

            Status = RtlOemStringToCountedUnicodeString( Lfn,
                                                         &ShortName,
                                                         FALSE );

            ASSERT( Status == STATUS_SUCCESS );
        }

    } finally {

        FatUnpinBcb( IrpContext, DirentBcb );
    }
}

VOID
FatSetFullFileNameInFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    )

/*++

Routine Description:

    If the FullFileName field in the Fcb has not yet been filled in, we
    proceed to do so.

Arguments:

    Fcb - Supplies the file.

Return Value:

    None

--*/

{
    if (Fcb->FullFileName.Buffer == NULL) {

        UNICODE_STRING Lfn;
        PFCB TmpFcb = Fcb;
        PFCB StopFcb;
        PWCHAR TmpBuffer;
        ULONG PathLength = 0;

        //
        //  We will assume we do this infrequently enough, that it's OK to
        //  to a pool allocation here.
        //

        Lfn.Length = 0;
        Lfn.MaximumLength = MAX_LFN_CHARACTERS * sizeof(WCHAR);
        Lfn.Buffer = FsRtlAllocatePoolWithTag( PagedPool,
                                               MAX_LFN_CHARACTERS * sizeof(WCHAR),
                                               TAG_FILENAME_BUFFER );

        try {

            //
            //  First determine how big the name will be.  If we find an
            //  ancestor with a FullFileName, our work is easier.
            //

            while (TmpFcb != Fcb->Vcb->RootDcb) {

                if ((TmpFcb != Fcb) && (TmpFcb->FullFileName.Buffer != NULL)) {

                    PathLength += TmpFcb->FullFileName.Length;

                    Fcb->FullFileName.Buffer = FsRtlAllocatePoolWithTag( PagedPool,
                                                                         PathLength,
                                                                         TAG_FILENAME_BUFFER );

                    RtlCopyMemory( Fcb->FullFileName.Buffer,
                                   TmpFcb->FullFileName.Buffer,
                                   TmpFcb->FullFileName.Length );

                    break;
                }

                PathLength += TmpFcb->FinalNameLength + sizeof(WCHAR);

                TmpFcb = TmpFcb->ParentDcb;
            }

            //
            //  If FullFileName.Buffer is still NULL, allocate it.
            //

            if (Fcb->FullFileName.Buffer == NULL) {

                Fcb->FullFileName.Buffer = FsRtlAllocatePoolWithTag( PagedPool,
                                                                     PathLength,
                                                                     TAG_FILENAME_BUFFER );
            }

            StopFcb = TmpFcb;

            TmpFcb = Fcb;
            TmpBuffer =  Fcb->FullFileName.Buffer + PathLength / sizeof(WCHAR);

            Fcb->FullFileName.Length =
            Fcb->FullFileName.MaximumLength = (USHORT)PathLength;

            while (TmpFcb != StopFcb) {

                FatGetUnicodeNameFromFcb( IrpContext,
                                          TmpFcb,
                                          &Lfn );

                TmpBuffer -= Lfn.Length / sizeof(WCHAR);

                RtlCopyMemory( TmpBuffer, Lfn.Buffer, Lfn.Length );

                TmpBuffer -= 1;

                *TmpBuffer = L'\\';

                TmpFcb = TmpFcb->ParentDcb;
            }

        } finally {

            if (AbnormalTermination()) {

                if (Fcb->FullFileName.Buffer) {

                    ExFreePool( Fcb->FullFileName.Buffer );
                    Fcb->FullFileName.Buffer = NULL;
                }
            }

            ExFreePool( Lfn.Buffer );
        }
    }
}

VOID
FatUnicodeToUpcaseOem (
    IN PIRP_CONTEXT IrpContext,
    IN POEM_STRING OemString,
    IN PUNICODE_STRING UnicodeString
    )

/*++

Routine Description:

    This routine is our standard routine for trying to use stack space
    if possible when calling RtlUpcaseUnicodeStringToCountedOemString().

    If an unmappable character is encountered, we set the destination
    length to 0.

Arguments:

    OemString - Specifies the destination string.  Space is already assumed to
        be allocated.  If there is not enough, then we allocate enough
        space.

    UnicodeString - Specifies the source string.

Return Value:

    None.

--*/

{
    NTSTATUS Status;

    Status = RtlUpcaseUnicodeStringToCountedOemString( OemString,
                                                       UnicodeString,
                                                       FALSE );

    if (Status == STATUS_BUFFER_OVERFLOW) {

        OemString->Buffer = NULL;
        OemString->Length = 0;
        OemString->MaximumLength = 0;

        Status = RtlUpcaseUnicodeStringToCountedOemString( OemString,
                                                           UnicodeString,
                                                           TRUE );
    }

    if (!NT_SUCCESS(Status)) {

        if (Status == STATUS_UNMAPPABLE_CHARACTER) {

            OemString->Length = 0;

        } else {

            FatNormalizeAndRaiseStatus( IrpContext, Status );
        }
    }

    return;
}


VOID
FatSelectNames (
    IN PIRP_CONTEXT IrpContext,
    IN PDCB Parent,
    IN POEM_STRING OemName,
    IN PUNICODE_STRING UnicodeName,
    IN OUT POEM_STRING ShortName,
    IN PUNICODE_STRING SuggestedShortName OPTIONAL,
    IN OUT BOOLEAN *AllLowerComponent,
    IN OUT BOOLEAN *AllLowerExtension,
    IN OUT BOOLEAN *CreateLfn
    )

/*++

Routine Description:

    This routine takes the original UNICODE string that the user specified,
    and the upcased Oem equivolent.  This routine then decides if the OemName
    is acceptable for dirent, or whether a short name has to be manufactured.

    Two values are returned to the caller.  One tells the caller if the name
    happens to be all lower case < 0x80.  In this special case we don't
    have to create an Lfn.  Also we tell the caller if it must create an LFN.

Arguments:

    OemName -  Supplies the proposed short Oem name.

    ShortName - If this OemName is OK for storeage in a dirent it is copied to
        this string, otherwise this string is filled with a name that is OK.
        If OemName and ShortName are the same string, no copy is done.

    UnicodeName - Provides the original final name.

    SuggestedShortName - a first-try short name to try before auto-generation
        is used

    AllLowerComponent - Returns whether this component was all lower case.

    AllLowerExtension - Returns wheather the extension was all lower case.

    CreateLfn - Tells the caller if we must create an LFN for the UnicodeName or
        SuggestedLongName

Return Value:

    None.

--*/

{
    BOOLEAN GenerateShortName;
    
    PAGED_CODE();

    //
    //  First see if we must generate a short name.
    //

    if ((OemName->Length == 0) ||
        !FatIsNameShortOemValid( IrpContext, *OemName, FALSE, FALSE, FALSE ) ||
        FatSpaceInName( IrpContext, UnicodeName )) {

        WCHAR ShortNameBuffer[12];
        UNICODE_STRING ShortUnicodeName;
        GENERATE_NAME_CONTEXT Context;
        BOOLEAN TrySuggestedShortName;

        PDIRENT Dirent;
        PBCB Bcb = NULL;
        ULONG ByteOffset;
        NTSTATUS Status;

        GenerateShortName = TRUE;

        TrySuggestedShortName = (SuggestedShortName != NULL);
    
        //
        //  Now generate a short name.
        //

        ShortUnicodeName.Length = 0;
        ShortUnicodeName.MaximumLength = 12 * sizeof(WCHAR);
        ShortUnicodeName.Buffer = ShortNameBuffer;

        RtlZeroMemory( &Context, sizeof( GENERATE_NAME_CONTEXT ) );

        try {
            
            while ( TRUE ) {

                FatUnpinBcb( IrpContext, Bcb );

                if (TrySuggestedShortName) {

                    //
                    //  Try our caller's candidate first. Note that this must have
                    //  been uppercased previously.
                    //

                    ShortUnicodeName.Length = SuggestedShortName->Length;
                    ShortUnicodeName.MaximumLength = SuggestedShortName->MaximumLength;
                    ShortUnicodeName.Buffer = SuggestedShortName->Buffer;

                    TrySuggestedShortName = FALSE;

                } else {

                    RtlGenerate8dot3Name( UnicodeName, TRUE, &Context, &ShortUnicodeName );
                }

                //
                //  We have a candidate, make sure it doesn't exist.
                //

                Status = RtlUnicodeStringToCountedOemString( ShortName,
                                                             &ShortUnicodeName,
                                                             FALSE );

                ASSERT( Status == STATUS_SUCCESS );

                FatLocateSimpleOemDirent( IrpContext,
                                          Parent,
                                          ShortName,
                                          &Dirent,
                                          &Bcb,
                                          &ByteOffset );

                if (Bcb == NULL) {

                    leave;

                }
            }

        } finally {
            
            FatUnpinBcb( IrpContext, Bcb );
        }

    } else {

        //
        //  Only do this copy if the two string are indeed different.
        //

        if (ShortName != OemName) {

            ShortName->Length = OemName->Length;
            RtlCopyMemory( ShortName->Buffer, OemName->Buffer, OemName->Length );
        }

        GenerateShortName = FALSE;
    }

    //
    //  Now see if the caller will have to use unicode string as an LFN
    //

    if (GenerateShortName) {

        *CreateLfn = TRUE;
        *AllLowerComponent = FALSE;
        *AllLowerExtension = FALSE;

    } else {

        FatEvaluateNameCase( IrpContext,
                             UnicodeName,
                             AllLowerComponent,
                             AllLowerExtension,
                             CreateLfn );
    }

    return;
}


VOID
FatEvaluateNameCase (
    IN PIRP_CONTEXT IrpContext,
    IN PUNICODE_STRING UnicodeName,
    IN OUT BOOLEAN *AllLowerComponent,
    IN OUT BOOLEAN *AllLowerExtension,
    IN OUT BOOLEAN *CreateLfn
    )

/*++

Routine Description:

    This routine takes a UNICODE string and sees if it is eligible for
    the special case optimization.

Arguments:

    UnicodeName - Provides the original final name.

    AllLowerComponent - Returns whether this compoent was all lower case.

    AllLowerExtension - Returns wheather the extension was all lower case.

    CreateLfn - Tells the call if we must create an LFN for the UnicodeName.

Return Value:

    None.

--*/

{
    ULONG i;
    UCHAR Uppers = 0;
    UCHAR Lowers = 0;

    BOOLEAN ExtensionPresent = FALSE;

    *CreateLfn = FALSE;

    for (i = 0; i < UnicodeName->Length / sizeof(WCHAR); i++) {

        WCHAR c;

        c = UnicodeName->Buffer[i];

        if ((c >= 'A') && (c <= 'Z')) {

            Uppers += 1;

        } else if ((c >= 'a') && (c <= 'z')) {

            Lowers += 1;

        } else if ((c >= 0x0080) && FatData.CodePageInvariant) {

            break;
        }

        //
        //  If we come to a period, figure out if the extension was
        //  all one case.
        //

        if (c == L'.') {

            *CreateLfn = (Lowers != 0) && (Uppers != 0);

            *AllLowerComponent = !(*CreateLfn) && (Lowers != 0);

            ExtensionPresent = TRUE;

            //
            //  Now reset the uppers and lowers count.
            //

            Uppers = Lowers = 0;
        }
    }

    //
    //  Now check again for creating an LFN.
    //

    *CreateLfn = (*CreateLfn ||
                  (i != UnicodeName->Length / sizeof(WCHAR)) ||
                  ((Lowers != 0) && (Uppers != 0)));

    //
    //  Now we know the final state of CreateLfn, update the two
    //  "AllLower" booleans.
    //

    if (ExtensionPresent) {

        *AllLowerComponent = !(*CreateLfn) && *AllLowerComponent;
        *AllLowerExtension = !(*CreateLfn) && (Lowers != 0);

    } else {

        *AllLowerComponent = !(*CreateLfn) && (Lowers != 0);
        *AllLowerExtension = FALSE;
    }

    return;
}


BOOLEAN
FatSpaceInName (
    IN PIRP_CONTEXT IrpContext,
    IN PUNICODE_STRING UnicodeName
    )

/*++

Routine Description:

    This routine takes a UNICODE string and sees if it contains any spaces.

Arguments:

    UnicodeName - Provides the final name.

Return Value:

    BOOLEAN - TRUE if it does, FALSE if it doesn't.

--*/

{
    ULONG i;

    for (i=0; i < UnicodeName->Length/sizeof(WCHAR); i++) {

        if (UnicodeName->Buffer[i] == L' ') {
            return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fastfat\read.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    Read.c

Abstract:

    This module implements the File Read routine for Read called by the
    dispatch driver.

// @@BEGIN_DDKSPLIT

Author:

    David Goebel      [DavidGoe]      28-Feb-1991

Revision History:

// @@END_DDKSPLIT

--*/

#include "FatProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (FAT_BUG_CHECK_READ)

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_READ)

//
//  Define stack overflow read threshhold.  For the x86 we'll use a smaller
//  threshold than for a risc platform.
//
//  Empirically, the limit is a result of the (large) amount of stack
//  neccesary to throw an exception.
//

#if defined(_M_IX86)
#define OVERFLOW_READ_THRESHHOLD         (0xE00)
#else
#define OVERFLOW_READ_THRESHHOLD         (0x1000)
#endif // defined(_M_IX86)


//
//  The following procedures handles read stack overflow operations.
//

VOID
FatStackOverflowRead (
    IN PVOID Context,
    IN PKEVENT Event
    );

NTSTATUS
FatPostStackOverflowRead (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PFCB Fcb
    );

VOID
FatOverflowPagingFileRead (
    IN PVOID Context,
    IN PKEVENT Event
    );

//
//  VOID
//  SafeZeroMemory (
//      IN PUCHAR At,
//      IN ULONG ByteCount
//      );
//

//
//  This macro just puts a nice little try-except around RtlZeroMemory
//

#define SafeZeroMemory(AT,BYTE_COUNT) {                            \
    try {                                                          \
        RtlZeroMemory((AT), (BYTE_COUNT));                         \
    } except(EXCEPTION_EXECUTE_HANDLER) {                          \
         FatRaiseStatus( IrpContext, STATUS_INVALID_USER_BUFFER ); \
    }                                                              \
}

//
//  Macro to increment appropriate performance counters.
//

#define CollectReadStats(VCB,OPEN_TYPE,BYTE_COUNT) {                                         \
    PFILESYSTEM_STATISTICS Stats = &(VCB)->Statistics[KeGetCurrentProcessorNumber()].Common; \
    if (((OPEN_TYPE) == UserFileOpen)) {                                                     \
        Stats->UserFileReads += 1;                                                           \
        Stats->UserFileReadBytes += (ULONG)(BYTE_COUNT);                                     \
    } else if (((OPEN_TYPE) == VirtualVolumeFile || ((OPEN_TYPE) == DirectoryFile))) {       \
        Stats->MetaDataReads += 1;                                                           \
        Stats->MetaDataReadBytes += (ULONG)(BYTE_COUNT);                                     \
    }                                                                                        \
}


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FatStackOverflowRead)
#pragma alloc_text(PAGE, FatPostStackOverflowRead)
#pragma alloc_text(PAGE, FatCommonRead)
#endif


NTSTATUS
FatFsdRead (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the driver entry to the common read routine for NtReadFile calls.
    For synchronous requests, the CommonRead is called with Wait == TRUE,
    which means the request will always be completed in the current thread,
    and never passed to the Fsp.  If it is not a synchronous request,
    CommonRead is called with Wait == FALSE, which means the request
    will be passed to the Fsp only if there is a need to block.

Arguments:

    VolumeDeviceObject - Supplies the volume device object where the
        file being Read exists

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The FSD status for the IRP

--*/

{
    PFCB Fcb;
    NTSTATUS Status;
    PIRP_CONTEXT IrpContext = NULL;

    BOOLEAN TopLevel;

    DebugTrace(+1, Dbg, "FatFsdRead\n", 0);

    //
    //  Call the common Read routine, with blocking allowed if synchronous
    //

    FsRtlEnterFileSystem();

    //
    //  We are first going to do a quick check for paging file IO.  Since this
    //  is a fast path, we must replicate the check for the fsdo.
    //

    if (!FatDeviceIsFatFsdo( IoGetCurrentIrpStackLocation(Irp)->DeviceObject))  {

        Fcb = (PFCB)(IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext);

        if ((NodeType(Fcb) == FAT_NTC_FCB) &&
            FlagOn(Fcb->FcbState, FCB_STATE_PAGING_FILE)) {

            //
            //  Do the usual STATUS_PENDING things.
            //

            IoMarkIrpPending( Irp );

            //
            //  If there is not enough stack to do this read, then post this
            //  read to the overflow queue.
            //

            if (IoGetRemainingStackSize() < OVERFLOW_READ_THRESHHOLD) {

                KEVENT Event;
                PAGING_FILE_OVERFLOW_PACKET Packet;

                Packet.Irp = Irp;
                Packet.Fcb = Fcb;

                KeInitializeEvent( &Event, NotificationEvent, FALSE );

                FsRtlPostPagingFileStackOverflow( &Packet, &Event, FatOverflowPagingFileRead );

                //
                //  And wait for the worker thread to complete the item
                //

                (VOID) KeWaitForSingleObject( &Event, Executive, KernelMode, FALSE, NULL );

            } else {

                //
                //  Perform the actual IO, it will be completed when the io finishes.
                //

                FatPagingFileIo( Irp, Fcb );
            }

            FsRtlExitFileSystem();

            return STATUS_PENDING;
        }
    }

    try {

        TopLevel = FatIsIrpTopLevel( Irp );

        IrpContext = FatCreateIrpContext( Irp, CanFsdWait( Irp ) );

        //
        //  If this is an Mdl complete request, don't go through
        //  common read.
        //

        if ( FlagOn(IrpContext->MinorFunction, IRP_MN_COMPLETE) ) {

            DebugTrace(0, Dbg, "Calling FatCompleteMdl\n", 0 );
            try_return( Status = FatCompleteMdl( IrpContext, Irp ));
        }

        //
        //  Check if we have enough stack space to process this request.  If there
        //  isn't enough then we will pass the request off to the stack overflow thread.
        //

        if (IoGetRemainingStackSize() < OVERFLOW_READ_THRESHHOLD) {

            DebugTrace(0, Dbg, "Passing StackOverflowRead off\n", 0 );
            try_return( Status = FatPostStackOverflowRead( IrpContext, Irp, Fcb ) );
        }

        Status = FatCommonRead( IrpContext, Irp );

    try_exit: NOTHING;
    } except(FatExceptionFilter( IrpContext, GetExceptionInformation() )) {

        //
        //  We had some trouble trying to perform the requested
        //  operation, so we'll abort the I/O request with
        //  the error status that we get back from the
        //  execption code
        //

        Status = FatProcessException( IrpContext, Irp, GetExceptionCode() );
    }

    if (TopLevel) { IoSetTopLevelIrp( NULL ); }

    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "FatFsdRead -> %08lx\n", Status);

    UNREFERENCED_PARAMETER( VolumeDeviceObject );

    return Status;
}


//
//  Internal support routine
//

NTSTATUS
FatPostStackOverflowRead (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine posts a read request that could not be processed by
    the fsp thread because of stack overflow potential.

Arguments:

    Irp - Supplies the request to process.

    Fcb - Supplies the file.

Return Value:

    STATUS_PENDING.

--*/

{
    KEVENT Event;
    PERESOURCE Resource;
    PVCB Vcb;

    DebugTrace(0, Dbg, "Getting too close to stack limit pass request to Fsp\n", 0 );

    //
    //  Initialize an event and get shared on the resource we will
    //  be later using the common read.
    //

    KeInitializeEvent( &Event, NotificationEvent, FALSE );

    //
    //  Preacquire the resource the read path will require so we know the
    //  worker thread can proceed without waiting.
    //
    
    if (FlagOn(Irp->Flags, IRP_PAGING_IO) && (Fcb->Header.PagingIoResource != NULL)) {

        Resource = Fcb->Header.PagingIoResource;

    } else {

        Resource = Fcb->Header.Resource;
    }
    
    //
    //  If there are no resources assodicated with the file (case: the virtual
    //  volume file), it is OK.  No resources will be acquired on the other side
    //  as well.
    //

    if (Resource) {
        
        ExAcquireResourceSharedLite( Resource, TRUE );
    }

    if (NodeType( Fcb ) == FAT_NTC_VCB) {

        Vcb = (PVCB) Fcb;
    
    } else {

        Vcb = Fcb->Vcb;
    }
    
    try {
        
        //
        //  Make the Irp just like a regular post request and
        //  then send the Irp to the special overflow thread.
        //  After the post we will wait for the stack overflow
        //  read routine to set the event that indicates we can
        //  now release the scb resource and return.
        //

        FatPrePostIrp( IrpContext, Irp );

        //
        //  If this read is the result of a verify, we have to
        //  tell the overflow read routne to temporarily
        //  hijack the Vcb->VerifyThread field so that reads
        //  can go through.
        //

        if (Vcb->VerifyThread == KeGetCurrentThread()) {

            SetFlag(IrpContext->Flags, IRP_CONTEXT_FLAG_VERIFY_READ);
        }

        FsRtlPostStackOverflow( IrpContext, &Event, FatStackOverflowRead );

        //
        //  And wait for the worker thread to complete the item
        //

        KeWaitForSingleObject( &Event, Executive, KernelMode, FALSE, NULL );

    } finally {

        if (Resource) {

            ExReleaseResourceLite( Resource );
        }
    }

    return STATUS_PENDING;
}


//
//  Internal support routine
//

VOID
FatStackOverflowRead (
    IN PVOID Context,
    IN PKEVENT Event
    )

/*++

Routine Description:

    This routine processes a read request that could not be processed by
    the fsp thread because of stack overflow potential.

Arguments:

    Context - Supplies the IrpContext being processed

    Event - Supplies the event to be signaled when we are done processing this
        request.

Return Value:

    None.

--*/

{
    PIRP_CONTEXT IrpContext = Context;
    PKTHREAD SavedVerifyThread = NULL;
    PVCB Vcb;

    //
    //  Make it now look like we can wait for I/O to complete
    //

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT );

    //
    //  If this read was as the result of a verify we have to fake out the
    //  the Vcb->VerifyThread field.
    //

    if (FlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_VERIFY_READ)) {

        PFCB Fcb = (PFCB)IoGetCurrentIrpStackLocation(IrpContext->OriginatingIrp)->
                    FileObject->FsContext;

        if (NodeType( Fcb ) == FAT_NTC_VCB) {
    
            Vcb = (PVCB) Fcb;
        
        } else {
    
            Vcb = Fcb->Vcb;
        }

        ASSERT( Vcb->VerifyThread != NULL );
        SavedVerifyThread = Vcb->VerifyThread;
        Vcb->VerifyThread = KeGetCurrentThread();
    }

    //
    //  Do the read operation protected by a try-except clause
    //

    try {

        (VOID) FatCommonRead( IrpContext, IrpContext->OriginatingIrp );

    } except(FatExceptionFilter( IrpContext, GetExceptionInformation() )) {

        NTSTATUS ExceptionCode;

        //
        //  We had some trouble trying to perform the requested
        //  operation, so we'll abort the I/O request with
        //  the error status that we get back from the
        //  execption code
        //

        ExceptionCode = GetExceptionCode();

        if (ExceptionCode == STATUS_FILE_DELETED) {

            IrpContext->ExceptionStatus = ExceptionCode = STATUS_END_OF_FILE;
            IrpContext->OriginatingIrp->IoStatus.Information = 0;
        }

        (VOID) FatProcessException( IrpContext, IrpContext->OriginatingIrp, ExceptionCode );
    }

    //
    //  Restore the original VerifyVolumeThread
    //

    if (SavedVerifyThread != NULL) {

        ASSERT( Vcb->VerifyThread == KeGetCurrentThread() );
        Vcb->VerifyThread = SavedVerifyThread;
    }

    //
    //  Set the stack overflow item's event to tell the original
    //  thread that we're done.
    //

    KeSetEvent( Event, 0, FALSE );
}


NTSTATUS
FatCommonRead (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common read routine for NtReadFile, called from both
    the Fsd, or from the Fsp if a request could not be completed without
    blocking in the Fsd.  This routine has no code where it determines
    whether it is running in the Fsd or Fsp.  Instead, its actions are
    conditionalized by the Wait input parameter, which determines whether
    it is allowed to block or not.  If a blocking condition is encountered
    with Wait == FALSE, however, the request is posted to the Fsp, who
    always calls with WAIT == TRUE.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    PVCB Vcb;
    PFCB FcbOrDcb;
    PCCB Ccb;

    VBO StartingVbo;
    ULONG ByteCount;
    ULONG RequestedByteCount;

    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;
    TYPE_OF_OPEN TypeOfOpen;

    BOOLEAN PostIrp = FALSE;
    BOOLEAN OplockPostIrp = FALSE;

    BOOLEAN FcbOrDcbAcquired = FALSE;

    BOOLEAN Wait;
    BOOLEAN PagingIo;
    BOOLEAN NonCachedIo;
    BOOLEAN SynchronousIo;

    NTSTATUS Status;

    FAT_IO_CONTEXT StackFatIoContext;

    //
    // A system buffer is only used if we have to access the
    // buffer directly from the Fsp to clear a portion or to
    // do a synchronous I/O, or a cached transfer.  It is
    // possible that our caller may have already mapped a
    // system buffer, in which case we must remember this so
    // we do not unmap it on the way out.
    //

    PVOID SystemBuffer = NULL;

    LARGE_INTEGER StartingByte;

    //
    // Get current Irp stack location.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );
    FileObject = IrpSp->FileObject;

    //
    // Initialize the appropriate local variables.
    //

    Wait          = BooleanFlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT);
    PagingIo      = BooleanFlagOn(Irp->Flags, IRP_PAGING_IO);
    NonCachedIo   = BooleanFlagOn(Irp->Flags,IRP_NOCACHE);
    SynchronousIo = BooleanFlagOn(FileObject->Flags, FO_SYNCHRONOUS_IO);

    DebugTrace(+1, Dbg, "CommonRead\n", 0);
    DebugTrace( 0, Dbg, "  Irp                   = %8lx\n", Irp);
    DebugTrace( 0, Dbg, "  ->ByteCount           = %8lx\n", IrpSp->Parameters.Read.Length);
    DebugTrace( 0, Dbg, "  ->ByteOffset.LowPart  = %8lx\n", IrpSp->Parameters.Read.ByteOffset.LowPart);
    DebugTrace( 0, Dbg, "  ->ByteOffset.HighPart = %8lx\n", IrpSp->Parameters.Read.ByteOffset.HighPart);

    //
    //  Extract starting Vbo and offset.
    //

    StartingByte = IrpSp->Parameters.Read.ByteOffset;

    StartingVbo = StartingByte.LowPart;

    ByteCount = IrpSp->Parameters.Read.Length;
    RequestedByteCount = ByteCount;

    //
    //  Check for a null request, and return immediately
    //

    if (ByteCount == 0) {

        Irp->IoStatus.Information = 0;
        FatCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
        return STATUS_SUCCESS;
    }

    //
    // Extract the nature of the read from the file object, and case on it
    //

    TypeOfOpen = FatDecodeFileObject(FileObject, &Vcb, &FcbOrDcb, &Ccb);

    ASSERT( Vcb != NULL );

    //
    //  Save callers who try to do cached IO to the raw volume from themselves.
    //

    if (TypeOfOpen == UserVolumeOpen) {

        NonCachedIo = TRUE;
    }

    ASSERT(!(NonCachedIo == FALSE && TypeOfOpen == VirtualVolumeFile));

    //
    // Collect interesting statistics.  The FLAG_USER_IO bit will indicate
    // what type of io we're doing in the FatNonCachedIo function.
    //

    if (PagingIo) {
        CollectReadStats(Vcb, TypeOfOpen, ByteCount);

        if (TypeOfOpen == UserFileOpen) {
            SetFlag(IrpContext->Flags, IRP_CONTEXT_FLAG_USER_IO);
        } else {
            ClearFlag(IrpContext->Flags, IRP_CONTEXT_FLAG_USER_IO);
        }
    }

    ASSERT(!FlagOn( IrpContext->Flags, IRP_CONTEXT_STACK_IO_CONTEXT ));

    //
    //  Allocate if necessary and initialize a FAT_IO_CONTEXT block for
    //  all non cached Io.  For synchronous Io we use stack storage,
    //  otherwise we allocate pool.
    //

    if (NonCachedIo) {

        if (IrpContext->FatIoContext == NULL) {

            if (!Wait) {

                IrpContext->FatIoContext =
                    FsRtlAllocatePoolWithTag( NonPagedPool,
                                              sizeof(FAT_IO_CONTEXT),
                                              TAG_FAT_IO_CONTEXT );

            } else {

                IrpContext->FatIoContext = &StackFatIoContext;

                SetFlag( IrpContext->Flags, IRP_CONTEXT_STACK_IO_CONTEXT );
            }
        }

        RtlZeroMemory( IrpContext->FatIoContext, sizeof(FAT_IO_CONTEXT) );

        if (Wait) {

            KeInitializeEvent( &IrpContext->FatIoContext->Wait.SyncEvent,
                               NotificationEvent,
                               FALSE );

        } else {

            IrpContext->FatIoContext->Wait.Async.ResourceThreadId =
                ExGetCurrentResourceThread();

            IrpContext->FatIoContext->Wait.Async.RequestedByteCount =
                ByteCount;

            IrpContext->FatIoContext->Wait.Async.FileObject = FileObject;
        }
    }


    //
    // These two cases correspond to either a general opened volume, ie.
    // open ("a:"), or a read of the volume file (boot sector + fat(s))
    //

    if ((TypeOfOpen == VirtualVolumeFile) ||
        (TypeOfOpen == UserVolumeOpen)) {

        LBO StartingLbo;

        StartingLbo = StartingByte.QuadPart;

        DebugTrace(0, Dbg, "Type of read is User Volume or virtual volume file\n", 0);

        if (TypeOfOpen == UserVolumeOpen) {

            //
            //  Verify that the volume for this handle is still valid
            //

            //
            //  Verify that the volume for this handle is still valid, permitting
            //  operations to proceed on dismounted volumes via the handle which
            //  performed the dismount.
            //

            if (!FlagOn( Ccb->Flags, CCB_FLAG_COMPLETE_DISMOUNT )) {

                FatQuickVerifyVcb( IrpContext, Vcb );
            }

            if (!FlagOn( Ccb->Flags, CCB_FLAG_DASD_FLUSH_DONE )) {

                (VOID)ExAcquireResourceExclusiveLite( &Vcb->Resource, TRUE );

                try {

                    //
                    //  If the volume isn't locked, flush it.
                    //

                    if (!FlagOn(Vcb->VcbState, VCB_STATE_FLAG_LOCKED)) {

                        FatFlushVolume( IrpContext, Vcb, Flush );
                    }

                } finally {

                    ExReleaseResourceLite( &Vcb->Resource );
                }

                SetFlag( Ccb->Flags, CCB_FLAG_DASD_FLUSH_DONE );
            }

            if (!FlagOn( Ccb->Flags, CCB_FLAG_ALLOW_EXTENDED_DASD_IO )) {

                LBO VolumeSize;

                //
                //  Make sure we don't try to read past end of volume,
                //  reducing the byte count if necessary.
                //

                VolumeSize = (LBO) Vcb->Bpb.BytesPerSector *
                             (Vcb->Bpb.Sectors != 0 ? Vcb->Bpb.Sectors :
                                                      Vcb->Bpb.LargeSectors);

                if (StartingLbo >= VolumeSize) {
                    Irp->IoStatus.Information = 0;
                    FatCompleteRequest( IrpContext, Irp, STATUS_END_OF_FILE );
                    return STATUS_END_OF_FILE;
                }

                if (ByteCount > VolumeSize - StartingLbo) {

                    ByteCount = RequestedByteCount = (ULONG) (VolumeSize - StartingLbo);

                    //
                    //  For async reads we had set the byte count in the FatIoContext
                    //  above, so fix that here.
                    //

                    if (!Wait) {

                        IrpContext->FatIoContext->Wait.Async.RequestedByteCount =
                            ByteCount;
                    }
                }
            }

            //
            //  For DASD we have to probe and lock the user's buffer
            //

            FatLockUserBuffer( IrpContext, Irp, IoWriteAccess, ByteCount );


        } else {

            //
            //  Virtual volume file open -- increment performance counters.
            //

            Vcb->Statistics[KeGetCurrentProcessorNumber()].Common.MetaDataDiskReads += 1;

        }

        //
        //  Read the data and wait for the results
        //

        FatSingleAsync( IrpContext,
                        Vcb,
                        StartingLbo,
                        ByteCount,
                        Irp );

        if (!Wait) {

            //
            //  We, nor anybody else, need the IrpContext any more.
            //

            IrpContext->FatIoContext = NULL;

            FatDeleteIrpContext( IrpContext );

            DebugTrace(-1, Dbg, "FatNonCachedIo -> STATUS_PENDING\n", 0);

            return STATUS_PENDING;
        }

        FatWaitSync( IrpContext );

        //
        //  If the call didn't succeed, raise the error status
        //

        if (!NT_SUCCESS( Status = Irp->IoStatus.Status )) {

            ASSERT( KeGetCurrentThread() != Vcb->VerifyThread || Status != STATUS_VERIFY_REQUIRED );
            FatNormalizeAndRaiseStatus( IrpContext, Status );
        }

        //
        //  Update the current file position
        //

        if (SynchronousIo && !PagingIo) {
            FileObject->CurrentByteOffset.QuadPart =
                StartingLbo + Irp->IoStatus.Information;
        }

        DebugTrace(-1, Dbg, "CommonRead -> %08lx\n", Status );

        FatCompleteRequest( IrpContext, Irp, Status );
        return Status;
    }

    //
    //  At this point we know there is an Fcb/Dcb.
    //

    ASSERT( FcbOrDcb != NULL );

    //
    //  Check for a non-zero high part offset
    //

    if ( StartingByte.HighPart != 0 ) {

        Irp->IoStatus.Information = 0;
        FatCompleteRequest( IrpContext, Irp, STATUS_END_OF_FILE );
        return STATUS_END_OF_FILE;
    }

    //
    //  Use a try-finally to free Fcb/Dcb and buffers on the way out.
    //

    try {

        //
        // This case corresponds to a normal user read file.
        //

        if ( TypeOfOpen == UserFileOpen) {

            ULONG FileSize;
            ULONG ValidDataLength;

            DebugTrace(0, Dbg, "Type of read is user file open\n", 0);

            //
            //  If this is a noncached transfer and is not a paging I/O, and
            //  the file has a data section, then we will do a flush here
            //  to avoid stale data problems.  Note that we must flush before
            //  acquiring the Fcb shared since the write may try to acquire
            //  it exclusive.
            //

            if (!PagingIo && NonCachedIo

                    &&

                (FileObject->SectionObjectPointer->DataSectionObject != NULL)) {

#ifndef REDUCE_SYNCHRONIZATION
                if (!FatAcquireExclusiveFcb( IrpContext, FcbOrDcb )) {

                    try_return( PostIrp = TRUE );
                }

                ExAcquireResourceSharedLite( FcbOrDcb->Header.PagingIoResource, TRUE);
#endif //REDUCE_SYNCHRONIZATION

                CcFlushCache( FileObject->SectionObjectPointer,
                              &StartingByte,
                              ByteCount,
                              &Irp->IoStatus );

#ifndef REDUCE_SYNCHRONIZATION
                ExReleaseResourceLite( FcbOrDcb->Header.PagingIoResource );
                FatReleaseFcb( IrpContext, FcbOrDcb );
#endif //REDUCE_SYNCHRONIZATION

                if (!NT_SUCCESS( Irp->IoStatus.Status)) {

                    try_return( Irp->IoStatus.Status );
                }

#ifndef REDUCE_SYNCHRONIZATION
                ExAcquireResourceExclusiveLite( FcbOrDcb->Header.PagingIoResource, TRUE );
                ExReleaseResourceLite( FcbOrDcb->Header.PagingIoResource );
#endif //REDUCE_SYNCHRONIZATION
            }

            //
            // We need shared access to the Fcb/Dcb before proceeding.
            //

            if ( PagingIo ) {

                if (!ExAcquireResourceSharedLite( FcbOrDcb->Header.PagingIoResource,
                                              Wait )) {

                    DebugTrace( 0, Dbg, "Cannot acquire FcbOrDcb = %08lx shared without waiting\n", FcbOrDcb );

                    try_return( PostIrp = TRUE );
                }

                if (!Wait) {

                    IrpContext->FatIoContext->Wait.Async.Resource =
                        FcbOrDcb->Header.PagingIoResource;
                }

            } else {

                //
                //  If this is async I/O, we will wait if there is an
                //  exclusive waiter.
                //

                if (!Wait && NonCachedIo) {

                    if (!FatAcquireSharedFcbWaitForEx( IrpContext, FcbOrDcb )) {

                        DebugTrace( 0,
                                    Dbg,
                                    "Cannot acquire FcbOrDcb = %08lx shared without waiting\n",
                                    FcbOrDcb );

                        try_return( PostIrp = TRUE );
                    }

                    IrpContext->FatIoContext->Wait.Async.Resource =
                        FcbOrDcb->Header.Resource;

                } else {

                    if (!FatAcquireSharedFcb( IrpContext, FcbOrDcb )) {

                        DebugTrace( 0,
                                    Dbg,
                                    "Cannot acquire FcbOrDcb = %08lx shared without waiting\n",
                                    FcbOrDcb );

                        try_return( PostIrp = TRUE );
                    }
                }
            }

            FcbOrDcbAcquired = TRUE;

            //
            //  Make sure the FcbOrDcb is still good
            //

            FatVerifyFcb( IrpContext, FcbOrDcb );

            //
            //  We now check whether we can proceed based on the state of
            //  the file oplocks.  
            //

            if (!PagingIo) {
                
                Status = FsRtlCheckOplock( &FcbOrDcb->Specific.Fcb.Oplock,
                                           Irp,
                                           IrpContext,
                                           FatOplockComplete,
                                           FatPrePostIrp );

                if (Status != STATUS_SUCCESS) {

                    OplockPostIrp = TRUE;
                    PostIrp = TRUE;
                    try_return( NOTHING );
                }

                //
                //  Reset the flag indicating if Fast I/O is possible since the oplock
                //  check could have broken existing (conflicting) oplocks.
                //

                FcbOrDcb->Header.IsFastIoPossible = FatIsFastIoPossible( FcbOrDcb );

                //
                // We have to check for read access according to the current
                // state of the file locks, and set FileSize from the Fcb.
                //

                if (!PagingIo &&
                    !FsRtlCheckLockForReadAccess( &FcbOrDcb->Specific.Fcb.FileLock,
                                                  Irp )) {

                    try_return( Status = STATUS_FILE_LOCK_CONFLICT );
                }
            }

            //
            //  Pick up our sizes and check/trim the IO.
            //

            FileSize = FcbOrDcb->Header.FileSize.LowPart;
            ValidDataLength = FcbOrDcb->Header.ValidDataLength.LowPart;

            //
            // If the read starts beyond End of File, return EOF.
            //

            if (StartingVbo >= FileSize) {

                DebugTrace( 0, Dbg, "End of File\n", 0 );

                try_return ( Status = STATUS_END_OF_FILE );
            }

            //
            //  If the read extends beyond EOF, truncate the read
            //

            if (ByteCount > FileSize - StartingVbo) {

                ByteCount = RequestedByteCount = FileSize - StartingVbo;

                if (NonCachedIo && !Wait) {

                    IrpContext->FatIoContext->Wait.Async.RequestedByteCount =
                        RequestedByteCount;

                }
            }

            //
            // HANDLE THE NON-CACHED CASE
            //

            if ( NonCachedIo ) {

                ULONG SectorSize;
                ULONG BytesToRead;

                DebugTrace(0, Dbg, "Non cached read.\n", 0);

                //
                //  Get the sector size
                //

                SectorSize = (ULONG)Vcb->Bpb.BytesPerSector;

                //
                //  Start by zeroing any part of the read after Valid Data
                //

                if (ValidDataLength < FcbOrDcb->ValidDataToDisk) {

                    ValidDataLength = FcbOrDcb->ValidDataToDisk;
                }

                if ( StartingVbo + ByteCount > ValidDataLength ) {

                    SystemBuffer = FatMapUserBuffer( IrpContext, Irp );

                    if (StartingVbo < ValidDataLength) {

                        ULONG ZeroingOffset;
                        
                        //
                        //  Now zero out the user's request sector aligned beyond
                        //  vdl.  We will handle the straddling sector at completion
                        //  time via the bytecount reduction which immediately
                        //  follows this check.
                        //
                        //  Note that we used to post in this case for async requests.
                        //  Note also that if the request was wholly beyond VDL that
                        //  we did not post, therefore this is consistent.  Synchronous
                        //  zeroing is fine for async requests.
                        //

                        ZeroingOffset = ((ValidDataLength - StartingVbo) + (SectorSize - 1))
                                                                        & ~(SectorSize - 1);

                        //
                        //  If the offset is at or above the byte count, no harm: just means
                        //  that the read ends in the last sector and the zeroing will be
                        //  done at completion.
                        //
                        
                        if (ByteCount > ZeroingOffset) {
                            
                            SafeZeroMemory( (PUCHAR) SystemBuffer + ZeroingOffset,
                                            ByteCount - ZeroingOffset);
                        }

                    } else {

                        //
                        //  All we have to do now is sit here and zero the
                        //  user's buffer, no reading is required.
                        //

                        SafeZeroMemory( (PUCHAR)SystemBuffer, ByteCount );

                        Irp->IoStatus.Information = ByteCount;

                        try_return ( Status = STATUS_SUCCESS );
                    }
                }

                //
                //  Reduce the byte count to actually read if it extends beyond
                //  Valid Data Length
                //

                ByteCount = (ValidDataLength - StartingVbo < ByteCount) ?
                             ValidDataLength - StartingVbo : ByteCount;
                //
                //  Round up to a sector boundary, and remember that if we are
                //  reading extra bytes we will zero them out during completion.
                //

                BytesToRead = (ByteCount + (SectorSize - 1))
                                        & ~(SectorSize - 1);

                //
                //  Just to help alleviate confusion.  At this point:
                //
                //  RequestedByteCount - is the number of bytes originally
                //                       taken from the Irp, but constrained
                //                       to filesize.
                //
                //  ByteCount -          is RequestedByteCount constrained to
                //                       ValidDataLength.
                //
                //  BytesToRead -        is ByteCount rounded up to sector
                //                       boundry.  This is the number of bytes
                //                       that we must physically read.
                //

                //
                //  If this request is not properly aligned, or extending
                //  to a sector boundary would overflow the buffer, send it off
                //  on a special-case path.
                //

                if ( (StartingVbo & (SectorSize - 1)) ||
                     (BytesToRead > IrpSp->Parameters.Read.Length) ) {

                    //
                    //  If we can't wait, we must post this.
                    //

                    if (!Wait) {

                        try_return( PostIrp = TRUE );
                    }

                    //
                    //  Do the physical read
                    //

                    FatNonCachedNonAlignedRead( IrpContext,
                                                Irp,
                                                FcbOrDcb,
                                                StartingVbo,
                                                ByteCount );

                    //
                    //  Set BytesToRead to ByteCount to satify the following ASSERT.
                    //

                    BytesToRead = ByteCount;

                } else {

                    //
                    //  Perform the actual IO
                    //

                    if (FatNonCachedIo( IrpContext,
                                        Irp,
                                        FcbOrDcb,
                                        StartingVbo,
                                        BytesToRead,
                                        ByteCount ) == STATUS_PENDING) {

                        IrpContext->FatIoContext = NULL;

                        Irp = NULL;

                        try_return( Status = STATUS_PENDING );
                    }
                }

                //
                //  If the call didn't succeed, raise the error status
                //

                if (!NT_SUCCESS( Status = Irp->IoStatus.Status )) {

                    ASSERT( KeGetCurrentThread() != Vcb->VerifyThread || Status != STATUS_VERIFY_REQUIRED );
                    FatNormalizeAndRaiseStatus( IrpContext, Status );

                } else {

                    //
                    //  Else set the Irp information field to reflect the
                    //  entire desired read.
                    //

                    ASSERT( Irp->IoStatus.Information == BytesToRead );

                    Irp->IoStatus.Information = RequestedByteCount;
                }

                //
                // The transfer is complete.
                //

                try_return( Status );

            }   // if No Intermediate Buffering


            //
            // HANDLE CACHED CASE
            //

            else {

                //
                // We delay setting up the file cache until now, in case the
                // caller never does any I/O to the file, and thus
                // FileObject->PrivateCacheMap == NULL.
                //

                if (FileObject->PrivateCacheMap == NULL) {

                    DebugTrace(0, Dbg, "Initialize cache mapping.\n", 0);

                    //
                    //  Get the file allocation size, and if it is less than
                    //  the file size, raise file corrupt error.
                    //

                    if (FcbOrDcb->Header.AllocationSize.QuadPart == FCB_LOOKUP_ALLOCATIONSIZE_HINT) {

                        FatLookupFileAllocationSize( IrpContext, FcbOrDcb );
                    }

                    if ( FileSize > FcbOrDcb->Header.AllocationSize.LowPart ) {

                        FatPopUpFileCorrupt( IrpContext, FcbOrDcb );

                        FatRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
                    }

                    //
                    //  Now initialize the cache map.
                    //

                    CcInitializeCacheMap( FileObject,
                                          (PCC_FILE_SIZES)&FcbOrDcb->Header.AllocationSize,
                                          FALSE,
                                          &FatData.CacheManagerCallbacks,
                                          FcbOrDcb );

                    CcSetReadAheadGranularity( FileObject, READ_AHEAD_GRANULARITY );
                }


                //
                // DO A NORMAL CACHED READ, if the MDL bit is not set,
                //

                DebugTrace(0, Dbg, "Cached read.\n", 0);

                if (!FlagOn(IrpContext->MinorFunction, IRP_MN_MDL)) {

                    //
                    //  Get hold of the user's buffer.
                    //

                    SystemBuffer = FatMapUserBuffer( IrpContext, Irp );

                    //
                    // Now try to do the copy.
                    //

                    if (!CcCopyRead( FileObject,
                                     &StartingByte,
                                     ByteCount,
                                     Wait,
                                     SystemBuffer,
                                     &Irp->IoStatus )) {

                        DebugTrace( 0, Dbg, "Cached Read could not wait\n", 0 );

                        try_return( PostIrp = TRUE );
                    }

                    Status = Irp->IoStatus.Status;

                    ASSERT( NT_SUCCESS( Status ));

                    try_return( Status );
                }


                //
                //  HANDLE A MDL READ
                //

                else {

                    DebugTrace(0, Dbg, "MDL read.\n", 0);

                    ASSERT( Wait );

                    CcMdlRead( FileObject,
                               &StartingByte,
                               ByteCount,
                               &Irp->MdlAddress,
                               &Irp->IoStatus );

                    Status = Irp->IoStatus.Status;

                    ASSERT( NT_SUCCESS( Status ));

                    try_return( Status );
                }
            }
        }

        //
        //  These two cases correspond to a system read directory file and
        //  ea file.
        //

        if (( TypeOfOpen == DirectoryFile ) || ( TypeOfOpen == EaFile)) {

            ULONG SectorSize;

            DebugTrace(0, Dbg, "Read Directory or Ea file.\n", 0);

            //
            //  For the noncached case, assert that everything is sector
            //  alligned.
            //

            SectorSize = (ULONG)Vcb->Bpb.BytesPerSector;

            //
            //  We make several assumptions about these two types of files.
            //  Make sure all of them are true.
            //

            ASSERT( NonCachedIo && PagingIo );
            ASSERT( ((StartingVbo | ByteCount) & (SectorSize - 1)) == 0 );

            //
            //  These calls must allways be within the allocation size
            //

            if (StartingVbo >= FcbOrDcb->Header.AllocationSize.LowPart) {

                DebugTrace( 0, Dbg, "PagingIo dirent started beyond EOF.\n", 0 );

                Irp->IoStatus.Information = 0;

                try_return( Status = STATUS_SUCCESS );
            }

            if ( StartingVbo + ByteCount > FcbOrDcb->Header.AllocationSize.LowPart ) {

                DebugTrace( 0, Dbg, "PagingIo dirent extending beyond EOF.\n", 0 );
                ByteCount = FcbOrDcb->Header.AllocationSize.LowPart - StartingVbo;
            }

            //
            //  Perform the actual IO
            //

            if (FatNonCachedIo( IrpContext,
                                Irp,
                                FcbOrDcb,
                                StartingVbo,
                                ByteCount,
                                ByteCount ) == STATUS_PENDING) {

                IrpContext->FatIoContext = NULL;

                Irp = NULL;

                try_return( Status = STATUS_PENDING );
            }

            //
            //  If the call didn't succeed, raise the error status
            //

            if (!NT_SUCCESS( Status = Irp->IoStatus.Status )) {

                ASSERT( KeGetCurrentThread() != Vcb->VerifyThread || Status != STATUS_VERIFY_REQUIRED );
                FatNormalizeAndRaiseStatus( IrpContext, Status );

            } else {

                ASSERT( Irp->IoStatus.Information == ByteCount );
            }

            try_return( Status );
        }

        //
        // This is the case of a user who openned a directory. No reading is
        // allowed.
        //

        if ( TypeOfOpen == UserDirectoryOpen ) {

            DebugTrace( 0, Dbg, "CommonRead -> STATUS_INVALID_PARAMETER\n", 0);

            try_return( Status = STATUS_INVALID_PARAMETER );
        }

        //
        //  If we get this far, something really serious is wrong.
        //

        DebugDump("Illegal TypeOfOpen\n", 0, FcbOrDcb );

        FatBugCheck( TypeOfOpen, (ULONG_PTR) FcbOrDcb, 0 );

    try_exit: NOTHING;

        //
        //  If the request was not posted and there's an Irp, deal with it.
        //

        if ( Irp ) {

            if ( !PostIrp ) {

                ULONG ActualBytesRead;

                DebugTrace( 0, Dbg, "Completing request with status = %08lx\n",
                            Status);

                DebugTrace( 0, Dbg, "                   Information = %08lx\n",
                            Irp->IoStatus.Information);

                //
                //  Record the total number of bytes actually read
                //

                ActualBytesRead = (ULONG)Irp->IoStatus.Information;

                //
                //  If the file was opened for Synchronous IO, update the current
                //  file position.
                //

                if (SynchronousIo && !PagingIo) {

                    FileObject->CurrentByteOffset.LowPart =
                                                    StartingVbo + ActualBytesRead;
                }

                //
                //  If this was not PagingIo, mark that the last access
                //  time on the dirent needs to be updated on close.
                //

                if (NT_SUCCESS(Status) && !PagingIo) {

                    SetFlag( FileObject->Flags, FO_FILE_FAST_IO_READ );
                }

            } else {

                DebugTrace( 0, Dbg, "Passing request to Fsp\n", 0 );

                if (!OplockPostIrp) {

                    Status = FatFsdPostRequest( IrpContext, Irp );
                }
            }
        }

    } finally {

        DebugUnwind( FatCommonRead );

        //
        // If the FcbOrDcb has been acquired, release it.
        //

        if (FcbOrDcbAcquired && Irp) {

            if ( PagingIo ) {

                ExReleaseResourceLite( FcbOrDcb->Header.PagingIoResource );

            } else {

                FatReleaseFcb( NULL, FcbOrDcb );
            }
        }

        //
        //  Complete the request if we didn't post it and no exception
        //
        //  Note that FatCompleteRequest does the right thing if either
        //  IrpContext or Irp are NULL
        //

        if (!PostIrp) {
             
            //
            //  If we had a stack io context, we have to make sure the contents
            //  are cleaned up before we leave.
            //
            //  At present with zero mdls, this will only really happen on exceptional
            //  termination where we failed to dispatch the IO. Cleanup of zero mdls
            //  normally occurs during completion, but when we bail we must make sure
            //  the cleanup occurs here or the fatiocontext will go out of scope.
            //
            //  If the operation was posted, cleanup occured there.
            //

            if (FlagOn(IrpContext->Flags, IRP_CONTEXT_STACK_IO_CONTEXT)) {

                if (IrpContext->FatIoContext->ZeroMdl) {
                    IoFreeMdl( IrpContext->FatIoContext->ZeroMdl );
                }

                ClearFlag(IrpContext->Flags, IRP_CONTEXT_STACK_IO_CONTEXT);
                IrpContext->FatIoContext = NULL;
            }

            if (!AbnormalTermination()) {

                FatCompleteRequest( IrpContext, Irp, Status );
            }
        }

        DebugTrace(-1, Dbg, "CommonRead -> %08lx\n", Status );
    }

    return Status;
}

//
//  Local support routine
//

VOID
FatOverflowPagingFileRead (
    IN PVOID Context,
    IN PKEVENT Event
    )

/*++

Routine Description:

    The routine simply call FatPagingFileIo.  It is invoked in cases when
    there was not enough stack space to perform the pagefault in the
    original thread.  It is also responsible for freeing the packet pool.

Arguments:

    Irp - Supplies the Irp being processed

    Fcb - Supplies the paging file Fcb, since we have it handy.

Return Value:

    VOID

--*/

{
    PPAGING_FILE_OVERFLOW_PACKET Packet = Context;

    FatPagingFileIo( Packet->Irp, Packet->Fcb );

    //
    //  Set the stack overflow item's event to tell the original
    //  thread that we're done.
    //

    KeSetEvent( Event, 0, FALSE );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fastfat\resrcsup.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    ResrcSup.c

Abstract:

    This module implements the Fat Resource acquisition routines

// @@BEGIN_DDKSPLIT

Author:

    Gary Kimura     [GaryKi]    22-Mar-1990

Revision History:

// @@END_DDKSPLIT

--*/

#include "FatProcs.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FatAcquireExclusiveVcb)
#pragma alloc_text(PAGE, FatAcquireFcbForLazyWrite)
#pragma alloc_text(PAGE, FatAcquireFcbForReadAhead)
#pragma alloc_text(PAGE, FatAcquireExclusiveFcb)
#pragma alloc_text(PAGE, FatAcquireSharedFcb)
#pragma alloc_text(PAGE, FatAcquireSharedFcbWaitForEx)
#pragma alloc_text(PAGE, FatAcquireExclusiveVcb)
#pragma alloc_text(PAGE, FatAcquireSharedVcb)
#pragma alloc_text(PAGE, FatNoOpAcquire)
#pragma alloc_text(PAGE, FatNoOpRelease)
#pragma alloc_text(PAGE, FatReleaseFcbFromLazyWrite)
#pragma alloc_text(PAGE, FatReleaseFcbFromReadAhead)
#pragma alloc_text(PAGE, FatAcquireForCcFlush)
#pragma alloc_text(PAGE, FatReleaseForCcFlush)
#endif


FINISHED
FatAcquireExclusiveVcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine acquires exclusive access to the Vcb.

    After we acquire the resource check to see if this operation is legal.
    If it isn't (ie. we get an exception), release the resource.

Arguments:

    Vcb - Supplies the Vcb to acquire

Return Value:

    FINISHED - TRUE if we have the resource and FALSE if we needed to block
        for the resource but Wait is FALSE.

--*/

{
    if (ExAcquireResourceExclusiveLite( &Vcb->Resource, BooleanFlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT))) {

        try {

            FatVerifyOperationIsLegal( IrpContext );

        } finally {

            if ( AbnormalTermination() ) {

                FatReleaseVcb( IrpContext, Vcb );
            
            }
        }

        return TRUE;

    } else {

        return FALSE;
    }
}


FINISHED
FatAcquireSharedVcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine acquires shared access to the Vcb.

    After we acquire the resource check to see if this operation is legal.
    If it isn't (ie. we get an exception), release the resource.

Arguments:

    Vcb - Supplies the Vcb to acquire

Return Value:

    FINISHED - TRUE if we have the resource and FALSE if we needed to block
        for the resource but Wait is FALSE.

--*/

{
    if (ExAcquireResourceSharedLite( &Vcb->Resource, BooleanFlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT))) {

        try {

            FatVerifyOperationIsLegal( IrpContext );

        } finally {

            if ( AbnormalTermination() ) {

                FatReleaseVcb( IrpContext, Vcb );
            }
        }

        return TRUE;

    } else {

        return FALSE;
    }
}


FINISHED
FatAcquireExclusiveFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine acquires exclusive access to the Fcb.

    After we acquire the resource check to see if this operation is legal.
    If it isn't (ie. we get an exception), release the resource.

Arguments:

    Fcb - Supplies the Fcb to acquire

Return Value:

    FINISHED - TRUE if we have the resource and FALSE if we needed to block
        for the resource but Wait is FALSE.

--*/

{

RetryFcbExclusive:

    if (ExAcquireResourceExclusiveLite( Fcb->Header.Resource, BooleanFlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT))) {

        //
        //  Check for anything other than a non-cached write if the
        //  async count is non-zero in the Fcb, or if others are waiting
        //  for the resource.  Then wait for all outstanding I/O to finish,
        //  drop the resource, and wait again.
        //

        if ((Fcb->NonPaged->OutstandingAsyncWrites != 0) &&
            ((IrpContext->MajorFunction != IRP_MJ_WRITE) ||
             !FlagOn(IrpContext->OriginatingIrp->Flags, IRP_NOCACHE) ||
             (ExGetSharedWaiterCount(Fcb->Header.Resource) != 0) ||
             (ExGetExclusiveWaiterCount(Fcb->Header.Resource) != 0))) {

            KeWaitForSingleObject( Fcb->NonPaged->OutstandingAsyncEvent,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   (PLARGE_INTEGER) NULL );

            FatReleaseFcb( IrpContext, Fcb );

            goto RetryFcbExclusive;
        }

        try {

            FatVerifyOperationIsLegal( IrpContext );

        } finally {

            if ( AbnormalTermination() ) {

                FatReleaseFcb( IrpContext, Fcb );
            }
        }

        return TRUE;

    } else {

        return FALSE;
    }
}


FINISHED
FatAcquireSharedFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine acquires shared access to the Fcb.

    After we acquire the resource check to see if this operation is legal.
    If it isn't (ie. we get an exception), release the resource.

Arguments:

    Fcb - Supplies the Fcb to acquire

Return Value:

    FINISHED - TRUE if we have the resource and FALSE if we needed to block
        for the resource but Wait is FALSE.

--*/

{

RetryFcbShared:

    if (ExAcquireResourceSharedLite( Fcb->Header.Resource, BooleanFlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT))) {

        //
        //  Check for anything other than a non-cached write if the
        //  async count is non-zero in the Fcb, or if others are waiting
        //  for the resource.  Then wait for all outstanding I/O to finish,
        //  drop the resource, and wait again.
        //

        if ((Fcb->NonPaged->OutstandingAsyncWrites != 0) &&
            ((IrpContext->MajorFunction != IRP_MJ_WRITE) ||
             !FlagOn(IrpContext->OriginatingIrp->Flags, IRP_NOCACHE) ||
             (ExGetSharedWaiterCount(Fcb->Header.Resource) != 0) ||
             (ExGetExclusiveWaiterCount(Fcb->Header.Resource) != 0))) {

            KeWaitForSingleObject( Fcb->NonPaged->OutstandingAsyncEvent,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   (PLARGE_INTEGER) NULL );

            FatReleaseFcb( IrpContext, Fcb );

            goto RetryFcbShared;
        }

        try {

            FatVerifyOperationIsLegal( IrpContext );

        } finally {

            if ( AbnormalTermination() ) {

                FatReleaseFcb( IrpContext, Fcb );
            }
        }


        return TRUE;

    } else {

        return FALSE;
    }
}


FINISHED
FatAcquireSharedFcbWaitForEx (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine acquires shared access to the Fcb, waiting first for any
    exclusive accessors to get the Fcb first.

    After we acquire the resource check to see if this operation is legal.
    If it isn't (ie. we get an exception), release the resource.

Arguments:

    Fcb - Supplies the Fcb to acquire

Return Value:

    FINISHED - TRUE if we have the resource and FALSE if we needed to block
        for the resource but Wait is FALSE.

--*/

{

    ASSERT( FlagOn(IrpContext->OriginatingIrp->Flags, IRP_NOCACHE) );
    ASSERT( !FlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT) );

RetryFcbSharedWaitEx:

    if (ExAcquireSharedWaitForExclusive( Fcb->Header.Resource, FALSE )) {

        //
        //  Check for anything other than a non-cached write if the
        //  async count is non-zero in the Fcb. Then wait for all
        //  outstanding I/O to finish, drop the resource, and wait again.
        //

        if ((Fcb->NonPaged->OutstandingAsyncWrites != 0) &&
            (IrpContext->MajorFunction != IRP_MJ_WRITE)) {

            KeWaitForSingleObject( Fcb->NonPaged->OutstandingAsyncEvent,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   (PLARGE_INTEGER) NULL );

            FatReleaseFcb( IrpContext, Fcb );

            goto RetryFcbSharedWaitEx;
        }

        try {

            FatVerifyOperationIsLegal( IrpContext );

        } finally {

            if ( AbnormalTermination() ) {

                FatReleaseFcb( IrpContext, Fcb );
            }
        }


        return TRUE;

    } else {

        return FALSE;
    }
}


BOOLEAN
FatAcquireFcbForLazyWrite (
    IN PVOID Fcb,
    IN BOOLEAN Wait
    )

/*++

Routine Description:

    The address of this routine is specified when creating a CacheMap for
    a file.  It is subsequently called by the Lazy Writer prior to its
    performing lazy writes to the file.

Arguments:

    Fcb - The Fcb which was specified as a context parameter for this
          routine.

    Wait - TRUE if the caller is willing to block.

Return Value:

    FALSE - if Wait was specified as FALSE and blocking would have
            been required.  The Fcb is not acquired.

    TRUE - if the Fcb has been acquired

--*/

{
    //
    //  Check here for the EA File.  It turns out we need the normal
    //  resource shared in this case.  Otherwise we take the paging
    //  I/O resource shared.
    //

    if (!ExAcquireResourceSharedLite( Fcb == ((PFCB)Fcb)->Vcb->EaFcb ?
                                  ((PFCB)Fcb)->Header.Resource :
                                  ((PFCB)Fcb)->Header.PagingIoResource,
                                  Wait )) {

        return FALSE;
    }

    //
    // We assume the Lazy Writer only acquires this Fcb once.
    // Therefore, it should be guaranteed that this flag is currently
    // clear (the ASSERT), and then we will set this flag, to insure
    // that the Lazy Writer will never try to advance Valid Data, and
    // also not deadlock by trying to get the Fcb exclusive.
    //


    ASSERT( NodeType(((PFCB)Fcb)) == FAT_NTC_FCB );
    ASSERT( ((PFCB)Fcb)->Specific.Fcb.LazyWriteThread == NULL );

    ((PFCB)Fcb)->Specific.Fcb.LazyWriteThread = PsGetCurrentThread();

    ASSERT( NULL != PsGetCurrentThread() );

    if (NULL == FatData.LazyWriteThread) {

        FatData.LazyWriteThread = PsGetCurrentThread();
    }

    //
    //  This is a kludge because Cc is really the top level.  When it
    //  enters the file system, we will think it is a resursive call
    //  and complete the request with hard errors or verify.  It will
    //  then have to deal with them, somehow....
    //

    ASSERT(IoGetTopLevelIrp() == NULL);

    IoSetTopLevelIrp((PIRP)FSRTL_CACHE_TOP_LEVEL_IRP);

    return TRUE;
}


VOID
FatReleaseFcbFromLazyWrite (
    IN PVOID Fcb
    )

/*++

Routine Description:

    The address of this routine is specified when creating a CacheMap for
    a file.  It is subsequently called by the Lazy Writer after its
    performing lazy writes to the file.

Arguments:

    Fcb - The Fcb which was specified as a context parameter for this
          routine.

Return Value:

    None

--*/

{
    //
    //  Assert that this really is an fcb and that this thread really owns
    //  the lazy writer mark in the fcb.
    //

    ASSERT( NodeType(((PFCB)Fcb)) == FAT_NTC_FCB );
    ASSERT( NULL != PsGetCurrentThread() );
    ASSERT( ((PFCB)Fcb)->Specific.Fcb.LazyWriteThread == PsGetCurrentThread() );

    //
    //  Release the lazy writer mark.
    //

    ((PFCB)Fcb)->Specific.Fcb.LazyWriteThread = NULL;

    //
    //  Check here for the EA File.  It turns out we needed the normal
    //  resource shared in this case.  Otherwise it was the PagingIoResource.
    //

    ExReleaseResourceLite( Fcb == ((PFCB)Fcb)->Vcb->EaFcb ?
                       ((PFCB)Fcb)->Header.Resource :
                       ((PFCB)Fcb)->Header.PagingIoResource );

    //
    //  Clear the kludge at this point.
    //

    ASSERT(IoGetTopLevelIrp() == (PIRP)FSRTL_CACHE_TOP_LEVEL_IRP);

    IoSetTopLevelIrp( NULL );

    return;
}


BOOLEAN
FatAcquireFcbForReadAhead (
    IN PVOID Fcb,
    IN BOOLEAN Wait
    )

/*++

Routine Description:

    The address of this routine is specified when creating a CacheMap for
    a file.  It is subsequently called by the Lazy Writer prior to its
    performing read ahead to the file.

Arguments:

    Fcb - The Fcb which was specified as a context parameter for this
          routine.

    Wait - TRUE if the caller is willing to block.

Return Value:

    FALSE - if Wait was specified as FALSE and blocking would have
            been required.  The Fcb is not acquired.

    TRUE - if the Fcb has been acquired

--*/

{
    //
    //  We acquire the normal file resource shared here to synchronize
    //  correctly with purges.
    //

    if (!ExAcquireResourceSharedLite( ((PFCB)Fcb)->Header.Resource,
                                  Wait )) {

        return FALSE;
    }

    //
    //  This is a kludge because Cc is really the top level.  We it
    //  enters the file system, we will think it is a resursive call
    //  and complete the request with hard errors or verify.  It will
    //  have to deal with them, somehow....
    //

    ASSERT(IoGetTopLevelIrp() == NULL);

    IoSetTopLevelIrp((PIRP)FSRTL_CACHE_TOP_LEVEL_IRP);

    return TRUE;
}


VOID
FatReleaseFcbFromReadAhead (
    IN PVOID Fcb
    )

/*++

Routine Description:

    The address of this routine is specified when creating a CacheMap for
    a file.  It is subsequently called by the Lazy Writer after its
    read ahead.

Arguments:

    Fcb - The Fcb which was specified as a context parameter for this
          routine.

Return Value:

    None

--*/

{
    //
    //  Clear the kludge at this point.
    //

    ASSERT(IoGetTopLevelIrp() == (PIRP)FSRTL_CACHE_TOP_LEVEL_IRP);

    IoSetTopLevelIrp( NULL );

    ExReleaseResourceLite( ((PFCB)Fcb)->Header.Resource );

    return;
}


NTSTATUS
FatAcquireForCcFlush (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PFCB Fcb;
    PCCB Ccb;
    PVCB Vcb;
    PFSRTL_COMMON_FCB_HEADER Header;
    TYPE_OF_OPEN Type;
    
    //
    //  Once again, the hack for making this look like
    //  a recursive call if needed. We cannot let ourselves
    //  verify under something that has resources held.
    //
    //  This value is good.  We should never try to acquire
    //  the file this way underneath of the cache.
    //

    ASSERT( IoGetTopLevelIrp() != (PIRP)FSRTL_CACHE_TOP_LEVEL_IRP );
    
    if (IoGetTopLevelIrp() == NULL) {
        
        IoSetTopLevelIrp((PIRP)FSRTL_CACHE_TOP_LEVEL_IRP);
    }

    //
    //  Time for some exposition.
    //
    //  Lockorder for FAT is main->bcb->pagingio. Invert this at your obvious peril.
    //  The default logic for AcquireForCcFlush breaks this since in writethrough
    //  unpinrepinned we will grab the bcb then Mm will use the callback (which
    //  orders us with respect to the MmCollidedFlushEvent) to help us. If for
    //  directories/ea we then grab the main we are out of order.
    //
    //  Fortunately, we do not need main. We only need paging - just look at the write
    //  path. This is basic pre-acquisition.
    //
    //  Regular files require both resources, and are safe since we never pin them.
    //

    Type = FatDecodeFileObject( FileObject, &Vcb, &Fcb, &Ccb );
    Header = (PFSRTL_COMMON_FCB_HEADER) FileObject->FsContext;

    if (Type < DirectoryFile) {
        
        if (Header->Resource) {
            
            if (!ExIsResourceAcquiredSharedLite( Header->Resource )) {
                
                ExAcquireResourceExclusiveLite( Header->Resource, TRUE );
            
            } else {
                
                ExAcquireResourceSharedLite( Header->Resource, TRUE );
            }
        }
    }

    if (Header->PagingIoResource) {
        
        ExAcquireResourceSharedLite( Header->PagingIoResource, TRUE );
    }
    
    return STATUS_SUCCESS;
}


NTSTATUS
FatReleaseForCcFlush (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PFCB Fcb;
    PCCB Ccb;
    PVCB Vcb;
    PFSRTL_COMMON_FCB_HEADER Header;
    TYPE_OF_OPEN Type;
    
    //
    //  Clear up our hint.
    //
    
    if (IoGetTopLevelIrp() == (PIRP)FSRTL_CACHE_TOP_LEVEL_IRP) {

        IoSetTopLevelIrp( NULL );
    }

    Type = FatDecodeFileObject( FileObject, &Vcb, &Fcb, &Ccb );
    Header = (PFSRTL_COMMON_FCB_HEADER) FileObject->FsContext;

    if (Type < DirectoryFile) {
        
        if (Header->Resource) {
            
            ExReleaseResourceLite( Header->Resource );
        }
    }

    if (Header->PagingIoResource) {
        
        ExReleaseResourceLite( Header->PagingIoResource );
    }

    return STATUS_SUCCESS;
}


BOOLEAN
FatNoOpAcquire (
    IN PVOID Fcb,
    IN BOOLEAN Wait
    )

/*++

Routine Description:

    This routine does nothing.

Arguments:

    Fcb - The Fcb/Dcb/Vcb which was specified as a context parameter for this
          routine.

    Wait - TRUE if the caller is willing to block.

Return Value:

    TRUE

--*/

{
    UNREFERENCED_PARAMETER( Fcb );
    UNREFERENCED_PARAMETER( Wait );

    //
    //  This is a kludge because Cc is really the top level.  We it
    //  enters the file system, we will think it is a resursive call
    //  and complete the request with hard errors or verify.  It will
    //  have to deal with them, somehow....
    //

    ASSERT(IoGetTopLevelIrp() == NULL);

    IoSetTopLevelIrp((PIRP)FSRTL_CACHE_TOP_LEVEL_IRP);

    return TRUE;
}


VOID
FatNoOpRelease (
    IN PVOID Fcb
    )

/*++

Routine Description:

    This routine does nothing.

Arguments:

    Fcb - The Fcb/Dcb/Vcb which was specified as a context parameter for this
          routine.

Return Value:

    None

--*/

{
    //
    //  Clear the kludge at this point.
    //

    ASSERT(IoGetTopLevelIrp() == (PIRP)FSRTL_CACHE_TOP_LEVEL_IRP);

    IoSetTopLevelIrp( NULL );

    UNREFERENCED_PARAMETER( Fcb );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fastfat\pnp.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    Pnp.c

Abstract:

    This module implements the Plug and Play routines for FAT called by
    the dispatch driver.

// @@BEGIN_DDKSPLIT

Author:

    Dan Lovinger    [DanLo]     23-Jul-1997

Revision History:

// @@END_DDKSPLIT

--*/

#include "FatProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (FAT_BUG_CHECK_PNP)

NTSTATUS
FatPnpQueryRemove (
    PIRP_CONTEXT IrpContext,
    PIRP Irp,
    PVCB Vcb
    );

NTSTATUS
FatPnpRemove (
    PIRP_CONTEXT IrpContext,
    PIRP Irp,
    PVCB Vcb
    );

NTSTATUS
FatPnpSurpriseRemove (
    PIRP_CONTEXT IrpContext,
    PIRP Irp,
    PVCB Vcb
    );

NTSTATUS
FatPnpCancelRemove (
    PIRP_CONTEXT IrpContext,
    PIRP Irp,
    PVCB Vcb
    );

NTSTATUS
FatPnpCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FatCommonPnp)
#pragma alloc_text(PAGE, FatFsdPnp)
#pragma alloc_text(PAGE, FatPnpCancelRemove)
#pragma alloc_text(PAGE, FatPnpQueryRemove)
#pragma alloc_text(PAGE, FatPnpRemove)
#pragma alloc_text(PAGE, FatPnpSurpriseRemove)
#endif


NTSTATUS
FatFsdPnp (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of PnP operations

Arguments:

    VolumeDeviceObject - Supplies the volume device object where the
        file exists

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The FSD status for the IRP

--*/

{
    NTSTATUS Status;
    PIRP_CONTEXT IrpContext = NULL;

    BOOLEAN TopLevel;
    BOOLEAN Wait;

    DebugTrace(+1, Dbg, "FatFsdPnp\n", 0);

    FsRtlEnterFileSystem();

    TopLevel = FatIsIrpTopLevel( Irp );

    try {

        //
        //  We expect there to never be a fileobject, in which case we will always
        //  wait.  Since at the moment we don't have any concept of pending Pnp
        //  operations, this is a bit nitpicky.
        //
        
        if (IoGetCurrentIrpStackLocation( Irp )->FileObject == NULL) {

            Wait = TRUE;

        } else {

            Wait = CanFsdWait( Irp );
        }

        IrpContext = FatCreateIrpContext( Irp, Wait );

        Status = FatCommonPnp( IrpContext, Irp );

    } except(FatExceptionFilter( IrpContext, GetExceptionInformation() )) {

        //
        //  We had some trouble trying to perform the requested
        //  operation, so we'll abort the I/O request with
        //  the error status that we get back from the
        //  execption code
        //

        Status = FatProcessException( IrpContext, Irp, GetExceptionCode() );
    }

    if (TopLevel) { IoSetTopLevelIrp( NULL ); }

    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "FatFsdPnp -> %08lx\n", Status);

    UNREFERENCED_PARAMETER( VolumeDeviceObject );

    return Status;
}


NTSTATUS
FatCommonPnp (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for doing PnP operations called
    by both the fsd and fsp threads

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    
    PIO_STACK_LOCATION IrpSp;

    PVOLUME_DEVICE_OBJECT OurDeviceObject;
    PVCB Vcb;

    //
    //  Get the current Irp stack location.
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Find our Vcb.  This is tricky since we have no file object in the Irp.
    //

    OurDeviceObject = (PVOLUME_DEVICE_OBJECT) IrpSp->DeviceObject;

    //
    //  Make sure this device object really is big enough to be a volume device
    //  object.  If it isn't, we need to get out before we try to reference some
    //  field that takes us past the end of an ordinary device object.
    //
    
    if (OurDeviceObject->DeviceObject.Size != sizeof(VOLUME_DEVICE_OBJECT) ||
        NodeType( &OurDeviceObject->Vcb ) != FAT_NTC_VCB) {
        
        //
        //  We were called with something we don't understand.
        //
        
        Status = STATUS_INVALID_PARAMETER;
        FatCompleteRequest( IrpContext, Irp, Status );
        return Status;
    }

    //
    //  Force everything to wait.
    //

    SetFlag(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT);
    
    Vcb = &OurDeviceObject->Vcb;

    //
    //  Case on the minor code.
    //
    
    switch ( IrpSp->MinorFunction ) {

        case IRP_MN_QUERY_REMOVE_DEVICE:
            
            Status = FatPnpQueryRemove( IrpContext, Irp, Vcb );
            break;
        
        case IRP_MN_SURPRISE_REMOVAL:
        
            Status = FatPnpSurpriseRemove( IrpContext, Irp, Vcb );
            break;

        case IRP_MN_REMOVE_DEVICE:

            Status = FatPnpRemove( IrpContext, Irp, Vcb );
            break;

        case IRP_MN_CANCEL_REMOVE_DEVICE:
    
            Status = FatPnpCancelRemove( IrpContext, Irp, Vcb );
            break;

        default:
    
            //
            //  Just pass the IRP on.  As we do not need to be in the
            //  way on return, ellide ourselves out of the stack.
            //
            
            IoSkipCurrentIrpStackLocation( Irp );
    
            Status = IoCallDriver(Vcb->TargetDeviceObject, Irp);
            
            //
            //  Cleanup our Irp Context.  The driver has completed the Irp.
            //
        
            FatCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );
            
            break;
    }
        
    return Status;
}


NTSTATUS
FatPnpQueryRemove (
    PIRP_CONTEXT IrpContext,
    PIRP Irp,
    PVCB Vcb
    )

/*++

Routine Description:

    This routine handles the PnP query remove operation.  The filesystem
    is responsible for answering whether there are any reasons it sees
    that the volume can not go away (and the device removed).  Initiation
    of the dismount begins when we answer yes to this question.
    
    Query will be followed by a Cancel or Remove.

Arguments:

    Irp - Supplies the Irp to process
    
    Vcb - Supplies the volume being queried.

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    KEVENT Event;
    BOOLEAN VcbDeleted = FALSE;
    BOOLEAN GlobalHeld = FALSE;

    //
    //  Having said yes to a QUERY, any communication with the
    //  underlying storage stack is undefined (and may block)
    //  until the bounding CANCEL or REMOVE is sent.
    //

    //
    //  Acquire the global resource so that we can try to vaporize
    //  the volume, and the vcb resource itself.
    //
    
    FatAcquireExclusiveVcb( IrpContext, Vcb );

    try {
        
        Status = FatLockVolumeInternal( IrpContext, Vcb, NULL );

        //
        //  Reacquire the resources in the right order.
        //

        FatReleaseVcb( IrpContext, Vcb );
        FatAcquireExclusiveGlobal( IrpContext );
        GlobalHeld = TRUE;
        FatAcquireExclusiveVcb( IrpContext, Vcb );

        if (NT_SUCCESS( Status )) {

            //
            //  With the volume held locked, note that we must finalize as much
            //  as possible right now.
            //

            FatFlushAndCleanVolume( IrpContext, Irp, Vcb, Flush );

            //
            //  We need to pass this down before starting the dismount, which
            //  could disconnect us immediately from the stack.
            //

            //
            //  Get the next stack location, and copy over the stack location
            //

            IoCopyCurrentIrpStackLocationToNext( Irp );

            //
            //  Set up the completion routine
            //

            KeInitializeEvent( &Event, NotificationEvent, FALSE );
            IoSetCompletionRoutine( Irp,
                                    FatPnpCompletionRoutine,
                                    &Event,
                                    TRUE,
                                    TRUE,
                                    TRUE );

            //
            //  Send the request and wait.
            //

            Status = IoCallDriver(Vcb->TargetDeviceObject, Irp);

            if (Status == STATUS_PENDING) {

                KeWaitForSingleObject( &Event,
                                       Executive,
                                       KernelMode,
                                       FALSE,
                                       NULL );

                Status = Irp->IoStatus.Status;
            }

            //
            //  Now if no one below us failed already, initiate the dismount
            //  on this volume, make it go away.  PnP needs to see our internal
            //  streams close and drop their references to the target device.
            //
            //  Since we were able to lock the volume, we are guaranteed to
            //  move this volume into dismount state and disconnect it from
            //  the underlying storage stack.  The force on our part is actually
            //  unnecesary, though complete.
            //
            //  What is not strictly guaranteed, though, is that the closes
            //  for the metadata streams take effect synchronously underneath
            //  of this call.  This would leave references on the target device
            //  even though we are disconnected!
            //

            if (NT_SUCCESS( Status )) {

                VcbDeleted = FatCheckForDismount( IrpContext, Vcb, TRUE );

                ASSERT( VcbDeleted || Vcb->VcbCondition == VcbBad );

            }
        }

        //
        //  Release the Vcb if it could still remain.
        //
        //  Note: if everything else succeeded and the Vcb is persistent because the
        //  internal streams did not vaporize, we really need to pend this IRP off on
        //  the side until the dismount is completed.  I can't think of a reasonable
        //  case (in FAT) where this would actually happen, though it might still need
        //  to be implemented.
        //
        //  The reason this is the case is that handles/fileobjects place a reference
        //  on the device objects they overly.  In the filesystem case, these references
        //  are on our target devices.  PnP correcly thinks that if references remain
        //  on the device objects in the stack that someone has a handle, and that this
        //  counts as a reason to not succeed the query - even though every interrogated
        //  driver thinks that it is OK.
        //

        ASSERT( !(NT_SUCCESS( Status ) && !VcbDeleted ));

    } finally {
        
        if (!VcbDeleted) {

            FatReleaseVcb( IrpContext, Vcb );
        }

        if (GlobalHeld) {
            
            FatReleaseGlobal( IrpContext );
        }
    }
    
    //
    //  Cleanup our IrpContext and complete the IRP if neccesary.
    //

    FatCompleteRequest( IrpContext, Irp, Status );

    return Status;
}


NTSTATUS
FatPnpRemove (
    PIRP_CONTEXT IrpContext,
    PIRP Irp,
    PVCB Vcb
    )

/*++

Routine Description:

    This routine handles the PnP remove operation.  This is our notification
    that the underlying storage device for the volume we have is gone, and
    an excellent indication that the volume will never reappear. The filesystem
    is responsible for initiation or completion of the dismount.
    
Arguments:

    Irp - Supplies the Irp to process
    
    Vcb - Supplies the volume being removed.

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    KEVENT Event;
    BOOLEAN VcbDeleted;
    
    //
    //  REMOVE - a storage device is now gone.  We either got
    //  QUERY'd and said yes OR got a SURPRISE OR a storage
    //  stack failed to spin back up from a sleep/stop state
    //  (the only case in which this will be the first warning).
    //
    //  Note that it is entirely unlikely that we will be around
    //  for a REMOVE in the first two cases, as we try to intiate
    //  dismount.
    //
    
    //
    //  Acquire the global resource so that we can try to vaporize
    //  the volume, and the vcb resource itself.
    //

    FatAcquireExclusiveGlobal( IrpContext );
    FatAcquireExclusiveVcb( IrpContext, Vcb );

    //
    //  The device will be going away.  Remove our lock (benign
    //  if we never had it).
    //

    (VOID) FatUnlockVolumeInternal( IrpContext, Vcb, NULL );
    
    //
    //  We need to pass this down before starting the dismount, which
    //  could disconnect us immediately from the stack.
    //
    
    //
    //  Get the next stack location, and copy over the stack location
    //

    IoCopyCurrentIrpStackLocationToNext( Irp );

    //
    //  Set up the completion routine
    //

    KeInitializeEvent( &Event, NotificationEvent, FALSE );
    IoSetCompletionRoutine( Irp,
                            FatPnpCompletionRoutine,
                            &Event,
                            TRUE,
                            TRUE,
                            TRUE );

    //
    //  Send the request and wait.
    //

    Status = IoCallDriver(Vcb->TargetDeviceObject, Irp);

    if (Status == STATUS_PENDING) {

        KeWaitForSingleObject( &Event,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );

        Status = Irp->IoStatus.Status;
    }

    try {
        
        //
        //  Knock as many files down for this volume as we can.
        //

        FatFlushAndCleanVolume( IrpContext, Irp, Vcb, NoFlush );

        //
        //  Now make our dismount happen.  This may not vaporize the
        //  Vcb, of course, since there could be any number of handles
        //  outstanding if we were not preceeded by a QUERY.
        //
        //  PnP will take care of disconnecting this stack if we
        //  couldn't get off of it immediately.
        //

        VcbDeleted = FatCheckForDismount( IrpContext, Vcb, TRUE );

    } finally {
        
        //
        //  Release the Vcb if it could still remain.
        //

        if (!VcbDeleted) {

            FatReleaseVcb( IrpContext, Vcb );
        }

        FatReleaseGlobal( IrpContext );
    }

    //
    //  Cleanup our IrpContext and complete the IRP.
    //

    FatCompleteRequest( IrpContext, Irp, Status );

    return Status;
}


NTSTATUS
FatPnpSurpriseRemove (
    PIRP_CONTEXT IrpContext,
    PIRP Irp,
    PVCB Vcb
    )

/*++

Routine Description:

    This routine handles the PnP surprise remove operation.  This is another
    type of notification that the underlying storage device for the volume we
    have is gone, and is excellent indication that the volume will never reappear.
    The filesystem is responsible for initiation or completion the dismount.
    
    For the most part, only "real" drivers care about the distinction of a
    surprise remove, which is a result of our noticing that a user (usually)
    physically reached into the machine and pulled something out.
    
    Surprise will be followed by a Remove when all references have been shut down.

Arguments:

    Irp - Supplies the Irp to process
    
    Vcb - Supplies the volume being removed.

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    KEVENT Event;
    BOOLEAN VcbDeleted;
    
    //
    //  SURPRISE - a device was physically yanked away without
    //  any warning.  This means external forces.
    //
    
    FatAcquireExclusiveGlobal( IrpContext );
    FatAcquireExclusiveVcb( IrpContext, Vcb );
        
    //
    //  We need to pass this down before starting the dismount, which
    //  could disconnect us immediately from the stack.
    //
    
    //
    //  Get the next stack location, and copy over the stack location
    //

    IoCopyCurrentIrpStackLocationToNext( Irp );

    //
    //  Set up the completion routine
    //

    KeInitializeEvent( &Event, NotificationEvent, FALSE );
    IoSetCompletionRoutine( Irp,
                            FatPnpCompletionRoutine,
                            &Event,
                            TRUE,
                            TRUE,
                            TRUE );

    //
    //  Send the request and wait.
    //

    Status = IoCallDriver(Vcb->TargetDeviceObject, Irp);

    if (Status == STATUS_PENDING) {

        KeWaitForSingleObject( &Event,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );

        Status = Irp->IoStatus.Status;
    }
    
    try {
        
        //
        //  Knock as many files down for this volume as we can.
        //

        FatFlushAndCleanVolume( IrpContext, Irp, Vcb, NoFlush );

        //
        //  Now make our dismount happen.  This may not vaporize the
        //  Vcb, of course, since there could be any number of handles
        //  outstanding since this is an out of band notification.
        //

        VcbDeleted = FatCheckForDismount( IrpContext, Vcb, TRUE );

    } finally {
        
        //
        //  Release the Vcb if it could still remain.
        //

        if (!VcbDeleted) {

            FatReleaseVcb( IrpContext, Vcb );
        }

        FatReleaseGlobal( IrpContext );
    }
    
    //
    //  Cleanup our IrpContext and complete the IRP.
    //

    FatCompleteRequest( IrpContext, Irp, Status );

    return Status;
}


NTSTATUS
FatPnpCancelRemove (
    PIRP_CONTEXT IrpContext,
    PIRP Irp,
    PVCB Vcb
    )

/*++

Routine Description:

    This routine handles the PnP cancel remove operation.  This is our
    notification that a previously proposed remove (query) was eventually
    vetoed by a component.  The filesystem is responsible for cleaning up
    and getting ready for more IO.
    
Arguments:

    Irp - Supplies the Irp to process
    
    Vcb - Supplies the volume being removed.

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;

    //
    //  CANCEL - a previous QUERY has been rescinded as a result
    //  of someone vetoing.  Since PnP cannot figure out who may
    //  have gotten the QUERY (think about it: stacked drivers),
    //  we must expect to deal with getting a CANCEL without having
    //  seen the QUERY.
    //
    //  For FAT, this is quite easy.  In fact, we can't get a
    //  CANCEL if the underlying drivers succeeded the QUERY since
    //  we disconnect the Vpb on our dismount initiation.  This is
    //  actually pretty important because if PnP could get to us
    //  after the disconnect we'd be thoroughly unsynchronized
    //  with respect to the Vcb getting torn apart - merely referencing
    //  the volume device object is insufficient to keep us intact.
    //
    
    FatAcquireExclusiveVcb( IrpContext, Vcb );
    
    //
    //  Unlock the volume.  This is benign if we never had seen
    //  a QUERY.
    //

    Status = FatUnlockVolumeInternal( IrpContext, Vcb, NULL );

    try {
        
        //
        //  We must re-enable allocation support if we got through
        //  the first stages of a QUERY_REMOVE; i.e., we decided we
        //  could place a lock on the volume.
        //

        if (NT_SUCCESS( Status )) {

            FatSetupAllocationSupport( IrpContext, Vcb );
        }
    
    } finally {
        
        FatReleaseVcb( IrpContext, Vcb );
    }

    //
    //  Send the request.  The underlying driver will complete the
    //  IRP.  Since we don't need to be in the way, simply ellide
    //  ourselves out of the IRP stack.
    //

    IoSkipCurrentIrpStackLocation( Irp );

    Status = IoCallDriver(Vcb->TargetDeviceObject, Irp);

    FatCompleteRequest( IrpContext, NULL, STATUS_SUCCESS );

    return Status;
}


//
//  Local support routine
//

NTSTATUS
FatPnpCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    )
{
    PKEVENT Event = (PKEVENT) Contxt;

    KeSetEvent( Event, 0, FALSE );

    return STATUS_MORE_PROCESSING_REQUIRED;

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Contxt );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fastfat\shutdown.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    Shutdown.c

Abstract:

    This module implements the file system shutdown routine for Fat

// @@BEGIN_DDKSPLIT

Author:

    Gary Kimura     [GaryKi]    19-Aug-1991

Revision History:

// @@END_DDKSPLIT

--*/

#include "FatProcs.h"

//
//  Local debug trace level
//

#define Dbg                              (DEBUG_TRACE_SHUTDOWN)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FatCommonShutdown)
#pragma alloc_text(PAGE, FatFsdShutdown)
#endif


NTSTATUS
FatFsdShutdown (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of shutdown.  Note that Shutdown will
    never be done asynchronously so we will never need the Fsp counterpart
    to shutdown.

    This is the shutdown routine for the Fat file system device driver.
    This routine locks the global file system lock and then syncs all the
    mounted volumes.

Arguments:

    VolumeDeviceObject - Supplies the volume device object where the
        file exists

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - Always STATUS_SUCCESS

--*/

{
    NTSTATUS Status;
    PIRP_CONTEXT IrpContext = NULL;

    BOOLEAN TopLevel;

    DebugTrace(+1, Dbg, "FatFsdShutdown\n", 0);

    //
    //  Call the common shutdown routine.
    //

    FsRtlEnterFileSystem();

    TopLevel = FatIsIrpTopLevel( Irp );

    try {

        IrpContext = FatCreateIrpContext( Irp, TRUE );

        Status = FatCommonShutdown( IrpContext, Irp );

    } except(FatExceptionFilter( IrpContext, GetExceptionInformation() )) {

        //
        //  We had some trouble trying to perform the requested
        //  operation, so we'll abort the I/O request with
        //  the error status that we get back from the
        //  execption code
        //

        Status = FatProcessException( IrpContext, Irp, GetExceptionCode() );
    }

    if (TopLevel) { IoSetTopLevelIrp( NULL ); }

    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "FatFsdShutdown -> %08lx\n", Status);

    UNREFERENCED_PARAMETER( VolumeDeviceObject );

    return Status;
}


NTSTATUS
FatCommonShutdown (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for shutdown called by both the fsd and
    fsp threads.

Arguments:

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    PKEVENT Event;

    PLIST_ENTRY Links;
    PVCB Vcb;
    PIRP NewIrp;
    IO_STATUS_BLOCK Iosb;

    //
    //  Make sure we don't get any pop-ups, and write everything through.
    //

    SetFlag(IrpContext->Flags, IRP_CONTEXT_FLAG_DISABLE_POPUPS |
                               IRP_CONTEXT_FLAG_WRITE_THROUGH);

    //
    //  Allocate an initialize an event for doing calls down to
    //  our target deivce objects
    //

    Event = FsRtlAllocatePoolWithTag( NonPagedPool,
                                      sizeof(KEVENT),
                                      TAG_EVENT );
    KeInitializeEvent( Event, NotificationEvent, FALSE );

    //
    //  Indicate that shutdown has started.  This is used in FatFspClose.
    //

    FatData.ShutdownStarted = TRUE;    

    //
    //  Get everyone else out of the way
    //

    (VOID) FatAcquireExclusiveGlobal( IrpContext );

    try {

        //
        //  For every volume that is mounted we will flush the
        //  volume and then shutdown the target device objects.
        //

        Links = FatData.VcbQueue.Flink;
        while (Links != &FatData.VcbQueue) {

            Vcb = CONTAINING_RECORD(Links, VCB, VcbLinks);

            Links = Links->Flink;

            //
            //  If we have already been called before for this volume
            //  (and yes this does happen), skip this volume as no writes
            //  have been allowed since the first shutdown.
            //

            if ( FlagOn( Vcb->VcbState, VCB_STATE_FLAG_SHUTDOWN) ||
                 (Vcb->VcbCondition != VcbGood) ) {

                continue;
            }

            FatAcquireExclusiveVolume( IrpContext, Vcb );

            try {

                (VOID)FatFlushVolume( IrpContext, Vcb, Flush );

                //
                //  The volume is now clean, note it.  We purge the
                //  volume file cache map before marking the volume
                //  clean incase there is a stale Bpb in the cache.
                //

                if (!FlagOn(Vcb->VcbState, VCB_STATE_FLAG_MOUNTED_DIRTY)) {

                    CcPurgeCacheSection( &Vcb->SectionObjectPointers,
                                         NULL,
                                         0,
                                         FALSE );

                    FatMarkVolume( IrpContext, Vcb, VolumeClean );
                }

            } except( EXCEPTION_EXECUTE_HANDLER ) {

                  FatResetExceptionState( IrpContext );
            }

            //
            //  Sometimes we take an excepion while flushing the volume, such
            //  as when autoconv has converted the volume and is rebooting.
            //  Even in that case we want to send the shutdown irp to the
            //  target device so it can know to flush its cache, if it has one.
            //

            try {

                NewIrp = IoBuildSynchronousFsdRequest( IRP_MJ_SHUTDOWN,
                                                       Vcb->TargetDeviceObject,
                                                       NULL,
                                                       0,
                                                       NULL,
                                                       Event,
                                                       &Iosb );

                if (NewIrp != NULL) {

                    if (NT_SUCCESS(IoCallDriver( Vcb->TargetDeviceObject, NewIrp ))) {

                        (VOID) KeWaitForSingleObject( Event,
                                                      Executive,
                                                      KernelMode,
                                                      FALSE,
                                                      NULL );

                        KeClearEvent( Event );
                    }
                }

            } except( EXCEPTION_EXECUTE_HANDLER ) {

                  FatResetExceptionState( IrpContext );
            }

            SetFlag( Vcb->VcbState, VCB_STATE_FLAG_SHUTDOWN );

            FatReleaseVolume( IrpContext, Vcb );

            //
            //  Attempt to punch the volume down.
            //

            if (!FatCheckForDismount( IrpContext, Vcb, FALSE )) {
                
                FatFspClose( NULL );
            }
        }

    } finally {

        ExFreePool( Event );

        FatReleaseGlobal( IrpContext );

        //
        // Unregister the file system.
        //
        
        IoUnregisterFileSystem( FatDiskFileSystemDeviceObject);
        IoUnregisterFileSystem( FatCdromFileSystemDeviceObject);
        IoDeleteDevice( FatDiskFileSystemDeviceObject);
        IoDeleteDevice( FatCdromFileSystemDeviceObject);

        FatCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
    }

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "FatFsdShutdown -> STATUS_SUCCESS\n", 0);

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fastfat\sources.inc ===
INCLUDES=..;$(PROJECT_ROOT)\ntos\inc

NTPROFILEINPUT=yes

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\AcChkSup.c \
        ..\AllocSup.c \
        ..\CacheSup.c \
        ..\Cleanup.c  \
        ..\Close.c    \
        ..\Create.c   \
        ..\DevCtrl.c  \
        ..\DevIoSup.c \
        ..\DirCtrl.c  \
        ..\DirSup.c   \
        ..\DumpSup.c  \
        ..\Ea.c       \
        ..\EaSup.c    \
        ..\FastFat.rc \
        ..\FatData.c  \
        ..\FatInit.c  \
        ..\FileInfo.c \
        ..\FilObSup.c \
        ..\Flush.c    \
        ..\FsCtrl.c   \
        ..\FspDisp.c  \
        ..\LockCtrl.c \
        ..\NameSup.c  \
        ..\Pnp.c      \
        ..\Read.c     \
        ..\ResrcSup.c \
        ..\Shutdown.c \
        ..\StrucSup.c \
        ..\SplaySup.c \
        ..\TimeSup.c  \
        ..\VerfySup.c \
        ..\VolInfo.c  \
        ..\WorkQue.c  \
        ..\Write.c

PRECOMPILED_INCLUDE=..\fatprocs.h
PRECOMPILED_PCH=fatprocs.pch
PRECOMPILED_OBJ=fatprocs.obj

# @@BEGIN_DDKSPLIT
MISCFILES=..\fastfat.sld
# @@END_DDKSPLIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fastfat\timesup.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    TimeSup.c

Abstract:

    This module implements the Fat Time conversion support routines

// @@BEGIN_DDKSPLIT

Author:

    Gary Kimura     [GaryKi]    19-Feb-1990

Revision History:

// @@END_DDKSPLIT

--*/

#include "FatProcs.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FatNtTimeToFatTime)
#pragma alloc_text(PAGE, FatFatDateToNtTime)
#pragma alloc_text(PAGE, FatFatTimeToNtTime)
#pragma alloc_text(PAGE, FatGetCurrentFatTime)
#endif

BOOLEAN
FatNtTimeToFatTime (
    IN PIRP_CONTEXT IrpContext,
    IN PLARGE_INTEGER NtTime,
    IN BOOLEAN Rounding,
    OUT PFAT_TIME_STAMP FatTime,
    OUT OPTIONAL PCHAR TenMsecs
    )

/*++

Routine Description:

    This routine converts an NtTime value to its corresponding Fat time value.

Arguments:

    NtTime - Supplies the Nt GMT Time value to convert from

    Rounding - Indicates whether the NT time should be rounded up to a FAT boundary.
        This should only be done *once* in the lifetime of a timestamp (important
        for tunneling, which will cause a timestamp to pass through at least twice).
        If true, rounded up. If false, rounded down to 10ms boundary. This obeys
        the rules for non-creation time and creation times (respectively).

    FatTime - Receives the equivalent Fat time value

    TenMsecs - Optionally receive the number of tens of milliseconds the NtTime, after
        any rounding, is greater than the FatTime

Return Value:

    BOOLEAN - TRUE if the Nt time value is within the range of Fat's
        time range, and FALSE otherwise

--*/

{
    TIME_FIELDS TimeFields;

    //
    //  Convert the input to the a time field record.
    //

    if (Rounding) {

        //
        //   Add almost two seconds to round up to the nearest double second.
        //
    
        NtTime->QuadPart = NtTime->QuadPart + AlmostTwoSeconds;
    }

    ExSystemTimeToLocalTime( NtTime, NtTime );

    RtlTimeToTimeFields( NtTime, &TimeFields );

    //
    //  Check the range of the date found in the time field record
    //

    if ((TimeFields.Year < 1980) || (TimeFields.Year > (1980 + 127))) {

        ExLocalTimeToSystemTime( NtTime, NtTime );

        return FALSE;
    }

    //
    //  The year will fit in Fat so simply copy over the information
    //

    FatTime->Time.DoubleSeconds = (USHORT)(TimeFields.Second / 2);
    FatTime->Time.Minute        = (USHORT)(TimeFields.Minute);
    FatTime->Time.Hour          = (USHORT)(TimeFields.Hour);

    FatTime->Date.Year          = (USHORT)(TimeFields.Year - 1980);
    FatTime->Date.Month         = (USHORT)(TimeFields.Month);
    FatTime->Date.Day           = (USHORT)(TimeFields.Day);

    if (TenMsecs) {

        if (!Rounding) {

            //
            //  If the number of seconds was not divisible by two, then there
            //  is another second of time (1 sec, 3 sec, etc.) Note we round down
            //  the number of milleconds onto tens of milleseconds boundaries.
            //

            *TenMsecs = (TimeFields.Milliseconds / 10) +
                ((TimeFields.Second % 2) * 100);

        } else {

            //
            //  If we rounded up, we have in effect changed the NT time. Therefore,
            //  it does not differ from the FAT time.
            //

            *TenMsecs = 0;
        }
    }

    if (Rounding) {

        //
        //  Slice off non-FAT boundary time and convert back to 64bit form
        //

        TimeFields.Milliseconds = 0;
        TimeFields.Second -= TimeFields.Second % 2;

    } else {

        //
        //  Round down to 10ms boundary
        //

        TimeFields.Milliseconds -= TimeFields.Milliseconds % 10;
    }

    //
    //  Convert back to NT time
    //

    (VOID) RtlTimeFieldsToTime(&TimeFields, NtTime);

    ExLocalTimeToSystemTime( NtTime, NtTime );

    UNREFERENCED_PARAMETER( IrpContext );

    return TRUE;
}


LARGE_INTEGER
FatFatDateToNtTime (
    IN PIRP_CONTEXT IrpContext,
    IN FAT_DATE FatDate
    )

/*++

Routine Description:

    This routine converts a Fat datev value to its corresponding Nt GMT
    Time value.

Arguments:

    FatDate - Supplies the Fat Date to convert from

Return Value:

    LARGE_INTEGER - Receives the corresponding Nt Time value

--*/

{
    TIME_FIELDS TimeFields;
    LARGE_INTEGER Time;

    //
    //  Pack the input time/date into a time field record
    //

    TimeFields.Year         = (USHORT)(FatDate.Year + 1980);
    TimeFields.Month        = (USHORT)(FatDate.Month);
    TimeFields.Day          = (USHORT)(FatDate.Day);
    TimeFields.Hour         = (USHORT)0;
    TimeFields.Minute       = (USHORT)0;
    TimeFields.Second       = (USHORT)0;
    TimeFields.Milliseconds = (USHORT)0;

    //
    //  Convert the time field record to Nt LARGE_INTEGER, and set it to zero
    //  if we were given a bogus time.
    //

    if (!RtlTimeFieldsToTime( &TimeFields, &Time )) {

        Time.LowPart = 0;
        Time.HighPart = 0;

    } else {

        ExLocalTimeToSystemTime( &Time, &Time );
    }

    return Time;

    UNREFERENCED_PARAMETER( IrpContext );
}


LARGE_INTEGER
FatFatTimeToNtTime (
    IN PIRP_CONTEXT IrpContext,
    IN FAT_TIME_STAMP FatTime,
    IN UCHAR TenMilliSeconds
    )

/*++

Routine Description:

    This routine converts a Fat time value pair to its corresponding Nt GMT
    Time value.

Arguments:

    FatTime - Supplies the Fat Time to convert from

    TenMilliSeconds - A 10 Milisecond resolution

Return Value:

    LARGE_INTEGER - Receives the corresponding Nt GMT Time value

--*/

{
    TIME_FIELDS TimeFields;
    LARGE_INTEGER Time;

    //
    //  Pack the input time/date into a time field record
    //

    TimeFields.Year         = (USHORT)(FatTime.Date.Year + 1980);
    TimeFields.Month        = (USHORT)(FatTime.Date.Month);
    TimeFields.Day          = (USHORT)(FatTime.Date.Day);
    TimeFields.Hour         = (USHORT)(FatTime.Time.Hour);
    TimeFields.Minute       = (USHORT)(FatTime.Time.Minute);
    TimeFields.Second       = (USHORT)(FatTime.Time.DoubleSeconds * 2);

    if (TenMilliSeconds != 0) {

        TimeFields.Second      += (USHORT)(TenMilliSeconds / 100);
        TimeFields.Milliseconds = (USHORT)((TenMilliSeconds % 100) * 10);

    } else {

        TimeFields.Milliseconds = (USHORT)0;
    }

    //
    //  If the second value is greater than 59 then we truncate it to 0.
    //  Note that this can't happen with a proper FAT timestamp.
    //

    if (TimeFields.Second > 59) {

        TimeFields.Second = 0;
    }

    //
    //  Convert the time field record to Nt LARGE_INTEGER, and set it to zero
    //  if we were given a bogus time.
    //

    if (!RtlTimeFieldsToTime( &TimeFields, &Time )) {

        Time.LowPart = 0;
        Time.HighPart = 0;

    } else {

        ExLocalTimeToSystemTime( &Time, &Time );
    }

    return Time;

    UNREFERENCED_PARAMETER( IrpContext );
}


FAT_TIME_STAMP
FatGetCurrentFatTime (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine returns the current system time in Fat time

Arguments:

Return Value:

    FAT_TIME_STAMP - Receives the current system time

--*/

{
    LARGE_INTEGER Time;
    TIME_FIELDS TimeFields;
    FAT_TIME_STAMP FatTime;

    //
    //  Get the current system time, and map it into a time field record.
    //

    KeQuerySystemTime( &Time );

    ExSystemTimeToLocalTime( &Time, &Time );

    //
    //  Always add almost two seconds to round up to the nearest double second.
    //

    Time.QuadPart = Time.QuadPart + AlmostTwoSeconds;

    (VOID)RtlTimeToTimeFields( &Time, &TimeFields );

    //
    //  Now simply copy over the information
    //

    FatTime.Time.DoubleSeconds = (USHORT)(TimeFields.Second / 2);
    FatTime.Time.Minute        = (USHORT)(TimeFields.Minute);
    FatTime.Time.Hour          = (USHORT)(TimeFields.Hour);

    FatTime.Date.Year          = (USHORT)(TimeFields.Year - 1980);
    FatTime.Date.Month         = (USHORT)(TimeFields.Month);
    FatTime.Date.Day           = (USHORT)(TimeFields.Day);

    UNREFERENCED_PARAMETER( IrpContext );

    return FatTime;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fastfat\strucsup.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    StrucSup.c

Abstract:

    This module implements the Fat in-memory data structure manipulation
    routines

// @@BEGIN_DDKSPLIT

Author:

    Gary Kimura     [GaryKi]    22-Jan-1990

Revision History:

// @@END_DDKSPLIT

--*/

#include "FatProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (FAT_BUG_CHECK_STRUCSUP)

//
//  The debug trace level
//

#define Dbg                              (DEBUG_TRACE_STRUCSUP)

#define FillMemory(BUF,SIZ,MASK) {                          \
    ULONG i;                                                \
    for (i = 0; i < (((SIZ)/4) - 1); i += 2) {              \
        ((PULONG)(BUF))[i] = (MASK);                        \
        ((PULONG)(BUF))[i+1] = (ULONG)PsGetCurrentThread(); \
    }                                                       \
}

#define IRP_CONTEXT_HEADER (sizeof( IRP_CONTEXT ) * 0x10000 + FAT_NTC_IRP_CONTEXT)

//
//  Local macros.
//
//  Define our lookaside list allocators.  For the time being, and perhaps
//  permanently, the paged structures don't come off of lookasides.  This
//  is due to complications with clean unload as FAT can be in the paging
//  path, making it really hard to find the right time to empty them.
//
//  Fortunately, the hit rates on the Fcb/Ccb lists weren't stunning.
//

#define FAT_FILL_FREE 0

INLINE
PCCB
FatAllocateCcb (
    )
{
    return (PCCB) FsRtlAllocatePoolWithTag( PagedPool, sizeof(CCB), TAG_CCB );
}

INLINE
VOID
FatFreeCcb (
    IN PCCB Ccb
    )
{
#if FAT_FILL_FREE
    RtlFillMemoryUlong(Ccb, sizeof(CCB), FAT_FILL_FREE);
#endif

    ExFreePool( Ccb );
}

INLINE
PFCB
FatAllocateFcb (
    )
{
    return (PFCB) FsRtlAllocatePoolWithTag( PagedPool, sizeof(FCB), TAG_FCB );
}

INLINE
VOID
FatFreeFcb (
    IN PFCB Fcb
    )
{
#if FAT_FILL_FREE
    RtlFillMemoryUlong(Fcb, sizeof(FCB), FAT_FILL_FREE);
#endif

    ExFreePool( Fcb );
}

INLINE
PNON_PAGED_FCB
FatAllocateNonPagedFcb (
    )
{
    return (PNON_PAGED_FCB) ExAllocateFromNPagedLookasideList( &FatNonPagedFcbLookasideList );
}

INLINE
VOID
FatFreeNonPagedFcb (
    PNON_PAGED_FCB NonPagedFcb
    )
{
#if FAT_FILL_FREE
    RtlFillMemoryUlong(NonPagedFcb, sizeof(NON_PAGED_FCB), FAT_FILL_FREE);
#endif

    ExFreeToNPagedLookasideList( &FatNonPagedFcbLookasideList, (PVOID) NonPagedFcb );
}

INLINE
PERESOURCE
FatAllocateResource (
    )
{
    PERESOURCE Resource;

    Resource = (PERESOURCE) ExAllocateFromNPagedLookasideList( &FatEResourceLookasideList );

    ExInitializeResourceLite( Resource );

    return Resource;
}

INLINE
VOID
FatFreeResource (
    IN PERESOURCE Resource
    )
{
    ExDeleteResourceLite( Resource );

#if FAT_FILL_FREE
    RtlFillMemoryUlong(Resource, sizeof(ERESOURCE), FAT_FILL_FREE);
#endif

    ExFreeToNPagedLookasideList( &FatEResourceLookasideList, (PVOID) Resource );
}

INLINE
PIRP_CONTEXT
FatAllocateIrpContext (
    )
{
    return (PIRP_CONTEXT) ExAllocateFromNPagedLookasideList( &FatIrpContextLookasideList );
}

INLINE
VOID
FatFreeIrpContext (
    IN PIRP_CONTEXT IrpContext
    )
{
#if FAT_FILL_FREE
    RtlFillMemoryUlong(IrpContext, sizeof(IRP_CONTEXT), FAT_FILL_FREE);
#endif

    ExFreeToNPagedLookasideList( &FatIrpContextLookasideList, (PVOID) IrpContext );
}

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FatInitializeVcb)
#pragma alloc_text(PAGE, FatDeleteVcb)
#pragma alloc_text(PAGE, FatCreateRootDcb)
#pragma alloc_text(PAGE, FatCreateFcb)
#pragma alloc_text(PAGE, FatCreateDcb)
#pragma alloc_text(PAGE, FatDeleteFcb_Real)
#pragma alloc_text(PAGE, FatCreateCcb)
#pragma alloc_text(PAGE, FatDeallocateCcbStrings)
#pragma alloc_text(PAGE, FatDeleteCcb_Real)
#pragma alloc_text(PAGE, FatGetNextFcbTopDown)
#pragma alloc_text(PAGE, FatGetNextFcbBottomUp)
#pragma alloc_text(PAGE, FatConstructNamesInFcb)
#pragma alloc_text(PAGE, FatCheckFreeDirentBitmap)
#pragma alloc_text(PAGE, FatCreateIrpContext)
#pragma alloc_text(PAGE, FatDeleteIrpContext_Real)
#pragma alloc_text(PAGE, FatIsHandleCountZero)
#pragma alloc_text(PAGE, FatPreallocateCloseContext)
#endif


VOID
FatInitializeVcb (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PVCB Vcb,
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PVPB Vpb,
    IN PDEVICE_OBJECT FsDeviceObject
    )

/*++

Routine Description:

    This routine initializes and inserts a new Vcb record into the in-memory
    data structure.  The Vcb record "hangs" off the end of the Volume device
    object and must be allocated by our caller.

Arguments:

    Vcb - Supplies the address of the Vcb record being initialized.

    TargetDeviceObject - Supplies the address of the target device object to
        associate with the Vcb record.

    Vpb - Supplies the address of the Vpb to associate with the Vcb record.

    FsDeviceObject - The filesystem device object that the mount was directed
                     too.

Return Value:

    None.

--*/

{
    CC_FILE_SIZES FileSizes;
    PDEVICE_OBJECT RealDevice;
    LONG i;

    STORAGE_HOTPLUG_INFO HotplugInfo;
    NTSTATUS Status;

    //
    //  The following variables are used for abnormal unwind
    //

    PLIST_ENTRY UnwindEntryList = NULL;
    PERESOURCE UnwindResource = NULL;
    PERESOURCE UnwindResource2 = NULL;
    PFILE_OBJECT UnwindFileObject = NULL;
    PFILE_OBJECT UnwindCacheMap = NULL;
    BOOLEAN UnwindWeAllocatedMcb = FALSE;
    PFILE_SYSTEM_STATISTICS UnwindStatistics = NULL;

    DebugTrace(+1, Dbg, "FatInitializeVcb, Vcb = %08lx\n", Vcb);

    try {

        //
        //  We start by first zeroing out all of the VCB, this will guarantee
        //  that any stale data is wiped clean
        //

        RtlZeroMemory( Vcb, sizeof(VCB) );

        //
        //  Set the proper node type code and node byte size
        //

        Vcb->VolumeFileHeader.NodeTypeCode = FAT_NTC_VCB;
        Vcb->VolumeFileHeader.NodeByteSize = sizeof(VCB);

        //
        //  Initialize the tunneling cache
        //

        FsRtlInitializeTunnelCache(&Vcb->Tunnel);

        //
        //  Insert this Vcb record on the FatData.VcbQueue
        //

        ASSERT( FlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT) );

        (VOID)FatAcquireExclusiveGlobal( IrpContext );
        InsertTailList( &FatData.VcbQueue, &Vcb->VcbLinks );
        FatReleaseGlobal( IrpContext );
        UnwindEntryList = &Vcb->VcbLinks;

        //
        //  Set the Target Device Object, Vpb, and Vcb State fields
        //


        ObReferenceObject( TargetDeviceObject );
        Vcb->TargetDeviceObject = TargetDeviceObject;
        Vcb->Vpb = Vpb;

        Vcb->CurrentDevice = Vpb->RealDevice;

        //
        //  Set the removable media and defflush flags based on the storage
        //  inquiry and the old characteristic bits.
        //

        Status = FatPerformDevIoCtrl( IrpContext,
                                      IOCTL_STORAGE_GET_HOTPLUG_INFO,
                                      TargetDeviceObject,
                                      &HotplugInfo,
                                      sizeof(HotplugInfo),
                                      FALSE,
                                      TRUE,
                                      NULL );

        if (NT_SUCCESS( Status )) {

            if (HotplugInfo.MediaRemovable) {
                
                SetFlag( Vcb->VcbState, VCB_STATE_FLAG_REMOVABLE_MEDIA );
            }

            if (!HotplugInfo.WriteCacheEnableOverride) {

                //
                //  If the device or media is hotplug and the override is not
                //  set, force defflush behavior for the device.
                //

                if (HotplugInfo.MediaHotplug || HotplugInfo.DeviceHotplug) {

                    SetFlag( Vcb->VcbState, VCB_STATE_FLAG_DEFERRED_FLUSH );

                //
                //  Now, for removables that claim to be lockable, lob a lock
                //  request and see if it works.  There can unfortunately be
                //  transient, media dependent reasons that it can fail.  If
                //  it does not, we must force defflush on.
                //

                } else if (HotplugInfo.MediaRemovable &&
                           !HotplugInfo.MediaHotplug) {

                    Status = FatToggleMediaEjectDisable( IrpContext, Vcb, TRUE );

                    if (!NT_SUCCESS( Status )) {

                        SetFlag( Vcb->VcbState, VCB_STATE_FLAG_DEFERRED_FLUSH );

                    }
                    
                    Status = FatToggleMediaEjectDisable( IrpContext, Vcb, FALSE );
                }
            }
        }

        if (FlagOn(Vpb->RealDevice->Characteristics, FILE_REMOVABLE_MEDIA)) {
            
            SetFlag( Vcb->VcbState, VCB_STATE_FLAG_REMOVABLE_MEDIA );
        }

        //
        //  Make sure we turn on deferred flushing for floppies like we always
        //  have.
        //
        
        if (FlagOn(Vpb->RealDevice->Characteristics, FILE_FLOPPY_DISKETTE)) {
            
            SetFlag( Vcb->VcbState, VCB_STATE_FLAG_DEFERRED_FLUSH );
        }

        Vcb->VcbCondition = VcbGood;

        //
        //  Initialize the resource variable for the Vcb
        //

        ExInitializeResourceLite( &Vcb->Resource );
        UnwindResource = &Vcb->Resource;

        ExInitializeResourceLite( &Vcb->ChangeBitMapResource );
        UnwindResource2 = &Vcb->ChangeBitMapResource;

        //
        //  Initialize the free cluster bitmap mutex.
        //

        ExInitializeFastMutex( &Vcb->FreeClusterBitMapMutex );

        //
        //  Create the special file object for the virtual volume file with a close
        //  context, its pointers back to the Vcb and the section object pointer.
        //
        //  We don't have to unwind the close context.  That will happen in the close
        //  path automatically.
        //

        RealDevice = Vcb->CurrentDevice;

        Vcb->VirtualVolumeFile = UnwindFileObject = IoCreateStreamFileObject( NULL, RealDevice );
        FatPreallocateCloseContext();

        FatSetFileObject( Vcb->VirtualVolumeFile,
                          VirtualVolumeFile,
                          Vcb,
                          NULL );

        Vcb->VirtualVolumeFile->SectionObjectPointer = &Vcb->SectionObjectPointers;

        Vcb->VirtualVolumeFile->ReadAccess = TRUE;
        Vcb->VirtualVolumeFile->WriteAccess = TRUE;
        Vcb->VirtualVolumeFile->DeleteAccess = TRUE;

        //
        //  Initialize the notify structures.
        //

        InitializeListHead( &Vcb->DirNotifyList );

        FsRtlNotifyInitializeSync( &Vcb->NotifySync );

        //
        //  Initialize the Cache Map for the volume file.  The size is
        //  initially set to that of our first read.  It will be extended
        //  when we know how big the Fat is.
        //

        FileSizes.AllocationSize.QuadPart =
        FileSizes.FileSize.QuadPart = sizeof(PACKED_BOOT_SECTOR);
        FileSizes.ValidDataLength = FatMaxLarge;

        CcInitializeCacheMap( Vcb->VirtualVolumeFile,
                              &FileSizes,
                              TRUE,
                              &FatData.CacheManagerNoOpCallbacks,
                              Vcb );
        UnwindCacheMap = Vcb->VirtualVolumeFile;

        //
        //  Initialize the structure that will keep track of dirty fat sectors.
        //  The largest possible Mcb structures are less than 1K, so we use
        //  non paged pool.
        //

        FsRtlInitializeLargeMcb( &Vcb->DirtyFatMcb, PagedPool );

        UnwindWeAllocatedMcb = TRUE;

        //
        //  Set the cluster index hint to the first valid cluster of a fat: 2
        //

        Vcb->ClusterHint = 2;

        //
        //  Initialize the directory stream file object creation event.
        //  This event is also "borrowed" for async non-cached writes.
        //

        ExInitializeFastMutex( &Vcb->DirectoryFileCreationMutex );

        //
        //  Initialize the clean volume callback Timer and DPC.
        //

        KeInitializeTimer( &Vcb->CleanVolumeTimer );

        KeInitializeDpc( &Vcb->CleanVolumeDpc, FatCleanVolumeDpc, Vcb );

        //
        //  Initialize the performance counters.
        //

        Vcb->Statistics = FsRtlAllocatePoolWithTag( NonPagedPool,
                                                    sizeof(FILE_SYSTEM_STATISTICS) * KeNumberProcessors,
                                                    TAG_VCB_STATS );
        UnwindStatistics = Vcb->Statistics;

        RtlZeroMemory( Vcb->Statistics, sizeof(FILE_SYSTEM_STATISTICS) * KeNumberProcessors );

        for (i = 0; i < KeNumberProcessors; i += 1) {
            Vcb->Statistics[i].Common.FileSystemType = FILESYSTEM_STATISTICS_TYPE_FAT;
            Vcb->Statistics[i].Common.Version = 1;
            Vcb->Statistics[i].Common.SizeOfCompleteStructure =
                sizeof(FILE_SYSTEM_STATISTICS);
        }

        //
        //  Pick up a VPB right now so we know we can pull this filesystem stack off
        //  of the storage stack on demand.
        //

        Vcb->SwapVpb = FsRtlAllocatePoolWithTag( NonPagedPool,
                                                 sizeof( VPB ),
                                                 TAG_VPB );

        RtlZeroMemory( Vcb->SwapVpb, sizeof( VPB ) );

        //
        //  Initialize the close queue listheads.
        //

        InitializeListHead( &Vcb->AsyncCloseList );
        InitializeListHead( &Vcb->DelayedCloseList );

        //
        //  Initialize the Advanced FCB Header
        //

        ExInitializeFastMutex( &Vcb->AdvancedFcbHeaderMutex );
        FsRtlSetupAdvancedHeader( &Vcb->VolumeFileHeader, 
                                  &Vcb->AdvancedFcbHeaderMutex );

        //
        //  With the Vcb now set up, set the IrpContext Vcb field.
        //

        IrpContext->Vcb = Vcb;

    } finally {

        DebugUnwind( FatInitializeVcb );

        //
        //  If this is an abnormal termination then undo our work
        //

        if (AbnormalTermination()) {

            if (UnwindCacheMap != NULL) { FatSyncUninitializeCacheMap( IrpContext, UnwindCacheMap ); }
            if (UnwindFileObject != NULL) { ObDereferenceObject( UnwindFileObject ); }
            if (UnwindResource != NULL) { FatDeleteResource( UnwindResource ); }
            if (UnwindResource2 != NULL) { FatDeleteResource( UnwindResource2 ); }
            if (UnwindWeAllocatedMcb) { FsRtlUninitializeLargeMcb( &Vcb->DirtyFatMcb ); }
            if (UnwindEntryList != NULL) {
                (VOID)FatAcquireExclusiveGlobal( IrpContext );
                RemoveEntryList( UnwindEntryList );
                FatReleaseGlobal( IrpContext );
            }
            if (UnwindStatistics != NULL) { ExFreePool( UnwindStatistics ); }
        }

        DebugTrace(-1, Dbg, "FatInitializeVcb -> VOID\n", 0);
    }

    //
    //  and return to our caller
    //

    UNREFERENCED_PARAMETER( IrpContext );

    return;
}


VOID
FatDeleteVcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine removes the Vcb record from Fat's in-memory data
    structures.  It also will remove all associated underlings
    (i.e., FCB records).

Arguments:

    Vcb - Supplies the Vcb to be removed

Return Value:

    None

--*/

{
    PFCB Fcb;

    DebugTrace(+1, Dbg, "FatDeleteVcb, Vcb = %08lx\n", Vcb);

    //
    //  If the IrpContext points to the VCB being deleted NULL out the stail
    //  pointer.
    //

    if (IrpContext->Vcb == Vcb) {

        IrpContext->Vcb = NULL;

    }


    //
    //  Chuck the backpocket Vpb we kept just in case.
    //

    if (Vcb->SwapVpb) {

        ExFreePool( Vcb->SwapVpb );
    }
    
    //
    //  Uninitialize the cache
    //

    FatSyncUninitializeCacheMap( IrpContext, Vcb->VirtualVolumeFile );

    //
    //  Dereference the virtual volume file.  This will cause a close
    //  Irp to be processed, so we need to do this before we destory
    //  the Vcb
    //

    FsRtlTeardownPerStreamContexts( &Vcb->VolumeFileHeader );

    FatSetFileObject( Vcb->VirtualVolumeFile, UnopenedFileObject, NULL, NULL );
    ObDereferenceObject( Vcb->VirtualVolumeFile );

    //
    //  Remove this record from the global list of all Vcb records
    //

    (VOID)FatAcquireExclusiveGlobal( IrpContext );
    RemoveEntryList( &(Vcb->VcbLinks) );
    FatReleaseGlobal( IrpContext );

    //
    //  Make sure the direct access open count is zero, and the open file count
    //  is also zero.
    //

    if ((Vcb->DirectAccessOpenCount != 0) || (Vcb->OpenFileCount != 0)) {

        FatBugCheck( 0, 0, 0 );
    }

    //
    //  Remove the EaFcb and dereference the Fcb for the Ea file if it
    //  exists.
    //

    FatCloseEaFile( IrpContext, Vcb, FALSE );

    if (Vcb->EaFcb != NULL) {

        Vcb->EaFcb->OpenCount = 0;
        FatDeleteFcb( IrpContext, Vcb->EaFcb );

        Vcb->EaFcb = NULL;
    }

    //
    //  Remove the Root Dcb
    //

    if (Vcb->RootDcb != NULL) {

        PFILE_OBJECT DirectoryFileObject = Vcb->RootDcb->Specific.Dcb.DirectoryFile;

        if (DirectoryFileObject != NULL) {

            FatSyncUninitializeCacheMap( IrpContext, DirectoryFileObject );

            //
            //  Dereference the directory file.  This will cause a close
            //  Irp to be processed, so we need to do this before we destory
            //  the Fcb
            //

            InterlockedDecrement( &Vcb->RootDcb->Specific.Dcb.DirectoryFileOpenCount );
            Vcb->RootDcb->Specific.Dcb.DirectoryFile = NULL;
            FatSetFileObject( DirectoryFileObject, UnopenedFileObject, NULL, NULL );
            ObDereferenceObject( DirectoryFileObject );
        }

        //
        //  Rundown stale child Fcbs that may be hanging around.  Yes, this
        //  can happen.  No, the create path isn't perfectly defensive about
        //  tearing down branches built up on creates that don't wind up
        //  succeeding.  Normal system operation usually winds up having
        //  cleaned them out through re-visiting, but ...
        //
        //  Just pick off Fcbs from the bottom of the tree until we run out.
        //  Then we delete the root Dcb.
        //

        while( (Fcb = FatGetNextFcbBottomUp( IrpContext, NULL, Vcb->RootDcb )) != Vcb->RootDcb ) {

            FatDeleteFcb( IrpContext, Fcb );
        }

        FatDeleteFcb( IrpContext, Vcb->RootDcb );
    }

    //
    //  Uninitialize the notify sychronization object.
    //

    FsRtlNotifyUninitializeSync( &Vcb->NotifySync );

    //
    //  Uninitialize the resource variable for the Vcb
    //

    FatDeleteResource( &Vcb->Resource );
    FatDeleteResource( &Vcb->ChangeBitMapResource );

    //
    //  If allocation support has been setup, free it.
    //

    if (Vcb->FreeClusterBitMap.Buffer != NULL) {

        FatTearDownAllocationSupport( IrpContext, Vcb );
    }

    //
    //  UnInitialize the Mcb structure that kept track of dirty fat sectors.
    //

    FsRtlUninitializeLargeMcb( &Vcb->DirtyFatMcb );

    //
    //  Free the pool for the stached copy of the boot sector
    //

    if ( Vcb->First0x24BytesOfBootSector ) {

        ExFreePool( Vcb->First0x24BytesOfBootSector );
    }

    //
    //  Cancel the CleanVolume Timer and Dpc
    //

    (VOID)KeCancelTimer( &Vcb->CleanVolumeTimer );

    (VOID)KeRemoveQueueDpc( &Vcb->CleanVolumeDpc );

    //
    //  Free the performance counters memory
    //

    ExFreePool( Vcb->Statistics );

    //
    //  Clean out the tunneling cache
    //

    FsRtlDeleteTunnelCache(&Vcb->Tunnel);

    //
    // Dereference the target device object.
    //

    ObDereferenceObject( Vcb->TargetDeviceObject );

    //
    //  And zero out the Vcb, this will help ensure that any stale data is
    //  wiped clean
    //

    RtlZeroMemory( Vcb, sizeof(VCB) );

    //
    //  return and tell the caller
    //

    DebugTrace(-1, Dbg, "FatDeleteVcb -> VOID\n", 0);

    return;
}


VOID
FatCreateRootDcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine allocates, initializes, and inserts a new root DCB record
    into the in memory data structure.

Arguments:

    Vcb - Supplies the Vcb to associate the new DCB under

Return Value:

    None. The Vcb is modified in-place.

--*/

{
    PDCB Dcb;

    //
    //  The following variables are used for abnormal unwind
    //

    PVOID UnwindStorage[2] = { NULL, NULL };
    PERESOURCE UnwindResource = NULL;
    PERESOURCE UnwindResource2 = NULL;
    PLARGE_MCB UnwindMcb = NULL;
    PFILE_OBJECT UnwindFileObject = NULL;

    DebugTrace(+1, Dbg, "FatCreateRootDcb, Vcb = %08lx\n", Vcb);

    try {

        //
        //  Make sure we don't already have a root dcb for this vcb
        //

        if (Vcb->RootDcb != NULL) {

            DebugDump("Error trying to create multiple root dcbs\n", 0, Vcb);
            FatBugCheck( 0, 0, 0 );
        }

        //
        //  Allocate a new DCB and zero it out, we use Dcb locally so we don't
        //  have to continually reference through the Vcb
        //

        UnwindStorage[0] = Dcb = Vcb->RootDcb = FsRtlAllocatePoolWithTag( NonPagedPool,
                                                                          sizeof(DCB),
                                                                          TAG_FCB );

        RtlZeroMemory( Dcb, sizeof(DCB));

        UnwindStorage[1] =
        Dcb->NonPaged = FatAllocateNonPagedFcb();

        RtlZeroMemory( Dcb->NonPaged, sizeof( NON_PAGED_FCB ) );

        //
        //  Set the proper node type code, node byte size, and call backs
        //

        Dcb->Header.NodeTypeCode = FAT_NTC_ROOT_DCB;
        Dcb->Header.NodeByteSize = sizeof(DCB);

        Dcb->FcbCondition = FcbGood;

        //
        //  The parent Dcb, initial state, open count, dirent location
        //  information, and directory change count fields are already zero so
        //  we can skip setting them
        //

        //
        //  Initialize the resource variable
        //

        UnwindResource =
        Dcb->Header.Resource = FatAllocateResource();

        //
        //  Initialize the PagingIo Resource.  We no longer use the FsRtl common
        //  shared pool because this led to a) deadlocks due to cases where files
        //  and their parent directories shared a resource and b) there is no way
        //  to anticipate inter-driver induced deadlock via recursive operation.
        //

        UnwindResource2 =
        Dcb->Header.PagingIoResource = FatAllocateResource();

        //
        //  The root Dcb has an empty parent dcb links field
        //

        InitializeListHead( &Dcb->ParentDcbLinks );

        //
        //  Set the Vcb
        //

        Dcb->Vcb = Vcb;

        //
        //  initialize the parent dcb queue.
        //

        InitializeListHead( &Dcb->Specific.Dcb.ParentDcbQueue );

        //
        //  Set the full file name up.
        //

        Dcb->FullFileName.Buffer = L"\\";
        Dcb->FullFileName.Length = (USHORT)2;
        Dcb->FullFileName.MaximumLength = (USHORT)4;

        Dcb->ShortName.Name.Oem.Buffer = "\\";
        Dcb->ShortName.Name.Oem.Length = (USHORT)1;
        Dcb->ShortName.Name.Oem.MaximumLength = (USHORT)2;

        //
        //  Construct a lie about file properties since we don't
        //  have a proper "." entry to look at.
        //

        Dcb->DirentFatFlags = FILE_ATTRIBUTE_DIRECTORY;

        //
        //  Initialize Advanced FCB Header fields
        //

        ExInitializeFastMutex( &Dcb->NonPaged->AdvancedFcbHeaderMutex );
        FsRtlSetupAdvancedHeader( &Dcb->Header, 
                                  &Dcb->NonPaged->AdvancedFcbHeaderMutex );

        //
        //  Initialize the Mcb, and setup its mapping.  Note that the root
        //  directory is a fixed size so we can set it everything up now.
        //

        FsRtlInitializeLargeMcb( &Dcb->Mcb, NonPagedPool );
        UnwindMcb = &Dcb->Mcb;

        if (FatIsFat32(Vcb)) {

            //
            //  The first cluster of fat32 roots comes from the BPB
            //

            Dcb->FirstClusterOfFile = Vcb->Bpb.RootDirFirstCluster;

        } else {

            FatAddMcbEntry( Vcb, &Dcb->Mcb,
                            0,
                            FatRootDirectoryLbo( &Vcb->Bpb ),
                            FatRootDirectorySize( &Vcb->Bpb ));
        }

        if (FatIsFat32(Vcb)) {

            //
            //  Find the size of the fat32 root. As a side-effect, this will create
            //  MCBs for the entire root. In the process of doing this, we may
            //  discover that the FAT chain is bogus and raise corruption.
            //

            Dcb->Header.AllocationSize.LowPart = 0xFFFFFFFF;
            FatLookupFileAllocationSize( IrpContext, Dcb);

            Dcb->Header.FileSize.QuadPart =
                    Dcb->Header.AllocationSize.QuadPart;
        } else {

            //
            //  set the allocation size to real size of the root directory
            //

            Dcb->Header.FileSize.QuadPart =
            Dcb->Header.AllocationSize.QuadPart = FatRootDirectorySize( &Vcb->Bpb );

        }

        //
        //  Set our two create dirent aids to represent that we have yet to
        //  enumerate the directory for never used or deleted dirents.
        //

        Dcb->Specific.Dcb.UnusedDirentVbo = 0xffffffff;
        Dcb->Specific.Dcb.DeletedDirentHint = 0xffffffff;

        //
        //  Setup the free dirent bitmap buffer.
        //

        RtlInitializeBitMap( &Dcb->Specific.Dcb.FreeDirentBitmap,
                             NULL,
                             0 );

        FatCheckFreeDirentBitmap( IrpContext, Dcb );

    } finally {

        DebugUnwind( FatCreateRootDcb );

        //
        //  If this is an abnormal termination then undo our work
        //

        if (AbnormalTermination()) {

            ULONG i;

            if (UnwindFileObject != NULL) { ObDereferenceObject( UnwindFileObject ); }
            if (UnwindMcb != NULL) { FsRtlUninitializeLargeMcb( UnwindMcb ); }
            if (UnwindResource != NULL) { FatFreeResource( UnwindResource ); }
            if (UnwindResource2 != NULL) { FatFreeResource( UnwindResource2 ); }

            for (i = 0; i < sizeof(UnwindStorage)/sizeof(PVOID); i += 1) {
                if (UnwindStorage[i] != NULL) { ExFreePool( UnwindStorage[i] ); }
            }

            //
            //  Re-zero the entry in the Vcb.
            //

            Vcb->RootDcb = NULL;
        }

        DebugTrace(-1, Dbg, "FatCreateRootDcb -> %8lx\n", Dcb);
    }

    return;
}


PFCB
FatCreateFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PDCB ParentDcb,
    IN ULONG LfnOffsetWithinDirectory,
    IN ULONG DirentOffsetWithinDirectory,
    IN PDIRENT Dirent,
    IN PUNICODE_STRING Lfn OPTIONAL,
    IN BOOLEAN IsPagingFile,
    IN BOOLEAN SingleResource
    )

/*++

Routine Description:

    This routine allocates, initializes, and inserts a new Fcb record into
    the in-memory data structures.

Arguments:

    Vcb - Supplies the Vcb to associate the new FCB under.

    ParentDcb - Supplies the parent dcb that the new FCB is under.

    LfnOffsetWithinDirectory - Supplies the offset of the LFN.  If there is
        no LFN associated with this file then this value is same as
        DirentOffsetWithinDirectory.

    DirentOffsetWithinDirectory - Supplies the offset, in bytes from the
        start of the directory file where the dirent for the fcb is located

    Dirent - Supplies the dirent for the fcb being created

    Lfn - Supplies a long UNICODE name associated with this file.

    IsPagingFile - Indicates if we are creating an FCB for a paging file
        or some other type of file.

    SingleResource - Indicates if this Fcb should share a single resource
        as both main and paging.

Return Value:

    PFCB - Returns a pointer to the newly allocated FCB

--*/

{
    PFCB Fcb;
    POOL_TYPE PoolType;

    //
    //  The following variables are used for abnormal unwind
    //

    PVOID UnwindStorage[2] = { NULL, NULL };
    PERESOURCE UnwindResource = NULL;
    PERESOURCE UnwindResource2 = NULL;
    PLIST_ENTRY UnwindEntryList = NULL;
    PLARGE_MCB UnwindMcb = NULL;
    PFILE_LOCK UnwindFileLock = NULL;
    POPLOCK UnwindOplock = NULL;

    DebugTrace(+1, Dbg, "FatCreateFcb\n", 0);

    try {

        //
        //  Determine the pool type we should be using for the fcb and the
        //  mcb structure
        //

        if (IsPagingFile) {

            PoolType = NonPagedPool;
            Fcb = UnwindStorage[0] = FsRtlAllocatePoolWithTag( NonPagedPool,
                                                               sizeof(FCB),
                                                               TAG_FCB );
        } else {

            PoolType = PagedPool;
            Fcb = UnwindStorage[0] = FatAllocateFcb();

        }

        //
        //  ... and zero it out
        //

        RtlZeroMemory( Fcb, sizeof(FCB) );

        UnwindStorage[1] =
        Fcb->NonPaged = FatAllocateNonPagedFcb();

        RtlZeroMemory( Fcb->NonPaged, sizeof( NON_PAGED_FCB ) );

        //
        //  Set the proper node type code, node byte size, and call backs
        //

        Fcb->Header.NodeTypeCode = FAT_NTC_FCB;
        Fcb->Header.NodeByteSize = sizeof(FCB);

        Fcb->FcbCondition = FcbGood;

        //
        //  Check to see if we need to set the Fcb state to indicate that this
        //  is a paging/system file.  This will prevent it from being opened
        //  again.
        //

        if (IsPagingFile) {

            SetFlag( Fcb->FcbState, FCB_STATE_PAGING_FILE | FCB_STATE_SYSTEM_FILE );
        }

        //
        //  The initial state, open count, and segment objects fields are already
        //  zero so we can skip setting them
        //

        //
        //  Initialize the resource variable
        //


        UnwindResource =
        Fcb->Header.Resource = FatAllocateResource();

        //
        //  Initialize the PagingIo Resource.  We no longer use the FsRtl common
        //  shared pool because this led to a) deadlocks due to cases where files
        //  and their parent directories shared a resource and b) there is no way
        //  to anticipate inter-driver induced deadlock via recursive operation.
        //

        if (SingleResource) {

            Fcb->Header.PagingIoResource = Fcb->Header.Resource;

        } else {

            UnwindResource2 =
            Fcb->Header.PagingIoResource = FatAllocateResource();
        }

        //
        //  Insert this fcb into our parent dcb's queue.
        //
        //  There is a deep reason why this goes on the tail, to allow us
        //  to easily enumerate all child directories before child files.
        //  This is important to let us maintain whole-volume lockorder
        //  via BottomUp enumeration.
        //

        InsertTailList( &ParentDcb->Specific.Dcb.ParentDcbQueue,
                        &Fcb->ParentDcbLinks );
        UnwindEntryList = &Fcb->ParentDcbLinks;

        //
        //  Point back to our parent dcb
        //

        Fcb->ParentDcb = ParentDcb;

        //
        //  Set the Vcb
        //

        Fcb->Vcb = Vcb;

        //
        //  Set the dirent offset within the directory
        //

        Fcb->LfnOffsetWithinDirectory = LfnOffsetWithinDirectory;
        Fcb->DirentOffsetWithinDirectory = DirentOffsetWithinDirectory;

        //
        //  Set the DirentFatFlags and LastWriteTime
        //

        Fcb->DirentFatFlags = Dirent->Attributes;

        Fcb->LastWriteTime = FatFatTimeToNtTime( IrpContext,
                                                 Dirent->LastWriteTime,
                                                 0 );

        //
        //  These fields are only non-zero when in Chicago mode.
        //

        if (FatData.ChicagoMode) {

            LARGE_INTEGER FatSystemJanOne1980;

            //
            //  If either date is possibly zero, get the system
            //  version of 1/1/80.
            //

            if ((((PUSHORT)Dirent)[9] & ((PUSHORT)Dirent)[8]) == 0) {

                ExLocalTimeToSystemTime( &FatJanOne1980,
                                         &FatSystemJanOne1980 );
            }

            //
            //  Only do the really hard work if this field is non-zero.
            //

            if (((PUSHORT)Dirent)[9] != 0) {

                Fcb->LastAccessTime =
                    FatFatDateToNtTime( IrpContext,
                                        Dirent->LastAccessDate );

            } else {

                Fcb->LastAccessTime = FatSystemJanOne1980;
            }

            //
            //  Only do the really hard work if this field is non-zero.
            //

            if (((PUSHORT)Dirent)[8] != 0) {

                Fcb->CreationTime =
                    FatFatTimeToNtTime( IrpContext,
                                        Dirent->CreationTime,
                                        Dirent->CreationMSec );

            } else {

                Fcb->CreationTime = FatSystemJanOne1980;
            }
        }

        //
        //  Initialize Advanced FCB Header fields
        //

        ExInitializeFastMutex( &Fcb->NonPaged->AdvancedFcbHeaderMutex );
        FsRtlSetupAdvancedHeader( &Fcb->Header, 
                                  &Fcb->NonPaged->AdvancedFcbHeaderMutex );

        //
        //  To make FAT match the present functionality of NTFS, disable
        //  stream contexts on paging files (nealch 7/2/01)
        //

        if (IsPagingFile) {

            ClearFlag( Fcb->Header.Flags2, FSRTL_FLAG2_SUPPORTS_FILTER_CONTEXTS );
        } 

        //
        //  Initialize the Mcb
        //

        FsRtlInitializeLargeMcb( &Fcb->Mcb, PoolType );
        UnwindMcb = &Fcb->Mcb;

        //
        //  Set the file size, valid data length, first cluster of file,
        //  and allocation size based on the information stored in the dirent
        //

        Fcb->Header.FileSize.LowPart = Dirent->FileSize;

        Fcb->Header.ValidDataLength.LowPart = Dirent->FileSize;

        Fcb->ValidDataToDisk = Dirent->FileSize;

        Fcb->FirstClusterOfFile = (ULONG)Dirent->FirstClusterOfFile;

        if ( FatIsFat32(Vcb) ) {

            Fcb->FirstClusterOfFile += Dirent->FirstClusterOfFileHi << 16;
        }

        if ( Fcb->FirstClusterOfFile == 0 ) {

            Fcb->Header.AllocationSize.QuadPart = 0;

        } else {

            Fcb->Header.AllocationSize.QuadPart = FCB_LOOKUP_ALLOCATIONSIZE_HINT;
        }

        //
        //  Initialize the Fcb's file lock record
        //

        FsRtlInitializeFileLock( &Fcb->Specific.Fcb.FileLock, NULL, NULL );
        UnwindFileLock = &Fcb->Specific.Fcb.FileLock;

        //
        //  Initialize the oplock structure.
        //

        FsRtlInitializeOplock( &Fcb->Specific.Fcb.Oplock );
        UnwindOplock = &Fcb->Specific.Fcb.Oplock;

        //
        //  Indicate that Fast I/O is possible
        //

        Fcb->Header.IsFastIoPossible = TRUE;

        //
        //  Set the file names.  This must be the last thing we do.
        //

        FatConstructNamesInFcb( IrpContext,
                                Fcb,
                                Dirent,
                                Lfn );

        //
        //  Drop the shortname hint so prefix searches can figure out
        //  what they found
        //

        Fcb->ShortName.FileNameDos = TRUE;

    } finally {

        DebugUnwind( FatCreateFcb );

        //
        //  If this is an abnormal termination then undo our work
        //

        if (AbnormalTermination()) {

            ULONG i;

            if (UnwindOplock != NULL) { FsRtlUninitializeOplock( UnwindOplock ); }
            if (UnwindFileLock != NULL) { FsRtlUninitializeFileLock( UnwindFileLock ); }
            if (UnwindMcb != NULL) { FsRtlUninitializeLargeMcb( UnwindMcb ); }
            if (UnwindEntryList != NULL) { RemoveEntryList( UnwindEntryList ); }
            if (UnwindResource != NULL) { FatFreeResource( UnwindResource ); }
            if (UnwindResource2 != NULL) { FatFreeResource( UnwindResource2 ); }

            for (i = 0; i < sizeof(UnwindStorage)/sizeof(PVOID); i += 1) {
                if (UnwindStorage[i] != NULL) { ExFreePool( UnwindStorage[i] ); }
            }
        }

        DebugTrace(-1, Dbg, "FatCreateFcb -> %08lx\n", Fcb);
    }

    //
    //  return and tell the caller
    //

    return Fcb;
}


PDCB
FatCreateDcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PDCB ParentDcb,
    IN ULONG LfnOffsetWithinDirectory,
    IN ULONG DirentOffsetWithinDirectory,
    IN PDIRENT Dirent,
    IN PUNICODE_STRING Lfn OPTIONAL
    )

/*++

Routine Description:

    This routine allocates, initializes, and inserts a new Dcb record into
    the in memory data structures.

Arguments:

    Vcb - Supplies the Vcb to associate the new DCB under.

    ParentDcb - Supplies the parent dcb that the new DCB is under.

    LfnOffsetWithinDirectory - Supplies the offset of the LFN.  If there is
        no LFN associated with this file then this value is same as
        DirentOffsetWithinDirectory.

    DirentOffsetWithinDirectory - Supplies the offset, in bytes from the
        start of the directory file where the dirent for the fcb is located

    Dirent - Supplies the dirent for the dcb being created

    FileName - Supplies the file name of the file relative to the directory
        it's in (e.g., the file \config.sys is called "CONFIG.SYS" without
        the preceding backslash).

    Lfn - Supplies a long UNICODE name associated with this directory.

Return Value:

    PDCB - Returns a pointer to the newly allocated DCB

--*/

{
    PDCB Dcb;

    //
    //  The following variables are used for abnormal unwind
    //

    PVOID UnwindStorage[2] = { NULL, NULL  };
    PERESOURCE UnwindResource = NULL;
    PERESOURCE UnwindResource2 = NULL;
    PLIST_ENTRY UnwindEntryList = NULL;
    PLARGE_MCB UnwindMcb = NULL;

    DebugTrace(+1, Dbg, "FatCreateDcb\n", 0);


    try {

        //
        //  assert that the only time we are called is if wait is true
        //

        ASSERT( FlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT) );

        //
        //  Allocate a new DCB, and zero it out
        //

        UnwindStorage[0] = Dcb = FatAllocateFcb();

        RtlZeroMemory( Dcb, sizeof(DCB) );

        UnwindStorage[1] =
        Dcb->NonPaged = FatAllocateNonPagedFcb();

        RtlZeroMemory( Dcb->NonPaged, sizeof( NON_PAGED_FCB ) );

        //
        //  Set the proper node type code, node byte size and call backs
        //

        Dcb->Header.NodeTypeCode = FAT_NTC_DCB;
        Dcb->Header.NodeByteSize = sizeof(DCB);

        Dcb->FcbCondition = FcbGood;

        //
        //  The initial state, open count, and directory change count fields are
        //  already zero so we can skip setting them
        //

        //
        //  Initialize the resource variable
        //


        UnwindResource =
        Dcb->Header.Resource = FatAllocateResource();

        //
        //  Initialize the PagingIo Resource.  We no longer use the FsRtl common
        //  shared pool because this led to a) deadlocks due to cases where files
        //  and their parent directories shared a resource and b) there is no way
        //  to anticipate inter-driver induced deadlock via recursive operation.
        //

        UnwindResource2 =
        Dcb->Header.PagingIoResource = FatAllocateResource();

        //
        //  Insert this Dcb into our parent dcb's queue
        //
        //  There is a deep reason why this goes on the head, to allow us
        //  to easily enumerate all child directories before child files.
        //  This is important to let us maintain whole-volume lockorder
        //  via BottomUp enumeration.
        //

        InsertHeadList( &ParentDcb->Specific.Dcb.ParentDcbQueue,
                        &Dcb->ParentDcbLinks );
        UnwindEntryList = &Dcb->ParentDcbLinks;

        //
        //  Point back to our parent dcb
        //

        Dcb->ParentDcb = ParentDcb;

        //
        //  Set the Vcb
        //

        Dcb->Vcb = Vcb;

        //
        //  Set the dirent offset within the directory
        //

        Dcb->LfnOffsetWithinDirectory = LfnOffsetWithinDirectory;
        Dcb->DirentOffsetWithinDirectory = DirentOffsetWithinDirectory;

        //
        //  Set the DirentFatFlags and LastWriteTime
        //

        Dcb->DirentFatFlags = Dirent->Attributes;

        Dcb->LastWriteTime = FatFatTimeToNtTime( IrpContext,
                                                 Dirent->LastWriteTime,
                                                 0 );

        //
        //  These fields are only non-zero when in Chicago mode.
        //

        if (FatData.ChicagoMode) {

            LARGE_INTEGER FatSystemJanOne1980;

            //
            //  If either date is possibly zero, get the system
            //  version of 1/1/80.
            //

            if ((((PUSHORT)Dirent)[9] & ((PUSHORT)Dirent)[8]) == 0) {

                ExLocalTimeToSystemTime( &FatJanOne1980,
                                         &FatSystemJanOne1980 );
            }

            //
            //  Only do the really hard work if this field is non-zero.
            //

            if (((PUSHORT)Dirent)[9] != 0) {

                Dcb->LastAccessTime =
                    FatFatDateToNtTime( IrpContext,
                                        Dirent->LastAccessDate );

            } else {

                Dcb->LastAccessTime = FatSystemJanOne1980;
            }

            //
            //  Only do the really hard work if this field is non-zero.
            //

            if (((PUSHORT)Dirent)[8] != 0) {

                Dcb->CreationTime =
                    FatFatTimeToNtTime( IrpContext,
                                        Dirent->CreationTime,
                                        Dirent->CreationMSec );

            } else {

                Dcb->CreationTime = FatSystemJanOne1980;
            }
        }

        //
        //  Initialize Advanced FCB Header fields
        //

        ExInitializeFastMutex( &Dcb->NonPaged->AdvancedFcbHeaderMutex );
        FsRtlSetupAdvancedHeader( &Dcb->Header, 
                                  &Dcb->NonPaged->AdvancedFcbHeaderMutex );

        //
        //  Initialize the Mcb
        //

        FsRtlInitializeLargeMcb( &Dcb->Mcb, PagedPool );
        UnwindMcb = &Dcb->Mcb;

        //
        //  Set the file size, first cluster of file, and allocation size
        //  based on the information stored in the dirent
        //

        Dcb->FirstClusterOfFile = (ULONG)Dirent->FirstClusterOfFile;

        if ( FatIsFat32(Dcb->Vcb) ) {

            Dcb->FirstClusterOfFile += Dirent->FirstClusterOfFileHi << 16;
        }

        if ( Dcb->FirstClusterOfFile == 0 ) {

            Dcb->Header.AllocationSize.QuadPart = 0;

        } else {

            Dcb->Header.AllocationSize.QuadPart = FCB_LOOKUP_ALLOCATIONSIZE_HINT;
        }

        //  initialize the notify queues, and the parent dcb queue.
        //

        InitializeListHead( &Dcb->Specific.Dcb.ParentDcbQueue );

        //
        //  Setup the free dirent bitmap buffer.  Since we don't know the
        //  size of the directory, leave it zero for now.
        //

        RtlInitializeBitMap( &Dcb->Specific.Dcb.FreeDirentBitmap,
                             NULL,
                             0 );

        //
        //  Set our two create dirent aids to represent that we have yet to
        //  enumerate the directory for never used or deleted dirents.
        //

        Dcb->Specific.Dcb.UnusedDirentVbo = 0xffffffff;
        Dcb->Specific.Dcb.DeletedDirentHint = 0xffffffff;

        //
        //  Postpone initializing the cache map until we need to do a read/write
        //  of the directory file.


        //
        //  set the file names.  This must be the last thing we do.
        //

        FatConstructNamesInFcb( IrpContext,
                                Dcb,
                                Dirent,
                                Lfn );

    } finally {

        DebugUnwind( FatCreateDcb );

        //
        //  If this is an abnormal termination then undo our work
        //

        if (AbnormalTermination()) {

            ULONG i;

            if (UnwindMcb != NULL) { FsRtlUninitializeLargeMcb( UnwindMcb ); }
            if (UnwindEntryList != NULL) { RemoveEntryList( UnwindEntryList ); }
            if (UnwindResource != NULL) { FatFreeResource( UnwindResource ); }
            if (UnwindResource2 != NULL) { FatFreeResource( UnwindResource2 ); }

            for (i = 0; i < sizeof(UnwindStorage)/sizeof(PVOID); i += 1) {
                if (UnwindStorage[i] != NULL) { ExFreePool( UnwindStorage[i] ); }
            }
        }

        DebugTrace(-1, Dbg, "FatCreateDcb -> %08lx\n", Dcb);
    }

    //
    //  return and tell the caller
    //

    DebugTrace(-1, Dbg, "FatCreateDcb -> %08lx\n", Dcb);

    return Dcb;
}


VOID
FatDeleteFcb_Real (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine deallocates and removes an FCB, DCB, or ROOT DCB record
    from Fat's in-memory data structures.  It also will remove all
    associated underlings (i.e., Notify irps, and child FCB/DCB records).

Arguments:

    Fcb - Supplies the FCB/DCB/ROOT DCB to be removed

Return Value:

    None

--*/

{
    DebugTrace(+1, Dbg, "FatDeleteFcb, Fcb = %08lx\n", Fcb);

    //
    //  We can only delete this record if the open count is zero.
    //

    if (Fcb->OpenCount != 0) {

        DebugDump("Error deleting Fcb, Still Open\n", 0, Fcb);
        FatBugCheck( 0, 0, 0 );
    }

    //
    //  If this is a DCB then remove every Notify record from the two
    //  notify queues
    //

    if ((Fcb->Header.NodeTypeCode == FAT_NTC_DCB) ||
        (Fcb->Header.NodeTypeCode == FAT_NTC_ROOT_DCB)) {

        //
        //  If we allocated a free dirent bitmap buffer, free it.
        //

        if ((Fcb->Specific.Dcb.FreeDirentBitmap.Buffer != NULL) &&
            (Fcb->Specific.Dcb.FreeDirentBitmap.Buffer !=
             &Fcb->Specific.Dcb.FreeDirentBitmapBuffer[0])) {

            ExFreePool(Fcb->Specific.Dcb.FreeDirentBitmap.Buffer);
        }

        ASSERT( Fcb->Specific.Dcb.DirectoryFileOpenCount == 0 );
        ASSERT( IsListEmpty(&Fcb->Specific.Dcb.ParentDcbQueue) );

    } else {

        //
        //  Uninitialize the byte range file locks and opportunistic locks
        //

        FsRtlUninitializeFileLock( &Fcb->Specific.Fcb.FileLock );
        FsRtlUninitializeOplock( &Fcb->Specific.Fcb.Oplock );
    }

    //
    //  Release any Filter Context structures associated with this FCB
    //

    FsRtlTeardownPerStreamContexts( &Fcb->Header );

    //
    //  Uninitialize the Mcb
    //

    FsRtlUninitializeLargeMcb( &Fcb->Mcb );

    //
    //  If this is not the root dcb then we need to remove ourselves from
    //  our parents Dcb queue
    //

    if (Fcb->Header.NodeTypeCode != FAT_NTC_ROOT_DCB) {

        RemoveEntryList( &(Fcb->ParentDcbLinks) );
    }

    //
    //  Remove the entry from the splay table if there is still is one.
    //

    if (FlagOn( Fcb->FcbState, FCB_STATE_NAMES_IN_SPLAY_TREE )) {

        FatRemoveNames( IrpContext, Fcb );
    }

    //
    //  Free the file name pool if allocated.
    //

    if (Fcb->Header.NodeTypeCode != FAT_NTC_ROOT_DCB) {

        //
        //  If we blew up at inconvenient times, the shortname
        //  could be null even though you will *never* see this
        //  normally.  Rename is a good example of this case.
        //

        if (Fcb->ShortName.Name.Oem.Buffer) {

            ExFreePool( Fcb->ShortName.Name.Oem.Buffer );
        }

        if (Fcb->FullFileName.Buffer) {

            ExFreePool( Fcb->FullFileName.Buffer );
        }
    }

    if (Fcb->ExactCaseLongName.Buffer) {

        ExFreePool(Fcb->ExactCaseLongName.Buffer);
    }

#ifdef SYSCACHE_COMPILE

    if (Fcb->WriteMask) {

        ExFreePool( Fcb->WriteMask );
    }

#endif

    //
    //  Finally deallocate the Fcb and non-paged fcb records
    //

    FatFreeResource( Fcb->Header.Resource );

    if (Fcb->Header.PagingIoResource != Fcb->Header.Resource) {

        FatFreeResource( Fcb->Header.PagingIoResource );
    }

    //
    //  If an Event was allocated, get rid of it.
    //

    if (Fcb->NonPaged->OutstandingAsyncEvent) {

        ExFreePool( Fcb->NonPaged->OutstandingAsyncEvent );
    }

    FatFreeNonPagedFcb( Fcb->NonPaged );
    FatFreeFcb( Fcb );

    //
    //  and return to our caller
    //

    DebugTrace(-1, Dbg, "FatDeleteFcb -> VOID\n", 0);

    return;
}

PCCB
FatCreateCcb (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine creates a new CCB record

Arguments:

Return Value:

    CCB - returns a pointer to the newly allocate CCB

--*/

{
    PCCB Ccb;

    DebugTrace(+1, Dbg, "FatCreateCcb\n", 0);

    //
    //  Allocate a new CCB Record
    //

    Ccb = FatAllocateCcb();

    RtlZeroMemory( Ccb, sizeof(CCB) );

    //
    //  Set the proper node type code and node byte size
    //

    Ccb->NodeTypeCode = FAT_NTC_CCB;
    Ccb->NodeByteSize = sizeof(CCB);

    //
    //  return and tell the caller
    //

    DebugTrace(-1, Dbg, "FatCreateCcb -> %08lx\n", Ccb);

    UNREFERENCED_PARAMETER( IrpContext );

    return Ccb;
}



VOID
FatDeallocateCcbStrings(
    IN PCCB Ccb
    )
/*++

Routine Description:

    This routine deallocates CCB query templates

Arguments:

    Ccb - Supplies the CCB

Return Value:

    None

--*/
{
    //
    //  If we allocated query template buffers, deallocate them now.
    //

    if (FlagOn(Ccb->Flags, CCB_FLAG_FREE_UNICODE)) {

        ASSERT( Ccb->UnicodeQueryTemplate.Buffer);
        ASSERT( !FlagOn( Ccb->Flags, CCB_FLAG_CLOSE_CONTEXT));
        RtlFreeUnicodeString( &Ccb->UnicodeQueryTemplate );
    }

    if (FlagOn(Ccb->Flags, CCB_FLAG_FREE_OEM_BEST_FIT)) {

        ASSERT( Ccb->OemQueryTemplate.Wild.Buffer );
        ASSERT( !FlagOn( Ccb->Flags, CCB_FLAG_CLOSE_CONTEXT));
        RtlFreeOemString( &Ccb->OemQueryTemplate.Wild );
    }

    ClearFlag( Ccb->Flags, CCB_FLAG_FREE_OEM_BEST_FIT | CCB_FLAG_FREE_UNICODE);
}



VOID
FatDeleteCcb_Real (
    IN PIRP_CONTEXT IrpContext,
    IN PCCB Ccb
    )

/*++

Routine Description:

    This routine deallocates and removes the specified CCB record
    from the Fat in memory data structures

Arguments:

    Ccb - Supplies the CCB to remove

Return Value:

    None

--*/

{
    DebugTrace(+1, Dbg, "FatDeleteCcb, Ccb = %08lx\n", Ccb);

    FatDeallocateCcbStrings( Ccb);

    //
    //  Deallocate the Ccb record
    //

    FatFreeCcb( Ccb );

    //
    //  return and tell the caller
    //

    DebugTrace(-1, Dbg, "FatDeleteCcb -> VOID\n", 0);

    UNREFERENCED_PARAMETER( IrpContext );

    return;
}


PIRP_CONTEXT
FatCreateIrpContext (
    IN PIRP Irp,
    IN BOOLEAN Wait
    )

/*++

Routine Description:

    This routine creates a new IRP_CONTEXT record

Arguments:

    Irp - Supplies the originating Irp.

    Wait - Supplies the wait value to store in the context

Return Value:

    PIRP_CONTEXT - returns a pointer to the newly allocate IRP_CONTEXT Record

--*/

{
    PIRP_CONTEXT IrpContext;
    PIO_STACK_LOCATION IrpSp;

    DebugTrace(+1, Dbg, "FatCreateIrpContext\n", 0);

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  The only operations a filesystem device object should ever receive
    //  are create/teardown of fsdo handles and operations which do not
    //  occur in the context of fileobjects (i.e., mount).
    //

    if (FatDeviceIsFatFsdo( IrpSp->DeviceObject))  {

        if (IrpSp->FileObject != NULL &&
            IrpSp->MajorFunction != IRP_MJ_CREATE &&
            IrpSp->MajorFunction != IRP_MJ_CLEANUP &&
            IrpSp->MajorFunction != IRP_MJ_CLOSE) {

            ExRaiseStatus( STATUS_INVALID_DEVICE_REQUEST );
        }

        ASSERT( IrpSp->FileObject != NULL ||

                (IrpSp->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL &&
                 IrpSp->MinorFunction == IRP_MN_USER_FS_REQUEST &&
                 IrpSp->Parameters.FileSystemControl.FsControlCode == FSCTL_INVALIDATE_VOLUMES) ||

                (IrpSp->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL &&
                 IrpSp->MinorFunction == IRP_MN_MOUNT_VOLUME ) ||

                IrpSp->MajorFunction == IRP_MJ_SHUTDOWN );
    }

    //
    //  Attemtp to allocate from the region first and failing that allocate
    //  from pool.
    //

    DebugDoit( FatFsdEntryCount += 1);

    IrpContext = FatAllocateIrpContext();

    //
    //  Zero out the irp context.
    //

    RtlZeroMemory( IrpContext, sizeof(IRP_CONTEXT) );

    //
    //  Set the proper node type code and node byte size
    //

    IrpContext->NodeTypeCode = FAT_NTC_IRP_CONTEXT;
    IrpContext->NodeByteSize = sizeof(IRP_CONTEXT);

    //
    //  Set the originating Irp field
    //

    IrpContext->OriginatingIrp = Irp;

    //
    //  Major/Minor Function codes
    //

    IrpContext->MajorFunction = IrpSp->MajorFunction;
    IrpContext->MinorFunction = IrpSp->MinorFunction;

    //
    //  Copy RealDevice for workque algorithms, and also set Write Through
    //  and Removable Media if there is a file object.  Only file system
    //  control Irps won't have a file object, and they should all have
    //  a Vpb as the first IrpSp location.
    //

    if (IrpSp->FileObject != NULL) {

        PVCB Vcb;
        PFILE_OBJECT FileObject = IrpSp->FileObject;

        IrpContext->RealDevice = FileObject->DeviceObject;
        Vcb = IrpContext->Vcb = &((PVOLUME_DEVICE_OBJECT)(IrpSp->DeviceObject))->Vcb;

        //
        //  See if the request is Write Through.
        //

        if (IsFileWriteThrough( FileObject, Vcb )) {

            SetFlag(IrpContext->Flags, IRP_CONTEXT_FLAG_WRITE_THROUGH);
        }

    } else if (IrpContext->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL) {

        IrpContext->RealDevice = IrpSp->Parameters.MountVolume.Vpb->RealDevice;
    }

    //
    //  Set the wait parameter
    //

    if (Wait) { SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT); }

    //
    //  Set the recursive file system call parameter.  We set it true if
    //  the TopLevelIrp field in the thread local storage is not the current
    //  irp, otherwise we leave it as FALSE.
    //

    if ( IoGetTopLevelIrp() != Irp) {

        SetFlag(IrpContext->Flags, IRP_CONTEXT_FLAG_RECURSIVE_CALL);
    }

    //
    //  return and tell the caller
    //

    DebugTrace(-1, Dbg, "FatCreateIrpContext -> %08lx\n", IrpContext);

    return IrpContext;
}



VOID
FatDeleteIrpContext_Real (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine deallocates and removes the specified IRP_CONTEXT record
    from the Fat in memory data structures.  It should only be called
    by FatCompleteRequest.

Arguments:

    IrpContext - Supplies the IRP_CONTEXT to remove

Return Value:

    None

--*/

{
    DebugTrace(+1, Dbg, "FatDeleteIrpContext, IrpContext = %08lx\n", IrpContext);

    ASSERT( IrpContext->NodeTypeCode == FAT_NTC_IRP_CONTEXT );
    ASSERT( IrpContext->PinCount == 0 );

    //
    //  If there is a FatIoContext that was allocated, free it.
    //

    if (IrpContext->FatIoContext != NULL) {

        if (!FlagOn(IrpContext->Flags, IRP_CONTEXT_STACK_IO_CONTEXT)) {
            
            if (IrpContext->FatIoContext->ZeroMdl) {
                IoFreeMdl( IrpContext->FatIoContext->ZeroMdl );
            }

            ExFreePool( IrpContext->FatIoContext );
        }
    }

    //
    //  Drop the IrpContext.
    //

    FatFreeIrpContext( IrpContext );

    //
    //  return and tell the caller
    //

    DebugTrace(-1, Dbg, "FatDeleteIrpContext -> VOID\n", 0);

    return;
}


PFCB
FatGetNextFcbBottomUp (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb OPTIONAL,
    IN PFCB TerminationFcb
    )

/*++

Routine Description:

    This routine is used to iterate through Fcbs in a tree.  In order to match
    the lockorder for getting multiple Fcbs (so this can be used for acquiring
    all Fcbs), this version does a bottom-up enumeration.

    This is different than the old one, now called TopDown. The problem with
    lockorder was very well hidden.

    The transition rule is still pretty simple:

        A) If you have an adjacent sibling, go to it
            1) Descend to its leftmost child
        B) Else go to your parent

    If this routine is called with in invalid TerminationFcb it will fail,
    badly.

    The TerminationFcb is the last Fcb returned in the enumeration.

    This method is incompatible with the possibility that ancestors may vanish
    based on operations done on the last returned node.  For instance,
    FatPurgeReferencedFileObjects cannot use BottomUp enumeration.

Arguments:

    Fcb - Supplies the current Fcb.  This is NULL if enumeration is starting.

    TerminationFcb - The root Fcb of the tree in which the enumeration starts
        and at which it inclusively stops.

Return Value:

    The next Fcb in the enumeration, or NULL if Fcb was the final one.

--*/

{
    PFCB NextFcb;

    ASSERT( FatVcbAcquiredExclusive( IrpContext, TerminationFcb->Vcb ) ||
            FlagOn( TerminationFcb->Vcb->VcbState, VCB_STATE_FLAG_LOCKED ) );

    //
    //  Do we need to begin the enumeration?
    //

    if (Fcb != NULL) {

        //
        //  Did we complete?
        //

        if (Fcb == TerminationFcb) {

            return NULL;
        }

        //
        //  Do we have a sibling to return?
        //

        NextFcb = FatGetNextSibling( Fcb );

        //
        //  If not, return our parent.  We are done with this branch.
        //

        if (NextFcb == NULL) {

            return Fcb->ParentDcb;
        }

    } else {

        NextFcb = TerminationFcb;
    }

    //
    //  Decend to its furthest child (if it exists) and return it.
    //

    for (;
         NodeType( NextFcb ) != FAT_NTC_FCB && FatGetFirstChild( NextFcb ) != NULL;
         NextFcb = FatGetFirstChild( NextFcb )) {
    }

    return NextFcb;
}

PFCB
FatGetNextFcbTopDown (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN PFCB TerminationFcb
    )

/*++

Routine Description:

    This routine is used to iterate through Fcbs in a tree, from the top down.

    The rule is very simple:

        A) If you have a child, go to it, else
        B) If you have an older sibling, go to it, else
        C) Go to your parent's older sibling.

    If this routine is called with in invalid TerminationFcb it will fail,
    badly.

    The Termination Fcb is never returned.  If it is the root of the tree you
    are traversing, visit it first.

    This routine never returns direct ancestors of Fcb, and thus is useful when
    making Fcb's go away (which may tear up the tree).

Arguments:

    Fcb - Supplies the current Fcb

    TerminationFcb - The Fcb at which the enumeration should (non-inclusivly)
        stop.  Assumed to be a directory.

Return Value:

    The next Fcb in the enumeration, or NULL if Fcb was the final one.

--*/

{
    PFCB Sibling;

    ASSERT( FatVcbAcquiredExclusive( IrpContext, Fcb->Vcb ) ||
            FlagOn( Fcb->Vcb->VcbState, VCB_STATE_FLAG_LOCKED ) );

    //
    //  If this was a directory (ie. not a file), get the child.  If
    //  there aren't any children and this is our termination Fcb,
    //  return NULL.
    //

    if ( ((NodeType(Fcb) == FAT_NTC_DCB) ||
          (NodeType(Fcb) == FAT_NTC_ROOT_DCB)) &&
         !IsListEmpty(&Fcb->Specific.Dcb.ParentDcbQueue) ) {

        return FatGetFirstChild( Fcb );
    }

    //
    //  Were we only meant to do one iteration?
    //

    if ( Fcb == TerminationFcb ) {

        return NULL;
    }

    Sibling = FatGetNextSibling(Fcb);

    while (TRUE) {

        //
        //  Do we still have an "older" sibling in this directory who is
        //  not the termination Fcb?
        //

        if ( Sibling != NULL ) {

            return (Sibling != TerminationFcb) ? Sibling : NULL;
        }

        //
        //  OK, let's move on to out parent and see if he is the termination
        //  node or has any older siblings.
        //

        if ( Fcb->ParentDcb == TerminationFcb ) {

            return NULL;
        }

        Fcb = Fcb->ParentDcb;

        Sibling = FatGetNextSibling(Fcb);
    }
}


BOOLEAN
FatCheckForDismount (
    IN PIRP_CONTEXT IrpContext,
    PVCB Vcb,
    IN BOOLEAN Force
    )

/*++

Routine Description:

    This routine determines if a volume is ready for deletion.  It
    correctly synchronizes with creates en-route to the file system.

Arguments:

    Vcb - Supplies the volume to examine

    Force - Specifies whether we want this Vcb forcibly disconnected
        from the driver stack if it will not be deleted (a new vpb will
        be installed if neccesary).  Caller is responsible for making
        sure that the volume has been marked in such a way that attempts
        to operate through the realdevice are blocked (i.e., move the vcb
        out of the mounted state).

Return Value:

    BOOLEAN - TRUE if the volume was deleted, FALSE otherwise.

--*/

{
    KIRQL SavedIrql;
    ULONG ResidualReferenceCount;
    PVPB OldVpb;
    BOOLEAN VcbDeleted = FALSE;

    OldVpb = Vcb->Vpb;

    //
    //  Compute if the volume is OK to tear down.  There should only be two
    //  residual file objects, one for the volume file and one for the root
    //  directory.  If we are in the midst of a create (of an unmounted
    //  volume that has failed verify) then there will be an additional
    //  reference.
    //

    if ((IrpContext->MajorFunction == IRP_MJ_CREATE) &&
        (IrpContext->RealDevice == Vcb->CurrentDevice)) {

        ResidualReferenceCount = 3;

    } else {

        ResidualReferenceCount = 2;
    }

    //
    //  Now check for a zero Vpb count on an unmounted volume.  These
    //  volumes will be deleted as they now have no file objects and
    //  there are no creates en route to this volume.
    //

    IoAcquireVpbSpinLock( &SavedIrql );

    if (Vcb->Vpb->ReferenceCount == ResidualReferenceCount && Vcb->OpenFileCount == 0) {

        PVPB Vpb = Vcb->Vpb;

#if DBG
        UNICODE_STRING VolumeLabel;

        //
        //  Setup the VolumeLabel string
        //

        VolumeLabel.Length = Vcb->Vpb->VolumeLabelLength;
        VolumeLabel.MaximumLength = MAXIMUM_VOLUME_LABEL_LENGTH;
        VolumeLabel.Buffer = &Vcb->Vpb->VolumeLabel[0];

        KdPrintEx((DPFLTR_FASTFAT_ID,
                   DPFLTR_INFO_LEVEL,
                   "FASTFAT: Dismounting Volume %Z\n",
                   &VolumeLabel));
#endif // DBG

        //
        //  Clear the VPB_MOUNTED bit so that new creates will not come
        //  to this volume.  We must leave the Vpb->DeviceObject field
        //  set until after the DeleteVcb call as two closes will
        //  have to make their way back to us.
        //
        //  Note also that if we were called from close, it will take care
        //  of freeing the Vpb if it is not the primary one, otherwise
        //  if we were called from Create->Verify, IopParseDevice will
        //  take care of freeing the Vpb in its Reparse path.
        //

        ClearFlag( Vpb->Flags, VPB_MOUNTED );

        //
        //  If this Vpb was locked, clear this flag now.
        //

        ClearFlag( Vpb->Flags, VPB_LOCKED );

        //
        //  This will prevent anybody else from attempting to mount this
        //  volume.  Also if this volume was mounted on a "wanna-be" real
        //  device object, keep anybody from following the link, and the Io
        //  system from deleting the Vpb.
        //

        if ((Vcb->CurrentDevice != Vpb->RealDevice) &&
            (Vcb->CurrentDevice->Vpb == Vpb)) {

            SetFlag( Vcb->CurrentDevice->Flags, DO_DEVICE_INITIALIZING );
            SetFlag( Vpb->Flags, VPB_PERSISTENT );
        }

        IoReleaseVpbSpinLock( SavedIrql );

        FatDeleteVcb( IrpContext, Vcb );

        //
        //  Note, after deleting the Vcb per the comment above.
        //
        
        Vpb->DeviceObject = NULL;

        IoDeleteDevice( (PDEVICE_OBJECT)
                        CONTAINING_RECORD( Vcb,
                                           VOLUME_DEVICE_OBJECT,
                                           Vcb ) );

        VcbDeleted = TRUE;

    } else if (OldVpb->RealDevice->Vpb == OldVpb && Force) {

        //
        //  If not the final reference and we are forcing the disconnect,
        //  then swap out the Vpb.  We must preserve the REMOVE_PENDING flag
        //  so that the device is not remounted in the middle of a PnP remove
        //  operation.
        //

        ASSERT( Vcb->SwapVpb != NULL );

        Vcb->SwapVpb->Type = IO_TYPE_VPB;
        Vcb->SwapVpb->Size = sizeof( VPB );
        Vcb->SwapVpb->RealDevice = OldVpb->RealDevice;

        Vcb->SwapVpb->RealDevice->Vpb = Vcb->SwapVpb;

        Vcb->SwapVpb->Flags = FlagOn( OldVpb->Flags, VPB_REMOVE_PENDING );

        IoReleaseVpbSpinLock( SavedIrql );

        //
        //  We place the volume in the Bad state (as opposed to NotMounted) so
        //  that it is not eligible for a remount.  Also indicate we used up
        //  the swap.
        //

        Vcb->SwapVpb = NULL;
        Vcb->VcbCondition = VcbBad;

    } else {

        //
        //  Just drop the Vpb spinlock.
        //

        IoReleaseVpbSpinLock( SavedIrql );
    }

    return VcbDeleted;
}


VOID
FatConstructNamesInFcb (
    IN PIRP_CONTEXT IrpContext,
    PFCB Fcb,
    PDIRENT Dirent,
    PUNICODE_STRING Lfn OPTIONAL
    )

/*++

Routine Description:

    This routine places the short name in the dirent in the first set of
    STRINGs in the Fcb.  If a long file name (Lfn) was specified, then
    we must decide whether we will store its Oem equivolent in the same
    prefix table as the short name, or rather just save the upcased
    version of the UNICODE string in the FCB.

    For looking up Fcbs, the first approach will be faster, so we want to
    do this as much as possible.  Here are the rules that I have thought
    through extensively to determine when it is safe to store only Oem
    version of the UNICODE name.

    - If the UNICODE name contains no extended characters (>0x80), use Oem.

    - Let U be the upcased version of the UNICODE name.
      Let Up(x) be the function that upcases a UNICODE string.
      Let Down(x) be the function that upcases a UNICODE string.
      Let OemToUni(x) be the function that converts an Oem string to Unicode.
      Let UniToOem(x) be the function that converts a Unicode string to Oem.
      Let BestOemFit(x) be the function that creates the Best uppercase Oem
        fit for the UNICODE string x.

      BestOemFit(x) = UniToOem(Up(OemToUni(UniToOem(x))))   <1>

      if (BestOemFit(U) == BestOemFit(Down(U))              <2>

          then I know that there exists no UNICODE string Y such that:

              Up(Y) == Up(U)                                <3>

              AND

              BestOemFit(U) != BestOemFit(Y)                <4>

      Consider string U as a collection of one character strings.  The
      conjecture is clearly true for each sub-string, thus it is true
      for the entire string.

      Equation <1> is what we use to convert an incoming unicode name in
      FatCommonCreate() to Oem.  The double conversion is done to provide
      better visual best fitting for characters in the Ansi code page but
      not in the Oem code page.  A single Nls routine is provided to do
      this conversion efficiently.

      The idea is that with U, I only have to worry about a case varient Y
      matching it in a unicode compare, and I have shown that any case varient
      of U (the set Y defined in equation <3>), when filtered through <1>
      (as in create), will match the Oem string defined in <1>.

      Thus I do not have to worry about another UNICODE string missing in
      the prefix lookup, but matching when comparing LFNs in the directory.

Arguments:

    Fcb - The Fcb we are supposed to fill in.  Note that ParentDcb must
        already be filled in.

    Dirent - The gives up the short name.

    Lfn - If provided, this gives us the long name.

Return Value:

    None

--*/

{
    NTSTATUS Status;
    ULONG i;

    OEM_STRING OemA;
    OEM_STRING OemB;
    UNICODE_STRING Unicode;
    POEM_STRING ShortName;
    POEM_STRING LongOemName;
    PUNICODE_STRING LongUniName;

    ShortName = &Fcb->ShortName.Name.Oem;

    ASSERT( ShortName->Buffer == NULL );

    try {

        //
        //  First do the short name.
        //

        //
        //  Copy over the case flags for the short name of the file
        //

        if (FlagOn(Dirent->NtByte, FAT_DIRENT_NT_BYTE_8_LOWER_CASE)) {

            SetFlag(Fcb->FcbState, FCB_STATE_8_LOWER_CASE);

        } else {

            ClearFlag(Fcb->FcbState, FCB_STATE_8_LOWER_CASE);
        }

        if (FlagOn(Dirent->NtByte, FAT_DIRENT_NT_BYTE_3_LOWER_CASE)) {

            SetFlag(Fcb->FcbState, FCB_STATE_3_LOWER_CASE);

        } else {

            ClearFlag(Fcb->FcbState, FCB_STATE_3_LOWER_CASE);
        }

        ShortName->MaximumLength = 16;
        ShortName->Buffer = FsRtlAllocatePoolWithTag( PagedPool,
                                                      16,
                                                      TAG_FILENAME_BUFFER );

        Fat8dot3ToString( IrpContext, Dirent, FALSE, ShortName );

        //
        //  If no Lfn was specified, we are done.  In either case, set the
        //  final name length.
        //

        ASSERT( Fcb->ExactCaseLongName.Buffer == NULL );

        if (!ARGUMENT_PRESENT(Lfn) || (Lfn->Length == 0)) {

            Fcb->FinalNameLength = (USHORT) RtlOemStringToCountedUnicodeSize( ShortName );
            Fcb->ExactCaseLongName.Length = Fcb->ExactCaseLongName.MaximumLength = 0;

            try_return( NOTHING );
        }

        //
        //  If we already set up the full filename, we could be in trouble.  If the fast
        //  path for doing it already fired, FatSetFullFileNameInFcb, it will have missed
        //  this and could have built the full filename out of the shortname of the file.
        //
        //  At that point, disaster could be inevitable since the final name length will not
        //  match.  We use this to tell the notify package what to do - FatNotifyReportChange.
        //

        ASSERT( Fcb->FullFileName.Buffer == NULL );

        //
        //  We know now we have an Lfn, save away a copy.
        //

        Fcb->FinalNameLength = Lfn->Length;

        Fcb->ExactCaseLongName.Length = Fcb->ExactCaseLongName.MaximumLength = Lfn->Length;
        Fcb->ExactCaseLongName.Buffer = FsRtlAllocatePoolWithTag( PagedPool,
                                                                  Lfn->Length,
                                                                  TAG_FILENAME_BUFFER );
        RtlCopyMemory(Fcb->ExactCaseLongName.Buffer, Lfn->Buffer, Lfn->Length);

        //
        //  First check for no extended characters.
        //

        for (i=0; i < Lfn->Length/sizeof(WCHAR); i++) {

            if (Lfn->Buffer[i] >= 0x80) {

                break;
            }
        }

        if (i == Lfn->Length/sizeof(WCHAR)) {

            //
            //  Cool, I can go with the Oem, upcase it fast by hand.
            //

            LongOemName = &Fcb->LongName.Oem.Name.Oem;


            LongOemName->Buffer = FsRtlAllocatePoolWithTag( PagedPool,
                                                            Lfn->Length/sizeof(WCHAR),
                                                            TAG_FILENAME_BUFFER );
            LongOemName->Length =
            LongOemName->MaximumLength = Lfn->Length/sizeof(WCHAR);

            for (i=0; i < Lfn->Length/sizeof(WCHAR); i++) {

                WCHAR c;

                c = Lfn->Buffer[i];

                LongOemName->Buffer[i] = c < 'a' ?
                                         (UCHAR)c :
                                         c <= 'z' ?
                                         c - (UCHAR)('a'-'A') :
                                         (UCHAR) c;
            }

            //
            //  If this name happens to be exactly the same as the short
            //  name, don't add it to the splay table.
            //

            if (FatAreNamesEqual(IrpContext, *ShortName, *LongOemName) ||
                (FatFindFcb( IrpContext,
                             &Fcb->ParentDcb->Specific.Dcb.RootOemNode,
                             LongOemName,
                             NULL) != NULL)) {

                ExFreePool( LongOemName->Buffer );

                LongOemName->Buffer = NULL;
                LongOemName->Length =
                LongOemName->MaximumLength = 0;

            } else {

                SetFlag( Fcb->FcbState, FCB_STATE_HAS_OEM_LONG_NAME );
            }

            try_return( NOTHING );
        }

        //
        //  Now we have the fun part.  Make a copy of the Lfn.
        //

        OemA.Buffer = NULL;
        OemB.Buffer = NULL;
        Unicode.Buffer = NULL;

        Unicode.Length =
        Unicode.MaximumLength = Lfn->Length;
        Unicode.Buffer = FsRtlAllocatePoolWithTag( PagedPool,
                                                   Lfn->Length,
                                                   TAG_FILENAME_BUFFER );

        RtlCopyMemory( Unicode.Buffer, Lfn->Buffer, Lfn->Length );

        Status = STATUS_SUCCESS;

#if TRUE
        //
        //  Unfortunately, this next block of code breaks down when you have
        //  two long Unicode filenames that both map to the same Oem (and are,
        //  well, long, i.e. are not the short names). In this case, with one
        //  in the prefix table first, the other will hit the common Oem
        //  representation.  This leads to several forms of user astonishment.
        //
        //  It isn't worth it, or probably even possible, to try to figure out
        //  when this is really safe to go through.  Simply omit the attempt.
        //
        //  Ex: ANSI 0x82 and 0x84 in the 1252 ANSI->UNI and 437 UNI->OEM codepages.
        //
        //      0x82 => 0x201a => 0x2c
        //      0x84 => 0x201e => 0x2c
        //
        //  0x2c is comma, so is FAT Oem illegal and forces shortname generation.
        //  Since it is otherwise well-formed by the rules articulated previously,
        //  we would have put 0x2c in the Oem prefix tree.  In terms of the
        //  argument given above, even though there exist no Y and U s.t.
        //
        //  Up(Y) == Up(U) && BestOemFit(U) != BestOemFit(Y)
        //
        //  there most certainly exist Y and U s.t.
        //
        //  Up(Y) != Up(U) && BestOemFit(U) == BestOemFit(Y)
        //
        //  and that is enough to keep us from doing this.  Note that the < 0x80
        //  case is OK since we know that the mapping in the OEM codepages are
        //  the identity in that range.
        //
        //  We still need to monocase it, though.  Do this through a full down/up
        //  transition.
        //

        (VOID)RtlDowncaseUnicodeString( &Unicode, &Unicode, FALSE );
        (VOID)RtlUpcaseUnicodeString( &Unicode, &Unicode, FALSE );
#else
        //
        //  Downcase and convert to upcased Oem.  Only continue if we can
        //  convert without error.  Any error other than UNMAPPABLE_CHAR
        //  is a fatal error and we raise.
        //
        //  Note that even if the conversion fails, we must leave Unicode
        //  in an upcased state.
        //
        //  NB: The Rtl doesn't NULL .Buffer on error.
        //

        (VOID)RtlDowncaseUnicodeString( &Unicode, &Unicode, FALSE );
        Status = RtlUpcaseUnicodeStringToCountedOemString( &OemA, &Unicode, TRUE );
        (VOID)RtlUpcaseUnicodeString( &Unicode, &Unicode, FALSE );

        if (!NT_SUCCESS(Status)) {

            if (Status != STATUS_UNMAPPABLE_CHARACTER) {

                ASSERT( Status == STATUS_NO_MEMORY );
                ExFreePool(Unicode.Buffer);
                FatNormalizeAndRaiseStatus( IrpContext, Status );
            }

        } else {

            //
            //  The same as above except upcase.
            //

            Status = RtlUpcaseUnicodeStringToCountedOemString( &OemB, &Unicode, TRUE );

            if (!NT_SUCCESS(Status)) {

                RtlFreeOemString( &OemA );

                if (Status != STATUS_UNMAPPABLE_CHARACTER) {

                    ASSERT( Status == STATUS_NO_MEMORY );
                    ExFreePool(Unicode.Buffer);
                    FatNormalizeAndRaiseStatus( IrpContext, Status );
                }
            }
        }

        //
        //  If the final OemNames are equal, I can use save only the Oem
        //  name.  If the name did not map, then I have to go with the UNICODE
        //  name because I could get a case varient that didn't convert
        //  in create, but did match the LFN.
        //

        if (NT_SUCCESS(Status) && FatAreNamesEqual( IrpContext, OemA, OemB )) {

            //
            //  Cool, I can go with the Oem.  If we didn't convert correctly,
            //  get a fresh convert from the original LFN.
            //

            ExFreePool(Unicode.Buffer);

            RtlFreeOemString( &OemB );

            Fcb->LongName.Oem.Name.Oem = OemA;

            //
            //  If this name happens to be exactly the same as the short
            //  name, or a similar short name already exists don't add it
            //  to the splay table (note the final condition implies a
            //  corrupt disk.
            //

            if (FatAreNamesEqual(IrpContext, *ShortName, OemA) ||
                (FatFindFcb( IrpContext,
                             &Fcb->ParentDcb->Specific.Dcb.RootOemNode,
                             &OemA,
                             NULL) != NULL)) {

                RtlFreeOemString( &OemA );

            } else {

                SetFlag( Fcb->FcbState, FCB_STATE_HAS_OEM_LONG_NAME );
            }

            try_return( NOTHING );
        }

        //
        //  The long name must be left in UNICODE.  Free the two Oem strings
        //  if we got here just because they weren't equal.
        //

        if (NT_SUCCESS(Status)) {

            RtlFreeOemString( &OemA );
            RtlFreeOemString( &OemB );
        }
#endif

        LongUniName = &Fcb->LongName.Unicode.Name.Unicode;

        LongUniName->Length =
        LongUniName->MaximumLength = Unicode.Length;
        LongUniName->Buffer = Unicode.Buffer;

        SetFlag(Fcb->FcbState, FCB_STATE_HAS_UNICODE_LONG_NAME);

    try_exit: NOTHING;
    } finally {

        if (AbnormalTermination()) {

            if (ShortName->Buffer != NULL) {

                ExFreePool( ShortName->Buffer );
                ShortName->Buffer = NULL;
            }

        } else {

            //
            //  Creating all the names worked, so add all the names
            //  to the splay tree.
            //

            FatInsertName( IrpContext,
                           &Fcb->ParentDcb->Specific.Dcb.RootOemNode,
                           &Fcb->ShortName );

            Fcb->ShortName.Fcb = Fcb;

            if (FlagOn(Fcb->FcbState, FCB_STATE_HAS_OEM_LONG_NAME)) {

                FatInsertName( IrpContext,
                               &Fcb->ParentDcb->Specific.Dcb.RootOemNode,
                               &Fcb->LongName.Oem );

                Fcb->LongName.Oem.Fcb = Fcb;
            }

            if (FlagOn(Fcb->FcbState, FCB_STATE_HAS_UNICODE_LONG_NAME)) {

                FatInsertName( IrpContext,
                               &Fcb->ParentDcb->Specific.Dcb.RootUnicodeNode,
                               &Fcb->LongName.Unicode );

                Fcb->LongName.Unicode.Fcb = Fcb;
            }

            SetFlag(Fcb->FcbState, FCB_STATE_NAMES_IN_SPLAY_TREE);
        }
    }

    return;
}


VOID
FatCheckFreeDirentBitmap (
    IN PIRP_CONTEXT IrpContext,
    IN PDCB Dcb
    )

/*++

Routine Description:

    This routine checks if the size of the free dirent bitmap is
    sufficient to for the current directory size.  It is called
    whenever we grow a directory.

Arguments:

    Dcb -  Supplies the directory in question.

Return Value:

    None

--*/

{
    ULONG OldNumberOfDirents;
    ULONG NewNumberOfDirents;

    //
    //  Setup the Bitmap buffer if it is not big enough already
    //

    ASSERT( Dcb->Header.AllocationSize.QuadPart != FCB_LOOKUP_ALLOCATIONSIZE_HINT );

    OldNumberOfDirents = Dcb->Specific.Dcb.FreeDirentBitmap.SizeOfBitMap;
    NewNumberOfDirents = Dcb->Header.AllocationSize.LowPart / sizeof(DIRENT);

    //
    //  Do the usual unsync/sync check.
    //

    if (NewNumberOfDirents > OldNumberOfDirents) {

        FatAcquireDirectoryFileMutex( Dcb->Vcb );

        try {

            PULONG OldBitmapBuffer;
            PULONG BitmapBuffer;

            ULONG BytesInBitmapBuffer;
            ULONG BytesInOldBitmapBuffer;

            OldNumberOfDirents = Dcb->Specific.Dcb.FreeDirentBitmap.SizeOfBitMap;
            NewNumberOfDirents = Dcb->Header.AllocationSize.LowPart / sizeof(DIRENT);

            if (NewNumberOfDirents > OldNumberOfDirents) {

                //
                //  Remember the old bitmap
                //

                OldBitmapBuffer = Dcb->Specific.Dcb.FreeDirentBitmap.Buffer;

                //
                //  Now make a new bitmap bufffer
                //

                BytesInBitmapBuffer = NewNumberOfDirents / 8;

                BytesInOldBitmapBuffer = OldNumberOfDirents / 8;

                if (DCB_UNION_SLACK_SPACE >= BytesInBitmapBuffer) {

                    BitmapBuffer = &Dcb->Specific.Dcb.FreeDirentBitmapBuffer[0];

                } else {

                    BitmapBuffer = FsRtlAllocatePoolWithTag( PagedPool,
                                                             BytesInBitmapBuffer,
                                                             TAG_DIRENT_BITMAP );
                }

                //
                //  Copy the old buffer to the new buffer, free the old one, and zero
                //  the rest of the new one.  Only do the first two steps though if
                //  we moved out of the initial buffer.
                //

                if ((OldNumberOfDirents != 0) &&
                    (BitmapBuffer != &Dcb->Specific.Dcb.FreeDirentBitmapBuffer[0])) {

                    RtlCopyMemory( BitmapBuffer,
                                   OldBitmapBuffer,
                                   BytesInOldBitmapBuffer );

                    if (OldBitmapBuffer != &Dcb->Specific.Dcb.FreeDirentBitmapBuffer[0]) {

                        ExFreePool( OldBitmapBuffer );
                    }
                }

                ASSERT( BytesInBitmapBuffer > BytesInOldBitmapBuffer );

                RtlZeroMemory( (PUCHAR)BitmapBuffer + BytesInOldBitmapBuffer,
                               BytesInBitmapBuffer - BytesInOldBitmapBuffer );

                //
                //  Now initialize the new bitmap.
                //

                RtlInitializeBitMap( &Dcb->Specific.Dcb.FreeDirentBitmap,
                                     BitmapBuffer,
                                     NewNumberOfDirents );
            }

        } finally {

            FatReleaseDirectoryFileMutex( Dcb->Vcb );
        }
    }
}


BOOLEAN
FatIsHandleCountZero (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine decides if the handle count on the volume is zero.

Arguments:

    Vcb - The volume in question

Return Value:

    BOOLEAN - TRUE if there are no open handles on the volume, FALSE
              otherwise.

--*/

{
    PFCB Fcb;

    Fcb = Vcb->RootDcb;

    while (Fcb != NULL) {

        if (Fcb->UncleanCount != 0) {

            return FALSE;
        }

        Fcb = FatGetNextFcbTopDown(IrpContext, Fcb, Vcb->RootDcb);
    }

    return TRUE;
}


VOID
FatPreallocateCloseContext (
    )

/*++

Routine Description:

    This routine preallocates a close context, presumeably on behalf
    of a fileobject which does not have a structure we can embed one
    in.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PCLOSE_CONTEXT CloseContext = FsRtlAllocatePoolWithTag( PagedPool,
                                                            sizeof(CLOSE_CONTEXT),
                                                            TAG_FAT_CLOSE_CONTEXT );

    ExInterlockedPushEntrySList( &FatCloseContextSList,
                                 (PSINGLE_LIST_ENTRY) CloseContext,
                                 &FatData.GeneralSpinLock );
}


VOID
FatEnsureStringBufferEnough(
    IN OUT PVOID String,
    IN USHORT DesiredBufferSize
    )
/*++

Routine Description:

    Ensures that a string string (STRING, UNICODE_STRING, ANSI_STRING, OEM_STRING)
    has a buffer >= DesiredBufferSize,  allocating from pool if neccessary.  Any
    existing pool buffer will be freed if a new one is allocated.

    NOTE: No copy of old buffer contents is performed on reallocation.
    
    Will raise on allocation failure.

Arguments:

    String - pointer to string structure

    DesiredBufferSize - (bytes) minimum required buffer size

--*/
{
    PSTRING LocalString = String;
    
    if (LocalString->MaximumLength < DesiredBufferSize)  {

        FatFreeStringBuffer( LocalString);

        LocalString->Buffer = FsRtlAllocatePoolWithTag( PagedPool, 
                                                        DesiredBufferSize, 
                                                        TAG_DYNAMIC_NAME_BUFFER);
        ASSERT( LocalString->Buffer);

        LocalString->MaximumLength = DesiredBufferSize;                
    }
}


VOID
FatFreeStringBuffer(
    IN PVOID String
    )
/*++

Routine Description:

    Frees the buffer of an string (STRING, UNICODE_STRING, ANSI_STRING, OEM_STRING) 
    structure if it is not within the current thread's stack limits.

    Regardless of action performed,  on exit String->Buffer will be set to NULL and 
    String->MaximumLength to zero.

Arguments:

    String - pointer to string structure

--*/
{
    ULONG_PTR High, Low;
    PSTRING LocalString = String;

    if (NULL != LocalString->Buffer)  {

        IoGetStackLimits( &Low, &High );
    
        if (((ULONG_PTR)(LocalString->Buffer) < Low) || 
            ((ULONG_PTR)(LocalString->Buffer) > High))  {
        
            ExFreePool( LocalString->Buffer);
        }

        LocalString->Buffer = NULL;
    }

    LocalString->MaximumLength = LocalString->Length = 0;
}


BOOLEAN
FatScanForDataTrack(
    IN PIRP_CONTEXT IrpContext,
    IN PDEVICE_OBJECT TargetDeviceObject
    )

/*++

Routine Description:

    This routine is called to verify and process the TOC for this disk.

    FAT queries for the TOC to avoid trying to mount on CD-DA/CD-E media,  Doing data reads on
    audio/leadin of that media sends a lot of drives into what could charitably be called
    "conniptions" which take a couple seconds to clear and would also convince FAT that the
    device was busted, and fail the mount (not letting CDFS get its crack).

    There is special handling of PD media.  These things fail the TOC read, but return
    a special error code so FAT knows to continue to try the mount anyway.

Arguments:

    TargetDeviceObject - Device object to send TOC request to.

Return Value:

    BOOLEAN - TRUE if we found a TOC with a single data track.

--*/

{
    NTSTATUS Status;
    IO_STATUS_BLOCK Iosb;

    ULONG LocalTrackCount;
    ULONG LocalTocLength;

    PCDROM_TOC CdromToc;
    BOOLEAN Result = FALSE;

    PAGED_CODE();

    CdromToc = FsRtlAllocatePoolWithTag( PagedPool,
                                         sizeof( CDROM_TOC ),
                                         TAG_IO_BUFFER );

    RtlZeroMemory( CdromToc, sizeof( CDROM_TOC ));

    try {
    
        //
        //  Go ahead and read the table of contents
        //

        Status = FatPerformDevIoCtrl( IrpContext,
                                     IOCTL_CDROM_READ_TOC,
                                     TargetDeviceObject,
                                     CdromToc,
                                     sizeof( CDROM_TOC ),
                                     FALSE,
                                     TRUE,
                                     &Iosb );

        //
        //  Nothing to process if this request fails.
        //

        if (Status != STATUS_SUCCESS) {

            //
            //  If we get the special error indicating a failed TOC read on PD media just
            //  plow ahead with the mount (see comments above).
            //

            if ((Status == STATUS_IO_DEVICE_ERROR) || (Status == STATUS_INVALID_DEVICE_REQUEST)) {

                Result = TRUE;

            }

            try_leave( NOTHING );
        }

        //
        //  Get the number of tracks and stated size of this structure.
        //

        LocalTrackCount = CdromToc->LastTrack - CdromToc->FirstTrack + 1;
        LocalTocLength = PtrOffset( CdromToc, &CdromToc->TrackData[LocalTrackCount + 1] );

        //
        //  Get out if there is an immediate problem with the TOC,  or more than 
        //  one track.
        //

        if ((LocalTocLength > Iosb.Information) ||
            (CdromToc->FirstTrack > CdromToc->LastTrack) ||
            (LocalTrackCount != 1)) {

            try_leave( NOTHING);
        }

        //
        //  Is it a data track?  DVD-RAM reports single,  data,  track.
        //

        Result = BooleanFlagOn( CdromToc->TrackData[ 0].Control, 0x04 );
    }
    finally {
    
        ExFreePool( CdromToc);
    }

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fastfat\workque.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    WorkQue.c

Abstract:

    This module implements the Work queue routines for the Fat File
    system.

// @@BEGIN_DDKSPLIT

Author:

    Gary Kimura     [GaryKi]    15-Jan-1990

Revision History:

// @@END_DDKSPLIT

--*/

#include "FatProcs.h"

//
//  The following constant is the maximum number of ExWorkerThreads that we
//  will allow to be servicing a particular target device at any one time.
//

#define FSP_PER_DEVICE_THRESHOLD         (2)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FatOplockComplete)
#pragma alloc_text(PAGE, FatPrePostIrp)
#endif


VOID
FatOplockComplete (
    IN PVOID Context,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the oplock package when an oplock break has
    completed, allowing an Irp to resume execution.  If the status in
    the Irp is STATUS_SUCCESS, then we queue the Irp to the Fsp queue.
    Otherwise we complete the Irp with the status in the Irp.

Arguments:

    Context - Pointer to the IrpContext to be queued to the Fsp

    Irp - I/O Request Packet.

Return Value:

    None.

--*/

{
    //
    //  Check on the return value in the Irp.
    //

    if (Irp->IoStatus.Status == STATUS_SUCCESS) {

        //
        //  Insert the Irp context in the workqueue.
        //

        FatAddToWorkque( (PIRP_CONTEXT) Context, Irp );

    //
    //  Otherwise complete the request.
    //

    } else {

        FatCompleteRequest( (PIRP_CONTEXT) Context, Irp, Irp->IoStatus.Status );
    }

    return;
}


VOID
FatPrePostIrp (
    IN PVOID Context,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine performs any neccessary work before STATUS_PENDING is
    returned with the Fsd thread.  This routine is called within the
    filesystem and by the oplock package.

Arguments:

    Context - Pointer to the IrpContext to be queued to the Fsp

    Irp - I/O Request Packet.

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION IrpSp;
    PIRP_CONTEXT IrpContext;

    //
    //  If there is no Irp, we are done.
    //

    if (Irp == NULL) {

        return;
    }

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    IrpContext = (PIRP_CONTEXT) Context;

    //
    //  If there is a STACK FatIoContext pointer, clean and NULL it.
    //

    if ((IrpContext->FatIoContext != NULL) &&
        FlagOn(IrpContext->Flags, IRP_CONTEXT_STACK_IO_CONTEXT)) {

        ClearFlag(IrpContext->Flags, IRP_CONTEXT_STACK_IO_CONTEXT);
        IrpContext->FatIoContext = NULL;
    }

    //
    //  We need to lock the user's buffer, unless this is an MDL-read,
    //  in which case there is no user buffer.
    //
    //  **** we need a better test than non-MDL (read or write)!

    if (IrpContext->MajorFunction == IRP_MJ_READ ||
        IrpContext->MajorFunction == IRP_MJ_WRITE) {

        //
        //  If not an Mdl request, lock the user's buffer.
        //

        if (!FlagOn( IrpContext->MinorFunction, IRP_MN_MDL )) {

            FatLockUserBuffer( IrpContext,
                               Irp,
                               (IrpContext->MajorFunction == IRP_MJ_READ) ?
                               IoWriteAccess : IoReadAccess,
                               (IrpContext->MajorFunction == IRP_MJ_READ) ?
                               IrpSp->Parameters.Read.Length : IrpSp->Parameters.Write.Length );
        }

    //
    //  We also need to check whether this is a query file operation.
    //

    } else if (IrpContext->MajorFunction == IRP_MJ_DIRECTORY_CONTROL
               && IrpContext->MinorFunction == IRP_MN_QUERY_DIRECTORY) {

        FatLockUserBuffer( IrpContext,
                           Irp,
                           IoWriteAccess,
                           IrpSp->Parameters.QueryDirectory.Length );

    //
    //  We also need to check whether this is a query ea operation.
    //

    } else if (IrpContext->MajorFunction == IRP_MJ_QUERY_EA) {

        FatLockUserBuffer( IrpContext,
                           Irp,
                           IoWriteAccess,
                           IrpSp->Parameters.QueryEa.Length );

    //
    //  We also need to check whether this is a set ea operation.
    //

    } else if (IrpContext->MajorFunction == IRP_MJ_SET_EA) {

        FatLockUserBuffer( IrpContext,
                           Irp,
                           IoReadAccess,
                           IrpSp->Parameters.SetEa.Length );

    //
    //  These two FSCTLs use neither I/O, so check for them.
    //

    } else if ((IrpContext->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL) &&
               (IrpContext->MinorFunction == IRP_MN_USER_FS_REQUEST) &&
               ((IrpSp->Parameters.FileSystemControl.FsControlCode == FSCTL_GET_VOLUME_BITMAP) ||
                (IrpSp->Parameters.FileSystemControl.FsControlCode == FSCTL_GET_RETRIEVAL_POINTERS))) {

        FatLockUserBuffer( IrpContext,
                           Irp,
                           IoWriteAccess,
                           IrpSp->Parameters.FileSystemControl.OutputBufferLength );
    }

    //
    //  Mark that we've already returned pending to the user
    //

    IoMarkIrpPending( Irp );

    return;
}


NTSTATUS
FatFsdPostRequest(
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine enqueues the request packet specified by IrpContext to the
    Ex Worker threads.  This is a FSD routine.

Arguments:

    IrpContext - Pointer to the IrpContext to be queued to the Fsp

    Irp - I/O Request Packet, or NULL if it has already been completed.

Return Value:

    STATUS_PENDING


--*/

{
    ASSERT( ARGUMENT_PRESENT(Irp) );
    ASSERT( IrpContext->OriginatingIrp == Irp );

    FatPrePostIrp( IrpContext, Irp );

    FatAddToWorkque( IrpContext, Irp );

    //
    //  And return to our caller
    //

    return STATUS_PENDING;
}


//
//  Local support routine.
//

VOID
FatAddToWorkque (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called to acually store the posted Irp to the Fsp
    workque.

Arguments:

    IrpContext - Pointer to the IrpContext to be queued to the Fsp

    Irp - I/O Request Packet.

Return Value:

    None.

--*/

{
    KIRQL SavedIrql;
    PIO_STACK_LOCATION IrpSp;

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Check if this request has an associated file object, and thus volume
    //  device object.
    //

    if ( IrpSp->FileObject != NULL ) {

        PVOLUME_DEVICE_OBJECT Vdo;

        Vdo = CONTAINING_RECORD( IrpSp->DeviceObject,
                                 VOLUME_DEVICE_OBJECT,
                                 DeviceObject );

        //
        //  Check to see if this request should be sent to the overflow
        //  queue.  If not, then send it off to an exworker thread.
        //

        KeAcquireSpinLock( &Vdo->OverflowQueueSpinLock, &SavedIrql );

        if ( Vdo->PostedRequestCount > FSP_PER_DEVICE_THRESHOLD) {

            //
            //  We cannot currently respond to this IRP so we'll just enqueue it
            //  to the overflow queue on the volume.
            //

            InsertTailList( &Vdo->OverflowQueue,
                            &IrpContext->WorkQueueItem.List );

            Vdo->OverflowQueueCount += 1;

            KeReleaseSpinLock( &Vdo->OverflowQueueSpinLock, SavedIrql );

            return;

        } else {

            //
            //  We are going to send this Irp to an ex worker thread so up
            //  the count.
            //

            Vdo->PostedRequestCount += 1;

            KeReleaseSpinLock( &Vdo->OverflowQueueSpinLock, SavedIrql );
        }
    }

    //
    //  Send it off.....
    //

    ExInitializeWorkItem( &IrpContext->WorkQueueItem,
                          FatFspDispatch,
                          IrpContext );

    ExQueueWorkItem( &IrpContext->WorkQueueItem, CriticalWorkQueue );

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fastfat\splaysup.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    PrefxSup.c

Abstract:

    This module implements the Fat Name lookup Suport routines

// @@BEGIN_DDKSPLIT

Author:

    David Goebel     [DavidGoe]    31-Jan-1994

Revision History:

// @@END_DDKSPLIT

--*/

#include "FatProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (FAT_BUG_CHECK_SPLAYSUP)

//
//  The debug trace level for this module
//

#define Dbg                              (DEBUG_TRACE_SPLAYSUP)

//
//  Local procedures and types used only in this package
//

typedef enum _COMPARISON {
    IsLessThan,
    IsGreaterThan,
    IsEqual
} COMPARISON;

COMPARISON
FatCompareNames (
    IN PSTRING NameA,
    IN PSTRING NameB
    );

//
//  Do a macro here to check for a common case.
//

#define CompareNames(NAMEA,NAMEB) (                        \
    *(PUCHAR)(NAMEA)->Buffer != *(PUCHAR)(NAMEB)->Buffer ? \
    *(PUCHAR)(NAMEA)->Buffer < *(PUCHAR)(NAMEB)->Buffer ?  \
    IsLessThan : IsGreaterThan :                           \
    FatCompareNames((PSTRING)(NAMEA), (PSTRING)(NAMEB))    \
)


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FatInsertName)
#pragma alloc_text(PAGE, FatRemoveNames)
#pragma alloc_text(PAGE, FatFindFcb)
#pragma alloc_text(PAGE, FatCompareNames)
#endif


VOID
FatInsertName (
    IN PIRP_CONTEXT IrpContext,
    IN PRTL_SPLAY_LINKS *RootNode,
    IN PFILE_NAME_NODE Name
    )

/*++

Routine Description:

    This routine will insert a name in the splay tree pointed to
    by RootNode.

    The name must not already exist in the splay tree.

Arguments:

    RootNode - Supplies a pointer to the table.

    Name - Contains the New name to enter.

Return Value:

    None.

--*/

{
    COMPARISON Comparison;
    PFILE_NAME_NODE Node;

    RtlInitializeSplayLinks(&Name->Links);

    //
    //  If we are the first entry in the tree, just become the root.
    //

    if (*RootNode == NULL) {

        *RootNode = &Name->Links;

        return;
    }

Restart:

    Node = CONTAINING_RECORD( *RootNode, FILE_NAME_NODE, Links );

    while (TRUE) {

        //
        //  Compare the prefix in the tree with the prefix we want
        //  to insert.  Note that Oem here doesn't mean anything.
        //

        Comparison = CompareNames(&Node->Name.Oem, &Name->Name.Oem);

        //
        //  We should never find the name in the table already.
        //

        if (Comparison == IsEqual) {

            //
            //  Almost. If the removable media was taken to another machine and
            //  back, and we have something like:
            //
            //  Old: foobar~1  /  foobarbaz
            //  New: foobar~1  /  foobarbazbaz
            //
            //  but a handle was kept open to foobarbaz so we couldn't purge
            //  away the Fcb in the verify path ... opening foobarbazbaz will
            //  try to insert a duplicate shortname. Bang!
            //
            //  Invalidate it and the horse it came in on.  This new one wins.
            //  The old one is gone.  Only if the old one is in normal state
            //  do we really have a problem.
            //
            
            if (Node->Fcb->FcbState == FcbGood) {
                
                FatBugCheck( (ULONG_PTR)*RootNode, (ULONG_PTR)Name, (ULONG_PTR)Node );
            }

            //
            //  Note, once we zap the prefix links we need to restart our walk
            //  of the tree.
            //
            
            FatMarkFcbCondition( IrpContext, Node->Fcb, FcbBad, TRUE );
            FatRemoveNames( IrpContext, Node->Fcb );

            goto Restart;
        }

        //
        //  If the tree prefix is greater than the new prefix then
        //  we go down the left subtree
        //

        if (Comparison == IsGreaterThan) {

            //
            //  We want to go down the left subtree, first check to see
            //  if we have a left subtree
            //

            if (RtlLeftChild(&Node->Links) == NULL) {

                //
                //  there isn't a left child so we insert ourselves as the
                //  new left child
                //

                RtlInsertAsLeftChild(&Node->Links, &Name->Links);

                //
                //  and exit the while loop
                //

                break;

            } else {

                //
                //  there is a left child so simply go down that path, and
                //  go back to the top of the loop
                //

                Node = CONTAINING_RECORD( RtlLeftChild(&Node->Links),
                                          FILE_NAME_NODE,
                                          Links );
            }

        } else {

            //
            //  The tree prefix is either less than or a proper prefix
            //  of the new string.  We treat both cases a less than when
            //  we do insert.  So we want to go down the right subtree,
            //  first check to see if we have a right subtree
            //

            if (RtlRightChild(&Node->Links) == NULL) {

                //
                //  These isn't a right child so we insert ourselves as the
                //  new right child
                //

                RtlInsertAsRightChild(&Node->Links, &Name->Links);

                //
                //  and exit the while loop
                //

                break;

            } else {

                //
                //  there is a right child so simply go down that path, and
                //  go back to the top of the loop
                //

                Node = CONTAINING_RECORD( RtlRightChild(&Node->Links),
                                          FILE_NAME_NODE,
                                          Links );
            }

        }
    }

    return;
}

VOID
FatRemoveNames (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine will remove the short name and any long names associated
    with the files from their repsective splay tree.

Arguments:

    Name - Supplies the Fcb to process.

Return Value:

    None.

--*/

{
    PDCB Parent;
    PRTL_SPLAY_LINKS NewRoot;

    Parent = Fcb->ParentDcb;

    //
    //  We used to assert this condition, but it really isn't good.  If
    //  someone rapidly renames a directory multiple times and we can't
    //  flush the lower fcbs fast enough (that didn't go away synch.)
    //  well, well hit some of them again.
    //
    //  ASSERT( FlagOn( Fcb->FcbState, FCB_STATE_NAMES_IN_SPLAY_TREE ));
    //

    if (FlagOn( Fcb->FcbState, FCB_STATE_NAMES_IN_SPLAY_TREE )) {

        //
        //  Delete the node short name.
        //

        NewRoot = RtlDelete(&Fcb->ShortName.Links);

        Parent->Specific.Dcb.RootOemNode = NewRoot;

        //
        //  Now check for the presence of long name and delete it.
        //

        if (FlagOn( Fcb->FcbState, FCB_STATE_HAS_OEM_LONG_NAME )) {

            NewRoot = RtlDelete(&Fcb->LongName.Oem.Links);

            Parent->Specific.Dcb.RootOemNode = NewRoot;

            RtlFreeOemString( &Fcb->LongName.Oem.Name.Oem );

            ClearFlag( Fcb->FcbState, FCB_STATE_HAS_OEM_LONG_NAME );
        }

        if (FlagOn( Fcb->FcbState, FCB_STATE_HAS_UNICODE_LONG_NAME )) {

            NewRoot = RtlDelete(&Fcb->LongName.Unicode.Links);

            Parent->Specific.Dcb.RootUnicodeNode = NewRoot;

            RtlFreeUnicodeString( &Fcb->LongName.Unicode.Name.Unicode );

            ClearFlag( Fcb->FcbState, FCB_STATE_HAS_UNICODE_LONG_NAME );
        }

        ClearFlag( Fcb->FcbState, FCB_STATE_NAMES_IN_SPLAY_TREE );
    }

    return;
}


PFCB
FatFindFcb (
    IN PIRP_CONTEXT IrpContext,
    IN OUT PRTL_SPLAY_LINKS *RootNode,
    IN PSTRING Name,
    OUT PBOOLEAN FileNameDos OPTIONAL
    )

/*++

Routine Description:

    This routine searches either the Oem or Unicode splay tree looking
    for an Fcb with the specified name.  In the case the Fcb is found,
    rebalance the tree.

Arguments:

    RootNode - Supplies the parent to search.

    Name - If present, search the Oem tree.

    UnicodeName - If present, search the Unicode tree.

Return Value:

    PFCB - The Fcb, or NULL if none was found.

--*/

{
    COMPARISON Comparison;
    PFILE_NAME_NODE Node;
    PRTL_SPLAY_LINKS Links;

    Links = *RootNode;

    while (Links != NULL) {

        Node = CONTAINING_RECORD(Links, FILE_NAME_NODE, Links);

        //
        //  Compare the prefix in the tree with the full name
        //

        Comparison = CompareNames(&Node->Name.Oem, Name);

        //
        //  See if they don't match
        //

        if (Comparison == IsGreaterThan) {

            //
            //  The prefix is greater than the full name
            //  so we go down the left child
            //

            Links = RtlLeftChild(Links);

            //
            //  And continue searching down this tree
            //

        } else if (Comparison == IsLessThan) {

            //
            //  The prefix is less than the full name
            //  so we go down the right child
            //

            Links = RtlRightChild(Links);

            //
            //  And continue searching down this tree
            //

        } else {

            //
            //  We found it.
            //
            //  Splay the tree and save the new root.
            //

            *RootNode = RtlSplay(Links);

            //
            //  Tell the caller what kind of name we hit
            //

            if (FileNameDos) {

                *FileNameDos = Node->FileNameDos;
            }

            return Node->Fcb;
        }
    }

    //
    //  We didn't find the Fcb.
    //

    return NULL;
}


//
//  Local support routine
//

COMPARISON
FatCompareNames (
    IN PSTRING NameA,
    IN PSTRING NameB
    )

/*++

Routine Description:

    This function compares two names as fast as possible.  Note that since
    this comparison is case sensitive, I neither know nor case if the names
    are UNICODE or OEM.  All that is important is that the result is
    deterministic.

Arguments:

    NameA & NameB - The names to compare.

Return Value:

    COMPARISON - returns

        IsLessThan    if NameA < NameB lexicalgraphically,
        IsGreaterThan if NameA > NameB lexicalgraphically,
        IsEqual       if NameA is equal to NameB

--*/

{
    ULONG i;
    ULONG MinLength;

    PAGED_CODE();

    //
    //  Figure out the minimum of the two lengths
    //

    MinLength = NameA->Length < NameB->Length ? NameA->Length :
                                                NameB->Length;

    //
    //  Loop through looking at all of the characters in both strings
    //  testing for equalilty, less than, and greater than
    //

    i = (ULONG)RtlCompareMemory( NameA->Buffer, NameB->Buffer, MinLength );


    if (i < MinLength) {

        return NameA->Buffer[i] < NameB->Buffer[i] ? IsLessThan :
                                                     IsGreaterThan;
    }

    if (NameA->Length < NameB->Length) {

        return IsLessThan;
    }

    if (NameA->Length > NameB->Length) {

        return IsGreaterThan;
    }

    return IsEqual;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fastfat\volinfo.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    VolInfo.c

Abstract:

    This module implements the volume information routines for Fat called by
    the dispatch driver.

// @@BEGIN_DDKSPLIT

Author:

    Gary Kimura     [GaryKi]    12-Apr-1990

Revision History:

// @@END_DDKSPLIT

--*/

#include "FatProcs.h"

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_VOLINFO)

NTSTATUS
FatQueryFsVolumeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_VOLUME_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
FatQueryFsSizeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_SIZE_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
FatQueryFsDeviceInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_DEVICE_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
FatQueryFsAttributeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_ATTRIBUTE_INFORMATION Buffer,
    IN OUT PULONG Length
    );

NTSTATUS
FatQueryFsFullSizeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_FULL_SIZE_INFORMATION Buffer,
    IN OUT PULONG Length
    );
 
NTSTATUS
FatSetFsLabelInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_LABEL_INFORMATION Buffer
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FatCommonQueryVolumeInfo)
#pragma alloc_text(PAGE, FatCommonSetVolumeInfo)
#pragma alloc_text(PAGE, FatFsdQueryVolumeInformation)
#pragma alloc_text(PAGE, FatFsdSetVolumeInformation)
#pragma alloc_text(PAGE, FatQueryFsAttributeInfo)
#pragma alloc_text(PAGE, FatQueryFsDeviceInfo)
#pragma alloc_text(PAGE, FatQueryFsSizeInfo)
#pragma alloc_text(PAGE, FatQueryFsVolumeInfo)
#pragma alloc_text(PAGE, FatQueryFsFullSizeInfo)
#pragma alloc_text(PAGE, FatSetFsLabelInfo)
#endif


NTSTATUS
FatFsdQueryVolumeInformation (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the Fsd part of the NtQueryVolumeInformation API
    call.

Arguments:

    VolumeDeviceObject - Supplies the volume device object where the file
        being queried exists.

    Irp - Supplies the Irp being processed.

Return Value:

    NTSTATUS - The FSD status for the Irp.

--*/

{
    NTSTATUS Status;
    PIRP_CONTEXT IrpContext = NULL;

    BOOLEAN TopLevel;

    DebugTrace(+1, Dbg, "FatFsdQueryVolumeInformation\n", 0);

    //
    //  Call the common query routine, with blocking allowed if synchronous
    //

    FsRtlEnterFileSystem();

    TopLevel = FatIsIrpTopLevel( Irp );

    try {

        IrpContext = FatCreateIrpContext( Irp, CanFsdWait( Irp ) );

        Status = FatCommonQueryVolumeInfo( IrpContext, Irp );

    } except(FatExceptionFilter( IrpContext, GetExceptionInformation() )) {

        //
        //  We had some trouble trying to perform the requested
        //  operation, so we'll abort the I/O request with
        //  the error status that we get back from the
        //  execption code
        //

        Status = FatProcessException( IrpContext, Irp, GetExceptionCode() );
    }

    if (TopLevel) { IoSetTopLevelIrp( NULL ); }

    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "FatFsdQueryVolumeInformation -> %08lx\n", Status);

    UNREFERENCED_PARAMETER( VolumeDeviceObject );

    return Status;
}


NTSTATUS
FatFsdSetVolumeInformation (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the NtSetVolumeInformation API
    call.

Arguments:

    VolumeDeviceObject - Supplies the volume device object where the file
        being set exists.

    Irp - Supplies the Irp being processed.

Return Value:

    NTSTATUS - The FSD status for the Irp.

--*/

{
    NTSTATUS Status;
    PIRP_CONTEXT IrpContext = NULL;

    BOOLEAN TopLevel;

    DebugTrace(+1, Dbg, "FatFsdSetVolumeInformation\n", 0);

    //
    //  Call the common set routine
    //

    FsRtlEnterFileSystem();

    TopLevel = FatIsIrpTopLevel( Irp );

    try {

        IrpContext = FatCreateIrpContext( Irp, CanFsdWait( Irp ) );

        Status = FatCommonSetVolumeInfo( IrpContext, Irp );

    } except(FatExceptionFilter( IrpContext, GetExceptionInformation() )) {

        //
        //  We had some trouble trying to perform the requested
        //  operation, so we'll abort the I/O request with
        //  the error status that we get back from the
        //  execption code
        //

        Status = FatProcessException( IrpContext, Irp, GetExceptionCode() );
    }

    if (TopLevel) { IoSetTopLevelIrp( NULL ); }

    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "FatFsdSetVolumeInformation -> %08lx\n", Status);

    UNREFERENCED_PARAMETER( VolumeDeviceObject );

    return Status;
}


NTSTATUS
FatCommonQueryVolumeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for querying volume information called by both
    the fsd and fsp threads.

Arguments:

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;

    PVCB Vcb;
    PFCB Fcb;
    PCCB Ccb;

    ULONG Length;
    FS_INFORMATION_CLASS FsInformationClass;
    PVOID Buffer;

    BOOLEAN WeAcquiredVcb = FALSE;

    //
    //  Get the current stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "FatCommonQueryVolumeInfo...\n", 0);
    DebugTrace( 0, Dbg, "Irp                  = %08lx\n", Irp );
    DebugTrace( 0, Dbg, "->Length             = %08lx\n", IrpSp->Parameters.QueryVolume.Length);
    DebugTrace( 0, Dbg, "->FsInformationClass = %08lx\n", IrpSp->Parameters.QueryVolume.FsInformationClass);
    DebugTrace( 0, Dbg, "->Buffer             = %08lx\n", Irp->AssociatedIrp.SystemBuffer);

    //
    //  Reference our input parameters to make things easier
    //

    Length = IrpSp->Parameters.QueryVolume.Length;
    FsInformationClass = IrpSp->Parameters.QueryVolume.FsInformationClass;
    Buffer = Irp->AssociatedIrp.SystemBuffer;

    //
    //  Decode the file object to get the Vcb
    //

    (VOID) FatDecodeFileObject( IrpSp->FileObject, &Vcb, &Fcb, &Ccb );

    ASSERT( Vcb != NULL );

    try {

        //
        //  Make sure the vcb is in a usable condition.  This will raise
        //  and error condition if the volume is unusable
        //
        //  Also verify the Root Dcb since we need info from there.
        //

        FatVerifyFcb( IrpContext, Vcb->RootDcb );

        //
        //  Based on the information class we'll do different actions.  Each
        //  of the procedures that we're calling fills up the output buffer
        //  if possible and returns true if it successfully filled the buffer
        //  and false if it couldn't wait for any I/O to complete.
        //

        switch (FsInformationClass) {

        case FileFsVolumeInformation:

            //
            //  This is the only routine we need the Vcb shared because of
            //  copying the volume label.  All other routines copy fields that
            //  cannot change or are just manifest constants.
            //

            if (!FatAcquireSharedVcb( IrpContext, Vcb )) {

                DebugTrace(0, Dbg, "Cannot acquire Vcb\n", 0);

                Status = FatFsdPostRequest( IrpContext, Irp );
                IrpContext = NULL;
                Irp = NULL;

            } else {

                WeAcquiredVcb = TRUE;
                
                Status = FatQueryFsVolumeInfo( IrpContext, Vcb, Buffer, &Length );
            }

            break;

        case FileFsSizeInformation:

            Status = FatQueryFsSizeInfo( IrpContext, Vcb, Buffer, &Length );
            break;

        case FileFsDeviceInformation:

            Status = FatQueryFsDeviceInfo( IrpContext, Vcb, Buffer, &Length );
            break;

        case FileFsAttributeInformation:

            Status = FatQueryFsAttributeInfo( IrpContext, Vcb, Buffer, &Length );
            break;

        case FileFsFullSizeInformation:

            Status = FatQueryFsFullSizeInfo( IrpContext, Vcb, Buffer, &Length );
            break;

        default:

            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        //
        //  Set the information field to the number of bytes actually filled in.
        //

        if (Irp != NULL) {
            
            Irp->IoStatus.Information = IrpSp->Parameters.QueryVolume.Length - Length;
        }

    } finally {

        DebugUnwind( FatCommonQueryVolumeInfo );

        if ( WeAcquiredVcb ) { FatReleaseVcb( IrpContext, Vcb ); }

        if (!AbnormalTermination()) {

            FatCompleteRequest( IrpContext, Irp, Status );
        }

        DebugTrace(-1, Dbg, "FatCommonQueryVolumeInfo -> %08lx\n", Status);
    }

    return Status;
}


NTSTATUS
FatCommonSetVolumeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common routine for setting Volume Information called by both
    the fsd and fsp threads.

Arguments:

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    NTSTATUS Status;
    PIO_STACK_LOCATION IrpSp;

    PVCB Vcb;
    PFCB Fcb;
    PCCB Ccb;
    TYPE_OF_OPEN TypeOfOpen;

    ULONG Length;
    FS_INFORMATION_CLASS FsInformationClass;
    PVOID Buffer;

    //
    //  Get the current stack location
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );

    DebugTrace(+1, Dbg, "FatCommonSetVolumeInfo...\n", 0);
    DebugTrace( 0, Dbg, "Irp                  = %08lx\n", Irp );
    DebugTrace( 0, Dbg, "->Length             = %08lx\n", IrpSp->Parameters.SetVolume.Length);
    DebugTrace( 0, Dbg, "->FsInformationClass = %08lx\n", IrpSp->Parameters.SetVolume.FsInformationClass);
    DebugTrace( 0, Dbg, "->Buffer             = %08lx\n", Irp->AssociatedIrp.SystemBuffer);

    //
    //  Reference our input parameters to make things easier
    //

    Length = IrpSp->Parameters.SetVolume.Length;
    FsInformationClass = IrpSp->Parameters.SetVolume.FsInformationClass;
    Buffer = Irp->AssociatedIrp.SystemBuffer;

    //
    //  Decode the file object to get the Vcb
    //

    TypeOfOpen = FatDecodeFileObject( IrpSp->FileObject, &Vcb, &Fcb, &Ccb );

    if (TypeOfOpen != UserVolumeOpen) {

        FatCompleteRequest( IrpContext, Irp, STATUS_ACCESS_DENIED );

        DebugTrace(-1, Dbg, "FatCommonSetVolumeInfo -> STATUS_ACCESS_DENIED\n", 0);

        return STATUS_ACCESS_DENIED;
    }

    //
    //  Acquire exclusive access to the Vcb and enqueue the Irp if we didn't
    //  get access
    //

    if (!FatAcquireExclusiveVcb( IrpContext, Vcb )) {

        DebugTrace(0, Dbg, "Cannot acquire Vcb\n", 0);

        Status = FatFsdPostRequest( IrpContext, Irp );

        DebugTrace(-1, Dbg, "FatCommonSetVolumeInfo -> %08lx\n", Status );
        return Status;
    }

    try {

        //
        //  Make sure the vcb is in a usable condition.  This will raise
        //  and error condition if the volume is unusable
        //
        //  Also verify the Root Dcb since we need info from there.
        //

        FatVerifyFcb( IrpContext, Vcb->RootDcb );

        //
        //  Based on the information class we'll do different actions.  Each
        //  of the procedures that we're calling performs the action if
        //  possible and returns true if it successful and false if it couldn't
        //  wait for any I/O to complete.
        //

        switch (FsInformationClass) {

        case FileFsLabelInformation:

            Status = FatSetFsLabelInfo( IrpContext, Vcb, Buffer );
            break;

        default:

            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        FatUnpinRepinnedBcbs( IrpContext );

    } finally {

        DebugUnwind( FatCommonSetVolumeInfo );

        FatReleaseVcb( IrpContext, Vcb );

        if (!AbnormalTermination()) {

            FatCompleteRequest( IrpContext, Irp, Status );
        }

        DebugTrace(-1, Dbg, "FatCommonSetVolumeInfo -> %08lx\n", Status);
    }

    return Status;
}


//
//  Internal support routine
//

NTSTATUS
FatQueryFsVolumeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_VOLUME_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine implements the query volume info call

Arguments:

    Vcb - Supplies the Vcb being queried

    Buffer - Supplies a pointer to the output buffer where the information
        is to be returned

    Length - Supplies the length of the buffer in byte.  This variable
        upon return recieves the remaining bytes free in the buffer

Return Value:

    NTSTATUS - Returns the status for the query

--*/

{
    ULONG BytesToCopy;

    NTSTATUS Status;

    DebugTrace(0, Dbg, "FatQueryFsVolumeInfo...\n", 0);

    //
    //  Zero out the buffer, then extract and fill up the non zero fields.
    //

    RtlZeroMemory( Buffer, sizeof(FILE_FS_VOLUME_INFORMATION) );

    Buffer->VolumeSerialNumber = Vcb->Vpb->SerialNumber;

    Buffer->SupportsObjects = FALSE;

    *Length -= FIELD_OFFSET(FILE_FS_VOLUME_INFORMATION, VolumeLabel[0]);

    //
    //  Check if the buffer we're given is long enough
    //

    if ( *Length >= (ULONG)Vcb->Vpb->VolumeLabelLength ) {

        BytesToCopy = Vcb->Vpb->VolumeLabelLength;

        Status = STATUS_SUCCESS;

    } else {

        BytesToCopy = *Length;

        Status = STATUS_BUFFER_OVERFLOW;
    }

    //
    //  Copy over what we can of the volume label, and adjust *Length
    //

    Buffer->VolumeLabelLength = Vcb->Vpb->VolumeLabelLength;

    RtlCopyMemory( &Buffer->VolumeLabel[0],
                   &Vcb->Vpb->VolumeLabel[0],
                   BytesToCopy );

    *Length -= BytesToCopy;

    //
    //  Set our status and return to our caller
    //

    UNREFERENCED_PARAMETER( IrpContext );

    return Status;
}


//
//  Internal support routine
//

NTSTATUS
FatQueryFsSizeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_SIZE_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine implements the query volume size call

Arguments:

    Vcb - Supplies the Vcb being queried

    Buffer - Supplies a pointer to the output buffer where the information
        is to be returned

    Length - Supplies the length of the buffer in byte.  This variable
        upon return recieves the remaining bytes free in the buffer

Return Value:

    Status - Returns the status for the query

--*/

{
    DebugTrace(0, Dbg, "FatQueryFsSizeInfo...\n", 0);

    RtlZeroMemory( Buffer, sizeof(FILE_FS_SIZE_INFORMATION) );

    //
    //  Set the output buffer.  
    //

    Buffer->TotalAllocationUnits.LowPart =
                                    Vcb->AllocationSupport.NumberOfClusters;
    Buffer->AvailableAllocationUnits.LowPart =
                                    Vcb->AllocationSupport.NumberOfFreeClusters;
  
    Buffer->SectorsPerAllocationUnit = Vcb->Bpb.SectorsPerCluster;
    Buffer->BytesPerSector = Vcb->Bpb.BytesPerSector;

    //
    //  Adjust the length variable
    //

    *Length -= sizeof(FILE_FS_SIZE_INFORMATION);

    //
    //  And return success to our caller
    //

    UNREFERENCED_PARAMETER( IrpContext );

    return STATUS_SUCCESS;
}


//
//  Internal support routine
//

NTSTATUS
FatQueryFsDeviceInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_DEVICE_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine implements the query volume device call

Arguments:

    Vcb - Supplies the Vcb being queried

    Buffer - Supplies a pointer to the output buffer where the information
        is to be returned

    Length - Supplies the length of the buffer in byte.  This variable
        upon return recieves the remaining bytes free in the buffer

Return Value:

    Status - Returns the status for the query

--*/

{
    DebugTrace(0, Dbg, "FatQueryFsDeviceInfo...\n", 0);

    RtlZeroMemory( Buffer, sizeof(FILE_FS_DEVICE_INFORMATION) );

    //
    //  Set the output buffer
    //

    Buffer->DeviceType = FILE_DEVICE_DISK;

    Buffer->Characteristics = Vcb->TargetDeviceObject->Characteristics;

    //
    //  Adjust the length variable
    //

    *Length -= sizeof(FILE_FS_DEVICE_INFORMATION);

    //
    //  And return success to our caller
    //

    UNREFERENCED_PARAMETER( IrpContext );

    return STATUS_SUCCESS;
}


//
//  Internal support routine
//

NTSTATUS
FatQueryFsAttributeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_ATTRIBUTE_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine implements the query volume attribute call

Arguments:

    Vcb - Supplies the Vcb being queried

    Buffer - Supplies a pointer to the output buffer where the information
        is to be returned

    Length - Supplies the length of the buffer in byte.  This variable
        upon return recieves the remaining bytes free in the buffer

Return Value:

    Status - Returns the status for the query

--*/

{
    ULONG BytesToCopy;

    NTSTATUS Status;

    DebugTrace(0, Dbg, "FatQueryFsAttributeInfo...\n", 0);

    //
    //  Set the output buffer
    //

    Buffer->FileSystemAttributes = FILE_CASE_PRESERVED_NAMES |
                                   FILE_UNICODE_ON_DISK;

    if (FlagOn( Vcb->VcbState, VCB_STATE_FLAG_WRITE_PROTECTED )) {
        
        SetFlag( Buffer->FileSystemAttributes, FILE_READ_ONLY_VOLUME );
    }

    Buffer->MaximumComponentNameLength = FatData.ChicagoMode ? 255 : 12;

    if (FatIsFat32(Vcb)) {

        //
        //  Determine how much of the file system name will fit.
        //
    
        if ( (*Length - FIELD_OFFSET( FILE_FS_ATTRIBUTE_INFORMATION,
                                      FileSystemName[0] )) >= 10 ) {
    
            BytesToCopy = 10;
            *Length -= FIELD_OFFSET( FILE_FS_ATTRIBUTE_INFORMATION,
                                     FileSystemName[0] ) + 10;
            Status = STATUS_SUCCESS;
    
        } else {
    
            BytesToCopy = *Length - FIELD_OFFSET( FILE_FS_ATTRIBUTE_INFORMATION,
                                                  FileSystemName[0]);
            *Length = 0;
    
            Status = STATUS_BUFFER_OVERFLOW;
        }
    
        RtlCopyMemory( &Buffer->FileSystemName[0], L"FAT32", BytesToCopy );

    } else {

        //
        //  Determine how much of the file system name will fit.
        //
    
        if ( (*Length - FIELD_OFFSET( FILE_FS_ATTRIBUTE_INFORMATION,
                                      FileSystemName[0] )) >= 6 ) {
    
            BytesToCopy = 6;
            *Length -= FIELD_OFFSET( FILE_FS_ATTRIBUTE_INFORMATION,
                                     FileSystemName[0] ) + 6;
            Status = STATUS_SUCCESS;
    
        } else {
    
            BytesToCopy = *Length - FIELD_OFFSET( FILE_FS_ATTRIBUTE_INFORMATION,
                                                  FileSystemName[0]);
            *Length = 0;
    
            Status = STATUS_BUFFER_OVERFLOW;
        }
    

        RtlCopyMemory( &Buffer->FileSystemName[0], L"FAT", BytesToCopy );
    }

    Buffer->FileSystemNameLength       = BytesToCopy;

    //
    //  And return success to our caller
    //

    UNREFERENCED_PARAMETER( IrpContext );
    UNREFERENCED_PARAMETER( Vcb );

    return Status;
}


//
//  Internal support routine
//

NTSTATUS
FatQueryFsFullSizeInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_FULL_SIZE_INFORMATION Buffer,
    IN OUT PULONG Length
    )

/*++

Routine Description:

    This routine implements the query volume full size call

Arguments:

    Vcb - Supplies the Vcb being queried

    Buffer - Supplies a pointer to the output buffer where the information
        is to be returned

    Length - Supplies the length of the buffer in byte.  This variable
        upon return recieves the remaining bytes free in the buffer

Return Value:

    Status - Returns the status for the query

--*/

{
    DebugTrace(0, Dbg, "FatQueryFsSizeInfo...\n", 0);

    RtlZeroMemory( Buffer, sizeof(FILE_FS_FULL_SIZE_INFORMATION) );

    Buffer->TotalAllocationUnits.LowPart =
                                Vcb->AllocationSupport.NumberOfClusters;
    Buffer->CallerAvailableAllocationUnits.LowPart =
                                Vcb->AllocationSupport.NumberOfFreeClusters;
    Buffer->ActualAvailableAllocationUnits.LowPart =
        Buffer->CallerAvailableAllocationUnits.LowPart;
    Buffer->SectorsPerAllocationUnit = Vcb->Bpb.SectorsPerCluster;
    Buffer->BytesPerSector = Vcb->Bpb.BytesPerSector;

    //
    //  Adjust the length variable
    //

    *Length -= sizeof(FILE_FS_FULL_SIZE_INFORMATION);

    //
    //  And return success to our caller
    //

    UNREFERENCED_PARAMETER( IrpContext );

    return STATUS_SUCCESS;
}


//
//  Internal support routine
//

NTSTATUS
FatSetFsLabelInfo (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN PFILE_FS_LABEL_INFORMATION Buffer
    )

/*++

Routine Description:

    This routine implements the set volume label call

Arguments:

    Vcb - Supplies the Vcb being queried

    Buffer - Supplies the input where the information is stored.

Return Value:

    NTSTATUS - Returns the status for the operation

--*/

{
    NTSTATUS Status;

    PDIRENT Dirent;
    PBCB DirentBcb = NULL;
    ULONG ByteOffset;

    WCHAR TmpBuffer[11];
    UCHAR OemBuffer[11];
    OEM_STRING OemLabel;
    UNICODE_STRING UnicodeString;
    UNICODE_STRING UpcasedLabel;

    DebugTrace(+1, Dbg, "FatSetFsLabelInfo...\n", 0);

    //
    //  Setup our local variable
    //

    UnicodeString.Length = (USHORT)Buffer->VolumeLabelLength;
    UnicodeString.MaximumLength = UnicodeString.Length;
    UnicodeString.Buffer = (PWSTR) &Buffer->VolumeLabel[0];

    //
    //  Make sure the name can fit into the stack buffer
    //

    if ( UnicodeString.Length > 11*sizeof(WCHAR) ) {

        return STATUS_INVALID_VOLUME_LABEL;
    }

    //
    //  Upcase the name and convert it to the Oem code page.
    //

    OemLabel.Buffer = &OemBuffer[0];
    OemLabel.Length = 0;
    OemLabel.MaximumLength = 11;

    Status = RtlUpcaseUnicodeStringToCountedOemString( &OemLabel,
                                                       &UnicodeString,
                                                       FALSE );

    //
    //  Volume label that fits in 11 unicode character length limit
    //  is not necessary within 11 characters in OEM character set.
    //

    if (!NT_SUCCESS( Status )) {

        DebugTrace(-1, Dbg, "FatSetFsLabelInfo:  Label must be too long. %08lx\n", Status );

        return STATUS_INVALID_VOLUME_LABEL;
    }

    //
    //  Strip spaces off of the label.
    //

    if (OemLabel.Length > 0) {

        USHORT i;
        USHORT LastSpaceIndex = MAXUSHORT;

        //
        //  Check the label for illegal characters
        //

        for ( i = 0; i < (ULONG)OemLabel.Length; i += 1 ) {

            if ( FsRtlIsLeadDbcsCharacter( OemLabel.Buffer[i] ) ) {

                LastSpaceIndex = MAXUSHORT;
                i += 1;
                continue;
            }

            if (!FsRtlIsAnsiCharacterLegalFat(OemLabel.Buffer[i], FALSE) ||
                (OemLabel.Buffer[i] == '.')) {

                return STATUS_INVALID_VOLUME_LABEL;
            }

            //
            //  Watch for the last run of spaces, so we can strip them.
            //

            if (OemLabel.Buffer[i] == ' ' &&
                LastSpaceIndex == MAXUSHORT) {
                LastSpaceIndex = i;
            } else {
                LastSpaceIndex = MAXUSHORT;
            }
        }

        if (LastSpaceIndex != MAXUSHORT) {
            OemLabel.Length = LastSpaceIndex;
        }
    }

    //
    //  Get the Unicode upcased string to store in the VPB.
    //

    UpcasedLabel.Length = UnicodeString.Length;
    UpcasedLabel.MaximumLength = 11*sizeof(WCHAR);
    UpcasedLabel.Buffer = &TmpBuffer[0];

    Status = RtlOemStringToCountedUnicodeString( &UpcasedLabel,
                                                 &OemLabel,
                                                 FALSE );

    if (!NT_SUCCESS( Status )) {

        DebugTrace(-1, Dbg, "FatSetFsLabelInfo:  Label must be too long. %08lx\n", Status );

        return STATUS_INVALID_VOLUME_LABEL;
    }

    DirentBcb = NULL;

    //
    //  Make this look like a write through to disk.  This is important to
    //  avoid a unpleasant window where it looks like we have the wrong volume.
    //

    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_WRITE_THROUGH );

    try {

        //
        //  Are we setting or removing the label?  Note that shaving spaces could
        //  make this different than wondering if the input buffer is non-zero length.
        //
        
        if (OemLabel.Length > 0) {

            //
            //  Locate the volume label if there already is one
            //

            FatLocateVolumeLabel( IrpContext,
                                  Vcb,
                                  &Dirent,
                                  &DirentBcb,
                                  &ByteOffset );

            //
            //  Check that we really got one, if not then we need to create
            //  a new one.  The procedure we call will raise an appropriate
            //  status if we are not able to allocate a new dirent
            //

            if (Dirent == NULL) {

                ByteOffset = FatCreateNewDirent( IrpContext,
                                                 Vcb->RootDcb,
                                                 1 );

                FatPrepareWriteDirectoryFile( IrpContext,
                                              Vcb->RootDcb,
                                              ByteOffset,
                                              sizeof(DIRENT),
                                              &DirentBcb,
                                              &Dirent,
                                              FALSE,
                                              TRUE,
                                              &Status );

                ASSERT( NT_SUCCESS( Status ));
            
            } else {

                //
                //  Just mark this guy dirty now.
                //
            
                FatSetDirtyBcb( IrpContext, DirentBcb, Vcb, TRUE );
            }

            //
            //  Now reconstruct the volume label dirent.
            //

            FatConstructLabelDirent( IrpContext,
                                     Dirent,
                                     &OemLabel );

            //
            //  Unpin the Bcb here so that we will get any IO errors
            //  here before changing the VPB label.
            //

            FatUnpinBcb( IrpContext, DirentBcb );
            FatUnpinRepinnedBcbs( IrpContext );

            //
            //  Now set the upcased label in the VPB
            //

            RtlCopyMemory( &Vcb->Vpb->VolumeLabel[0],
                           &UpcasedLabel.Buffer[0],
                           UpcasedLabel.Length );

            Vcb->Vpb->VolumeLabelLength = UpcasedLabel.Length;

        } else {

            //
            //  Otherwise we're trying to delete the label
            //  Locate the current volume label if there already is one
            //

            FatLocateVolumeLabel( IrpContext,
                                  Vcb,
                                  &Dirent,
                                  &DirentBcb,
                                  &ByteOffset );

            //
            //  Check that we really got one
            //

            if (Dirent == NULL) {

                try_return( Status = STATUS_SUCCESS );
            }

            //
            //  Now delete the current label.
            //

            Dirent->FileName[0] = FAT_DIRENT_DELETED;

            ASSERT( (Vcb->RootDcb->Specific.Dcb.UnusedDirentVbo == 0xffffffff) ||
                    RtlAreBitsSet( &Vcb->RootDcb->Specific.Dcb.FreeDirentBitmap,
                                   ByteOffset / sizeof(DIRENT),
                                   1 ) );

            RtlClearBits( &Vcb->RootDcb->Specific.Dcb.FreeDirentBitmap,
                          ByteOffset / sizeof(DIRENT),
                          1 );

            FatSetDirtyBcb( IrpContext, DirentBcb, Vcb, TRUE );

            //
            //  Unpin the Bcb here so that we will get any IO errors
            //  here before changing the VPB label.
            //

            FatUnpinBcb( IrpContext, DirentBcb );
            FatUnpinRepinnedBcbs( IrpContext );

            //
            //  Now set the label in the VPB
            //

            Vcb->Vpb->VolumeLabelLength = 0;
        }

        Status = STATUS_SUCCESS;

    try_exit: NOTHING;
    } finally {

        DebugUnwind( FatSetFsALabelInfo );

        FatUnpinBcb( IrpContext, DirentBcb );

        DebugTrace(-1, Dbg, "FatSetFsALabelInfo -> STATUS_SUCCESS\n", 0);
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fastfat\verfysup.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    VerfySup.c

Abstract:

    This module implements the Fat Verify volume and fcb/dcb support
    routines

// @@BEGIN_DDKSPLIT

Author:

    Gary Kimura     [GaryKi]    01-Jun-1990

Revision History:

// @@END_DDKSPLIT

--*/

#include "FatProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (FAT_BUG_CHECK_VERFYSUP)

//
//  The Debug trace level for this module
//

#define Dbg                              (DEBUG_TRACE_VERFYSUP)

//
//  Local procedure prototypes
//

VOID
FatResetFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    );

VOID
FatDetermineAndMarkFcbCondition (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    );

VOID
FatDeferredCleanVolume (
    PVOID Parameter
    );

NTSTATUS
FatMarkVolumeCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FatCheckDirtyBit)
#pragma alloc_text(PAGE, FatVerifyOperationIsLegal)
#pragma alloc_text(PAGE, FatDeferredCleanVolume)
#pragma alloc_text(PAGE, FatDetermineAndMarkFcbCondition)
#pragma alloc_text(PAGE, FatQuickVerifyVcb)
#pragma alloc_text(PAGE, FatPerformVerify)
#pragma alloc_text(PAGE, FatMarkFcbCondition)
#pragma alloc_text(PAGE, FatResetFcb)
#pragma alloc_text(PAGE, FatVerifyVcb)
#pragma alloc_text(PAGE, FatVerifyFcb)
#endif


VOID
FatMarkFcbCondition (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb,
    IN FCB_CONDITION FcbCondition,
    IN BOOLEAN Recursive
    )

/*++

Routine Description:

    This routines marks the entire Fcb/Dcb structure from Fcb down with
    FcbCondition.

Arguments:

    Fcb - Supplies the Fcb/Dcb being marked

    FcbCondition - Supplies the setting to use for the Fcb Condition

    Recursive - Specifies whether this condition should be applied to
        all children (see the case where we are invalidating a live volume
        for a case where this is now desireable).

Return Value:

    None.

--*/

{
    DebugTrace(+1, Dbg, "FatMarkFcbCondition, Fcb = %08lx\n", Fcb );

    //
    //  If we are marking this Fcb something other than Good, we will need
    //  to have the Vcb exclusive.
    //

    ASSERT( FcbCondition != FcbNeedsToBeVerified ? TRUE :
            FatVcbAcquiredExclusive(IrpContext, Fcb->Vcb) );

    //
    //  If this is a PagingFile it has to be good.
    //

    if (FlagOn(Fcb->FcbState, FCB_STATE_PAGING_FILE)) {

        Fcb->FcbCondition = FcbGood;
        return;
    }

    //
    //  Update the condition of the Fcb.
    //

    Fcb->FcbCondition = FcbCondition;

    DebugTrace(0, Dbg, "MarkFcb: %Z\n", &Fcb->FullFileName);

    //
    //  This FastIo flag is based on FcbCondition, so update it now.  This only
    //  applies to regular FCBs, of course.
    //

    if (Fcb->Header.NodeTypeCode == FAT_NTC_FCB) {

        Fcb->Header.IsFastIoPossible = FatIsFastIoPossible( Fcb );
    }

    //
    //  Now if we marked NeedsVerify or Bad a directory then we also need to
    //  go and mark all of our children with the same condition.
    //

    if ( ((FcbCondition == FcbNeedsToBeVerified) ||
          (FcbCondition == FcbBad)) &&
         Recursive &&
         ((Fcb->Header.NodeTypeCode == FAT_NTC_DCB) ||
          (Fcb->Header.NodeTypeCode == FAT_NTC_ROOT_DCB)) ) {

        PFCB OriginalFcb = Fcb;

        while ( (Fcb = FatGetNextFcbTopDown(IrpContext, Fcb, OriginalFcb)) != NULL ) {

            DebugTrace(0, Dbg, "MarkFcb: %Z\n", &Fcb->FullFileName);

            Fcb->FcbCondition = FcbCondition;

            //
            //  We already know that FastIo is not possible since we are propagating
            //  a parent's bad/verify flag down the tree - IO to the children must
            //  take the long route for now.
            //

            Fcb->Header.IsFastIoPossible = FastIoIsNotPossible;
        }
    }

    DebugTrace(-1, Dbg, "FatMarkFcbCondition -> VOID\n", 0);

    return;
}


VOID
FatVerifyVcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routines verifies that the Vcb still denotes a valid Volume
    If the Vcb is bad it raises an error condition.

Arguments:

    Vcb - Supplies the Vcb being verified

Return Value:

    None.

--*/

{
    ULONG ChangeCount = 0;

    DebugTrace(+1, Dbg, "FatVerifyVcb, Vcb = %08lx\n", Vcb );

    //
    //  If the media is removable and the verify volume flag in the
    //  device object is not set then we want to ping the device
    //  to see if it needs to be verified.
    //
    //  Note that we only force this ping for create operations.
    //  For others we take a sporting chance.  If in the end we
    //  have to physically access the disk, the right thing will happen.
    //

    if ( FlagOn(Vcb->VcbState, VCB_STATE_FLAG_REMOVABLE_MEDIA) &&
         !FlagOn(Vcb->Vpb->RealDevice->Flags, DO_VERIFY_VOLUME) ) {

        IO_STATUS_BLOCK Iosb;
        NTSTATUS Status;

        Status = FatPerformDevIoCtrl( IrpContext,
                                      IOCTL_DISK_CHECK_VERIFY,
                                      Vcb->TargetDeviceObject,
                                      &ChangeCount,
                                      sizeof(ULONG),
                                      FALSE,
                                      TRUE,
                                      &Iosb );

        //
        //  Verify potentially empty devices, explicit verify requests and
        //  when we get the secondary indication of media change via the
        //  device change count.
        //

        if ((Vcb->VcbCondition == VcbGood &&
             FatIsRawDevice( IrpContext, Status )) ||
            (Status == STATUS_VERIFY_REQUIRED) ||
            (NT_SUCCESS(Status) &&
             (Vcb->ChangeCount != ChangeCount))) {

            SetFlag( Vcb->Vpb->RealDevice->Flags, DO_VERIFY_VOLUME );
        }

        //
        //  Raise the error condition otherwise.
        //

        else if (!NT_SUCCESS( Status )) {

            FatNormalizeAndRaiseStatus( IrpContext, Status );
        }

    }

    //
    //  Now that the verify bit has been appropriately set, check the Vcb.
    //

    FatQuickVerifyVcb( IrpContext, Vcb );

    DebugTrace(-1, Dbg, "FatVerifyVcb -> VOID\n", 0);

    return;
}


VOID
FatVerifyFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routines verifies that the Fcb still denotes the same file.
    If the Fcb is bad it raises a error condition.

Arguments:

    Fcb - Supplies the Fcb being verified

Return Value:

    None.

--*/

{
    PFCB CurrentFcb;

    DebugTrace(+1, Dbg, "FatVerifyFcb, Vcb = %08lx\n", Fcb );

    //
    //  Always refuse operations on dismounted volumes.
    //

    if (FlagOn( Fcb->Vcb->VcbState, VCB_STATE_FLAG_VOLUME_DISMOUNTED )) {

        FatRaiseStatus( IrpContext, STATUS_VOLUME_DISMOUNTED );
    }

    //
    //  If this is the Fcb of a deleted dirent or our parent is deleted,
    //  no-op this call with the hope that the caller will do the right thing.
    //  The only caller we really have to worry about is the AdvanceOnly
    //  callback for setting valid data length from Cc, this will happen after
    //  cleanup (and file deletion), just before the SCM is ripped down.
    //

    if (IsFileDeleted( IrpContext, Fcb ) ||
        ((NodeType(Fcb) != FAT_NTC_ROOT_DCB) &&
         IsFileDeleted( IrpContext, Fcb->ParentDcb ))) {

        return;
    }

    //
    //  If we are not in the process of doing a verify,
    //  first do a quick spot check on the Vcb.
    //

    if ( Fcb->Vcb->VerifyThread != KeGetCurrentThread() ) {

        FatQuickVerifyVcb( IrpContext, Fcb->Vcb );
    }

    //
    //  Now based on the condition of the Fcb we'll either return
    //  immediately to the caller, raise a condition, or do some work
    //  to verify the Fcb.
    //

    switch (Fcb->FcbCondition) {

    case FcbGood:

        DebugTrace(0, Dbg, "The Fcb is good\n", 0);
        break;

    case FcbBad:

        FatRaiseStatus( IrpContext, STATUS_FILE_INVALID );
        break;

    case FcbNeedsToBeVerified:

        //
        //  We loop here checking our ancestors until we hit an Fcb which
        //  is either good or bad.
        //

        CurrentFcb = Fcb;

        while (CurrentFcb->FcbCondition == FcbNeedsToBeVerified) {

            FatDetermineAndMarkFcbCondition(IrpContext, CurrentFcb);

            //
            //  If this Fcb didn't make it, or it was the Root Dcb, exit
            //  the loop now, else continue with out parent.
            //

            if ( (CurrentFcb->FcbCondition != FcbGood) ||
                 (NodeType(CurrentFcb) == FAT_NTC_ROOT_DCB) ) {

                break;
            }

            CurrentFcb = CurrentFcb->ParentDcb;
        }

        //
        //  Now we can just look at ourselves to see how we did.
        //

        if (Fcb->FcbCondition != FcbGood) {

            FatRaiseStatus( IrpContext, STATUS_FILE_INVALID );
        }

        break;

    default:

        DebugDump("Invalid FcbCondition\n", 0, Fcb);
        FatBugCheck( Fcb->FcbCondition, 0, 0 );
    }

    DebugTrace(-1, Dbg, "FatVerifyFcb -> VOID\n", 0);

    return;
}

VOID
FatDeferredCleanVolume (
    PVOID Parameter
    )

/*++

Routine Description:

    This is the routine that performs the actual FatMarkVolumeClean call.
    It assures that the target volume still exists as there ia a race
    condition between queueing the ExWorker item and volumes going away.

Arguments:

    Parameter - Points to a clean volume packet that was allocated from pool

Return Value:

    None.

--*/

{
    PCLEAN_AND_DIRTY_VOLUME_PACKET Packet;
    PLIST_ENTRY Links;
    PVCB Vcb;
    IRP_CONTEXT IrpContext;
    BOOLEAN VcbExists = FALSE;

    DebugTrace(+1, Dbg, "FatDeferredCleanVolume\n", 0);

    Packet = (PCLEAN_AND_DIRTY_VOLUME_PACKET)Parameter;

    Vcb = Packet->Vcb;

    //
    //  Make us appear as a top level FSP request so that we will
    //  receive any errors from the operation.
    //

    IoSetTopLevelIrp( (PIRP)FSRTL_FSP_TOP_LEVEL_IRP );

    //
    //  Dummy up and Irp Context so we can call our worker routines
    //

    RtlZeroMemory( &IrpContext, sizeof(IRP_CONTEXT));

    SetFlag(IrpContext.Flags, IRP_CONTEXT_FLAG_WAIT);

    //
    //  Acquire shared access to the global lock and make sure this volume
    //  still exists.
    //

    FatAcquireSharedGlobal( &IrpContext );

    for (Links = FatData.VcbQueue.Flink;
         Links != &FatData.VcbQueue;
         Links = Links->Flink) {

        PVCB ExistingVcb;

        ExistingVcb = CONTAINING_RECORD(Links, VCB, VcbLinks);

        if ( Vcb == ExistingVcb ) {

            VcbExists = TRUE;
            break;
        }
    }

    //
    //  If the vcb is good then mark it clean.  Ignore any problems.
    //

    if ( VcbExists &&
         (Vcb->VcbCondition == VcbGood) &&
         !FlagOn(Vcb->VcbState, VCB_STATE_FLAG_SHUTDOWN) ) {

        try {

            if (!FlagOn(Vcb->VcbState, VCB_STATE_FLAG_MOUNTED_DIRTY)) {

                FatMarkVolume( &IrpContext, Vcb, VolumeClean );
            }

            //
            //  Check for a pathological race condition, and fix it.
            //

            if (FlagOn(Vcb->VcbState, VCB_STATE_FLAG_VOLUME_DIRTY)) {

                FatMarkVolume( &IrpContext, Vcb, VolumeDirty );

            } else {

                //
                //  Unlock the volume if it is removable.
                //

                if (FlagOn(Vcb->VcbState, VCB_STATE_FLAG_REMOVABLE_MEDIA) &&
                    !FlagOn(Vcb->VcbState, VCB_STATE_FLAG_BOOT_OR_PAGING_FILE)) {

                    FatToggleMediaEjectDisable( &IrpContext, Vcb, FALSE );
                }
            }

        } except( FsRtlIsNtstatusExpected(GetExceptionCode()) ?
                  EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH ) {

              NOTHING;
        }
    }

    //
    //  Release the global resource, unpin and repinned Bcbs and return.
    //

    FatReleaseGlobal( &IrpContext );

    try {

        FatUnpinRepinnedBcbs( &IrpContext );

    } except( FsRtlIsNtstatusExpected(GetExceptionCode()) ?
              EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH ) {

          NOTHING;
    }

    IoSetTopLevelIrp( NULL );

    //
    //  and finally free the packet.
    //

    ExFreePool( Packet );

    return;
}


VOID
FatCleanVolumeDpc (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This routine is dispatched 5 seconds after the last disk structure was
    modified in a specific volume, and exqueues an execuative worker thread
    to perform the actual task of marking the volume dirty.

Arguments:

    DefferedContext - Contains the Vcb to process.

Return Value:

    None.

--*/

{
    PVCB Vcb;
    PCLEAN_AND_DIRTY_VOLUME_PACKET Packet;

    Vcb = (PVCB)DeferredContext;

    //
    //  If there is still dirty data (highly unlikely), set the timer for a
    //  second in the future.
    //

    if (CcIsThereDirtyData(Vcb->Vpb)) {

        LARGE_INTEGER TwoSecondsFromNow;

        TwoSecondsFromNow.QuadPart = (LONG)-2*1000*1000*10;

        KeSetTimer( &Vcb->CleanVolumeTimer,
                    TwoSecondsFromNow,
                    &Vcb->CleanVolumeDpc );

        return;
    }

    //
    //  If we couldn't get pool, oh well....
    //

    Packet = ExAllocatePool(NonPagedPool, sizeof(CLEAN_AND_DIRTY_VOLUME_PACKET));

    if ( Packet ) {

        Packet->Vcb = Vcb;
        Packet->Irp = NULL;

        //
        //  Clear the dirty flag now since we cannot synchronize after this point.
        //

        ClearFlag( Packet->Vcb->VcbState, VCB_STATE_FLAG_VOLUME_DIRTY );

        ExInitializeWorkItem( &Packet->Item, &FatDeferredCleanVolume, Packet );

        ExQueueWorkItem( &Packet->Item, CriticalWorkQueue );
    }

    return;
}


VOID
FatMarkVolume (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb,
    IN FAT_VOLUME_STATE VolumeState
    )

/*++

Routine Description:

    This routine moves the physically marked volume state between the clean
    and dirty states.  For compatibility with Win9x, we manipulate both the
    historical DOS (on==clean in index 1 of the FAT) and NT (on==dirty in
    the CurrentHead field of the BPB) dirty bits.

Arguments:

    Vcb - Supplies the Vcb being modified

    VolumeState - Supplies the state the volume is transitioning to

Return Value:

    None.

--*/

{
    PCHAR Sector;
    PBCB Bcb = NULL;
    KEVENT Event;
    PIRP Irp = NULL;
    NTSTATUS Status;
    BOOLEAN FsInfoUpdate = FALSE;
    ULONG FsInfoOffset;
    ULONG ThisPass;
    LARGE_INTEGER Offset;

    DebugTrace(+1, Dbg, "FatMarkVolume, Vcb = %08lx\n", Vcb);

    //
    //  We had best not be trying to scribble dirty/clean bits if the
    //  volume is write protected.  The responsibility lies with the
    //  callers to make sure that operations that could cause a state
    //  change cannot happen.  There are a few, though, that show it
    //  just doesn't make sense to force everyone to do the dinky
    //  check.
    //

    //
    //  If we were called for FAT12 or readonly media, return immediately.
    //

    if (FlagOn(Vcb->VcbState, VCB_STATE_FLAG_WRITE_PROTECTED) ||
        FatIsFat12( Vcb )) {

        return;
    }

    //
    //  We have two possible additional tasks to do to mark a volume
    //
    //      Pass 0) Flip the dirty bit in the Bpb
    //      Pass 1) Rewrite the FsInfo sector for FAT32 if needed
    //
    //  In most cases we can collapse these two either because the volume
    //  is either not FAT32 or the FsInfo sector is adjacent to the boot sector.
    //

    for (ThisPass = 0; ThisPass < 2; ThisPass++) {

        //
        //  If this volume is being dirtied, or isn't FAT32, or if it is and
        //  we were able to perform the fast update, or the bpb lied to us
        //  about where the FsInfo went, we're done - no FsInfo to update in
        //  a seperate write.
        //

        if (ThisPass == 1 && (!FatIsFat32( Vcb ) ||
                              VolumeState != VolumeClean ||
                              FsInfoUpdate ||
                              Vcb->Bpb.FsInfoSector == 0)) {

            break;
        }

        //
        //  Bail if we get an IO error.
        //

        try {

            ULONG PinLength;
            ULONG WriteLength;

            //
            // If the FAT table is 12-bit then our strategy is to pin the entire
            // thing when any of it is modified.  Here we're going to pin the
            // first page, so in the 12-bit case we also want to pin the rest
            // of the FAT table.
            //

            Offset.QuadPart = 0;

            if (Vcb->AllocationSupport.FatIndexBitSize == 12) {

                //
                //  But we only write back the first sector.
                //

                PinLength = FatReservedBytes(&Vcb->Bpb) + FatBytesPerFat(&Vcb->Bpb);
                WriteLength = Vcb->Bpb.BytesPerSector;

            } else {

                WriteLength = PinLength = Vcb->Bpb.BytesPerSector;

                //
                //  If this is a FAT32 volume going into the clean state,
                //  see about doing the FsInfo sector.
                //

                if (FatIsFat32( Vcb ) && VolumeState == VolumeClean) {

                    //
                    //  If the FsInfo sector immediately follows the boot sector,
                    //  we can do this in a single operation by rewriting both
                    //  sectors at once.
                    //

                    if (Vcb->Bpb.FsInfoSector == 1) {

                        ASSERT( ThisPass == 0 );

                        FsInfoUpdate = TRUE;
                        FsInfoOffset = Vcb->Bpb.BytesPerSector;
                        WriteLength = PinLength = Vcb->Bpb.BytesPerSector * 2;

                    } else if (ThisPass == 1) {

                        //
                        //  We are doing an explicit write to the FsInfo sector.
                        //

                        FsInfoUpdate = TRUE;
                        FsInfoOffset = 0;

                        Offset.QuadPart = Vcb->Bpb.BytesPerSector * Vcb->Bpb.FsInfoSector;
                    }
                }
            }

            //
            //  Call Cc directly here so that we can avoid overhead and push this
            //  right down to the disk.
            //

            CcPinRead( Vcb->VirtualVolumeFile,
                       &Offset,
                       PinLength,
                       TRUE,
                       &Bcb,
                       (PVOID *)&Sector );

            DbgDoit( IrpContext->PinCount += 1 )

            //
            //  Set the Bpb on Pass 0 always
            //

            if (ThisPass == 0) {

                PCHAR CurrentHead;

                //
                //  Before we do anything, doublecheck that this still looks like a
                //  FAT bootsector.  If it doesn't, something remarkable happened
                //  and we should avoid touching the volume.
                //
                //  THIS IS TEMPORARY (but may last a while)
                //

                if (!FatIsBootSectorFat( (PPACKED_BOOT_SECTOR) Sector )) {

                    return;
                }

                if (FatIsFat32( Vcb )) {

                    CurrentHead = &((PPACKED_BOOT_SECTOR_EX) Sector)->CurrentHead;

                } else {

                    CurrentHead = &((PPACKED_BOOT_SECTOR) Sector)->CurrentHead;
                }

                if (VolumeState == VolumeClean) {

                    ClearFlag( *CurrentHead, FAT_BOOT_SECTOR_DIRTY );

                } else {

                    SetFlag( *CurrentHead, FAT_BOOT_SECTOR_DIRTY );

                    //
                    //  In addition, if this request received an error that may indicate
                    //  media corruption, have autochk perform a surface test.
                    //

                    if ( VolumeState == VolumeDirtyWithSurfaceTest ) {

                        SetFlag( *CurrentHead, FAT_BOOT_SECTOR_TEST_SURFACE );
                    }
                }
            }

            //
            //  Update the FsInfo as appropriate.
            //

            if (FsInfoUpdate) {

                PFSINFO_SECTOR FsInfoSector = (PFSINFO_SECTOR) ((PCHAR)Sector + FsInfoOffset);

                //
                //  We just rewrite all of the spec'd fields.  Note that we don't
                //  care to synchronize with the allocation package - this will be
                //  quickly taken care of by a re-dirtying of the volume if a change
                //  is racing with us.  Remember that this is all a compatibility
                //  deference for Win9x FAT32 - NT will never look at this information.
                //

                FsInfoSector->SectorBeginSignature = FSINFO_SECTOR_BEGIN_SIGNATURE;
                FsInfoSector->FsInfoSignature = FSINFO_SIGNATURE;
                FsInfoSector->FreeClusterCount = Vcb->AllocationSupport.NumberOfFreeClusters;
                FsInfoSector->NextFreeCluster = Vcb->ClusterHint;
                FsInfoSector->SectorEndSignature = FSINFO_SECTOR_END_SIGNATURE;
            }

            //
            //  Initialize the event we're going to use
            //

            KeInitializeEvent( &Event, NotificationEvent, FALSE );

            //
            //  Build the irp for the operation and also set the override flag.
            //  Note that we may be at APC level, so do this asyncrhonously and
            //  use an event for synchronization as normal request completion
            //  cannot occur at APC level.
            //

            Irp = IoBuildAsynchronousFsdRequest( IRP_MJ_WRITE,
                                                 Vcb->TargetDeviceObject,
                                                 (PVOID)Sector,
                                                 WriteLength,
                                                 &Offset,
                                                 NULL );

            if ( Irp == NULL ) {

                try_return(NOTHING);
            }

            //
            //  Make this operation write-through.  It never hurts to try to be
            //  safer about this, even though we aren't logged.
            //

            SetFlag( IoGetNextIrpStackLocation( Irp )->Flags, SL_WRITE_THROUGH );

            //
            //  Set up the completion routine
            //

            IoSetCompletionRoutine( Irp,
                                    FatMarkVolumeCompletionRoutine,
                                    &Event,
                                    TRUE,
                                    TRUE,
                                    TRUE );

            //
            //  Call the device to do the write and wait for it to finish.
            //  Igmore any return status.
            //

            Status = IoCallDriver( Vcb->TargetDeviceObject, Irp );

            if (Status == STATUS_PENDING) {

                (VOID)KeWaitForSingleObject( &Event, Executive, KernelMode, FALSE, (PLARGE_INTEGER)NULL );
            }

        try_exit: NOTHING;
        } finally {

            //
            //  Clean up the Irp and Mdl
            //

            if (Irp) {

                //
                //  If there is an MDL (or MDLs) associated with this I/O
                //  request, Free it (them) here.  This is accomplished by
                //  walking the MDL list hanging off of the IRP and deallocating
                //  each MDL encountered.
                //

                while (Irp->MdlAddress != NULL) {

                    PMDL NextMdl;

                    NextMdl = Irp->MdlAddress->Next;

                    MmUnlockPages( Irp->MdlAddress );

                    IoFreeMdl( Irp->MdlAddress );

                    Irp->MdlAddress = NextMdl;
                }

                IoFreeIrp( Irp );
            }

            if (Bcb != NULL) {

                FatUnpinBcb( IrpContext, Bcb );
            }
        }
    }

    //
    //  Flip the dirty bit in the FAT
    //

    if (VolumeState == VolumeDirty) {

        FatSetFatEntry( IrpContext, Vcb, FAT_DIRTY_BIT_INDEX, FAT_DIRTY_VOLUME);

    } else {

        FatSetFatEntry( IrpContext, Vcb, FAT_DIRTY_BIT_INDEX, FAT_CLEAN_VOLUME);
    }

    DebugTrace(-1, Dbg, "FatMarkVolume -> VOID\n", 0);

    return;
}


VOID
FatFspMarkVolumeDirtyWithRecover(
    PVOID Parameter
    )

/*++

Routine Description:

    This is the routine that performs the actual FatMarkVolume Dirty call
    on a paging file Io that encounters a media error.  It is responsible
    for completing the PagingIo Irp as soon as this is done.

    Note:  this routine (and thus FatMarkVolume()) must be resident as
           the paging file might be damaged at this point.

Arguments:

    Parameter - Points to a dirty volume packet that was allocated from pool

Return Value:

    None.

--*/

{
    PCLEAN_AND_DIRTY_VOLUME_PACKET Packet;
    PVCB Vcb;
    IRP_CONTEXT IrpContext;
    PIRP Irp;
    BOOLEAN VcbExists = FALSE;

    DebugTrace(+1, Dbg, "FatDeferredCleanVolume\n", 0);

    Packet = (PCLEAN_AND_DIRTY_VOLUME_PACKET)Parameter;

    Vcb = Packet->Vcb;
    Irp = Packet->Irp;

    //
    //  Dummy up the IrpContext so we can call our worker routines
    //

    RtlZeroMemory( &IrpContext, sizeof(IRP_CONTEXT));

    SetFlag(IrpContext.Flags, IRP_CONTEXT_FLAG_WAIT);
    IrpContext.OriginatingIrp = Irp;

    //
    //  Make us appear as a top level FSP request so that we will
    //  receive any errors from the operation.
    //

    IoSetTopLevelIrp( (PIRP)FSRTL_FSP_TOP_LEVEL_IRP );

    //
    //  Try to write out the dirty bit.  If something goes wrong, we
    //  tried.
    //

    try {

        SetFlag( Vcb->VcbState, VCB_STATE_FLAG_MOUNTED_DIRTY );

        FatMarkVolume( &IrpContext, Vcb, VolumeDirtyWithSurfaceTest );

    } except(FatExceptionFilter( &IrpContext, GetExceptionInformation() )) {

        NOTHING;
    }

    IoSetTopLevelIrp( NULL );

    //
    //  Now complete the originating Irp or set the synchronous event.
    //

    if (Packet->Event) {
        KeSetEvent( Packet->Event, 0, FALSE );
    } else {
        IoCompleteRequest( Irp, IO_DISK_INCREMENT );
    }
}


VOID
FatCheckDirtyBit (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routine looks at the volume dirty bit, and depending on the state of
    VCB_STATE_FLAG_MOUNTED_DIRTY, the appropriate action is taken.

Arguments:

    Vcb - Supplies the Vcb being queried.

Return Value:

    None.

--*/

{
    BOOLEAN Dirty;

    PPACKED_BOOT_SECTOR BootSector;
    PBCB BootSectorBcb;

    UNICODE_STRING VolumeLabel;

    //
    //  Look in the boot sector
    //

    FatReadVolumeFile( IrpContext,
                       Vcb,
                       0,
                       sizeof(PACKED_BOOT_SECTOR),
                       &BootSectorBcb,
                       (PVOID *)&BootSector );

    try {

        //
        //  Check if the magic bit is set
        //

        if (IsBpbFat32(&BootSector->PackedBpb)) {
            Dirty = BooleanFlagOn( ((PPACKED_BOOT_SECTOR_EX)BootSector)->CurrentHead,
                                   FAT_BOOT_SECTOR_DIRTY );
        } else {
            Dirty = BooleanFlagOn( BootSector->CurrentHead, FAT_BOOT_SECTOR_DIRTY );
        }

        //
        //  Setup the VolumeLabel string
        //

        VolumeLabel.Length = Vcb->Vpb->VolumeLabelLength;
        VolumeLabel.MaximumLength = MAXIMUM_VOLUME_LABEL_LENGTH;
        VolumeLabel.Buffer = &Vcb->Vpb->VolumeLabel[0];

        if ( Dirty ) {

            //
            //  Do not trigger the mounted dirty bit if this is a verify
            //  and the volume is a boot or paging device.  We know that
            //  a boot or paging device cannot leave the system, and thus
            //  that on its mount we will have figured this out correctly.
            //
            //  This logic is a reasonable hack-o-rama to make BillG happy
            //  since his machine ran chkdsk after he installed Beta 3.  Why?
            //  'cause setup cracked a non-exclusive DASD handle near the
            //  end of setup, wrote some data, closed the handle and we
            //  set the verify bit ... came back around and saw that other
            //  arbitrary activity had left the volume in a temporarily dirty
            //  state.
            //
            //  Of course, the real problem is that we don't have a journal.
            //

            if (!(IrpContext->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL &&
                  IrpContext->MinorFunction == IRP_MN_VERIFY_VOLUME &&
                  FlagOn( Vcb->VcbState, VCB_STATE_FLAG_BOOT_OR_PAGING_FILE))) {

                KdPrintEx((DPFLTR_FASTFAT_ID,
                           DPFLTR_INFO_LEVEL,
                           "FASTFAT: WARNING! Mounting Dirty Volume %Z\n",
                           &VolumeLabel));

                SetFlag( Vcb->VcbState, VCB_STATE_FLAG_MOUNTED_DIRTY );
            }

        } else {

            if (FlagOn(Vcb->VcbState, VCB_STATE_FLAG_MOUNTED_DIRTY)) {

                KdPrintEx((DPFLTR_FASTFAT_ID,
                           DPFLTR_INFO_LEVEL,
                           "FASTFAT: Volume %Z has been cleaned.\n",
                           &VolumeLabel));

                ClearFlag( Vcb->VcbState, VCB_STATE_FLAG_MOUNTED_DIRTY );

            } else {

                (VOID)FsRtlBalanceReads( Vcb->TargetDeviceObject );
            }
        }

    } finally {

        FatUnpinBcb( IrpContext, BootSectorBcb );
    }
}


VOID
FatVerifyOperationIsLegal (
    IN PIRP_CONTEXT IrpContext
    )

/*++

Routine Description:

    This routine determines is the requested operation should be allowed to
    continue.  It either returns to the user if the request is Okay, or
    raises an appropriate status.

Arguments:

    Irp - Supplies the Irp to check

Return Value:

    None.

--*/

{
    PIRP Irp;
    PFILE_OBJECT FileObject;

    Irp = IrpContext->OriginatingIrp;

    //
    //  If the Irp is not present, then we got here via close.
    //
    //

    if ( Irp == NULL ) {

        return;
    }

    FileObject = IoGetCurrentIrpStackLocation(Irp)->FileObject;

    //
    //  If there is not a file object, we cannot continue.
    //

    if ( FileObject == NULL ) {

        return;
    }

    //
    //  If the file object has already been cleaned up, and
    //
    //  A) This request is a paging io read or write, or
    //  B) This request is a close operation, or
    //  C) This request is a set or query info call (for Lou)
    //  D) This is an MDL complete
    //
    //  let it pass, otherwise return STATUS_FILE_CLOSED.
    //

    if ( FlagOn(FileObject->Flags, FO_CLEANUP_COMPLETE) ) {

        PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation( Irp );

        if ( (FlagOn(Irp->Flags, IRP_PAGING_IO)) ||
             (IrpSp->MajorFunction == IRP_MJ_CLOSE ) ||
             (IrpSp->MajorFunction == IRP_MJ_SET_INFORMATION) ||
             (IrpSp->MajorFunction == IRP_MJ_QUERY_INFORMATION) ||
             ( ( (IrpSp->MajorFunction == IRP_MJ_READ) ||
                 (IrpSp->MajorFunction == IRP_MJ_WRITE) ) &&
               FlagOn(IrpSp->MinorFunction, IRP_MN_COMPLETE) ) ) {

            NOTHING;

        } else {

            FatRaiseStatus( IrpContext, STATUS_FILE_CLOSED );
        }
    }

    return;
}



//
//  Internal support routine
//

VOID
FatResetFcb (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine is called when an Fcb has been marked as needs to be verified.

    It does the following tasks:

        - Reset Mcb mapping information
        - For directories, reset dirent hints
        - Set allocation size to unknown

Arguments:

    Fcb - Supplies the Fcb to reset

Return Value:

    None.

--*/

{
    //
    //  Don't do the two following operations for the Root Dcb
    //  or paging files.  Paging files!? Yes, if someone diddles
    //  a volume we try to reverify all of the Fcbs just in case;
    //  however, there is no safe way to chuck and retrieve the
    //  mapping pair information for the paging file. Lose it and
    //  die.
    //

    if ( NodeType(Fcb) != FAT_NTC_ROOT_DCB &&
         !FlagOn( Fcb->FcbState, FCB_STATE_PAGING_FILE )) {

        //
        //  Reset the mcb mapping.
        //

        FsRtlRemoveLargeMcbEntry( &Fcb->Mcb, 0, 0xFFFFFFFF );

        //
        //  Reset the allocation size to 0 or unknown
        //

        if ( Fcb->FirstClusterOfFile == 0 ) {

            Fcb->Header.AllocationSize.QuadPart = 0;

        } else {

            Fcb->Header.AllocationSize.QuadPart = FCB_LOOKUP_ALLOCATIONSIZE_HINT;
        }
    }

    //
    //  If this is a directory, reset the hints.
    //

    if ( (NodeType(Fcb) == FAT_NTC_DCB) ||
         (NodeType(Fcb) == FAT_NTC_ROOT_DCB) ) {

        //
        //  Force a rescan of the directory
        //

        Fcb->Specific.Dcb.UnusedDirentVbo = 0xffffffff;
        Fcb->Specific.Dcb.DeletedDirentHint = 0xffffffff;
    }
}



//
//  Internal support routine
//

VOID
FatDetermineAndMarkFcbCondition (
    IN PIRP_CONTEXT IrpContext,
    IN PFCB Fcb
    )

/*++

Routine Description:

    This routine checks a specific Fcb to see if it is different from what's
    on the disk.  The following things are checked:

        - File Name
        - File Size (if not directory)
        - First Cluster Of File
        - Dirent Attributes

Arguments:

    Fcb - Supplies the Fcb to examine

Return Value:

    None.

--*/

{
    PDIRENT Dirent;
    PBCB DirentBcb;
    ULONG FirstClusterOfFile;

    OEM_STRING Name;
    CHAR Buffer[16];

    //
    //  If this is the Root Dcb, special case it.  That is, we know
    //  by definition that it is good since it is fixed in the volume
    //  structure.
    //

    if ( NodeType(Fcb) == FAT_NTC_ROOT_DCB ) {

        FatResetFcb( IrpContext, Fcb );

        FatMarkFcbCondition( IrpContext, Fcb, FcbGood, FALSE );

        return;
    }

    //  The first thing we need to do to verify ourselves is
    //  locate the dirent on the disk.
    //

    FatGetDirentFromFcbOrDcb( IrpContext,
                              Fcb,
                              &Dirent,
                              &DirentBcb );

    //
    //  If we couldn't get the dirent, this fcb must be bad (case of
    //  enclosing directory shrinking during the time it was ejected).
    //
    
    if (DirentBcb == NULL) {
        
        FatMarkFcbCondition( IrpContext, Fcb, FcbBad, TRUE );
        return;
    }

    //
    //  We located the dirent for ourselves now make sure it
    //  is really ours by comparing the Name and FatFlags.
    //  Then for a file we also check the file size.
    //
    //  Note that we have to unpin the Bcb before calling FatResetFcb
    //  in order to avoid a deadlock in CcUninitializeCacheMap.
    //

    try {

        Name.MaximumLength = 16;
        Name.Buffer = &Buffer[0];

        Fat8dot3ToString( IrpContext, Dirent, FALSE, &Name );

        //
        //  We need to calculate the first cluster 'cause FAT32 splits
        //  this field across the dirent.
        //

        FirstClusterOfFile = Dirent->FirstClusterOfFile;

        if (FatIsFat32( Fcb->Vcb )) {

            FirstClusterOfFile += Dirent->FirstClusterOfFileHi << 16;
        }

        if (!RtlEqualString( &Name, &Fcb->ShortName.Name.Oem, TRUE )

                ||

             ( (NodeType(Fcb) == FAT_NTC_FCB) &&
               (Fcb->Header.FileSize.LowPart != Dirent->FileSize) )

                ||

             (FirstClusterOfFile != Fcb->FirstClusterOfFile)

                ||

              (Dirent->Attributes != Fcb->DirentFatFlags) ) {

            FatMarkFcbCondition( IrpContext, Fcb, FcbBad, TRUE );

        } else {

            //
            //  We passed.  Get the Fcb ready to use again.
            //

            FatResetFcb( IrpContext, Fcb );

            FatMarkFcbCondition( IrpContext, Fcb, FcbGood, FALSE );
        }

    } finally {

        FatUnpinBcb( IrpContext, DirentBcb );
    }

    return;
}



//
//  Internal support routine
//

VOID
FatQuickVerifyVcb (
    IN PIRP_CONTEXT IrpContext,
    IN PVCB Vcb
    )

/*++

Routine Description:

    This routines just checks the verify bit in the real device and the
    Vcb condition and raises an appropriate exception if so warented.
    It is called when verifying both Fcbs and Vcbs.

Arguments:

    Vcb - Supplies the Vcb to check the condition of.

Return Value:

    None.

--*/

{
    //
    //  If the real device needs to be verified we'll set the
    //  DeviceToVerify to be our real device and raise VerifyRequired.
    //

    if (FlagOn(Vcb->Vpb->RealDevice->Flags, DO_VERIFY_VOLUME)) {

        DebugTrace(0, Dbg, "The Vcb needs to be verified\n", 0);

        IoSetHardErrorOrVerifyDevice( IrpContext->OriginatingIrp,
                                      Vcb->Vpb->RealDevice );

        FatRaiseStatus( IrpContext, STATUS_VERIFY_REQUIRED );
    }

    //
    //  Based on the condition of the Vcb we'll either return to our
    //  caller or raise an error condition
    //

    switch (Vcb->VcbCondition) {

    case VcbGood:

        DebugTrace(0, Dbg, "The Vcb is good\n", 0);

        //
        //  Do a check here of an operation that would try to modify a
        //  write protected media.
        //

        if (FlagOn(Vcb->VcbState, VCB_STATE_FLAG_WRITE_PROTECTED) &&
            ((IrpContext->MajorFunction == IRP_MJ_WRITE) ||
             (IrpContext->MajorFunction == IRP_MJ_SET_INFORMATION) ||
             (IrpContext->MajorFunction == IRP_MJ_SET_EA) ||
             (IrpContext->MajorFunction == IRP_MJ_FLUSH_BUFFERS) ||
             (IrpContext->MajorFunction == IRP_MJ_SET_VOLUME_INFORMATION) ||
             (IrpContext->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL &&
              IrpContext->MinorFunction == IRP_MN_USER_FS_REQUEST &&
              IoGetCurrentIrpStackLocation(IrpContext->OriginatingIrp)->Parameters.FileSystemControl.FsControlCode ==
                FSCTL_MARK_VOLUME_DIRTY))) {

            //
            //  Set the real device for the pop-up info, and set the verify
            //  bit in the device object, so that we will force a verify
            //  in case the user put the correct media back in.
            //


            IoSetHardErrorOrVerifyDevice( IrpContext->OriginatingIrp,
                                          Vcb->Vpb->RealDevice );

            SetFlag(Vcb->Vpb->RealDevice->Flags, DO_VERIFY_VOLUME);

            FatRaiseStatus( IrpContext, STATUS_MEDIA_WRITE_PROTECTED );
        }

        break;

    case VcbNotMounted:

        DebugTrace(0, Dbg, "The Vcb is not mounted\n", 0);

        //
        //  Set the real device for the pop-up info, and set the verify
        //  bit in the device object, so that we will force a verify
        //  in case the user put the correct media back in.
        //

        IoSetHardErrorOrVerifyDevice( IrpContext->OriginatingIrp,
                                      Vcb->Vpb->RealDevice );

        SetFlag(Vcb->Vpb->RealDevice->Flags, DO_VERIFY_VOLUME);

        FatRaiseStatus( IrpContext, STATUS_WRONG_VOLUME );

        break;

    case VcbBad:

        DebugTrace(0, Dbg, "The Vcb is bad\n", 0);

        if (FlagOn( Vcb->VcbState, VCB_STATE_FLAG_VOLUME_DISMOUNTED )) {

            FatRaiseStatus( IrpContext, STATUS_VOLUME_DISMOUNTED );

        } else {

            FatRaiseStatus( IrpContext, STATUS_FILE_INVALID );
        }
        break;

    default:

        DebugDump("Invalid VcbCondition\n", 0, Vcb);
        FatBugCheck( Vcb->VcbCondition, 0, 0 );
    }
}

NTSTATUS
FatPerformVerify (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp,
    IN PDEVICE_OBJECT Device
    )

/*++

Routine Description:

    This routines performs an IoVerifyVolume operation and takes the
    appropriate action.  After the Verify is complete the originating
    Irp is sent off to an Ex Worker Thread.  This routine is called
    from the exception handler.

Arguments:

    Irp - The irp to send off after all is well and done.

    Device - The real device needing verification.

Return Value:

    None.

--*/

{
    PVCB Vcb;
    NTSTATUS Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION IrpSp;

    //
    //  Check if this Irp has a status of Verify required and if it does
    //  then call the I/O system to do a verify.
    //
    //  Skip the IoVerifyVolume if this is a mount or verify request
    //  itself.  Trying a recursive mount will cause a deadlock with
    //  the DeviceObject->DeviceLock.
    //

    if ( (IrpContext->MajorFunction == IRP_MJ_FILE_SYSTEM_CONTROL)

               &&

         ((IrpContext->MinorFunction == IRP_MN_MOUNT_VOLUME) ||
          (IrpContext->MinorFunction == IRP_MN_VERIFY_VOLUME)) ) {

        return FatFsdPostRequest( IrpContext, Irp );
    }

    DebugTrace(0, Dbg, "Verify Required, DeviceObject = %08lx\n", Device);

    //
    //  Extract a pointer to the Vcb from the VolumeDeviceObject.
    //  Note that since we have specifically excluded mount,
    //  requests, we know that IrpSp->DeviceObject is indeed a
    //  volume device object.
    //

    IrpSp = IoGetCurrentIrpStackLocation(Irp);

    Vcb = &CONTAINING_RECORD( IrpSp->DeviceObject,
                              VOLUME_DEVICE_OBJECT,
                              DeviceObject )->Vcb;

    //
    //  Check if the volume still thinks it needs to be verified,
    //  if it doesn't then we can skip doing a verify because someone
    //  else beat us to it.
    //

    try {

        if (FlagOn(Device->Flags, DO_VERIFY_VOLUME)) {

            PFILE_OBJECT FileObject = IoGetCurrentIrpStackLocation(Irp)->FileObject;
            BOOLEAN AllowRawMount;

            //
            //  We will allow Raw to mount this volume if we were doing a
            //  a DASD open.
            //

            if ( (IrpContext->MajorFunction == IRP_MJ_CREATE) &&
                 (IrpSp->FileObject->FileName.Length == 0) &&
                 (IrpSp->FileObject->RelatedFileObject == NULL) ) {

                AllowRawMount = TRUE;

            } else {

                AllowRawMount = FALSE;
            }

            //
            //  If the IopMount in IoVerifyVolume did something, and
            //  this is an absolute open, force a reparse.
            //

            Status = IoVerifyVolume( Device, AllowRawMount );

            //
            //  If the verify operation completed it will return
            //  either STATUS_SUCCESS or STATUS_WRONG_VOLUME, exactly.
            //
            //  If FatVerifyVolume encountered an error during
            //  processing, it will return that error.  If we got
            //  STATUS_WRONG_VOLUME from the verfy, and our volume
            //  is now mounted, commute the status to STATUS_SUCCESS.
            //

            if ( (Status == STATUS_WRONG_VOLUME) &&
                 (Vcb->VcbCondition == VcbGood) ) {

                Status = STATUS_SUCCESS;
            }

            //
            //  Do a quick unprotected check here.  The routine will do
            //  a safe check.  After here we can release the resource.
            //  Note that if the volume really went away, we will be taking
            //  the Reparse path.
            //

            (VOID)FatAcquireExclusiveGlobal( IrpContext );

            if ( ((Vcb->VcbCondition == VcbNotMounted) ||
                  (Vcb->VcbCondition == VcbBad)) &&
                 (Vcb->OpenFileCount == 0) ) {

                (VOID)FatCheckForDismount( IrpContext, Vcb, FALSE );
            }

            FatReleaseGlobal( IrpContext );

            if ((IrpContext->MajorFunction == IRP_MJ_CREATE) &&
                (FileObject->RelatedFileObject == NULL) &&
                ((Status == STATUS_SUCCESS) || (Status == STATUS_WRONG_VOLUME))) {

                Irp->IoStatus.Information = IO_REMOUNT;

                FatCompleteRequest( IrpContext, Irp, STATUS_REPARSE );
                Status = STATUS_REPARSE;
                Irp = NULL;
            }

            if ( (Irp != NULL) && !NT_SUCCESS(Status) ) {

                //
                //  Fill in the device object if required.
                //

                if ( IoIsErrorUserInduced( Status ) ) {

                    IoSetHardErrorOrVerifyDevice( Irp, Device );
                }

                FatNormalizeAndRaiseStatus( IrpContext, Status );
            }

        } else {

            DebugTrace(0, Dbg, "Volume no longer needs verification\n", 0);
        }

        //
        //  If there is still an Irp, send it off to an Ex Worker thread.
        //

        if ( Irp != NULL ) {

            Status = FatFsdPostRequest( IrpContext, Irp );
        }

    } except(FatExceptionFilter( IrpContext, GetExceptionInformation() )) {

        //
        //  We had some trouble trying to perform the verify or raised
        //  an error ourselves.  So we'll abort the I/O request with
        //  the error status that we get back from the execption code.
        //

        Status = FatProcessException( IrpContext, Irp, GetExceptionCode() );
    }

    return Status;
}

//
//  Local support routine
//

NTSTATUS
FatMarkVolumeCompletionRoutine(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Contxt
    )

{
    //
    //  Set the event so that our call will wake up.
    //

    KeSetEvent( (PKEVENT)Contxt, 0, FALSE );

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Irp );

    return STATUS_MORE_PROCESSING_REQUIRED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fastfat\fskd\cdfs.c ===
#include "pch.h"
#include "cdfskd.h"
#include "fatkd.h"

#include <ntddcdrm.h>
#include <ntdddisk.h>
#include <ntddscsi.h>

#include "..\..\cdfs\nodetype.h"
#include "..\..\cdfs\cd.h"
#include "..\..\cdfs\cdstruc.h"
#include "..\..\cdfs\cddata.h"

#define WordAlign(Ptr) (                \
    ((((ULONG)(Ptr)) + 1) & 0xfffffffe) \
    )

STATE CdFcbState[] = {

    {   FCB_STATE_INITIALIZED,      FCB_STATE_INITIALIZED,      "Initialised"},
    {   FCB_STATE_IN_FCB_TABLE,     FCB_STATE_IN_FCB_TABLE,     "InFcbTable"},
    {   FCB_STATE_MODE2FORM2_FILE,  FCB_STATE_MODE2FORM2_FILE,  "Mode2Form2"},
    {   FCB_STATE_MODE2_FILE,       FCB_STATE_MODE2_FILE,       "Mode2"},
    {   FCB_STATE_DA_FILE,          FCB_STATE_DA_FILE,          "CdDa"},
    { 0 }
};


STATE CdIrpContextFlags[] = {

    {   IRP_CONTEXT_FLAG_ON_STACK,          IRP_CONTEXT_FLAG_ON_STACK,          "OnStack"},
    {   IRP_CONTEXT_FLAG_MORE_PROCESSING,   IRP_CONTEXT_FLAG_MORE_PROCESSING,   "MoreProcessing"},
    {   IRP_CONTEXT_FLAG_FORCE_POST,        IRP_CONTEXT_FLAG_FORCE_POST,        "ForcePost"},
    {   IRP_CONTEXT_FLAG_TOP_LEVEL,         IRP_CONTEXT_FLAG_TOP_LEVEL,         "TopLevel"},
    {   IRP_CONTEXT_FLAG_TOP_LEVEL_CDFS,    IRP_CONTEXT_FLAG_TOP_LEVEL_CDFS,    "TopLevelCdfs"},
    {   IRP_CONTEXT_FLAG_IN_TEARDOWN,       IRP_CONTEXT_FLAG_IN_TEARDOWN,       "InTeardown"},
    {   IRP_CONTEXT_FLAG_ALLOC_IO,          IRP_CONTEXT_FLAG_ALLOC_IO,          "AllocIo"},
    {   IRP_CONTEXT_FLAG_WAIT,              IRP_CONTEXT_FLAG_WAIT,              "Wait"},
    {   IRP_CONTEXT_FLAG_DISABLE_POPUPS,    IRP_CONTEXT_FLAG_DISABLE_POPUPS,    "DisablePopups"},
    {   IRP_CONTEXT_FLAG_IN_FSP,            IRP_CONTEXT_FLAG_IN_FSP,            "InFsp"},
    {   IRP_CONTEXT_FLAG_FULL_NAME,         IRP_CONTEXT_FLAG_FULL_NAME,         "FullName"},
    {   IRP_CONTEXT_FLAG_TRAIL_BACKSLASH,   IRP_CONTEXT_FLAG_TRAIL_BACKSLASH,   "TrailingBackSlash"},
    { 0 }
};


STATE CdVcbStateFlags[] = {

    {   VCB_STATE_HSG,              VCB_STATE_HSG,              "HSG"},
    {   VCB_STATE_ISO,              VCB_STATE_ISO,              "ISO"},
    {   VCB_STATE_JOLIET,           VCB_STATE_JOLIET,           "Joliet"},
    {   VCB_STATE_LOCKED,           VCB_STATE_LOCKED,           "Locked"},
    {   VCB_STATE_REMOVABLE_MEDIA,  VCB_STATE_REMOVABLE_MEDIA,  "Removable"},
    {   VCB_STATE_CDXA,             VCB_STATE_CDXA,             "XA"},
    {   VCB_STATE_AUDIO_DISK,       VCB_STATE_AUDIO_DISK,       "Audio"},
    {   VCB_STATE_NOTIFY_REMOUNT,   VCB_STATE_NOTIFY_REMOUNT,   "NotifyRemount"},
    { 0 }
};


STATE CdCcbFlags[] = {

    {   CCB_FLAG_OPEN_BY_ID,                    CCB_FLAG_OPEN_BY_ID,                    "OpenById"},
    {   CCB_FLAG_OPEN_RELATIVE_BY_ID,           CCB_FLAG_OPEN_RELATIVE_BY_ID,           "OpenRelById"},
    {   CCB_FLAG_IGNORE_CASE,                   CCB_FLAG_IGNORE_CASE,                   "IgnoreCase"},
    {   CCB_FLAG_OPEN_WITH_VERSION,             CCB_FLAG_OPEN_WITH_VERSION,             "OpenWithVersion"},
    {   CCB_FLAG_DISMOUNT_ON_CLOSE,             CCB_FLAG_DISMOUNT_ON_CLOSE,             "DismountOnClose"},
    {   CCB_FLAG_ENUM_NAME_EXP_HAS_WILD,        CCB_FLAG_ENUM_NAME_EXP_HAS_WILD,        "EnumNameHasWild"},
    {   CCB_FLAG_ENUM_VERSION_EXP_HAS_WILD,     CCB_FLAG_ENUM_VERSION_EXP_HAS_WILD,     "EnumVersionHasWild"},
    {   CCB_FLAG_ENUM_MATCH_ALL,                CCB_FLAG_ENUM_MATCH_ALL,                "EnumMatchAll"},
    {   CCB_FLAG_ENUM_VERSION_MATCH_ALL,        CCB_FLAG_ENUM_VERSION_MATCH_ALL,        "EnumVersionMatchAll"},
    {   CCB_FLAG_ENUM_RETURN_NEXT,              CCB_FLAG_ENUM_RETURN_NEXT,              "EnumReturnNext"},
    {   CCB_FLAG_ENUM_INITIALIZED,              CCB_FLAG_ENUM_INITIALIZED,              "EnumInitialised"},
    {   CCB_FLAG_ENUM_NOMATCH_CONSTANT_ENTRY,   CCB_FLAG_ENUM_NOMATCH_CONSTANT_ENTRY,   "NoMatchConstantEntry"},
    { 0 }
};


STATE IsoDirentFlags[] = {
    {   CD_ATTRIBUTE_HIDDEN,        CD_ATTRIBUTE_HIDDEN,        "Hidden"},
    {   CD_ATTRIBUTE_DIRECTORY,     CD_ATTRIBUTE_DIRECTORY,     "Directory"},
    {   CD_ATTRIBUTE_MULTI,         CD_ATTRIBUTE_MULTI,         "Multi(MoreDirentsFollow)"},
    {   CD_ATTRIBUTE_ASSOC,         CD_ATTRIBUTE_ASSOC,         "Associated"},
    { 0 }
};


VOID
CdSummaryFcbDumpRoutine(
    IN UINT64 RemoteAddress,
    IN LONG Options
    )
{
    ULONG Offset;
    
    if (Options >= 2)  {
    
        DumpCdFcb( RemoteAddress, 0, 0);
    }
    else  {
    
        USHORT Type;

        ReadM( &Type, RemoteAddress, sizeof( Type));
        
        if ((Type != CDFS_NTC_FCB_DATA) && (CDFS_NTC_FCB_INDEX != Type) &&
            (Type != CDFS_NTC_FCB_PATH_TABLE)
           ) {
           
            dprintf( "FCB signature does not match @%I64x", RemoteAddress);
            return;
        }

        dprintf( "%s @ %I64x  ", NodeTypeName( TypeCodeInfoIndex( Type)), RemoteAddress);

        ROE( GetFieldOffset( "cdfs!FCB", "FileNamePrefix.ExactCaseName.FileName", &Offset));
        DumpStr( Offset, RemoteAddress + Offset, "Name: ", FALSE, TRUE);
    }
}


DUMP_ROUTINE( DumpCdFcb)

/*++

Routine Description:

    Dump a specific fcb.

Arguments:

    Address - Gives the address of the fcb to dump

Return Value:

    None

--*/

{
    USHORT Type;
    ULONG FcbState, Flags, Offset, Offsetb;
    UINT64 NonP;

    ReadM( &Type, Address, sizeof( Type));

    dprintf("[ Option flags:  1 = list children,  2 = Dump MCB ]\n\n");

    //
    //  Having established that this looks like an fcb, let's dump the
    //  interesting parts.
    //

    ROE( GetFieldValue( Address, InfoNode->TypeName, "FcbState", FcbState));
    dprintf("FcbState     : ");
    PrintState( CdFcbState, FcbState );

    ROE( GetFieldValue( Address, InfoNode->TypeName, "Header.Flags", Flags));
    dprintf("Header.Flags : ");
    PrintState( HeaderFlags, Flags );

    ROE( GetFieldValue( Address, InfoNode->TypeName, "Header.Flags2", Flags));
    dprintf("Header.Flags2: ");
    PrintState( HeaderFlags2, Flags );
    dprintf("\n");

    Dt( InfoNode->TypeName, Address, 0, 0, NULL);

    //
    //  Nonpaged portion
    //

    ROE( GetFieldValue( Address, InfoNode->TypeName, "FcbNonpaged", NonP));

    if (0 != NonP)  {
    
        dprintf("\n");
        Dt( "cdfs!FCB_NONPAGED", Address, 0, 0, NULL);
    }

    //
    //  Dump all children 
    //
    
    if (( Options & 1)  && (CDFS_NTC_FCB_INDEX == Type)) {

        dprintf("\nChild Fcb list\n\n");

        ROE( GetFieldOffset( InfoNode->TypeName, "FcbQueue", &Offset));
        ROE( GetFieldOffset( InfoNode->TypeName, "FcbLinks", &Offsetb));

        DumpList( Address + Offset,
                  CdSummaryFcbDumpRoutine,
                  Offsetb,
                  FALSE,
                  0 );
    }

    if (Options & 2)  {

        ROE( GetFieldOffset( InfoNode->TypeName, "Mcb", &Offset));
        DumpCdMcb( Address + Offset, 1, 0);
    }
    
    dprintf( "\n" );
}


DUMP_ROUTINE( DumpCdCcb)
{
    ULONG Flags;

    ROE( GetFieldValue(  Address, InfoNode->TypeName, "Flags", Flags));
    
    dprintf( "Ccb.Flags: ");
    PrintState( CdCcbFlags, Flags);
    dprintf( "\n");

    Dt( InfoNode->TypeName, Address, Options, 0, NULL);
}


DUMP_ROUTINE( DumpCdIrpContext )
{
    ULONG Flags;

    ROE( GetFieldValue(  Address, InfoNode->TypeName, "Flags", Flags));
    
    dprintf( "Flags: ");
    PrintState( CdIrpContextFlags, Flags);
    dprintf( "\n");

    Dt( InfoNode->TypeName, Address, Options, 0, NULL);
}


DUMP_ROUTINE( DumpCdMcb)
{
    UINT64 Entries;
    ULONG Count, Size;
    
    dprintf( "\nCD_MCB @ %I64x\n\n", Address );

    Dt( "cdfs!CD_MCB", Address, 0, 0, NULL);

    ROE( GetFieldValue( Address, "cdfs!CD_MCB", "McbArray", Entries));
    ROE( GetFieldValue( Address, "cdfs!CD_MCB", "CurrentEntryCount", Count));
    Size = GetTypeSize( "cdfs!CD_MCB_ENTRY");

    dprintf("\n");
    
    if ((1 & Options) && (0 != Count)) {

        LONGLONG DO,BC,FO,DBB,TBB;

        while (Count)  {

            ROE( GetFieldValue( Entries, "cdfs!CD_MCB_ENTRY", "DiskOffset", DO));
            ROE( GetFieldValue( Entries, "cdfs!CD_MCB_ENTRY", "ByteCount", BC));
            ROE( GetFieldValue( Entries, "cdfs!CD_MCB_ENTRY", "FileOffset", FO));
            ROE( GetFieldValue( Entries, "cdfs!CD_MCB_ENTRY", "DataBlockByteCount", DBB));
            ROE( GetFieldValue( Entries, "cdfs!CD_MCB_ENTRY", "TotalBlockByteCount", TBB));

            dprintf(" DO %016I64x BC %016I64x FO %016I64x DB %016I64x TB %016I64x",
                      DO, BC, FO, DBB, TBB);

            Count--;
            Entries += Size;
        }
    }
    dprintf( "\n" );
}



DUMP_ROUTINE( DumpCdVcb)
{
    ULONG Flags;

    ROE( GetFieldValue( Address, InfoNode->TypeName, "VcbState", Flags));
    
    dprintf( "Flags: ");
    PrintState( CdVcbStateFlags, Flags);
    dprintf( "\n");

    Dt( InfoNode->TypeName, Address, Options, 0, NULL);
}


VOID
DumpCdRawDirent(
    IN ULONG64 Address,
    IN LONG Options,
    ULONG Processor,
    HANDLE hCurrentThread
    )
{
    RAW_DIRENT Raw;
    PRAW_DIRENT pRaw;
    UCHAR Buffer[512];
    PUCHAR pBuffer;
    ULONG Result;
    
    UNREFERENCED_PARAMETER( Processor );
    UNREFERENCED_PARAMETER( hCurrentThread );

    if (Options == 0)  {  Options = 1; }

    while (Options--)  {

        RM( Address, Raw, pRaw, PRAW_DIRENT, Result );

        dprintf("\nDumping ISO9660 dirent structure @ 0x%X\n", Address);

        dprintf("\nFileLoc: 0x%8x    DataLen: 0x%8x\n",  *(PULONG)&Raw.FileLoc, *(PULONG)&Raw.DataLen);
        dprintf("ISO Flags: ");
        PrintState(  IsoDirentFlags, (ULONG)Raw.FlagsISO);

        DUMP8_WITH_OFFSET(RAW_DIRENT,   Raw,    DirLen,         "DirLen");
        DUMP8_WITH_OFFSET(RAW_DIRENT,   Raw,    XarLen,         "XarLen");
        DUMP8_WITH_OFFSET(RAW_DIRENT,   Raw,    FlagsHSG,       "FlagsHSG");
        DUMP8_WITH_OFFSET(RAW_DIRENT,   Raw,    FlagsISO,       "FlagsISO");
        DUMP8_WITH_OFFSET(RAW_DIRENT,   Raw,    IntLeaveSkip,   "IntLeaveSkip");
        DUMP8_WITH_OFFSET(RAW_DIRENT,   Raw,    IntLeaveSize,   "IntLeaveSize");
        DUMP8_WITH_OFFSET(RAW_DIRENT,   Raw,    FileIdLen,      "FileIdLen");
        
        dprintf("\nSU area size = 0x%X,  addr = 0x%X\n", Raw.DirLen - ((FIELD_OFFSET( RAW_DIRENT, FileId ) + Raw.FileIdLen) + 1),
                                                   Address + WordAlign( FIELD_OFFSET( RAW_DIRENT, FileId ) + Raw.FileIdLen ));
        if (Raw.FileIdLen)  {

            RMSS( Address,  FIELD_OFFSET( RAW_DIRENT, FileId) + Raw.FileIdLen,  Buffer, pBuffer, PUCHAR, Result );

            pRaw = (PRAW_DIRENT)Buffer;

            if ((1 == Raw.FileIdLen) && ((0 == pRaw->FileId[0]) || (1 == pRaw->FileId[0])))  {

                if (0 == pRaw->FileId[0])  {

                dprintf( "\n\nFileID: <Self>\n\n");

                } else {

                    dprintf( "\n\nFileId: <Parent>\n\n");
                }
            }
            else {

                pRaw->FileId[Raw.FileIdLen] = '\0';
                dprintf("\n\nFileID: '%s'\n\n", pRaw->FileId);
            }
        }

        Address += Raw.DirLen;
    }
}


DUMP_ROUTINE( DumpCdVdo)
{
    USHORT Ntc;
    ULONG Offset;

    ReadM( &Ntc, Address, sizeof( Ntc));
    
    if (CDFS_NTC_VCB == Ntc)  {
    
        //
        //  Looks like we've been given a VCB pointer.  Work back to the containing vdo.
        //

        dprintf("Backtracking to containing VDO from VCB...\n");

        ROE( GetFieldOffset( "cdfs!VOLUME_DEVICE_OBJECT", "Vcb", &Offset));

        Address -= Offset;
    }
    
    dprintf( "\nCDFS Volume device object @ %I64x\n\n",  Address );

    Dt( "cdfs!VOLUME_DEVICE_OBJECT", Address, Options, 0, NULL);    
}


DECLARE_API( cdvdo )
{
    UNREFERENCED_PARAMETER( dwCurrentPc );
    UNREFERENCED_PARAMETER( hCurrentProcess );

    ParseAndDump( (PCHAR) args, (STRUCT_DUMP_ROUTINE) DumpCdVdo, dwProcessor, hCurrentThread );
}


DECLARE_API( cdmcb )
{
    UNREFERENCED_PARAMETER( dwCurrentPc );
    UNREFERENCED_PARAMETER( hCurrentProcess );

    ParseAndDump( (PCHAR) args, (STRUCT_DUMP_ROUTINE) DumpCdMcb, dwProcessor, hCurrentThread );
}

DECLARE_API( cdrawdirent )
{
    UNREFERENCED_PARAMETER( dwCurrentPc );
    UNREFERENCED_PARAMETER( hCurrentProcess );

    ParseAndDump( (PCHAR) args, (STRUCT_DUMP_ROUTINE) DumpCdRawDirent, dwProcessor, hCurrentThread );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fastfat\fskd\cdfskd.h ===
#ifndef __CDFSKD_H
#define __CDFSKD_H

#include "pch.h"

DUMP_ROUTINE( DumpCdCcb);
    
DUMP_ROUTINE( DumpCdFcb);
    
DUMP_ROUTINE( DumpCdIrpContext);

DUMP_ROUTINE( DumpCdMcb);

DUMP_ROUTINE( DumpCdVcb);
    
DUMP_ROUTINE( DumpCdData);

DUMP_ROUTINE( DumpCdVdo);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fastfat\write.c ===
/*++

Copyright (c) 1989-2000 Microsoft Corporation

Module Name:

    Write.c

Abstract:

    This module implements the File Write routine for Write called by the
    dispatch driver.

// @@BEGIN_DDKSPLIT

Author:

    DavidGoebel      [DavidGoe]      11-Apr-1990

Revision History:

// @@END_DDKSPLIT

--*/

#include "FatProcs.h"

//
//  The Bug check file id for this module
//

#define BugCheckFileId                   (FAT_BUG_CHECK_WRITE)

//
//  The local debug trace level
//

#define Dbg                              (DEBUG_TRACE_WRITE)

//
//  Macros to increment the appropriate performance counters.
//

#define CollectWriteStats(VCB,OPEN_TYPE,BYTE_COUNT) {                                        \
    PFILESYSTEM_STATISTICS Stats = &(VCB)->Statistics[KeGetCurrentProcessorNumber()].Common; \
    if (((OPEN_TYPE) == UserFileOpen)) {                                                     \
        Stats->UserFileWrites += 1;                                                          \
        Stats->UserFileWriteBytes += (ULONG)(BYTE_COUNT);                                    \
    } else if (((OPEN_TYPE) == VirtualVolumeFile || ((OPEN_TYPE) == DirectoryFile))) {       \
        Stats->MetaDataWrites += 1;                                                          \
        Stats->MetaDataWriteBytes += (ULONG)(BYTE_COUNT);                                    \
    }                                                                                        \
}

BOOLEAN FatNoAsync = FALSE;

//
//  Local support routines
//

VOID
FatDeferredFlushDpc (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

VOID
FatDeferredFlush (
    PVOID Parameter
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, FatDeferredFlush)
#pragma alloc_text(PAGE, FatCommonWrite)
#endif


NTSTATUS
FatFsdWrite (
    IN PVOLUME_DEVICE_OBJECT VolumeDeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine implements the FSD part of the NtWriteFile API call

Arguments:

    VolumeDeviceObject - Supplies the volume device object where the
        file being Write exists

    Irp - Supplies the Irp being processed

Return Value:

    NTSTATUS - The FSD status for the IRP

--*/

{
    PFCB Fcb;
    NTSTATUS Status;
    PIRP_CONTEXT IrpContext = NULL;

    BOOLEAN ModWriter = FALSE;
    BOOLEAN TopLevel;

    DebugTrace(+1, Dbg, "FatFsdWrite\n", 0);

    //
    //  Call the common Write routine, with blocking allowed if synchronous
    //

    FsRtlEnterFileSystem();

    //
    //  We are first going to do a quick check for paging file IO.  Since this
    //  is a fast path, we must replicate the check for the fsdo.
    //

    if (!FatDeviceIsFatFsdo( IoGetCurrentIrpStackLocation(Irp)->DeviceObject))  {

        Fcb = (PFCB)(IoGetCurrentIrpStackLocation(Irp)->FileObject->FsContext);

        if ((NodeType(Fcb) == FAT_NTC_FCB) &&
            FlagOn(Fcb->FcbState, FCB_STATE_PAGING_FILE)) {

            //
            //  Do the usual STATUS_PENDING things.
            //

            IoMarkIrpPending( Irp );

            //
            //  Perform the actual IO, it will be completed when the io finishes.
            //

            FatPagingFileIo( Irp, Fcb );

            FsRtlExitFileSystem();

            return STATUS_PENDING;
        }
    }

    try {

        TopLevel = FatIsIrpTopLevel( Irp );

        IrpContext = FatCreateIrpContext( Irp, CanFsdWait( Irp ) );

        //
        //  This is a kludge for the mod writer case.  The correct state
        //  of recursion is set in IrpContext, however, we much with the
        //  actual top level Irp field to get the correct WriteThrough
        //  behaviour.
        //

        if (IoGetTopLevelIrp() == (PIRP)FSRTL_MOD_WRITE_TOP_LEVEL_IRP) {

            ModWriter = TRUE;

            IoSetTopLevelIrp( Irp );
        }

        //
        //  If this is an Mdl complete request, don't go through
        //  common write.
        //

        if (FlagOn( IrpContext->MinorFunction, IRP_MN_COMPLETE )) {

            DebugTrace(0, Dbg, "Calling FatCompleteMdl\n", 0 );
            Status = FatCompleteMdl( IrpContext, Irp );

        } else {

            Status = FatCommonWrite( IrpContext, Irp );
        }

    } except(FatExceptionFilter( IrpContext, GetExceptionInformation() )) {

        //
        //  We had some trouble trying to perform the requested
        //  operation, so we'll abort the I/O request with
        //  the error status that we get back from the
        //  execption code
        //

        Status = FatProcessException( IrpContext, Irp, GetExceptionCode() );
    }

//  ASSERT( !(ModWriter && (Status == STATUS_CANT_WAIT)) );

    ASSERT( !(ModWriter && TopLevel) );

    if (ModWriter) { IoSetTopLevelIrp((PIRP)FSRTL_MOD_WRITE_TOP_LEVEL_IRP); }

    if (TopLevel) { IoSetTopLevelIrp( NULL ); }

    FsRtlExitFileSystem();

    //
    //  And return to our caller
    //

    DebugTrace(-1, Dbg, "FatFsdWrite -> %08lx\n", Status);

    UNREFERENCED_PARAMETER( VolumeDeviceObject );

    return Status;
}


NTSTATUS
FatCommonWrite (
    IN PIRP_CONTEXT IrpContext,
    IN PIRP Irp
    )

/*++

Routine Description:

    This is the common write routine for NtWriteFile, called from both
    the Fsd, or from the Fsp if a request could not be completed without
    blocking in the Fsd.  This routine's actions are
    conditionalized by the Wait input parameter, which determines whether
    it is allowed to block or not.  If a blocking condition is encountered
    with Wait == FALSE, however, the request is posted to the Fsp, who
    always calls with WAIT == TRUE.

Arguments:

    Irp - Supplies the Irp to process

Return Value:

    NTSTATUS - The return status for the operation

--*/

{
    PVCB Vcb;
    PFCB FcbOrDcb;
    PCCB Ccb;

    VBO StartingVbo;
    ULONG ByteCount;
    ULONG FileSize;
    ULONG InitialFileSize;
    ULONG InitialValidDataLength;

    PIO_STACK_LOCATION IrpSp;
    PFILE_OBJECT FileObject;
    TYPE_OF_OPEN TypeOfOpen;

    BOOLEAN PostIrp = FALSE;
    BOOLEAN OplockPostIrp = FALSE;
    BOOLEAN ExtendingFile = FALSE;
    BOOLEAN FcbOrDcbAcquired = FALSE;
    BOOLEAN SwitchBackToAsync = FALSE;
    BOOLEAN CalledByLazyWriter = FALSE;
    BOOLEAN ExtendingValidData = FALSE;
    BOOLEAN FcbAcquiredExclusive = FALSE;
    BOOLEAN FcbCanDemoteToShared = FALSE;
    BOOLEAN WriteFileSizeToDirent = FALSE;
    BOOLEAN RecursiveWriteThrough = FALSE;
    BOOLEAN UnwindOutstandingAsync = FALSE;
    BOOLEAN PagingIoResourceAcquired = FALSE;

    BOOLEAN SynchronousIo;
    BOOLEAN WriteToEof;
    BOOLEAN PagingIo;
    BOOLEAN NonCachedIo;
    BOOLEAN Wait;

    NTSTATUS Status;

    FAT_IO_CONTEXT StackFatIoContext;

    //
    // A system buffer is only used if we have to access the buffer directly
    // from the Fsp to clear a portion or to do a synchronous I/O, or a
    // cached transfer.  It is possible that our caller may have already
    // mapped a system buffer, in which case we must remember this so
    // we do not unmap it on the way out.
    //

    PVOID SystemBuffer = (PVOID) NULL;

    LARGE_INTEGER StartingByte;

    //
    // Get current Irp stack location and file object
    //

    IrpSp = IoGetCurrentIrpStackLocation( Irp );
    FileObject = IrpSp->FileObject;


    DebugTrace(+1, Dbg, "FatCommonWrite\n", 0);
    DebugTrace( 0, Dbg, "Irp                 = %8lx\n", Irp);
    DebugTrace( 0, Dbg, "ByteCount           = %8lx\n", IrpSp->Parameters.Write.Length);
    DebugTrace( 0, Dbg, "ByteOffset.LowPart  = %8lx\n", IrpSp->Parameters.Write.ByteOffset.LowPart);
    DebugTrace( 0, Dbg, "ByteOffset.HighPart = %8lx\n", IrpSp->Parameters.Write.ByteOffset.HighPart);

    //
    // Initialize the appropriate local variables.
    //

    Wait          = BooleanFlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT);
    PagingIo      = BooleanFlagOn(Irp->Flags, IRP_PAGING_IO);
    NonCachedIo   = BooleanFlagOn(Irp->Flags,IRP_NOCACHE);
    SynchronousIo = BooleanFlagOn(FileObject->Flags, FO_SYNCHRONOUS_IO);

    //ASSERT( PagingIo || FileObject->WriteAccess );

    //
    //  Extract the bytecount and do our noop/throttle checking.
    //

    ByteCount = IrpSp->Parameters.Write.Length;

    //
    //  If there is nothing to write, return immediately.
    //

    if (ByteCount == 0) {

        Irp->IoStatus.Information = 0;
        FatCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
        return STATUS_SUCCESS;
    }

    //
    //  See if we have to defer the write.
    //

    if (!NonCachedIo &&
        !CcCanIWrite(FileObject,
                     ByteCount,
                     (BOOLEAN)(Wait && !BooleanFlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_IN_FSP)),
                     BooleanFlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_DEFERRED_WRITE))) {

        BOOLEAN Retrying = BooleanFlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_DEFERRED_WRITE);

        FatPrePostIrp( IrpContext, Irp );

        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_DEFERRED_WRITE );

        CcDeferWrite( FileObject,
                      (PCC_POST_DEFERRED_WRITE)FatAddToWorkque,
                      IrpContext,
                      Irp,
                      ByteCount,
                      Retrying );

        return STATUS_PENDING;
    }

    //
    //  Determine our starting position and type.  If we are writing
    //  at EOF, then we will need additional synchronization before
    //  the IO is issued to determine where the data will go.
    //

    StartingByte = IrpSp->Parameters.Write.ByteOffset;
    StartingVbo = StartingByte.LowPart;

    WriteToEof = ( (StartingByte.LowPart == FILE_WRITE_TO_END_OF_FILE) &&
                   (StartingByte.HighPart == -1) );

    //
    //  Extract the nature of the write from the file object, and case on it
    //

    TypeOfOpen = FatDecodeFileObject(FileObject, &Vcb, &FcbOrDcb, &Ccb);

    ASSERT( Vcb != NULL );

    //
    //  Save callers who try to do cached IO to the raw volume from themselves.
    //

    if (TypeOfOpen == UserVolumeOpen) {

        NonCachedIo = TRUE;
    }

    ASSERT(!(NonCachedIo == FALSE && TypeOfOpen == VirtualVolumeFile));

    //
    //  Collect interesting statistics.  The FLAG_USER_IO bit will indicate
    //  what type of io we're doing in the FatNonCachedIo function.
    //

    if (PagingIo) {
        CollectWriteStats(Vcb, TypeOfOpen, ByteCount);

        if (TypeOfOpen == UserFileOpen) {
            SetFlag(IrpContext->Flags, IRP_CONTEXT_FLAG_USER_IO);
        } else {
            ClearFlag(IrpContext->Flags, IRP_CONTEXT_FLAG_USER_IO);
        }
    }

    //
    //  We must disallow writes to regular objects that would require us
    //  to maintain an AllocationSize of greater than 32 significant bits.
    //
    //  If this is paging IO, this is simply a case where we need to trim.
    //  This will occur in due course.
    //

    if (!PagingIo && !WriteToEof && (TypeOfOpen != UserVolumeOpen)) {

        if (!FatIsIoRangeValid( Vcb, StartingByte, ByteCount )) {

            Irp->IoStatus.Information = 0;
            FatCompleteRequest( IrpContext, Irp, STATUS_DISK_FULL );

            return STATUS_DISK_FULL;
        }
    }

    //
    //  Allocate if necessary and initialize a FAT_IO_CONTEXT block for
    //  all non cached Io.  For synchronous Io
    //  we use stack storage, otherwise we allocate pool.
    //

    if (NonCachedIo) {

        if (IrpContext->FatIoContext == NULL) {

            if (!Wait) {

                IrpContext->FatIoContext =
                    FsRtlAllocatePoolWithTag( NonPagedPool,
                                              sizeof(FAT_IO_CONTEXT),
                                              TAG_FAT_IO_CONTEXT );

            } else {

                IrpContext->FatIoContext = &StackFatIoContext;

                SetFlag( IrpContext->Flags, IRP_CONTEXT_STACK_IO_CONTEXT );
            }
        }

        RtlZeroMemory( IrpContext->FatIoContext, sizeof(FAT_IO_CONTEXT) );

        if (Wait) {

            KeInitializeEvent( &IrpContext->FatIoContext->Wait.SyncEvent,
                               NotificationEvent,
                               FALSE );

        } else {

            IrpContext->FatIoContext->Wait.Async.ResourceThreadId =
                ExGetCurrentResourceThread();

            IrpContext->FatIoContext->Wait.Async.RequestedByteCount =
                ByteCount;

            IrpContext->FatIoContext->Wait.Async.FileObject = FileObject;
        }
    }

    //
    //  Check if this volume has already been shut down.  If it has, fail
    //  this write request.
    //

    if ( FlagOn(Vcb->VcbState, VCB_STATE_FLAG_SHUTDOWN) ) {

        Irp->IoStatus.Information = 0;
        FatCompleteRequest( IrpContext, Irp, STATUS_TOO_LATE );
        return STATUS_TOO_LATE;
    }

    //
    //  This case corresponds to a write of the volume file (only the first
    //  fat allowed, the other fats are written automatically in parallel).
    //
    //  We use an Mcb keep track of dirty sectors.  Actual entries are Vbos
    //  and Lbos (ie. bytes), though they are all added in sector chunks.
    //  Since Vbo == Lbo for the volume file, the Mcb entries
    //  alternate between runs of Vbo == Lbo, and holes (Lbo == 0).  We use
    //  the prior to represent runs of dirty fat sectors, and the latter
    //  for runs of clean fat.  Note that since the first part of the volume
    //  file (boot sector) is always clean (a hole), and an Mcb never ends in
    //  a hole, there must always be an even number of runs(entries) in the Mcb.
    //
    //  The strategy is to find the first and last dirty run in the desired
    //  write range (which will always be a set of pages), and write from the
    //  former to the later.  The may result in writing some clean data, but
    //  will generally be more efficient than writing each runs seperately.
    //

    if (TypeOfOpen == VirtualVolumeFile) {

        LBO DirtyLbo;
        LBO CleanLbo;

        VBO DirtyVbo;
        VBO StartingDirtyVbo;

        ULONG DirtyByteCount;
        ULONG CleanByteCount;

        ULONG WriteLength;

        BOOLEAN MoreDirtyRuns = TRUE;

        IO_STATUS_BLOCK RaiseIosb;

        DebugTrace(0, Dbg, "Type of write is Virtual Volume File\n", 0);

        //
        //  If we can't wait we have to post this.
        //

        if (!Wait) {

            DebugTrace( 0, Dbg, "Passing request to Fsp\n", 0 );

            Status = FatFsdPostRequest(IrpContext, Irp);

            return Status;
        }

        //
        //  If we weren't called by the Lazy Writer, then this write
        //  must be the result of a write-through or flush operation.
        //  Setting the IrpContext flag, will cause DevIoSup.c to
        //  write-through the data to the disk.
        //

        if (!FlagOn((ULONG_PTR)IoGetTopLevelIrp(), FSRTL_CACHE_TOP_LEVEL_IRP)) {

            SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_WRITE_THROUGH );
        }

        //
        //  Assert an even number of entries in the Mcb, an odd number would
        //  mean that the Mcb is corrupt.
        //

        ASSERT( (FsRtlNumberOfRunsInLargeMcb( &Vcb->DirtyFatMcb ) & 1) == 0);

        //
        //  We need to skip over any clean sectors at the start of the write.
        //
        //  Also check the two cases where there are no dirty fats in the
        //  desired write range, and complete them with success.
        //
        //      1) There is no Mcb entry corresponding to StartingVbo, meaning
        //         we are beyond the end of the Mcb, and thus dirty fats.
        //
        //      2) The run at StartingVbo is clean and continues beyond the
        //         desired write range.
        //

        if (!FatLookupMcbEntry( Vcb, &Vcb->DirtyFatMcb,
                                StartingVbo,
                                &DirtyLbo,
                                &DirtyByteCount,
                                NULL )

          || ( (DirtyLbo == 0) && (DirtyByteCount >= ByteCount) ) ) {

            DebugTrace(0, DEBUG_TRACE_DEBUG_HOOKS,
                       "No dirty fat sectors in the write range.\n", 0);

            FatCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
            return STATUS_SUCCESS;
        }

        DirtyVbo = (VBO)DirtyLbo;

        //
        //  If the last run was a hole (clean), up DirtyVbo to the next
        //  run, which must be dirty.
        //

        if (DirtyVbo == 0) {

            DirtyVbo = StartingVbo + DirtyByteCount;
        }

        //
        //  This is where the write will start.
        //

        StartingDirtyVbo = DirtyVbo;

        //
        //
        //  Now start enumerating the dirty fat sectors spanning the desired
        //  write range, this first one of which is now DirtyVbo.
        //

        while ( MoreDirtyRuns ) {

            //
            //  Find the next dirty run, if it is not there, the Mcb ended
            //  in a hole, or there is some other corruption of the Mcb.
            //

            if (!FatLookupMcbEntry( Vcb, &Vcb->DirtyFatMcb,
                                    DirtyVbo,
                                    &DirtyLbo,
                                    &DirtyByteCount,
                                    NULL )) {

                DirtyVbo = (VBO)DirtyLbo;

                DebugTrace(0, Dbg, "Last dirty fat Mcb entry was a hole: corrupt.\n", 0);
                FatBugCheck( 0, 0, 0 );

            } else {

                DirtyVbo = (VBO)DirtyLbo;

                //
                //  This has to correspond to a dirty run, and must start
                //  within the write range since we check it at entry to,
                //  and at the bottom of this loop.
                //

                ASSERT((DirtyVbo != 0) && (DirtyVbo < StartingVbo + ByteCount));

                //
                //  There are three ways we can know that this was the
                //  last dirty run we want to write.
                //
                //      1)  The current dirty run extends beyond or to the
                //          desired write range.
                //
                //      2)  On trying to find the following clean run, we
                //          discover that this is the last run in the Mcb.
                //
                //      3)  The following clean run extend beyond the
                //          desired write range.
                //
                //  In any of these cases we set MoreDirtyRuns = FALSE.
                //

                //
                //  If the run is larger than we are writing, we also
                //  must truncate the WriteLength.  This is benign in
                //  the equals case.
                //

                if (DirtyVbo + DirtyByteCount >= StartingVbo + ByteCount) {

                    DirtyByteCount = StartingVbo + ByteCount - DirtyVbo;

                    MoreDirtyRuns = FALSE;

                } else {

                    //
                    //  Scan the clean hole after this dirty run.  If this
                    //  run was the last, prepare to exit the loop
                    //

                    if (!FatLookupMcbEntry( Vcb, &Vcb->DirtyFatMcb,
                                            DirtyVbo + DirtyByteCount,
                                            &CleanLbo,
                                            &CleanByteCount,
                                            NULL )) {

                        MoreDirtyRuns = FALSE;

                    } else {

                        //
                        //  Assert that we actually found a clean run.
                        //  and compute the start of the next dirty run.
                        //

                        ASSERT (CleanLbo == 0);

                        //
                        //  If the next dirty run starts beyond the desired
                        //  write, we have found all the runs we need, so
                        //  prepare to exit.
                        //

                        if (DirtyVbo + DirtyByteCount + CleanByteCount >=
                                                    StartingVbo + ByteCount) {

                            MoreDirtyRuns = FALSE;

                        } else {

                            //
                            //  Compute the start of the next dirty run.
                            //

                            DirtyVbo += DirtyByteCount + CleanByteCount;
                        }
                    }
                }
            }
        } // while ( MoreDirtyRuns )

        //
        //  At this point DirtyVbo and DirtyByteCount correctly reflect the
        //  final dirty run, constrained to the desired write range.
        //
        //  Now compute the length we finally must write.
        //

        WriteLength = (DirtyVbo + DirtyByteCount) - StartingDirtyVbo;

        //
        // We must now assume that the write will complete with success,
        // and initialize our expected status in RaiseIosb.  It will be
        // modified below if an error occurs.
        //

        RaiseIosb.Status = STATUS_SUCCESS;
        RaiseIosb.Information = ByteCount;

        //
        //  Loop through all the fats, setting up a multiple async to
        //  write them all.  If there are more than FAT_MAX_PARALLEL_IOS
        //  then we do several muilple asyncs.
        //

        {
            ULONG Fat;
            ULONG BytesPerFat;
            IO_RUN StackIoRuns[2];
            PIO_RUN IoRuns;

            BytesPerFat = FatBytesPerFat( &Vcb->Bpb );

            if ((ULONG)Vcb->Bpb.Fats > 2) {

                IoRuns = FsRtlAllocatePoolWithTag( PagedPool,
                                                   (ULONG)Vcb->Bpb.Fats,
                                                   TAG_IO_RUNS );

            } else {

                IoRuns = StackIoRuns;
            }

            for (Fat = 0; Fat < (ULONG)Vcb->Bpb.Fats; Fat++) {

                IoRuns[Fat].Vbo = StartingDirtyVbo;
                IoRuns[Fat].Lbo = Fat * BytesPerFat + StartingDirtyVbo;
                IoRuns[Fat].Offset = StartingDirtyVbo - StartingVbo;
                IoRuns[Fat].ByteCount = WriteLength;
            }

            //
            //  Keep track of meta-data disk ios.
            //

            Vcb->Statistics[KeGetCurrentProcessorNumber()].Common.MetaDataDiskWrites += Vcb->Bpb.Fats;

            try {

                FatMultipleAsync( IrpContext,
                                  Vcb,
                                  Irp,
                                  (ULONG)Vcb->Bpb.Fats,
                                  IoRuns );

            } finally {

                if (IoRuns != StackIoRuns) {

                    ExFreePool( IoRuns );
                }
            }

            //
            //  Wait for all the writes to finish
            //

            FatWaitSync( IrpContext );

            //
            //  If we got an error, or verify required, remember it.
            //

            if (!NT_SUCCESS( Irp->IoStatus.Status )) {

                DebugTrace( 0,
                            Dbg,
                            "Error %X while writing volume file.\n",
                            Irp->IoStatus.Status );

                RaiseIosb = Irp->IoStatus;
            }
        }

        //
        //  If the writes were a success, set the sectors clean, else
        //  raise the error status and mark the volume as needing
        //  verification.  This will automatically reset the volume
        //  structures.
        //
        //  If not, then mark this volume as needing verification to
        //  automatically cause everything to get cleaned up.
        //

        Irp->IoStatus = RaiseIosb;

        if ( NT_SUCCESS( Status = Irp->IoStatus.Status )) {

            FatRemoveMcbEntry( Vcb, &Vcb->DirtyFatMcb,
                               StartingDirtyVbo,
                               WriteLength );

        } else {

            FatNormalizeAndRaiseStatus( IrpContext, Status );
        }

        DebugTrace(-1, Dbg, "CommonRead -> %08lx\n", Status );

        FatCompleteRequest( IrpContext, Irp, Status );
        return Status;
    }

    //
    //  This case corresponds to a general opened volume (DASD), ie.
    //  open ("a:").
    //

    if (TypeOfOpen == UserVolumeOpen) {

        LBO StartingLbo;
        LBO VolumeSize;

        //
        //  Precalculate the volume size since we're nearly always going
        //  to be wanting to use it.
        //

        VolumeSize = (LBO) Int32x32To64( Vcb->Bpb.BytesPerSector,
                                         (Vcb->Bpb.Sectors != 0 ? Vcb->Bpb.Sectors :
                                                                  Vcb->Bpb.LargeSectors));

        StartingLbo = StartingByte.QuadPart;

        DebugTrace(0, Dbg, "Type of write is User Volume.\n", 0);

        //
        //  Verify that the volume for this handle is still valid, permitting
        //  operations to proceed on dismounted volumes via the handle which
        //  performed the dismount.
        //

        if (!FlagOn( Ccb->Flags, CCB_FLAG_COMPLETE_DISMOUNT )) {

            FatQuickVerifyVcb( IrpContext, Vcb );
        }

        if (!FlagOn( Ccb->Flags, CCB_FLAG_DASD_PURGE_DONE )) {

            BOOLEAN PreviousWait = BooleanFlagOn( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT );

            //
            //  Grab the entire volume so that even the normally unsafe action
            //  of writing to an unlocked volume won't open us to a race between
            //  the flush and purge of the FAT below.
            //
            //  I really don't think this is particularly important to worry about,
            //  but a repro case for another bug happens to dance into this race
            //  condition pretty easily. Eh.
            //
            
            SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT );
            FatAcquireExclusiveVolume( IrpContext, Vcb );

            try {

                //
                //  If the volume isn't locked, flush and purge it.
                //

                if (!FlagOn(Vcb->VcbState, VCB_STATE_FLAG_LOCKED)) {

                    FatFlushFat( IrpContext, Vcb );
                    CcPurgeCacheSection( &Vcb->SectionObjectPointers,
                                         NULL,
                                         0,
                                         FALSE );

                    FatPurgeReferencedFileObjects( IrpContext, Vcb->RootDcb, Flush );
                }

            } finally {

                FatReleaseVolume( IrpContext, Vcb );
                if (!PreviousWait) {
                    ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT );
                }
            }

            SetFlag( Ccb->Flags, CCB_FLAG_DASD_PURGE_DONE |
                                 CCB_FLAG_DASD_FLUSH_DONE );
        }

        if (!FlagOn( Ccb->Flags, CCB_FLAG_ALLOW_EXTENDED_DASD_IO )) {

            //
            //  Make sure we don't try to write past end of volume,
            //  reducing the requested byte count if necessary.
            //

            if (WriteToEof || StartingLbo >= VolumeSize) {
                FatCompleteRequest( IrpContext, Irp, STATUS_SUCCESS );
                return STATUS_SUCCESS;
            }

            if (ByteCount > VolumeSize - StartingLbo) {

                ByteCount = (ULONG) (VolumeSize - StartingLbo);

                //
                //  For async writes we had set the byte count in the FatIoContext
                //  above, so fix that here.
                //

                if (!Wait) {

                    IrpContext->FatIoContext->Wait.Async.RequestedByteCount =
                        ByteCount;
                }
            }
        } else {

            //
            //  This has a peculiar interpretation, but just adjust the starting
            //  byte to the end of the visible volume.
            //

            if (WriteToEof) {

                StartingLbo = VolumeSize;
            }
        }

        //
        // For DASD we have to probe and lock the user's buffer
        //

        FatLockUserBuffer( IrpContext, Irp, IoReadAccess, ByteCount );

        //
        //  Set the FO_MODIFIED flag here to trigger a verify when this
        //  handle is closed.  Note that we can err on the conservative
        //  side with no problem, i.e. if we accidently do an extra
        //  verify there is no problem.
        //

        SetFlag( FileObject->Flags, FO_FILE_MODIFIED );

        //
        //  Write the data and wait for the results
        //

        FatSingleAsync( IrpContext,
                        Vcb,
                        StartingLbo,
                        ByteCount,
                        Irp );

        if (!Wait) {

            //
            //  We, nor anybody else, need the IrpContext any more.
            //

            IrpContext->FatIoContext = NULL;

            FatDeleteIrpContext( IrpContext );

            DebugTrace(-1, Dbg, "FatNonCachedIo -> STATUS_PENDING\n", 0);

            return STATUS_PENDING;
        }

        FatWaitSync( IrpContext );

        //
        //  If the call didn't succeed, raise the error status
        //
        //  Also mark this volume as needing verification to automatically
        //  cause everything to get cleaned up.
        //

        if (!NT_SUCCESS( Status = Irp->IoStatus.Status )) {

            FatNormalizeAndRaiseStatus( IrpContext, Status );
        }

        //
        //  Update the current file position.  We assume that
        //  open/create zeros out the CurrentByteOffset field.
        //

        if (SynchronousIo && !PagingIo) {
            FileObject->CurrentByteOffset.QuadPart =
                StartingLbo + Irp->IoStatus.Information;
        }

        DebugTrace(-1, Dbg, "FatCommonWrite -> %08lx\n", Status );

        FatCompleteRequest( IrpContext, Irp, Status );
        return Status;
    }

    //
    //  At this point we know there is an Fcb/Dcb.
    //

    ASSERT( FcbOrDcb != NULL );

    //
    //  Use a try-finally to free Fcb/Dcb and buffers on the way out.
    //

    try {

        //
        // This case corresponds to a normal user write file.
        //

        if ( TypeOfOpen == UserFileOpen ) {

            ULONG ValidDataLength;
            ULONG ValidDataToDisk;
            ULONG ValidDataToCheck;

            DebugTrace(0, Dbg, "Type of write is user file open\n", 0);

            //
            //  If this is a noncached transfer and is not a paging I/O, and
            //  the file has been opened cached, then we will do a flush here
            //  to avoid stale data problems.  Note that we must flush before
            //  acquiring the Fcb shared since the write may try to acquire
            //  it exclusive.
            //
            //  The Purge following the flush will garentee cache coherency.
            //

            if (NonCachedIo && !PagingIo &&
                (FileObject->SectionObjectPointer->DataSectionObject != NULL)) {

                //
                //  We need the Fcb exclsuive to do the CcPurgeCache
                //

                if (!FatAcquireExclusiveFcb( IrpContext, FcbOrDcb )) {

                    DebugTrace( 0, Dbg, "Cannot acquire FcbOrDcb = %08lx shared without waiting\n", FcbOrDcb );

                    try_return( PostIrp = TRUE );
                }

                FcbOrDcbAcquired = TRUE;
                FcbAcquiredExclusive = TRUE;

                //
                //  Preacquire pagingio for the flush.
                //
                
                ExAcquireSharedStarveExclusive( FcbOrDcb->Header.PagingIoResource, TRUE );

                CcFlushCache( FileObject->SectionObjectPointer,
                              WriteToEof ? &FcbOrDcb->Header.FileSize : &StartingByte,
                              ByteCount,
                              &Irp->IoStatus );

                ExReleaseResourceLite( FcbOrDcb->Header.PagingIoResource );

                if (!NT_SUCCESS( Irp->IoStatus.Status)) {

                    try_return( Irp->IoStatus.Status );
                }

                //
                //  Now pick up and hold pagingIO exclusive.  This serializes us with the
                //  completion of a coincedent lazy writer doing its part of the write of
                //  this range.
                //
                //  We hold so that we will prevent a pagefault from occuring and seeing
                //  soon-to-be stale data from the disk. We used to believe this was
                //  something to be left to the app to synchronize; we now realize that
                //  noncached IO on a fileserver is doomed without the filesystem forcing
                //  the coherency issue. By only penalizing noncached coherency when
                //  needed, this is about the best we can do.
                //
                
                ExAcquireResourceExclusiveLite( FcbOrDcb->Header.PagingIoResource, TRUE);
                PagingIoResourceAcquired = TRUE;

                CcPurgeCacheSection( FileObject->SectionObjectPointer,
                                     WriteToEof ? &FcbOrDcb->Header.FileSize : &StartingByte,
                                     ByteCount,
                                     FALSE );

                //
                //  Indicate we're OK with the fcb being demoted to shared access
                //  if that turns out to be possible later on after VDL extension
                //  is checked for.
                //
                //  PagingIo must be held all the way through.
                //
                
                FcbCanDemoteToShared = TRUE;
            }

            //
            //  We assert that Paging Io writes will never WriteToEof.
            //

            ASSERT( WriteToEof ? !PagingIo : TRUE );

            //
            //  First let's acquire the Fcb shared.  Shared is enough if we
            //  are not writing beyond EOF.
            //

            if ( PagingIo ) {

                (VOID)ExAcquireResourceSharedLite( FcbOrDcb->Header.PagingIoResource, TRUE );
                PagingIoResourceAcquired = TRUE;

                if (!Wait) {

                    IrpContext->FatIoContext->Wait.Async.Resource =
                        FcbOrDcb->Header.PagingIoResource;
                }

                //
                //  Check to see if we colided with a MoveFile call, and if
                //  so block until it completes.
                //

                if (FcbOrDcb->MoveFileEvent) {

                    (VOID)KeWaitForSingleObject( FcbOrDcb->MoveFileEvent,
                                                 Executive,
                                                 KernelMode,
                                                 FALSE,
                                                 NULL );
                }

            } else {

                //
                //  We may already have the Fcb due to noncached coherency
                //  work done just above; however, we may still have to extend
                //  valid data length.  We can't demote this to shared, matching
                //  what occured before, until we figure that out a bit later. 
                //
                //  We kept ahold of it since our lockorder is main->paging,
                //  and paging must now held across the noncached write from
                //  the purge on.
                //
                
                //
                //  If this is async I/O, we will wait if there is an exclusive
                //  waiter.
                //

                if (!Wait && NonCachedIo) {

                    if (!FcbOrDcbAcquired &&
                        !FatAcquireSharedFcbWaitForEx( IrpContext, FcbOrDcb )) {

                        DebugTrace( 0, Dbg, "Cannot acquire FcbOrDcb = %08lx shared without waiting\n", FcbOrDcb );
                        try_return( PostIrp = TRUE );
                    }

                    //
                    //  Note we will have to release this resource elsewhere.  If we came
                    //  out of the noncached coherency path, we will also have to drop
                    //  the paging io resource.
                    //

                    IrpContext->FatIoContext->Wait.Async.Resource = FcbOrDcb->Header.Resource;

                    if (FcbCanDemoteToShared) {
                        
                        IrpContext->FatIoContext->Wait.Async.Resource2 = FcbOrDcb->Header.PagingIoResource;
                    }
                } else {

                    if (!FcbOrDcbAcquired &&
                        !FatAcquireSharedFcb( IrpContext, FcbOrDcb )) {

                        DebugTrace( 0, Dbg, "Cannot acquire FcbOrDcb = %08lx shared without waiting\n", FcbOrDcb );
                        try_return( PostIrp = TRUE );
                    }
                }

                FcbOrDcbAcquired = TRUE;
            }

            //
            //  Get a first tentative file size and valid data length.
            //  We must get ValidDataLength first since it is always
            //  increased second (in case we are unprotected) and
            //  we don't want to capture ValidDataLength > FileSize.
            //

            ValidDataToDisk = FcbOrDcb->ValidDataToDisk;
            ValidDataLength = FcbOrDcb->Header.ValidDataLength.LowPart;
            FileSize = FcbOrDcb->Header.FileSize.LowPart;

            ASSERT( ValidDataLength <= FileSize );

            //
            // If are paging io, then we do not want
            // to write beyond end of file.  If the base is beyond Eof, we will just
            // Noop the call.  If the transfer starts before Eof, but extends
            // beyond, we will truncate the transfer to the last sector
            // boundary.
            //

            //
            //  Just in case this is paging io, limit write to file size.
            //  Otherwise, in case of write through, since Mm rounds up
            //  to a page, we might try to acquire the resource exclusive
            //  when our top level guy only acquired it shared. Thus, =><=.
            //

            if ( PagingIo ) {

                if (StartingVbo >= FileSize) {

                    DebugTrace( 0, Dbg, "PagingIo started beyond EOF.\n", 0 );

                    Irp->IoStatus.Information = 0;

                    try_return( Status = STATUS_SUCCESS );
                }

                if (ByteCount > FileSize - StartingVbo) {

                    DebugTrace( 0, Dbg, "PagingIo extending beyond EOF.\n", 0 );

                    ByteCount = FileSize - StartingVbo;
                }
            }

            //
            //  Determine if we were called by the lazywriter.
            //  (see resrcsup.c)
            //

            if (FcbOrDcb->Specific.Fcb.LazyWriteThread == PsGetCurrentThread()) {

                CalledByLazyWriter = TRUE;

                if (FlagOn( FcbOrDcb->Header.Flags, FSRTL_FLAG_USER_MAPPED_FILE )) {

                    //
                    //  Fail if the start of this request is beyond valid data length.
                    //  Don't worry if this is an unsafe test.  MM and CC won't
                    //  throw this page away if it is really dirty.
                    //

                    if ((StartingVbo + ByteCount > ValidDataLength) &&
                        (StartingVbo < FileSize)) {

                        //
                        //  It's OK if byte range is within the page containing valid data length,
                        //  since we will use ValidDataToDisk as the start point.
                        //

                        if (StartingVbo + ByteCount > ((ValidDataLength + PAGE_SIZE - 1) & ~(PAGE_SIZE - 1))) {

                            //
                            //  Don't flush this now.
                            //

                            try_return( Status = STATUS_FILE_LOCK_CONFLICT );
                        }
                    }
                }
            }

            //
            //  This code detects if we are a recursive synchronous page write
            //  on a write through file object.
            //

            if (FlagOn(Irp->Flags, IRP_SYNCHRONOUS_PAGING_IO) &&
                FlagOn(IrpContext->Flags, IRP_CONTEXT_FLAG_RECURSIVE_CALL)) {

                PIRP TopIrp;

                TopIrp = IoGetTopLevelIrp();

                //
                //  This clause determines if the top level request was
                //  in the FastIo path.  Gack.  Since we don't have a
                //  real sharing protocol for the top level IRP field ...
                //  yet ... if someone put things other than a pure IRP in
                //  there we best be careful.
                //

                if ((ULONG_PTR)TopIrp > FSRTL_MAX_TOP_LEVEL_IRP_FLAG &&
                    NodeType(TopIrp) == IO_TYPE_IRP) {

                    PIO_STACK_LOCATION IrpStack;

                    IrpStack = IoGetCurrentIrpStackLocation(TopIrp);

                    //
                    //  Finally this routine detects if the Top irp was a
                    //  write to this file and thus we are the writethrough.
                    //

                    if ((IrpStack->MajorFunction == IRP_MJ_WRITE) &&
                        (IrpStack->FileObject->FsContext == FileObject->FsContext)) {

                        RecursiveWriteThrough = TRUE;
                        SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_WRITE_THROUGH );
                    }
                }
            }

            //
            //  Here is the deal with ValidDataLength and FileSize:
            //
            //  Rule 1: PagingIo is never allowed to extend file size.
            //
            //  Rule 2: Only the top level requestor may extend Valid
            //          Data Length.  This may be paging IO, as when a
            //          a user maps a file, but will never be as a result
            //          of cache lazy writer writes since they are not the
            //          top level request.
            //
            //  Rule 3: If, using Rules 1 and 2, we decide we must extend
            //          file size or valid data, we take the Fcb exclusive.
            //

            //
            // Now see if we are writing beyond valid data length, and thus
            // maybe beyond the file size.  If so, then we must
            // release the Fcb and reacquire it exclusive.  Note that it is
            // important that when not writing beyond EOF that we check it
            // while acquired shared and keep the FCB acquired, in case some
            // turkey truncates the file.
            //

            //
            //  Note that the lazy writer must not be allowed to try and
            //  acquire the resource exclusive.  This is not a problem since
            //  the lazy writer is paging IO and thus not allowed to extend
            //  file size, and is never the top level guy, thus not able to
            //  extend valid data length.
            //

            if ( !CalledByLazyWriter &&

                 !RecursiveWriteThrough &&

                 (WriteToEof ||
                  StartingVbo + ByteCount > ValidDataLength)) {

                //
                //  If this was an asynchronous write, we are going to make
                //  the request synchronous at this point, but only kinda.
                //  At the last moment, before sending the write off to the
                //  driver, we may shift back to async.
                //
                //  The modified page writer already has the resources
                //  he requires, so this will complete in small finite
                //  time.
                //

                if (!Wait) {

                    Wait = TRUE;
                    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT );

                    if (NonCachedIo) {

                        ASSERT( TypeOfOpen == UserFileOpen );

                        SwitchBackToAsync = TRUE;
                    }
                }

                //
                // We need Exclusive access to the Fcb/Dcb since we will
                // probably have to extend valid data and/or file.
                //

                //
                //  Y'know, the PagingIo case is a mapped page writer, and
                //  MmFlushSection or the mapped page writer itself already
                //  snatched up the main exclusive for us via the AcquireForCcFlush
                //  or AcquireForModWrite logic (the default logic parallels FAT's
                //  requirements since this order/model came first).  Should ASSERT
                //  this since it'll just go 1->2, and a few more unnecesary DPC
                //  transitions.
                //
                //  The preacquire is done to avoid inversion over the collided flush
                //  meta-resource in Mm.  The one time this is not true is at final
                //  system shutdown time, when Mm goes off and flushes all the dirty
                //  pages.  Since the callback is defined as Wait == FALSE he can't
                //  guarantee acquisition (though with clean process shutdown being
                //  enforced, it really should be now).  Permit this to float.
                //
                //  Note that since we're going to fall back on the acquisition aleady
                //  done for us, don't confuse things by thinking we did the work
                //  for it.
                //

                if ( PagingIo ) {

                    ExReleaseResourceLite( FcbOrDcb->Header.PagingIoResource );
                    PagingIoResourceAcquired = FALSE;

                } else {

                    //
                    //  The Fcb may already be acquired exclusive due to coherency
                    //  work performed earlier.  If so, obviously no work to do.
                    //
                    
                    if (!FcbAcquiredExclusive) {
                        
                        FatReleaseFcb( IrpContext, FcbOrDcb );
                        FcbOrDcbAcquired = FALSE;

                        if (!FatAcquireExclusiveFcb( IrpContext, FcbOrDcb )) {

                            DebugTrace( 0, Dbg, "Cannot acquire FcbOrDcb = %08lx shared without waiting\n", FcbOrDcb );

                            try_return( PostIrp = TRUE );
                        }
                        
                        FcbOrDcbAcquired = TRUE;
                        FcbAcquiredExclusive = TRUE;
                    }
                }

                //
                //  Now that we have the Fcb exclusive, see if this write
                //  qualifies for being made async again.  The key point
                //  here is that we are going to update ValidDataLength in
                //  the Fcb before returning.  We must make sure this will
                //  not cause a problem.  One thing we must do is keep out
                //  the FastIo path.
                //

                if (SwitchBackToAsync) {

                    if ((FcbOrDcb->NonPaged->SectionObjectPointers.DataSectionObject != NULL) ||
                        (StartingVbo + ByteCount > FcbOrDcb->Header.ValidDataLength.LowPart) ||
                        FatNoAsync) {

                        RtlZeroMemory( IrpContext->FatIoContext, sizeof(FAT_IO_CONTEXT) );

                        KeInitializeEvent( &IrpContext->FatIoContext->Wait.SyncEvent,
                                           NotificationEvent,
                                           FALSE );

                        SwitchBackToAsync = FALSE;

                    } else {

                        if (!FcbOrDcb->NonPaged->OutstandingAsyncEvent) {

                            FcbOrDcb->NonPaged->OutstandingAsyncEvent =
                                FsRtlAllocatePoolWithTag( NonPagedPool,
                                                          sizeof(KEVENT),
                                                          TAG_EVENT );

                            KeInitializeEvent( FcbOrDcb->NonPaged->OutstandingAsyncEvent,
                                               NotificationEvent,
                                               FALSE );
                        }

                        //
                        //  If we are transitioning from 0 to 1, reset the event.
                        //

                        if (ExInterlockedAddUlong( &FcbOrDcb->NonPaged->OutstandingAsyncWrites,
                                                   1,
                                                   &FatData.GeneralSpinLock ) == 0) {

                            KeClearEvent( FcbOrDcb->NonPaged->OutstandingAsyncEvent );
                        }

                        UnwindOutstandingAsync = TRUE;

                        IrpContext->FatIoContext->Wait.Async.NonPagedFcb = FcbOrDcb->NonPaged;
                    }
                }

                //
                //  Now that we have the Fcb exclusive, get a new batch of
                //  filesize and ValidDataLength.
                //

                ValidDataToDisk = FcbOrDcb->ValidDataToDisk;
                ValidDataLength = FcbOrDcb->Header.ValidDataLength.LowPart;
                FileSize = FcbOrDcb->Header.FileSize.LowPart;

                //
                //  If this is PagingIo check again if any pruning is
                //  required.  It is important to start from basic
                //  princples in case the file was *grown* ...
                //

                if ( PagingIo ) {

                    if (StartingVbo >= FileSize) {
                        Irp->IoStatus.Information = 0;
                        try_return( Status = STATUS_SUCCESS );
                    }
                    
                    ByteCount = IrpSp->Parameters.Write.Length;

                    if (ByteCount > FileSize - StartingVbo) {
                        ByteCount = FileSize - StartingVbo;
                    }
                }
            }

            //
            //  Remember the final requested byte count
            //

            if (NonCachedIo && !Wait) {

                IrpContext->FatIoContext->Wait.Async.RequestedByteCount =
                    ByteCount;
            }

            //
            //  Remember the initial file size and valid data length,
            //  just in case .....
            //

            InitialFileSize = FileSize;

            InitialValidDataLength = ValidDataLength;

            //
            //  Make sure the FcbOrDcb is still good
            //

            FatVerifyFcb( IrpContext, FcbOrDcb );

            //
            //  Check for writing to end of File.  If we are, then we have to
            //  recalculate a number of fields.
            //

            if ( WriteToEof ) {

                StartingVbo = FileSize;
                StartingByte = FcbOrDcb->Header.FileSize;

                //
                //  Since we couldn't know this information until now, perform the
                //  necessary bounds checking that we ommited at the top because
                //  this is a WriteToEof operation.
                //

                if (!FatIsIoRangeValid( Vcb, StartingByte, ByteCount )) {

                    Irp->IoStatus.Information = 0;
                    try_return( Status = STATUS_DISK_FULL );
                }
            }

            //
            //  If this is a non paging write to a data stream object we have to
            //  check for access according to the current state op/filelocks.
            //
            //  Note that after this point, operations will be performed on the file.
            //  No modifying activity can occur prior to this point in the write
            //  path.
            //

            if (!PagingIo && TypeOfOpen == UserFileOpen) {

                Status = FsRtlCheckOplock( &FcbOrDcb->Specific.Fcb.Oplock,
                                           Irp,
                                           IrpContext,
                                           FatOplockComplete,
                                           FatPrePostIrp );

                if (Status != STATUS_SUCCESS) {

                    OplockPostIrp = TRUE;
                    PostIrp = TRUE;
                    try_return( NOTHING );
                }

                //
                //  This oplock call can affect whether fast IO is possible.
                //  We may have broken an oplock to no oplock held.  If the
                //  current state of the file is FastIoIsNotPossible then
                //  recheck the fast IO state.
                //

                if (FcbOrDcb->Header.IsFastIoPossible == FastIoIsNotPossible) {

                    FcbOrDcb->Header.IsFastIoPossible = FatIsFastIoPossible( FcbOrDcb );
                }

                //
                //  And finally check the regular file locks.
                //

                if (!FsRtlCheckLockForWriteAccess( &FcbOrDcb->Specific.Fcb.FileLock, Irp )) {

                    try_return( Status = STATUS_FILE_LOCK_CONFLICT );
                }
            }

            //
            //  Determine if we will deal with extending the file. Note that
            //  this implies extending valid data, and so we already have all
            //  of the required synchronization done.
            //

            if (!PagingIo && (StartingVbo + ByteCount > FileSize)) {

                ExtendingFile = TRUE;
            }

            if ( ExtendingFile ) {

                //
                //  EXTENDING THE FILE
                //
                //  Update our local copy of FileSize
                //

                FileSize = StartingVbo + ByteCount;

                if (FcbOrDcb->Header.AllocationSize.QuadPart == FCB_LOOKUP_ALLOCATIONSIZE_HINT) {

                    FatLookupFileAllocationSize( IrpContext, FcbOrDcb );
                }

                //
                //  If the write goes beyond the allocation size, add some
                //  file allocation.
                //

                if ( FileSize > FcbOrDcb->Header.AllocationSize.LowPart ) {

                    BOOLEAN AllocateMinimumSize = TRUE;

                    //
                    //  Only do allocation chuncking on writes if this is
                    //  not the first allocation added to the file.
                    //

                    if (FcbOrDcb->Header.AllocationSize.LowPart != 0 ) {

                        ULONG ApproximateClusterCount;
                        ULONG TargetAllocation;
                        ULONG Multiplier;
                        ULONG BytesPerCluster;
                        ULONG ClusterAlignedFileSize;

                        //
                        //  We are going to try and allocate a bigger chunk than
                        //  we actually need in order to maximize FastIo usage.
                        //
                        //  The multiplier is computed as follows:
                        //
                        //
                        //            (FreeDiskSpace            )
                        //  Mult =  ( (-------------------------) / 32 ) + 1
                        //            (FileSize - AllocationSize)
                        //
                        //          and max out at 32.
                        //
                        //  With this formula we start winding down chunking
                        //  as we get near the disk space wall.
                        //
                        //  For instance on an empty 1 MEG floppy doing an 8K
                        //  write, the multiplier is 6, or 48K to allocate.
                        //  When this disk is half full, the multipler is 3,
                        //  and when it is 3/4 full, the mupltiplier is only 1.
                        //
                        //  On a larger disk, the multiplier for a 8K read will
                        //  reach its maximum of 32 when there is at least ~8 Megs
                        //  available.
                        //

                        //
                        //  Small write performance note, use cluster aligned
                        //  file size in above equation.
                        //

                        //
                        //  We need to carefully consider what happens when we approach
                        //  a 2^32 byte filesize.  Overflows will cause problems.
                        //

                        BytesPerCluster = 1 << Vcb->AllocationSupport.LogOfBytesPerCluster;

                        //
                        //  This can overflow if the target filesize is in the last cluster.
                        //  In this case, we can obviously skip over all of this fancy
                        //  logic and just max out the file right now.
                        //

                        ClusterAlignedFileSize = (FileSize + (BytesPerCluster - 1)) &
                                                 ~(BytesPerCluster - 1);

                        if (ClusterAlignedFileSize != 0) {

                            //
                            //  This actually has a chance but the possibility of overflowing
                            //  the numerator is pretty unlikely, made more unlikely by moving
                            //  the divide by 32 up to scale the BytesPerCluster. However, even if it does the
                            //  effect is completely benign.
                            //
                            //  FAT32 with a 64k cluster and over 2^21 clusters would do it (and
                            //  so forth - 2^(16 - 5 + 21) == 2^32).  Since this implies a partition
                            //  of 32gb and a number of clusters (and cluster size) we plan to
                            //  disallow in format for FAT32, the odds of this happening are pretty
                            //  low anyway.
                            //
    
                            Multiplier = ((Vcb->AllocationSupport.NumberOfFreeClusters *
                                           (BytesPerCluster >> 5)) /
                                          (ClusterAlignedFileSize -
                                           FcbOrDcb->Header.AllocationSize.LowPart)) + 1;
    
                            if (Multiplier > 32) { Multiplier = 32; }
    
                            Multiplier *= (ClusterAlignedFileSize - FcbOrDcb->Header.AllocationSize.LowPart);

                            TargetAllocation = FcbOrDcb->Header.AllocationSize.LowPart + Multiplier;
    
                            //
                            //  We know that TargetAllocation is in whole clusters, so simply
                            //  checking if it wrapped is correct.  If it did, we fall back
                            //  to allocating up to the maximum legal size.
                            //
    
                            if (TargetAllocation < FcbOrDcb->Header.AllocationSize.LowPart) {
    
                                TargetAllocation = ~BytesPerCluster + 1;
                                Multiplier = TargetAllocation - FcbOrDcb->Header.AllocationSize.LowPart;
                            }
    
                            //
                            //  Now do an unsafe check here to see if we should even
                            //  try to allocate this much.  If not, just allocate
                            //  the minimum size we need, if so so try it, but if it
                            //  fails, just allocate the minimum size we need.
                            //
    
                            ApproximateClusterCount = (Multiplier / BytesPerCluster);
    
                            if (ApproximateClusterCount <= Vcb->AllocationSupport.NumberOfFreeClusters) {
    
                                try {
    
                                    FatAddFileAllocation( IrpContext,
                                                          FcbOrDcb,
                                                          FileObject,
                                                          TargetAllocation );
    
                                    AllocateMinimumSize = FALSE;
                                    SetFlag( FcbOrDcb->FcbState, FCB_STATE_TRUNCATE_ON_CLOSE );
    
                                } except( GetExceptionCode() == STATUS_DISK_FULL ?
                                          EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH ) {
    
                                      FatResetExceptionState( IrpContext );
                                }
                            }
                        }
                    }

                    if ( AllocateMinimumSize ) {

                        FatAddFileAllocation( IrpContext,
                                              FcbOrDcb,
                                              FileObject,
                                              FileSize );
                    }

                    //
                    //  Assert that the allocation worked
                    //

                    ASSERT( FcbOrDcb->Header.AllocationSize.LowPart >= FileSize );
                }

                //
                //  Set the new file size in the Fcb
                //

                ASSERT( FileSize <= FcbOrDcb->Header.AllocationSize.LowPart );

                FcbOrDcb->Header.FileSize.LowPart = FileSize;

                //
                //  Extend the cache map, letting mm knows the new file size.
                //  We only have to do this if the file is cached.
                //

                if (CcIsFileCached(FileObject)) {
                    CcSetFileSizes( FileObject, (PCC_FILE_SIZES)&FcbOrDcb->Header.AllocationSize );
                }
            }

            //
            //  Determine if we will deal with extending valid data.
            //

            if ( !CalledByLazyWriter &&
                 !RecursiveWriteThrough &&
                 (StartingVbo + ByteCount > ValidDataLength) ) {

                ExtendingValidData = TRUE;
            
            } else {

                //
                //  If not extending valid data, and we otherwise believe we
                //  could demote from exclusive to shared, do so.  This will
                //  occur when we synchronize tight for noncached coherency
                //  but must defer the demotion until after we decide about
                //  valid data length, which requires it exclusive.  Since we
                //  can't drop/re-pick the resources without letting a pagefault
                //  squirt through, the resource decision was kept up in the air
                //  until now.
                //
                //  Note that we've still got PagingIo exclusive in these cases.
                //
                
                if (FcbCanDemoteToShared) {

                    ASSERT( FcbAcquiredExclusive && ExIsResourceAcquiredExclusiveLite( FcbOrDcb->Header.Resource ));
                    ExConvertExclusiveToSharedLite( FcbOrDcb->Header.Resource );
                    FcbAcquiredExclusive = FALSE;
                }
            }
            
            if (ValidDataToDisk > ValidDataLength) {
                
                ValidDataToCheck = ValidDataToDisk;
            
            } else {
                
                ValidDataToCheck = ValidDataLength;
            }

            //
            // HANDLE THE NON-CACHED CASE
            //

            if ( NonCachedIo ) {

                //
                // Declare some local variables for enumeration through the
                // runs of the file, and an array to store parameters for
                // parallel I/Os
                //

                ULONG SectorSize;

                ULONG BytesToWrite;

                DebugTrace(0, Dbg, "Non cached write.\n", 0);

                //
                //  Round up to sector boundry.  The end of the write interval
                //  must, however, be beyond EOF.
                //

                SectorSize = (ULONG)Vcb->Bpb.BytesPerSector;

                BytesToWrite = (ByteCount + (SectorSize - 1))
                                         & ~(SectorSize - 1);

                //
                //  All requests should be well formed and
                //  make sure we don't wipe out any data
                //

                if (((StartingVbo & (SectorSize - 1)) != 0) ||

                        ((BytesToWrite != ByteCount) &&
                         (StartingVbo + ByteCount < ValidDataLength))) {

                    ASSERT( FALSE );

                    DebugTrace( 0, Dbg, "FatCommonWrite -> STATUS_NOT_IMPLEMENTED\n", 0);
                    try_return( Status = STATUS_NOT_IMPLEMENTED );
                }

                //
                // If this noncached transfer is at least one sector beyond
                // the current ValidDataLength in the Fcb, then we have to
                // zero the sectors in between.  This can happen if the user
                // has opened the file noncached, or if the user has mapped
                // the file and modified a page beyond ValidDataLength.  It
                // *cannot* happen if the user opened the file cached, because
                // ValidDataLength in the Fcb is updated when he does the cached
                // write (we also zero data in the cache at that time), and
                // therefore, we will bypass this test when the data
                // is ultimately written through (by the Lazy Writer).
                //
                //  For the paging file we don't care about security (ie.
                //  stale data), do don't bother zeroing.
                //
                //  We can actually get writes wholly beyond valid data length
                //  from the LazyWriter because of paging Io decoupling.
                //

                if (!CalledByLazyWriter &&
                    !RecursiveWriteThrough &&
                    (StartingVbo > ValidDataToCheck)) {

                    FatZeroData( IrpContext,
                                 Vcb,
                                 FileObject,
                                 ValidDataToCheck,
                                 StartingVbo - ValidDataToCheck );
                }

                //
                // Make sure we write FileSize to the dirent if we
                // are extending it and we are successful.  (This may or
                // may not occur Write Through, but that is fine.)
                //

                WriteFileSizeToDirent = TRUE;

                //
                //  Perform the actual IO
                //

                if (SwitchBackToAsync) {

                    Wait = FALSE;
                    ClearFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT );
                }

#ifdef SYSCACHE_COMPILE

#define MY_SIZE 0x1000000
#define LONGMAP_COUNTER

#ifdef BITMAP
                //
                //  Maintain a bitmap of IO started on this file.
                //

                {
                    PULONG WriteMask = FcbOrDcb->WriteMask;

                    if (NULL == WriteMask) {

                        WriteMask = FsRtlAllocatePoolWithTag( NonPagedPool,
                                                              (MY_SIZE/PAGE_SIZE) / 8,
                                                              'wtaF' );

                        FcbOrDcb->WriteMask = WriteMask;
                        RtlZeroMemory(WriteMask, (MY_SIZE/PAGE_SIZE) / 8);
                    }

                    if (StartingVbo < MY_SIZE) {

                        ULONG Off = StartingVbo;
                        ULONG Len = BytesToWrite;

                        if (Off + Len > MY_SIZE) {
                            Len = MY_SIZE - Off;
                        }

                        while (Len != 0) {
                            WriteMask[(Off/PAGE_SIZE) / 32] |=
                                1 << (Off/PAGE_SIZE) % 32;

                            Off += PAGE_SIZE;
                            if (Len <= PAGE_SIZE) {
                                break;
                            }
                            Len -= PAGE_SIZE;
                        }
                    }
                }
#endif

#ifdef LONGMAP_COUNTER
                //
                //  Maintain a longmap of IO started on this file, each ulong containing
                //  the value of an ascending counter per write (gives us order information).
                //
                //  Unlike the old bitmask stuff, this is mostly well synchronized.
                //

                {
                    PULONG WriteMask = (PULONG)FcbOrDcb->WriteMask;

                    if (NULL == WriteMask) {

                        WriteMask = FsRtlAllocatePoolWithTag( NonPagedPool,
                                                              (MY_SIZE/PAGE_SIZE) * sizeof(ULONG),
                                                              'wtaF' );

                        FcbOrDcb->WriteMask = WriteMask;
                        RtlZeroMemory(WriteMask, (MY_SIZE/PAGE_SIZE) * sizeof(ULONG));
                    }

                    if (StartingVbo < MY_SIZE) {

                        ULONG Off = StartingVbo;
                        ULONG Len = BytesToWrite;
                        ULONG Tick = InterlockedIncrement( &FcbOrDcb->WriteMaskData );

                        if (Off + Len > MY_SIZE) {
                            Len = MY_SIZE - Off;
                        }

                        while (Len != 0) {
                            InterlockedExchange( WriteMask + Off/PAGE_SIZE, Tick );

                            Off += PAGE_SIZE;
                            if (Len <= PAGE_SIZE) {
                                break;
                            }
                            Len -= PAGE_SIZE;
                        }
                    }
                }
#endif

#endif

                if (FatNonCachedIo( IrpContext,
                                    Irp,
                                    FcbOrDcb,
                                    StartingVbo,
                                    BytesToWrite,
                                    BytesToWrite ) == STATUS_PENDING) {

                    UnwindOutstandingAsync = FALSE;

                    Wait = TRUE;
                    SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_WAIT );

                    IrpContext->FatIoContext = NULL;
                    Irp = NULL;

                    //
                    //  As a matter of fact, if we hit this we are in deep trouble
                    //  if VDL is being extended. We are no longer attached to the
                    //  IRP, and have thus lost synchronization.  Note that we should
                    //  not hit this case anymore since we will not re-async vdl extension.
                    //
                    
                    ASSERT( !ExtendingValidData );

                    try_return( Status = STATUS_PENDING );
                }

                //
                //  If the call didn't succeed, raise the error status
                //

                if (!NT_SUCCESS( Status = Irp->IoStatus.Status )) {

                    FatNormalizeAndRaiseStatus( IrpContext, Status );

                } else {

                    ULONG Temp;

                    //
                    //  Else set the context block to reflect the entire write
                    //  Also assert we got how many bytes we asked for.
                    //

                    ASSERT( Irp->IoStatus.Information == BytesToWrite );

                    Irp->IoStatus.Information = ByteCount;

                    //
                    //  Take this opportunity to update ValidDataToDisk.
                    //

                    Temp = StartingVbo + BytesToWrite;

                    if (FcbOrDcb->ValidDataToDisk < Temp) {
                        FcbOrDcb->ValidDataToDisk = Temp;
                    }
                }

                //
                // The transfer is either complete, or the Iosb contains the
                // appropriate status.
                //

                try_return( Status );

            } // if No Intermediate Buffering


            //
            // HANDLE CACHED CASE
            //

            else {

                ASSERT( !PagingIo );

                //
                // We delay setting up the file cache until now, in case the
                // caller never does any I/O to the file, and thus
                // FileObject->PrivateCacheMap == NULL.
                //

                if ( FileObject->PrivateCacheMap == NULL ) {

                    DebugTrace(0, Dbg, "Initialize cache mapping.\n", 0);

                    //
                    //  Get the file allocation size, and if it is less than
                    //  the file size, raise file corrupt error.
                    //

                    if (FcbOrDcb->Header.AllocationSize.QuadPart == FCB_LOOKUP_ALLOCATIONSIZE_HINT) {

                        FatLookupFileAllocationSize( IrpContext, FcbOrDcb );
                    }

                    if ( FileSize > FcbOrDcb->Header.AllocationSize.LowPart ) {

                        FatPopUpFileCorrupt( IrpContext, FcbOrDcb );

                        FatRaiseStatus( IrpContext, STATUS_FILE_CORRUPT_ERROR );
                    }

                    //
                    //  Now initialize the cache map.
                    //

                    CcInitializeCacheMap( FileObject,
                                          (PCC_FILE_SIZES)&FcbOrDcb->Header.AllocationSize,
                                          FALSE,
                                          &FatData.CacheManagerCallbacks,
                                          FcbOrDcb );

                    CcSetReadAheadGranularity( FileObject, READ_AHEAD_GRANULARITY );

                    //
                    //  Special case large floppy tranfers, and make the file
                    //  object write through.  For small floppy transfers,
                    //  set a timer to go off in a second and flush the file.
                    //
                    //

                    if (!FlagOn( FileObject->Flags, FO_WRITE_THROUGH ) &&
                        FlagOn(Vcb->VcbState, VCB_STATE_FLAG_DEFERRED_FLUSH)) {

                        if (((StartingByte.LowPart & (PAGE_SIZE-1)) == 0) &&
                            (ByteCount >= PAGE_SIZE)) {

                            SetFlag( FileObject->Flags, FO_WRITE_THROUGH );

                        } else {

                            LARGE_INTEGER OneSecondFromNow;
                            PDEFERRED_FLUSH_CONTEXT FlushContext;

                            //
                            //  Get pool and initialize the timer and DPC
                            //

                            FlushContext = FsRtlAllocatePoolWithTag( NonPagedPool,
                                                                     sizeof(DEFERRED_FLUSH_CONTEXT),
                                                                     TAG_DEFERRED_FLUSH_CONTEXT );

                            KeInitializeTimer( &FlushContext->Timer );

                            KeInitializeDpc( &FlushContext->Dpc,
                                             FatDeferredFlushDpc,
                                             FlushContext );


                            //
                            //  We have to reference the file object here.
                            //

                            ObReferenceObject( FileObject );

                            FlushContext->File = FileObject;

                            //
                            //  Let'er rip!
                            //

                            OneSecondFromNow.QuadPart = (LONG)-1*1000*1000*10;

                            KeSetTimer( &FlushContext->Timer,
                                        OneSecondFromNow,
                                        &FlushContext->Dpc );
                        }
                    }
                }

                //
                // If this write is beyond valid data length, then we
                // must zero the data in between.
                //

                if ( StartingVbo > ValidDataToCheck ) {

                    //
                    // Call the Cache Manager to zero the data.
                    //

                    if (!FatZeroData( IrpContext,
                                      Vcb,
                                      FileObject,
                                      ValidDataToCheck,
                                      StartingVbo - ValidDataToCheck )) {

                        DebugTrace( 0, Dbg, "Cached Write could not wait to zero\n", 0 );

                        try_return( PostIrp = TRUE );
                    }
                }

                WriteFileSizeToDirent = BooleanFlagOn(IrpContext->Flags,
                                                      IRP_CONTEXT_FLAG_WRITE_THROUGH);


                //
                // DO A NORMAL CACHED WRITE, if the MDL bit is not set,
                //

                if (!FlagOn(IrpContext->MinorFunction, IRP_MN_MDL)) {

                    DebugTrace(0, Dbg, "Cached write.\n", 0);

                    //
                    //  Get hold of the user's buffer.
                    //

                    SystemBuffer = FatMapUserBuffer( IrpContext, Irp );

                    //
                    // Do the write, possibly writing through
                    //

                    if (!CcCopyWrite( FileObject,
                                      &StartingByte,
                                      ByteCount,
                                      Wait,
                                      SystemBuffer )) {

                        DebugTrace( 0, Dbg, "Cached Write could not wait\n", 0 );

                        try_return( PostIrp = TRUE );
                    }

                    Irp->IoStatus.Status = STATUS_SUCCESS;
                    Irp->IoStatus.Information = ByteCount;

                    try_return( Status = STATUS_SUCCESS );

                } else {

                    //
                    //  DO AN MDL WRITE
                    //

                    DebugTrace(0, Dbg, "MDL write.\n", 0);

                    ASSERT( Wait );

                    CcPrepareMdlWrite( FileObject,
                                       &StartingByte,
                                       ByteCount,
                                       &Irp->MdlAddress,
                                       &Irp->IoStatus );

                    Status = Irp->IoStatus.Status;

                    try_return( Status );
                }
            }
        }

        //
        //  These two cases correspond to a system write directory file and
        //  ea file.
        //

        if (( TypeOfOpen == DirectoryFile ) || ( TypeOfOpen == EaFile)) {

            ULONG SectorSize;

            DebugTrace(0, Dbg, "Write Directory or Ea file.\n", 0);

            //
            //  Make sure the FcbOrDcb is still good
            //

            FatVerifyFcb( IrpContext, FcbOrDcb );

            //
            //  Synchronize here with people deleting directories and
            //  mucking with the internals of the EA file.
            //

            if (!ExAcquireSharedStarveExclusive( FcbOrDcb->Header.PagingIoResource,
                                          Wait )) {

                DebugTrace( 0, Dbg, "Cannot acquire FcbOrDcb = %08lx shared without waiting\n", FcbOrDcb );

                try_return( PostIrp = TRUE );
            }

            PagingIoResourceAcquired = TRUE;

            if (!Wait) {

                IrpContext->FatIoContext->Wait.Async.Resource =
                    FcbOrDcb->Header.PagingIoResource;
            }

            //
            //  Check to see if we colided with a MoveFile call, and if
            //  so block until it completes.
            //

            if (FcbOrDcb->MoveFileEvent) {

                (VOID)KeWaitForSingleObject( FcbOrDcb->MoveFileEvent,
                                             Executive,
                                             KernelMode,
                                             FALSE,
                                             NULL );
            }

            //
            //  If we weren't called by the Lazy Writer, then this write
            //  must be the result of a write-through or flush operation.
            //  Setting the IrpContext flag, will cause DevIoSup.c to
            //  write-through the data to the disk.
            //

            if (!FlagOn((ULONG_PTR)IoGetTopLevelIrp(), FSRTL_CACHE_TOP_LEVEL_IRP)) {

                SetFlag( IrpContext->Flags, IRP_CONTEXT_FLAG_WRITE_THROUGH );
            }

            //
            //  For the noncached case, assert that everything is sector
            //  alligned.
            //

            SectorSize = (ULONG)Vcb->Bpb.BytesPerSector;

            //
            //  We make several assumptions about these two types of files.
            //  Make sure all of them are true.
            //

            ASSERT( NonCachedIo && PagingIo );
            ASSERT( ((StartingVbo | ByteCount) & (SectorSize - 1)) == 0 );

            //
            //  These calls must always be within the allocation size, which is
            //  convienently the same as filesize, which conveniently doesn't
            //  get reset to a hint value when we verify the volume.
            //

            if (StartingVbo >= FcbOrDcb->Header.FileSize.LowPart) {

                DebugTrace( 0, Dbg, "PagingIo dirent started beyond EOF.\n", 0 );

                Irp->IoStatus.Information = 0;

                try_return( Status = STATUS_SUCCESS );
            }

            if ( StartingVbo + ByteCount > FcbOrDcb->Header.FileSize.LowPart ) {

                DebugTrace( 0, Dbg, "PagingIo dirent extending beyond EOF.\n", 0 );
                ByteCount = FcbOrDcb->Header.FileSize.LowPart - StartingVbo;
            }

            //
            //  Perform the actual IO
            //

            if (FatNonCachedIo( IrpContext,
                                Irp,
                                FcbOrDcb,
                                StartingVbo,
                                ByteCount,
                                ByteCount ) == STATUS_PENDING) {

                IrpContext->FatIoContext = NULL;

                Irp = NULL;

                try_return( Status = STATUS_PENDING );
            }

            //
            //  The transfer is either complete, or the Iosb contains the
            //  appropriate status.
            //
            //  Also, mark the volume as needing verification to automatically
            //  clean up stuff.
            //

            if (!NT_SUCCESS( Status = Irp->IoStatus.Status )) {

                FatNormalizeAndRaiseStatus( IrpContext, Status );
            }

            try_return( Status );
        }

        //
        // This is the case of a user who openned a directory. No writing is
        // allowed.
        //

        if ( TypeOfOpen == UserDirectoryOpen ) {

            DebugTrace( 0, Dbg, "FatCommonWrite -> STATUS_INVALID_PARAMETER\n", 0);

            try_return( Status = STATUS_INVALID_PARAMETER );
        }

        //
        //  If we get this far, something really serious is wrong.
        //

        DebugDump("Illegal TypeOfOpen\n", 0, FcbOrDcb );

        FatBugCheck( TypeOfOpen, (ULONG_PTR) FcbOrDcb, 0 );

    try_exit: NOTHING;


        //
        //  If the request was not posted and there is still an Irp,
        //  deal with it.
        //

        if (Irp) {

            if ( !PostIrp ) {

                ULONG ActualBytesWrote;

                DebugTrace( 0, Dbg, "Completing request with status = %08lx\n",
                            Status);

                DebugTrace( 0, Dbg, "                   Information = %08lx\n",
                            Irp->IoStatus.Information);

                //
                //  Record the total number of bytes actually written
                //

                ActualBytesWrote = (ULONG)Irp->IoStatus.Information;

                //
                //  If the file was opened for Synchronous IO, update the current
                //  file position.
                //

                if (SynchronousIo && !PagingIo) {

                    FileObject->CurrentByteOffset.LowPart =
                                                    StartingVbo + ActualBytesWrote;
                }

                //
                //  The following are things we only do if we were successful
                //

                if ( NT_SUCCESS( Status ) ) {

                    //
                    //  If this was not PagingIo, mark that the modify
                    //  time on the dirent needs to be updated on close.
                    //

                    if ( !PagingIo ) {

                        SetFlag( FileObject->Flags, FO_FILE_MODIFIED );
                    }

                    //
                    //  If we extended the file size and we are meant to
                    //  immediately update the dirent, do so. (This flag is
                    //  set for either Write Through or noncached, because
                    //  in either case the data and any necessary zeros are
                    //  actually written to the file.)
                    //

                    if ( ExtendingFile && WriteFileSizeToDirent ) {

                        ASSERT( FileObject->DeleteAccess || FileObject->WriteAccess );

                        FatSetFileSizeInDirent( IrpContext, FcbOrDcb, NULL );

                        //
                        //  Report that a file size has changed.
                        //

                        FatNotifyReportChange( IrpContext,
                                               Vcb,
                                               FcbOrDcb,
                                               FILE_NOTIFY_CHANGE_SIZE,
                                               FILE_ACTION_MODIFIED );
                    }

                    if ( ExtendingFile && !WriteFileSizeToDirent ) {

                        SetFlag( FileObject->Flags, FO_FILE_SIZE_CHANGED );
                    }

                    if ( ExtendingValidData ) {

                        ULONG EndingVboWritten = StartingVbo + ActualBytesWrote;

                        //
                        //  Never set a ValidDataLength greater than FileSize.
                        //

                        if ( FileSize < EndingVboWritten ) {

                            FcbOrDcb->Header.ValidDataLength.LowPart = FileSize;

                        } else {

                            FcbOrDcb->Header.ValidDataLength.LowPart = EndingVboWritten;
                        }

                        //
                        //  Now, if we are noncached and the file is cached, we must
                        //  tell the cache manager about the VDL extension so that
                        //  async cached IO will not be optimized into zero-page faults
                        //  beyond where it believes VDL is.
                        //
                        //  In the cached case, since Cc did the work, it has updated
                        //  itself already.
                        //

                        if (NonCachedIo && CcIsFileCached(FileObject)) {
                            CcSetFileSizes( FileObject, (PCC_FILE_SIZES)&FcbOrDcb->Header.AllocationSize );
                        }
                    }
                }

                //
                //  Note that we have to unpin repinned Bcbs here after the above
                //  work, but if we are going to post the request, we must do this
                //  before the post (below).
                //

                FatUnpinRepinnedBcbs( IrpContext );

            } else {

                //
                //  Take action if the Oplock package is not going to post the Irp.
                //

                if (!OplockPostIrp) {

                    FatUnpinRepinnedBcbs( IrpContext );

                    if ( ExtendingFile ) {

                        //
                        //  We need the PagingIo resource exclusive whenever we
                        //  pull back either file size or valid data length.
                        //

                        if ( FcbOrDcb->Header.PagingIoResource != NULL ) {

                            (VOID)ExAcquireResourceExclusiveLite(FcbOrDcb->Header.PagingIoResource, TRUE);
                        }

                        FcbOrDcb->Header.FileSize.LowPart = InitialFileSize;

                        ASSERT( FcbOrDcb->Header.FileSize.LowPart <= FcbOrDcb->Header.AllocationSize.LowPart );

                        //
                        //  Pull back the cache map as well
                        //

                        if (FileObject->SectionObjectPointer->SharedCacheMap != NULL) {

                            *CcGetFileSizePointer(FileObject) = FcbOrDcb->Header.FileSize;
                        }

                        if ( FcbOrDcb->Header.PagingIoResource != NULL ) {

                            ExReleaseResourceLite( FcbOrDcb->Header.PagingIoResource );
                        }
                    }

                    DebugTrace( 0, Dbg, "Passing request to Fsp\n", 0 );

                    Status = FatFsdPostRequest(IrpContext, Irp);
                }
            }
        }

    } finally {

        DebugUnwind( FatCommonWrite );

        if (AbnormalTermination()) {

            PERESOURCE PagingIoResource = NULL;

            //
            //  Restore initial file size and valid data length
            //

            if (ExtendingFile || ExtendingValidData) {

                //
                //  We got an error, pull back the file size if we extended it.
                //
                //  We need the PagingIo resource exclusive whenever we
                //  pull back either file size or valid data length.
                //

                FcbOrDcb->Header.FileSize.LowPart = InitialFileSize;
                FcbOrDcb->Header.ValidDataLength.LowPart = InitialValidDataLength;

                ASSERT( FcbOrDcb->Header.FileSize.LowPart <= FcbOrDcb->Header.AllocationSize.LowPart );

                //
                //  Pull back the cache map as well
                //

                if (FileObject->SectionObjectPointer->SharedCacheMap != NULL) {

                    *CcGetFileSizePointer(FileObject) = FcbOrDcb->Header.FileSize;
                }
            }
        }

        //
        //  Check if this needs to be backed out.
        //

        if (UnwindOutstandingAsync) {

            ExInterlockedAddUlong( &FcbOrDcb->NonPaged->OutstandingAsyncWrites,
                                   0xffffffff,
                                   &FatData.GeneralSpinLock );
        }

        //
        //  If the FcbOrDcb has been acquired, release it.
        //

        if (FcbOrDcbAcquired && Irp) {

            FatReleaseFcb( NULL, FcbOrDcb );
        }

        if (PagingIoResourceAcquired && Irp) {

            ExReleaseResourceLite( FcbOrDcb->Header.PagingIoResource );
        }

        //
        //  Complete the request if we didn't post it and no exception
        //
        //  Note that FatCompleteRequest does the right thing if either
        //  IrpContext or Irp are NULL
        //

        if ( !PostIrp && !AbnormalTermination() ) {

            FatCompleteRequest( IrpContext, Irp, Status );
        }

        DebugTrace(-1, Dbg, "FatCommonWrite -> %08lx\n", Status );
    }

    return Status;
}


//
//  Local support routine
//

VOID
FatDeferredFlushDpc (
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This routine is dispatched 1 second after a small write to a deferred
    write device that initialized the cache map.  It exqueues an executive
    worker thread to perform the actual task of flushing the file.

Arguments:

    DeferredContext - Contains the deferred flush context.

Return Value:

    None.

--*/

{
    PDEFERRED_FLUSH_CONTEXT FlushContext;

    FlushContext = (PDEFERRED_FLUSH_CONTEXT)DeferredContext;

    //
    //  Send it off
    //

    ExInitializeWorkItem( &FlushContext->Item,
                          FatDeferredFlush,
                          FlushContext );

    ExQueueWorkItem( &FlushContext->Item, CriticalWorkQueue );
}


//
//  Local support routine
//

VOID
FatDeferredFlush (
    PVOID Parameter
    )

/*++

Routine Description:

    This routine performs the actual task of flushing the file.

Arguments:

    DeferredContext - Contains the deferred flush context.

Return Value:

    None.

--*/

{

    PFILE_OBJECT File;
    PVCB Vcb;
    PFCB FcbOrDcb;
    PCCB Ccb;

    File = ((PDEFERRED_FLUSH_CONTEXT)Parameter)->File;

    FatDecodeFileObject(File, &Vcb, &FcbOrDcb, &Ccb);
    ASSERT( FcbOrDcb != NULL );
    
    //
    //  Make us appear as a top level FSP request so that we will
    //  receive any errors from the flush.
    //

    IoSetTopLevelIrp( (PIRP)FSRTL_FSP_TOP_LEVEL_IRP );

    ExAcquireResourceSharedLite( FcbOrDcb->Header.Resource, TRUE );
    ExAcquireResourceSharedLite( FcbOrDcb->Header.PagingIoResource, TRUE );
    
    CcFlushCache( File->SectionObjectPointer, NULL, 0, NULL );

    ExReleaseResourceLite( FcbOrDcb->Header.PagingIoResource );
    ExReleaseResourceLite( FcbOrDcb->Header.Resource );
    
    IoSetTopLevelIrp( NULL );

    ObDereferenceObject( File );

    ExFreePool( Parameter );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fastfat\fskd\fat.c ===
#include "pch.h"
#include "fatkd.h"
#include "..\nodetype.h"
#include "..\fat.h"
#include "..\fatstruc.h"
#include "..\fatdata.h"

STATE FatFcbState[] = {

    {   FCB_STATE_DELETE_ON_CLOSE,              FCB_STATE_DELETE_ON_CLOSE,              "DeleteOnClose" },
    {   FCB_STATE_TRUNCATE_ON_CLOSE,            FCB_STATE_TRUNCATE_ON_CLOSE,            "TruncateOnClose" },
    {   FCB_STATE_PAGING_FILE,                  FCB_STATE_PAGING_FILE,                  "PagingFile" },
    {   FCB_STATE_FORCE_MISS_IN_PROGRESS,       FCB_STATE_FORCE_MISS_IN_PROGRESS,       "ForceMissInProgress" },
    {   FCB_STATE_FLUSH_FAT,                    FCB_STATE_FLUSH_FAT,                    "FlushFat" },
    {   FCB_STATE_TEMPORARY,                    FCB_STATE_TEMPORARY,                    "Temporary" },
    {   FCB_STATE_SYSTEM_FILE,                  FCB_STATE_SYSTEM_FILE,                  "SystemFile" },
    {   FCB_STATE_NAMES_IN_SPLAY_TREE,          FCB_STATE_NAMES_IN_SPLAY_TREE,          "NamesInSplayTree" },
    {   FCB_STATE_HAS_OEM_LONG_NAME,            FCB_STATE_HAS_OEM_LONG_NAME,            "OEMLongName" },
    {   FCB_STATE_HAS_UNICODE_LONG_NAME,        FCB_STATE_HAS_UNICODE_LONG_NAME,        "UnicodeLongName" },
    {   FCB_STATE_DELAY_CLOSE,                  FCB_STATE_DELAY_CLOSE,                  "DelayClose" },
    {   FCB_STATE_8_LOWER_CASE,                 FCB_STATE_8_LOWER_CASE,                 "8LowerCase" },
    {   FCB_STATE_3_LOWER_CASE,                 FCB_STATE_3_LOWER_CASE,                 "3LowerCase" },
    { 0 }
};


STATE FatIrpContextFlags[] = {

    {   IRP_CONTEXT_FLAG_DISABLE_DIRTY,         IRP_CONTEXT_FLAG_DISABLE_DIRTY,         "DisableDirty" },
    {   IRP_CONTEXT_FLAG_WAIT,                  IRP_CONTEXT_FLAG_WAIT,                  "Wait"},
    {   IRP_CONTEXT_FLAG_WRITE_THROUGH,         IRP_CONTEXT_FLAG_WRITE_THROUGH,         "WriteThrough"},
    {   IRP_CONTEXT_FLAG_DISABLE_WRITE_THROUGH, IRP_CONTEXT_FLAG_DISABLE_WRITE_THROUGH, "DisableWriteThrough"},
    {   IRP_CONTEXT_FLAG_RECURSIVE_CALL,        IRP_CONTEXT_FLAG_RECURSIVE_CALL,        "RecursiveCall"},
    {   IRP_CONTEXT_FLAG_DISABLE_POPUPS,        IRP_CONTEXT_FLAG_DISABLE_POPUPS,        "DisablePopups"},
    {   IRP_CONTEXT_FLAG_DEFERRED_WRITE,        IRP_CONTEXT_FLAG_DEFERRED_WRITE,        "DeferredWrite"},
    {   IRP_CONTEXT_FLAG_VERIFY_READ,           IRP_CONTEXT_FLAG_VERIFY_READ,           "VerifyRead"},
    {   IRP_CONTEXT_STACK_IO_CONTEXT,           IRP_CONTEXT_STACK_IO_CONTEXT,           "StackIoContext"},
    {   IRP_CONTEXT_FLAG_IN_FSP,                IRP_CONTEXT_FLAG_IN_FSP,                "InFsp"},
    {   IRP_CONTEXT_FLAG_USER_IO,               IRP_CONTEXT_FLAG_USER_IO,               "UserIo"},
    {   IRP_CONTEXT_FLAG_DISABLE_RAISE,         IRP_CONTEXT_FLAG_DISABLE_RAISE,         "DisableRaise"},
    {   IRP_CONTEXT_FLAG_PARENT_BY_CHILD,       IRP_CONTEXT_FLAG_PARENT_BY_CHILD,       "ParentByChild"},
    { 0 }
};


STATE FatVcbStateFlags[] = {

    {   VCB_STATE_FLAG_LOCKED,              VCB_STATE_FLAG_LOCKED,              "Locked"},
    {   VCB_STATE_FLAG_REMOVABLE_MEDIA,     VCB_STATE_FLAG_REMOVABLE_MEDIA,     "Removable"},
    {   VCB_STATE_FLAG_VOLUME_DIRTY,        VCB_STATE_FLAG_VOLUME_DIRTY,        "VolumeDirty"},
    {   VCB_STATE_FLAG_MOUNTED_DIRTY,       VCB_STATE_FLAG_MOUNTED_DIRTY,       "MountedDirty"},
    {   VCB_STATE_FLAG_SHUTDOWN,            VCB_STATE_FLAG_SHUTDOWN,            "Shutdown"},
    {   VCB_STATE_FLAG_CLOSE_IN_PROGRESS,   VCB_STATE_FLAG_CLOSE_IN_PROGRESS,   "CloseInProgress"},
    {   VCB_STATE_FLAG_DELETED_FCB,         VCB_STATE_FLAG_DELETED_FCB,         "DeletedFcb"},
    {   VCB_STATE_FLAG_CREATE_IN_PROGRESS,  VCB_STATE_FLAG_CREATE_IN_PROGRESS,  "CreateInProgress"},
    {   VCB_STATE_FLAG_BOOT_OR_PAGING_FILE, VCB_STATE_FLAG_BOOT_OR_PAGING_FILE, "BootOrPagingFile"},
    {   VCB_STATE_FLAG_DEFERRED_FLUSH,      VCB_STATE_FLAG_DEFERRED_FLUSH,      "DeferredFlush"},
    {   VCB_STATE_FLAG_ASYNC_CLOSE_ACTIVE,  VCB_STATE_FLAG_ASYNC_CLOSE_ACTIVE,  "AsyncCloseActive"},
    {   VCB_STATE_FLAG_WRITE_PROTECTED,     VCB_STATE_FLAG_WRITE_PROTECTED,     "WriteProtect"},
    {   VCB_STATE_FLAG_REMOVAL_PREVENTED,   VCB_STATE_FLAG_REMOVAL_PREVENTED,   "RemovalPrevented"},
    {   VCB_STATE_FLAG_VOLUME_DISMOUNTED,   VCB_STATE_FLAG_VOLUME_DISMOUNTED,   "Dismounted"},
    { 0 }
};


STATE FatCcbFlags[] = {

    {   CCB_FLAG_MATCH_ALL,                 CCB_FLAG_MATCH_ALL,                 "MatchAll"},
    {   CCB_FLAG_SKIP_SHORT_NAME_COMPARE,   CCB_FLAG_SKIP_SHORT_NAME_COMPARE,   "ShortNameCompare"},
    {   CCB_FLAG_FREE_OEM_BEST_FIT,         CCB_FLAG_FREE_OEM_BEST_FIT,         "OemBestFit"},
    {   CCB_FLAG_FREE_UNICODE,              CCB_FLAG_FREE_UNICODE,              "FreeUnicode"},
    {   CCB_FLAG_USER_SET_LAST_WRITE,       CCB_FLAG_USER_SET_LAST_WRITE,       "UserSetLastWrite"},
    {   CCB_FLAG_USER_SET_LAST_ACCESS,      CCB_FLAG_USER_SET_LAST_ACCESS,      "UserSetLastAccess"},
    {   CCB_FLAG_USER_SET_CREATION,         CCB_FLAG_USER_SET_CREATION,         "UserSetCreation"},
    {   CCB_FLAG_READ_ONLY,                 CCB_FLAG_READ_ONLY,                 "ReadOnly"},
    {   CCB_FLAG_DASD_FLUSH_DONE,           CCB_FLAG_DASD_FLUSH_DONE,           "DasdFlushDone"},
    {   CCB_FLAG_DASD_PURGE_DONE,           CCB_FLAG_DASD_PURGE_DONE,           "DasdPurgeDone"},
    {   CCB_FLAG_DELETE_ON_CLOSE,           CCB_FLAG_DELETE_ON_CLOSE,           "DeleteOnClose"},
    {   CCB_FLAG_OPENED_BY_SHORTNAME,       CCB_FLAG_OPENED_BY_SHORTNAME,       "OpenedByShortname"},
    {   CCB_FLAG_QUERY_TEMPLATE_MIXED,      CCB_FLAG_QUERY_TEMPLATE_MIXED,      "QueryTemplateMixed"},
    {   CCB_FLAG_ALLOW_EXTENDED_DASD_IO,    CCB_FLAG_ALLOW_EXTENDED_DASD_IO,    "AllowExtendedDasdIo"},
    {   CCB_FLAG_CLOSE_CONTEXT,             CCB_FLAG_CLOSE_CONTEXT,             "CloseContext"},
    {   CCB_FLAG_COMPLETE_DISMOUNT,         CCB_FLAG_COMPLETE_DISMOUNT,         "CompleteDismount"},
    { 0 }
};


VOID
FatSummaryFcbDumpRoutine(
    IN ULONG64 RemoteAddress,
    IN LONG Options
    )
{
    ULONG Offset;
    
    if (Options >= 2)  {
    
        DumpFatFcb( RemoteAddress, 0, 0);
    }
    else  {
    
        USHORT Type;

        ReadM( &Type, RemoteAddress, sizeof( Type));
        
        if ((Type != FAT_NTC_FCB) && (FAT_NTC_DCB != Type) &&
            (Type != FAT_NTC_ROOT_DCB)
           ) {
           
            dprintf( "FCB/DCB signature does not match @%I64x", RemoteAddress);
            return;
        }

        ROE( GetFieldValue( RemoteAddress, "fastfat!FCB", "LfnOffsetWithinDirectory", Offset));

        dprintf( "\n%s @ %I64x  LFN: %08x  ", NodeTypeName( TypeCodeInfoIndex( Type)), RemoteAddress, Offset);

        ROE( GetFieldOffset( "fastfat!FCB", "ShortName.Name.Unicode", &Offset));
        DumpStr( Offset, RemoteAddress + Offset, "ShortName", FALSE, FALSE);
    }
}


DUMP_ROUTINE( DumpFatFcb )
{
    ULONG Result;
    USHORT Type;
    ULONG FcbState, Flags, Offset, Offsetb;
    UINT64 NonP;
    FIELD_INFO Expand[] = { //{ ".", NULL, 0,  0, 0, NULL},
                           { "Header.", NULL, 0,  DBG_DUMP_FIELD_RECUR_ON_THIS,0, NULL}
                         };
    FIELD_INFO ExpandFcb[] = { //{ ".", NULL, 0,  0, 0, NULL},
                           { "Specific.Fcb.", NULL, 0,  DBG_DUMP_FIELD_RECUR_ON_THIS,0, NULL}
                         };
    FIELD_INFO ExpandDcb[] = { //{ ".", NULL, 0,  0, 0, NULL},
                           { "Specific.Dcb.", NULL, 0,  DBG_DUMP_FIELD_RECUR_ON_THIS,0, NULL}
                         };

    ReadM( &Type, Address, sizeof( Type));

    dprintf("[ Option flags:  1 = list children,  2 = Dump MCB ]\n\n");
    
    //
    //  Having established that this looks like an fcb, let's dump the
    //  interesting parts.
    //

    ROE( GetFieldValue( Address, InfoNode->TypeName, "FcbState", FcbState));
    dprintf("FcbState     : ");
    PrintState( FatFcbState, FcbState );
    
    ROE( GetFieldValue( Address, InfoNode->TypeName, "Header.Flags", Flags));
    dprintf("Header.Flags : ");
    PrintState( HeaderFlags, Flags );

    ROE( GetFieldValue( Address, InfoNode->TypeName, "Header.Flags2", Flags));
    dprintf("Header.Flags2: ");
    PrintState( HeaderFlags2, Flags );
    dprintf("\n");

    //
    //  Dump names etc.
    //

    ROE( GetFieldOffset( InfoNode->TypeName, "ShortName.Name.Unicode", &Offset));
    DumpStr( Offset, Address + Offset, "ShortName: ", FALSE, FALSE);

    if ( FcbState & FCB_STATE_HAS_UNICODE_LONG_NAME)  {
    
        ROE( GetFieldOffset( InfoNode->TypeName, "LongName.Unicode.Name.Unicode", &Offset));
        DumpStr( Offset, Address + Offset, "LongName :", FALSE, TRUE);
    }
    
    dprintf("\n");
    Dt( InfoNode->TypeName, Address, 0, 1, Expand);
    Dt( InfoNode->TypeName, Address, 0, 0, NULL);
    dprintf("\n");

    //
    //  Expand F/Dcb specific portion
    //
    
    if (Type == FAT_NTC_FCB)  {
    
        Dt( InfoNode->TypeName, Address, 0, 1, ExpandFcb);
    }
    else {
    
        Dt( InfoNode->TypeName, Address, 0, 1, ExpandDcb);
    }
    
    //
    //  Nonpaged portion
    //

    ROE( GetFieldValue( Address, InfoNode->TypeName, "NonPaged", NonP));

    if (NonP != 0)  {
    
        dprintf("\nNonpaged part @ %I64x\n\n", NonP);

        Dt( "fastfat!NON_PAGED_FCB", NonP, 0, 0, NULL);
    }
    
    //
    //  Dump all children / siblings?
    //
    
    if (( Options & 1)  && ((FAT_NTC_DCB == Type) ||
                           (FAT_NTC_ROOT_DCB == Type))) {

        dprintf("\nChild Fcb list\n");

        ROE( GetFieldOffset( InfoNode->TypeName, "Specific.Dcb.ParentDcbQueue", &Offset));
        ROE( GetFieldOffset( InfoNode->TypeName, "ParentDcbLinks", &Offsetb));
        
        DumpList( Address + Offset,
                  FatSummaryFcbDumpRoutine,
                  Offsetb,
                  FALSE,
                  0 );
    }

    if (Options & 2)  {
    
        ROE( GetFieldOffset( InfoNode->TypeName, "Mcb", &Offset));
        DumpLargeMcb( Address+Offset, 0, NULL);
    }
    
    dprintf( "\n" );
}


DUMP_ROUTINE( DumpFatCcb)
{
    ULONG Flags;

    ROE( GetFieldValue(  Address, InfoNode->TypeName, "Flags", Flags));
    
    dprintf( "Ccb.Flags: ");
    PrintState( FatCcbFlags, Flags);
    dprintf( "\n");

    Dt( InfoNode->TypeName, Address, Options, 0, NULL);
}


DUMP_ROUTINE( DumpFatIrpContext)
{
    ULONG Flags;

    ROE( GetFieldValue(  Address, InfoNode->TypeName, "Flags", Flags));
    
    dprintf( "IrpContext.Flags: ");
    PrintState( FatIrpContextFlags, Flags);
    dprintf( "\n");

    Dt( InfoNode->TypeName, Address, Options, 0, NULL);
}


DUMP_ROUTINE( DumpFatVcb)
{
    ULONG Flags;
    FIELD_INFO Alloc[] = { //{ ".", NULL, 0,  0, 0, NULL},
                           { "AllocationSupport.", NULL, 0,  DBG_DUMP_FIELD_RECUR_ON_THIS,0, NULL}
                         };

    ROE( GetFieldValue(  Address, InfoNode->TypeName, "VcbState", Flags));
    
    dprintf( "Vcb.VcbState: ");
    PrintState( FatVcbStateFlags, Flags);
    dprintf( "\n");

    Dt( InfoNode->TypeName, Address, Options, 0, NULL);

    dprintf( "\n");
    
    Dt( InfoNode->TypeName, Address, 1, 1, Alloc);
    
    dprintf( "\n" );
}


DUMP_ROUTINE( DumpFatVdo)
{
    USHORT Ntc;
    PUSHORT pNtc;
    ULONG Offset;

    ReadM( &Ntc, Address, sizeof( Ntc));
    
    if (FAT_NTC_VCB == Ntc)  {
    
        //
        //  Looks like we've been given a VCB pointer.  Work back to the containing vdo.
        //

        dprintf("Backtracking to containing VDO from VCB...");

        ROE( GetFieldOffset( "fastfat!VOLUME_DEVICE_OBJECT", "Vcb", &Offset));

        Address -= Offset;
    }
    
    dprintf( "\nFAT Volume device object @ %08lx\n",  Address );

    Dt( "fastfat!VOLUME_DEVICE_OBJECT", Address, Options, 0, NULL);    
}


DECLARE_API( fatvdo )
{
    UNREFERENCED_PARAMETER( dwCurrentPc );
    UNREFERENCED_PARAMETER( hCurrentProcess );

    ParseAndDump( (PCHAR) args, (STRUCT_DUMP_ROUTINE) DumpFatVdo, dwProcessor, hCurrentThread );
}


DECLARE_API( fatmcb )
{
    UNREFERENCED_PARAMETER( dwCurrentPc );
    UNREFERENCED_PARAMETER( hCurrentProcess );

    ParseAndDump( (PCHAR) args, (STRUCT_DUMP_ROUTINE) DumpLargeMcb, dwProcessor, hCurrentThread );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fastfat\fskd\fatkd.h ===
#ifndef FATKD_H
#define FATKD_H

#include "pch.h"
#pragma hdrstop

DUMP_ROUTINE( DumpAnyStruct);
DUMP_ROUTINE( DumpLargeMcb);

DUMP_ROUTINE(DumpFatFcb);
DUMP_ROUTINE(DumpFatIrpContext);
DUMP_ROUTINE(DumpFatVcb);
DUMP_ROUTINE(DumpFatCcb);
DUMP_ROUTINE(DumpFatVdo);
DUMP_ROUTINE(DumpFatMcb);


extern STATE HeaderFlags[];
extern STATE HeaderFlags2[];

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fastfat\fskd\udfskd.h ===
#ifndef __UDFSKD_H
#define __UDFSKD_H

#include "pch.h"

DUMP_ROUTINE( DumpUdfCcb);
DUMP_ROUTINE( DumpUdfFcb);
DUMP_ROUTINE( DumpUdfIrpContext);
DUMP_ROUTINE( DumpUdfVcb);
DUMP_ROUTINE( DumpUdfData);
DUMP_ROUTINE( DumpUdfVdo);
DUMP_ROUTINE( DumpUdfIrpContextLite);
DUMP_ROUTINE( DumpUdfLcb);
DUMP_ROUTINE( DumpUdfPcb);
DUMP_ROUTINE( DumpUdfFcbRw);
DUMP_ROUTINE( DumpUdfScb);


VOID
UdfSummaryLcbDumpRoutine(
    IN ULONG64 RemoteAddress,
    IN LONG Options
    );

//
//  TRUE if the nodetype code falls in the UDFS RW range.  Enables rejection of
//  RW structures in non-rw FSKD builds
//

#define NTC_IS_UDFS_RW(X)  (((X) >= 0x930) && ((X) <= 0x950))


#ifdef UDFS_RW_IN_BUILD

// RW flags fields

extern STATE UdfRwIrpContextFlags[];
extern STATE UdfRwVcbStateFlags[];
extern STATE UdfScbFlags[];
extern STATE UdfRwCcbFlags[];
extern STATE UdfRwLcbFlags[];

BOOLEAN
NodeIsUdfsRwIndex( USHORT T);

BOOLEAN
NodeIsUdfsRwData( USHORT T);

BOOLEAN
LcbDeleted( ULONG F);

#else

#define UdfRwIrpContextFlags NULL
#define UdfRwVcbStateFlags NULL
#define UdfScbFlags NULL
#define UdfRwCcbFlags NULL
#define UdfRwLcbFlags NULL

#endif


// RO flags fields

extern STATE UdfFcbState[];
extern STATE UdfIrpContextFlags[];
extern STATE UdfVcbStateFlags[];
extern STATE UdfCcbFlags[];
extern STATE UdfLcbFlags[];
extern STATE UdfPcbFlags[];


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fastfat\fskd\pch.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       PCH.cxx
//
//  Contents:   Pre-compiled header
//
//  History:    21-Dec-92       BartoszM        Created
//
//--------------------------------------------------------------------------

#define KDEXTMODE

//
//  Following define prevents the inclusion of extra filter related fields
//  in the FSRTL_COMMON_FCB_HEADER in fsrtl.h,  whcih aren't in ntifs.h (used
//  by FAT)
//

#define BUILDING_FSKDEXT

#ifndef __FATKDPCH_H
#define __FATKDPCH_H

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntos.h>
#include <zwapi.h>

//    typedef int DCB;
#include <windef.h>
#include <windows.h>

#include <memory.h>
#include <fsrtl.h>

#undef CREATE_NEW
#undef OPEN_EXISTING


//#include <ntifs.h>
//#include <ntdddisk.h>

//#include "..\nodetype.h"
//#include "..\Fat.h"
//#include "..\Lfn.h"
//#include "..\FatStruc.h"
//#include "..\FatData.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

//#include <imagehlp.h>

// Stolen from ntrtl.h to override RECOMASSERT
#undef ASSERT
#undef ASSERTMSG

#if DBG
#define ASSERT( exp ) \
    if (!(exp)) \
        RtlAssert( #exp, __FILE__, __LINE__, NULL )

#define ASSERTMSG( msg, exp ) \
    if (!(exp)) \
        RtlAssert( #exp, __FILE__, __LINE__, msg )

#else
#define ASSERT( exp )
#define ASSERTMSG( msg, exp )
#endif // DBG

#define KDEXT_64BIT

#include <wdbgexts.h>

#define OFFSET(struct, elem)	((char *) &(struct->elem) - (char *) struct)

#define _DRIVER

#define KDBG_EXT

#include "wmistr.h"

#pragma hdrstop


typedef struct _STATE {
    ULONG mask;
    ULONG value;
    CHAR *pszname;
} STATE;

VOID
PrintState(STATE *ps, ULONG state);

typedef VOID (*ELEMENT_DUMP_ROUTINE)(
    IN ULONG64 RemoteAddress,
    IN LONG Options
    );

typedef ELEMENT_DUMP_ROUTINE *PELEMENT_DUMP_ROUTINE;

struct _NODE_TYPE_INFO_NEW;
typedef struct _NODE_TYPE_INFO_NEW *PNODE_TYPE_INFO_NEW;

typedef VOID (*STRUCT_DUMP_ROUTINE)(
    IN ULONG64 Address,
    IN LONG Options,
    IN PNODE_TYPE_INFO_NEW InfoNode
    );

typedef STRUCT_DUMP_ROUTINE *PSTRUCT_DUMP_ROUTINE;

#define DUMP_ROUTINE( X)            \
VOID                                \
X(  IN ULONG64 Address,             \
    IN LONG Options,                \
    IN PNODE_TYPE_INFO_NEW InfoNode)

//
//  Node types,  names,  and associated dump routines.
//

typedef struct _NODE_TYPE_INFO_NEW {
    USHORT              TypeCode;   // should be NODE_TYPE_CODE
    char                *Text;
    char                *TypeName;
    STRUCT_DUMP_ROUTINE DumpRoutine;
//    char                *flagsfield;  // TODO: add field to specify field recursion (dump params) as well?
//    STATE               *flagsinfo;
    
} NODE_TYPE_INFO_NEW;

#define NodeTypeName( InfoIndex)            (NewNodeTypeCodes[ (InfoIndex)].Text)
#define NodeTypeTypeName( InfoIndex)        (NewNodeTypeCodes[ (InfoIndex)].TypeName)
#define NodeTypeDumpFunction( InfoIndex)    (NewNodeTypeCodes[ (InfoIndex)].DumpRoutine)
#define NodeTypeSize( InfoIndex)            (NewNodeTypeCodes[ (InfoIndex)].Size)


//
//  Define the global in memory structure tag information
//

extern NODE_TYPE_INFO_NEW NewNodeTypeCodes[];

#define TypeCodeInfoIndex( X)  SearchTypeCodeIndex( X, NewNodeTypeCodes)

ULONG
SearchTypeCodeIndex (
    IN USHORT TypeCode,
    IN NODE_TYPE_INFO_NEW TypeCodes[]
    );


#define AVERAGE(TOTAL,COUNT) ((COUNT) != 0 ? (TOTAL)/(COUNT) : 0)

//
//  DUMP_WITH_OFFSET -- for dumping pointers contained in structures.
//

#define DUMP8_WITH_OFFSET(type, ptr, element, label)  \
        dprintf( "\n(%03x) %8hx %s ",                   \
        FIELD_OFFSET(type, element),                    \
        (USHORT)((UCHAR)ptr.element),                   \
        label )
        
#define DUMP16_WITH_OFFSET(type, ptr, element, label)  \
        dprintf( "\n(%03x) %8hx %s ",                   \
        FIELD_OFFSET(type, element),                    \
        (USHORT)ptr.element,                            \
        label )

#define DUMP_WITH_OFFSET(type, ptr, element, label)     \
        dprintf( "\n(%03x) %08x %s ",                   \
        FIELD_OFFSET(type, element),                    \
        ptr.element,                                    \
        label )

#define DUMP64_WITH_OFFSET(type, ptr, element, label)   \
        dprintf( "\n(%03x) %016I64x %s ",                \
        FIELD_OFFSET(type, element),                    \
        ptr.element,                                    \
        label )

//
//  DUMP_EMBW_OFFSET -- for dumping elements embedded in structures.
//

#define DUMP_EMBW_OFFSET(type, address, element, label)     \
        dprintf( "\n(%03x) %08x -> %s ",                   \
        FIELD_OFFSET(type, element),                    \
        ((PUCHAR)address) + FIELD_OFFSET(type, element),              \
        label )

#define ReadM( B, A, L)  {                     \
        ULONG RmResult;                        \
        if (!ReadMemory( (A), (B), (L), &RmResult))  { \
            dprintf( "Unable to read %d bytes at 0x%I64x\n", (L), (A));     \
            return;                                                         \
        }       \
    }
        
#define RM( Addr, Obj, pObj, Type, Result )  {                           			\
        (pObj) = (Type)(Addr);                                                 		\
        if ( !ReadMemory( (Addr), &(Obj), sizeof( Obj ), &(Result)) ) { 	\
            dprintf( "Unable to read %d bytes at %p\n", sizeof(Obj), (Addr)); 		\
            return;                                                         		\
        }                                                                           \
    }

#define RMSS( Addr, Length, Obj, pObj, Type, Result )  {      						\
	    (pObj) = (Type)(Addr);                                                 		\
	    if ( !ReadMemory( (Addr), &(Obj), (Length), &(Result)) ) { 		\
	        dprintf( "Unable to read %d bytes at %p\n", (Length), (Addr)); 			\
	        return;                                                         		\
	    }																			\
    }


#define ROE( X)  {                                  \
                    ULONG _E_;                      \
                    if (_E_ = (X))  {               \
                        dprintf("Error %d (File %s Line %d)\n", _E_, __FILE__, __LINE__); \
                        return;                     \
                    }                               \
                 }
VOID 
DumpStr( 
    IN ULONG FieldOffset,
    IN ULONG64 StringAddress,
    IN PUCHAR Label,
    IN BOOLEAN CrFirst,
    IN BOOLEAN Wide
    );

//
//  ....( TYPE, LOCAL_RECORD, REMOTE_ADDRESS_OF_RECORD,  TYPE_FIELD_NAME,  LABEL)
//

#define DUMP_UCST_OFFSET( type, ptr, address, resident, element, label)                         \
            DumpWStr( FIELD_OFFSET(type, element),                                              \
                      resident ? (((PUCHAR)address) + FIELD_OFFSET(type, element)) : *((PVOID*)&(ptr.element)),     \
                      resident ? &(ptr.element) : NULL,                                   \
                      label, TRUE                                                                   \
                    )
                    
#define DUMP_UCST_OFFSET_NO_CR( type, ptr, address, resident, element, label)                         \
            DumpWStr( FIELD_OFFSET(type, element),                                              \
                      resident ? (((PUCHAR)address) + FIELD_OFFSET(type, element)) : *((PVOID*)&(ptr.element)),     \
                      resident ? &(ptr.element) : NULL,                                   \
                      label,  FALSE                                                                   \
                    )

#define DUMP_STRN_OFFSET( type, ptr, address, resident, element, label)                         \
            DumpStr( FIELD_OFFSET(type, element),                                              \
                      resident ? (((PUCHAR)address) + FIELD_OFFSET(type, element)) : *((PVOID*)&(ptr.element)),     \
                      resident ? &(ptr.element) : NULL,                                   \
                      label, TRUE                                                               \
                    )

#define DUMP_STRN_OFFSET_NO_CR( type, ptr, address, resident, element, label)                         \
            DumpStr( FIELD_OFFSET(type, element),                                              \
                      resident ? (((PUCHAR)address) + FIELD_OFFSET(type, element)) : *((PVOID*)&(ptr.element)),     \
                      resident ? &(ptr.element) : NULL,                                   \
                      label,  FALSE                                                                   \
                    )
                    
#define DUMP_RAW_TERM_STRN_OFFSET( type, ptr, address, element, label)  \
        dprintf( "\n(%03x) %08x -> %s = '%s'",                          \
        FIELD_OFFSET(type, element),                                    \
        ((PUCHAR)address) + FIELD_OFFSET(type, element),                \
        label ,                                                         \
        ptr.element)

VOID
DumpList(
    IN ULONG64 RemoteListEntryAddress,
    IN ELEMENT_DUMP_ROUTINE ProcessElementRoutine,
    IN ULONG OffsetToContainerStart,
    IN BOOLEAN ProcessThisEntry,
    IN ULONG Options
    );

VOID
ParseAndDump (
    IN PCHAR args,
    IN STRUCT_DUMP_ROUTINE DumpFunction,
    ULONG Processor,
    HANDLE hCurrentThread
    );

ULONG
Dt( IN UCHAR *Type,
    IN ULONG64 Addr,
    IN ULONG Recur,
    IN ULONG FieldInfoCount,
    IN FIELD_INFO FieldInfo[]
  );

//
//  Definitions nicked from fsrtl/largemcb.c to enable dumping of FAT/UDFS
//  MCB structures
//

typedef struct _MAPPING {
    VBN NextVbn;
    LBN Lbn;
} MAPPING;
typedef MAPPING *PMAPPING;

typedef struct _NONOPAQUE_MCB {
    PFAST_MUTEX FastMutex;
    ULONG MaximumPairCount;
    ULONG PairCount;
    POOL_TYPE PoolType;
    PMAPPING Mapping;
} NONOPAQUE_MCB;
typedef NONOPAQUE_MCB *PNONOPAQUE_MCB;

//
//  A macro to return the size, in bytes, of a retrieval mapping structure
//

#define SizeOfMapping(MCB) ((sizeof(MAPPING) * (MCB)->MaximumPairCount))

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fastfat\fskd\udfsro.c ===
//
//  Define flags and specific dump routines for the UDFR/W structures
//

#include "pch.h"
#include "fatkd.h"
#include "..\..\udfs\nodetype.h"
#include "..\..\udfs\udf.h"
#include "..\..\udfs\udfstruc.h"
#include "..\..\udfs\udfdata.h"

//
//  UDFS R/O In memory structure flag descriptions
//

STATE UdfFcbState[] = {

    {   FCB_STATE_INITIALIZED,      FCB_STATE_INITIALIZED,      "Initialised"},
    {   FCB_STATE_IN_FCB_TABLE,     FCB_STATE_IN_FCB_TABLE,     "InFcbTable"},
    {   FCB_STATE_VMCB_MAPPING,     FCB_STATE_VMCB_MAPPING,     "VMCB"},
    {   FCB_STATE_EMBEDDED_DATA,    FCB_STATE_EMBEDDED_DATA,    "EmbeddedData"},
    {   FCB_STATE_MCB_INITIALIZED,  FCB_STATE_MCB_INITIALIZED,  "McbInit"},
    {   FCB_STATE_ALLOW_ONEGIG_WORKAROUND, FCB_STATE_ALLOW_ONEGIG_WORKAROUND, "OneGigWorkaround"},
    { 0 }
};

STATE UdfIrpContextFlags[] = {

    {   IRP_CONTEXT_FLAG_ON_STACK,          IRP_CONTEXT_FLAG_ON_STACK,          "OnStack"},
    {   IRP_CONTEXT_FLAG_MORE_PROCESSING,   IRP_CONTEXT_FLAG_MORE_PROCESSING,   "MoreProcessing"},
    {   IRP_CONTEXT_FLAG_FORCE_POST,        IRP_CONTEXT_FLAG_FORCE_POST,        "ForcePost"},
    {   IRP_CONTEXT_FLAG_WAIT,              IRP_CONTEXT_FLAG_WAIT,              "Wait"},    
    {   IRP_CONTEXT_FLAG_TOP_LEVEL,         IRP_CONTEXT_FLAG_TOP_LEVEL,         "TopLevel"},
    {   IRP_CONTEXT_FLAG_TOP_LEVEL_UDFS,    IRP_CONTEXT_FLAG_TOP_LEVEL_UDFS,    "TopLevelUdfs"},    
    {   IRP_CONTEXT_FLAG_IN_TEARDOWN,       IRP_CONTEXT_FLAG_IN_TEARDOWN,       "InTeardown"},
    {   IRP_CONTEXT_FLAG_ALLOC_IO,          IRP_CONTEXT_FLAG_ALLOC_IO,          "AllocIo"},
    {   IRP_CONTEXT_FLAG_DISABLE_POPUPS,    IRP_CONTEXT_FLAG_DISABLE_POPUPS,    "DisablePopups"},
    {   IRP_CONTEXT_FLAG_IN_FSP,            IRP_CONTEXT_FLAG_IN_FSP,            "InFsp"},
    {   IRP_CONTEXT_FLAG_FULL_NAME,         IRP_CONTEXT_FLAG_FULL_NAME,         "FullName"},
    {   IRP_CONTEXT_FLAG_TRAIL_BACKSLASH,   IRP_CONTEXT_FLAG_TRAIL_BACKSLASH,   "TrailBackslash"},
    { 0 }
};


STATE UdfVcbStateFlags[] = {

    {   VCB_STATE_REMOVABLE_MEDIA,  VCB_STATE_REMOVABLE_MEDIA,  "Removable"},
    {   VCB_STATE_LOCKED,           VCB_STATE_LOCKED,           "Locked"},
    {   VCB_STATE_NOTIFY_REMOUNT,   VCB_STATE_NOTIFY_REMOUNT,   "NotifyRemount"},
    {   VCB_STATE_METHOD_2_FIXUP,   VCB_STATE_METHOD_2_FIXUP,   "Method2Fixup"},
    { 0 }
};


STATE UdfCcbFlags[] = {

    {   CCB_FLAG_OPEN_BY_ID,                    CCB_FLAG_OPEN_BY_ID,                    "OpenById"},
    {   CCB_FLAG_OPEN_RELATIVE_BY_ID,           CCB_FLAG_OPEN_RELATIVE_BY_ID,           "OpenRelById"},
    {   CCB_FLAG_IGNORE_CASE,                   CCB_FLAG_IGNORE_CASE,                   "IgnoreCase"},
    {   CCB_FLAG_DISMOUNT_ON_CLOSE,             CCB_FLAG_DISMOUNT_ON_CLOSE,             "DismountOnClose"},
    {   CCB_FLAG_ALLOW_EXTENDED_DASD_IO,        CCB_FLAG_ALLOW_EXTENDED_DASD_IO,        "ExtendedDASD"},
    {   CCB_FLAG_ENUM_NAME_EXP_HAS_WILD,        CCB_FLAG_ENUM_NAME_EXP_HAS_WILD,        "EnumNameHasWild"},
    {   CCB_FLAG_ENUM_MATCH_ALL,                CCB_FLAG_ENUM_MATCH_ALL,                "EnumMatchAll"},
    {   CCB_FLAG_ENUM_RETURN_NEXT,              CCB_FLAG_ENUM_RETURN_NEXT,              "EnumReturnNext"},
    {   CCB_FLAG_ENUM_INITIALIZED,              CCB_FLAG_ENUM_INITIALIZED,              "EnumInitialised"},
    {   CCB_FLAG_ENUM_NOMATCH_CONSTANT_ENTRY,   CCB_FLAG_ENUM_NOMATCH_CONSTANT_ENTRY,   "NoMatchConstantEntry"},
    { 0 }
};


STATE UdfLcbFlags[] = {

    {   LCB_FLAG_IGNORE_CASE,       LCB_FLAG_IGNORE_CASE,  "IgnoreCase"},
    {   LCB_FLAG_SHORT_NAME,        LCB_FLAG_SHORT_NAME,   "ShortName"},
    {   LCB_FLAG_POOL_ALLOCATED,    LCB_FLAG_POOL_ALLOCATED, "PoolAllocated"},
    { 0 }
};


STATE UdfPcbFlags[] = {

    {   PCB_FLAG_PHYSICAL_PARTITION,    PCB_FLAG_PHYSICAL_PARTITION,    "Physical"},
    {   PCB_FLAG_VIRTUAL_PARTITION,     PCB_FLAG_VIRTUAL_PARTITION,     "Virtual"},
    {   PCB_FLAG_SPARABLE_PARTITION,    PCB_FLAG_SPARABLE_PARTITION,    "Sparable"},
    { 0 }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fastfat\fskd\udfsrw.c ===
//
//  Define flags and specific dump routines for the UDFR/W structures
//

#include "pch.h"

#ifdef UDFS_RW_IN_BUILD

#include "fatkd.h"
#include "..\..\udfsrw\nodetype.h"
#include "..\..\udfsrw\udf.h"
#include "..\..\udfsrw\udfstruc.h"
#include "..\..\udfsrw\udfdata.h"
#include "udfskd.h"


STATE UdfScbFlags[] = {

    {   SCB_STATE_INITIALIZED,                   SCB_STATE_INITIALIZED,         "Init"},
    {   SCB_STATE_EMBEDDED_DATA,                 SCB_STATE_EMBEDDED_DATA,       "Embedded"},
    {   SCB_STATE_MCB_INITIALIZED,               SCB_STATE_MCB_INITIALIZED,     "MCBInit"},
    {   SCB_STATE_STREAM_DIRECTORY,              SCB_STATE_STREAM_DIRECTORY,    "StreamDirectory"},
    {   SCB_STATE_SECONDARY_STREAM,              SCB_STATE_SECONDARY_STREAM,    "SecondaryStream"},
    {   SCB_STATE_SYSTEM_STREAM,                 SCB_STATE_SYSTEM_STREAM,       "SystemStream"},
    {   SCB_STATE_IN_SCB_TABLE,                  SCB_STATE_IN_SCB_TABLE,        "InSCBTable"},
    {   SCB_STATE_VMCB_MAPPING,                  SCB_STATE_VMCB_MAPPING,        "VMCB"},
    {   SCB_STATE_TEMPORARY,                     SCB_STATE_TEMPORARY,           "Temp"},
    {   SCB_STATE_DELETE_ON_CLOSE,               SCB_STATE_DELETE_ON_CLOSE,     "DeleteOnClose"},
    {   SCB_STATE_TRUNCATE_ON_CLOSE,             SCB_STATE_TRUNCATE_ON_CLOSE,   "TruncateOnClose"},
    {   SCB_STATE_NON_RELOCATABLE,               SCB_STATE_NON_RELOCATABLE,     "NonRelocatable"},
    {   SCB_STATE_EXTENDED_FE,                   SCB_STATE_EXTENDED_FE,         "ExtendedFE"},
    {   SCB_STATE_SPARSE,                        SCB_STATE_SPARSE,              "Sparse"},
    {   SCB_STATE_MCB_ANR_INITIALIZED,           SCB_STATE_MCB_ANR_INITIALIZED, "ANRMCBInit"},
    {   SCB_STATE_UPDATE_TIMESTAMPS,             SCB_STATE_UPDATE_TIMESTAMPS,   "UpdateTimestamps"},
    {   SCB_STATE_ALLOW_ONEGIG_WORKAROUND,       SCB_STATE_ALLOW_ONEGIG_WORKAROUND, "OneGigWorkaround"},
    {   SCB_STATE_DE_EMBED_IN_PROGRESS,          SCB_STATE_DE_EMBED_IN_PROGRESS,"DeEmbedInProgress"},
    {   SCB_STATE_LONG_ADS,                      SCB_STATE_LONG_ADS,            "LongADs"},
    {   SCB_STATE_FILE_DATA_MODIFIED,            SCB_STATE_FILE_DATA_MODIFIED,  "FileDataModified"},
    { 0 }
};


STATE UdfRwCcbFlags[] = {

    {   CCB_FLAG_OPEN_BY_ID,                    CCB_FLAG_OPEN_BY_ID,                    "OpenById"},
    {   CCB_FLAG_OPEN_RELATIVE_BY_ID,           CCB_FLAG_OPEN_RELATIVE_BY_ID,           "OpenRelById"},
    {   CCB_FLAG_IGNORE_CASE,                   CCB_FLAG_IGNORE_CASE,                   "IgnoreCase"},
    {   CCB_FLAG_DISMOUNT_ON_CLOSE,             CCB_FLAG_DISMOUNT_ON_CLOSE,             "DismountOnClose"},
    {   CCB_FLAG_ALLOW_EXTENDED_DASD_IO,        CCB_FLAG_ALLOW_EXTENDED_DASD_IO,        "ExtendedDASD"},
    {   CCB_FLAG_DELETE_ON_CLOSE,               CCB_FLAG_DELETE_ON_CLOSE,               "DeleteOnClose"},
    {   CCB_FLAG_READ_ONLY,                     CCB_FLAG_READ_ONLY,                     "ReadOnly"},
    {   CCB_FLAG_ENUM_NAME_EXP_HAS_WILD,        CCB_FLAG_ENUM_NAME_EXP_HAS_WILD,        "EnumNameHasWild"},
    {   CCB_FLAG_ENUM_MATCH_ALL,                CCB_FLAG_ENUM_MATCH_ALL,                "EnumMatchAll"},
    {   CCB_FLAG_ENUM_RETURN_NEXT,              CCB_FLAG_ENUM_RETURN_NEXT,              "EnumReturnNext"},
    {   CCB_FLAG_ENUM_INITIALIZED,              CCB_FLAG_ENUM_INITIALIZED,              "EnumInitialised"},
    {   CCB_FLAG_ENUM_NOMATCH_CONSTANT_ENTRY,   CCB_FLAG_ENUM_NOMATCH_CONSTANT_ENTRY,   "NoMatchConstantEntry"},
    { 0 }
};

STATE UdfRwIrpContextFlags[] = {

    {   IRP_CONTEXT_FLAG_ON_STACK,          IRP_CONTEXT_FLAG_ON_STACK,          "OnStack"},
    {   IRP_CONTEXT_FLAG_MORE_PROCESSING,   IRP_CONTEXT_FLAG_MORE_PROCESSING,   "MoreProcessing"},
    {   IRP_CONTEXT_FLAG_FORCE_POST,        IRP_CONTEXT_FLAG_FORCE_POST,        "ForcePost"},
    {   IRP_CONTEXT_FLAG_WAIT,              IRP_CONTEXT_FLAG_WAIT,              "Wait"},    
    {   IRP_CONTEXT_FLAG_TOP_LEVEL,         IRP_CONTEXT_FLAG_TOP_LEVEL,         "TopLevel"},
    {   IRP_CONTEXT_FLAG_TOP_LEVEL_UDFS,    IRP_CONTEXT_FLAG_TOP_LEVEL_UDFS,    "TopLevelUdfs"},    
    {   IRP_CONTEXT_FLAG_IN_TEARDOWN,       IRP_CONTEXT_FLAG_IN_TEARDOWN,       "InTeardown"},
    {   IRP_CONTEXT_FLAG_ALLOC_IO,          IRP_CONTEXT_FLAG_ALLOC_IO,          "AllocIo"},
    {   IRP_CONTEXT_FLAG_DISABLE_POPUPS,    IRP_CONTEXT_FLAG_DISABLE_POPUPS,    "DisablePopups"},
    {   IRP_CONTEXT_FLAG_IN_FSP,            IRP_CONTEXT_FLAG_IN_FSP,            "InFsp"},
    {   IRP_CONTEXT_FLAG_FULL_NAME,         IRP_CONTEXT_FLAG_FULL_NAME,         "FullName"},
    {   IRP_CONTEXT_FLAG_TRAIL_BACKSLASH,   IRP_CONTEXT_FLAG_TRAIL_BACKSLASH,   "TrailBackslash"},
    {   IRP_CONTEXT_FLAG_DEFERRED_WRITE,    IRP_CONTEXT_FLAG_DEFERRED_WRITE,    "DeferredWrite"},
    { 0 }
};


STATE UdfRwVcbStateFlags[] = {

    {   VCB_STATE_REMOVABLE_MEDIA,  VCB_STATE_REMOVABLE_MEDIA,  "Removable"},
    {   VCB_STATE_LOCKED,           VCB_STATE_LOCKED,           "Locked"},
    {   VCB_STATE_NOTIFY_REMOUNT,   VCB_STATE_NOTIFY_REMOUNT,   "NotifyRemount"},
    {   VCB_STATE_METHOD_2_FIXUP,   VCB_STATE_METHOD_2_FIXUP,   "Method2Fixup"},
    {   VCB_STATE_READ_ONLY,        VCB_STATE_READ_ONLY,        "ReadOnly"},
    {   VCB_STATE_MOUNTED_DIRTY,    VCB_STATE_MOUNTED_DIRTY,    "MountedDirty"},
    {   VCB_STATE_BITMAP_INIT,      VCB_STATE_BITMAP_INIT,      "BitmapInit"},
    {   VCB_STATE_MEDIA_WRITE_PROTECT, VCB_STATE_MEDIA_WRITE_PROTECT, "WriteProtect"},
    { 0 }
};


STATE UdfRwLcbFlags[] = {

    {   LCB_FLAG_IGNORE_CASE,       LCB_FLAG_IGNORE_CASE,  "IgnoreCase"},
    {   LCB_FLAG_SHORT_NAME,        LCB_FLAG_SHORT_NAME,   "ShortName"},
    {   LCB_FLAG_POOL_ALLOCATED,    LCB_FLAG_POOL_ALLOCATED, "PoolAllocated"},
    {   LCB_FLAG_DELETE_ON_CLEANUP, LCB_FLAG_DELETE_ON_CLEANUP, "DeleteOnCleanup"},
    {   LCB_FLAG_DELETE_IN_PROGRESS,LCB_FLAG_DELETE_IN_PROGRESS , "DeleteInProgress"},
    {   LCB_FLAG_LINKS_REMOVED,     LCB_FLAG_LINKS_REMOVED, "NameLinksRemoved"},
    { 0 }
};


BOOLEAN
NodeIsUdfsRwIndex( USHORT T) 
{
    return T == UDFSRW_NTC_SCB_INDEX;
}

BOOLEAN
NodeIsUdfsRwData( USHORT T) 
{
    return T == UDFSRW_NTC_SCB_DATA;
}

BOOLEAN
LcbDeleted( ULONG F)
{
    return (0 != (F & LCB_FLAG_DELETE_IN_PROGRESS));
}


// OK
DUMP_ROUTINE( DumpUdfScb)
{
    ULONG Flags, Offset, Offsetb, ScbState;
    UINT64 NonP;
    
    dprintf("[ Option flags:  1 = list children,  2 = List parent links,  4 = dump Mcbs ]\n\n");

    ROE( GetFieldValue(  Address, InfoNode->TypeName, "ScbState", ScbState));
    dprintf("ScbState     : ");
    PrintState( UdfScbFlags, ScbState );
    
    ROE( GetFieldValue( Address, InfoNode->TypeName, "Flags", Flags));
    dprintf("Header.Flags : ");
    PrintState( HeaderFlags, Flags );

    ROE( GetFieldValue( Address, InfoNode->TypeName, "Flags2", Flags));
    dprintf("Header.Flags2: ");
    PrintState( HeaderFlags2, Flags );
    dprintf("\n");

    Dt( InfoNode->TypeName, Address, 0, 0, NULL);

    //
    //  Nonpaged portion
    //
    
    ROE( GetFieldValue( Address, InfoNode->TypeName, "ScbNonpaged", NonP));

    if (NonP)  {
    
        dprintf("\nNonpaged portion @ %I64x\n\n",NonP);
        Dt( "Udfs!SCB_NONPAGED", NonP, 1, 0, NULL);
    }

    if (( Options & 1)  && (UDFSRW_NTC_SCB_INDEX == InfoNode->TypeCode)) {

        dprintf("\nChild Lcb list\n");

        ROE( GetFieldOffset( "udfs!_SCB", "ChildLcbQueue", &Offset));
        ROE( GetFieldOffset( "udfs!_LCB", "ParentScbLinks", &Offsetb));
        
        DumpList( Address + Offset,
                  UdfSummaryLcbDumpRoutine,
                  Offsetb,
                  FALSE,
                  0 );
    }

    if (Options & 2)  {
    
        dprintf("\nParent Lcb list\n");
        
        ROE( GetFieldOffset( "udfs!_SCB", "ParentLcbQueue", &Offset));
        ROE( GetFieldOffset( "udfs!_LCB", "ChildScbLinks", &Offsetb));
        
        DumpList( Address + Offset,
                  UdfSummaryLcbDumpRoutine,
                  Offsetb,
                  FALSE,
                  0 );
    }

    if (Options & 4)  {
    
        if (ScbState & SCB_STATE_MCB_INITIALIZED)  {

            ROE( GetFieldOffset( InfoNode->TypeName, "Mcb", &Offset));
            dprintf("\nA+R Mcb\n");
            DumpLargeMcb( Address+Offset, 0, NULL);
        }
        
        if (ScbState & SCB_STATE_MCB_ANR_INITIALIZED)  {
        
            ROE( GetFieldOffset( InfoNode->TypeName, "ANRMcb", &Offset));
            dprintf("\nA+NR Mcb\n");
            DumpLargeMcb( Address+Offset, 0, NULL);
        }
    }

    dprintf("\n");
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fastfat\fskd\udfs.c ===
#include "pch.h"
#include "udfskd.h"
#include "fatkd.h"

#include <ntddcdrm.h>
#include <ntdddisk.h>
#include <ntddscsi.h>

#include "..\..\udfs\nodetype.h"

#ifdef UDFS_RW_IN_BUILD
#include "..\..\udfsrw\nodetype.h"
#endif

#include "..\..\udfs\udf.h"
#include "..\..\udfs\udfstruc.h"
#include "..\..\udfs\udfdata.h"

//
//  13346/UDF on disc note type codes and dump routines
//


DUMP_ROUTINE( DumpUdfOnDiscIcbFile);
DUMP_ROUTINE( DumpUdfOnDiscFid);
DUMP_ROUTINE( DumpUdfOnDiscFsd);
DUMP_ROUTINE( DumpUdfOnDiscLvol);
DUMP_ROUTINE( DumpUdfOnDiscPartDesc);
DUMP_ROUTINE( DumpUdfOnDiscVdp);
DUMP_ROUTINE( DumpUdfOnDiscAnchor);
DUMP_ROUTINE( DumpUdfOnDiscPvd);
DUMP_ROUTINE( DumpUdfOnDiscIcbExtFile);


static NODE_TYPE_INFO_NEW UdfOnDiscTypeCodes[] = {
    {   DESTAG_ID_NSR_PVD,          "(3/10.1) PVD",             NULL, DumpUdfOnDiscPvd },
    {   DESTAG_ID_NSR_ANCHOR,       "(3/10.2) AVDP",            NULL, DumpUdfOnDiscAnchor },
    {   DESTAG_ID_NSR_VDP,          "(3/10.3) VDP",             NULL, DumpUdfOnDiscVdp },
    {   DESTAG_ID_NSR_IMPUSE,       "(3/10.4) IUVD",            NULL, NULL },
    {   DESTAG_ID_NSR_PART,         "(3/10.5) PD",              NULL, DumpUdfOnDiscPartDesc },
    {   DESTAG_ID_NSR_LVOL,         "(3/10.6) LVD",             NULL, DumpUdfOnDiscLvol },
    {   DESTAG_ID_NSR_UASD,         "(3/10.8) UASD",            NULL, NULL },
    {   DESTAG_ID_NSR_TERM,         "(3/10.9) TD",              NULL, NULL },
    {   DESTAG_ID_NSR_LVINTEG,      "(3/10.10) LVID",           NULL, NULL },

    {   DESTAG_ID_NSR_FSD,          "(4/14.1) FSD",             NULL, DumpUdfOnDiscFsd },
    {   DESTAG_ID_NSR_FID,          "(4/14.4) FID",             NULL, DumpUdfOnDiscFid },
    {   DESTAG_ID_NSR_ALLOC,        "(4/14.5) AED",             NULL, NULL },
    {   DESTAG_ID_NSR_ICBIND,       "(4/14.7) ICB Indirect",    NULL, NULL },
    {   DESTAG_ID_NSR_ICBTRM,       "(4/14.8) ICB Terminal",    NULL, NULL },
    {   DESTAG_ID_NSR_FILE,         "(4/14.9) FE",              NULL, DumpUdfOnDiscIcbFile },
    {   DESTAG_ID_NSR_EXT_FILE,     "(4/14.17) EXT FE",         NULL, DumpUdfOnDiscIcbExtFile },
    {   DESTAG_ID_NSR_EA,           "(4/14.10) EAH",            NULL, NULL },
    {   DESTAG_ID_NSR_UASE,         "(4/14.11) USE",            NULL, NULL },
    {   DESTAG_ID_NSR_SBP,          "(4/14.12) SBD",            NULL, NULL },
    {   DESTAG_ID_NSR_PINTEG,       "(4/14.13) PI",             NULL, NULL },
    
    {   0, "UNKNOWN/NotSpec", NULL }
};

static PCHAR IcbStrategies[] = {
    "NOTSPEC",  
    "4/A.2 TREE",  
    "4/A.3 MASTER",  
    "4/A.4 BALTREE",  
    "4/A.5 DIRECT"
    };

#define MAX_VALID_ICB_STRAT 4

static PCHAR IcbFileTypes[] = {
    "NOTSPEC",
    "UASPACE",
    "PINTEG",
    "INDIRECT",
    "DIRECTORY",
    "FILE",
    "BLOCKDEV",
    "CHARDEV",
    "XA",
    "FIFO",
    "SOCKET",
    "TERMINAL",
    "PATHLINK",
    "STREAMDIR"
    };

#define MAX_VALID_ICB_TYPE 13

static STATE UdfIcbTagFlags[] = {

    {   ICBTAG_F_ALLOC_MASK,        ICBTAG_F_ALLOC_SHORT,       "ShortAlloc"},
    {   ICBTAG_F_ALLOC_MASK,        ICBTAG_F_ALLOC_LONG,        "LongAlloc"},
    {   ICBTAG_F_ALLOC_MASK,        ICBTAG_F_ALLOC_EXTENDED,    "ExtAlloc"},
    {   ICBTAG_F_ALLOC_MASK,        ICBTAG_F_ALLOC_IMMEDIATE,   "ImmAlloc"},

    {   ICBTAG_F_SORTED,            ICBTAG_F_SORTED,            "Sorted(4/8.6.1)"},
    {   ICBTAG_F_NO_RELOCATE,       ICBTAG_F_NO_RELOCATE,       "Nonrelocatable"},
    {   ICBTAG_F_ARCHIVE,           ICBTAG_F_ARCHIVE,           "Archive"},
    {   ICBTAG_F_SETUID,            ICBTAG_F_SETUID,            "SetUid"},
    {   ICBTAG_F_SETGID,            ICBTAG_F_SETGID,            "SetGid"},
    {   ICBTAG_F_STICKY,            ICBTAG_F_STICKY,            "Sticky"},
    {   ICBTAG_F_CONTIGUOUS,        ICBTAG_F_CONTIGUOUS,        "Contiguous"},
    {   ICBTAG_F_SYSTEM,            ICBTAG_F_SYSTEM,            "System"},
    {   ICBTAG_F_TRANSFORMED,       ICBTAG_F_TRANSFORMED,       "Transformed"},
    {   ICBTAG_F_MULTIVERSIONS,     ICBTAG_F_MULTIVERSIONS,     "MultiVersions"},
    {   0}
};


static STATE UdfFidFlags[] = {

    {   NSR_FID_F_HIDDEN,           NSR_FID_F_HIDDEN,       "Hidden"},
    {   NSR_FID_F_DIRECTORY,        NSR_FID_F_DIRECTORY,    "Directory"},
    {   NSR_FID_F_DELETED,          NSR_FID_F_DELETED,      "Deleted"},
    {   NSR_FID_F_PARENT,           NSR_FID_F_PARENT,       "Parent"},
    {   NSR_FID_F_META,             NSR_FID_F_META,         "MetadataStream"},
    { 0 }
};


//  LCB summary dump used by F/Scb tree dump

VOID
UdfSummaryLcbDumpRoutine(
    IN ULONG64 RemoteAddress,
    IN LONG Options
    )
{
    USHORT Type;
    ULONG64 Scb;
    ULONG Offset;

    ReadM( &Type, RemoteAddress, sizeof( Type));

#ifdef UDFS_RW_IN_BUILD
    if (( UDFS_NTC_LCB != Type) && (UDFSRW_NTC_LCB != Type)) {
#else
    if ( UDFS_NTC_LCB != Type) {
#endif
        dprintf( "Not a UDF LCB @ %08x\n", RemoteAddress);
        return;
    }
    
    if (Options & 2)  {
    
        DumpUdfLcb( RemoteAddress, (Options & 8) ? 1 : 0, &NewNodeTypeCodes[ TypeCodeInfoIndex( Type)]);
    }
    else  {

        GetFieldValue( RemoteAddress, 
                       "udfs!_LCB", 
                       (UDFS_NTC_LCB != Type) ? "ChildScb" : "ChildFcb", 
                       Scb);

        dprintf( "\nUDF LCB @ %I64x   Child F/Scb: %I64x  ",  RemoteAddress, Scb);

        GetFieldOffset( "udfs!_LCB", "FileName", &Offset);
        DumpStr( Offset, RemoteAddress + Offset, "FileName", FALSE, TRUE);
    }
}


// OK
DUMP_ROUTINE( DumpUdfFcb)

/*++

Routine Description:

    Dump a specific fcb.

Arguments:

    Address - Gives the address of the fcb to dump

Return Value:

    None

--*/

{
    ULONG Result;
    UINT64 NonP;
    ULONG Flags, FcbState;
    ULONG Offset, Offsetb;

    ROE( GetFieldValue( Address, InfoNode->TypeName, "FcbState", FcbState));

    //
    //  For R/O udfs,  dump the FCB flags and common header flags.  RW FCB
    //  is less interesting,  nothing to dump.
    //
    
    if (!NTC_IS_UDFS_RW( InfoNode->TypeCode))  {
    
        dprintf("[ Option flags:  1 = list children,  2 = List parent links,  4 = dump Mcb ]\n\n");

        dprintf("FcbState: ");
        PrintState( UdfFcbState, FcbState );

        ROE( GetFieldValue( Address, InfoNode->TypeName, "Flags", Flags));
        dprintf("\nHeader.Flags: ");
        PrintState( HeaderFlags, Flags );

        ROE( GetFieldValue( Address, InfoNode->TypeName, "Flags2", Flags));    // TODO:
        dprintf("\nHeader.Flags2: ");
        PrintState( HeaderFlags2, Flags );
        dprintf("\n");
    }
    
    //
    //  Having established that this looks like an fcb, let's dump the
    //  interesting parts.
    //
    

    Dt( InfoNode->TypeName, Address, 0, 0, NULL);

    // TODO: Does the above dump the union data/index part?

    dprintf("\n");
    
    //
    //  Nonpaged portion
    //
    
    ROE( GetFieldValue( Address, InfoNode->TypeName, "FcbNonpaged", NonP));

    if (NonP)  {
    
        dprintf("\nNonpaged portion @ %I64x\n\n",NonP);

        Dt( "Udfs!FCB_NONPAGED", NonP, 0, 0, NULL);
    }
    
    //
    //  R/O UDFS:  Dump all Fcb children 
    //

    if (!NTC_IS_UDFS_RW( InfoNode->TypeCode))  {
    
        if (( Options & 1)  && (UDFS_NTC_FCB_INDEX == InfoNode->TypeCode)) {

            dprintf("\nChild Lcb list\n");

            ROE( GetFieldOffset( "udfs!_FCB", "ChildLcbQueue", &Offset));
            ROE( GetFieldOffset( "udfs!_LCB", "ParentFcbLinks", &Offsetb));
            
            DumpList( Address + Offset,
                      UdfSummaryLcbDumpRoutine,
                      Offsetb,
                      FALSE,
                      0 );
        }

        if (Options & 2)  {
        
            dprintf("\nParent Lcb list\n");
            
            ROE( GetFieldOffset( "udfs!_FCB", "ParentLcbQueue", &Offset));
            ROE( GetFieldOffset( "udfs!_LCB", "ChildFcbLinks", &Offsetb));
            
            DumpList( Address + Offset,
                      UdfSummaryLcbDumpRoutine,
                      Offsetb,
                      FALSE,
                      0 );
        }
        
        if (Options & 4)  {
        
            if (FcbState & FCB_STATE_MCB_INITIALIZED)  {

                ROE( GetFieldOffset( "udfs!_FCB", "Mcb", &Offset));
                dprintf("\nMcb\n");
                DumpLargeMcb( Address+Offset, 0, NULL);
            }
        }
    }
    else {

        //
        // TODO: RW UDFS - dump attached stream Scb list?
        //
    }
    
    dprintf( "\n" );
}


// OK
DUMP_ROUTINE( DumpUdfLcb)
{
    ULONG Flags;
    ULONG Ntc;

    ROE( GetFieldValue(  Address, InfoNode->TypeName, "NodeTypeCode", Ntc));
    ROE( GetFieldValue(  Address, InfoNode->TypeName, "Flags", Flags));
    
    dprintf("Lcb.Flags: ");
    PrintState( NTC_IS_UDFS_RW(Ntc) ? UdfRwLcbFlags : UdfLcbFlags, Flags );
    dprintf( "\n");

    Dt( InfoNode->TypeName, Address, Options, 0, NULL); // TODO: Expand parent list?

    if (Options >= 1)  {

        ULONG64 Scb;

        dprintf("\n\nChild S/Fcb:\n");

        ROE( GetFieldValue( Scb, 
                            InfoNode->TypeName, 
                            (Ntc == UDFS_NTC_LCB) ? "ChildFcb" : "ChildScb",
                            Scb));
                            
        DumpAnyStruct( Scb, 0, NULL);
    }
}


// OK
DUMP_ROUTINE( DumpUdfPcb)
{
    ULONG Result;
    ULONG Offset;
    ULONG Current = 0;
    ULONG Partitions;
    ULONG Flags;
    ULONG Size;

    ROE( GetFieldValue(  Address, InfoNode->TypeName, "Flags", Flags));

    dprintf( "\nPcb.Flags: ");
    PrintState( UdfPcbFlags, Flags);

    Dt( InfoNode->TypeName, Address, Options, 0, NULL);

    ROE( GetFieldValue(  Address, InfoNode->TypeName, "Partitions", Partitions));

    if (Partitions > 5)  {

        dprintf("Bogus partition count %d\n", Partitions);
        return;
    }

    ROE( GetFieldOffset( InfoNode->TypeName, "Partition", &Offset));
    Address += Offset;

    Size = GetTypeSize( "Udfs!PARTITION");

    for (Current = 0;  Current < Partitions; ++Current)  {

        dprintf("\nRef: %d\n", Current);
        
        Dt( "Udfs!PARTITION", Address, Options, 0, NULL);

        Address += Size;
    }
}

// OK
DUMP_ROUTINE( DumpUdfCcb)
{
    ULONG Flags;
    ULONG Ntc;

    ROE( GetFieldValue(  Address, InfoNode->TypeName, "NodeTypeCode", Ntc));
    ROE( GetFieldValue(  Address, InfoNode->TypeName, "Flags", Flags));
    
    dprintf( "Ccb.Flags: ");
    PrintState( NTC_IS_UDFS_RW(Ntc) ? UdfRwCcbFlags : UdfCcbFlags, Flags);
    dprintf( "\n");

    Dt( InfoNode->TypeName, Address, Options, 0, NULL);
}

// OK
DUMP_ROUTINE( DumpUdfIrpContextLite)
{

    Dt( InfoNode->TypeName, Address, Options, 0, NULL);

    // *** FIXME - dump delayed close queue
}

// OK
DUMP_ROUTINE( DumpUdfIrpContext)
{
    ULONG Flags;
    ULONG Ntc;

    ROE( GetFieldValue(  Address, InfoNode->TypeName, "NodeTypeCode", Ntc));
    ROE( GetFieldValue(  Address, InfoNode->TypeName, "Flags", Flags));
    
    dprintf("\nIrpContext Flags: ");
    PrintState( NTC_IS_UDFS_RW(Ntc) ? UdfRwIrpContextFlags : UdfIrpContextFlags, Flags );
    dprintf( "\n");

    Dt( InfoNode->TypeName, Address, Options, 0, NULL);
}


// OK
DUMP_ROUTINE( DumpUdfIcbSearchContext)
{
    Dt( "udfs!_ICB_SEARCH_CONTEXT", Address, 1, 0, NULL);   // TODO: expand current/active only
}


// OK
DUMP_ROUTINE( DumpLargeMcb)
{
    ULONG PairCount = 0, EntryCount = 0, Result;
    ULONG64 Mapping;
    PMAPPING Mappings, Current;
    ULONG PrevVbn = 0;
    
    dprintf("\nLARGE MCB @ %I64X\n", Address);    

    Dt( "udfs!LARGE_MCB", Address, 0,0, NULL);
    dprintf("\n");
    
    ROE( GetFieldValue( Address,  "udfs!LARGE_MCB", "PairCount", PairCount));
    ROE( GetFieldValue( Address,  "udfs!LARGE_MCB", "Mapping", Mapping));
    
    Mappings = calloc( PairCount, sizeof( MAPPING));

    if (NULL == Mappings)  {

        dprintf("Failed to allocate space for %d mappings\n", PairCount);
        return;
    }

    if (!ReadMemory( Mapping,  Mappings, sizeof( MAPPING)*PairCount, &Result ))  {
    
        dprintf("Unable to read mapping info @ %08x", Mapping);
        return;
    }

    Current = Mappings;
    
    for ( Current = Mappings;  
          EntryCount < PairCount;  
          ++EntryCount, ++Current)  {

        dprintf("(%08x,%08x) -> %08x\n", PrevVbn, Current->NextVbn - PrevVbn, Current->Lbn);    
        PrevVbn = Current->NextVbn;
    }

    dprintf("\n");
    free( Mappings);
}


// OK
DUMP_ROUTINE( DumpUdfVcb)
{    
    ULONG Flags;
    ULONG Ntc;
    FIELD_INFO Alloc[] = { //{ ".", NULL, 0,  0, 0, NULL},
                           { "AllocSup.", NULL, 0,  DBG_DUMP_FIELD_RECUR_ON_THIS,0, NULL}
                         };

    ROE( GetFieldValue(  Address, InfoNode->TypeName, "NodeTypeCode", Ntc));
    ROE( GetFieldValue(  Address, InfoNode->TypeName, "VcbState", Flags));
    
    dprintf("VcbState: ");
    PrintState( NTC_IS_UDFS_RW(Ntc) ? UdfRwVcbStateFlags : UdfVcbStateFlags, Flags );
    dprintf("\n");

    Dt( InfoNode->TypeName, Address, Options, 0, NULL);
    dprintf("\n");

    //
    //  For RW UDFS,  expand some more fields.
    //
    
    if (NTC_IS_UDFS_RW( Ntc))  {

        Dt( InfoNode->TypeName, Address, Options, 1, Alloc);
    }
}


DUMP_ROUTINE( DumpUdfVdo)
{
    USHORT Ntc;
    PUSHORT pNtc;
    ULONG Offset;
    ULONG Result;

    RM( Address, Ntc, pNtc, PUSHORT, Result );
    
#ifndef UDFS_RW_IN_BUILD
    if (UDFS_NTC_VCB == Ntc)  {
#else
    if ((UDFS_NTC_VCB == Ntc) || (UDFSRW_NTC_VCB == Ntc))  {
#endif
        //
        //  Looks like we've been given a VCB pointer.  Work back to the containing vdo.
        //

        dprintf("Backtracking to containing VDO from VCB...");

        ROE( GetFieldOffset( "udfs!VOLUME_DEVICE_OBJECT", "Vcb", &Offset));

        Address -= Offset;
    }
    
    dprintf( "\nUDFS Volume device object @ %08lx\n",  Address );

    Dt( "Udfs!VOLUME_DEVICE_OBJECT", Address, Options, 0, NULL);    
}


VOID
DumpTreeLcb(
    IN ULONG64 Lcb,
    IN LONG RecurLevel
    );

static UCHAR RecurDumpBuf[512];
static ULONG __i;

#define DoIndent(I)  for ( __i = 0;  __i < (I);  ++__i) RecurDumpBuf[__i] = ' ';  \
                   RecurDumpBuf[ __i] = 0;                                       \
                   dprintf( RecurDumpBuf);

static WCHAR RDumpNameBuf[512];


//
//  Called from outside for "main" stream SCBs,
//  recursive for stream directories / stream Scbs
//

// OK
static VOID
DumpTreeRecur (
    IN ULONG64 Scb,
    IN ULONG RecurLevel
    )
{
    ULONG64 Fcb, SdScb, Lcb;
    ULONG Ur, Cc, R, Offset, Offsetb, Error, Flags = 0;
    USHORT Type, Indent, Lc;
    UNICODE_STRING Name;
    PUCHAR TypeString = NULL;
    BOOLEAN Stream, Index, StreamDir, Data;

    if ((*ExtensionApis.lpCheckControlCRoutine)())  {
    
        dprintf("CTRL+C - aborting\n");
        
        // Raise out - could be looping in many levels...

        *((PULONG)(0)) = 0;
        return;    
    }

    if (RecurLevel > 100)  {

        dprintf("*** Recursed more than 100 deep - aborting ***\n");
        return;
    }
    
    //
    //  dump S/Fcb vitals
    //

    Indent = ((USHORT)RecurLevel) << 1;

    if (0 == Scb)  {

        DoIndent( Indent);
        dprintf("Called with NULL F/Scb\n");
        return;
    }

    ReadM( &Type, Scb, sizeof( Type));

    if (!NTC_IS_UDFS_RW( Type))  {

        Stream = StreamDir = FALSE;
        TypeString = "Udfs!FCB";
        Fcb = 0;

        Index = Type == UDFS_NTC_FCB_INDEX;
        Data  = Type == UDFS_NTC_FCB_DATA;
    }
    else {

#ifdef UDFS_RW_IN_BUILD

        TypeString = "Udfs!SCB";

        ROE( GetFieldValue( Scb, "udfs!_SCB", "ScbState", Flags));

        Stream = 0 != (Flags & 0x10);  // scb_state_secondary_stream
        StreamDir = 0 != (Flags & 0x08); // stream_directory

        if ((Error = GetFieldValue( Scb, "udfs!_SCB", "Fcb", Fcb)) || (0 == Fcb))  {

            DoIndent( Indent);
            
            if (Error)  {
            
                dprintf("Error reading Fcb from Scb %d\n", Error);
            }
            else {
            
                dprintf("<NULL Fcb ptr>\n");
            }            
        }
        
        Index = NodeIsUdfsRwIndex( Type);
        Data  = NodeIsUdfsRwData( Type);
#else
        dprintf("This FSKD build does not support R/W UDFS structures\n");
        return;
#endif
    }
    
    //
    //  If this is a new file,  as opposed to a stream of a file we've already dumped,
    //  them dump out the FCB and follow the stream directory.  For R/O UDFS there's
    //  nothing to do here (No streams & F/Scb split)
    //

#ifdef UDFS_RW_IN_BUILD
    
    if (!Stream && NTC_IS_UDFS_RW( Type))  {

        DoIndent( Indent);
        dprintf("FCB     @ 0x%I64x\n", Fcb);
    
        if ((0 != Fcb) && !(Error = GetFieldValue( Fcb, "udfs!_FCB", "StreamDirectoryScb", SdScb)) &&
            (0 != SdScb))  {

            //
            // TODO: Count SCBs in chain,  verify match scbs under streamdir?
            //
            
            ROE( GetFieldValue( SdScb, "udfs!_SCB", "NodeTypeCode", Type));

            if (NodeIsUdfsRwIndex(Type))  {

                //
                //  Stream dir - dump details than trawl through LCBs
                //

                ROE( GetFieldValue( SdScb, "udfs!_SCB", "ScbUserReference", Ur)); // TODO: Don't bail here!
                ROE( GetFieldValue( SdScb, "udfs!_SCB", "ScbReference", R));
                ROE( GetFieldValue( SdScb, "udfs!_SCB", "ScbCleanup", Cc));

                DoIndent( Indent);
                dprintf("SCB     @ 0x%I64X (%X,%X,%X) (-STREAMDIR-) \n", SdScb, Cc, Ur, R);

                //
                //  Follow all Lcbs and recursively dump tree
                //

                ROE( GetFieldOffset( "udfs!_SCB", "ChildLcbQueue", &Offset));
                ROE( GetFieldOffset( "udfs!_LCB", "ParentScbLinks", &Offsetb));

                DumpList( SdScb + Offset,
                          DumpTreeLcb,
                          Offsetb,
                          FALSE,
                          RecurLevel + 1);
            }
            else {
            
                DoIndent( Indent);
                dprintf("Invalid StreamDir Scb nodetypecode %l\n", Type);
            }
        }
        else {

            DoIndent( Indent);
            
            if (Error)  {
            
                dprintf("Error reading streamdirscb from fcb %d\n", Error);
            }
            else {
            
                dprintf("<NULL stream dir or Fcb>\n");
            }
        }
    }
#endif
    
    if (!StreamDir)  {

        // old (win2k) udfs didn't have this field.  Ignore failure.
        
        Lc = 0xffff;
        GetFieldValue( Scb, TypeString, "LinkCount", Lc);

        if (NTC_IS_UDFS_RW( Type))  {
        
#ifdef UDFS_RW_IN_BUILD        
            ROE( GetFieldValue( Scb, TypeString, "ScbUserReference", Ur));
            ROE( GetFieldValue( Scb, TypeString, "ScbReference", R));
            ROE( GetFieldValue( Scb, TypeString, "ScbCleanup", Cc));
#endif
        }
        else {
            ROE( GetFieldValue( Scb, TypeString, "FcbUserReference", Ur));
            ROE( GetFieldValue( Scb, TypeString, "FcbReference", R));
            ROE( GetFieldValue( Scb, TypeString, "FcbCleanup", Cc));
        }
        
        if (Index)  {

            //
            //  Index - dump details then trawl Lcbs
            //

            DoIndent( Indent);
            dprintf("F/SCB (-DIR-) @ 0x%I64X (%d,%d,%d - %d)\n", Scb, Cc, Ur, R, Lc);

            if (NTC_IS_UDFS_RW( Type) && (0 != Fcb))  {

                if (!GetFieldValue( Fcb, "udfs!_FCB", "DefaultStreamScb", SdScb))  {

                    if (SdScb != Scb)  {

                        DoIndent(Indent);
                        dprintf("INCONSISTENT - Scb->Fcb->DefaultStreamScb != Scb\n");
                    }
                }
            }

            if (Stream)  {
            
                DoIndent( Indent);
                dprintf("ILLEGAL - secondary stream is index\n");
            }

            //
            //  Follow all Lcbs and recursively dump tree
            //

            ROE( GetFieldOffset( TypeString, "ChildLcbQueue", &Offset));
            ROE( GetFieldOffset( "udfs!_LCB", 
                                 NTC_IS_UDFS_RW( Type) ? "ParentScbLinks" : "ParentFcbLinks",
                                 &Offsetb));

            DumpList( Scb + Offset,
                      DumpTreeLcb,
                      Offsetb,
                      FALSE,
                      RecurLevel + 1);                      
        }
        else if (Data)  {

            //
            //  File - dump details
            //
            
            DoIndent( Indent);
            dprintf("F/SCB (-DATA-) @ 0x%I64X (%d,%d,%d - %d)\n", Scb, Cc, Ur, R, Lc);
        }
        else {
        
            DoIndent( Indent);
            dprintf("Invalid F/Scb nodetypecode %d\n", Type);
        }
    }
}

//
//  Dump an LCB and all below it.
//

// OK
VOID
DumpTreeLcb(
    IN ULONG64 Lcb,
    IN LONG RecurLevel
    )
{
    ULONG64 Scb;
    ULONG Offset;
    ULONG Ntc;
    ULONG Ref;

    ROE( GetFieldValue( Lcb, "udfs!_LCB", "NodeTypeCode", Ntc));

#ifdef UDFS_RW_IN_BUILD
    if (( UDFS_NTC_LCB != Ntc) && (UDFSRW_NTC_LCB != Ntc))  {
#else
    if ( UDFS_NTC_LCB != Ntc)  {
#endif
        dprintf( "Not a UDF LCB @ %I64x - list corrupt\n", Lcb);
        return;
    }

    GetFieldValue( Lcb, 
                   "udfs!_LCB", 
                   NTC_IS_UDFS_RW( Ntc) ? "ChildScb" : "ChildFcb",
                   Scb);

    ROE( GetFieldValue( Lcb, "udfs!_LCB", "Reference", Ref));

    DoIndent( ((ULONG)RecurLevel) << 1);
    dprintf( "LCB @ %I64x  (Ref: %d)  Child F/Scb: %I64x ",  Lcb, Ref, Scb);

#ifdef UDFS_RW_IN_BUILD
    if (NTC_IS_UDFS_RW( Ntc))  {
    
        ROE( GetFieldValue( Lcb, "udfs!_LCB", "Flags", Ref));
        
        if (LcbDeleted( Ref))  {
        
            dprintf(" *DEL*  ");
        }
    }
#endif

    GetFieldOffset( "udfs!_LCB", "FileName", &Offset);
    DumpStr( Offset, Lcb+Offset, "Name", FALSE, TRUE);



    DumpTreeRecur( Scb, (ULONG)(RecurLevel + 1));
}


void 
DumpCloseQueue( 
    IN ULONG64 Vcb
    )
{
    ULONG64 UdfData; 
    ULONG Offset;

//    ROE( GetFieldOffset( "udfs!", "UdfData", &Offset));
   
//    ROE( GetFieldValue( 0, "Udfs!UdfData", NULL, UdfData));
        
    dprintf("\nDelayed closes on Vcb %I64X\n", Vcb);

    dprintf("NOT IMPLEMENTED\n");
}

// OK
VOID
SummariseIrpContextLite(
    IN ULONG64 RemoteAddress,
    IN LONG Options
    )
{
    ULONG64 Scb;
    USHORT Type;

    ReadM( &Type, RemoteAddress, sizeof( Type));

    ROE( GetFieldValue( RemoteAddress, 
                        "udfs!_IRP_CONTEXT_LITE", 
                        NTC_IS_UDFS_RW( Type) ? "Scb" : "Fcb", Scb));

    dprintf("  0x%I64x\n", Scb);
}

// OK
VOID
SummariseIrpContext(
    IN ULONG64 RemoteAddress,
    IN LONG Options
    )
{
    ULONG64 Irp;

    ROE( GetFieldValue( RemoteAddress, "udfs!_IRP_CONTEXT", "Irp", Irp));

    dprintf("  0x%I64x\n", Irp);
}

// OK
DUMP_ROUTINE( DumpUdfData)
{
    ULONG Count, Offset, LinkOffset;

    Dt( "udfs!UDF_DATA", Address, Options, 0, NULL);

    ROE( GetFieldValue( Address, "udfs!_UDF_DATA", "DelayedCloseCount", Count));

    if (Count)  {
        
        dprintf("\nSCBs on Delayed Close Queue (%d entries)\n", Count);

        ROE( GetFieldOffset( "udfs!_UDF_DATA", "DelayedCloseQueue", &Offset));
        ROE( GetFieldOffset( "udfs!_IRP_CONTEXT_LITE", "DelayedCloseLinks", &LinkOffset));

        DumpList( Address+Offset, SummariseIrpContextLite, LinkOffset, FALSE, 0);
    }

    dprintf(" \n");
    
    GetFieldValue( Address, "udfs!_UDF_DATA", "AsyncCloseCount", Count);

    if (Count)  {

        dprintf("\nF/SCBs on Async Close Queue (%d entries)\n", Count);

        ROE( GetFieldOffset( "udfs!_UDF_DATA", "AsyncCloseQueue", &Offset));
        ROE( GetFieldOffset( "udfs!_IRP_CONTEXT", "WorkQueueItem.List", &LinkOffset));
        
        DumpList( Address+Offset, SummariseIrpContext, LinkOffset, FALSE, 0);
    }
    
    dprintf(" \n");
}

// OK
DUMP_ROUTINE( DumpTreeSummary)
{
    ULONG64 RootFcbAddr, Scb, Vcb = 0;
    ULONG Error;
    USHORT Type;
    
    ReadM( &Type, Address, sizeof( Type));

#ifdef UDFS_RW_IN_BUILD
    if ((UDFS_NTC_VCB == Type) || (UDFSRW_NTC_VCB == Type) ) {
#else
    if (UDFS_NTC_VCB == Type)  {
#endif        
        Error = GetFieldValue( Address, 
                               "udfs!_VCB",
                               NTC_IS_UDFS_RW( Type) ? "RootIndexScb" : "RootIndexFcb", 
                               Scb);
        if (Error)  {
        
            dprintf( "Error %d reading rootindex f/scb addr\n", Error);
            return;
        }

        Vcb = Address;
        dprintf( "\nSummary tree for UDF Vcb @ %I64x    Refs: (clean,userref,ref - linkcount)\n\n", Address );
        dprintf( "(1,0,0) handle\n(0,1,1) Outstanding FO / del.close / child lcb\n(0,0,1) Stream file\n(0,0,1) Stream directory\n\n");
    }
    else {

        //
        //  Try and extract vcb from scb->fcb to dump delay close info
        //

        Scb = Address;
    }
    
    DumpTreeRecur( Scb, 0);

    //
    //  Dump delayed close queue info
    //

    dprintf("\nDo   !d Udfs!UdfData   to display globals and dump the delayed close queue\n");

    dprintf( "\n" );
}


DECLARE_API( tree )
{
    UNREFERENCED_PARAMETER( dwCurrentPc );
    UNREFERENCED_PARAMETER( hCurrentProcess );

    ParseAndDump( (PCHAR) args, (STRUCT_DUMP_ROUTINE) DumpTreeSummary, dwProcessor, hCurrentThread );
}

DECLARE_API( udfvcb )
{
    UNREFERENCED_PARAMETER( dwCurrentPc );
    UNREFERENCED_PARAMETER( hCurrentProcess );

    ParseAndDump( (PCHAR) args, (STRUCT_DUMP_ROUTINE) DumpUdfVcb, dwProcessor, hCurrentThread );
}


DECLARE_API( udficbsc )
{
    UNREFERENCED_PARAMETER( dwCurrentPc );
    UNREFERENCED_PARAMETER( hCurrentProcess );

    ParseAndDump( (PCHAR) args, (STRUCT_DUMP_ROUTINE) DumpUdfIcbSearchContext, dwProcessor, hCurrentThread );
}


DECLARE_API( udfccb)
{
    ParseAndDump( (PCHAR) args, (STRUCT_DUMP_ROUTINE) DumpUdfCcb, dwProcessor, hCurrentThread );
}


DECLARE_API( udffcb )
{
    UNREFERENCED_PARAMETER( dwCurrentPc );
    UNREFERENCED_PARAMETER( hCurrentProcess );

    ParseAndDump( (PCHAR) args, (STRUCT_DUMP_ROUTINE) DumpUdfFcb, dwProcessor, hCurrentThread );
}


DECLARE_API( udfvdo )
{
    UNREFERENCED_PARAMETER( dwCurrentPc );
    UNREFERENCED_PARAMETER( hCurrentProcess );

    ParseAndDump( (PCHAR) args, (STRUCT_DUMP_ROUTINE) DumpUdfVdo, dwProcessor, hCurrentThread );
}



DECLARE_API( udfirpcontext )
{
    UNREFERENCED_PARAMETER( dwCurrentPc );
    UNREFERENCED_PARAMETER( hCurrentProcess );

    ParseAndDump( (PCHAR) args, (STRUCT_DUMP_ROUTINE) DumpUdfIrpContext, dwProcessor, hCurrentThread );
}


DECLARE_API( udfirpcontextlite )
{
    UNREFERENCED_PARAMETER( dwCurrentPc );
    UNREFERENCED_PARAMETER( hCurrentProcess );

    ParseAndDump( (PCHAR) args, (STRUCT_DUMP_ROUTINE) DumpUdfIrpContextLite, dwProcessor, hCurrentThread );
}


DECLARE_API( udfmcb )
{
    UNREFERENCED_PARAMETER( dwCurrentPc );
    UNREFERENCED_PARAMETER( hCurrentProcess );

    ParseAndDump( (PCHAR) args, (STRUCT_DUMP_ROUTINE) DumpLargeMcb, dwProcessor, hCurrentThread );
}


DECLARE_API( lcb )
{
    UNREFERENCED_PARAMETER( dwCurrentPc );
    UNREFERENCED_PARAMETER( hCurrentProcess );

    ParseAndDump( (PCHAR) args, (STRUCT_DUMP_ROUTINE) DumpUdfLcb, dwProcessor, hCurrentThread );
}

DECLARE_API( pcb )
{
    UNREFERENCED_PARAMETER( dwCurrentPc );
    UNREFERENCED_PARAMETER( hCurrentProcess );

    ParseAndDump( (PCHAR) args, (STRUCT_DUMP_ROUTINE) DumpUdfPcb, dwProcessor, hCurrentThread );
}


//
//  RAW ON DISC STUCTURE DUMP ROUTINES FOLLOW....
//

#define UdfNodeTypeName( InfoIndex)  (UdfOnDiscTypeCodes[ InfoIndex].Text)
#define UdfNodeTypeDumpFunction( InfoIndex)  (UdfOnDiscTypeCodes[ InfoIndex].DumpRoutine)
#define UdfNodeTypeSize( InfoIndex)  (UdfOnDiscTypeCodes[ InfoIndex].Size)


#define DUMP_EXTN_AD( type, realaddress, structure, element, label)       \
        dprintf( "\n(%03x) %08x -> %s (LSN %08x, LEN %08x)",              \
                FIELD_OFFSET(type, element),                              \
                ((PUCHAR)realaddress) + FIELD_OFFSET(type, element),      \
                label,                                                    \
                structure.element.Lsn, structure.element.Len)

static UCHAR RegIdBuffer[ 33];

#define DUMP_REGID( type, realaddress, structure, element, label)         \
        strncpy( RegIdBuffer, structure.element.Identifier, 23);          \
        strncpy( RegIdBuffer+24, structure.element.Suffix, 8);            \
        RegIdBuffer[23] = '\0';                                           \
        RegIdBuffer[32] = '\0';                                           \
        dprintf( "\n(%03x) %08x -> %s (Flags %02x, '%s':'%s')",           \
                FIELD_OFFSET(type, element),                              \
                ((PUCHAR)realaddress) + FIELD_OFFSET(type, element),      \
                label,                                                    \
                structure.element.Flags,                                  \
                RegIdBuffer, RegIdBuffer+24)

#define DUMP_LONGAD( type, realaddress, structure, element, label)        \
        dprintf( "\n(%03x) %08x -> %s (Len %1x:%08x, StartLba %04x:%08x)",\
                FIELD_OFFSET(type, element),                              \
                ((PUCHAR)realaddress) + FIELD_OFFSET(type, element),      \
                label,                                                    \
                structure.element.Length.Type,                            \
                structure.element.Length.Length,                          \
                structure.element.Start.Partition,                        \
                structure.element.Start.Lbn)

#define DUMP_NSRLBA( type, realaddress, structure, element, label)        \
        dprintf( "\n(%03x) %08x -> %s (%04x:%08x)",                       \
                FIELD_OFFSET(type, element),                              \
                ((PUCHAR)realaddress) + FIELD_OFFSET(type, element),      \
                label,                                                    \
                structure.element.Partition,                              \
                structure.element.Lbn)


DUMP_ROUTINE( DumpUdfOnDiscStructure)
{
    DESTAG Tag;
    PDESTAG pTag;
    ULONG Result, InfoIndex;
    STRUCT_DUMP_ROUTINE Routine;
    
    RM( Address, Tag, pTag, PDESTAG, Result );
  
    InfoIndex = SearchTypeCodeIndex( Tag.Ident, UdfOnDiscTypeCodes);
    Routine = UdfNodeTypeDumpFunction( InfoIndex);

    if ( NULL == Routine) {
    
        dprintf( "Udf/Iso node tag 0x%04x unknown.\n", Tag.Ident);
        return;
    }

    //
    //  And call it...
    //

    dprintf( "\n%s @ %08x\n", UdfNodeTypeName(InfoIndex),  Address);
    
    (Routine)(Address, Options, &UdfOnDiscTypeCodes[InfoIndex]);
}


DUMP_ROUTINE( DumpUdfOnDiscTag)
{
    DESTAG Tag;
    PDESTAG pTag;
    ULONG Result, InfoIndex;
    STRUCT_DUMP_ROUTINE Routine;
    
    RM( Address, Tag, pTag, PDESTAG, Result );

    InfoIndex = SearchTypeCodeIndex( Tag.Ident, UdfOnDiscTypeCodes);
    Routine = UdfNodeTypeDumpFunction( InfoIndex);

    DUMP16_WITH_OFFSET(  DESTAG, Tag,    Ident,     "Ident" );    
    dprintf(" (== %s)", UdfNodeTypeName(InfoIndex));
    
    DUMP16_WITH_OFFSET(  DESTAG, Tag,    Version,   "Version");
    DUMP8_WITH_OFFSET(   DESTAG, Tag,    Checksum,  "Checksum");
    DUMP16_WITH_OFFSET(  DESTAG, Tag,    Serial,    "Serial");
    DUMP16_WITH_OFFSET(  DESTAG, Tag,    CRC,       "CRC");
    DUMP16_WITH_OFFSET(  DESTAG, Tag,    CRCLen,    "CRCLen");
    DUMP_WITH_OFFSET(    DESTAG, Tag,    Lbn,       "(TagLoc)Lbn");
}


DUMP_ROUTINE( DumpUdfOnDiscPvd)
{
    NSR_PVD Pvd;
    PNSR_PVD pPvd;
    ULONG Result;
    
    RM( Address, Pvd, pPvd, PNSR_PVD, Result );

    DUMP_EMBW_OFFSET(  NSR_PVD, Address,   Destag,              "Destag" );
    DUMP_WITH_OFFSET(  NSR_PVD, Pvd,       VolDescSeqNum,       "VolDescSeqNum" );
    DUMP_WITH_OFFSET(  NSR_PVD, Pvd,       Number,              "Number" );

    Pvd.VolumeID[ Pvd.VolumeID[ 31]] = '\0';
    DUMP_RAW_TERM_STRN_OFFSET( NSR_PVD, Pvd, Address, VolumeID,    "VolumeID");
   
    DUMP16_WITH_OFFSET(  NSR_PVD, Pvd,       VolSetSeq,         "VolSetSeq" );
    DUMP16_WITH_OFFSET(  NSR_PVD, Pvd,       VolSetSeqMax,      "VolSetSeqMax" );
    DUMP16_WITH_OFFSET(  NSR_PVD, Pvd,       Level,             "Level" );
    DUMP16_WITH_OFFSET(  NSR_PVD, Pvd,       LevelMax,          "LevelMax" );

    Pvd.VolSetID[ Pvd.VolSetID[ 127]] = '\0';
    DUMP_RAW_TERM_STRN_OFFSET( NSR_PVD, Pvd, Address, VolSetID,    "VolSetID");
    
    DUMP_EXTN_AD( NSR_PVD, Address, Pvd, Abstract, "Abstract");
    DUMP_EXTN_AD( NSR_PVD, Address, Pvd, Copyright, "Copyright");
    DUMP_REGID( NSR_PVD, Address, Pvd, ImpUseID, "ImpUseID");
    
    DUMP_WITH_OFFSET(  NSR_PVD, Pvd,       Predecessor,    "Predecessor" );
    DUMP16_WITH_OFFSET(  NSR_PVD, Pvd,     Flags,          "Flags" );
}


DUMP_ROUTINE( DumpUdfOnDiscAnchor)
{
    NSR_ANCHOR Avd;
    PNSR_ANCHOR pAvd;
    ULONG Result;
    
    RM( Address, Avd, pAvd, PNSR_ANCHOR, Result );
    
    DUMP_EMBW_OFFSET(  NSR_ANCHOR, Address,   Destag,           "Destag" );
    DUMP_EXTN_AD( NSR_ANCHOR, Address, Avd,   Main,             "Main");
    DUMP_EXTN_AD( NSR_ANCHOR, Address, Avd,   Reserve,          "Reserve");
}


DUMP_ROUTINE( DumpUdfOnDiscVdp)
{
    NSR_VDP Vdp;
    PNSR_VDP pVdp;
    ULONG Result;
    
    RM( Address, Vdp, pVdp, PNSR_VDP, Result );
    
    DUMP_EMBW_OFFSET(  NSR_VDP, Address,   Destag,           "Destag" );
    DUMP_WITH_OFFSET(  NSR_VDP, Vdp,       VolDescSeqNum,    "VolDescSeqNum" );
    DUMP_EXTN_AD( NSR_VDP, Address, Vdp,   Next,             "Next");
}


DUMP_ROUTINE( DumpUdfOnDiscPartDesc)
{
    NSR_PART Part;
    PNSR_PART pPart;
    ULONG Result;
    
    RM( Address, Part, pPart, PNSR_PART, Result );
    
    dprintf("\n(3/10.5)\n");
    
    DUMP_EMBW_OFFSET(  NSR_PART, Address,   Destag,         "Destag" );
    DUMP_WITH_OFFSET(  NSR_PART, Part,      VolDescSeqNum,  "VolDescSeqNum" );

    DUMP16_WITH_OFFSET(  NSR_PART, Part,      Flags,        "Flags" );
    DUMP16_WITH_OFFSET(  NSR_PART, Part,      Number,       "Number" );

    DUMP_REGID( NSR_PART, Address, Part, ContentsID,        "ContentsID");
    
    DUMP_WITH_OFFSET(  NSR_PART, Part,      AccessType,     "AccessType" );
    DUMP_WITH_OFFSET(  NSR_PART, Part,      Start,          "Start" );
    DUMP_WITH_OFFSET(  NSR_PART, Part,      Length,         "Length" );
    
    DUMP_REGID( NSR_PART, Address, Part,    ImpUseID,       "ImpUseID");
}

DUMP_ROUTINE( DumpUdfOnDiscLvol)
{
    NSR_LVOL Lv;
    PNSR_LVOL pLv;
    ULONG Result;
    
    RM( Address, Lv, pLv, PNSR_LVOL, Result );
    
    DUMP_EMBW_OFFSET(  NSR_LVOL, Address,   Destag,         "Destag" );
    DUMP_WITH_OFFSET(  NSR_LVOL, Lv,        VolDescSeqNum,  "VolDescSeqNum" );

    Lv.VolumeID[ Lv.VolumeID[ 127]] = '\0';
    DUMP_RAW_TERM_STRN_OFFSET( NSR_LVOL, Lv, Address, VolumeID,    "VolumeID");
    
    DUMP_WITH_OFFSET(  NSR_LVOL, Lv,        BlockSize,  "BlockSize" );
    DUMP_REGID( NSR_LVOL, Address, Lv,      DomainID,   "DomainID");

    DUMP_LONGAD( NSR_LVOL, Address, Lv, FSD, "FSD");
    
    DUMP_WITH_OFFSET(  NSR_LVOL, Lv,        MapTableLength, "MapTableLength" );
    DUMP_WITH_OFFSET(  NSR_LVOL, Lv,        MapTableCount,  "MapTableCount" );
    
    DUMP_REGID( NSR_LVOL, Address,  Lv, ImpUseID,   "ImpUseID");
    
    DUMP_EXTN_AD( NSR_LVOL, Address, Lv, Integrity,             "Integrity");
    DUMP_EMBW_OFFSET(  NSR_LVOL, Address,   MapTable,           "MapTable" );
}


DUMP_ROUTINE( DumpUdfOnDiscLvInteg)
{
}


DUMP_ROUTINE( DumpUdfOnDiscFsd)
{
    NSR_FSD Fsd;
    PNSR_FSD pFsd;
    ULONG Result;
    STRING Str;
    
    RM( Address, Fsd, pFsd, PNSR_FSD, Result );
    
    DUMP_EMBW_OFFSET(  NSR_FSD, Address,   Destag,          "Destag" );
    DUMP_EMBW_OFFSET(  NSR_FSD, Address,   Time,            "Time" );
    DUMP16_WITH_OFFSET(  NSR_FSD, Fsd,      Level,         "Level" );
    DUMP16_WITH_OFFSET(  NSR_FSD, Fsd,      LevelMax,       "LevelMax" );
    DUMP_WITH_OFFSET(  NSR_FSD, Fsd,      FileSet,       "FileSet" );
    DUMP_WITH_OFFSET(  NSR_FSD, Fsd,      FileSetDesc,       "FileSetDesc" );

    Fsd.VolID[ Fsd.VolID[ 127]] = '\0';
    DUMP_RAW_TERM_STRN_OFFSET( NSR_FSD, Fsd, Address, VolID,       "VolID    ");

    Fsd.FileSetID[ Fsd.FileSetID[ 127]] = '\0';
    DUMP_RAW_TERM_STRN_OFFSET( NSR_FSD, Fsd, Address, FileSetID,   "FileSetID");

    DUMP_LONGAD( NSR_FSD, Address, Fsd, IcbRoot,             "IcbRoot   ");
    DUMP_REGID( NSR_FSD, Address, Fsd, DomainID,             "DomainID  ");
    DUMP_LONGAD( NSR_FSD, Address, Fsd, NextExtent,          "NextExtent");

    dprintf("\n");
}


DUMP_ROUTINE( DumpUdfOnDiscFid)
{
    NSR_FID Fid;
    PNSR_FID pFid;
    ULONG Result;
    UCHAR Buffer[512];
    
    RM( Address, Fid, pFid, PNSR_FID, Result );

    dprintf("\nFid.Flags: ");
    PrintState( UdfFidFlags, Fid.Flags);
    
    DUMP_EMBW_OFFSET(  NSR_FID, Address,   Destag,          "Destag" );
    DUMP16_WITH_OFFSET(  NSR_FID, Fid,     Version,         "Version" );
    DUMP8_WITH_OFFSET(  NSR_FID, Fid,      Flags,           "Flags" );
    DUMP8_WITH_OFFSET(  NSR_FID, Fid,      FileIDLen,       "FileIDLen" );
    DUMP_LONGAD( NSR_FID, Address, Fid, Icb, "Icb");
    DUMP16_WITH_OFFSET(  NSR_FID, Fid,     ImpUseLen,       "ImpUseLen" );
    DUMP_EMBW_OFFSET(  NSR_FID, Address,   ImpUse,          "ImpUse" );
    
    dprintf("\nFileID @ %08x\n", ((PUCHAR)Address) + FIELD_OFFSET( NSR_FID, ImpUse) + Fid.ImpUseLen);    
}


DUMP_ROUTINE( DumpUdfOnDiscIcbFile)
{
    ICBFILE Icb;
    PICBFILE pIcb;
    ULONG Result;
    USHORT AllocType;
    ULONG AllocLength = 0;
    DWORD_PTR AllocDescsRealAddr;
    
    RM( Address, Icb, pIcb, PICBFILE, Result );
    
    dprintf("\nIcb.IcbTag.Flags: ");
    PrintState( UdfIcbTagFlags, Icb.Icbtag.Flags);
    
    DUMP_EMBW_OFFSET(  ICBFILE, Address,   Destag,                      "Destag" );

    // IcbTag embedded structure
    
    DUMP_WITH_OFFSET(    ICBFILE, Icb,       Icbtag.PriorDirectCount,   "Icbtag.PriorDirectCount" );
    
    DUMP16_WITH_OFFSET(  ICBFILE, Icb,       Icbtag.StratType,          "Icbtag.StratType" );
    dprintf(" == %s", (Icb.Icbtag.StratType <= MAX_VALID_ICB_STRAT) ? IcbStrategies[ Icb.Icbtag.StratType ] : "INVALID");
    
    DUMP16_WITH_OFFSET(  ICBFILE, Icb,       Icbtag.StratParm,          "Icbtag.StratParm" );
    DUMP16_WITH_OFFSET(  ICBFILE, Icb,       Icbtag.MaxEntries,         "Icbtag.MaxEntries" );
    
    DUMP16_WITH_OFFSET(  ICBFILE, Icb,       Icbtag.FileType,           "Icbtag.FileType" );
    dprintf(" == %s", (Icb.Icbtag.FileType <= MAX_VALID_ICB_TYPE) ? IcbFileTypes[ Icb.Icbtag.FileType ] : "INVALID");
    
    DUMP_NSRLBA( ICBFILE, Address,  Icb,  Icbtag.IcbParent,             "IcbTag.IcbParent");
    DUMP16_WITH_OFFSET(  ICBFILE, Icb,       Icbtag.Flags,              "Icbtag.Flags" );

    // end icbtag

    DUMP_WITH_OFFSET(    ICBFILE, Icb,       UID,               "UID" );
    DUMP_WITH_OFFSET(    ICBFILE, Icb,       GID,               "GID" );
    DUMP_WITH_OFFSET(    ICBFILE, Icb,       Permissions,       "Permissions" );
    DUMP16_WITH_OFFSET(    ICBFILE, Icb,     LinkCount,         "LinkCount" );
    DUMP8_WITH_OFFSET(    ICBFILE, Icb,      RecordFormat,      "RecordFormat" );
    DUMP8_WITH_OFFSET(    ICBFILE, Icb,      RecordDisplay,     "RecordDisplay" );
    DUMP_WITH_OFFSET(    ICBFILE, Icb,       RecordLength,      "RecordLength" );
    DUMP64_WITH_OFFSET(    ICBFILE, Icb,     InfoLength,        "InfoLength" );
    DUMP64_WITH_OFFSET(    ICBFILE, Icb,     BlocksRecorded,    "BlocksRecorded" );
    DUMP_EMBW_OFFSET(  ICBFILE, Address,     AccessTime,        "AccessTime" );
    DUMP_EMBW_OFFSET(  ICBFILE, Address,     ModifyTime,        "ModifyTime" );
    DUMP_EMBW_OFFSET(  ICBFILE, Address,     AttributeTime,     "AttributeTime" );
    DUMP_WITH_OFFSET(    ICBFILE, Icb,       Checkpoint,        "Checkpoint" );
    
    DUMP_LONGAD( ICBFILE,  Address, Icb,  IcbEA,    "IcbEA");
    DUMP_REGID(  ICBFILE,  Address, Icb,  ImpUseID, "ImpUseID");

    DUMP64_WITH_OFFSET(    ICBFILE, Icb,     UniqueID,          "UniqueID" );
    DUMP_WITH_OFFSET(    ICBFILE, Icb,       EALength,          "EALength" );
    DUMP_WITH_OFFSET(    ICBFILE, Icb,       AllocLength,       "AllocLength" );

    // lazy! *** dump EA list
    
    DUMP_EMBW_OFFSET(  ICBFILE, Address,     EAs,     "EAs[]" );

    AllocDescsRealAddr = ((ULONG)Address) + FIELD_OFFSET( ICBFILE, EAs) + Icb.EALength;
    AllocType = (ICBTAG_F_ALLOC_MASK & Icb.Icbtag.Flags);
    
    dprintf("\n\nAllocation descriptors @ %08x\n\n", AllocDescsRealAddr );

    if ((Options & 1) && (ICBTAG_F_ALLOC_IMMEDIATE != AllocType))  {

        UCHAR Buffer[4*1024];
        PUCHAR CurrentDesc = Buffer;
        ULONG Size;

        if ( sizeof(Buffer) < Icb.AllocLength)  {
        
            dprintf("Buffer too small\n");
            return;
        }
        
        //
        //  Dump allocation descriptors
        //
        
        if (!ReadMemory( AllocDescsRealAddr, Buffer, Icb.AllocLength, &Result))  {
        
            dprintf( "Failed to read memory @%p\n", AllocDescsRealAddr);
            return;
        }

        while ( AllocLength < Icb.AllocLength)  {

            switch (AllocType)  {
            
                case ICBTAG_F_ALLOC_SHORT:
                
                    dprintf( " %08x , %01x:%08x\n", ((PSHORTAD)CurrentDesc)->Start, 
                             ((PSHORTAD)CurrentDesc)->Length.Type,  ((PSHORTAD)CurrentDesc)->Length.Length);
                    Size = sizeof( SHORTAD);
                    break;
                    
                case ICBTAG_F_ALLOC_LONG:  {
                    
                        PLONGAD Ad = (PLONGAD)CurrentDesc;
                        
                        dprintf( " %04x:%08x , %01x:%08x,  ImpUse[6] @ %08x\n", 
                                 Ad->Start.Partition, Ad->Start.Lbn, 
                                 Ad->Length.Type,  Ad->Length.Length,
                                 AllocDescsRealAddr + AllocLength + FIELD_OFFSET( LONGAD, ImpUse));
                        Size = sizeof( LONGAD);
                    }
                    break;
                    
                case ICBTAG_F_ALLOC_EXTENDED:  {
                    
                        PEXTAD Ad = (PEXTAD)CurrentDesc;
                        
                        dprintf( " %04x:%08x , EL: %01x:%08x, RL: %01x:%08x, InfoL: %08x, ImpUse[2] @ %08x\n", 
                                 Ad->Start.Partition, Ad->Start.Lbn, 
                                 Ad->ExtentLen.Type,  Ad->ExtentLen.Length,
                                 Ad->RecordedLen.Type,  Ad->RecordedLen.Length,
                                 Ad->InfoLen,
                                 AllocDescsRealAddr + AllocLength + FIELD_OFFSET( EXTAD, ImpUse));
                        Size = sizeof( EXTAD);
                    }
                    break;
                    
                default:
                    dprintf("INVALID Allocdesc type %d\n", AllocType);
                    return;
            }

            AllocLength += Size;
            CurrentDesc += Size;
        }
    }
}


DUMP_ROUTINE( DumpUdfOnDiscIcbExtFile)
{
    ICBEXTFILE Icb;
    PICBEXTFILE pIcb;
    ULONG Result;
    USHORT AllocType;
    ULONG AllocLength = 0;
    DWORD_PTR AllocDescsRealAddr;
    
    RM( Address, Icb, pIcb, PICBEXTFILE, Result );
    
    dprintf("\nIcb.IcbTag.Flags: ");
    PrintState( UdfIcbTagFlags, Icb.Icbtag.Flags);
    
    DUMP_EMBW_OFFSET(  ICBFILE, Address,   Destag,                      "Destag" );

    // IcbTag embedded structure
    
    DUMP_WITH_OFFSET(    ICBEXTFILE, Icb,       Icbtag.PriorDirectCount,   "Icbtag.PriorDirectCount" );
    
    DUMP16_WITH_OFFSET(  ICBEXTFILE, Icb,       Icbtag.StratType,          "Icbtag.StratType" );
    dprintf(" == %s", (Icb.Icbtag.StratType <= MAX_VALID_ICB_STRAT) ? IcbStrategies[ Icb.Icbtag.StratType ] : "INVALID");
    
    DUMP16_WITH_OFFSET(  ICBEXTFILE, Icb,       Icbtag.StratParm,          "Icbtag.StratParm" );
    DUMP16_WITH_OFFSET(  ICBEXTFILE, Icb,       Icbtag.MaxEntries,         "Icbtag.MaxEntries" );
    
    DUMP16_WITH_OFFSET(  ICBEXTFILE, Icb,       Icbtag.FileType,           "Icbtag.FileType" );
    dprintf(" == %s", (Icb.Icbtag.FileType <= MAX_VALID_ICB_TYPE) ? IcbFileTypes[ Icb.Icbtag.FileType ] : "INVALID");
    
    DUMP_NSRLBA( ICBEXTFILE, Address,  Icb,  Icbtag.IcbParent,             "IcbTag.IcbParent");
    DUMP16_WITH_OFFSET(  ICBEXTFILE, Icb,       Icbtag.Flags,              "Icbtag.Flags" );

    // end icbtag

    DUMP_WITH_OFFSET(    ICBEXTFILE, Icb,       UID,               "UID" );
    DUMP_WITH_OFFSET(    ICBEXTFILE, Icb,       GID,               "GID" );
    DUMP_WITH_OFFSET(    ICBEXTFILE, Icb,       Permissions,       "Permissions" );
    DUMP16_WITH_OFFSET(    ICBEXTFILE, Icb,     LinkCount,         "LinkCount" );
    DUMP8_WITH_OFFSET(    ICBEXTFILE, Icb,      RecordFormat,      "RecordFormat" );
    DUMP8_WITH_OFFSET(    ICBEXTFILE, Icb,      RecordDisplay,     "RecordDisplay" );
    DUMP_WITH_OFFSET(    ICBEXTFILE, Icb,       RecordLength,      "RecordLength" );
    DUMP64_WITH_OFFSET(    ICBEXTFILE, Icb,     InfoLength,        "InfoLength" );
    DUMP64_WITH_OFFSET(    ICBEXTFILE, Icb,     ObjectSize,         "ObjectSize" );
    DUMP64_WITH_OFFSET(    ICBEXTFILE, Icb,     BlocksRecorded,    "BlocksRecorded" );
    DUMP_EMBW_OFFSET(  ICBEXTFILE, Address,     AccessTime,        "AccessTime" );
    DUMP_EMBW_OFFSET(  ICBEXTFILE, Address,     ModifyTime,        "ModifyTime" );
    DUMP_EMBW_OFFSET(  ICBEXTFILE, Address,     AttributeTime,     "AttributeTime" );
    DUMP_EMBW_OFFSET(  ICBEXTFILE, Address,     CreationTime,     "CreationTime" );
    DUMP_WITH_OFFSET(    ICBEXTFILE, Icb,       Checkpoint,        "Checkpoint" );
    
    DUMP_LONGAD( ICBEXTFILE,  Address, Icb,  IcbEA,    "IcbEA");
    DUMP_LONGAD( ICBEXTFILE,  Address, Icb,  IcbStream,    "IcbStream");
    DUMP_REGID(  ICBEXTFILE,  Address, Icb,  ImpUseID, "ImpUseID");

    DUMP64_WITH_OFFSET(    ICBEXTFILE, Icb,     UniqueID,          "UniqueID" );
    DUMP_WITH_OFFSET(    ICBEXTFILE, Icb,       EALength,          "EALength" );
    DUMP_WITH_OFFSET(    ICBEXTFILE, Icb,       AllocLength,       "AllocLength" );

    // lazy! *** dump EA list
    
    DUMP_EMBW_OFFSET(  ICBEXTFILE, Address,     EAs,     "EAs[]" );

    AllocDescsRealAddr = ((ULONG)Address) + FIELD_OFFSET( ICBEXTFILE, EAs) + Icb.EALength;
    AllocType = (ICBTAG_F_ALLOC_MASK & Icb.Icbtag.Flags);
    
    dprintf("\n\nAllocation descriptors @ %08x\n\n", AllocDescsRealAddr );

    if ((Options & 1) && (ICBTAG_F_ALLOC_IMMEDIATE != AllocType))  {

        UCHAR Buffer[4*1024];
        PUCHAR CurrentDesc = Buffer;
        ULONG Size;

        if ( sizeof(Buffer) < Icb.AllocLength)  {
        
            dprintf("Buffer too small\n");
            return;
        }
        
        //
        //  Dump allocation descriptors
        //
        
        if (!ReadMemory( AllocDescsRealAddr, Buffer, Icb.AllocLength, &Result))  {
        
            dprintf( "Failed to read memory @%p\n", AllocDescsRealAddr);
            return;
        }

        while ( AllocLength < Icb.AllocLength)  {

            switch (AllocType)  {
            
                case ICBTAG_F_ALLOC_SHORT:
                
                    dprintf( " %08x , %01x:%08x\n", ((PSHORTAD)CurrentDesc)->Start, 
                             ((PSHORTAD)CurrentDesc)->Length.Type,  ((PSHORTAD)CurrentDesc)->Length.Length);
                    Size = sizeof( SHORTAD);
                    break;
                    
                case ICBTAG_F_ALLOC_LONG:  {
                    
                        PLONGAD Ad = (PLONGAD)CurrentDesc;
                        
                        dprintf( " %04x:%08x , %01x:%08x,  ImpUse[6] @ %08x\n", 
                                 Ad->Start.Partition, Ad->Start.Lbn, 
                                 Ad->Length.Type,  Ad->Length.Length,
                                 AllocDescsRealAddr + AllocLength + FIELD_OFFSET( LONGAD, ImpUse));
                        Size = sizeof( LONGAD);
                    }
                    break;
                    
                case ICBTAG_F_ALLOC_EXTENDED:  {
                    
                        PEXTAD Ad = (PEXTAD)CurrentDesc;
                        
                        dprintf( " %04x:%08x , EL: %01x:%08x, RL: %01x:%08x, InfoL: %08x, ImpUse[2] @ %08x\n", 
                                 Ad->Start.Partition, Ad->Start.Lbn, 
                                 Ad->ExtentLen.Type,  Ad->ExtentLen.Length,
                                 Ad->RecordedLen.Type,  Ad->RecordedLen.Length,
                                 Ad->InfoLen,
                                 AllocDescsRealAddr + AllocLength + FIELD_OFFSET( EXTAD, ImpUse));
                        Size = sizeof( EXTAD);
                    }
                    break;
                    
                default:
                    dprintf("INVALID Allocdesc type %d\n", AllocType);
                    return;
            }

            AllocLength += Size;
            CurrentDesc += Size;
        }
    }
}


DECLARE_API( udftag )
{
    UNREFERENCED_PARAMETER( dwCurrentPc );
    UNREFERENCED_PARAMETER( hCurrentProcess );

    ParseAndDump( (PCHAR) args, (STRUCT_DUMP_ROUTINE) DumpUdfOnDiscTag, dwProcessor, hCurrentThread );
}

DECLARE_API( ud )
{
    UNREFERENCED_PARAMETER( dwCurrentPc );
    UNREFERENCED_PARAMETER( hCurrentProcess );

    ParseAndDump( (PCHAR) args, (STRUCT_DUMP_ROUTINE) DumpUdfOnDiscStructure, dwProcessor, hCurrentThread );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fastfat\fskd\kdext.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    kdexts.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

Author:

    Wesley Witt (wesw) 26-Aug-1993

Environment:

    User Mode

--*/

#include "pch.h"
#pragma hdrstop

#include <ntverp.h>
#include <imagehlp.h>

//
// globals
//
EXT_API_VERSION        ApiVersion = { 3, 5, EXT_API_VERSION_NUMBER64, 0 };
WINDBG_EXTENSION_APIS  ExtensionApis;
ULONG                  STeip;
ULONG                  STebp;
ULONG                  STesp;
USHORT                 SavedMajorVersion;
USHORT                 SavedMinorVersion;



DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    UNREFERENCED_PARAMETER( hModule );
    UNREFERENCED_PARAMETER( dwReserved );
    
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}


VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    return;
}

DECLARE_API( version )
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    UNREFERENCED_PARAMETER( args );
    UNREFERENCED_PARAMETER( dwProcessor );
    UNREFERENCED_PARAMETER( dwCurrentPc );
    UNREFERENCED_PARAMETER( hCurrentThread );
    UNREFERENCED_PARAMETER( hCurrentProcess );

    dprintf( "%s Extension dll for Build %d debugging %s kernel for Build %d\n",
             DebuggerType,
             VER_PRODUCTBUILD,
             SavedMajorVersion == 0x0c ? "Checked" : "Free",
             SavedMinorVersion
           );
}

VOID
CheckVersion(
    VOID
    )
{
#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fastfat\fskd\fatkd.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    FatKd.c

Abstract:

    KD Extension Api for examining Fat specific data structures

Author:

    Tom Jolly    [tomjolly]   14-Sep-99
    (ntfskd) Keith Kaplan [KeithKa]    24-Apr-96
    Portions by Jeff Havens

Environment:

    User Mode.

Revision History:

--*/

#include "pch.h"

#undef FlagOn
#undef WordAlign
#undef LongAlign
#undef QuadAlign
#undef DebugPrint
#undef MAXULONGLONG

#define KDEXT
//#include "gentable.h"

#undef DebugTrace

#include "..\nodetype.h"
#include "..\..\cdfs\nodetype.h"
#include "..\..\udfs\nodetype.h"

#ifdef UDFS_RW_IN_BUILD
#include "..\..\udfsrw\nodetype.h"
#endif

#include "fatkd.h"
#include "cdfskd.h"
#include "udfskd.h"

//
//  Lookup table that tells how many clear bits (i.e., 0) there are in a byte
//

CONST UCHAR BitsClearTotal[] =
          { 8,7,7,6,7,6,6,5,7,6,6,5,6,5,5,4,
            7,6,6,5,6,5,5,4,6,5,5,4,5,4,4,3,
            7,6,6,5,6,5,5,4,6,5,5,4,5,4,4,3,
            6,5,5,4,5,4,4,3,5,4,4,3,4,3,3,2,
            7,6,6,5,6,5,5,4,6,5,5,4,5,4,4,3,
            6,5,5,4,5,4,4,3,5,4,4,3,4,3,3,2,
            6,5,5,4,5,4,4,3,5,4,4,3,4,3,3,2,
            5,4,4,3,4,3,3,2,4,3,3,2,3,2,2,1,
            7,6,6,5,6,5,5,4,6,5,5,4,5,4,4,3,
            6,5,5,4,5,4,4,3,5,4,4,3,4,3,3,2,
            6,5,5,4,5,4,4,3,5,4,4,3,4,3,3,2,
            5,4,4,3,4,3,3,2,4,3,3,2,3,2,2,1,
            6,5,5,4,5,4,4,3,5,4,4,3,4,3,3,2,
            5,4,4,3,4,3,3,2,4,3,3,2,3,2,2,1,
            5,4,4,3,4,3,3,2,4,3,3,2,3,2,2,1,
            4,3,3,2,3,2,2,1,3,2,2,1,2,1,1,0 };
            

VOID 
DumpStr( 
    IN ULONG FieldOffset,
    IN ULONG64 StringAddress,
    IN PUCHAR Label,
    IN BOOLEAN CrFirst,
    IN BOOLEAN Wide
    )
{
    WCHAR Buffer[512];
    ULONG64 StringChars = 0;    // *64
    USHORT DisplayLength;
    UNICODE_STRING String;

    ROE( GetFieldValue( StringAddress, "UNICODE_STRING", "Buffer", StringChars));
    ROE( GetFieldValue( StringAddress, "UNICODE_STRING", "Length", DisplayLength));
    ROE( GetFieldValue( StringAddress, "UNICODE_STRING", "MaximumLength", String.MaximumLength));

    if (DisplayLength > sizeof( Buffer))  {
    
        DisplayLength = sizeof(Buffer);
    }

    if (CrFirst)  {
    
        dprintf("\n");
    }
    
    if (DisplayLength)  {

        if (StringChars)  {

            ReadM( Buffer, StringChars, DisplayLength);
            String.Length = DisplayLength;
            String.Buffer = Buffer;
        }
        else {
            
            String.Buffer = (PWCHAR)"<<NULL buffer pointer>>";
            String.Length = 23;
            Wide = FALSE;
        }
    }
    else {

        String.Buffer = (PWCHAR)"<<empty>>";
        String.Length = 9;
        Wide = FALSE;
    }

    if (Wide)  {
    
        dprintf( "%s: (%03x/%03x) '%wZ'\n", 
                 Label,  DisplayLength, String.MaximumLength, 
                 &String );
    }
    else {
    
        dprintf( "%s: (%03x/%03x) '%Z'\n", 
                 Label,  DisplayLength, String.MaximumLength, 
                 &String );
    }
}


ULONG
Dt( IN UCHAR *Type,
    IN ULONG64 Addr,
    IN ULONG Recur,
    IN ULONG FieldInfoCount,
    IN FIELD_INFO FieldInfo[]
  )
{
    SYM_DUMP_PARAM Param;

    Param.size = sizeof( Param);
    Param.sName = Type;
    Param.Options = DBG_DUMP_RECUR_LEVEL(Recur);
    Param.addr = Addr;
    Param.listLink = NULL;
    Param.Context = NULL;
    Param.CallbackRoutine = NULL;
    Param.nFields = FieldInfoCount;
    Param.Fields = FieldInfo;

    return Ioctl( IG_DUMP_SYMBOL_INFO, &Param, Param.size);
}

//
// The help strings printed out
//

static LPSTR Extensions[] = {
    "FAT/CDFS/UDFS Debugger Extension Commands,  where...\n\n   [FS] => CD/UDF/FAT\n   -> in output denotes address of embedded structure\n",
    "  [FS]mcb            [addr] [1]       Dump MCB",
    "                                          [1] Dump out extent list",
    "  [FS]vdo            [addr]           Volume device object (from direct addr *OR* VCB addr)",
    "  fo                 [addr] [1]       Dump FileObject."
    "\n                                      [1] Also dump associated Fcb/Ccb structures",
    "                                          [2] dump SHARED_CACHE_MAP",
    " ",
    "  d                  [addr] [...]     Dump any tagged structure (any FS).  Understands...",
    "                                      VCB, CCB, fsDATA, IRPCONTEXT, IRPCONTEXTLITE,"
    "\n                                         FCB / SCB (** see command ouput for further options)",
    "                                      and (UDF ONLY) PCB, VMCB,",
    "                                      LCB - options",
    "                                          [1] dump associated FCB"
    " ",
    "                                      For structures without options,  second parameter is dump recurse level",
    " ",
    "  db                 [addr] [recur]   As !d,  but just a straight DT of the structure based on node type",
    " ",
    "  cdrawdirent        [addr] [count]   Dump a COUNT raw ISO9660 dirents starting at ADDR",
    " ",
    "  udficbsc           [addr]           (UDFS only) Dump an ICB_CONTEXT",
    "  udftag             [addr]           Dump out a UDF on disk format descriptor tag in detail (3/7.2)",
    "  ud                 [addr] [...]     Dump any on disc format UDF structure which has a descr.tag",
    "                                          Currently: PVD,AVDP,VDP,PD,LVD,FSD,FID,FE",
    "                                              [1] (FE) Dump allocation decriptors",
    " ",
    "  vmcb               [addr]           Use on pre 1.10.2000 builds (vmcb not tagged) rather than !d ",
    " ",
    "  tree               [addr]           (UDFS only) Dumps a summary of the F/Scb tree (names, ref counts) from",
    "                                                 the specified Scb down.  If a Vcb address is specified will",
    "                                                 dump from root down",
    " ",
    "  countclearbits     [addr] [bytes]   Count clear bits in mem range",
    "  countdwords        [addr] [dword]   Count occurences of dword in mem range",
    " ",
    " ",
    "  fshelp                              ...",
    0
};

STATE FoFlags[] = {

    {   FO_FILE_OPEN,                   FO_FILE_OPEN,                   "Open"  },
    {   FO_SYNCHRONOUS_IO,              FO_SYNCHRONOUS_IO,              "Synchronous" },
    {   FO_ALERTABLE_IO,                FO_ALERTABLE_IO,                "Alertable" },
    {   FO_NO_INTERMEDIATE_BUFFERING,   FO_NO_INTERMEDIATE_BUFFERING,   "NoIntermediateBuffering" },
    {   FO_WRITE_THROUGH,               FO_WRITE_THROUGH,               "WriteThrough"},
    {   FO_SEQUENTIAL_ONLY,             FO_SEQUENTIAL_ONLY,             "SequentialOnly"},
    {   FO_CACHE_SUPPORTED,             FO_CACHE_SUPPORTED,             "CacheSupported"},
    {   FO_NAMED_PIPE,                  FO_NAMED_PIPE,                  "NamedPipe"},
    {   FO_STREAM_FILE,                 FO_STREAM_FILE,                 "StreamFile"},
    {   FO_MAILSLOT,                    FO_MAILSLOT,                    "MailSlot"},
    {   FO_GENERATE_AUDIT_ON_CLOSE,     FO_GENERATE_AUDIT_ON_CLOSE,     "AuditOnClose"},
    {   FO_DIRECT_DEVICE_OPEN,          FO_DIRECT_DEVICE_OPEN,          "DirectDeviceOpen"},
    {   FO_FILE_MODIFIED,               FO_FILE_MODIFIED,               "Modified"},
    {   FO_FILE_SIZE_CHANGED,           FO_FILE_SIZE_CHANGED,           "SizeChanged"},
    {   FO_CLEANUP_COMPLETE,            FO_CLEANUP_COMPLETE,            "CleanupComplete"},
    {   FO_TEMPORARY_FILE,              FO_TEMPORARY_FILE,              "Temporary"},
    {   FO_DELETE_ON_CLOSE,             FO_DELETE_ON_CLOSE,             "DeleteOnClose"},
    {   FO_OPENED_CASE_SENSITIVE,       FO_OPENED_CASE_SENSITIVE,       "CaseSensitive"},
    {   FO_HANDLE_CREATED,              FO_HANDLE_CREATED,              "HandleCreated"},
    {   FO_FILE_FAST_IO_READ,           FO_FILE_FAST_IO_READ,           "FastIoRead"},
    {   FO_RANDOM_ACCESS,               FO_RANDOM_ACCESS,               "RandomAccess"},
    {   FO_FILE_OPEN_CANCELLED,         FO_FILE_OPEN_CANCELLED,         "OpenCancelled"},
    {   FO_VOLUME_OPEN,                 FO_VOLUME_OPEN,                 "VolumeOpen"},
    { 0 }
};

//
//  FSRTL Common header flags
//

STATE HeaderFlags[] = {

    {   FSRTL_FLAG_FILE_MODIFIED,          FSRTL_FLAG_FILE_MODIFIED,            "Modified"},
    {   FSRTL_FLAG_FILE_LENGTH_CHANGED,    FSRTL_FLAG_FILE_LENGTH_CHANGED,      "LengthChanged"},
    {   FSRTL_FLAG_LIMIT_MODIFIED_PAGES,   FSRTL_FLAG_LIMIT_MODIFIED_PAGES,     "LimitModPages"},
    {   FSRTL_FLAG_ACQUIRE_MAIN_RSRC_EX,   FSRTL_FLAG_ACQUIRE_MAIN_RSRC_EX,     "ModWrAcqMainEx"},
    {   FSRTL_FLAG_ACQUIRE_MAIN_RSRC_SH,   FSRTL_FLAG_ACQUIRE_MAIN_RSRC_SH,     "ModWrAcqMainSh"},
    {   FSRTL_FLAG_USER_MAPPED_FILE,       FSRTL_FLAG_USER_MAPPED_FILE,         "UserMapped"},
    {   FSRTL_FLAG_ADVANCED_HEADER,        FSRTL_FLAG_ADVANCED_HEADER,          "AdvancedHeader"},
    {   FSRTL_FLAG_EOF_ADVANCE_ACTIVE,     FSRTL_FLAG_EOF_ADVANCE_ACTIVE,       "EofAdvanceActive"},
    { 0 }
};

STATE HeaderFlags2[] = {

    {   FSRTL_FLAG2_DO_MODIFIED_WRITE,          FSRTL_FLAG2_DO_MODIFIED_WRITE,          "DoModWrite"},
    {   FSRTL_FLAG2_SUPPORTS_FILTER_CONTEXTS,   FSRTL_FLAG2_SUPPORTS_FILTER_CONTEXTS,   "FilterContexts"},
    {   FSRTL_FLAG2_PURGE_WHEN_MAPPED,          FSRTL_FLAG2_PURGE_WHEN_MAPPED,          "PurgeOnMap"},
    { 0 }
};


VOID
DumpList(
    IN ULONG64 RemoteListEntryAddress,
    IN ELEMENT_DUMP_ROUTINE ProcessElementRoutine,
    IN ULONG OffsetToContainerStart,
    IN BOOLEAN ProcessThisEntry,
    IN ULONG Options
    )
{
    LIST_ENTRY64 Entry;
    ULONG64 CurrentEntryRemoteAddress = 0;

    //
    //  Read the first LIST_ENTRY structure
    //

    ROE( !ReadListEntry( RemoteListEntryAddress, &Entry));

    //
    //  Scan through until we end up back at the  3start again.
    //
    
    while (CurrentEntryRemoteAddress != RemoteListEntryAddress)  {

        if (ProcessThisEntry)  {

            (ProcessElementRoutine)( CurrentEntryRemoteAddress - OffsetToContainerStart,  Options);
        }
        else  {
        
            ProcessThisEntry = TRUE;
        }
        
        CurrentEntryRemoteAddress = Entry.Flink;
        ROE( !ReadListEntry( CurrentEntryRemoteAddress, &Entry));
    }
}


/*
 * Dump structures
 */

typedef BOOLEAN (WINAPI *PENUM_PROCESS_CALLBACK)(PVOID ProcessAddress, PVOID Process, PVOID ThreadAddress, PVOID Thread);
typedef VOID (* ENUM_PROCESSES_FUNC)(PENUM_PROCESS_CALLBACK CallBack);


VOID
PrintState(STATE *ps, ULONG state)
{
    ULONG ul = 0;

    if (NULL == ps)  {
    
        dprintf(" << NULL flags supplied! >>\n");
        return;
    }
    
    while (ps->mask != 0)
    {
        ul |= ps->mask;
        if ((state & ps->mask) == ps->value)
        {
            dprintf(" %s", ps->pszname);
        }
        ps++;
    }
    state &= ~ul;
    if (state != 0)
    {
        dprintf(" +%lx!!", state);
    }
    dprintf("\n");
}

DUMP_ROUTINE( DumpVmcb);
DUMP_ROUTINE( DumpFileObject);    
DUMP_ROUTINE( DumpAnyStruct);


VOID
PrintHelp (
    VOID
    );

//
//  NULL dump function means just do DT with type.
//

NODE_TYPE_INFO_NEW NewNodeTypeCodes[] = {

    //  RO UDFS
    
    {   UDFS_NTC_DATA_HEADER,       "UDFS DATA",            "Udfs!UDF_DATA",       DumpUdfData},
    {   UDFS_NTC_VCB,               "UDFS VCB",             "Udfs!VCB",            DumpUdfVcb},
    {   UDFS_NTC_FCB_INDEX,         "UDFS FCB (INDEX)",     "Udfs!FCB",            DumpUdfFcb},
    {   UDFS_NTC_FCB_DATA,          "UDFS FCB (DATA) ",     "Udfs!FCB",            DumpUdfFcb},
    {   UDFS_NTC_FCB_NONPAGED,      "UDFS FCB (nonpaged)",  "Udfs!FCB_NONPAGED",   NULL},
    {   UDFS_NTC_CCB,               "UDFS CCB",             "Udfs!CCB",            DumpUdfCcb},
    {   UDFS_NTC_IRP_CONTEXT,       "UDFS IRPCONTEXT",      "Udfs!IRP_CONTEXT",    DumpUdfIrpContext},
    {   UDFS_NTC_IRP_CONTEXT_LITE,  "UDFS IRPCONTEXT LITE", "Udfs!IRP_CONTEXT_LITE",DumpUdfIrpContextLite},
    {   UDFS_NTC_LCB,               "UDFS LCB",             "Udfs!LCB",            DumpUdfLcb},
    {   UDFS_NTC_PCB,               "UDFS PCB",             "Udfs!PCB",            DumpUdfPcb},
    {   UDFS_NTC_VMCB,              "UDFS VMCB",            "Udfs!VMCB",           DumpVmcb},

#ifdef UDFS_RW_IN_BUILD

    //  RW UDFS,  same dump fn.
    
    {   UDFSRW_NTC_DATA_HEADER,     "UDFSRW DATA",            "Udfs!UDF_DATA",       DumpUdfData},
    {   UDFSRW_NTC_IRP_CONTEXT,     "UDFSRW IRPCONTEXT",      "Udfs!IRP_CONTEXT",    DumpUdfIrpContext},
    {   UDFSRW_NTC_IRP_CONTEXT_LITE,"UDFSRW IRPCONTEXT LITE", "Udfs!IRP_CONTEXT_LITE",DumpUdfIrpContextLite},
    {   UDFSRW_NTC_CCB,             "UDFSRW CCB",             "Udfs!CCB",            DumpUdfCcb},
    {   UDFSRW_NTC_LCB,             "UDFSRW LCB",             "Udfs!LCB",            DumpUdfLcb},
    {   UDFSRW_NTC_PCB,             "UDFSRW PCB",             "Udfs!PCB",            DumpUdfPcb},
    {   UDFSRW_NTC_VCB,             "UDFSRW VCB",             "Udfs!VCB",            DumpUdfVcb},
    {   UDFSRW_NTC_VMCB,            "UDFSRW VMCB",            "Udfs!VMCB",           DumpVmcb},
    {   UDFSRW_NTC_FCB,             "UDFSRW FCB",             "Udfs!FCB",            DumpUdfFcb}, // TODO: Dump stream SCB list?
    {   UDFSRW_NTC_FCB_NONPAGED,    "UDFSRW FCB (nonpaged)",  "Udfs!FCB_NONPAGED",   DumpUdfFcb},

    //  RW UDFS specific dump fn.
    
    {   UDFSRW_NTC_SCB_INDEX,       "UDFSRW SCB (INDEX)",     "Udfs!SCB_INDEX_TYPE", DumpUdfScb},
    {   UDFSRW_NTC_SCB_DATA,        "UDFSRW SCB (DATA) ",     "Udfs!SCB_DATA_TYPE",  DumpUdfScb},
    {   UDFSRW_NTC_SCB_NONPAGED,    "UDFSRW SCB (nonpaged)",  "Udfs!SCB_NONPAGED",   NULL},

#endif

    {   FAT_NTC_VCB,                "FAT VCB",              "FastFat!VCB",          DumpFatVcb},
    {   FAT_NTC_FCB,                "FAT FCB",              "FastFat!FCB",          DumpFatFcb},
    {   FAT_NTC_DCB,                "FAT DCB",              "FastFat!FCB",          DumpFatFcb},
    {   FAT_NTC_CCB,                "FAT CCB",              "FastFat!CCB",          DumpFatCcb},
    {   FAT_NTC_ROOT_DCB,           "FAT ROOT DCB",         "FastFat!FCB",          DumpFatFcb},
    {   FAT_NTC_IRP_CONTEXT,        "FAT IRP CONTEXT",      "FastFat!IRP_CONTEXT",  DumpFatIrpContext},
    {   FAT_NTC_DATA_HEADER,        "FAT DATA",             "FastFat!FAT_DATA",     NULL},

    {   CDFS_NTC_DATA_HEADER,       "CDFS DATA",            "Cdfs!CD_DATA",         NULL},
    {   CDFS_NTC_VCB,               "CDFS VCB",             "Cdfs!VCB",             DumpCdVcb},
    {   CDFS_NTC_FCB_PATH_TABLE,    "CDFS FCB (PATH TABLE)","Cdfs!FCB",             DumpCdFcb},
    {   CDFS_NTC_FCB_INDEX,         "CDFS FCB (INDEX)",     "Cdfs!FCB",             DumpCdFcb},
    {   CDFS_NTC_FCB_DATA,          "CDFS FCB (DATA) ",     "Cdfs!FCB",             DumpCdFcb},
    {   CDFS_NTC_FCB_NONPAGED,      "CDFS FCB (nonpaged)",  "Cdfs!FCB_NONPAGED",    NULL},
    {   CDFS_NTC_CCB,               "CDFS CCB",             "Cdfs!CCB",             DumpCdCcb},
    {   CDFS_NTC_IRP_CONTEXT,       "CDFS IRPCONTEXT",      "Cdfs!IRP_CONTEXT",     DumpCdIrpContext},
    {   CDFS_NTC_IRP_CONTEXT_LITE,  "CDFS IRPCONTEXT (LITE)","Cdfs!IRP_CONTEXT_LITE",NULL},


//    {   CACHE_NTC_SHARED_CACHE_MAP, "CC Shared Cache Map",  "nt!SHARED_CACHE_MAP",  NULL},

    {   0,                          "Undefined",            NULL,   NULL}
};


ULONG
SearchTypeCodeIndex (
    IN USHORT TypeCode,
    IN NODE_TYPE_INFO_NEW TypeCodes[]
    )

/*++

Routine Description:

    Guess at a structure's type code

Arguments:

    TypeCode - Type code from the data structure

Return Value:

    None

--*/

{
    int i = 0;

    while (TypeCodes[i].TypeCode != 0 &&
           TypeCodes[i].TypeCode != TypeCode) {

        i++;
    }

    return i;
}

DUMP_ROUTINE( DumpFileObject)
{
    ULONG Result;
    ULONG Flags, Offset;
    USHORT ObType;
    ULONG64 Adr, Scm;

    dprintf( "\nFileObject @ %I64X\n", Address );
    dprintf( "\n[ Options: 1 = dump FsContext & FsContext2,  2 = dump shared cache map ]\n");

    ReadM( &ObType, Address, sizeof( USHORT));

    if (ObType != IO_TYPE_FILE) {

        dprintf( "Invalid signature, probably not a file object" );
        return;
    }

    GetFieldValue( Address, "nt!FILE_OBJECT", "Flags", Flags);
    dprintf("\nFlags: ");
    PrintState( FoFlags, Flags);
    dprintf( "\n" );
    
    Dt( "nt!FILE_OBJECT", Address, 0, 0, NULL);

    dprintf( "\n" );
    GetFieldValue( Address, "nt!FILE_OBJECT", "SectionObjectPointer", Adr);

    if (Adr)  {

        Dt( "nt!SECTION_OBJECT_POINTERS", Adr, 0, 0, NULL);
    }

    GetFieldValue( Adr, "nt!SECTION_OBJECT_POINTERS", "SharedCacheMap", Scm);

    if (Options & 2)  {

        dprintf( "\n" );
        Dt( "nt!SHARED_CACHE_MAP", Scm, 0, 0, NULL);
    }
    
    if (Options & 1)  {
    
        GetFieldValue( Address, "nt!FILE_OBJECT", "FsContext", Adr);
        
        if (Adr) {

            DumpAnyStruct( Adr, 0, NULL);
        }
        
        GetFieldValue( Address, "nt!FILE_OBJECT", "FsContext2", Adr);

        if (Adr)  {
        
            DumpAnyStruct( Adr, 0, NULL);
        }
    }
    
    dprintf( "\n" );
}


DUMP_ROUTINE( DumpVmcb)
{
    ULONG Result;

    ULONG Offset;
    
    dprintf( "\nVMCB @ %I64X\n", Address );

    Dt( "udfs!VMCB", Address, 0, 0, NULL);
    
#ifdef UDFS_RW_IN_BUILD

    if (Options & 2)  {

        USHORT NodeType;

        //
        //  UDFS in Win2k had no nodetype field in the vmcb
        //
        
        if (!GetFieldValue( Address, "udfs!VMCB", "NodeTypeCode", NodeType))  {

            if (NodeType == UDFSRW_NTC_VMCB)  {

                //
                //  Summarize the dirty bitmap,  if
                //  these fields are present.
                //

                // TODO: Dump dirty blocks
            }
        }
    }
#endif

    if (Options & 1)  {

        dprintf("\n\nLbn->Vbn Mappings\n");
        ROE( GetFieldOffset( "udfs!VMCB", "LbnIndexed", &Offset));
        DumpLargeMcb( Address + Offset, Options, NULL);
                    
        dprintf("\nVbn->Lbn Mappings\n");
        ROE( GetFieldOffset( "udfs!VMCB", "VbnIndexed", &Offset));    
        DumpLargeMcb( Address + Offset, Options, NULL);
    }
    
    dprintf("\n");
}



VOID
CountClearBits(
    IN UINT64 Address,
    IN ULONG Length
    )
{
    UCHAR Buffer[2048];
    ULONG Result;
    ULONG ThisBytes;
    ULONG ClearBits = 0;
    ULONG CurrByte;
    
    // address, length

    dprintf("\nCounting clear bits in range 0x%p L 0x%x\n", Address, Length);

    while (Length)  {

        ThisBytes = (Length > sizeof( Buffer)) ? sizeof( Buffer) : Length;

        if ( !ReadMemory( (DWORD_PTR)Address, Buffer, ThisBytes, &Result) ) {
        
            dprintf( "Unable to read %d bytes at %p\n", ThisBytes, Address);
            return;
        }

        for (CurrByte = 0;  CurrByte < ThisBytes;  ++CurrByte)  {

            ClearBits += BitsClearTotal[ Buffer[CurrByte]];
        }

        Address += ThisBytes;
        Length -= ThisBytes;
    }

    dprintf("\n0x%x bits clear.\n\n", ClearBits);
}


VOID CountDwords(
    IN UINT64 Address,
    IN ULONG Length,
    IN ULONG Dword
    )
{
    ULONG Buffer[512];
    ULONG Result;
    ULONG ThisBytes;
    ULONG Count = 0;
    ULONG CurrByte;
    
    // address, length

    dprintf("\nCounting ocurrences of DWORD 0x%x in range 0x%p L 0x%x\n", Dword, Address, Length);

    if (Length & 3)  {
    
        dprintf("Length must be multiple of 4 bytes\n");
        return;
    }

    while (Length)  {

        ThisBytes = (Length > sizeof( Buffer)) ? sizeof( Buffer) : Length;

        if ( !ReadMemory( (DWORD_PTR)Address, Buffer, ThisBytes, &Result) ) {
        
            dprintf( "Unable to read %d bytes at %p\n", ThisBytes, Address);
            return;
        }

        for (CurrByte = 0;  CurrByte < (ThisBytes >> 2);  ++CurrByte)  {

            if (Buffer[ CurrByte] == Dword)  {
            
                ++Count;
            }
        }

        Address += ThisBytes;
        Length -= ThisBytes;
    }

    dprintf("\n0x%x found.\n\n", Count);

}



DUMP_ROUTINE( DumpAnyStruct)
/*++

Routine Description:

    Dump a tagged structure,  guessing based on node type code.

Arguments:

    Address - Gives the address of the structure

Return Value:

    None

--*/
{
    STRUCT_DUMP_ROUTINE Routine;
    ULONG TagAndSize,  *TagAndSizePtr, Result, Error;
    LONG InfoIndex;

    RM( Address, TagAndSize, TagAndSizePtr, PULONG, Result );

    //
    //  Find out what function should be used to dump the stucture (if we can)
    //

    InfoIndex = TypeCodeInfoIndex( (USHORT)(TagAndSize & 0xffff));
    Routine = NodeTypeDumpFunction( InfoIndex);

    if ( 0 == NewNodeTypeCodes[ InfoIndex].TypeCode)  {

        dprintf( "\nNode type %0x%04x unknown.\n", (USHORT)TagAndSize & 0xffff);
        return;
    }

    dprintf("\n%s @ 0x%I64X\n\n", NewNodeTypeCodes[InfoIndex].Text, Address);
    
    if (Routine)  {

        //
        //  And call it...
        //

        (Routine)(Address, Options, &NewNodeTypeCodes[InfoIndex]);
    }
    else {

        //
        //  No special routine - just DT it,  treating first parameter following
        //  address as level of recursion
        //

        Error = Dt( NewNodeTypeCodes[InfoIndex].TypeName, Address, Options, 0, NULL);

        if (Error)  {

            dprintf("Error %d from debugger when dumping structure\n", Error);
        }        
    }
}


DUMP_ROUTINE( DtAnyStruct)
/*++

Routine Description:

    Dump a tagged structure,  guessing based on node type code.

Arguments:

    Address - Gives the address of the structure

Return Value:

    None

--*/
{
    ULONG TagAndSize,  *TagAndSizePtr, Result;
    ULONG Error;
    LONG InfoIndex;
 
    RM( Address, TagAndSize, TagAndSizePtr, PULONG, Result );

    InfoIndex = TypeCodeInfoIndex( (USHORT)(TagAndSize & 0xffff));

    dprintf("\n%s @ 0x%X\n\n", NewNodeTypeCodes[InfoIndex].Text, Address);

    Error = Dt( NewNodeTypeCodes[InfoIndex].TypeName, Address, Options, 0, NULL);

    if (Error)  {

        dprintf("Error %d\n", Error);
    }
}

//
//  Entry points, parameter parsers, etc. below
//

VOID
ParseAndDump (
    IN PCHAR args,
    IN STRUCT_DUMP_ROUTINE DumpFunction,
    ULONG Processor,
    HANDLE hCurrentThread
    )

/*++

Routine Description:

    Parse command line arguments and dump an ntfs structure.

Arguments:

    Args - String of arguments to parse.

    DumpFunction - Function to call with parsed arguments.

Return Value:

    None

--*/

{
    CHAR StringStructToDump[1024];  // See other kd routines for size
    CHAR Dummy[24];
    LARGE_INTEGER StructToDump;
    LONG Options;

    //
    //  If the caller specified an address then that's the item we dump
    //

    StructToDump.QuadPart = 0;
    Options = 0;

    StringStructToDump[0] = '\0';
    
//dprintf("Args %s\n", args);

    sscanf(args,"%s %lx", StringStructToDump, &Options );

//dprintf("GetExpr %s\n", StringStructToDump);

    if (!GetExpressionEx( StringStructToDump, &StructToDump.QuadPart, NULL))  {

        dprintf("GetExpression failed\n");
        return;
    }
    
//dprintf("Getexpr returned %I64X\n", StructToDump.QuadPart);
    
    if (!StructToDump.QuadPart){
        dprintf("unable to get expression %s\n",StringStructToDump);
        return;
    }

    (*DumpFunction) ( StructToDump.QuadPart, Options, NULL );

    dprintf( "\n" );
}



VOID
PrintHelp (
    VOID
    )
{
    int i;

    for( i=0; Extensions[i]; i++ )
        dprintf( "   %s\n", Extensions[i] );
}

DECLARE_API( fshelp )

{
    UNREFERENCED_PARAMETER( args );
    UNREFERENCED_PARAMETER( dwProcessor );
    UNREFERENCED_PARAMETER( dwCurrentPc );
    UNREFERENCED_PARAMETER( hCurrentProcess );
    UNREFERENCED_PARAMETER( hCurrentThread );

    PrintHelp();
}


DECLARE_API( d)
{
    ParseAndDump( (PCHAR) args, (STRUCT_DUMP_ROUTINE) DumpAnyStruct, dwProcessor, hCurrentThread );
}


DECLARE_API( fo)
{
    ParseAndDump( (PCHAR) args, (STRUCT_DUMP_ROUTINE) DumpFileObject, dwProcessor, hCurrentThread );
}


DECLARE_API( vmcb)
{
    ParseAndDump( (PCHAR) args, (STRUCT_DUMP_ROUTINE) DumpVmcb, dwProcessor, hCurrentThread );
}

DECLARE_API( db )
{
    UNREFERENCED_PARAMETER( dwCurrentPc );
    UNREFERENCED_PARAMETER( hCurrentProcess );

    ParseAndDump( (PCHAR) args, (STRUCT_DUMP_ROUTINE) DtAnyStruct, dwProcessor, hCurrentThread );
}


DECLARE_API( countclearbits)
{
    CHAR StringStructToDump[1024];  // See other kd routines for size
    UINT64 StructToDump;
    ULONG Length;

    //
    //  If the caller specified an address then that's the item we dump
    //

    StructToDump = 0;
    Length = 0;

    StringStructToDump[0] = '\0';

    sscanf(args,"%s %lx", StringStructToDump, &Length );

    if (!GetExpressionEx( StringStructToDump, &StructToDump, NULL ))  {
    
        dprintf("unable to get expression %s\n",StringStructToDump);
        return;
    }

    CountClearBits( StructToDump,  Length);
}


DECLARE_API( countdwords)
{
    CHAR StringStructToDump[1024];  // See other kd routines for size
    UINT64 StructToDump;
    ULONG Length;
    ULONG Dword;

    //
    //  If the caller specified an address then that's the item we dump
    //

    StructToDump = 0;
    Length = 0;

    StringStructToDump[0] = '\0';

    sscanf(args,"%s %lx %lx", StringStructToDump, &Length, &Dword);

    if (!GetExpressionEx( StringStructToDump, &StructToDump, NULL))  {
    
        dprintf("unable to get expression %s\n",StringStructToDump);
        return;
    }

    CountDwords( StructToDump,  Length, Dword);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fastfat\tests\tmfatum.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    tfat.c

Abstract:

    Test program for the Fat File system

Author:

    Gary Kimura     [GaryKi]    24-May-1989

Revision History:

--*/

#define BIG

#include <stdio.h>
#include <string.h>
//#include <ctype.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#define toupper(C) ((C) >= 'a' && (C) <= 'z' ? (C) - ('a' - 'A') : (C))
#define isdigit(C) ((C) >= '0' && (C) <= '9')

#define RtlDosPathNameToNtPathName(IN_STR,OUT_STR,FOO,BAR) {           \
    STRING TmpStr;                                                     \
    UNICODE_STRING TmpUStr;                                            \
                                                                       \
    RtlInitString( &TmpStr, (IN_STR) );                                \
    TmpStr.Length++;                                                  \
    RtlAnsiStringToUnicodeString( &TmpUStr, &TmpStr, TRUE );           \
    RtlDosPathNameToNtPathName_U( (PWSTR)TmpUStr.Buffer, (OUT_STR),   \
                                   (FOO),(BAR) );                      \
                                                                       \
    RtlFreeUnicodeString( &TmpUStr );                                  \
}

#ifndef SIMULATOR
ULONG IoInitIncludeDevices;
#endif // SIMULATOR

ULONG Threads;
HANDLE StartSignal;
ULONG Id;

ULONG WriteThrough = FILE_SYNCHRONOUS_IO_ALERT;

#define simprintf(X,Y) {if (!Silent) {DbgPrint(X,Y);} }
BOOLEAN Silent;

//
//  The buffer size must be a multiple of 512
//

#define BUFFERSIZE 1024

HANDLE CurrentProcessHandle;
ULONG LoopCount;
CHAR RootDir[32];
STRING NtRootDir;

VOID
PrintTime (
    IN PLARGE_INTEGER Time
    );

VOID
WaitForSingleObjectError(
    IN NTSTATUS Status
    );

VOID
CreateFileError(
    IN NTSTATUS Status,
    IN PUCHAR File
    );

VOID
OpenFileError(
    IN NTSTATUS Status,
    IN PUCHAR File
    );

VOID
ReadFileError(
    IN NTSTATUS Status,
    IN PUCHAR File
    );

VOID
WriteFileError(
    IN NTSTATUS Status,
    IN PUCHAR File
    );

VOID
CheckIoStatus(
    IN PIO_STATUS_BLOCK IoStatus,
    IN ULONG Length,
    IN BOOLEAN Read
    );

VOID
SetInformationFileError(
    IN NTSTATUS Status
    );

VOID
QueryInformationFileError(
    IN NTSTATUS Status
    );

VOID
SetVolumeInformationFileError(
    IN NTSTATUS Status
    );

VOID
QueryVolumeInformationFileError(
    IN NTSTATUS Status
    );

VOID
CloseError(
    IN NTSTATUS Status,
    IN PUCHAR File
    );

VOID
IoStatusError(
    IN NTSTATUS Status
    );

VOID
CreateThreadError(
    IN NTSTATUS Status
    );

VOID
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    NTSTATUS Status;
    ULONG i;
    VOID FatMain();
    LARGE_INTEGER DelayTime;

    LARGE_INTEGER Time;
    TIME_FIELDS TimeFields;

    NtQuerySystemTime(&Time);
    RtlTimeToTimeFields( &Time, &TimeFields );
    Id = 100 * (TimeFields.Minute +
         100 * (TimeFields.Hour +
         100 * TimeFields.Day));

    CurrentProcessHandle = NtCurrentProcess();
    Status = STATUS_SUCCESS;

    if (argc > 1) {
        strcpy( RootDir, argv[1]);
    } else {
        DbgPrint("usage: %s RootDir [itterations] [threads] [writethrough]\n", argv[0]);
        return;
    }


    if (argc > 2) {
        LoopCount = 0;
        for (i = 0; isdigit(argv[2][i]); i += 1) {
            LoopCount = LoopCount * 10 + (ULONG)(argv[2][i] - '0');
        }
    } else {
        LoopCount = 1;
    }

    if (argc > 3) {
        Threads = 0;
        for (i = 0; isdigit(argv[3][i]); i += 1) {
            Threads = Threads * 10 + (ULONG)(argv[3][i] - '0');
        }
    } else {
        Threads = 1;
    }

    if (argc > 4) {
        WriteThrough |= FILE_WRITE_THROUGH;
    }

    if (toupper(RootDir[0]) != RootDir[0]) {
        RootDir[0] = (CHAR)toupper(RootDir[0]);
        Silent = TRUE;
    } else {
        Silent = FALSE;
    }

    //
    //  Initialize my starting signal
    //

    NtCreateEvent(
        &StartSignal,
        EVENT_ALL_ACCESS,
        NULL,
        NotificationEvent,
        FALSE);

    //
    //  Create a bunch of threads to run FatMain
    //

    for (i=0; i< Threads; i++) {
        if (!NT_SUCCESS(Status = RtlCreateUserThread(
                                    CurrentProcessHandle,
                                    NULL,
                                    FALSE,
                                    0,
                                    0,
                                    0,
                                    (PUSER_THREAD_START_ROUTINE)FatMain,
                                    NULL,
                                    NULL,
                                    NULL))) {
            CreateThreadError( Status );
            return;
        }
    }

    DelayTime.HighPart = -1;
    DelayTime.LowPart = -10*1000*1000*1;

    DbgPrint( "Wait 1 second for all thread to get ready .....");
    NtDelayExecution(FALSE, &DelayTime);
    DbgPrint( "Notifying %d threads to go.\n", Threads);

    NtSetEvent( StartSignal, NULL );


    NtTerminateThread(NtCurrentThread(), STATUS_SUCCESS);

//    DbgPrint( "Exiting User Mode Test Program with Status = %lx\n", Status );
//    NtTerminateProcess( CurrentProcessHandle, Status );
}

VOID
FatMain()
{
    VOID Upcase();
    VOID Append(),Chmode(),Copy(),Create(),DebugLevel(),Delete();
    VOID Directory(),Mkdir(),Query(),QVolume(),Rename();
    VOID SVolume(),Type(),Quit();

    CHAR Str[64];
    CHAR Str2[64];
    CHAR LoopStr[64];
    CHAR Prefix[64];
    ULONG i, MyId;
    NTSTATUS Status;

    //
    // Get our id and wait for wakeup
    //

    MyId = Id++;

    if (!NT_SUCCESS(Status = NtWaitForSingleObject( StartSignal, TRUE, NULL))) {
        WaitForSingleObjectError( Status );
        return;
    }

    strcpy( Prefix, RootDir ); // "\\A:\\";

    RtlIntegerToChar( MyId, 10, -8, &Str[0] );
    Str[8] = 0;

    strcat( Prefix, Str );

    DbgPrint("FatMain %s:%d %08l \n\n", Prefix, LoopCount, MyId);

    Mkdir( Prefix );
//    Directory( Prefix );

    for (i = 0; i < LoopCount; i += 1) {

        strcpy(LoopStr, "Start loop xxxxxxxx ");
        RtlIntegerToChar(i, 16, -8, &LoopStr[11]);
        strcat( LoopStr, Prefix );
        DbgPrint(LoopStr);
        DbgPrint("\n");

        //
        //  Create new log
        //

        strcpy( Str2, "\\" ); RtlIntegerToChar(i, 16, -8, &Str2[1]); Str2[9] = 0;
        strcpy( Str, Prefix ); Create( strcat( Str, Str2 ), i);

        //
        //  Delete last log file if i > 0
        //

        if (i > 0) {
            strcpy( Str2, "\\" ); RtlIntegerToChar(i-1, 16, -8, &Str2[1]); Str2[9] = 0;
            strcpy( Str, Prefix ); Delete( strcat( Str, Str2 ) );
        }

        //
        //  Create some new files
        //

        DbgPrint( "%s: Creating ....\n", Prefix );
        strcpy( Str, Prefix ); Create( strcat( Str, "\\0.tmp" ),   0 );
        strcpy( Str, Prefix ); Create( strcat( Str, "\\1.tmp" ),   1 );
        strcpy( Str, Prefix ); Create( strcat( Str, "\\511.tmp" ), 511 );
        strcpy( Str, Prefix ); Create( strcat( Str, "\\512.tmp" ), 512 );
        strcpy( Str, Prefix ); Create( strcat( Str, "\\513.tmp" ), 513 );
        strcpy( Str, Prefix ); Create( strcat( Str, "\\1023.tmp" ), 1023 );
        strcpy( Str, Prefix ); Create( strcat( Str, "\\1024.tmp" ), 1024 );
        strcpy( Str, Prefix ); Create( strcat( Str, "\\1025.tmp" ), 1025 );
        strcpy( Str, Prefix ); Create( strcat( Str, "\\4095.tmp" ), 4095 );
        strcpy( Str, Prefix ); Create( strcat( Str, "\\4096.tmp" ), 4096 );
        strcpy( Str, Prefix ); Create( strcat( Str, "\\4097.tmp" ), 4097 );
        strcpy( Str, Prefix ); Create( strcat( Str, "\\8191.tmp" ), 8191 );
        strcpy( Str, Prefix ); Create( strcat( Str, "\\8192.tmp" ), 8192 );
        strcpy( Str, Prefix ); Create( strcat( Str, "\\8193.tmp" ), 8193 );
#ifdef BIG
        strcpy( Str, Prefix ); Create( strcat( Str, "\\40970.tmp" ), 40970 );
        strcpy( Str, Prefix ); Create( strcat( Str, "\\81910.tmp" ), 81910 );
        strcpy( Str, Prefix ); Create( strcat( Str, "\\409700.tmp" ), 409700 );
#endif

//        Directory( Prefix );

        DbgPrint( "%s: Copying ....\n", Prefix );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str,    "\\0.tmp" ), strcat( Str2,    "\\0.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str,    "\\1.tmp" ), strcat( Str2,    "\\1.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str,  "\\511.tmp" ), strcat( Str2,  "\\511.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str,  "\\512.tmp" ), strcat( Str2,  "\\512.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str,  "\\513.tmp" ), strcat( Str2,  "\\513.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str, "\\1023.tmp" ), strcat( Str2, "\\1023.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str, "\\1024.tmp" ), strcat( Str2, "\\1024.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str, "\\1025.tmp" ), strcat( Str2, "\\1025.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str, "\\4095.tmp" ), strcat( Str2, "\\4095.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str, "\\4096.tmp" ), strcat( Str2, "\\4096.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str, "\\4097.tmp" ), strcat( Str2, "\\4097.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str, "\\8191.tmp" ), strcat( Str2, "\\8191.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str, "\\8192.tmp" ), strcat( Str2, "\\8192.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str, "\\8193.tmp" ), strcat( Str2, "\\8193.tmq" ) );
#ifdef BIG
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str, "\\40970.tmp" ), strcat( Str2, "\\40970.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str, "\\81910.tmp" ), strcat( Str2, "\\81910.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str, "\\409700.tmp" ), strcat( Str2, "\\409700.tmq" ) );
#endif

//        Directory( Prefix );

        DbgPrint( "%s: Appending ....\n", Prefix );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str,    "\\0.tmp" ), strcat( Str2,    "\\0.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str,    "\\1.tmp" ), strcat( Str2,    "\\1.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str,  "\\511.tmp" ), strcat( Str2,  "\\511.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str,  "\\512.tmp" ), strcat( Str2,  "\\512.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str,  "\\513.tmp" ), strcat( Str2,  "\\513.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str, "\\1023.tmp" ), strcat( Str2, "\\1023.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str, "\\1024.tmp" ), strcat( Str2, "\\1024.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str, "\\1025.tmp" ), strcat( Str2, "\\1025.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str, "\\4095.tmp" ), strcat( Str2, "\\4095.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str, "\\4096.tmp" ), strcat( Str2, "\\4096.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str, "\\4097.tmp" ), strcat( Str2, "\\4097.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str, "\\8191.tmp" ), strcat( Str2, "\\8191.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str, "\\8192.tmp" ), strcat( Str2, "\\8192.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str, "\\8193.tmp" ), strcat( Str2, "\\8193.tmq" ) );
#ifdef BIG
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str, "\\40970.tmp" ), strcat( Str2, "\\40970.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str, "\\81910.tmp" ), strcat( Str2, "\\81910.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str, "\\409700.tmp" ), strcat( Str2, "\\409700.tmq" ) );
#endif

//        Directory( Prefix );

        DbgPrint( "%s: Deleteing ....\n", Prefix );
        strcpy( Str, Prefix ); Delete( strcat( Str,    "\\0.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str,    "\\1.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str,  "\\511.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str,  "\\512.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str,  "\\513.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str, "\\1023.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str, "\\1024.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str, "\\1025.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str, "\\4095.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str, "\\4096.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str, "\\4097.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str, "\\8191.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str, "\\8192.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str, "\\8193.tmp" ) );
#ifdef BIG
        strcpy( Str, Prefix ); Delete( strcat( Str, "\\40970.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str, "\\81910.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str, "\\409700.tmp" ) );
#endif

//        Directory( Prefix );

    }

    DbgPrint( "%s: Done.\n", Prefix );

    Quit();

    NtTerminateThread(NtCurrentThread(), STATUS_SUCCESS);

    return; // TRUE;

}
#ifdef undef
VOID
FatMain()
{
    NTSTATUS Status;

    //
    // Wait for wakeup
    //

    if (!NT_SUCCESS(Status = NtWaitForSingleObject( StartSignal, TRUE, NULL))) {
        WaitForSingleObjectError( Status );
        return;
    }

    DbgPrint("Here Captain, number 0x%x.\n",
             (ULONG)NtCurrentTeb()->ClientId.UniqueThread);

    NtTerminateThread(NtCurrentThread(), STATUS_SUCCESS);
}
#endif

VOID
Upcase (
    IN OUT PUCHAR String
    )
{
    while (*String != '\0') {
        *String = (UCHAR)toupper(*String);
        String += 1;
    }
}


VOID Append(
    IN PCHAR FromName,
    IN PCHAR ToName
    )
{
    NTSTATUS Status;
    CHAR Buffer[BUFFERSIZE];

    HANDLE FromFileHandle;
    HANDLE ToFileHandle;

    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING NameString;
    IO_STATUS_BLOCK IoStatus;

    LARGE_INTEGER ByteOffset;
    LARGE_INTEGER EofOffset;
    ULONG LogLsn;

    simprintf("Append ", 0);
    simprintf(FromName, 0);
    simprintf(" ", 0);
    simprintf(ToName, 0);
    simprintf("\n", 0);

    //
    //  Open the From file for read access
    //

//    RtlInitString( &NameString, FromName );

    RtlDosPathNameToNtPathName( FromName, &NameString, NULL, NULL );

    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtOpenFile( &FromFileHandle,
                               FILE_READ_DATA,
                               &ObjectAttributes,
                               &IoStatus,
                               0L,
                               WriteThrough ))) {
        OpenFileError( Status, FromName );
        return;
    }

    RtlFreeUnicodeString( &NameString );

    //
    //  Open the To file for write access
    //

//    RtlInitString( &NameString, ToName );

    RtlDosPathNameToNtPathName( ToName, &NameString, NULL, NULL );

    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtOpenFile( &ToFileHandle,
                               FILE_WRITE_DATA,
                               &ObjectAttributes,
                               &IoStatus,
                               0L,
                               WriteThrough ))) {
        OpenFileError( Status, ToName );
        return;
    }

    RtlFreeUnicodeString( &NameString );

    //
    //  Now append the files
    //

    ByteOffset = LiFromLong( 0 );
    EofOffset = LiFromLong( FILE_WRITE_TO_END_OF_FILE );

    for (LogLsn = 0; TRUE; LogLsn += BUFFERSIZE/512) {

        ULONG ReadLength;

        //
        //  Read the next logical sectors in
        //

        ByteOffset.LowPart = LogLsn * 512;

        if (!NT_SUCCESS(Status = NtReadFile( FromFileHandle,
                                 (HANDLE)NULL,
                                 (PIO_APC_ROUTINE)NULL,
                                 (PVOID)NULL,
                                 &IoStatus,
                                 Buffer,
                                 BUFFERSIZE,
                                 &ByteOffset,
                                 (PULONG) NULL ))) {
            if (Status == STATUS_END_OF_FILE) {
                break;
            }
            ReadFileError( Status, FromName );
            break;
        }

        //
        //  Check how the read turned out
        //

        if (IoStatus.Status == STATUS_END_OF_FILE) {
            break;
        }
        CheckIoStatus( &IoStatus, BUFFERSIZE, TRUE );
        if (!NT_SUCCESS(IoStatus.Status)) {
            break;
        }

        //
        //  Append the sectors to the To file
        //

        ReadLength = IoStatus.Information;
        if (!NT_SUCCESS(Status = NtWriteFile( ToFileHandle,
                                  (HANDLE)NULL,
                                  (PIO_APC_ROUTINE)NULL,
                                  (PVOID)NULL,
                                  &IoStatus,
                                  Buffer,
                                  IoStatus.Information,
                                  &EofOffset,
                                  (PULONG) NULL ))) {
            WriteFileError( Status, ToName );
            return;
        }

        //
        //  Check how the write turned out
        //

        CheckIoStatus( &IoStatus, ReadLength, FALSE );
        if (!NT_SUCCESS(IoStatus.Status)) {
            IoStatusError( IoStatus.Status );
            break;
        }

        //
        //  If we didn't read or write a full buffer then the copy is done
        //

        if (IoStatus.Information < BUFFERSIZE) {
            break;
        }

    }

    if (!NT_SUCCESS(IoStatus.Status) && (IoStatus.Status != STATUS_END_OF_FILE)) {

        IoStatusError( IoStatus.Status );

    }

    //
    //  Close both files
    //

    if (!NT_SUCCESS(Status = NtClose( FromFileHandle ))) {
        CloseError( Status, FromName );
    }

    if (!NT_SUCCESS(Status = NtClose( ToFileHandle ))) {
        CloseError( Status, ToName );
    }

    //
    //  And return to our caller
    //

    return;

}


VOID Chmode(
    IN PCHAR Attrib,
    IN PCHAR String
    )
{
    CHAR Buffer[BUFFERSIZE];
    NTSTATUS Status;

    HANDLE FileHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING NameString;
    IO_STATUS_BLOCK IoStatus;

    ULONG FileAttribute;

    //
    //  Get the attribute
    //

    Upcase( (PUCHAR)Attrib );

    //
    //  Get the filename
    //

    simprintf("Chmode", 0);
    simprintf(String, 0);
    simprintf(" ", 0);
    simprintf(Attrib, 0);
    simprintf("\n", 0);

    //
    //  Decode the attributes
    //

    FileAttribute = 0;
    if (strpbrk(Attrib,"N") != NULL) {FileAttribute |= FILE_ATTRIBUTE_NORMAL;}
    if (strpbrk(Attrib,"R") != NULL) {FileAttribute |= FILE_ATTRIBUTE_READONLY;}
    if (strpbrk(Attrib,"H") != NULL) {FileAttribute |= FILE_ATTRIBUTE_HIDDEN;}
    if (strpbrk(Attrib,"S") != NULL) {FileAttribute |= FILE_ATTRIBUTE_SYSTEM;}
    if (strpbrk(Attrib,"A") != NULL) {FileAttribute |= FILE_ATTRIBUTE_ARCHIVE;}

    //
    //  Open the file for write attributes access
    //

//    RtlInitString( &NameString, String );

    RtlDosPathNameToNtPathName( String, &NameString, NULL, NULL );

    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtOpenFile( &FileHandle,
                               FILE_WRITE_ATTRIBUTES,
                               &ObjectAttributes,
                               &IoStatus,
                               0L,
                               WriteThrough ))) {
        OpenFileError( Status, String );
        return;
    }

    //
    //  Change the file attributes
    //

    ((PFILE_BASIC_INFORMATION)&Buffer[0])->CreationTime.HighPart = 0;
    ((PFILE_BASIC_INFORMATION)&Buffer[0])->CreationTime.LowPart = 0;

    ((PFILE_BASIC_INFORMATION)&Buffer[0])->LastAccessTime.HighPart = 0;
    ((PFILE_BASIC_INFORMATION)&Buffer[0])->LastAccessTime.LowPart = 0;

    ((PFILE_BASIC_INFORMATION)&Buffer[0])->LastWriteTime.HighPart = 0;
    ((PFILE_BASIC_INFORMATION)&Buffer[0])->LastWriteTime.LowPart = 0;

    ((PFILE_BASIC_INFORMATION)&Buffer[0])->FileAttributes = FileAttribute;

    if (!NT_SUCCESS(Status = NtSetInformationFile( FileHandle,
                                       &IoStatus,
                                       Buffer,
                                       sizeof(FILE_BASIC_INFORMATION),
                                       FileBasicInformation))) {
        SetInformationFileError( Status );
    }

    //
    //  Now close the file
    //

    if (!NT_SUCCESS(Status = NtClose( FileHandle ))) {
        CloseError( Status, String );
    }

    //
    //  And return to our caller
    //

    RtlFreeUnicodeString( &NameString );

    return;

}


VOID Copy(
    IN PCHAR FromName,
    IN PCHAR ToName
    )
{
    CHAR Buffer[BUFFERSIZE];
    NTSTATUS Status;

    HANDLE FromFileHandle;
    HANDLE ToFileHandle;

    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING NameString;
    IO_STATUS_BLOCK IoStatus;

    LARGE_INTEGER FromFileAllocation;

    LARGE_INTEGER ByteOffset;
    ULONG LogLsn;

    //
    //  Get both file names
    //

    simprintf("Copy ", 0);
    simprintf(FromName, 0);
    simprintf(" ", 0);
    simprintf(ToName, 0);
    simprintf("\n", 0);

    //
    //  Open the From file for read access
    //

//    RtlInitString( &NameString, FromName );

    RtlDosPathNameToNtPathName( FromName, &NameString, NULL, NULL );

    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtOpenFile( &FromFileHandle,
                               FILE_READ_DATA | FILE_READ_ATTRIBUTES,
                               &ObjectAttributes,
                               &IoStatus,
                               0L,
                               WriteThrough ))) {
        OpenFileError( Status, FromName );
        return;
    }

    RtlFreeUnicodeString( &NameString );

    //
    //  Get the size of the from file
    //

    if (!NT_SUCCESS(Status = NtQueryInformationFile( FromFileHandle,
                                         &IoStatus,
                                         Buffer,
                                         BUFFERSIZE,
                                         FileStandardInformation))) {
        QueryInformationFileError( Status );
        return;
    }
    FromFileAllocation = ((PFILE_STANDARD_INFORMATION)Buffer)->AllocationSize;

    //
    //  Create the To file
    //

//    RtlInitString( &NameString, ToName );

    RtlDosPathNameToNtPathName( ToName, &NameString, NULL, NULL );

    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtCreateFile( &ToFileHandle,
                               FILE_WRITE_DATA,
                               &ObjectAttributes,
                               &IoStatus,
                               &FromFileAllocation,
                               FILE_ATTRIBUTE_NORMAL,
                               0L,
                               FILE_SUPERSEDE,
                               WriteThrough,
                               (PVOID)NULL,
                               0L ))) {
        CreateFileError( Status, ToName );
        return;
    }

    RtlFreeUnicodeString( &NameString );

    //
    //  Now copy the files
    //

    ByteOffset = LiFromLong( 0 );

    for (LogLsn = 0; TRUE; LogLsn += BUFFERSIZE/512) {

        ULONG ReadLength;

        //
        //  Read the next logical sectors in
        //

        ByteOffset.LowPart = LogLsn * 512;

        if (!NT_SUCCESS(Status = NtReadFile( FromFileHandle,
                                 (HANDLE)NULL,
                                 (PIO_APC_ROUTINE)NULL,
                                 (PVOID)NULL,
                                 &IoStatus,
                                 Buffer,
                                 BUFFERSIZE,
                                 &ByteOffset,
                                 (PULONG) NULL ))) {
            if (Status == STATUS_END_OF_FILE) {
                break;
            }
            ReadFileError( Status, FromName );
            break;
        }

        //
        //  Check how the read turned out
        //

        if (IoStatus.Status == STATUS_END_OF_FILE) {
            break;
        }
        CheckIoStatus( &IoStatus, BUFFERSIZE, TRUE );
        if (!NT_SUCCESS(IoStatus.Status)) {
            break;
        }

        //
        //  Write the sectors out
        //

        ReadLength = IoStatus.Information;
        if (!NT_SUCCESS(Status = NtWriteFile( ToFileHandle,
                                  (HANDLE)NULL,
                                  (PIO_APC_ROUTINE)NULL,
                                  (PVOID)NULL,
                                  &IoStatus,
                                  Buffer,
                                  IoStatus.Information,
                                  &ByteOffset,
                                  (PULONG) NULL ))) {
            WriteFileError( Status, ToName );
            return;
        }

        //
        //  Check how the write turned out
        //

        CheckIoStatus( &IoStatus, ReadLength, FALSE );
        if (!NT_SUCCESS(IoStatus.Status)) {
            IoStatusError( IoStatus.Status );
            break;
        }

        //
        //  If we didn't read or write a full buffer then the copy is done
        //

        if (IoStatus.Information < BUFFERSIZE) {
            break;
        }

    }

    if (!NT_SUCCESS(IoStatus.Status) && (IoStatus.Status != STATUS_END_OF_FILE)) {

        IoStatusError( IoStatus.Status );

    }

    //
    //  Close both files
    //

    if (!NT_SUCCESS(Status = NtClose( FromFileHandle ))) {
        CloseError( Status, FromName );
    }

    if (!NT_SUCCESS(Status = NtClose( ToFileHandle ))) {
        CloseError( Status, ToName );
    }

    //
    //  And return to our caller
    //

    return;

}


VOID Create(
    IN PCHAR String,
    IN ULONG Size
    )
{
    CHAR Buffer[BUFFERSIZE];
    NTSTATUS Status;

    HANDLE FileHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING NameString;
    IO_STATUS_BLOCK IoStatus;
    LARGE_INTEGER AllocationSize;

    LARGE_INTEGER ByteOffset;
    ULONG BufferLength;
    ULONG i;

    static CHAR FoxString[] = "The quick brown fox jumped over the lazy dog.\r\n";
    ULONG FoxLength;

    //
    //  Get the filename
    //

    simprintf("Create ", 0);
    simprintf(String, 0);
    simprintf("\n", 0);

    //
    //  Create the new file
    //

    AllocationSize = LiFromUlong( Size );
//    RtlInitString( &NameString, String );

    RtlDosPathNameToNtPathName( String, &NameString, NULL, NULL );

    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtCreateFile( &FileHandle,
                               FILE_WRITE_DATA,
                               &ObjectAttributes,
                               &IoStatus,
                               &AllocationSize,
                               FILE_ATTRIBUTE_NORMAL,
                               0L,
                               FILE_SUPERSEDE,
                               WriteThrough,
                               (PVOID)NULL,
                               0L ))) {
        CreateFileError( Status, String );
        return;
    }

    //
    //  create a test buffer to output
    //

    FoxLength = strlen(FoxString);
    for (i = FoxLength; i < BUFFERSIZE; i += FoxLength) {
        strcpy((PCHAR)&Buffer[i-FoxLength], FoxString);
    }
    BufferLength = i - FoxLength;

    //
    //  The main loop writes out the test buffer a BufferLength amount
    //  at a time
    //

    ByteOffset = LiFromLong( 0 );

    for (i = BufferLength; i < Size; i += BufferLength) {

        //
        //  Write the next buffer
        //

        ByteOffset.LowPart = i-BufferLength;

        if (!NT_SUCCESS(Status = NtWriteFile( FileHandle,
                                  (HANDLE)NULL,
                                  (PIO_APC_ROUTINE)NULL,
                                  (PVOID)NULL,
                                  &IoStatus,
                                  Buffer,
                                  BufferLength,
                                  &ByteOffset,
                                  (PULONG) NULL ))) {
            WriteFileError( Status, String );
            return;
        }

        //
        //  check how the write turned out
        //

        CheckIoStatus( &IoStatus, BufferLength, FALSE );
        if (!NT_SUCCESS(IoStatus.Status)) {
            IoStatusError( IoStatus.Status );
            break;
        }

    }

    //
    //  Check for a residual to output
    //

    if (i - BufferLength < Size) {

        //
        //  Write out the residual buffer
        //

        ByteOffset.LowPart = i-BufferLength;

        if (!NT_SUCCESS(Status = NtWriteFile( FileHandle,
                                  (HANDLE)NULL,
                                  (PIO_APC_ROUTINE)NULL,
                                  (PVOID)NULL,
                                  &IoStatus,
                                  Buffer,
                                  Size - (i - BufferLength),
                                  &ByteOffset,
                                  (PULONG) NULL ))) {
            WriteFileError( Status, String );
            return;
        }

        //
        //  check how the write turned out
        //

        CheckIoStatus( &IoStatus, Size - (i - BufferLength), FALSE );
        if (!NT_SUCCESS(IoStatus.Status)) {
            IoStatusError( IoStatus.Status );
        }

    }

    //
    //  Now close the file
    //

    if (!NT_SUCCESS(Status = NtClose( FileHandle ))) {
        CloseError( Status, String );
    }

    //
    //  And return to our caller
    //

    RtlFreeUnicodeString( &NameString );

    return;

}


VOID DebugLevel()
{

#ifdef FATDBG
    //simprintf("Debug Trace Level %x\n", FatDebugTraceLevel);
#else
    //simprintf("System not compiled for debug tracing\n", 0);
#endif // FATDBG

    return;
}


VOID Delete(
    IN PCHAR String
    )
{
    CHAR Buffer[BUFFERSIZE];
    NTSTATUS Status;

    HANDLE FileHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING NameString;
    IO_STATUS_BLOCK IoStatus;

    //
    //  Get the filename
    //

    simprintf("Delete ", 0);
    simprintf(String, 0);
    simprintf("\n", 0);

    //
    //  Open the file for delete access
    //

//    RtlInitString( &NameString, String );

    RtlDosPathNameToNtPathName( String, &NameString, NULL, NULL );

    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtCreateFile( &FileHandle,
                               DELETE,
                               &ObjectAttributes,
                               &IoStatus,
                               (PLARGE_INTEGER)NULL,
                               0L,
                               0L,
                               FILE_OPEN,
                               WriteThrough,
                               (PVOID)NULL,
                               0L ))) {
        CreateFileError( Status, String );
        return;
    }

    //
    //  Mark the file for delete
    //

    ((PFILE_DISPOSITION_INFORMATION)&Buffer[0])->DeleteFile = TRUE;

    if (!NT_SUCCESS(Status = NtSetInformationFile( FileHandle,
                                       &IoStatus,
                                       Buffer,
                                       sizeof(FILE_DISPOSITION_INFORMATION),
                                       FileDispositionInformation))) {
        SetInformationFileError( Status );
        return;
    }

    //
    //  Now close the file
    //

    if (!NT_SUCCESS(Status = NtClose( FileHandle ))) {
        CloseError( Status, String );
    }

    //
    //  And return to our caller
    //

    RtlFreeUnicodeString( &NameString );

    return;

}


VOID Directory(
    IN PCHAR String
    )
{
    CHAR Buffer[BUFFERSIZE];
    NTSTATUS Status;

    HANDLE FileHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING NameString;
    IO_STATUS_BLOCK IoStatus;

    NTSTATUS NtStatus;

    PFILE_ADIRECTORY_INFORMATION FileInfo;
//    ULONG i;

    //
    //  Get the filename
    //

    simprintf("Directory ", 0);
    simprintf(String, 0);
    simprintf("\n", 0);

    //
    //  Open the file for list directory access
    //

//    RtlInitString( &NameString, String );

    RtlDosPathNameToNtPathName( String, &NameString, NULL, NULL );

    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtOpenFile( &FileHandle,
                               FILE_LIST_DIRECTORY,
                               &ObjectAttributes,
                               &IoStatus,
                               FILE_SHARE_READ,
                               WriteThrough | FILE_DIRECTORY_FILE ))) {
        OpenFileError( Status, String );
        return;
    }

    //
    //  zero out the buffer so next time we'll recognize the end of data
    //

    RtlZeroMemory(Buffer, BUFFERSIZE);

    //
    //  Do the directory loop
    //

    for (NtStatus = NtQueryDirectoryFile( FileHandle,
                                          (HANDLE)NULL,
                                          (PIO_APC_ROUTINE)NULL,
                                          (PVOID)NULL,
                                          &IoStatus,
                                          Buffer,
                                          BUFFERSIZE,
                                          FileADirectoryInformation,
                                          FALSE,
                                          (PSTRING)NULL,
                                          TRUE);
         NT_SUCCESS(NtStatus);
         NtStatus = NtQueryDirectoryFile( FileHandle,
                                          (HANDLE)NULL,
                                          (PIO_APC_ROUTINE)NULL,
                                          (PVOID)NULL,
                                          &IoStatus,
                                          Buffer,
                                          BUFFERSIZE,
                                          FileADirectoryInformation,
                                          FALSE,
                                          (PSTRING)NULL,
                                          FALSE) ) {

        //
        //  Check the Irp for success
        //

        if (!NT_SUCCESS(IoStatus.Status)) {

            break;

        }

        //
        //  For every record in the buffer type out the directory information
        //

        //
        //  Point to the first record in the buffer, we are guaranteed to have
        //  one otherwise IoStatus would have been No More Files
        //

        FileInfo = (PFILE_ADIRECTORY_INFORMATION)&Buffer[0];

        while (TRUE) {

            //
            //  Lets put in some checks to make sure these are ok.
            //

            ASSERT(FileInfo->FileNameLength < MAXIMUM_FILENAME_LENGTH);
            ASSERT(FileInfo->NextEntryOffset < MAXIMUM_FILENAME_LENGTH+sizeof(FILE_ADIRECTORY_INFORMATION)+4);

            //
            //  Print out information about the file
            //

            simprintf("%8lx ", FileInfo->FileAttributes);
            simprintf("%8lx/", FileInfo->EndOfFile.LowPart);
            simprintf("%8lx ", FileInfo->AllocationSize.LowPart);

            {
                CHAR Saved;
                Saved = FileInfo->FileName[FileInfo->FileNameLength];
                FileInfo->FileName[FileInfo->FileNameLength] = 0;
                simprintf(FileInfo->FileName, 0);
                FileInfo->FileName[FileInfo->FileNameLength] = Saved;
            }

            simprintf("\n", 0);

            //
            //  Check if there is another record, if there isn't then we
            //  simply get out of this loop
            //

            if (FileInfo->NextEntryOffset == 0) {
                break;
            }

            //
            //  There is another record so advance FileInfo to the next
            //  record
            //

            FileInfo = (PFILE_ADIRECTORY_INFORMATION)(((PUCHAR)FileInfo) + FileInfo->NextEntryOffset);

        }

        //
        //  zero out the buffer so next time we'll recognize the end of data
        //

        RtlZeroMemory(Buffer, BUFFERSIZE);

    }

    //
    //  Now close the file
    //

    if (!NT_SUCCESS(Status = NtClose( FileHandle ))) {
        CloseError( Status, String );
    }

    //
    //  And return to our caller
    //

    RtlFreeUnicodeString( &NameString );

    return;

}


VOID Mkdir(
    IN PCHAR String
    )
{
    NTSTATUS Status;

    HANDLE FileHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING NameString;
    IO_STATUS_BLOCK IoStatus;
    LARGE_INTEGER AllocationSize;

    //
    //  Get the filename
    //

    simprintf("Mkdir ", 0);
    simprintf(String, 0);
    simprintf("\n", 0);

    //
    //  Create the new directory
    //

    AllocationSize = LiFromLong( 4 );
//    RtlInitString( &NameString, String );

    RtlDosPathNameToNtPathName( String, &NameString, NULL, NULL );

    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtCreateFile( &FileHandle,
                               0,
                               &ObjectAttributes,
                               &IoStatus,
                               &AllocationSize,
                               0L,
                               0L,
                               FILE_CREATE,
                               WriteThrough | FILE_DIRECTORY_FILE,
                               (PVOID)NULL,
                               0L ))) {
        CreateFileError( Status, String );
        return;
    }

    //
    //  Now close the directory
    //

    if (!NT_SUCCESS(Status = NtClose( FileHandle ))) {
        CloseError( Status, String );
    }

    //
    //  And return to our caller
    //

    RtlFreeUnicodeString( &NameString );

    return;

}


VOID Query(
    IN PCHAR String
    )
{
    CHAR Buffer[BUFFERSIZE];
    NTSTATUS Status;

    HANDLE FileHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING NameString;
    IO_STATUS_BLOCK IoStatus;
    ULONG i;

    PFILE_AALL_INFORMATION     AllInfo;
    PFILE_BASIC_INFORMATION    BasicInfo;
    PFILE_STANDARD_INFORMATION StandardInfo;
    PFILE_INTERNAL_INFORMATION InternalInfo;
    PFILE_EA_INFORMATION       EaInfo;
    PFILE_ACCESS_INFORMATION   AccessInfo;
    PFILE_ANAME_INFORMATION    NameInfo;

    //
    //  zero out the buffer so next time we'll recognize the end of data
    //

    for (i = 0; i < BUFFERSIZE; i += 1) { Buffer[i] = 0; }

    //
    //  Set up some local pointers
    //

    AllInfo      = (PFILE_AALL_INFORMATION)Buffer;
    BasicInfo    = &AllInfo->BasicInformation;
    StandardInfo = &AllInfo->StandardInformation;
    InternalInfo = &AllInfo->InternalInformation;
    EaInfo       = &AllInfo->EaInformation;
    AccessInfo   = &AllInfo->AccessInformation;
    NameInfo     = &AllInfo->NameInformation;

    //
    //  Get the filename
    //

    simprintf("Query ", 0);
    simprintf(String, 0);
    simprintf("\n", 0);

    //
    //  Open the file for read attributes, read ea, and read control access
    //

//    RtlInitString( &NameString, String );

    RtlDosPathNameToNtPathName( String, &NameString, NULL, NULL );

    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtOpenFile( &FileHandle,
                               FILE_READ_ATTRIBUTES | FILE_READ_EA | READ_CONTROL,
                               &ObjectAttributes,
                               &IoStatus,
                               0L,
                               WriteThrough ))) {
        OpenFileError( Status, String );
        return;
    }

    //
    //  Query the file
    //

    if (!NT_SUCCESS(Status = NtQueryInformationFile( FileHandle,
                                         &IoStatus,
                                         Buffer,
                                         BUFFERSIZE,
                                         FileAAllInformation))) {
        QueryInformationFileError( Status );
        return;
    }

    //
    //  Output file name information
    //

    simprintf("\"", 0);
    simprintf(NameInfo->FileName, 0);
    simprintf("\"\n", 0);

    //
    //  Output the times
    //

    simprintf(" Create = ", 0); PrintTime( &BasicInfo->CreationTime ); simprintf("\n", 0);
    simprintf(" Access = ", 0); PrintTime( &BasicInfo->LastAccessTime ); simprintf("\n", 0);
    simprintf(" Write  = ", 0); PrintTime( &BasicInfo->LastWriteTime ); simprintf("\n", 0);

    //
    //  Output File size, and allocation size
    //

    simprintf(" Size  = %8lx\n", StandardInfo->EndOfFile.LowPart);
    simprintf(" Alloc = %8lx\n", StandardInfo->AllocationSize.LowPart);

    //
    //  Output File attributes, Device type, link count, and flags
    //

    simprintf(" Attrib  = %8lx\n", BasicInfo->FileAttributes);
//    simprintf(" DevType = %8lx\n", StandardInfo->DeviceType);
    simprintf(" Links   = %8lx\n", StandardInfo->NumberOfLinks);
    simprintf(" Dir     = %8lx\n", StandardInfo->Directory);
    simprintf(" Delete  = %8lx\n", StandardInfo->DeletePending);

    //
    //  Output the index number and ea size
    //

    simprintf(" Index   = %8lx\n", InternalInfo->IndexNumber.LowPart);
    simprintf(" EaSize  = %8lx\n", EaInfo->EaSize);

    //
    //  Output the file access flags
    //

    simprintf(" Flags = %8lx\n", AccessInfo->AccessFlags);

    //
    //  Now close the file
    //

    if (!NT_SUCCESS(Status = NtClose( FileHandle ))) {
        CloseError( Status, String );
    }

    //
    //  And return to our caller
    //

    RtlFreeUnicodeString( &NameString );

    return;

}


VOID QVolume(
    IN PCHAR String
    )
{
    CHAR Buffer[BUFFERSIZE];
    NTSTATUS Status;

    HANDLE FileHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING NameString;
    IO_STATUS_BLOCK IoStatus;
    ULONG i;

    PFILE_FS_AVOLUME_INFORMATION VolumeInfo;

    //
    //  zero out the buffer so next time we'll recognize the end of data
    //

    for (i = 0; i < BUFFERSIZE; i += 1) { Buffer[i] = 0; }

    //
    //  Set up some local pointers
    //

    VolumeInfo = (PFILE_FS_AVOLUME_INFORMATION)Buffer;

    //
    //  Get the volume name
    //

    simprintf("QVolume ", 0);
    simprintf(String, 0);
    simprintf("\n", 0);

    //
    //  Open the Volume for no access
    //

//    RtlInitString( &NameString, String );

    RtlDosPathNameToNtPathName( String, &NameString, NULL, NULL );

    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtOpenFile( &FileHandle,
                               FILE_READ_ATTRIBUTES,
                               &ObjectAttributes,
                               &IoStatus,
                               0L,
                               WriteThrough ))) {
        OpenFileError( Status, String );
        return;
    }

    //
    //  zero out the buffer so next time we'll recognize the end of data
    //

    for (i = 0; i < BUFFERSIZE; i += 1) { Buffer[i] = 0; }

    //
    //  Query the volume info
    //

    if (!NT_SUCCESS(Status = NtQueryVolumeInformationFile( FileHandle,
                                               &IoStatus,
                                               Buffer,
                                               BUFFERSIZE,
                                               FileAFsVolumeInformation))) {
        QueryVolumeInformationFileError( Status );
        return;
    }

    //
    //  Output Volume name information
    //

    simprintf("\"", 0);
    simprintf(VolumeInfo->VolumeLabel, 0);
    simprintf("\"\n", 0);

    //
    //  Output the volume serial number
    //

    simprintf(" SerialNum = %8lx\n", VolumeInfo->VolumeSerialNumber);

    //
    //  Now close the Volume
    //

    if (!NT_SUCCESS(Status = NtClose( FileHandle ))) {
        CloseError( Status, String );
    }

    //
    //  And return to our caller
    //

    RtlFreeUnicodeString( &NameString );

    return;

}


VOID Rename()
{
    //simprintf("Rename not implemented\n", 0);
}


VOID SVolume(
    IN PCHAR String,
    IN PCHAR Label
    )
{
    CHAR Buffer[BUFFERSIZE];
    NTSTATUS Status;

    HANDLE FileHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING NameString;
    IO_STATUS_BLOCK IoStatus;
    ULONG i;

    PFILE_FS_ALABEL_INFORMATION LabelInfo;

    //
    //  zero out the buffer so next time we'll recognize the end of data
    //

    for (i = 0; i < BUFFERSIZE; i += 1) { Buffer[i] = 0; }

    //
    //  Set up some local pointers
    //

    LabelInfo = (PFILE_FS_ALABEL_INFORMATION)Buffer;

    //
    //  Get the volume name, and new label name
    //

    strcpy( LabelInfo->VolumeLabel, Label );

    LabelInfo->VolumeLabelLength = strlen(LabelInfo->VolumeLabel);

    if ((LabelInfo->VolumeLabelLength == 1) &&
        (LabelInfo->VolumeLabel[0] == '.')) {

        LabelInfo->VolumeLabelLength = 0;

    }

    simprintf("SVolume ", 0);
    simprintf(String, 0);
    simprintf(" ", 0);
    simprintf(LabelInfo->VolumeLabel, 0);
    simprintf("\n", 0);

    //
    //  Open the Volume for no access
    //

//    RtlInitString( &NameString, String );

    RtlDosPathNameToNtPathName( String, &NameString, NULL, NULL );

    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtOpenFile( &FileHandle,
                               FILE_WRITE_ATTRIBUTES,
                               &ObjectAttributes,
                               &IoStatus,
                               0L,
                               WriteThrough ))) {
        OpenFileError( Status, String );
        return;
    }

    //
    //  Set the volume info
    //

    if (!NT_SUCCESS(Status = NtSetVolumeInformationFile( FileHandle,
                                             &IoStatus,
                                             LabelInfo,
                                             BUFFERSIZE,
                                             FileAFsLabelInformation))) {
        SetVolumeInformationFileError( Status );
        return;
    }

    //
    //  Now close the Volume
    //

    if (!NT_SUCCESS(Status = NtClose( FileHandle ))) {
        CloseError( Status, String );
    }

    //
    //  And return to our caller
    //

    RtlFreeUnicodeString( &NameString );

    return;

}


VOID Type(
    IN PCHAR String
    )
{
    CHAR Buffer[BUFFERSIZE];
    NTSTATUS Status;

    HANDLE FileHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING NameString;
    IO_STATUS_BLOCK IoStatus;

    LARGE_INTEGER ByteOffset;
    ULONG LogLsn;
    ULONG i;

    //
    //  Get the filename
    //

    simprintf("Type ", 0);
    simprintf(String, 0);
    simprintf("\n", 0);

    //
    //  Open the file for read
    //

//    RtlInitString( &NameString, String );

    RtlDosPathNameToNtPathName( String, &NameString, NULL, NULL );

    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtOpenFile( &FileHandle,
                               FILE_READ_DATA,
                               &ObjectAttributes,
                               &IoStatus,
                               0L,
                               WriteThrough ))) {
        OpenFileError( Status, String );
        return;
    }

    //
    //  While there is data to be read we'll read a buffer and write it out
    //

    ByteOffset = LiFromLong( 0 );

    for (LogLsn = 0; TRUE; LogLsn += BUFFERSIZE/512) {

        //
        //  Read the next logical sector
        //

        ByteOffset.LowPart = LogLsn * 512;

        if (!NT_SUCCESS(Status = NtReadFile( FileHandle,
                                 (HANDLE)NULL,
                                 (PIO_APC_ROUTINE)NULL,
                                 (PVOID)NULL,
                                 &IoStatus,
                                 Buffer,
                                 BUFFERSIZE,
                                 &ByteOffset,
                                 (PULONG) NULL ))) {
            if (Status == STATUS_END_OF_FILE) {
                break;
            }
            ReadFileError( Status, String );
            break;
        }

        //
        //  check how the read turned out
        //

        if (IoStatus.Status == STATUS_END_OF_FILE) {
            break;
        }
        CheckIoStatus( &IoStatus, BUFFERSIZE, TRUE );
        if (!NT_SUCCESS(IoStatus.Status)) {
            IoStatusError( IoStatus.Status );
            break;
        }

        //
        //  Write out the buffer
        //

        for (i = 0; i < IoStatus.Information; i += 1) {
            simprintf("%c", Buffer[i]);
        }

        //
        //  If we didn't read in a complete buffer then we're all done reading
        //  and can get out of here
        //

        if (IoStatus.Information < BUFFERSIZE) {
            break;
        }

    }

    //
    //  Now close the file
    //

    if (!NT_SUCCESS(Status = NtClose( FileHandle ))) {
        CloseError( Status, String );
    }

    //
    //  And return to our caller
    //

    RtlFreeUnicodeString( &NameString );

    return;

}

VOID
Quit()
{
    simprintf("FatTest Exiting.\n", 0);
    return;
}


VOID
PrintTime (
    IN PLARGE_INTEGER Time
    )
{
    TIME_FIELDS TimeFields;

    static PCHAR Months[] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun",
                            "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};

    static PCHAR Days[] = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};

    RtlTimeToTimeFields( Time, &TimeFields );

    simprintf(" %4d-", TimeFields.Year);
    simprintf(Months[TimeFields.Month-1], 0);
    simprintf("-%2d", TimeFields.Day);

    simprintf(" %2d", TimeFields.Hour);
    simprintf(":%2d", TimeFields.Minute);
    simprintf(":%2d", TimeFields.Second);
    simprintf(".%3d (", TimeFields.Milliseconds);

    simprintf(Days[TimeFields.Weekday], 0);
    simprintf(")", 0);

    return;
}

VOID
WaitForSingleObjectError(
    IN NTSTATUS Status
    )
{
    DbgPrint(" WaitForSingleObject Error %X\n", Status);
}

VOID
CreateFileError(
    IN NTSTATUS Status,
    IN PUCHAR File
    )
{
    DbgPrint(" CreateFile Error %X on %s\n", Status, File);
}

VOID
OpenFileError(
    IN NTSTATUS Status,
    IN PUCHAR File
    )
{
    DbgPrint(" OpenFile Error %X on %s\n", Status, File);
}

VOID
ReadFileError(
    IN NTSTATUS Status,
    IN PUCHAR File
    )
{
    DbgPrint(" ReadFile Error %X on %s\n", Status, File);
}

VOID
WriteFileError(
    IN NTSTATUS Status,
    IN PUCHAR File
    )
{
    DbgPrint(" WriteFile Error %X on %s\n", Status, File);
}

VOID
CheckIoStatus(
    IN PIO_STATUS_BLOCK IoStatus,
    IN ULONG Length,
    IN BOOLEAN Read
    )
{
    if (!NT_SUCCESS(IoStatus->Status)) {
        DbgPrint(" IoStatus->Status Error %08lx\n", IoStatus->Status);
    }
    if ((!Read && (IoStatus->Information != Length))

            ||

        (Read && (IoStatus->Information > Length))) {

        DbgPrint(" IoStatus->Information Error %08lx\n", IoStatus->Information);
    }
}

VOID
SetInformationFileError(
    IN NTSTATUS Status
    )
{
    DbgPrint(" SetInfoFile Error %X\n", Status);
}

VOID
QueryInformationFileError(
    IN NTSTATUS Status
    )
{
    DbgPrint(" QueryInfoFile Error %X\n", Status);
}

VOID
SetVolumeInformationFileError(
    IN NTSTATUS Status
    )
{
    DbgPrint(" SetVolumeInfoFile Error %X\n", Status);
}

VOID
QueryVolumeInformationFileError(
    IN NTSTATUS Status
    )
{
    DbgPrint(" QueryVolumeInfoFile Error %X\n", Status);
}

VOID
CloseError(
    IN NTSTATUS Status,
    IN PUCHAR File
    )
{
    DbgPrint(" Close Error %8lx on %s\n", Status, File);
}

VOID
IoStatusError(
    IN NTSTATUS Status
    )
{
    DbgPrint(" IoStatus Error %8lx\n", Status);
}

VOID
CreateThreadError(
    IN NTSTATUS Status
    )
{
   DbgPrint(" CreateThread Error %8lx\n", Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fastfat\tests\tfatwinn.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    tfat.c

Abstract:

    Test program for the Fat File system

Author:

    Gary Kimura     [GaryKi]    24-May-1989

Revision History:

--*/

#include <stdio.h>
#include <string.h>

#define toupper(C) ((C) >= 'a' && (C) <= 'z' ? (C) - ('a' - 'A') : (C))
#define isdigit(C) ((C) >= '0' && (C) <= '9')

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#define simprintf(X,Y) {if (!Silent) {printf(X,Y);} }
BOOLEAN Silent;

//
//  The buffer size must be a multiple of 512
//

#define BUFFERSIZE 1024
UCHAR Buffer[BUFFERSIZE];

CHAR Prefix[64];

ULONG WriteThrough = 0;

VOID
WaitForSingleObjectError(
    IN NTSTATUS Status
    );

VOID
CreateFileError(
    IN NTSTATUS Status,
    PCHAR File
    );

VOID
OpenFileError(
    IN NTSTATUS Status,
    PCHAR File
    );

VOID
ReadFileError(
    IN NTSTATUS Status
    );

VOID
WriteFileError(
    IN NTSTATUS Status
    );

VOID
CheckIoStatus(
    IN PIO_STATUS_BLOCK IoStatus,
    IN ULONG Length,
    IN BOOLEAN Read
    );

VOID
SetInformationFileError(
    IN NTSTATUS Status
    );

VOID
QueryInformationFileError(
    IN NTSTATUS Status
    );

VOID
CloseError(
    IN NTSTATUS Status
    );

VOID
IoStatusError(
    IN NTSTATUS Status
    );

VOID
main(
    int argc,
    char *argv[]
    )
{
    ULONG i;
    ULONG Count;
    VOID FatMain();
    CHAR Device[8];
    STRING NtDevice;
    CHAR NtDeviceBuffer[32];

    if (argc <= 1) {

        printf("usage: %s drive: [iterations [writethrough] ]\n", argv[0]);
        return;
    }

    //
    //  Decode the device/drive
    //

    strcpy( Device, argv[1] );

    NtDevice.MaximumLength = NtDevice.Length = 32;
    NtDevice.Buffer = NtDeviceBuffer;

    if (!RtlDosPathNameToNtPathName( Device, &NtDevice, NULL, NULL )) {
        printf( "Invalid Dos Device Name\n" );
        RtlFreeHeap(RtlProcessHeap(), 0, NtDevice.Buffer);
        return;
    }

    if (NtDevice.Length > 31) {
        NtDevice.Length = 31;
    }

    NtDevice.Buffer[NtDevice.Length] = 0;

    //
    //  Now do the iteration count
    //

    if (argc >= 3) {
        Count = 0;
        for (i = 0; isdigit(argv[2][i]); i += 1) {
            Count = Count * 10 + argv[2][i] - '0';
        }
    } else {
        Count = 1;
    }

    //
    //  Check for write through
    //

    if (argc >= 4) {
        WriteThrough = FILE_WRITE_THROUGH;
    }

    //
    //  Check for silent operation
    //

    if (toupper(Device[0]) != Device[0]) {
        Silent = TRUE;
    } else {
        Silent = FALSE;
    }

    //
    //  Do the work
    //

    FatMain(Count, NtDevice.Buffer);

    RtlFreeHeap(RtlProcessHeap(), 0, NtDevice.Buffer);

    return;
}


VOID
FatMain(
    IN ULONG LoopCount,
    IN CHAR Device[]
    )
{
    VOID Create(),Delete(),Mkdir(),Directory(),Read();

    CHAR Str[64];
    CHAR LoopStr[64];
    ULONG i;
    LARGE_INTEGER Time;

    printf("FatMain %d\n", LoopCount);

    NtQuerySystemTime(&Time);
    strcpy( Prefix, Device);
    Prefix[48] = 0;
    RtlIntegerToChar((ULONG)NtCurrentTeb()->ClientId.UniqueProcess, 16, -8, &Prefix[strlen(Device)]);

    Mkdir( Prefix );
    Directory( Device );
    Directory( Prefix );

    for (i = 0; i < LoopCount; i += 1) {

        NtQuerySystemTime(&Time);
        strcpy(LoopStr, "Start loop xxxxxxxx ");
        RtlIntegerToChar(i, 16, -8, &LoopStr[11]);
        strcat( LoopStr, Prefix );
        printf(LoopStr);
        printf("\n");

        strcpy( Str, Prefix ); Create( strcat( Str,     "\\1.tmp" ), Time.LowPart,     1 );
        strcpy( Str, Prefix ); Create( strcat( Str,     "\\2.tmp" ), Time.LowPart,     2 );
        strcpy( Str, Prefix ); Create( strcat( Str,     "\\4.tmp" ), Time.LowPart,     4 );
        strcpy( Str, Prefix ); Create( strcat( Str,     "\\8.tmp" ), Time.LowPart,     8 );
        strcpy( Str, Prefix ); Create( strcat( Str,    "\\16.tmp" ), Time.LowPart,    16 );
        strcpy( Str, Prefix ); Create( strcat( Str,    "\\32.tmp" ), Time.LowPart,    32 );
        strcpy( Str, Prefix ); Create( strcat( Str,    "\\64.tmp" ), Time.LowPart,    64 );
        strcpy( Str, Prefix ); Create( strcat( Str,   "\\128.tmp" ), Time.LowPart,   128 );
        strcpy( Str, Prefix ); Create( strcat( Str,   "\\236.tmp" ), Time.LowPart,   256 );
        strcpy( Str, Prefix ); Create( strcat( Str,   "\\512.tmp" ), Time.LowPart,   512 );
        strcpy( Str, Prefix ); Create( strcat( Str,  "\\1024.tmp" ), Time.LowPart,  1024 );
        strcpy( Str, Prefix ); Create( strcat( Str,  "\\2048.tmp" ), Time.LowPart,  2048 );
        strcpy( Str, Prefix ); Create( strcat( Str,  "\\4096.tmp" ), Time.LowPart,  4096 );
        strcpy( Str, Prefix ); Create( strcat( Str,  "\\8192.tmp" ), Time.LowPart,  8192 );
        strcpy( Str, Prefix ); Create( strcat( Str, "\\16384.tmp" ), Time.LowPart, 16384 );
        strcpy( Str, Prefix ); Create( strcat( Str, "\\32768.tmp" ), Time.LowPart, 32768 );

        strcpy( Str, Prefix ); Read( strcat( Str,     "\\1.tmp" ), Time.LowPart,     1 );
        strcpy( Str, Prefix ); Read( strcat( Str,     "\\2.tmp" ), Time.LowPart,     2 );
        strcpy( Str, Prefix ); Read( strcat( Str,     "\\4.tmp" ), Time.LowPart,     4 );
        strcpy( Str, Prefix ); Read( strcat( Str,     "\\8.tmp" ), Time.LowPart,     8 );
        strcpy( Str, Prefix ); Read( strcat( Str,    "\\16.tmp" ), Time.LowPart,    16 );
        strcpy( Str, Prefix ); Read( strcat( Str,    "\\32.tmp" ), Time.LowPart,    32 );
        strcpy( Str, Prefix ); Read( strcat( Str,    "\\64.tmp" ), Time.LowPart,    64 );
        strcpy( Str, Prefix ); Read( strcat( Str,   "\\128.tmp" ), Time.LowPart,   128 );
        strcpy( Str, Prefix ); Read( strcat( Str,   "\\236.tmp" ), Time.LowPart,   256 );
        strcpy( Str, Prefix ); Read( strcat( Str,   "\\512.tmp" ), Time.LowPart,   512 );
        strcpy( Str, Prefix ); Read( strcat( Str,  "\\1024.tmp" ), Time.LowPart,  1024 );
        strcpy( Str, Prefix ); Read( strcat( Str,  "\\2048.tmp" ), Time.LowPart,  2048 );
        strcpy( Str, Prefix ); Read( strcat( Str,  "\\4096.tmp" ), Time.LowPart,  4096 );
        strcpy( Str, Prefix ); Read( strcat( Str,  "\\8192.tmp" ), Time.LowPart,  8192 );
        strcpy( Str, Prefix ); Read( strcat( Str, "\\16384.tmp" ), Time.LowPart, 16384 );
        strcpy( Str, Prefix ); Read( strcat( Str, "\\32768.tmp" ), Time.LowPart, 32768 );

        Directory( Device );
        Directory( Prefix );

        strcpy( Str, Prefix ); Delete( strcat( Str,     "\\1.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str,     "\\2.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str,     "\\4.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str,     "\\8.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str,    "\\16.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str,    "\\32.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str,    "\\64.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str,   "\\128.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str,   "\\236.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str,   "\\512.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str,  "\\1024.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str,  "\\2048.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str,  "\\4096.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str,  "\\8192.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str, "\\16384.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str, "\\32768.tmp" ) );

        Directory( Device );
        Directory( Prefix );
    }

    printf( "Done\n" );

    return;
}


VOID Create(
    IN PCHAR FileName,
    IN ULONG FileTime,
    IN ULONG FileCount
    )
{
    NTSTATUS Status;

    HANDLE FileHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    STRING NameString;
    IO_STATUS_BLOCK IoStatus;
    LARGE_INTEGER AllocationSize;

    LARGE_INTEGER ByteOffset;
    ULONG Count;

    ULONG Pattern[3];

    //
    //  Get the filename
    //

    simprintf("Create ", 0); simprintf(FileName, 0); simprintf("\n", 0);

    //
    //  Create the new file
    //

    AllocationSize = LiFromUlong( FileCount * 4 );
    RtlInitString( &NameString, FileName );
    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtCreateFile( &FileHandle,
                                           FILE_WRITE_DATA | SYNCHRONIZE,
                                           &ObjectAttributes,
                                           &IoStatus,
                                           &AllocationSize,
                                           FILE_ATTRIBUTE_NORMAL,
                                           0L,
                                           FILE_SUPERSEDE,
                                           WriteThrough,
                                           (PVOID)NULL,
                                           0L ))) {
        CreateFileError( Status , FileName );
        return;
    }

    //
    //  The main loop writes out the test pattern our test pattern
    //  is <FileTime> <FileSize> <Count> where count is the current
    //  iteration count for the current test pattern output.
    //

    Pattern[0] = FileTime;
    Pattern[1] = FileCount;

    for (Count = 0; Count < FileCount; Count += 1) {

        Pattern[2] = Count;

        ByteOffset = LiFromUlong( Count * 3 * 4 );

        if (!NT_SUCCESS(Status = NtWriteFile( FileHandle,
                                              (HANDLE)NULL,
                                              (PIO_APC_ROUTINE)NULL,
                                              (PVOID)NULL,
                                              &IoStatus,
                                              Pattern,
                                              3 * 4,
                                              &ByteOffset,
                                              (PULONG) NULL ))) {
            WriteFileError( Status );
            return;
        }

        if (!NT_SUCCESS(Status = NtWaitForSingleObject(FileHandle, TRUE, NULL))) {
            WaitForSingleObjectError( Status );
            return;
        }

        //
        //  check how the write turned out
        //

        CheckIoStatus( &IoStatus, 3 * 4, FALSE );
        if (!NT_SUCCESS(IoStatus.Status)) {
            IoStatusError( IoStatus.Status );
            break;
        }
    }

    //
    //  Now close the file
    //

    if (!NT_SUCCESS(Status = NtClose( FileHandle ))) {
        CloseError( Status );
    }

    //
    //  And return to our caller
    //

    return;
}


VOID Read(
    IN PCHAR FileName,
    IN ULONG FileTime,
    IN ULONG FileCount
    )
{
    NTSTATUS Status;

    HANDLE FileHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    STRING NameString;
    IO_STATUS_BLOCK IoStatus;
    LARGE_INTEGER AllocationSize;

    LARGE_INTEGER ByteOffset;
    ULONG Count;

    ULONG Pattern[3];

    //
    //  Get the filename
    //

    simprintf("Read ", 0); simprintf(FileName, 0); simprintf("\n", 0);

    //
    //  Open the existing file
    //

    AllocationSize = LiFromUlong( FileCount * 4 );
    RtlInitString( &NameString, FileName );
    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtOpenFile( &FileHandle,
                                         FILE_READ_DATA | FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                                         &ObjectAttributes,
                                         &IoStatus,
                                         0L,
                                         WriteThrough ))) {
        OpenFileError( Status, FileName );
        return;
    }

    //
    //  The main loop read in the test pattern our test pattern
    //  is <FileTime> <FileSize> <Count> where count is the current
    //  iteration count for the current test pattern output.
    //

    for (Count = 0; Count < FileCount; Count += 1) {

        ByteOffset = LiFromUlong( Count * 3 * 4 );

        if (!NT_SUCCESS(Status = NtReadFile( FileHandle,
                                             (HANDLE)NULL,
                                             (PIO_APC_ROUTINE)NULL,
                                             (PVOID)NULL,
                                             &IoStatus,
                                             Pattern,
                                             3 * 4,
                                             &ByteOffset,
                                             (PULONG) NULL ))) {

            ReadFileError( Status );
            return;
        }

        if (!NT_SUCCESS(Status = NtWaitForSingleObject(FileHandle, TRUE, NULL))) {
            WaitForSingleObjectError( Status );
            return;
        }

        //
        //  check how the read turned out
        //

        CheckIoStatus( &IoStatus, 3 * 4, TRUE );
        if (!NT_SUCCESS(IoStatus.Status)) {
            IoStatusError( IoStatus.Status );
            break;
        }

        //
        //  Now compare the what we read with what we should have read
        //

        if ((Pattern[0] != FileTime) ||
            (Pattern[1] != FileCount) ||
            (Pattern[2] != Count)) {

            printf("**** Read Error ****\n");
            NtPartyByNumber( 50 );
            return;
        }
    }

    //
    //  Now close the file
    //

    if (!NT_SUCCESS(Status = NtClose( FileHandle ))) {
        CloseError( Status );
    }

    //
    //  And return to our caller
    //

    return;
}


VOID Delete(
    IN PCHAR FileName
    )
{
    NTSTATUS Status;

    HANDLE FileHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    STRING NameString;
    IO_STATUS_BLOCK IoStatus;

    //
    //  Get the filename
    //

    simprintf("Delete ", 0); simprintf(FileName, 0); simprintf("\n", 0);

    //
    //  Open the file for delete access
    //

    RtlInitString( &NameString, FileName );
    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtCreateFile( &FileHandle,
                                           DELETE | SYNCHRONIZE,
                                           &ObjectAttributes,
                                           &IoStatus,
                                           (PLARGE_INTEGER)NULL,
                                           0L,
                                           0L,
                                           FILE_OPEN,
                                           WriteThrough,
                                           (PVOID)NULL,
                                           0L ))) {
        CreateFileError( Status, FileName );
        return;
    }

    //
    //  Mark the file for delete
    //

    ((PFILE_DISPOSITION_INFORMATION)&Buffer[0])->DeleteFile = TRUE;

    if (!NT_SUCCESS(Status = NtSetInformationFile( FileHandle,
                                                   &IoStatus,
                                                   Buffer,
                                                   sizeof(FILE_DISPOSITION_INFORMATION),
                                                   FileDispositionInformation))) {
        SetInformationFileError( Status );
        return;
    }

    //
    //  Now close the file
    //

    if (!NT_SUCCESS(Status = NtClose( FileHandle ))) {
        CloseError( Status );
    }

    //
    //  And return to our caller
    //

    return;
}


VOID Directory(
    IN PCHAR String
    )
{
    NTSTATUS Status;

    HANDLE FileHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    STRING NameString;
    IO_STATUS_BLOCK IoStatus;

    NTSTATUS NtStatus;

    PFILE_ADIRECTORY_INFORMATION FileInfo;
    ULONG i;

    //
    //  Get the filename
    //

    simprintf("Directory ", 0);
    simprintf(String, 0);
    simprintf("\n", 0);

    //
    //  Open the file for list directory access
    //

    RtlInitString( &NameString, String );
    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtOpenFile( &FileHandle,
                               FILE_LIST_DIRECTORY | SYNCHRONIZE,
                               &ObjectAttributes,
                               &IoStatus,
                               FILE_SHARE_READ,
                               WriteThrough | FILE_DIRECTORY_FILE ))) {
        OpenFileError( Status , String );
        return;
    }

    //
    //  zero out the buffer so next time we'll recognize the end of data
    //

    for (i = 0; i < BUFFERSIZE; i += 1) { Buffer[i] = 0; }

    //
    //  Do the directory loop
    //

    for (NtStatus = NtQueryDirectoryFile( FileHandle,
                                          (HANDLE)NULL,
                                          (PIO_APC_ROUTINE)NULL,
                                          (PVOID)NULL,
                                          &IoStatus,
                                          Buffer,
                                          BUFFERSIZE,
                                          FileADirectoryInformation,
                                          FALSE,
                                          (PSTRING)NULL,
                                          TRUE);
         NT_SUCCESS(NtStatus);
         NtStatus = NtQueryDirectoryFile( FileHandle,
                                          (HANDLE)NULL,
                                          (PIO_APC_ROUTINE)NULL,
                                          (PVOID)NULL,
                                          &IoStatus,
                                          Buffer,
                                          BUFFERSIZE,
                                          FileADirectoryInformation,
                                          FALSE,
                                          (PSTRING)NULL,
                                          FALSE) ) {

        if (!NT_SUCCESS(Status = NtWaitForSingleObject(FileHandle, TRUE, NULL))) {
//            NtPartyByNumber(50);
            WaitForSingleObjectError( Status );
            return;
        }

        //
        //  Check the Irp for success
        //

        if (!NT_SUCCESS(IoStatus.Status)) {

            break;

        }

        //
        //  For every record in the buffer type out the directory information
        //

        //
        //  Point to the first record in the buffer, we are guaranteed to have
        //  one otherwise IoStatus would have been No More Files
        //

        FileInfo = (PFILE_ADIRECTORY_INFORMATION)&Buffer[0];

        while (TRUE) {

            //
            //  Print out information about the file
            //

            simprintf("%8lx ", FileInfo->FileAttributes);
            simprintf("%8lx/", FileInfo->EndOfFile.LowPart);
            simprintf("%8lx ", FileInfo->AllocationSize.LowPart);

            {
                CHAR Saved;
                Saved = FileInfo->FileName[FileInfo->FileNameLength];
                FileInfo->FileName[FileInfo->FileNameLength] = 0;
                simprintf(FileInfo->FileName, 0);
                FileInfo->FileName[FileInfo->FileNameLength] = Saved;
            }

            simprintf("\n", 0);

            //
            //  Check if there is another record, if there isn't then we
            //  simply get out of this loop
            //

            if (FileInfo->NextEntryOffset == 0) {
                break;
            }

            //
            //  There is another record so advance FileInfo to the next
            //  record
            //

            FileInfo = (PFILE_ADIRECTORY_INFORMATION)(((PUCHAR)FileInfo) + FileInfo->NextEntryOffset);

        }

        //
        //  zero out the buffer so next time we'll recognize the end of data
        //

        for (i = 0; i < BUFFERSIZE; i += 1) { Buffer[i] = 0; }

    }

    //
    //  Now close the file
    //

    if (!NT_SUCCESS(Status = NtClose( FileHandle ))) {
        CloseError( Status );
    }

    //
    //  And return to our caller
    //

    return;

}


VOID Mkdir(
    IN PCHAR String
    )
{
    NTSTATUS Status;

    HANDLE FileHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    STRING NameString;
    IO_STATUS_BLOCK IoStatus;
    LARGE_INTEGER AllocationSize;

    //
    //  Get the filename
    //

    simprintf("Mkdir ", 0);
    simprintf(String, 0);
    simprintf("\n", 0);

    //
    //  Create the new directory
    //

    AllocationSize = LiFromLong( 4 );
    RtlInitString( &NameString, String );
    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtCreateFile( &FileHandle,
                               SYNCHRONIZE,
                               &ObjectAttributes,
                               &IoStatus,
                               &AllocationSize,
                               0L,
                               0L,
                               FILE_CREATE,
                               WriteThrough | FILE_DIRECTORY_FILE,
                               (PVOID)NULL,
                               0L ))) {
        CreateFileError( Status , String );
        return;
    }

    //
    //  Now close the directory
    //

    if (!NT_SUCCESS(Status = NtClose( FileHandle ))) {
        CloseError( Status );
    }

    //
    //  And return to our caller
    //

    return;
}


VOID WaitForSingleObjectError(NTSTATUS Status)
{ printf("%s WaitForSingleObject Error %X\n", Prefix, Status); }

VOID CreateFileError(NTSTATUS Status, PCHAR File)
{ printf("%s CreateFile of %s Error %X\n", Prefix, File, Status); }

VOID OpenFileError(NTSTATUS Status, PCHAR File)
{ printf("%s OpenFile of %s Error %X\n", Prefix, File, Status); }

VOID ReadFileError(NTSTATUS Status)
{ printf("%s ReadFile Error %X\n", Prefix, Status); }

VOID WriteFileError(NTSTATUS Status)
{ printf("%s WriteFile Error %X\n", Prefix, Status); }

VOID SetInformationFileError(NTSTATUS Status)
{ printf("%s SetInfoFile Error %X\n", Prefix, Status); }

VOID QueryInformationFileError(NTSTATUS Status)
{ printf("%s QueryInfoFile Error %X\n", Prefix, Status); }

VOID CloseError(NTSTATUS Status)
{ printf("%s Close Error %X\n", Prefix, Status); }

VOID IoStatusError(NTSTATUS Status)
{ printf("%s IoStatus Error %X\n", Prefix, Status); }

VOID CheckIoStatus(PIO_STATUS_BLOCK IoStatus, ULONG Length, BOOLEAN Read)
{
    if (!NT_SUCCESS(IoStatus->Status)) {
        printf(" IoStatus->Status Error %08lx\n", IoStatus->Status);
    }
    if ((!Read && (IoStatus->Information != Length))

            ||

        (Read && (IoStatus->Information > Length))) {

        printf(" IoStatus->Information Error %08lx\n", IoStatus->Information);
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fastfat\tests\tfatum.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    tfat.c

Abstract:

    Test program for the Fat File system

Author:

    Gary Kimura     [GaryKi]    24-May-1989

Revision History:

--*/

#include <stdio.h>
#include <string.h>
//#include <ctype.h>
#define toupper(C) ((C) >= 'a' && (C) <= 'z' ? (C) - ('a' - 'A') : (C))
#define isdigit(C) ((C) >= '0' && (C) <= '9')

#include <nt.h>
#include <ntrtl.h>

#ifndef SIMULATOR
ULONG IoInitIncludeDevices;
#endif // SIMULATOR

#define simprintf(X,Y) {if (!Silent) {DbgPrint(X,Y);} }
BOOLEAN Silent;

//
//  The buffer size must be a multiple of 512
//

#define BUFFERSIZE 1024
UCHAR Buffer[BUFFERSIZE];

HANDLE CurrentProcessHandle;
CHAR Prefix[32];

ULONG WriteThrough = 0;

VOID
PrintTime (
    IN PLARGE_INTEGER Time
    );

VOID
WaitForSingleObjectError(
    IN NTSTATUS Status
    );

VOID
CreateFileError(
    IN NTSTATUS Status,
    PCHAR File
    );

VOID
OpenFileError(
    IN NTSTATUS Status,
    PCHAR File
    );

VOID
ReadFileError(
    IN NTSTATUS Status
    );

VOID
WriteFileError(
    IN NTSTATUS Status
    );

VOID
CheckIoStatus(
    IN PIO_STATUS_BLOCK IoStatus,
    IN ULONG Length,
    IN BOOLEAN Read
    );

VOID
SetInformationFileError(
    IN NTSTATUS Status
    );

VOID
QueryInformationFileError(
    IN NTSTATUS Status
    );

VOID
SetVolumeInformationFileError(
    IN NTSTATUS Status
    );

VOID
QueryVolumeInformationFileError(
    IN NTSTATUS Status
    );

VOID
CloseError(
    IN NTSTATUS Status
    );

VOID
IoStatusError(
    IN NTSTATUS Status
    );

VOID
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    NTSTATUS Status;
    ULONG i;
    ULONG Count;
    VOID FatMain();
    CHAR Device[8];

    CurrentProcessHandle = NtCurrentProcess();
    Status = STATUS_SUCCESS;

//    DbgPrint( "Entering User Mode Test Program\n" );

//    DbgPrint( "argc: %ld\n", argc );
//    if (argv != NULL) {
//        for (i=0; i<argc; i++) {
//            DbgPrint( "argv[ %ld ]: %s\n", i, argv[ i ] );
//            }
//        }

//    if (envp != NULL) {
//        i = 0;
//        while (*envp) {
//            DbgPrint( "envp[ %02ld ]: %s\n", i++, *envp++ );
//            }
//        }

    if (argc > 1) {
        Count = 0;
        for (i = 0; isdigit(argv[1][i]); i += 1) {
            Count = Count * 10 + argv[1][i] - '0';
        }
    } else {
        Count = 1;
    }

    if (argc > 2) {
        strcpy( Device, argv[2]);
    } else {
        strcpy( Device, "\\A:\\");
    }

    if (argc > 3) {
        WriteThrough = FILE_WRITE_THROUGH;
    }

    if (toupper(Device[1]) != Device[1]) {
        Device[1] = (CHAR)toupper(Device[1]);
        Silent = TRUE;
    } else {
        Silent = FALSE;
    }

    FatMain(Count, Device);

//    DbgPrint( "Exiting User Mode Test Program with Status = %X\n", Status );

    NtTerminateProcess( CurrentProcessHandle, Status );
}


VOID
FatMain(
    IN ULONG LoopCount,
    IN CHAR Device[]
    )
{
    VOID Upcase();
    VOID Append(),Chmode(),Copy(),Create(),DebugLevel(),Delete();
    VOID Directory(),Mkdir(),Query(),QVolume(),Rename();
    VOID SVolume(),Type(),Quit();

    CHAR Str[64];
    CHAR Str2[64];
    CHAR LoopStr[64];
    ULONG i;
    LARGE_INTEGER Time;

    DbgPrint("FatMain %d\n", LoopCount);

    NtQuerySystemTime(&Time);
    strcpy( Prefix, Device); // "\\A:\\";
    Prefix[12] = 0;
    RtlIntegerToChar((ULONG)NtCurrentTeb()->ClientId.UniqueProcess, 16, -8, &Prefix[4]);

    Mkdir( Prefix );
    Directory( Device );
    Directory( Prefix );

    for (i = 0; i < LoopCount; i += 1) {
        NtQuerySystemTime(&Time);
        strcpy(LoopStr, "Start loop xxxxxxxx ");
        RtlIntegerToChar(i, 16, -8, &LoopStr[11]);
        strcat( LoopStr, Prefix );
        DbgPrint(LoopStr);
        DbgPrint("\n");

        //
        //  Create new log
        //

        strcpy( Str2, "\\" ); RtlIntegerToChar(i, 16, -8, &Str2[1]); Str2[9] = 0;
        strcpy( Str, Prefix ); Create( strcat( Str, Str2 ), i);

        //
        //  Delete last log file if i > 0
        //

        if (i > 0) {
            strcpy( Str2, "\\" ); RtlIntegerToChar(i-1, 16, -8, &Str2[1]); Str2[9] = 0;
            strcpy( Str, Prefix ); Delete( strcat( Str, Str2 ) );
        }

        //
        //  Create some new files
        //

        strcpy( Str, Prefix ); Create( strcat( Str, "\\0.tmp" ),   0 );
        strcpy( Str, Prefix ); Create( strcat( Str, "\\1.tmp" ),   1 );
        strcpy( Str, Prefix ); Create( strcat( Str, "\\511.tmp" ), 511 );
        strcpy( Str, Prefix ); Create( strcat( Str, "\\512.tmp" ), 512 );
        strcpy( Str, Prefix ); Create( strcat( Str, "\\513.tmp" ), 513 );
        strcpy( Str, Prefix ); Create( strcat( Str, "\\1023.tmp" ), 1023 );
        strcpy( Str, Prefix ); Create( strcat( Str, "\\1024.tmp" ), 1024 );
        strcpy( Str, Prefix ); Create( strcat( Str, "\\1025.tmp" ), 1025 );
        strcpy( Str, Prefix ); Create( strcat( Str, "\\4095.tmp" ), 4095 );
        strcpy( Str, Prefix ); Create( strcat( Str, "\\4096.tmp" ), 4096 );
        strcpy( Str, Prefix ); Create( strcat( Str, "\\4097.tmp" ), 4097 );
        strcpy( Str, Prefix ); Create( strcat( Str, "\\8191.tmp" ), 8191 );
        strcpy( Str, Prefix ); Create( strcat( Str, "\\8192.tmp" ), 8192 );
        strcpy( Str, Prefix ); Create( strcat( Str, "\\8193.tmp" ), 8193 );

        Directory( Device );
        Directory( Prefix );

        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str,    "\\0.tmp" ), strcat( Str2,    "\\0.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str,    "\\1.tmp" ), strcat( Str2,    "\\1.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str,  "\\511.tmp" ), strcat( Str2,  "\\511.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str,  "\\512.tmp" ), strcat( Str2,  "\\512.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str,  "\\513.tmp" ), strcat( Str2,  "\\513.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str, "\\1023.tmp" ), strcat( Str2, "\\1023.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str, "\\1024.tmp" ), strcat( Str2, "\\1024.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str, "\\1025.tmp" ), strcat( Str2, "\\1025.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str, "\\4095.tmp" ), strcat( Str2, "\\4095.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str, "\\4096.tmp" ), strcat( Str2, "\\4096.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str, "\\4097.tmp" ), strcat( Str2, "\\4097.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str, "\\8191.tmp" ), strcat( Str2, "\\8191.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str, "\\8192.tmp" ), strcat( Str2, "\\8192.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str, "\\8193.tmp" ), strcat( Str2, "\\8193.tmq" ) );

        Directory( Device );
        Directory( Prefix );

        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str,    "\\0.tmp" ), strcat( Str2,    "\\0.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str,    "\\1.tmp" ), strcat( Str2,    "\\1.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str,  "\\511.tmp" ), strcat( Str2,  "\\511.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str,  "\\512.tmp" ), strcat( Str2,  "\\512.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str,  "\\513.tmp" ), strcat( Str2,  "\\513.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str, "\\1023.tmp" ), strcat( Str2, "\\1023.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str, "\\1024.tmp" ), strcat( Str2, "\\1024.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str, "\\1025.tmp" ), strcat( Str2, "\\1025.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str, "\\4095.tmp" ), strcat( Str2, "\\4095.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str, "\\4096.tmp" ), strcat( Str2, "\\4096.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str, "\\4097.tmp" ), strcat( Str2, "\\4097.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str, "\\8191.tmp" ), strcat( Str2, "\\8191.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str, "\\8192.tmp" ), strcat( Str2, "\\8192.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str, "\\8193.tmp" ), strcat( Str2, "\\8193.tmq" ) );

        Directory( Device );
        Directory( Prefix );

        strcpy( Str, Prefix ); Delete( strcat( Str,    "\\0.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str,    "\\1.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str,  "\\511.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str,  "\\512.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str,  "\\513.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str, "\\1023.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str, "\\1024.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str, "\\1025.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str, "\\4095.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str, "\\4096.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str, "\\4097.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str, "\\8191.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str, "\\8192.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str, "\\8193.tmp" ) );

        Directory( Device );
        Directory( Prefix );

    }

    DbgPrint( "Done\n" );
    NtQuerySystemTime(&Time);

    Quit();

    return; // TRUE;

}

VOID
Upcase (
    IN OUT PUCHAR String
    )
{
    while (*String != '\0') {
        *String = (UCHAR)toupper(*String);
        String += 1;
    }
}


VOID Append(
    IN PCHAR FromName,
    IN PCHAR ToName
    )
{
    NTSTATUS Status;

    HANDLE FromFileHandle;
    HANDLE ToFileHandle;

    OBJECT_ATTRIBUTES ObjectAttributes;
    STRING NameString;
    IO_STATUS_BLOCK IoStatus;

    LARGE_INTEGER ByteOffset;
    LARGE_INTEGER EofOffset;
    ULONG LogLsn;

    simprintf("Append ", 0);
    simprintf(FromName, 0);
    simprintf(" ", 0);
    simprintf(ToName, 0);
    simprintf("\n", 0);

    //
    //  Open the From file for read access
    //

    RtlInitString( &NameString, FromName );
    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtOpenFile( &FromFileHandle,
                               FILE_READ_DATA | SYNCHRONIZE,
                               &ObjectAttributes,
                               &IoStatus,
                               0L,
                               WriteThrough ))) {
        OpenFileError( Status , FromName );
        return;
    }

    //
    //  Open the To file for write access
    //

    RtlInitString( &NameString, ToName );
    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtOpenFile( &ToFileHandle,
                               FILE_WRITE_DATA | SYNCHRONIZE,
                               &ObjectAttributes,
                               &IoStatus,
                               0L,
                               WriteThrough ))) {
        OpenFileError( Status , ToName );
        return;
    }

    //
    //  Now append the files
    //

    ByteOffset = LiFromLong( 0 );
    EofOffset = LiFromLong( FILE_WRITE_TO_END_OF_FILE );

    for (LogLsn = 0; TRUE; LogLsn += BUFFERSIZE/512) {

        ULONG ReadLength;

        //
        //  Read the next logical sectors in
        //

        ByteOffset.LowPart = LogLsn * 512;

        if (!NT_SUCCESS(Status = NtReadFile( FromFileHandle,
                                 (HANDLE)NULL,
                                 (PIO_APC_ROUTINE)NULL,
                                 (PVOID)NULL,
                                 &IoStatus,
                                 Buffer,
                                 BUFFERSIZE,
                                 &ByteOffset,
                                 (PULONG) NULL ))) {
            if (Status == STATUS_END_OF_FILE) {
                break;
            }
            ReadFileError( Status );
            break;
        }
        if (!NT_SUCCESS( Status = NtWaitForSingleObject( FromFileHandle, TRUE, NULL))) {
//            NtPartyByNumber(50);
            WaitForSingleObjectError( Status );
            return;
        }

        //
        //  Check how the read turned out
        //

        if (IoStatus.Status == STATUS_END_OF_FILE) {
            break;
        }
        CheckIoStatus( &IoStatus, BUFFERSIZE, TRUE );
        if (!NT_SUCCESS(IoStatus.Status)) {
            break;
        }

        //
        //  Append the sectors to the To file
        //

        ReadLength = IoStatus.Information;
        if (!NT_SUCCESS(Status = NtWriteFile( ToFileHandle,
                                  (HANDLE)NULL,
                                  (PIO_APC_ROUTINE)NULL,
                                  (PVOID)NULL,
                                  &IoStatus,
                                  Buffer,
                                  IoStatus.Information,
                                  &EofOffset,
                                  (PULONG) NULL ))) {
            WriteFileError( Status );
            return;
        }
        if (!NT_SUCCESS(Status = NtWaitForSingleObject( ToFileHandle, TRUE, NULL))) {
//            NtPartyByNumber(50);
            WaitForSingleObjectError( Status );
            return;
        }

        //
        //  Check how the write turned out
        //

        CheckIoStatus( &IoStatus, ReadLength, FALSE );
        if (!NT_SUCCESS(IoStatus.Status)) {
            IoStatusError( IoStatus.Status );
            break;
        }

        //
        //  If we didn't read or write a full buffer then the copy is done
        //

        if (IoStatus.Information < BUFFERSIZE) {
            break;
        }

    }

    if (!NT_SUCCESS(IoStatus.Status) && (IoStatus.Status != STATUS_END_OF_FILE)) {

        IoStatusError( IoStatus.Status );

    }

    //
    //  Close both files
    //

    if (!NT_SUCCESS(Status = NtClose( FromFileHandle ))) {
        CloseError( Status );
    }

    if (!NT_SUCCESS(Status = NtClose( ToFileHandle ))) {
        CloseError( Status );
    }

    //
    //  And return to our caller
    //

    return;

}


VOID Chmode(
    IN PCHAR Attrib,
    IN PCHAR String
    )
{
    NTSTATUS Status;

    HANDLE FileHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    STRING NameString;
    IO_STATUS_BLOCK IoStatus;

    ULONG FileAttribute;

    //
    //  Get the attribute
    //

    Upcase( (PUCHAR)Attrib );

    //
    //  Get the filename
    //

    simprintf("Chmode", 0);
    simprintf(String, 0);
    simprintf(" ", 0);
    simprintf(Attrib, 0);
    simprintf("\n", 0);

    //
    //  Decode the attributes
    //

    FileAttribute = 0;
    if (strpbrk(Attrib,"N") != NULL) {FileAttribute |= FILE_ATTRIBUTE_NORMAL;}
    if (strpbrk(Attrib,"R") != NULL) {FileAttribute |= FILE_ATTRIBUTE_READONLY;}
    if (strpbrk(Attrib,"H") != NULL) {FileAttribute |= FILE_ATTRIBUTE_HIDDEN;}
    if (strpbrk(Attrib,"S") != NULL) {FileAttribute |= FILE_ATTRIBUTE_SYSTEM;}
    if (strpbrk(Attrib,"A") != NULL) {FileAttribute |= FILE_ATTRIBUTE_ARCHIVE;}

    //
    //  Open the file for write attributes access
    //

    RtlInitString( &NameString, String );
    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtOpenFile( &FileHandle,
                               FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
                               &ObjectAttributes,
                               &IoStatus,
                               0L,
                               WriteThrough ))) {
        OpenFileError( Status , String );
        return;
    }

    //
    //  Change the file attributes
    //

    ((PFILE_BASIC_INFORMATION)&Buffer[0])->CreationTime.HighPart = 0;
    ((PFILE_BASIC_INFORMATION)&Buffer[0])->CreationTime.LowPart = 0;

    ((PFILE_BASIC_INFORMATION)&Buffer[0])->LastAccessTime.HighPart = 0;
    ((PFILE_BASIC_INFORMATION)&Buffer[0])->LastAccessTime.LowPart = 0;

    ((PFILE_BASIC_INFORMATION)&Buffer[0])->LastWriteTime.HighPart = 0;
    ((PFILE_BASIC_INFORMATION)&Buffer[0])->LastWriteTime.LowPart = 0;

    ((PFILE_BASIC_INFORMATION)&Buffer[0])->FileAttributes = FileAttribute;

    if (!NT_SUCCESS(Status = NtSetInformationFile( FileHandle,
                                       &IoStatus,
                                       Buffer,
                                       sizeof(FILE_BASIC_INFORMATION),
                                       FileBasicInformation))) {
        SetInformationFileError( Status );
    }

    //
    //  Now close the file
    //

    if (!NT_SUCCESS(Status = NtClose( FileHandle ))) {
        CloseError( Status );
    }

    //
    //  And return to our caller
    //

    return;

}


VOID Copy(
    IN PCHAR FromName,
    IN PCHAR ToName
    )
{
    NTSTATUS Status;

    HANDLE FromFileHandle;
    HANDLE ToFileHandle;

    OBJECT_ATTRIBUTES ObjectAttributes;
    STRING NameString;
    IO_STATUS_BLOCK IoStatus;

    LARGE_INTEGER FromFileAllocation;

    LARGE_INTEGER ByteOffset;
    ULONG LogLsn;

    //
    //  Get both file names
    //

    simprintf("Copy ", 0);
    simprintf(FromName, 0);
    simprintf(" ", 0);
    simprintf(ToName, 0);
    simprintf("\n", 0);

    //
    //  Open the From file for read access
    //

    RtlInitString( &NameString, FromName );
    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtOpenFile( &FromFileHandle,
                               FILE_READ_DATA | FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                               &ObjectAttributes,
                               &IoStatus,
                               0L,
                               WriteThrough ))) {
        OpenFileError( Status , FromName );
        return;
    }

    //
    //  Get the size of the from file
    //

    if (!NT_SUCCESS(Status = NtQueryInformationFile( FromFileHandle,
                                         &IoStatus,
                                         Buffer,
                                         BUFFERSIZE,
                                         FileStandardInformation))) {
        QueryInformationFileError( Status );
        return;
    }
    FromFileAllocation = ((PFILE_STANDARD_INFORMATION)Buffer)->AllocationSize;

    //
    //  Create the To file
    //

    RtlInitString( &NameString, ToName );
    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtCreateFile( &ToFileHandle,
                               FILE_WRITE_DATA | SYNCHRONIZE,
                               &ObjectAttributes,
                               &IoStatus,
                               &FromFileAllocation,
                               FILE_ATTRIBUTE_NORMAL,
                               0L,
                               FILE_SUPERSEDE,
                               WriteThrough,
                               (PVOID)NULL,
                               0L ))) {
        CreateFileError( Status , ToName );
        return;
    }

    //
    //  Now copy the files
    //

    ByteOffset = LiFromLong( 0 );

    for (LogLsn = 0; TRUE; LogLsn += BUFFERSIZE/512) {

        ULONG ReadLength;

        //
        //  Read the next logical sectors in
        //

        ByteOffset.LowPart = LogLsn * 512;

        if (!NT_SUCCESS(Status = NtReadFile( FromFileHandle,
                                 (HANDLE)NULL,
                                 (PIO_APC_ROUTINE)NULL,
                                 (PVOID)NULL,
                                 &IoStatus,
                                 Buffer,
                                 BUFFERSIZE,
                                 &ByteOffset,
                                 (PULONG) NULL ))) {
            if (Status == STATUS_END_OF_FILE) {
                break;
            }
            ReadFileError( Status );
            break;
        }
        if (!NT_SUCCESS(Status = NtWaitForSingleObject( FromFileHandle, TRUE, NULL))) {
//            NtPartyByNumber(50);
            WaitForSingleObjectError( Status );
            return;
        }

        //
        //  Check how the read turned out
        //

        if (IoStatus.Status == STATUS_END_OF_FILE) {
            break;
        }
        CheckIoStatus( &IoStatus, BUFFERSIZE, TRUE );
        if (!NT_SUCCESS(IoStatus.Status)) {
            break;
        }

        //
        //  Write the sectors out
        //

        ReadLength = IoStatus.Information;
        if (!NT_SUCCESS(Status = NtWriteFile( ToFileHandle,
                                  (HANDLE)NULL,
                                  (PIO_APC_ROUTINE)NULL,
                                  (PVOID)NULL,
                                  &IoStatus,
                                  Buffer,
                                  IoStatus.Information,
                                  &ByteOffset,
                                  (PULONG) NULL ))) {
            WriteFileError( Status );
            return;
        }
        if (!NT_SUCCESS(Status = NtWaitForSingleObject( ToFileHandle, TRUE, NULL))) {
//            NtPartyByNumber(50);
            WaitForSingleObjectError( Status );
            return;
        }

        //
        //  Check how the write turned out
        //

        CheckIoStatus( &IoStatus, ReadLength, FALSE );
        if (!NT_SUCCESS(IoStatus.Status)) {
            IoStatusError( IoStatus.Status );
            break;
        }

        //
        //  If we didn't read or write a full buffer then the copy is done
        //

        if (IoStatus.Information < BUFFERSIZE) {
            break;
        }

    }

    if (!NT_SUCCESS(IoStatus.Status) && (IoStatus.Status != STATUS_END_OF_FILE)) {

        IoStatusError( IoStatus.Status );

    }

    //
    //  Close both files
    //

    if (!NT_SUCCESS(Status = NtClose( FromFileHandle ))) {
        CloseError( Status );
    }

    if (!NT_SUCCESS(Status = NtClose( ToFileHandle ))) {
        CloseError( Status );
    }

    //
    //  And return to our caller
    //

    return;

}


VOID Create(
    IN PCHAR String,
    IN ULONG Size
    )
{
    NTSTATUS Status;

    HANDLE FileHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    STRING NameString;
    IO_STATUS_BLOCK IoStatus;
    LARGE_INTEGER AllocationSize;

    LARGE_INTEGER ByteOffset;
    ULONG BufferLength;
    ULONG i;

    static CHAR FoxString[] = "The quick brown fox jumped over the lazy dog.\r\n";
    ULONG FoxLength;

    //
    //  Get the filename
    //

    simprintf("Create ", 0);
    simprintf(String, 0);
    simprintf("\n", 0);

    //
    //  Create the new file
    //

    AllocationSize = LiFromUlong( Size );
    RtlInitString( &NameString, String );
    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtCreateFile( &FileHandle,
                               FILE_WRITE_DATA | SYNCHRONIZE,
                               &ObjectAttributes,
                               &IoStatus,
                               &AllocationSize,
                               FILE_ATTRIBUTE_NORMAL,
                               0L,
                               FILE_SUPERSEDE,
                               WriteThrough,
                               (PVOID)NULL,
                               0L ))) {
        CreateFileError( Status , String );
        return;
    }

    //
    //  create a test buffer to output
    //

    FoxLength = strlen(FoxString);
    for (i = FoxLength; i < BUFFERSIZE; i += FoxLength) {
        strcpy((PCHAR)&Buffer[i-FoxLength], FoxString);
    }
    BufferLength = i - FoxLength;

    //
    //  The main loop writes out the test buffer a BufferLength amount
    //  at a time
    //

    ByteOffset = LiFromLong( 0 );

    for (i = BufferLength; i < Size; i += BufferLength) {

        //
        //  Write the next buffer
        //

        ByteOffset.LowPart = i-BufferLength;

        if (!NT_SUCCESS(Status = NtWriteFile( FileHandle,
                                  (HANDLE)NULL,
                                  (PIO_APC_ROUTINE)NULL,
                                  (PVOID)NULL,
                                  &IoStatus,
                                  Buffer,
                                  BufferLength,
                                  &ByteOffset,
                                  (PULONG) NULL ))) {
            WriteFileError( Status );
            return;
        }

        if (!NT_SUCCESS(Status = NtWaitForSingleObject( FileHandle, TRUE, NULL))) {
//            NtPartyByNumber(50);
            WaitForSingleObjectError( Status );
            return;
        }

        //
        //  check how the write turned out
        //

        CheckIoStatus( &IoStatus, BufferLength, FALSE );
        if (!NT_SUCCESS(IoStatus.Status)) {
            IoStatusError( IoStatus.Status );
            break;
        }

    }

    //
    //  Check for a residual to output
    //

    if (i - BufferLength < Size) {

        //
        //  Write out the residual buffer
        //

        ByteOffset.LowPart = i-BufferLength;

        if (!NT_SUCCESS(Status = NtWriteFile( FileHandle,
                                  (HANDLE)NULL,
                                  (PIO_APC_ROUTINE)NULL,
                                  (PVOID)NULL,
                                  &IoStatus,
                                  Buffer,
                                  Size - (i - BufferLength),
                                  &ByteOffset,
                                  (PULONG) NULL ))) {
            WriteFileError( Status );
            return;
        }

        if (!NT_SUCCESS(Status = NtWaitForSingleObject( FileHandle, TRUE, NULL))) {
//            NtPartyByNumber(50);
            WaitForSingleObjectError( Status );
            return;
        }

        //
        //  check how the write turned out
        //

        CheckIoStatus( &IoStatus, Size - (i - BufferLength), FALSE );
        if (!NT_SUCCESS(IoStatus.Status)) {
            IoStatusError( IoStatus.Status );
        }

    }

    //
    //  Now close the file
    //

    if (!NT_SUCCESS(Status = NtClose( FileHandle ))) {
        CloseError( Status );
    }

    //
    //  And return to our caller
    //

    return;

}


VOID DebugLevel()
{

#ifdef FATDBG
    //simprintf("Debug Trace Level %x\n", FatDebugTraceLevel);
#else
    //simprintf("System not compiled for debug tracing\n", 0);
#endif // FATDBG

    return;
}


VOID Delete(
    IN PCHAR String
    )
{
    NTSTATUS Status;

    HANDLE FileHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    STRING NameString;
    IO_STATUS_BLOCK IoStatus;

    //
    //  Get the filename
    //

    simprintf("Delete ", 0);
    simprintf(String, 0);
    simprintf("\n", 0);

    //
    //  Open the file for delete access
    //

    RtlInitString( &NameString, String );
    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtCreateFile( &FileHandle,
                               DELETE | SYNCHRONIZE,
                               &ObjectAttributes,
                               &IoStatus,
                               (PLARGE_INTEGER)NULL,
                               0L,
                               0L,
                               FILE_OPEN,
                               WriteThrough,
                               (PVOID)NULL,
                               0L ))) {
        CreateFileError( Status , String);
        return;
    }

    //
    //  Mark the file for delete
    //

    ((PFILE_DISPOSITION_INFORMATION)&Buffer[0])->DeleteFile = TRUE;

    if (!NT_SUCCESS(Status = NtSetInformationFile( FileHandle,
                                       &IoStatus,
                                       Buffer,
                                       sizeof(FILE_DISPOSITION_INFORMATION),
                                       FileDispositionInformation))) {
        SetInformationFileError( Status );
        return;
    }

    //
    //  Now close the file
    //

    if (!NT_SUCCESS(Status = NtClose( FileHandle ))) {
        CloseError( Status );
    }

    //
    //  And return to our caller
    //

    return;

}


VOID Directory(
    IN PCHAR String
    )
{
    NTSTATUS Status;

    HANDLE FileHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    STRING NameString;
    IO_STATUS_BLOCK IoStatus;

    NTSTATUS NtStatus;

    PFILE_ADIRECTORY_INFORMATION FileInfo;
    ULONG i;

    //
    //  Get the filename
    //

    simprintf("Directory ", 0);
    simprintf(String, 0);
    simprintf("\n", 0);

    //
    //  Open the file for list directory access
    //

    RtlInitString( &NameString, String );
    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtOpenFile( &FileHandle,
                               FILE_LIST_DIRECTORY | SYNCHRONIZE,
                               &ObjectAttributes,
                               &IoStatus,
                               FILE_SHARE_READ,
                               WriteThrough | FILE_DIRECTORY_FILE ))) {
        OpenFileError( Status , String );
        return;
    }

    //
    //  zero out the buffer so next time we'll recognize the end of data
    //

    for (i = 0; i < BUFFERSIZE; i += 1) { Buffer[i] = 0; }

    //
    //  Do the directory loop
    //

    for (NtStatus = NtQueryDirectoryFile( FileHandle,
                                          (HANDLE)NULL,
                                          (PIO_APC_ROUTINE)NULL,
                                          (PVOID)NULL,
                                          &IoStatus,
                                          Buffer,
                                          BUFFERSIZE,
                                          FileADirectoryInformation,
                                          FALSE,
                                          (PSTRING)NULL,
                                          TRUE);
         NT_SUCCESS(NtStatus);
         NtStatus = NtQueryDirectoryFile( FileHandle,
                                          (HANDLE)NULL,
                                          (PIO_APC_ROUTINE)NULL,
                                          (PVOID)NULL,
                                          &IoStatus,
                                          Buffer,
                                          BUFFERSIZE,
                                          FileADirectoryInformation,
                                          FALSE,
                                          (PSTRING)NULL,
                                          FALSE) ) {

        if (!NT_SUCCESS(Status = NtWaitForSingleObject(FileHandle, TRUE, NULL))) {
//            NtPartyByNumber(50);
            WaitForSingleObjectError( Status );
            return;
        }

        //
        //  Check the Irp for success
        //

        if (!NT_SUCCESS(IoStatus.Status)) {

            break;

        }

        //
        //  For every record in the buffer type out the directory information
        //

        //
        //  Point to the first record in the buffer, we are guaranteed to have
        //  one otherwise IoStatus would have been No More Files
        //

        FileInfo = (PFILE_ADIRECTORY_INFORMATION)&Buffer[0];

        while (TRUE) {

            //
            //  Print out information about the file
            //

            simprintf("%8lx ", FileInfo->FileAttributes);
            simprintf("%8lx/", FileInfo->EndOfFile.LowPart);
            simprintf("%8lx ", FileInfo->AllocationSize.LowPart);

            {
                CHAR Saved;
                Saved = FileInfo->FileName[FileInfo->FileNameLength];
                FileInfo->FileName[FileInfo->FileNameLength] = 0;
                simprintf(FileInfo->FileName, 0);
                FileInfo->FileName[FileInfo->FileNameLength] = Saved;
            }

            simprintf("\n", 0);

            //
            //  Check if there is another record, if there isn't then we
            //  simply get out of this loop
            //

            if (FileInfo->NextEntryOffset == 0) {
                break;
            }

            //
            //  There is another record so advance FileInfo to the next
            //  record
            //

            FileInfo = (PFILE_ADIRECTORY_INFORMATION)(((PUCHAR)FileInfo) + FileInfo->NextEntryOffset);

        }

        //
        //  zero out the buffer so next time we'll recognize the end of data
        //

        for (i = 0; i < BUFFERSIZE; i += 1) { Buffer[i] = 0; }

    }

    //
    //  Now close the file
    //

    if (!NT_SUCCESS(Status = NtClose( FileHandle ))) {
        CloseError( Status );
    }

    //
    //  And return to our caller
    //

    return;

}


VOID Mkdir(
    IN PCHAR String
    )
{
    NTSTATUS Status;

    HANDLE FileHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    STRING NameString;
    IO_STATUS_BLOCK IoStatus;
    LARGE_INTEGER AllocationSize;

    //
    //  Get the filename
    //

    simprintf("Mkdir ", 0);
    simprintf(String, 0);
    simprintf("\n", 0);

    //
    //  Create the new directory
    //

    AllocationSize = LiFromLong( 4 );
    RtlInitString( &NameString, String );
    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtCreateFile( &FileHandle,
                               SYNCHRONIZE,
                               &ObjectAttributes,
                               &IoStatus,
                               &AllocationSize,
                               0L,
                               0L,
                               FILE_CREATE,
                               WriteThrough | FILE_DIRECTORY_FILE,
                               (PVOID)NULL,
                               0L ))) {
        CreateFileError( Status , String );
        return;
    }

    //
    //  Now close the directory
    //

    if (!NT_SUCCESS(Status = NtClose( FileHandle ))) {
        CloseError( Status );
    }

    //
    //  And return to our caller
    //

    return;

}


VOID Query(
    IN PCHAR String
    )
{
    NTSTATUS Status;

    HANDLE FileHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    STRING NameString;
    IO_STATUS_BLOCK IoStatus;
    ULONG i;

    PFILE_AALL_INFORMATION     AllInfo;
    PFILE_BASIC_INFORMATION    BasicInfo;
    PFILE_STANDARD_INFORMATION StandardInfo;
    PFILE_INTERNAL_INFORMATION InternalInfo;
    PFILE_EA_INFORMATION       EaInfo;
    PFILE_ACCESS_INFORMATION   AccessInfo;
    PFILE_ANAME_INFORMATION    NameInfo;

    //
    //  zero out the buffer so next time we'll recognize the end of data
    //

    for (i = 0; i < BUFFERSIZE; i += 1) { Buffer[i] = 0; }

    //
    //  Set up some local pointers
    //

    AllInfo      = (PFILE_AALL_INFORMATION)Buffer;
    BasicInfo    = &AllInfo->BasicInformation;
    StandardInfo = &AllInfo->StandardInformation;
    InternalInfo = &AllInfo->InternalInformation;
    EaInfo       = &AllInfo->EaInformation;
    AccessInfo   = &AllInfo->AccessInformation;
    NameInfo     = &AllInfo->NameInformation;

    //
    //  Get the filename
    //

    simprintf("Query ", 0);
    simprintf(String, 0);
    simprintf("\n", 0);

    //
    //  Open the file for read attributes, read ea, and read control access
    //

    RtlInitString( &NameString, String );
    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtOpenFile( &FileHandle,
                               FILE_READ_ATTRIBUTES | FILE_READ_EA | READ_CONTROL | SYNCHRONIZE,
                               &ObjectAttributes,
                               &IoStatus,
                               0L,
                               WriteThrough ))) {
        OpenFileError( Status , String );
        return;
    }

    //
    //  Query the file
    //

    if (!NT_SUCCESS(Status = NtQueryInformationFile( FileHandle,
                                         &IoStatus,
                                         Buffer,
                                         BUFFERSIZE,
                                         FileAAllInformation))) {
        QueryInformationFileError( Status );
        return;
    }

    //
    //  Output file name information
    //

    simprintf("\"", 0);
    simprintf(NameInfo->FileName, 0);
    simprintf("\"\n", 0);

    //
    //  Output the times
    //

    simprintf(" Create = ", 0); PrintTime( &BasicInfo->CreationTime ); simprintf("\n", 0);
    simprintf(" Access = ", 0); PrintTime( &BasicInfo->LastAccessTime ); simprintf("\n", 0);
    simprintf(" Write  = ", 0); PrintTime( &BasicInfo->LastWriteTime ); simprintf("\n", 0);

    //
    //  Output File size, and allocation size
    //

    simprintf(" Size  = %8lx\n", StandardInfo->EndOfFile.LowPart);
    simprintf(" Alloc = %8lx\n", StandardInfo->AllocationSize.LowPart);

    //
    //  Output File attributes, Device type, link count, and flags
    //

    simprintf(" Attrib  = %8lx\n", BasicInfo->FileAttributes);
//    simprintf(" DevType = %8lx\n", StandardInfo->DeviceType);
    simprintf(" Links   = %8lx\n", StandardInfo->NumberOfLinks);
    simprintf(" Dir     = %8lx\n", StandardInfo->Directory);
    simprintf(" Delete  = %8lx\n", StandardInfo->DeletePending);

    //
    //  Output the index number and ea size
    //

    simprintf(" Index   = %8lx\n", InternalInfo->IndexNumber.LowPart);
    simprintf(" EaSize  = %8lx\n", EaInfo->EaSize);

    //
    //  Output the file access flags
    //

    simprintf(" Flags = %8lx\n", AccessInfo->AccessFlags);

    //
    //  Now close the file
    //

    if (!NT_SUCCESS(Status = NtClose( FileHandle ))) {
        CloseError( Status );
    }

    //
    //  And return to our caller
    //

    return;

}


VOID QVolume(
    IN PCHAR String
    )
{
    NTSTATUS Status;

    HANDLE FileHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    STRING NameString;
    IO_STATUS_BLOCK IoStatus;
    ULONG i;

    PFILE_FS_AVOLUME_INFORMATION VolumeInfo;

    //
    //  zero out the buffer so next time we'll recognize the end of data
    //

    for (i = 0; i < BUFFERSIZE; i += 1) { Buffer[i] = 0; }

    //
    //  Set up some local pointers
    //

    VolumeInfo = (PFILE_FS_AVOLUME_INFORMATION)Buffer;

    //
    //  Get the volume name
    //

    simprintf("QVolume ", 0);
    simprintf(String, 0);
    simprintf("\n", 0);

    //
    //  Open the Volume for no access
    //

    RtlInitString( &NameString, String );
    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtOpenFile( &FileHandle,
                               FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                               &ObjectAttributes,
                               &IoStatus,
                               0L,
                               WriteThrough ))) {
        OpenFileError( Status , String );
        return;
    }

    //
    //  zero out the buffer so next time we'll recognize the end of data
    //

    for (i = 0; i < BUFFERSIZE; i += 1) { Buffer[i] = 0; }

    //
    //  Query the volume info
    //

    if (!NT_SUCCESS(Status = NtQueryVolumeInformationFile( FileHandle,
                                               &IoStatus,
                                               Buffer,
                                               BUFFERSIZE,
                                               FileAFsVolumeInformation))) {
        QueryVolumeInformationFileError( Status );
        return;
    }

    //
    //  Output Volume name information
    //

    simprintf("\"", 0);
    simprintf(VolumeInfo->VolumeLabel, 0);
    simprintf("\"\n", 0);

    //
    //  Output the volume serial number
    //

    simprintf(" SerialNum = %8lx\n", VolumeInfo->VolumeSerialNumber);

    //
    //  Now close the Volume
    //

    if (!NT_SUCCESS(Status = NtClose( FileHandle ))) {
        CloseError( Status );
    }

    //
    //  And return to our caller
    //

    return;

}


VOID Rename()
{
    //simprintf("Rename not implemented\n", 0);
}


VOID SVolume(
    IN PCHAR String,
    IN PCHAR Label
    )
{
    NTSTATUS Status;

    HANDLE FileHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    STRING NameString;
    IO_STATUS_BLOCK IoStatus;
    ULONG i;

    PFILE_FS_ALABEL_INFORMATION LabelInfo;

    //
    //  zero out the buffer so next time we'll recognize the end of data
    //

    for (i = 0; i < BUFFERSIZE; i += 1) { Buffer[i] = 0; }

    //
    //  Set up some local pointers
    //

    LabelInfo = (PFILE_FS_ALABEL_INFORMATION)Buffer;

    //
    //  Get the volume name, and new label name
    //

    strcpy( LabelInfo->VolumeLabel, Label );

    LabelInfo->VolumeLabelLength = strlen(LabelInfo->VolumeLabel);

    if ((LabelInfo->VolumeLabelLength == 1) &&
        (LabelInfo->VolumeLabel[0] == '.')) {

        LabelInfo->VolumeLabelLength = 0;

    }

    simprintf("SVolume ", 0);
    simprintf(String, 0);
    simprintf(" ", 0);
    simprintf(LabelInfo->VolumeLabel, 0);
    simprintf("\n", 0);

    //
    //  Open the Volume for no access
    //

    RtlInitString( &NameString, String );
    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtOpenFile( &FileHandle,
                               FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
                               &ObjectAttributes,
                               &IoStatus,
                               0L,
                               WriteThrough ))) {
        OpenFileError( Status, String  );
        return;
    }

    //
    //  Set the volume info
    //

    if (!NT_SUCCESS(Status = NtSetVolumeInformationFile( FileHandle,
                                             &IoStatus,
                                             LabelInfo,
                                             BUFFERSIZE,
                                             FileAFsLabelInformation))) {
        SetVolumeInformationFileError( Status );
        return;
    }

    //
    //  Now close the Volume
    //

    if (!NT_SUCCESS(Status = NtClose( FileHandle ))) {
        CloseError( Status );
    }

    //
    //  And return to our caller
    //

    return;

}


VOID Type(
    IN PCHAR String
    )
{
    NTSTATUS Status;

    HANDLE FileHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    STRING NameString;
    IO_STATUS_BLOCK IoStatus;

    LARGE_INTEGER ByteOffset;
    ULONG LogLsn;
    ULONG i;

    //
    //  Get the filename
    //

    simprintf("Type ", 0);
    simprintf(String, 0);
    simprintf("\n", 0);

    //
    //  Open the file for read
    //

    RtlInitString( &NameString, String );
    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtOpenFile( &FileHandle,
                               FILE_READ_DATA | SYNCHRONIZE,
                               &ObjectAttributes,
                               &IoStatus,
                               0L,
                               WriteThrough ))) {
        OpenFileError( Status, String  );
        return;
    }

    //
    //  While there is data to be read we'll read a buffer and write it out
    //

    ByteOffset = LiFromLong( 0 );

    for (LogLsn = 0; TRUE; LogLsn += BUFFERSIZE/512) {

        //
        //  Read the next logical sector
        //

        ByteOffset.LowPart = LogLsn * 512;

        if (!NT_SUCCESS(Status = NtReadFile( FileHandle,
                                 (HANDLE)NULL,
                                 (PIO_APC_ROUTINE)NULL,
                                 (PVOID)NULL,
                                 &IoStatus,
                                 Buffer,
                                 BUFFERSIZE,
                                 &ByteOffset,
                                 (PULONG) NULL ))) {
            if (Status == STATUS_END_OF_FILE) {
                break;
            }
            ReadFileError( Status );
            break;
        }

        if (!NT_SUCCESS(Status = NtWaitForSingleObject( FileHandle, TRUE, NULL))) {
//            NtPartyByNumber(50);
            WaitForSingleObjectError( Status );
            return;
        }

        //
        //  check how the read turned out
        //

        if (IoStatus.Status == STATUS_END_OF_FILE) {
            break;
        }
        CheckIoStatus( &IoStatus, BUFFERSIZE, TRUE );
        if (!NT_SUCCESS(IoStatus.Status)) {
            IoStatusError( IoStatus.Status );
            break;
        }

        //
        //  Write out the buffer
        //

        for (i = 0; i < IoStatus.Information; i += 1) {
            simprintf("%c", Buffer[i]);
        }

        //
        //  If we didn't read in a complete buffer then we're all done reading
        //  and can get out of here
        //

        if (IoStatus.Information < BUFFERSIZE) {
            break;
        }

    }

    //
    //  Now close the file
    //

    if (!NT_SUCCESS(Status = NtClose( FileHandle ))) {
        CloseError( Status );
    }

    //
    //  And return to our caller
    //

    return;

}

VOID
Quit()
{
    simprintf("FatTest Exiting.\n", 0);
    return;
}


VOID
PrintTime (
    IN PLARGE_INTEGER Time
    )
{
    TIME_FIELDS TimeFields;

    static PCHAR Months[] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun",
                            "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};

    static PCHAR Days[] = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};

    RtlTimeToTimeFields( Time, &TimeFields );

    simprintf(" %4d-", TimeFields.Year);
    simprintf(Months[TimeFields.Month-1], 0);
    simprintf("-%2d", TimeFields.Day);

    simprintf(" %2d", TimeFields.Hour);
    simprintf(":%2d", TimeFields.Minute);
    simprintf(":%2d", TimeFields.Second);
    simprintf(".%3d (", TimeFields.Milliseconds);

    simprintf(Days[TimeFields.Weekday], 0);
    simprintf(")", 0);

    return;
}

VOID
WaitForSingleObjectError(
    IN NTSTATUS Status
    )
{
    DbgPrint(Prefix);
    DbgPrint(" WaitForSingleObject Error %X\n", Status);
}

VOID
CreateFileError(
    IN NTSTATUS Status,
    PCHAR File
    )
{
    DbgPrint(Prefix);
    DbgPrint(" CreateFile of %s  Error %X\n", File, Status);
}

VOID
OpenFileError(
    IN NTSTATUS Status,
    PCHAR File
    )
{
    DbgPrint(Prefix);
    DbgPrint(" OpenFile of %s  Error %X\n", File, Status);
}

VOID
ReadFileError(
    IN NTSTATUS Status
    )
{
    DbgPrint(Prefix);
    DbgPrint(" ReadFile Error %X\n", Status);
}

VOID
WriteFileError(
    IN NTSTATUS Status
    )
{
    DbgPrint(Prefix);
    DbgPrint(" WriteFile Error %X\n", Status);
}

VOID
CheckIoStatus(
    IN PIO_STATUS_BLOCK IoStatus,
    IN ULONG Length,
    IN BOOLEAN Read
    )
{
    if (!NT_SUCCESS(IoStatus->Status)) {
        DbgPrint(" IoStatus->Status Error %08lx\n", IoStatus->Status);
    }
    if ((!Read && (IoStatus->Information != Length))

            ||

        (Read && (IoStatus->Information > Length))) {

        DbgPrint(" IoStatus->Information Error %08lx\n", IoStatus->Information);
    }
}

VOID
SetInformationFileError(
    IN NTSTATUS Status
    )
{
    DbgPrint(Prefix);
    DbgPrint(" SetInfoFile Error %X\n", Status);
}

VOID
QueryInformationFileError(
    IN NTSTATUS Status
    )
{
    DbgPrint(Prefix);
    DbgPrint(" QueryInfoFile Error %X\n", Status);
}

VOID
SetVolumeInformationFileError(
    IN NTSTATUS Status
    )
{
    DbgPrint(Prefix);
    DbgPrint(" SetVolumeInfoFile Error %X\n", Status);
}

VOID
QueryVolumeInformationFileError(
    IN NTSTATUS Status
    )
{
    DbgPrint(Prefix);
    DbgPrint(" QueryVolumeInfoFile Error %X\n", Status);
}

VOID
CloseError(
    IN NTSTATUS Status
    )
{
    DbgPrint(Prefix);
    DbgPrint(" Close Error %X\n", Status);
}

VOID
IoStatusError(
    IN NTSTATUS Status
    )
{
    DbgPrint(Prefix);
    DbgPrint(" IoStatus Error %X\n", Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fastfat\tests\tmfatwin.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    tfat.c

Abstract:

    Test program for the Fat File system

Author:

    Gary Kimura     [GaryKi]    24-May-1989

Revision History:

--*/

//#define BIG

#include <stdio.h>
#include <string.h>
//#include <ctype.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#define toupper(C) ((C) >= 'a' && (C) <= 'z' ? (C) - ('a' - 'A') : (C))
#define isdigit(C) ((C) >= '0' && (C) <= '9')

#define RtlDosPathNameToNtPathName(IN_STR,OUT_STR,FOO,BAR) {           \
    STRING TmpStr;                                                     \
    UNICODE_STRING TmpUStr;                                            \
                                                                       \
    RtlInitString( &TmpStr, (IN_STR) );                                \
    TmpStr.Length++;                                                  \
    RtlAnsiStringToUnicodeString( &TmpUStr, &TmpStr, TRUE );           \
    RtlDosPathNameToNtPathName_U( (PWSTR)TmpUStr.Buffer, (OUT_STR),   \
                                   (FOO),(BAR) );                      \
                                                                       \
    RtlFreeUnicodeString( &TmpUStr );                                  \
}

#ifndef SIMULATOR
ULONG IoInitIncludeDevices;
#endif // SIMULATOR

ULONG Threads;
HANDLE StartSignal;
ULONG Id;

ULONG WriteThrough = 0;

#define simprintf(X,Y) {if (!Silent) {printf(X,Y);} }
BOOLEAN Silent;

//
//  The buffer size must be a multiple of 512
//

#define BUFFERSIZE 1024

HANDLE CurrentProcessHandle;
ULONG LoopCount;
CHAR RootDir[32];
STRING NtRootDir;

VOID
PrintTime (
    IN PLARGE_INTEGER Time
    );

VOID
WaitForSingleObjectError(
    IN NTSTATUS Status
    );

VOID
CreateFileError(
    IN NTSTATUS Status,
    IN PUCHAR File
    );

VOID
OpenFileError(
    IN NTSTATUS Status,
    IN PUCHAR File
    );

VOID
ReadFileError(
    IN NTSTATUS Status,
    IN PUCHAR File
    );

VOID
WriteFileError(
    IN NTSTATUS Status,
    IN PUCHAR File
    );

VOID
CheckIoStatus(
    IN PIO_STATUS_BLOCK IoStatus,
    IN ULONG Length,
    IN BOOLEAN Read
    );

VOID
SetInformationFileError(
    IN NTSTATUS Status
    );

VOID
QueryInformationFileError(
    IN NTSTATUS Status
    );

VOID
SetVolumeInformationFileError(
    IN NTSTATUS Status
    );

VOID
QueryVolumeInformationFileError(
    IN NTSTATUS Status
    );

VOID
CloseError(
    IN NTSTATUS Status,
    IN PUCHAR File
    );

VOID
IoStatusError(
    IN NTSTATUS Status
    );

VOID
CreateThreadError(
    IN NTSTATUS Status
    );

VOID
main(
    int argc,
    char *argv[],
    char *envp[]
    )
{
    NTSTATUS Status;
    ULONG i;
    VOID FatMain();
    LARGE_INTEGER DelayTime;

    LARGE_INTEGER Time;
    TIME_FIELDS TimeFields;

    NtQuerySystemTime(&Time);
    RtlTimeToTimeFields( &Time, &TimeFields );
    Id = 100 * (TimeFields.Minute +
         100 * (TimeFields.Hour +
         100 * TimeFields.Day));

    CurrentProcessHandle = NtCurrentProcess();
    Status = STATUS_SUCCESS;

    if (argc > 1) {
        strcpy( RootDir, argv[1]);
    } else {
        printf("usage: %s RootDir [itterations] [threads] [writethrough]\n", argv[0]);
        return;
    }


    if (argc > 2) {
        LoopCount = 0;
        for (i = 0; isdigit(argv[2][i]); i += 1) {
            LoopCount = LoopCount * 10 + (ULONG)(argv[2][i] - '0');
        }
    } else {
        LoopCount = 1;
    }

    if (argc > 3) {
        Threads = 0;
        for (i = 0; isdigit(argv[3][i]); i += 1) {
            Threads = Threads * 10 + (ULONG)(argv[3][i] - '0');
        }
    } else {
        Threads = 1;
    }

    if (argc > 4) {
        WriteThrough = FILE_WRITE_THROUGH;
    }

    if (toupper(RootDir[0]) != RootDir[0]) {
        RootDir[0] = (CHAR)toupper(RootDir[0]);
        Silent = TRUE;
    } else {
        Silent = FALSE;
    }

    //
    //  Initialize my starting signal
    //

    NtCreateEvent(
        &StartSignal,
        EVENT_ALL_ACCESS,
        NULL,
        NotificationEvent,
        FALSE);

    //
    //  Create a bunch of threads to run FatMain
    //

    for (i=0; i< Threads; i++) {
        if (!NT_SUCCESS(Status = RtlCreateUserThread(
                                    CurrentProcessHandle,
                                    NULL,
                                    FALSE,
                                    0,
                                    0,
                                    0,
                                    (PUSER_THREAD_START_ROUTINE)FatMain,
                                    NULL,
                                    NULL,
                                    NULL))) {
            CreateThreadError( Status );
            return;
        }
    }

    DelayTime.HighPart = -1;
    DelayTime.LowPart = -10*1000*1000*5;

    printf( "Wait 5 seconds for all thread to get ready .....");
    NtDelayExecution(FALSE, &DelayTime);
    printf( "Notifying %d threads to go.\n", Threads);

    NtSetEvent( StartSignal, NULL );


    NtTerminateThread(NtCurrentThread(), STATUS_SUCCESS);

//    printf( "Exiting User Mode Test Program with Status = %lx\n", Status );
//    NtTerminateProcess( CurrentProcessHandle, Status );
}

VOID
FatMain()
{
    VOID Upcase();
    VOID Append(),Chmode(),Copy(),Create(),DebugLevel(),Delete();
    VOID Directory(),Mkdir(),Query(),QVolume(),Rename();
    VOID SVolume(),Type(),Quit();

    CHAR Str[64];
    CHAR Str2[64];
    CHAR LoopStr[64];
    CHAR Prefix[64];
    ULONG i, MyId;
    NTSTATUS Status;

    //
    // Get our id and wait for wakeup
    //

    MyId = Id++;

    if (!NT_SUCCESS(Status = NtWaitForSingleObject( StartSignal, TRUE, NULL))) {
        WaitForSingleObjectError( Status );
        return;
    }

    strcpy( Prefix, RootDir ); // "\\A:\\";

    RtlIntegerToChar( MyId, 10, -8, &Str[0] );
    Str[8] = 0;

    strcat( Prefix, Str );

    printf("FatMain %s:%d %08l \n\n", Prefix, LoopCount, MyId);

    Mkdir( Prefix );
    Directory( Prefix );

    for (i = 0; i < LoopCount; i += 1) {

        strcpy(LoopStr, "Start loop xxxxxxxx ");
        RtlIntegerToChar(i, 16, -8, &LoopStr[11]);
        strcat( LoopStr, Prefix );
        printf(LoopStr);
        printf("\n");

        //
        //  Create new log
        //

        strcpy( Str2, "\\" ); RtlIntegerToChar(i, 16, -8, &Str2[1]); Str2[9] = 0;
        strcpy( Str, Prefix ); Create( strcat( Str, Str2 ), i);

        //
        //  Delete last log file if i > 0
        //

        if (i > 0) {
            strcpy( Str2, "\\" ); RtlIntegerToChar(i-1, 16, -8, &Str2[1]); Str2[9] = 0;
            strcpy( Str, Prefix ); Delete( strcat( Str, Str2 ) );
        }

        //
        //  Create some new files
        //

        printf( "%s: Creating ....\n", Prefix );
        strcpy( Str, Prefix ); Create( strcat( Str, "\\0.tmp" ),   0 );
        strcpy( Str, Prefix ); Create( strcat( Str, "\\1.tmp" ),   1 );
        strcpy( Str, Prefix ); Create( strcat( Str, "\\511.tmp" ), 511 );
        strcpy( Str, Prefix ); Create( strcat( Str, "\\512.tmp" ), 512 );
        strcpy( Str, Prefix ); Create( strcat( Str, "\\513.tmp" ), 513 );
        strcpy( Str, Prefix ); Create( strcat( Str, "\\1023.tmp" ), 1023 );
        strcpy( Str, Prefix ); Create( strcat( Str, "\\1024.tmp" ), 1024 );
        strcpy( Str, Prefix ); Create( strcat( Str, "\\1025.tmp" ), 1025 );
        strcpy( Str, Prefix ); Create( strcat( Str, "\\4095.tmp" ), 4095 );
        strcpy( Str, Prefix ); Create( strcat( Str, "\\4096.tmp" ), 4096 );
        strcpy( Str, Prefix ); Create( strcat( Str, "\\4097.tmp" ), 4097 );
        strcpy( Str, Prefix ); Create( strcat( Str, "\\8191.tmp" ), 8191 );
        strcpy( Str, Prefix ); Create( strcat( Str, "\\8192.tmp" ), 8192 );
        strcpy( Str, Prefix ); Create( strcat( Str, "\\8193.tmp" ), 8193 );
#ifdef BIG
        strcpy( Str, Prefix ); Create( strcat( Str, "\\40970.tmp" ), 40970 );
        strcpy( Str, Prefix ); Create( strcat( Str, "\\81910.tmp" ), 81910 );
        strcpy( Str, Prefix ); Create( strcat( Str, "\\409700.tmp" ), 409700 );
#endif

        Directory( Prefix );

        printf( "%s: Copying ....\n", Prefix );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str,    "\\0.tmp" ), strcat( Str2,    "\\0.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str,    "\\1.tmp" ), strcat( Str2,    "\\1.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str,  "\\511.tmp" ), strcat( Str2,  "\\511.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str,  "\\512.tmp" ), strcat( Str2,  "\\512.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str,  "\\513.tmp" ), strcat( Str2,  "\\513.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str, "\\1023.tmp" ), strcat( Str2, "\\1023.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str, "\\1024.tmp" ), strcat( Str2, "\\1024.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str, "\\1025.tmp" ), strcat( Str2, "\\1025.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str, "\\4095.tmp" ), strcat( Str2, "\\4095.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str, "\\4096.tmp" ), strcat( Str2, "\\4096.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str, "\\4097.tmp" ), strcat( Str2, "\\4097.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str, "\\8191.tmp" ), strcat( Str2, "\\8191.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str, "\\8192.tmp" ), strcat( Str2, "\\8192.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str, "\\8193.tmp" ), strcat( Str2, "\\8193.tmq" ) );
#ifdef BIG
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str, "\\40970.tmp" ), strcat( Str2, "\\40970.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str, "\\81910.tmp" ), strcat( Str2, "\\81910.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Copy( strcat( Str, "\\409700.tmp" ), strcat( Str2, "\\409700.tmq" ) );
#endif

        Directory( Prefix );

        printf( "%s: Appending ....\n", Prefix );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str,    "\\0.tmp" ), strcat( Str2,    "\\0.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str,    "\\1.tmp" ), strcat( Str2,    "\\1.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str,  "\\511.tmp" ), strcat( Str2,  "\\511.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str,  "\\512.tmp" ), strcat( Str2,  "\\512.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str,  "\\513.tmp" ), strcat( Str2,  "\\513.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str, "\\1023.tmp" ), strcat( Str2, "\\1023.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str, "\\1024.tmp" ), strcat( Str2, "\\1024.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str, "\\1025.tmp" ), strcat( Str2, "\\1025.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str, "\\4095.tmp" ), strcat( Str2, "\\4095.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str, "\\4096.tmp" ), strcat( Str2, "\\4096.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str, "\\4097.tmp" ), strcat( Str2, "\\4097.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str, "\\8191.tmp" ), strcat( Str2, "\\8191.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str, "\\8192.tmp" ), strcat( Str2, "\\8192.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str, "\\8193.tmp" ), strcat( Str2, "\\8193.tmq" ) );
#ifdef BIG
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str, "\\40970.tmp" ), strcat( Str2, "\\40970.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str, "\\81910.tmp" ), strcat( Str2, "\\81910.tmq" ) );
        strcpy( Str, Prefix ); strcpy( Str2, Prefix ); Append( strcat( Str, "\\409700.tmp" ), strcat( Str2, "\\409700.tmq" ) );
#endif

        Directory( Prefix );

        printf( "%s: Deleteing ....\n", Prefix );
        strcpy( Str, Prefix ); Delete( strcat( Str,    "\\0.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str,    "\\1.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str,  "\\511.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str,  "\\512.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str,  "\\513.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str, "\\1023.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str, "\\1024.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str, "\\1025.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str, "\\4095.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str, "\\4096.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str, "\\4097.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str, "\\8191.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str, "\\8192.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str, "\\8193.tmp" ) );
#ifdef BIG
        strcpy( Str, Prefix ); Delete( strcat( Str, "\\40970.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str, "\\81910.tmp" ) );
        strcpy( Str, Prefix ); Delete( strcat( Str, "\\409700.tmp" ) );
#endif

        Directory( Prefix );

    }

    printf( "%s: Done.\n", Prefix );

    Quit();

    NtTerminateThread(NtCurrentThread(), STATUS_SUCCESS);

    return; // TRUE;

}
#ifdef undef
VOID
FatMain()
{
    NTSTATUS Status;

    //
    // Wait for wakeup
    //

    if (!NT_SUCCESS(Status = NtWaitForSingleObject( StartSignal, TRUE, NULL))) {
        WaitForSingleObjectError( Status );
        return;
    }

    printf("Here Captain, number 0x%x.\n",
             (ULONG)NtCurrentTeb()->ClientId.UniqueThread);

    NtTerminateThread(NtCurrentThread(), STATUS_SUCCESS);
}
#endif

VOID
Upcase (
    IN OUT PUCHAR String
    )
{
    while (*String != '\0') {
        *String = (UCHAR)toupper(*String);
        String += 1;
    }
}


VOID Append(
    IN PCHAR FromName,
    IN PCHAR ToName
    )
{
    NTSTATUS Status;
    CHAR Buffer[BUFFERSIZE];

    HANDLE FromFileHandle;
    HANDLE ToFileHandle;

    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING NameString;
    IO_STATUS_BLOCK IoStatus;

    LARGE_INTEGER ByteOffset;
    LARGE_INTEGER EofOffset;
    ULONG LogLsn;

    simprintf("Append ", 0);
    simprintf(FromName, 0);
    simprintf(" ", 0);
    simprintf(ToName, 0);
    simprintf("\n", 0);

    //
    //  Open the From file for read access
    //

//    RtlInitString( &NameString, FromName );
    RtlDosPathNameToNtPathName( FromName, &NameString, NULL, NULL );

    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtOpenFile( &FromFileHandle,
                               FILE_READ_DATA | SYNCHRONIZE,
                               &ObjectAttributes,
                               &IoStatus,
                               0L,
                               WriteThrough ))) {
        OpenFileError( Status, FromName );
        return;
    }

    RtlFreeUnicodeString( &NameString );

    //
    //  Open the To file for write access
    //

//    RtlInitString( &NameString, ToName );

    RtlDosPathNameToNtPathName( ToName, &NameString, NULL, NULL );

    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtOpenFile( &ToFileHandle,
                               FILE_WRITE_DATA | SYNCHRONIZE,
                               &ObjectAttributes,
                               &IoStatus,
                               0L,
                               WriteThrough ))) {
        OpenFileError( Status, ToName );
        return;
    }

    RtlFreeUnicodeString( &NameString );

    //
    //  Now append the files
    //

    ByteOffset = LiFromLong( 0 );
    EofOffset = LiFromLong( FILE_WRITE_TO_END_OF_FILE );

    for (LogLsn = 0; TRUE; LogLsn += BUFFERSIZE/512) {

        ULONG ReadLength;

        //
        //  Read the next logical sectors in
        //

        ByteOffset.LowPart = LogLsn * 512;

        if (!NT_SUCCESS(Status = NtReadFile( FromFileHandle,
                                 (HANDLE)NULL,
                                 (PIO_APC_ROUTINE)NULL,
                                 (PVOID)NULL,
                                 &IoStatus,
                                 Buffer,
                                 BUFFERSIZE,
                                 &ByteOffset,
                                 (PULONG) NULL ))) {
            if (Status == STATUS_END_OF_FILE) {
                break;
            }
            ReadFileError( Status, FromName );
            break;
        }
        if (!NT_SUCCESS( Status = NtWaitForSingleObject( FromFileHandle, TRUE, NULL))) {
//            NtPartyByNumber(50);
            WaitForSingleObjectError( Status );
            return;
        }

        //
        //  Check how the read turned out
        //

        if (IoStatus.Status == STATUS_END_OF_FILE) {
            break;
        }
        CheckIoStatus( &IoStatus, BUFFERSIZE, TRUE );
        if (!NT_SUCCESS(IoStatus.Status)) {
            break;
        }

        //
        //  Append the sectors to the To file
        //

        ReadLength = IoStatus.Information;
        if (!NT_SUCCESS(Status = NtWriteFile( ToFileHandle,
                                  (HANDLE)NULL,
                                  (PIO_APC_ROUTINE)NULL,
                                  (PVOID)NULL,
                                  &IoStatus,
                                  Buffer,
                                  IoStatus.Information,
                                  &EofOffset,
                                  (PULONG) NULL ))) {
            WriteFileError( Status, ToName );
            return;
        }
        if (!NT_SUCCESS(Status = NtWaitForSingleObject( ToFileHandle, TRUE, NULL))) {
//            NtPartyByNumber(50);
            WaitForSingleObjectError( Status );
            return;
        }

        //
        //  Check how the write turned out
        //

        CheckIoStatus( &IoStatus, ReadLength, FALSE );
        if (!NT_SUCCESS(IoStatus.Status)) {
            IoStatusError( IoStatus.Status );
            break;
        }

        //
        //  If we didn't read or write a full buffer then the copy is done
        //

        if (IoStatus.Information < BUFFERSIZE) {
            break;
        }

    }

    if (!NT_SUCCESS(IoStatus.Status) && (IoStatus.Status != STATUS_END_OF_FILE)) {

        IoStatusError( IoStatus.Status );

    }

    //
    //  Close both files
    //

    if (!NT_SUCCESS(Status = NtClose( FromFileHandle ))) {
        CloseError( Status, FromName );
    }

    if (!NT_SUCCESS(Status = NtClose( ToFileHandle ))) {
        CloseError( Status, ToName );
    }

    //
    //  And return to our caller
    //

    return;

}


VOID Chmode(
    IN PCHAR Attrib,
    IN PCHAR String
    )
{
    CHAR Buffer[BUFFERSIZE];
    NTSTATUS Status;

    HANDLE FileHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING NameString;
    IO_STATUS_BLOCK IoStatus;

    ULONG FileAttribute;

    //
    //  Get the attribute
    //

    Upcase( (PUCHAR)Attrib );

    //
    //  Get the filename
    //

    simprintf("Chmode", 0);
    simprintf(String, 0);
    simprintf(" ", 0);
    simprintf(Attrib, 0);
    simprintf("\n", 0);

    //
    //  Decode the attributes
    //

    FileAttribute = 0;
    if (strpbrk(Attrib,"N") != NULL) {FileAttribute |= FILE_ATTRIBUTE_NORMAL;}
    if (strpbrk(Attrib,"R") != NULL) {FileAttribute |= FILE_ATTRIBUTE_READONLY;}
    if (strpbrk(Attrib,"H") != NULL) {FileAttribute |= FILE_ATTRIBUTE_HIDDEN;}
    if (strpbrk(Attrib,"S") != NULL) {FileAttribute |= FILE_ATTRIBUTE_SYSTEM;}
    if (strpbrk(Attrib,"A") != NULL) {FileAttribute |= FILE_ATTRIBUTE_ARCHIVE;}

    //
    //  Open the file for write attributes access
    //

//    RtlInitString( &NameString, String );

    RtlDosPathNameToNtPathName( String, &NameString, NULL, NULL );

    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtOpenFile( &FileHandle,
                               FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
                               &ObjectAttributes,
                               &IoStatus,
                               0L,
                               WriteThrough ))) {
        OpenFileError( Status, String );
        return;
    }

    //
    //  Change the file attributes
    //

    ((PFILE_BASIC_INFORMATION)&Buffer[0])->CreationTime.HighPart = 0;
    ((PFILE_BASIC_INFORMATION)&Buffer[0])->CreationTime.LowPart = 0;

    ((PFILE_BASIC_INFORMATION)&Buffer[0])->LastAccessTime.HighPart = 0;
    ((PFILE_BASIC_INFORMATION)&Buffer[0])->LastAccessTime.LowPart = 0;

    ((PFILE_BASIC_INFORMATION)&Buffer[0])->LastWriteTime.HighPart = 0;
    ((PFILE_BASIC_INFORMATION)&Buffer[0])->LastWriteTime.LowPart = 0;

    ((PFILE_BASIC_INFORMATION)&Buffer[0])->FileAttributes = FileAttribute;

    if (!NT_SUCCESS(Status = NtSetInformationFile( FileHandle,
                                       &IoStatus,
                                       Buffer,
                                       sizeof(FILE_BASIC_INFORMATION),
                                       FileBasicInformation))) {
        SetInformationFileError( Status );
    }

    //
    //  Now close the file
    //

    if (!NT_SUCCESS(Status = NtClose( FileHandle ))) {
        CloseError( Status, String );
    }

    //
    //  And return to our caller
    //

    RtlFreeUnicodeString( &NameString );

    return;

}


VOID Copy(
    IN PCHAR FromName,
    IN PCHAR ToName
    )
{
    CHAR Buffer[BUFFERSIZE];
    NTSTATUS Status;

    HANDLE FromFileHandle;
    HANDLE ToFileHandle;

    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING NameString;
    IO_STATUS_BLOCK IoStatus;

    LARGE_INTEGER FromFileAllocation;

    LARGE_INTEGER ByteOffset;
    ULONG LogLsn;

    //
    //  Get both file names
    //

    simprintf("Copy ", 0);
    simprintf(FromName, 0);
    simprintf(" ", 0);
    simprintf(ToName, 0);
    simprintf("\n", 0);

    //
    //  Open the From file for read access
    //

//    RtlInitString( &NameString, FromName );

    RtlDosPathNameToNtPathName( FromName, &NameString, NULL, NULL );

    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtOpenFile( &FromFileHandle,
                               FILE_READ_DATA | FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                               &ObjectAttributes,
                               &IoStatus,
                               0L,
                               WriteThrough ))) {
        OpenFileError( Status, FromName );
        return;
    }

    RtlFreeUnicodeString( &NameString );

    //
    //  Get the size of the from file
    //

    if (!NT_SUCCESS(Status = NtQueryInformationFile( FromFileHandle,
                                         &IoStatus,
                                         Buffer,
                                         BUFFERSIZE,
                                         FileStandardInformation))) {
        QueryInformationFileError( Status );
        return;
    }
    FromFileAllocation = ((PFILE_STANDARD_INFORMATION)Buffer)->AllocationSize;

    //
    //  Create the To file
    //

//    RtlInitString( &NameString, ToName );

    RtlDosPathNameToNtPathName( ToName, &NameString, NULL, NULL );

    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtCreateFile( &ToFileHandle,
                               FILE_WRITE_DATA | SYNCHRONIZE,
                               &ObjectAttributes,
                               &IoStatus,
                               &FromFileAllocation,
                               FILE_ATTRIBUTE_NORMAL,
                               0L,
                               FILE_SUPERSEDE,
                               WriteThrough,
                               (PVOID)NULL,
                               0L ))) {
        CreateFileError( Status, ToName );
        return;
    }

    RtlFreeUnicodeString( &NameString );

    //
    //  Now copy the files
    //

    ByteOffset = LiFromLong( 0 );

    for (LogLsn = 0; TRUE; LogLsn += BUFFERSIZE/512) {

        ULONG ReadLength;

        //
        //  Read the next logical sectors in
        //

        ByteOffset.LowPart = LogLsn * 512;

        if (!NT_SUCCESS(Status = NtReadFile( FromFileHandle,
                                 (HANDLE)NULL,
                                 (PIO_APC_ROUTINE)NULL,
                                 (PVOID)NULL,
                                 &IoStatus,
                                 Buffer,
                                 BUFFERSIZE,
                                 &ByteOffset,
                                 (PULONG) NULL ))) {
            if (Status == STATUS_END_OF_FILE) {
                break;
            }
            ReadFileError( Status, FromName );
            break;
        }
        if (!NT_SUCCESS(Status = NtWaitForSingleObject( FromFileHandle, TRUE, NULL))) {
//            NtPartyByNumber(50);
            WaitForSingleObjectError( Status );
            return;
        }

        //
        //  Check how the read turned out
        //

        if (IoStatus.Status == STATUS_END_OF_FILE) {
            break;
        }
        CheckIoStatus( &IoStatus, BUFFERSIZE, TRUE );
        if (!NT_SUCCESS(IoStatus.Status)) {
            break;
        }

        //
        //  Write the sectors out
        //

        ReadLength = IoStatus.Information;
        if (!NT_SUCCESS(Status = NtWriteFile( ToFileHandle,
                                  (HANDLE)NULL,
                                  (PIO_APC_ROUTINE)NULL,
                                  (PVOID)NULL,
                                  &IoStatus,
                                  Buffer,
                                  IoStatus.Information,
                                  &ByteOffset,
                                  (PULONG) NULL ))) {
            WriteFileError( Status, ToName );
            return;
        }
        if (!NT_SUCCESS(Status = NtWaitForSingleObject( ToFileHandle, TRUE, NULL))) {
//            NtPartyByNumber(50);
            WaitForSingleObjectError( Status );
            return;
        }

        //
        //  Check how the write turned out
        //

        CheckIoStatus( &IoStatus, ReadLength, FALSE );
        if (!NT_SUCCESS(IoStatus.Status)) {
            IoStatusError( IoStatus.Status );
            break;
        }

        //
        //  If we didn't read or write a full buffer then the copy is done
        //

        if (IoStatus.Information < BUFFERSIZE) {
            break;
        }

    }

    if (!NT_SUCCESS(IoStatus.Status) && (IoStatus.Status != STATUS_END_OF_FILE)) {

        IoStatusError( IoStatus.Status );

    }

    //
    //  Close both files
    //

    if (!NT_SUCCESS(Status = NtClose( FromFileHandle ))) {
        CloseError( Status, FromName );
    }

    if (!NT_SUCCESS(Status = NtClose( ToFileHandle ))) {
        CloseError( Status, ToName );
    }

    //
    //  And return to our caller
    //

    return;

}


VOID Create(
    IN PCHAR String,
    IN ULONG Size
    )
{
    CHAR Buffer[BUFFERSIZE];
    NTSTATUS Status;

    HANDLE FileHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING NameString;
    IO_STATUS_BLOCK IoStatus;
    LARGE_INTEGER AllocationSize;

    LARGE_INTEGER ByteOffset;
    ULONG BufferLength;
    ULONG i;

    static CHAR FoxString[] = "The quick brown fox jumped over the lazy dog.\r\n";
    ULONG FoxLength;

    //
    //  Get the filename
    //

    simprintf("Create ", 0);
    simprintf(String, 0);
    simprintf("\n", 0);

    //
    //  Create the new file
    //

    AllocationSize = LiFromUlong( Size );
//    RtlInitString( &NameString, String );

    RtlDosPathNameToNtPathName( String, &NameString, NULL, NULL );

    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtCreateFile( &FileHandle,
                               FILE_WRITE_DATA | SYNCHRONIZE,
                               &ObjectAttributes,
                               &IoStatus,
                               &AllocationSize,
                               FILE_ATTRIBUTE_NORMAL,
                               0L,
                               FILE_SUPERSEDE,
                               WriteThrough,
                               (PVOID)NULL,
                               0L ))) {
        CreateFileError( Status, String );
        return;
    }

    //
    //  create a test buffer to output
    //

    FoxLength = strlen(FoxString);
    for (i = FoxLength; i < BUFFERSIZE; i += FoxLength) {
        strcpy((PCHAR)&Buffer[i-FoxLength], FoxString);
    }
    BufferLength = i - FoxLength;

    //
    //  The main loop writes out the test buffer a BufferLength amount
    //  at a time
    //

    ByteOffset = LiFromLong( 0 );

    for (i = BufferLength; i < Size; i += BufferLength) {

        //
        //  Write the next buffer
        //

        ByteOffset.LowPart = i-BufferLength;

        if (!NT_SUCCESS(Status = NtWriteFile( FileHandle,
                                  (HANDLE)NULL,
                                  (PIO_APC_ROUTINE)NULL,
                                  (PVOID)NULL,
                                  &IoStatus,
                                  Buffer,
                                  BufferLength,
                                  &ByteOffset,
                                  (PULONG) NULL ))) {
            WriteFileError( Status, String );
            return;
        }

        if (!NT_SUCCESS(Status = NtWaitForSingleObject( FileHandle, TRUE, NULL))) {
//            NtPartyByNumber(50);
            WaitForSingleObjectError( Status );
            return;
        }

        //
        //  check how the write turned out
        //

        CheckIoStatus( &IoStatus, BufferLength, FALSE );
        if (!NT_SUCCESS(IoStatus.Status)) {
            IoStatusError( IoStatus.Status );
            break;
        }

    }

    //
    //  Check for a residual to output
    //

    if (i - BufferLength < Size) {

        //
        //  Write out the residual buffer
        //

        ByteOffset.LowPart = i-BufferLength;

        if (!NT_SUCCESS(Status = NtWriteFile( FileHandle,
                                  (HANDLE)NULL,
                                  (PIO_APC_ROUTINE)NULL,
                                  (PVOID)NULL,
                                  &IoStatus,
                                  Buffer,
                                  Size - (i - BufferLength),
                                  &ByteOffset,
                                  (PULONG) NULL ))) {
            WriteFileError( Status, String );
            return;
        }

        if (!NT_SUCCESS(Status = NtWaitForSingleObject( FileHandle, TRUE, NULL))) {
//            NtPartyByNumber(50);
            WaitForSingleObjectError( Status );
            return;
        }

        //
        //  check how the write turned out
        //

        CheckIoStatus( &IoStatus, Size - (i - BufferLength), FALSE );
        if (!NT_SUCCESS(IoStatus.Status)) {
            IoStatusError( IoStatus.Status );
        }

    }

    //
    //  Now close the file
    //

    if (!NT_SUCCESS(Status = NtClose( FileHandle ))) {
        CloseError( Status, String );
    }

    //
    //  And return to our caller
    //

    RtlFreeUnicodeString( &NameString );

    return;

}


VOID DebugLevel()
{

#ifdef FATDBG
    //simprintf("Debug Trace Level %x\n", FatDebugTraceLevel);
#else
    //simprintf("System not compiled for debug tracing\n", 0);
#endif // FATDBG

    return;
}


VOID Delete(
    IN PCHAR String
    )
{
    CHAR Buffer[BUFFERSIZE];
    NTSTATUS Status;

    HANDLE FileHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING NameString;
    IO_STATUS_BLOCK IoStatus;

    //
    //  Get the filename
    //

    simprintf("Delete ", 0);
    simprintf(String, 0);
    simprintf("\n", 0);

    //
    //  Open the file for delete access
    //

//    RtlInitString( &NameString, String );

    RtlDosPathNameToNtPathName( String, &NameString, NULL, NULL );

    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtCreateFile( &FileHandle,
                               DELETE | SYNCHRONIZE,
                               &ObjectAttributes,
                               &IoStatus,
                               (PLARGE_INTEGER)NULL,
                               0L,
                               0L,
                               FILE_OPEN,
                               WriteThrough,
                               (PVOID)NULL,
                               0L ))) {
        CreateFileError( Status, String );
        return;
    }

    //
    //  Mark the file for delete
    //

    ((PFILE_DISPOSITION_INFORMATION)&Buffer[0])->DeleteFile = TRUE;

    if (!NT_SUCCESS(Status = NtSetInformationFile( FileHandle,
                                       &IoStatus,
                                       Buffer,
                                       sizeof(FILE_DISPOSITION_INFORMATION),
                                       FileDispositionInformation))) {
        SetInformationFileError( Status );
        return;
    }

    //
    //  Now close the file
    //

    if (!NT_SUCCESS(Status = NtClose( FileHandle ))) {
        CloseError( Status, String );
    }

    //
    //  And return to our caller
    //

    RtlFreeUnicodeString( &NameString );

    return;

}


VOID Directory(
    IN PCHAR String
    )
{
    CHAR Buffer[BUFFERSIZE];
    NTSTATUS Status;

    HANDLE FileHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING NameString;
    IO_STATUS_BLOCK IoStatus;

    NTSTATUS NtStatus;

    PFILE_ADIRECTORY_INFORMATION FileInfo;
//    ULONG i;

    //
    //  Get the filename
    //

    simprintf("Directory ", 0);
    simprintf(String, 0);
    simprintf("\n", 0);

    //
    //  Open the file for list directory access
    //

//    RtlInitString( &NameString, String );

    RtlDosPathNameToNtPathName( String, &NameString, NULL, NULL );

    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtOpenFile( &FileHandle,
                               FILE_LIST_DIRECTORY | SYNCHRONIZE,
                               &ObjectAttributes,
                               &IoStatus,
                               FILE_SHARE_READ,
                               WriteThrough | FILE_DIRECTORY_FILE ))) {
        OpenFileError( Status, String );
        return;
    }

    //
    //  zero out the buffer so next time we'll recognize the end of data
    //

    RtlZeroMemory(Buffer, BUFFERSIZE);

    //
    //  Do the directory loop
    //

    for (NtStatus = NtQueryDirectoryFile( FileHandle,
                                          (HANDLE)NULL,
                                          (PIO_APC_ROUTINE)NULL,
                                          (PVOID)NULL,
                                          &IoStatus,
                                          Buffer,
                                          BUFFERSIZE,
                                          FileADirectoryInformation,
                                          FALSE,
                                          (PSTRING)NULL,
                                          TRUE);
         NT_SUCCESS(NtStatus);
         NtStatus = NtQueryDirectoryFile( FileHandle,
                                          (HANDLE)NULL,
                                          (PIO_APC_ROUTINE)NULL,
                                          (PVOID)NULL,
                                          &IoStatus,
                                          Buffer,
                                          BUFFERSIZE,
                                          FileADirectoryInformation,
                                          FALSE,
                                          (PSTRING)NULL,
                                          FALSE) ) {

        if (!NT_SUCCESS(Status = NtWaitForSingleObject(FileHandle, TRUE, NULL))) {
//            NtPartyByNumber(50);
            WaitForSingleObjectError( Status );
            return;
        }

        //
        //  Check the Irp for success
        //

        if (!NT_SUCCESS(IoStatus.Status)) {

            break;

        }

        //
        //  For every record in the buffer type out the directory information
        //

        //
        //  Point to the first record in the buffer, we are guaranteed to have
        //  one otherwise IoStatus would have been No More Files
        //

        FileInfo = (PFILE_ADIRECTORY_INFORMATION)&Buffer[0];

        while (TRUE) {

            //
            //  Lets put in some checks to make sure these are ok.
            //

            ASSERT(FileInfo->FileNameLength < MAXIMUM_FILENAME_LENGTH);
            ASSERT(FileInfo->NextEntryOffset < MAXIMUM_FILENAME_LENGTH+sizeof(FILE_ADIRECTORY_INFORMATION)+4);

            //
            //  Print out information about the file
            //

            simprintf("%8lx ", FileInfo->FileAttributes);
            simprintf("%8lx/", FileInfo->EndOfFile.LowPart);
            simprintf("%8lx ", FileInfo->AllocationSize.LowPart);

            {
                CHAR Saved;
                Saved = FileInfo->FileName[FileInfo->FileNameLength];
                FileInfo->FileName[FileInfo->FileNameLength] = 0;
                simprintf(FileInfo->FileName, 0);
                FileInfo->FileName[FileInfo->FileNameLength] = Saved;
            }

            simprintf("\n", 0);

            //
            //  Check if there is another record, if there isn't then we
            //  simply get out of this loop
            //

            if (FileInfo->NextEntryOffset == 0) {
                break;
            }

            //
            //  There is another record so advance FileInfo to the next
            //  record
            //

            FileInfo = (PFILE_ADIRECTORY_INFORMATION)(((PUCHAR)FileInfo) + FileInfo->NextEntryOffset);

        }

        //
        //  zero out the buffer so next time we'll recognize the end of data
        //

        RtlZeroMemory(Buffer, BUFFERSIZE);

    }

    //
    //  Now close the file
    //

    if (!NT_SUCCESS(Status = NtClose( FileHandle ))) {
        CloseError( Status, String );
    }

    //
    //  And return to our caller
    //

    RtlFreeUnicodeString( &NameString );

    return;

}


VOID Mkdir(
    IN PCHAR String
    )
{
    NTSTATUS Status;

    HANDLE FileHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING NameString;
    IO_STATUS_BLOCK IoStatus;
    LARGE_INTEGER AllocationSize;

    //
    //  Get the filename
    //

    simprintf("Mkdir ", 0);
    simprintf(String, 0);
    simprintf("\n", 0);

    //
    //  Create the new directory
    //

    AllocationSize = LiFromLong( 4 );
//    RtlInitString( &NameString, String );

    RtlDosPathNameToNtPathName( String, &NameString, NULL, NULL );

    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtCreateFile( &FileHandle,
                               SYNCHRONIZE,
                               &ObjectAttributes,
                               &IoStatus,
                               &AllocationSize,
                               0L,
                               0L,
                               FILE_CREATE,
                               WriteThrough | FILE_DIRECTORY_FILE,
                               (PVOID)NULL,
                               0L ))) {
        CreateFileError( Status, String );
        return;
    }

    //
    //  Now close the directory
    //

    if (!NT_SUCCESS(Status = NtClose( FileHandle ))) {
        CloseError( Status, String );
    }

    //
    //  And return to our caller
    //

    RtlFreeUnicodeString( &NameString );

    return;

}


VOID Query(
    IN PCHAR String
    )
{
    CHAR Buffer[BUFFERSIZE];
    NTSTATUS Status;

    HANDLE FileHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING NameString;
    IO_STATUS_BLOCK IoStatus;
    ULONG i;

    PFILE_AALL_INFORMATION     AllInfo;
    PFILE_BASIC_INFORMATION    BasicInfo;
    PFILE_STANDARD_INFORMATION StandardInfo;
    PFILE_INTERNAL_INFORMATION InternalInfo;
    PFILE_EA_INFORMATION       EaInfo;
    PFILE_ACCESS_INFORMATION   AccessInfo;
    PFILE_ANAME_INFORMATION    NameInfo;

    //
    //  zero out the buffer so next time we'll recognize the end of data
    //

    for (i = 0; i < BUFFERSIZE; i += 1) { Buffer[i] = 0; }

    //
    //  Set up some local pointers
    //

    AllInfo      = (PFILE_AALL_INFORMATION)Buffer;
    BasicInfo    = &AllInfo->BasicInformation;
    StandardInfo = &AllInfo->StandardInformation;
    InternalInfo = &AllInfo->InternalInformation;
    EaInfo       = &AllInfo->EaInformation;
    AccessInfo   = &AllInfo->AccessInformation;
    NameInfo     = &AllInfo->NameInformation;

    //
    //  Get the filename
    //

    simprintf("Query ", 0);
    simprintf(String, 0);
    simprintf("\n", 0);

    //
    //  Open the file for read attributes, read ea, and read control access
    //

//    RtlInitString( &NameString, String );

    RtlDosPathNameToNtPathName( String, &NameString, NULL, NULL );

    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtOpenFile( &FileHandle,
                               FILE_READ_ATTRIBUTES | FILE_READ_EA | READ_CONTROL | SYNCHRONIZE,
                               &ObjectAttributes,
                               &IoStatus,
                               0L,
                               WriteThrough ))) {
        OpenFileError( Status, String );
        return;
    }

    //
    //  Query the file
    //

    if (!NT_SUCCESS(Status = NtQueryInformationFile( FileHandle,
                                         &IoStatus,
                                         Buffer,
                                         BUFFERSIZE,
                                         FileAAllInformation))) {
        QueryInformationFileError( Status );
        return;
    }

    //
    //  Output file name information
    //

    simprintf("\"", 0);
    simprintf(NameInfo->FileName, 0);
    simprintf("\"\n", 0);

    //
    //  Output the times
    //

    simprintf(" Create = ", 0); PrintTime( &BasicInfo->CreationTime ); simprintf("\n", 0);
    simprintf(" Access = ", 0); PrintTime( &BasicInfo->LastAccessTime ); simprintf("\n", 0);
    simprintf(" Write  = ", 0); PrintTime( &BasicInfo->LastWriteTime ); simprintf("\n", 0);

    //
    //  Output File size, and allocation size
    //

    simprintf(" Size  = %8lx\n", StandardInfo->EndOfFile.LowPart);
    simprintf(" Alloc = %8lx\n", StandardInfo->AllocationSize.LowPart);

    //
    //  Output File attributes, Device type, link count, and flags
    //

    simprintf(" Attrib  = %8lx\n", BasicInfo->FileAttributes);
//    simprintf(" DevType = %8lx\n", StandardInfo->DeviceType);
    simprintf(" Links   = %8lx\n", StandardInfo->NumberOfLinks);
    simprintf(" Dir     = %8lx\n", StandardInfo->Directory);
    simprintf(" Delete  = %8lx\n", StandardInfo->DeletePending);

    //
    //  Output the index number and ea size
    //

    simprintf(" Index   = %8lx\n", InternalInfo->IndexNumber.LowPart);
    simprintf(" EaSize  = %8lx\n", EaInfo->EaSize);

    //
    //  Output the file access flags
    //

    simprintf(" Flags = %8lx\n", AccessInfo->AccessFlags);

    //
    //  Now close the file
    //

    if (!NT_SUCCESS(Status = NtClose( FileHandle ))) {
        CloseError( Status, String );
    }

    //
    //  And return to our caller
    //

    RtlFreeUnicodeString( &NameString );

    return;

}


VOID QVolume(
    IN PCHAR String
    )
{
    CHAR Buffer[BUFFERSIZE];
    NTSTATUS Status;

    HANDLE FileHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING NameString;
    IO_STATUS_BLOCK IoStatus;
    ULONG i;

    PFILE_FS_AVOLUME_INFORMATION VolumeInfo;

    //
    //  zero out the buffer so next time we'll recognize the end of data
    //

    for (i = 0; i < BUFFERSIZE; i += 1) { Buffer[i] = 0; }

    //
    //  Set up some local pointers
    //

    VolumeInfo = (PFILE_FS_AVOLUME_INFORMATION)Buffer;

    //
    //  Get the volume name
    //

    simprintf("QVolume ", 0);
    simprintf(String, 0);
    simprintf("\n", 0);

    //
    //  Open the Volume for no access
    //

//    RtlInitString( &NameString, String );

    RtlDosPathNameToNtPathName( String, &NameString, NULL, NULL );

    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtOpenFile( &FileHandle,
                               FILE_READ_ATTRIBUTES | SYNCHRONIZE,
                               &ObjectAttributes,
                               &IoStatus,
                               0L,
                               WriteThrough ))) {
        OpenFileError( Status, String );
        return;
    }

    //
    //  zero out the buffer so next time we'll recognize the end of data
    //

    for (i = 0; i < BUFFERSIZE; i += 1) { Buffer[i] = 0; }

    //
    //  Query the volume info
    //

    if (!NT_SUCCESS(Status = NtQueryVolumeInformationFile( FileHandle,
                                               &IoStatus,
                                               Buffer,
                                               BUFFERSIZE,
                                               FileAFsVolumeInformation))) {
        QueryVolumeInformationFileError( Status );
        return;
    }

    //
    //  Output Volume name information
    //

    simprintf("\"", 0);
    simprintf(VolumeInfo->VolumeLabel, 0);
    simprintf("\"\n", 0);

    //
    //  Output the volume serial number
    //

    simprintf(" SerialNum = %8lx\n", VolumeInfo->VolumeSerialNumber);

    //
    //  Now close the Volume
    //

    if (!NT_SUCCESS(Status = NtClose( FileHandle ))) {
        CloseError( Status, String );
    }

    //
    //  And return to our caller
    //

    RtlFreeUnicodeString( &NameString );

    return;

}


VOID Rename()
{
    //simprintf("Rename not implemented\n", 0);
}


VOID SVolume(
    IN PCHAR String,
    IN PCHAR Label
    )
{
    CHAR Buffer[BUFFERSIZE];
    NTSTATUS Status;

    HANDLE FileHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING NameString;
    IO_STATUS_BLOCK IoStatus;
    ULONG i;

    PFILE_FS_ALABEL_INFORMATION LabelInfo;

    //
    //  zero out the buffer so next time we'll recognize the end of data
    //

    for (i = 0; i < BUFFERSIZE; i += 1) { Buffer[i] = 0; }

    //
    //  Set up some local pointers
    //

    LabelInfo = (PFILE_FS_ALABEL_INFORMATION)Buffer;

    //
    //  Get the volume name, and new label name
    //

    strcpy( LabelInfo->VolumeLabel, Label );

    LabelInfo->VolumeLabelLength = strlen(LabelInfo->VolumeLabel);

    if ((LabelInfo->VolumeLabelLength == 1) &&
        (LabelInfo->VolumeLabel[0] == '.')) {

        LabelInfo->VolumeLabelLength = 0;

    }

    simprintf("SVolume ", 0);
    simprintf(String, 0);
    simprintf(" ", 0);
    simprintf(LabelInfo->VolumeLabel, 0);
    simprintf("\n", 0);

    //
    //  Open the Volume for no access
    //

//    RtlInitString( &NameString, String );

    RtlDosPathNameToNtPathName( String, &NameString, NULL, NULL );

    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtOpenFile( &FileHandle,
                               FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,
                               &ObjectAttributes,
                               &IoStatus,
                               0L,
                               WriteThrough ))) {
        OpenFileError( Status, String );
        return;
    }

    //
    //  Set the volume info
    //

    if (!NT_SUCCESS(Status = NtSetVolumeInformationFile( FileHandle,
                                             &IoStatus,
                                             LabelInfo,
                                             BUFFERSIZE,
                                             FileAFsLabelInformation))) {
        SetVolumeInformationFileError( Status );
        return;
    }

    //
    //  Now close the Volume
    //

    if (!NT_SUCCESS(Status = NtClose( FileHandle ))) {
        CloseError( Status, String );
    }

    //
    //  And return to our caller
    //

    RtlFreeUnicodeString( &NameString );

    return;

}


VOID Type(
    IN PCHAR String
    )
{
    CHAR Buffer[BUFFERSIZE];
    NTSTATUS Status;

    HANDLE FileHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    UNICODE_STRING NameString;
    IO_STATUS_BLOCK IoStatus;

    LARGE_INTEGER ByteOffset;
    ULONG LogLsn;
    ULONG i;

    //
    //  Get the filename
    //

    simprintf("Type ", 0);
    simprintf(String, 0);
    simprintf("\n", 0);

    //
    //  Open the file for read
    //

//    RtlInitString( &NameString, String );

    RtlDosPathNameToNtPathName( String, &NameString, NULL, NULL );

    InitializeObjectAttributes( &ObjectAttributes, &NameString, 0, NULL, NULL );
    if (!NT_SUCCESS(Status = NtOpenFile( &FileHandle,
                               FILE_READ_DATA | SYNCHRONIZE,
                               &ObjectAttributes,
                               &IoStatus,
                               0L,
                               WriteThrough ))) {
        OpenFileError( Status, String );
        return;
    }

    //
    //  While there is data to be read we'll read a buffer and write it out
    //

    ByteOffset = LiFromLong( 0 );

    for (LogLsn = 0; TRUE; LogLsn += BUFFERSIZE/512) {

        //
        //  Read the next logical sector
        //

        ByteOffset.LowPart = LogLsn * 512;

        if (!NT_SUCCESS(Status = NtReadFile( FileHandle,
                                 (HANDLE)NULL,
                                 (PIO_APC_ROUTINE)NULL,
                                 (PVOID)NULL,
                                 &IoStatus,
                                 Buffer,
                                 BUFFERSIZE,
                                 &ByteOffset,
                                 (PULONG) NULL ))) {
            if (Status == STATUS_END_OF_FILE) {
                break;
            }
            ReadFileError( Status, String );
            break;
        }

        if (!NT_SUCCESS(Status = NtWaitForSingleObject( FileHandle, TRUE, NULL))) {
//            NtPartyByNumber(50);
            WaitForSingleObjectError( Status );
            return;
        }

        //
        //  check how the read turned out
        //

        if (IoStatus.Status == STATUS_END_OF_FILE) {
            break;
        }
        CheckIoStatus( &IoStatus, BUFFERSIZE, TRUE );
        if (!NT_SUCCESS(IoStatus.Status)) {
            IoStatusError( IoStatus.Status );
            break;
        }

        //
        //  Write out the buffer
        //

        for (i = 0; i < IoStatus.Information; i += 1) {
            simprintf("%c", Buffer[i]);
        }

        //
        //  If we didn't read in a complete buffer then we're all done reading
        //  and can get out of here
        //

        if (IoStatus.Information < BUFFERSIZE) {
            break;
        }

    }

    //
    //  Now close the file
    //

    if (!NT_SUCCESS(Status = NtClose( FileHandle ))) {
        CloseError( Status, String );
    }

    //
    //  And return to our caller
    //

    RtlFreeUnicodeString( &NameString );

    return;

}

VOID
Quit()
{
    simprintf("FatTest Exiting.\n", 0);
    return;
}


VOID
PrintTime (
    IN PLARGE_INTEGER Time
    )
{
    TIME_FIELDS TimeFields;

    static PCHAR Months[] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun",
                            "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};

    static PCHAR Days[] = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};

    RtlTimeToTimeFields( Time, &TimeFields );

    simprintf(" %4d-", TimeFields.Year);
    simprintf(Months[TimeFields.Month-1], 0);
    simprintf("-%2d", TimeFields.Day);

    simprintf(" %2d", TimeFields.Hour);
    simprintf(":%2d", TimeFields.Minute);
    simprintf(":%2d", TimeFields.Second);
    simprintf(".%3d (", TimeFields.Milliseconds);

    simprintf(Days[TimeFields.Weekday], 0);
    simprintf(")", 0);

    return;
}

VOID
WaitForSingleObjectError(
    IN NTSTATUS Status
    )
{
    printf(" WaitForSingleObject Error %X\n", Status);
}

VOID
CreateFileError(
    IN NTSTATUS Status,
    IN PUCHAR File
    )
{
    printf(" CreateFile Error %X on %s\n", Status, File);
}

VOID
OpenFileError(
    IN NTSTATUS Status,
    IN PUCHAR File
    )
{
    printf(" OpenFile Error %X on %s\n", Status, File);
}

VOID
ReadFileError(
    IN NTSTATUS Status,
    IN PUCHAR File
    )
{
    printf(" ReadFile Error %X on %s\n", Status, File);
}

VOID
WriteFileError(
    IN NTSTATUS Status,
    IN PUCHAR File
    )
{
    printf(" WriteFile Error %X on %s\n", Status, File);
}

VOID
CheckIoStatus(
    IN PIO_STATUS_BLOCK IoStatus,
    IN ULONG Length,
    IN BOOLEAN Read
    )
{
    if (!NT_SUCCESS(IoStatus->Status)) {
        printf(" IoStatus->Status Error %08lx\n", IoStatus->Status);
    }
    if ((!Read && (IoStatus->Information != Length))

            ||

        (Read && (IoStatus->Information > Length))) {

        printf(" IoStatus->Information Error %08lx\n", IoStatus->Information);
    }
}

VOID
SetInformationFileError(
    IN NTSTATUS Status
    )
{
    printf(" SetInfoFile Error %X\n", Status);
}

VOID
QueryInformationFileError(
    IN NTSTATUS Status
    )
{
    printf(" QueryInfoFile Error %X\n", Status);
}

VOID
SetVolumeInformationFileError(
    IN NTSTATUS Status
    )
{
    printf(" SetVolumeInfoFile Error %X\n", Status);
}

VOID
QueryVolumeInformationFileError(
    IN NTSTATUS Status
    )
{
    printf(" QueryVolumeInfoFile Error %X\n", Status);
}

VOID
CloseError(
    IN NTSTATUS Status,
    IN PUCHAR File
    )
{
    printf(" Close Error %8lx on %s\n", Status, File);
}

VOID
IoStatusError(
    IN NTSTATUS Status
    )
{
    printf(" IoStatus Error %8lx\n", Status);
}

VOID
CreateThreadError(
    IN NTSTATUS Status
    )
{
   printf(" CreateThread Error %8lx\n", Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\filespy\filter\filespy.h ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    filespy.h

Abstract:

    Header file which contains the structures, type definitions,
    and constants that are shared between the kernel mode driver, 
    filespy.sys, and the user mode executable, filespy.exe.

Environment:

    Kernel mode

// @@BEGIN_DDKSPLIT

Author:

    George Jenkins (georgeje) 6-Jan-1999
    Neal Christiansen (nealch)
    Molly Brown (mollybro)  

Revision History:

    Neal Christiansen (nealch)     06-Jul-2001
        Modified to use Stream Contexts to track names

    Ravisankar Pudipeddi (ravisp)  07-May-2002
        Make it work on IA64

// @@END_DDKSPLIT
--*/
#ifndef __FILESPY_H__
#define __FILESPY_H__

#include "filespyLib.h"


//
//  Enable these warnings in the code.
//

#pragma warning(error:4100)   // Unreferenced formal parameter
#pragma warning(error:4101)   // Unreferenced local variable


#define FILESPY_Reset              (ULONG) CTL_CODE( FILE_DEVICE_DISK_FILE_SYSTEM, 0x00, METHOD_BUFFERED, FILE_WRITE_ACCESS )
#define FILESPY_StartLoggingDevice (ULONG) CTL_CODE( FILE_DEVICE_DISK_FILE_SYSTEM, 0x01, METHOD_BUFFERED, FILE_READ_ACCESS )
#define FILESPY_StopLoggingDevice  (ULONG) CTL_CODE( FILE_DEVICE_DISK_FILE_SYSTEM, 0x02, METHOD_BUFFERED, FILE_READ_ACCESS )
#define FILESPY_GetLog             (ULONG) CTL_CODE( FILE_DEVICE_DISK_FILE_SYSTEM, 0x03, METHOD_BUFFERED, FILE_READ_ACCESS )
#define FILESPY_GetVer             (ULONG) CTL_CODE( FILE_DEVICE_DISK_FILE_SYSTEM, 0x04, METHOD_BUFFERED, FILE_READ_ACCESS )
#define FILESPY_ListDevices        (ULONG) CTL_CODE( FILE_DEVICE_DISK_FILE_SYSTEM, 0x05, METHOD_BUFFERED, FILE_READ_ACCESS )
#define FILESPY_GetStats           (ULONG) CTL_CODE( FILE_DEVICE_DISK_FILE_SYSTEM, 0x06, METHOD_BUFFERED, FILE_READ_ACCESS )

#define FILESPY_DRIVER_NAME      L"FILESPY.SYS"
#define FILESPY_DEVICE_NAME      L"FileSpy"
#define FILESPY_W32_DEVICE_NAME  L"\\\\.\\FileSpy"
#define FILESPY_DOSDEVICE_NAME   L"\\DosDevices\\FileSpy"
#define FILESPY_FULLDEVICE_NAME1 L"\\FileSystem\\Filters\\FileSpy"
#define FILESPY_FULLDEVICE_NAME2 L"\\FileSystem\\FileSpyCDO"

    
#define FILESPY_MAJ_VERSION 1
#define FILESPY_MIN_VERSION 0

#ifndef ROUND_TO_SIZE
#define ROUND_TO_SIZE(_length, _alignment)    \
            (((_length) + ((_alignment)-1)) & ~((_alignment) - 1))
#endif 

typedef struct _FILESPYVER {
    USHORT Major;
    USHORT Minor;
} FILESPYVER, *PFILESPYVER;

typedef ULONG_PTR FILE_ID;        //  To allow passing up PFILE_OBJECT as 
                                  //     unique file identifier in user-mode
typedef ULONG_PTR DEVICE_ID;      //  To allow passing up PDEVICE_OBJECT as
                                  //     unique device identifier in user-mode
typedef LONG NTSTATUS;            //  To allow status values to be passed up 
                                  //     to user-mode

//
//  This is set to the number of characters we want to allow the 
//  device extension to store for the various names used to identify
//  a device object.
//

#define DEVICE_NAMES_SZ  100

//
//  An array of these structures are returned when the attached device list is
//  returned.
//

typedef struct _ATTACHED_DEVICE {
    BOOLEAN LoggingOn;
    WCHAR DeviceNames[DEVICE_NAMES_SZ];
} ATTACHED_DEVICE, *PATTACHED_DEVICE;

#define MAX_BUFFERS     100

//
//  Attach modes for the filespy kernel driver
//

#define FILESPY_ATTACH_ON_DEMAND    1   
    //  Filespy will only attach to a volume when a user asks to start logging 
    //  that volume.
                                        
#define FILESPY_ATTACH_ALL_VOLUMES  2   
    //  VERSION NOTE:
    //  
    //  On Windows 2000, Filespy will attach to all volumes in the system that
    //  it sees mount but not turn on logging until requested to through the
    //  filespy user application.  Therefore, if filespy is set to mount on 
    //  demand, it will miss the mounting of the local volumes at boot time.  
    //  If filespy is set to load at boot time, it will see all the local 
    //  volumes be mounted and attach.  This can be beneficial if you want
    //  filespy to attach low in the device stack.
    //
    //  On Windows XP and later, Filespy will attach to all volumes in the
    //  system when it is loaded and all volumes that mount after Filespy is
    //  loaded.  Again, logging on these volumes will not be turned on until 
    //  the user asks it to be.
    //
                                        
//
//  Record types field definitions
//

typedef enum _RECORD_TYPE_FLAGS {

    RECORD_TYPE_STATIC                  = 0x80000000,
    RECORD_TYPE_NORMAL                  = 0x00000000,

    RECORD_TYPE_IRP                     = 0x00000001,
    RECORD_TYPE_FASTIO                  = 0x00000002,
#if WINVER >= 0x0501    
    RECORD_TYPE_FS_FILTER_OP            = 0x00000003,
#endif    

    RECORD_TYPE_OUT_OF_MEMORY           = 0x10000000,
    RECORD_TYPE_EXCEED_MEMORY_ALLOWANCE = 0x20000000

} RECORD_TYPE_FLAGS;

//
//  Macro to return the lower portion of RecordType
//

#define GET_RECORD_TYPE(pLogRecord) ((pLogRecord)->RecordType & 0x0000FFFF)

//
//  Structure defining the information recorded for an IRP operation
//

typedef struct _RECORD_IRP {

    LARGE_INTEGER OriginatingTime; //  The time the IRP originated
    LARGE_INTEGER CompletionTime;  //  The time the IRP was completed

    UCHAR IrpMajor;                //  From _IO_STACK_LOCATION
    UCHAR IrpMinor;                //  From _IO_STACK_LOCATION
    ULONG IrpFlags;                //  From _IRP (no cache, paging i/o, sync. 
                                   //  api, assoc. irp, buffered i/o, etc.)                   
    FILE_ID FileObject;            //  From _IO_STACK_LOCATION (This is the 
                                   //     PFILE_OBJECT, but this isn't 
                                   //     available in user-mode)
    DEVICE_ID DeviceObject;        //  From _IO_STACK_LOCATION (This is the 
                                   //     PDEVICE_OBJECT, but this isn't 
                                   //     available in user-mode)
    NTSTATUS ReturnStatus;         //  From _IRP->IoStatus.Status
    ULONG_PTR ReturnInformation;   //  From _IRP->IoStatus.Information
    FILE_ID ProcessId;
    FILE_ID ThreadId;
    
    //
    //  These fields are only filled in the appropriate
    //  Verbose mode.
    //
    
    PVOID Argument1;               //  
    PVOID Argument2;               //  Current IrpStackLocation
    PVOID Argument3;               //  Parameters
    PVOID Argument4;               //  
    ACCESS_MASK DesiredAccess;     //  Only used for CREATE irps

} RECORD_IRP, *PRECORD_IRP;

//
//  Structure defining the information recorded for a Fast IO operation
//

typedef struct _RECORD_FASTIO {

    LARGE_INTEGER StartTime;     //  Time Fast I/O request begins processing
    LARGE_INTEGER CompletionTime;//  Time Fast I/O request completes processing
    LARGE_INTEGER FileOffset;    //  Offset into the file for the I/O
    
    FILE_ID FileObject;          //  Parameter to FASTIO call
    DEVICE_ID DeviceObject;      //  Parameter to FASTIO call

    FILE_ID ProcessId;
    FILE_ID ThreadId;

    FASTIO_TYPE Type;            //  Type of FASTIO operation
    ULONG Length;                //  The length of data for the I/O operation

    NTSTATUS ReturnStatus;       //  From IO_STATUS_BLOCK

    BOOLEAN Wait;                //  Parameter to most FASTIO calls, signifies 
                                 //  if this operation can wait

} RECORD_FASTIO, *PRECORD_FASTIO;

#if WINVER >= 0x0501

//
//  Structure defining the information recorded for FsFilter operations
//

typedef struct _RECORD_FS_FILTER_OPERATION {

    LARGE_INTEGER OriginatingTime;
    LARGE_INTEGER CompletionTime;

    FILE_ID FileObject;
    DEVICE_ID DeviceObject;

    FILE_ID ProcessId;
    FILE_ID ThreadId;
    
    NTSTATUS ReturnStatus;

    UCHAR FsFilterOperation;

} RECORD_FS_FILTER_OPERATION, *PRECORD_FS_FILTER_OPERATION;

#endif

//
//  The three types of records that are possible.
//

typedef union _RECORD_IO {

    RECORD_IRP RecordIrp;
    RECORD_FASTIO RecordFastIo;
#if WINVER >= 0x0501   
    RECORD_FS_FILTER_OPERATION RecordFsFilterOp;
#endif

} RECORD_IO, *PRECORD_IO;


//
//  Log record structure defines the additional information needed for
//  managing the processing of the each IO FileSpy monitors.
//

typedef struct _LOG_RECORD {

    ULONG Length;           //  Length of record including header 
    ULONG SequenceNumber;
    RECORD_TYPE_FLAGS RecordType;
    RECORD_IO Record;
    WCHAR Name[0];          //  The name starts here

} LOG_RECORD, *PLOG_RECORD;


#define SIZE_OF_LOG_RECORD  (sizeof( LOG_RECORD )) 


//
//  This is the in-memory structure used to track log records.
//

typedef enum _RECORD_LIST_FLAGS {

    //
    //  If set, we want to sync this operation back to the dispatch routine
    //

    RLFL_SYNC_TO_DISPATCH       = 0x00000001,

    //
    //  During some operations (like rename) we need to know if the file is
    //  a file or directory.
    //

    RLFL_IS_DIRECTORY           = 0x00000002

} RECORD_LIST_FLAGS;

typedef struct _RECORD_LIST {

    LIST_ENTRY List;
    PVOID NewContext;
    PVOID WaitEvent;
    RECORD_LIST_FLAGS Flags;
    LOG_RECORD LogRecord;

} RECORD_LIST, *PRECORD_LIST;

#define SIZE_OF_RECORD_LIST (sizeof( RECORD_LIST ))

//
//  The statistics that are kept on the file name hash table
//  to monitor its efficiency.
//

typedef struct _FILESPY_STATISTICS {

    ULONG   TotalContextSearches;
    ULONG   TotalContextFound;
    ULONG   TotalContextCreated;
    ULONG   TotalContextTemporary;
    ULONG   TotalContextDuplicateFrees;
    ULONG   TotalContextCtxCallbackFrees;
    ULONG   TotalContextNonDeferredFrees;
    ULONG   TotalContextDeferredFrees;
    ULONG   TotalContextDeleteAlls;
    ULONG   TotalContextsNotSupported;
    ULONG   TotalContextsNotFoundInStreamList;

} FILESPY_STATISTICS, *PFILESPY_STATISTICS;

//
//  Maximum name length definitions
//

#ifndef MAX_PATH
#define MAX_PATH        384
#endif

#define MAX_NAME_SPACE  (MAX_PATH*sizeof(WCHAR))

//
//  Size of the actual records with the name built in.
//

#define RECORD_SIZE     (SIZE_OF_RECORD_LIST + MAX_NAME_SPACE)

#endif /* __FILESPY_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\filespy\filter\fspydef.h ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    fspydef.h

Abstract:
    Header file which contains the definitions that may be
    shared with the file spy kernel debugger extensions

// @@BEGIN_DDKSPLIT

Author:

    
// @@END_DDKSPLIT

Environment:

    Kernel mode

// @@BEGIN_DDKSPLIT

Revision History:

   Split off from fspykern.h 
            - Ravisankar Pudipeddi [ravisp] 3-March-01

// @@END_DDKSPLIT
--*/
#ifndef __FSPYDEF_H__
#define __FSPYDEF_H__

#define HASH_SIZE            128        // MUST be a power of 2

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\filespy\filter\fspyctx.c ===
/*++

Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    context.c

Abstract:

    This module contains all of the routines for tracking names using
    the new Stream Context feature.  It does this by attaching a context
    structure to a stream whenever a new name is requested.  It does
    properly handle when files and directories are renamed.

    Note that StreamContexts are a new feature in the system and are not
    supported by all file systems.  All of the standard Microsoft file
    systems support them (ntfs, fat, cdfs, udfs, rdr2) but there may be 3rd
    party file systems that do not.  This is one of the main reasons why
    track names by stream contexts is not enabled by default.

Environment:

    Kernel mode

// @@BEGIN_DDKSPLIT
Author:

    Neal Christiansen (nealch)     27-Dec-2000

Revision History:

    Ravisankar Pudipeddi (ravisp)  07-May-2002
        Make it work on IA64

// @@END_DDKSPLIT
--*/

#include <ntifs.h>
#include "filespy.h"
#include "fspyKern.h"

#if USE_STREAM_CONTEXTS
#if WINVER < 0x0501
#error Stream contexts on only supported on Windows XP or later.
#endif

////////////////////////////////////////////////////////////////////////
//
//                    Local prototypes
//
////////////////////////////////////////////////////////////////////////

VOID
SpyDeleteContextCallback(
    IN PVOID Context
    );


//
// linker commands
//

#ifdef ALLOC_PRAGMA

#pragma alloc_text( PAGE, SpyInitDeviceNamingEnvironment )
#pragma alloc_text( PAGE, SpyCleanupDeviceNamingEnvironment )
#pragma alloc_text( PAGE, SpyDeleteAllContexts )
#pragma alloc_text( PAGE, SpyDeleteContext )
#pragma alloc_text( PAGE, SpyDeleteContextCallback )
#pragma alloc_text( PAGE, SpyLinkContext )
#pragma alloc_text( PAGE, SpyCreateContext )
#pragma alloc_text( PAGE, SpyFindExistingContext )
#pragma alloc_text( PAGE, SpyReleaseContext )

#endif  // ALLOC_PRAGMA

///////////////////////////////////////////////////////////////////////////
//
//                      Context support routines
//
///////////////////////////////////////////////////////////////////////////

VOID
SpyInitNamingEnvironment(
    VOID
    )
/*++

Routine Description:

    Init global variables

Arguments:

    None

Return Value:

    None.

--*/
{
}


VOID
SpyLogIrp (
    IN PIRP Irp,
    OUT PRECORD_LIST RecordList
    )
/*++

Routine Description:

    Records the Irp necessary information according to LoggingFlags in
    RecordList.  For any activity on the Irp path of a device being
    logged, this function should get called twice: once on the Irp's
    originating path and once on the Irp's completion path.

Arguments:

    Irp - The Irp that contains the information we want to record.
    LoggingFlags - The flags that say what to log.
    RecordList - The PRECORD_LIST in which the Irp information is stored.
    Context - if non-zero, an existing context record for this entry.

Return Value:

    None.

--*/
{
    PRECORD_IRP pRecordIrp = &RecordList->LogRecord.Record.RecordIrp;
    PIO_STACK_LOCATION pIrpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_OBJECT deviceObject;
    PFILESPY_DEVICE_EXTENSION devExt;
    PSPY_STREAM_CONTEXT pContext;
    NAME_LOOKUP_FLAGS lookupFlags = 0;
    NTSTATUS status;
    FILE_STANDARD_INFORMATION standardInformation;

    //
    //  Init locals
    //

    deviceObject = pIrpStack->DeviceObject;
    devExt = deviceObject->DeviceExtension;

    //
    // Record the information we use for an originating Irp.  We first
    // need to initialize some of the RECORD_LIST and RECORD_IRP fields.
    // Then get the interesting information from the Irp.
    //

    SetFlag( RecordList->LogRecord.RecordType, RECORD_TYPE_IRP );

    pRecordIrp->IrpMajor        = pIrpStack->MajorFunction;
    pRecordIrp->IrpMinor        = pIrpStack->MinorFunction;
    pRecordIrp->IrpFlags        = Irp->Flags;
    pRecordIrp->FileObject      = (FILE_ID)pIrpStack->FileObject;
    pRecordIrp->DeviceObject    = (FILE_ID)deviceObject;
    pRecordIrp->ProcessId       = (FILE_ID)PsGetCurrentProcessId();
    pRecordIrp->ThreadId        = (FILE_ID)PsGetCurrentThreadId();
    pRecordIrp->Argument1       = pIrpStack->Parameters.Others.Argument1;
    pRecordIrp->Argument2       = pIrpStack->Parameters.Others.Argument2;
    pRecordIrp->Argument3       = pIrpStack->Parameters.Others.Argument3;
    pRecordIrp->Argument4       = pIrpStack->Parameters.Others.Argument4;

    KeQuerySystemTime( &pRecordIrp->OriginatingTime );

    //
    //  Do different things based on the operation
    //

    switch (pIrpStack->MajorFunction) {

        case IRP_MJ_CREATE:

            //
            //                      OPEN/CREATE file
			//
			//  Only record the desired access if this is a CREATE irp.
			//

            pRecordIrp->DesiredAccess = pIrpStack->Parameters.Create.SecurityContext->DesiredAccess;

            //
            //  Set out name lookup state
            //

            SetFlag( lookupFlags, NLFL_IN_CREATE );

            //
            //  Flag if opening the directory of the given file
            //

            if (FlagOn( pIrpStack->Flags, SL_OPEN_TARGET_DIRECTORY )) {

                SetFlag( lookupFlags, NLFL_OPEN_TARGET_DIR );
            }

            //
            //  Set if opening by ID
            //

            if (FlagOn( pIrpStack->Parameters.Create.Options, FILE_OPEN_BY_FILE_ID )) {

                SetFlag( lookupFlags, NLFL_OPEN_BY_ID );
            }

            //
            //  We are in pre-create, we can not attach a context to the file
            //  object yet so simply create a context.  If it fails no name
            //  will be logged.  
            //  Note:  We may already have a context on this file but we can't
            //         find it yet because the FsContext field is not setup yet.
            //         We go ahead and get a context so we will have a name if
            //         the operations fails.  We will detect the duplicate
            //         context during the post-create and delete the new one.
            //

            status = SpyCreateContext( deviceObject, 
                                       pIrpStack->FileObject,
                                       lookupFlags,
                                       &pContext );

            if (NT_SUCCESS(status)) {
        
                SPY_LOG_PRINT( SPYDEBUG_TRACE_CONTEXT_OPS, 
                               ("FileSpy!SpyLogIrp:             Created     (%p) Fl=%02x Use=%d \"%wZ\"\n",
                                 pContext,
                                 pContext->Flags,
                                 pContext->UseCount,
                                 &pContext->Name) );

                //
                //  If a context was found save it and mark that to sync back
                //  to the dispatch routine to complete this operation.
                //

                ASSERT(RecordList->NewContext == NULL);
                RecordList->NewContext = pContext;
                SetFlag( RecordList->Flags, RLFL_SYNC_TO_DISPATCH );
            }
            break;

        case IRP_MJ_CLOSE:


            //
            //                      CLOSE FILE
            //
            //  If this is a close we can only look up the name in the name
            //  cache.  It is possible that the close could be occurring
            //  during a cleanup  operation in the file system (i.e., before we
            //  have received the cleanup completion) and requesting the name
            //  would cause a deadlock in the file system.
            //  

            SetFlag( lookupFlags, NLFL_ONLY_CHECK_CACHE );
            break;

        case IRP_MJ_SET_INFORMATION:

            if (FileRenameInformation == 
                pIrpStack->Parameters.SetFile.FileInformationClass)
            {

                //
                //                      RENAME FILE
                //
                //  We are doing a rename.  First get a context for the
                //  given file.  If this fails, mark that we don't want to
                //  try and lookup a name.
                //  

                status = SpyGetContext( deviceObject,
                                        pIrpStack->FileObject,
                                        lookupFlags,
                                        &pContext );

                if (!NT_SUCCESS(status)) {

                    //
                    //  If we couldn't get a context simply delete all
                    //  existing ones (since we don't know what this rename
                    //  will change) and mark not to do a lookup.
                    //

                    SetFlag( lookupFlags, NLFL_NO_LOOKUP );
                    SpyDeleteAllContexts( deviceObject );
                    break;
                }

                //
                //  We retrieved a context, save it in the record and mark
                //  that we want to handle this during post rename.
                //

                ASSERT(RecordList->NewContext == NULL);
                RecordList->NewContext = pContext;
                SetFlag( RecordList->Flags, RLFL_SYNC_TO_DISPATCH );

                //
                //  We need to decide if we are renaming a file or a
                //  directory because we need to handle this differently
                //

                status = SpyQueryInformationFile( devExt->AttachedToDeviceObject,
                                                  pIrpStack->FileObject,
                                                  &standardInformation,
                                                  sizeof( standardInformation ),
                                                  FileStandardInformation,
                                                  NULL );

                if (!NT_SUCCESS(status)) {

                    //
                    //  We can't tell if it is a file or directory, assume
                    //  the worst case and handle it like a directory.
                    //

                    InterlockedIncrement( &devExt->AllContextsTemporary );
                    SpyDeleteAllContexts( deviceObject );
                    SetFlag( RecordList->Flags, RLFL_IS_DIRECTORY );
                    break;
                }

                if (standardInformation.Directory) {

                    //
                    //  Renaming a directory.  Mark that any contexts
                    //  created while the rename is in progress should be
                    //  temporary.  This way there is no window where
                    //  we may get an old stale name.  Then delete all
                    //  existing contexts.  NOTE:  the context we hold will
                    //  not actually be deleted until we release it.
                    //

                    InterlockedIncrement( &devExt->AllContextsTemporary );
                    SpyDeleteAllContexts( deviceObject );
                    SetFlag( RecordList->Flags, RLFL_IS_DIRECTORY );

                } else {

                    //
                    //  We are renaming a file.  Mark the context so it will
                    //  not be used.  This way if someone accesses this file
                    //  while it is being renamed they will lookup the
                    //  name again so we will always get an accurate name.
                    //  This context will be deleted during post rename
                    //  processing
                    //

                    SetFlag( pContext->Flags, CTXFL_DoNotUse);
                }
            }
            break;

    }

    //
    //  If the flag IRP_PAGING_IO is set in this IRP, we cannot query the name
    //  because it can lead to deadlocks.  Therefore, add in the flag so that
    //  we will only try to find the name in our cache.
    //

    if (FlagOn( Irp->Flags, IRP_PAGING_IO )) {

        ASSERT( !FlagOn( lookupFlags, NLFL_NO_LOOKUP ) );

        SetFlag( lookupFlags, NLFL_ONLY_CHECK_CACHE );
    }

    SpySetName( RecordList, 
                deviceObject,
                pIrpStack->FileObject,
                lookupFlags, 
                (PSPY_STREAM_CONTEXT)RecordList->NewContext );

}


VOID
SpyLogIrpCompletion(
    IN PIRP Irp,
    PRECORD_LIST RecordList
    )
/*++

Routine Description:

    This routine performs post-operation logging of the IRP.

Arguments:

    DeviceObject - Pointer to device object FileSpy attached to the file system
        filter stack for the volume receiving this I/O request.
        
    Irp - Pointer to the request packet representing the I/O request.

    Record - RecordList

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION pIrpStack = IoGetCurrentIrpStackLocation(Irp);
    PRECORD_IRP pRecordIrp;
    PDEVICE_OBJECT deviceObject;
    PFILESPY_DEVICE_EXTENSION devExt;
    PSPY_STREAM_CONTEXT pContext;

    //
    //  Init locals
    //

    deviceObject = pIrpStack->DeviceObject;
    devExt = deviceObject->DeviceExtension;

    ASSERT(deviceObject == 
           (PDEVICE_OBJECT)RecordList->LogRecord.Record.RecordIrp.DeviceObject);

    //
    //  Do completion processing based on the operation
    //
    
    switch (pIrpStack->MajorFunction) {    

        case IRP_MJ_CREATE:

            //
            //                  CREATE FILE
            //
            //  NOTE:  When processing CREATE completion IRPS this completion
            //         routine is never called at DISPATCH level, it is always
            //         synchronized back to the dispatch routine.  This is
            //         controlled by the setting of the RLFL_SYNC_TO_DISPATCH
            //         flag in the log record.
            //

            if (NULL != (pContext = RecordList->NewContext)) {

                //
                //  Mark context field so it won't be freed later
                //

                RecordList->NewContext = NULL;

                //
                //  If the operation succeeded and an FsContext is defined,
                //  then attach the context.  Else when the context is
                //  released it will be freed.
                //

                if (NT_SUCCESS(Irp->IoStatus.Status) &&
                    (NULL != pIrpStack->FileObject->FsContext)) {

                    SpyLinkContext( deviceObject,
                                    pIrpStack->FileObject,
                                    &pContext );

                    SPY_LOG_PRINT( SPYDEBUG_TRACE_CONTEXT_OPS, 
                                   ("FileSpy!SpyLogIrpCompletion:   Link        (%p) Fl=%02x Use=%d \"%wZ\"\n",
                                     pContext,
                                     pContext->Flags,
                                     pContext->UseCount,
                                     &pContext->Name) );
                }

                //
                //  Now release the context
                //

                SpyReleaseContext( pContext );
            }
            break;

        case IRP_MJ_SET_INFORMATION:

            if (FileRenameInformation == 
                pIrpStack->Parameters.SetFile.FileInformationClass)
            {

                //
                //                  RENAMING FILE
                //
                //  NOTE:  When processing RENAME completion IRPS this
                //         completion routine is never called at DISPATCH level,
                //         it is always synchronized back to the dispatch
                //         routine.  This is controlled by the setting of the
                //         RLFL_SYNC_TO_DISPATCH flag in the log record.
                //

                if (NULL != (pContext = RecordList->NewContext)) {

                    //
                    //  Mark context field so it won't be freed later
                    //

                    RecordList->NewContext = NULL;

                    //
                    //  See if renaming a directory
                    //

                    if (FlagOn(RecordList->Flags,RLFL_IS_DIRECTORY)) {

                        //
                        //  We were renaming a directory, decrement the
                        //  AllContexts temporary flag.  We need to always
                        //  do this, even on a failure
                        //

                        ASSERT(devExt->AllContextsTemporary > 0);
                        InterlockedDecrement( &devExt->AllContextsTemporary );
                        ASSERT(!FlagOn(pContext->Flags,CTXFL_DoNotUse));

                    } else {

                        //
                        //  We were renaming a file, delete the given context
                        //  if the operation was successful
                        //

                        ASSERT(FlagOn(pContext->Flags,CTXFL_DoNotUse));

                        if (NT_SUCCESS(Irp->IoStatus.Status)) {
            
                            SpyDeleteContext( deviceObject, pContext );
                        }
                    }

                    SpyReleaseContext( pContext );
                }
            }
            break;

        default:

            //
            //  Validate this field isn't set for anything else
            //

            ASSERT(RecordList->NewContext == NULL);
            break;
    }

    //
    //  Process the log record
    //

    if (SHOULD_LOG( deviceObject )) {

        pRecordIrp = &RecordList->LogRecord.Record.RecordIrp;

        //
        // Record the information we use for a completion Irp.
        //

        pRecordIrp->ReturnStatus = Irp->IoStatus.Status;
        pRecordIrp->ReturnInformation = Irp->IoStatus.Information;
        KeQuerySystemTime(&pRecordIrp->CompletionTime);

        //
        //  Add recordList to our gOutputBufferList so that it gets up to 
        //  the user
        //
        
        SpyLog( RecordList );       

    } else {

        if (RecordList) {

            //
            //  Context is set with a RECORD_LIST, but we are no longer
            //  logging so free this record.
            //

            SpyFreeRecord( RecordList );
        }
    }
}


VOID
SpySetName (
    IN PRECORD_LIST RecordList,
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN NAME_LOOKUP_FLAGS LookupFlags,
    IN PSPY_STREAM_CONTEXT Context OPTIONAL
    )
/*++

Routine Description:

    This routine is used to set the file name.  This routine first tries to
    locate a context structure associated with the given stream.  If one is
    found the name is used from it.  If not found the name is looked up, and
    a context structure is created and attached to the given stream.

    In all cases some sort of name will be set.

Arguments:

    RecordList - RecordList to copy name to.
    LookupFlags - holds state flags for the lookup
    Context - optional context parameter.  If not defined one will be looked
        up.

Return Value:

    None.
    
--*/
{
    PRECORD_IRP pRecordIrp = &RecordList->LogRecord.Record.RecordIrp;
    PFILESPY_DEVICE_EXTENSION devExt = DeviceObject->DeviceExtension;
    BOOLEAN releaseContext = FALSE;
    UNICODE_STRING fileName;
    WCHAR fileNameBuffer[MAX_PATH];

    ASSERT(IS_FILESPY_DEVICE_OBJECT( DeviceObject ));

    if (!ARGUMENT_PRESENT(Context) &&
        !FlagOn(LookupFlags,NLFL_NO_LOOKUP)) {

        //
        //  If no FileObject, just return
        //

        if (NULL == FileObject) {

            return;
        }

        //
        //  This will set the return context to NULL if no context
        //  could be created.
        //

        SpyGetContext( DeviceObject,
                       FileObject,
                       LookupFlags,
                       &Context );

        //
        //  Mark that we need to release this context (since we grabbed it)
        //

        releaseContext = TRUE;
    }

    //
    //  If we got a context, use the name from it.  If we didn't, at least
    //  put the device name out there
    //

    if (NULL != Context) {

        SpyCopyFileNameToLogRecord( &RecordList->LogRecord, 
                                    &Context->Name );

    } else {

        SPY_LOG_PRINT( SPYDEBUG_TRACE_DETAILED_CONTEXT_OPS, 
                       ("FileSpy!SpySetName:            NoCtx                              \"%wZ\"\n",
                        &devExt->UserNames) );

        RtlInitEmptyUnicodeString( &fileName, 
                                   fileNameBuffer, 
                                   sizeof(fileNameBuffer) );

        RtlCopyUnicodeString( &fileName, &devExt->UserNames );
        RtlAppendUnicodeToString( &fileName,
                                  L"[-=Context Allocate Failed=-]" );

        SpyCopyFileNameToLogRecord( &RecordList->LogRecord, 
                                    &fileName );
    }

    //
    //  Release the context if we grabbed it in this routine
    //

    if ((NULL != Context) && releaseContext) {

        SpyReleaseContext( Context );
    }
}


VOID
SpyNameDeleteAllNames()
/*++

Routine Description:

    This routine will walk through all attaches volumes and delete all
    contexts in each volume.
    
Arguments:

    None

Return Value:

    None

--*/
{
    PLIST_ENTRY link;
    PFILESPY_DEVICE_EXTENSION devExt;

    ExAcquireFastMutex( &gSpyDeviceExtensionListLock );

    for (link = gSpyDeviceExtensionList.Flink;
         link != &gSpyDeviceExtensionList;
         link = link->Flink)
    {

        devExt = CONTAINING_RECORD(link, FILESPY_DEVICE_EXTENSION, NextFileSpyDeviceLink);

        SpyDeleteAllContexts( devExt->ThisDeviceObject );
    }

    ExReleaseFastMutex( &gSpyDeviceExtensionListLock );
}


///////////////////////////////////////////////////////////////////////////
//
//                      Context support routines
//
///////////////////////////////////////////////////////////////////////////

VOID
SpyInitDeviceNamingEnvironment (
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Initializes context information for a given device

Arguments:

    DeviceObject - Device to init

Return Value:

    None.

--*/
{
    PFILESPY_DEVICE_EXTENSION devExt = DeviceObject->DeviceExtension;

    PAGED_CODE();
    ASSERT(IS_FILESPY_DEVICE_OBJECT(DeviceObject));

    InitializeListHead( &devExt->CtxList );
    ExInitializeResourceLite( &devExt->CtxLock );

    SetFlag( devExt->Flags, ContextsInitialized );
}


VOID
SpyCleanupDeviceNamingEnvironment (
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Cleans up the context information for a given device

Arguments:

    DeviceObject - Device to cleanup

Return Value:

    None.

--*/
{
    PFILESPY_DEVICE_EXTENSION devExt = DeviceObject->DeviceExtension;

    PAGED_CODE();
    ASSERT(IS_FILESPY_DEVICE_OBJECT(DeviceObject));

    //
    //  Cleanup if initialized
    //

    if (FlagOn(devExt->Flags,ContextsInitialized)) {

        //
        //  Delete all existing contexts
        //

        SpyDeleteAllContexts( DeviceObject );
        ASSERT(IsListEmpty( &devExt->CtxList ));

        //
        //  Release resource
        //

        ExDeleteResourceLite( &devExt->CtxLock );

        //
        //  Flag not initialized
        //

        ClearFlag( devExt->Flags, ContextsInitialized );
    }
}


VOID
SpyDeleteAllContexts (
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This will free all existing contexts for the given device

Arguments:

    DeviceObject - Device to operate on

Return Value:

    None.

--*/
{
    PFILESPY_DEVICE_EXTENSION devExt = DeviceObject->DeviceExtension;
    PLIST_ENTRY link;
    PSPY_STREAM_CONTEXT pContext;
    PFSRTL_PER_STREAM_CONTEXT ctxCtrl;
    LIST_ENTRY localHead;
    ULONG deleteNowCount = 0;
    ULONG deleteDeferredCount = 0;
    ULONG deleteInCallbackCount = 0;

    PAGED_CODE();
    ASSERT(IS_FILESPY_DEVICE_OBJECT(DeviceObject));

    INC_STATS(TotalContextDeleteAlls);

    InitializeListHead( &localHead );

    try {

        //
        //  Acquire list lock
        //

        SpyAcquireContextLockExclusive( devExt );

        //
        //  Walk the list of contexts and release each one
        //

        while (!IsListEmpty( &devExt->CtxList )) {

            //
            //  Unlink from top of list
            //

            link = RemoveHeadList( &devExt->CtxList );
            pContext = CONTAINING_RECORD( link, SPY_STREAM_CONTEXT, ExtensionLink );

            //
            //  Mark that we are unlinked from the list.  We need to do this
            //  because of the race condition between this routine and the
            //  deleteCallback from the FS.
            //

            ASSERT(FlagOn(pContext->Flags,CTXFL_InExtensionList));
            RtlInterlockedClearBitsDiscardReturn(&pContext->Flags,CTXFL_InExtensionList);

            //
            //  Try and remove ourselves from the File Systems context control
            //  structure.  Note that the file system could be trying to tear
            //  down their context control right now.  If they are then we 
            //  will get a NULL back from this call.  This is OK because it
            //  just means that they are going to free the memory, not us.
            //  NOTE:  This will be safe because we are holding the ContextLock
            //         exclusively.  If this were happening then they would be
            //         blocked in the callback routine on this lock which
            //         means the file system has not freed the memory for
            //         this yet.
            //  
            
            if (FlagOn(pContext->Flags,CTXFL_InStreamList)) {

                ctxCtrl = FsRtlRemovePerStreamContext( pContext->Stream,
                                                       devExt,
                                                       NULL );

                //
                //  Always clear the flag wether we found it in the list or
                //  not.  We can have the flag set and not be in the list if
                //  after we acquired the context list lock we context swapped
                //  and the file system is right now in SpyDeleteContextCallback
                //  waiting on the list lock.
                //

                RtlInterlockedClearBitsDiscardReturn(&pContext->Flags,CTXFL_InStreamList);

                //
                //  Handle wether we were still attached to the file or not.
                //

                if (NULL != ctxCtrl) {

                    ASSERT(pContext == CONTAINING_RECORD(ctxCtrl,SPY_STREAM_CONTEXT,ContextCtrl));

                    //
                    //  To save time we don't do the free now (with the lock
                    //  held).  We link into a local list and then free it
                    //  later (in this routine).  We can do this because it
                    //  is no longer on any list.
                    //

                    InsertHeadList( &localHead, &pContext->ExtensionLink );

                } else {

                    //
                    //  The context is in the process of being freed by the file
                    //  system.  Don't do anything with it here, it will be
                    //  freed in the callback.
                    //

                    INC_STATS(TotalContextsNotFoundInStreamList);
                    INC_LOCAL_STATS(deleteInCallbackCount);
                }
            }
        }
    } finally {

        SpyReleaseContextLock( devExt );
    }

    //
    //  We have removed everything from the list and released the list lock.
    //  Go through and figure out what entries we can free and then do it.
    //

    while (!IsListEmpty( &localHead )) {

        //
        //  Get next entry of the list and get our context back
        //

        link = RemoveHeadList( &localHead );
        pContext = CONTAINING_RECORD( link, SPY_STREAM_CONTEXT, ExtensionLink );

        //
        //  Decrement the USE count and see if we can free it now
        //

        ASSERT(pContext->UseCount > 0);

        if (InterlockedDecrement( &pContext->UseCount ) <= 0) {

            //
            //  No one is using it, free it now
            //

            SpyFreeContext( pContext );

            INC_STATS(TotalContextNonDeferredFrees);
            INC_LOCAL_STATS(deleteNowCount);

        } else {

            //
            //  Someone still has a pointer to it, it will get deleted
            //  later when they release
            //

            INC_LOCAL_STATS(deleteDeferredCount);
            SPY_LOG_PRINT( SPYDEBUG_TRACE_CONTEXT_OPS, 
                           ("FileSpy!SpyDeleteAllContexts:  DEFERRED    (%p) Fl=%02x Use=%d \"%wZ\"\n",
                             pContext,
                             pContext->Flags,
                             pContext->UseCount,
                             &pContext->Name) );
        }
    }

    SPY_LOG_PRINT( SPYDEBUG_TRACE_CONTEXT_OPS, 
                   ("FileSpy!SpyDeleteAllContexts:   %3d deleted now, %3d deferred, %3d close contention  \"%wZ\"\n",
                    deleteNowCount,
                    deleteDeferredCount,
                    deleteInCallbackCount,
                    &devExt->DeviceName) );
}


VOID
SpyDeleteContext (
    IN PDEVICE_OBJECT DeviceObject,
    IN PSPY_STREAM_CONTEXT pContext
    )
/*++

Routine Description:

    Unlink and release the given context.

Arguments:

    DeviceObject - Device to operate on

    pContext - The context to delete

Return Value:

    None.

--*/
{
    PFILESPY_DEVICE_EXTENSION devExt = DeviceObject->DeviceExtension;
    PFSRTL_PER_STREAM_CONTEXT ctxCtrl;

    PAGED_CODE();
    ASSERT(IS_FILESPY_DEVICE_OBJECT(DeviceObject));

    SPY_LOG_PRINT( SPYDEBUG_TRACE_CONTEXT_OPS, 
                   ("FileSpy!SpyDeleteContext:                   (%p) Fl=%02x Use=%d \"%wZ\"\n",
                    pContext,
                    pContext->Flags,
                    pContext->UseCount,
                    &pContext->Name));

    //
    //  Acquire list lock
    //

    SpyAcquireContextLockExclusive( devExt );

    //
    //  Remove from extension list (if still in it)
    //

    if (FlagOn(pContext->Flags,CTXFL_InExtensionList)) {

        RemoveEntryList( &pContext->ExtensionLink );
        RtlInterlockedClearBitsDiscardReturn(&pContext->Flags,CTXFL_InExtensionList);
    }

    //
    //  See if still in stream list.
    //

    if (!FlagOn(pContext->Flags,CTXFL_InStreamList)) {

        //
        //  Not in stream list, release lock and return
        //

        SpyReleaseContextLock( devExt );

    } else {

        //
        //  Remove from Stream list
        //

        ctxCtrl = FsRtlRemovePerStreamContext( pContext->Stream,
                                               devExt,
                                               NULL );
        //
        //  Always clear the flag wether we found it in the list or not.  We
        //  can have the flag set and not be in the list if after we acquired
        //  the context list lock we context swapped and the file system 
        //  is right now in SpyDeleteContextCallback waiting on the list lock.
        //

        RtlInterlockedClearBitsDiscardReturn(&pContext->Flags,CTXFL_InStreamList);

        //
        //  Release list lock
        //

        SpyReleaseContextLock( devExt );

        //
        //  The context is now deleted from all of the lists and the lock is
        //  removed.  We need to see if we found this entry on the systems context
        //  list.  If not that means the callback was in the middle of trying
        //  to free this (while we were) and has already deleted it.
        //  If we found a structure then delete it now ourselves.
        //

        if (NULL != ctxCtrl) {

            ASSERT(pContext == CONTAINING_RECORD(ctxCtrl,SPY_STREAM_CONTEXT,ContextCtrl));

            //
            //  Decrement USE count, free context if zero
            //

            ASSERT(pContext->UseCount > 0);

            if (InterlockedDecrement( &pContext->UseCount ) <= 0) {

                INC_STATS(TotalContextNonDeferredFrees);
                SpyFreeContext( pContext );

            } else {

                SPY_LOG_PRINT( SPYDEBUG_TRACE_CONTEXT_OPS, 
                               ("FileSpy!SpyDeleteContext:      DEFERRED    (%p) Fl=%02x Use=%d \"%wZ\"\n",
                                pContext,
                                pContext->Flags,
                                pContext->UseCount,
                                &pContext->Name));
            }

        } else {

            INC_STATS(TotalContextsNotFoundInStreamList);
        }
    }
}


VOID
SpyDeleteContextCallback (
    IN PVOID Context
    )
/*++

Routine Description:

    This is called by base file systems when a context needs to be deleted.

Arguments:

    Context - The context structure being deleted

Return Value:

    None.

--*/
{
    PSPY_STREAM_CONTEXT pContext = Context;
    PFILESPY_DEVICE_EXTENSION devExt;
    
    PAGED_CODE();

    devExt = (PFILESPY_DEVICE_EXTENSION)pContext->ContextCtrl.OwnerId;

    SPY_LOG_PRINT( SPYDEBUG_TRACE_CONTEXT_OPS, 
                   ("FileSpy!SpyDeleteContextCallback:          (%p) Fl=%02x Use=%d \"%wZ\"\n",
                    pContext,
                    pContext->Flags,
                    pContext->UseCount,
                    &pContext->Name) );

    //
    //  When we get here we have already been removed from the stream list (by
    //  the calling file system), flag that this has happened.  
    //

    RtlInterlockedClearBitsDiscardReturn(&pContext->Flags,CTXFL_InStreamList);

    //
    //  Lock the context list lock in the extension
    //

    SpyAcquireContextLockExclusive( devExt );

    //
    //  See if we are still linked into the extension list.  If not then skip
    //  the unlinking.  This can happen if someone is trying to delete this
    //  context at the same time as we are.
    //

    if (FlagOn(pContext->Flags,CTXFL_InExtensionList)) {

        RemoveEntryList( &pContext->ExtensionLink );
        RtlInterlockedClearBitsDiscardReturn(&pContext->Flags,CTXFL_InExtensionList);
    }

    SpyReleaseContextLock( devExt );

    //
    //  Decrement USE count, free context if zero
    //

    ASSERT(pContext->UseCount > 0);

    if (InterlockedDecrement( &pContext->UseCount ) <= 0) {

        INC_STATS(TotalContextCtxCallbackFrees);
        SpyFreeContext( pContext );

    } else {

        SPY_LOG_PRINT( SPYDEBUG_TRACE_CONTEXT_OPS, 
                       ("FileSpy!SpyDeleteContextCB:    DEFFERED    (%p) Fl=%02x Use=%d \"%wZ\"\n",
                        pContext,
                        pContext->Flags,
                        pContext->UseCount,
                        &pContext->Name) );
    }
}


VOID
SpyLinkContext ( 
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN OUT PSPY_STREAM_CONTEXT *ppContext
    )
/*++

Routine Description:

    This will link the given context into the context list for the given
    device as well as into the given stream.

    NOTE:   It is possible for this entry to already exist in the table since
            between the time we initially looked and the time we inserted
            (which is now) someone else may have inserted one.  If we find an
            entry that already exists we will free the entry passed in and
            return the entry found.  

Arguments:

    DeviceObject - Device we are operating on

    FileObject - Represents the stream to link the context into

    ppContext - Enters with the context to link, returns with the context
            to use.  They may be different if the given context already
            exists.

Return Value:

    None.

--*/
{
    PFILESPY_DEVICE_EXTENSION devExt = DeviceObject->DeviceExtension;
    NTSTATUS status;
    PSPY_STREAM_CONTEXT pContext = *ppContext;
    PSPY_STREAM_CONTEXT ctx;
    PFSRTL_PER_STREAM_CONTEXT ctxCtrl;
    
    PAGED_CODE();
    ASSERT(IS_FILESPY_DEVICE_OBJECT(DeviceObject));
    ASSERT(FileObject->FsContext != NULL);
    ASSERT(pContext != NULL);

    //
    //  If this is marked as a temporary context, return now.  Because we
    //  don't bump the reference count, when it is release it to be freed.
    //

    if (FlagOn(pContext->Flags,CTXFL_Temporary)) {

        ASSERT(!FlagOn(pContext->Flags,CTXFL_InExtensionList));
        return;
    }

    //
    //  We need to figure out if a duplicate entry already exists on
    //  the context list for this file object.  Acquire our list lock
    //  and then see if it exists.  If not, insert into the stream and
    //  volume lists.  If so, then simply free this new entry and return
    //  the original.
    //
    //  This can happen when:
    //  - Someone created an entry at the exact same time as we were
    //    creating an entry.
    //  - When someone does a create with overwrite or supersede we
    //    do not have the information yet to see if a context already
    //    exists.  Because of this we have to create a new context
    //    every time.  During post-create we then see if one already
    //    exists.
    //

    //
    //  Initialize the context control structure.  We do this now so we
    //  don't have to do it while the lock is held (even if we might
    //  have to free it because of a duplicate found)
    //

    FsRtlInitPerStreamContext( &pContext->ContextCtrl,
                               devExt,
                               NULL,
                               SpyDeleteContextCallback );

    //
    //  Save the stream we are associated with.
    //

    pContext->Stream = FsRtlGetPerStreamContextPointer(FileObject);

    //
    //  Acquire list lock exclusively
    //

    SpyAcquireContextLockExclusive( devExt );

    ASSERT(pContext->UseCount == 1);
    ASSERT(!FlagOn(pContext->Flags,CTXFL_InExtensionList));
    ASSERT(!FlagOn(pContext->Flags,CTXFL_Temporary));

    //
    //  See if we have an entry already on the list
    //

    ctxCtrl = FsRtlLookupPerStreamContext( FsRtlGetPerStreamContextPointer(FileObject),
                                           devExt,
                                           NULL );

    if (NULL != ctxCtrl) {

        //
        //  The context already exists so free the new one we just
        //  created.  First increment the use count on the one we found in
        //  the list.
        //

        ctx = CONTAINING_RECORD(ctxCtrl,SPY_STREAM_CONTEXT,ContextCtrl);

        ASSERT(ctx->Stream == FsRtlGetPerStreamContextPointer(FileObject));
        ASSERT(FlagOn(ctx->Flags,CTXFL_InExtensionList));
        ASSERT(ctx->UseCount > 0);

        //
        //  Bump ref count and release lock
        //

        InterlockedIncrement( &ctx->UseCount );

        SpyReleaseContextLock( devExt );

        //
        //  Since this cache is across opens on the same stream there are
        //  cases where the names will be different even though they are the
        //  same file.  These cases are:
        //      - One open could be by short name where another open
        //        is by long name.
        //      - This does not presently strip extended stream names like
        //        :$DATA
        //  When enabled this will display to the debugger screen when the
        //  names don't exactly match.  You can also break on this difference.
        //

        if (!RtlEqualUnicodeString( &pContext->Name,&ctx->Name,TRUE )) {

            SPY_LOG_PRINT( SPYDEBUG_TRACE_MISMATCHED_NAMES, 
                           ("FileSpy!SpyLinkContext:        Old Name:   (%p) Fl=%02x Use=%d \"%wZ\"\n"
                            "                               New Name:   (%p) Fl=%02x Use=%d \"%wZ\"\n",
                            ctx,
                            ctx->Flags,
                            ctx->UseCount,
                            &ctx->Name,
                            pContext,
                            pContext->Flags,
                            pContext->UseCount,
                            &pContext->Name) );

            if (FlagOn(gFileSpyDebugLevel,SPYDEBUG_ASSERT_MISMATCHED_NAMES)) {

                DbgBreakPoint();
            }
        }

        SPY_LOG_PRINT( SPYDEBUG_TRACE_CONTEXT_OPS, 
                       ("FileSpy!SpyLinkContext:        Rel Dup:    (%p) Fl=%02x Use=%d \"%wZ\"\n",
                        pContext,
                        pContext->Flags,
                        pContext->UseCount,
                        &pContext->Name) );

        //
        //  Free the new structure because it was already resident.  Note
        //  that this entry has never been linked into any lists so we know
        //  no one else has a reference to it.  Decrement use count to keep
        //  the ASSERTS happy then free the memory.
        //

        INC_STATS(TotalContextDuplicateFrees);

        pContext->UseCount--;
        SpyFreeContext( pContext );

        //
        //  Return the one we found in the list
        //

        *ppContext = ctx;

    } else {

        //
        //  The new context did not exist, insert this new one.
        //

        //
        //  Link into Stream context.  This can fail for the following
        //  reasons:
        //      This is a paging file
        //      This is a volume open
        //  If this happens then don't bump the reference count and it will be
        //  freed when the caller is done with it.
        //

        status = FsRtlInsertPerStreamContext( FsRtlGetPerStreamContextPointer(FileObject),
                                              &pContext->ContextCtrl );

        if (NT_SUCCESS(status)) {

            //
            //  Increment the USE count (because it is added to the stream)
            //

            InterlockedIncrement( &pContext->UseCount );

            //
            //  Link into Device extension
            //

            InsertHeadList( &devExt->CtxList, &pContext->ExtensionLink );

            //
            //  Mark that we have been inserted into both lists.  We don't have
            //  to do this interlocked because no one can access this entry
            //  until we release the context lock.
            //

            SetFlag( pContext->Flags, CTXFL_InExtensionList|CTXFL_InStreamList );

        }

        //
        //  Release lock
        //

        SpyReleaseContextLock( devExt );
    }
}


/***************************************************************************++

Routine Description:

    This will allocate and initialize a context structure but it does NOT
    link it into the context hash list.

Arguments:

Return Value:

--***************************************************************************/
NTSTATUS
SpyCreateContext (
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN NAME_LOOKUP_FLAGS LookupFlags,
    OUT PSPY_STREAM_CONTEXT *pRetContext
    )
/*++

Routine Description:

    Allocate and initialize a context structure including retrieving the name.

Arguments:

    DeviceObject - Device to operate on

    FileObject - The stream the context is being created for

    LookupFlags - Flag telling how to do this create

    pRetContext - Receives the created context

Return Value:

    Status of the operation

--*/
{
    PFILESPY_DEVICE_EXTENSION devExt = DeviceObject->DeviceExtension;
    PSPY_STREAM_CONTEXT ctx;
    ULONG contextSize;
    UNICODE_STRING fileName;
    WCHAR fileNameBuffer[MAX_PATH];
    BOOLEAN getNameResult;    


    PAGED_CODE();
    ASSERT(IS_FILESPY_DEVICE_OBJECT(DeviceObject));

    //
    //  Setup locals
    //

    *pRetContext = NULL;

    RtlInitEmptyUnicodeString( &fileName,
                               fileNameBuffer,
                               sizeof(fileNameBuffer) );

    //
    //  Get the filename string
    //

    getNameResult = SpyGetFullPathName( FileObject,
                                        &fileName,
                                        devExt,
                                        LookupFlags );

    //
    //  Allocate the context structure with space for the name
    //  added to the end.
    //

    contextSize = sizeof(SPY_STREAM_CONTEXT) + fileName.Length;

    ctx = ExAllocatePoolWithTag( NonPagedPool, 
                                 contextSize,
                                 FILESPY_CONTEXT_TAG );

    if (!ctx) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  Init the context structure
    //

    RtlZeroMemory( ctx, sizeof(SPY_STREAM_CONTEXT) );
    ctx->UseCount = 1;
    
    //
    //  Insert the file name
    //

    RtlInitEmptyUnicodeString( &ctx->Name, 
                               (PWCHAR)(ctx + 1), 
                               contextSize - sizeof(SPY_STREAM_CONTEXT) );

    RtlCopyUnicodeString( &ctx->Name, &fileName );

    //
    //  If they don't want to keep this context, mark it temporary
    //

    if (!getNameResult) {

        SetFlag(ctx->Flags, CTXFL_Temporary);
        INC_STATS(TotalContextTemporary);
    }

    //
    //  Return the object context
    //

    INC_STATS(TotalContextCreated);
    *pRetContext = ctx;

    //
    //  Cleanup the local nameControl structure
    //

    return STATUS_SUCCESS;
}


NTSTATUS
SpyGetContext (
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN NAME_LOOKUP_FLAGS LookupFlags,
    OUT PSPY_STREAM_CONTEXT *pRetContext
    )
/*++

Routine Description:

    This will see if a given context already exists.  If not it will create
    one and return it.  Note:  the return context pointer is NULL on a
    failure.

    This will also see if all contexts are to be temporary (global flag in
    the extension).  If so, a temporary context is always created.  It also
    sees if the found context is marked temporary (because it is being
    renamed).  If so, a temporary context is also created and returned.

Arguments:

    DeviceObject - Device to operate on

    FileObject - The stream the context is being looked up/created for

    LookupFlags - State flags incase a context is created

    pRetContext - Receives the found/created context

Return Value:

    Status of the operation

--*/
{
    PFILESPY_DEVICE_EXTENSION devExt = DeviceObject->DeviceExtension;
    PSPY_STREAM_CONTEXT pContext;
    PFSRTL_PER_STREAM_CONTEXT ctxCtrl;
    NTSTATUS status;
    BOOLEAN makeTemporary = FALSE;

    ASSERT(IS_FILESPY_DEVICE_OBJECT(DeviceObject));

    //
    //  Bump total search count
    //

    INC_STATS(TotalContextSearches);

    //
    //  See if the all-contexts-temporary state is on.  If not then do
    //  the normal search.
    //

    if (devExt->AllContextsTemporary != 0) {

        //
        //  Mark that we want this context to be temporary
        //

        makeTemporary = TRUE;

    } else {

        //
        //                      NOT-TEMPORARY
        //  Try and locate the context structure.  We acquire the list lock
        //  so that we can guarantee that the context will not go away between
        //  the time when we find it and can increment the use count
        //

        SpyAcquireContextLockShared( devExt );

        ctxCtrl = FsRtlLookupPerStreamContext( FsRtlGetPerStreamContextPointer(FileObject),
                                               devExt,
                                               NULL );

        if (NULL != ctxCtrl) {

            //
            //  A context was attached to the given stream
            //

            pContext = CONTAINING_RECORD( ctxCtrl,
                                          SPY_STREAM_CONTEXT,
                                          ContextCtrl );

            ASSERT(pContext->Stream == FsRtlGetPerStreamContextPointer(FileObject));
            ASSERT(FlagOn(pContext->Flags,CTXFL_InExtensionList));
            ASSERT(!FlagOn(pContext->Flags,CTXFL_Temporary));
            ASSERT(pContext->UseCount > 0);

            //
            //  See if this is marked that we should not use it (happens when a
            //  file is being renamed).
            //

            if (FlagOn(pContext->Flags,CTXFL_DoNotUse)) {

                //
                //  We should not use this context, unlock and set flag so we
                //  will create a temporary context.
                //

                SpyReleaseContextLock( devExt );
                makeTemporary = TRUE;

            } else {

                //
                //  We want this context so bump the use count and release
                //  the lock
                //

                InterlockedIncrement( &pContext->UseCount );

                SpyReleaseContextLock( devExt );
                INC_STATS(TotalContextFound);

                SPY_LOG_PRINT( SPYDEBUG_TRACE_CONTEXT_OPS, 
                               ("FileSpy!SpyGetContext:         Found:      (%p) Fl=%02x Use=%d \"%wZ\"\n",
                                pContext,
                                pContext->Flags,
                                pContext->UseCount,
                                &pContext->Name) );

                //
                //  Return the found context
                //

                *pRetContext = pContext;
                return STATUS_SUCCESS;
            }

        } else {

            //
            //  We didn't find a context, release the lock
            //

            SpyReleaseContextLock( devExt );
        }
    }

    //
    //  For whatever reason, we did not find a context.
    //  See if contexts are supported for this particular file.  Note that
    //  NTFS does not presently support contexts on paging files.
    //

    if (!FsRtlSupportsPerStreamContexts(FileObject)) {

        INC_STATS(TotalContextsNotSupported);
        *pRetContext = NULL;
        return STATUS_NOT_SUPPORTED;
    }

    //
    //  If we get here we need to create a context, do it
    //

    status = SpyCreateContext( DeviceObject,
                               FileObject,
                               LookupFlags,
                               &pContext );
                               
    if (!NT_SUCCESS( status )) {

        *pRetContext = NULL;
        return status;
    }       

    //
    //  Mark context temporary (if requested)
    //

    if (makeTemporary) {

        SetFlag(pContext->Flags,CTXFL_Temporary);

        INC_STATS(TotalContextTemporary);

        SPY_LOG_PRINT( SPYDEBUG_TRACE_CONTEXT_OPS, 
                       ("FileSpy!SpyGetContext:         RenAllTmp:  (%p) Fl=%02x Use=%d \"%wZ\"\n",
                        pContext,
                        pContext->Flags,
                        pContext->UseCount,
                        &pContext->Name) );

    } else {

        //
        //  Insert the context into the linked list.  Note that the
        //  link routine will see if this entry has already been added to
        //  the list (could happen while we were building it).  If so it
        //  will release the one we created and use the one it found in
        //  the list.  It will return the new entry (if it was changed).
        //  The link routine properly handles temporary contexts.
        //

        SpyLinkContext( DeviceObject,
                        FileObject,
                        &pContext );
    }

    SPY_LOG_PRINT( SPYDEBUG_TRACE_CONTEXT_OPS, 
                   ("FileSpy!SrGetContext:          Created%s (%p) Fl=%02x Use=%d \"%wZ\"\n",
                    (FlagOn(pContext->Flags,CTXFL_Temporary) ? "Tmp:" : ":   "),
                    pContext,
                    pContext->Flags,
                    pContext->UseCount,
                    &pContext->Name) );

    //
    //  Return the context
    //

    ASSERT(pContext->UseCount > 0);

    *pRetContext = pContext;
    return STATUS_SUCCESS;
}


PSPY_STREAM_CONTEXT
SpyFindExistingContext (
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject
    )
/*++

Routine Description:

    See if a context for the given stream already exists.  If so it will
    bump the reference count and return the context.  If not, NULL
    is returned.

Arguments:

    DeviceObject - Device to operate on

    FileObject - The stream the context is being looked up for

Return Value:

    Returns the found context


--*/
{
    PFILESPY_DEVICE_EXTENSION devExt = DeviceObject->DeviceExtension;
    PSPY_STREAM_CONTEXT pContext;
    PFSRTL_PER_STREAM_CONTEXT ctxCtrl;

    PAGED_CODE();
    ASSERT(IS_FILESPY_DEVICE_OBJECT(DeviceObject));

    //
    //  Try and locate the context structure.  We acquire the list lock
    //  so that we can guarantee that the context will not go away between
    //  the time when we find it and can increment the use count
    //

    INC_STATS(TotalContextSearches);

    SpyAcquireContextLockShared( devExt );

    ctxCtrl = FsRtlLookupPerStreamContext( FsRtlGetPerStreamContextPointer(FileObject),
                                           devExt,
                                           NULL );

    if (NULL != ctxCtrl) {

        //
        //  We found the entry, increment use count
        //

        pContext = CONTAINING_RECORD(ctxCtrl,SPY_STREAM_CONTEXT,ContextCtrl);

        ASSERT(pContext->Stream == FsRtlGetPerStreamContextPointer(FileObject));
        ASSERT(pContext->UseCount > 0);

        InterlockedIncrement( &pContext->UseCount );

        //
        //  Release the list lock
        //

        SpyReleaseContextLock( devExt );
        INC_STATS(TotalContextFound);

        SPY_LOG_PRINT( SPYDEBUG_TRACE_CONTEXT_OPS, 
                       ("FileSpy!SpyFindExistingContext:Found:      (%p) Fl=%02x Use=%d \"%wZ\"\n",
                        pContext,
                        pContext->Flags,
                        pContext->UseCount,
                        &pContext->Name) );

    } else {

        //
        //  Release the list lock while we create the new context.
        //

        SpyReleaseContextLock( devExt );

        pContext = NULL;
    }

    return pContext;
}


VOID
SpyReleaseContext (
    IN PSPY_STREAM_CONTEXT pContext
    )
/*++

Routine Description:

    Decrement the use count for the given context.  If it goes to zero, free it

Arguments:

    pContext - The context to operate on

Return Value:

    None.

--*/
{
    PAGED_CODE();

    SPY_LOG_PRINT( SPYDEBUG_TRACE_DETAILED_CONTEXT_OPS, 
                   ("FileSpy!SpyReleaseContext:     Release     (%p) Fl=%02x Use=%d \"%wZ\"\n",
                    pContext,
                    pContext->Flags,
                    pContext->UseCount,
                    &pContext->Name) );

    //
    //  Decrement USE count, free context if zero
    //

    ASSERT(pContext->UseCount > 0);

    if (InterlockedDecrement( &pContext->UseCount ) <= 0) {

        ASSERT(!FlagOn(pContext->Flags,CTXFL_InExtensionList));

        //
        //  Free the memory
        //

        SPY_LOG_PRINT( SPYDEBUG_TRACE_CONTEXT_OPS, 
                       ("FileSpy!SpyReleaseContext:     Freeing     (%p) Fl=%02x Use=%d \"%wZ\"\n",
                         pContext,
                         pContext->Flags,
                         pContext->UseCount,
                         &pContext->Name) );

        INC_STATS(TotalContextDeferredFrees);
        SpyFreeContext( pContext );
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\filespy\filter\filespy.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    filespy.c

Abstract:

    This is the main module of FileSpy.

    As of the Windows XP SP1 IFS Kit version of this sample and later, this
    sample can be built for each build environment released with the IFS Kit
    with no additional modifications.  To provide this capability, additional
    compile-time logic was added -- see the '#if WINVER' locations.  Comments
    
    tagged with the 'VERSION NOTE' header have also been added as appropriate to
    describe how the logic must change between versions.

    If this sample is built in the Windows XP environment or later, it will run
    on Windows 2000 or later.  This is done by dynamically loading the routines
    that are only available on Windows XP or later and making run-time decisions
    to determine what code to execute.  Comments tagged with 'MULTIVERISON NOTE'
    mark the locations where such logic has been added.
    
Environment:

    Kernel mode

// @@BEGIN_DDKSPLIT

Author:

    George Jenkins (georgeje) 6-Jan-1999
    Neal Christiansen (nealch)
    Molly Brown (mollybro)  

Revision History:

    George Jenkins (georgeje) 6-Jan-1999    cloned from sfilter.c

    Molly Brown (mollybro) 28-Jun-2000  
        Cleaned up code and made it work with new FsFilter operations.

    Neal Christiansen (nealch)     06-Jul-2001
        Modified to use Stream Contexts to track names

    Molly Brown (mollybro)         21-May-2002
        Modify sample to make it support running on Windows 2000 or later if
        built in the latest build environment and allow it to be built in W2K 
        and later build environments.

// @@END_DDKSPLIT
--*/

#include <ntifs.h>
#include <stdlib.h>
#include "filespy.h"
#include "fspyKern.h"

//
// Global variables.
//

ULONG gFileSpyDebugLevel = DEFAULT_FILESPY_DEBUG_LEVEL;
#if WINVER >= 0x0501
ULONG gFileSpyAttachMode = FILESPY_ATTACH_ALL_VOLUMES;
#else
ULONG gFileSpyAttachMode = FILESPY_ATTACH_ON_DEMAND;
#endif

PDEVICE_OBJECT gControlDeviceObject;

PDRIVER_OBJECT gFileSpyDriverObject;

//
//  The list of device extensions for the volume device objects we are
//  attached to (the volumes we are spying on).  Note:  This list does NOT
//  include FileSystem control device objects we are attached to.  This
//  list is used to answer the question "Which volumes are we logging?"
//

FAST_MUTEX gSpyDeviceExtensionListLock;
LIST_ENTRY gSpyDeviceExtensionList;

//
// NOTE 1:  There are some cases where we need to hold both the 
//   gControlDeviceStateLock and the gOutputBufferLock at the same time.  In
//   these cases, you should acquire the gControlDeviceStateLock then the
//   gOutputBufferLock.
// NOTE 2:  The gControlDeviceStateLock MUST be a spinlock since we try to 
//   acquire it during the completion path in SpyLog, which could be called at
//   DISPATCH_LEVEL (only KSPIN_LOCKs can be acquired at DISPATCH_LEVEL).
//

CONTROL_DEVICE_STATE gControlDeviceState = CLOSED;
KSPIN_LOCK gControlDeviceStateLock;

// NOTE:  Like the gControlDeviceStateLock, gOutputBufferLock MUST be a spinlock
//   since we try to acquire it during the completion path in SpyLog, which 
//   could be called at DISPATCH_LEVEL (only KSPIN_LOCKs can be acquired at 
//   DISPATCH_LEVEL).
//
KSPIN_LOCK gOutputBufferLock;
LIST_ENTRY gOutputBufferList;

#ifndef MEMORY_DBG
NPAGED_LOOKASIDE_LIST gFreeBufferList;
#endif

ULONG gLogSequenceNumber = 0;
KSPIN_LOCK gLogSequenceLock;

UNICODE_STRING gVolumeString;
UNICODE_STRING gOverrunString;
UNICODE_STRING gPagingIoString;

LONG gMaxRecordsToAllocate = DEFAULT_MAX_RECORDS_TO_ALLOCATE;
LONG gRecordsAllocated = 0;

LONG gMaxNamesToAllocate = DEFAULT_MAX_NAMES_TO_ALLOCATE;
LONG gNamesAllocated = 0;

LONG gStaticBufferInUse = FALSE;
CHAR gOutOfMemoryBuffer[RECORD_SIZE];

#if WINVER >= 0x0501
//
//  The structure of function pointers for the functions that are not available
//  on all OS versions.
//

SPY_DYNAMIC_FUNCTION_POINTERS gSpyDynamicFunctions = {0};

ULONG gSpyOsMajorVersion = 0;
ULONG gSpyOsMinorVersion = 0;
#endif

//
//  Control fileSpy statistics
//

FILESPY_STATISTICS gStats;

//
//  This lock is used to synchronize our attaching to a given device object.
//  This lock fixes a race condition where we could accidently attach to the
//  same device object more then once.  This race condition only occurs if
//  a volume is being mounted at the same time as this filter is being loaded.
//  This problem will never occur if this filter is loaded at boot time before
//  any file systems are loaded.
//
//  This lock is used to atomically test if we are already attached to a given
//  device object and if not, do the attach.
//

FAST_MUTEX gSpyAttachLock;

//
//  Macro for validating the FastIo dispatch routines before calling
//  them in the FastIo pass through functions.
//

#define VALID_FAST_IO_DISPATCH_HANDLER(FastIoDispatchPtr, FieldName) \
    (((FastIoDispatchPtr) != NULL) && \
     (((FastIoDispatchPtr)->SizeOfFastIoDispatch) >= \
      (FIELD_OFFSET(FAST_IO_DISPATCH, FieldName) + sizeof(VOID *))) && \
     ((FastIoDispatchPtr)->FieldName != NULL))
    
//
//  list of known device types
//

const PCHAR DeviceTypeNames[] = {
    "",
    "BEEP",
    "CD_ROM",
    "CD_ROM_FILE_SYSTEM",
    "CONTROLLER",
    "DATALINK",
    "DFS",
    "DISK",
    "DISK_FILE_SYSTEM",
    "FILE_SYSTEM",
    "INPORT_PORT",
    "KEYBOARD",
    "MAILSLOT",
    "MIDI_IN",
    "MIDI_OUT",
    "MOUSE",
    "MULTI_UNC_PROVIDER",
    "NAMED_PIPE",
    "NETWORK",
    "NETWORK_BROWSER",
    "NETWORK_FILE_SYSTEM",
    "NULL",
    "PARALLEL_PORT",
    "PHYSICAL_NETCARD",
    "PRINTER",
    "SCANNER",
    "SERIAL_MOUSE_PORT",
    "SERIAL_PORT",
    "SCREEN",
    "SOUND",
    "STREAMS",
    "TAPE",
    "TAPE_FILE_SYSTEM",
    "TRANSPORT",
    "UNKNOWN",
    "VIDEO",
    "VIRTUAL_DISK",
    "WAVE_IN",
    "WAVE_OUT",
    "8042_PORT",
    "NETWORK_REDIRECTOR",
    "BATTERY",
    "BUS_EXTENDER",
    "MODEM",
    "VDM",
    "MASS_STORAGE",
    "SMB",
    "KS",
    "CHANGER",
    "SMARTCARD",
    "ACPI",
    "DVD",
    "FULLSCREEN_VIDEO",
    "DFS_FILE_SYSTEM",
    "DFS_VOLUME",
    "SERENUM",
    "TERMSRV",
    "KSEC"
};

//
//  We need this because the compiler doesn't like doing sizeof an external
//  array in the other file that needs it (fspylib.c)
//

ULONG SizeOfDeviceTypeNames = sizeof( DeviceTypeNames );

//
//  Since functions in drivers are non-pageable by default, these pragmas 
//  allow the driver writer to tell the system what functions can be paged.
//
//  Use the PAGED_CODE() macro at the beginning of these functions'
//  implementations while debugging to ensure that these routines are
//  never called at IRQL > APC_LEVEL (therefore the routine cannot
//  be paged).
//
#if DBG && WINVER >= 0x0501
VOID
DriverUnload(
    IN PDRIVER_OBJECT DriverObject
    );
#endif

#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, DriverEntry)
#if DBG && WINVER >= 0x0501
#pragma alloc_text(PAGE, DriverUnload)
#endif
#pragma alloc_text(PAGE, SpyFsNotification)
#pragma alloc_text(PAGE, SpyClose)
#pragma alloc_text(PAGE, SpyFsControl)
#pragma alloc_text(PAGE, SpyFsControlMountVolume)
#pragma alloc_text(PAGE, SpyFsControlMountVolumeComplete)
#pragma alloc_text(PAGE, SpyFsControlLoadFileSystem)
#pragma alloc_text(PAGE, SpyFsControlLoadFileSystemComplete)
#pragma alloc_text(PAGE, SpyFastIoCheckIfPossible)
#pragma alloc_text(PAGE, SpyFastIoRead)
#pragma alloc_text(PAGE, SpyFastIoWrite)
#pragma alloc_text(PAGE, SpyFastIoQueryBasicInfo)
#pragma alloc_text(PAGE, SpyFastIoQueryStandardInfo)
#pragma alloc_text(PAGE, SpyFastIoLock)
#pragma alloc_text(PAGE, SpyFastIoUnlockSingle)
#pragma alloc_text(PAGE, SpyFastIoUnlockAll)
#pragma alloc_text(PAGE, SpyFastIoUnlockAllByKey)
#pragma alloc_text(PAGE, SpyFastIoDeviceControl)
#pragma alloc_text(PAGE, SpyFastIoDetachDevice)
#pragma alloc_text(PAGE, SpyFastIoQueryNetworkOpenInfo)
#pragma alloc_text(PAGE, SpyFastIoMdlRead)
#pragma alloc_text(PAGE, SpyFastIoPrepareMdlWrite)
#pragma alloc_text(PAGE, SpyFastIoReadCompressed)
#pragma alloc_text(PAGE, SpyFastIoWriteCompressed)
#pragma alloc_text(PAGE, SpyFastIoQueryOpen)
#pragma alloc_text(PAGE, SpyCommonDeviceIoControl)

#endif

NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
)
/*++

Routine Description:

    This is the initialization routine for the general purpose file system
    filter driver.  This routine creates the device object that represents 
    this driver in the system and registers it for watching all file systems 
    that register or unregister themselves as active file systems.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    The function value is the final status from the initialization operation.

--*/
{
    UNICODE_STRING nameString;
    NTSTATUS status;
    PFAST_IO_DISPATCH fastIoDispatch;
    ULONG i;
    UNICODE_STRING linkString;
    
    //////////////////////////////////////////////////////////////////////
    //
    //  General setup for all filter drivers.  This sets up the filter
    //  driver's DeviceObject and registers the callback routines for
    //  the filter driver.
    //
    //////////////////////////////////////////////////////////////////////

#if WINVER >= 0x0501
    //
    //  Try to load the dynamic functions that may be available for our use.
    //

    SpyLoadDynamicFunctions();

    //
    //  Now get the current OS version that we will use to determine what logic
    //  paths to take when this driver is built to run on various OS version.
    //

    SpyGetCurrentVersion();
#endif
    
    //
    //  Read the custom parameters for FileSpy from the registry
    //

    SpyReadDriverParameters( RegistryPath );

    if (FlagOn(gFileSpyDebugLevel,SPYDEBUG_BREAK_ON_DRIVER_ENTRY)) {

        DbgBreakPoint();
    }

    //
    //  Save our Driver Object.
    //

    gFileSpyDriverObject = DriverObject;

#if DBG && WINVER >= 0x0501

    //
    //  MULTIVERSION NOTE:
    //
    //  We can only support unload for testing environments if we can enumerate
    //  the outstanding device objects that our driver has.
    //

    //
    //  Unload is useful for development purposes. It is not recommended for 
    //  production versions. 
    //

    if (IS_WINDOWSXP_OR_LATER()) {

        ASSERT( NULL != gSpyDynamicFunctions.EnumerateDeviceObjectList );
        
        gFileSpyDriverObject->DriverUnload = DriverUnload;
    }
#endif

    //
    // Create the device object that will represent the FileSpy device.
    //

    RtlInitUnicodeString( &nameString, FILESPY_FULLDEVICE_NAME1 );
    
    //
    // Create the "control" device object.  Note that this device object does
    // not have a device extension (set to NULL).  Most of the fast IO routines
    // check for this condition to determine if the fast IO is directed at the
    // control device.
    //

    status = IoCreateDevice( DriverObject,
                             0,                 //  has no device extension
                             &nameString,
                             FILE_DEVICE_DISK_FILE_SYSTEM,
                             FILE_DEVICE_SECURE_OPEN,
                             FALSE,
                             &gControlDeviceObject);

    if (STATUS_OBJECT_PATH_NOT_FOUND == status) {

        //
        //  The "\FileSystem\Filter' path does not exist in the object name
        //  space, so we must be dealing with an OS pre-Windows XP.  Try
        //  the second name we have to see if we can create a device by that
        //  name.
        //

        RtlInitUnicodeString( &nameString, FILESPY_FULLDEVICE_NAME2 );

        status = IoCreateDevice( DriverObject,
                                 0,             //  has no device extension
                                 &nameString,
                                 FILE_DEVICE_DISK_FILE_SYSTEM,
                                 FILE_DEVICE_SECURE_OPEN,
                                 FALSE,
                                 &gControlDeviceObject);

        if (!NT_SUCCESS( status )) {
            
            SPY_LOG_PRINT( SPYDEBUG_ERROR,
                           ("FileSpy!DriverEntry: Error creating FileSpy control device \"%wZ\", error: %x\n",
                           &nameString,
                           status) );

            return status;
        }

        //
        //  We were able to successfully create the file spy control device
        //  using this second name, so we will now fall through and create the 
        //  symbolic link.
        //
        
    } else if (!NT_SUCCESS( status )) {

        SPY_LOG_PRINT( SPYDEBUG_ERROR,
                       ("FileSpy!DriverEntry: Error creating FileSpy control device \"%wZ\", error: %x\n",
                       &nameString,
                       status) );

        return status;

    }

    RtlInitUnicodeString( &linkString, FILESPY_DOSDEVICE_NAME );
    status = IoCreateSymbolicLink( &linkString, &nameString );

    if (!NT_SUCCESS(status)) {

        //
        //  Remove the existing symbol link and try and create it again.
        //  If this fails then quit.
        //

        IoDeleteSymbolicLink( &linkString );
        status = IoCreateSymbolicLink( &linkString, &nameString );

        if (!NT_SUCCESS(status)) {

            SPY_LOG_PRINT( SPYDEBUG_ERROR,
                           ("FileSpy!DriverEntry: IoCreateSymbolicLink failed\n") );

            IoDeleteDevice(gControlDeviceObject);
            return status;
        }
    }

    //
    // Initialize the driver object with this device driver's entry points.
    //

    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {

        DriverObject->MajorFunction[i] = SpyDispatch;
    }

    DriverObject->MajorFunction[IRP_MJ_CREATE] = SpyCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = SpyClose;
    DriverObject->MajorFunction[IRP_MJ_FILE_SYSTEM_CONTROL] = SpyFsControl;

    //
    // Allocate fast I/O data structure and fill it in.  This structure
    // is used to register the callbacks for FileSpy in the fast I/O
    // data paths.
    //

    fastIoDispatch = ExAllocatePoolWithTag( NonPagedPool, 
                                            sizeof( FAST_IO_DISPATCH ),
                                            FILESPY_POOL_TAG );

    if (!fastIoDispatch) {

        IoDeleteDevice( gControlDeviceObject );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory( fastIoDispatch, sizeof( FAST_IO_DISPATCH ) );
    fastIoDispatch->SizeOfFastIoDispatch = sizeof( FAST_IO_DISPATCH );
    fastIoDispatch->FastIoCheckIfPossible = SpyFastIoCheckIfPossible;
    fastIoDispatch->FastIoRead = SpyFastIoRead;
    fastIoDispatch->FastIoWrite = SpyFastIoWrite;
    fastIoDispatch->FastIoQueryBasicInfo = SpyFastIoQueryBasicInfo;
    fastIoDispatch->FastIoQueryStandardInfo = SpyFastIoQueryStandardInfo;
    fastIoDispatch->FastIoLock = SpyFastIoLock;
    fastIoDispatch->FastIoUnlockSingle = SpyFastIoUnlockSingle;
    fastIoDispatch->FastIoUnlockAll = SpyFastIoUnlockAll;
    fastIoDispatch->FastIoUnlockAllByKey = SpyFastIoUnlockAllByKey;
    fastIoDispatch->FastIoDeviceControl = SpyFastIoDeviceControl;
    fastIoDispatch->FastIoDetachDevice = SpyFastIoDetachDevice;
    fastIoDispatch->FastIoQueryNetworkOpenInfo = SpyFastIoQueryNetworkOpenInfo;
    fastIoDispatch->MdlRead = SpyFastIoMdlRead;
    fastIoDispatch->MdlReadComplete = SpyFastIoMdlReadComplete;
    fastIoDispatch->PrepareMdlWrite = SpyFastIoPrepareMdlWrite;
    fastIoDispatch->MdlWriteComplete = SpyFastIoMdlWriteComplete;
    fastIoDispatch->FastIoReadCompressed = SpyFastIoReadCompressed;
    fastIoDispatch->FastIoWriteCompressed = SpyFastIoWriteCompressed;
    fastIoDispatch->MdlReadCompleteCompressed = SpyFastIoMdlReadCompleteCompressed;
    fastIoDispatch->MdlWriteCompleteCompressed = SpyFastIoMdlWriteCompleteCompressed;
    fastIoDispatch->FastIoQueryOpen = SpyFastIoQueryOpen;

    DriverObject->FastIoDispatch = fastIoDispatch;

//
//  VERSION NOTE:
//
//  There are 6 FastIO routines for which file system filters are bypassed as
//  the requests are passed directly to the base file system.  These 6 routines
//  are AcquireFileForNtCreateSection, ReleaseFileForNtCreateSection,
//  AcquireForModWrite, ReleaseForModWrite, AcquireForCcFlush, and 
//  ReleaseForCcFlush.
//
//  In Windows XP and later, the FsFilter callbacks were introduced to allow
//  filters to safely hook these operations.  See the IFS Kit documentation for
//  more details on how these new interfaces work.
//
//  MULTIVERSION NOTE:
//  
//  If built for Windows XP or later, this driver is built to run on 
//  multiple versions.  When this is the case, we will test
//  for the presence of FsFilter callbacks registration API.  If we have it,
//  then we will register for those callbacks, otherwise, we will not.
//

#if WINVER >= 0x0501

    {
        FS_FILTER_CALLBACKS fsFilterCallbacks;

        if (IS_WINDOWSXP_OR_LATER()) {

            ASSERT( NULL != gSpyDynamicFunctions.RegisterFileSystemFilterCallbacks );
            
            //
            //  This version of the OS exports FsRtlRegisterFileSystemFilterCallbacks,
            //  therefore it must support the FsFilter callbacks interface.  We
            //  will register to receive callbacks for these operations.
            //
        
            //
            //  Setup the callbacks for the operations we receive through
            //  the FsFilter interface.
            //

            fsFilterCallbacks.SizeOfFsFilterCallbacks = sizeof( FS_FILTER_CALLBACKS );
            fsFilterCallbacks.PreAcquireForSectionSynchronization = SpyPreFsFilterOperation;
            fsFilterCallbacks.PostAcquireForSectionSynchronization = SpyPostFsFilterOperation;
            fsFilterCallbacks.PreReleaseForSectionSynchronization = SpyPreFsFilterOperation;
            fsFilterCallbacks.PostReleaseForSectionSynchronization = SpyPostFsFilterOperation;
            fsFilterCallbacks.PreAcquireForCcFlush = SpyPreFsFilterOperation;
            fsFilterCallbacks.PostAcquireForCcFlush = SpyPostFsFilterOperation;
            fsFilterCallbacks.PreReleaseForCcFlush = SpyPreFsFilterOperation;
            fsFilterCallbacks.PostReleaseForCcFlush = SpyPostFsFilterOperation;
            fsFilterCallbacks.PreAcquireForModifiedPageWriter = SpyPreFsFilterOperation;
            fsFilterCallbacks.PostAcquireForModifiedPageWriter = SpyPostFsFilterOperation;
            fsFilterCallbacks.PreReleaseForModifiedPageWriter = SpyPreFsFilterOperation;
            fsFilterCallbacks.PostReleaseForModifiedPageWriter = SpyPostFsFilterOperation;

            status = (gSpyDynamicFunctions.RegisterFileSystemFilterCallbacks)( DriverObject, 
                                                                              &fsFilterCallbacks );

            if (!NT_SUCCESS( status )) {

                DriverObject->FastIoDispatch = NULL;
                ExFreePoolWithTag( fastIoDispatch, FILESPY_POOL_TAG );
                IoDeleteDevice( gControlDeviceObject );
                return status;
            }
        }
    }
#endif

    //////////////////////////////////////////////////////////////////////
    //
    //  Initialize global data structures that are used for FileSpy's
    //  logging of I/O operations.
    //
    //////////////////////////////////////////////////////////////////////

    //
    //  A fast mutex was used in this case because the mutex is never acquired
    //  at DPC level or above.  Spinlocks were chosen in other cases because
    //  they are acquired at DPC level or above.  Another consideration is
    //  that on an MP machine, a spin lock will literally spin trying to 
    //  acquire the lock when the lock is already acquired.  Acquiring a
    //  previously acquired fast mutex will suspend the thread, thus freeing
    //  up the processor.
    //
    
    ExInitializeFastMutex( &gSpyDeviceExtensionListLock );
    InitializeListHead( &gSpyDeviceExtensionList );

    KeInitializeSpinLock( &gControlDeviceStateLock );

    InitializeListHead( &gOutputBufferList );

    KeInitializeSpinLock( &gOutputBufferLock );
    KeInitializeSpinLock( &gLogSequenceLock );

    ExInitializeFastMutex( &gSpyAttachLock );

#ifndef MEMORY_DBG

    //
    //  When we aren't debugging our memory usage, we want to allocate 
    //  memory from a look-aside list for better performance.  Unfortunately,
    //  we cannot benefit from the memory debugging help of the Driver 
    //  Verifier if we allocate memory from a look-aside list.
    //

    ExInitializeNPagedLookasideList( &gFreeBufferList, 
                                     NULL/*ExAllocatePoolWithTag*/, 
                                     NULL/*ExFreePool*/, 
                                     0, 
                                     RECORD_SIZE, 
                                     FILESPY_LOGRECORD_TAG, 
                                     100 );
#endif

        
    //
    //  Initialize the naming environment
    //

    SpyInitNamingEnvironment();

    //
    //  Init internal strings
    //

    RtlInitUnicodeString(&gVolumeString, L"VOLUME");
    RtlInitUnicodeString(&gOverrunString, L"......");
    RtlInitUnicodeString(&gPagingIoString, L"Paging IO");

    //
    //  If we are supposed to attach to all devices, register a callback
    //  with IoRegisterFsRegistrationChange so that we are called whenever a
    //  file system registers with the IO Manager.
    //
    //  VERSION NOTE:
    //
    //  On Windows XP and later this will also enumerate all existing file
    //  systems (except the RAW file systems).  On Windows 2000 this does not
    //  enumerate the file systems that were loaded before this filter was
    //  loaded.
    //

    if (gFileSpyAttachMode == FILESPY_ATTACH_ALL_VOLUMES) {
    
        status = IoRegisterFsRegistrationChange( DriverObject, SpyFsNotification );
        
        if (!NT_SUCCESS( status )) {

            SPY_LOG_PRINT( SPYDEBUG_ERROR,
                           ("FileSpy!DriverEntry: Error registering FS change notification, status=%08x\n", 
                            status) );

            DriverObject->FastIoDispatch = NULL;
            ExFreePoolWithTag( fastIoDispatch, FILESPY_POOL_TAG );
            IoDeleteDevice( gControlDeviceObject );
            return status;
        }
    }

    //
    //  Clear the initializing flag on the control device object since we
    //  have now successfully initialized everything.
    //

    ClearFlag( gControlDeviceObject->Flags, DO_DEVICE_INITIALIZING );

    return STATUS_SUCCESS;
}

#if DBG && WINVER >= 0x0501

VOID
DriverUnload (
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This routine is called when a driver can be unloaded.  This performs all of
    the necessary cleanup for unloading the driver from memory.  Note that an
    error can not be returned from this routine.
    
    When a request is made to unload a driver the IO System will cache that
    information and not actually call this routine until the following states
    have occurred:
    - All device objects which belong to this filter are at the top of their
      respective attachment chains.
    - All handle counts for all device objects which belong to this filter have
      gone to zero.

    WARNING: Microsoft does not officially support the unloading of File
             System Filter Drivers.  This is an example of how to unload
             your driver if you would like to use it during development.
             This should not be made available in production code.

Arguments:

    DriverObject - Driver object for this module

Return Value:

    None.

--*/

{
    PFILESPY_DEVICE_EXTENSION devExt;
    PFAST_IO_DISPATCH fastIoDispatch;
    NTSTATUS status;
    ULONG numDevices;
    ULONG i;
    LARGE_INTEGER interval;
    UNICODE_STRING linkString;
#   define DEVOBJ_LIST_SIZE 64
    PDEVICE_OBJECT devList[DEVOBJ_LIST_SIZE];

    ASSERT(DriverObject == gFileSpyDriverObject);

    //
    //  Log we are unloading
    //

    SPY_LOG_PRINT( SPYDEBUG_DISPLAY_ATTACHMENT_NAMES,
                   ("FileSpy!DriverUnload:                        Unloading Driver (%p)\n",
                    DriverObject) );

    //
    //  Remove the symbolic link so no one else will be able to find it.
    //

    RtlInitUnicodeString( &linkString, FILESPY_DOSDEVICE_NAME );
    IoDeleteSymbolicLink( &linkString );

    //
    //  Don't get anymore file system change notifications
    //

    IoUnregisterFsRegistrationChange( DriverObject, SpyFsNotification );

    //
    //  This is the loop that will go through all of the devices we are attached
    //  to and detach from them.  Since we don't know how many there are and
    //  we don't want to allocate memory (because we can't return an error)
    //  we will free them in chunks using a local array on the stack.
    //

    for (;;) {

        //
        //  Get what device objects we can for this driver.  Quit if there
        //  are not any more.  Note that this routine should always be defined
        //  since this routine is only compiled for Windows XP and later.
        //

        ASSERT( NULL != gSpyDynamicFunctions.EnumerateDeviceObjectList );
        status = (gSpyDynamicFunctions.EnumerateDeviceObjectList)(
                        DriverObject,
                        devList,
                        sizeof(devList),
                        &numDevices);

        if (numDevices <= 0)  {

            break;
        }

        numDevices = min( numDevices, DEVOBJ_LIST_SIZE );

        //
        //  First go through the list and detach each of the devices.
        //  Our control device object does not have a DeviceExtension and
        //  is not attached to anything so don't detach it.
        //

        for (i=0; i < numDevices; i++) {

            devExt = devList[i]->DeviceExtension;
            if (NULL != devExt) {

                IoDetachDevice( devExt->AttachedToDeviceObject );
            }
        }

        //
        //  The IO Manager does not currently add a reference count to a device
        //  object for each outstanding IRP.  This means there is no way to
        //  know if there are any outstanding IRPs on the given device.
        //  We are going to wait for a reasonable amount of time for pending
        //  irps to complete.  
        //
        //  WARNING: This does not work 100% of the time and the driver may be
        //           unloaded before all IRPs are completed during high stress
        //           situations.  The system will fault if this occurs.  This
        //           is a sample of how to do this during testing.  This is
        //           not recommended for production code.
        //

        interval.QuadPart = (5 * DELAY_ONE_SECOND);      //delay 5 seconds
        KeDelayExecutionThread( KernelMode, FALSE, &interval );

        //
        //  Now go back through the list and delete the device objects.
        //

        for (i=0; i < numDevices; i++) {

            //
            //  See if this is our control device object.  If not then cleanup
            //  the device extension.  If so then clear the global pointer
            //  that references it.
            //

            if (NULL != devList[i]->DeviceExtension) {

                SpyCleanupMountedDevice( devList[i] );

            } else {

                ASSERT(devList[i] == gControlDeviceObject);
                ASSERT(gControlDeviceState == CLOSED);
                gControlDeviceObject = NULL;
            }

            //
            //  Delete the device object, remove reference counts added by
            //  IoEnumerateDeviceObjectList.  Note that the delete does
            //  not actually occur until the reference count goes to zero.
            //

            IoDeleteDevice( devList[i] );
            ObDereferenceObject( devList[i] );
        }
    }

    //
    //  Delete the look aside list.
    //

    ASSERT(IsListEmpty( &gSpyDeviceExtensionList ));

#ifndef MEMORY_DBG
    ExDeleteNPagedLookasideList( &gFreeBufferList );
#endif

    //
    //  Free our FastIO table
    //

    fastIoDispatch = DriverObject->FastIoDispatch;
    DriverObject->FastIoDispatch = NULL;
    ExFreePoolWithTag( fastIoDispatch, FILESPY_POOL_TAG );
}

#endif

VOID
SpyFsNotification (
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN FsActive
    )
/*++

Routine Description:

    This routine is invoked whenever a file system has either registered or
    unregistered itself as an active file system.

    For the former case, this routine creates a device object and attaches it
    to the specified file system's device object.  This allows this driver
    to filter all requests to that file system.

    For the latter case, this file system's device object is located,
    detached, and deleted.  This removes this file system as a filter for
    the specified file system.

Arguments:

    DeviceObject - Pointer to the file system's device object.

    FsActive - Boolean indicating whether the file system has registered
        (TRUE) or unregistered (FALSE) itself as an active file system.

Return Value:

    None.

--*/
{
    UNICODE_STRING name;
    WCHAR nameBuffer[DEVICE_NAMES_SZ];

    PAGED_CODE();

    //
    //  Init local name buffer
    //

    RtlInitEmptyUnicodeString( &name, 
                               nameBuffer, 
                               sizeof( nameBuffer ) );

    //
    //  The DeviceObject passed in is always the base device object at this
    //  point because it is the file system's control device object.  We can
    //  just query this object's name directly.
    //
    
    SpyGetObjectName( DeviceObject, 
                      &name );

    //
    //  Display the names of all the file system we are notified of
    //

    SPY_LOG_PRINT( SPYDEBUG_DISPLAY_ATTACHMENT_NAMES,
                   ("FileSpy!SpyFsNotification:                   %s   %p \"%wZ\" (%s)\n",
                    (FsActive) ? "Activating file system  " : "Deactivating file system",
                    DeviceObject,
                    &name,
                    GET_DEVICE_TYPE_NAME(DeviceObject->DeviceType)) );

    //
    //  See if we want to ATTACH or DETACH from the given file system.
    //

    if (FsActive) {

        SpyAttachToFileSystemDevice( DeviceObject, &name );

    } else {

        SpyDetachFromFileSystemDevice( DeviceObject );
    }
}


NTSTATUS
SpyPassThrough (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
)
/*++

Routine Description:

    This routine is the main dispatch routine for the general purpose file
    system driver.  It simply passes requests onto the next driver in the
    stack, which is presumably a disk file system, while logging any
    relevant information if logging is turned on for this DeviceObject.

Arguments:

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.
        
    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

Note:

    This routine passes the I/O request through to the next driver
    *without* removing itself from the stack (like sfilter) since it could
    want to see the result of this I/O request.
    
    To remain in the stack, we have to copy the caller's parameters to the
    next stack location.  Note that we do not want to copy the caller's I/O
    completion routine into the next stack location, or the caller's routine
    will get invoked twice.  This is why we NULL out the Completion routine.
    If we are logging this device, we set our own Completion routine.
    
--*/
{
    PRECORD_LIST recordList = NULL;
    KEVENT waitEvent;
    NTSTATUS status;
    BOOLEAN syncToDispatch;

    ASSERT(IS_FILESPY_DEVICE_OBJECT( DeviceObject ));

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //

    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_IRP_OPS )) {

        SpyDumpIrpOperation( TRUE, Irp );
    }

    //
    //  See if we should log this IRP
    //
    
    if (SHOULD_LOG( DeviceObject )) {

        //
        // The ControlDevice is opened, so allocate the Record 
        // and log the Irp information if we have the memory.
        //

        recordList = SpyNewRecord(0);

        if (NULL != recordList) {

            SpyLogIrp( Irp, recordList );

            //
            //  Since we are logging this operation, we want to 
            //  call our completion routine.
            //

            IoCopyCurrentIrpStackLocationToNext( Irp );

            KeInitializeEvent( &waitEvent, 
                               NotificationEvent, 
                               FALSE );

            recordList->WaitEvent = &waitEvent;

            IoSetCompletionRoutine( Irp,
                                    SpyPassThroughCompletion,
                                    recordList,
                                    TRUE,
                                    TRUE,
                                    TRUE);
        } else {

            //
            //  We could not get a record to log with so get this driver out
            //  of the driver stack and get to the next driver as quickly as
            //  possible.
            //

            IoSkipCurrentIrpStackLocation( Irp );
        }

    } else {

        //
        //  We are not logging so get this driver out of the driver stack and
        //  get to the next driver as quickly as possible.
        //

        IoSkipCurrentIrpStackLocation( Irp );
    }

    //
    //  Determine if we are syncing back to the dispatch routine.  We need to
    //  do this before calling down because the recordList entry could be free
    //  upon return.
    //
    
    syncToDispatch = ((NULL != recordList) &&
                      (FlagOn(recordList->Flags,RLFL_SYNC_TO_DISPATCH)));

    //
    // Now call the next file system driver with the request.
    //

    status = IoCallDriver( ((PFILESPY_DEVICE_EXTENSION)DeviceObject->DeviceExtension)->AttachedToDeviceObject, Irp );

    //
    //  If we are logging and we need to synchronize back to our dispatch routine
    //  for completion processing, do it now.
    //

    if (syncToDispatch) {

        //
        //  We are syncing back to the dispatch routine, wait for the operation to
        //  complete.
        //

	    if (STATUS_PENDING == status) {

		    status = KeWaitForSingleObject( &waitEvent,
		                                    Executive,
		                                    KernelMode,
		                                    FALSE,
		                                    NULL );

	        ASSERT(STATUS_SUCCESS == status);
	    }

        //
        //  Verify the completion has actually been run
        //

        ASSERT(KeReadStateEvent(&waitEvent) || 
               !NT_SUCCESS(Irp->IoStatus.Status));

        //
        //  Do completion processing
        //

        SpyLogIrpCompletion( Irp, recordList );

        //
        //  Continue processing the operation
        //

        status = Irp->IoStatus.Status;

        IoCompleteRequest( Irp, IO_NO_INCREMENT );
    }

    return status;
}

NTSTATUS
SpyPassThroughCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
)
/*++

Routine Description:

    This routine is the completion routine SpyPassThrough.  This is used
    to log the information that can only be gathered after the I/O request
    has been completed.

    Once we are done logging all the information we care about, we append
    the record to the gOutputBufferList to be returned to the user.
    
    Note: This routine will only be set if we were trying to log the
        specified device when the Irp originated and we were able to
        allocate a record to store this logging information.

Arguments:

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.
        
    Irp - Pointer to the request packet representing the I/O request.
    
    Context - Pointer to the RECORD_LIST structure in which we store the
        information we are logging.

Return Value:

    The function value is the status of the operation.

--*/
{
    PRECORD_LIST recordList = (PRECORD_LIST)Context;

    ASSERT(IS_FILESPY_DEVICE_OBJECT( DeviceObject ));
    UNREFERENCED_PARAMETER( DeviceObject );

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_IRP_OPS )) {

        SpyDumpIrpOperation( FALSE, Irp );
    }
    
    //
    //  If we are to SYNC back to the dispatch routine, signal the event
    //  and return
    //

    if (FlagOn(recordList->Flags,RLFL_SYNC_TO_DISPATCH)) {

        KeSetEvent( recordList->WaitEvent, IO_NO_INCREMENT, FALSE );
        
        //
        //  When syncing back to the dispatch routine do not propagate the
        //  IRP_PENDING flag.
        //

        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    //
    //  Do completion log processing
    //

    SpyLogIrpCompletion( Irp, recordList );
        
    //
    //  Propagate the IRP pending flag.
    //

    if (Irp->PendingReturned) {
        
        IoMarkIrpPending( Irp );
    }

    return STATUS_SUCCESS;
}

NTSTATUS
SpyDispatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
)
/*++

Routine Description:

    This function completes all requests on the gControlDeviceObject 
    (FileSpy's device object) and passes all other requests on to the 
    SpyPassThrough function.

Arguments:

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.
        
    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    If this is a request on the gControlDeviceObject, STATUS_SUCCESS 
    will be returned unless the device is already attached.  In that case,
    STATUS_DEVICE_ALREADY_ATTACHED is returned.

    If this is a request on a device other than the gControlDeviceObject,
    the function will return the value of SpyPassThrough().

--*/
{
    NTSTATUS status = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpStack;
    
    if (DeviceObject == gControlDeviceObject) {

        //
        //  If the specified debug level is set, output what operation
        //  we are seeing to the debugger.
        //

        if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_IRP_OPS )) {

            SpyDumpIrpOperation( TRUE, Irp );
        }

        //
        //  A request is being made on our control device object
        //

        Irp->IoStatus.Information = 0;
    
        irpStack = IoGetCurrentIrpStackLocation( Irp );
       
        switch (irpStack->MajorFunction) {

            case IRP_MJ_DEVICE_CONTROL:

                //
                //  This is a private device control irp for our control device.
                //  Pass the parameter information along to the common routine
                //  use to service these requests.
                //
            
                status = SpyCommonDeviceIoControl( irpStack->Parameters.DeviceIoControl.Type3InputBuffer,
                                                   irpStack->Parameters.DeviceIoControl.InputBufferLength,
                                                   Irp->UserBuffer,
                                                   irpStack->Parameters.DeviceIoControl.OutputBufferLength,
                                                   irpStack->Parameters.DeviceIoControl.IoControlCode,
                                                   &Irp->IoStatus );
                break;

            case IRP_MJ_CLEANUP:
        
                //
                //  This is the cleanup that we will see when all references to a handle
                //  opened to filespy's control device object are cleaned up.  We don't
                //  have to do anything here since we wait until the actual IRP_MJ_CLOSE
                //  to clean up the name cache.  Just complete the IRP successfully.
                //

                status = STATUS_SUCCESS;

                break;
                
            default:

                status = STATUS_INVALID_DEVICE_REQUEST;
        }

        Irp->IoStatus.Status = status;

        //
        //  We have completed all processing for this IRP, so tell the 
        //  I/O Manager.  This IRP will not be passed any further down
        //  the stack since no drivers below FileSpy care about this 
        //  I/O operation that was directed to FileSpy.
        //

        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return status;
    }

    return SpyPassThrough( DeviceObject, Irp );
}

NTSTATUS
SpyCreate (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
)
/*++

Routine Description:

    This is the routine that is associated with IRP_MJ_CREATE irp.  If the 
    DeviceObject is the ControlDevice, we do the creation work for the 
    ControlDevice and complete the irp.  Otherwise, we pass through
    this irp for another device to complete.
    
    Note: Some of the code in this function duplicates the functions 
        SpyDispatch and SpyPassThrough, but a design decision was made that 
        it was worth the code duplication to break out the irp handlers 
        that can be pageable code.
    
Arguments:

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.
        
    Irp - Pointer to the request packet representing the I/O request.
    
Return Value:

    If DeviceObject == gControlDeviceObject, then this function will 
    complete the Irp and return the status of that completion.  Otherwise,
    this function returns the result of calling SpyPassThrough.
    
--*/
{
    NTSTATUS status;
    KIRQL oldIrql;

    //
    //  See if they want to open the control device object for the filter.
    //  This will only allow one thread to have this object open at a time.
    //  All other requests will be failed.
    //

    if (DeviceObject == gControlDeviceObject) {

        //
        //  If the specified debug level is set, output what operation
        //  we are seeing to the debugger.
        //

        if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_IRP_OPS )) {

            SpyDumpIrpOperation( TRUE, Irp );
        }

        //
        //  A CREATE request is being made on our gControlDeviceObject.
        //  See if someone else has it open.  If so, disallow this open.
        //

        KeAcquireSpinLock( &gControlDeviceStateLock, &oldIrql );

        if (gControlDeviceState != CLOSED) {

            Irp->IoStatus.Status = STATUS_DEVICE_ALREADY_ATTACHED;
            Irp->IoStatus.Information = 0;

        } else {

            Irp->IoStatus.Status = STATUS_SUCCESS;
            Irp->IoStatus.Information = FILE_OPENED;

            gControlDeviceState = OPENED;
        }

        KeReleaseSpinLock( &gControlDeviceStateLock, oldIrql );

        //
        // Since this is our gControlDeviceObject, we complete the
        // irp here.
        //

        status = Irp->IoStatus.Status;

        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return status;
    }

    ASSERT( IS_FILESPY_DEVICE_OBJECT( DeviceObject ) );

    //
    // This is NOT our gControlDeviceObject, so let SpyPassThrough handle
    // it appropriately
    //

    return SpyPassThrough( DeviceObject, Irp );
}


NTSTATUS
SpyClose (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This is the routine that is associated with IRP_MJ_CLOSE irp.  If the 
    DeviceObject is the ControlDevice, we do the necessary cleanup and
    complete the irp.  Otherwise, we pass through this irp for another device
    to complete.
    
Arguments:

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.
        
    Irp - Pointer to the request packet representing the I/O request.
    
Return Value:

    If DeviceObject == gControlDeviceObject, then this function will 
    complete the Irp and return the status of that completion.  Otherwise,
    this function returns the result of calling SpyPassThrough.
    
--*/
{
    PAGED_CODE();

    //
    //  See if they are closing the control device object for the filter.
    //

    if (DeviceObject == gControlDeviceObject) {

        //
        //  If the specified debug level is set, output what operation
        //  we are seeing to the debugger.
        //

        if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_IRP_OPS )) {

            SpyDumpIrpOperation( TRUE, Irp );
        }

        //
        //  A CLOSE request is being made on our gControlDeviceObject.
        //  Cleanup state.
        //

        SpyCloseControlDevice();

        //
        //  We have completed all processing for this IRP, so tell the 
        //  I/O Manager.  This IRP will not be passed any further down
        //  the stack since no drivers below FileSpy care about this 
        //  I/O operation that was directed to FileSpy.
        //

        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return STATUS_SUCCESS;
    }

    ASSERT( IS_FILESPY_DEVICE_OBJECT( DeviceObject ) );
 

    //
    //  Log (if it is turned on) and pass the request on.
    //

    return SpyPassThrough( DeviceObject, Irp );
}


NTSTATUS
SpyFsControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is invoked whenever an I/O Request Packet (IRP) w/a major
    function code of IRP_MJ_FILE_SYSTEM_CONTROL is encountered.  For most
    IRPs of this type, the packet is simply passed through.  However, for
    some requests, special processing is required.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

--*/

{
    PIO_STACK_LOCATION pIrpSp = IoGetCurrentIrpStackLocation( Irp );

    PAGED_CODE();

    //
    //  If this is for our control device object, fail the operation
    //

    if (gControlDeviceObject == DeviceObject) {

        //
        //  If the specified debug level is set, output what operation
        //  we are seeing to the debugger.
        //

        if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_IRP_OPS )) {

            SpyDumpIrpOperation( TRUE, Irp );
        }

        //
        //  If this device object is our control device object rather than 
        //  a mounted volume device object, then this is an invalid request.
        //

        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest( Irp, IO_NO_INCREMENT );

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    ASSERT(IS_FILESPY_DEVICE_OBJECT( DeviceObject ));

    //
    //  Process the minor function code.
    //

    switch (pIrpSp->MinorFunction) {

        case IRP_MN_MOUNT_VOLUME:

            return SpyFsControlMountVolume ( DeviceObject, Irp );

        case IRP_MN_LOAD_FILE_SYSTEM:

            return SpyFsControlLoadFileSystem ( DeviceObject, Irp );

        case IRP_MN_USER_FS_REQUEST:
        {
            switch (pIrpSp->Parameters.FileSystemControl.FsControlCode) {

                case FSCTL_DISMOUNT_VOLUME:
                {
                    PFILESPY_DEVICE_EXTENSION devExt = DeviceObject->DeviceExtension;

                    SPY_LOG_PRINT( SPYDEBUG_DISPLAY_ATTACHMENT_NAMES,
                                   ("FILESPY!SpyFsControl:                        Dismounting volume         %p \"%wZ\"\n",
                                    devExt->AttachedToDeviceObject,
                                    &devExt->DeviceName) );
                    break;
                }
            }
            break;
        }
    } 

    //
    // This is a regular FSCTL that we need to let the filters see
    // Just do the callbacks for all the filters & passthrough
    //

    return SpyPassThrough( DeviceObject, Irp );
}


NTSTATUS
SpyFsControlCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is invoked for the completion of a mount/LoadFS request.  This
    will load the IRP and then signal the waiting dispatch routine.

Arguments:

    DeviceObject - Pointer to this driver's device object that was attached to
            the file system device object

    Irp - Pointer to the IRP that was just completed.

    Context - Pointer to the device object allocated during the down path so
            we wouldn't have to deal with errors here.

Return Value:

    The return value is always STATUS_SUCCESS.

--*/

{
    PRECORD_LIST recordList = ((PSPY_COMPLETION_CONTEXT)Context)->RecordList;

    ASSERT(IS_FILESPY_DEVICE_OBJECT( DeviceObject ));
    UNREFERENCED_PARAMETER( DeviceObject );

    //
    //  Log the completion (if we need to)
    //

    if (NULL != recordList) {

        SpyLogIrpCompletion( Irp, recordList );
    }

#if WINVER >= 0x0501
    if (IS_WINDOWSXP_OR_LATER()) {

        PKEVENT event = &((PSPY_COMPLETION_CONTEXT_WXP_OR_LATER)Context)->WaitEvent;

        //
        //  wakeup the dispatch routine
        //

        KeSetEvent(event, IO_NO_INCREMENT, FALSE);

    } else {
#endif

        //
        //  For Windows 2000, if we are not at passive level, we should 
        //  queue this work to a worker thread using the workitem that is in 
        //  Context.
        //

        if (KeGetCurrentIrql() > PASSIVE_LEVEL) {

            //
            //  We are not at passive level, but we need to be to do our work,
            //  so queue off to the worker thread.

            ExQueueWorkItem( &(((PSPY_COMPLETION_CONTEXT_W2K)Context)->WorkItem),
                             DelayedWorkQueue );

        } else {

            PSPY_COMPLETION_CONTEXT_W2K completionContext = Context;

            //
            //  We are already at passive level, so we will just call our 
            //  worker routine directly.
            //

            (completionContext->WorkItem.WorkerRoutine)(completionContext->WorkItem.Parameter);
        }

#if WINVER >= 0x0501
    }
#endif

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
SpyFsControlMountVolume (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This processes a MOUNT VOLUME request

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

--*/

{
    PFILESPY_DEVICE_EXTENSION devExt = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION pIrpSp = IoGetCurrentIrpStackLocation( Irp );
    PDEVICE_OBJECT newDeviceObject;
    PFILESPY_DEVICE_EXTENSION newDevExt;
    NTSTATUS status;
    PRECORD_LIST recordList = NULL;
    PSPY_COMPLETION_CONTEXT_W2K completionContext;

    PAGED_CODE();
    ASSERT(IS_FILESPY_DEVICE_OBJECT( DeviceObject ));

    //
    //  We should only see these FS_CTLs to control device objects.
    //
    
    ASSERT(!FlagOn(devExt->Flags,IsVolumeDeviceObject));

    //
    //  This is a mount request.  Create a device object that can be
    //  attached to the file system's volume device object if this request
    //  is successful.  We allocate this memory now since we can not return
    //  an error after the completion routine.
    //
    //  Since the device object we are going to attach to has not yet been
    //  created (it is created by the base file system) we are going to use
    //  the type of the file system control device object.  We are assuming
    //  that the file system control device object will have the same type
    //  as the volume device objects associated with it.
    //

    status = IoCreateDevice( gFileSpyDriverObject,
                             sizeof( FILESPY_DEVICE_EXTENSION ),
                             NULL,
                             DeviceObject->DeviceType,
                             0,
                             FALSE,
                             &newDeviceObject );

    if (!NT_SUCCESS( status )) {

        //
        //  If we can not attach to the volume, then simply skip it.
        //

        SPY_LOG_PRINT( SPYDEBUG_ERROR,
                       ("FileSpy!SpyFsControlMountVolume: Error creating volume device object, status=%08x\n", 
                        status) );

        return SpyPassThrough( DeviceObject, Irp );
    }

    //
    //  We need to save the RealDevice object pointed to by the vpb
    //  parameter because this vpb may be changed by the underlying
    //  file system.  Both FAT and CDFS may change the VPB address if
    //  the volume being mounted is one they recognize from a previous
    //  mount.
    //

    newDevExt = newDeviceObject->DeviceExtension;
    newDevExt->Flags = 0;
        
    newDevExt->DiskDeviceObject = pIrpSp->Parameters.MountVolume.Vpb->RealDevice;

    //
    //  Get the name of this device
    //

    RtlInitEmptyUnicodeString( &newDevExt->DeviceName, 
                               newDevExt->DeviceNameBuffer, 
                               sizeof(newDevExt->DeviceNameBuffer) );

    SpyGetObjectName( newDevExt->DiskDeviceObject, 
                      &newDevExt->DeviceName );

    //
    //  Since we have our own private completion routine we need to
    //  do our own logging of this operation, do it now.
    //

    if (SHOULD_LOG( DeviceObject )) {

        //
        // Lock the IRP if we can
        //

        recordList = SpyNewRecord(0);

        if (recordList) {

            SpyLogIrp( Irp, recordList );
        }
    }

    //
    //  Send the IRP to the legacy filters.  Note that the IRP we are sending
    //  down is for our CDO, not the new VDO that we have been passing to
    //  the mini-filters.
    //

    //
    //  VERSION NOTE:
    //
    //  On Windows 2000, we cannot simply synchronize back to the dispatch
    //  routine to do our post-mount processing.  We need to do this work at
    //  passive level, so we will queue that work to a worker thread from
    //  the completion routine.
    //
    //  For Windows XP and later, we can safely synchronize back to the dispatch
    //  routine.  The code below shows both methods.  Admittedly, the code
    //  would be simplified if you chose to only use one method or the other, 
    //  but you should be able to easily adapt this for your needs.
    //

#if WINVER >= 0x0501
    if (IS_WINDOWSXP_OR_LATER()) {

        SPY_COMPLETION_CONTEXT_WXP_OR_LATER completionContext;
        
        IoCopyCurrentIrpStackLocationToNext ( Irp );

        completionContext.RecordList = recordList;
        KeInitializeEvent( &completionContext.WaitEvent, 
                           NotificationEvent, 
                           FALSE );

        IoSetCompletionRoutine( Irp,
                                SpyFsControlCompletion,
                                &completionContext,     //context parameter
                                TRUE,
                                TRUE,
                                TRUE );

        status = IoCallDriver( devExt->AttachedToDeviceObject, Irp );

        //
        //  Wait for the operation to complete
        //

    	if (STATUS_PENDING == status) {

    		status = KeWaitForSingleObject( &completionContext.WaitEvent,
    		                                Executive,
    		                                KernelMode,
    		                                FALSE,
    		                                NULL );
    	    ASSERT(STATUS_SUCCESS == status);
    	}

        //
        //  Verify the IoCompleteRequest was called
        //

        ASSERT(KeReadStateEvent(&completionContext.WaitEvent) ||
               !NT_SUCCESS(Irp->IoStatus.Status));

        status = SpyFsControlMountVolumeComplete( DeviceObject,
                                                  Irp,
                                                  newDeviceObject );
        
    } else {
#endif    
        completionContext = ExAllocatePoolWithTag( NonPagedPool, 
                                                   sizeof( SPY_COMPLETION_CONTEXT_W2K ),
                                                   FILESPY_POOL_TAG );

        if (completionContext == NULL) {

            IoSkipCurrentIrpStackLocation( Irp );

            status = IoCallDriver( devExt->AttachedToDeviceObject, Irp );
            
        } else {
        
            completionContext->RecordList = recordList;

            ExInitializeWorkItem( &completionContext->WorkItem,
                                  SpyFsControlMountVolumeCompleteWorker,
                                  completionContext );
            completionContext->DeviceObject = DeviceObject,
            completionContext->Irp = Irp;
            completionContext->NewDeviceObject = newDeviceObject;

            IoCopyCurrentIrpStackLocationToNext ( Irp );

            IoSetCompletionRoutine( Irp,
                                    SpyFsControlCompletion,
                                    completionContext,     //context parameter
                                    TRUE,
                                    TRUE,
                                    TRUE );

            status = IoCallDriver( devExt->AttachedToDeviceObject, Irp );
        }
#if WINVER >= 0x0501        
    }
#endif
    return status;
}

VOID
SpyFsControlMountVolumeCompleteWorker (
    IN PSPY_COMPLETION_CONTEXT_W2K Context
    )
/*++

Routine Description:

    The worker thread routine that will call our common routine to do the
    post-MountVolume work.

Arguments:

    Context - The context passed to this worker thread.
    
Return Value:

    None.

--*/
{
    SpyFsControlMountVolumeComplete( Context->DeviceObject,
                                     Context->Irp,
                                     Context->NewDeviceObject );

    ExFreePoolWithTag( Context, FILESPY_POOL_TAG );
}

NTSTATUS
SpyFsControlMountVolumeComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PDEVICE_OBJECT NewDeviceObject
    )
/*++

Routine Description:

    This does the post-Mount work and must be done at PASSIVE_LEVEL.

Arguments:

    DeviceObject - The device object for this operation,

    Irp - The IRP for this operation that we will complete once we are finished
        with it.
    
Return Value:

    Returns the status of the mount operation.

--*/
{
    PVPB vpb;
    PFILESPY_DEVICE_EXTENSION newDevExt = NewDeviceObject->DeviceExtension;
    PDEVICE_OBJECT attachedDeviceObject;
    NTSTATUS status;

    PAGED_CODE();
    
    //
    //  Get the correct VPB from the real device object saved in our
    //  device extension.  We do this because the VPB in the IRP stack
    //  may not be the correct VPB when we get here.  The underlying
    //  file system may change VPBs if it detects a volume it has
    //  mounted previously.
    //

    vpb = newDevExt->DiskDeviceObject->Vpb;

    //
    //  See if the mount was successful.
    //

    if (NT_SUCCESS( Irp->IoStatus.Status )) {

        //
        //  Acquire lock so we can atomically test if we area already attached
        //  and if not, then attach.  This prevents a double attach race
        //  condition.
        //

        ExAcquireFastMutex( &gSpyAttachLock );

        //
        //  The mount succeeded.  If we are not already attached, attach to the
        //  device object.  Note: one reason we could already be attached is
        //  if the underlying file system revived a previous mount.
        //

        if (!SpyIsAttachedToDevice( vpb->DeviceObject, &attachedDeviceObject )) {

            //
            //  Attach to the new mounted volume.  The correct file system device
            //  object that was just mounted is pointed to by the VPB.
            //

            status = SpyAttachToMountedDevice( vpb->DeviceObject,
                                               NewDeviceObject );

            if (!NT_SUCCESS( status )) {

                //
                //  The attachment failed, cleanup.  Since we are in the
                //  post-mount phase, we can not fail this operation.
                //  We simply won't be attached.  The only reason this should
                //  ever happen at this point is if somebody already started
                //  dismounting the volume therefore not attaching should
                //  not be a problem.
                //

                SpyCleanupMountedDevice( NewDeviceObject );
                IoDeleteDevice( NewDeviceObject );

            } else {

                //
                //  We completed initialization of this device object, so now
                //  clear the initializing flag.
                //

                ClearFlag( NewDeviceObject->Flags, DO_DEVICE_INITIALIZING );
            }

            ASSERT( NULL == attachedDeviceObject );

        } else {

            //
            //  We were already attached, cleanup device object
            //

            SPY_LOG_PRINT( SPYDEBUG_DISPLAY_ATTACHMENT_NAMES,
                           ("FileSpy!SpyFsControlMountVolume:             Mount volume failure for   %p \"%wZ\", already attached\n",
                            ((PFILESPY_DEVICE_EXTENSION)attachedDeviceObject->DeviceExtension)->AttachedToDeviceObject,
                            &newDevExt->DeviceName) );

            SpyCleanupMountedDevice( NewDeviceObject );
            IoDeleteDevice( NewDeviceObject );

            //
            //  Remove the reference added by SpyIsAttachedToDevice.
            //
        
            ObDereferenceObject( attachedDeviceObject );
        }

        //
        //  Release the lock
        //

        ExReleaseFastMutex( &gSpyAttachLock );

    } else {

        //
        //  Display why mount failed.  Setup the buffers.
        //

        SPY_LOG_PRINT( SPYDEBUG_DISPLAY_ATTACHMENT_NAMES,
                       ("FileSpy!SpyFsControlMountVolume:             Mount volume failure for   %p \"%wZ\", status=%08x\n",
                        DeviceObject,
                        &newDevExt->DeviceName,
                        Irp->IoStatus.Status) );

        //
        //  The mount request failed.  Cleanup and delete the device
        //  object we created
        //

        SpyCleanupMountedDevice( NewDeviceObject );
        IoDeleteDevice( NewDeviceObject );
    }

    //
    //  Continue processing the operation
    //

    status = Irp->IoStatus.Status;

    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return status;
}


NTSTATUS
SpyFsControlLoadFileSystem (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is invoked whenever an I/O Request Packet (IRP) w/a major
    function code of IRP_MJ_FILE_SYSTEM_CONTROL is encountered.  For most
    IRPs of this type, the packet is simply passed through.  However, for
    some requests, special processing is required.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

--*/

{
    PFILESPY_DEVICE_EXTENSION devExt = DeviceObject->DeviceExtension;
    NTSTATUS status;
    PSPY_COMPLETION_CONTEXT_W2K completionContext;
    PRECORD_LIST recordList = NULL;

    PAGED_CODE();
    ASSERT(IS_FILESPY_DEVICE_OBJECT( DeviceObject ));

    //
    //  This is a "load file system" request being sent to a file system
    //  recognizer device object.  This IRP_MN code is only sent to 
    //  file system recognizers.
    //
    //  NOTE:  Since we no longer are attaching to the standard Microsoft file
    //         system recognizers we will normally never execute this code.
    //         However, there might be 3rd party file systems which have their
    //         own recognizer which may still trigger this IRP.
    //

    SPY_LOG_PRINT( SPYDEBUG_DISPLAY_ATTACHMENT_NAMES,
                   ("FileSpy!SpyFsControlLoadFileSystem:          Loading File System, Detaching from \"%wZ\"\n",
                    &devExt->DeviceName) );

    //
    //  Since we have our own private completion routine we need to
    //  do our own logging of this operation, do it now.
    //

    if (SHOULD_LOG( DeviceObject )) {

        recordList = SpyNewRecord(0);

        if (recordList) {

            SpyLogIrp( Irp, recordList );
        }
    }

    //
    //  Set a completion routine so we can delete the device object when
    //  the load is complete.
    //

    //
    //  VERSION NOTE:
    //
    //  On Windows 2000, we cannot simply synchronize back to the dispatch
    //  routine to do our post-load filesystem processing.  We need to do 
    //  this work at passive level, so we will queue that work to a worker 
    //  thread from the completion routine.
    //
    //  For Windows XP and later, we can safely synchronize back to the dispatch
    //  routine.  The code below shows both methods.  Admittedly, the code
    //  would be simplified if you chose to only use one method or the other, 
    //  but you should be able to easily adapt this for your needs.
    //

#if WINVER >= 0x0501

    if (IS_WINDOWSXP_OR_LATER()) {

        SPY_COMPLETION_CONTEXT_WXP_OR_LATER completionContext;

        IoCopyCurrentIrpStackLocationToNext( Irp );

        completionContext.RecordList = recordList;
        KeInitializeEvent( &completionContext.WaitEvent, 
                           NotificationEvent, 
                           FALSE );

        IoSetCompletionRoutine(
            Irp,
            SpyFsControlCompletion,
            &completionContext,
            TRUE,
            TRUE,
            TRUE );

        //
        //  Detach from the file system recognizer device object.
        //

        IoDetachDevice( devExt->AttachedToDeviceObject );

        //
        //  Call the driver
        //

        status = IoCallDriver( devExt->AttachedToDeviceObject, Irp );

        //
        //  Wait for the completion routine to be called
        //

    	if (STATUS_PENDING == status) {

    		status = KeWaitForSingleObject( &completionContext.WaitEvent, 
    		                                Executive, 
    		                                KernelMode, 
    		                                FALSE, 
    		                                NULL );

    	    ASSERT(STATUS_SUCCESS == status);
    	}

        ASSERT(KeReadStateEvent(&completionContext.WaitEvent) ||
               !NT_SUCCESS(Irp->IoStatus.Status));

        status = SpyFsControlLoadFileSystemComplete( DeviceObject, Irp );

    } else {
#endif
        completionContext = ExAllocatePoolWithTag( NonPagedPool,
                                                   sizeof( SPY_COMPLETION_CONTEXT_W2K ),
                                                   FILESPY_POOL_TAG );

        if (completionContext == NULL) {

            IoSkipCurrentIrpStackLocation( Irp );
            status = IoCallDriver( devExt->AttachedToDeviceObject, Irp );

        } else {

            completionContext->RecordList = recordList;
            ExInitializeWorkItem( &completionContext->WorkItem,
                                  SpyFsControlLoadFileSystemCompleteWorker,
                                  completionContext );
            
            completionContext->DeviceObject = DeviceObject;
            completionContext->Irp = Irp;
            completionContext->NewDeviceObject = NULL;

            IoSetCompletionRoutine(
                Irp,
                SpyFsControlCompletion,
                &completionContext,
                TRUE,
                TRUE,
                TRUE );

            //
            //  Detach from the file system recognizer device object.
            //

            IoDetachDevice( devExt->AttachedToDeviceObject );

            //
            //  Call the driver
            //

            status = IoCallDriver( devExt->AttachedToDeviceObject, Irp );
        }
#if WINVER >= 0x0501
    }
#endif     

    return status;
}

VOID
SpyFsControlLoadFileSystemCompleteWorker (
    IN PSPY_COMPLETION_CONTEXT_W2K Context
    )
/*++

Routine Description:

    The worker thread routine that will call our common routine to do the
    post-LoadFileSystem work.

Arguments:

    Context - The context passed to this worker thread.
    
Return Value:

    None.

--*/
{
    SpyFsControlLoadFileSystemComplete( Context->DeviceObject,
                                        Context->Irp );

    ExFreePoolWithTag( Context, FILESPY_POOL_TAG );
}

NTSTATUS
SpyFsControlLoadFileSystemComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This does the post-LoadFileSystem work and must be done at PASSIVE_LEVEL.

Arguments:

    DeviceObject - The device object for this operation,

    Irp - The IRP for this operation that we will complete once we are finished
        with it.
    
Return Value:

    Returns the status of the load file system operation.

--*/
{
    PFILESPY_DEVICE_EXTENSION devExt = DeviceObject->DeviceExtension;
    NTSTATUS status;

    PAGED_CODE();
        
    //
    //  Display the name if requested
    //

    SPY_LOG_PRINT( SPYDEBUG_DISPLAY_ATTACHMENT_NAMES,
                   ("FileSpy!SpyFsControlLoadFileSystem:          Detaching from recognizer  %p \"%wZ\", status=%08x\n",
                    DeviceObject,
                    &devExt->DeviceName,
                    Irp->IoStatus.Status) );

    //
    //  Check status of the operation
    //

    if (!NT_SUCCESS( Irp->IoStatus.Status ) && 
        (Irp->IoStatus.Status != STATUS_IMAGE_ALREADY_LOADED)) {

        //
        //  The load was not successful.  Simply reattach to the recognizer
        //  driver in case it ever figures out how to get the driver loaded
        //  on a subsequent call.
        //

        SpyAttachDeviceToDeviceStack( DeviceObject, 
                                      devExt->AttachedToDeviceObject,
                                      &devExt->AttachedToDeviceObject );

        ASSERT(devExt->AttachedToDeviceObject != NULL);

    } else {

        //
        //  The load was successful, delete the Device object
        //

        SpyCleanupMountedDevice( DeviceObject );
        IoDeleteDevice( DeviceObject );
    }

    //
    //  Continue processing the operation
    //

    status = Irp->IoStatus.Status;

    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return status;
}

/////////////////////////////////////////////////////////////////////////////
//
//                      FastIO Handling routines
//
/////////////////////////////////////////////////////////////////////////////

BOOLEAN
SpyFastIoCheckIfPossible (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN BOOLEAN CheckForReadOperation,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for checking to see
    whether fast I/O is possible for this file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be operated on.

    FileOffset - Byte offset in the file for the operation.

    Length - Length of the operation to be performed.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    LockKey - Provides the caller's key for file locks.

    CheckForReadOperation - Indicates whether the caller is checking for a
        read (TRUE) or a write operation.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.
    
--*/
{
    PDEVICE_OBJECT    deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN           returnValue = FALSE;
    PRECORD_LIST      recordList;
    BOOLEAN           shouldLog;
    
    PAGED_CODE();

    ASSERT( IS_FILESPY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( TRUE, CHECK_IF_POSSIBLE );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = SpyLogFastIoStart( CHECK_IF_POSSIBLE,
                                        DeviceObject,
                                        FileObject,
                                        FileOffset,
                                        Length,
                                        Wait );
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PFILESPY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        //
        //  We have a valid DeviceObject, so look at its FastIoDispatch
        //  table for the next driver's Fast IO routine.
        //

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoCheckIfPossible )) {

            returnValue = (fastIoDispatch->FastIoCheckIfPossible)( FileObject,
                                                                   FileOffset,
                                                                   Length,
                                                                   Wait,
                                                                   LockKey,
                                                                   CheckForReadOperation,
                                                                   IoStatus,
                                                                   deviceObject);
        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( FALSE, CHECK_IF_POSSIBLE );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog) {

        //
        // Log the necessary information for the end of the Fast I/O 
        // operation if we were able to allocate a RecordList to store 
        // this information
        //

        if (recordList) {

            SpyLogFastIoComplete( IoStatus, recordList);
        }
    }

    return returnValue;
}

BOOLEAN
SpyFastIoRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for reading from a
    file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be read.

    FileOffset - Byte offset in the file of the read.

    Length - Length of the read operation to be performed.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    LockKey - Provides the caller's key for file locks.

    Buffer - Pointer to the caller's buffer to receive the data read.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN returnValue = FALSE;
    PRECORD_LIST recordList;
    BOOLEAN shouldLog;

    PAGED_CODE();

    ASSERT( IS_FILESPY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( TRUE, READ );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = SpyLogFastIoStart( READ, 
                                        DeviceObject,
                                        FileObject, 
                                        FileOffset, 
                                        Length, 
                                        Wait );
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PFILESPY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoRead )) {

            returnValue = (fastIoDispatch->FastIoRead)( FileObject,
                                                        FileOffset,
                                                        Length,
                                                        Wait,
                                                        LockKey,
                                                        Buffer,
                                                        IoStatus,
                                                        deviceObject);
        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( FALSE, READ );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog) {

        //
        // Log the necessary information for the end of the Fast I/O operation
        // if we were able to allocate a RecordList to store this information
        //

        if (recordList) {

            SpyLogFastIoComplete( IoStatus, recordList);
        }
    }                                                      
    
    return returnValue;
}

BOOLEAN
SpyFastIoWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for writing to a
    file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be written.

    FileOffset - Byte offset in the file of the write operation.

    Length - Length of the write operation to be performed.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    LockKey - Provides the caller's key for file locks.

    Buffer - Pointer to the caller's buffer that contains the data to be
        written.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    PAGED_CODE();

    ASSERT( IS_FILESPY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( TRUE, WRITE );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = SpyLogFastIoStart( WRITE,
                                        DeviceObject,
                                        FileObject,
                                        FileOffset,
                                        Length,
                                        Wait );
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PFILESPY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoWrite )) {

            returnValue = (fastIoDispatch->FastIoWrite)( FileObject,
                                                         FileOffset,
                                                         Length,
                                                         Wait,
                                                         LockKey,
                                                         Buffer,
                                                         IoStatus,
                                                         deviceObject);
        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( FALSE, WRITE );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog) {

        //
        // Log the necessary information for the end of the Fast I/O operation
        // if we were able to allocate a RecordList to store this information
        //

        if (recordList) {

            SpyLogFastIoComplete( IoStatus, recordList);
        }
    }

    return returnValue;
}
 
BOOLEAN
SpyFastIoQueryBasicInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_BASIC_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for querying basic
    information about the file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be queried.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    Buffer - Pointer to the caller's buffer to receive the information about
        the file.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN returnValue = FALSE;
    PRECORD_LIST recordList;
    BOOLEAN shouldLog;

    PAGED_CODE();

    ASSERT( IS_FILESPY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( TRUE, QUERY_BASIC_INFO );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = SpyLogFastIoStart( QUERY_BASIC_INFO,
                                        DeviceObject,
                                        FileObject,
                                        NULL,
                                        0,
                                        Wait );
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PFILESPY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoQueryBasicInfo )) {

            returnValue = (fastIoDispatch->FastIoQueryBasicInfo)( FileObject,
                                                                  Wait,
                                                                  Buffer,
                                                                  IoStatus,
                                                                  deviceObject);
        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( FALSE, QUERY_BASIC_INFO );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog) {

        //
        // Log the necessary information for the end of the Fast I/O operation
        // if we were able to allocate a RecordList to store this information
        //

        if (recordList) {

            SpyLogFastIoComplete( IoStatus, recordList);
        }
    }

    return returnValue;
}
 
BOOLEAN
SpyFastIoQueryStandardInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_STANDARD_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for querying standard
    information about the file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be queried.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    Buffer - Pointer to the caller's buffer to receive the information about
        the file.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    PAGED_CODE();

    ASSERT( IS_FILESPY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( TRUE, QUERY_STANDARD_INFO );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = SpyLogFastIoStart( QUERY_STANDARD_INFO,
                                        DeviceObject,
                                        FileObject,
                                        NULL,
                                        0,
                                        Wait );
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PFILESPY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;
    
    if (NULL != deviceObject) {
           
        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoQueryStandardInfo )) {

            returnValue = (fastIoDispatch->FastIoQueryStandardInfo)( FileObject,
                                                                     Wait,
                                                                     Buffer,
                                                                     IoStatus,
                                                                     deviceObject );

        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( FALSE, QUERY_STANDARD_INFO );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog) {
        
        //
        // Log the necessary information for the end of the Fast I/O operation
        // if we were able to allocate a RecordList to store this information
        //
        
        if (recordList) {

            SpyLogFastIoComplete( IoStatus, recordList);
        }
    }

    return returnValue;
}

BOOLEAN
SpyFastIoLock (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    IN PEPROCESS ProcessId,
    IN ULONG Key,
    IN BOOLEAN FailImmediately,
    IN BOOLEAN ExclusiveLock,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for locking a byte
    range within a file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be locked.

    FileOffset - Starting byte offset from the base of the file to be locked.

    Length - Length of the byte range to be locked.

    ProcessId - ID of the process requesting the file lock.

    Key - Lock key to associate with the file lock.

    FailImmediately - Indicates whether or not the lock request is to fail
        if it cannot be immediately be granted.

    ExclusiveLock - Indicates whether the lock to be taken is exclusive (TRUE)
        or shared.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    PAGED_CODE();

    ASSERT( IS_FILESPY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( TRUE, LOCK );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = SpyLogFastIoStart( LOCK,
                                        DeviceObject,
                                        FileObject,
                                        FileOffset,
                                        0,
                                        0 );
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PFILESPY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoLock )) {

            returnValue = (fastIoDispatch->FastIoLock)( FileObject,
                                                        FileOffset,
                                                        Length,
                                                        ProcessId,
                                                        Key,
                                                        FailImmediately,
                                                        ExclusiveLock,
                                                        IoStatus,
                                                        deviceObject);

        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( FALSE, LOCK );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog) {

        //
        // Log the necessary information for the end of the Fast I/O operation
        // if we were able to allocate a RecordList to store this information
        //

        if (recordList) {

            SpyLogFastIoComplete( IoStatus, recordList);
        }
    }

    return returnValue;
}
 
BOOLEAN
SpyFastIoUnlockSingle (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    IN PEPROCESS ProcessId,
    IN ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for unlocking a byte
    range within a file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be unlocked.

    FileOffset - Starting byte offset from the base of the file to be
        unlocked.

    Length - Length of the byte range to be unlocked.

    ProcessId - ID of the process requesting the unlock operation.

    Key - Lock key associated with the file lock.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    PAGED_CODE();

    ASSERT( IS_FILESPY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( TRUE, UNLOCK_SINGLE );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = SpyLogFastIoStart( UNLOCK_SINGLE,
                                        DeviceObject,
                                        FileObject,
                                        FileOffset,
                                        0,
                                        0 );
    }


    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PFILESPY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoUnlockSingle )) {

            returnValue = (fastIoDispatch->FastIoUnlockSingle)( FileObject,
                                                                FileOffset,
                                                                Length,
                                                                ProcessId,
                                                                Key,
                                                                IoStatus,
                                                                deviceObject);

        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( FALSE, UNLOCK_SINGLE );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog) {

        //
        // Log the necessary information for the end of the Fast I/O operation
        // if we were able to allocate a RecordList to store this information
        //

        if (recordList) {

            SpyLogFastIoComplete( IoStatus, recordList);
        }
    }

    return returnValue;
}
 
BOOLEAN
SpyFastIoUnlockAll (
    IN PFILE_OBJECT FileObject,
    IN PEPROCESS ProcessId,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for unlocking all
    locks within a file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be unlocked.

    ProcessId - ID of the process requesting the unlock operation.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    PAGED_CODE();

    ASSERT( IS_FILESPY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( TRUE, UNLOCK_ALL );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = SpyLogFastIoStart( UNLOCK_ALL,
                                        DeviceObject,
                                        FileObject,
                                        NULL,
                                        0,
                                        0 );
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PFILESPY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoUnlockAll )) {

            returnValue = (fastIoDispatch->FastIoUnlockAll)( FileObject,
                                                             ProcessId,
                                                             IoStatus,
                                                             deviceObject);

        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( FALSE, UNLOCK_ALL );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog) {

        //
        // Log the necessary information for the end of the Fast I/O operation
        // if we were able to allocate a RecordList to store this information
        //

        if (recordList) {

            SpyLogFastIoComplete( IoStatus, recordList);
        }
    }

    return returnValue;
}

BOOLEAN
SpyFastIoUnlockAllByKey (
    IN PFILE_OBJECT FileObject,
    IN PVOID ProcessId,
    IN ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for unlocking all
    locks within a file based on a specified key.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be unlocked.

    ProcessId - ID of the process requesting the unlock operation.

    Key - Lock key associated with the locks on the file to be released.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    PAGED_CODE();

    ASSERT( IS_FILESPY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( TRUE, UNLOCK_ALL_BY_KEY );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = SpyLogFastIoStart( UNLOCK_ALL_BY_KEY,
                                        DeviceObject,
                                        FileObject,
                                        NULL,
                                        0,
                                        0 );
    }

    //
    // Pass through logic for this type of Fast I/O
    //
    
    deviceObject = ((PFILESPY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoUnlockAllByKey )) {

            returnValue = (fastIoDispatch->FastIoUnlockAllByKey)( FileObject,
                                                                  ProcessId,
                                                                  Key,
                                                                  IoStatus,
                                                                  deviceObject);
        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( FALSE, UNLOCK_ALL_BY_KEY );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog) {

        //
        // Log the necessary information for the end of the Fast I/O operation
        // if we were able to allocate a RecordList to store this information
        //

        if (recordList) {

            SpyLogFastIoComplete( IoStatus, recordList);
        }
    }

    return returnValue;
}

BOOLEAN
SpyFastIoDeviceControl (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for device I/O 
    control operations on a file.
    
    If this I/O is directed to gControlDevice, then the parameters specify
    control commands to FileSpy.  These commands are interpreted and handled
    appropriately.

    If this is I/O directed at another DriverObject, this function simply 
    invokes the next driver's corresponding routine, or returns FALSE if 
    the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object representing the device to be
        serviced.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    InputBuffer - Optional pointer to a buffer to be passed into the driver.

    InputBufferLength - Length of the optional InputBuffer, if one was
        specified.

    OutputBuffer - Optional pointer to a buffer to receive data from the
        driver.

    OutputBufferLength - Length of the optional OutputBuffer, if one was
        specified.

    IoControlCode - I/O control code indicating the operation to be performed
        on the device.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

Notes:

    This function does not check the validity of the input/output buffers
    because the ioctl's are implemented as METHOD_BUFFERED.  In this case,
    the I/O manager does the buffer validation checks for us.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    PAGED_CODE();

    //
    // Get a pointer to the current location in the Irp. This is where
    // the function codes and parameters are located.
    //

    if (DeviceObject == gControlDeviceObject) {

        SpyCommonDeviceIoControl( InputBuffer,
                                  InputBufferLength,
                                  OutputBuffer,
                                  OutputBufferLength,
                                  IoControlCode,
                                  IoStatus );

        returnValue = TRUE;

    } else {

        ASSERT( IS_FILESPY_DEVICE_OBJECT( DeviceObject ) );

        //
        //  If the specified debug level is set, output what operation
        //  we are seeing to the debugger.
        //
        
        if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

            SpyDumpFastIoOperation( TRUE, DEVICE_CONTROL );
        }
        
        //
        //  Perform filespy logging if we care about this device.
        //
        
        if (shouldLog = SHOULD_LOG(DeviceObject)) {

            //
            //
            // Log the necessary information for the start of the Fast I/O 
            // operation
            //

            recordList = SpyLogFastIoStart( DEVICE_CONTROL,
                                            DeviceObject,
                                            FileObject,
                                            NULL,
                                            0,
                                            Wait );
        }

        deviceObject = ((PFILESPY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

        if (NULL != deviceObject) {

            fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

            if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoDeviceControl )) {

                returnValue = (fastIoDispatch->FastIoDeviceControl)( FileObject,
                                                                     Wait,
                                                                     InputBuffer,
                                                                     InputBufferLength,
                                                                     OutputBuffer,
                                                                     OutputBufferLength,
                                                                     IoControlCode,
                                                                     IoStatus,
                                                                     deviceObject);

            } else {

                IoStatus->Status = STATUS_SUCCESS;
            }
        }

        //
        //  If the specified debug level is set, output what operation
        //  we are seeing to the debugger.
        //
        
        if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

            SpyDumpFastIoOperation( FALSE, DEVICE_CONTROL );
        }
        
        //
        //  Perform filespy logging if we care about this device.
        //
        
        if (shouldLog) {

            //
            // Log the necessary information for the end of the Fast I/O 
            // operation if we were able to allocate a RecordList to store 
            // this information
            //

            if (recordList) {

                SpyLogFastIoComplete( IoStatus, recordList);
            }
        }
    }

    return returnValue;
}


VOID
SpyFastIoDetachDevice (
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice
)
/*++

Routine Description:

    This routine is invoked on the fast path to detach from a device that
    is being deleted.  This occurs when this driver has attached to a file
    system volume device object, and then, for some reason, the file system
    decides to delete that device (it is being dismounted, it was dismounted
    at some point in the past and its last reference has just gone away, etc.)

Arguments:

    SourceDevice - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

    TargetDevice - Pointer to the file system's volume device object.

Return Value:

    None.
    
--*/
{
    PRECORD_LIST recordList;
    BOOLEAN shouldLog;
    PFILESPY_DEVICE_EXTENSION devext;

    PAGED_CODE();

    ASSERT( IS_FILESPY_DEVICE_OBJECT( SourceDevice ) );

    devext = SourceDevice->DeviceExtension;

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( TRUE, DETACH_DEVICE );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(SourceDevice)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = SpyLogFastIoStart( DETACH_DEVICE, 
                                        SourceDevice, 
                                        NULL, 
                                        NULL, 
                                        0, 
                                        0 );
    }

    SPY_LOG_PRINT( SPYDEBUG_DISPLAY_ATTACHMENT_NAMES,
                   ("FileSpy!SpyFastIoDetachDevice:               Detaching from volume      %p \"%wZ\"\n",
                    TargetDevice,
                    &devext->DeviceName) );

    //
    // Detach from the file system's volume device object.
    //

    SpyCleanupMountedDevice( SourceDevice );
    IoDetachDevice( TargetDevice );
    IoDeleteDevice( SourceDevice );

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( FALSE, DETACH_DEVICE );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog) {

        //
        // Log the necessary information for the end of the Fast I/O operation
        // if we were able to allocate a RecordList to store this information
        //

        if (recordList) {

            SpyLogFastIoComplete( NULL, recordList);
        }
    }
}
 
BOOLEAN
SpyFastIoQueryNetworkOpenInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for querying network
    information about a file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be queried.

    Wait - Indicates whether or not the caller can handle the file system
        having to wait and tie up the current thread.

    Buffer - Pointer to a buffer to receive the network information about the
        file.

    IoStatus - Pointer to a variable to receive the final status of the query
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    PAGED_CODE();

    ASSERT( IS_FILESPY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( TRUE, QUERY_NETWORK_OPEN_INFO );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = SpyLogFastIoStart( QUERY_NETWORK_OPEN_INFO,
                                        DeviceObject,
                                        FileObject,
                                        NULL,
                                        0,
                                        Wait );
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PFILESPY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoQueryNetworkOpenInfo )) {

            returnValue = (fastIoDispatch->FastIoQueryNetworkOpenInfo)( FileObject,
                                                                        Wait,
                                                                        Buffer,
                                                                        IoStatus,
                                                                        deviceObject);

        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( FALSE, QUERY_NETWORK_OPEN_INFO );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog) {

        //
        // Log the necessary information for the end of the Fast I/O operation
        // if we were able to allocate a RecordList to store this information
        //

        if (recordList) {

            SpyLogFastIoComplete( IoStatus, recordList);
        }
    }

    return returnValue;
}

BOOLEAN
SpyFastIoMdlRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for reading a file
    using MDLs as buffers.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object that is to be read.

    FileOffset - Supplies the offset into the file to begin the read operation.

    Length - Specifies the number of bytes to be read from the file.

    LockKey - The key to be used in byte range lock checks.

    MdlChain - A pointer to a variable to be filled in w/a pointer to the MDL
        chain built to describe the data read.

    IoStatus - Variable to receive the final status of the read operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    PAGED_CODE();

    ASSERT( IS_FILESPY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( TRUE, MDL_READ );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = SpyLogFastIoStart( MDL_READ,
                                        DeviceObject,
                                        FileObject,                  
                                        FileOffset,                  
                                        Length,
                                        0 );
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PFILESPY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlRead )) {

            returnValue = (fastIoDispatch->MdlRead)( FileObject,
                                                     FileOffset,
                                                     Length,
                                                     LockKey,
                                                     MdlChain,
                                                     IoStatus,
                                                     deviceObject);
        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( FALSE, MDL_READ );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog) {

        //
        // Log the necessary information for the end of the Fast I/O operation
        // if we were able to allocate a RecordList to store this information
        //

        if (recordList) {

            SpyLogFastIoComplete( IoStatus, recordList);
        }
    }

    return returnValue;
}
 
BOOLEAN
SpyFastIoMdlReadComplete (
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for completing an
    MDL read operation.

    This function simply invokes the next driver's corresponding routine, if
    it has one.  It should be the case that this routine is invoked only if
    the MdlRead function is supported by the underlying driver, and
    therefore this function will also be supported, but this is not assumed
    by this driver.

Arguments:

    FileObject - Pointer to the file object to complete the MDL read upon.

    MdlChain - Pointer to the MDL chain used to perform the read operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.
    
--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    ASSERT( IS_FILESPY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( TRUE, MDL_READ_COMPLETE );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = SpyLogFastIoStart( MDL_READ_COMPLETE,
                                        DeviceObject,
                                        FileObject,
                                        NULL,
                                        0,
                                        0 );
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PFILESPY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlReadComplete )) {

            returnValue = (fastIoDispatch->MdlReadComplete)( FileObject,
                                                             MdlChain,
                                                             deviceObject);
        } 
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( FALSE, MDL_READ_COMPLETE );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog) {
        
        //
        // Log the necessary information for the end of the Fast I/O 
        // operation if we were able to allocate a RecordList to store 
        // this information
        //

        if (recordList) {

            SpyLogFastIoComplete( NULL, recordList);
        }
    }

    return returnValue;
}
 
BOOLEAN
SpyFastIoPrepareMdlWrite (
    IN  PFILE_OBJECT FileObject,
    IN  PLARGE_INTEGER FileOffset,
    IN  ULONG Length,
    IN  ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN  PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for preparing for an
    MDL write operation.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object that will be written.

    FileOffset - Supplies the offset into the file to begin the write 
        operation.

    Length - Specifies the number of bytes to be write to the file.

    LockKey - The key to be used in byte range lock checks.

    MdlChain - A pointer to a variable to be filled in w/a pointer to the MDL
        chain built to describe the data written.

    IoStatus - Variable to receive the final status of the write operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    PAGED_CODE();

    ASSERT( IS_FILESPY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( TRUE, PREPARE_MDL_WRITE );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = SpyLogFastIoStart( PREPARE_MDL_WRITE,
                                        DeviceObject,
                                        FileObject,
                                        FileOffset,
                                        Length,
                                        0 );
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PFILESPY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, PrepareMdlWrite )) {

            returnValue = (fastIoDispatch->PrepareMdlWrite)( FileObject,
                                                             FileOffset,
                                                             Length,
                                                             LockKey,
                                                             MdlChain,
                                                             IoStatus,
                                                             deviceObject);
        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( FALSE, PREPARE_MDL_WRITE );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog) {

        //
        // Log the necessary information for the end of the Fast I/O operation
        // if we were able to allocate a RecordList to store this information
        //

        if (recordList) {

            SpyLogFastIoComplete( IoStatus, recordList);
        }
    }

    return returnValue;
}
 
BOOLEAN
SpyFastIoMdlWriteComplete (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for completing an
    MDL write operation.

    This function simply invokes the next driver's corresponding routine, if
    it has one.  It should be the case that this routine is invoked only if
    the PrepareMdlWrite function is supported by the underlying file system,
    and therefore this function will also be supported, but this is not
    assumed by this driver.

Arguments:

    FileObject - Pointer to the file object to complete the MDL write upon.

    FileOffset - Supplies the file offset at which the write took place.

    MdlChain - Pointer to the MDL chain used to perform the write operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    ASSERT( IS_FILESPY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( TRUE, MDL_WRITE_COMPLETE );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = SpyLogFastIoStart( MDL_WRITE_COMPLETE,
                                        DeviceObject,
                                        FileObject,
                                        FileOffset,
                                        0,
                                        0 );
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PFILESPY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlWriteComplete )) {

            returnValue = (fastIoDispatch->MdlWriteComplete)( FileObject,
                                                              FileOffset,
                                                              MdlChain,
                                                              deviceObject);

        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( FALSE, MDL_WRITE_COMPLETE );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog) {

        //
        // Log the necessary information for the end of the Fast I/O operation
        // if we were able to allocate a RecordList to store this information
        //

        if (recordList) {

            SpyLogFastIoComplete( NULL, recordList);
        }
    }

    return returnValue;
}
 
BOOLEAN
SpyFastIoReadCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    OUT struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for reading 
    compressed data from a file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object that will be read.

    FileOffset - Supplies the offset into the file to begin the read operation.

    Length - Specifies the number of bytes to be read from the file.

    LockKey - The key to be used in byte range lock checks.

    Buffer - Pointer to a buffer to receive the compressed data read.

    MdlChain - A pointer to a variable to be filled in w/a pointer to the MDL
        chain built to describe the data read.

    IoStatus - Variable to receive the final status of the read operation.

    CompressedDataInfo - A buffer to receive the description of the 
        compressed data.

    CompressedDataInfoLength - Specifies the size of the buffer described by
        the CompressedDataInfo parameter.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    PAGED_CODE();

    ASSERT( IS_FILESPY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( TRUE, READ_COMPRESSED );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = SpyLogFastIoStart( READ_COMPRESSED,
                                        DeviceObject,
                                        FileObject,
                                        FileOffset,
                                        Length,
                                        0 );
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PFILESPY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoReadCompressed )) {

            returnValue = (fastIoDispatch->FastIoReadCompressed)( FileObject,
                                                                  FileOffset,
                                                                  Length,
                                                                  LockKey,
                                                                  Buffer,
                                                                  MdlChain,
                                                                  IoStatus,
                                                                  CompressedDataInfo,
                                                                  CompressedDataInfoLength,
                                                                  deviceObject);
        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( FALSE, READ_COMPRESSED );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog) {

        //
        // Log the necessary information for the end of the Fast I/O operation
        // if we were able to allocate a RecordList to store this information
        //

        if (recordList) {

            SpyLogFastIoComplete( IoStatus, recordList);
        }
    }

    return returnValue;
}
 
BOOLEAN
SpyFastIoWriteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for writing 
    compressed data to a file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object that will be written.

    FileOffset - Supplies the offset into the file to begin the write 
        operation.

    Length - Specifies the number of bytes to be write to the file.

    LockKey - The key to be used in byte range lock checks.

    Buffer - Pointer to the buffer containing the data to be written.

    MdlChain - A pointer to a variable to be filled in w/a pointer to the MDL
        chain built to describe the data written.

    IoStatus - Variable to receive the final status of the write operation.

    CompressedDataInfo - A buffer to containing the description of the
        compressed data.

    CompressedDataInfoLength - Specifies the size of the buffer described by
        the CompressedDataInfo parameter.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    PAGED_CODE();

    ASSERT( IS_FILESPY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( TRUE, WRITE_COMPRESSED );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //
        
        recordList = SpyLogFastIoStart( WRITE_COMPRESSED,
                                        DeviceObject,
                                        FileObject,
                                        FileOffset,
                                        Length,
                                        0 );
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PFILESPY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoWriteCompressed )) {

            returnValue = (fastIoDispatch->FastIoWriteCompressed)( FileObject,
                                                                   FileOffset,
                                                                   Length,
                                                                   LockKey,
                                                                   Buffer,
                                                                   MdlChain,
                                                                   IoStatus,
                                                                   CompressedDataInfo,
                                                                   CompressedDataInfoLength,
                                                                   deviceObject);
        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( FALSE, WRITE_COMPRESSED );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog) {

        //
        // Log the necessary information for the end of the Fast I/O operation
        // if we were able to allocate a RecordList to store this information
        //

        if (recordList) {

            SpyLogFastIoComplete( IoStatus, recordList);
        }
    }

    return returnValue;
}
 
BOOLEAN
SpyFastIoMdlReadCompleteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for completing an
    MDL read compressed operation.

    This function simply invokes the next driver's corresponding routine, if
    it has one.  It should be the case that this routine is invoked only if
    the read compressed function is supported by the underlying file system,
    and therefore this function will also be supported, but this is not 
    assumed by this driver.

Arguments:

    FileObject - Pointer to the file object to complete the compressed read
        upon.

    MdlChain - Pointer to the MDL chain used to perform the read operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.
    
--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    ASSERT( IS_FILESPY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( TRUE, MDL_READ_COMPLETE_COMPRESSED );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = SpyLogFastIoStart( MDL_READ_COMPLETE_COMPRESSED,
                                        DeviceObject,
                                        FileObject,
                                        NULL,
                                        0,
                                        0 );
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PFILESPY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlReadCompleteCompressed )) {

            returnValue = (fastIoDispatch->MdlReadCompleteCompressed)( FileObject,
                                                                       MdlChain,
                                                                       deviceObject);

        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( FALSE, MDL_READ_COMPLETE_COMPRESSED );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog) {

        //
        // Log the necessary information for the end of the Fast I/O operation
        // if we were able to allocate a RecordList to store this information
        //

        if (recordList) {

            SpyLogFastIoComplete( NULL, recordList);
        }
    }

    return returnValue;
}
 
BOOLEAN
SpyFastIoMdlWriteCompleteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for completing a
    write compressed operation.

    This function simply invokes the next driver's corresponding routine, if
    it has one.  It should be the case that this routine is invoked only if
    the write compressed function is supported by the underlying file system,
    and therefore this function will also be supported, but this is not 
    assumed by this driver.

Arguments:

    FileObject - Pointer to the file object to complete the compressed write
        upon.

    FileOffset - Supplies the file offset at which the file write operation
        began.

    MdlChain - Pointer to the MDL chain used to perform the write operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    ASSERT( IS_FILESPY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( TRUE, MDL_WRITE_COMPLETE_COMPRESSED );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = SpyLogFastIoStart( MDL_WRITE_COMPLETE_COMPRESSED,
                                        DeviceObject,
                                        FileObject,
                                        FileOffset,
                                        0,
                                        0 );
    }

    //
    // Pass through logic for this type of Fast I/O
    //
    
    deviceObject = ((PFILESPY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlWriteCompleteCompressed )) {

            returnValue = (fastIoDispatch->MdlWriteCompleteCompressed)( FileObject,
                                                                        FileOffset, 
                                                                        MdlChain,
                                                                        deviceObject);

        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( FALSE, MDL_WRITE_COMPLETE_COMPRESSED );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog) {

        //
        // Log the necessary information for the end of the Fast I/O operation
        // if we were able to allocate a RecordList to store this information
        //

        if (recordList) {

            SpyLogFastIoComplete( NULL, recordList);
        }
    }

    return returnValue;
}
 
BOOLEAN
SpyFastIoQueryOpen (
    IN PIRP Irp,
    OUT PFILE_NETWORK_OPEN_INFORMATION NetworkInformation,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for opening a file
    and returning network information it.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    Irp - Pointer to a create IRP that represents this open operation.  It is
        to be used by the file system for common open/create code, but not
        actually completed.

    NetworkInformation - A buffer to receive the information required by the
        network about the file being opened.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN result = FALSE;
    BOOLEAN shouldLog;

    PAGED_CODE();

    ASSERT( IS_FILESPY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( TRUE, QUERY_OPEN );
    }

    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = SpyLogFastIoStart( QUERY_OPEN,
                                        DeviceObject,
                                        NULL,
                                        NULL,
                                        0,
                                        0 );
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PFILESPY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoQueryOpen )) {

            PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation( Irp );

            //
            //  Before calling the next filter, we must make sure their device
            //  object is in the current stack entry for the given IRP
            //

            irpSp->DeviceObject = deviceObject;

            result = (fastIoDispatch->FastIoQueryOpen)( Irp,
                                                        NetworkInformation,
                                                        deviceObject );
            //
            //  Restore the IRP back to our device object
            //

            irpSp->DeviceObject = DeviceObject;
        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FAST_IO_OPS )) {

        SpyDumpFastIoOperation( FALSE, QUERY_OPEN );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog) {

        //
        // Log the necessary information for the end of the Fast I/O operation
        // if we were able to allocate a RecordList to store this information
        //

        if (recordList) {

            SpyLogFastIoComplete( &Irp->IoStatus, recordList);
        }
    }

    return result;
}

#if WINVER >= 0x0501 /* See comment in DriverEntry */

NTSTATUS
SpyPreFsFilterOperation (
    IN PFS_FILTER_CALLBACK_DATA Data,
    OUT PVOID *CompletionContext
    )
/*++

Routine Description:

    This routine is the FS Filter pre-operation "pass through" routine.

Arguments:

    Data - The FS_FILTER_CALLBACK_DATA structure containing the information
        about this operation.
        
    CompletionContext - A context set by this operation that will be passed
        to the corresponding SpyPostFsFilterOperation call.
        
Return Value:

    Returns STATUS_SUCCESS if the operation can continue or an appropriate
    error code if the operation should fail.

--*/
{

    PDEVICE_OBJECT deviceObject;
    PRECORD_LIST recordList = NULL;
    BOOLEAN shouldLog;

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FSFILTER_OPS )) {

        SpyDumpFsFilterOperation( TRUE, Data );
    }

    deviceObject = Data->DeviceObject;

    ASSERT( IS_FILESPY_DEVICE_OBJECT( deviceObject ) );

    if (shouldLog = SHOULD_LOG( deviceObject )) {

        recordList = SpyNewRecord(0);

        if (recordList != NULL) {

            //
            //  Log the necessary information for the start of this
            //  operation.
            //

            SpyLogPreFsFilterOperation( Data, recordList );
        }
    }

    *CompletionContext = recordList;

    return STATUS_SUCCESS;
}

VOID
SpyPostFsFilterOperation (
    IN PFS_FILTER_CALLBACK_DATA Data,
    IN NTSTATUS OperationStatus,
    IN PVOID CompletionContext
    )
/*++

Routine Description:

    This routine is the FS Filter post-operation "pass through" routine.

Arguments:

    Data - The FS_FILTER_CALLBACK_DATA structure containing the information
        about this operation.
        
    OperationStatus - The status of this operation.        
    
    CompletionContext - A context that was set in the pre-operation 
        callback by this driver.
        
Return Value:

    None.
    
--*/
{

    PDEVICE_OBJECT deviceObject;
    PRECORD_LIST recordList = (PRECORD_LIST) CompletionContext;
    BOOLEAN shouldLog;

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //

    if (FlagOn( gFileSpyDebugLevel, SPYDEBUG_TRACE_FSFILTER_OPS )) {

        SpyDumpFsFilterOperation( FALSE, Data );
    }

    deviceObject = Data->DeviceObject;

    ASSERT( IS_FILESPY_DEVICE_OBJECT( deviceObject ) );

    if ((shouldLog = SHOULD_LOG( deviceObject )) &&
        (recordList != NULL)) {

        //
        //  Log the necessary information for the end of the Fast IO
        //  operation if we have a recordList.
        //

        SpyLogPostFsFilterOperation( OperationStatus, recordList );

        //
        //  Add recordList to our gOutputBufferList so that it gets up to 
        //  the user.  We don't have to worry about freeing the recordList
        //  at this time because it will get free when it is taken off
        //  gOutputBufferList.
        //

        SpyLog(recordList);       
        
    } else if (recordList != NULL) {

        //
        //  We are no longer logging for this device, so just
        //  free this recordList entry.
        //

        SpyFreeRecord( recordList );
    }
}

#endif

NTSTATUS
SpyCommonDeviceIoControl (
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:

    This routine does the common processing of interpreting the Device IO Control
    request.

Arguments:

    FileObject - The file object related to this operation.
    
    InputBuffer - The buffer containing the input parameters for this control
        operation.
        
    InputBufferLength - The length in bytes of InputBuffer.
    
    OutputBuffer - The buffer to receive any output from this control operation.
    
    OutputBufferLength - The length in bytes of OutputBuffer.
    
    IoControlCode - The control code specifying what control operation this is.
    
    IoStatus - Receives the status of this operation.
    
Return Value:

    None.
    
--*/
{
    PWSTR deviceName = NULL;
    FILESPYVER fileSpyVer;

    PAGED_CODE();

    ASSERT( IoStatus != NULL );
    
    IoStatus->Status      = STATUS_SUCCESS;
    IoStatus->Information = 0;

    switch (IoControlCode) {
        case FILESPY_Reset:
            IoStatus->Status = STATUS_INVALID_PARAMETER;
            break;

        //
        //      Request to start logging on a device
        //                                      

        case FILESPY_StartLoggingDevice:

            if (InputBuffer == NULL || InputBufferLength <= 0) {

                IoStatus->Status = STATUS_INVALID_PARAMETER;
                break;
            }
        
            //
            // Copy the device name and add a null to ensure that it is null terminated
            //

            deviceName =  ExAllocatePoolWithTag( NonPagedPool, 
                                                 InputBufferLength + sizeof(WCHAR),
                                                 FILESPY_POOL_TAG );

            if (NULL == deviceName) {

                IoStatus->Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
        
            RtlCopyMemory( deviceName, InputBuffer, InputBufferLength );
            deviceName[InputBufferLength / sizeof(WCHAR)] = UNICODE_NULL;

            IoStatus->Status = SpyStartLoggingDevice( deviceName );
            break;  

        //
        //      Detach from a specified device
        //  

        case FILESPY_StopLoggingDevice:

            if (InputBuffer == NULL || InputBufferLength <= 0) {

                IoStatus->Status = STATUS_INVALID_PARAMETER;
                break;
            }
        
            //
            // Copy the device name and add a null to ensure that it is null terminated
            //

            deviceName =  ExAllocatePoolWithTag( NonPagedPool, 
                                                 InputBufferLength + sizeof(WCHAR),
                                                 FILESPY_POOL_TAG );

            if (NULL == deviceName) {

                IoStatus->Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
        
            RtlCopyMemory( deviceName, InputBuffer, InputBufferLength );
            deviceName[InputBufferLength / sizeof(WCHAR) - 1] = UNICODE_NULL;

            IoStatus->Status = SpyStopLoggingDevice( deviceName );
            break;  

        //
        //      List all the devices that we are currently
        //      monitoring
        //

        case FILESPY_ListDevices:

            if (OutputBuffer == NULL || OutputBufferLength <= 0) {

                IoStatus->Status = STATUS_INVALID_PARAMETER;
                break;
            }
                    
            IoStatus->Status = SpyGetAttachList( OutputBuffer,
                                                 OutputBufferLength,
                                                 &IoStatus->Information);
            break;

        //
        //      Return entries from the log buffer
        //                                      

        case FILESPY_GetLog:

            if (OutputBuffer == NULL || OutputBufferLength == 0) {

                IoStatus->Status = STATUS_INVALID_PARAMETER;
                break;
            }

            SpyGetLog( OutputBuffer, OutputBufferLength, IoStatus );
            break;

        //
        //      Return version of the FileSpy filter driver
        //                                      

        case FILESPY_GetVer:

            if ((OutputBufferLength < sizeof(FILESPYVER)) || 
                (OutputBuffer == NULL)) {

                IoStatus->Status = STATUS_INVALID_PARAMETER;
                break;                    
            }
        
            fileSpyVer.Major = FILESPY_MAJ_VERSION;
            fileSpyVer.Minor = FILESPY_MIN_VERSION;
        
            RtlCopyMemory(OutputBuffer, &fileSpyVer, sizeof(FILESPYVER));
        
            IoStatus->Information = sizeof(FILESPYVER);
            break;
    
        //
        //      Return hash table statistics
        //                                      

        case FILESPY_GetStats:

            if ((OutputBufferLength < sizeof(gStats)) || 
                (OutputBuffer == NULL)) {

                IoStatus->Status = STATUS_INVALID_PARAMETER;
                break;                    
            }

            RtlCopyMemory( OutputBuffer, &gStats, sizeof(gStats) );
            IoStatus->Information = sizeof(gStats);
            break;
        
        default:

            IoStatus->Status = STATUS_INVALID_PARAMETER;
            break;
    }

    if (NULL != deviceName) {

        ExFreePoolWithTag( deviceName, FILESPY_POOL_TAG );
    }

  return IoStatus->Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\filespy\filter\fspyhash.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    filespy.c

Abstract:

    This module contains all of the routines for tracking names by
    hashing the fileObject.  This cache is limited in size by the
    following registry setting "MaxNames".

Environment:

    Kernel mode

// @@BEGIN_DDKSPLIT

Author:

    Neal Christiansen (nealch)     04-Jul-2001

Revision History:

    Ravisankar Pudipeddi (ravisp)  07-May-2002
        Make it work on IA64

// @@END_DDKSPLIT
--*/

#include <ntifs.h>
#include "filespy.h"
#include "fspyKern.h"


#if !USE_STREAM_CONTEXTS

////////////////////////////////////////////////////////////////////////
//
//                    Local definitions
//
////////////////////////////////////////////////////////////////////////

#define HASH_FUNC(FileObject) \
    (((UINT_PTR)(FileObject) >> 8) & (HASH_SIZE - 1))

////////////////////////////////////////////////////////////////////////
//
//                    Global Variables
//
////////////////////////////////////////////////////////////////////////

//
// NOTE:  Must use KSPIN_LOCKs to synchronize access to hash buckets since
//        we may try to acquire them at DISPATCH_LEVEL.
//

LIST_ENTRY gHashTable[HASH_SIZE];
KSPIN_LOCK gHashLockTable[HASH_SIZE];
ULONG gHashMaxCounters[HASH_SIZE];
ULONG gHashCurrentCounters[HASH_SIZE];

UNICODE_STRING OutOfBuffers = CONSTANT_UNICODE_STRING(L"[-=Out Of Buffers=-]");


////////////////////////////////////////////////////////////////////////
//
//                    Local prototypes
//
////////////////////////////////////////////////////////////////////////

VOID
SpyDeleteContextCallback(
    IN PVOID Context
    );


//
// linker commands
//

#ifdef ALLOC_PRAGMA

#pragma alloc_text( PAGE, SpyInitNamingEnvironment)
#pragma alloc_text( PAGE, SpyInitDeviceNamingEnvironment)
#pragma alloc_text( PAGE, SpyCleanupDeviceNamingEnvironment)

#endif  // ALLOC_PRAGMA


////////////////////////////////////////////////////////////////////////
//
//                    Main routines
//
////////////////////////////////////////////////////////////////////////


VOID
SpyInitNamingEnvironment(
    VOID
    )
/*++

Routine Description:

    Init global variables

Arguments:

    None

Return Value:

    None.

--*/
{
    int i;

    //
    //  Initialize the hash table
    //
        
    for (i = 0; i < HASH_SIZE; i++){

        InitializeListHead(&gHashTable[i]);
        KeInitializeSpinLock(&gHashLockTable[i]);
    }
}


VOID
SpyInitDeviceNamingEnvironment (
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Initialize the per DeviceObject naming environment

Arguments:

    DeviceObject - The device object to initialize

Return Value:

    None.

--*/
{
    UNREFERENCED_PARAMETER( DeviceObject );
}


VOID
SpyCleanupDeviceNamingEnvironment (
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Initialize the per DeviceObject naming environment

Arguments:

    DeviceObject - The device object to initialize

Return Value:

    None.

--*/
{
    UNREFERENCED_PARAMETER( DeviceObject );
}


VOID
SpyLogIrp (
    IN PIRP Irp,
    OUT PRECORD_LIST RecordList
    )
/*++

Routine Description:

    Records the Irp necessary information according to LoggingFlags in
    RecordList.  For any activity on the Irp path of a device being
    logged, this function should get called twice: once on the Irp's
    originating path and once on the Irp's completion path.

Arguments:

    Irp - The Irp that contains the information we want to record.
    LoggingFlags - The flags that say what to log.
    RecordList - The PRECORD_LIST in which the Irp information is stored.

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION pIrpStack;
    PRECORD_IRP pRecordIrp;
    ULONG lookupFlags;

    pRecordIrp = &RecordList->LogRecord.Record.RecordIrp;

    pIrpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // Record the information we use for an originating Irp.  We first
    // need to initialize some of the RECORD_LIST and RECORD_IRP fields.
    // Then get the interesting information from the Irp.
    //

    SetFlag( RecordList->LogRecord.RecordType, RECORD_TYPE_IRP );

    pRecordIrp->IrpMajor        = pIrpStack->MajorFunction;
    pRecordIrp->IrpMinor        = pIrpStack->MinorFunction;
    pRecordIrp->IrpFlags        = Irp->Flags;
    pRecordIrp->FileObject      = (FILE_ID)pIrpStack->FileObject;
    pRecordIrp->DeviceObject    = (FILE_ID)pIrpStack->DeviceObject;
    pRecordIrp->ProcessId       = (FILE_ID)PsGetCurrentProcessId();
    pRecordIrp->ThreadId        = (FILE_ID)PsGetCurrentThreadId();
    pRecordIrp->Argument1       = pIrpStack->Parameters.Others.Argument1;
    pRecordIrp->Argument2       = pIrpStack->Parameters.Others.Argument2;
    pRecordIrp->Argument3       = pIrpStack->Parameters.Others.Argument3;
    pRecordIrp->Argument4       = pIrpStack->Parameters.Others.Argument4;

    if (IRP_MJ_CREATE == pRecordIrp->IrpMajor) {

		//
		//  Only record the desired access if this is a CREATE irp.
		//

        pRecordIrp->DesiredAccess = pIrpStack->Parameters.Create.SecurityContext->DesiredAccess;
    }

    KeQuerySystemTime(&(pRecordIrp->OriginatingTime));

    lookupFlags = 0;

    switch (pIrpStack->MajorFunction) {

        case IRP_MJ_CREATE:

            //
            // This is a CREATE so we need to invalidate the name currently
            // stored in the name cache for this FileObject.
            //

            SpyNameDelete(pIrpStack->FileObject);

            //
            //  Flag in Create
            //

            SetFlag( lookupFlags, NLFL_IN_CREATE );

            //
            //  Flag if opening the directory of the given file
            //

            if (FlagOn( pIrpStack->Flags, SL_OPEN_TARGET_DIRECTORY )) {

                SetFlag( lookupFlags, NLFL_OPEN_TARGET_DIR );
            }

            //
            //  Flag if opening by ID
            //

            if (FlagOn( pIrpStack->Parameters.Create.Options, FILE_OPEN_BY_FILE_ID )) {

                SetFlag( lookupFlags, NLFL_OPEN_BY_ID );
            }
            break;

        case IRP_MJ_CLOSE:
            //
            //  We can only look up the name in the name cache if this is a CLOSE.  
            //  It is possible that the close could be occurring during a cleanup 
            //  operation in the file system (i.e., before we have received the
            //  cleanup completion) and requesting the name would cause a deadlock
            //  in the file system.
            //  

            SetFlag( lookupFlags, NLFL_ONLY_CHECK_CACHE );
            break;
    }

    //
    //  If the flag IRP_PAGING_IO is set in this IRP, we cannot query the name
    //  because it can lead to deadlocks.  Therefore, add in the flag so that
    //  we will only try to find the name in our cache.
    //

    if (FlagOn( Irp->Flags, IRP_PAGING_IO )) {

        ASSERT( !FlagOn( lookupFlags, NLFL_NO_LOOKUP ) );

        SetFlag( lookupFlags, NLFL_ONLY_CHECK_CACHE );
    }

    SpySetName( RecordList, 
                pIrpStack->DeviceObject, 
                pIrpStack->FileObject, 
                lookupFlags, 
                NULL);
}


VOID
SpyLogIrpCompletion (
    IN PIRP Irp,
    OUT PRECORD_LIST RecordList
    )
/*++

Routine Description:

    Records the Irp necessary information according to LoggingFlags in
    RecordList.  For any activity on the Irp path of a device being
    logged, this function should get called twice: once on the Irp's
    originating path and once on the Irp's completion path.

Arguments:

    Irp - The Irp that contains the information we want to record.
    LoggingFlags - The flags that say what to log.
    RecordList - The PRECORD_LIST in which the Irp information is stored.

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION pIrpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_OBJECT deviceObject = pIrpStack->DeviceObject;
    PRECORD_IRP pRecordIrp;

    //
    //  Process the log record
    //

    if (SHOULD_LOG( deviceObject )) {

        pRecordIrp = &RecordList->LogRecord.Record.RecordIrp;

        //
        // Record the information we use for a completion Irp.
        //

        pRecordIrp->ReturnStatus = Irp->IoStatus.Status;
        pRecordIrp->ReturnInformation = Irp->IoStatus.Information;
        KeQuerySystemTime(&pRecordIrp->CompletionTime);

        //
        //  Add recordList to our gOutputBufferList so that it gets up to 
        //  the user
        //
        
        SpyLog( RecordList );       

    } else {

        if (RecordList) {

            //
            //  Context is set with a RECORD_LIST, but we are no longer
            //  logging so free this record.
            //

            SpyFreeRecord( RecordList );
        }
    }

    switch (pIrpStack->MajorFunction) {

        case IRP_MJ_CREATE:
            //
            //  If the operation failed remove the name from the cache because
            //  it is stale
            //

            if (!NT_SUCCESS(Irp->IoStatus.Status) &&
                (pIrpStack->FileObject != NULL)) {

                SpyNameDelete(pIrpStack->FileObject);
            }
            break;

        case IRP_MJ_CLOSE:

            //
            //  Always remove the name on close
            //

            SpyNameDelete(pIrpStack->FileObject);
            break;


        case IRP_MJ_SET_INFORMATION:
            //
            //  If the operation was successful and it was a rename, always
            //  remove the name.  They can re-get it next time.
            //

            if (NT_SUCCESS(Irp->IoStatus.Status) &&
                (FileRenameInformation == 
                 pIrpStack->Parameters.SetFile.FileInformationClass)) {

                SpyNameDelete(pIrpStack->FileObject);
            }
            break;
    }
}


////////////////////////////////////////////////////////////////////////
//
//                    FileName cache routines
//
////////////////////////////////////////////////////////////////////////

PHASH_ENTRY
SpyHashBucketLookup (
    IN PLIST_ENTRY  ListHead,
    IN PFILE_OBJECT FileObject
    )
/*++

Routine Description:

    This routine looks up the FileObject in the give hash bucket.  This routine
    does NOT lock the hash bucket.

Arguments:

    ListHead - hash list to search
    FileObject - the FileObject to look up.

Return Value:

    A pointer to the hash table entry.  NULL if not found

--*/
{
    PHASH_ENTRY pHash;
    PLIST_ENTRY pList;

    pList = ListHead->Flink;

    while (pList != ListHead){

        pHash = CONTAINING_RECORD( pList, HASH_ENTRY, List );

        if (FileObject == pHash->FileObject) {

            return pHash;
        }

        pList = pList->Flink;
    }

    return NULL;
}

VOID
SpySetName (
    IN PRECORD_LIST RecordList,
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN ULONG LookupFlags,
    IN PVOID Context OPTIONAL
    )
/*++

Routine Description:

    This routine looks up the FileObject in the hash table.  If the FileObject
    is found in the hash table, copy the associated file name to RecordList.
    Otherwise, calls SpyGetFullPathName to try to get the name of the FileObject.
    If successful, copy the file name to the RecordList and insert into hash
    table.

Arguments:

    RecordList - RecordList to copy name to.
    FileObject - the FileObject to look up.
    LookInFileObject - see routine description
    DeviceExtension - contains the volume name (e.g., "c:") and
        the next device object which may be needed.

Return Value:

    None.
    
--*/
{
    PFILESPY_DEVICE_EXTENSION devExt = DeviceObject->DeviceExtension;
    UINT_PTR hashIndex;
    KIRQL oldIrql;
    PHASH_ENTRY pHash;
    PHASH_ENTRY newHash;
    PLIST_ENTRY listHead;
    PUNICODE_STRING newName;
    PCHAR buffer;

    UNREFERENCED_PARAMETER( Context );

    if (FileObject == NULL) {

        return;
    }

    hashIndex = HASH_FUNC(FileObject);

    INC_STATS(TotalContextSearches);

    listHead = &gHashTable[hashIndex];

    //
    //  Don't bother checking the hash if we are in create, we must always
    //  generate a name
    //

    if (!FlagOn( LookupFlags, NLFL_IN_CREATE )) {

        KeAcquireSpinLock( &gHashLockTable[hashIndex], &oldIrql );

        pHash = SpyHashBucketLookup(&gHashTable[hashIndex], FileObject);

        if (pHash != NULL) {

            //
            //  Copy the file name to the LogRecord, make sure that it is NULL terminated,
            //  and increment the length of the LogRecord.
            //

            SpyCopyFileNameToLogRecord( &RecordList->LogRecord, &pHash->Name );
        
            KeReleaseSpinLock(&gHashLockTable[hashIndex], oldIrql);

            INC_STATS(TotalContextFound);

            return;
        }

        KeReleaseSpinLock(&gHashLockTable[hashIndex], oldIrql);
    }

    //
    //  If it is not in the table, try to add it.  We will not be able to look
    //  up the name if we are at DISPATCH_LEVEL.
    //

    buffer = SpyAllocateBuffer(&gNamesAllocated, gMaxNamesToAllocate, NULL);

    if (buffer != NULL) {
    
        newHash = (PHASH_ENTRY) buffer;
        newName = &newHash->Name;

        RtlInitEmptyUnicodeString(
                newName,
                (PWCHAR)(buffer + sizeof(HASH_ENTRY)),
                RECORD_SIZE - sizeof(HASH_ENTRY) );

        if (SpyGetFullPathName( FileObject, newName, devExt, LookupFlags )) {

            newHash->FileObject = FileObject;
            KeAcquireSpinLock(&gHashLockTable[hashIndex], &oldIrql);

            //
            //  Search again because it may have been stored in the
            //  hash table since we dropped the lock.
            //
			
			pHash = SpyHashBucketLookup(&gHashTable[hashIndex], FileObject);

            if (pHash != NULL) {

                //
                //  We found it in the hash table this time, so
                //  write the name we found to the LogRecord.
                //

                //
                //  Copy the file name to the LogRecord, make sure that it is NULL terminated,
                //  and increment the length of the LogRecord.
                //

                SpyCopyFileNameToLogRecord( &RecordList->LogRecord, &pHash->Name );

                KeReleaseSpinLock(&gHashLockTable[hashIndex], oldIrql);

                SpyFreeBuffer(buffer, &gNamesAllocated);

                return;
            }

            //
            // It wasn't found, add the new entry
            //

            //
            //  Copy the file name to the LogRecord, make sure that it is NULL terminated,
            //  and increment the length of the LogRecord.
            //

            SpyCopyFileNameToLogRecord( &RecordList->LogRecord, newName );

            InsertHeadList(listHead, &newHash->List);

            gHashCurrentCounters[hashIndex]++;

            if (gHashCurrentCounters[hashIndex] > gHashMaxCounters[hashIndex]) {

                gHashMaxCounters[hashIndex] = gHashCurrentCounters[hashIndex];
            }

            KeReleaseSpinLock(&gHashLockTable[hashIndex], oldIrql);

        } else {

            //
            //  We are not supposed to keep the log record entry, copy
            //  what ever they gave us in
            //

            SpyCopyFileNameToLogRecord( &RecordList->LogRecord, newName );

            INC_STATS(TotalContextTemporary);
            SpyFreeBuffer (buffer, &gNamesAllocated);
        }

    } else {

        //
        //  Set a default string even if there is no buffer
        //

        SpyCopyFileNameToLogRecord( &RecordList->LogRecord, &OutOfBuffers );
    }

    return;
}

VOID
SpyNameDeleteAllNames (
    VOID
    )
/*++

Routine Description:

    This will free all entries from the hash table

Arguments:

    None

Return Value:

    None


--*/
{
    KIRQL oldIrql;
    PHASH_ENTRY pHash;
    PLIST_ENTRY pList;
    ULONG i;

    INC_STATS(TotalContextDeleteAlls);
    for (i=0;i < HASH_SIZE;i++) {

        KeAcquireSpinLock(&gHashLockTable[i], &oldIrql);

        while (!IsListEmpty(&gHashTable[i])) {

            pList = RemoveHeadList(&gHashTable[i]);
            pHash = CONTAINING_RECORD( pList, HASH_ENTRY, List );
            SpyFreeBuffer( pHash, &gNamesAllocated);
        }

        gHashCurrentCounters[i] = 0;

        KeReleaseSpinLock(&gHashLockTable[i], oldIrql);
    }
}

VOID
SpyNameDelete (
    IN PFILE_OBJECT FileObject
    )
/*++

Routine Description:

    This routine looks up the FileObject in the hash table.  If it is found,
    it deletes it and frees the memory.

Arguments:

    FileObject - the FileObject to look up.

Return Value:

    None


--*/
{
    UINT_PTR hashIndex;
    KIRQL oldIrql;
    PHASH_ENTRY pHash;
    PLIST_ENTRY pList;
    PLIST_ENTRY listHead;

    hashIndex = HASH_FUNC(FileObject);

    KeAcquireSpinLock(&gHashLockTable[hashIndex], &oldIrql);

    listHead = &gHashTable[hashIndex];

    pList = listHead->Flink;

    while(pList != listHead){

        pHash = CONTAINING_RECORD( pList, HASH_ENTRY, List );

        if (FileObject == pHash->FileObject) {

            INC_STATS(TotalContextNonDeferredFrees);
            gHashCurrentCounters[hashIndex]--;
            RemoveEntryList(pList);
            SpyFreeBuffer( pHash, &gNamesAllocated );
            break;
        }

        pList = pList->Flink;
    }

    KeReleaseSpinLock(&gHashLockTable[hashIndex], oldIrql);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\filespy\fspykd\pch.h ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    pch.h

Abstract:

    Header file which allows kernel and user mode header files
	to be included together for compilation of debugger extensions.

// @@BEGIN_DDKSPLIT

Author:

    Molly Brown [MollyBro]    1-Mar-2000

Revision History:

	Molly Brown [MollyBro]
		
		Cleaned up this header file based on example in 
		"The Windows NT Device Driver Book" by Art Baker.

// @@END_DDKSPLIT

Environment:

    User Mode.

--*/
#include <windows.h>
#include <string.h>
#define KDEXT_64BIT
#include <wdbgexts.h>
#include <stdlib.h>
#include <stdio.h>
#include <fspydef.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\filespy\fspykd\kdext.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    kdext.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.
// @@BEGIN_DDKSPLIT

Author:

    Wesley Witt (wesw) 26-Aug-1993
    Ravisankar Pudipeddi [ravisp] 3-March-01 (moved to filespy)

// @@END_DDKSPLIT

Environment:

    User Mode

--*/

#include "pch.h"
#pragma hdrstop

#include <ntverp.h>

//
// globals
//

EXT_API_VERSION        ApiVersion = { 6, 0, EXT_API_VERSION_NUMBER64, 0 };
WINDBG_EXTENSION_APIS  ExtensionApis;
ULONG                  STeip;
ULONG                  STebp;
ULONG                  STesp;
USHORT                 SavedMajorVersion;
USHORT                 SavedMinorVersion;



DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    UNREFERENCED_PARAMETER( hModule );
    UNREFERENCED_PARAMETER( dwReserved );

    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}


VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    return;
}

DECLARE_API( version )
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    UNREFERENCED_PARAMETER( args );
    UNREFERENCED_PARAMETER( dwProcessor );
    UNREFERENCED_PARAMETER( dwCurrentPc );
    UNREFERENCED_PARAMETER( hCurrentThread );
    UNREFERENCED_PARAMETER( hCurrentProcess );

    dprintf( "%s Extension dll for Build %d debugging %s kernel for Build %d\n",
             DebuggerType,
             VER_PRODUCTBUILD,
             SavedMajorVersion == 0x0c ? "Checked" : "Free",
             SavedMinorVersion
           );
}

VOID
CheckVersion(
    VOID
    )
{
#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\filespy\install\install.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

   install.c

Abstract:

   This is the main module to install the filespy filter driver.  This was
   adapted from the sfilter installation program.

// @@BEGIN_DDKSPLIT

Author:

	Molly Brown	(MollyBro)

// @@END_DDKSPLIT

Environment:

   User Mode Only

// @@BEGIN_DDKSPLIT

Revision History:
    Neal Christiansen (nealch) 28-Jun-2000
        Updated to not fail if it can't copy the driver.  Updated to handle
        the service already being present.  Updated to add the DebugDisplay
        registry value.

// @@END_DDKSPLIT

--*/

#include <windows.h>
#include <stdio.h>
#include <conio.h>
#include "filespy.h"
#include "fspyServ.h"

//
//  Enable these warnings in the code.
//

#pragma warning(error:4101)   // Unreferenced local variable

/////////////////////////////////////////////////////////////////////////////
//
//                          Globals
//
/////////////////////////////////////////////////////////////////////////////

VOID
DisplayError(
   DWORD Code
   );


/////////////////////////////////////////////////////////////////////////////
//
//                      Functions
//
/////////////////////////////////////////////////////////////////////////////

void __cdecl
main (
   int argc,
   char *argv[]
   )
/*++

Routine Description:

   This is the program entry point and main processing routine for the
   installation console mode application. It will be responsible for
   installing the file system filter driver into the registry and preparing
   the system for a reboot.

Arguments:

   argc - The count of arguments passed into the command line.

   argv - Array of arguments passed into the command line.

Return Value:

   None.

--*/

{
    SC_HANDLE           scmHandle = NULL;
    SC_HANDLE           filespyService = NULL;
    DWORD               errorCode = 0;
    DWORD               tagID;
    BOOL                status;
    HKEY                key = NULL;
    LONG                openStatus;
    ULONG               initialValue;
    WCHAR               driverDirectory[MAX_PATH];
    WCHAR               driverFullPath[MAX_PATH];

    UNREFERENCED_PARAMETER( argc );
    UNREFERENCED_PARAMETER( argv );
    
    //
    // Begin by displaying an introduction message to the user to let them
    // know that the application has started.
    //
    
    printf( "\nFilespy.sys Simple Installation Aid\n"
            "Copyright (c) 1999  Microsoft Corporation\n\n\n" );
    
    //
    // Get the directory where we are going to put the driver
    // Get the full path to the driver
    //
    
    GetSystemDirectory( driverDirectory, sizeof(driverDirectory) );
    wcscat( driverDirectory, L"\\drivers" );

    swprintf( driverFullPath, L"%s\\filespy.sys", driverDirectory );
    
    //
    // Obtain a handle to the service control manager requesting all access
    //
    
    scmHandle = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    
    //
    // Verify that a handle could be obtained.
    //
    
    if (!scmHandle) {
    
        //
        // A handle could not be obtained. Get the error code and display a
        // useful message to the user.
        //

        printf( "The Service Control Manager could not be opened.\n" );
        DisplayError( GetLastError() );
        return;
    }
    
    //
    // Install the service with the Service Control Manager.
    //
    
    filespyService = CreateService ( scmHandle,
                                     FILESPY_SERVICE_NAME,
                                     L"Sample File System Filter that displays File Operations",
                                     SERVICE_ALL_ACCESS,
                                     SERVICE_FILE_SYSTEM_DRIVER,
                                     SERVICE_DEMAND_START,
                                     SERVICE_ERROR_NORMAL,
                                     driverFullPath,
                                     L"FSFilter Activity Monitor",
                                     &tagID,
                                     NULL,
                                     NULL,
                                     NULL );
    
    //
    // Check to see if the driver could actually be installed.
    //
    
    if (!filespyService) {
    
        //
        // The driver could not be installed. Display a useful error message
        // and exit.
        //
        errorCode = GetLastError();

        //
        //  If the service already existed, just go on and copy the driver
        //

        if (ERROR_SERVICE_EXISTS == errorCode) {
            printf( "The FILESPY service already exists.\n" );
            goto CopyTheFile;
        }

        printf( "The Filespy service could not be created.\n" );
        DisplayError( errorCode );
        goto Cleanup;
    }
    
    //
    // Get a handle to the key for the driver so that it can be altered in the
    // next step.
    //
    
    openStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                              L"SYSTEM\\CurrentControlSet\\Services\\filespy",
                              0,
                              KEY_ALL_ACCESS,
                              &key);
    
    //
    // Check the return to make sure that the application could get a
    // handle to the key.
    //
    
    if (openStatus != ERROR_SUCCESS) {
    
      //
      // A problem has occurred. Delete the service so that it is not
      // installed, then display error message and exit.
      //
    
      DeleteService( filespyService );
      printf( "Registry key could not be opened for driver.\n" );
      DisplayError( openStatus );
      goto Cleanup;
    }
    
    //
    // Delete the ImagePath value in the newly created key so that the
    // system looks for the driver in the normal location.
    //

    openStatus = RegDeleteValue (key, L"ImagePath");

    //
    // report an error and go on if we can't delete the key
    //

    if (openStatus != ERROR_SUCCESS) {

      printf("Could not delete ImagePath key.\n") ;
      DisplayError (openStatus) ;
    }

    //
    // Add the MaxRecords and MaxNames parameters to the registry
    //

    initialValue = 500;
    openStatus = RegSetValueEx( key,
                                L"MaxRecords",
                                0,
                                REG_DWORD,
                                (PUCHAR)&initialValue,
                                sizeof(initialValue));

    openStatus = RegSetValueEx( key,
                                L"MaxNames",
                                0,
                                REG_DWORD,
                                (PUCHAR)&initialValue,
                                sizeof(initialValue) );

    //
    // Display a message indicating that the driver has successfully been
    // installed and the system will be shutting down.
    //
    
    printf("The FILESPY service was successfully created.\n");


CopyTheFile:

    //
    // Copy the file to the appropriate directory on the target drive.
    //
    
    status = CopyFile( L"filespy.sys", driverFullPath, FALSE );

    if (!status) {

        printf("\nCopying of \"filespy.sys\" to \"%S\" failed.\n",
                driverDirectory );
        DisplayError( GetLastError() );

    } else {

        printf( "\"filespy.sys\" was successfully copied to \"%S\".\n", 
                driverDirectory );
    }


Cleanup:

    //
    // Close the key handle if it is set since it is no longer needed.
    //

    if (key) {

        RegCloseKey( key );
    }
    
    //
    // The driver has now been installed or there was an error. Close the 
    // service handle and scmHandle handle if they were set
    // since we don't need them any longer.
    //

    if(filespyService){

        CloseServiceHandle(filespyService);
    }

    if(scmHandle) {

        CloseServiceHandle(scmHandle);
    }

    //
    // Display a message indicating that the driver has successfully been
    // installed and the system will be shutting down.
    //

    if (!errorCode) {

        printf( "\nDriver successfully installed.\n\n"
                "The driver can be started immediately with the following command line:\n"
                "    sc start filespy\n"
                "or by rebooting the system.\n" );
    }
}

VOID
DisplayError (
   DWORD Code
   )

/*++

Routine Description:

   This routine will display an error message based off of the Win32 error
   code that is passed in. This allows the user to see an understandable
   error message instead of just the code.

Arguments:

   Code - The error code to be translated.

Return Value:

   None.

--*/

{
   WCHAR buffer[80];
   DWORD count;

   //
   // Translate the Win32 error code into a useful message.
   //

   count = FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM,
                          NULL,
                          Code,
                          0,
                          buffer,
                          sizeof(buffer),
                          NULL);

   //
   // Make sure that the message could be translated.
   //

   if (count == 0) {

      printf( "(%d) Error could not be translated.\n", Code );
      return;
   }
   else {

      //
      // Display the translated error.
      //

      printf( "(%d) %S\n", Code, buffer );
      return;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\filespy\filter\fspykern.h ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    fspyKern.h

Abstract:
    Header file which contains the structures, type definitions,
    constants, global variables and function prototypes that are
    only visible within the kernel.

    As of the Windows XP SP1 IFS Kit version of this sample and later, this
    sample can be built for each build environment released with the IFS Kit
    with no additional modifications.  To provide this capability, additional
    compile-time logic was added -- see the '#if WINVER' locations.  Comments
    tagged with the 'VERSION NOTE' header have also been added as appropriate to
    describe how the logic must change between versions.

    If this sample is built in the Windows XP environment or later, it will run
    on Windows 2000 or later.  This is done by dynamically loading the routines
    that are only available on Windows XP or later and making run-time decisions
    to determine what code to execute.  Comments tagged with 'MULTIVERISON NOTE'
    mark the locations where such logic has been added.

// @@BEGIN_DDKSPLIT

Author:

    George Jenkins (georgeje)
    Neal Christiansen (nealch)
    Molly Brown (mollybro)  

// @@END_DDKSPLIT

Environment:

    Kernel mode

// @@BEGIN_DDKSPLIT

Revision History:
    Neal Christiansen (nealch) updated to support stream contexts

    Molly Brown (mollybro)         21-May-2002
        Modify sample to make it support running on Windows 2000 or later if
        built in the latest build environment and allow it to be built in W2K 
        and later build environments.

// @@END_DDKSPLIT
--*/
#ifndef __FSPYKERN_H__
#define __FSPYKERN_H__

//
//  VERSION NOTE:
//
//  The following useful macros are defined in NTIFS.H in Windows XP and later.
//  We will define them locally if we are building for the Windows 2000 
//  environment.
//

#if WINVER == 0x0500

//
//  These macros are used to test, set and clear flags respectively
//

#ifndef FlagOn
#define FlagOn(_F,_SF)        ((_F) & (_SF))
#endif

#ifndef BooleanFlagOn
#define BooleanFlagOn(F,SF)   ((BOOLEAN)(((F) & (SF)) != 0))
#endif

#ifndef SetFlag
#define SetFlag(_F,_SF)       ((_F) |= (_SF))
#endif

#ifndef ClearFlag
#define ClearFlag(_F,_SF)     ((_F) &= ~(_SF))
#endif


#define RtlInitEmptyUnicodeString(_ucStr,_buf,_bufSize) \
    ((_ucStr)->Buffer = (_buf), \
     (_ucStr)->Length = 0, \
     (_ucStr)->MaximumLength = (USHORT)(_bufSize))


#ifndef min
#define min(a,b) (((a) < (b)) ? (a) : (b))
#endif

#ifndef max
#define max(a,b) (((a) > (b)) ? (a) : (b))
#endif

#define ExFreePoolWithTag( a, b ) ExFreePool( (a) )
#endif /* WINVER == 0x0500 */

//
//  This controls how FileSpy is built.  It has 2 options:
//  0 - Build using NameHashing (old way, see fspyHash.c)
//  1 - Build using StreamContexts (new Way, see fspyCtx.c)
//
//  VERSION NOTE:
//  
//  Filter stream contexts are only supported on Windows XP and later
//  OS versions.  This support was not available in Windows 2000 or NT 4.0.
//

#define USE_STREAM_CONTEXTS 0

#if USE_STREAM_CONTEXTS && WINVER < 0x0501
#error Stream contexts on only supported on Windows XP or later.
#endif

//
//  POOL Tag definitions
//

#define FILESPY_POOL_TAG        'ypSF'          //misc POOL allocations
#define FILESPY_LOGRECORD_TAG   'rlSF'          //log record tag
#define FILESPY_CONTEXT_TAG     'xcSF'          //contexts tag

#ifndef INVALID_HANDLE_VALUE
#define INVALID_HANDLE_VALUE ((HANDLE) -1)
#endif

#define CONSTANT_UNICODE_STRING(s)   { sizeof( s ) - sizeof( WCHAR ), sizeof(s), s }

//
//  Delay values for KeDelayExecutionThread()
//  (Values are negative to represent relative time)
//

#define DELAY_ONE_MICROSECOND   (-10)
#define DELAY_ONE_MILLISECOND   (DELAY_ONE_MICROSECOND*1000)
#define DELAY_ONE_SECOND        (DELAY_ONE_MILLISECOND*1000)

//
//  Don't use look-aside-list in the debug versions
//

#if DBG
#define MEMORY_DBG
#endif

//---------------------------------------------------------------------------
//  Macros for FileSpy DbgPrint levels.
//---------------------------------------------------------------------------

#define SPY_LOG_PRINT( _dbgLevel, _string )                 \
    (FlagOn(gFileSpyDebugLevel,(_dbgLevel)) ?               \
        DbgPrint _string  :                                 \
        ((void)0))


//---------------------------------------------------------------------------
//      Generic Resource acquire/release macros
//---------------------------------------------------------------------------

#define SpyAcquireResourceExclusive( _r, _wait )                            \
    (ASSERT( ExIsResourceAcquiredExclusiveLite((_r)) ||                     \
            !ExIsResourceAcquiredSharedLite((_r)) ),                        \
     KeEnterCriticalRegion(),                                               \
     ExAcquireResourceExclusiveLite( (_r), (_wait) ))

#define SpyAcquireResourceShared( _r, _wait )                               \
    (KeEnterCriticalRegion(),                                               \
     ExAcquireResourceSharedLite( (_r), (_wait) ))

#define SpyReleaseResource( _r )                                            \
    (ASSERT( ExIsResourceAcquiredSharedLite((_r)) ||                        \
             ExIsResourceAcquiredExclusiveLite((_r)) ),                     \
     ExReleaseResourceLite( (_r) ),                                         \
     KeLeaveCriticalRegion())

//---------------------------------------------------------------------------
// Macro to test if we are logging for this device
//
// NOTE: We don't bother synchronizing to check the gControlDeviceState since
//   we can tolerate a stale value here.  We just look at it here to avoid 
//   doing the logging work if we can.  We synchronize to check the 
//   gControlDeviceState before we add the log record to the gOutputBufferList 
//   and discard the log record if the ControlDevice is no longer OPENED.
//---------------------------------------------------------------------------

#define SHOULD_LOG(pDeviceObject) \
    ((gControlDeviceState == OPENED) && \
     FlagOn(((PFILESPY_DEVICE_EXTENSION)(pDeviceObject)->DeviceExtension)->Flags,LogThisDevice))

     
//---------------------------------------------------------------------------
//      Global variables
//---------------------------------------------------------------------------

//
//  Debugger definitions
//

typedef enum _SPY_DEBUG_FLAGS {

    SPYDEBUG_DISPLAY_ATTACHMENT_NAMES       = 0x00000001,
    SPYDEBUG_ERROR                          = 0x00000002,
    SPYDEBUG_TRACE_NAME_REQUESTS            = 0x00000004,
    SPYDEBUG_TRACE_IRP_OPS                  = 0x00000010,
    SPYDEBUG_TRACE_FAST_IO_OPS              = 0x00000020,
    SPYDEBUG_TRACE_FSFILTER_OPS             = 0x00000040,
    SPYDEBUG_TRACE_CONTEXT_OPS              = 0x00000100,
    SPYDEBUG_TRACE_DETAILED_CONTEXT_OPS     = 0x00000200,
    SPYDEBUG_TRACE_MISMATCHED_NAMES         = 0x00001000,
    SPYDEBUG_ASSERT_MISMATCHED_NAMES        = 0x00002000,

    SPYDEBUG_BREAK_ON_DRIVER_ENTRY          = 0x80000000
} SPY_DEBUG_FLAGS;

//
//  FileSpy global variables
//

extern SPY_DEBUG_FLAGS gFileSpyDebugLevel;
extern ULONG gFileSpyAttachMode;

extern PDEVICE_OBJECT gControlDeviceObject;
extern PDRIVER_OBJECT gFileSpyDriverObject;

extern FAST_MUTEX gSpyDeviceExtensionListLock;
extern LIST_ENTRY gSpyDeviceExtensionList;

extern KSPIN_LOCK gOutputBufferLock;
extern LIST_ENTRY gOutputBufferList;

extern NPAGED_LOOKASIDE_LIST gFreeBufferList;

extern ULONG gLogSequenceNumber;
extern KSPIN_LOCK gLogSequenceLock;

extern UNICODE_STRING gVolumeString;
extern UNICODE_STRING gOverrunString;
extern UNICODE_STRING gPagingIoString;

extern LONG gStaticBufferInUse;
extern CHAR gOutOfMemoryBuffer[RECORD_SIZE];

//
//  Statistics definitions.  Note that we don't do interlocked operations
//  because loosing a count once in a while isn't important enough vs the
//  overhead.
//

extern FILESPY_STATISTICS gStats;

#define INC_STATS(field)    (gStats.field++)
#define INC_LOCAL_STATS(var) ((var)++)

//
//  Attachment lock
//

extern FAST_MUTEX gSpyAttachLock;

//
//  FileSpy Registry values
//

#define DEFAULT_MAX_RECORDS_TO_ALLOCATE 100;
#define DEFAULT_MAX_NAMES_TO_ALLOCATE   100;
#define DEFAULT_FILESPY_DEBUG_LEVEL     SPYDEBUG_ERROR;
#define MAX_RECORDS_TO_ALLOCATE         L"MaxRecords"
#define MAX_NAMES_TO_ALLOCATE           L"MaxNames"
#define DEBUG_LEVEL                     L"DebugFlags"
#define ATTACH_MODE                     L"AttachMode"

extern LONG gMaxRecordsToAllocate;
extern LONG gRecordsAllocated;
extern LONG gMaxNamesToAllocate;
extern LONG gNamesAllocated;

//
//  Our Control Device State information
//

typedef enum _CONTROL_DEVICE_STATE {

    OPENED,
    CLOSED,
    CLEANING_UP

} CONTROL_DEVICE_STATE;

extern CONTROL_DEVICE_STATE gControlDeviceState;
extern KSPIN_LOCK gControlDeviceStateLock;

//
//  Given a device type, return a valid name
//

extern const PCHAR DeviceTypeNames[];
extern ULONG SizeOfDeviceTypeNames;

#define GET_DEVICE_TYPE_NAME( _type ) \
            ((((_type) > 0) && ((_type) < (SizeOfDeviceTypeNames / sizeof(PCHAR)))) ? \
                DeviceTypeNames[ (_type) ] : \
                "[Unknown]")

//---------------------------------------------------------------------------
//      Global defines
//---------------------------------------------------------------------------

//
//  Macro to test for device types we want to attach to
//

#define IS_SUPPORTED_DEVICE_TYPE(_type) \
    (((_type) == FILE_DEVICE_DISK_FILE_SYSTEM) || \
     ((_type) == FILE_DEVICE_CD_ROM_FILE_SYSTEM) || \
     ((_type) == FILE_DEVICE_NETWORK_FILE_SYSTEM))

//
// Returns the number of BYTES unused in the RECORD_LIST structure
//

#define REMAINING_NAME_SPACE(RecordList) \
    (USHORT)(RECORD_SIZE - \
            (((RecordList)->LogRecord.Length) + sizeof(LIST_ENTRY)))

#define USER_NAMES_SZ   64

//---------------------------------------------------------------------------
//      NameLookup Flags
//---------------------------------------------------------------------------

//
//    These are flags passed to the name lookup routine to identify different
//    ways the name of a file can be obtained
//

typedef enum _NAME_LOOKUP_FLAGS {

    //
    //  If set, only check in the name cache for the file name.
    //

    NLFL_ONLY_CHECK_CACHE           = 0x00000001,

    //
    //  If set, don't lookup the name
    //

    NLFL_NO_LOOKUP                  = 0x00000002,

    //
    //  if set, we are in the CREATE operation and the full path filename may
    //  need to be built up from the related FileObject.
    //

    NLFL_IN_CREATE                  = 0x00000004,
                
    //
    //  if set and we are looking up the name in the file object, the file object
    //  does not actually contain a name but it contains a file/object ID.
    //

    NLFL_OPEN_BY_ID                 = 0x00000008,

    //
    //  If set, the target directory is being opened
    //

    NLFL_OPEN_TARGET_DIR            = 0x00000010

} NAME_LOOKUP_FLAGS;


//---------------------------------------------------------------------------
//      Device Extension defines
//---------------------------------------------------------------------------

typedef enum _FSPY_DEV_FLAGS {

    //
    //  If set, this is an attachment to a volume device object, 
    //  If not set, this is an attachment to a file system control device
    //  object.
    //

    IsVolumeDeviceObject = 0x00000001,

    //
    //  If set, logging is turned on for this device
    //

    LogThisDevice = 0x00000002,

    //
    //  If set, contexts are initialized
    //

    ContextsInitialized = 0x00000004,
    
    //
    //  If set, this is linked into the extension list
    //

    ExtensionIsLinked = 0x00000008

} FSPY_DEV_FLAGS;


//
// Define the device extension structure that the FileSpy driver
// adds to each device object it is attached to.  It stores
// the context FileSpy needs to perform its logging operations on
// a device.
//

typedef struct _FILESPY_DEVICE_EXTENSION {

    //
    //  Device Object this extension is attached to
    //

    PDEVICE_OBJECT ThisDeviceObject;

    //
    //  Device object this filter is directly attached to
    //

    PDEVICE_OBJECT AttachedToDeviceObject;

    //
    //  When attached to Volume Device Objects, the physical device object
    //  that represents that volume.  NULL when attached to Control Device
    //  objects.
    //

    PDEVICE_OBJECT DiskDeviceObject;

    //
    //  Linked list of devices we are attached to
    //

    LIST_ENTRY NextFileSpyDeviceLink;

    //
    //  Flags for this device
    //

    FSPY_DEV_FLAGS Flags;

    //
    //  Linked list of contexts associated with this volume along with the
    //  lock.
    //

    LIST_ENTRY CtxList;
    ERESOURCE CtxLock;

    //
    //  When renaming a directory there is a window where the current names
    //  in the context cache may be invalid.  To eliminate this window we
    //  increment this count every time we start doing a directory rename 
    //  and decrement this count when it is completed.  When this count is
    //  non-zero then we query for the name every time so we will get a
    //  correct name for that instance in time.
    //

    ULONG AllContextsTemporary;

    //
    //  Name for this device.  If attached to a Volume Device Object it is the
    //  name of the physical disk drive.  If attached to a Control Device
    //  Object it is the name of the Control Device Object.
    //

    UNICODE_STRING DeviceName;

    //
    // Names the user used to start logging this device
    //

    UNICODE_STRING UserNames;

    //
    //  Buffers used to hold the above unicode strings
    //  Note:  We keep these two forms of the name so that we can build
    //         a nicer looking name when we are printing out file names.
    //         We want just the "c:" type device name at the beginning
    //         of a file name, not "\device\hardiskVolume1".
    //

    WCHAR DeviceNameBuffer[DEVICE_NAMES_SZ];
    WCHAR UserNamesBuffer[USER_NAMES_SZ];

} FILESPY_DEVICE_EXTENSION, *PFILESPY_DEVICE_EXTENSION;


#define IS_FILESPY_DEVICE_OBJECT( _devObj )                               \
    (((_devObj) != NULL) &&                                               \
     ((_devObj)->DriverObject == gFileSpyDriverObject) &&                 \
     ((_devObj)->DeviceExtension != NULL))


#if WINVER >= 0x0501
//
//  MULTIVERSION NOTE:
//
//  If built in the Windows XP environment or later, we will dynamically import
//  the function pointers for routines that were not supported on Windows 2000
//  so that we can build a driver that will run, with modified logic, on 
//  Windows 2000 or later.
//
//  Below are the prototypes for the function pointers that we need to 
//  dynamically import because not all OS versions support these routines.
//

typedef
NTSTATUS
(*PSPY_REGISTER_FILE_SYSTEM_FILTER_CALLBACKS) (
    IN PDRIVER_OBJECT DriverObject,
    IN PFS_FILTER_CALLBACKS Callbacks
    );

typedef
NTSTATUS
(*PSPY_ENUMERATE_DEVICE_OBJECT_LIST) (
    IN  PDRIVER_OBJECT DriverObject,
    IN  PDEVICE_OBJECT *DeviceObjectList,
    IN  ULONG DeviceObjectListSize,
    OUT PULONG ActualNumberDeviceObjects
    );

typedef
NTSTATUS
(*PSPY_ATTACH_DEVICE_TO_DEVICE_STACK_SAFE) (
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice,
    OUT PDEVICE_OBJECT *AttachedToDeviceObject
    );

typedef    
PDEVICE_OBJECT
(*PSPY_GET_LOWER_DEVICE_OBJECT) (
    IN  PDEVICE_OBJECT  DeviceObject
    );

typedef
PDEVICE_OBJECT
(*PSPY_GET_DEVICE_ATTACHMENT_BASE_REF) (
    IN PDEVICE_OBJECT DeviceObject
    );

typedef
NTSTATUS
(*PSPY_GET_DISK_DEVICE_OBJECT) (
    IN  PDEVICE_OBJECT  FileSystemDeviceObject,
    OUT PDEVICE_OBJECT  *DiskDeviceObject
    );

typedef
PDEVICE_OBJECT
(*PSPY_GET_ATTACHED_DEVICE_REFERENCE) (
    IN PDEVICE_OBJECT DeviceObject
    );

typedef
NTSTATUS
(*PSPY_GET_VERSION) (
    IN OUT PRTL_OSVERSIONINFOW VersionInformation
    );

typedef struct _SPY_DYNAMIC_FUNCTION_POINTERS {

    PSPY_REGISTER_FILE_SYSTEM_FILTER_CALLBACKS RegisterFileSystemFilterCallbacks;
    PSPY_ATTACH_DEVICE_TO_DEVICE_STACK_SAFE AttachDeviceToDeviceStackSafe;
    PSPY_ENUMERATE_DEVICE_OBJECT_LIST EnumerateDeviceObjectList;
    PSPY_GET_LOWER_DEVICE_OBJECT GetLowerDeviceObject;
    PSPY_GET_DEVICE_ATTACHMENT_BASE_REF GetDeviceAttachmentBaseRef;
    PSPY_GET_DISK_DEVICE_OBJECT GetDiskDeviceObject;
    PSPY_GET_ATTACHED_DEVICE_REFERENCE GetAttachedDeviceReference;
    PSPY_GET_VERSION GetVersion;

} SPY_DYNAMIC_FUNCTION_POINTERS, *PSPY_DYNAMIC_FUNCTION_POINTERS;

extern SPY_DYNAMIC_FUNCTION_POINTERS gSpyDynamicFunctions;

//
//  MULTIVERSION NOTE: For this version of the driver, we need to know the
//  current OS version while we are running to make decisions regarding what
//  logic to use when the logic cannot be the same for all platforms.  We
//  will look up the OS version in DriverEntry and store the values
//  in these global variables.
//

extern ULONG gSpyOsMajorVersion;
extern ULONG gSpyOsMinorVersion;

//
//  Here is what the major and minor versions should be for the various OS versions:
//
//  OS Name                                 MajorVersion    MinorVersion
//  ---------------------------------------------------------------------
//  Windows 2000                             5                 0
//  Windows XP                               5                 1
//  Windows .NET                             5                 2
//

#define IS_WINDOWSXP_OR_LATER() \
    (((gSpyOsMajorVersion == 5) && (gSpyOsMinorVersion >= 1)) || \
     (gSpyOsMajorVersion > 5))

#endif

//
//  Structure used to pass context information from dispatch routines to
//  completion routines for FSCTRL operations.  We need a different structures
//  for Windows 2000 from what we can use on Windows XP and later because
//  we handle the completion processing differently.
//

typedef struct _SPY_COMPLETION_CONTEXT {

    PRECORD_LIST RecordList;

} SPY_COMPLETION_CONTEXT, *PSPY_COMPLETION_CONTEXT;

typedef struct _SPY_COMPLETION_CONTEXT_W2K {

    SPY_COMPLETION_CONTEXT;
    
    WORK_QUEUE_ITEM WorkItem;
    PDEVICE_OBJECT DeviceObject;
    PIRP Irp;
    PDEVICE_OBJECT NewDeviceObject;

} SPY_COMPLETION_CONTEXT_W2K, *PSPY_COMPLETION_CONTEXT_W2K;

#if WINVER >= 0x0501
typedef struct _SPY_COMPLETION_CONTEXT_WXP_OR_LATER {

    SPY_COMPLETION_CONTEXT;
    
    KEVENT WaitEvent;

} SPY_COMPLETION_CONTEXT_WXP_OR_LATER, *PSPY_COMPLETION_CONTEXT_WXP_OR_LATER;
#endif

#ifndef FORCEINLINE
#define FORCEINLINE __inline
#endif

FORCEINLINE
VOID
SpyCopyFileNameToLogRecord( 
    PLOG_RECORD LogRecord,
    PUNICODE_STRING FileName
    )
/*++

Routine Description:

    Inline function to copy the file name into the log record.  The routine
    only copies as much of the file name into the log record as the log
    record allows.  Therefore, if the name is too long for the record, it will
    be truncated.  Also, the name is always NULL-terminated.

Arguments:

    LogRecord - The log record for which the name should be set.

    FileName - The file name to be set in the log record.

Return Value:

    None.

--*/
{                                                                          
    //
    //  Include space for NULL when copying the name
    //
    
    ULONG toCopy = min( MAX_NAME_SPACE,                                  
                        (ULONG)FileName->Length + sizeof( WCHAR ) );     
    
    RtlCopyMemory( LogRecord->Name,                                    
                   FileName->Buffer,                                       
                   toCopy - sizeof( WCHAR ) );
    
    //
    //  NULL terminate
    //
    
    LogRecord->Name[toCopy/sizeof( WCHAR ) - 1] = L'\0';
    LogRecord->Length += toCopy ;
}


    
////////////////////////////////////////////////////////////////////////
//
//    Prototypes for the routines this driver uses to filter the
//    the data that is being seen by this file systems.
//
//                   implemented in filespy.c
//
////////////////////////////////////////////////////////////////////////

NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

VOID
DriverUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
SpyDispatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SpyPassThrough (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SpyPassThroughCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
SpyCreate (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SpyClose (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

BOOLEAN
SpyFastIoCheckIfPossible (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN BOOLEAN CheckForReadOperation,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SpyFastIoRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN        
SpyFastIoWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SpyFastIoQueryBasicInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_BASIC_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SpyFastIoQueryStandardInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_STANDARD_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SpyFastIoLock (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    BOOLEAN FailImmediately,
    BOOLEAN ExclusiveLock,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SpyFastIoUnlockSingle (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SpyFastIoUnlockAll (
    IN PFILE_OBJECT FileObject,
    PEPROCESS ProcessId,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SpyFastIoUnlockAllByKey (
    IN PFILE_OBJECT FileObject,
    PVOID ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SpyFastIoDeviceControl (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
SpyFastIoDetachDevice (
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice
    );

BOOLEAN
SpyFastIoQueryNetworkOpenInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SpyFastIoMdlRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SpyFastIoMdlReadComplete (
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SpyFastIoPrepareMdlWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SpyFastIoMdlWriteComplete (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SpyFastIoReadCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    OUT struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SpyFastIoWriteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SpyFastIoMdlReadCompleteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SpyFastIoMdlWriteCompleteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SpyFastIoQueryOpen (
    IN PIRP Irp,
    OUT PFILE_NETWORK_OPEN_INFORMATION NetworkInformation,
    IN PDEVICE_OBJECT DeviceObject
    );

#if WINVER >= 0x0501 /* See comment in DriverEntry */

NTSTATUS
SpyPreFsFilterOperation (
    IN PFS_FILTER_CALLBACK_DATA Data,
    OUT PVOID *CompletionContext
    );

VOID
SpyPostFsFilterOperation (
    IN PFS_FILTER_CALLBACK_DATA Data,
    IN NTSTATUS OperationStatus,
    IN PVOID CompletionContext
    );

#endif

NTSTATUS
SpyCommonDeviceIoControl (
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus
    );

//-----------------------------------------------------
//
//  These routines are only used if Filespy is attaching
//  to all volumes in the system instead of attaching to
//  volumes on demand.
//
//-----------------------------------------------------

NTSTATUS
SpyFsControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SpyFsControlMountVolume (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
SpyFsControlMountVolumeCompleteWorker (
    IN PSPY_COMPLETION_CONTEXT_W2K Context
    );

NTSTATUS
SpyFsControlMountVolumeComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PDEVICE_OBJECT NewDeviceObject
    );

NTSTATUS
SpyFsControlLoadFileSystem (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
SpyFsControlLoadFileSystemComplete (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
SpyFsControlLoadFileSystemCompleteWorker (
    IN PSPY_COMPLETION_CONTEXT_W2K Context
    );

VOID
SpyFsNotification (
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN FsActive
    );

NTSTATUS
SpyMountCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
SpyLoadFsCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

////////////////////////////////////////////////////////////////////////
//
//                  Library support routines
//                   implemented in fspylib.c
//
////////////////////////////////////////////////////////////////////////

VOID
SpyReadDriverParameters (
    IN PUNICODE_STRING RegistryPath
    );

#if WINVER >= 0x0501
VOID
SpyLoadDynamicFunctions (
    );

VOID
SpyGetCurrentVersion (
    );
#endif
    
////////////////////////////////////////////////////////////////////////
//
//                  Memory allocation routines
//                   implemented in fspylib.c
//
////////////////////////////////////////////////////////////////////////

PVOID
SpyAllocateBuffer (
    IN OUT PLONG Counter,
    IN LONG MaxCounterValue,
    OUT PULONG RecordType
    );

VOID
SpyFreeBuffer (
    PVOID Buffer,
    PLONG Counter
    );

////////////////////////////////////////////////////////////////////////
//
//                      Logging routines
//                   implemented in fspylib.c
//
////////////////////////////////////////////////////////////////////////

PRECORD_LIST
SpyNewRecord (
    ULONG AssignedSequenceNumber
    );

VOID
SpyFreeRecord (
    PRECORD_LIST Record
    );

PRECORD_LIST
SpyLogFastIoStart (
    IN FASTIO_TYPE FastIoType,
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait
    );

VOID
SpyLogFastIoComplete (
    IN PIO_STATUS_BLOCK ReturnStatus,
    IN PRECORD_LIST RecordList
    );

#if WINVER >= 0x0501 /* See comment in DriverEntry */

VOID
SpyLogPreFsFilterOperation (
    IN PFS_FILTER_CALLBACK_DATA Data,
    OUT PRECORD_LIST RecordList
    );

VOID
SpyLogPostFsFilterOperation (
    IN NTSTATUS OperationStatus,
    OUT PRECORD_LIST RecordList
    );

#endif

NTSTATUS
SpyAttachDeviceToDeviceStack (
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice,
    IN OUT PDEVICE_OBJECT *AttachedToDeviceObject
    );

NTSTATUS
SpyLog (
    IN PRECORD_LIST NewRecord
    );

////////////////////////////////////////////////////////////////////////
//
//                    FileName cache routines
//                    implemented in fspylib.c
//
////////////////////////////////////////////////////////////////////////

BOOLEAN
SpyGetFullPathName (
    IN PFILE_OBJECT FileObject,
    IN OUT PUNICODE_STRING FileName,
    IN PFILESPY_DEVICE_EXTENSION DeviceExtension,
    IN NAME_LOOKUP_FLAGS LookupFlags
    );

NTSTATUS
SpyQueryFileSystemForFileName (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT NextDeviceObject,
    IN ULONG FileNameInfoLength,
    OUT PFILE_NAME_INFORMATION FileNameInfo,
    OUT PULONG ReturnedLength
    );

NTSTATUS
SpyQueryInformationFile (
	IN PDEVICE_OBJECT NextDeviceObject,
	IN PFILE_OBJECT FileObject,
	OUT PVOID FileInformation,
	IN ULONG Length,
	IN FILE_INFORMATION_CLASS FileInformationClass,
	OUT PULONG LengthReturned OPTIONAL
    );

////////////////////////////////////////////////////////////////////////
//
//         Common attachment and detachment routines
//              implemented in fspylib.c
//
////////////////////////////////////////////////////////////////////////

NTSTATUS 
SpyIsAttachedToDeviceByUserDeviceName (
    IN PUNICODE_STRING DeviceName,
    IN OUT PBOOLEAN IsAttached,
    IN OUT PDEVICE_OBJECT *StackDeviceObject,
    IN OUT PDEVICE_OBJECT *OurAttachedDeviceObject
    );

BOOLEAN
SpyIsAttachedToDevice (
    PDEVICE_OBJECT DeviceObject,
    PDEVICE_OBJECT *AttachedDeviceObject
    );

BOOLEAN
SpyIsAttachedToDeviceW2K (
    PDEVICE_OBJECT DeviceObject,
    PDEVICE_OBJECT *AttachedDeviceObject
    );

#if WINVER >= 0x0501
BOOLEAN
SpyIsAttachedToDeviceWXPAndLater (
    PDEVICE_OBJECT DeviceObject,
    PDEVICE_OBJECT *AttachedDeviceObject
    );
#endif

NTSTATUS
SpyAttachToMountedDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_OBJECT FilespyDeviceObject
    );

VOID
SpyCleanupMountedDevice (
    IN PDEVICE_OBJECT DeviceObject
    );

////////////////////////////////////////////////////////////////////////
//
//           Helper routine for turning on/off logging on demand
//                  implemented in fspylib.c
//
////////////////////////////////////////////////////////////////////////

NTSTATUS
SpyGetDeviceObjectFromName (
    IN PUNICODE_STRING DeviceName,
    OUT PDEVICE_OBJECT *DeviceObject
    );

////////////////////////////////////////////////////////////////////////
//
//                 Start/stop logging routines and helper functions
//                  implemented in fspylib.c
//
////////////////////////////////////////////////////////////////////////

NTSTATUS
SpyAttachToDeviceOnDemand (
    IN PDEVICE_OBJECT DeviceObject,
    IN PUNICODE_STRING UserDeviceName,
    IN OUT PDEVICE_OBJECT *FileSpyDeviceObject
    );

NTSTATUS
SpyAttachToDeviceOnDemandW2K (
    IN PDEVICE_OBJECT DeviceObject,
    IN PUNICODE_STRING UserDeviceName,
    IN OUT PDEVICE_OBJECT *FileSpyDeviceObject
    );

#if WINVER >= 0x0501
NTSTATUS
SpyAttachToDeviceOnDemandWXPAndLater (
    IN PDEVICE_OBJECT DeviceObject,
    IN PUNICODE_STRING UserDeviceName,
    IN OUT PDEVICE_OBJECT *FileSpyDeviceObject
    );
#endif

NTSTATUS
SpyStartLoggingDevice (
    PWSTR UserDeviceName
    );

NTSTATUS
SpyStopLoggingDevice (
    PWSTR deviceName
    );

////////////////////////////////////////////////////////////////////////
//
//       Attaching/detaching to all volumes in system routines
//                  implemented in fspylib.c
//
////////////////////////////////////////////////////////////////////////

NTSTATUS
SpyAttachToFileSystemDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PUNICODE_STRING Name
    );

VOID
SpyDetachFromFileSystemDevice (
    IN PDEVICE_OBJECT DeviceObject
    );

#if WINVER >= 0x0501
NTSTATUS
SpyEnumerateFileSystemVolumes (
    IN PDEVICE_OBJECT FSDeviceObject,
    IN PUNICODE_STRING Name
    );
#endif

////////////////////////////////////////////////////////////////////////
//
//             Private Filespy IOCTLs helper routines
//                  implemented in fspylib.c
//
////////////////////////////////////////////////////////////////////////

NTSTATUS
SpyGetAttachList (
    PVOID buffer,
    ULONG bufferSize,
    PULONG_PTR returnLength
    );

VOID
SpyGetLog (
    OUT PVOID OutputBuffer,
    IN ULONG OutputBufferLength,
    OUT PIO_STATUS_BLOCK IoStatus
    );

VOID
SpyCloseControlDevice (
    );

////////////////////////////////////////////////////////////////////////
//
//               Device name tracking helper routines
//                  implemented in fspylib.c
//
////////////////////////////////////////////////////////////////////////

VOID
SpyGetObjectName (
    IN PVOID Object,
    IN OUT PUNICODE_STRING Name
    );

VOID
SpyGetBaseDeviceObjectName (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PUNICODE_STRING Name
    );

VOID
SpyCacheDeviceName (
    IN PDEVICE_OBJECT DeviceObject
    );

BOOLEAN
SpyFindSubString (
    IN PUNICODE_STRING String,
    IN PUNICODE_STRING SubString
    );

VOID
SpyStoreUserName (
    IN PFILESPY_DEVICE_EXTENSION DeviceExtension,
    IN PUNICODE_STRING UserName
    );

////////////////////////////////////////////////////////////////////////
//
//                       Debug support routines
//                       implemented in fspylib.c
//
////////////////////////////////////////////////////////////////////////

VOID
SpyDumpIrpOperation (
    IN BOOLEAN InOriginatingPath,
    IN PIRP Irp
    );

VOID
SpyDumpFastIoOperation (
    IN BOOLEAN InPreOperation,
    IN FASTIO_TYPE FastIoOperation
    );

#if WINVER >= 0x0501 /* See comment in DriverEntry */

VOID
SpyDumpFsFilterOperation (
    IN BOOLEAN InPreOperationCallback,
    IN PFS_FILTER_CALLBACK_DATA Data
    );

#endif

////////////////////////////////////////////////////////////////////////
//
//                      COMMON Naming Routines    
//
//  Common named routines implemented differently between name Context
//  and name Hashing
//
////////////////////////////////////////////////////////////////////////

VOID
SpyInitNamingEnvironment(
    VOID
    );

VOID
SpyInitDeviceNamingEnvironment (
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
SpyCleanupDeviceNamingEnvironment (
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
SpySetName (
    IN PRECORD_LIST RecordList,
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN ULONG LookupFlags,
    IN PVOID Context OPTIONAL
);

VOID
SpyNameDeleteAllNames (
    VOID
    );

VOID
SpyLogIrp (
    IN PIRP Irp,
    OUT PRECORD_LIST RecordList
    );

VOID
SpyLogIrpCompletion(
    IN PIRP Irp,
    PRECORD_LIST RecordList
    );


#if USE_STREAM_CONTEXTS

////////////////////////////////////////////////////////////////////////
//
//                  Stream Context name routines
//                    implemented in fspyCtx.c
//
////////////////////////////////////////////////////////////////////////

//
//  Context specific flags
//

typedef enum _CTX_FLAGS {
    //
    //  If set, then we are currently linked into the device extension linked
    //  list.  
    //

    CTXFL_InExtensionList       = 0x00000001,

    //
    //  If set, then we are linked into the stream list.  Note that there is
    //  a small period of time when we might be unlinked with this flag still
    //  set (when the file system is calling SpyDeleteContextCallback).  This is
    //  fine because we still handle not being found in the list when we do
    //  the search.  This flag handles the case when the file has been completely
    //  closed (and the memory freed) on us.
    //

    CTXFL_InStreamList          = 0x00000002,


    //
    //  If set, this is a temporary context and should not be linked into
    //  any of the context lists.  It will be freed as soon as the user is
    //  done with this operation.  
    //

    CTXFL_Temporary             = 0x00000100,

    //
    //  If set, we are performing a significant operation that affects the state
    //  of this context so we should not use it.  If someone tries to get this
    //  context then create a temporary context and return it.  Cases where this
    //  occurs:
    //  - Source file of a rename.
    //  - Source file for the creation of a hardlink
    //

    CTXFL_DoNotUse              = 0x00000200

} CTX_FLAGS;

//
//  Structure for tracking an individual stream context.  Note that the buffer
//  for the FileName is allocated as part of this structure and follows 
//  immediately after it.
//

typedef struct _SPY_STREAM_CONTEXT
{
    //
    //  OS Structure used to track contexts per stream.  Note how we use
    //  the following fields:
    //      OwnerID     -> Holds pointer to our DeviceExtension
    //      InstanceId  -> Holds Pointer to FsContext associated
    //                     with this structure
    //  We use these values to get back to these structures
    //

    FSRTL_PER_STREAM_CONTEXT ContextCtrl;

    //
    //  Linked list used to track contexts per device (in our device
    //  extension).
    //

    LIST_ENTRY ExtensionLink;

    //
    //  This is a counter of how many threads are currently using this
    //  context.  The count is used in this way:
    //  - It is set to 1 when it is created.
    //  - It is incremented every time it is returned to a thread
    //  - It is decremented when the thread is done with it.
    //  - It is decremented when the underlying stream that is using it is freed
    //  - The context is deleted when this count goes to zero
    //

    LONG UseCount;

    //
    //  Holds the name of the file
    //

    UNICODE_STRING Name;

    //
    //  Flags for this context.  All flags are set or cleared via
    //  the interlocked bit routines except when the entry is being
    //  created, at this time we know nobody is using this entry.
    //

    CTX_FLAGS Flags;

    //
    //  Contains the FSContext value for the stream we are attached to.  We
    //  track this so we can delete this entry at any time.
    //

    PFSRTL_ADVANCED_FCB_HEADER Stream;

} SPY_STREAM_CONTEXT, *PSPY_STREAM_CONTEXT;

//
//  Macros for locking the context lock
//

#define SpyAcquireContextLockShared(_devext) \
            SpyAcquireResourceShared( &(_devext)->CtxLock, TRUE )

#define SpyAcquireContextLockExclusive(_devext) \
            SpyAcquireResourceExclusive( &(_devext)->CtxLock, TRUE )

#define SpyReleaseContextLock(_devext) \
            SpyReleaseResource( &(_devext)->CtxLock )


VOID
SpyDeleteAllContexts (
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
SpyDeleteContext (
    IN PDEVICE_OBJECT DeviceObject,
    IN PSPY_STREAM_CONTEXT pContext
    );

VOID
SpyLinkContext ( 
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN OUT PSPY_STREAM_CONTEXT *ppContext
    );

NTSTATUS
SpyCreateContext (
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN NAME_LOOKUP_FLAGS LookupFlags,
    OUT PSPY_STREAM_CONTEXT *pRetContext
    );

#define SpyFreeContext( pCtx ) \
    (ASSERT((pCtx)->UseCount == 0), \
     ExFreePool( (pCtx) ))

NTSTATUS
SpyGetContext (
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT pFileObject,
    IN NAME_LOOKUP_FLAGS LookupFlags,
    OUT PSPY_STREAM_CONTEXT *pRetContext
    );

PSPY_STREAM_CONTEXT
SpyFindExistingContext (
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject
    );

VOID
SpyReleaseContext (
    IN PSPY_STREAM_CONTEXT pContext
    );
#endif


#if !USE_STREAM_CONTEXTS
////////////////////////////////////////////////////////////////////////
//
//                  Name Hash support routines
//                  implemented in fspyHash.c
//
////////////////////////////////////////////////////////////////////////

typedef struct _HASH_ENTRY {

    LIST_ENTRY List;
    PFILE_OBJECT FileObject;
    UNICODE_STRING Name;

} HASH_ENTRY, *PHASH_ENTRY;


PHASH_ENTRY
SpyHashBucketLookup (
    PLIST_ENTRY ListHead,
    PFILE_OBJECT FileObject
);

VOID
SpyNameLookup (
    IN PRECORD_LIST RecordList,
    IN PFILE_OBJECT FileObject,
    IN ULONG LookupFlags,
    IN PFILESPY_DEVICE_EXTENSION DeviceExtension
    );

VOID
SpyNameDelete (
    IN PFILE_OBJECT FileObject
    );

#endif

//
//  Include definitions
//

#include "fspydef.h"

#endif /* __FSPYKERN_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\filespy\filter\fspylib.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    fspyLib.c

Abstract:

    This contains library support routines for FileSpy.  These routines
    do the main work for logging the I/O operations --- creating the log
    records, recording the relevant information, attach/detach from
    devices, etc.

    As of the Windows XP SP1 IFS Kit version of this sample and later, this
    sample can be built for each build environment released with the IFS Kit
    with no additional modifications.  To provide this capability, additional
    compile-time logic was added -- see the '#if WINVER' locations.  Comments
    tagged with the 'VERSION NOTE' header have also been added as appropriate to
    describe how the logic must change between versions.

    If this sample is built in the Windows XP environment or later, it will run
    on Windows 2000 or later.  This is done by dynamically loading the routines
    that are only available on Windows XP or later and making run-time decisions
    to determine what code to execute.  Comments tagged with 'MULTIVERISON NOTE'
    mark the locations where such logic has been added.

Environment:

    Kernel mode

// @@BEGIN_DDKSPLIT

Author:

    George Jenkins (georgeje) 6-Jan-1999
    Neal Christiansen (nealch)
    Molly Brown (mollybro)  

Revision History:

    Neal Christiansen (nealch)     06-Jul-2001
        Modified to use Stream Contexts to track names

    Ravisankar Pudipeddi (ravisp)  07-May-2002
        Make it work on IA64

    Molly Brown (mollybro)         21-May-2002
        Modify sample to make it support running on Windows 2000 or later if
        built in the latest build environment and allow it to be built in W2K 
        and later build environments.
        
// @@END_DDKSPLIT
--*/

#include <stdio.h>

#include <ntifs.h>
#include "filespy.h"
#include "fspyKern.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, SpyReadDriverParameters)
#pragma alloc_text(PAGE, SpyAttachDeviceToDeviceStack)
#pragma alloc_text(PAGE, SpyQueryFileSystemForFileName)
#pragma alloc_text(PAGE, SpyQueryInformationFile)
#pragma alloc_text(PAGE, SpyIsAttachedToDeviceByUserDeviceName)
#pragma alloc_text(PAGE, SpyIsAttachedToDevice)
#pragma alloc_text(PAGE, SpyIsAttachedToDeviceW2K)
#pragma alloc_text(PAGE, SpyAttachToMountedDevice)
#pragma alloc_text(PAGE, SpyCleanupMountedDevice)
#pragma alloc_text(PAGE, SpyAttachToDeviceOnDemand)
#pragma alloc_text(PAGE, SpyAttachToDeviceOnDemandW2K)
#pragma alloc_text(PAGE, SpyStartLoggingDevice)
#pragma alloc_text(PAGE, SpyStopLoggingDevice)
#pragma alloc_text(PAGE, SpyAttachToFileSystemDevice)
#pragma alloc_text(PAGE, SpyDetachFromFileSystemDevice)
#pragma alloc_text(PAGE, SpyGetAttachList)
#pragma alloc_text(PAGE, SpyGetObjectName)


#if WINVER >= 0x0501
#pragma alloc_text(INIT, SpyLoadDynamicFunctions)
#pragma alloc_text(INIT, SpyGetCurrentVersion)
#pragma alloc_text(PAGE, SpyIsAttachedToDeviceWXPAndLater)
#pragma alloc_text(PAGE, SpyAttachToDeviceOnDemandWXPAndLater)
#pragma alloc_text(PAGE, SpyEnumerateFileSystemVolumes)
#pragma alloc_text(PAGE, SpyGetBaseDeviceObjectName)
#endif

#endif

//////////////////////////////////////////////////////////////////////////
//                                                                      //
//                     Library support routines                         //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

VOID
SpyReadDriverParameters (
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    This routine tries to read the FileSpy-specific parameters from
    the registry.  These values will be found in the registry location
    indicated by the RegistryPath passed in.

Arguments:

    RegistryPath - the path key which contains the values that are
        the FileSpy parameters

Return Value:

    None.

--*/
{
    OBJECT_ATTRIBUTES attributes;
    HANDLE driverRegKey;
    NTSTATUS status;
    ULONG bufferSize, resultLength;
    PVOID buffer = NULL;
    UNICODE_STRING valueName;
    PKEY_VALUE_PARTIAL_INFORMATION pValuePartialInfo;

    PAGED_CODE();

    //
    //  All the global values are already set to default values.  Any
    //  values we read from the registry will override these defaults.
    //
    
    //
    //  Do the initial setup to start reading from the registry.
    //

    InitializeObjectAttributes( &attributes,
								RegistryPath,
								OBJ_CASE_INSENSITIVE,
								NULL,
								NULL);

    status = ZwOpenKey( &driverRegKey,
						KEY_READ,
						&attributes);

    if (!NT_SUCCESS(status)) {

        driverRegKey = NULL;
        goto SpyReadDriverParameters_Exit;
    }

    bufferSize = sizeof( KEY_VALUE_PARTIAL_INFORMATION ) + sizeof( ULONG );
    buffer = ExAllocatePoolWithTag( NonPagedPool, bufferSize, FILESPY_POOL_TAG );

    if (NULL == buffer) {

        goto SpyReadDriverParameters_Exit;
    }

    //
    // Read the gMaxRecordsToAllocate from the registry
    //

    RtlInitUnicodeString(&valueName, MAX_RECORDS_TO_ALLOCATE);

    status = ZwQueryValueKey( driverRegKey,
							  &valueName,
							  KeyValuePartialInformation,
							  buffer,
							  bufferSize,
							  &resultLength);

    if (NT_SUCCESS(status)) {

        pValuePartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION) buffer;
        ASSERT(pValuePartialInfo->Type == REG_DWORD);
        gMaxRecordsToAllocate = *((PLONG)&pValuePartialInfo->Data);

    }

    //
    // Read the gMaxNamesToAllocate from the registry
    //

    RtlInitUnicodeString(&valueName, MAX_NAMES_TO_ALLOCATE);

    status = ZwQueryValueKey( driverRegKey,
							  &valueName,
							  KeyValuePartialInformation,
							  buffer,
							  bufferSize,
							  &resultLength);

    if (NT_SUCCESS(status)) {

        pValuePartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION) buffer;
        ASSERT(pValuePartialInfo->Type == REG_DWORD);
        gMaxNamesToAllocate = *((PLONG)&pValuePartialInfo->Data);

    }

    //
    // Read the initial debug setting from the registry
    //

    RtlInitUnicodeString(&valueName, DEBUG_LEVEL);

    status = ZwQueryValueKey( driverRegKey,
                              &valueName,
                              KeyValuePartialInformation,
                              buffer,
                              bufferSize,
                              &resultLength );

    if (NT_SUCCESS( status )) {

        pValuePartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION) buffer;
        ASSERT( pValuePartialInfo->Type == REG_DWORD );
        gFileSpyDebugLevel |= *((PULONG)&pValuePartialInfo->Data);
        
    }
    
    //
    // Read the attachment mode setting from the registry
    //

    RtlInitUnicodeString(&valueName, ATTACH_MODE);

    status = ZwQueryValueKey( driverRegKey,
                              &valueName,
                              KeyValuePartialInformation,
                              buffer,
                              bufferSize,
                              &resultLength );

    if (NT_SUCCESS( status )) {

        pValuePartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION) buffer;
        ASSERT( pValuePartialInfo->Type == REG_DWORD );
        gFileSpyAttachMode = *((PULONG)&pValuePartialInfo->Data);
    }
    
    goto SpyReadDriverParameters_Exit;

SpyReadDriverParameters_Exit:

    if (NULL != buffer) {

        ExFreePoolWithTag( buffer, FILESPY_POOL_TAG );
    }

    if (NULL != driverRegKey) {

        ZwClose(driverRegKey);
    }

    return;
}

#if WINVER >= 0x0501
VOID
SpyLoadDynamicFunctions (
    )
/*++

Routine Description:

    This routine tries to load the function pointers for the routines that
    are not supported on all versions of the OS.  These function pointers are
    then stored in the global structure gSpyDynamicFunctions.

    This support allows for one driver to be built that will run on all 
    versions of the OS Windows 2000 and greater.  Note that on Windows 2000, 
    the functionality may be limited.
    
Arguments:

    None.
    
Return Value:

    None.

--*/
{
    UNICODE_STRING functionName;

    RtlZeroMemory( &gSpyDynamicFunctions, sizeof( gSpyDynamicFunctions ) );

    //
    //  For each routine that we would want to use, lookup its address in the
    //  kernel or hal.  If it is not present, that field in our global
    //  gSpyDynamicFunctions structure will be set to NULL.
    //

    RtlInitUnicodeString( &functionName, L"FsRtlRegisterFileSystemFilterCallbacks" );
    gSpyDynamicFunctions.RegisterFileSystemFilterCallbacks = MmGetSystemRoutineAddress( &functionName );

    RtlInitUnicodeString( &functionName, L"IoAttachDeviceToDeviceStackSafe" );
    gSpyDynamicFunctions.AttachDeviceToDeviceStackSafe = MmGetSystemRoutineAddress( &functionName );
    
    RtlInitUnicodeString( &functionName, L"IoEnumerateDeviceObjectList" );
    gSpyDynamicFunctions.EnumerateDeviceObjectList = MmGetSystemRoutineAddress( &functionName );

    RtlInitUnicodeString( &functionName, L"IoGetLowerDeviceObject" );
    gSpyDynamicFunctions.GetLowerDeviceObject = MmGetSystemRoutineAddress( &functionName );

    RtlInitUnicodeString( &functionName, L"IoGetDeviceAttachmentBaseRef" );
    gSpyDynamicFunctions.GetDeviceAttachmentBaseRef = MmGetSystemRoutineAddress( &functionName );

    RtlInitUnicodeString( &functionName, L"IoGetDiskDeviceObject" );
    gSpyDynamicFunctions.GetDiskDeviceObject = MmGetSystemRoutineAddress( &functionName );

    RtlInitUnicodeString( &functionName, L"IoGetAttachedDeviceReference" );
    gSpyDynamicFunctions.GetAttachedDeviceReference = MmGetSystemRoutineAddress( &functionName );

    RtlInitUnicodeString( &functionName, L"RtlGetVersion" );
    gSpyDynamicFunctions.GetVersion = MmGetSystemRoutineAddress( &functionName );
}

VOID
SpyGetCurrentVersion (
    )
/*++

Routine Description:

    This routine reads the current OS version using the correct routine based
    on what routine is available.

Arguments:

    None.
    
Return Value:

    None.

--*/
{
    if (NULL != gSpyDynamicFunctions.GetVersion) {

        RTL_OSVERSIONINFOW versionInfo;
        NTSTATUS status;

        //
        //  VERSION NOTE: RtlGetVersion does a bit more than we need, but
        //  we are using it if it is available to show how to use it.  It
        //  is available on Windows XP and later.  RtlGetVersion and
        //  RtlVerifyVersionInfo (both documented in the IFS Kit docs) allow
        //  you to make correct choices when you need to change logic based
        //  on the current OS executing your code.
        //

        versionInfo.dwOSVersionInfoSize = sizeof( RTL_OSVERSIONINFOW );

        status = (gSpyDynamicFunctions.GetVersion)( &versionInfo );

        ASSERT( NT_SUCCESS( status ) );

        gSpyOsMajorVersion = versionInfo.dwMajorVersion;
        gSpyOsMinorVersion = versionInfo.dwMinorVersion;
        
    } else {

        PsGetVersion( &gSpyOsMajorVersion,
                      &gSpyOsMinorVersion,
                      NULL,
                      NULL );
    }
}

#endif
////////////////////////////////////////////////////////////////////////
//                                                                    //
//                  Memory allocation routines                        //
//                                                                    //
////////////////////////////////////////////////////////////////////////

PVOID
SpyAllocateBuffer (
    IN OUT PLONG Counter,
    IN LONG MaxCounterValue,
    OUT PULONG RecordType
    )
/*++

Routine Description:

    Allocates a new buffer from the gFreeBufferList if there is enough memory
    to do so and Counter does not exceed MaxCounterValue.  The RecordType
    is set to one of the record type constants based on the allocation state.

Arguments:

    Counter - (optional) the counter variable to test and increment if
        we can allocate
    MaxCounterValue - (ignored if Counter not given) the value which
        Counter should not exceed
    RecordType - (optional) set to one of the following:
        RECORD_TYPE_NORMAL  allocation succeeded
        RECORD_TYPE_OUT_OF_MEMORY allocation failed because the system was
                                  out of memory
        RECORD_TYPE_EXCEED_MEMORY_ALLOWANCE allocation failed because the
                                counter exceeded its maximum value.

Return Value:

    Pointer to the buffer allocate, or NULL if allocation failed (either
    because system is out of memory or we have exceeded the MaxCounterValue).

--*/
{
    PVOID newBuffer;
    ULONG newRecordType = RECORD_TYPE_NORMAL;

#ifdef MEMORY_DBG
    //
    //  When we are debugging the memory usage to make sure that we
    //  don't leak memory, we want to allocate the memory from pool
    //  so that we can use the Driver Verifier to help debug any
    //  memory problems.
    //

    newBuffer = ExAllocatePoolWithTag( NonPagedPool, 
                                       RECORD_SIZE, 
                                       FILESPY_LOGRECORD_TAG );
#else

    //
    //  When we are not debugging the memory usage, we use a look-aside
    //  list for better performance.
    //

    newBuffer = ExAllocateFromNPagedLookasideList( &gFreeBufferList );
#endif

    if (newBuffer) {

        if (Counter) {

            if (*Counter < MaxCounterValue) {

                InterlockedIncrement(Counter);

            } else {

				//
                // We've exceed our driver's memory limit so note that
                // and give back the record
				//

                SetFlag( newRecordType, 
                         (RECORD_TYPE_STATIC | RECORD_TYPE_EXCEED_MEMORY_ALLOWANCE) );

#ifdef MEMORY_DBG
                ExFreePoolWithTag( newBuffer, FILESPY_POOL_TAG );
#else
                ExFreeToNPagedLookasideList( &gFreeBufferList, newBuffer );
#endif

                newBuffer = NULL;
            }
        }

    }  else {

        SetFlag( newRecordType,
                 (RECORD_TYPE_STATIC | RECORD_TYPE_OUT_OF_MEMORY) );
    }

    if (RecordType) {

        *RecordType = newRecordType;
    }

    return newBuffer;
}

VOID
SpyFreeBuffer (
    IN PVOID Buffer,
    IN PLONG Counter
    )
/*++

Routine Description:

    Returns a Buffer to the gFreeBufferList.

Arguments:

    Buffer - the buffer to return to the gFreeBufferList

Return Value:

    None.

--*/
{

#ifdef MEMORY_DBG
    ExFreePoolWithTag( Buffer, FILESPY_POOL_TAG );
#else
    ExFreeToNPagedLookasideList( &gFreeBufferList, Buffer );
#endif

    //
    // Update the count
    //
    if (Counter) {

        InterlockedDecrement(Counter);
    }
}


////////////////////////////////////////////////////////////////////////
//                                                                    //
//                  Logging routines                                  //
//                                                                    //
////////////////////////////////////////////////////////////////////////

PRECORD_LIST
SpyNewRecord (
    IN ULONG AssignedSequenceNumber
    )
/*++

Routine Description:

    Allocates a new RECORD_LIST structure if there is enough memory to do so. A
    sequence number is updated for each request for a new record.

Arguments:

    AssignedSequenceNumber - 0 if you want this function to generate the
        next sequence number; if not 0, the new record is assigned the
        given sequence number.

Return Value:

    Pointer to the RECORD_LIST allocated, or NULL if no memory is available.

--*/
{
    PRECORD_LIST newRecord = NULL;
    ULONG currentSequenceNumber;
    KIRQL irql;
    ULONG initialRecordType;

    newRecord = (PRECORD_LIST) SpyAllocateBuffer( &gRecordsAllocated,
                                                  gMaxRecordsToAllocate,
                                                  &initialRecordType);

    KeAcquireSpinLock(&gLogSequenceLock, &irql);

    //
    // Assign a new sequence number if 0 was passed in, otherwise use the
    // number passed in
    //

    if (AssignedSequenceNumber == 0) {

        gLogSequenceNumber++;
        currentSequenceNumber = gLogSequenceNumber;

    } else {

        currentSequenceNumber = AssignedSequenceNumber;
    }


    if ((newRecord == NULL) &&
        !InterlockedCompareExchange( &gStaticBufferInUse, TRUE, FALSE)) {

        //
        // Toggle on our gStaticBufferInUse flag and use the static out of memory
        // buffer to record this log entry.  This special log record is used
        // to notify the user application that we are out of memory.  Log
        // request will be dropped until we can get more memory.
        //

        newRecord   = (PRECORD_LIST)gOutOfMemoryBuffer;
        newRecord->LogRecord.RecordType = initialRecordType;
        newRecord->LogRecord.Length = SIZE_OF_LOG_RECORD;
        newRecord->LogRecord.SequenceNumber = currentSequenceNumber;

    } else if (newRecord) {

		//
        // We were able to allocate a new record so initialize it
        // appropriately.
		//

        newRecord->LogRecord.RecordType = initialRecordType;
        newRecord->LogRecord.Length = SIZE_OF_LOG_RECORD;
        newRecord->LogRecord.SequenceNumber = currentSequenceNumber;
    }

    KeReleaseSpinLock(&gLogSequenceLock, irql);

    //
    //  Init record specific fields.
    //

    if (newRecord != NULL) {

        newRecord->NewContext = NULL;
        newRecord->WaitEvent = NULL;
        newRecord->Flags = 0;
    }

    return( newRecord );
}

VOID
SpyFreeRecord (
    IN PRECORD_LIST Record
    )
/*++

Routine Description:

    Frees a RECORD_LIST, which returns the memory to the gFreeBufferList look-aside
    list and updates the gRecordsAllocated count.

Arguments:

    Record - the record to free

Return Value:

    None.

--*/
{
    //
    //  If there is a context record defined, release it now
    //

#if USE_STREAM_CONTEXTS
    if (NULL != Record->NewContext) {

        SpyReleaseContext( Record->NewContext );
    }
#endif

    if (FlagOn( Record->LogRecord.RecordType, RECORD_TYPE_STATIC )) {

		//
        // This is our static record, so reset our gStaticBufferInUse
        // flag.
		//

        InterlockedExchange( &gStaticBufferInUse, FALSE );

    } else {

		//
        // This isn't our static memory buffer, so free the dynamically
        // allocated memory.
		//

        SpyFreeBuffer( Record, &gRecordsAllocated );
    }
}


PRECORD_LIST
SpyLogFastIoStart (
    IN FASTIO_TYPE FastIoType,
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PLARGE_INTEGER FileOffset OPTIONAL,
    IN ULONG Length OPTIONAL,
    IN BOOLEAN Wait	OPTIONAL
    )
/*++

Routine Description:

    Creates the log record if possible and records the necessary Fast I/O
    information at the beginning of the fast I/O operation in RecordList
    according to LoggingFlags.

    The optional arguments are not recorded for all Fast I/O types.  If
    the argument is not needed for a given Fast I/O type, the parameter
    was ignored.

Arguments:

    FastIoType - The type of fast I/O we are logging (REQUIRED)
    DeviceObject - The device object for our filter. (REQUIRED)
    FileObject - Pointer to the file object this operation is on (OPTIONAL)
    FileOffset - Pointer to the file offset for this operation (OPTIONAL)
    Length - Length of the data for this operation (OPTIONAL)
    Wait - Whether or not this operation can wait for a result (OPTIONAL)

Return Value:

    The RECORD_LIST structure created with the appropriate information
    filled in.  If a RECORD_LIST structure couldn't be allocated, NULL
    is returned.

--*/
{
    PRECORD_LIST    pRecordList;
    PRECORD_FASTIO  pRecordFastIo;
    PFILESPY_DEVICE_EXTENSION devExt;

    //
    // Try to get a new record
    //

    pRecordList = SpyNewRecord(0);

    //
    // If we didn't get a RECORD_LIST, exit and return NULL
    //

    if (pRecordList == NULL) {

        return NULL;
    }

    //
    // We got a RECORD_LIST, so now fill in the appropriate information
    //

    pRecordFastIo = &pRecordList->LogRecord.Record.RecordFastIo;

    //
    // Perform the necessary book keeping for the RECORD_LIST
    //

    SetFlag( pRecordList->LogRecord.RecordType, RECORD_TYPE_FASTIO );

    //
    // Set the RECORD_FASTIO fields that are set for all Fast I/O types
    //

    pRecordFastIo->Type = FastIoType;
    KeQuerySystemTime(&pRecordFastIo->StartTime);

    //
    // Get process and thread information
    //

    pRecordFastIo->ProcessId = (ULONG_PTR) PsGetCurrentProcessId();
    pRecordFastIo->ThreadId = (ULONG_PTR) PsGetCurrentThreadId();

    //
    // Record the information that is appropriate based on the
    // Fast I/O type
    //

    pRecordFastIo->FileObject = (FILE_ID)FileObject;
    pRecordFastIo->DeviceObject = (DEVICE_ID)DeviceObject;
    pRecordFastIo->FileOffset.QuadPart = ((FileOffset != NULL) ? FileOffset->QuadPart : 0);
    pRecordFastIo->Length = Length;
    pRecordFastIo->Wait = Wait;

    devExt = DeviceObject->DeviceExtension;

    if (FastIoType == CHECK_IF_POSSIBLE) {

        //
        //  On NTFS, locks are sometimes held but top-level irp is not set, 
        //  therefore it is not safe to query the base file system for the
        //  file name at this time.  If we've got it in the cache, we'll
        //  use it.  Otherwise, we will not return a name.
        //
        
        SpySetName(pRecordList, DeviceObject, FileObject, NLFL_ONLY_CHECK_CACHE, NULL);
        
    } else {

        SpySetName(pRecordList, DeviceObject, FileObject, 0, NULL);
    }

    return pRecordList;
}

VOID
SpyLogFastIoComplete (
    IN PIO_STATUS_BLOCK ReturnStatus,
    IN PRECORD_LIST RecordList
    )
/*++

Routine Description:

    Records the necessary Fast I/O information in RecordList according to
    LoggingFlags.

    The optional arguments are not recorded for all Fast I/O types.  If
    the argument is not needed for a given Fast I/O type, the parameter
    was ignored.

Arguments:
    ReturnStatus - The return value of the operation (OPTIONAL)
    RecordList - The PRECORD_LIST in which the Fast I/O information is stored.

Return Value:

    None.

--*/
{
    PRECORD_FASTIO pRecordFastIo;

    ASSERT(RecordList);

    pRecordFastIo = &RecordList->LogRecord.Record.RecordFastIo;

    //
    // Set the RECORD_FASTIO fields that are set for all Fast I/O types
    //

    KeQuerySystemTime(&pRecordFastIo->CompletionTime);

    if (ReturnStatus != NULL) {

        pRecordFastIo->ReturnStatus = ReturnStatus->Status;

    } else {

        pRecordFastIo->ReturnStatus = 0;
    }

    SpyLog(RecordList);
}

#if WINVER >= 0x0501 /* See comment in DriverEntry */

VOID
SpyLogPreFsFilterOperation (
    IN PFS_FILTER_CALLBACK_DATA Data,
    OUT PRECORD_LIST RecordList
    )
{
    NAME_LOOKUP_FLAGS lookupFlags = 0;
    
    PRECORD_FS_FILTER_OPERATION pRecordFsFilterOp;

    pRecordFsFilterOp = &RecordList->LogRecord.Record.RecordFsFilterOp;
    
    //
    // Record the information we use for an originating Irp.  We first
    // need to initialize some of the RECORD_LIST and RECORD_IRP fields.
    // Then get the interesting information from the Irp.
    //

    SetFlag( RecordList->LogRecord.RecordType, RECORD_TYPE_FS_FILTER_OP );

    pRecordFsFilterOp->FsFilterOperation = Data->Operation;
    pRecordFsFilterOp->FileObject = (FILE_ID) Data->FileObject;
    pRecordFsFilterOp->DeviceObject = (FILE_ID) Data->DeviceObject;
    pRecordFsFilterOp->ProcessId = (FILE_ID)PsGetCurrentProcessId();
    pRecordFsFilterOp->ThreadId = (FILE_ID)PsGetCurrentThreadId();
    
    KeQuerySystemTime(&pRecordFsFilterOp->OriginatingTime);

    //
    //  Do not query for the name on any of the release operations
    //  because a file system resource is currently being held and
    //  we may deadlock.
    //

    switch (Data->Operation) {

        case FS_FILTER_RELEASE_FOR_CC_FLUSH:
        case FS_FILTER_RELEASE_FOR_SECTION_SYNCHRONIZATION:
        case FS_FILTER_RELEASE_FOR_MOD_WRITE:

            SPY_LOG_PRINT( SPYDEBUG_TRACE_DETAILED_CONTEXT_OPS, 
                           ("FileSpy!SpyLogPreFsFilterOp:   RelOper\n") );

            SetFlag( lookupFlags, NLFL_ONLY_CHECK_CACHE );
            break;
    }

    //
    //  Only set the volumeName if the next device is a file system
    //  since we only want to prepend the volumeName if we are on
    //  top of a local file system.
    //

    SpySetName( RecordList, Data->DeviceObject, Data->FileObject, lookupFlags, NULL);
}

VOID
SpyLogPostFsFilterOperation (
    IN NTSTATUS OperationStatus,
    OUT PRECORD_LIST RecordList
    )
{
    PRECORD_FS_FILTER_OPERATION pRecordFsFilterOp;

    pRecordFsFilterOp = &RecordList->LogRecord.Record.RecordFsFilterOp;
    
    //
    // Record the information we see in the post operation.
    //

    pRecordFsFilterOp->ReturnStatus = OperationStatus;
    KeQuerySystemTime(&pRecordFsFilterOp->CompletionTime);
}

#endif

NTSTATUS
SpyAttachDeviceToDeviceStack (
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice,
    IN OUT PDEVICE_OBJECT *AttachedToDeviceObject
    )
/*++

Routine Description:

    This routine attaches the SourceDevice to the TargetDevice's stack and
    returns the device object SourceDevice was directly attached to in 
    AttachedToDeviceObject.  Note that the SourceDevice does not necessarily
    get attached directly to TargetDevice.  The SourceDevice will get attached
    to the top of the stack of which TargetDevice is a member.

    VERSION NOTE:

    In Windows XP, a new API was introduced to close a rare timing window that 
    can cause IOs to start being sent to a device before its 
    AttachedToDeviceObject is set in its device extension.  This is possible
    if a filter is attaching to a device stack while the system is actively
    processing IOs.  The new API closes this timing window by setting the
    device extension field that holds the AttachedToDeviceObject while holding
    the IO Manager's lock that protects the device stack.

    A sufficient work around for earlier versions of the OS is to set the
    AttachedToDeviceObject to the device object that the SourceDevice is most
    likely to attach to.  While it is possible that another filter will attach
    in between the SourceDevice and TargetDevice, this will prevent the
    system from bug checking if the SourceDevice receives IOs before the 
    AttachedToDeviceObject is correctly set.

    For a driver built in the Windows 2000 build environment, we will always 
    use the work-around code to attach.  For a driver that is built in the
    Windows XP or later build environments (therefore you are building a 
    multiversion driver), we will determine which method of attachment to use 
    based on which APIs are available.
    

Arguments:

    SourceDevice - The device object to be attached to the stack.

    TargetDevice - The device that we currently think is the top of the stack
        to which SourceDevice should be attached.

    AttachedToDeviceObject - This is set to the device object to which 
        SourceDevice is attached if the attach is successful.
        
Return Value:

    Return STATUS_SUCCESS if the device is successfully attached.  If 
    TargetDevice represents a stack to which devices can no longer be attached,
    STATUS_NO_SUCH_DEVICE is returned.

--*/
{

    PAGED_CODE();

#if WINVER >= 0x0501
    if (IS_WINDOWSXP_OR_LATER()) {

        ASSERT( NULL != gSpyDynamicFunctions.AttachDeviceToDeviceStackSafe );
        
        return (gSpyDynamicFunctions.AttachDeviceToDeviceStackSafe)( SourceDevice,
                                                                     TargetDevice,
                                                                     AttachedToDeviceObject );

    } else {
#endif

        *AttachedToDeviceObject = TargetDevice;
        *AttachedToDeviceObject = IoAttachDeviceToDeviceStack( SourceDevice,
                                                               TargetDevice );

        if (*AttachedToDeviceObject == NULL) {

            return STATUS_NO_SUCH_DEVICE;
        }

        return STATUS_SUCCESS;

#if WINVER >= 0x0501
    }
#endif

}

NTSTATUS
SpyLog (
    IN PRECORD_LIST NewRecord
    )
/*++

Routine Description:

    This routine appends the completed log record to the gOutputBufferList.

Arguments:

    NewRecord - The record to append to the gOutputBufferList

Return Value:

    The function returns STATUS_SUCCESS.

--*/
{
    KIRQL controlDeviceIrql;
    KIRQL outputBufferIrql;

    KeAcquireSpinLock( &gControlDeviceStateLock, &controlDeviceIrql );

    if (gControlDeviceState == OPENED) {

        //
        // The device is still open so add this record onto the list
        //

        KeAcquireSpinLock(&gOutputBufferLock, &outputBufferIrql);
        InsertTailList(&gOutputBufferList, &NewRecord->List);
        KeReleaseSpinLock(&gOutputBufferLock, outputBufferIrql);

    } else {

        //
        // We can no longer log this record, so free the record
        //

        SpyFreeRecord( NewRecord );

    }

    KeReleaseSpinLock( &gControlDeviceStateLock, controlDeviceIrql );

    return STATUS_SUCCESS;
}

////////////////////////////////////////////////////////////////////////
//                                                                    //
//                    FileName cache routines                         //
//                                                                    //
////////////////////////////////////////////////////////////////////////

BOOLEAN
SpyGetFullPathName (
    IN PFILE_OBJECT FileObject,
    IN OUT PUNICODE_STRING FileName,
    IN PFILESPY_DEVICE_EXTENSION devExt,
    IN NAME_LOOKUP_FLAGS LookupFlags
    )
/*++

Routine Description:

    This routine retrieves the full pathname of the FileObject.  Note that
    the buffers containing pathname components may be stored in paged pool,
    therefore if we are at DISPATCH_LEVEL we cannot look up the name.

    The file is looked up one of the following ways based on the LookupFlags:
    1.  FlagOn( FileObject->Flags, FO_VOLUME_OPEN ) or (FileObject->FileName.Length == 0).
        This is a volume open, so just use DeviceName from the devExt 
        for the FileName, if it exists.
    2.  NAMELOOKUPFL_IN_CREATE and NAMELOOKUPFL_OPEN_BY_ID are set.
        This is an open by file id, so format the file id into the FileName
        string if there is enough room.
    3.  NAMELOOKUPFL_IN_CREATE set and FileObject->RelatedFileObject != NULL.
        This is a relative open, therefore the fullpath file name must
        be built up from the name of the FileObject->RelatedFileObject
        and FileObject->FileName.
    4.  NAMELOOKUPFL_IN_CREATE and FileObject->RelatedFileObject == NULL.
        This is an absolute open, therefore the fullpath file name is
        found in FileObject->FileName.
    5.  No LookupFlags set.
        This is a lookup sometime after CREATE.  FileObject->FileName is 
        no longer guaranteed to be valid, so use ObQueryNameString
        to get the fullpath name of the FileObject.
    
Arguments:

    FileObject - Pointer to the FileObject to the get name of.

    FileName - Unicode string that will be filled in with the filename,  It 
        is assumed that the caller allocates and frees the memory used by 
        the string.  The buffer and MaximumLength for this string should be 
        set.  If there is room in the buffer, the string will be NULL 
        terminated.

    devExt - Contains the device name and next device object
        which are needed to build the full path name.

    LookupFlags - The flags to say whether to get the name from the file
        object or to get the file id.

Return Value:

    Returns TRUE if the returned name should be saved in the cache,
    returns FALSE if the returned name should NOT be saved in the cache.
    In all cases some sort of valid name is always returned.

--*/
{
    NTSTATUS status;
    ULONG i;
    BOOLEAN retValue = TRUE;
    UCHAR buffer[sizeof(FILE_NAME_INFORMATION) + MAX_NAME_SPACE];

    //
    //  Copy over the name the user gave for this device.  These names
    //  should be meaningful to the user.  Note that we do not do this for
    //  NETWORK file system because internally they already show the
    //  connection name.  If this is a direct device open of the network
    //  file system device, we will copy over the device name to be
    //  returned to the user.
    //
    
    if (FILE_DEVICE_NETWORK_FILE_SYSTEM != devExt->ThisDeviceObject->DeviceType) {

        RtlCopyUnicodeString( FileName, &devExt->UserNames );
        
    } else if (FlagOn( FileObject->Flags, FO_DIRECT_DEVICE_OPEN )) {

        ASSERT( devExt->ThisDeviceObject->DeviceType == FILE_DEVICE_NETWORK_FILE_SYSTEM );
        RtlCopyUnicodeString( FileName, &devExt->DeviceName );

        //
        //  We are now done since there will be no more to the name in this
        //  case, so return TRUE.
        //
        
        return TRUE;
    }

    //
    //  See if we can request the name
    //

    if (FlagOn( LookupFlags, NLFL_ONLY_CHECK_CACHE )) {

        RtlAppendUnicodeToString( FileName, L"[-=Not In Cache=-]" );
        return FALSE;
    }

    //
    //  Can not get the name at DPC level
    //

    if (KeGetCurrentIrql() > APC_LEVEL) {

        RtlAppendUnicodeToString( FileName, L"[-=At DPC Level=-]" );
        return FALSE;
    }

    //
    //  If there is a ToplevelIrp then this is a nested operation and
    //  there might be other locks held.  Can not get name without the
    //  potential of deadlocking.
    //

    if (IoGetTopLevelIrp() != NULL) {

        RtlAppendUnicodeToString( FileName, L"[-=Nested Operation=-]" );
        return FALSE;
    }

    //
    //  CASE 1:  This FileObject refers to a Volume open.  Either the
    //           flag is set or no filename is specified.
    //

    if (FlagOn( FileObject->Flags, FO_VOLUME_OPEN ) ||
        (FlagOn( LookupFlags, NLFL_IN_CREATE ) &&
         (FileObject->FileName.Length == 0) && 
         (FileObject->RelatedFileObject == NULL))) {

        //
        //  We've already copied the VolumeName so just return.
        //

    }

    //
    //  CASE 2:  We are opening the file by ID.
    //

    else if (FlagOn( LookupFlags, NLFL_IN_CREATE ) &&
             FlagOn( LookupFlags, NLFL_OPEN_BY_ID )) {

#       define OBJECT_ID_KEY_LENGTH 16
        UNICODE_STRING fileIdName;

        RtlInitEmptyUnicodeString( &fileIdName,
                                   (PWSTR)buffer,
                                   sizeof(buffer) );

        if (FileObject->FileName.Length == sizeof(LONGLONG)) {

			//
            //  Opening by FILE ID, generate a name
			//
			
            swprintf( fileIdName.Buffer, 
                      L"<%016I64x>", 
                      *((PLONGLONG)FileObject->FileName.Buffer) );

        } else if ((FileObject->FileName.Length == OBJECT_ID_KEY_LENGTH) ||
                   (FileObject->FileName.Length == OBJECT_ID_KEY_LENGTH + 
                                                                sizeof(WCHAR)))
        {
            PUCHAR idBuffer;

            //
            //  Opening by Object ID, generate a name
            //

            idBuffer = (PUCHAR)&FileObject->FileName.Buffer[0];

            if (FileObject->FileName.Length != OBJECT_ID_KEY_LENGTH) {

                //
                //  Skip win32 backslash at start of buffer
                //
                idBuffer = (PUCHAR)&FileObject->FileName.Buffer[1];
            }

            swprintf( fileIdName.Buffer,
					  L"<%08x-%04hx-%04hx-%04hx-%04hx%08x>",
                      *(PULONG)&idBuffer[0],
                      *(PUSHORT)&idBuffer[0+4],
                      *(PUSHORT)&idBuffer[0+4+2],
                      *(PUSHORT)&idBuffer[0+4+2+2],
                      *(PUSHORT)&idBuffer[0+4+2+2+2],
                      *(PULONG)&idBuffer[0+4+2+2+2+2]);

        } else {

			//
            //  Unknown ID format
			//

            swprintf( fileIdName.Buffer,
                      L"[-=Unknown ID (Len=%u)=-]",
                      FileObject->FileName.Length);
        }

        fileIdName.Length = wcslen( fileIdName.Buffer ) * sizeof( WCHAR );

        //
        //  Append the fileIdName to FileName.
        //

        RtlAppendUnicodeStringToString( FileName, &fileIdName );

        //
        //  Don't cache the ID name
        //

        retValue = FALSE;
    } 

    //
    //  CASE 3: We are opening a file that has a RelatedFileObject.
    //
    
    else if (FlagOn( LookupFlags, NLFL_IN_CREATE ) &&
             (NULL != FileObject->RelatedFileObject)) {

        //
        //  Must be a relative open.  Use ObQueryNameString to get
        //  the name of the related FileObject.  Then we will append this
        //  fileObject's name.
        //
        //  Note: 
        //  The name in FileObject and FileObject->RelatedFileObject are accessible.  Names further up
        //  the related file object chain (ie FileObject->RelatedFileObject->RelatedFileObject)
        //  may not be accessible.  This is the reason we use ObQueryNameString
        //  to get the name for the RelatedFileObject.
        //

        PFILE_NAME_INFORMATION relativeNameInfo = (PFILE_NAME_INFORMATION)buffer;
        ULONG returnLength;

        status = SpyQueryFileSystemForFileName( FileObject->RelatedFileObject,
                                                devExt->AttachedToDeviceObject,
                                                sizeof( buffer ),
                                                relativeNameInfo,
                                                &returnLength );

        if (NT_SUCCESS( status ) &&
            ((FileName->Length + relativeNameInfo->FileNameLength + FileObject->FileName.Length + sizeof( L'\\' ))
             <= FileName->MaximumLength)) {

            //
            //  We were able to get the relative fileobject's name and we have
            //  enough room in the FileName buffer, so build up the file name
            //  in the following format:
            //      [volumeName]\[relativeFileObjectName]\[FileObjectName]
            //  The VolumeName is already in FileName if we've got one.
            //

            RtlCopyMemory( &FileName->Buffer[FileName->Length/sizeof(WCHAR)],
                           relativeNameInfo->FileName,
                           relativeNameInfo->FileNameLength );

            FileName->Length += (USHORT)relativeNameInfo->FileNameLength;

        } else if ((FileName->Length + FileObject->FileName.Length + sizeof(L"...\\")) <=
                   FileName->MaximumLength ) {

            //
            //  Either the query for the relative fileObject name was unsuccessful,
            //  or we don't have enough room for the relativeFileObject name, but we
            //  do have enough room for "...\[fileObjectName]" in FileName.
            //

            status = RtlAppendUnicodeToString( FileName, L"...\\" );
            ASSERT( status == STATUS_SUCCESS );
        }

        //
        //  If there is not a slash and the end of the related file object
        //  string and there is not a slash at the front of the file object
        //  string, then add one.
        //

        if (((FileName->Length < sizeof(WCHAR) ||
             (FileName->Buffer[(FileName->Length/sizeof(WCHAR))-1] != L'\\'))) &&
            ((FileObject->FileName.Length < sizeof(WCHAR)) ||
             (FileObject->FileName.Buffer[0] != L'\\')))
        {

            RtlAppendUnicodeToString( FileName, L"\\" );
        }

        //
        //  At this time, copy over the FileObject->FileName to the FileName
        //  unicode string.
        //

        RtlAppendUnicodeStringToString( FileName, &FileObject->FileName );
    }
    
    //
    //  CASE 4: We have a open on a file with an absolute path.
    //
    
    else if (FlagOn( LookupFlags, NLFL_IN_CREATE ) &&
             (FileObject->RelatedFileObject == NULL) ) {

        // 
        //  We have an absolute path, so try to copy that into FileName.
        //

        RtlAppendUnicodeStringToString( FileName, &FileObject->FileName );
    }

    //
    //  CASE 5: We are retrieving the file name sometime after the
    //  CREATE operation.
    //

    else if (!FlagOn( LookupFlags, NLFL_IN_CREATE )) {

        PFILE_NAME_INFORMATION nameInfo = (PFILE_NAME_INFORMATION)buffer;
        ULONG returnLength;

        status = SpyQueryFileSystemForFileName( FileObject,
                                                devExt->AttachedToDeviceObject,
                                                sizeof( buffer ),
                                                nameInfo,
                                                &returnLength );

        if (NT_SUCCESS( status )) {

            if ((FileName->Length + nameInfo->FileNameLength) <= FileName->MaximumLength) {

                //
                //  We've got enough room for the file name, so copy it into
                //  FileName.
                //

                RtlCopyMemory( &FileName->Buffer[FileName->Length/sizeof(WCHAR)],
                               nameInfo->FileName,
                               nameInfo->FileNameLength );

                FileName->Length += (USHORT)nameInfo->FileNameLength;
                               
            } else {

                //
                //  We don't have enough room for the file name, so copy our
                //  EXCEED_NAME_BUFFER error message.
                //

                RtlAppendUnicodeToString( FileName, 
                                          L"[-=Name To Large=-]" );
            }
            
        } else {

            //
            //  Got an error trying to get the file name from the base file system,
            //  so put that error message into FileName.
            //

            swprintf((PWCHAR)buffer,L"[-=Error 0x%x Getting Name=-]",status );

            RtlAppendUnicodeToString( FileName, (PWCHAR)buffer );

            //
            //  Don't cache an error-generated name
            //

            retValue = FALSE;
        }
    }

    //
    //  When we get here we have a valid name.
    //  Sometimes when we query a name it has a trailing slash, other times
    //  it doesn't.  To make sure the contexts are correct we are going to
    //  remove a trailing slash if there is not a ":" just before it.
    //

    if ((FileName->Length >= (2*sizeof(WCHAR))) &&
        (FileName->Buffer[(FileName->Length/sizeof(WCHAR))-1] == L'\\') &&
        (FileName->Buffer[(FileName->Length/sizeof(WCHAR))-2] != L':'))
    {

        FileName->Length -= sizeof(WCHAR);
    }

    //
    //  See if we are actually opening the target directory.  If so then
    //  remove the trailing name and slash.  Note that we won't remove
    //  the initial slash (just after the colon).
    //

    if (FlagOn( LookupFlags, NLFL_OPEN_TARGET_DIR ) &&
        (FileName->Length > 0))
    {
        i = (FileName->Length / sizeof(WCHAR)) - 1;

        //
        //  See if the path ends in a backslash, if so skip over it
        //  (since the file system did).
        //

        if ((i > 0) &&
            (FileName->Buffer[i] == L'\\') &&
            (FileName->Buffer[i-1] != L':')) {

            i--;
        }

        //
        //  Scan backwards over the last component
        //

        for ( ;
              i > 0;
              i-- )
        {

            if (FileName->Buffer[i] == L'\\') {

                if ((i > 0) && (FileName->Buffer[i-1] == L':')) {

                    i++;
                }

                FileName->Length = (USHORT)(i * sizeof(WCHAR));
                break;
            }
        }
    }

    return retValue;
}


NTSTATUS
SpyQueryCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT SynchronizingEvent
    )
/*++

Routine Description:

    This routine does the cleanup necessary once the query request completed
    by the file system.
    
Arguments:

    DeviceObject - This will be NULL since we originated this
        Irp.

    Irp - The io request structure containing the information
        about the current state of our file name query.

    SynchronizingEvent - The event to signal to notify the 
        originator of this request that the operation is
        complete.

Return Value:

    Returns STATUS_MORE_PROCESSING_REQUIRED so that IO Manager
    will not try to free the Irp again.

--*/
{

    UNREFERENCED_PARAMETER( DeviceObject );
    
    //
    //  Make sure that the Irp status is copied over to the user's
    //  IO_STATUS_BLOCK so that the originator of this irp will know
    //  the final status of this operation.
    //

    ASSERT( NULL != Irp->UserIosb );
    *Irp->UserIosb = Irp->IoStatus;

    //
    //  Signal SynchronizingEvent so that the originator of this
    //  Irp know that the operation is completed.
    //

    KeSetEvent( SynchronizingEvent, IO_NO_INCREMENT, FALSE );

    //
    //  We are now done, so clean up the irp that we allocated.
    //

    IoFreeIrp( Irp );

    //
    //  If we return STATUS_SUCCESS here, the IO Manager will
    //  perform the cleanup work that it thinks needs to be done
    //  for this IO operation.  This cleanup work includes:
    //  * Copying data from the system buffer to the user's buffer 
    //    if this was a buffered IO operation.
    //  * Freeing any MDLs that are in the Irp.
    //  * Copying the Irp->IoStatus to Irp->UserIosb so that the
    //    originator of this irp can see the final status of the
    //    operation.
    //  * If this was an asynchronous request or this was a 
    //    synchronous request that got pending somewhere along the
    //    way, the IO Manager will signal the Irp->UserEvent, if one 
    //    exists, otherwise it will signal the FileObject->Event.
    //    (This can have REALLY bad implications if the irp originator
    //     did not an Irp->UserEvent and the irp originator is not
    //     waiting on the FileObject->Event.  It would not be that
    //     farfetched to believe that someone else in the system is
    //     waiting on FileObject->Event and who knows who will be
    //     awoken as a result of the IO Manager signaling this event.
    //
    //  Since some of these operations require the originating thread's
    //  context (e.g., the IO Manager need the UserBuffer address to 
    //  be valid when copy is done), the IO Manager queues this work
    //  to an APC on the Irp's originating thread.
    //
    //  Since FileSpy allocated and initialized this irp, we know
    //  what cleanup work needs to be done.  We can do this cleanup
    //  work more efficiently than the IO Manager since we are handling
    //  a very specific case.  Therefore, it is better for us to
    //  perform the cleanup work here then free the irp than passing
    //  control back to the IO Manager to do this work.
    //
    //  By returning STATUS_MORE_PROCESS_REQUIRED, we tell the IO Manager 
    //  to stop processing this irp until it is told to restart processing
    //  with a call to IoCompleteRequest.  Since the IO Manager has
    //  already performed all the work we want it to do on this
    //  irp, we do the cleanup work, return STATUS_MORE_PROCESSING_REQUIRED,
    //  and ask the IO Manager to resume processing by calling 
    //  IoCompleteRequest.
    //

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
SpyQueryFileSystemForFileName (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT NextDeviceObject,
    IN ULONG FileNameInfoLength,
    OUT PFILE_NAME_INFORMATION FileNameInfo,
    OUT PULONG ReturnedLength
    )
/*++

Routine Description:

    This routine rolls an irp to query the name of the
    FileObject parameter from the base file system.

    Note:  ObQueryNameString CANNOT be used here because it
      would cause recursive lookup of the file name for FileObject.
      
Arguments:

    FileObject - the file object for which we want the name.
    NextDeviceObject - the device object for the next driver in the
        stack.  This is where we want to start our request
        for the name of FileObject.
    FileNameInfoLength - the length in bytes of FileNameInfo
        parameter.
    FileNameInfo - the buffer that will be receive the name
        information.  This must be memory that safe to write
        to from kernel space.
    ReturnedLength - the number of bytes written to FileNameInfo.
    
Return Value:

    Returns the status of the operation.
    
--*/
{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;
    NTSTATUS status;

    PAGED_CODE();

    irp = IoAllocateIrp( NextDeviceObject->StackSize, FALSE );
    
    if (irp == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  Set our current thread as the thread for this
    //  irp so that the IO Manager always knows which
    //  thread to return to if it needs to get back into
    //  the context of the thread that originated this
    //  irp.
    //
    
    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    //  Set that this irp originated from the kernel so that
    //  the IO Manager knows that the buffers do not
    //  need to be probed.
    //
    
    irp->RequestorMode = KernelMode;

    //
    //  Initialize the UserIosb and UserEvent in the 
    //

    ioStatus.Status = STATUS_SUCCESS;
    ioStatus.Information = 0;

    irp->UserIosb = &ioStatus;
    irp->UserEvent = NULL;        //already zeroed

    //
    //  Set the IRP_SYNCHRONOUS_API to denote that this
    //  is a synchronous IO request.
    //

    irp->Flags = IRP_SYNCHRONOUS_API;

    irpSp = IoGetNextIrpStackLocation( irp );

    irpSp->MajorFunction = IRP_MJ_QUERY_INFORMATION;
    irpSp->FileObject = FileObject;

    //
    //  Setup the parameters for IRP_MJ_QUERY_INFORMATION.
    //  The buffer we want to be filled in should be placed in
    //  the system buffer.
    //

    irp->AssociatedIrp.SystemBuffer = FileNameInfo;

    irpSp->Parameters.QueryFile.Length = FileNameInfoLength;
    irpSp->Parameters.QueryFile.FileInformationClass = FileNameInformation;

    //
    //  Set up the completion routine so that we know when our
    //  request for the file name is completed.  At that time,
    //  we can free the irp.
    //
    
    KeInitializeEvent( &event, NotificationEvent, FALSE );

    IoSetCompletionRoutine( irp, 
                            SpyQueryCompletion, 
                            &event, 
                            TRUE, 
                            TRUE, 
                            TRUE );

    status = IoCallDriver( NextDeviceObject, irp );

    SPY_LOG_PRINT( SPYDEBUG_TRACE_NAME_REQUESTS,
                   ("FileSpy!SpyQueryFileSystemForFileName: Issued name request -- IoCallDriver status: 0x%08x\n",
                    status) );

    if (STATUS_PENDING == status) {

        (VOID) KeWaitForSingleObject( &event, 
                                      Executive, 
                                      KernelMode,
                                      FALSE,
                                      NULL );
    }

    ASSERT(KeReadStateEvent(&event) || !NT_SUCCESS(ioStatus.Status));

    SPY_LOG_PRINT( SPYDEBUG_TRACE_NAME_REQUESTS,
                   ("FileSpy!SpyQueryFileSystemForFileName: Finished waiting for name request to complete...\n") );

    *ReturnedLength = (ULONG) ioStatus.Information;
    return ioStatus.Status;
}


NTSTATUS
SpyQueryInformationFile (
	IN PDEVICE_OBJECT NextDeviceObject,
	IN PFILE_OBJECT FileObject,
	OUT PVOID FileInformation,
	IN ULONG Length,
	IN FILE_INFORMATION_CLASS FileInformationClass,
	OUT PULONG LengthReturned OPTIONAL
	)

/*++

Routine Description:

    This routine returns the requested information about a specified file.
    The information returned is determined by the FileInformationClass that
    is specified, and it is placed into the caller's FileInformation buffer.

Arguments:

    NextDeviceObject - Supplies the device object where this IO should start
        in the device stack.

    FileObject - Supplies the file object about which the requested
        information should be returned.

    FileInformation - Supplies a buffer to receive the requested information
        returned about the file.  This must be a buffer allocated from kernel
        space.

    Length - Supplies the length, in bytes, of the FileInformation buffer.

    FileInformationClass - Specifies the type of information which should be
        returned about the file.

    LengthReturned - the number of bytes returned if the operation was 
        successful.

Return Value:

    The status returned is the final completion status of the operation.

--*/

{
    PIRP irp = NULL;
    PIO_STACK_LOCATION irpSp = NULL;
    IO_STATUS_BLOCK ioStatusBlock;
    KEVENT event;
    NTSTATUS status;

    PAGED_CODE();
    
    //
    //  In DBG builds, make sure that we have valid parameters before we do 
    //  any work here.
    //

    ASSERT( NULL != NextDeviceObject );
    ASSERT( NULL != FileObject );
    ASSERT( NULL != FileInformation );
    
    //
    //  The parameters look ok, so setup the Irp.
    //

    KeInitializeEvent( &event, NotificationEvent, FALSE );
    ioStatusBlock.Status = STATUS_SUCCESS;
    ioStatusBlock.Information = 0;

    irp = IoAllocateIrp( NextDeviceObject->StackSize, FALSE );
    
    if (irp == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  Set our current thread as the thread for this
    //  irp so that the IO Manager always knows which
    //  thread to return to if it needs to get back into
    //  the context of the thread that originated this
    //  irp.
    //
    
    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    //  Set that this irp originated from the kernel so that
    //  the IO Manager knows that the buffers do not
    //  need to be probed.
    //
    
    irp->RequestorMode = KernelMode;

    //
    //  Initialize the UserIosb and UserEvent in the 
    irp->UserIosb = &ioStatusBlock;
    irp->UserEvent = NULL;

    //
    //  Set the IRP_SYNCHRONOUS_API to denote that this
    //  is a synchronous IO request.
    //

    irp->Flags = IRP_SYNCHRONOUS_API;

    irpSp = IoGetNextIrpStackLocation( irp );

    irpSp->MajorFunction = IRP_MJ_QUERY_INFORMATION;
    irpSp->FileObject = FileObject;

    //
    //  Setup the parameters for IRP_MJ_QUERY_INFORMATION.  These
    //  were supplied by the caller of this routine.
    //  The buffer we want to be filled in should be placed in
    //  the system buffer.
    //

    irp->AssociatedIrp.SystemBuffer = FileInformation;

    irpSp->Parameters.QueryFile.Length = Length;
    irpSp->Parameters.QueryFile.FileInformationClass = FileInformationClass;

    //
    //  Set up the completion routine so that we know when our
    //  request for the file name is completed.  At that time,
    //  we can free the irp.
    //
    
    IoSetCompletionRoutine( irp, 
                            SpyQueryCompletion, 
                            &event, 
                            TRUE, 
                            TRUE, 
                            TRUE );

    status = IoCallDriver( NextDeviceObject, irp );

    if (STATUS_PENDING == status) {

        KeWaitForSingleObject( &event, 
                               Executive, 
                               KernelMode,
                               FALSE,
                               NULL );
     }

    //
    //  Verify the completion has actually been run
    //

    ASSERT(KeReadStateEvent(&event) || !NT_SUCCESS(ioStatusBlock.Status));


    if (ARGUMENT_PRESENT(LengthReturned)) {

        *LengthReturned = (ULONG) ioStatusBlock.Information;
    }

    return ioStatusBlock.Status;
}


////////////////////////////////////////////////////////////////////////
//                                                                    //
//         Common attachment and detachment routines                  //
//                                                                    //
////////////////////////////////////////////////////////////////////////

//
//  VERSION NOTE:
//
//  To be able to safely find out if our filter is attached to a device given
//  its name on Windows 2000 and later, we need to use the approach in 
//  SpyIsAttachedToDeviceByUserDeviceName.  This method uses APIs that are
//  available on Windows 2000 and later.  On Windows XP or later, you could
//  change this routine to separate the translation from DeviceName to device
//  object from the search to see if our filter's device is attached to the
//  device stack.  In Windows XP and later, the logic to translate the 
//  DeviceName to the device object is the same, but you can use the logic
//  in SpyIsAttachedToDeviceWXPAndLater to find your filter's device object
//  in the device stack safely.
//

NTSTATUS 
SpyIsAttachedToDeviceByUserDeviceName (
    IN PUNICODE_STRING DeviceName,
    IN OUT PBOOLEAN IsAttached,
    IN OUT PDEVICE_OBJECT *StackDeviceObject,
    IN OUT PDEVICE_OBJECT *OurAttachedDeviceObject
    )
/*++

Routine Description:

    This routine maps a user's device name to a file system device stack, if
    one exists.  Then this routine walks the device stack to find a device
    object belonging to our driver.

    The APIs used here to walk the device stack are all safe to use while you
    are guaranteed that the device stack will not go away.  We enforce this
    guarantee
Arguments:

    DeviceName - The name provided by the user to identify this device.

    IsAttached - This is set to TRUE if our filter is attached to this device
        stack, otherwise this is set to FALSE.

    StackDeviceObject - Set to a device object in the stack identified by the
        DeviceName.  If this is non-NULL, the caller is responsible for removing
        the reference put on this object before it was returned.

    AttachedDeviceObject - Set to the deviceObject which FileSpy has previously 
        attached to the device stack identify by DeviceName.  If this is
        non-NULL, the caller is responsible for removing the reference put on
        this object before it was returned.

Return Value:

    Returns STATUS_SUCCESS if we were able to successfully translate the
    DeviceName into a device stack and return the StackDeviceObject.  If an
    error occurs during the translation of the DeviceName into a device stack,
    the appropriate error code is returned.

--*/
{
    WCHAR nameBuf[DEVICE_NAMES_SZ];
    UNICODE_STRING volumeNameUnicodeString;
    NTSTATUS status;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK openStatus;
    PFILE_OBJECT volumeFileObject;
    HANDLE fileHandle;
    PDEVICE_OBJECT baseFsDeviceObject;

    PAGED_CODE();

    //
    //  Initialize return state
    //

    ASSERT( NULL != StackDeviceObject );
    ASSERT( NULL != OurAttachedDeviceObject );
    ASSERT( NULL != IsAttached );
    
    *StackDeviceObject = NULL;
    *OurAttachedDeviceObject = NULL;
    *IsAttached = FALSE;

    //
    //  Setup the name to open
    //

    RtlInitEmptyUnicodeString( &volumeNameUnicodeString, nameBuf, sizeof( nameBuf ) );
    RtlAppendUnicodeToString( &volumeNameUnicodeString, L"\\DosDevices\\" );
    RtlAppendUnicodeStringToString( &volumeNameUnicodeString, DeviceName );

    InitializeObjectAttributes( &objectAttributes,
								&volumeNameUnicodeString,
								OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
								NULL,
								NULL);

    //
	// open the file object for the given device
	//

    status = ZwCreateFile( &fileHandle,
						   SYNCHRONIZE|FILE_READ_DATA,
						   &objectAttributes,
						   &openStatus,
						   NULL,
						   0,
						   FILE_SHARE_READ|FILE_SHARE_WRITE,
						   FILE_OPEN,
						   FILE_SYNCHRONOUS_IO_NONALERT,
						   NULL,
						   0);

    if (STATUS_OBJECT_PATH_NOT_FOUND == status ||
        STATUS_OBJECT_NAME_INVALID == status) {

        //
        //  Maybe this name didn't need the "\DosDevices\" prepended to the
        //  name.  Try the open again using just the DeviceName passed in.
        //

         InitializeObjectAttributes( &objectAttributes,
                                     DeviceName,
                                     OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                                     NULL,
                                     NULL);

        //
    	// open the file object for the given device
    	//

        status = ZwCreateFile( &fileHandle,
    						   SYNCHRONIZE|FILE_READ_DATA,
    						   &objectAttributes,
    						   &openStatus,
    						   NULL,
    						   0,
    						   FILE_SHARE_READ|FILE_SHARE_WRITE,
    						   FILE_OPEN,
    						   FILE_SYNCHRONOUS_IO_NONALERT,
    						   NULL,
    						   0);

        if (!NT_SUCCESS( status )) {

            return status;
        }

        //
        //  We were able to open the device using the name passed in, so
        //  now we will fall through and do the rest of this work.
        //

    } else if (!NT_SUCCESS( status )) {

        return status;
    }

	//
    // get a pointer to the volumes file object
	//

    status = ObReferenceObjectByHandle( fileHandle,
										FILE_READ_DATA,
										*IoFileObjectType,
										KernelMode,
										&volumeFileObject,
										NULL);

    if(!NT_SUCCESS( status )) {

        ZwClose( fileHandle );
        return status;
    }

	//
    // Get the device object we want to attach to (parent device object in chain)
	//

    baseFsDeviceObject = IoGetBaseFileSystemDeviceObject( volumeFileObject );
    
    if (baseFsDeviceObject == NULL) {

        ObDereferenceObject( volumeFileObject );
        ZwClose( fileHandle );

        return STATUS_INVALID_DEVICE_STATE;
    }

    //
    //  Now see if we are attached to this device stack.  Note that we need to 
    //  keep this file object open while we do this search to ensure that the 
    //  stack won't get torn down while SpyIsAttachedToDevice does its work.
    //

    *IsAttached = SpyIsAttachedToDevice( baseFsDeviceObject,
                                         OurAttachedDeviceObject );
    
    //
    //  Return the base file system's device object to represent this device
    //  stack even if we didn't find our device object in the stack.
    //

    ObReferenceObject( baseFsDeviceObject );
    *StackDeviceObject = baseFsDeviceObject;

    //
    //  Close our handle
    //

    ObDereferenceObject( volumeFileObject );
    ZwClose( fileHandle );

    return STATUS_SUCCESS;
}

//
//  VERSION NOTE:
//  
//  In Windows 2000, the APIs to safely walk an arbitrary file system device 
//  stack were not supported.  If we can guarantee that a device stack won't 
//  be torn down during the walking of the device stack, we can walk from
//  the base file system's device object up to the top of the device stack
//  to see if we are attached.  We know the device stack will not go away if
//  we are in the process of processing a mount request OR we have a file object
//  open on this device.
//  
//  In Windows XP and later, the IO Manager provides APIs that will allow us to
//  walk through the chain safely using reference counts to protect the device 
//  object from going away while we are inspecting it.  This can be done at any
//  time.
//
//  MULTIVERSION NOTE:
//
//  If built for Windows XP or later, this driver is built to run on 
//  multiple versions.  When this is the case, we will test for the presence of
//  the new IO Manager routines that allow for a filter to safely walk the file
//  system device stack and use those APIs if they are present to determine if
//  we have already attached to this volume.  If these new IO Manager routines
//  are not present, we will assume that we are at the bottom of the file
//  system stack and walk up the stack looking for our device object.
//

BOOLEAN
SpyIsAttachedToDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PDEVICE_OBJECT *AttachedDeviceObject OPTIONAL
    )
{
    PAGED_CODE();
    
#if WINVER >= 0x0501
    if (IS_WINDOWSXP_OR_LATER()) {

        ASSERT( NULL != gSpyDynamicFunctions.GetLowerDeviceObject &&
                NULL != gSpyDynamicFunctions.GetDeviceAttachmentBaseRef );
        
        return SpyIsAttachedToDeviceWXPAndLater( DeviceObject, AttachedDeviceObject );
    } else {
#endif

        return SpyIsAttachedToDeviceW2K( DeviceObject, AttachedDeviceObject );

#if WINVER >= 0x0501
    }
#endif    
}

BOOLEAN
SpyIsAttachedToDeviceW2K (
    PDEVICE_OBJECT DeviceObject,
    PDEVICE_OBJECT *AttachedDeviceObject OPTIONAL
    )
/*++

Routine Description:

    VERSION: Windows 2000

    This routine walks up the device stack from the DeviceObject passed in
    looking for a device object that belongs to our filter.

    Note:  For this routine to operate safely, the caller must ensure two
        things:
        * the DeviceObject is the base file system's device object and therefore
        is at the bottom of the file system stack
        * this device stack won't be going away while we walk up this stack.  If
        we currently have a file object open for this device stack or we are
        in the process of mounting this device, this guarantee is satisfied.

Arguments:

    DeviceObject - The device chain we want to look through

    AttachedDeviceObject - Set to the deviceObject which FileSpy
            has previously attached to DeviceObject.  If this is non-NULL,
            the caller must clear the reference put on this device object.

Return Value:

    TRUE if we are attached, FALSE if not

--*/
{
    PDEVICE_OBJECT currentDeviceObject;

    PAGED_CODE();

    currentDeviceObject = DeviceObject;

    for (currentDeviceObject = DeviceObject;
         currentDeviceObject != NULL;
         currentDeviceObject = currentDeviceObject->AttachedDevice) {

        if (IS_FILESPY_DEVICE_OBJECT( currentDeviceObject )) {

            //
            //  We are attached.  If requested, return the found device object.
            //

            if (ARGUMENT_PRESENT( AttachedDeviceObject )) {

                ObReferenceObject( currentDeviceObject );
                *AttachedDeviceObject = currentDeviceObject;
            }

            return TRUE;
        }
    }

    //
    //  We did not find ourselves on the attachment chain.  Return a NULL
    //  device object pointer (if requested) and return we did not find
    //  ourselves.
    //
    
    if (ARGUMENT_PRESENT(AttachedDeviceObject)) {

        *AttachedDeviceObject = NULL;
    }

    return FALSE;
}

#if WINVER >= 0x0501

BOOLEAN
SpyIsAttachedToDeviceWXPAndLater (
    PDEVICE_OBJECT DeviceObject,
    PDEVICE_OBJECT *AttachedDeviceObject OPTIONAL
    )
/*++

Routine Description:

    VERSION: Windows XP and later

    This walks down the attachment chain looking for a device object that
    belongs to this driver.  If one is found, the attached device object
    is returned in AttachedDeviceObject.

Arguments:

    DeviceObject - The device chain we want to look through

    AttachedDeviceObject - Set to the deviceObject which FileSpy
            has previously attached to DeviceObject.

Return Value:

    TRUE if we are attached, FALSE if not

--*/
{
    PDEVICE_OBJECT currentDevObj;
    PDEVICE_OBJECT nextDevObj;

    PAGED_CODE();
    
    //
    //  Get the device object at the TOP of the attachment chain
    //

    ASSERT( NULL != gSpyDynamicFunctions.GetAttachedDeviceReference );
    currentDevObj = (gSpyDynamicFunctions.GetAttachedDeviceReference)( DeviceObject );

    //
    //  Scan down the list to find our device object.
    //

    do {
    
        if (IS_FILESPY_DEVICE_OBJECT( currentDevObj )) {

            //
            //  We have found that we are already attached.  If we are
            //  returning the device object, leave it referenced else remove
            //  the reference.
            //

            if (NULL != AttachedDeviceObject) {

                *AttachedDeviceObject = currentDevObj;

            } else {

                ObDereferenceObject( currentDevObj );
            }

            return TRUE;
        }

        //
        //  Get the next attached object.  This puts a reference on 
        //  the device object.
        //

        ASSERT( NULL != gSpyDynamicFunctions.GetLowerDeviceObject );
        nextDevObj = (gSpyDynamicFunctions.GetLowerDeviceObject)( currentDevObj );

        //
        //  Dereference our current device object, before
        //  moving to the next one.
        //

        ObDereferenceObject( currentDevObj );

        currentDevObj = nextDevObj;
        
    } while (NULL != currentDevObj);
    
    //
    //  Mark no device returned
    //

    if (ARGUMENT_PRESENT(AttachedDeviceObject)) {

        *AttachedDeviceObject = NULL;
    }

    return FALSE;
}

#endif //WINVER >= 0x0501

NTSTATUS
SpyAttachToMountedDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_OBJECT FilespyDeviceObject
    )
/*++

Routine Description:

    This routine will attach the FileSpyDeviceObject to the filter stack
    that DeviceObject is in.

    NOTE:  If there is an error in attaching, the caller is responsible
        for deleting the FilespyDeviceObject.
    
Arguments:

    DeviceObject - The device object in the stack to which we want to attach.

    FilespyDeviceObject - The filespy device object that is to be attached to
            "DeviceObject".
        
Return Value:

    Returns STATUS_SUCCESS if the filespy deviceObject could be attached,
    otherwise an appropriate error code is returned.
    
--*/
{
    PFILESPY_DEVICE_EXTENSION devExt = FilespyDeviceObject->DeviceExtension;
    NTSTATUS status = STATUS_SUCCESS;
    ULONG i;

    PAGED_CODE();
    ASSERT( IS_FILESPY_DEVICE_OBJECT( FilespyDeviceObject ) );
#if WINVER >= 0x0501    
    ASSERT( !SpyIsAttachedToDevice( DeviceObject, NULL ) );
#endif
    
    //
    //  Insert pointer from extension back to owning device object
    //

    devExt->ThisDeviceObject = FilespyDeviceObject;

    //
    //  Propagate flags from Device Object we are trying to attach to.
    //  Note that we do this before the actual attachment to make sure
    //  the flags are properly set once we are attached (since an IRP
    //  can come in immediately after attachment but before the flags would
    //  be set).
    //

    if (FlagOn( DeviceObject->Flags, DO_BUFFERED_IO )) {

        SetFlag( FilespyDeviceObject->Flags, DO_BUFFERED_IO );
    }

    if (FlagOn( DeviceObject->Flags, DO_DIRECT_IO )) {

        SetFlag( FilespyDeviceObject->Flags, DO_DIRECT_IO );
    }

    //
    //  It is possible for this attachment request to fail because this device
    //  object has not finished initializing.  This can occur if this filter
    //  loaded just as this volume was being mounted.
    //

    for (i=0; i < 8; i++) {
        LARGE_INTEGER interval;

        //
        //  Attach our device object to the given device object
        //  The only reason this can fail is if someone is trying to dismount
        //  this volume while we are attaching to it.
        //

        status = SpyAttachDeviceToDeviceStack( FilespyDeviceObject,
                                               DeviceObject,
                                               &devExt->AttachedToDeviceObject );

        if (NT_SUCCESS(status) ) {

            //
            //  Do all common initializing of the device extension
            //

            SetFlag(devExt->Flags,IsVolumeDeviceObject);

            RtlInitEmptyUnicodeString( &devExt->UserNames,
                                       devExt->UserNamesBuffer,
                                       sizeof(devExt->UserNamesBuffer) );

            SpyInitDeviceNamingEnvironment( FilespyDeviceObject );

            SPY_LOG_PRINT( SPYDEBUG_DISPLAY_ATTACHMENT_NAMES,
                           ("FileSpy!SpyAttachToMountedDevice:            Attaching to volume        %p \"%wZ\"\n",
                            devExt->AttachedToDeviceObject,
                            &devExt->DeviceName) );

            //
            //  Add this device to our attachment list
            //

            ExAcquireFastMutex( &gSpyDeviceExtensionListLock );
            InsertTailList( &gSpyDeviceExtensionList, &devExt->NextFileSpyDeviceLink );
            ExReleaseFastMutex( &gSpyDeviceExtensionListLock );
            SetFlag(devExt->Flags,ExtensionIsLinked);

            return STATUS_SUCCESS;
        }

        //
        //  Delay, giving the device object a chance to finish its
        //  initialization so we can try again
        //

        interval.QuadPart = (500 * DELAY_ONE_MILLISECOND);      //delay 1/2 second
        KeDelayExecutionThread( KernelMode, FALSE, &interval );
    }

    return status;
}


VOID
SpyCleanupMountedDevice (
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This cleans up any allocated memory in the device extension.

Arguments:

    DeviceObject - The device we are cleaning up

Return Value:

--*/
{        
    PFILESPY_DEVICE_EXTENSION devExt = DeviceObject->DeviceExtension;

    PAGED_CODE();
    
    ASSERT(IS_FILESPY_DEVICE_OBJECT( DeviceObject ));

    SpyCleanupDeviceNamingEnvironment( DeviceObject );

    //
    //  Unlink from global list
    //

    if (FlagOn(devExt->Flags,ExtensionIsLinked)) {

        ExAcquireFastMutex( &gSpyDeviceExtensionListLock );
        RemoveEntryList( &devExt->NextFileSpyDeviceLink );
        ExReleaseFastMutex( &gSpyDeviceExtensionListLock );
        ClearFlag(devExt->Flags,ExtensionIsLinked);
    }
}

////////////////////////////////////////////////////////////////////////
//                                                                    //
//                    Start/stop logging routines                     //
//                                                                    //
////////////////////////////////////////////////////////////////////////

//
//  VERSION NOTE:
//
//  On Windows 2000, we will try to attach a new FileSpy device object to the 
//  device stack represented by the DeviceObject parameter.  We cannot get the
//  real disk device at this time, so this field will be set to NULL in the 
//  device extension.  We also cannot get the device name as it is named
//  in the storage stack for this volume (e.g., \Device\HarddiskVolume1), so we 
//  will just use the user's name for the device for our device name.  On
//  Windows 2000, this information is only available as the device mounts.
//
//  On Windows XP and later, we will try to attach a new FileSpy device object
//  to the device stack represented by the DeviceObject parameter.  We are able
//  to get the disk device object for this stack, so that will be appropriately
//  set in the device extension.  We will also be able to get the device name
//  as it is named by the storage stack.
//
//  MULTIVERSION NOTE:
//
//  In SpyAttachToDeviceOnDemand, you see the code to determine which method of
//  determining if we are already attached based on the dynamically loaded
//  functions present.  If this driver is build for Windows 2000 specifically,
//  this logic will not be used.
//

NTSTATUS
SpyAttachToDeviceOnDemand (
    IN PDEVICE_OBJECT DeviceObject,
    IN PUNICODE_STRING UserDeviceName,
    IN OUT PDEVICE_OBJECT *FileSpyDeviceObject
    )
/*++

Routine Description:

    This routine does what is necessary to attach to a device sometime after
    the device has been mounted.

Arguments:

    DeviceObject - The device object that represents the file system stack
        for the volume named by UserDeviceName.

    UserDeviceName - Name of device for which logging should be started

    FileSpyDeviceObject - Set to the new filespy device object that was
        attached if we could successfully attach.
    
Return Value:

    STATUS_SUCCESS if we were able to attach, or an appropriate error code 
    otherwise.
    
--*/
{
    PAGED_CODE();
    
    //
    //  If this device is a DFS device, we do not want to attach to it, so
    //  do this quick check here and return an error if this is the case.
    //
    //  DFS will just redirect the operation to the appropriate redirector.  If
    //  you are interested in monitoring these IOs, you should attach to the 
    //  redirectors.  You cannot attach to these on demand by naming the DFS
    //  device, therefore we fail these requests.
    //

    if (DeviceObject->DeviceType == FILE_DEVICE_DFS) {

        return STATUS_NOT_SUPPORTED;
    }
    
#if WINVER >= 0x0501
    if (IS_WINDOWSXP_OR_LATER()) {

        ASSERT( NULL != gSpyDynamicFunctions.GetDeviceAttachmentBaseRef &&
                NULL != gSpyDynamicFunctions.GetDiskDeviceObject );
        
        return SpyAttachToDeviceOnDemandWXPAndLater( DeviceObject,
                                                     UserDeviceName,
                                                     FileSpyDeviceObject );
    } else {
#endif

        return SpyAttachToDeviceOnDemandW2K( DeviceObject,
                                             UserDeviceName,
                                             FileSpyDeviceObject );
#if WINVER >= 0x0501
    }
#endif    
}

NTSTATUS
SpyAttachToDeviceOnDemandW2K (
    IN PDEVICE_OBJECT DeviceObject,
    IN PUNICODE_STRING UserDeviceName,
    IN OUT PDEVICE_OBJECT *FileSpyDeviceObject
    )
/*++

Routine Description:

    VERSION: Windows 2000
    
    This routine does what is necessary to attach to a device sometime after
    the device has been mounted.

    Note that on Windows 2000, we cannot get the disk device object, therefore
    we will just use the User's device name as our name here.

Arguments:

    DeviceObject - The device object that represents the file system stack
        for the volume named by UserDeviceName.

    UserDeviceName - Name of device for which logging should be started

    FileSpyDeviceObject - Set to the new filespy device object that was
        attached if we could successfully attach.
    
Return Value:

    STATUS_SUCCESS if we were able to attach, or an appropriate error code 
    otherwise.
    
--*/
{
    NTSTATUS status;
    PFILESPY_DEVICE_EXTENSION devExt;

    PAGED_CODE();

    ASSERT( FileSpyDeviceObject != NULL );

    //
    //  Create a new device object so we can attach it in the filter stack
    //
    
    status = IoCreateDevice( gFileSpyDriverObject,
							 sizeof( FILESPY_DEVICE_EXTENSION ),
							 NULL,
							 DeviceObject->DeviceType,
							 0,
							 FALSE,
							 FileSpyDeviceObject );

    if (!NT_SUCCESS( status )) {

        return status;
    }

    //
    //  Set disk device object
    //

    devExt = (*FileSpyDeviceObject)->DeviceExtension;
    devExt->Flags = 0;

    //
    //  We cannot get the disk device object when we attach on demand in W2K.
    //
    
    devExt->DiskDeviceObject = NULL;

    //
    //  Set Device Name, we will just use the user's device name on W2K.
    //

    RtlInitEmptyUnicodeString( &devExt->DeviceName,
                               devExt->DeviceNameBuffer,
                               sizeof(devExt->DeviceNameBuffer) );

    RtlAppendUnicodeStringToString( &devExt->DeviceName,
                                    UserDeviceName );
  
    //
    //  Call the routine to attach to a mounted device.
    //

    status = SpyAttachToMountedDevice( DeviceObject,
                                       *FileSpyDeviceObject );

    if (!NT_SUCCESS( status )) {

        SPY_LOG_PRINT( SPYDEBUG_ERROR,
                       ("FileSpy!SpyStartLoggingDevice: Could not attach to \"%wZ\"; logging not started.\n",
                        UserDeviceName) );

        SpyCleanupMountedDevice( *FileSpyDeviceObject );
        IoDeleteDevice( *FileSpyDeviceObject );
        *FileSpyDeviceObject = NULL;
    }

    return status;
}

#if WINVER >= 0x0501

NTSTATUS
SpyAttachToDeviceOnDemandWXPAndLater (
    IN PDEVICE_OBJECT DeviceObject,
    IN PUNICODE_STRING UserDeviceName,
    IN OUT PDEVICE_OBJECT *FileSpyDeviceObject
    )
/*++

Routine Description:

    This routine does what is necessary to attach to a device sometime after
    the device has been mounted.

Arguments:

    DeviceObject - The device object that represents the file system stack
        for the volume named by UserDeviceName.

    UserDeviceName - Name of device for which logging should be started

    FileSpyDeviceObject - Set to the new filespy device object that was
        attached if we could successfully attach.
    
Return Value:

    STATUS_SUCCESS if we were able to attach, or an appropriate error code 
    otherwise.
    
--*/
{

    NTSTATUS status;
    PFILESPY_DEVICE_EXTENSION devExt;
    PDEVICE_OBJECT baseFileSystemDeviceObject = NULL;
    PDEVICE_OBJECT diskDeviceObject = NULL;

    PAGED_CODE();

    UNREFERENCED_PARAMETER( UserDeviceName );
    ASSERT( FileSpyDeviceObject != NULL );

    //
    //  If this is a network file system, there will not be a disk device
    //  associated with this device, so there is no need to make this request
    //  of the IO Manager.  We will get the name of the network file system
    //  later from the baseFileSystemDeviceObject vs. the diskDeviceObject 
    //  which is used to retrieve the device name for local volumes.
    //

    baseFileSystemDeviceObject = (gSpyDynamicFunctions.GetDeviceAttachmentBaseRef)( DeviceObject );

    if (FILE_DEVICE_NETWORK_FILE_SYSTEM != baseFileSystemDeviceObject->DeviceType) {

        //
        //  If this is not a network file system, query the IO Manager to get
        //  the diskDeviceObject.  We will only attach if this device has a
        //  disk device object.
        //
        //  It may not have a disk device object for the following reasons:
        //  - It is a control device object for a driver
        //  - There is no media in the device.
        //

        status = (gSpyDynamicFunctions.GetDiskDeviceObject)( baseFileSystemDeviceObject, 
                                                            &diskDeviceObject );

        if (!NT_SUCCESS( status )) {

            SPY_LOG_PRINT( SPYDEBUG_ERROR,
                           ("FileSpy!SpyStartLoggingDevice: No disk device object exists for \"%wZ\"; cannot log this volume.\n",
                            UserDeviceName) );

            goto SpyAttachToDeviceOnDemand_Exit;
        }
    }
    
    //
    //  Create a new device object so we can attach it in the filter stack
    //
    
    status = IoCreateDevice( gFileSpyDriverObject,
							 sizeof( FILESPY_DEVICE_EXTENSION ),
							 NULL,
							 DeviceObject->DeviceType,
							 0,
							 FALSE,
							 FileSpyDeviceObject );

    if (!NT_SUCCESS( status )) {

        goto SpyAttachToDeviceOnDemand_Exit;
    }

    //
    //  Set disk device object
    //

    devExt = (*FileSpyDeviceObject)->DeviceExtension;
    devExt->Flags = 0;

    devExt->DiskDeviceObject = diskDeviceObject;

    //
    //  Set Device Name
    //

    RtlInitEmptyUnicodeString( &devExt->DeviceName,
                               devExt->DeviceNameBuffer,
                               sizeof(devExt->DeviceNameBuffer) );

    if (NULL != diskDeviceObject) {
        
        SpyGetObjectName( diskDeviceObject, 
                          &devExt->DeviceName );

    } else {

        ASSERT( NULL != baseFileSystemDeviceObject &&
                FILE_DEVICE_NETWORK_FILE_SYSTEM == baseFileSystemDeviceObject->DeviceType);

        SpyGetObjectName( baseFileSystemDeviceObject,
                          &devExt->DeviceName );
    }

    //
    //  Call the routine to attach to a mounted device.
    //

    status = SpyAttachToMountedDevice( DeviceObject,
                                       *FileSpyDeviceObject );


    if (!NT_SUCCESS( status )) {

        SPY_LOG_PRINT( SPYDEBUG_ERROR,
                       ("FileSpy!SpyStartLoggingDevice: Could not attach to \"%wZ\"; logging not started.\n",
                        UserDeviceName) );

        SpyCleanupMountedDevice( *FileSpyDeviceObject );
        IoDeleteDevice( *FileSpyDeviceObject );
        *FileSpyDeviceObject = NULL;
        goto SpyAttachToDeviceOnDemand_Exit;
    }

SpyAttachToDeviceOnDemand_Exit:

    if (NULL != baseFileSystemDeviceObject) {

        ObDereferenceObject( baseFileSystemDeviceObject );
    }

    if (NULL != diskDeviceObject) {

        ObDereferenceObject( diskDeviceObject );
    }
    
    return status;
}

#endif    

NTSTATUS
SpyStartLoggingDevice (
    IN PWSTR UserDeviceName
    )
/*++

Routine Description:

    This routine ensures that we are attached to the specified device
    then turns on logging for that device.
    
    Note:  Since all network drives through LAN Manager are represented by _
        one_ device object, we want to only attach to this device stack once
        and use only one device extension to represent all these drives.
        Since FileSpy does not do anything to filter I/O on the LAN Manager's
        device object to only log the I/O to the requested drive, the user
        will see all I/O to a network drive it he/she is attached to a
        network drive.

Arguments:

    UserDeviceName - Name of device for which logging should be started
    
Return Value:

    STATUS_SUCCESS if the logging has been successfully started, or
    an appropriate error code if the logging could not be started.
    
--*/
{
    UNICODE_STRING userDeviceName;
    NTSTATUS status;
    PFILESPY_DEVICE_EXTENSION devExt;
    BOOLEAN isAttached = FALSE;
    PDEVICE_OBJECT stackDeviceObject;
    PDEVICE_OBJECT filespyDeviceObject;

    PAGED_CODE();
    
    //
    //  Check to see if we have previously attached to this device by
    //  opening this device name then looking through its list of attached
    //  devices.
    //

    RtlInitUnicodeString( &userDeviceName, UserDeviceName );

    status = SpyIsAttachedToDeviceByUserDeviceName( &userDeviceName,
                                                    &isAttached,
                                                    &stackDeviceObject,
                                                    &filespyDeviceObject );

    if (!NT_SUCCESS( status )) {

        //
        //  There was an error, so return the error code.
        //
        
        return status;
    }
        
    if (isAttached) {

        //
        //  We are already attached, so just make sure that logging is turned on
        //  for this device.
        //

        ASSERT( NULL != filespyDeviceObject );

        devExt = filespyDeviceObject->DeviceExtension;
        SetFlag(devExt->Flags,LogThisDevice);

        SpyStoreUserName( devExt, &userDeviceName );

        //
        //  Clear the reference that was returned from SpyIsAttachedToDevice.
        //
        
        ObDereferenceObject( filespyDeviceObject );
        
    } else {

        status = SpyAttachToDeviceOnDemand( stackDeviceObject,
                                            &userDeviceName,
                                            &filespyDeviceObject );

        if (!NT_SUCCESS( status )) {

            ObDereferenceObject( stackDeviceObject );
            return status;
        }

        ASSERT( filespyDeviceObject != NULL );
        
        devExt = filespyDeviceObject->DeviceExtension;

        //
        //  We successfully attached so finish our device extension 
        //  initialization.  Along this code path, we want to turn on
        //  logging and store our device name.
        // 

        SetFlag(devExt->Flags,LogThisDevice);

        //
        //  We want to store the name that was used by the user-mode
        //  application to name this device.
        //

        SpyStoreUserName( devExt, &userDeviceName );

        //
        //
        //  Finished all initialization of the new device object,  so clear the
        //  initializing flag now.  This allows other filters to now attach
        //  to our device object.
        //
        //

        ClearFlag( filespyDeviceObject->Flags, DO_DEVICE_INITIALIZING );

    }

    ObDereferenceObject( stackDeviceObject );
    return STATUS_SUCCESS;
}

NTSTATUS
SpyStopLoggingDevice (
    IN PWSTR DeviceName
    )
/*++

Routine Description:

    This routine stop logging the specified device.  Since you can not
    physically detach from devices, this routine simply sets a flag saying
    to not log the device anymore.

    Note:  Since all network drives are represented by _one_ device object,
        and, therefore, one device extension, if the user detaches from one
        network drive, it has the affect of detaching from _all_ network
        devices.

Arguments:

    DeviceName - The name of the device to stop logging.

Return Value:
    NT Status code

--*/
{
    WCHAR nameBuf[DEVICE_NAMES_SZ];
    UNICODE_STRING volumeNameUnicodeString;
    PDEVICE_OBJECT deviceObject;
    PDEVICE_OBJECT filespyDeviceObject;
    BOOLEAN isAttached = FALSE;
    PFILESPY_DEVICE_EXTENSION devExt;
    NTSTATUS status;

    PAGED_CODE();
    
    RtlInitEmptyUnicodeString( &volumeNameUnicodeString, nameBuf, sizeof( nameBuf ) );
    RtlAppendUnicodeToString( &volumeNameUnicodeString, DeviceName );

    status = SpyIsAttachedToDeviceByUserDeviceName( &volumeNameUnicodeString, 
                                                    &isAttached,
                                                    &deviceObject,
                                                    &filespyDeviceObject );

    if (!NT_SUCCESS( status )) {

        //
        //  We could not get the deviceObject from this DeviceName, so
        //  return the error code.
        //
        
        return status;
    }

    //
    //  Find Filespy's device object from the device stack to which
    //  deviceObject is attached.
    //

    if (isAttached) {

        //
        //  FileSpy is attached and FileSpy's deviceObject was returned.
        //

        ASSERT( NULL != filespyDeviceObject );

        devExt = filespyDeviceObject->DeviceExtension;

        //
        //  Stop logging
        //

        ClearFlag(devExt->Flags,LogThisDevice);

        status = STATUS_SUCCESS;

        ObDereferenceObject( filespyDeviceObject );

    } else {

        status = STATUS_INVALID_PARAMETER;
    }    

    ObDereferenceObject( deviceObject );

    return status;
}

////////////////////////////////////////////////////////////////////////
//                                                                    //
//       Attaching/detaching to all volumes in system routines        //
//                                                                    //
////////////////////////////////////////////////////////////////////////

NTSTATUS
SpyAttachToFileSystemDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN PUNICODE_STRING DeviceName
    )
/*++

Routine Description:

    This will attach to the given file system device object.  We attach to
    these devices so we will know when new devices are mounted.

Arguments:

    DeviceObject - The device to attach to

    DeviceName - Contains the name of this device.

Return Value:

    Status of the operation

--*/
{
    PDEVICE_OBJECT filespyDeviceObject;
    PFILESPY_DEVICE_EXTENSION devExt;
    UNICODE_STRING fsrecName;
    NTSTATUS status;
    UNICODE_STRING tempName;
    WCHAR tempNameBuffer[DEVICE_NAMES_SZ];

    PAGED_CODE();

    //
    //  See if this is a file system we care about.  If not, return.
    //

    if (!IS_SUPPORTED_DEVICE_TYPE(DeviceObject->DeviceType)) {

        return STATUS_SUCCESS;
    }

    //
    //  See if this is Microsoft's file system recognizer device (see if the name of the
    //  driver is the FS_REC driver).  If so skip it.  We don't need to 
    //  attach to file system recognizer devices since we can just wait for the
    //  real file system driver to load.  Therefore, if we can identify them, we won't
    //  attach to them.
    //

    RtlInitUnicodeString( &fsrecName, L"\\FileSystem\\Fs_Rec" );

    RtlInitEmptyUnicodeString( &tempName,
                               tempNameBuffer,
                               sizeof(tempNameBuffer) );

    SpyGetObjectName( DeviceObject->DriverObject, &tempName );
    
    if (RtlCompareUnicodeString( &tempName, &fsrecName, TRUE ) == 0) {

        return STATUS_SUCCESS;
    }

    //
    //  Create a new device object we can attach with
    //

    status = IoCreateDevice( gFileSpyDriverObject,
                             sizeof( FILESPY_DEVICE_EXTENSION ),
                             (PUNICODE_STRING) NULL,
                             DeviceObject->DeviceType,
                             0,
                             FALSE,
                             &filespyDeviceObject );

    if (!NT_SUCCESS( status )) {

        SPY_LOG_PRINT( SPYDEBUG_ERROR,
                       ("FileSpy!SpyAttachToFileSystemDevice: Error creating volume device object for \"%wZ\", status=%08x\n",
                        DeviceName,
                        status) );
        return status;
    }

    //
    //  Load extension, set device object associated with extension
    //

    devExt = filespyDeviceObject->DeviceExtension;
    devExt->Flags = 0;

    devExt->ThisDeviceObject = filespyDeviceObject;

    //
    //  Propagate flags from Device Object we are trying to attach to.
    //  Note that we do this before the actual attachment to make sure
    //  the flags are properly set once we are attached (since an IRP
    //  can come in immediately after attachment but before the flags would
    //  be set).
    //

    if ( FlagOn( DeviceObject->Flags, DO_BUFFERED_IO )) {

        SetFlag( filespyDeviceObject->Flags, DO_BUFFERED_IO );
    }

    if ( FlagOn( DeviceObject->Flags, DO_DIRECT_IO )) {

        SetFlag( filespyDeviceObject->Flags, DO_DIRECT_IO );
    }

    if ( FlagOn( DeviceObject->Characteristics, FILE_DEVICE_SECURE_OPEN ) ) {

        SetFlag( filespyDeviceObject->Characteristics, FILE_DEVICE_SECURE_OPEN );
    }

    //
    //  Do the attachment
    //

    status = SpyAttachDeviceToDeviceStack( filespyDeviceObject, 
                                           DeviceObject, 
                                           &devExt->AttachedToDeviceObject );

    if (!NT_SUCCESS( status )) {

        SPY_LOG_PRINT( SPYDEBUG_ERROR,
                       ("FileSpy!SpyAttachToFileSystemDevice: Could not attach FileSpy to the filesystem control device object \"%wZ\".\n",
                        DeviceName) );

        goto ErrorCleanupDevice;
    }

    //
    //  Since this is an attachment to a file system control device object
    //  we are not going to log anything, but properly initialize our
    //  extension.
    //

    RtlInitEmptyUnicodeString( &devExt->DeviceName,
                               devExt->DeviceNameBuffer,
                               sizeof(devExt->DeviceNameBuffer) );

    RtlCopyUnicodeString( &devExt->DeviceName, DeviceName );        //Save Name

    RtlInitEmptyUnicodeString( &devExt->UserNames,
                               devExt->UserNamesBuffer,
                               sizeof(devExt->UserNamesBuffer) );
                               
    SpyInitDeviceNamingEnvironment( filespyDeviceObject );

    //
    //  The NETWORK device objects function as both CDOs (control device object)
    //  and VDOs (volume device object) so insert the NETWORK CDO devices into
    //  the list of attached device so we will properly enumerate it.
    //

    if (FILE_DEVICE_NETWORK_FILE_SYSTEM == DeviceObject->DeviceType) {

        ExAcquireFastMutex( &gSpyDeviceExtensionListLock );
        InsertTailList( &gSpyDeviceExtensionList, &devExt->NextFileSpyDeviceLink );
        ExReleaseFastMutex( &gSpyDeviceExtensionListLock );
        SetFlag(devExt->Flags,ExtensionIsLinked);
    }

    //
    //  Flag we are no longer initializing this device object
    //

    ClearFlag( filespyDeviceObject->Flags, DO_DEVICE_INITIALIZING );

    //
    //  Display who we have attached to
    //

    SPY_LOG_PRINT( SPYDEBUG_DISPLAY_ATTACHMENT_NAMES,
                   ("FileSpy!SpyAttachToFileSystemDevice:         Attaching to file system   %p \"%wZ\" (%s)\n",
                    DeviceObject,
                    &devExt->DeviceName,
                    GET_DEVICE_TYPE_NAME(filespyDeviceObject->DeviceType)) );

    //
    //  VERSION NOTE:
    //
    //  In Windows XP, the IO Manager provided APIs to safely enumerate all the
    //  device objects for a given driver.  This allows filters to attach to 
    //  all mounted volumes for a given file system at some time after the
    //  volume has been mounted.  There is no support for this functionality
    //  in Windows 2000.
    //
    //  MULTIVERSION NOTE:
    //
    //  If built for Windows XP or later, this driver is built to run on 
    //  multiple versions.  When this is the case, we will test
    //  for the presence of the new IO Manager routines that allow for volume 
    //  enumeration.  If they are not present, we will not enumerate the volumes
    //  when we attach to a new file system.
    //
    
#if WINVER >= 0x0501

    if (IS_WINDOWSXP_OR_LATER()) {

        ASSERT( NULL != gSpyDynamicFunctions.EnumerateDeviceObjectList &&
                NULL != gSpyDynamicFunctions.GetDiskDeviceObject &&
                NULL != gSpyDynamicFunctions.GetDeviceAttachmentBaseRef &&
                NULL != gSpyDynamicFunctions.GetLowerDeviceObject );

        //
        //  Enumerate all the mounted devices that currently
        //  exist for this file system and attach to them.
        //

        status = SpyEnumerateFileSystemVolumes( DeviceObject, &tempName );

        if (!NT_SUCCESS( status )) {

            SPY_LOG_PRINT( SPYDEBUG_ERROR,
                           ("FileSpy!SpyAttachToFileSystemDevice: Error attaching to existing volumes for \"%wZ\", status=%08x\n",
                            DeviceName,
                            status) );

            IoDetachDevice( devExt->AttachedToDeviceObject );
            goto ErrorCleanupDevice;
        }
    }
    
#endif

    return STATUS_SUCCESS;

    /////////////////////////////////////////////////////////////////////
    //                  Cleanup error handling
    /////////////////////////////////////////////////////////////////////

    ErrorCleanupDevice:
        SpyCleanupMountedDevice( filespyDeviceObject );
        IoDeleteDevice( filespyDeviceObject );

    return status;
}

VOID
SpyDetachFromFileSystemDevice (
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Given a base file system device object, this will scan up the attachment
    chain looking for our attached device object.  If found it will detach
    us from the chain.

Arguments:

    DeviceObject - The file system device to detach from.

Return Value:

--*/ 
{
    PDEVICE_OBJECT ourAttachedDevice;
    PFILESPY_DEVICE_EXTENSION devExt;

    PAGED_CODE();

    //
    //  We have to iterate through the device objects in the filter stack
    //  attached to DeviceObject.  If we are attached to this filesystem device
    //  object, We should be at the top of the stack, but there is no guarantee.
    //  If we are in the stack and not at the top, we can safely call IoDetachDevice
    //  at this time because the IO Manager will only really detach our device
    //  object from the stack at a safe time.
    //

    //
    //  Skip the base file system device object (since it can't be us)
    //

    ourAttachedDevice = DeviceObject->AttachedDevice;

    while (NULL != ourAttachedDevice) {

        if (IS_FILESPY_DEVICE_OBJECT( ourAttachedDevice )) {

            devExt = ourAttachedDevice->DeviceExtension;

            //
            //  Display who we detached from
            //

            SPY_LOG_PRINT( SPYDEBUG_DISPLAY_ATTACHMENT_NAMES,
                           ("FileSpy!SpyDetachFromFileSystem:             Detaching from file system %p \"%wZ\" (%s)\n",
                            devExt->AttachedToDeviceObject,
                            &devExt->DeviceName,
                            GET_DEVICE_TYPE_NAME(ourAttachedDevice->DeviceType)) );
                                
            //
            //  Unlink from global list
            //

            if (FlagOn(devExt->Flags,ExtensionIsLinked)) {

                ExAcquireFastMutex( &gSpyDeviceExtensionListLock );
                RemoveEntryList( &devExt->NextFileSpyDeviceLink );
                ExReleaseFastMutex( &gSpyDeviceExtensionListLock );
                ClearFlag(devExt->Flags,ExtensionIsLinked);
            }

            //
            //  Detach us from the object just below us
            //  Cleanup and delete the object
            //

            SpyCleanupMountedDevice( ourAttachedDevice );
            IoDetachDevice( DeviceObject );
            IoDeleteDevice( ourAttachedDevice );

            return;
        }

        //
        //  Look at the next device up in the attachment chain
        //

        DeviceObject = ourAttachedDevice;
        ourAttachedDevice = ourAttachedDevice->AttachedDevice;
    }
}

#if WINVER >= 0x0501

NTSTATUS
SpyEnumerateFileSystemVolumes (
    IN PDEVICE_OBJECT FSDeviceObject,
    IN PUNICODE_STRING Name
    ) 
/*++

Routine Description:

    Enumerate all the mounted devices that currently exist for the given file
    system and attach to them.  We do this because this filter could be loaded
    at any time and there might already be mounted volumes for this file system.

Arguments:

    FSDeviceObject - The device object for the file system we want to enumerate

    Name - An already initialized unicode string used to retrieve names

Return Value:

    The status of the operation

--*/
{
    PDEVICE_OBJECT newDeviceObject;
    PFILESPY_DEVICE_EXTENSION newDevExt;
    PDEVICE_OBJECT *devList;
    PDEVICE_OBJECT diskDeviceObject;
    NTSTATUS status;
    ULONG numDevices;
    ULONG i;

    PAGED_CODE();

    //
    //  Find out how big of an array we need to allocate for the
    //  mounted device list.
    //

    ASSERT( NULL != gSpyDynamicFunctions.EnumerateDeviceObjectList );
    status = (gSpyDynamicFunctions.EnumerateDeviceObjectList)( FSDeviceObject->DriverObject,
                                                              NULL,
                                                              0,
                                                              &numDevices);

    //
    //  We only need to get this list of there are devices.  If we
    //  don't get an error there are no devices so go on.
    //

    if (!NT_SUCCESS( status )) {

        ASSERT(STATUS_BUFFER_TOO_SMALL == status);

        //
        //  Allocate memory for the list of known devices
        //

        numDevices += 8;        //grab a few extra slots

        devList = ExAllocatePoolWithTag( NonPagedPool, 
                                         (numDevices * sizeof(PDEVICE_OBJECT)), 
                                         FILESPY_POOL_TAG );
        if (NULL == devList) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        //  Now get the list of devices.  If we get an error again
        //  something is wrong, so just fail.
        //

        status = (gSpyDynamicFunctions.EnumerateDeviceObjectList)(
                        FSDeviceObject->DriverObject,
                        devList,
                        (numDevices * sizeof(PDEVICE_OBJECT)),
                        &numDevices);

        if (!NT_SUCCESS( status ))  {

            ExFreePoolWithTag( devList, FILESPY_POOL_TAG );
            return status;
        }

        //
        //  Walk the given list of devices and attach to them if we should.
        //

        for (i=0; i < numDevices; i++) {

            //
            //  Do not attach if:
            //      - This is the control device object (the one passed in)
            //      - The device type does not match
            //      - We are already attached to it
            //

            if ((devList[i] != FSDeviceObject) && 
                (devList[i]->DeviceType == FSDeviceObject->DeviceType) &&
                !SpyIsAttachedToDevice( devList[i], NULL )) {

                //
                //  See if this device has a name.  If so, then it must
                //  be a control device so don't attach to it.  This handles
                //  drivers with more then one control device.
                //

                SpyGetBaseDeviceObjectName( devList[i], Name );

                if (Name->Length <= 0) {

                    //
                    //  Get the disk device object associated with this
                    //  file  system device object.  Only try to attach if we
                    //  have a disk device object.
                    //

                    ASSERT( NULL != gSpyDynamicFunctions.GetDiskDeviceObject );
                    status = (gSpyDynamicFunctions.GetDiskDeviceObject)( devList[i], &diskDeviceObject );

                    if (NT_SUCCESS( status )) {

                        //
                        //  Allocate a new device object to attach with
                        //

                        status = IoCreateDevice( gFileSpyDriverObject,
                                                 sizeof( FILESPY_DEVICE_EXTENSION ),
                                                 (PUNICODE_STRING) NULL,
                                                 devList[i]->DeviceType,
                                                 0,
                                                 FALSE,
                                                 &newDeviceObject );

                        if (NT_SUCCESS( status )) {

                            //
                            //  Set disk device object
                            //

                            newDevExt = newDeviceObject->DeviceExtension;
                            newDevExt->Flags = 0;

                            newDevExt->DiskDeviceObject = diskDeviceObject;
                    
                            //
                            //  Set Device Name
                            //

                            RtlInitEmptyUnicodeString( &newDevExt->DeviceName,
                                                       newDevExt->DeviceNameBuffer,
                                                       sizeof(newDevExt->DeviceNameBuffer) );

                            SpyGetObjectName( diskDeviceObject, 
                                              &newDevExt->DeviceName );

                            //
                            //  We have done a lot of work since the last time
                            //  we tested to see if we were already attached
                            //  to this device object.  Test again, this time
                            //  with a lock, and attach if we are not attached.
                            //  The lock is used to atomically test if we are
                            //  attached, and then do the attach.
                            //

                            ExAcquireFastMutex( &gSpyAttachLock );

                            if (!SpyIsAttachedToDevice( devList[i], NULL )) {

                                //
                                //  Attach to this device object
                                //

                                status = SpyAttachToMountedDevice( devList[i], 
                                                                   newDeviceObject );

                                //
                                //  Handle normal vs error cases, but keep going
                                //

                                if (NT_SUCCESS( status )) {

                                    //
                                    //  Finished all initialization of the new
                                    //  device object,  so clear the initializing
                                    //  flag now.  This allows other filters to
                                    //  now attach to our device object.
                                    //

                                    ClearFlag( newDeviceObject->Flags, DO_DEVICE_INITIALIZING );

                                } else {

                                    //
                                    //  The attachment failed, cleanup.  Note that
                                    //  we continue processing so we will cleanup
                                    //  the reference counts and try to attach to
                                    //  the rest of the volumes.
                                    //
                                    //  One of the reasons this could have failed
                                    //  is because this volume is just being
                                    //  mounted as we are attaching and the
                                    //  DO_DEVICE_INITIALIZING flag has not yet
                                    //  been cleared.  A filter could handle
                                    //  this situation by pausing for a short
                                    //  period of time and retrying the attachment.
                                    //

                                    SpyCleanupMountedDevice( newDeviceObject );
                                    IoDeleteDevice( newDeviceObject );
                                }

                            } else {

                                //
                                //  We were already attached, cleanup this
                                //  device object.
                                //

                                SpyCleanupMountedDevice( newDeviceObject );
                                IoDeleteDevice( newDeviceObject );
                            }

                            //
                            //  Release the lock
                            //

                            ExReleaseFastMutex( &gSpyAttachLock );

                        } else {

                            SPY_LOG_PRINT( SPYDEBUG_ERROR,
                                           ("FileSpy!SpyEnumberateFileSystemVolumes: Error creating volume device object, status=%08x\n",
                                            status) );
                        }
                        
                        //
                        //  Remove reference added by IoGetDiskDeviceObject.
                        //  We only need to hold this reference until we are
                        //  successfully attached to the current volume.  Once
                        //  we are successfully attached to devList[i], the
                        //  IO Manager will make sure that the underlying
                        //  diskDeviceObject will not go away until the file
                        //  system stack is torn down.
                        //

                        ObDereferenceObject( diskDeviceObject );
                    }
                }
            }

            //
            //  Dereference the object (reference added by 
            //  IoEnumerateDeviceObjectList)
            //

            ObDereferenceObject( devList[i] );
        }

        //
        //  We are going to ignore any errors received while loading.  We
        //  simply won't be attached to those volumes if we get an error
        //

        status = STATUS_SUCCESS;

        //
        //  Free the memory we allocated for the list
        //

        ExFreePoolWithTag( devList, FILESPY_POOL_TAG );
    }

    return status;
}
#endif

////////////////////////////////////////////////////////////////////////
//                                                                    //
//             Private Filespy IOCTLs helper routines                 //
//                                                                    //
////////////////////////////////////////////////////////////////////////

NTSTATUS
SpyGetAttachList (
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG_PTR ReturnLength
    )
/*++

Routine Description:
    This returns an array of structure identifying all of the devices
    we are currently physical attached to and whether logging is on or
    off for the given device

Arguments:
    buffer - buffer to receive the attachment list
    bufferSize - total size in bytes of the return buffer
    returnLength - receives number of bytes we actually return

Return Value:
    NT Status code

--*/
{
    PLIST_ENTRY link;
    PFILESPY_DEVICE_EXTENSION devExt;
    PATTACHED_DEVICE pAttDev;
    ULONG retlen = 0;

    PAGED_CODE();

    pAttDev = Buffer;

    ExAcquireFastMutex( &gSpyDeviceExtensionListLock );

    for (link = gSpyDeviceExtensionList.Flink;
         link != &gSpyDeviceExtensionList;
         link = link->Flink) {

        devExt = CONTAINING_RECORD(link, FILESPY_DEVICE_EXTENSION, NextFileSpyDeviceLink);

        if (BufferSize < sizeof(ATTACHED_DEVICE)) {

            break;
		}

        pAttDev->LoggingOn = BooleanFlagOn(devExt->Flags,LogThisDevice);
        wcscpy( pAttDev->DeviceNames, devExt->DeviceNameBuffer );
        retlen += sizeof( ATTACHED_DEVICE );
        BufferSize -= sizeof( ATTACHED_DEVICE );
        pAttDev++;
    }

    ExReleaseFastMutex( &gSpyDeviceExtensionListLock );

    *ReturnLength = retlen;
    return STATUS_SUCCESS;
}

VOID
SpyGetLog (
    OUT PVOID            OutputBuffer,
    IN  ULONG            OutputBufferLength,
    OUT PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:
    This function fills OutputBuffer with as many LOG_RECORDs as possible.
    The LOG_RECORDs are variable sizes and are tightly packed in the
    OutputBuffer.

Arguments:
    OutputBuffer - the user's buffer to fill with the log data we have
        collected
    OutputBufferLength - the size in bytes of OutputBuffer
    IoStatus - is set to the correct return status information for this
        operation

Return Value:
    None

--*/
{
    PLIST_ENTRY pList = NULL;
    ULONG length = OutputBufferLength;
    PCHAR pOutBuffer = OutputBuffer;
    PLOG_RECORD pLogRecord = NULL;
    ULONG recordsAvailable = 0, logRecordLength;
    PRECORD_LIST pRecordList;
    KIRQL oldIrql;

    IoStatus->Information = 0;

    KeAcquireSpinLock(&gOutputBufferLock, &oldIrql);

    while (!IsListEmpty( &gOutputBufferList ) && (length > 0)) {

        pList = RemoveHeadList( &gOutputBufferList );

        pRecordList = CONTAINING_RECORD( pList, RECORD_LIST, List );

        pLogRecord = &pRecordList->LogRecord;

        recordsAvailable++;

		//
		//  Pack log records on PVOID boundaries to avoid alignment faults when accessing 
        //  the packed buffer on 64-bit architectures
        // 

        logRecordLength = ROUND_TO_SIZE( pLogRecord->Length, sizeof( PVOID ) );

        if (length < logRecordLength) {

            InsertHeadList( &gOutputBufferList, pList );
            break;
        }

        KeReleaseSpinLock( &gOutputBufferLock, oldIrql );

        //
        //  Copy of course the non-padded number of bytes
        //

        RtlCopyMemory( pOutBuffer, pLogRecord, pLogRecord->Length );

        //
        //  Adjust the log-record length to the padded length in the copied record 
        //

        ((PLOG_RECORD) pOutBuffer)->Length = logRecordLength;

        IoStatus->Information += logRecordLength;
       
        length -= logRecordLength;

        pOutBuffer += logRecordLength;

        SpyFreeRecord( pRecordList );

        KeAcquireSpinLock( &gOutputBufferLock, &oldIrql );
    }

    KeReleaseSpinLock( &gOutputBufferLock, oldIrql );

	//
    // no copies occurred
	//

    if (length == OutputBufferLength && recordsAvailable > 0) {

        IoStatus->Status = STATUS_BUFFER_TOO_SMALL;
    }

    return;
}

VOID
SpyCloseControlDevice (
    )
/*++

Routine Description:

    This is the routine that is associated with IRP_MJ_
    This routine does the cleanup involved in closing the ControlDevice.
    On the close of the Control Device, we need to empty the queue of
    logRecords that are waiting to be returned to the user.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PLIST_ENTRY pList;
    PRECORD_LIST pRecordList;
    KIRQL oldIrql;

    //
    // Set the gControlDeviceState to CLEANING_UP so that we can
    // signal that we are cleaning up the device.
    //

    KeAcquireSpinLock( &gControlDeviceStateLock, &oldIrql );
    gControlDeviceState = CLEANING_UP;
    KeReleaseSpinLock( &gControlDeviceStateLock, oldIrql );

    KeAcquireSpinLock( &gOutputBufferLock, &oldIrql );

    while (!IsListEmpty( &gOutputBufferList )) {

        pList = RemoveHeadList( &gOutputBufferList );

        KeReleaseSpinLock( &gOutputBufferLock, oldIrql );

        pRecordList = CONTAINING_RECORD( pList, RECORD_LIST, List );

        SpyFreeRecord( pRecordList );

        KeAcquireSpinLock( &gOutputBufferLock, &oldIrql );
    }

    KeReleaseSpinLock( &gOutputBufferLock, oldIrql );

    SpyNameDeleteAllNames();

    //
    // All the cleanup is done, so set the gControlDeviceState
    // to CLOSED.
    //

    KeAcquireSpinLock( &gControlDeviceStateLock, &oldIrql );
    gControlDeviceState = CLOSED;
    KeReleaseSpinLock( &gControlDeviceStateLock, oldIrql );
}

////////////////////////////////////////////////////////////////////////
//                                                                    //
//               Device name tracking helper routines                 //
//                                                                    //
////////////////////////////////////////////////////////////////////////

VOID
SpyGetObjectName (
    IN PVOID Object,
    IN OUT PUNICODE_STRING Name
    )
/*++

Routine Description:

    This routine will return the name of the given object.
    If a name can not be found an empty string will be returned.

Arguments:

    Object - The object whose name we want

    Name - A unicode string that is already initialized with a buffer

Return Value:

    None

--*/
{
    NTSTATUS status;
    CHAR nibuf[512];        //buffer that receives NAME information and name
    POBJECT_NAME_INFORMATION nameInfo = (POBJECT_NAME_INFORMATION)nibuf;
    ULONG retLength;

    PAGED_CODE();

    status = ObQueryNameString( Object, 
                                nameInfo, 
                                sizeof(nibuf), 
                                &retLength );

    //
    //  Init current length, if we have an error a NULL string will be returned
    //

    Name->Length = 0;

    if (NT_SUCCESS( status )) {

        //
        //  Copy what we can of the name string
        //

        RtlCopyUnicodeString( Name, &nameInfo->Name );
    }
}

//
//  VERSION NOTE:
//
//  This helper routine is only needed when enumerating all volumes in the
//  system, which is only supported on Windows XP and later.
//

#if WINVER >= 0x0501

VOID
SpyGetBaseDeviceObjectName (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PUNICODE_STRING Name
    )
/*++

Routine Description:

    This locates the base device object in the given attachment chain and then
    returns the name of that object.

    If no name can be found, an empty string is returned.

Arguments:

    Object - The object whose name we want

    Name - A unicode string that is already initialized with a buffer

Return Value:

    None

--*/
{
    PAGED_CODE();
    
    //
    //  Get the base file system device object
    //

    ASSERT( NULL != gSpyDynamicFunctions.GetDeviceAttachmentBaseRef );
    DeviceObject = (gSpyDynamicFunctions.GetDeviceAttachmentBaseRef)( DeviceObject );

    //
    //  Get the name of that object
    //

    SpyGetObjectName( DeviceObject, Name );

    //
    //  Remove the reference added by IoGetDeviceAttachmentBaseRef
    //

    ObDereferenceObject( DeviceObject );
}

#endif

BOOLEAN
SpyFindSubString (
    IN PUNICODE_STRING String,
    IN PUNICODE_STRING SubString
    )
/*++

Routine Description:
    This routine looks to see if SubString is a substring of String.

Arguments:
    String - the string to search in
    SubString - the substring to find in String

Return Value:
    Returns TRUE if the substring is found in string and FALSE otherwise.
    
--*/
{
    ULONG index;

    //
    //  First, check to see if the strings are equal.
    //

    if (RtlEqualUnicodeString( String, SubString, TRUE )) {

        return TRUE;
    }

    //
    //  String and SubString aren't equal, so now see if SubString
    //  is in String any where.
    //

    for (index = 0;
         index + SubString->Length <= String->Length;
         index++) {

        if (_wcsnicmp( &String->Buffer[index], SubString->Buffer, SubString->Length ) == 0) {

            //
            //  SubString is found in String, so return TRUE.
            //
            return TRUE;
        }
    }

    return FALSE;
}

VOID
SpyStoreUserName (
    IN PFILESPY_DEVICE_EXTENSION devExt,
    IN PUNICODE_STRING UserName
    )
/*++

Routine Description:

    Stores the current device name in the device extension.  If
    this name is already in the device name list of this extension,
    it will not be added.  If there is already a name for this device, 
    the new device name is appended to the DeviceName in the device extension.
    
Arguments:

    devExt - The device extension that will store the
        device name.

    UserName - The device name as specified by the user to be stored.

Return Value:

    None

--*/
{
    //
    //  See if this UserName is already in the list of user names filespy
    //  keeps in its device extension.  If not, add it to the list.
    //

    if (!SpyFindSubString( &devExt->UserNames, UserName )) {

        //
        //  We didn't find this name in the list, so if there are no names 
        //  in the UserNames list, just append UserName.  Otherwise, append a
        //  delimiter then append UserName.
        //

        if (devExt->UserNames.Length == 0) {

            RtlAppendUnicodeStringToString( &devExt->UserNames, UserName );

        } else {

            RtlAppendUnicodeToString( &devExt->UserNames, L", " );
            RtlAppendUnicodeStringToString( &devExt->UserNames, UserName );
        }
    }

    //
    //  See if this UserName is already in the list of device names filespy
    //  keeps in its device extension.  If not, add it to the list.
    //

    if (!SpyFindSubString( &devExt->DeviceName, UserName )) {

        //
        //  We didn't find this name in the list, so if there are no names 
        //  in the UserNames list, just append UserName.  Otherwise, append a
        //  delimiter then append UserName.
        //

        if (devExt->DeviceName.Length == 0) {

            RtlAppendUnicodeStringToString( &devExt->DeviceName, UserName );

        } else {

            RtlAppendUnicodeToString( &devExt->DeviceName, L", " );
            RtlAppendUnicodeStringToString( &devExt->DeviceName, UserName );
        }
    }
}

////////////////////////////////////////////////////////////////////////
//                                                                    //
//                        Debug support routines                      //
//                                                                    //
////////////////////////////////////////////////////////////////////////

VOID
SpyDumpIrpOperation (
    IN BOOLEAN InOriginatingPath,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is for debugging and prints out a string to the
    debugger specifying what Irp operation is being seen.
    
Arguments:

    InOriginatingPath - TRUE if we are in the originating path
        for the IRP, FALSE if in the completion path.

    Irp - The IRP for this operation.
        
Return Value:

    None.
    
--*/
{
    CHAR irpMajorString[OPERATION_NAME_BUFFER_SIZE];
    CHAR irpMinorString[OPERATION_NAME_BUFFER_SIZE];
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation( Irp );

    GetIrpName(irpSp->MajorFunction,
               irpSp->MinorFunction,
               irpSp->Parameters.FileSystemControl.FsControlCode,
               irpMajorString,irpMinorString);


    if (InOriginatingPath) {

        DbgPrint( "FILESPY: Irp preoperation for %s %s\n", irpMajorString, irpMinorString );
            
    } else {
    
        DbgPrint( "FILESPY: Irp postoperation for %s %s\n", irpMajorString, irpMinorString );
    }
}

VOID
SpyDumpFastIoOperation (
    IN BOOLEAN InPreOperation,
    IN FASTIO_TYPE FastIoOperation
    )
/*++

Routine Description:

    This routine is for debugging and prints out a string to the
    debugger specifying what FsFilter operation is being seen.
    
Arguments:

    InPreOperation - TRUE if we have not called down to the next
        device in the stack, FALSE otherwise.

    FastIoOperation - The code for the Fast Io operation.
    
Return Value:

    None.
    
--*/
{
    CHAR operationString[OPERATION_NAME_BUFFER_SIZE];

    GetFastioName(FastIoOperation,
               operationString);


    if (InPreOperation) {
    
        DbgPrint( "FILESPY: Fast IO preOperation for %s\n", operationString );

    } else {

        DbgPrint( "FILESPY: Fast IO postOperation for %s\n", operationString );
    }
}

#if WINVER >= 0x0501 /* See comment in DriverEntry */

VOID
SpyDumpFsFilterOperation (
    IN BOOLEAN InPreOperationCallback,
    IN PFS_FILTER_CALLBACK_DATA Data
    )
/*++

Routine Description:

    This routine is for debugging and prints out a string to the
    debugger specifying what FsFilter operation is being seen.
    
Arguments:

    InPreOperationCallback - TRUE if we are in a preOperation 
        callback, FALSE otherwise.

    Data - The FS_FILTER_CALLBACK_DATA structure for this
        operation.
        
Return Value:

    None.
    
--*/
{
    CHAR operationString[OPERATION_NAME_BUFFER_SIZE];


    GetFsFilterOperationName(Data->Operation,operationString);

    if (InPreOperationCallback) {
    
        DbgPrint( "FILESPY: FsFilter preOperation for %s\n", operationString );

    } else {

        DbgPrint( "FILESPY: FsFilter postOperation for %s\n", operationString );
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\filespy\fspykd\fspykd.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    FilmonKd.c

Abstract:

    KD Extension Api for examining FileSpy specific data structures.

    Note: While this extension can only build in the Windows XP and .NET
    environments, it can still be used to debug a version of this FileSpy
    sample built for Windows 2000.

// @@BEGIN_DDKSPLIT

Author:

    Molly Brown [MollyBro]    29-Apr-99

Revision History:

    Port to platform independent - 

                        Ravisankar Pudipeddi [ravisp] 3-March-01


// @@END_DDKSPLIT

Environment:

    User Mode.


--*/

#include "pch.h"

//
// Windows.h doesn't include this definition
//
typedef struct _UNICODE_STRING {
    USHORT Length;
    USHORT MaximumLength;
    PWSTR Buffer;
} UNICODE_STRING, *PUNICODE_STRING;


#ifndef MAX
    #define MAX(a,b) (((a) > (b))?(a):(b))
#endif

/****************************************************************************
  Typedefs and constants
****************************************************************************/
typedef PVOID (*PSTRUCT_DUMP_ROUTINE)(
    IN ULONG64 Address,
    IN LONG Options,
    USHORT Processor,
    HANDLE hCurrentThread
    );

//
// The help strings printed out
//

static LPSTR Extensions[] = {
    "FileSpy Debugger Extensions:\n",
    "attachments [1|2]                  Dump all the devices FileSpy is attached to ",
    "devext      [address] [1|2]        Dump FileSpy device extension",
    "filenames   [1|2]                  Dumps all the file names cached",
    0
};


/******************************************************************************
    Function prototypes
******************************************************************************/
VOID
PrintHelp (
    VOID
    );

/******************************************************************************
    Useful macros
******************************************************************************/

#define xGetFieldValue(Address, Type, Field, Value)                         \
     {                                                                      \
        if (GetFieldValue(Address, Type, Field, Value)) {                   \
            dprintf("\nCould not read field %s of %s from address: %08p\n", \
                    (Field), (Type), (Address));                            \
            return;                                                         \
        }                                                                   \
     }
       
#define xGetFieldOffset(Type, Field, Offset)                                \
     {                                                                      \
        if (GetFieldOffset(Type, Field, Offset)) {                          \
            dprintf("\nCould not read offset of field %s from type %s\n",   \
                    (Field), (Type));                                       \
            return;                                                         \
        }                                                                   \
     }
   

/*++

/****************************************************************************
  Entry points, parameter parsers, etc. below
****************************************************************************/
VOID
DumpDeviceExtension (
    IN ULONG64 Address,
    IN LONG      Options,
    USHORT Processor,
    HANDLE hCurrentThread
    )

/*++

Routine Description:

    Dump a specific device extension.

Arguments:

    Address - Gives the address of the device extension to dump

Return Value:

    None

--*/

{
    ULONG64 pointer, pName;
    UNICODE_STRING string1, string2;
    PUCHAR  buffer;
    USHORT  length;
    ULONG   offset, offset2;
    ULONG   result;
    BOOLEAN boolean;


    UNREFERENCED_PARAMETER( Processor );
    UNREFERENCED_PARAMETER( hCurrentThread );

    dprintf( "\nFileSpy device extension: %08p", Address );


    //
    //  Dump the interesting parts of the device extension
    //
    if (Options <= 1) {
        //
        // Get the device name length
        //
        xGetFieldValue(Address, "FileSpy!_FILESPY_DEVICE_EXTENSION", "DeviceNames.Length", length);

        // Get offset, and addres of string
        //
        xGetFieldOffset("FileSpy!_FILESPY_DEVICE_EXTENSION", "DeviceNamesBuffer", &offset);
        pName = Address+offset;

        //
        // Allocate buffer to hold string.
        // We should not call any xGet* macros before freeing the buffer
        // as they might just return from the function on failure
        //
        buffer = LocalAlloc(LPTR, length);
                                 
        if (buffer == NULL) {
            return;
        }
        //
        // Read in the string: assuming it's NULL terminated here..
        //
        if (ReadMemory(pName,
                       buffer,
                       (ULONG) length,
                       &result) && (result == (ULONG) length)) {

            string1.Length = string1.MaximumLength = length;
            string1.Buffer = (PWSTR) buffer;

            dprintf( "\n\t(%3x) %s %wZ",
                      offset,
                      "DeviceNames                       ",
                      &string1);
        }
        //
        // Free the buffer
        //
        LocalFree(buffer);
        buffer = NULL;
        
        xGetFieldOffset("FileSpy!_FILESPY_DEVICE_EXTENSION", "LogThisDevice", &offset);
        xGetFieldValue(Address, "FileSpy!_FILESPY_DEVICE_EXTENSION", "LogThisDevice", boolean);

        dprintf( "\n\t(%3x) %s %s",
                 offset,
                 "LogThisDevice                     ",
                 (boolean ? "TRUE" : "FALSE") );
        

    } else if (Options == 2) {
        dprintf( "\n\t(OFF) %s",
                 "FIELD NAME                         VALUE");
        dprintf( "\n\t%s",
                 "----------------------------------------------");

        xGetFieldOffset("FileSpy!_FILESPY_DEVICE_EXTENSION", "AttachedToDeviceObject", &offset);
        xGetFieldValue(Address, "FileSpy!_FILESPY_DEVICE_EXTENSION", "AttachedToDeviceObject", pointer);
        dprintf( "\n\t(%3x) %s %08p",
                 offset,
                 "AttachedToDeviceObject            ",
                 pointer);

        xGetFieldOffset("FileSpy!_FILESPY_DEVICE_EXTENSION", "DiskDeviceObject", &offset);
        xGetFieldValue(Address, "FileSpy!_FILESPY_DEVICE_EXTENSION", "DiskDeviceObject", pointer);
        dprintf( "\n\t(%3x) %s %08p",
                 offset,
                 "DiskDeviceObject                  ",
                 pointer);

        xGetFieldOffset("FileSpy!_FILESPY_DEVICE_EXTENSION", "LogThisDevice", &offset);
        xGetFieldValue(Address, "FileSpy!_FILESPY_DEVICE_EXTENSION", "LogThisDevice", boolean);
        dprintf( "\n\t(%3x) %s %s",
                 offset,
                 "LogThisDevice                     ",
                 (boolean ? "TRUE" : "FALSE") );

        xGetFieldOffset("FileSpy!_FILESPY_DEVICE_EXTENSION", "DeviceNames.Length", &offset);
        xGetFieldValue(Address, "FileSpy!_FILESPY_DEVICE_EXTENSION", "DeviceNames.Length", length);
        dprintf( "\n\t(%3x) %s %04x",
                 offset,
                 "DeviceNames.Length(bytes)         ",
                 length);
        //
        // Save buffersize, since we need it later to print the string
        //
        string1.Length = string1.MaximumLength = length;
                 
        xGetFieldOffset("FileSpy!_FILESPY_DEVICE_EXTENSION", "DeviceNames.MaximumLength", &offset);
        xGetFieldValue(Address, "FileSpy!_FILESPY_DEVICE_EXTENSION", "DeviceNames.MaximumLength", length);
        dprintf( "\n\t(%3x) %s %04x",
                 offset,
                 "DeviceNames.MaximumLength(bytes)  ",
                 length);

        xGetFieldOffset("FileSpy!_FILESPY_DEVICE_EXTENSION", "DeviceNames.Buffer", &offset);
        xGetFieldValue(Address, "FileSpy!_FILESPY_DEVICE_EXTENSION", "DeviceNames.Buffer", pointer);
        dprintf( "\n\t(%3x) %s %08p",
                 offset,
                 "DeviceNames.Buffer                ",
                 pointer);

        
        xGetFieldOffset("FileSpy!_FILESPY_DEVICE_EXTENSION", "UserNames.Length", &offset);
        xGetFieldValue(Address, "FileSpy!_FILESPY_DEVICE_EXTENSION", "UserNames.Length", length);
        dprintf( "\n\t(%3x) %s %04x",
                 offset,
                 "UserNames.Length(bytes)           ",
                 length);

        //
        // Update size of buffer needed 
        //
        string2.Length = string2.MaximumLength = length;

        xGetFieldOffset("FileSpy!_FILESPY_DEVICE_EXTENSION", "UserNames.MaximumLength", &offset);
        xGetFieldValue(Address, "FileSpy!_FILESPY_DEVICE_EXTENSION", "UserNames.MaximumLength", length);
        dprintf( "\n\t(%3x) %s %04x",
                 offset,
                 "UserNames.MaximumLength(bytes)    ",
                 length);

        xGetFieldOffset("FileSpy!_FILESPY_DEVICE_EXTENSION", "UserNames.Buffer", &offset);
        xGetFieldValue(Address, "FileSpy!_FILESPY_DEVICE_EXTENSION", "UserNames.Buffer", pointer);
        dprintf( "\n\t(%3x) %s %08p",
                 offset,
                 "UserNames.Buffer                  ",
                 pointer);

        
        //
        // Get the device names buffer offset
        //
        xGetFieldOffset("FileSpy!_FILESPY_DEVICE_EXTENSION", "DeviceNamesBuffer", &offset);
        pName = Address+offset;

        //
        // Get the user names buffer offset
        //
        xGetFieldOffset("FileSpy!_FILESPY_DEVICE_EXTENSION", "UserNamesBuffer", &offset2);

        //
        // Allocate buffer large enough to hold the largest string
        // we will serialize access to it
        //
        buffer = LocalAlloc(LPTR, MAX(string1.MaximumLength,
                                      string2.MaximumLength));
        if (buffer == NULL) {
            return;
        }

        string1.Buffer = string2.Buffer = (PWSTR) buffer;

        if (ReadMemory(pName,
                       buffer,
                       string1.Length,
                       &result) && (result == string1.Length)) {

            dprintf( "\n\t(%3x) %s %wZ",
                      offset,
                      "DeviceNames                       ",
                      &string1);
        }

        pName = Address+offset2;
        if (ReadMemory(pName,
                       buffer,
                       string2.Length,
                       &result) && (result == string2.Length)) {

            dprintf( "\n\t(%3x) %s %wZ",
                      offset2,
                      "UserNames                         ",
                      &string2);
        }

        LocalFree(buffer);
        buffer = NULL;

    } else {
        dprintf ("\nNot a valid option");
    }
    dprintf( "\n" );
}


VOID
DumpAttachments (
    IN LONG Options,
    USHORT Processor,
    HANDLE hCurrentThread
    )
/*++

Routine Description:

    Dump the list of attached devices that is global to FileSpy.

Arguments:

    Options - Ignored for now

Return Value:

    None

--*/
{
    ULONG64 address, next;
    ULONG64 deviceExtensionAddress;
    ULONG linkOffset;

    UNREFERENCED_PARAMETER( Processor );
    UNREFERENCED_PARAMETER( hCurrentThread );

    address = GetExpression( "FileSpy!gSpyDeviceExtensionList" );

    dprintf( "\nAttachedDeviceList: %08p", address );


    //
    // Establish offset of the linking entry..
    //
    xGetFieldOffset("FileSpy!_FILESPY_DEVICE_EXTENSION", "NextFileSpyDeviceLink", &linkOffset);
    xGetFieldValue(address, "nt!_LIST_ENTRY", "Flink", next);

    while (next != address) {

        deviceExtensionAddress =  (next - linkOffset);
            // i.e., CONTAINING_RECORD( next, _FILESPY_DEVICE_EXTENSION, NextFileSpyDeviceLink );

        DumpDeviceExtension( 
            deviceExtensionAddress, 
            Options,
            Processor, 
            hCurrentThread );

        if (CheckControlC()) {
            return;
        }

        xGetFieldValue(next, "nt!_LIST_ENTRY", "Flink", next);
    }
}

VOID
DumpFileNameCache (
    IN LONG Options,
    USHORT  Processor,
    HANDLE  hCurrentThread
)
/*++

Routine Description:

    Dump all the fileObjects and file names that are currently in the
    file name cache

Arguments:

    Options - 1 dumps just the file objects and file names
              2 dumps the hash bucket labels along with the file objects
                and file names

Return Value:

    None

--*/
{
    ULONG64      address;
    ULONG64      next;
    ULONG64      pName;
    ULONG64      fileObject;
    ULONG64      pHashEntry;
    ULONG        length;
    ULONG        result;
    ULONG        linkOffset;
    UNICODE_STRING string;
    LIST_ENTRY64  listEntry;
    PUCHAR       buffer;
    INT         i;
    ULONG       nameCount = 0;

    UNREFERENCED_PARAMETER( Processor );
    UNREFERENCED_PARAMETER( hCurrentThread );

    address = GetExpression( "FileSpy!gHashTable" );
    dprintf( "\nHashTable: %08p\n", address);

    dprintf( "  FileObject  Length  FileName\n" );
    dprintf( "  -----------------------------------------\n" );

    xGetFieldOffset("FileSpy!_HASH_ENTRY", "List", &linkOffset);

    for (i=0; i < HASH_SIZE; i++) {

        if (!ReadListEntry(address, &listEntry)) {
            dprintf("Can't read hash table\n");
            return;
        }

        if (Options > 1) {
            dprintf ("Hash Bucket[%3d]\n", i);
        }

        next = listEntry.Flink;

        while (next != address) {

            pHashEntry =  next - linkOffset;// CONTAINING_RECORD( next, HASH_ENTRY, List );

            xGetFieldValue(pHashEntry, "FileSpy!_HASH_ENTRY", "FileObject", fileObject);
            xGetFieldValue(pHashEntry, "FileSpy!_HASH_ENTRY", "Name.Length", length);

            //
            // Get the names buffer pointer
            //
            xGetFieldValue(pHashEntry, "FileSpy!_HASH_ENTRY", "Name.Buffer", pName);
            //
            // Allocate buffer to hold the string
            //
            buffer = LocalAlloc(LPTR, length);
            if (buffer != NULL) {
                string.MaximumLength = string.Length = (USHORT) length;
                string.Buffer = (PWSTR) buffer;
                if (ReadMemory(pName,
                               buffer,
                               length,
                               &result) && (result == length)) {
                    dprintf (
                        "  %08p    %4d    %wZ\n", 
                        fileObject, 
                        length/sizeof(WCHAR),
                        &string);

                }
                //
                // Free the buffer
                //
                LocalFree(buffer);
                buffer = NULL;
            } else {
                dprintf("\nCould not allocate buffer to hold filename\n");
            }

            nameCount ++;

            if (CheckControlC()) {
                dprintf("%u Names in cache\n", nameCount);
                return;
            }
            
            if (!ReadListEntry(next, &listEntry)) {
                dprintf("Can't read hash table\n");
                return;
            }

            next = listEntry.Flink;
        }
        //
        // Advance address to next hash entry
        //
        if (IsPtr64()) {
            address += sizeof(LIST_ENTRY64);
        } else {
            address += sizeof(LIST_ENTRY);
        }
    }
    dprintf("%u Names in cache\n", nameCount);
}



VOID
ParseAndDump (
    IN PCSTR args,
    IN PSTRUCT_DUMP_ROUTINE DumpFunction,
    USHORT Processor,
    HANDLE hCurrentThread
    )

/*++

Routine Description:

    Parse command line arguments and dump an ntfs structure.

Arguments:

    Args - String of arguments to parse.

    DumpFunction - Function to call with parsed arguments.

Return Value:

    None

--*/

{
    UCHAR StringStructToDump[1024];  // See other kd routines for size
    ULONG64 StructToDump = 0;
    LONG Options = 0;

    //
    //  If the caller specified an address then that's the item we dump
    //
    if (args) {
       StructToDump = 0;
       Options = 0;

       StringStructToDump[0] = '\0';

        (VOID) sscanf(args,"%s %lx", StringStructToDump, &Options );

       StructToDump = GetExpression( StringStructToDump );

       if (StructToDump == 0){
         dprintf("unable to get expression %s\n",StringStructToDump);
         return;
       }

       (*DumpFunction) ( StructToDump, Options, Processor, hCurrentThread );

       dprintf( "\n" );
    } else {
       PrintHelp();
    }
}


VOID
PrintHelp (
    VOID
    )
/*++

Routine Description:

    Dump out one line of help for each DECLARE_API

Arguments:

    None

Return Value:

    None

--*/
{
    int i;

    for( i=0; Extensions[i]; i++ )
        dprintf( "   %s\n", Extensions[i] );
}


DECLARE_API( devext )

/*++

Routine Description:

    Dump device extension struct

Arguments:

    arg - [Address] [options]

Return Value:

    None

--*/

{
    UNREFERENCED_PARAMETER( dwCurrentPc );
    UNREFERENCED_PARAMETER( hCurrentProcess );

    ParseAndDump( 
        args, 
        (PSTRUCT_DUMP_ROUTINE) DumpDeviceExtension, 
        (USHORT)dwProcessor, 
        hCurrentThread );
}

DECLARE_API( attachments )

/*++

Routine Description:

    Dumps the list of devices we are currently attached to

Arguments:

    arg - [options]

Return Value:

    None

--*/

{
    LONG options = 0;
    
    UNREFERENCED_PARAMETER( dwCurrentPc );
    UNREFERENCED_PARAMETER( hCurrentProcess );
    
    (VOID)sscanf(args,"%lx", &options );
    
    DumpAttachments( options, (USHORT)dwProcessor, hCurrentThread );
    
    dprintf( "\n" );
}

DECLARE_API( filenames )

/*++

Routine Description:

    Dumps all the entries in the file name cache

Arguments:

    arg - 

Return Value:

    None

--*/

{
    LONG options = 0;
    
    UNREFERENCED_PARAMETER( dwCurrentPc );
    UNREFERENCED_PARAMETER( hCurrentProcess );
    
    (VOID)sscanf(args,"%lx", &options );

    DumpFileNameCache(options, (USHORT)dwProcessor, hCurrentThread );
    
}


DECLARE_API( help )

/*++

Routine Description:

    Dump the help for this debugger extension module.

Arguments:

    arg - None

Return Value:

    None

--*/

{
    UNREFERENCED_PARAMETER( args );
    UNREFERENCED_PARAMETER( dwCurrentPc );
    UNREFERENCED_PARAMETER( hCurrentProcess );
    UNREFERENCED_PARAMETER( hCurrentThread );
    UNREFERENCED_PARAMETER( dwProcessor );

    PrintHelp();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\filespy\lib\filespylib.h ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    filespyLib.h

Abstract:

    This contains internal definitions from the fileSpy library
    
// @@BEGIN_DDKSPLIT
Author:

    Neal Christiansen (NealCH) 27-Sep-2000

// @@END_DDKSPLIT
Environment:

    Library used by both USER and KERNEL mode components

// @@BEGIN_DDKSPLIT
Revision History:

    Molly Brown (mollybro)         21-May-2002
        Modify sample to make it support running on Windows 2000 or later if
        built in the latest build environment and allow it to be built in W2K 
        and later build environments.

// @@END_DDKSPLIT
--*/

#ifndef __FILESPYLIB_H__
#define __FILESPYLIB_H__

#ifdef __cplusplus
extern "C" {
#endif

//
//  The types FASTIO that are available for the Type field of the 
//  RECORD_FASTIO structure.
//

typedef enum {

    CHECK_IF_POSSIBLE = 1,
    READ,
    WRITE,
    QUERY_BASIC_INFO,
    QUERY_STANDARD_INFO,
    LOCK,
    UNLOCK_SINGLE,
    UNLOCK_ALL,
    UNLOCK_ALL_BY_KEY,
    DEVICE_CONTROL,
    DETACH_DEVICE,
    QUERY_NETWORK_OPEN_INFO,
    MDL_READ,
    MDL_READ_COMPLETE,
    MDL_WRITE,
    MDL_WRITE_COMPLETE,
    READ_COMPRESSED,
    WRITE_COMPRESSED,
    MDL_READ_COMPLETE_COMPRESSED,
    PREPARE_MDL_WRITE,
    MDL_WRITE_COMPLETE_COMPRESSED,
    QUERY_OPEN,

    FASTIO_MAX_OPERATION=QUERY_OPEN
} FASTIO_TYPE/*, *PFASTIO_TYPE*/;

//
//  Size of return name buffers
//

#define OPERATION_NAME_BUFFER_SIZE 80

//
//  Function prototypes
//

extern
VOID
GetIrpName (
    IN UCHAR MajorCode,
    IN UCHAR MinorCode,
    IN ULONG FsctlCode,
    OUT PCHAR MajorCodeName,
    OUT PCHAR MinorCodeName);

extern
VOID
GetFastioName (
    IN FASTIO_TYPE FastioCode,
    OUT PCHAR FastioName);

#if WINVER >= 0x0501 /* See comment in DriverEntry */
extern
VOID
GetFsFilterOperationName (
    IN UCHAR FsFilterOperation,
    OUT PCHAR FsFilterOperationName);
#endif
    
//
//  Service definitions
//

#define FILESPY_SERVICE_NAME   L"FileSpy"
#define FILESPY_SERVICE_ACCESS (STANDARD_RIGHTS_REQUIRED | \
                                SERVICE_QUERY_CONFIG | \
                                SERVICE_QUERY_STATUS | \
                                SERVICE_START)

//
//  These are copied from NTIFS.H because we need them in user mode.
//

#define IRP_MJ_CREATE                   0x00
#define IRP_MJ_CREATE_NAMED_PIPE        0x01
#define IRP_MJ_CLOSE                    0x02
#define IRP_MJ_READ                     0x03
#define IRP_MJ_WRITE                    0x04
#define IRP_MJ_QUERY_INFORMATION        0x05
#define IRP_MJ_SET_INFORMATION          0x06
#define IRP_MJ_QUERY_EA                 0x07
#define IRP_MJ_SET_EA                   0x08
#define IRP_MJ_FLUSH_BUFFERS            0x09
#define IRP_MJ_QUERY_VOLUME_INFORMATION 0x0a
#define IRP_MJ_SET_VOLUME_INFORMATION   0x0b
#define IRP_MJ_DIRECTORY_CONTROL        0x0c
#define IRP_MJ_FILE_SYSTEM_CONTROL      0x0d
#define IRP_MJ_DEVICE_CONTROL           0x0e
#define IRP_MJ_INTERNAL_DEVICE_CONTROL  0x0f
#define IRP_MJ_SHUTDOWN                 0x10
#define IRP_MJ_LOCK_CONTROL             0x11
#define IRP_MJ_CLEANUP                  0x12
#define IRP_MJ_CREATE_MAILSLOT          0x13
#define IRP_MJ_QUERY_SECURITY           0x14
#define IRP_MJ_SET_SECURITY             0x15
#define IRP_MJ_POWER                    0x16
#define IRP_MJ_SYSTEM_CONTROL           0x17
#define IRP_MJ_DEVICE_CHANGE            0x18
#define IRP_MJ_QUERY_QUOTA              0x19
#define IRP_MJ_SET_QUOTA                0x1a
#define IRP_MJ_PNP                      0x1b
#define IRP_MJ_MAXIMUM_FUNCTION         0x1b

#define IRP_MN_QUERY_DIRECTORY          0x01
#define IRP_MN_NOTIFY_CHANGE_DIRECTORY  0x02
#define IRP_MN_USER_FS_REQUEST          0x00
#define IRP_MN_MOUNT_VOLUME             0x01
#define IRP_MN_VERIFY_VOLUME            0x02
#define IRP_MN_LOAD_FILE_SYSTEM         0x03
#define IRP_MN_TRACK_LINK               0x04
#define IRP_MN_LOCK                     0x01
#define IRP_MN_UNLOCK_SINGLE            0x02
#define IRP_MN_UNLOCK_ALL               0x03
#define IRP_MN_UNLOCK_ALL_BY_KEY        0x04
#define IRP_MN_NORMAL                   0x00
#define IRP_MN_DPC                      0x01
#define IRP_MN_MDL                      0x02
#define IRP_MN_COMPLETE                 0x04
#define IRP_MN_COMPRESSED               0x08
#define IRP_MN_MDL_DPC                  (IRP_MN_MDL | IRP_MN_DPC)
#define IRP_MN_COMPLETE_MDL             (IRP_MN_COMPLETE | IRP_MN_MDL)
#define IRP_MN_COMPLETE_MDL_DPC         (IRP_MN_COMPLETE_MDL | IRP_MN_DPC)
#define IRP_MN_SCSI_CLASS               0x01
#define IRP_MN_START_DEVICE                 0x00
#define IRP_MN_QUERY_REMOVE_DEVICE          0x01
#define IRP_MN_REMOVE_DEVICE                0x02
#define IRP_MN_CANCEL_REMOVE_DEVICE         0x03
#define IRP_MN_STOP_DEVICE                  0x04
#define IRP_MN_QUERY_STOP_DEVICE            0x05
#define IRP_MN_CANCEL_STOP_DEVICE           0x06
#define IRP_MN_QUERY_DEVICE_RELATIONS       0x07
#define IRP_MN_QUERY_INTERFACE              0x08
#define IRP_MN_QUERY_CAPABILITIES           0x09
#define IRP_MN_QUERY_RESOURCES              0x0A
#define IRP_MN_QUERY_RESOURCE_REQUIREMENTS  0x0B
#define IRP_MN_QUERY_DEVICE_TEXT            0x0C
#define IRP_MN_FILTER_RESOURCE_REQUIREMENTS 0x0D
#define IRP_MN_READ_CONFIG                  0x0F
#define IRP_MN_WRITE_CONFIG                 0x10
#define IRP_MN_EJECT                        0x11
#define IRP_MN_SET_LOCK                     0x12
#define IRP_MN_QUERY_ID                     0x13
#define IRP_MN_QUERY_PNP_DEVICE_STATE       0x14
#define IRP_MN_QUERY_BUS_INFORMATION        0x15
#define IRP_MN_DEVICE_USAGE_NOTIFICATION    0x16
#define IRP_MN_SURPRISE_REMOVAL             0x17
#define IRP_MN_QUERY_LEGACY_BUS_INFORMATION 0x18
#define IRP_MN_WAIT_WAKE                    0x00
#define IRP_MN_POWER_SEQUENCE               0x01
#define IRP_MN_SET_POWER                    0x02
#define IRP_MN_QUERY_POWER                  0x03
#define IRP_MN_QUERY_ALL_DATA               0x00
#define IRP_MN_QUERY_SINGLE_INSTANCE        0x01
#define IRP_MN_CHANGE_SINGLE_INSTANCE       0x02
#define IRP_MN_CHANGE_SINGLE_ITEM           0x03
#define IRP_MN_ENABLE_EVENTS                0x04
#define IRP_MN_DISABLE_EVENTS               0x05
#define IRP_MN_ENABLE_COLLECTION            0x06
#define IRP_MN_DISABLE_COLLECTION           0x07
#define IRP_MN_REGINFO                      0x08
#define IRP_MN_EXECUTE_METHOD               0x09

//
//  Lists of IRP names and FASTIO names
//

extern PWCHAR IrpNameList[IRP_MJ_MAXIMUM_FUNCTION+1];
extern PWCHAR FastIoNameList[FASTIO_MAX_OPERATION];


#ifdef __cplusplus
}
#endif

#endif __FILESPYLIB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\filespy\lib\fastionames.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    irpName.c

Abstract:

    This module contains functions used to generate names for IRPs

// @@BEGIN_DDKSPLIT
Author:

    Neal Christiansen (NealCH) 27-Sep-2000

// @@END_DDKSPLIT

Environment:

    User mode


// @@BEGIN_DDKSPLIT
Revision History:

// @@END_DDKSPLIT
--*/

#include <ntifs.h>
#include <stdio.h>
#include "filespyLib.h"


VOID
GetFastioName (
    IN FASTIO_TYPE FastIoCode,
    OUT PCHAR FastIoName
    )
/*++

Routine Description:

    This routine translates the given FastIO code into a printable string which
    is returned.  

Arguments:

    FastIoCode - the FastIO code to translate
    FastioName - a buffer at least OPERATION_NAME_BUFFER_SIZE characters long
                 that receives the fastIO name.

Return Value:

    None.

--*/
{
    PCHAR fastIoString;
    CHAR nameBuf[OPERATION_NAME_BUFFER_SIZE];

    switch (FastIoCode) {

        case CHECK_IF_POSSIBLE:
            fastIoString = "CHECK_IF_POSSIBLE";
            break;

        case READ:
            fastIoString = "READ";
            break;

        case WRITE:
            fastIoString = "WRITE";
            break;

        case QUERY_BASIC_INFO:
            fastIoString = "QUERY_BASIC_INFO";
            break;

        case QUERY_STANDARD_INFO:
            fastIoString = "QUERY_STANDARD_INFO";
            break;

        case LOCK:
            fastIoString = "LOCK";
            break;

        case UNLOCK_SINGLE:
            fastIoString = "UNLOCK_SINGLE";
            break;

        case UNLOCK_ALL:
            fastIoString = "UNLOCK_ALL";
            break;

        case UNLOCK_ALL_BY_KEY:
            fastIoString = "UNLOCK_ALL_BY_KEY";
            break;

        case DEVICE_CONTROL:
            fastIoString = "DEVICE_CONTROL";
            break;

        case DETACH_DEVICE:
            fastIoString = "DETACH_DEVICE";
            break;

        case QUERY_NETWORK_OPEN_INFO:
            fastIoString = "QUERY_NETWORK_OPEN_INFO";
            break;

        case MDL_READ:
            fastIoString = "MDL_READ";
            break;

        case MDL_READ_COMPLETE:
            fastIoString = "MDL_READ_COMPLETE";
            break;

        case MDL_WRITE:
            fastIoString = "MDL_WRITE";
            break;

        case MDL_WRITE_COMPLETE:
            fastIoString = "MDL_WRITE_COMPLETE";
            break;

        case READ_COMPRESSED:
            fastIoString = "READ_COMPRESSED";
            break;

        case WRITE_COMPRESSED:
            fastIoString = "WRITE_COMPRESSED";
            break;

        case MDL_READ_COMPLETE_COMPRESSED:
            fastIoString = "MDL_READ_COMPLETE_COMPRESSED";
            break;

        case PREPARE_MDL_WRITE:
            fastIoString = "PREPARE_MDL_WRITE";
            break;

        case MDL_WRITE_COMPLETE_COMPRESSED:
            fastIoString = "MDL_WRITE_COMPLETE_COMPRESSED";
            break;

        case QUERY_OPEN:
            fastIoString = "QUERY_OPEN";
            break;

        default:
            sprintf(nameBuf,"Unknown FastIO operation (%u)",FastIoCode);
            fastIoString = nameBuf;
    }

    strcpy(FastIoName,fastIoString);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\filespy\lib\fsfilteroperationnames.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    irpName.c

Abstract:

    This module contains functions used to generate names for IRPs

// @@BEGIN_DDKSPLIT
Author:

    Neal Christiansen (NealCH) 27-Sep-2000

// @@END_DDKSPLIT

Environment:

    User mode


// @@BEGIN_DDKSPLIT
Revision History:

    Molly Brown (mollybro)         21-May-2002
        Modify sample to make it support running on Windows 2000 or later if
        built in the latest build environment and allow it to be built in W2K 
        and later build environments.

// @@END_DDKSPLIT
--*/

#include <ntifs.h>
#include <stdio.h>
#include "filespyLib.h"

#if WINVER >= 0x0501

VOID
GetFsFilterOperationName (
    IN UCHAR FsFilterOperation,
    OUT PCHAR FsFilterOperationName
    )
/*++

Routine Description:

    This routine translates the given FsFilter Operation code into a printable
    string which is returned.  

Arguments:

    FsFilterOperation - the FsFilter operation code to translate
    FsFilterOperationName - a buffer at least OPERATION_NAME_BUFFER_SIZE
                characters long that receives the name.

Return Value:

    None.

--*/
{
    PCHAR operationString;
    CHAR nameBuf[OPERATION_NAME_BUFFER_SIZE];

    switch (FsFilterOperation) {

        case FS_FILTER_ACQUIRE_FOR_CC_FLUSH:
            operationString = "ACQUIRE_FOR_CC_FLUSH";
            break;

        case FS_FILTER_RELEASE_FOR_CC_FLUSH:
            operationString = "RELEASE_FOR_CC_FLUSH";
            break;

        case FS_FILTER_ACQUIRE_FOR_SECTION_SYNCHRONIZATION:
            operationString = "ACQUIRE_FOR_SECTION_SYNC";
            break;

        case FS_FILTER_RELEASE_FOR_SECTION_SYNCHRONIZATION:
            operationString = "RELEASE_FOR_SECTION_SYNC";
            break;

        case FS_FILTER_ACQUIRE_FOR_MOD_WRITE:
            operationString = "ACQUIRE_FOR_MOD_WRITE";
            break;

        case FS_FILTER_RELEASE_FOR_MOD_WRITE:
            operationString = "RELEASE_FOR_MOD_WRITE";
            break;

        default:
            sprintf(nameBuf,"Unknown FsFilter operation (%u)",FsFilterOperation);
            operationString = nameBuf;
    }

    strcpy(FsFilterOperationName,operationString);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\filespy\lib\irpnames.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    irpName.c

Abstract:

    This module contains functions used to generate names for IRPs

// @@BEGIN_DDKSPLIT
Author:

    Neal Christiansen (NealCH) 27-Sep-2000

// @@END_DDKSPLIT

Environment:

    User mode


// @@BEGIN_DDKSPLIT
Revision History:

    Molly Brown (mollybro)         21-May-2002
        Modify sample to make it support running on Windows 2000 or later if
        built in the latest build environment and allow it to be built in W2K 
        and later build environments.

// @@END_DDKSPLIT
--*/

#include <ntifs.h>
#include <stdio.h>
#include "filespyLib.h"

//
//  Globals
//

CHAR UnknownIrpMinor[] = "Unknown Irp minor code (%u)";


VOID
GetIrpName (
    IN UCHAR MajorCode,
    IN UCHAR MinorCode,
    IN ULONG FsctlCode,
    OUT PCHAR MajorCodeName,
    OUT PCHAR MinorCodeName
    )
/*++

Routine Description:

    This routine translates the given Irp codes into printable strings which
    are returned.  This guarantees to routine valid strings in each buffer.
    The MinorCode string may be a NULL string (not a null pointer).

Arguments:

    MajorCode - the IRP Major code of the operation
    MinorCode - the IRP Minor code of the operation
    FsctlCode - if this is an IRP_MJ_FILE_SYSTEM_CONTROL/IRP_MN_USER_FS_REQUEST
                operation then this is the FSCTL code whose name is also
                translated.  This name is returned as part of the MinorCode
                string.
    MajorCodeName - a string buffer at least OPERATION_NAME_BUFFER_SIZE
                characters long that receives the major code name.
    MinorCodeName - a string buffer at least OPERATION_NAME_BUFFER_SIZE
                characters long that receives the minor/fsctl code name.

Return Value:

    None.

--*/
{
    PCHAR irpMajorString;
    PCHAR irpMinorString = "";
    CHAR nameBuf[OPERATION_NAME_BUFFER_SIZE];

    switch (MajorCode) {
        case IRP_MJ_CREATE:
            irpMajorString = "IRP_MJ_CREATE";
            break;
        case IRP_MJ_CREATE_NAMED_PIPE:
            irpMajorString = "IRP_MJ_CREATE_NAMED_PIPE";
            break;
        case IRP_MJ_CLOSE:
            irpMajorString = "IRP_MJ_CLOSE";
            break;
        case IRP_MJ_READ:
            irpMajorString = "IRP_MJ_READ";
            switch (MinorCode) {
                case IRP_MN_NORMAL:
                    irpMinorString = "IRP_MN_NORMAL";
                    break;
                case IRP_MN_DPC:
                    irpMinorString = "IRP_MN_DPC";
                    break;
                case IRP_MN_MDL:
                    irpMinorString = "IRP_MN_MDL";
                    break;
                case IRP_MN_COMPLETE:
                    irpMinorString = "IRP_MN_COMPLETE";
                    break;
                case IRP_MN_COMPRESSED:
                    irpMinorString = "IRP_MN_COMPRESSED";
                    break;
                case IRP_MN_MDL_DPC:
                    irpMinorString = "IRP_MN_MDL_DPC";
                    break;
                case IRP_MN_COMPLETE_MDL:
                    irpMinorString = "IRP_MN_COMPLETE_MDL";
                    break;
                case IRP_MN_COMPLETE_MDL_DPC:
                    irpMinorString = "IRP_MN_COMPLETE_MDL_DPC";
                    break;
                default:
                    sprintf( nameBuf, UnknownIrpMinor, MinorCode );
                    irpMinorString = nameBuf;
            }
            break;

        case IRP_MJ_WRITE:
            irpMajorString = "IRP_MJ_WRITE";
            switch (MinorCode) {
                case IRP_MN_NORMAL:
                    irpMinorString = "IRP_MN_NORMAL";
                    break;
                case IRP_MN_DPC:
                    irpMinorString = "IRP_MN_DPC";
                    break;
                case IRP_MN_MDL:
                    irpMinorString = "IRP_MN_MDL";
                    break;
                case IRP_MN_COMPLETE:
                    irpMinorString = "IRP_MN_COMPLETE";
                    break;
                case IRP_MN_COMPRESSED:
                    irpMinorString = "IRP_MN_COMPRESSED";
                    break;
                case IRP_MN_MDL_DPC:
                    irpMinorString = "IRP_MN_MDL_DPC";
                    break;
                case IRP_MN_COMPLETE_MDL:
                    irpMinorString = "IRP_MN_COMPLETE_MDL";
                    break;
                case IRP_MN_COMPLETE_MDL_DPC:
                    irpMinorString = "IRP_MN_COMPLETE_MDL_DPC";
                    break;
                default:
                    sprintf(nameBuf,UnknownIrpMinor,MinorCode);
                    irpMinorString = nameBuf;
            }
            break;

        case IRP_MJ_QUERY_INFORMATION:
            irpMajorString = "IRP_MJ_QUERY_INFORMATION";
            break;
        case IRP_MJ_SET_INFORMATION:
            irpMajorString = "IRP_MJ_SET_INFORMATION";
            break;
        case IRP_MJ_QUERY_EA:
            irpMajorString = "IRP_MJ_QUERY_EA";
            break;
        case IRP_MJ_SET_EA:
            irpMajorString = "IRP_MJ_SET_EA";
            break;
        case IRP_MJ_FLUSH_BUFFERS:
            irpMajorString = "IRP_MJ_FLUSH_BUFFERS";
            break;
        case IRP_MJ_QUERY_VOLUME_INFORMATION:
            irpMajorString = "IRP_MJ_QUERY_VOLUME_INFORMATION";
            break;
        case IRP_MJ_SET_VOLUME_INFORMATION:
            irpMajorString = "IRP_MJ_SET_VOLUME_INFORMATION";
            break;
        case IRP_MJ_DIRECTORY_CONTROL:
            irpMajorString = "IRP_MJ_DIRECTORY_CONTROL";
            switch (MinorCode) {
                case IRP_MN_QUERY_DIRECTORY:
                    irpMinorString = "IRP_MN_QUERY_DIRECTORY";
                    break;
                case IRP_MN_NOTIFY_CHANGE_DIRECTORY:
                    irpMinorString = "IRP_MN_NOTIFY_CHANGE_DIRECTORY";
                    break;
                default:
                    sprintf(nameBuf,UnknownIrpMinor,MinorCode);
                    irpMinorString = nameBuf;
            }
            break;

        case IRP_MJ_FILE_SYSTEM_CONTROL:
            irpMajorString = "IRP_MJ_FILE_SYSTEM_CONTROL";
            switch (MinorCode) {
                case IRP_MN_USER_FS_REQUEST:
                    switch (FsctlCode) {
                        case FSCTL_REQUEST_OPLOCK_LEVEL_1:
                            irpMinorString = "FSCTL_REQUEST_OPLOCK_LEVEL_1";
                            break;
                        case FSCTL_REQUEST_OPLOCK_LEVEL_2:
                            irpMinorString = "FSCTL_REQUEST_OPLOCK_LEVEL_2";
                            break;
                        case FSCTL_REQUEST_BATCH_OPLOCK:
                            irpMinorString = "FSCTL_REQUEST_BATCH_OPLOCK";
                            break;
                        case FSCTL_OPLOCK_BREAK_ACKNOWLEDGE:
                            irpMinorString = "FSCTL_OPLOCK_BREAK_ACKNOWLEDGE";
                            break;
                        case FSCTL_OPBATCH_ACK_CLOSE_PENDING:
                            irpMinorString = "FSCTL_OPBATCH_ACK_CLOSE_PENDING";
                            break;
                        case FSCTL_OPLOCK_BREAK_NOTIFY:
                            irpMinorString = "FSCTL_OPLOCK_BREAK_NOTIFY";
                            break;
                        case FSCTL_LOCK_VOLUME:
                            irpMinorString = "FSCTL_LOCK_VOLUME";
                            break;
                        case FSCTL_UNLOCK_VOLUME:
                            irpMinorString = "FSCTL_UNLOCK_VOLUME";
                            break;
                        case FSCTL_DISMOUNT_VOLUME:
                            irpMinorString = "FSCTL_DISMOUNT_VOLUME";
                            break;
                        case FSCTL_IS_VOLUME_MOUNTED:
                            irpMinorString = "FSCTL_IS_VOLUME_MOUNTED";
                            break;
                        case FSCTL_IS_PATHNAME_VALID:
                            irpMinorString = "FSCTL_IS_PATHNAME_VALID";
                            break;
                        case FSCTL_MARK_VOLUME_DIRTY:
                            irpMinorString = "FSCTL_MARK_VOLUME_DIRTY";
                            break;
                        case FSCTL_QUERY_RETRIEVAL_POINTERS:
                            irpMinorString = "FSCTL_QUERY_RETRIEVAL_POINTERS";
                            break;
                        case FSCTL_GET_COMPRESSION:
                            irpMinorString = "FSCTL_GET_COMPRESSION";
                            break;
                        case FSCTL_SET_COMPRESSION:
                            irpMinorString = "FSCTL_SET_COMPRESSION";
                            break;
                        case FSCTL_MARK_AS_SYSTEM_HIVE:
                            irpMinorString = "FSCTL_MARK_AS_SYSTEM_HIVE";
                            break;
                        case FSCTL_OPLOCK_BREAK_ACK_NO_2:
                            irpMinorString = "FSCTL_OPLOCK_BREAK_ACK_NO_2";
                            break;
                        case FSCTL_INVALIDATE_VOLUMES:
                            irpMinorString = "FSCTL_INVALIDATE_VOLUMES";
                            break;
                        case FSCTL_QUERY_FAT_BPB:
                            irpMinorString = "FSCTL_QUERY_FAT_BPB";
                            break;
                        case FSCTL_REQUEST_FILTER_OPLOCK:
                            irpMinorString = "FSCTL_REQUEST_FILTER_OPLOCK";
                            break;
                        case FSCTL_FILESYSTEM_GET_STATISTICS:
                            irpMinorString = "FSCTL_FILESYSTEM_GET_STATISTICS";
                            break;
                        case FSCTL_GET_NTFS_VOLUME_DATA:
                            irpMinorString = "FSCTL_GET_NTFS_VOLUME_DATA";
                            break;
                        case FSCTL_GET_NTFS_FILE_RECORD:
                            irpMinorString = "FSCTL_GET_NTFS_FILE_RECORD";
                            break;
                        case FSCTL_GET_VOLUME_BITMAP:
                            irpMinorString = "FSCTL_GET_VOLUME_BITMAP";
                            break;
                        case FSCTL_GET_RETRIEVAL_POINTERS:
                            irpMinorString = "FSCTL_GET_RETRIEVAL_POINTERS";
                            break;
                        case FSCTL_MOVE_FILE:
                            irpMinorString = "FSCTL_MOVE_FILE";
                            break;
                        case FSCTL_IS_VOLUME_DIRTY:
                            irpMinorString = "FSCTL_IS_VOLUME_DIRTY";
                            break;
                        case FSCTL_ALLOW_EXTENDED_DASD_IO:
                            irpMinorString = "FSCTL_ALLOW_EXTENDED_DASD_IO";
                            break;
                        case FSCTL_FIND_FILES_BY_SID:
                            irpMinorString = "FSCTL_FIND_FILES_BY_SID";
                            break;
                        case FSCTL_SET_OBJECT_ID:
                            irpMinorString = "FSCTL_SET_OBJECT_ID";
                            break;
                        case FSCTL_GET_OBJECT_ID:
                            irpMinorString = "FSCTL_GET_OBJECT_ID";
                            break;
                        case FSCTL_DELETE_OBJECT_ID:
                            irpMinorString = "FSCTL_DELETE_OBJECT_ID";
                            break;
                        case FSCTL_SET_REPARSE_POINT:
                            irpMinorString = "FSCTL_SET_REPARSE_POINT";
                            break;
                        case FSCTL_GET_REPARSE_POINT:
                            irpMinorString = "FSCTL_GET_REPARSE_POINT";
                            break;
                        case FSCTL_DELETE_REPARSE_POINT:
                            irpMinorString = "FSCTL_DELETE_REPARSE_POINT";
                            break;
                        case FSCTL_ENUM_USN_DATA:
                            irpMinorString = "FSCTL_ENUM_USN_DATA";
                            break;
                        case FSCTL_SECURITY_ID_CHECK:
                            irpMinorString = "FSCTL_SECURITY_ID_CHECK";
                            break;
                        case FSCTL_READ_USN_JOURNAL:
                            irpMinorString = "FSCTL_READ_USN_JOURNAL";
                            break;
                        case FSCTL_SET_OBJECT_ID_EXTENDED:
                            irpMinorString = "FSCTL_SET_OBJECT_ID_EXTENDED";
                            break;
                        case FSCTL_CREATE_OR_GET_OBJECT_ID:
                            irpMinorString = "FSCTL_CREATE_OR_GET_OBJECT_ID";
                            break;
                        case FSCTL_SET_SPARSE:
                            irpMinorString = "FSCTL_SET_SPARSE";
                            break;
                        case FSCTL_SET_ZERO_DATA:
                            irpMinorString = "FSCTL_SET_ZERO_DATA";
                            break;
                        case FSCTL_QUERY_ALLOCATED_RANGES:
                            irpMinorString = "FSCTL_QUERY_ALLOCATED_RANGES";
                            break;
                        case FSCTL_SET_ENCRYPTION:
                            irpMinorString = "FSCTL_SET_ENCRYPTION";
                            break;
                        case FSCTL_ENCRYPTION_FSCTL_IO:
                            irpMinorString = "FSCTL_ENCRYPTION_FSCTL_IO";
                            break;
                        case FSCTL_WRITE_RAW_ENCRYPTED:
                            irpMinorString = "FSCTL_WRITE_RAW_ENCRYPTED";
                            break;
                        case FSCTL_READ_RAW_ENCRYPTED:
                            irpMinorString = "FSCTL_READ_RAW_ENCRYPTED";
                            break;
                        case FSCTL_CREATE_USN_JOURNAL:
                            irpMinorString = "FSCTL_CREATE_USN_JOURNAL";
                            break;
                        case FSCTL_READ_FILE_USN_DATA:
                            irpMinorString = "FSCTL_READ_FILE_USN_DATA";
                            break;
                        case FSCTL_WRITE_USN_CLOSE_RECORD:
                            irpMinorString = "FSCTL_WRITE_USN_CLOSE_RECORD";
                            break;
                        case FSCTL_EXTEND_VOLUME:
                            irpMinorString = "FSCTL_EXTEND_VOLUME";
                            break;
                        case FSCTL_QUERY_USN_JOURNAL:
                            irpMinorString = "FSCTL_QUERY_USN_JOURNAL";
                            break;
                        case FSCTL_DELETE_USN_JOURNAL:
                            irpMinorString = "FSCTL_DELETE_USN_JOURNAL";
                            break;
                        case FSCTL_MARK_HANDLE:
                            irpMinorString = "FSCTL_MARK_HANDLE";
                            break;
                        case FSCTL_SIS_COPYFILE:
                            irpMinorString = "FSCTL_SIS_COPYFILE";
                            break;
                        case FSCTL_SIS_LINK_FILES:
                            irpMinorString = "FSCTL_SIS_LINK_FILES";
                            break;
                        case FSCTL_HSM_MSG:
                            irpMinorString = "FSCTL_HSM_MSG";
                            break;
                        case FSCTL_HSM_DATA:
                            irpMinorString = "FSCTL_HSM_DATA";
                            break;
                        case FSCTL_RECALL_FILE:
                            irpMinorString = "FSCTL_RECALL_FILE";
                            break;
#if WINVER >= 0x0501                            
                        case FSCTL_READ_FROM_PLEX:
                            irpMinorString = "FSCTL_READ_FROM_PLEX";
                            break;
                        case FSCTL_FILE_PREFETCH:
                            irpMinorString = "FSCTL_FILE_PREFETCH";
                            break;
#endif                            
                        default:
                            sprintf(nameBuf,"Unknown FSCTL (%u)",MinorCode);
                            irpMinorString = nameBuf;
                            break;
                    }

                    sprintf(nameBuf,"%s (USER)",irpMinorString);
                    irpMinorString = nameBuf;
                    break;

                case IRP_MN_MOUNT_VOLUME:
                    irpMinorString = "IRP_MN_MOUNT_VOLUME";
                    break;
                case IRP_MN_VERIFY_VOLUME:
                    irpMinorString = "IRP_MN_VERIFY_VOLUME";
                    break;
                case IRP_MN_LOAD_FILE_SYSTEM:
                    irpMinorString = "IRP_MN_LOAD_FILE_SYSTEM";
                    break;
                case IRP_MN_TRACK_LINK:
                    irpMinorString = "IRP_MN_TRACK_LINK";
                    break;
                default:
                    sprintf(nameBuf,UnknownIrpMinor,MinorCode);
                    irpMinorString = nameBuf;
            }
            break;

        case IRP_MJ_DEVICE_CONTROL:
            irpMajorString = "IRP_MJ_DEVICE_CONTROL";
            switch (MinorCode) {
                case 0:
                    irpMinorString = "User request";
                    break;
                case IRP_MN_SCSI_CLASS:
                    irpMinorString = "IRP_MN_SCSI_CLASS";
                    break;
                default:
                    sprintf(nameBuf,UnknownIrpMinor,MinorCode);
                    irpMinorString = nameBuf;
            }
            break;

        case IRP_MJ_INTERNAL_DEVICE_CONTROL:
            irpMajorString = "IRP_MJ_INTERNAL_DEVICE_CONTROL";
            break;
        case IRP_MJ_SHUTDOWN:
            irpMajorString = "IRP_MJ_SHUTDOWN";
            break;
        case IRP_MJ_LOCK_CONTROL:
            irpMajorString = "IRP_MJ_LOCK_CONTROL";
            switch (MinorCode) {
                case IRP_MN_LOCK:
                    irpMinorString = "IRP_MN_LOCK";
                    break;
                case IRP_MN_UNLOCK_SINGLE:
                    irpMinorString = "IRP_MN_UNLOCK_SINGLE";
                    break;
                case IRP_MN_UNLOCK_ALL:
                    irpMinorString = "IRP_MN_UNLOCK_ALL";
                    break;
                case IRP_MN_UNLOCK_ALL_BY_KEY:
                    irpMinorString = "IRP_MN_UNLOCK_ALL_BY_KEY";
                    break;
                default:
                    sprintf(nameBuf,UnknownIrpMinor,MinorCode);
                    irpMinorString = nameBuf;
            }
            break;

        case IRP_MJ_CLEANUP:
            irpMajorString = "IRP_MJ_CLEANUP";
            break;
        case IRP_MJ_CREATE_MAILSLOT:
            irpMajorString = "IRP_MJ_CREATE_MAILSLOT";
            break;
        case IRP_MJ_QUERY_SECURITY:
            irpMajorString = "IRP_MJ_QUERY_SECURITY";
            break;
        case IRP_MJ_SET_SECURITY:
            irpMajorString = "IRP_MJ_SET_SECURITY";
            break;
        case IRP_MJ_POWER:
            irpMajorString = "IRP_MJ_POWER";
            switch (MinorCode) {
                case IRP_MN_WAIT_WAKE:
                    irpMinorString = "IRP_MN_WAIT_WAKE";
                    break;
                case IRP_MN_POWER_SEQUENCE:
                    irpMinorString = "IRP_MN_POWER_SEQUENCE";
                    break;
                case IRP_MN_SET_POWER:
                    irpMinorString = "IRP_MN_SET_POWER";
                    break;
                case IRP_MN_QUERY_POWER:
                    irpMinorString = "IRP_MN_QUERY_POWER";
                    break;
                default :
                    sprintf(nameBuf,UnknownIrpMinor,MinorCode);
                    irpMinorString = nameBuf;
            }
            break;

        case IRP_MJ_SYSTEM_CONTROL:
            irpMajorString = "IRP_MJ_SYSTEM_CONTROL";
            switch (MinorCode) {
                case IRP_MN_QUERY_ALL_DATA:
                    irpMinorString = "IRP_MN_QUERY_ALL_DATA";
                    break;
                case IRP_MN_QUERY_SINGLE_INSTANCE:
                    irpMinorString = "IRP_MN_QUERY_SINGLE_INSTANCE";
                    break;
                case IRP_MN_CHANGE_SINGLE_INSTANCE:
                    irpMinorString = "IRP_MN_CHANGE_SINGLE_INSTANCE";
                    break;
                case IRP_MN_CHANGE_SINGLE_ITEM:
                    irpMinorString = "IRP_MN_CHANGE_SINGLE_ITEM";
                    break;
                case IRP_MN_ENABLE_EVENTS:
                    irpMinorString = "IRP_MN_ENABLE_EVENTS";
                    break;
                case IRP_MN_DISABLE_EVENTS:
                    irpMinorString = "IRP_MN_DISABLE_EVENTS";
                    break;
                case IRP_MN_ENABLE_COLLECTION:
                    irpMinorString = "IRP_MN_ENABLE_COLLECTION";
                    break;
                case IRP_MN_DISABLE_COLLECTION:
                    irpMinorString = "IRP_MN_DISABLE_COLLECTION";
                    break;
                case IRP_MN_REGINFO:
                    irpMinorString = "IRP_MN_REGINFO";
                    break;
                case IRP_MN_EXECUTE_METHOD:
                    irpMinorString = "IRP_MN_EXECUTE_METHOD";
                    break;
                default :
                    sprintf(nameBuf,UnknownIrpMinor,MinorCode);
                    irpMinorString = nameBuf;
            }
            break;

        case IRP_MJ_DEVICE_CHANGE:
            irpMajorString = "IRP_MJ_DEVICE_CHANGE";
            break;
        case IRP_MJ_QUERY_QUOTA:
            irpMajorString = "IRP_MJ_QUERY_QUOTA";
            break;
        case IRP_MJ_SET_QUOTA:
            irpMajorString = "IRP_MJ_SET_QUOTA";
            break;
        case IRP_MJ_PNP:
            irpMajorString = "IRP_MJ_PNP";
            switch (MinorCode) {
                case IRP_MN_START_DEVICE:
                    irpMinorString = "IRP_MN_START_DEVICE";
                    break;
                case IRP_MN_QUERY_REMOVE_DEVICE:
                    irpMinorString = "IRP_MN_QUERY_REMOVE_DEVICE";
                    break;
                case IRP_MN_REMOVE_DEVICE:
                    irpMinorString = "IRP_MN_REMOVE_DEVICE";
                    break;
                case IRP_MN_CANCEL_REMOVE_DEVICE:
                    irpMinorString = "IRP_MN_CANCEL_REMOVE_DEVICE";
                    break;
                case IRP_MN_STOP_DEVICE:
                    irpMinorString = "IRP_MN_STOP_DEVICE";
                    break;
                case IRP_MN_QUERY_STOP_DEVICE:
                    irpMinorString = "IRP_MN_QUERY_STOP_DEVICE";
                    break;
                case IRP_MN_CANCEL_STOP_DEVICE:
                    irpMinorString = "IRP_MN_CANCEL_STOP_DEVICE";
                    break;
                case IRP_MN_QUERY_DEVICE_RELATIONS:
                    irpMinorString = "IRP_MN_QUERY_DEVICE_RELATIONS";
                    break;
                case IRP_MN_QUERY_INTERFACE:
                    irpMinorString = "IRP_MN_QUERY_INTERFACE";
                    break;
                case IRP_MN_QUERY_CAPABILITIES:
                    irpMinorString = "IRP_MN_QUERY_CAPABILITIES";
                    break;
                case IRP_MN_QUERY_RESOURCES:
                    irpMinorString = "IRP_MN_QUERY_RESOURCES";
                    break;
                case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
                    irpMinorString = "IRP_MN_QUERY_RESOURCE_REQUIREMENTS";
                    break;
                case IRP_MN_QUERY_DEVICE_TEXT:
                    irpMinorString = "IRP_MN_QUERY_DEVICE_TEXT";
                    break;
                case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
                    irpMinorString = "IRP_MN_FILTER_RESOURCE_REQUIREMENTS";
                    break;
                case IRP_MN_READ_CONFIG:
                    irpMinorString = "IRP_MN_READ_CONFIG";
                    break;
                case IRP_MN_WRITE_CONFIG:
                    irpMinorString = "IRP_MN_WRITE_CONFIG";
                    break;
                case IRP_MN_EJECT:
                    irpMinorString = "IRP_MN_EJECT";
                    break;
                case IRP_MN_SET_LOCK:
                    irpMinorString = "IRP_MN_SET_LOCK";
                    break;
                case IRP_MN_QUERY_ID:
                    irpMinorString = "IRP_MN_QUERY_ID";
                    break;
                case IRP_MN_QUERY_PNP_DEVICE_STATE:
                    irpMinorString = "IRP_MN_QUERY_PNP_DEVICE_STATE";
                    break;
                case IRP_MN_QUERY_BUS_INFORMATION:
                    irpMinorString = "IRP_MN_QUERY_BUS_INFORMATION";
                    break;
                case IRP_MN_DEVICE_USAGE_NOTIFICATION:
                    irpMinorString = "IRP_MN_DEVICE_USAGE_NOTIFICATION";
                    break;
                case IRP_MN_SURPRISE_REMOVAL:
                    irpMinorString = "IRP_MN_SURPRISE_REMOVAL";
                    break;
                case IRP_MN_QUERY_LEGACY_BUS_INFORMATION:
                    irpMinorString = "IRP_MN_QUERY_LEGACY_BUS_INFORMATION";
                    break;
                default :
                    sprintf(nameBuf,UnknownIrpMinor,MinorCode);
                    irpMinorString = nameBuf;
            }
            break;

        default:
            sprintf(nameBuf,"Unknown Irp major code (%u)",MajorCode);
            irpMajorString = nameBuf;
    }

    strcpy(MajorCodeName,irpMajorString);
    strcpy(MinorCodeName,irpMinorString);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\filespy\lib\namelists.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    irpNameList.c

Abstract:

    This module contains an array of unicode IRP names.

// @@BEGIN_DDKSPLIT
Author:

    Neal Christiansen (NealCH) 29-Sep-2000

// @@END_DDKSPLIT

Environment:

    User mode


// @@BEGIN_DDKSPLIT
Revision History:

// @@END_DDKSPLIT
--*/

#include <ntifs.h>
#include "filespyLib.h"

//
//  List of unicode irp names
//

PWCHAR IrpNameList[IRP_MJ_MAXIMUM_FUNCTION+1] = 
{
    L"IRP_MJ_CREATE",
    L"IRP_MJ_CREATE_NAMED_PIPE",
    L"IRP_MJ_CLOSE",
    L"IRP_MJ_READ",
    L"IRP_MJ_WRITE",
    L"IRP_MJ_QUERY_INFORMATION",
    L"IRP_MJ_SET_INFORMATION",
    L"IRP_MJ_QUERY_EA",
    L"IRP_MJ_SET_EA",
    L"IRP_MJ_FLUSH_BUFFERS",
    L"IRP_MJ_QUERY_VOLUME_INFORMATION",
    L"IRP_MJ_SET_VOLUME_INFORMATION",
    L"IRP_MJ_DIRECTORY_CONTROL",
    L"IRP_MJ_FILE_SYSTEM_CONTROL",
    L"IRP_MJ_DEVICE_CONTROL",
    L"IRP_MJ_INTERNAL_DEVICE_CONTROL",
    L"IRP_MJ_SHUTDOWN",
    L"IRP_MJ_LOCK_CONTROL",
    L"IRP_MJ_CLEANUP",
    L"IRP_MJ_CREATE_MAILSLOT",
    L"IRP_MJ_QUERY_SECURITY",
    L"IRP_MJ_SET_SECURITY",
    L"IRP_MJ_POWER",
    L"IRP_MJ_SYSTEM_CONTROL",
    L"IRP_MJ_DEVICE_CHANGE",
    L"IRP_MJ_QUERY_QUOTA",
    L"IRP_MJ_SET_QUOTA",
    L"IRP_MJ_PNP"
};


PWCHAR FastIoNameList[FASTIO_MAX_OPERATION] =
{
    L"CHECK_IF_POSSIBLE",
    L"READ",
    L"WRITE",
    L"QUERY_BASIC_INFO",
    L"QUERY_STANDARD_INFO",
    L"LOCK",
    L"UNLOCK_SINGLE",
    L"UNLOCK_ALL",
    L"UNLOCK_ALL_BY_KEY",
    L"DEVICE_CONTROL",
    L"DETACH_DEVICE",
    L"QUERY_NETWORK_OPEN_INFO",
    L"MDL_READ",
    L"MDL_READ_COMPLETE",
    L"MDL_WRITE",
    L"MDL_WRITE_COMPLETE",
    L"READ_COMPRESSED",
    L"WRITE_COMPRESSED",
    L"MDL_READ_COMPLETE_COMPRESSED",
    L"PREPARE_MDL_WRITE",
    L"MDL_WRITE_COMPLETE_COMPRESSED",
    L"QUERY_OPEN_STRING",
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\filespy\user\fspylog.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    fspyLog.c

Abstract:

    This module contains functions used to retrieve and see the log records
    recorded by filespy.sys.

Environment:

    User mode

// @@BEGIN_DDKSPLIT
Author:

    Molly Brown (MollyBro) 21-Apr-1999

Revision History:

    Molly Brown (mollybro)         21-May-2002
        Modify sample to make it support running on Windows 2000 or later if
        built in the latest build environment and allow it to be built in W2K 
        and later build environments.

// @@END_DDKSPLIT
--*/
#include <stdio.h>
#include <windows.h>
#include <stdlib.h>
#include <winioctl.h>
#include "fspyLog.h"
#include "filespyLib.h"

#define TIME_BUFFER_LENGTH 20
#define TIME_ERROR         L"time error"

#define FlagOn(F,SF) ( \
    (((F) & (SF)))     \
)

DWORD WINAPI 
RetrieveLogRecords (
    LPVOID lpParameter
)
{
    PLOG_CONTEXT context = (PLOG_CONTEXT)lpParameter;
    CHAR buffer[BUFFER_SIZE];
    DWORD bytesReturned = 0;
    BOOL bResult;
    DWORD result;
    PLOG_RECORD pLogRecord;

    printf("Log: Starting up\n");

    while (TRUE) {

        //
        // Check to see if we should shut down
        //

        if (context->CleaningUp) {

            break;
        }

        //
        // Request log data from filespy
        //

        bResult = DeviceIoControl( context->Device,
                                   FILESPY_GetLog,
                                   NULL,
                                   0,
                                   buffer,
                                   BUFFER_SIZE,
                                   &bytesReturned,
                                   NULL);

        if (!bResult) {

            result = GetLastError();
            printf("ERROR controlling device: 0x%x\n", result);
        }

        //
        // Buffer is filled with a series of LOG_RECORD structures, one
        // right after another.  Each LOG_RECORD says how long it is, so
        // we know where the next LOG_RECORD begins.
        //

        pLogRecord = (PLOG_RECORD) buffer;

        //
        // Logic to write record to screen and/or file
        //

        while ((BYTE *) pLogRecord < buffer + bytesReturned) {

            PRECORD_IRP pRecordIrp;
            PRECORD_FASTIO pRecordFastIo;
#if WINVER >= 0x0501            
            PRECORD_FS_FILTER_OPERATION pRecordFsFilterOp;
#endif
            ULONG nameLength;

            //
            //  Calculate the length of the name in the log record.
            //
            
            nameLength = wcslen( pLogRecord->Name ) * sizeof( WCHAR );

            //
            // A LOG_RECORD could have Irp or FastIo data in it.  This
            // is denoted in the low-order byte of the RecordType flag.
            //

            switch (GET_RECORD_TYPE(pLogRecord)) {
            case RECORD_TYPE_IRP:

                //
                // We've got an Irp record, so output this data correctly.
                //
                pRecordIrp = &(pLogRecord->Record.RecordIrp);

                if (context->LogToScreen) {

                    IrpScreenDump( pLogRecord->SequenceNumber,
                                   pLogRecord->Name,
                                   nameLength,
                                   pRecordIrp,
                                   context->VerbosityFlags);
                }

                if (context->LogToFile) {

                    IrpFileDump( pLogRecord->SequenceNumber,
                                 pLogRecord->Name,
                                 nameLength,
                                 pRecordIrp, 
                                 context->OutputFile,
                                 context->VerbosityFlags);
                }
                break;

            case RECORD_TYPE_FASTIO:

                //
                // We've got a FastIo record, so output this data correctly.
                //

                pRecordFastIo = &(pLogRecord->Record.RecordFastIo);

                if (context->LogToScreen) {

                    FastIoScreenDump( pLogRecord->SequenceNumber,
                                      pLogRecord->Name,
                                      nameLength,
                                      pRecordFastIo);
                }

                if (context->LogToFile) {

                    FastIoFileDump( pLogRecord->SequenceNumber,
                                    pLogRecord->Name,
                                    nameLength,
                                    pRecordFastIo,
                                    context->OutputFile);
                }
                break;

#if WINVER >= 0x0501 /* See comment in DriverEntry */
            case RECORD_TYPE_FS_FILTER_OP:

                //
                //  We've got a FsFilter operation record, so output this
                //  data correctly.
                //

                pRecordFsFilterOp = &(pLogRecord->Record.RecordFsFilterOp);

                if (context->LogToScreen) {

                    FsFilterOperationScreenDump( pLogRecord->SequenceNumber,
                                                 pLogRecord->Name,
                                                 nameLength,
                                                 pRecordFsFilterOp );

                }

                if (context->LogToFile) {

                    FsFilterOperationFileDump( pLogRecord->SequenceNumber,
                                               pLogRecord->Name,
                                               nameLength,
                                               pRecordFsFilterOp,
                                               context->OutputFile );
                }
                break;
#endif                
                
            default:

                printf("FileSpy:  Unknown log record type\n");
            }

            //
            // The RecordType could also designate that we are out of memory
            // or hit our program defined memory limit, so check for these
            // cases.
            // 

            if (pLogRecord->RecordType & RECORD_TYPE_OUT_OF_MEMORY) {

                if (context->LogToScreen) {

                    printf("M %08X SYSTEM OUT OF MEMORY\n", pLogRecord->SequenceNumber);
                }

                if (context->LogToFile) {

                    fprintf(context->OutputFile, "M:\t%u", pLogRecord->SequenceNumber);
                }

            } else if (pLogRecord->RecordType & RECORD_TYPE_EXCEED_MEMORY_ALLOWANCE) {

                if (context->LogToScreen) {

                    printf("M %08X EXCEEDED MEMORY ALLOWANCE\n", pLogRecord->SequenceNumber);
                }

                if (context->LogToFile) {

                    fprintf(context->OutputFile, "M:\t%u", pLogRecord->SequenceNumber);
                }
            }

            //
            // Move to next LOG_RECORD
            //

            pLogRecord = (PLOG_RECORD) (((BYTE *) pLogRecord) + pLogRecord->Length);
        }

        if (bytesReturned == 0) {

            Sleep( 500 );
        }
    }

    printf("Log: Shutting down\n");
    ReleaseSemaphore(context->ShutDown, 1, NULL);
    printf("Log: All done\n");
    return 0;
}

VOID
PrintIrpCode (
    UCHAR MajorCode,
    UCHAR MinorCode,
    ULONG FsControlCode,
    FILE *OutputFile,
    BOOLEAN PrintMajorCode
    )
{
    CHAR irpMajorString[OPERATION_NAME_BUFFER_SIZE];
    CHAR irpMinorString[OPERATION_NAME_BUFFER_SIZE];
    CHAR formatBuf[OPERATION_NAME_BUFFER_SIZE*2];


    GetIrpName(MajorCode,MinorCode,FsControlCode,irpMajorString,irpMinorString);

    if (OutputFile) {

        sprintf(formatBuf, "%s  %s", irpMajorString, irpMinorString);
        fprintf(OutputFile, "\t%-50s", formatBuf);

    } else {

        if (PrintMajorCode) {

            printf("%-31s ", irpMajorString);

        } else {

            if (irpMinorString[0] != 0) {

                printf("                                                   %-35s\n",
                        irpMinorString);
            }
        }
    }
}

VOID
PrintFastIoType (
    FASTIO_TYPE Code,
    FILE *OutputFile
    )
{
    CHAR outputString[OPERATION_NAME_BUFFER_SIZE];

    GetFastioName(Code,outputString);

    if (OutputFile) {

        fprintf(OutputFile, "\t%-50s", outputString);

    } else {

        printf("%-31s ", outputString);
    }
}

#if WINVER >= 0x0501 /* See comment in DriverEntry */

VOID
PrintFsFilterOperation (
    UCHAR Operation,
    FILE *OutputFile
    )
{
    CHAR outputString[OPERATION_NAME_BUFFER_SIZE];

    GetFsFilterOperationName(Operation,outputString);

    if (OutputFile) {
    
        fprintf( OutputFile, "\t%-50s", outputString );
        
    } else {

        printf( "%-31s ", outputString );
    }
}

#endif

ULONG
FormatSystemTime (
    SYSTEMTIME *SystemTime,
    PWCHAR Buffer,
    ULONG BufferLength
)
/*++
Routine Name:

    FormatSystemTime

Routine Description:

    Formats the values in a SystemTime struct into the buffer
    passed in.  The resulting string is NULL terminated.  The format
    for the time is:
        hours:minutes:seconds:milliseconds

Arguments:

    SystemTime - the struct to format
    Buffer - the buffer to place the formatted time in
    BufferLength - the size of the buffer in characters

Return Value:

    The number of characters returned in Buffer.

--*/
{
    PWCHAR writePosition;
    ULONG returnLength = 0;

    writePosition = Buffer;

    if (BufferLength < TIME_BUFFER_LENGTH) {

        //
        // Buffer is too short so exit
        //

        return 0;
    }

    returnLength = swprintf( Buffer,
                             L"%02d:%02d:%02d:%03d",
                             SystemTime->wHour,
                             SystemTime->wMinute,
                             SystemTime->wSecond,
                             SystemTime->wMilliseconds);

    return returnLength;
}

VOID
IrpFileDump (
    ULONG SequenceNumber,
    PWCHAR Name,
    ULONG NameLength,
    PRECORD_IRP RecordIrp,
    FILE *File,
    ULONG VerbosityFlags
)
/*++
Routine Name:

    IrpFileDump

Routine Description:

    Prints a Irp log record to the specified file.  The output is in a tab
    delimited format with the fields in the following order:

    SequenceNumber, OriginatingTime, CompletionTime, IrpMajor, IrpMinor,
    IrpFlags, NoCache, Paging I/O, Synchronous, Synchronous paging, FileName,
    ReturnStatus, FileName


Arguments:

    SequenceNumber - the sequence number for this log record
    Name - the name of the file that this Irp relates to
    NameLength - the length of Name in bytes
    RecordIrp - the Irp record to print
    File - the file to print to

Return Value:

    None.

--*/
{
    FILETIME    localTime;
    SYSTEMTIME  systemTime;
    WCHAR       time[TIME_BUFFER_LENGTH];

    fprintf(File, "I\t%08X", SequenceNumber);

    //
    // Convert originating time
    //

    FileTimeToLocalFileTime( (FILETIME *)&(RecordIrp->OriginatingTime), &localTime );
    FileTimeToSystemTime( &localTime, &systemTime );

    if (FormatSystemTime( &systemTime, time, TIME_BUFFER_LENGTH )) {

        fprintf( File, "\t%-12S", time );

    } else {

        fprintf( File, "\t%-12S", TIME_ERROR );
    }

    //
    // Convert completion time
    //

    FileTimeToLocalFileTime( (FILETIME *)&(RecordIrp->CompletionTime), &localTime );
    FileTimeToSystemTime( &localTime, &systemTime );
    if (FormatSystemTime( &systemTime, time, TIME_BUFFER_LENGTH )) {

        fprintf( File, "\t%-12S", time );

    } else {

        fprintf( File, "\t%-12S", TIME_ERROR );
    }

    fprintf( File, "\t%8x.%-4x ", RecordIrp->ProcessId, RecordIrp->ThreadId );

    PrintIrpCode( RecordIrp->IrpMajor, RecordIrp->IrpMinor, (ULONG)(ULONG_PTR)RecordIrp->Argument3, File, TRUE );

    fprintf( File, "\t%p", (PVOID)RecordIrp->DeviceObject );
    fprintf( File, "\t%p", (PVOID)RecordIrp->FileObject );
    fprintf( File, "\t%08lx:%08lx", RecordIrp->ReturnStatus, RecordIrp->ReturnInformation );

    //
    // Interpret set flags
    //

    fprintf( File, "\t%08lx ", RecordIrp->IrpFlags );
    fprintf( File, "%s", (RecordIrp->IrpFlags & IRP_NOCACHE) ? "N":"-" );
    fprintf( File, "%s", (RecordIrp->IrpFlags & IRP_PAGING_IO) ? "P":"-" );
    fprintf( File, "%s", (RecordIrp->IrpFlags & IRP_SYNCHRONOUS_API) ? "S":"-" );
    fprintf( File, "%s", (RecordIrp->IrpFlags & IRP_SYNCHRONOUS_PAGING_IO) ? "Y":"-" );

    if (FlagOn( VerbosityFlags, FS_VF_DUMP_PARAMETERS )) {

        fprintf( File,
                 "%p %p %p %p ", 
                 RecordIrp->Argument1,
                 RecordIrp->Argument2,
                 RecordIrp->Argument3,
                 RecordIrp->Argument4 );
        
        if (IRP_MJ_CREATE == RecordIrp->IrpMajor) {

            fprintf( File, "DesiredAccess->%08lx ", RecordIrp->DesiredAccess );
        }
    }

    fprintf( File, "\t%.*S", NameLength/sizeof(WCHAR), Name );
    fprintf( File, "\n" );
}

VOID
IrpScreenDump (
    ULONG SequenceNumber,
    PWCHAR Name,
    ULONG NameLength,
    PRECORD_IRP RecordIrp,
    ULONG VerbosityFlags
)
/*++
Routine Name:

    IrpScreenDump

Routine Description:

    Prints a Irp log record to the screen in the following order:
    SequenceNumber, OriginatingTime, CompletionTime, IrpMajor, IrpMinor,
    IrpFlags, NoCache, Paging I/O, Synchronous, Synchronous paging,
    FileName, ReturnStatus, FileName

Arguments:

    SequenceNumber - the sequence number for this log record
    Name - the file name to which this Irp relates
    NameLength - the length of Name in bytes
    RecordIrp - the Irp record to print

Return Value:

    None.

--*/
{
    FILETIME localTime;
    SYSTEMTIME systemTime;
    WCHAR time[TIME_BUFFER_LENGTH];

    printf( "I %08X ", SequenceNumber );

    //
    // Convert originating time
    //

    FileTimeToLocalFileTime( (FILETIME *)&(RecordIrp->OriginatingTime), &localTime );
    FileTimeToSystemTime( &localTime, &systemTime );

    if (FormatSystemTime( &systemTime, time, TIME_BUFFER_LENGTH )) {

        printf( "%-12S ", time );

    } else {

        printf( "%-12S ", TIME_ERROR );
    }

    //
    // Convert completion time
    //

    FileTimeToLocalFileTime( (FILETIME *)&(RecordIrp->CompletionTime), &localTime );
    FileTimeToSystemTime( &localTime, &systemTime );

    if (FormatSystemTime( &systemTime, time, TIME_BUFFER_LENGTH )) {

        printf( "%-12S ", time );

    } else {

        printf( "%-12S ", TIME_ERROR );
    }

    printf( "%8x.%-4x ", RecordIrp->ProcessId, RecordIrp->ThreadId );

    PrintIrpCode( RecordIrp->IrpMajor, RecordIrp->IrpMinor, (ULONG)(ULONG_PTR)RecordIrp->Argument3, NULL, TRUE );

    printf( "%p ", (PVOID)RecordIrp->DeviceObject );
    printf( "%p ", (PVOID)RecordIrp->FileObject );
    printf( "%08lx:%08lx ", RecordIrp->ReturnStatus, RecordIrp->ReturnInformation );

    //
    // Interpret set flags
    //

    printf( "%08lx ", RecordIrp->IrpFlags );
    printf( "%s", (RecordIrp->IrpFlags & IRP_NOCACHE) ? "N":"-" );
    printf( "%s", (RecordIrp->IrpFlags & IRP_PAGING_IO) ? "P":"-" );
    printf( "%s", (RecordIrp->IrpFlags & IRP_SYNCHRONOUS_API) ? "S":"-" );
    printf( "%s ", (RecordIrp->IrpFlags & IRP_SYNCHRONOUS_PAGING_IO) ? "Y":"-" );

    if (FlagOn( VerbosityFlags, FS_VF_DUMP_PARAMETERS )) {

        printf( "%p %p %p %p  ", 
                RecordIrp->Argument1,
                RecordIrp->Argument2,
                RecordIrp->Argument3,
                RecordIrp->Argument4 );
        
        if (IRP_MJ_CREATE == RecordIrp->IrpMajor) {

            printf( "DesiredAccess->%08lx ", RecordIrp->DesiredAccess );
        }
    }

    printf( "%.*S", NameLength/sizeof(WCHAR), Name );
    printf( "\n" );
    PrintIrpCode( RecordIrp->IrpMajor, RecordIrp->IrpMinor, (ULONG)(ULONG_PTR)RecordIrp->Argument3, NULL, FALSE );
}

VOID
FastIoFileDump (
    ULONG SequenceNumber,
    PWCHAR Name,
    ULONG NameLength,
    PRECORD_FASTIO RecordFastIo,
    FILE *File
)
/*++
Routine Name:

    FastIoFileDump

Routine Description:

    Prints a FastIo log record to the specified file.  The output is in a tab
    delimited format with the fields in the following order:
    SequenceNumber, StartTime, CompletionTime, Fast I/O Type, FileName,
    Length, Wait, ReturnStatus, FileName

Arguments:

    SequenceNumber - the sequence number for this log record
    Name - the name of the file referenced by this Fast I/O operation
    NameLength - the length of name in bytes
    RecordFastIo - the FastIo record to print
    File - the file to print to

Return Value:

    None.

--*/
{
    SYSTEMTIME systemTime;
    FILETIME localTime;
    WCHAR time[TIME_BUFFER_LENGTH];

    fprintf( File, "F\t%08X", SequenceNumber );

    //
    // Convert start time
    //

    FileTimeToLocalFileTime( (FILETIME *)&(RecordFastIo->StartTime), &localTime );
    FileTimeToSystemTime( &localTime, &systemTime );

    if (FormatSystemTime( &systemTime, time, TIME_BUFFER_LENGTH )) {

        fprintf( File, "\t%-12S", time );

    } else {

        fprintf( File, "\t%-12S", TIME_ERROR );
    }

    //
    // Convert completion time
    //

    FileTimeToLocalFileTime( (FILETIME *)&(RecordFastIo->CompletionTime), &localTime );
    FileTimeToSystemTime( &localTime, &systemTime );

    if (FormatSystemTime( &systemTime, time, TIME_BUFFER_LENGTH )) {

        fprintf( File, "\t%-12S", time );

    } else {

        fprintf( File, "\t%-12S", TIME_ERROR );
    }

    fprintf( File, "\t%8x.%-4x ", RecordFastIo->ProcessId, RecordFastIo->ThreadId );

    PrintFastIoType( RecordFastIo->Type, File );

    fprintf( File, "\t%p", (PVOID)RecordFastIo->DeviceObject );
    fprintf( File, "\t%p", (PVOID)RecordFastIo->FileObject );
    fprintf( File, "\t%08x", RecordFastIo->ReturnStatus );

    fprintf( File, "\t%s", (RecordFastIo->Wait)?"T":"F" );
    fprintf( File, "\t%08x", RecordFastIo->Length );
    fprintf( File, "\t%016I64x ", RecordFastIo->FileOffset.QuadPart );

    fprintf( File, "\t%.*S", NameLength/sizeof(WCHAR), Name );
    fprintf( File, "\n" );
}

VOID
FastIoScreenDump (
    ULONG SequenceNumber,
    PWCHAR Name,
    ULONG NameLength,
    PRECORD_FASTIO RecordFastIo
)
/*++
Routine Name:

    FastIoScreenDump

Routine Description:

    Prints a FastIo log record to the screen in the following order:
    SequenceNumber, StartTime, CompletionTime, Fast I/O Type, FileName,
    Length, Wait, ReturnStatus, FileName

Arguments:

    SequenceNumber - the sequence number for this log record
    Name - the name of the file referenced by this Fast I/O operation
    NameLength - the length of name in bytes
    RecordIrp - the Irp record to print

Return Value:

    None.

--*/
{
    SYSTEMTIME systemTime;
    FILETIME localTime;
    WCHAR time[TIME_BUFFER_LENGTH];

    printf( "F %08X ", SequenceNumber );

    //
    // Convert start time
    //

    FileTimeToLocalFileTime( (FILETIME *)&(RecordFastIo->StartTime), &localTime );
    FileTimeToSystemTime( &localTime, &systemTime );

    if (FormatSystemTime( &systemTime, time, TIME_BUFFER_LENGTH )) {

        printf( "%-12S ", time );

    } else {

        printf( "%-12S ", TIME_ERROR );
    }

    //
    // Convert completion time
    //

    FileTimeToLocalFileTime( (FILETIME *)&(RecordFastIo->CompletionTime), &localTime );
    FileTimeToSystemTime( &localTime, &systemTime );

    if (FormatSystemTime( &systemTime, time, TIME_BUFFER_LENGTH )) {

        printf( "%-12S ", time );

    } else {

        printf( "%-12S ", TIME_ERROR );
    }

    printf( "%8x.%-4x ", RecordFastIo->ProcessId, RecordFastIo->ThreadId );

    PrintFastIoType( RecordFastIo->Type, NULL );

    printf( "%p ", (PVOID)RecordFastIo->DeviceObject );
    printf( "%p ", (PVOID)RecordFastIo->FileObject );
    printf( "%08x ", RecordFastIo->ReturnStatus );

    printf( "%s ", (RecordFastIo->Wait)?"T":"F" );
    printf( "%08x ", RecordFastIo->Length );
    printf( "%016I64x ", RecordFastIo->FileOffset.QuadPart );

    printf( "%.*S", NameLength/sizeof(WCHAR), Name );
    printf ("\n" );
}

#if WINVER >= 0x0501 /* See comment in DriverEntry */

VOID
FsFilterOperationFileDump (
    ULONG SequenceNumber,
    PWCHAR Name,
    ULONG NameLength,
    PRECORD_FS_FILTER_OPERATION RecordFsFilterOp,
    FILE *File
)
/*++
Routine Name:

    FsFilterOperationFileDump

Routine Description:

    Prints a FsFilterOperation log record to the specified file.  The output is in a tab
    delimited format with the fields in the following order:

    SequenceNumber, OriginatingTime, CompletionTime, ProcessId, ThreadId,
    Operation, FileObject, ReturnStatus, FileName

Arguments:

    SequenceNumber - the sequence number for this log record
    Name - the name of the file that this operation relates to
    NameLength - the length of Name in bytes
    RecordFsFilterOp - the FsFilter operation record to print
    File - the file to print to

Return Value:

    None.

--*/
{
    FILETIME    localTime;
    SYSTEMTIME  systemTime;
    WCHAR       time[TIME_BUFFER_LENGTH];

    fprintf(File, "O\t%08X", SequenceNumber);

    //
    // Convert originating time
    //

    FileTimeToLocalFileTime( (FILETIME *)&(RecordFsFilterOp->OriginatingTime), &localTime );
    FileTimeToSystemTime( &localTime, &systemTime );

    if (FormatSystemTime( &systemTime, time, TIME_BUFFER_LENGTH )) {

        fprintf( File, "\t%-12S", time );

    } else {

        fprintf( File, "\t%-12S", TIME_ERROR );
    }

    //
    // Convert completion time
    //

    FileTimeToLocalFileTime( (FILETIME *)&(RecordFsFilterOp->CompletionTime), &localTime );
    FileTimeToSystemTime( &localTime, &systemTime );
    if (FormatSystemTime( &systemTime, time, TIME_BUFFER_LENGTH )) {

        fprintf( File, "\t%-12S", time );

    } else {

        fprintf( File, "\t%-12S", TIME_ERROR );
    }

    //
    //  Output the process and thread id
    //

    fprintf( File, "\t%8x.%-4x ", RecordFsFilterOp->ProcessId, RecordFsFilterOp->ThreadId );

    //
    //  Output the FsFilter operation parameters
    //
    
    PrintFsFilterOperation( RecordFsFilterOp->FsFilterOperation, File );

    fprintf( File, "\t%p", (PVOID)RecordFsFilterOp->DeviceObject );
    fprintf( File, "\t%p", (PVOID)RecordFsFilterOp->FileObject );
    fprintf( File, "\t%08lx", RecordFsFilterOp->ReturnStatus );
    fprintf( File, "\t%.*S", NameLength/sizeof(WCHAR), Name );
    fprintf( File, "\n" );
}

VOID
FsFilterOperationScreenDump (
    ULONG SequenceNumber,
    PWCHAR Name,
    ULONG NameLength,
    PRECORD_FS_FILTER_OPERATION RecordFsFilterOp
)
/*++
Routine Name:

    FsFilterOperationScreenDump

Routine Description:

    Prints a FsFilterOperation log record to the screen in the following order:
    
    SequenceNumber, OriginatingTime, CompletionTime, ProcessId, ThreadId,
    Operation, FileObject, ReturnStatus, FileName

Arguments:

    SequenceNumber - the sequence number for this log record
    Name - the file name to which this Irp relates
    NameLength - the length of name in bytes
    RecordFsFilterOp - the FsFilterOperation record to print

Return Value:

    None.

--*/
{
    FILETIME localTime;
    SYSTEMTIME systemTime;
    WCHAR time[TIME_BUFFER_LENGTH];

    printf( "O %08X ", SequenceNumber );

    //
    // Convert originating time
    //

    FileTimeToLocalFileTime( (FILETIME *)&(RecordFsFilterOp->OriginatingTime), &localTime );
    FileTimeToSystemTime( &localTime, &systemTime );

    if (FormatSystemTime( &systemTime, time, TIME_BUFFER_LENGTH )) {

        printf( "%-12S ", time );

    } else {

        printf( "%-12S ", TIME_ERROR );
    }

    //
    // Convert completion time
    //

    FileTimeToLocalFileTime( (FILETIME *)&(RecordFsFilterOp->CompletionTime), &localTime );
    FileTimeToSystemTime( &localTime, &systemTime );

    if (FormatSystemTime( &systemTime, time, TIME_BUFFER_LENGTH )) {

        printf( "%-12S ", time );

    } else {

        printf( "%-12S ", TIME_ERROR );
    }

    printf( "%8x.%-4x ", RecordFsFilterOp->ProcessId, RecordFsFilterOp->ThreadId );

    PrintFsFilterOperation( RecordFsFilterOp->FsFilterOperation, NULL );

    //
    // Print FsFilter operation specific values.
    //

    printf( "%p ", (PVOID)RecordFsFilterOp->DeviceObject );
    printf( "%p ", (PVOID)RecordFsFilterOp->FileObject );
    printf( "%08lx ", RecordFsFilterOp->ReturnStatus );
    printf( "%.*S", NameLength/sizeof(WCHAR),Name );
    printf( "\n" );
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\filespy\user\fspylog.h ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    log.h

Abstract:

    This module contains the structures and prototypes used by the user 
    program to retrieve and see the log records recorded by filespy.sys.
    
// @@BEGIN_DDKSPLIT
Author:

    Molly Brown (MollyBro) 21-Apr-1999

// @@END_DDKSPLIT
Environment:

    User mode


// @@BEGIN_DDKSPLIT
Revision History:

    Molly Brown (mollybro)         21-May-2002
        Modify sample to make it support running on Windows 2000 or later if
        built in the latest build environment and allow it to be built in W2K 
        and later build environments.

// @@END_DDKSPLIT
--*/
#ifndef __FSPYLOG_H__
#define __FSPYLOG_H__

#include <stdio.h>
#include "filespy.h"

#define BUFFER_SIZE     4096

typedef struct _LOG_CONTEXT{
    HANDLE  Device;
    BOOLEAN LogToScreen;
    BOOLEAN LogToFile;
    ULONG   VerbosityFlags;     //  FS_VF_DUMP_PARAMETERS, etc.
    FILE   *OutputFile;

    BOOLEAN NextLogToScreen;

    // For synchronizing shutting down of both threads
    BOOLEAN CleaningUp;
    HANDLE  ShutDown;
}LOG_CONTEXT, *PLOG_CONTEXT;

DWORD WINAPI 
RetrieveLogRecords(
    LPVOID lpParameter
);
                
VOID
IrpFileDump(
    ULONG SequenceNumber,
    PWCHAR Name,
    ULONG NameLength,
    PRECORD_IRP RecordIrp,
    FILE *File,
    ULONG Verbosity
);

VOID
IrpScreenDump(
    ULONG SequenceNumber,
    PWCHAR Name,
    ULONG NameLength,
    PRECORD_IRP RecordIrp,
    ULONG Verbosity
);

VOID
FastIoFileDump(
    ULONG SequenceNumber,
    PWCHAR Name,
    ULONG NameLength,
    PRECORD_FASTIO RecordFastIo,
    FILE *File
);

VOID
FastIoScreenDump(
    ULONG SequenceNumber,
    PWCHAR Name,
    ULONG NameLength,
    PRECORD_FASTIO RecordFastIo
);

#if WINVER >= 0x0501 /* See comment in DriverEntry */

VOID
FsFilterOperationFileDump (
    ULONG SequenceNumber,
    PWCHAR Name,
    ULONG NameLength,
    PRECORD_FS_FILTER_OPERATION RecordFsFilterOp,
    FILE *File
);

VOID
FsFilterOperationScreenDump (
    ULONG SequenceNumber,
    PWCHAR Name,
    ULONG NameLength,
    PRECORD_FS_FILTER_OPERATION RecordFsFilterOp
);

#endif

#define IRP_NOCACHE                     0x00000001
#define IRP_PAGING_IO                   0x00000002
#define IRP_SYNCHRONOUS_API             0x00000004
#define IRP_SYNCHRONOUS_PAGING_IO       0x00000040

#if WINVER >= 0x0501 
#define FS_FILTER_ACQUIRE_FOR_SECTION_SYNCHRONIZATION    (UCHAR)-1
#define FS_FILTER_RELEASE_FOR_SECTION_SYNCHRONIZATION    (UCHAR)-2
#define FS_FILTER_ACQUIRE_FOR_MOD_WRITE                  (UCHAR)-3
#define FS_FILTER_RELEASE_FOR_MOD_WRITE                  (UCHAR)-4
#define FS_FILTER_ACQUIRE_FOR_CC_FLUSH                   (UCHAR)-5
#define FS_FILTER_RELEASE_FOR_CC_FLUSH                   (UCHAR)-6
#endif

//
//  Verbosity flags.
//

#define FS_VF_DUMP_PARAMETERS           0x00000001

#endif __FSPYLOG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\filespy\usergui\define.h ===
#pragma once

#define DEVICE_NAME_SIZE 64


#define IRP_NOCACHE                     0x00000001
#define IRP_PAGING_IO                   0x00000002
#define IRP_SYNCHRONOUS_API             0x00000004
#define IRP_SYNCHRONOUS_PAGING_IO       0x00000040

#define FS_FILTER_ACQUIRE_FOR_SECTION_SYNCHRONIZATION    (UCHAR)-1
#define FS_FILTER_RELEASE_FOR_SECTION_SYNCHRONIZATION    (UCHAR)-2
#define FS_FILTER_ACQUIRE_FOR_MOD_WRITE                  (UCHAR)-3
#define FS_FILTER_RELEASE_FOR_MOD_WRITE                  (UCHAR)-4
#define FS_FILTER_ACQUIRE_FOR_CC_FLUSH                   (UCHAR)-5
#define FS_FILTER_RELEASE_FOR_CC_FLUSH                   (UCHAR)-6
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\filespy\usergui\drive.cpp ===
#include "global.h"
#include "protos.h"

#define DRIVE_STRING_LENGTH 512

USHORT BuildDriveTable(VOLINFO *pVolInfo)
{
    WCHAR sDriveString[DRIVE_STRING_LENGTH];
    PWCHAR sDrive;
    USHORT  index;

    GetLogicalDriveStrings(DRIVE_STRING_LENGTH, sDriveString);

    index = 0;

    for (sDrive = sDriveString; *sDrive != NULL; sDrive += 4, index ++) {

        pVolInfo[index].nDriveName = sDrive[0];
        pVolInfo[index].nType = GetDriveType( sDrive );
        pVolInfo[index].bHook = FALSE;
        
        switch (pVolInfo[index].nType) {
        case DRIVE_FIXED:
            pVolInfo[index].nImage = IMAGE_FIXEDDRIVE;
            break;

        case DRIVE_CDROM:
            pVolInfo[index].nImage = IMAGE_CDROMDRIVE;
            break;

        case DRIVE_REMOVABLE:
            pVolInfo[index].nImage = IMAGE_REMOVABLEDRIVE;
            break;

        case DRIVE_REMOTE:
            pVolInfo[index].nImage = IMAGE_REMOTEDRIVE;
            break;

        default:
            pVolInfo[index].nImage = IMAGE_UNKNOWNDRIVE;
            break;
        }
    }
    
    return index;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\filespy\usergui\declare.h ===
#pragma once

#include "define.h"

//
// This file contains all data structure declarations 
//


struct VolumeInfo
{
    char nDriveName;
    char sVolumeLable[20];
    char nType;
    char nHook;
    char nImage;
};

typedef struct VolumeInfo VOLINFO;
  
typedef ULONG FILE_ID;
typedef LONG NTSTATUS;

#define LOG_ORIGINATING_IRP  0x0001
#define LOG_COMPLETION_IRP   0x0002

/* The types FASTIO that are available for the Type field of the 
   RECORD_FASTIO structure. */
typedef enum {
    CHECK_IF_POSSIBLE = 1,
    READ,
    WRITE,
    QUERY_BASIC_INFO,
    QUERY_STANDARD_INFO,
    LOCK,
    UNLOCK_SINGLE,
    UNLOCK_ALL,
    UNLOCK_ALL_BY_KEY,
    DEVICE_CONTROL,
    ACQUIRE_FILE,
    RELEASE_FILE,
    DETACH_DEVICE,
    QUERY_NETWORK_OPEN_INFO,
    ACQUIRE_FOR_MOD_WRITE,
    MDL_READ,
    MDL_READ_COMPLETE,
    MDL_WRITE,
    MDL_WRITE_COMPLETE,
    READ_COMPRESSED,
    WRITE_COMPRESSED,
    MDL_READ_COMPLETE_COMPRESSED,
    PREPARE_MDL_WRITE,
    MDL_WRITE_COMPLETE_COMPRESSED,
    QUERY_OPEN,
    RELEASE_FOR_MOD_WRITE,
    ACQUIRE_FOR_CC_FLUSH,
    RELEASE_FOR_CC_FLUSH
} FASTIO_TYPE, *PFASTIO_TYPE;

typedef struct _RECORD_IRP 
{
    LARGE_INTEGER   OriginatingTime; // The time the IRP orginated
    LARGE_INTEGER   CompletionTime;  // The time the IRP was completed

    UCHAR        IrpMajor;        // From _IO_STACK_LOCATION
    UCHAR        IrpMinor;        // From _IO_STACK_LOCATION
    ULONG        IrpFlags;        // From _IRP (no cache, paging i/o, sync. 
                                  // api, assoc. irp, buffered i/o, etc.)                   
    FILE_ID      FileObject;      // From _IO_STACK_LOCATION (This is the 
                                  //     PFILE_OBJECT, but this isn't 
                                  //     available in user-mode)
    NTSTATUS     ReturnStatus;    // From _IRP->IoStatus.Status
    ULONG    ReturnInformation; // From _IRP->IoStatus.Information
    FILE_ID      ProcessId;
    FILE_ID      ThreadId;
} RECORD_IRP, *PRECORD_IRP;

typedef struct _RECORD_FASTIO 
{
    LARGE_INTEGER StartTime;     // Time Fast I/O request begins processing
    LARGE_INTEGER CompletionTime;// Time Fast I/O request completes processing
    FASTIO_TYPE   Type;          // Type of FASTIO operation
    FILE_ID       FileObject;    // Parameter to FASTIO call, should be 
                                 //     unique identifier in user space
    LARGE_INTEGER FileOffset;    // Offset into the file where the I/O is 
                                 //     taking place
    ULONG         Length;        // The length of data for the I/O operation
    BOOLEAN       Wait;          // Parameter to most FASTIO calls, signifies 
                                 //     if this operation can wait
    NTSTATUS      ReturnStatus;  // From IO_STATUS_BLOCK
    ULONG         Reserved;      // Reserved space
    FILE_ID       ProcessId;
    FILE_ID       ThreadId;
} RECORD_FASTIO, *PRECORD_FASTIO;


typedef union _RECORD_IO 
{
    RECORD_IRP      RecordIrp;
    RECORD_FASTIO   RecordFastIo;
} RECORD_IO, *PRECORD_IO;

typedef struct _LOG_RECORD 
{
    ULONG       Length;          // Length of record including header 
    ULONG       SequenceNumber;
    ULONG       RecordType;
    RECORD_IO   Record;
    WCHAR       Name[MAX_PATH];
} LOG_RECORD, *PLOG_RECORD;

typedef struct _PATTACHED_DEVICE
{
    BOOLEAN     LogState;
    WCHAR       DeviceName[DEVICE_NAME_SIZE];
} ATTACHED_DEVICE, *PATTACHED_DEVICE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\filespy\user\fspyuser.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    fspyUser.c

Abstract:

    This file contains the implementation for the main function of the 
    user application piece of FileSpy.  This function is responsible for
    controlling the command mode available to the user to control the 
    kernel mode driver.
    
Environment:

    User mode

// @@BEGIN_DDKSPLIT
Author:

    George Jenkins (GeorgeJe)                       

Revision History:                     

    Molly Brown (MollyBro) 21-Apr-1999
        Broke out the logging code and added command mode functionality.

    Neal Christiansen (nealch)     06-Jul-2001
        Updated cash statistics for use with contexts

// @@END_DDKSPLIT
--*/

#include <windows.h>                
#include <stdlib.h>
#include <stdio.h>
#include <winioctl.h>
#include <string.h>
#include <crtdbg.h>
#include "filespy.h"
#include "fspyLog.h"
#include "filespyLib.h"

#define SUCCESS              0
#define USAGE_ERROR          1
#define EXIT_INTERPRETER     2
#define EXIT_PROGRAM         4

#define INTERPRETER_EXIT_COMMAND1 "go"
#define INTERPRETER_EXIT_COMMAND2 "g"
#define PROGRAM_EXIT_COMMAND      "exit"

#define ToggleFlag(V, F) (V = (((V) & (F)) ? (V & (~F)) : (V | F)))

DWORD
InterpretCommand(
    int argc,
    char *argv[],
    PLOG_CONTEXT Context
);

BOOL
ListDevices(
    PLOG_CONTEXT Context
);

BOOL
ListHashStats(
    PLOG_CONTEXT Context
);

VOID
DisplayError (
   DWORD Code
   );

int _cdecl main(int argc, char *argv[])
{
    SC_HANDLE               hSCManager = NULL;
    SC_HANDLE               hService = NULL;
    SERVICE_STATUS_PROCESS  serviceInfo;
    DWORD                   bytesNeeded;
    HANDLE                  hDevice = NULL;
    BOOL                    bResult;
    DWORD                   result;
    ULONG                   threadId;
    HANDLE                  thread = NULL;
    LOG_CONTEXT             context;
    INT                     inputChar;


    //
    // Initialize handle in case of error
    //

    context.ShutDown = NULL;
    context.VerbosityFlags = 0;

    //
    // Start the kernel mode driver through the service manager
    //
    
    hSCManager = OpenSCManager (NULL, NULL, SC_MANAGER_ALL_ACCESS) ;
    if (NULL == hSCManager) {
        result = GetLastError();
        printf("ERROR opening Service Manager...\n");
        DisplayError( result );
        goto Main_Continue;
    }


    hService = OpenService( hSCManager,
                            FILESPY_SERVICE_NAME,
                            FILESPY_SERVICE_ACCESS);

    if (NULL == hService) {
        result = GetLastError();
        printf("ERROR opening FileSpy Service...\n");
        DisplayError( result );
        goto Main_Continue;
    }

    if (!QueryServiceStatusEx( hService,
                               SC_STATUS_PROCESS_INFO,
                               (UCHAR *)&serviceInfo,
                               sizeof(serviceInfo),
                               &bytesNeeded))
    {
        result = GetLastError();
        printf("ERROR querrying status of FileSpy Service...\n");
        DisplayError( result );
        goto Main_Continue;
    }

    if(serviceInfo.dwCurrentState != SERVICE_RUNNING) {
        //
        // Service hasn't been started yet, so try to start service
        //
        if (!StartService(hService, 0, NULL)) {
            result = GetLastError();
            printf("ERROR starting FileSpy service...\n");
            DisplayError( result );
            goto Main_Continue;
        }
    }
   

Main_Continue:
    printf("Hit [Enter] to begin command mode...\n");

    //
    //  Open the device that is used to talk to FileSpy.
    //
    printf("FileSpy:  Opening device...\n");
    
    hDevice = CreateFile( FILESPY_W32_DEVICE_NAME,
                          GENERIC_READ | GENERIC_WRITE,
                          0,
                          NULL,
                          OPEN_EXISTING,
                          FILE_ATTRIBUTE_NORMAL,
                          NULL);
    if (hDevice == INVALID_HANDLE_VALUE) {
        result = GetLastError();
        printf("ERROR opening device...\n");
        DisplayError( result );
        goto Main_Exit;
    }
    
    //
    //  Initialize the fields of the LOG_CONTEXT.
    //
    context.Device = hDevice;
    context.ShutDown = CreateSemaphore(
        NULL, 
        0, 
        1, 
        L"FileSpy shutdown");
    context.CleaningUp = FALSE;
    context.LogToScreen = context.NextLogToScreen = TRUE;
    context.LogToFile = FALSE;
    context.OutputFile = NULL;

    //
    // Check the valid parameters for startup
    //
    if (argc > 1) {
        if (InterpretCommand(argc - 1, &(argv[1]), &context) == USAGE_ERROR) {
            goto Main_Exit;
        }
    }

    //
    // Propagate the /s switch to the variable that the logging
    // thread checks.
    //
    context.LogToScreen = context.NextLogToScreen;

    //
    // Check to see what devices we are attached to from
    // previous runs of this program.
    //
    bResult = ListDevices(&context);
    if (!bResult) {
        result = GetLastError();
        printf("ERROR listing devices...\n");
        DisplayError( result );
    }

    //
    // Create the thread to read the log records that are gathered
    // by filespy.sys.
    //
    printf("FileSpy:  Creating logging thread...\n");
    thread = CreateThread(
        NULL,
        0,
        RetrieveLogRecords,
        (LPVOID)&context,
        0,
        &threadId);
    if (!thread) {
        result = GetLastError();
        printf("ERROR creating logging thread...\n");
        DisplayError( result );
        goto Main_Exit;
    }

    while (inputChar = getchar()) {
        CHAR    commandLine[81];
        INT     parmCount, count, ch;
        CHAR  **parms;
        BOOLEAN newParm;
        DWORD   returnValue = SUCCESS;

        if (inputChar == '\n') {
            //
            // Start command interpreter.  First we must turn off logging
            // to screen if we are.  Also, remember the state of logging
            // to the screen, so that we can reinstate that when command
            // interpreter is finished.
            //
            context.NextLogToScreen = context.LogToScreen;
            context.LogToScreen = FALSE;

            while (returnValue != EXIT_INTERPRETER) {
                //
                // Print prompt
                //
                printf(">");

                //
                // Read in next line, keeping track of the number of parameters 
                // as you go
                //
                parmCount = 1;
                for (count = 0; 
                     (count < 80) && ((ch = getchar())!= '\n'); 
                     count++) {
                    commandLine[count] = (CHAR)ch;
                    if (ch == ' ') {
                        parmCount ++;
                    }
                }
                commandLine[count] = '\0';
    
                parms = (CHAR **)malloc(parmCount * sizeof(CHAR *));
    
                parmCount = 0;
                newParm = TRUE;
                for (count = 0; commandLine[count] != '\0'; count++) {
                    if (newParm) {
                        parms[parmCount] = &(commandLine[count]);
                        parmCount ++;
                    }
                    if (commandLine[count] == ' ' ) {
                        newParm = TRUE;
                    } else {
                        newParm = FALSE;
                    }
                }
    
                //
                // We've got our parameter count and parameter list, so
                // send it off to be interpreted.
                //
                returnValue = InterpretCommand(parmCount, parms, &context);
                free(parms);
                if (returnValue == EXIT_PROGRAM) {
                    // Time to stop the program
                    goto Main_Cleanup;
                }
            }

            // Set LogToScreen appropriately based on any commands seen
            context.LogToScreen = context.NextLogToScreen;

            if (context.LogToScreen) {
                printf("Should be logging to screen...\n");
            }
        }
    }

Main_Cleanup:
    //
    // Clean up the threads, then fall through to Main_Exit
    //

    printf("FileSpy:  Cleaning up...\n");
    // 
    // Set the Cleaning up flag to TRUE to notify other threads
    // that we are cleaning up
    //
    context.CleaningUp = TRUE;

    // 
    // Wait for everyone to shut down
    //
    WaitForSingleObject(context.ShutDown, INFINITE);
    if (context.LogToFile) {
        fclose(context.OutputFile);
    }

Main_Exit:
    // 
    // Clean up the data that is always around and exit
    //
    if(context.ShutDown) {
        CloseHandle(context.ShutDown);
    }
    if (thread) {
        CloseHandle(thread);
    }

    if(hSCManager) {
        CloseServiceHandle(hSCManager);
    }
    if(hService) {
        CloseServiceHandle(hService);
    }
    if (hDevice) {
        CloseHandle(hDevice);
    }
    
    printf("FileSpy:  All done\n");
    return 0;  

}


DWORD
InterpretCommand(
    int argc,
    char *argv[],
    PLOG_CONTEXT Context
)
{
    int         parmIndex;
    CHAR       *parm;      
    BOOL        bResult;
    DWORD       result;
    DWORD       returnValue = SUCCESS;
    CHAR        buffer[BUFFER_SIZE];
    DWORD       bufferLength;
    DWORD       bytesReturned;

    //
    // Interpret the command line parameters
    //
    for (parmIndex = 0; parmIndex < argc; parmIndex++) {
        parm = argv[parmIndex];
        if (parm[0] == '/') {
            //
            // Have the beginning of a switch
            //
            switch (parm[1]) {
            case 'a':
            case 'A':
                //
                // Attach to the specified drive letter
                //
                parmIndex++;
                if (parmIndex >= argc) {
                    //
                    // Not enough parameters
                    //
                    goto InterpretCommand_Usage;
                }
                parm = argv[parmIndex];
                printf("\tAttaching to %s\n", parm);
                bufferLength = MultiByteToWideChar(
                    CP_ACP,
                    MB_ERR_INVALID_CHARS,
                    parm,
                    -1,
                    (LPWSTR)buffer,
                    BUFFER_SIZE/sizeof(WCHAR));
                
                bResult = DeviceIoControl(
                    Context->Device,
                    FILESPY_StartLoggingDevice,
                    buffer,
                    bufferLength * sizeof(WCHAR),
                    NULL,
                    0,
                    &bytesReturned,
                    NULL);
                if (!bResult) {
                    result = GetLastError();
                    printf("ERROR attaching to device...\n");
                    DisplayError( result );
                }
                
                break;

            case 'd':
            case 'D':
                //
                // Detach to the specified drive letter
                //
                parmIndex++;
                if (parmIndex >= argc) {
                    //
                    // Not enough parameters
                    //
                    goto InterpretCommand_Usage;
                }
                parm = argv[parmIndex];
                printf("\tDetaching from %s\n", parm);
                bufferLength = MultiByteToWideChar(
                    CP_ACP,
                    MB_ERR_INVALID_CHARS,
                    parm,
                    -1,
                    (LPWSTR)buffer,
                    BUFFER_SIZE/sizeof(WCHAR));
                
                bResult = DeviceIoControl(
                    Context->Device,
                    FILESPY_StopLoggingDevice,
                    buffer,
                    bufferLength * sizeof(WCHAR),
                    NULL,
                    0,
                    &bytesReturned,
                    NULL);
                
                if (!bResult) {
                    result = GetLastError();
                    printf("ERROR detaching to device...\n");
                    DisplayError( result );
                }
                break;
            
            case 'h':
            case 'H':
                ListHashStats(Context);
                break;

            case 'l':
            case 'L':
                //
                // List all devices that are currently being monitored
                //
                bResult = ListDevices(Context);
                if (!bResult) {
                    result = GetLastError();
                    printf("ERROR listing devices...\n");
                    DisplayError( result );
                }
                
                break;

            case 's':
            case 'S':
                //
                // Output logging results to screen, save new value to
                // instate when command interpreter is exited.
                //
                if (Context->NextLogToScreen) {
                    printf("\tTurning off logging to screen\n");
                } else {
                    printf("\tTurning on logging to screen\n");
                }
                Context->NextLogToScreen = !Context->NextLogToScreen;
                break;

            case 'f':
            case 'F':
                //
                // Output logging results to file
                //
                if (Context->LogToFile) {
                    printf("\tStop logging to file \n");
                    Context->LogToFile = FALSE;
                    _ASSERT(Context->OutputFile);
                    fclose(Context->OutputFile);
                    Context->OutputFile = NULL;
                } else {
                    parmIndex++;
                    if (parmIndex >= argc) {
                        // Not enough parameters
                        goto InterpretCommand_Usage;
                    }
                    parm = argv[parmIndex];
                    Context->OutputFile = fopen(parm, "w");

                    if (Context->OutputFile == NULL) {
                        result = GetLastError();
                        printf("\nERROR opening \"%s\"...\n",parm);
                        DisplayError( result );
                        exit(1);
                    }
                    Context->LogToFile = TRUE;
                    printf("\tLog to file %s\n", parm);
                }
                break;

            case 'v':
            case 'V':
                //
                // Toggle the specified verbosity flag.
                //
                parmIndex++;
                if (parmIndex >= argc) {
                    //
                    // Not enough parameters
                    //
                    goto InterpretCommand_Usage;
                }
                parm = argv[parmIndex];
                switch(parm[0]) {
                case 'p':
                case 'P':
                    ToggleFlag( Context->VerbosityFlags, FS_VF_DUMP_PARAMETERS );
                    break;

                default:                    
                    //
                    // Invalid switch, goto usage
                    //
                    goto InterpretCommand_Usage;
                }
                break;

            default:
                //
                // Invalid switch, goto usage
                //
                goto InterpretCommand_Usage;
            }
        } else {
            //
            // Look for "go" or "g" to see if we should exit interpreter
            //
            if (!_strnicmp(
                    parm, 
                    INTERPRETER_EXIT_COMMAND1, 
                    sizeof(INTERPRETER_EXIT_COMMAND1))) {
                returnValue = EXIT_INTERPRETER;
                goto InterpretCommand_Exit;
            }
            if (!_strnicmp(
                    parm, 
                    INTERPRETER_EXIT_COMMAND2, 
                    sizeof(INTERPRETER_EXIT_COMMAND2))) {
                returnValue = EXIT_INTERPRETER;
                goto InterpretCommand_Exit;
            }
            //
            // Look for "exit" to see if we should exit program
            //
            if (!_strnicmp(
                    parm, 
                    PROGRAM_EXIT_COMMAND, 
                    sizeof(PROGRAM_EXIT_COMMAND))) {
                returnValue = EXIT_PROGRAM;
                goto InterpretCommand_Exit;
            }
            //
            // Invalid parameter
            //
            goto InterpretCommand_Usage;
        }
    }

InterpretCommand_Exit:
    return returnValue;

InterpretCommand_Usage:
    printf("Valid switches: [/a <drive>] [/d <drive>] [/h] [/l] [/s] [/f [<file name>] [/v <flag>]]\n"
           "\t[/a <drive>] attaches monitor to <drive>\n"
           "\t[/d <drive>] detaches monitor from <drive>\n"
           "\t[/h] print filename hash statistics\n"
           "\t[/l] lists all the drives the monitor is currently attached to\n"
           "\t[/s] turns on and off showing logging output on the screen\n"
           "\t[/f [<file name>]] turns on and off logging to the specified file\n"
           "\t[/v <flag>] toggles a verbosity flag.  Valid verbosity flags are:\n"
           "\t\tp (dump irp parameters)\n"
           "If you are in command mode,\n"
           "\t[go|g] will exit command mode\n"
           "\t[exit] will terminate this program\n"
           );
    returnValue = USAGE_ERROR;
    goto InterpretCommand_Exit;
}

BOOL
ListHashStats(
    PLOG_CONTEXT Context
)
{
    ULONG bytesReturned;
    BOOL returnValue;
    FILESPY_STATISTICS stats;

    returnValue = DeviceIoControl( Context->Device,
                                   FILESPY_GetStats,
                                   NULL,
                                   0,
                                   (CHAR *) &stats,
                                   BUFFER_SIZE,
                                   &bytesReturned,
                                   NULL );

    if (returnValue) {
        printf("         STATISTICS\n");
        printf("---------------------------------\n");
        printf("%-40s %8d\n", 
               "Name lookups",
               stats.TotalContextSearches);

        printf("%-40s %8d\n",
               "Name lookup hits",
               stats.TotalContextFound);

        if (stats.TotalContextSearches) {
            printf(
                "%-40s %8.2f%%\n",
                "Hit ratio",
                ((FLOAT) stats.TotalContextFound / (FLOAT) stats.TotalContextSearches) * 100.);
        }

        printf("%-40s %8d\n",
               "Names created",
               stats.TotalContextCreated);

        printf("%-40s %8d\n",
               "Temporary Names created",
               stats.TotalContextTemporary);

        printf("%-40s %8d\n",
               "Duplicate names created",
               stats.TotalContextDuplicateFrees);

        printf("%-40s %8d\n",
               "Context callback frees",
               stats.TotalContextCtxCallbackFrees);

        printf("%-40s %8d\n",
               "NonDeferred context frees",
               stats.TotalContextNonDeferredFrees);

        printf("%-40s %8d\n",
               "Deferred context frees",
               stats.TotalContextDeferredFrees);

        printf("%-40s %8d\n",
               "Delete all contexts",
               stats.TotalContextDeleteAlls);

        printf("%-40s %8d\n",
               "Contexts not supported",
               stats.TotalContextsNotSupported);

        printf("%-40s %8d\n",
               "Contexts not found attached to stream",
               stats.TotalContextsNotFoundInStreamList);
    }
    
    return returnValue;
}


BOOL
ListDevices(
    PLOG_CONTEXT Context
)
{
    CHAR             buffer[BUFFER_SIZE];
    ULONG            bytesReturned;
    BOOL             returnValue;

    returnValue = DeviceIoControl(
        Context->Device,
        FILESPY_ListDevices,
        NULL,
        0,
        buffer,
        BUFFER_SIZE,
        &bytesReturned,
        NULL);

    if (returnValue) {
        PATTACHED_DEVICE device = (PATTACHED_DEVICE) buffer;


        printf("DEVICE NAME                           | LOGGING STATUS\n");
        printf("------------------------------------------------------\n");

        if (bytesReturned == 0) {
            printf("No devices attached\n");
        } else {
            while ((BYTE *)device < buffer + bytesReturned) {
                printf(
                    "%-38S| %s\n", 
                    device->DeviceNames, 
                    (device->LoggingOn)?"ON":"OFF");
                device ++;
            }
        }
    }

    return returnValue;
}

VOID
DisplayError (
   DWORD Code
   )

/*++

Routine Description:

   This routine will display an error message based off of the Win32 error
   code that is passed in. This allows the user to see an understandable
   error message instead of just the code.

Arguments:

   Code - The error code to be translated.

Return Value:

   None.

--*/

{
   WCHAR                                    buffer[80] ;
   DWORD                                    count ;

   //
   // Translate the Win32 error code into a useful message.
   //

   count = FormatMessage (FORMAT_MESSAGE_FROM_SYSTEM,
                          NULL,
                          Code,
                          0,
                          buffer,
                          sizeof( buffer )/sizeof( WCHAR ),
                          NULL) ;

   //
   // Make sure that the message could be translated.
   //

   if (count == 0) {

      printf("\nError could not be translated.\n Code: %d\n", Code) ;
      return;
   }
   else {

      //
      // Display the translated error.
      //

      printf("%S\n", buffer) ;
      return;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\filespy\usergui\fastioview.cpp ===
// FastIoView.cpp : implementation file
//

#include "stdafx.h"
#include "FileSpyApp.h"
#include "FastIoView.h"

#include "global.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFastIoView

IMPLEMENT_DYNCREATE(CFastIoView, CListView)

CFastIoView::CFastIoView()
{
	pFastIoView = (LPVOID) this;
}

CFastIoView::~CFastIoView()
{
}


BEGIN_MESSAGE_MAP(CFastIoView, CListView)
	//{{AFX_MSG_MAP(CFastIoView)
	ON_WM_KEYDOWN()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFastIoView drawing

void CFastIoView::OnDraw(CDC* pDC)
{
    UNREFERENCED_PARAMETER( pDC );
    
	CDocument* pDoc = GetDocument();
	// TODO: add draw code here
}

/////////////////////////////////////////////////////////////////////////////
// CFastIoView diagnostics+

#ifdef _DEBUG
void CFastIoView::AssertValid() const
{
	CListView::AssertValid();
}

void CFastIoView::Dump(CDumpContext& dc) const
{
	CListView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CFastIoView message handlers

BOOL CFastIoView::PreCreateWindow(CREATESTRUCT& cs) 
{
	// TODO: Add your specialized code here and/or call the base class
	cs.style |= LVS_REPORT | WS_HSCROLL | WS_VSCROLL;
	return CListView::PreCreateWindow(cs);
}

void CFastIoView::OnInitialUpdate() 
{
	CListView::OnInitialUpdate();
	
	// TODO: Add your specialized code here and/or call the base class
	//
	// Add the list header items
	//
	GetListCtrl().InsertColumn(0, L"S. No", LVCFMT_LEFT, 50);
	GetListCtrl().InsertColumn(1, L"Fast IO Entry", LVCFMT_LEFT, 100);
	GetListCtrl().InsertColumn(2, L"FileObject", LVCFMT_LEFT, 75);
	GetListCtrl().InsertColumn(3, L"Name", LVCFMT_LEFT, 250);
	GetListCtrl().InsertColumn(4, L"Offset", LVCFMT_LEFT, 100);
	GetListCtrl().InsertColumn(5, L"Length", LVCFMT_LEFT, 100);
	GetListCtrl().InsertColumn(6, L"Wait", LVCFMT_LEFT, 100);
	GetListCtrl().InsertColumn(7, L"Process:Thread", LVCFMT_LEFT, 100);
	GetListCtrl().InsertColumn(8, L"OrgnTime", LVCFMT_LEFT, 78);
	GetListCtrl().InsertColumn(9, L"CompTime", LVCFMT_LEFT, 78);
	GetListCtrl().InsertColumn(10, L"Return Status", LVCFMT_LEFT, 100);
}

void CFastIoView::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	// TODO: Add your message handler code here and/or call default
	int ti, oldti;
	
	if (nChar == VK_DELETE)
	{
		ti = 0;
		oldti = 0;
		while(ti < GetListCtrl().GetItemCount())
		{
			if (GetListCtrl().GetItemState(ti, LVIS_SELECTED) & LVIS_SELECTED)
			{
				GetListCtrl().DeleteItem(ti);
				oldti = ti;
			}
			else
			{
				ti++;
			}
		}
		if (oldti < GetListCtrl().GetItemCount())
		{
			GetListCtrl().SetItemState(oldti, LVIS_SELECTED, LVIS_SELECTED);
		}
		else
		{
			GetListCtrl().SetItemState(oldti-1, LVIS_SELECTED, LVIS_SELECTED);
		}
	}
	
	CListView::OnKeyDown(nChar, nRepCnt, nFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\filespy\usergui\drvcomm.cpp ===
#include "global.h"
#include "protos.h"

#include "filespyview.h"
#include "fastioview.h"
#include "fsfilterview.h"
#include "leftview.h"
#include "filespyLib.h"

void DisplayIrpFields(CFileSpyView *pView, PLOG_RECORD pLog);
void DisplayFastIoFields(CFastIoView *pView, PLOG_RECORD pLog);
void DisplayFsFilterFields(CFsFilterView *pView, PLOG_RECORD pLog);

DWORD StartFileSpy(void)
{

    DWORD nBytesNeeded;
    CLeftView *pDriveView;

    pDriveView = (CLeftView *) pLeftView;

    // Open Service control manager
    hSCManager = OpenSCManager (NULL, NULL, SC_MANAGER_ALL_ACCESS) ;

    hService = OpenServiceW(hSCManager, FILESPY_SERVICE_NAME, FILESPY_SERVICE_ACCESS);
    if (hService == NULL)
    {
        DisplayError(GetLastError());
        return 0;
    }

    if (!QueryServiceStatusEx( hService,
                               SC_STATUS_PROCESS_INFO,
                               (UCHAR *)&ServiceInfo,
                               sizeof(ServiceInfo),
                               &nBytesNeeded)) 
    {
        DisplayError(GetLastError());
        CloseServiceHandle(hSCManager);
        CloseServiceHandle(hService);
        MessageBox(NULL, L"Unable to query Service status information", L"Startup Error", MB_OK|MB_ICONEXCLAMATION);
        return 0;
    }

    if(ServiceInfo.dwCurrentState != SERVICE_RUNNING) {
        //
        // Service hasn't been started yet, so try to start service
        //
        if (!StartService(hService, 0, NULL))
        {
            CloseServiceHandle(hSCManager);
            CloseServiceHandle(hService);
            MessageBox(NULL, L"Unable to start service", L"Startup Error", MB_OK|MB_ICONSTOP);
            return 0;
        }
    }
   
    //
    //  Open the device that is used to talk to FileSpy.
    //
    hDevice = CreateFile( FILESPY_W32_DEVICE_NAME,
                          GENERIC_READ | GENERIC_WRITE,
                          0,
                          NULL,
                          OPEN_EXISTING,
                          FILE_ATTRIBUTE_NORMAL,
                          NULL );
    if (hDevice == INVALID_HANDLE_VALUE) 
    {
        CloseServiceHandle(hSCManager);
        CloseServiceHandle(hService);
        MessageBox(NULL, L"Unable to open FileSpy device", L"Device Error", MB_OK|MB_ICONSTOP);
        return 0;
    }

    QueryDeviceAttachments();
    pDriveView->UpdateImage();

    // Create the polling thread
    hPollThread = CreateThread(NULL, 0, PollFileSpy, NULL, 0, &nPollThreadId);

    return 1;
}

DWORD ShutdownFileSpy(void)
{
    USHORT ti;

    for (ti = 0; ti < nTotalDrives; ti++)
    {
        if (VolInfo[ti].bHook)
        {
            DetachFromDrive( VolInfo[ti].nDriveName );
        }
    }
    CloseHandle(hDevice);
    CloseServiceHandle(hService);
    CloseServiceHandle(hSCManager);
    return 1;
}

BOOL QueryDeviceAttachments(void)
{
    WCHAR Buffer[BUFFER_SIZE];
    ULONG nBytesReturned;
    BOOL nReturnValue;
    USHORT ti;
    PATTACHED_DEVICE pDevice;

    nReturnValue = DeviceIoControl(hDevice, FILESPY_ListDevices, NULL, 0, Buffer, sizeof( Buffer ), &nBytesReturned, NULL);

    if (nReturnValue && nBytesReturned)
    {
        pDevice = (PATTACHED_DEVICE) Buffer;
        while ( ((char *)pDevice) < (((char *)Buffer) + nBytesReturned))
        {
            if (pDevice->LoggingOn)
            {
                //
                // Locate this drive in VolInfo and set its attachment status
                //
                for (ti = 0; ti < nTotalDrives; ti++)
                {
                    if (VolInfo[ti].nDriveName == towupper( pDevice->DeviceNames[0] ))
                    {
                        VolInfo[ti].bHook = 1;
                        VolInfo[ti].nImage += IMAGE_ATTACHSTART;
                    }
                }
            }
            pDevice++;
        }
    }       
    return nReturnValue;
}

DWORD AttachToDrive(WCHAR cDriveName)
{
    WCHAR sDriveString[5];
    DWORD nResult, nBytesReturned;

    wcscpy(sDriveString, L" :\0");
    sDriveString[0] = cDriveName;

    nResult = DeviceIoControl( hDevice, 
                               FILESPY_StartLoggingDevice, 
                               sDriveString, 
                               sizeof( sDriveString), 
                               NULL, 
                               0, 
                               &nBytesReturned, 
                               NULL);
    if (!nResult)
    {
        DisplayError(GetLastError());
        return 0;
    }
    return 1;
}

DWORD DetachFromDrive(WCHAR cDriveName)
{
    WCHAR sDriveString[5];
    DWORD nResult, nBytesReturned;

    wcscpy(sDriveString, L" :\0");
    sDriveString[0] = cDriveName;

    nResult = DeviceIoControl( hDevice, 
                               FILESPY_StopLoggingDevice, 
                               sDriveString, 
                               sizeof(sDriveString), 
                               NULL, 
                               0, 
                               &nBytesReturned, 
                               NULL );
    if (!nResult)
    {
        DisplayError(GetLastError());
        return 0;
    }
    return 1;
}

DWORD WINAPI PollFileSpy(LPVOID pParm)
{
    char pBuffer[BUFFER_SIZE];
    DWORD nBytesReturned, nResult;
    PLOG_RECORD pLog;
    CFileSpyView *pIrpView;
    CFastIoView *pFastView;
    CFsFilterView *pFilterView;    

    UNREFERENCED_PARAMETER( pParm );
    
    pIrpView = (CFileSpyView *) pSpyView;
    pFastView = (CFastIoView *) pFastIoView;
    pFilterView = (CFsFilterView *) pFsFilterView;
    
    while (1)
    {
        //
        // Start receiving log
        //
        nResult = DeviceIoControl(hDevice, FILESPY_GetLog, NULL, 0, pBuffer, \
                                    BUFFER_SIZE, &nBytesReturned, NULL);

		if (nResult) {

	        if (nBytesReturned > 0)
	        {
	            pLog = (PLOG_RECORD) pBuffer;

				while ((CHAR *) pLog < pBuffer + nBytesReturned) {

					switch (GET_RECORD_TYPE(pLog))
					{
					case RECORD_TYPE_IRP:
						DisplayIrpFields(pIrpView, pLog);
						break;
					case RECORD_TYPE_FASTIO:
						DisplayFastIoFields(pFastView, pLog);
						break;
				    case RECORD_TYPE_FS_FILTER_OP:
				        DisplayFsFilterFields(pFilterView, pLog);
				        break;
					default:
						//
						// Special handling required
						break;
					}

					//
					//  Move to the next LogRecord
					//

					pLog = (PLOG_RECORD) (((CHAR *) pLog) + pLog->Length);
				}
	        } 
	        else 
	        {
	            Sleep( 500 );
	        }
	        
	    } else {

	        return 1;

        }
    }
    return 1;
}

void DisplayIrpFields(CFileSpyView *pView, PLOG_RECORD pLog)
{
    INT nItem;
    CHAR cStr[128], cMnStr[128];
    WCHAR sStr[128], sMnStr[128];
    ULONG nameLength;

    if (IRPFilter[pLog->Record.RecordIrp.IrpMajor] == 0)
    {
        return;
    }
    else
    {
        if (nSuppressPagingIO && (pLog->Record.RecordIrp.IrpFlags & IRP_PAGING_IO || pLog->Record.RecordIrp.IrpFlags & IRP_SYNCHRONOUS_PAGING_IO))
        {
            return;
        }
    }

    nItem = pView->GetListCtrl().GetItemCount();

    //
    // nItem is 1 based but when we insert/delete items ListCtrl takes 0 based parameter
    // so automatically nItem gives an insertion number which is the last item
    //
    pView->GetListCtrl().InsertItem( nItem,L" " );
    pView->GetListCtrl().EnsureVisible( nItem, FALSE );

    //
    //  Sequence number
    //
    swprintf( sStr, L"%06X ", pLog->SequenceNumber );
    pView->GetListCtrl().SetItemText( nItem, 0, sStr );
    
    //
    //  Irp major and minor strings
    //
    
    GetIrpName( pLog->Record.RecordIrp.IrpMajor, 
                pLog->Record.RecordIrp.IrpMinor,
                (ULONG)(ULONG_PTR)pLog->Record.RecordIrp.Argument3,
                cStr, 
                cMnStr);
   
    MultiByteToWideChar(CP_ACP,0,cStr,-1,sStr,sizeof(sStr)/sizeof(WCHAR));
    MultiByteToWideChar(CP_ACP,0,cMnStr,-1,sMnStr,sizeof(sStr)/sizeof(WCHAR));

    pView->GetListCtrl().SetItemText( nItem, 1, sStr);
    pView->GetListCtrl().SetItemText( nItem, 2, sMnStr);
    
    //
    //  FileObject
    //
    swprintf( sStr, 
              L"%08X", 
              pLog->Record.RecordIrp.FileObject );
    pView->GetListCtrl().SetItemText( nItem, 3, sStr );

    //
    //  FileName
    //
    nameLength = pLog->Length - SIZE_OF_LOG_RECORD;
    swprintf( sStr, L"%.*s", nameLength/sizeof(WCHAR), pLog->Name );
    pView->GetListCtrl().SetItemText( nItem, 4, sStr );

    //
    //  Process and thread ids
    //
    swprintf( sStr, 
              L"%08X:%08X", 
              pLog->Record.RecordIrp.ProcessId, 
              pLog->Record.RecordIrp.ThreadId );
    pView->GetListCtrl().SetItemText( nItem, 5, sStr );

    //
    //  Originating time
    //
    GetTimeString( (FILETIME *) &pLog->Record.RecordIrp.OriginatingTime, sStr );
    pView->GetListCtrl().SetItemText( nItem, 6, sStr );

    //
    //  Completion time
    //
    GetTimeString( (FILETIME *) &pLog->Record.RecordIrp.CompletionTime, sStr );
    pView->GetListCtrl().SetItemText( nItem, 7, sStr );

    //
    //  Irp flags
    //
    GetFlagsString( pLog->Record.RecordIrp.IrpFlags, sStr );
    pView->GetListCtrl().SetItemText( nItem, 8, sStr );

    //
    //  Sequence number
    //
    swprintf( sStr, 
              L"%08lX:%08lX", 
              pLog->Record.RecordIrp.ReturnStatus, 
              pLog->Record.RecordIrp.ReturnInformation);
    pView->GetListCtrl().SetItemText( nItem, 9, sStr );
}

void DisplayFastIoFields(CFastIoView *pView, PLOG_RECORD pLog)
{
    INT nItem;
    CHAR cStr[128];
    WCHAR sStr[128];
    ULONG nameLength;

    if (FASTIOFilter[pLog->Record.RecordFastIo.Type] == 0)
    {
        return;
    }

    nItem = pView->GetListCtrl().GetItemCount();

    //
    // nItem is 1 based but when we insert/delete items ListCtrl takes 0 based parameter
    // so automatically nItem gives an insertion number which is the last item
    //
    pView->GetListCtrl().InsertItem( nItem, L" " );
    pView->GetListCtrl().EnsureVisible( nItem, FALSE );

    //
    //  Sequence number
    //
    swprintf( sStr, L"%06X ", pLog->SequenceNumber );
    pView->GetListCtrl().SetItemText( nItem, 0, sStr );

    //
    //  Fast IO type
    //
    GetFastioName( pLog->Record.RecordFastIo.Type, cStr );
    MultiByteToWideChar(CP_ACP,0,cStr,-1,sStr,sizeof(sStr)/sizeof(WCHAR));

    pView->GetListCtrl().SetItemText( nItem, 1, sStr );

    //
    //  FileObject
    //
    swprintf( sStr, L"%08X", pLog->Record.RecordFastIo.FileObject) ;
    pView->GetListCtrl().SetItemText( nItem, 2, sStr ); 

    //
    //  File name
    //
    nameLength = pLog->Length - SIZE_OF_LOG_RECORD;
    swprintf( sStr, L"%.*s", nameLength/sizeof(WCHAR), pLog->Name );
    pView->GetListCtrl().SetItemText( nItem, 3, sStr );

    //
    //  File offset
    //
    swprintf( sStr, L"%08X", pLog->Record.RecordFastIo.FileOffset );
    pView->GetListCtrl().SetItemText( nItem, 4, sStr );

    //
    //  File length
    //
    swprintf( sStr, L"%08X", pLog->Record.RecordFastIo.Length );
    pView->GetListCtrl().SetItemText( nItem, 5, sStr );
    
    //
    //  Fast IO can wait
    //
    if (pLog->Record.RecordFastIo.Wait)
    {
        pView->GetListCtrl().SetItemText(nItem, 6, L"True");
    }
    else
    {
        pView->GetListCtrl().SetItemText(nItem, 6, L"False");
    }
    
    //
    //  Thread and process ids
    //
    swprintf( sStr, 
             L"%08X:%08X", 
             pLog->Record.RecordFastIo.ProcessId, 
             pLog->Record.RecordFastIo.ThreadId );
    pView->GetListCtrl().SetItemText( nItem, 7, sStr );

    //
    //  Start time
    //
    GetTimeString( (FILETIME *) &pLog->Record.RecordFastIo.StartTime, 
                   sStr);
    pView->GetListCtrl().SetItemText( nItem, 8, sStr );

    //
    //  Completion time
    //
    GetTimeString( (FILETIME *) &pLog->Record.RecordFastIo.CompletionTime, sStr );
    pView->GetListCtrl().SetItemText( nItem, 9, sStr );

    //
    //  Return status
    //
    swprintf( sStr, L"%08X", pLog->Record.RecordFastIo.ReturnStatus );
    pView->GetListCtrl().SetItemText( nItem, 10, sStr );
}

void DisplayFsFilterFields(CFsFilterView *pView, PLOG_RECORD pLog)
{
    INT nItem;
    CHAR cStr[128];
    WCHAR sStr[128];
    ULONG nameLength;

    nItem = pView->GetListCtrl().GetItemCount();

    //
    // nItem is 1 based but when we insert/delete items ListCtrl takes 0 based parameter
    // so automatically nItem gives an insertion number which is the last item
    //
    pView->GetListCtrl().InsertItem( nItem, L" " );
    pView->GetListCtrl().EnsureVisible( nItem, FALSE );

    //
    //  Sequence number
    //
    swprintf( sStr, L"%06X ", pLog->SequenceNumber );
    pView->GetListCtrl().SetItemText( nItem, 0, sStr );

    //
    //  Fs Filter operation
    //
    
    GetFsFilterOperationName( pLog->Record.RecordFsFilterOp.FsFilterOperation, cStr );
    MultiByteToWideChar(CP_ACP,0,cStr,-1,sStr,sizeof(sStr)/sizeof(WCHAR));

    pView->GetListCtrl().SetItemText( nItem, 1, sStr );

    //
    //  FileObject
    //
    swprintf( sStr, L"%08X", pLog->Record.RecordFsFilterOp.FileObject );
    pView->GetListCtrl().SetItemText( nItem, 2, sStr );

    //
    //  File name
    //
    nameLength = pLog->Length - SIZE_OF_LOG_RECORD;
    swprintf( sStr, L"%.*s", nameLength/sizeof(WCHAR), pLog->Name );
    pView->GetListCtrl().SetItemText( nItem, 3, sStr );

    //
    //  Process and thread id
    //
    swprintf( sStr, 
              L"%08X:%08X", 
              pLog->Record.RecordFsFilterOp.ProcessId, 
              pLog->Record.RecordFsFilterOp.ThreadId );
    pView->GetListCtrl().SetItemText( nItem, 4, sStr );

    //
    //  Originating time
    //
    GetTimeString( (FILETIME *) &pLog->Record.RecordFsFilterOp.OriginatingTime, sStr );
    pView->GetListCtrl().SetItemText( nItem, 5, sStr );

    //
    //  Completion time
    //
    GetTimeString( (FILETIME *) &pLog->Record.RecordFsFilterOp.CompletionTime, sStr );
    pView->GetListCtrl().SetItemText( nItem, 6, sStr );

    //
    //  Return status
    //
    swprintf( sStr, L"%08X", pLog->Record.RecordFsFilterOp.ReturnStatus );
    pView->GetListCtrl().SetItemText( nItem, 7, sStr );
}

void GetFlagsString(DWORD nFlags, PWCHAR sStr)
{

    swprintf(sStr, L"%08lX ", nFlags);
    
    if (nFlags & IRP_NOCACHE)
    {
        wcscat( sStr, L"NOCACHE ");
    }
    if (nFlags & IRP_PAGING_IO)
    {
        wcscat(sStr, L"PAGEIO ");
    }
    if (nFlags & IRP_SYNCHRONOUS_API)
    {
        wcscat(sStr, L"SYNCAPI ");
    }
    if (nFlags & IRP_SYNCHRONOUS_PAGING_IO)
    {
        wcscat(sStr, L"SYNCPAGEIO");
    }
}


void GetTimeString(FILETIME *pFileTime, PWCHAR sStr)
{
    FILETIME LocalFileTime;
    SYSTEMTIME SystemTime;

    FileTimeToLocalFileTime(pFileTime, &LocalFileTime);
    FileTimeToSystemTime(&LocalFileTime, &SystemTime);

    swprintf( sStr, 
              L"%02d:%02d:%02d:%03d", 
              SystemTime.wHour, 
              SystemTime.wMinute,
              SystemTime.wSecond, 
              SystemTime.wMilliseconds);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\filespy\usergui\fastioview.h ===
#if !defined(AFX_FASTIOVIEW_H__9C4DA95F_33EF_42EF_B16F_81656827DECA__INCLUDED_)
#define AFX_FASTIOVIEW_H__9C4DA95F_33EF_42EF_B16F_81656827DECA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// FastIoView.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CFastIoView view

class CFastIoView : public CListView
{
protected:
	CFastIoView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CFastIoView)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFastIoView)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void OnDraw(CDC* pDC);      // overridden to draw this view
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CFastIoView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CFastIoView)
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_FASTIOVIEW_H__9C4DA95F_33EF_42EF_B16F_81656827DECA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\filespy\usergui\filespy.cpp ===
// FileSpy.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "FileSpyApp.h"

#include "MainFrm.h"
#include "FileSpyDoc.h"
#include "LeftView.h"

#define  MAINMODULE
#include "global.h"
#undef   MAINMODULE

#include "protos.h"
#include "init.cpp"
#include "drvcomm.cpp"
#include "support.cpp"
#include "drive.cpp"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFileSpyApp

BEGIN_MESSAGE_MAP(CFileSpyApp, CWinApp)
	//{{AFX_MSG_MAP(CFileSpyApp)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
	//}}AFX_MSG_MAP
	// Standard file based document commands
	ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
	ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFileSpyApp construction

CFileSpyApp::CFileSpyApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CFileSpyApp object

CFileSpyApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CFileSpyApp initialization

BOOL CFileSpyApp::InitInstance()
{
	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	// Change the registry key under which our settings are stored.
	// TODO: You should modify this string to be something appropriate
	// such as the name of your company or organization.
	SetRegistryKey(_T("Local AppWizard-Generated Applications"));

	LoadStdProfileSettings(0);  // Load standard INI file options (including MRU)


	//
	// Program Initialization
	//
	ProgramInit();


	// Register the application's document templates.  Document templates
	//  serve as the connection between documents, frame windows and views.

	CSingleDocTemplate* pDocTemplate;
	pDocTemplate = new CSingleDocTemplate(
		IDR_MAINFRAME,
		RUNTIME_CLASS(CFileSpyDoc),
		RUNTIME_CLASS(CMainFrame),       // main SDI frame window
		RUNTIME_CLASS(CLeftView));
	AddDocTemplate(pDocTemplate);

	// Parse command line for standard shell commands, DDE, file open
	CCommandLineInfo cmdInfo;
	ParseCommandLine(cmdInfo);

	// Dispatch commands specified on the command line
	if (!ProcessShellCommand(cmdInfo)) {
		return FALSE;
    }

	if (!StartFileSpy()) {
	    return FALSE;
	}

	//
	//Set main window title
	//
	m_pMainWnd->SetWindowText(L"FileSpy");


	// The one and only window has been initialized, so show and update it.
	m_pMainWnd->ShowWindow(SW_SHOW);
	m_pMainWnd->UpdateWindow();

	return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
		// No message handlers
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CFileSpyApp::OnAppAbout()
{
	CAboutDlg aboutDlg;
	aboutDlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CFileSpyApp message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\filespy\usergui\filespyapp.h ===
// FileSpy.h : main header file for the FILESPY application
//

#if !defined(AFX_FILESPY_H__177A9CDF_B3B4_41D6_B48C_79D0F309D152__INCLUDED_)
#define AFX_FILESPY_H__177A9CDF_B3B4_41D6_B48C_79D0F309D152__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CFileSpyApp:
// See FileSpy.cpp for the implementation of this class
//

class CFileSpyApp : public CWinApp
{
public:
	CFileSpyApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFileSpyApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation
	//{{AFX_MSG(CFileSpyApp)
	afx_msg void OnAppAbout();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_FILESPY_H__177A9CDF_B3B4_41D6_B48C_79D0F309D152__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\filespy\usergui\filespydoc.cpp ===
// FileSpyDoc.cpp : implementation of the CFileSpyDoc class
//

#include "stdafx.h"
#include "FileSpyApp.h"

#include "global.h"
#include "FileSpyDoc.h"
#include "filespyview.h"
#include "fastioview.h"
#include "fsfilterview.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFileSpyDoc

IMPLEMENT_DYNCREATE(CFileSpyDoc, CDocument)

BEGIN_MESSAGE_MAP(CFileSpyDoc, CDocument)
	//{{AFX_MSG_MAP(CFileSpyDoc)
	ON_COMMAND(ID_FILE_SAVE, OnFileSave)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFileSpyDoc construction/destruction

CFileSpyDoc::CFileSpyDoc()
{
	// TODO: add one-time construction code here

}

CFileSpyDoc::~CFileSpyDoc()
{
}

BOOL CFileSpyDoc::OnNewDocument()
{
	if (!CDocument::OnNewDocument())
		return FALSE;

	// TODO: add reinitialization code here
	// (SDI documents will reuse this document)

	return TRUE;
}



/////////////////////////////////////////////////////////////////////////////
// CFileSpyDoc serialization

void CFileSpyDoc::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
		// TODO: add storing code here
	}
	else
	{
		// TODO: add loading code here
	}
}

/////////////////////////////////////////////////////////////////////////////
// CFileSpyDoc diagnostics

#ifdef _DEBUG
void CFileSpyDoc::AssertValid() const
{
	CDocument::AssertValid();
}

void CFileSpyDoc::Dump(CDumpContext& dc) const
{
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CFileSpyDoc commands


void CFileSpyDoc::OnFileSave() 
{
	// TODO: Add your command handler code here
	OPENFILENAME OpenFileName;
	WCHAR sFilePath[1024];
	WCHAR sFileName[1024];
	WCHAR sFileStr[2048];
	WCHAR sStr[1024];
	WCHAR CRLF[3];
	WCHAR TAB[1];
	HANDLE hFile;
	long nSaved;
	int nMBRet, ti, nCount, tj;
	CFileSpyView *pIrp = (CFileSpyView *) pSpyView;
	CFastIoView *pFast = (CFastIoView *) pFastIoView;
	CFsFilterView *pFsFilter = (CFsFilterView *) pFsFilterView;
	DWORD nBytesWritten;


	if (pIrp->GetListCtrl().GetItemCount() == 0 && pFast->GetListCtrl().GetItemCount() == 0)
	{
		MessageBox(NULL, L"Nothing to save", L"FileSpy", MB_OK);
		return;
	}

	wcscpy(sFilePath, L"FILESPY.LOG");
	sFileName[0] = 0;
	OpenFileName.lStructSize = sizeof(OpenFileName);
	OpenFileName.hwndOwner = AfxGetMainWnd()->m_hWnd;
	OpenFileName.hInstance = AfxGetInstanceHandle();
	OpenFileName.Flags = OFN_HIDEREADONLY|OFN_NOREADONLYRETURN|OFN_PATHMUSTEXIST;
	OpenFileName.lpstrFilter = NULL;
	OpenFileName.lpstrCustomFilter = NULL;
	OpenFileName.nFilterIndex = 0;
	OpenFileName.lpstrFileTitle = sFileName;
	OpenFileName.nMaxFileTitle = 512;
	OpenFileName.lpstrInitialDir = NULL;
	OpenFileName.lpstrTitle = NULL;
	OpenFileName.lpstrDefExt = NULL;
	OpenFileName.lpfnHook = NULL;
	OpenFileName.lpstrFile = sFilePath;
	OpenFileName.nMaxFile = 512;

	if (!GetSaveFileName(&OpenFileName))
	{
		return;
	}
	hFile = CreateFile(sFilePath, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFile != INVALID_HANDLE_VALUE)
	{
		nMBRet = MessageBox(NULL, L"The selected file already exists. Do you want to append to it?", L"FileSpy", MB_YESNOCANCEL);
		if (nMBRet == IDCANCEL)
		{
			return;
		}
		if (nMBRet == IDYES)
		{
			SetFilePointer(hFile, 0, NULL, FILE_END);
		}
		else
		{
			CloseHandle(hFile);
			hFile = CreateFile(sFilePath, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
		}
	}
	else
	{
		hFile = CreateFile(sFilePath, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	}
	if (hFile == INVALID_HANDLE_VALUE)
	{
		MessageBox(NULL, L"File creation error", L"FileSpy - Error", MB_OK);
		return;
	}

	CRLF[0] = 0x0D;
	CRLF[1] = 0x0A;
	CRLF[2] = 0;
	TAB[0] = 0x9;
	TAB[1] = 0;

	WriteFile(hFile, CRLF, 2, &nBytesWritten, NULL);
	//
	// Write IRP header string
	//


	//
	// Start saving the traces now
	// First save IRP traces and then FASTIO
	//
	nCount = pIrp->GetListCtrl().GetItemCount();
	for (ti = 0; ti < nCount; ti++)
	{
		pIrp->GetListCtrl().GetItemText(ti, 0, sStr, 1024);
		wcscpy(sFileStr, sStr);
		for (tj = 1; tj < 10; tj++)
		{
			wcscat(sFileStr, TAB);
			pIrp->GetListCtrl().GetItemText(ti, tj, sStr, 1024);
			wcscat(sFileStr, sStr);
		}
		wcscat(sFileStr, CRLF);
		WriteFile(hFile, sFileStr, wcslen(sFileStr), &nBytesWritten, NULL);
	}
	nSaved = nCount;

	//
	// FastIO View now
	//
	nCount = pFast->GetListCtrl().GetItemCount();
	for (ti = 0; ti < nCount; ti++)
	{
		pFast->GetListCtrl().GetItemText(ti, 0, sStr, 1024);
		wcscpy(sFileStr, sStr);
		for (tj = 1; tj < 11; tj++)
		{
			wcscat(sFileStr, TAB);
			pFast->GetListCtrl().GetItemText(ti, tj, sStr, 1024);
			wcscat(sFileStr, sStr);
		}
		wcscat(sFileStr, CRLF);
		WriteFile(hFile, sFileStr, wcslen(sFileStr), &nBytesWritten, NULL);
	}
	CloseHandle(hFile);
	nSaved += nCount;
	swprintf(sStr, L"%ld traces saved", nSaved);
	MessageBox(NULL, sStr, L"FileSpy", MB_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\filespy\usergui\filespydoc.h ===
// FileSpyDoc.h : interface of the CFileSpyDoc class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_FILESPYDOC_H__C8DFCE29_6D9F_4261_A9AA_2306759C3BB7__INCLUDED_)
#define AFX_FILESPYDOC_H__C8DFCE29_6D9F_4261_A9AA_2306759C3BB7__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


class CFileSpyDoc : public CDocument
{
protected: // create from serialization only
	CFileSpyDoc();
	DECLARE_DYNCREATE(CFileSpyDoc)

// Attributes
public:
	LPVOID pBuffer;

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFileSpyDoc)
	public:
	virtual BOOL OnNewDocument();
	virtual void Serialize(CArchive& ar);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CFileSpyDoc();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CFileSpyDoc)
	afx_msg void OnFileSave();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_FILESPYDOC_H__C8DFCE29_6D9F_4261_A9AA_2306759C3BB7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\filespy\usergui\filespyview.cpp ===
// FileSpyView.cpp : implementation of the CFileSpyView class
//

#include "stdafx.h"
#include "FileSpyApp.h"

#include "FileSpyDoc.h"
#include "FileSpyView.h"

#include "global.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFileSpyView

IMPLEMENT_DYNCREATE(CFileSpyView, CListView)

BEGIN_MESSAGE_MAP(CFileSpyView, CListView)
	//{{AFX_MSG_MAP(CFileSpyView)
	ON_WM_KEYDOWN()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFileSpyView construction/destruction

CFileSpyView::CFileSpyView()
{
	// TODO: add construction code here
	pSpyView = (LPVOID) this;
}

CFileSpyView::~CFileSpyView()
{
}

BOOL CFileSpyView::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs
	cs.style |= LVS_REPORT | WS_HSCROLL | WS_VSCROLL;
	return CListView::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CFileSpyView drawing

void CFileSpyView::OnDraw(CDC* pDC)
{
    UNREFERENCED_PARAMETER( pDC );
    
	CFileSpyDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);
	CListCtrl& refCtrl = GetListCtrl();
	refCtrl.InsertItem(0, L"Item!");
	// TODO: add draw code for native data here
}

void CFileSpyView::OnInitialUpdate()
{
	CListView::OnInitialUpdate();


	// TODO: You may populate your ListView with items by directly accessing
	//  its list control through a call to GetListCtrl().

	//
	// Add the list header items
	//
	GetListCtrl().InsertColumn(0, L"S. No", LVCFMT_LEFT, 50);
	GetListCtrl().InsertColumn(1, L"Major Code", LVCFMT_LEFT, 100);
	GetListCtrl().InsertColumn(2, L"Minor Code", LVCFMT_LEFT, 100);
	GetListCtrl().InsertColumn(3, L"FileObject", LVCFMT_LEFT, 75);
	GetListCtrl().InsertColumn(4, L"Name", LVCFMT_LEFT, 250);
	GetListCtrl().InsertColumn(5, L"Process:Thread", LVCFMT_LEFT, 100);
	GetListCtrl().InsertColumn(6, L"OrgnTime", LVCFMT_LEFT, 78);
	GetListCtrl().InsertColumn(7, L"CompTime", LVCFMT_LEFT, 78);
	GetListCtrl().InsertColumn(8, L"Flags", LVCFMT_LEFT, 175);
	GetListCtrl().InsertColumn(9, L"Status:RetInfo", LVCFMT_LEFT, 100);
}

/////////////////////////////////////////////////////////////////////////////
// CFileSpyView diagnostics

#ifdef _DEBUG
void CFileSpyView::AssertValid() const
{
	CListView::AssertValid();
}

void CFileSpyView::Dump(CDumpContext& dc) const
{
	CListView::Dump(dc);
}

CFileSpyDoc* CFileSpyView::GetDocument() // non-debug version is inline
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CFileSpyDoc)));
	return (CFileSpyDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CFileSpyView message handlers
void CFileSpyView::OnStyleChanged(int nStyleType, LPSTYLESTRUCT lpStyleStruct)
{
	//TODO: add code to react to the user changing the view style of your window
	UNREFERENCED_PARAMETER( nStyleType );
	UNREFERENCED_PARAMETER( lpStyleStruct );
}


void CFileSpyView::OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint) 
{
	// TODO: Add your specialized code here and/or call the base class
	UNREFERENCED_PARAMETER( pSender );
	UNREFERENCED_PARAMETER( lHint );
	UNREFERENCED_PARAMETER( pHint );
}


void CFileSpyView::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	// TODO: Add your message handler code here and/or call default
	int ti, oldti;
	
	if (nChar == VK_DELETE)
	{
		ti = 0;
		oldti = 0;
		while(ti < GetListCtrl().GetItemCount())
		{
			if (GetListCtrl().GetItemState(ti, LVIS_SELECTED) & LVIS_SELECTED)
			{
				GetListCtrl().DeleteItem(ti);
				oldti = ti;
			}
			else
			{
				ti++;
			}
		}
		if (oldti < GetListCtrl().GetItemCount())
		{
			GetListCtrl().SetItemState(oldti, LVIS_SELECTED, LVIS_SELECTED);
		}
		else
		{
			GetListCtrl().SetItemState(oldti-1, LVIS_SELECTED, LVIS_SELECTED);
		}
	}
	CListView::OnKeyDown(nChar, nRepCnt, nFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\filespy\usergui\filespyview.h ===
// FileSpyView.h : interface of the CFileSpyView class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_FILESPYVIEW_H__D19318D3_9763_4FDC_93B8_535C29C978B1__INCLUDED_)
#define AFX_FILESPYVIEW_H__D19318D3_9763_4FDC_93B8_535C29C978B1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


class CFileSpyView : public CListView
{
protected: // create from serialization only
	CFileSpyView();
	DECLARE_DYNCREATE(CFileSpyView)

// Attributes
public:
	CFileSpyDoc* GetDocument();

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFileSpyView)
	public:
	virtual void OnDraw(CDC* pDC);  // overridden to draw this view
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	protected:
	virtual void OnInitialUpdate(); // called first time after construct
	virtual void OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CFileSpyView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CFileSpyView)
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	//}}AFX_MSG
	afx_msg void OnStyleChanged(int nStyleType, LPSTYLESTRUCT lpStyleStruct);
	DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in FileSpyView.cpp
inline CFileSpyDoc* CFileSpyView::GetDocument()
   { return (CFileSpyDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_FILESPYVIEW_H__D19318D3_9763_4FDC_93B8_535C29C978B1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\filespy\usergui\filterdlg.h ===
#if !defined(AFX_FILTERDLG_H__89CBEC30_0250_4AF7_AABB_B1AD9251C0FF__INCLUDED_)
#define AFX_FILTERDLG_H__89CBEC30_0250_4AF7_AABB_B1AD9251C0FF__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// FilterDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CFilterDlg dialog

class CFilterDlg : public CDialog
{
// Construction
public:
	CFilterDlg(CWnd* pParent = NULL);   // standard constructor
	~CFilterDlg(void);
	LPCTSTR MakeShortString(CDC* pDC, LPCTSTR lpszLong, int nColumnLen, int nOffset);
	CImageList *m_pImageList;

// Dialog Data
	//{{AFX_DATA(CFilterDlg)
	enum { IDD = IDD_IRPFASTIOFILTER };
	CButton	m_SuppressPageIo;
	CButton	m_ApplyInDriver;
	CButton	m_ApplyInDisplay;
	CListCtrl	m_IrpList;
	CListCtrl	m_FastList;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFilterDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CFilterDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnIrpselectall();
	afx_msg void OnFastioselectall();
	afx_msg void OnClickIrplist(NMHDR* pNMHDR, LRESULT* pResult);
	virtual void OnOK();
	afx_msg void OnClickFastiolist(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnFastiodeselectall();
	afx_msg void OnIrpdeselectall();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_FILTERDLG_H__89CBEC30_0250_4AF7_AABB_B1AD9251C0FF__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\filespy\usergui\fsfilterview.cpp ===
// FastIoView.cpp : implementation file
//

#include "stdafx.h"
#include "FileSpyApp.h"
#include "FsFilterView.h"

#include "global.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFsFilterView

IMPLEMENT_DYNCREATE(CFsFilterView, CListView)

CFsFilterView::CFsFilterView()
{
	pFsFilterView = (LPVOID) this;
}

CFsFilterView::~CFsFilterView()
{
}


BEGIN_MESSAGE_MAP(CFsFilterView, CListView)
	//{{AFX_MSG_MAP(CFsFilterView)
	ON_WM_KEYDOWN()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFsFilterView drawing

void CFsFilterView::OnDraw(CDC* pDC)
{
    UNREFERENCED_PARAMETER( pDC );
    
	CDocument* pDoc = GetDocument();
	// TODO: add draw code here
}

/////////////////////////////////////////////////////////////////////////////
// CFsFilterView diagnostics+

#ifdef _DEBUG
void CFsFilterView::AssertValid() const
{
	CListView::AssertValid();
}

void CFsFilterView::Dump(CDumpContext& dc) const
{
	CListView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CFsFilterView message handlers

BOOL CFsFilterView::PreCreateWindow(CREATESTRUCT& cs) 
{
	// TODO: Add your specialized code here and/or call the base class
	cs.style |= LVS_REPORT | WS_HSCROLL | WS_VSCROLL;
	return CListView::PreCreateWindow(cs);
}

void CFsFilterView::OnInitialUpdate() 
{
	CListView::OnInitialUpdate();
	
	// TODO: Add your specialized code here and/or call the base class
	//
	// Add the list header items
	//
	GetListCtrl().InsertColumn(0, L"S. No", LVCFMT_LEFT, 50);
	GetListCtrl().InsertColumn(1, L"FsFilter Operation", LVCFMT_LEFT, 100);
	GetListCtrl().InsertColumn(2, L"FileObject", LVCFMT_LEFT, 75);
	GetListCtrl().InsertColumn(3, L"Name", LVCFMT_LEFT, 250);
	GetListCtrl().InsertColumn(4, L"Process:Thread", LVCFMT_LEFT, 100);
	GetListCtrl().InsertColumn(5, L"OrgnTime", LVCFMT_LEFT, 78);
	GetListCtrl().InsertColumn(6, L"CompTime", LVCFMT_LEFT, 78);
	GetListCtrl().InsertColumn(7, L"Return Status", LVCFMT_LEFT, 100);
}

void CFsFilterView::OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags) 
{
	// TODO: Add your message handler code here and/or call default
	int ti, oldti;
	
	if (nChar == VK_DELETE)
	{
		ti = 0;
		oldti = 0;
		while(ti < GetListCtrl().GetItemCount())
		{
			if (GetListCtrl().GetItemState(ti, LVIS_SELECTED) & LVIS_SELECTED)
			{
				GetListCtrl().DeleteItem(ti);
				oldti = ti;
			}
			else
			{
				ti++;
			}
		}
		if (oldti < GetListCtrl().GetItemCount())
		{
			GetListCtrl().SetItemState(oldti, LVIS_SELECTED, LVIS_SELECTED);
		}
		else
		{
			GetListCtrl().SetItemState(oldti-1, LVIS_SELECTED, LVIS_SELECTED);
		}
	}
	
	CListView::OnKeyDown(nChar, nRepCnt, nFlags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\filespy\usergui\filterdlg.cpp ===
// FilterDlg.cpp : implementation file
//

#include "stdafx.h"
#include "FileSpyApp.h"
#include "FilterDlg.h"
#include "filespyLib.h"

#include "global.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFilterDlg dialog
#define OFFSET_FIRST	2
#define OFFSET_OTHER	6


CFilterDlg::CFilterDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CFilterDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CFilterDlg)
	//}}AFX_DATA_INIT
	m_pImageList = new CImageList;
	m_pImageList->Create(IDB_STATEIMAGELIST,16,0,RGB(255,255,255));
}

CFilterDlg::~CFilterDlg(void)
{
	if (m_pImageList)
	{
		delete m_pImageList;
	}
}


void CFilterDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFilterDlg)
	DDX_Control(pDX, IDC_SUPPRESSPAGEIO, m_SuppressPageIo);
	DDX_Control(pDX, IDC_IRPLIST, m_IrpList);
	DDX_Control(pDX, IDC_FASTIOLIST, m_FastList);
	//}}AFX_DATA_MAP
}

LPCTSTR CFilterDlg::MakeShortString(CDC* pDC, LPCTSTR lpszLong, int nColumnLen, int nOffset)
{
	static const _TCHAR szThreeDots[] = _T("...");

	int nStringLen = lstrlen(lpszLong);

	if(nStringLen == 0 ||
		(pDC->GetTextExtent(lpszLong, nStringLen).cx + nOffset) <= nColumnLen)
	{
		return(lpszLong);
	}

	static _TCHAR szShort[MAX_PATH];

	lstrcpy(szShort,lpszLong);
	int nAddLen = pDC->GetTextExtent(szThreeDots,sizeof(szThreeDots)).cx;

	for(int i = nStringLen-1; i > 0; i--)
	{
		szShort[i] = 0;
		if((pDC->GetTextExtent(szShort, i).cx + nOffset + nAddLen)
			<= nColumnLen)
		{
			break;
		}
	}

	lstrcat(szShort, szThreeDots);
	return(szShort);
}

BEGIN_MESSAGE_MAP(CFilterDlg, CDialog)
	//{{AFX_MSG_MAP(CFilterDlg)
	ON_BN_CLICKED(IDC_IRPSELECTALL, OnIrpselectall)
	ON_BN_CLICKED(IDC_FASTIOSELECTALL, OnFastioselectall)
	ON_NOTIFY(NM_CLICK, IDC_IRPLIST, OnClickIrplist)
	ON_NOTIFY(NM_CLICK, IDC_FASTIOLIST, OnClickFastiolist)
	ON_BN_CLICKED(IDC_FASTIODESELECTALL, OnFastiodeselectall)
	ON_BN_CLICKED(IDC_IRPDESELECTALL, OnIrpdeselectall)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CFilterDlg message handlers


BOOL CFilterDlg::OnInitDialog() 
{
	CDialog::OnInitDialog();
	// TODO: Add extra initialization here
	int ti;
	LV_COLUMN ListColumn;
	LV_ITEM ListItem;

	m_IrpList.SetImageList(m_pImageList, LVSIL_STATE);
	m_FastList.SetImageList(m_pImageList, LVSIL_STATE);

	ListColumn.mask = LVCF_TEXT|LVCF_WIDTH;
	ListColumn.pszText = L"IRP Codes";
	ListColumn.cx = 145;
	m_IrpList.InsertColumn(0, &ListColumn);

	ListColumn.mask = LVCF_TEXT|LVCF_WIDTH;
	ListColumn.pszText = L"FASTIO Entries";
	ListColumn.cx = 145;
	m_FastList.InsertColumn(0, &ListColumn);


	// Create IRP list
	for (ti = 0; ti < IRP_MJ_MAXIMUM_FUNCTION+1; ti++)
	{
		ListItem.mask = LVIF_TEXT|LVIF_STATE;
		ListItem.iItem = m_IrpList.GetItemCount();
		ListItem.iSubItem = 0;
		ListItem.iImage = 1;
		if (IRPFilter[ti])
		{
			ListItem.state = INDEXTOSTATEIMAGEMASK(2);
		}
		else
		{
			ListItem.state = INDEXTOSTATEIMAGEMASK(1);
		}
		ListItem.stateMask = LVIS_STATEIMAGEMASK;
		ListItem.pszText = IrpNameList[ti];
		m_IrpList.InsertItem(&ListItem);
	}
	
	// Create FASTIO List
	for (ti = 0; ti < FASTIO_MAX_OPERATION; ti++)
	{
		ListItem.mask = LVIF_TEXT|LVIF_STATE;
		ListItem.iItem = m_FastList.GetItemCount();
		ListItem.iSubItem = 0;
		ListItem.iImage = 1;
		if (FASTIOFilter[ti])
		{
			ListItem.state = INDEXTOSTATEIMAGEMASK(2);
		}
		else
		{
			ListItem.state = INDEXTOSTATEIMAGEMASK(1);
		}
		ListItem.stateMask = LVIS_STATEIMAGEMASK;
		ListItem.pszText = FastIoNameList[ti];
		m_FastList.InsertItem(&ListItem);
	}

	// Set SupressPagingIO state
	if (nSuppressPagingIO)
	{
		m_SuppressPageIo.SendMessage(BM_SETCHECK, BST_CHECKED, 0);
	}
	else
	{
		m_SuppressPageIo.SendMessage(BM_SETCHECK, BST_UNCHECKED, 0);
	}
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CFilterDlg::OnIrpselectall() 
{
	// TODO: Add your control notification handler code here
	int ti;
	
	for (ti = 0; ti < IRP_MJ_MAXIMUM_FUNCTION+1; ti++)
	{
		m_IrpList.SetItemState(ti, INDEXTOSTATEIMAGEMASK(2), LVIS_STATEIMAGEMASK);
	}
}

void CFilterDlg::OnFastioselectall() 
{
	// TODO: Add your control notification handler code here
	int ti;
	
	for (ti = 0; ti < FASTIO_MAX_OPERATION; ti++)
	{
		m_FastList.SetItemState(ti, INDEXTOSTATEIMAGEMASK(2), LVIS_STATEIMAGEMASK);
	}
}

void CFilterDlg::OnClickIrplist(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// TODO: Add your control notification handler code here
	LVHITTESTINFO hti;
	int nHit;
	UINT State;
	CRect rect;
	CPoint point;
	RECT rectWindow;

	UNREFERENCED_PARAMETER( pNMHDR );
	
	*pResult = 0;

	GetCursorPos(&point);
	m_IrpList.GetWindowRect(&rectWindow);
	point.x = point.x - rectWindow.left;
	point.y = point.y - rectWindow.top;

	hti.pt.x = point.x;
	hti.pt.y = point.y;

	
	nHit = m_IrpList.HitTest(&hti);

	if (nHit == -1)
	{
		return;
	}

	if (!(hti.flags & LVHT_ONITEMSTATEICON))
	{
		return;
	}
	else
	{
		State = m_IrpList.GetItemState(nHit, LVIS_STATEIMAGEMASK);
		if (State == 8192)
		{
			m_IrpList.SetItemState(nHit, INDEXTOSTATEIMAGEMASK(1), LVIS_STATEIMAGEMASK);
			m_IrpList.GetItemRect(nHit, &rect, LVIR_BOUNDS);
			::InvalidateRect(m_IrpList.m_hWnd, LPRECT(rect), TRUE);
		}
		else
		{
			m_IrpList.SetItemState(nHit, INDEXTOSTATEIMAGEMASK(2), LVIS_STATEIMAGEMASK);
		}
	}
}

void CFilterDlg::OnClickFastiolist(NMHDR* pNMHDR, LRESULT* pResult) 
{
	// TODO: Add your control notification handler code here
	LVHITTESTINFO hti;
	int nHit;
	UINT State;
	CRect rect;
	CPoint point;
	RECT rectWindow;

	UNREFERENCED_PARAMETER( pNMHDR );
	
	*pResult = 0;

	GetCursorPos(&point);
	m_FastList.GetWindowRect(&rectWindow);
	point.x = point.x - rectWindow.left;
	point.y = point.y - rectWindow.top;

	hti.pt.x = point.x;
	hti.pt.y = point.y;

	
	nHit = m_FastList.HitTest(&hti);

	if (nHit == -1)
	{
		return;
	}

	if (!(hti.flags & LVHT_ONITEMSTATEICON))
	{
		return;
	}
	else
	{
		State = m_FastList.GetItemState(nHit, LVIS_STATEIMAGEMASK);
		if (State == 8192)
		{
			m_FastList.SetItemState(nHit, INDEXTOSTATEIMAGEMASK(1), LVIS_STATEIMAGEMASK);
			m_FastList.GetItemRect(nHit, &rect, LVIR_BOUNDS);
			::InvalidateRect(m_FastList.m_hWnd, LPRECT(rect), TRUE);
		}
		else
		{
			m_FastList.SetItemState(nHit, INDEXTOSTATEIMAGEMASK(2), LVIS_STATEIMAGEMASK);
		}
	}
}

void CFilterDlg::OnOK() 
{
	// TODO: Add extra validation here
	int ti;

	for (ti = 0; ti < IRP_MJ_MAXIMUM_FUNCTION+1; ti++)
	{
		if (m_IrpList.GetItemState(ti, LVIS_STATEIMAGEMASK) == 8192)
		{
			IRPFilter[ti] = 1;
		}
		else
		{
			IRPFilter[ti] = 0;
		}
	}

	for (ti = 0; ti < FASTIO_MAX_OPERATION; ti++)
	{
		if (m_FastList.GetItemState(ti, LVIS_STATEIMAGEMASK) == 8192)
		{
			FASTIOFilter[ti] = 1;
		}
		else
		{
			FASTIOFilter[ti] = 0;
		}

	}

	if (m_SuppressPageIo.SendMessage(BM_GETCHECK, 0, 0) == BST_CHECKED)
	{
		nSuppressPagingIO = 1;
	}
	else
	{
		nSuppressPagingIO = 0;
	}
	CDialog::OnOK();
}


void CFilterDlg::OnFastiodeselectall() 
{
	// TODO: Add your control notification handler code here
	int ti;
	
	for (ti = 0; ti < FASTIO_MAX_OPERATION; ti++)
	{
		m_FastList.SetItemState(ti, INDEXTOSTATEIMAGEMASK(1), LVIS_STATEIMAGEMASK);
	}
}

void CFilterDlg::OnIrpdeselectall() 
{
	// TODO: Add your control notification handler code here
	int ti;
	
	for (ti = 0; ti < IRP_MJ_MAXIMUM_FUNCTION+1; ti++)
	{
		m_IrpList.SetItemState(ti, INDEXTOSTATEIMAGEMASK(1), LVIS_STATEIMAGEMASK);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\filespy\usergui\init.cpp ===
//
// Initialize or allocate any global resources here
//
void ProgramInit(void)
{
	int ti;
	nTotalDrives = BuildDriveTable(VolInfo);

	for (ti = 0; ti < IRP_MJ_MAXIMUM_FUNCTION+1; ti++)
	{
		//
		// Enabled by default
		//
		IRPFilter[ti] = 1;
	}

	for (ti = 0; ti < FASTIO_MAX_OPERATION; ti++)
	{
		//
		// Enabled by default
		//
		FASTIOFilter[ti] = 1;
	}

	//
	// Disabled by default
	//
	nSuppressPagingIO = 0;
}

//
// Release any global resources here
//
void ProgramExit(void)
{
	//
	// !?!
	// Before we get here MFC terminates this thread!!!
	// 
	TerminateThread(hPollThread, 1);

	ShutdownFileSpy();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\filespy\usergui\fsfilterview.h ===
#if !defined(AFX_FSFILTERVIEW_H__9C4DA95F_33EF_42EF_B16F_81656827DECA__INCLUDED_)
#define AFX_FSFILTERVIEW_H__9C4DA95F_33EF_42EF_B16F_81656827DECA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// FsFilterView.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CFsFilterView view

class CFsFilterView : public CListView
{
protected:
	CFsFilterView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CFsFilterView)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFsFilterView)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void OnDraw(CDC* pDC);      // overridden to draw this view
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CFsFilterView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(CFsFilterView)
	afx_msg void OnKeyDown(UINT nChar, UINT nRepCnt, UINT nFlags);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_FASTIOVIEW_H__9C4DA95F_33EF_42EF_B16F_81656827DECA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\filespy\usergui\global.h ===
#ifndef __GLOBAL_H__
#define __GLOBAL_H__

#include <filespy.h>
#include "define.h"

#include <windows.h>
#include <winioctl.h>
#include <winsvc.h>

// Global variables

#ifdef MAINMODULE
#define EXTERN
#else
#define EXTERN extern
#endif

//
// Buffer size
//
#define BUFFER_SIZE 4096

//
// Image list values
//
#define IMAGE_FIXEDDRIVE 0
#define IMAGE_REMOTEDRIVE 1
#define IMAGE_REMOVABLEDRIVE 2
#define IMAGE_CDROMDRIVE 3
#define IMAGE_UNKNOWNDRIVE 4
#define IMAGE_SPY	5
#define IMAGE_ATTACHSTART 6

typedef struct _VOLINFO
{
    WCHAR nDriveName;
    WCHAR sVolumeLable[20];
    ULONG nType;
    BOOLEAN bHook;
    CCHAR nImage;
} VOLINFO, *PVOLINFO;

EXTERN SC_HANDLE hSCManager;
EXTERN SC_HANDLE hService;
EXTERN SERVICE_STATUS_PROCESS ServiceInfo;
EXTERN HANDLE hDevice;
EXTERN ULONG nPollThreadId;
EXTERN HANDLE hPollThread;
EXTERN VOLINFO VolInfo[26];
EXTERN USHORT nTotalDrives;
EXTERN LPVOID pSpyView;
EXTERN LPVOID pFastIoView;
EXTERN LPVOID pFsFilterView;
EXTERN LPVOID pLeftView;
EXTERN int IRPFilter[IRP_MJ_MAXIMUM_FUNCTION+1];
EXTERN int FASTIOFilter[FASTIO_MAX_OPERATION];
EXTERN int nSuppressPagingIO;

#endif /* __GLOBAL_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\filespy\usergui\leftview.h ===
// LeftView.h : interface of the CLeftView class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_LEFTVIEW_H__F23CDADF_7629_455B_AEBF_9968AB10CA64__INCLUDED_)
#define AFX_LEFTVIEW_H__F23CDADF_7629_455B_AEBF_9968AB10CA64__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CFileSpyDoc;

class CLeftView : public CTreeView
{
protected: // create from serialization only
	CLeftView();
	DECLARE_DYNCREATE(CLeftView)

// Attributes
public:
	CFileSpyDoc* GetDocument();
	CImageList *m_pImageList;
	HTREEITEM hRootItem;
	char nRButtonSet;

// Operations
public:
	USHORT GetAssociatedVolumeIndex(HTREEITEM hItem);
	HTREEITEM GetAssociatedhItem(WCHAR cDriveName);
	void UpdateImage(void);
// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CLeftView)
	public:
	virtual void OnDraw(CDC* pDC);  // overridden to draw this view
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	protected:
	virtual void OnInitialUpdate(); // called first time after construct
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CLeftView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CLeftView)
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnRButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMenuattach();
	afx_msg void OnMenudetach();
	afx_msg void OnMenuattachall();
	afx_msg void OnMenudetachall();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in LeftView.cpp
inline CFileSpyDoc* CLeftView::GetDocument()
   { return (CFileSpyDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_LEFTVIEW_H__F23CDADF_7629_455B_AEBF_9968AB10CA64__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\filespy\usergui\mainfrm.cpp ===
// MainFrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"
#include "FileSpyApp.h"

#include "MainFrm.h"
#include "LeftView.h"
#include "FileSpyView.h"
#include "FastIoView.h"
#include "FsFilterView.h"
#include "FilterDlg.h"

#include "global.h"
#include "protos.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
    //{{AFX_MSG_MAP(CMainFrame)
    ON_WM_CREATE()
    ON_WM_DESTROY()
    ON_COMMAND(ID_EDIT_FILTERS, OnEditFilters)
    ON_COMMAND(ID_EDIT_CLEARFASTIO, OnEditClearfastio)
    ON_COMMAND(ID_EDIT_CLEARIRP, OnEditClearirp)
    ON_COMMAND(ID_EDIT_CLEARFSFILTER, OnEditClearfsfilter)
    //}}AFX_MSG_MAP
    // Global help commands
    ON_COMMAND(ID_HELP_FINDER, CFrameWnd::OnHelpFinder)
    ON_COMMAND(ID_HELP, CFrameWnd::OnHelp)
    ON_COMMAND(ID_CONTEXT_HELP, CFrameWnd::OnContextHelp)
    ON_COMMAND(ID_DEFAULT_HELP, CFrameWnd::OnHelpFinder)
    ON_UPDATE_COMMAND_UI_RANGE(AFX_ID_VIEW_MINIMUM, AFX_ID_VIEW_MAXIMUM, OnUpdateViewStyles)
    ON_COMMAND_RANGE(AFX_ID_VIEW_MINIMUM, AFX_ID_VIEW_MAXIMUM, OnViewStyle)
END_MESSAGE_MAP()

static UINT indicators[] =
{
    ID_SEPARATOR,           // status line indicator
    ID_INDICATOR_CAPS,
    ID_INDICATOR_NUM,
    ID_INDICATOR_SCRL,
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
    // TODO: add member initialization code here
    
}

CMainFrame::~CMainFrame()
{
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
        return -1;
    
    if (!m_wndToolBar.CreateEx(this) ||
        !m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
    {
        TRACE0("Failed to create toolbar\n");
        return -1;      // fail to create
    }
/*  if (!m_wndDlgBar.Create(this, IDR_MAINFRAME, 
        CBRS_ALIGN_TOP, AFX_IDW_DIALOGBAR))
    {
        TRACE0("Failed to create dialogbar\n");
        return -1;      // fail to create
    }
*/
    if (!m_wndReBar.Create(this) ||
        !m_wndReBar.AddBar(&m_wndToolBar)) /*||
        !m_wndReBar.AddBar(&m_wndDlgBar)) */
    {
        TRACE0("Failed to create rebar\n");
        return -1;      // fail to create
    }

    if (!m_wndStatusBar.Create(this) ||
        !m_wndStatusBar.SetIndicators(indicators,
          sizeof(indicators)/sizeof(UINT)))
    {
        TRACE0("Failed to create status bar\n");
        return -1;      // fail to create
    }

    // TODO: Remove this if you don't want tool tips
    m_wndToolBar.SetBarStyle(m_wndToolBar.GetBarStyle() |
        CBRS_TOOLTIPS | CBRS_FLYBY);

    return 0;
}

BOOL CMainFrame::OnCreateClient(LPCREATESTRUCT /*lpcs*/,
    CCreateContext* pContext)
{
    // create splitter window
    if (!m_wndSplitter.CreateStatic(this, 1, 2))
        return FALSE;
    if (!m_wndSplitter2.CreateStatic(&m_wndSplitter, 3, 1, WS_CHILD|WS_VISIBLE|WS_BORDER, m_wndSplitter.IdFromRowCol(0, 1)))
    {
        m_wndSplitter.DestroyWindow();
        return FALSE;
    }

    if (!m_wndSplitter.CreateView(0, 0, RUNTIME_CLASS(CLeftView), CSize(100, 100), pContext) ||
        !m_wndSplitter2.CreateView(0, 0, RUNTIME_CLASS(CFileSpyView), CSize(100, 100), pContext) ||
        !m_wndSplitter2.CreateView(1, 0, RUNTIME_CLASS(CFastIoView), CSize(100, 100), pContext) ||
        !m_wndSplitter2.CreateView(2, 0, RUNTIME_CLASS(CFsFilterView), CSize(100, 100), pContext))
    {
        m_wndSplitter.DestroyWindow();
        return FALSE;
    }
    m_wndSplitter.SetColumnInfo(0, 170, 0);
    m_wndSplitter2.SetRowInfo(0, 225, 0);
    m_wndSplitter.RecalcLayout();
    m_wndSplitter.RecalcLayout();

    return TRUE;
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
    if( !CFrameWnd::PreCreateWindow(cs) )
        return FALSE;
    // TODO: Modify the Window class or styles here by modifying
    //  the CREATESTRUCT cs

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
    CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
    CFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers

CFileSpyView* CMainFrame::GetRightPane()
{
    CWnd* pWnd = m_wndSplitter.GetPane(0, 1);
    CFileSpyView* pView = DYNAMIC_DOWNCAST(CFileSpyView, pWnd);
    return pView;
}

void CMainFrame::OnUpdateViewStyles(CCmdUI* pCmdUI)
{
    // TODO: customize or extend this code to handle choices on the
    // View menu.

    CFileSpyView* pView = GetRightPane(); 

    // if the right-hand pane hasn't been created or isn't a view,
    // disable commands in our range

    if (pView == NULL)
        pCmdUI->Enable(FALSE);
    else
    {
        DWORD dwStyle = pView->GetStyle() & LVS_TYPEMASK;

        // if the command is ID_VIEW_LINEUP, only enable command
        // when we're in LVS_ICON or LVS_SMALLICON mode

        if (pCmdUI->m_nID == ID_VIEW_LINEUP)
        {
            if (dwStyle == LVS_ICON || dwStyle == LVS_SMALLICON)
                pCmdUI->Enable();
            else
                pCmdUI->Enable(FALSE);
        }
        else
        {
            // otherwise, use dots to reflect the style of the view
            pCmdUI->Enable();
            BOOL bChecked = FALSE;

            switch (pCmdUI->m_nID)
            {
            case ID_VIEW_DETAILS:
                bChecked = (dwStyle == LVS_REPORT);
                break;

            case ID_VIEW_SMALLICON:
                bChecked = (dwStyle == LVS_SMALLICON);
                break;

            case ID_VIEW_LARGEICON:
                bChecked = (dwStyle == LVS_ICON);
                break;

            case ID_VIEW_LIST:
                bChecked = (dwStyle == LVS_LIST);
                break;

            default:
                bChecked = FALSE;
                break;
            }

            pCmdUI->SetRadio(bChecked ? 1 : 0);
        }
    }
}


void CMainFrame::OnViewStyle(UINT nCommandID)
{
    // TODO: customize or extend this code to handle choices on the
    // View menu.
    CFileSpyView* pView = GetRightPane();

    // if the right-hand pane has been created and is a CFileSpyView,
    // process the menu commands...
    if (pView != NULL)
    {
        DWORD dwStyle = (DWORD)-1;

        switch (nCommandID)
        {
        case ID_VIEW_LINEUP:
            {
                // ask the list control to snap to grid
                CListCtrl& refListCtrl = pView->GetListCtrl();
                refListCtrl.Arrange(LVA_SNAPTOGRID);
            }
            break;

        // other commands change the style on the list control
        case ID_VIEW_DETAILS:
            dwStyle = LVS_REPORT;
            break;

        case ID_VIEW_SMALLICON:
            dwStyle = LVS_SMALLICON;
            break;

        case ID_VIEW_LARGEICON:
            dwStyle = LVS_ICON;
            break;

        case ID_VIEW_LIST:
            dwStyle = LVS_LIST;
            break;
        }

        // change the style; window will repaint automatically
        if (dwStyle != -1)
            pView->ModifyStyle(LVS_TYPEMASK, dwStyle);
    }
}

void CMainFrame::OnDestroy() 
{
    CFrameWnd::OnDestroy();
    
    // TODO: Add your message handler code here
    ProgramExit();  
}

void CMainFrame::OnEditFilters() 
{
    // TODO: Add your command handler code here
    CFilterDlg cfd;

    cfd.DoModal();
    
}

void CMainFrame::OnEditClearfastio() 
{
    // TODO: Add your command handler code here
    CFastIoView *pView;

    pView = (CFastIoView *) pFastIoView;
    pView->GetListCtrl().DeleteAllItems();
}

void CMainFrame::OnEditClearirp() 
{
    // TODO: Add your command handler code here
    CFileSpyView* pView;
    
    pView = (CFileSpyView *) pSpyView;
    pView->GetListCtrl().DeleteAllItems();
}

void CMainFrame::OnEditClearfsfilter() 
{
    // TODO: Add your command handler code here
    CFsFilterView* pView;
    
    pView = (CFsFilterView *) pFsFilterView;
    pView->GetListCtrl().DeleteAllItems();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\filespy\usergui\protos.h ===
#include "global.h"

//
// Init.cpp
//
void ProgramInit(void);
void ProgramExit(void);

//
// DrvComm.cpp
//
DWORD StartFileSpy(void);
DWORD ShutdownFileSpy(void);
BOOL QueryDeviceAttachments(void);
DWORD AttachToDrive(WCHAR cDriveName);
DWORD DetachFromDrive(WCHAR cDriveName);
DWORD WINAPI PollFileSpy(LPVOID pParm);
void GetFlagsString(DWORD nFlags, PWCHAR sStr);
void GetTimeString(FILETIME *pFileTime, PWCHAR sStr);

//
// Support.cpp
//
void DisplayError(DWORD nCode);

//
// Drive.cpp
//
USHORT BuildDriveTable(VOLINFO *pVolInfo);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\filespy\usergui\mainfrm.h ===
// MainFrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MAINFRM_H__7F1D7310_0433_406F_8D82_205D723EAE2F__INCLUDED_)
#define AFX_MAINFRM_H__7F1D7310_0433_406F_8D82_205D723EAE2F__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CFileSpyView;

class CMainFrame : public CFrameWnd
{
	
protected: // create from serialization only
	CMainFrame();
	DECLARE_DYNCREATE(CMainFrame)

// Attributes
protected:
	CSplitterWnd m_wndSplitter;
	CSplitterWnd m_wndSplitter2;
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	public:
	virtual BOOL OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext);
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainFrame();
	CFileSpyView* GetRightPane();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // control bar embedded members
	CStatusBar  m_wndStatusBar;
	CToolBar    m_wndToolBar;
	CReBar      m_wndReBar;
	CDialogBar      m_wndDlgBar;

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnDestroy();
	afx_msg void OnEditFilters();
	afx_msg void OnEditClearfsfilter();
	afx_msg void OnEditClearfastio();
	afx_msg void OnEditClearirp();
	//}}AFX_MSG
	afx_msg void OnUpdateViewStyles(CCmdUI* pCmdUI);
	afx_msg void OnViewStyle(UINT nCommandID);
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MAINFRM_H__7F1D7310_0433_406F_8D82_205D723EAE2F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\filespy\usergui\leftview.cpp ===
// LeftView.cpp : implementation of the CLeftView class
//

#include "stdafx.h"
#include "FileSpyApp.h"

#include "FileSpyDoc.h"
#include "LeftView.h"

#include "global.h"
#include "protos.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CLeftView

IMPLEMENT_DYNCREATE(CLeftView, CTreeView)

BEGIN_MESSAGE_MAP(CLeftView, CTreeView)
	//{{AFX_MSG_MAP(CLeftView)
	ON_WM_RBUTTONDOWN()
	ON_WM_RBUTTONUP()
	ON_COMMAND(IDR_MENUATTACH, OnMenuattach)
	ON_COMMAND(IDR_MENUDETACH, OnMenudetach)
	ON_COMMAND(IDR_MENUATTACHALL, OnMenuattachall)
	ON_COMMAND(IDR_MENUDETACHALL, OnMenudetachall)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CLeftView construction/destruction

CLeftView::CLeftView()
{
	// TODO: add construction code here
	m_pImageList = new CImageList;
	m_pImageList->Create(IDB_DRIVEIMAGELIST,16,0,RGB(255,255,255));
	nRButtonSet = 0;
	pLeftView = (LPVOID) this;
}

CLeftView::~CLeftView()
{
	if (m_pImageList)
	{
		delete m_pImageList;
	}
}

BOOL CLeftView::PreCreateWindow(CREATESTRUCT& cs)
{
	// TODO: Modify the Window class or styles here by modifying
	//  the CREATESTRUCT cs
	cs.style |= TVS_HASBUTTONS | TVS_HASLINES | TVS_LINESATROOT | TVS_SHOWSELALWAYS;
	return CTreeView::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CLeftView drawing

void CLeftView::OnDraw(CDC* pDC)
{
    UNREFERENCED_PARAMETER( pDC );
    
	CFileSpyDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	// TODO: add draw code for native data here
}


void CLeftView::OnInitialUpdate()
{
	CTreeView::OnInitialUpdate();

	// TODO: You may populate your TreeView with items by directly accessing
 	//  its tree control through a call to GetTreeCtrl().

	USHORT ti;
	WCHAR sDriveString[30];

	//
	// Set the image list first
	//
	GetTreeCtrl().SetImageList(m_pImageList, TVSIL_NORMAL);

	//
	// Add a root node and name it "FileSpy"
	//
	hRootItem = GetTreeCtrl().InsertItem(L"FileSpy", IMAGE_SPY, IMAGE_SPY);

	//
	// Add drive names to LeftView
	//
	for (ti = 0; ti < nTotalDrives; ti++)
	{
		switch (VolInfo[ti].nType)
		{
		case DRIVE_FIXED:
			wcscpy( sDriveString, L"[ :] Local Disk" );
			break;
		case DRIVE_REMOTE:
			wcscpy( sDriveString, L"[ :] Remote" );
			break;
		case DRIVE_REMOVABLE:
			wcscpy( sDriveString, L"[ :] Removable" );
			break;
		case DRIVE_CDROM:
			wcscpy( sDriveString, L"[ :] CD-ROM" );
			break;
		default:
			wcscpy( sDriveString, L"[ :] Unknown" );
			break;
		}
		sDriveString[1] = VolInfo[ti].nDriveName;
		GetTreeCtrl().InsertItem( sDriveString, 
		                          VolInfo[ti].nImage, 
		                          VolInfo[ti].nImage, 
		                          hRootItem );
	}

	GetTreeCtrl().Expand(hRootItem, TVE_EXPAND);
}

/////////////////////////////////////////////////////////////////////////////
// CLeftView diagnostics

#ifdef _DEBUG
void CLeftView::AssertValid() const
{
	CTreeView::AssertValid();
}

void CLeftView::Dump(CDumpContext& dc) const
{
	CTreeView::Dump(dc);
}

CFileSpyDoc* CLeftView::GetDocument() // non-debug version is inline
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CFileSpyDoc)));
	return (CFileSpyDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CLeftView message handlers

void CLeftView::OnRButtonDown(UINT nFlags, CPoint point) 
{
    UNREFERENCED_PARAMETER( nFlags );
    UNREFERENCED_PARAMETER( point );
    
	// TODO: Add your message handler code here and/or call default
	nRButtonSet = 1;
//	CTreeView::OnRButtonDown(nFlags, point);
}

void CLeftView::OnRButtonUp(UINT nFlags, CPoint point) 
{
	// TODO: Add your message handler code here and/or call default
	HTREEITEM hItem;
	CMenu menu, *menupopup;
	RECT rect;
	UINT ret;

	hItem = GetTreeCtrl().HitTest(point);

	if (hItem != NULL && hItem != hRootItem && nRButtonSet)
	{
		GetTreeCtrl().SelectItem(hItem);
		menu.LoadMenu(IDR_LEFTVIEWMENU);
		menupopup = menu.GetSubMenu(0);
		GetWindowRect(&rect);
		if (VolInfo[GetAssociatedVolumeIndex(hItem)].bHook)
		{
			ret = menupopup->EnableMenuItem(IDR_MENUATTACH, MF_DISABLED|MF_GRAYED);
			ret = menupopup->EnableMenuItem(IDR_MENUDETACH, MF_ENABLED);
		}
		else
		{
			ret = menupopup->EnableMenuItem(IDR_MENUATTACH, MF_ENABLED);
			ret = menupopup->EnableMenuItem(IDR_MENUDETACH, MF_DISABLED|MF_GRAYED);
		}
		menupopup->TrackPopupMenu(TPM_LEFTALIGN, rect.left+point.x, rect.top+point.y, this);
		CTreeView::OnRButtonUp(nFlags, point);
	}
	else
	{
		if (hItem != NULL && hItem == hRootItem && nRButtonSet)
		{
			GetTreeCtrl().SelectItem(hItem);
			menu.LoadMenu(IDR_LEFTVIEWSPYMENU);
			menupopup = menu.GetSubMenu(0);
			GetWindowRect(&rect);
			ret = menupopup->EnableMenuItem(IDR_MENUATTACHALL, MF_ENABLED);
			ret = menupopup->EnableMenuItem(IDR_MENUDETACHALL, MF_ENABLED);
			menupopup->TrackPopupMenu(TPM_LEFTALIGN, rect.left+point.x, rect.top+point.y, this);
			CTreeView::OnRButtonUp(nFlags, point);
		}	
	}
	nRButtonSet = 0;
}

void CLeftView::OnMenuattach() 
{
	// TODO: Add your command handler code here
	HTREEITEM hItem;
	hItem = GetTreeCtrl().GetSelectedItem();

	if (AttachToDrive(VolInfo[GetAssociatedVolumeIndex(hItem)].nDriveName))
	{
		VolInfo[GetAssociatedVolumeIndex(hItem)].bHook = TRUE;
		GetTreeCtrl().SetItemImage( hItem, 
                                    VolInfo[GetAssociatedVolumeIndex(hItem)].nImage+IMAGE_ATTACHSTART,
                                    VolInfo[GetAssociatedVolumeIndex(hItem)].nImage+IMAGE_ATTACHSTART );
	}
}

void CLeftView::OnMenudetach() 
{
	// TODO: Add your command handler code here
	HTREEITEM hItem;
	hItem = GetTreeCtrl().GetSelectedItem();

	if (DetachFromDrive(VolInfo[GetAssociatedVolumeIndex(hItem)].nDriveName))
	{
		VolInfo[GetAssociatedVolumeIndex(hItem)].bHook = 0;
		GetTreeCtrl().SetItemImage(hItem, 
			VolInfo[GetAssociatedVolumeIndex(hItem)].nImage, \
			VolInfo[GetAssociatedVolumeIndex(hItem)].nImage);
	}
}

void CLeftView::OnMenuattachall() 
{
	// TODO: Add your command handler code here
	USHORT ti;
	HTREEITEM hItem;

	for (ti = 0; ti < nTotalDrives; ti++)
	{
		if (AttachToDrive(VolInfo[ti].nDriveName))
		{
			VolInfo[ti].bHook = TRUE;
			hItem = GetAssociatedhItem(VolInfo[ti].nDriveName);
			if (hItem)
			{
				GetTreeCtrl().SetItemImage(hItem, 
					VolInfo[ti].nImage+IMAGE_ATTACHSTART, \
					VolInfo[ti].nImage+IMAGE_ATTACHSTART);
			}
		}
	}
}

void CLeftView::OnMenudetachall() 
{
	// TODO: Add your command handler code here
	USHORT ti;
	HTREEITEM hItem;

	for (ti = 0; ti < nTotalDrives; ti++)
	{
		if (DetachFromDrive(VolInfo[ti].nDriveName))
		{
			VolInfo[ti].bHook = FALSE;
			hItem = GetAssociatedhItem(VolInfo[ti].nDriveName);
			if (hItem)
			{
				GetTreeCtrl().SetItemImage(hItem, VolInfo[ti].nImage, VolInfo[ti].nImage);
			}
		}
	}	
}

/*
void CLeftView::OnMenuscannewvolume() 
{
	// TODO: Add your command handler code here

	VOLINFO NewVol[26];
	DWORD nNewTotalDrives;
	USHORT ti, tj;
	HTREEITEM hItem;
	
	BuildDriveTable(NewVol, nNewTotalDrives);

	// We should remember the old hook status
	for (ti = 0; ti < nNewTotalDrives; ti++)
	{
		for (tj = 0; tj < nTotalDrives; tj++)
		{
			if (NewVol[ti].nDriveName == VolInfo[tj].nDriveName)
			{
				NewVol[ti].nHook = VolInfo[tj].nHook;
				break;
			}
		}
	}
}
*/

USHORT CLeftView::GetAssociatedVolumeIndex(HTREEITEM hItem)
{
	CString cs;
	USHORT ti;
	PWCHAR sDriveString;

	cs = GetTreeCtrl().GetItemText(hItem);
	sDriveString = cs.GetBuffer(20);


	for (ti = 0; ti < nTotalDrives; ti++)
	{
		if (VolInfo[ti].nDriveName == sDriveString[1])
		{
			return ti;
		}
	}
	return 0; // still a valid value but this will not happen
}

HTREEITEM CLeftView::GetAssociatedhItem(WCHAR cDriveName)
{
	HTREEITEM hItem;
	CString cs;
	PWCHAR sDriveString;

	hItem = GetTreeCtrl().GetChildItem(hRootItem);
	while (hItem)
	{
		cs = GetTreeCtrl().GetItemText(hItem);
		sDriveString = cs.GetBuffer(20);
		if (cDriveName == sDriveString[1])
		{
			break;
		}
		hItem = GetTreeCtrl().GetNextSiblingItem(hItem);
	}
	return hItem;
}

void CLeftView::UpdateImage(void)
{

	USHORT ti;
	HTREEITEM hItem;

	for (ti = 0; ti < nTotalDrives; ti++)
	{
		hItem = GetAssociatedhItem(VolInfo[ti].nDriveName);
		GetTreeCtrl().SetItemImage(hItem, VolInfo[ti].nImage, VolInfo[ti].nImage);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\filespy\usergui\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	FileSpy.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\filespy\usergui\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#pragma warning( disable : 4100 )   // Disable unreferenced local warning
#pragma warning( disable : 4200 )   // Disable nonstandard extensions warning

#if !defined(AFX_STDAFX_H__1F8039B8_3194_48E0_9C9A_3236C0654B33__INCLUDED_)
#define AFX_STDAFX_H__1F8039B8_3194_48E0_9C9A_3236C0654B33__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN        // Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxres.h>
#include <afxcview.h>
#include <afxdtctl.h>       // MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>         // MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__1F8039B8_3194_48E0_9C9A_3236C0654B33__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\filespy\usergui\support.cpp ===
void DisplayError(DWORD nCode)

/*++

Routine Description:

   This routine will display an error message based off of the Win32 error
   code that is passed in. This allows the user to see an understandable
   error message instead of just the code.

Arguments:

   Code - The error code to be translated.

Return Value:

   None.

--*/

{
   WCHAR sBuffer[200];
   DWORD nCount ;

   //
   // Translate the Win32 error code into a useful message.
   //

   nCount = FormatMessage (FORMAT_MESSAGE_FROM_SYSTEM,
                          NULL,
                          nCode,
                          0,
                          sBuffer,
                          sizeof( sBuffer )/sizeof( WCHAR ),
                          NULL) ;

   //
   // Make sure that the message could be translated.
   //

	if (nCount == 0) 
	{ 
		swprintf(sBuffer, L"Unable to translate error code %d", nCode);
		MessageBox(NULL, sBuffer, L"Translation Error", MB_OK);
	}
	else
	{
		//
		// Display the translated error.
		//
		MessageBox(NULL, sBuffer, L"Error", MB_OK);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\filespy\usergui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by FileSpy.rc
//
#define IDD_ABOUTBOX                    100
#define ID_VIEW_ARRANGE                 127
#define IDR_MAINFRAME                   128
#define IDR_FILESPTYPE                  129
#define IDB_DRIVEIMAGELIST              130
#define IDR_LEFTVIEWMENU                131
#define IDR_LEFTVIEWSPYMENU             132
#define IDD_IRPFASTIOFILTER             133
#define IDB_STATEIMAGELIST              134
#define IDC_IRPLIST                     1000
#define IDC_SUPPRESSPAGEIO              1002
#define IDC_FASTIOLIST                  1003
#define IDC_IRPSELECTALL                1007
#define IDC_FASTIOSELECTALL             1008
#define IDC_IRPDESELECTALL              1009
#define IDC_FASTIODESELECTALL           1010
#define ID_EDIT_OPTIONS                 32771
#define IDR_MENUATTACH                  32772
#define IDR_MENUDETACH                  32773
#define IDR_MENUATTACHALL               32776
#define IDR_DETACHALL                   32777
#define IDR_MENUDETACHALL               32778
#define ID_EDIT_FILTERS                 32780
#define ID_EDIT_CLEARIRP                32781
#define ID_EDIT_CLEARFASTIO             32782
#define ID_EDIT_CLEARFSFILTER           32783

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        135
#define _APS_NEXT_COMMAND_VALUE         32783
#define _APS_NEXT_CONTROL_VALUE         1011
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\iotest\filter\iotest.h ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    filespy.h

Abstract:

    Header file which contains the structures, type definitions,
    and constants that are shared between the kernel mode driver, 
    filespy.sys, and the user mode executable, filespy.exe.

// @@BEGIN_DDKSPLIT

Author:

    George Jenkins (georgeje) 6-Jan-1999
    Neal Christiansen (nealch)
    Molly Brown (mollybro)  

// @@END_DDKSPLIT

Environment:

    Kernel mode

// @@BEGIN_DDKSPLIT

Revision History:

// @@END_DDKSPLIT
--*/
#ifndef __IOTEST_H__
#define __IOTEST_H__

#include "ioTestLib.h"

//
//  Enable these warnings in the code.
//

#pragma warning(error:4100)   // Unreferenced formal parameter
#pragma warning(error:4101)   // Unreferenced local variable

#define USE_DO_HINT

#define IOTEST_Reset              (ULONG) CTL_CODE( FILE_DEVICE_DISK_FILE_SYSTEM, 0x00, METHOD_BUFFERED, FILE_WRITE_ACCESS )
#define IOTEST_StartLoggingDevice (ULONG) CTL_CODE( FILE_DEVICE_DISK_FILE_SYSTEM, 0x01, METHOD_BUFFERED, FILE_READ_ACCESS )
#define IOTEST_StopLoggingDevice  (ULONG) CTL_CODE( FILE_DEVICE_DISK_FILE_SYSTEM, 0x02, METHOD_BUFFERED, FILE_READ_ACCESS )
#define IOTEST_GetLog             (ULONG) CTL_CODE( FILE_DEVICE_DISK_FILE_SYSTEM, 0x03, METHOD_BUFFERED, FILE_READ_ACCESS )
#define IOTEST_GetVer             (ULONG) CTL_CODE( FILE_DEVICE_DISK_FILE_SYSTEM, 0x04, METHOD_BUFFERED, FILE_READ_ACCESS )
#define IOTEST_ListDevices        (ULONG) CTL_CODE( FILE_DEVICE_DISK_FILE_SYSTEM, 0x05, METHOD_BUFFERED, FILE_READ_ACCESS )
#define IOTEST_GetStats           (ULONG) CTL_CODE( FILE_DEVICE_DISK_FILE_SYSTEM, 0x06, METHOD_BUFFERED, FILE_READ_ACCESS )
#define IOTEST_ReadTest           (ULONG) CTL_CODE( FILE_DEVICE_DISK_FILE_SYSTEM, 0x07, METHOD_BUFFERED, FILE_READ_ACCESS )
#define IOTEST_RenameTest         (ULONG) CTL_CODE( FILE_DEVICE_DISK_FILE_SYSTEM, 0x08, METHOD_BUFFERED, FILE_READ_ACCESS )
#define IOTEST_ShareTest          (ULONG) CTL_CODE( FILE_DEVICE_DISK_FILE_SYSTEM, 0x09, METHOD_BUFFERED, FILE_READ_ACCESS )

#define IOTEST_DRIVER_NAME     L"IOTEST.SYS"
#define IOTEST_DEVICE_NAME     L"IoTest"
#define IOTEST_W32_DEVICE_NAME L"\\\\.\\IoTest"
#define IOTEST_DOSDEVICE_NAME  L"\\DosDevices\\IoTest"
#define IOTEST_FULLDEVICE_NAME L"\\FileSystem\\Filters\\IoTest"

    
#define IOTEST_MAJ_VERSION 1
#define IOTEST_MIN_VERSION 0

typedef struct _IOTESTVER {
    USHORT Major;
    USHORT Minor;
} IOTESTVER, *PIOTESTVER;

typedef ULONG_PTR FILE_ID;        //  To allow passing up PFILE_OBJECT as 
                                  //     unique file identifier in user-mode
typedef LONG NTSTATUS;            //  To allow status values to be passed up 
                                  //     to user-mode

//
//  This is set to the number of characters we want to allow the 
//  device extension to store for the various names used to identify
//  a device object.
//
#define DEVICE_NAMES_SZ  100

//
//  An array of these structures are returned when the attached device list is
//  returned.
//

typedef struct _ATTACHED_DEVICE {
    BOOLEAN LoggingOn;
    enum _IOTEST_DEVICE_TYPE DeviceType;
    WCHAR DeviceNames[DEVICE_NAMES_SZ];
} ATTACHED_DEVICE, *PATTACHED_DEVICE;

#define MAX_BUFFERS     100

//
//  Attach modes for the filespy kernel driver
//

#define IOTEST_ATTACH_ON_DEMAND    1   //  Filespy will only attach to a volume
                                        //  when a user asks to start logging that
                                        //  volume.
                                        
#define IOTEST_ATTACH_ALL_VOLUMES  2   //  Filespy will attach to all volumes
                                        //  in the system at the time the driver
                                        //  is loaded and will attach to all volumes
                                        //  that appear in the system while the 
                                        //  filespy driver is loaded.  Logging on these
                                        //  volumes will not be turned on until the 
                                        //  user asks it to be.
                                        
//
//  The valid record types.
//

#define RECORD_TYPE_STATIC                  0x80000000
#define RECORD_TYPE_NORMAL                  0X00000000

#define RECORD_TYPE_IRP                     0x00000001
#define RECORD_TYPE_FASTIO                  0x00000002
#define RECORD_TYPE_FS_FILTER_OP            0x00000003
#define RECORD_TYPE_OUT_OF_MEMORY           0x10000000
#define RECORD_TYPE_EXCEED_MEMORY_ALLOWANCE 0x20000000

#ifndef NOTHING
#define NOTHING
#endif

//
//  Macro to return the lower byte of RecordType
//

#define GET_RECORD_TYPE(pLogRecord) ((pLogRecord)->RecordType & 0x0000FFFF)

#define LOG_ORIGINATING_IRP  0x0001
#define LOG_COMPLETION_IRP   0x0002

typedef enum _IOTEST_DEVICE_TYPE {

    TOP_FILTER,      //  Closest to the IO Mananger
    BOTTOM_FILTER    // Closest to the file system

} IOTEST_DEVICE_TYPE, *PIOTEST_DEVICE_TYPE;

typedef struct _EXPECTED_OPERATION {

    IOTEST_DEVICE_TYPE Device;
    UCHAR Op;

} EXPECTED_OPERATION, *PEXPECTED_OPERATION;

//
//  Structure defining the information recorded for an IRP operation
//

typedef struct _RECORD_IRP {

    LARGE_INTEGER OriginatingTime; //  The time the IRP originated

    UCHAR IrpMajor;                //  From _IO_STACK_LOCATION
    UCHAR IrpMinor;                //  From _IO_STACK_LOCATION
    ULONG IrpFlags;                //  From _IRP (no cache, paging i/o, sync. 
                                   //  api, assoc. irp, buffered i/o, etc.)                   
    FILE_ID FileObject;            //  From _IO_STACK_LOCATION (This is the 
                                   //     PFILE_OBJECT, but this isn't 
                                   //     available in user-mode)
    FILE_ID ProcessId;
    FILE_ID ThreadId;
    
    //
    //  These fields are only filled in the appropriate
    //  Verbose mode.
    //
    
    PVOID Argument1;               //  
    PVOID Argument2;               //  Current IrpStackLocation
    PVOID Argument3;               //  Parameters
    PVOID Argument4;               //  
    ACCESS_MASK DesiredAccess;     //  Only used for CREATE irps

} RECORD_IRP, *PRECORD_IRP;

//
//  Structure defining the information recorded for a Fast IO operation
//

typedef struct _RECORD_FASTIO {

    LARGE_INTEGER StartTime;     //  Time Fast I/O request begins processing
    FASTIO_TYPE Type;            //  Type of FASTIO operation
    FILE_ID FileObject;          //  Parameter to FASTIO call, should be 
                                 //    unique identifier in user space
    LARGE_INTEGER FileOffset;    //  Offset into the file where the I/O is 
                                 //    taking place
    ULONG Length;                //  The length of data for the I/O operation
    BOOLEAN Wait;                //  Parameter to most FASTIO calls, signifies 
                                 //    if this operation can wait
    FILE_ID ProcessId;
    FILE_ID ThreadId;

} RECORD_FASTIO, *PRECORD_FASTIO;

//
//  Structure defining the information recorded for FsFilter operations
//

typedef struct _RECORD_FS_FILTER_OPERATION {

    LARGE_INTEGER OriginatingTime;

    UCHAR FsFilterOperation;
    FILE_ID FileObject;

    FILE_ID ProcessId;
    FILE_ID ThreadId;
    
} RECORD_FS_FILTER_OPERATION, *PRECORD_FS_FILTER_OPERATION;

//
//  The two types of records that are possible.
//

typedef union _RECORD_IO {

    RECORD_IRP RecordIrp;
    RECORD_FASTIO RecordFastIo;
    RECORD_FS_FILTER_OPERATION RecordFsFilterOp;

} RECORD_IO, *PRECORD_IO;


//
//  Log record structure defines the additional information needed for
//  managing the processing of the each IO IoTest monitors.
//

typedef struct _LOG_RECORD {

    ULONG Length;           //  Length of record including header 
    ULONG SequenceNumber;
    IOTEST_DEVICE_TYPE DeviceType;
    ULONG RecordType;
    RECORD_IO Record;
    WCHAR Name[1];          //  Really want a 0 sized array here, but since
                            //  some compilers don't like that, making the
                            //  variable sized array of size 1 to hold
                            //  this place.

} LOG_RECORD, *PLOG_RECORD;

#define SIZE_OF_LOG_RECORD  (sizeof( LOG_RECORD ) - sizeof( WCHAR ))

typedef struct _RECORD_LIST {

    LIST_ENTRY List;
    LOG_RECORD LogRecord;

} RECORD_LIST, *PRECORD_LIST;

#define SIZE_OF_RECORD_LIST (SIZE_OF_LOG_RECORD + sizeof( LIST_ENTRY ))


//
//  The statistics that are kept on the file name hash table
//  to monitor its efficiency.
//

typedef struct _HASH_STATISTICS {

    ULONG Lookups;
    ULONG LookupHits;
    ULONG DeleteLookups;
    ULONG DeleteLookupHits;

} HASH_STATISTICS, *PHASH_STATISTICS;

#ifndef MAX_PATH
#define MAX_PATH        260
#endif
#define RECORD_SIZE     ((MAX_PATH*sizeof(WCHAR))+SIZE_OF_RECORD_LIST)

typedef enum _IOTEST_PHASE {

    IoTestSetup,
    IoTestAction,
    IoTestValidation,
    IoTestCleanup,
    IoTestCompleted

} IOTEST_PHASE, *PIOTEST_PHASE;

typedef struct _IOTEST_STATUS {

    IOTEST_PHASE Phase;
    NTSTATUS TestResult;

} IOTEST_STATUS, *PIOTEST_STATUS;

#define DEVICE_NAME_SZ 64

#define IO_TEST_NO_FLAGS                     0x0
#define IO_TEST_TOP_OF_STACK                 0x00000001
#define IO_TEST_SAME_VOLUME_MOUNT_POINT      0x00000002
#define IO_TEST_DIFFERENT_VOLUME_MOUNT_POINT 0x00000004

typedef struct _IOTEST_READ_WRITE_PARAMETERS {

    ULONG Flags;
    ULONG DriveNameLength;
    ULONG FileNameLength;
    ULONG FileDataLength;

    WCHAR DriveNameBuffer[DEVICE_NAME_SZ];
    WCHAR FileNameBuffer[MAX_PATH];
    CHAR FileData[1];

} IOTEST_READ_WRITE_PARAMETERS, *PIOTEST_READ_WRITE_PARAMETERS;

typedef struct _IOTEST_RENAME_PARAMETERS {

    ULONG Flags;
    ULONG DriveNameLength;
    ULONG SourceFileNameLength;
    ULONG TargetFileNameLength;

    WCHAR DriveNameBuffer[DEVICE_NAME_SZ];
    WCHAR SourceFileNameBuffer[MAX_PATH];
    WCHAR TargetFileNameBuffer[MAX_PATH];
    
} IOTEST_RENAME_PARAMETERS, *PIOTEST_RENAME_PARAMETERS;

typedef struct _IOTEST_SHARE_PARAMETERS {

    ULONG Flags;
    ULONG DriveNameLength;
    ULONG FileNameLength;

    WCHAR DriveNameBuffer[DEVICE_NAME_SZ];
    WCHAR FileNameBuffer[MAX_PATH];
    
} IOTEST_SHARE_PARAMETERS, *PIOTEST_SHARE_PARAMETERS;

#endif /* __IOTEST_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\iotest\filter\iotestsup.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    ioTestSup.c

Abstract:

    This contains test routines for IoTest.

// @@BEGIN_DDKSPLIT

Author:

    Molly Brown (mollybro)  

// @@END_DDKSPLIT

Environment:

    Kernel mode

// @@BEGIN_DDKSPLIT
Revision History:

// @@END_DDKSPLIT
--*/

#include <stdio.h>

#include <ntifs.h>
#include "ioTest.h"
#include "ioTestKern.h"

NTSTATUS
IoTestFindTopDeviceObject (
    IN PUNICODE_STRING DriveName,
    OUT PDEVICE_OBJECT *IoTestDeviceObject
    )
{
    NTSTATUS status;
    PDEVICE_OBJECT deviceObject;
    PDEVICE_OBJECT ioTestDeviceObject;

    ASSERT( IoTestDeviceObject != NULL );
    
    status = IoTestGetDeviceObjectFromName( DriveName, &deviceObject );

    if (!NT_SUCCESS( status )) {

        //
        //  There was an error, so return the error code.
        //
        
        return status;
    }

    if (IoTestIsAttachedToDevice( TOP_FILTER, 
                                  deviceObject, 
                                  &(ioTestDeviceObject))) {

        ASSERT( ioTestDeviceObject != NULL );

        status = STATUS_SUCCESS;

    } else {

        status = STATUS_INVALID_PARAMETER;
    }

    ObDereferenceObject( deviceObject );
    
    *IoTestDeviceObject = ioTestDeviceObject;

    return status;
}

#define FILE_NAME_HEADER L"\\??\\"

NTSTATUS
IoTestGenerateFileName (
    IN PUNICODE_STRING FileName,
    OUT PUNICODE_STRING RealFileName
    )
{
    PWCHAR realFileNameBuffer;

    ASSERT( FileName != NULL );
    ASSERT( RealFileName != NULL );
    
    //
    //  Must prefix the filename coming in with \\??\\
    //

    realFileNameBuffer = ExAllocatePoolWithTag( PagedPool,
                                                FileName->Length + sizeof( FILE_NAME_HEADER ),
                                                IOTEST_POOL_TAG );
    if (realFileNameBuffer == NULL) {

        IOTEST_DBG_PRINT0( IOTESTDEBUG_TESTS,
                           "(IoTestGenerateFileName) Cannot allocate a buffer for filename\n" );
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    
    realFileNameBuffer[0] = UNICODE_NULL;

    RtlInitEmptyUnicodeString( RealFileName, 
                               realFileNameBuffer, 
                               FileName->Length + sizeof( FILE_NAME_HEADER ));

    RtlAppendUnicodeToString( RealFileName, FILE_NAME_HEADER );
    RtlAppendUnicodeStringToString( RealFileName, FileName );

    return STATUS_SUCCESS;
}

NTSTATUS
IoTestReadTestDriver (
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN ULONG OutputBufferLength
    )
{
    UNICODE_STRING deviceName;
    UNICODE_STRING fileName;
    PIOTEST_READ_WRITE_PARAMETERS parms = InputBuffer;
    PIOTEST_STATUS testStatus = OutputBuffer;
    PDEVICE_OBJECT ioTestDeviceObject, targetDevice;
    NTSTATUS status;

    UNREFERENCED_PARAMETER( InputBufferLength );
    UNREFERENCED_PARAMETER( OutputBufferLength );

    RtlInitUnicodeString(&deviceName, parms->DriveNameBuffer);
    status = IoTestPrepareDevicesForTest( &deviceName, &ioTestDeviceObject);

    if (!NT_SUCCESS( status )) {

        return status;
    }

    ASSERT( ioTestDeviceObject != NULL );

    if (FlagOn( parms->Flags, IO_TEST_TOP_OF_STACK)) {

        targetDevice = NULL;

    } else {

        targetDevice = IO_TEST_TARGET_DEVICE( ioTestDeviceObject );
    }

    RtlInitUnicodeString(&fileName, parms->FileNameBuffer);
    
    IoTestReadTest( &fileName,
                    parms->FileData,
                    parms->FileDataLength,
                    targetDevice,
                    testStatus );

    IoTestCleanupDevicesForTest( ioTestDeviceObject );
    
    return STATUS_SUCCESS;
    
}

NTSTATUS
IoTestReadTest (
    IN PUNICODE_STRING FileName,
    IN PVOID FileData,
    IN ULONG FileDataLength,
    IN PDEVICE_OBJECT TargetDevice,
    OUT PIOTEST_STATUS TestStatus
    )
{
    OBJECT_ATTRIBUTES objAttribs;
    UNICODE_STRING realFileName;
    HANDLE fileHandle = INVALID_HANDLE_VALUE;
    IO_STATUS_BLOCK ioStatus;
    NTSTATUS status;
    PVOID readData = NULL;

    ASSERT( TestStatus != NULL );

    //
    //  Must prefix the filename coming in with \\??\\
    //

    realFileName.Buffer = NULL;
    status = IoTestGenerateFileName( FileName, 
                                     &realFileName );

    if (!NT_SUCCESS( status )) {

        TestStatus->Phase = IoTestSetup;
        TestStatus->TestResult = status;

        IOTEST_DBG_PRINT0( IOTESTDEBUG_TESTS,
                           "(IoTestReadTest) Setup -- Cannot allocate a buffer for filename\n" );
        goto IoReadTest_Cleanup;
    }
    
    InitializeObjectAttributes( &objAttribs,
                                &realFileName,
                                OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL );

    status = IoTestCreateFile( &fileHandle,
                               FILE_GENERIC_READ,
                               &objAttribs,
                               &ioStatus,
                               NULL,
                               FILE_ATTRIBUTE_NORMAL,
                               FILE_SHARE_READ,
                               FILE_OPEN,
                               FILE_SYNCHRONOUS_IO_NONALERT,
                               NULL,
                               0,
                               0,
                               TargetDevice );

    if (!NT_SUCCESS( status )) {

        TestStatus->Phase = IoTestSetup;
        TestStatus->TestResult = status;

        IOTEST_DBG_PRINT1( IOTESTDEBUG_TESTS,
                           "(IoTestReadTest) Setup -- Cannot open handle to %wZ\n",
                           FileName );
        goto IoReadTest_Cleanup;
    }

    readData = ExAllocatePoolWithTag( PagedPool,
                                      FileDataLength,
                                      IOTEST_POOL_TAG );

    if (NULL == readData) {

        TestStatus->Phase = IoTestSetup;
        TestStatus->TestResult = STATUS_INSUFFICIENT_RESOURCES;
        IOTEST_DBG_PRINT0( IOTESTDEBUG_TESTS,
                           "(IoTestReadTest) Setup -- Cannot allocate read buffer.\n");
        goto IoReadTest_Cleanup;
    }
        
    status = ZwReadFile( fileHandle,
                         NULL,
                         NULL,
                         NULL,
                         &ioStatus,
                         readData,
                         FileDataLength,
                         NULL,
                         NULL );

    if (!NT_SUCCESS( status )) {

        TestStatus->Phase = IoTestAction;
        TestStatus->TestResult = status;
        IOTEST_DBG_PRINT2( IOTESTDEBUG_TESTS,
                           "(IoTestReadTest) Action -- Cannot read file %wZ - status 0x%08x.\n",
                           FileName,
                           status );
        goto IoReadTest_Cleanup;
    }

    if (ioStatus.Information != FileDataLength) {

        TestStatus->Phase = IoTestAction;
        TestStatus->TestResult = status;
        IOTEST_DBG_PRINT1( IOTESTDEBUG_TESTS,
                           "(IoTestReadTest) Action -- Didn't read enough from file %wZ.\n",
                           FileName );
        goto IoReadTest_Cleanup;
    }

    //
    //  Validate the data we read from the disk.
    //

    status = IoTestCompareData( FileData,
                                readData,
                                FileDataLength );
    
                               
    if (!NT_SUCCESS( status )) {

        TestStatus->Phase = IoTestValidation;
        TestStatus->TestResult = status;
        IOTEST_DBG_PRINT1( IOTESTDEBUG_TESTS,
                           "(IoTestReadTest) Validation -- The data read doesn't match what was expected from file %wZ.\n",
                           FileName );
        goto IoReadTest_Cleanup;
    }

    //
    //  The test completed successfully, so update the TestStatus structure
    //  and cleanup.
    //

    TestStatus->Phase = IoTestCompleted;
    TestStatus->TestResult = STATUS_SUCCESS;
    
IoReadTest_Cleanup:

    if (fileHandle != INVALID_HANDLE_VALUE) {

        ZwClose( fileHandle );
    }

    if (readData != NULL) {

        ExFreePool( readData );
    }

    if (realFileName.Buffer != NULL) {

        ExFreePool( realFileName.Buffer );
    }

    return status;
}

NTSTATUS
IoTestRenameTestDriver (
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN ULONG OutputBufferLength
    )
{
    UNICODE_STRING deviceName;
    UNICODE_STRING sourceFileName, targetFileName;
    PIOTEST_RENAME_PARAMETERS parms = InputBuffer;
    PIOTEST_STATUS testStatus = OutputBuffer;
    PDEVICE_OBJECT ioTestDeviceObject, targetDevice;
    NTSTATUS status;

    UNREFERENCED_PARAMETER( InputBufferLength );
    UNREFERENCED_PARAMETER( OutputBufferLength );

    RtlInitUnicodeString(&deviceName, parms->DriveNameBuffer);
    status = IoTestPrepareDevicesForTest( &deviceName, &ioTestDeviceObject);

    if (!NT_SUCCESS( status )) {

        return status;
    }

    ASSERT( ioTestDeviceObject != NULL );

    if (FlagOn( parms->Flags, IO_TEST_TOP_OF_STACK)) {

        targetDevice = NULL;

    } else {

        targetDevice = IO_TEST_TARGET_DEVICE( ioTestDeviceObject );
    }

    RtlInitUnicodeString( &sourceFileName, parms->SourceFileNameBuffer );
    RtlInitUnicodeString( &targetFileName, parms->TargetFileNameBuffer );
    
    IoTestRenameTest( &sourceFileName,
                      &targetFileName,
                      targetDevice,
                      testStatus );

    IoTestCleanupDevicesForTest( ioTestDeviceObject );

    return STATUS_SUCCESS;
}

NTSTATUS
IoTestRenameTest (
    IN PUNICODE_STRING SourceFileName,
    IN PUNICODE_STRING TargetFileName,
    IN PDEVICE_OBJECT TargetDevice,
    OUT PIOTEST_STATUS TestStatus
    )
{
    OBJECT_ATTRIBUTES objAttribs;
    UNICODE_STRING realSourceFileName, realTargetFileName;
    HANDLE fileHandle = INVALID_HANDLE_VALUE;
    PFILE_RENAME_INFORMATION renameInfo = NULL;
    ULONG renameInfoSize = 0;
    IO_STATUS_BLOCK ioStatus;
    NTSTATUS status;

    ASSERT( TestStatus != NULL );

    //
    //  Must prefix the filename coming in with \\??\\
    //

    realSourceFileName.Buffer = NULL;
    realTargetFileName.Buffer = NULL;
    status = IoTestGenerateFileName( SourceFileName, 
                                     &realSourceFileName );

    if (!NT_SUCCESS( status )) {

        TestStatus->Phase = IoTestSetup;
        TestStatus->TestResult = status;

        IOTEST_DBG_PRINT0( IOTESTDEBUG_TESTS,
                           "(IoTestRenameTest) Setup -- Cannot allocate a buffer for source filename\n" );
        goto IoRenameTest_Cleanup;
    }
    
    status = IoTestGenerateFileName( TargetFileName, 
                                     &realTargetFileName );

    if (!NT_SUCCESS( status )) {

        TestStatus->Phase = IoTestSetup;
        TestStatus->TestResult = status;

        IOTEST_DBG_PRINT0( IOTESTDEBUG_TESTS,
                           "(IoTestRenameTest) Setup -- Cannot allocate a buffer for target filename\n" );
        goto IoRenameTest_Cleanup;
    }

    InitializeObjectAttributes( &objAttribs,
                                &realSourceFileName,
                                OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL );

    status = IoTestCreateFile( &fileHandle,
                               FILE_GENERIC_WRITE,
                               &objAttribs,
                               &ioStatus,
                               NULL,
                               FILE_ATTRIBUTE_NORMAL,
                               FILE_SHARE_READ | FILE_SHARE_DELETE,
                               FILE_OPEN,
                               FILE_SYNCHRONOUS_IO_NONALERT,
                               NULL,
                               0,
                               0,
                               TargetDevice );

    if (!NT_SUCCESS( status )) {

        TestStatus->Phase = IoTestSetup;
        TestStatus->TestResult = status;

        IOTEST_DBG_PRINT1( IOTESTDEBUG_TESTS,
                           "(IoTestRenameTest) Setup -- Cannot open handle to %wZ\n",
                           SourceFileName );
        goto IoRenameTest_Cleanup;
    }

    renameInfoSize = sizeof(FILE_RENAME_INFORMATION) + realTargetFileName.Length;
    renameInfo = ExAllocatePoolWithTag( PagedPool,
                                        renameInfoSize,
                                        IOTEST_POOL_TAG );

    if (NULL == renameInfo) {

        TestStatus->Phase = IoTestSetup;
        TestStatus->TestResult = STATUS_INSUFFICIENT_RESOURCES;
        IOTEST_DBG_PRINT0( IOTESTDEBUG_TESTS,
                           "(IoTestRenameTest) Setup -- Cannot allocate rename information buffer.\n");
        goto IoRenameTest_Cleanup;
    }

    renameInfo->ReplaceIfExists = FALSE;
    renameInfo->RootDirectory = NULL;
    renameInfo->FileNameLength = realTargetFileName.Length;
    RtlCopyMemory( renameInfo->FileName, 
                   realTargetFileName.Buffer, 
                   realTargetFileName.Length );
        
    status = ZwSetInformationFile( fileHandle,
                                   &ioStatus,
                                   renameInfo,
                                   renameInfoSize,
                                   FileRenameInformation );

    if (!NT_SUCCESS( status )) {

        TestStatus->Phase = IoTestAction;
        TestStatus->TestResult = status;
        IOTEST_DBG_PRINT3( IOTESTDEBUG_TESTS,
                           "(IoTestRenameTest) Action -- Cannot rename file %wZ to %wZ- status 0x%08x.\n",
                           SourceFileName,
                           TargetFileName,
                           status );
        goto IoRenameTest_Cleanup;
    }

    //
    //  The test completed successfully, so update the TestStatus structure
    //  and cleanup.
    //

    TestStatus->Phase = IoTestCompleted;
    TestStatus->TestResult = STATUS_SUCCESS;
    
IoRenameTest_Cleanup:

    if (fileHandle != INVALID_HANDLE_VALUE) {

        ZwClose( fileHandle );
    }

    if (realSourceFileName.Buffer != NULL) {

        ExFreePool( realSourceFileName.Buffer );
    }

    if (realTargetFileName.Buffer != NULL) {

        ExFreePool( realTargetFileName.Buffer );
    }

    if (renameInfo != NULL) {

        ExFreePool( renameInfo );
    }
    
    return status;
}

NTSTATUS
IoTestShareTestDriver (
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN ULONG OutputBufferLength
    )
{
    UNICODE_STRING deviceName;
    UNICODE_STRING fileName;
    PIOTEST_SHARE_PARAMETERS parms = InputBuffer;
    PIOTEST_STATUS testStatus = OutputBuffer;
    PDEVICE_OBJECT ioTestDeviceObject, targetDevice;
    NTSTATUS status;

    UNREFERENCED_PARAMETER( InputBufferLength );
    UNREFERENCED_PARAMETER( OutputBufferLength );

    RtlInitUnicodeString(&deviceName, parms->DriveNameBuffer);
    status = IoTestPrepareDevicesForTest( &deviceName, &ioTestDeviceObject);

    if (!NT_SUCCESS( status )) {

        return status;
    }

    ASSERT( ioTestDeviceObject != NULL );

    if (FlagOn( parms->Flags, IO_TEST_TOP_OF_STACK)) {

        targetDevice = NULL;

    } else {

        targetDevice = IO_TEST_TARGET_DEVICE( ioTestDeviceObject );
    }

    RtlInitUnicodeString( &fileName, parms->FileNameBuffer );
    
    IoTestShareTest( &fileName,
                     targetDevice,
                     testStatus );

    IoTestCleanupDevicesForTest( ioTestDeviceObject );

    return STATUS_SUCCESS;
}

NTSTATUS
IoTestShareTest (
    IN PUNICODE_STRING FileName,
    IN PDEVICE_OBJECT TargetDevice,
    OUT PIOTEST_STATUS TestStatus
    )
{
    OBJECT_ATTRIBUTES objAttribs;
    UNICODE_STRING realFileName;
    HANDLE fileHandle = INVALID_HANDLE_VALUE;
    IO_STATUS_BLOCK ioStatus;
    NTSTATUS status;

    ASSERT( TestStatus != NULL );

    //
    //  Must prefix the filename coming in with \\??\\
    //

    realFileName.Buffer = NULL;
    status = IoTestGenerateFileName( FileName, 
                                     &realFileName );

    if (!NT_SUCCESS( status )) {

        TestStatus->Phase = IoTestSetup;
        TestStatus->TestResult = status;

        IOTEST_DBG_PRINT0( IOTESTDEBUG_TESTS,
                           "(IoTestShareTest) Setup -- Cannot allocate a buffer for filename\n" );
        goto IoShareTest_Cleanup;
    }
    
    InitializeObjectAttributes( &objAttribs,
                                &realFileName,
                                OBJ_KERNEL_HANDLE,
                                NULL,
                                NULL );

    status = IoTestCreateFile( &fileHandle,
                               FILE_GENERIC_WRITE,
                               &objAttribs,
                               &ioStatus,
                               NULL,
                               FILE_ATTRIBUTE_NORMAL,
                               FILE_SHARE_READ | FILE_SHARE_DELETE | FILE_SHARE_DELETE,
                               FILE_OPEN,
                               FILE_SYNCHRONOUS_IO_NONALERT,
                               NULL,
                               0,
                               IO_IGNORE_SHARE_ACCESS_CHECK,
                               TargetDevice );

    if (!NT_SUCCESS( status )) {

        TestStatus->Phase = IoTestSetup;
        TestStatus->TestResult = status;

        IOTEST_DBG_PRINT1( IOTESTDEBUG_TESTS,
                           "(IoTestShareTest) Setup -- Cannot open handle to %wZ\n",
                           FileName );
        goto IoShareTest_Cleanup;
    }

    //
    //  The test completed successfully, so update the TestStatus structure
    //  and cleanup.
    //

    TestStatus->Phase = IoTestCompleted;
    TestStatus->TestResult = STATUS_SUCCESS;
    
IoShareTest_Cleanup:

    if (fileHandle != INVALID_HANDLE_VALUE) {

        ZwClose( fileHandle );
    }

    if (realFileName.Buffer != NULL) {

        ExFreePool( realFileName.Buffer );
    }

    return status;
}

NTSTATUS
IoTestPrepareDevicesForTest (
    IN PUNICODE_STRING DeviceName,
    OUT PDEVICE_OBJECT* IoTestDeviceObject
    )
{
    PIOTEST_DEVICE_EXTENSION topDevExt, botDevExt;
    PDEVICE_OBJECT ioTestDeviceObject;
    NTSTATUS status;

    status = IoTestFindTopDeviceObject( DeviceName, &ioTestDeviceObject);

    if (!NT_SUCCESS( status )) {

        return status;
    }

    ASSERT( ioTestDeviceObject != NULL );

    //
    //  Turn off log, flush log, turn on log
    //

    topDevExt = ioTestDeviceObject->DeviceExtension;
    botDevExt = topDevExt->AttachedToDeviceObject->DeviceExtension;
    
    topDevExt->LogThisDevice = FALSE;
    botDevExt->LogThisDevice = FALSE;

    IoTestFlushLog();

    topDevExt->LogThisDevice = TRUE;
    botDevExt->LogThisDevice = TRUE;

    if (IoTestDeviceObject != NULL) {

        *IoTestDeviceObject = ioTestDeviceObject;
    }

    return STATUS_SUCCESS;
}

VOID
IoTestCleanupDevicesForTest (
    IN PDEVICE_OBJECT IoTestDeviceObject
    )
{
    PIOTEST_DEVICE_EXTENSION topDevExt, botDevExt;
   
    topDevExt = IoTestDeviceObject->DeviceExtension;
    botDevExt = topDevExt->AttachedToDeviceObject->DeviceExtension;
    
    //
    //  Turn off log.
    //

    topDevExt->LogThisDevice = FALSE;
    botDevExt->LogThisDevice = FALSE;

    //
    // Clear the reference on IoTestDeviceObject added by IoTestFindDeviceObject
    // in IoTestPrepareDevicesForTest.
    //

    ObDereferenceObject( IoTestDeviceObject );
}

NTSTATUS
IoTestCompareData (
    IN PCHAR OriginalData,
    IN PCHAR TestData,
    IN ULONG DataLength
    )
{
    ULONG i;

    for (i=0; i < DataLength; i++) {

        if (OriginalData[i] != TestData[i]) {

            return STATUS_DATA_ERROR;
        }
    }
    
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\iotest\lib\fastionames.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    irpName.c

Abstract:

    This module contains functions used to generate names for IRPs

// @@BEGIN_DDKSPLIT
Author:

    Neal Christiansen (NealCH) 27-Sep-2000

// @@END_DDKSPLIT

Environment:

    User mode


// @@BEGIN_DDKSPLIT
Revision History:

// @@END_DDKSPLIT
--*/

#include <ntifs.h>
#include <stdio.h>
#include "ioTestLib.h"


VOID
GetFastioName (
    IN FASTIO_TYPE FastIoCode,
    OUT PCHAR FastIoName
    )
/*++

Routine Description:

    This routine translates the given FastIO code into a printable string which
    is returned.  

Arguments:

    FastIoCode - the FastIO code to translate
    FastioName - a buffer at least OPERATION_NAME_BUFFER_SIZE characters long
                 that receives the fastIO name.

Return Value:

    None.

--*/
{
    PCHAR fastIoString;
    CHAR nameBuf[OPERATION_NAME_BUFFER_SIZE];

    switch (FastIoCode) {

        case CHECK_IF_POSSIBLE:
            fastIoString = "CHECK_IF_POSSIBLE";
            break;

        case READ:
            fastIoString = "READ";
            break;

        case WRITE:
            fastIoString = "WRITE";
            break;

        case QUERY_BASIC_INFO:
            fastIoString = "QUERY_BASIC_INFO";
            break;

        case QUERY_STANDARD_INFO:
            fastIoString = "QUERY_STANDARD_INFO";
            break;

        case LOCK:
            fastIoString = "LOCK";
            break;

        case UNLOCK_SINGLE:
            fastIoString = "UNLOCK_SINGLE";
            break;

        case UNLOCK_ALL:
            fastIoString = "UNLOCK_ALL";
            break;

        case UNLOCK_ALL_BY_KEY:
            fastIoString = "UNLOCK_ALL_BY_KEY";
            break;

        case DEVICE_CONTROL:
            fastIoString = "DEVICE_CONTROL";
            break;

        case DETACH_DEVICE:
            fastIoString = "DETACH_DEVICE";
            break;

        case QUERY_NETWORK_OPEN_INFO:
            fastIoString = "QUERY_NETWORK_OPEN_INFO";
            break;

        case MDL_READ:
            fastIoString = "MDL_READ";
            break;

        case MDL_READ_COMPLETE:
            fastIoString = "MDL_READ_COMPLETE";
            break;

        case MDL_WRITE:
            fastIoString = "MDL_WRITE";
            break;

        case MDL_WRITE_COMPLETE:
            fastIoString = "MDL_WRITE_COMPLETE";
            break;

        case READ_COMPRESSED:
            fastIoString = "READ_COMPRESSED";
            break;

        case WRITE_COMPRESSED:
            fastIoString = "WRITE_COMPRESSED";
            break;

        case MDL_READ_COMPLETE_COMPRESSED:
            fastIoString = "MDL_READ_COMPLETE_COMPRESSED";
            break;

        case PREPARE_MDL_WRITE:
            fastIoString = "PREPARE_MDL_WRITE";
            break;

        case MDL_WRITE_COMPLETE_COMPRESSED:
            fastIoString = "MDL_WRITE_COMPLETE_COMPRESSED";
            break;

        case QUERY_OPEN:
            fastIoString = "QUERY_OPEN";
            break;

        default:
            sprintf(nameBuf,"Unknown FastIO operation (%u)",FastIoCode);
            fastIoString = nameBuf;
    }

    strcpy(FastIoName,fastIoString);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\iotest\filter\iotestlib.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    ioTestLib.c

Abstract:

    This contains library support routines for IoTest.  These routines
    do the main work for logging the I/O operations --- creating the log
    records, recording the relevant information, attach/detach from
    devices, etc.

// @@BEGIN_DDKSPLIT

Author:

    Molly Brown (mollybro)  

// @@END_DDKSPLIT

Environment:

    Kernel mode

// @@BEGIN_DDKSPLIT
Revision History:

// @@END_DDKSPLIT
--*/

#include <stdio.h>

#include <ntifs.h>
#include "ioTest.h"
#include "ioTestKern.h"

//
//  NameLookup Flags
//
//    These are flags passed to the name lookup routine to identify different
//    ways the name of a file can be obtained
//

#define NAMELOOKUPFL_ONLY_CHECK_CACHE           0x00000001
                // If set, only check in the name cache for the file name.

#define NAMELOOKUPFL_IN_CREATE                  0x00000002
                // if set, we are in the CREATE operation and the full path 
                // filename may need to be built up from the related FileObject.
                
#define NAMELOOKUPFL_OPEN_BY_ID                 0x00000004
                // if set and we are looking up the name in the file object,
                // the file object does not actually contain a name but it
                // contains a file/object ID.

//
//  Macro for copying file name into LogRecord.
//

#define COPY_FILENAME_TO_LOG_RECORD( _logRecord, _hashName, _bytesToCopy ) \
    RtlCopyMemory( (_logRecord).Name, (_hashName), (_bytesToCopy) );       \
    (_logRecord).Length += (_bytesToCopy)

#define NULL_TERMINATE_UNICODE_STRING(_string)                                    \
{                                                                                 \
    ASSERT( (_string)->Length <= (_string)->MaximumLength );                      \
    if ((_string)->Length == (_string)->MaximumLength) {                          \
        (_string)->Length -= sizeof( UNICODE_NULL );                              \
    }                                                                             \
    (_string)->Buffer[(_string)->Length/sizeof( WCHAR )] = UNICODE_NULL;  \
}

#define IOTEST_EXCEED_NAME_BUFFER_MESSAGE           L"FILE NAME EXCEEDS BUFFER SIZE"
#define IOTEST_EXCEED_NAME_BUFFER_MESSAGE_LENGTH    (sizeof( IOTEST_EXCEED_NAME_BUFFER_MESSAGE ) - sizeof( UNICODE_NULL ))
#define IOTEST_ERROR_RETRIEVING_NAME_MESSAGE        L"ERROR RETRIEVING FILE NAME"
#define IOTEST_ERROR_RETRIEVING_NAME_MESSAGE_LENGTH (sizeof( IOTEST_ERROR_RETRIEVING_NAME_MESSAGE ) - sizeof( UNICODE_NULL ))
#define IOTEST_MAX_ERROR_MESSAGE_LENGTH             (max( IOTEST_ERROR_RETRIEVING_NAME_MESSAGE_LENGTH, IOTEST_EXCEED_NAME_BUFFER_MESSAGE_LENGTH))

//////////////////////////////////////////////////////////////////////////
//                                                                      //
//                     Library support routines                         //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

VOID
IoTestReadDriverParameters (
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    This routine tries to read the IoTest-specific parameters from
    the registry.  These values will be found in the registry location
    indicated by the RegistryPath passed in.

Arguments:

    RegistryPath - the path key which contains the values that are
        the IoTest parameters

Return Value:

    None.

--*/
{

    OBJECT_ATTRIBUTES attributes;
    HANDLE driverRegKey;
    NTSTATUS status;
    ULONG bufferSize, resultLength;
    PVOID buffer = NULL;
    UNICODE_STRING valueName;
    PKEY_VALUE_PARTIAL_INFORMATION pValuePartialInfo;

    //
    //  All the global values are already set to default values.  Any
    //  values we read from the registry will override these defaults.
    //
    
    //
    //  Do the initial setup to start reading from the registry.
    //

    InitializeObjectAttributes( &attributes,
								RegistryPath,
								OBJ_CASE_INSENSITIVE,
								NULL,
								NULL);

    status = ZwOpenKey( &driverRegKey,
						KEY_READ,
						&attributes);

    if (!NT_SUCCESS(status)) {

        driverRegKey = NULL;
        goto IoTestReadDriverParameters_Exit;
    }

    bufferSize = sizeof( KEY_VALUE_PARTIAL_INFORMATION ) + sizeof( ULONG );
    buffer = ExAllocatePool( NonPagedPool, bufferSize );

    if (NULL == buffer) {

        goto IoTestReadDriverParameters_Exit;
    }

    //
    // Read the gMaxRecordsToAllocate from the registry
    //

    RtlInitUnicodeString(&valueName, MAX_RECORDS_TO_ALLOCATE);

    status = ZwQueryValueKey( driverRegKey,
							  &valueName,
							  KeyValuePartialInformation,
							  buffer,
							  bufferSize,
							  &resultLength);

    if (NT_SUCCESS(status)) {

        pValuePartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION) buffer;
        ASSERT(pValuePartialInfo->Type == REG_DWORD);
        gMaxRecordsToAllocate = *((PLONG)&(pValuePartialInfo->Data));

    }

    //
    // Read the gMaxNamesToAllocate from the registry
    //

    RtlInitUnicodeString(&valueName, MAX_NAMES_TO_ALLOCATE);

    status = ZwQueryValueKey( driverRegKey,
							  &valueName,
							  KeyValuePartialInformation,
							  buffer,
							  bufferSize,
							  &resultLength);

    if (NT_SUCCESS(status)) {

        pValuePartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION) buffer;
        ASSERT(pValuePartialInfo->Type == REG_DWORD);
        gMaxNamesToAllocate = *((PLONG)&(pValuePartialInfo->Data));

    }

    //
    // Read the initial debug setting from the registry
    //

    RtlInitUnicodeString(&valueName, DEBUG_LEVEL);

    status = ZwQueryValueKey( driverRegKey,
                              &valueName,
                              KeyValuePartialInformation,
                              buffer,
                              bufferSize,
                              &resultLength );

    if (NT_SUCCESS( status )) {

        pValuePartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION) buffer;
        ASSERT( pValuePartialInfo->Type == REG_DWORD );
        gIoTestDebugLevel |= *((PULONG)&(pValuePartialInfo->Data));
        
    }
    
    //
    // Read the attachment mode setting from the registry
    //

    RtlInitUnicodeString(&valueName, ATTACH_MODE);

    status = ZwQueryValueKey( driverRegKey,
                              &valueName,
                              KeyValuePartialInformation,
                              buffer,
                              bufferSize,
                              &resultLength );

    if (NT_SUCCESS( status )) {

        pValuePartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION) buffer;
        ASSERT( pValuePartialInfo->Type == REG_DWORD );
        gIoTestAttachMode = *((PULONG)&(pValuePartialInfo->Data));
        
    }
    
    goto IoTestReadDriverParameters_Exit;

IoTestReadDriverParameters_Exit:

    if (NULL != buffer) {

        ExFreePool(buffer);
    }

    if (NULL != driverRegKey) {

        ZwClose(driverRegKey);
    }

    return;
}

////////////////////////////////////////////////////////////////////////
//                                                                    //
//                  Memory allocation routines                        //
//                                                                    //
////////////////////////////////////////////////////////////////////////

PVOID
IoTestAllocateBuffer (
    IN OUT PLONG Counter,
    IN LONG MaxCounterValue,
    OUT PULONG RecordType
    )
/*++

Routine Description:

    Allocates a new buffer from the gFreeBufferList if there is enough memory
    to do so and Counter does not exceed MaxCounterValue.  The RecordType
    is set to one of the record type constants based on the allocation state.

Arguments:

    Counter - (optional) the counter variable to test and increment if
        we can allocate
    MaxCounterValue - (ignored if Counter not given) the value which
        Counter should not exceed
    RecordType - (optional) set to one of the following:
        RECORD_TYPE_NORMAL  allocation succeeded
        RECORD_TYPE_OUT_OF_MEMORY allocation failed because the system was
                                  out of memory
        RECORD_TYPE_EXCEED_MEMORY_ALLOWANCE allocation failed because the
                                counter exceeded its maximum value.

Return Value:

    Pointer to the buffer allocate, or NULL if allocation failed (either
    because system is out of memory or we have exceeded the MaxCounterValue).

--*/
{
    PVOID newBuffer;
    ULONG newRecordType = RECORD_TYPE_NORMAL;

#ifdef MEMORY_DBG
    //
    //  When we are debugging the memory usage to make sure that we
    //  don't leak memory, we want to allocate the memory from pool
    //  so that we can use the Driver Verifier to help debug any
    //  memory problems.
    //

    newBuffer = ExAllocatePoolWithTag( NonPagedPool, RECORD_SIZE, MSFM_TAG );
#else

    //
    //  When we are not debugging the memory usage, we use a look-aside
    //  list for better performance.
    //

    newBuffer = ExAllocateFromNPagedLookasideList( &gFreeBufferList );
#endif

    if (newBuffer) {

        if (Counter) {

            if (*Counter < MaxCounterValue) {

                InterlockedIncrement(Counter);

            } else {

				//
                // We've exceed our driver's memory limit so note that
                // and give back the record
				//

                SetFlag( newRecordType, 
                         (RECORD_TYPE_STATIC | RECORD_TYPE_EXCEED_MEMORY_ALLOWANCE) );

#ifdef MEMORY_DBG
                ExFreePool( newBuffer );
#else
                ExFreeToNPagedLookasideList( &gFreeBufferList, newBuffer );
#endif

                newBuffer = NULL;
            }
        }

    }  else {

        SetFlag( newRecordType,
                 (RECORD_TYPE_STATIC | RECORD_TYPE_OUT_OF_MEMORY) );
    }

    if (RecordType) {

        *RecordType = newRecordType;
    }

    return newBuffer;
}

VOID
IoTestFreeBuffer (
    IN PVOID Buffer,
    IN PLONG Counter
    )
/*++

Routine Description:

    Returns a Buffer to the gFreeBufferList.

Arguments:

    Buffer - the buffer to return to the gFreeBufferList

Return Value:

    None.

--*/
{

#ifdef MEMORY_DBG
    ExFreePool( Buffer );
#else
    ExFreeToNPagedLookasideList( &gFreeBufferList, Buffer );
#endif

    //
    // Update the count
    //
    if (Counter) {

        InterlockedDecrement(Counter);
    }
}


////////////////////////////////////////////////////////////////////////
//                                                                    //
//                  Logging routines                                  //
//                                                                    //
////////////////////////////////////////////////////////////////////////

PRECORD_LIST
IoTestNewRecord (
    IN ULONG AssignedSequenceNumber
    )
/*++

Routine Description:

    Allocates a new RECORD_LIST structure if there is enough memory to do so. A
    sequence number is updated for each request for a new record.

Arguments:

    AssignedSequenceNumber - 0 if you want this function to generate the
        next sequence number; if not 0, the new record is assigned the
        given sequence number.

Return Value:

    Pointer to the RECORD_LIST allocated, or NULL if no memory is available.

--*/
{
    PRECORD_LIST newRecord = NULL;
    ULONG currentSequenceNumber;
    KIRQL irql;
    ULONG initialRecordType;

    newRecord = (PRECORD_LIST) IoTestAllocateBuffer( &gRecordsAllocated,
                                                  gMaxRecordsToAllocate,
                                                  &initialRecordType);

    KeAcquireSpinLock(&gLogSequenceLock, &irql);

    //
    // Assign a new sequence number if 0 was passed in, otherwise use the
    // number passed in
    //

    if (AssignedSequenceNumber == 0) {

        gLogSequenceNumber++;
        currentSequenceNumber = gLogSequenceNumber;

    } else {

        currentSequenceNumber = AssignedSequenceNumber;
    }


    if ((newRecord == NULL) &&
        !InterlockedCompareExchange( &gStaticBufferInUse, TRUE, FALSE)) {

        //
        // Toggle on our gStaticBufferInUse flag and use the static out of memory
        // buffer to record this log entry.  This special log record is used
        // to notify the user application that we are out of memory.  Log
        // request will be dropped until we can get more memory.
        //

        newRecord   = (PRECORD_LIST)gOutOfMemoryBuffer;
        newRecord->LogRecord.RecordType = initialRecordType;
        newRecord->LogRecord.Length = SIZE_OF_LOG_RECORD;
        newRecord->LogRecord.SequenceNumber = currentSequenceNumber;

    } else if (newRecord) {

		//
        // We were able to allocate a new record so initialize it
        // appropriately.
		//

        newRecord->LogRecord.RecordType = initialRecordType;
        newRecord->LogRecord.Length = SIZE_OF_LOG_RECORD;
        newRecord->LogRecord.SequenceNumber = currentSequenceNumber;
    }

    KeReleaseSpinLock(&gLogSequenceLock, irql);

    return( newRecord );
}

VOID
IoTestFreeRecord (
    IN PRECORD_LIST Record
    )
/*++

Routine Description:

    Frees a RECORD_LIST, which returns the memory to the gFreeBufferList look-aside
    list and updates the gRecordsAllocated count.

Arguments:

    Record - the record to free

Return Value:

    None.

--*/
{
    if (FlagOn( Record->LogRecord.RecordType, RECORD_TYPE_STATIC )) {

		//
        // This is our static record, so reset our gStaticBufferInUse
        // flag.
		//

        InterlockedExchange( &gStaticBufferInUse, FALSE );

    } else {

		//
        // This isn't our static memory buffer, so free the dynamically
        // allocated memory.
		//

        IoTestFreeBuffer( Record, &gRecordsAllocated );
    }
}

VOID
IoTestLogIrp (
    IN PIRP Irp,
    IN UCHAR LoggingFlags,
    OUT PRECORD_LIST RecordList
    )
/*++

Routine Description:

    Records the Irp necessary information according to LoggingFlags in
    RecordList.  For any activity on the Irp path of a device being
    logged, this function should get called twice: once on the Irp's
    originating path and once on the Irp's completion path.

Arguments:

    Irp - The Irp that contains the information we want to record.
    LoggingFlags - The flags that say what to log.
    RecordList - The PRECORD_LIST in which the Irp information is stored.

Return Value:

    None.

--*/
{
    PIO_STACK_LOCATION pIrpStack;
    PRECORD_IRP pRecordIrp;
    PIOTEST_DEVICE_EXTENSION deviceExtension;
    ULONG lookupFlags;

    pRecordIrp = &RecordList->LogRecord.Record.RecordIrp;

    pIrpStack = IoGetCurrentIrpStackLocation(Irp);
    deviceExtension = pIrpStack->DeviceObject->DeviceExtension;


    if (FlagOn( LoggingFlags, LOG_ORIGINATING_IRP )) {

        //
        // Record the information we use for an originating Irp.  We first
        // need to initialize some of the RECORD_LIST and RECORD_IRP fields.
        // Then get the interesting information from the Irp.
        //

        SetFlag( RecordList->LogRecord.RecordType, RECORD_TYPE_IRP );

        RecordList->LogRecord.DeviceType = deviceExtension->Type;
        
        pRecordIrp->IrpMajor        = pIrpStack->MajorFunction;
        pRecordIrp->IrpMinor        = pIrpStack->MinorFunction;
        pRecordIrp->IrpFlags        = Irp->Flags;
        pRecordIrp->FileObject      = (FILE_ID)pIrpStack->FileObject;
        pRecordIrp->ProcessId       = (FILE_ID)PsGetCurrentProcessId();
        pRecordIrp->ThreadId        = (FILE_ID)PsGetCurrentThreadId();
        pRecordIrp->Argument1       = pIrpStack->Parameters.Others.Argument1;
        pRecordIrp->Argument2       = pIrpStack->Parameters.Others.Argument2;
        pRecordIrp->Argument3       = pIrpStack->Parameters.Others.Argument3;
        pRecordIrp->Argument4       = pIrpStack->Parameters.Others.Argument4;

        if (IRP_MJ_CREATE == pRecordIrp->IrpMajor) {

			//
			//  Only record the desired access if this is a CREATE irp.
			//

            pRecordIrp->DesiredAccess = pIrpStack->Parameters.Create.SecurityContext->DesiredAccess;
        }

        KeQuerySystemTime(&(pRecordIrp->OriginatingTime));

        lookupFlags = 0;

        if (IRP_MJ_CREATE == pIrpStack->MajorFunction) {

            SetFlag( lookupFlags, NAMELOOKUPFL_IN_CREATE );

            if (FlagOn( pIrpStack->Parameters.Create.Options, FILE_OPEN_BY_FILE_ID )) {

                SetFlag( lookupFlags, NAMELOOKUPFL_OPEN_BY_ID );
            }
        }

        //
        //  We can only look up the name in the name cache if this is a CLOSE.  
        //  It is possible that the close could be occurring during a cleanup 
        //  operation in the file system (i.e., before we have received the
        //  cleanup completion) and requesting the name would cause a deadlock
        //  in the file system.
        //  
        if (pIrpStack->MajorFunction == IRP_MJ_CLOSE) {

            SetFlag( lookupFlags, NAMELOOKUPFL_ONLY_CHECK_CACHE );
        }

        IoTestNameLookup( RecordList, pIrpStack->FileObject, lookupFlags, deviceExtension);
    }

#if 0
    if (FlagOn( LoggingFlags, LOG_COMPLETION_IRP )) {

        //
        // Record the information we use for a completion Irp.
        //

        pRecordIrp->ReturnStatus = Irp->IoStatus.Status;
        pRecordIrp->ReturnInformation = Irp->IoStatus.Information;
        KeQuerySystemTime(&(pRecordIrp->CompletionTime));
    }
#endif     
}

PRECORD_LIST
IoTestLogFastIoStart (
    IN FASTIO_TYPE FastIoType,
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject OPTIONAL,
    IN PLARGE_INTEGER FileOffset OPTIONAL,
    IN ULONG Length OPTIONAL,
    IN BOOLEAN Wait	OPTIONAL
    )
/*++

Routine Description:

    Creates the log record if possible and records the necessary Fast I/O
    information at the beginning of the fast I/O operation in RecordList
    according to LoggingFlags.

    The optional arguments are not recorded for all Fast I/O types.  If
    the argument is not needed for a given Fast I/O type, the parameter
    was ignored.

Arguments:

    FastIoType - The type of fast I/O we are logging (REQUIRED)
    DeviceObject - The device object for our filter. (REQUIRED)
    FileObject - Pointer to the file object this operation is on (OPTIONAL)
    FileOffset - Pointer to the file offset for this operation (OPTIONAL)
    Length - Length of the data for this operation (OPTIONAL)
    Wait - Whether or not this operation can wait for a result (OPTIONAL)

Return Value:

    The RECORD_LIST structure created with the appropriate information
    filled in.  If a RECORD_LIST structure couldn't be allocated, NULL
    is returned.

--*/
{
    PRECORD_LIST    pRecordList;
    PRECORD_FASTIO  pRecordFastIo;
    PIOTEST_DEVICE_EXTENSION deviceExtension;

    //
    // Try to get a new record
    //

    pRecordList = IoTestNewRecord(0);

    //
    // If we didn't get a RECORD_LIST, exit and return NULL
    //

    if (pRecordList == NULL) {

        return NULL;
    }

    deviceExtension = DeviceObject->DeviceExtension;
    
    //
    // We got a RECORD_LIST, so now fill in the appropriate information
    //

    pRecordFastIo = &pRecordList->LogRecord.Record.RecordFastIo;

    //
    // Perform the necessary book keeping for the RECORD_LIST
    //

    SetFlag( pRecordList->LogRecord.RecordType, RECORD_TYPE_FASTIO );

    //
    //  Record which device is seeing this operation.
    //
    
    pRecordList->LogRecord.DeviceType = deviceExtension->Type;

    //
    // Set the RECORD_FASTIO fields that are set for all Fast I/O types
    //

    pRecordFastIo->Type = FastIoType;
    KeQuerySystemTime(&(pRecordFastIo->StartTime));

    //
    // Get process and thread information
    //

    pRecordFastIo->ProcessId = (ULONG_PTR) PsGetCurrentProcessId();
    pRecordFastIo->ThreadId = (ULONG_PTR) PsGetCurrentThreadId();

    //
    // Record the information that is appropriate based on the
    // Fast I/O type
    //

    pRecordFastIo->FileObject = (FILE_ID)FileObject;
    pRecordFastIo->FileOffset.QuadPart = ((FileOffset != NULL) ? FileOffset->QuadPart : 0);
    pRecordFastIo->Length = Length;
    pRecordFastIo->Wait = Wait;

    IoTestNameLookup(pRecordList, FileObject, 0, deviceExtension);

    return pRecordList;
}

#if 0
VOID
IoTestLogFastIoComplete (
    IN PIO_STATUS_BLOCK ReturnStatus,
    IN PRECORD_LIST RecordList
    )
/*++

Routine Description:

    Records the necessary Fast I/O information in RecordList according to
    LoggingFlags.

    The optional arguments are not recorded for all Fast I/O types.  If
    the argument is not needed for a given Fast I/O type, the parameter
    was ignored.

Arguments:
    ReturnStatus - The return value of the operation (OPTIONAL)
    RecordList - The PRECORD_LIST in which the Fast I/O information is stored.

Return Value:

    None.

--*/
{
    PRECORD_FASTIO pRecordFastIo;

    ASSERT(RecordList);

    pRecordFastIo = &RecordList->LogRecord.Record.RecordFastIo;

    //
    // Set the RECORD_FASTIO fields that are set for all Fast I/O types
    //

    KeQuerySystemTime(&(pRecordFastIo->CompletionTime));

    if (ReturnStatus != NULL) {

        pRecordFastIo->ReturnStatus = ReturnStatus->Status;

    } else {

        pRecordFastIo->ReturnStatus = 0;
    }

    IoTestLog(RecordList);
}
#endif

VOID
IoTestLogPreFsFilterOperation (
    IN PFS_FILTER_CALLBACK_DATA Data,
    OUT PRECORD_LIST RecordList
    )
{
    PIOTEST_DEVICE_EXTENSION deviceExtension;
    
    PRECORD_FS_FILTER_OPERATION pRecordFsFilterOp;

    deviceExtension = Data->DeviceObject->DeviceExtension;

    pRecordFsFilterOp = &RecordList->LogRecord.Record.RecordFsFilterOp;
    
    //
    // Record the information we use for an originating Irp.  We first
    // need to initialize some of the RECORD_LIST and RECORD_IRP fields.
    // Then get the interesting information from the Irp.
    //

    SetFlag( RecordList->LogRecord.RecordType, RECORD_TYPE_FS_FILTER_OP );

    RecordList->LogRecord.DeviceType = deviceExtension->Type;
    
    pRecordFsFilterOp->FsFilterOperation = Data->Operation;
    pRecordFsFilterOp->FileObject = (FILE_ID) Data->FileObject;
    pRecordFsFilterOp->ProcessId = (FILE_ID)PsGetCurrentProcessId();
    pRecordFsFilterOp->ThreadId = (FILE_ID)PsGetCurrentThreadId();
    
    KeQuerySystemTime(&(pRecordFsFilterOp->OriginatingTime));

    //
    //  Only set the volumeName if the next device is a file system
    //  since we only want to prepend the volumeName if we are on
    //  top of a local file system.
    //

    IoTestNameLookup( RecordList, Data->FileObject, 0, deviceExtension);
}

#if 0
VOID
IoTestLogPostFsFilterOperation (
    IN NTSTATUS OperationStatus,
    OUT PRECORD_LIST RecordList
    )
{
    PRECORD_FS_FILTER_OPERATION pRecordFsFilterOp;

    pRecordFsFilterOp = &RecordList->LogRecord.Record.RecordFsFilterOp;
    
    //
    // Record the information we see in the post operation.
    //

    pRecordFsFilterOp->ReturnStatus   = OperationStatus;
    KeQuerySystemTime(&(pRecordFsFilterOp->CompletionTime));
}
#endif

NTSTATUS
IoTestLog (
    IN PRECORD_LIST NewRecord
    )
/*++

Routine Description:

    This routine appends the completed log record to the gOutputBufferList.

Arguments:

    NewRecord - The record to append to the gOutputBufferList

Return Value:

    The function returns STATUS_SUCCESS.



--*/
{
    KIRQL controlDeviceIrql;
    KIRQL outputBufferIrql;

    KeAcquireSpinLock( &gControlDeviceStateLock, &controlDeviceIrql );

    if (gControlDeviceState == OPENED) {

        //
        // The device is still open so add this record onto the list
        //

        KeAcquireSpinLock(&gOutputBufferLock, &outputBufferIrql);
        InsertTailList(&gOutputBufferList, &NewRecord->List);
        KeReleaseSpinLock(&gOutputBufferLock, outputBufferIrql);

    } else {

        //
        // We can no longer log this record, so free the record
        //

        IoTestFreeRecord( NewRecord );

    }

    KeReleaseSpinLock( &gControlDeviceStateLock, controlDeviceIrql );

    return STATUS_SUCCESS;
}

////////////////////////////////////////////////////////////////////////
//                                                                    //
//                    FileName cache routines                         //
//                                                                    //
////////////////////////////////////////////////////////////////////////

PHASH_ENTRY
IoTestHashBucketLookup (
    IN PLIST_ENTRY  ListHead,
    IN PFILE_OBJECT FileObject
    )
/*++

Routine Description:

    This routine looks up the FileObject in the give hash bucket.  This routine
    does NOT lock the hash bucket.

Arguments:

    ListHead - hash list to search
    FileObject - the FileObject to look up.

Return Value:

    A pointer to the hash table entry.  NULL if not found

--*/
{
    PHASH_ENTRY pHash;
    PLIST_ENTRY pList;

    pList = ListHead->Flink;

    while (pList != ListHead){

        pHash = CONTAINING_RECORD( pList, HASH_ENTRY, List );

        if (FileObject == pHash->FileObject) {

            return pHash;
        }

        pList = pList->Flink;
    }

    return NULL;
}

VOID
IoTestNameLookup (
    IN PRECORD_LIST RecordList,
    IN PFILE_OBJECT FileObject,
    IN ULONG LookupFlags,
    IN PIOTEST_DEVICE_EXTENSION DeviceExtension
    )
/*++

Routine Description:

    This routine looks up the FileObject in the hash table.  If the FileObject
    is found in the hash table, copy the associated file name to RecordList.
    Otherwise, calls IoTestGetFullPathName to try to get the name of the FileObject.
    If successful, copy the file name to the RecordList and insert into hash
    table.

Arguments:

    RecordList - RecordList to copy name to.
    FileObject - the FileObject to look up.
    LookInFileObject - see routine description
    DeviceExtension - contains the volume name (e.g., "c:") and
        the next device object which may be needed.

Return Value:

    None.
    
--*/
{
    UINT_PTR hashIndex;
    KIRQL oldIrql;
    PHASH_ENTRY pHash;
    PHASH_ENTRY newHash;
    PLIST_ENTRY listHead;
    PUNICODE_STRING newName;
    PCHAR buffer;
    SHORT bytesToCopy;

    if (FileObject == NULL) {

        return;
    }

    hashIndex = HASH_FUNC(FileObject);

    gHashStat.Lookups++;

    KeAcquireSpinLock( &gHashLockTable[hashIndex], &oldIrql );

    listHead = &gHashTable[hashIndex];

    pHash = IoTestHashBucketLookup(&gHashTable[hashIndex], FileObject);

    if (pHash != NULL) {

        bytesToCopy = min( MAX_NAME_SPACE, pHash->Name.Length );

        ASSERT((bytesToCopy > 0) && (bytesToCopy <= MAX_NAME_SPACE));

        //
        //  Copy the file name to the LogRecord, make sure that it is NULL terminated,
        //  and increment the length of the LogRecord.
        //

        COPY_FILENAME_TO_LOG_RECORD( RecordList->LogRecord, pHash->Name.Buffer, bytesToCopy );
        
        KeReleaseSpinLock(&gHashLockTable[hashIndex], oldIrql);

        gHashStat.LookupHits++;

        return;
    }

    KeReleaseSpinLock(&gHashLockTable[hashIndex], oldIrql);

    if (FlagOn( LookupFlags, NAMELOOKUPFL_ONLY_CHECK_CACHE )) {

        //
        //  We didn't find the name in the cache, but we can't ask the 
        //  file system now, so just return.
        //

        return;
    }

    //
    //  If it is not in the table, try to add it.  We will not be able to look up
    //  the name if we are at DISPATCH_LEVEL.
    //

    buffer = IoTestAllocateBuffer(&gNamesAllocated, gMaxNamesToAllocate, NULL);

    if (buffer != NULL) {
    
        newHash = (PHASH_ENTRY) buffer;
        newName = &newHash->Name;

        RtlInitEmptyUnicodeString(
                newName,
                (PWCHAR)(buffer + sizeof(HASH_ENTRY)),
                RECORD_SIZE - sizeof(HASH_ENTRY) );

        if (IoTestGetFullPathName( FileObject, newName, DeviceExtension, LookupFlags )) {

            newHash->FileObject = FileObject;
            KeAcquireSpinLock(&gHashLockTable[hashIndex], &oldIrql);

            //
            //  Search again because it may have been stored in the
            //  hash table since we dropped the lock.
            //
			
			pHash = IoTestHashBucketLookup(&gHashTable[hashIndex], FileObject);

            if (pHash != NULL) {

                //
                //  We found it in the hash table this time, so
                //  write the name we found to the LogRecord.
                //

                bytesToCopy = min(
                    MAX_NAME_SPACE,
                    pHash->Name.Length );

                ASSERT( (bytesToCopy > 0) && (bytesToCopy <= MAX_NAME_SPACE) );

                //
                //  Copy the file name to the LogRecord, make sure that it is NULL terminated,
                //  and increment the length of the LogRecord.
                //

                COPY_FILENAME_TO_LOG_RECORD( RecordList->LogRecord, pHash->Name.Buffer, bytesToCopy );

                KeReleaseSpinLock(&gHashLockTable[hashIndex], oldIrql);

                IoTestFreeBuffer(buffer, &gNamesAllocated);

                return;
            }

            //
            // It wasn't found, add the new entry
            //

            bytesToCopy = min( MAX_NAME_SPACE, newHash->Name.Length );

            ASSERT(bytesToCopy > 0 && bytesToCopy <= MAX_NAME_SPACE);

            //
            //  Copy the file name to the LogRecord, make sure that it is NULL terminated,
            //  and increment the length of the LogRecord.
            //

            COPY_FILENAME_TO_LOG_RECORD( RecordList->LogRecord, newHash->Name.Buffer, bytesToCopy );

            InsertHeadList(listHead, &newHash->List);

            gHashCurrentCounters[hashIndex]++;

            if (gHashCurrentCounters[hashIndex] > gHashMaxCounters[hashIndex]) {

                gHashMaxCounters[hashIndex] = gHashCurrentCounters[hashIndex];
            }

            KeReleaseSpinLock(&gHashLockTable[hashIndex], oldIrql);

        } else {

            IoTestFreeBuffer (buffer, &gNamesAllocated);
        }
    }

    return;
}

VOID
IoTestNameDeleteAllNames (
    VOID
    )
/*++

Routine Description:

    This will free all entries from the hash table

Arguments:

    None

Return Value:

    None


--*/
{
    KIRQL oldIrql;
    PHASH_ENTRY pHash;
    PLIST_ENTRY pList;
    ULONG i;

    for (i=0;i < HASH_SIZE;i++) {

        KeAcquireSpinLock(&gHashLockTable[i], &oldIrql);

        while (!IsListEmpty(&gHashTable[i])) {

            pList = RemoveHeadList(&gHashTable[i]);
            pHash = CONTAINING_RECORD( pList, HASH_ENTRY, List );
            IoTestFreeBuffer( pHash, &gNamesAllocated);
        }

        gHashCurrentCounters[i] = 0;

        KeReleaseSpinLock(&gHashLockTable[i], oldIrql);
    }
}

VOID
IoTestNameDelete (
    IN PFILE_OBJECT FileObject
    )
/*++

Routine Description:

    This routine looks up the FileObject in the hash table.  If it is found,
    it deletes it and frees the memory.

Arguments:

    FileObject - the FileObject to look up.

Return Value:

    None


--*/
{
    UINT_PTR hashIndex;
    KIRQL oldIrql;
    PHASH_ENTRY pHash;
    PLIST_ENTRY pList;
    PLIST_ENTRY listHead;

    hashIndex = HASH_FUNC(FileObject);

    gHashStat.DeleteLookups++;

    KeAcquireSpinLock(&gHashLockTable[hashIndex], &oldIrql);

    listHead = &gHashTable[hashIndex];

    pList = listHead->Flink;

    while(pList != listHead){

        pHash = CONTAINING_RECORD( pList, HASH_ENTRY, List );

        if (FileObject == pHash->FileObject) {

            gHashStat.DeleteLookupHits++;
            gHashCurrentCounters[hashIndex]--;
            RemoveEntryList(pList);
            IoTestFreeBuffer( pHash, &gNamesAllocated );
            break;
        }

        pList = pList->Flink;
    }

    KeReleaseSpinLock(&gHashLockTable[hashIndex], oldIrql);
}

BOOLEAN
IoTestGetFullPathName (
    IN PFILE_OBJECT FileObject,
    IN OUT PUNICODE_STRING FileName,
    IN PIOTEST_DEVICE_EXTENSION DeviceExtension,
    IN ULONG LookupFlags
    )
/*++

Routine Description:

    This routine retrieves the full pathname of the FileObject.  Note that
    the buffers containing pathname components may be stored in paged pool,
    therefore if we are at DISPATCH_LEVEL we cannot look up the name.

    The file is looked up one of the following ways based on the LookupFlags:
    1.  FlagOn( FileObject->Flags, FO_VOLUME_OPEN ) or FileObject->FileName.Length == 0.
        This is a volume open, so just use DeviceName from the DeviceExtension 
        for the FileName, if it exists.
    2.  NAMELOOKUPFL_IN_CREATE and NAMELOOKUPFL_OPEN_BY_ID are set.
        This is an open by file id, so format the file id into the FileName
        string if there is enough room.
    3.  NAMELOOKUPFL_IN_CREATE set and FileObject->RelatedFileObject != NULL.
        This is a relative open, therefore the fullpath file name must
        be built up from the name of the FileObject->RelatedFileObject
        and FileObject->FileName.
    4.  NAMELOOKUPFL_IN_CREATE and FileObject->RelatedFileObject == NULL.
        This is an absolute open, therefore the fullpath file name is
        found in FileObject->FileName.
    5.  No LookupFlags set.
        This is a lookup sometime after CREATE.  FileObject->FileName is 
        no longer guaranteed to be valid, so use ObQueryNameString
        to get the fullpath name of the FileObject.
    
Arguments:

    FileObject - Pointer to the FileObject to the get name of.

    FileName - Unicode string that will be filled in with the filename,  It 
        is assumed that the caller allocates and frees the memory used by 
        the string.  The buffer and MaximumLength for this string should be 
        set.  If there is room in the buffer, the string will be NULL 
        terminated.

    DeviceExtension - Contains the device name and next device object
        which are needed to build the full path name.

    LookupFlags - The flags to say whether to get the name from the file
        object or to get the file id.

Return Value:

    Returns TRUE if the name is successfully found (the name could
    be a NULL string) and should be copied into the LogRecord, or FALSE 
    if the FileName should not be copied into the LogRecord.

--*/
{
    NTSTATUS status;

    //
    //  Check to make sure that parameters are valid.
    //
    
    if ((NULL == FileObject) ||
        (NULL == FileName) ||
        (NULL == DeviceExtension) ||
        (FlagOn( LookupFlags, NAMELOOKUPFL_OPEN_BY_ID ) &&
         !FlagOn( LookupFlags, NAMELOOKUPFL_IN_CREATE ))) {

        return FALSE;
    }

    //
    // Names buffers in file objects might be paged.
    //

    if (KeGetCurrentIrql() > PASSIVE_LEVEL) {

        return FALSE;
    }

    //
    //  Copy over the name the user gave for this device.  These names
    //  should be meaningful to the user.
    //
    
    RtlCopyUnicodeString( FileName, &(DeviceExtension->UserNames) );

    //
    //  Make sure we at least have enough room for our name error messages.
    //

    if ((FileName->Length + IOTEST_MAX_ERROR_MESSAGE_LENGTH) > FileName->MaximumLength) {

        return FALSE;
    }

    //
    //  Do a quick check here to see if we even have enough
    //  room in FileName for the FileObject->FileName.  If
    //  not, there is no use doing the work to build up the
    //  rest of the name.
    //

    if ((FileName->Length + FileObject->FileName.Length) > FileName->MaximumLength) {

        //
        //  We don't have enough room in FileName, so just return
        //  IOTEST_EXCEED_NAME_BUFFER_MESSAGE
        //

        RtlAppendUnicodeToString( FileName, IOTEST_EXCEED_NAME_BUFFER_MESSAGE );
        
        return TRUE;
    }
       
    //
    //  CASE 1:  This FileObject refers to a Volume open.
    //

    if (FlagOn( FileObject->Flags, FO_VOLUME_OPEN )) {

        //
        //  We've already copied over VolumeName to FileName if
        //  we've got VolumeName, so just return.
        //

        return TRUE;
    }

    //
    //  CASE 2:  We are opening the file by ID.
    //

    else if (FlagOn( LookupFlags, NAMELOOKUPFL_IN_CREATE ) &&
             FlagOn( LookupFlags, NAMELOOKUPFL_OPEN_BY_ID )) {

#       define OBJECT_ID_KEY_LENGTH 16
#       define OBJECT_ID_STRING_LENGTH 64

        UNICODE_STRING fileIdName;
        WCHAR fileIdBuffer[OBJECT_ID_STRING_LENGTH];
        PUCHAR idBuffer;

        if (FileObject->FileName.Length == sizeof(LONGLONG)) {

			//
            //  Opening by FILE ID, generate a name
			//
			
            PLONGLONG fileref;

            fileref = (PLONGLONG) FileObject->FileName.Buffer;

            swprintf( fileIdBuffer, L"<%016I64x>", *fileref );

        } else if ((FileObject->FileName.Length == OBJECT_ID_KEY_LENGTH) ||
                   (FileObject->FileName.Length == OBJECT_ID_KEY_LENGTH + sizeof(WCHAR))) {

            //
            //  Opening by Object ID, generate a name
            //

            idBuffer = (PUCHAR)&FileObject->FileName.Buffer[0];

            if (FileObject->FileName.Length != OBJECT_ID_KEY_LENGTH) {

                //
                //  Skip win32k backslash at start of buffer
                //
                idBuffer = (PUCHAR)&FileObject->FileName.Buffer[1];
            }

            swprintf( fileIdBuffer,
					  L"<%08x-%04hx-%04hx-%04hx-%04hx%08x>",
                      *(PULONG)&idBuffer[0],
                      *(PUSHORT)&idBuffer[0+4],
                      *(PUSHORT)&idBuffer[0+4+2],
                      *(PUSHORT)&idBuffer[0+4+2+2],
                      *(PUSHORT)&idBuffer[0+4+2+2+2],
                      *(PULONG)&idBuffer[0+4+2+2+2+2]);

        } else {

			//
            //  Unknown ID format
			//

            swprintf( fileIdBuffer,
                      L"<Unknown ID (Len=%u)>",
                      FileObject->FileName.Length);
        }

        fileIdName.MaximumLength = sizeof( fileIdBuffer );
        fileIdName.Buffer = fileIdBuffer;
        fileIdName.Length = wcslen( fileIdBuffer ) * sizeof( WCHAR );

        //
        //  Try to append the fileIdName to FileName.
        //

        status = RtlAppendUnicodeStringToString( FileName, &fileIdName );

        if (!NT_SUCCESS( status )) {

            //
            //  We don't have enough room for the file name, so copy our
            //  EXCEED_NAME_BUFFER error message.
            //

            RtlAppendUnicodeToString( FileName, IOTEST_EXCEED_NAME_BUFFER_MESSAGE );
        }

        return TRUE;
    } 

    //
    //  CASE 3: We are opening a file that has a RelatedFileObject.
    //
    
    else if (FlagOn( LookupFlags, NAMELOOKUPFL_IN_CREATE ) &&
             (FileObject->RelatedFileObject != NULL)) {

        //
        //  Must be a relative open.  Use ObQueryNameString to get
        //  the name of the related FileObject.  Then we will append this
        //  fileObject's name.
        //
        //  Note: 
        //  The name in FileObject and FileObject->RelatedFileObject are accessible.  Names further up
        //  the related file object chain (ie FileObject->RelatedFileObject->RelatedFileObject)
        //  may not be accessible.  This is the reason we use ObQueryNameString
        //  to get the name for the RelatedFileObject.
        //

        CHAR buffer [(MAX_PATH * sizeof( WCHAR )) + sizeof( ULONG )];
        PFILE_NAME_INFORMATION relativeNameInfo = (PFILE_NAME_INFORMATION) buffer;
        NTSTATUS status;
        ULONG returnLength;

        status = IoTestQueryFileSystemForFileName( FileObject->RelatedFileObject,
                                                DeviceExtension->AttachedToDeviceObject,
                                                sizeof( buffer ),
                                                relativeNameInfo,
                                                &returnLength );

        if (NT_SUCCESS( status ) &&
            ((FileName->Length + relativeNameInfo->FileNameLength + FileObject->FileName.Length + sizeof( L'\\' ))
             <= FileName->MaximumLength)) {

            //
            //  We were able to get the relative fileobject's name and we have
            //  enough room in the FileName buffer, so build up the file name
            //  in the following format:
            //      [volumeName]\[relativeFileObjectName]\[FileObjectName]
            //  The VolumeName is already in FileName if we've got one.
            //

            RtlCopyMemory( &FileName->Buffer[FileName->Length/sizeof(WCHAR)],
                           relativeNameInfo->FileName,
                           relativeNameInfo->FileNameLength );
            FileName->Length += (USHORT)relativeNameInfo->FileNameLength;

        } else if ((FileName->Length + FileObject->FileName.Length + sizeof(L"...\\")) <=
                   FileName->MaximumLength ) {

            //
            //  Either the query for the relative fileObject name was unsuccessful,
            //  or we don't have enough room for the relativeFileObject name, but we
            //  do have enough room for "...\[fileObjectName]" in FileName.
            //

            status = RtlAppendUnicodeToString( FileName, L"...\\" );
            ASSERT( status == STATUS_SUCCESS );
        }

        //
        //  At this time, copy over the FileObject->FileName to the FileName
        //  unicode string.  If we get a failure return FALSE from this routine.
        //

        status = RtlAppendUnicodeStringToString( FileName, &(FileObject->FileName) );

        if (!NT_SUCCESS( status )) {

            //
            //  We should have had enough space to copy the FileObject->FileName,
            //  so there must be something wrong with FileName now, so return
            //  FALSE so that the data in FileName will not get copied into
            //  the log record.
            //

            return FALSE;
        }

        return TRUE;
    }
    
    //
    //  CASE 4: We have a open on a file with an absolute path.
    //
    
    else if (FlagOn( LookupFlags, NAMELOOKUPFL_IN_CREATE ) &&
             (FileObject->RelatedFileObject == NULL) ) {

        // 
        //  We have an absolute path, so try to copy that into FileName.
        //

        status = RtlAppendUnicodeStringToString( FileName, &(FileObject->FileName) );

        if (!NT_SUCCESS( status )) {

            //
            //  We don't have enough room for the file name, so copy our
            //  EXCEED_NAME_BUFFER error message.
            //

            RtlAppendUnicodeToString( FileName, IOTEST_EXCEED_NAME_BUFFER_MESSAGE );
        }
        
        return TRUE;
    }

    //
    //  CASE 5: We are retrieving the file name sometime after the
    //  CREATE operation.
    //

    else if(!FlagOn( LookupFlags, NAMELOOKUPFL_IN_CREATE )) {

        CHAR buffer [(MAX_PATH * sizeof( WCHAR )) + sizeof( ULONG )];
        PFILE_NAME_INFORMATION nameInfo = (PFILE_NAME_INFORMATION) buffer;
        NTSTATUS status;
        ULONG returnLength;

        status = IoTestQueryFileSystemForFileName( FileObject,
                                                DeviceExtension->AttachedToDeviceObject,
                                                sizeof( buffer ),
                                                nameInfo,
                                                &returnLength );

        if (NT_SUCCESS( status )) {

            if ((FileName->Length + nameInfo->FileNameLength) <= FileName->MaximumLength) {

                //
                //  We've got enough room for the file name, so copy it into
                //  FileName.
                //

                RtlCopyMemory( &FileName->Buffer[FileName->Length/sizeof(WCHAR)],
                               nameInfo->FileName,
                               nameInfo->FileNameLength );
                FileName->Length += (USHORT)nameInfo->FileNameLength;
                               
            } else {

                //
                //  We don't have enough room for the file name, so copy our
                //  EXCEED_NAME_BUFFER error message.
                //

                RtlAppendUnicodeToString( FileName, IOTEST_EXCEED_NAME_BUFFER_MESSAGE );
            }
            
        } else {

            //
            //  Got an error trying to get the file name from the base file system,
            //  so put that error message into FileName.
            //

            RtlAppendUnicodeToString( FileName, IOTEST_ERROR_RETRIEVING_NAME_MESSAGE );
        }
        
        return TRUE;
    }

    //
    //  Shouldn't get here -- we didn't fall into one of the
    //  above legitimate cases, so ASSERT and return FALSE.
    //

    ASSERT( FALSE );

    return FALSE;
}

NTSTATUS
IoTestQueryFileSystemForFileName (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT NextDeviceObject,
    IN ULONG FileNameInfoLength,
    OUT PFILE_NAME_INFORMATION FileNameInfo,
    OUT PULONG ReturnedLength
    )
/*++

Routine Description:

    This routine rolls an irp to query the name of the
    FileObject parameter from the base file system.

    Note:  ObQueryNameString CANNOT be used here because it
      would cause recursive lookup of the file name for FileObject.
      
Arguments:

    FileObject - the file object for which we want the name.
    NextDeviceObject - the device object for the next driver in the
        stack.  This is where we want to start our request
        for the name of FileObject.
    FileNameInfoLength - the length in bytes of FileNameInfo
        parameter.
    FileNameInfo - the buffer that will be receive the name
        information.  This must be memory that safe to write
        to from kernel space.
    ReturnedLength - the number of bytes written to FileNameInfo.
    
Return Value:

    Returns the status of the operation.
    
--*/
{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    KEVENT event;
    IO_STATUS_BLOCK ioStatus;
    NTSTATUS status;

    KeInitializeEvent( &event, SynchronizationEvent, FALSE );
    ioStatus.Status = STATUS_SUCCESS;
    ioStatus.Information = 0;

    irp = IoAllocateIrp( NextDeviceObject->StackSize, FALSE );
    
    if (irp == NULL) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    //  We don't need to take a reference on the FileObject
    //  here because we are going to perform our IO request
    //  synchronously and the current operation already
    //  has a reference for the FileObject.
    //
    
    irp->Tail.Overlay.OriginalFileObject = FileObject;

    //
    //  Set our current thread as the thread for this
    //  irp so that the IO Manager always knows which
    //  thread to return to if it needs to get back into
    //  the context of the thread that originated this
    //  irp.
    //
    
    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    //  Set that this irp originated from the kernel so that
    //  the IO Manager knows that the buffers do not
    //  need to be probed.
    //
    
    irp->RequestorMode = KernelMode;

    //
    //  Initialize the UserIosb and UserEvent in the 
    irp->UserIosb = &ioStatus;
    irp->UserEvent = NULL;

    //
    //  Set the IRP_SYNCHRONOUS_API to denote that this
    //  is a synchronous IO request.
    //

    irp->Flags = IRP_SYNCHRONOUS_API;
    irp->Overlay.AsynchronousParameters.UserApcRoutine = NULL;
    irp->Overlay.AsynchronousParameters.UserApcContext = NULL;

    irpSp = IoGetNextIrpStackLocation( irp );

    irpSp->MajorFunction = IRP_MJ_QUERY_INFORMATION;
    irpSp->FileObject = FileObject;

    //
    //  Setup the parameters for IRP_MJ_QUERY_INFORMATION.
    //  The buffer we want to be filled in should be placed in
    //  the system buffer.
    //

    irp->AssociatedIrp.SystemBuffer = FileNameInfo;

    irpSp->Parameters.QueryFile.Length = FileNameInfoLength;
    irpSp->Parameters.QueryFile.FileInformationClass = FileNameInformation;

    //
    //  Set up the completion routine so that we know when our
    //  request for the file name is completed.  At that time,
    //  we can free the irp.
    //
    
    IoSetCompletionRoutine( irp, 
                            IoTestQueryFileSystemForNameCompletion, 
                            &event, 
                            TRUE, 
                            TRUE, 
                            TRUE );

    status = IoCallDriver( NextDeviceObject, irp );

    IOTEST_DBG_PRINT1( IOTESTDEBUG_TRACE_NAME_REQUESTS,
                        "IOTEST (IoTestQueryFileSystemForFileName): Issued name request -- IoCallDriver status: 0x%08x\n",
                        status );

    (VOID) KeWaitForSingleObject( &event, 
                                  Executive, 
                                  KernelMode,
                                  FALSE,
                                  NULL );
    status = ioStatus.Status;

    IOTEST_DBG_PRINT0( IOTESTDEBUG_TRACE_NAME_REQUESTS,
                        "IOTEST (IoTestQueryFileSystemForFileName): Finished waiting for name request to complete...\n" );

    *ReturnedLength = (ULONG) ioStatus.Information;
    return status;
}

NTSTATUS
IoTestQueryFileSystemForNameCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT SynchronizingEvent
    )
/*++

Routine Description:

    This routine does the cleanup necessary once the request
    for a file name is completed by the file system.
    
Arguments:

    DeviceObject - This will be NULL since we originated this
        Irp.

    Irp - The io request structure containing the information
        about the current state of our file name query.

    SynchronizingEvent - The event to signal to notify the 
        originator of this request that the operation is
        complete.

Return Value:

    Returns STATUS_MORE_PROCESSING_REQUIRED so that IO Manager
    will not try to free the Irp again.

--*/
{

    UNREFERENCED_PARAMETER( DeviceObject );
    
    //
    //  Make sure that the Irp status is copied over to the user's
    //  IO_STATUS_BLOCK so that the originator of this irp will know
    //  the final status of this operation.
    //

    ASSERT( NULL != Irp->UserIosb );
    *Irp->UserIosb = Irp->IoStatus;

    //
    //  Signal SynchronizingEvent so that the originator of this
    //  Irp know that the operation is completed.
    //

    KeSetEvent( SynchronizingEvent, IO_NO_INCREMENT, FALSE );

    //
    //  We are now done, so clean up the irp that we allocated.
    //

    IoFreeIrp( Irp );

    //
    //  If we return STATUS_SUCCESS here, the IO Manager will
    //  perform the cleanup work that it thinks needs to be done
    //  for this IO operation.  This cleanup work includes:
    //  * Copying data from the system buffer to the user's buffer 
    //    if this was a buffered IO operation.
    //  * Freeing any MDLs that are in the Irp.
    //  * Copying the Irp->IoStatus to Irp->UserIosb so that the
    //    originator of this irp can see the final status of the
    //    operation.
    //  * If this was an asynchronous request or this was a 
    //    synchronous request that got pending somewhere along the
    //    way, the IO Manager will signal the Irp->UserEvent, if one 
    //    exists, otherwise it will signal the FileObject->Event.
    //    (This can have REALLY bad implications if the irp originator
    //     did not an Irp->UserEvent and the irp originator is not
    //     waiting on the FileObject->Event.  It would not be that
    //     farfetched to believe that someone else in the system is
    //     waiting on FileObject->Event and who knows who will be
    //     awoken as a result of the IO Manager signaling this event.
    //
    //  Since some of these operations require the originating thread's
    //  context (e.g., the IO Manager need the UserBuffer address to 
    //  be valid when copy is done), the IO Manager queues this work
    //  to an APC on the Irp's orginating thread.
    //
    //  Since IoTest allocated and initialized this irp, we know
    //  what cleanup work needs to be done.  We can do this cleanup
    //  work more efficiently than the IO Manager since we are handling
    //  a very specific case.  Therefore, it is better for us to
    //  perform the cleanup work here then free the irp than passing
    //  control back to the IO Manager to do this work.
    //
    //  By returning STATUS_MORE_PROCESS_REQUIRED, we tell the IO Manager 
    //  to stop processing this irp until it is told to restart processing
    //  with a call to IoCompleteRequest.  Since the IO Manager has
    //  already performed all the work we want it to do on this
    //  irp, we do the cleanup work, return STATUS_MORE_PROCESSING_REQUIRED,
    //  and ask the IO Manager to resume processing by calling 
    //  IoCompleteRequest.
    //

    return STATUS_MORE_PROCESSING_REQUIRED;
}

////////////////////////////////////////////////////////////////////////
//                                                                    //
//         Common attachment and detachment routines                  //
//                                                                    //
////////////////////////////////////////////////////////////////////////

BOOLEAN
IoTestIsAttachedToDevice (
    IOTEST_DEVICE_TYPE DeviceType,
    PDEVICE_OBJECT DeviceObject,
    PDEVICE_OBJECT *AttachedDeviceObject OPTIONAL
    )
/*++

Routine Description:

    This walks down the attachment chain looking for a device object that
    belongs to this driver.  If one is found, the attached device object
    is returned in AttachedDeviceObject.

    Note:  If AttachedDeviceObject is returned with a non-NULL value,
           there is a reference on the AttachedDeviceObject that must
           be cleared by the caller.

Arguments:

    DeviceObject - The device chain we want to look through

    AttachedDeviceObject - Set to the deviceObject which IoTest
        has previously attached to DeviceObject.

Return Value:

    TRUE if we are attached, FALSE if not

--*/
{
    PDEVICE_OBJECT currentDevObj;
    PDEVICE_OBJECT nextDevObj;
    PIOTEST_DEVICE_EXTENSION currentDevExt;

    currentDevObj = IoGetAttachedDeviceReference( DeviceObject );
    ASSERT( currentDevObj != NULL );

    //
    //  CurrentDevObj has the top of the attachment chain.  Scan
    //  down the list to find our device object.

    do {

        currentDevExt = currentDevObj->DeviceExtension;
        
        if (IS_IOTEST_DEVICE_OBJECT( currentDevObj ) &&
            currentDevExt->Type == DeviceType) {

            //
            //  We have found that we are already attached.  If we are
            //  returning the device object we are attached to then leave the
            //  refrence on it.  If not then remove the refrence.
            //

            if (NULL != AttachedDeviceObject) {

                *AttachedDeviceObject = currentDevObj;

            } else {

                ObDereferenceObject( currentDevObj );
            }

            return TRUE;
        }

        //
        //  Get the next attached object.  This puts a reference on 
        //  the device object.
        //

        nextDevObj = IoGetLowerDeviceObject( currentDevObj );

        //
        //  Dereference our current device object, before
        //  moving to the next one.
        //

        ObDereferenceObject( currentDevObj );

        currentDevObj = nextDevObj;
        
    } while (NULL != currentDevObj);
    
    return FALSE;
}

NTSTATUS
IoTestAttachToMountedDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_OBJECT IoTestDeviceObject,
    IN PDEVICE_OBJECT DiskDeviceObject,
    IN IOTEST_DEVICE_TYPE DeviceType
    )
/*++

Routine Description:

    This routine will attach the IoTestDeviceObject to the filter stack
    that DeviceObject is in.

    NOTE:  If there is an error in attaching, the caller is responsible
        for deleting the IoTestDeviceObject.
    
Arguments:

    DeviceObject - A device object in the stack to which we want to attach.

    IoTestDeviceObject - The filespy device object that has been created
        to attach to this filter stack.

    DiskDeviceObject - The device object the disk with which this file system
        filter stack is associated.

    DeviceType - The IoTest device type for the device being attached
        to the mounted volume.
            
Return Value:

    Returns STATUS_SUCCESS if the filespy deviceObject could be attached,
    otherwise an appropriate error code is returned.
    
--*/
{
    PIOTEST_DEVICE_EXTENSION devext;
    NTSTATUS status = STATUS_SUCCESS;

    ASSERT( IS_IOTEST_DEVICE_OBJECT( IoTestDeviceObject ) );
    ASSERT( !IoTestIsAttachedToDevice ( DeviceType, DeviceObject, NULL ) );
    
    devext = IoTestDeviceObject->DeviceExtension;

    devext->AttachedToDeviceObject = IoAttachDeviceToDeviceStack( IoTestDeviceObject,
                                                                  DeviceObject );

    if (devext->AttachedToDeviceObject == NULL ) {

        status = STATUS_INSUFFICIENT_RESOURCES;

    } else {

        //
        //  Do all common initializing of the device extension
        //

        devext->Type = DeviceType;

        //
        //  We just want to attach to the device, but not actually
        //  start logging.
        //
        
        devext->LogThisDevice = FALSE;

        RtlInitEmptyUnicodeString( &(devext->DeviceNames), 
                                   devext->DeviceNamesBuffer, 
                                   sizeof( devext->DeviceNamesBuffer ) );
        RtlInitEmptyUnicodeString( &(devext->UserNames),
                                   devext->UserNamesBuffer,
                                   sizeof( devext->UserNamesBuffer ) );

        //
        //  Store off the DiskDeviceObject.  We shouldn't need it
        //  later since we have already successfully attached to the
        //  filter stack, but it may be helpful for debugging.
        //  
        
        devext->DiskDeviceObject = DiskDeviceObject;                         

        //
        //  Try to get the device name so that we can store it in the
        //  device extension.
        //

        IoTestCacheDeviceName( IoTestDeviceObject );

        if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_DISPLAY_ATTACHMENT_NAMES )) {

            switch ( devext->Type ) {
            case TOP_FILTER:
                DbgPrint( "IOTEST (IoTestAttachToMountedDevice): Attaching TOP_FILTER to volume %p       \"%wZ\"\n", 
                          devext->AttachedToDeviceObject,
                          &devext->DeviceNames);
                break;

            case BOTTOM_FILTER:
                DbgPrint( "IOTEST (IoTestAttachToMountedDevice): Attaching BOTTOM_FILTER to volume %p     \"%wZ\"\n", 
                          devext->AttachedToDeviceObject,
                          &devext->DeviceNames );
                break;
                
            default:
                DbgPrint( "IOTEST (IoTestAttachToMountedDevice): Attaching UNKNOWN FILTER TYPE to volume %p \"%wZ\"\n", 
                          devext->AttachedToDeviceObject,
                          &devext->DeviceNames );
                
            }
        }

        //
        //  Set our deviceObject flags based on the 
        //   flags send in the next driver's device object.
        //
        
        if (FlagOn( DeviceObject->Flags, DO_BUFFERED_IO )) {

            SetFlag( IoTestDeviceObject->Flags, DO_BUFFERED_IO );
        }

        if (FlagOn( DeviceObject->Flags, DO_DIRECT_IO )) {

            SetFlag( IoTestDeviceObject->Flags, DO_DIRECT_IO );
        }

        //
        //  Add this device to our attachment list
        //

        devext->IsVolumeDeviceObject = TRUE;

        ExAcquireFastMutex( &gIoTestDeviceExtensionListLock );
        InsertTailList( &gIoTestDeviceExtensionList, &devext->NextIoTestDeviceLink );
        ExReleaseFastMutex( &gIoTestDeviceExtensionListLock );

        ClearFlag( IoTestDeviceObject->Flags, DO_DEVICE_INITIALIZING );
    }

    return status;
}


VOID
IoTestCleanupMountedDevice (
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This cleans up any allocated memory in the device extension.

Arguments:

    DeviceObject - The device we are cleaning up

Return Value:

--*/
{        
    PIOTEST_DEVICE_EXTENSION devext = DeviceObject->DeviceExtension;

    ASSERT(IS_IOTEST_DEVICE_OBJECT( DeviceObject ));

    //
    //  Unlink from global list
    //

    if (devext->IsVolumeDeviceObject) {

        ExAcquireFastMutex( &gIoTestDeviceExtensionListLock );
        RemoveEntryList( &devext->NextIoTestDeviceLink );
        ExReleaseFastMutex( &gIoTestDeviceExtensionListLock );
        devext->IsVolumeDeviceObject = FALSE;
    }
}


////////////////////////////////////////////////////////////////////////
//                                                                    //
//           Helper routine for turning on/off logging on demand      //
//                                                                    //
////////////////////////////////////////////////////////////////////////

NTSTATUS
IoTestGetDeviceObjectFromName (
    IN PUNICODE_STRING DeviceName,
    OUT PDEVICE_OBJECT *DeviceObject
    )
/*++

Routine Description:

    This routine
    
Arguments:

    DeviceName - Name of device for which we want the deviceObject.
    DeviceObject - Set to the DeviceObject for this device name if
        we can successfully retrieve it.

    Note:  If the DeviceObject is returned, it is returned with a
        reference that must be cleared by the caller once the caller
        is finished with it.

Return Value:

    STATUS_SUCCESS if the deviceObject was retrieved from the
    name, and an error code otherwise.
    
--*/
{
    WCHAR nameBuf[DEVICE_NAMES_SZ];
    UNICODE_STRING volumeNameUnicodeString;
    NTSTATUS status;
    OBJECT_ATTRIBUTES objectAttributes;
    IO_STATUS_BLOCK openStatus;
    PFILE_OBJECT volumeFileObject;
    HANDLE fileHandle;
    PDEVICE_OBJECT nextDeviceObject;

    RtlInitEmptyUnicodeString( &volumeNameUnicodeString, nameBuf, sizeof( nameBuf ) );
    RtlAppendUnicodeToString( &volumeNameUnicodeString, L"\\DosDevices\\" );
    RtlAppendUnicodeStringToString( &volumeNameUnicodeString, DeviceName );

    InitializeObjectAttributes( &objectAttributes,
								&volumeNameUnicodeString,
								OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
								NULL,
								NULL);

    //
	// open the file object for the given device
	//

    status = ZwCreateFile( &fileHandle,
						   SYNCHRONIZE|FILE_READ_DATA,
						   &objectAttributes,
						   &openStatus,
						   NULL,
						   0,
						   FILE_SHARE_READ|FILE_SHARE_WRITE,
						   FILE_OPEN,
						   FILE_SYNCHRONOUS_IO_NONALERT,
						   NULL,
						   0);

    if(!NT_SUCCESS( status )) {

        return status;
    }

	//
    // get a pointer to the volumes file object
	//

    status = ObReferenceObjectByHandle( fileHandle,
										FILE_READ_DATA,
										*IoFileObjectType,
										KernelMode,
										&volumeFileObject,
										NULL);

    if(!NT_SUCCESS( status )) {

        ZwClose( fileHandle );
        return status;
    }

	//
    // Get the device object we want to attach to (parent device object in chain)
	//

    nextDeviceObject = IoGetRelatedDeviceObject( volumeFileObject );
    
    if (nextDeviceObject == NULL) {

        ObDereferenceObject( volumeFileObject );
        ZwClose( fileHandle );

        return status;
    }

    ObDereferenceObject( volumeFileObject );
    ZwClose( fileHandle );

    ASSERT( NULL != DeviceObject );

    ObReferenceObject( nextDeviceObject );
    
    *DeviceObject = nextDeviceObject;

    return STATUS_SUCCESS;
}

////////////////////////////////////////////////////////////////////////
//                                                                    //
//                    Start/stop logging routines                     //
//                                                                    //
////////////////////////////////////////////////////////////////////////

NTSTATUS
IoTestStartLoggingDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN PWSTR UserDeviceName
    )
/*++

Routine Description:

    This routine ensures that we are attached to the specified device
    then turns on logging for that device.
    
    Note:  Since all network drives through LAN Manager are represented by _
        one_ device object, we want to only attach to this device stack once
        and use only one device extension to represent all these drives.
        Since IoTest does not do anything to filter I/O on the LAN Manager's
        device object to only log the I/O to the requested drive, the user
        will see all I/O to a network drive it he/she is attached to a
        network drive.

Arguments:

    DeviceObject - Device object for IOTEST driver

    UserDeviceName - Name of device for which logging should be started
    
Return Value:

    STATUS_SUCCESS if the logging has been successfully started, or
    an appropriate error code if the logging could not be started.
    
--*/
{
    UNICODE_STRING userDeviceName;
    NTSTATUS status;
    PIOTEST_DEVICE_EXTENSION devext;
    PDEVICE_OBJECT nextDeviceObject;
    PDEVICE_OBJECT diskDeviceObject;
    MINI_DEVICE_STACK ioTestDevObjects;

    UNREFERENCED_PARAMETER( DeviceObject );
    
    //
    //  Check to see if we have previously attached to this device by
    //  opening this device name then looking through its list of attached
    //  devices.
    //

    RtlInitUnicodeString( &userDeviceName, UserDeviceName );

    status = IoTestGetDeviceObjectFromName( &userDeviceName, &nextDeviceObject );

    if (!NT_SUCCESS( status )) {

        //
        //  There was an error, so return the error code.
        //
        
        return status;
    }

    if (IoTestIsAttachedToDevice( TOP_FILTER, nextDeviceObject, &(ioTestDevObjects.Top))) {

        //
        //  We are already attached, so just make sure that logging is turned on
        //  for both the top and bottom IoTest device in this stack.
        //

        ASSERT( NULL != ioTestDevObjects.Top );

        devext = ioTestDevObjects.Top->DeviceExtension;
        devext->LogThisDevice = TRUE;

        IoTestStoreUserName( devext, &userDeviceName );

        //
        //  We don't need to take a reference on the Bottom device object
        //  here because our reference on Top is protecting Bottom from
        //  going away.
        //
        
        ioTestDevObjects.Bottom = devext->AttachedToDeviceObject;
        
        devext = ioTestDevObjects.Bottom->DeviceExtension;
        devext->LogThisDevice = TRUE;
        IoTestStoreUserName( devext, &userDeviceName );

        //
        //  Clear the reference that was returned from IoTestIsAttachedToDevice.
        //
        
        ObDereferenceObject( ioTestDevObjects.Top );
        
    } else {

        //
        //  We are not already attached, so create the IoTest device objects and
        //  attach it to this device object.
        //

        //
        //  Get the disk device object associated with this
        //  file  system device object.  Only try to attach if we
        //  have a disk device object.  If the device does not
        //  have a disk device object, it is a control device object
        //  for a driver and we don't want to attach to those
        //  device objects.
        //

        status = IoGetDiskDeviceObject( nextDeviceObject, &diskDeviceObject );

        if (!NT_SUCCESS( status )) {

            IOTEST_DBG_PRINT1( IOTESTDEBUG_ERROR,
                                "IOTEST (IoTestStartLoggingDevice): No disk device object exists for \"%wZ\"; cannot log this volume.\n",
                                &userDeviceName );
            ObDereferenceObject( nextDeviceObject );
            return status;
        }
        //
        //  Create the new IoTest device objects so we can attach it in the filter stack
        //

        status = IoTestCreateDeviceObjects(nextDeviceObject, 
                                           diskDeviceObject,
                                           &ioTestDevObjects);
        
        if (!NT_SUCCESS( status )) {

            ObDereferenceObject( diskDeviceObject );
            ObDereferenceObject( nextDeviceObject );
            return status;
        }
        
        //
        //  Call the routine to attach to a mounted device.
        //

        status = IoTestAttachDeviceObjects( &ioTestDevObjects,
                                            nextDeviceObject, 
                                            diskDeviceObject );
        
        //
        //  Clear the reference on diskDeviceObject that was
        //  added by IoGetDiskDeviceObject.
        //

        ObDereferenceObject( diskDeviceObject );

        if (!NT_SUCCESS( status )) {

            IOTEST_DBG_PRINT1( IOTESTDEBUG_ERROR,
                                "IOTEST (IoTestStartLoggingDevice): Could not attach to \"%wZ\"; logging not started.\n",
                                &userDeviceName );

            IoTestCleanupDeviceObjects( &ioTestDevObjects );
            ObDereferenceObject( nextDeviceObject );
            return status;
        }

        //
        //  We successfully attached so do any more device extension 
        //  initialization we need.  Along this code path, we want to
        //  turn on logging and store our device name for both the top and
        //  bottom device objects.
        // 

        devext = ioTestDevObjects.Top->DeviceExtension;
        devext->LogThisDevice = TRUE;
        IoTestStoreUserName( devext, &userDeviceName );

        devext = ioTestDevObjects.Bottom->DeviceExtension;
        devext->LogThisDevice = TRUE;
        IoTestStoreUserName( devext, &userDeviceName );
    }

    ObDereferenceObject( nextDeviceObject );
    return STATUS_SUCCESS;
}

NTSTATUS
IoTestStopLoggingDevice (
    IN PWSTR DeviceName
    )
/*++

Routine Description:

    This routine stop logging the specified device.  Since you can not
    physically detach from devices, this routine simply sets a flag saying
    to not log the device anymore.

    Note:  Since all network drives are represented by _one_ device object,
        and, therefore, one device extension, if the user detaches from one
        network drive, it has the affect of detaching from _all_ network
        devices.

Arguments:

    DeviceName - The name of the device to stop logging.

Return Value:
    NT Status code

--*/
{
    WCHAR nameBuf[DEVICE_NAMES_SZ];
    UNICODE_STRING volumeNameUnicodeString;
    PDEVICE_OBJECT deviceObject;
    MINI_DEVICE_STACK ioTestDevObjects;
    PIOTEST_DEVICE_EXTENSION devext;
    NTSTATUS status;
    
    RtlInitEmptyUnicodeString( &volumeNameUnicodeString, nameBuf, sizeof( nameBuf ) );
    RtlAppendUnicodeToString( &volumeNameUnicodeString, DeviceName );

    status = IoTestGetDeviceObjectFromName( &volumeNameUnicodeString, &deviceObject );

    if (!NT_SUCCESS( status )) {

        //
        //  We could not get the deviceObject from this DeviceName, so
        //  return the error code.
        //
        
        return status;
    }

    //
    //  Find IoTest's device object from the device stack to which
    //  deviceObject is attached.
    //

    if (IoTestIsAttachedToDevice( TOP_FILTER, deviceObject, &(ioTestDevObjects.Top) )) {

        //
        //  IoTest is attached and IoTest's deviceObject was returned.
        //

        ASSERT( NULL != ioTestDevObjects.Top );

        devext = ioTestDevObjects.Top->DeviceExtension;
        devext->LogThisDevice = FALSE;

        ioTestDevObjects.Bottom = devext->AttachedToDeviceObject;
        
        devext = ioTestDevObjects.Bottom->DeviceExtension;
        devext->LogThisDevice = FALSE;

        status = STATUS_SUCCESS;

    } else {

        status = STATUS_INVALID_PARAMETER;
    }    

    ObDereferenceObject( deviceObject );
    ObDereferenceObject( ioTestDevObjects.Bottom );

    return status;
}

////////////////////////////////////////////////////////////////////////
//                                                                    //
//       Attaching/detaching to all volumes in system routines        //
//                                                                    //
////////////////////////////////////////////////////////////////////////

NTSTATUS
IoTestCreateDeviceObjects (
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_OBJECT RealDeviceObject OPTIONAL,
    IN OUT PMINI_DEVICE_STACK IoTestDevObjects
    )
{
    NTSTATUS status;
    PIOTEST_DEVICE_EXTENSION newDevExt;
    
    ASSERT( IoTestDevObjects != NULL );

    //
    //  Create BOTTOM_FILTER and initialize its device extension.
    //
    
    status = IoCreateDevice( gIoTestDriverObject,
                             sizeof( IOTEST_DEVICE_EXTENSION ),
                             NULL,
                             DeviceObject->DeviceType,
                             0,
                             FALSE,
                             &(IoTestDevObjects->Bottom) );

    if (!NT_SUCCESS( status )) {
#if DBG
        DbgPrint( "IOTEST: Error creating BOTTOM volume device object, status=%08x\n", status );
#endif

        goto IoTestCreateDeviceObjects_Exit;
    }

    //
    //  We need to save the RealDevice object pointed to by the vpb
    //  parameter because this vpb may be changed by the underlying
    //  file system.  Both FAT and CDFS may change the VPB address if
    //  the volume being mounted is one they recognize from a previous
    //  mount.
    //
    //  We store it in the device extension instead of just in the mount
    //  completion context because it is useful to keep around for 
    //  debugging purposes.
    //

    newDevExt = (IoTestDevObjects->Bottom)->DeviceExtension;
    newDevExt->Type = BOTTOM_FILTER;
    newDevExt->DiskDeviceObject = RealDeviceObject;

    //
    //  Create TOP_FILTER and initialize its device extension.
    //
    
    status = IoCreateDevice( gIoTestDriverObject,
                             sizeof( IOTEST_DEVICE_EXTENSION ),
                             NULL,
                             DeviceObject->DeviceType,
                             0,
                             FALSE,
                             &(IoTestDevObjects->Top) );

    if (!NT_SUCCESS( status )) {
#if DBG
        DbgPrint( "IOTEST: Error creating TOP volume device object, status=%08x\n", status );
#endif

        goto IoTestCreateDeviceObjects_Exit;
    }

    newDevExt = (IoTestDevObjects->Bottom)->DeviceExtension;
    newDevExt->Type = TOP_FILTER;
    newDevExt->DiskDeviceObject = RealDeviceObject;

IoTestCreateDeviceObjects_Exit:

    return status;
}

NTSTATUS
IoTestAttachDeviceObjects (
    IN PMINI_DEVICE_STACK IoTestDevObjects,
    IN PDEVICE_OBJECT MountedDevice,
    IN PDEVICE_OBJECT DiskDevice
    )
{
    NTSTATUS status;
    PIOTEST_DEVICE_EXTENSION devExt;

    status = IoTestAttachToMountedDevice( MountedDevice,
                                          IoTestDevObjects->Bottom, 
                                          DiskDevice,
                                          BOTTOM_FILTER );
    if (!NT_SUCCESS( status )) {

#if DBG
        DbgPrint( "IOTEST: Error attaching BOTTOM volume device object, status=%08x\n", status );
#endif

        //
        //  Neither the top or bottom device objects are attached yet, so just
        //  cleanup both device objects.
        //
        IoTestCleanupDeviceObjects( IoTestDevObjects );

        goto IoTestAttachDeviceObjects_Exit;
    }

    status = IoTestAttachToMountedDevice( MountedDevice,
                                          IoTestDevObjects->Top, 
                                          DiskDevice,
                                          TOP_FILTER );
    if (!NT_SUCCESS( status )) {

#if DBG
        DbgPrint( "IOTEST: Error attaching TOP volume device object, status=%08x\n", status );
#endif

        //
        //  Detach the bottom filter since we can't attach both the bottom
        //  and top filters.
        //
        devExt = IoTestDevObjects->Bottom->DeviceExtension;
        IoDetachDevice( devExt->AttachedToDeviceObject );

        //
        //  Then cleanup both our top and bottom device objects.
        //
        IoTestCleanupDeviceObjects( IoTestDevObjects );
        
        goto IoTestAttachDeviceObjects_Exit;
    }

IoTestAttachDeviceObjects_Exit:

    return status;
}

VOID
IoTestCleanupDeviceObjects (
    IN PMINI_DEVICE_STACK IoTestDevObjects
    )
{
    IoTestCleanupMountedDevice( IoTestDevObjects->Top );
    IoDeleteDevice( IoTestDevObjects->Top );
    IoTestCleanupMountedDevice( IoTestDevObjects->Bottom );
    IoDeleteDevice( IoTestDevObjects->Bottom );

    IoTestDevObjects->Top = NULL;
    IoTestDevObjects->Bottom = NULL;
}
NTSTATUS
IoTestAttachToFileSystemDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PUNICODE_STRING Name
    )
/*++

Routine Description:

    This will attach to the given file system device object.  We attach to
    these devices so we will know when new devices are mounted.

Arguments:

    DeviceObject - The device to attach to

    Name - An already initialized unicode string used to retrieve names.
        NOTE:  The only reason this parameter is passed in is to conserve         
        stack space.  In most cases, the caller to this function has already
        allocated a buffer to temporarily store the device name and there
        is no reason this function and the functions it calls can't share
        the same buffer.

Return Value:

    Status of the operation

--*/
{
    PDEVICE_OBJECT filespyDeviceObject;
    PDEVICE_OBJECT attachedToDevObj;
    PIOTEST_DEVICE_EXTENSION devExt;
    UNICODE_STRING fsrecName;
    NTSTATUS status;

    PAGED_CODE();

    //
    //  See if this is a file system we care about.  If not, return.
    //

    if (!IS_DESIRED_DEVICE_TYPE(DeviceObject->DeviceType)) {

        return STATUS_SUCCESS;
    }

    //
    //  See if this is Microsoft's file system recognizer device (see if the name of the
    //  driver is the FS_REC driver).  If so skip it.  We don't need to 
    //  attach to file system recognizer devices since we can just wait for the
    //  real file system driver to load.  Therefore, if we can identify them, we won't
    //  attach to them.
    //

    RtlInitUnicodeString( &fsrecName, L"\\FileSystem\\Fs_Rec" );
    IoTestGetObjectName( DeviceObject->DriverObject, Name );
    
    if (RtlCompareUnicodeString( Name, &fsrecName, TRUE ) == 0) {

        return STATUS_SUCCESS;
    }

    //
    //  Create a new device object we can attach with
    //

    status = IoCreateDevice( gIoTestDriverObject,
                             sizeof( IOTEST_DEVICE_EXTENSION ),
                             (PUNICODE_STRING) NULL,
                             DeviceObject->DeviceType,
                             0,
                             FALSE,
                             &filespyDeviceObject );

    if (!NT_SUCCESS( status )) {

        IOTEST_DBG_PRINT0( IOTESTDEBUG_ERROR,
                            "IOTEST (IoTestAttachToFileSystem): Could not create a IoTest device object to attach to the filesystem.\n" );
        return status;
    }

    //
    //  Do the attachment
    //

    attachedToDevObj = IoAttachDeviceToDeviceStack( filespyDeviceObject, DeviceObject );

    if (attachedToDevObj == NULL) {

        IOTEST_DBG_PRINT0( IOTESTDEBUG_ERROR,
                            "IOTEST (IoTestAttachToFileSystem): Could not attach IoTest to the filesystem control device object.\n" );
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto ErrorCleanupDevice;
    }

    //
    //  Finish initializing our device extension
    //

    devExt = filespyDeviceObject->DeviceExtension;
    devExt->AttachedToDeviceObject = attachedToDevObj;

    //
    //  Propagate flags from Device Object we attached to
    //

    if ( FlagOn( attachedToDevObj->Flags, DO_BUFFERED_IO )) {

        SetFlag( filespyDeviceObject->Flags, DO_BUFFERED_IO );
    }

    if ( FlagOn( attachedToDevObj->Flags, DO_DIRECT_IO )) {

        SetFlag( filespyDeviceObject->Flags, DO_DIRECT_IO );
    }

    //
    //  Since this is an attachment to a file system control device object
    //  we are not going to log anything, but properly initialize our
    //  extension.
    //

    devExt->LogThisDevice = FALSE;
    devExt->IsVolumeDeviceObject = FALSE;

    RtlInitEmptyUnicodeString( &(devExt->DeviceNames),
                               devExt->DeviceNamesBuffer,
                               sizeof( devExt->DeviceNamesBuffer ) );
                               
    RtlInitEmptyUnicodeString( &(devExt->UserNames),
                               devExt->UserNamesBuffer,
                               sizeof( devExt->UserNamesBuffer ) );
                               
    ClearFlag( filespyDeviceObject->Flags, DO_DEVICE_INITIALIZING );

    //
    //  Display who we have attached to
    //

    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_DISPLAY_ATTACHMENT_NAMES )) {

        IoTestCacheDeviceName( filespyDeviceObject );
        DbgPrint( "IOTEST (IoTestAttachToFileSystem): Attaching to file system   \"%wZ\" (%s)\n",
                  &devExt->DeviceNames,
                  GET_DEVICE_TYPE_NAME(filespyDeviceObject->DeviceType) );
    }

    //
    //  Enumerate all the mounted devices that currently
    //  exist for this file system and attach to them.
    //

    status = IoTestEnumerateFileSystemVolumes( DeviceObject, Name );

    if (!NT_SUCCESS( status )) {

        IOTEST_DBG_PRINT2( IOTESTDEBUG_ERROR,
                            "IOTEST (IoTestAttachToFileSystem): Error attaching to existing volumes for \"%wZ\", status=%08x\n",
                            &devExt->DeviceNames,
                            status );

        goto ErrorCleanupAttachment;
    }

    return STATUS_SUCCESS;

    /////////////////////////////////////////////////////////////////////
    //                  Cleanup error handling
    /////////////////////////////////////////////////////////////////////

    ErrorCleanupAttachment:
        IoDetachDevice( filespyDeviceObject );

    ErrorCleanupDevice:
        IoTestCleanupMountedDevice( filespyDeviceObject );
        IoDeleteDevice( filespyDeviceObject );

    return status;
}

VOID
IoTestDetachFromFileSystemDevice (
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Given a base file system device object, this will scan up the attachment
    chain looking for our attached device object.  If found it will detach
    us from the chain.

Arguments:

    DeviceObject - The file system device to detach from.

Return Value:

--*/ 
{
    PDEVICE_OBJECT ourAttachedDevice;
    PIOTEST_DEVICE_EXTENSION devExt;

    PAGED_CODE();

    //
    //  We have to iterate through the device objects in the filter stack
    //  attached to DeviceObject.  If we are attached to this filesystem device
    //  object, We should be at the top of the stack, but there is no guarantee.
    //  If we are in the stack and not at the top, we can safely call IoDetachDevice
    //  at this time because the IO Manager will only really detach our device
    //  object from the stack at a safe time.
    //

    //
    //  Skip the base file system device object (since it can't be us)
    //

    ourAttachedDevice = DeviceObject->AttachedDevice;

    while (NULL != ourAttachedDevice) {

        if (IS_IOTEST_DEVICE_OBJECT( ourAttachedDevice )) {

            devExt = ourAttachedDevice->DeviceExtension;

            //
            //  Display who we detached from
            //

            IOTEST_DBG_PRINT2( IOTESTDEBUG_DISPLAY_ATTACHMENT_NAMES,
                                "IOTEST (IoTestDetachFromFileSystem): Detaching from file system \"%wZ\" (%s)\n",
                                &devExt->DeviceNames,
                                GET_DEVICE_TYPE_NAME(ourAttachedDevice->DeviceType) );
                                
            //
            //  Detach us from the object just below us
            //  Cleanup and delete the object
            //

            IoTestCleanupMountedDevice( ourAttachedDevice );
            IoDetachDevice( DeviceObject );
            IoDeleteDevice( ourAttachedDevice );

            return;
        }

        //
        //  Look at the next device up in the attachment chain
        //

        DeviceObject = ourAttachedDevice;
        ourAttachedDevice = ourAttachedDevice->AttachedDevice;
    }
}

NTSTATUS
IoTestEnumerateFileSystemVolumes (
    IN PDEVICE_OBJECT FSDeviceObject,
    IN PUNICODE_STRING Name
    ) 
/*++

Routine Description:

    Enumerate all the mounted devices that currently exist for the given file
    system and attach to them.  We do this because this filter could be loaded
    at any time and there might already be mounted volumes for this file system.

Arguments:

    FSDeviceObject - The device object for the file system we want to enumerate

    Name - An already initialized unicode string used to retrieve names

Return Value:

    The status of the operation

--*/
{
    PDEVICE_OBJECT *devList;
    PDEVICE_OBJECT diskDeviceObject;
    NTSTATUS status;
    ULONG numDevices;
    ULONG i;

    PAGED_CODE();

    //
    //  Find out how big of an array we need to allocate for the
    //  mounted device list.
    //

    status = IoEnumerateDeviceObjectList( FSDeviceObject->DriverObject,
                                          NULL,
                                          0,
                                          &numDevices);

    //
    //  We only need to get this list of there are devices.  If we
    //  don't get an error there are no devices so go on.
    //

    if (!NT_SUCCESS( status )) {

        ASSERT(STATUS_BUFFER_TOO_SMALL == status);

        //
        //  Allocate memory for the list of known devices
        //

        numDevices += 8;        //grab a few extra slots

        devList = ExAllocatePoolWithTag( NonPagedPool, 
                                         (numDevices * sizeof(PDEVICE_OBJECT)), 
                                         IOTEST_POOL_TAG );
        if (NULL == devList) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        //  Now get the list of devices.  If we get an error again
        //  something is wrong, so just fail.
        //

        status = IoEnumerateDeviceObjectList(
                        FSDeviceObject->DriverObject,
                        devList,
                        (numDevices * sizeof(PDEVICE_OBJECT)),
                        &numDevices);

        if (!NT_SUCCESS( status ))  {

            ExFreePool( devList );
            return status;
        }

        //
        //  Walk the given list of devices and attach to them if we should.
        //

        for (i=0; i < numDevices; i++) {

            //
            //  Do not attach if:
            //      - This is the control device object (the one passed in)
            //      - We are already attached to it
            //

            if ((devList[i] != FSDeviceObject) && 
                !IoTestIsAttachedToDevice( TOP_FILTER, devList[i], NULL )) {

                //
                //  See if this device has a name.  If so, then it must
                //  be a control device so don't attach to it.  This handles
                //  drivers with more then one control device.
                //

                IoTestGetBaseDeviceObjectName( devList[i], Name );

                if (Name->Length <= 0) {

                    //
                    //  Get the disk device object associated with this
                    //  file  system device object.  Only try to attach if we
                    //  have a disk device object.
                    //

                    status = IoGetDiskDeviceObject( devList[i], &diskDeviceObject );

                    if (NT_SUCCESS( status )) {

                        MINI_DEVICE_STACK ioTestDeviceObjects;

                        //
                        //  Allocate a new device object to attach with
                        //

                        status = IoTestCreateDeviceObjects( devList[i],
                                                            diskDeviceObject,
                                                            &ioTestDeviceObjects );
                        
                        if (NT_SUCCESS( status )) {

                            //
                            //  Attach to this device object
                            //

                            status = IoTestAttachDeviceObjects( &ioTestDeviceObjects,
                                                                devList[i],
                                                                diskDeviceObject );

                            //
                            //  This shouldn't fail.
                            //
                            
                            ASSERT( NT_SUCCESS( status ));
                        } else {

                            IOTEST_DBG_PRINT0( IOTESTDEBUG_ERROR,
                                                "IOTEST (IoTestEnumberateFileSystemVolumes): Cannot attach IoTest device object to volume.\n" );
                        }
                        
                        //
                        //  Remove reference added by IoGetDiskDeviceObject.
                        //  We only need to hold this reference until we are
                        //  successfully attached to the current volume.  Once
                        //  we are successfully attached to devList[i], the
                        //  IO Manager will make sure that the underlying
                        //  diskDeviceObject will not go away until the file
                        //  system stack is torn down.
                        //

                        ObDereferenceObject( diskDeviceObject );
                    }
                }
            }

            //
            //  Dereference the object (reference added by 
            //  IoEnumerateDeviceObjectList)
            //

            ObDereferenceObject( devList[i] );
        }

        //
        //  We are going to ignore any errors received while mounting.  We
        //  simply won't be attached to those volumes if we get an error
        //

        status = STATUS_SUCCESS;

        //
        //  Free the memory we allocated for the list
        //

        ExFreePool( devList );
    }

    return status;
}

////////////////////////////////////////////////////////////////////////
//                                                                    //
//             Private IoTest IOCTLs helper routines                 //
//                                                                    //
////////////////////////////////////////////////////////////////////////

NTSTATUS
IoTestGetAttachList (
    IN PVOID Buffer,
    IN ULONG BufferSize,
    OUT PULONG_PTR ReturnLength
    )
/*++

Routine Description:
    This returns an array of structure identifying all of the devices
    we are currently physical attached to and whether logging is on or
    off for the given device

Arguments:
    buffer - buffer to receive the attachment list
    bufferSize - total size in bytes of the return buffer
    returnLength - receives number of bytes we actually return

Return Value:
    NT Status code

--*/
{
    PLIST_ENTRY link;
    PIOTEST_DEVICE_EXTENSION pDevext;
    PATTACHED_DEVICE pAttDev;
    ULONG retlen = 0;

    pAttDev = Buffer;

    ExAcquireFastMutex( &gIoTestDeviceExtensionListLock );

    for (link = gIoTestDeviceExtensionList.Flink;
         link != &gIoTestDeviceExtensionList;
         link = link->Flink) {

        pDevext = CONTAINING_RECORD(link, IOTEST_DEVICE_EXTENSION, NextIoTestDeviceLink);

        if (BufferSize < sizeof(ATTACHED_DEVICE)) {

            break;
		}

        pAttDev->LoggingOn = pDevext->LogThisDevice;
        pAttDev->DeviceType = pDevext->Type;
        wcscpy( pAttDev->DeviceNames, pDevext->DeviceNamesBuffer );
        retlen += sizeof( ATTACHED_DEVICE );
        BufferSize -= sizeof( ATTACHED_DEVICE );
        pAttDev++;
    }

    ExReleaseFastMutex( &gIoTestDeviceExtensionListLock );

    *ReturnLength = retlen;
    return STATUS_SUCCESS;
}

VOID
IoTestGetLog (
    OUT PVOID            OutputBuffer,
    IN  ULONG            OutputBufferLength,
    OUT PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:
    This function fills OutputBuffer with as many LOG_RECORDs as possible.
    The LOG_RECORDs are variable sizes and are tightly packed in the
    OutputBuffer.

Arguments:
    OutputBuffer - the user's buffer to fill with the log data we have
        collected
    OutputBufferLength - the size in bytes of OutputBuffer
    IoStatus - is set to the correct return status information for this
        operation

Return Value:
    None

--*/
{
    PLIST_ENTRY pList = NULL;
    ULONG length = OutputBufferLength;
    PCHAR pOutBuffer = OutputBuffer;
    PLOG_RECORD pLogRecord = NULL;
    ULONG recordsAvailable = 0;
    PRECORD_LIST pRecordList;
    KIRQL oldIrql;

    IoStatus->Information = 0;

    KeAcquireSpinLock(&gOutputBufferLock, &oldIrql);

    while (!IsListEmpty( &gOutputBufferList ) && (length > 0)) {
        pList = RemoveHeadList( &gOutputBufferList );

        pRecordList = CONTAINING_RECORD( pList, RECORD_LIST, List );

        pLogRecord = &pRecordList->LogRecord;

        recordsAvailable++;

		//
        // put it back if we've run out of room
		//

        if (length < pLogRecord->Length) {

            InsertHeadList( &gOutputBufferList, pList );
            break;
        }

        KeReleaseSpinLock( &gOutputBufferLock, oldIrql );

        RtlCopyMemory( pOutBuffer, pLogRecord, pLogRecord->Length );

        IoStatus->Information += pLogRecord->Length;
        length -= pLogRecord->Length;
        pOutBuffer += pLogRecord->Length;

        IoTestFreeRecord( pRecordList );

        KeAcquireSpinLock( &gOutputBufferLock, &oldIrql );
    }

    KeReleaseSpinLock( &gOutputBufferLock, oldIrql );

	//
    // no copies occurred
	//

    if (length == OutputBufferLength && recordsAvailable > 0) {

        IoStatus->Status = STATUS_BUFFER_TOO_SMALL;
    }

    return;
}


VOID
IoTestFlushLog (
    )
/*++

Routine Description:
    This function removes all the LOG_RECORDs from the queue.

Arguments:

Return Value:
    None

--*/
{
    PLIST_ENTRY pList = NULL;
    PRECORD_LIST pRecordList;
    KIRQL oldIrql;

    KeAcquireSpinLock(&gOutputBufferLock, &oldIrql);

    while (!IsListEmpty( &gOutputBufferList )) {
        
        pList = RemoveHeadList( &gOutputBufferList );

        pRecordList = CONTAINING_RECORD( pList, RECORD_LIST, List );

        IoTestFreeRecord( pRecordList );
    }

    KeReleaseSpinLock( &gOutputBufferLock, oldIrql );

    return;
}
VOID
IoTestCloseControlDevice (
    )
/*++

Routine Description:

    This is the routine that is associated with IRP_MJ_
    This routine does the cleanup involved in closing the ControlDevice.
    On the close of the Control Device, we need to empty the queue of
    logRecords that are waiting to be returned to the user.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PLIST_ENTRY pList;
    PRECORD_LIST pRecordList;
    KIRQL oldIrql;

    //
    // Set the gControlDeviceState to CLEANING_UP so that we can
    // signal that we are cleaning up the device.
    //

    KeAcquireSpinLock( &gControlDeviceStateLock, &oldIrql );
    gControlDeviceState = CLEANING_UP;
    KeReleaseSpinLock( &gControlDeviceStateLock, oldIrql );

    KeAcquireSpinLock( &gOutputBufferLock, &oldIrql );

    while (!IsListEmpty( &gOutputBufferList )) {

        pList = RemoveHeadList( &gOutputBufferList );

        KeReleaseSpinLock( &gOutputBufferLock, oldIrql );

        pRecordList = CONTAINING_RECORD( pList, RECORD_LIST, List );

        IoTestFreeRecord( pRecordList );

        KeAcquireSpinLock( &gOutputBufferLock, &oldIrql );
    }

    KeReleaseSpinLock( &gOutputBufferLock, oldIrql );

    IoTestNameDeleteAllNames();

    //
    // All the cleanup is done, so set the gControlDeviceState
    // to CLOSED.
    //

    KeAcquireSpinLock( &gControlDeviceStateLock, &oldIrql );
    gControlDeviceState = CLOSED;
    KeReleaseSpinLock( &gControlDeviceStateLock, oldIrql );
}

////////////////////////////////////////////////////////////////////////
//                                                                    //
//               Device name tracking helper routines                 //
//                                                                    //
////////////////////////////////////////////////////////////////////////

VOID
IoTestGetObjectName (
    IN PVOID Object,
    IN OUT PUNICODE_STRING Name
    )
/*++

Routine Description:

    This routine will return the name of the given object.
    If a name can not be found an empty string will be returned.

Arguments:

    Object - The object whose name we want

    Name - A unicode string that is already initialized with a buffer

Return Value:

    None

--*/
{
    NTSTATUS status;
    CHAR nibuf[512];        //buffer that receives NAME information and name
    POBJECT_NAME_INFORMATION nameInfo = (POBJECT_NAME_INFORMATION)nibuf;
    ULONG retLength;

    status = ObQueryNameString( Object, nameInfo, sizeof(nibuf), &retLength);

    Name->Length = 0;
    if (NT_SUCCESS( status )) {

        RtlCopyUnicodeString( Name, &nameInfo->Name );
    }
}

VOID
IoTestGetBaseDeviceObjectName (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PUNICODE_STRING Name
    )
/*++

Routine Description:

    This locates the base device object in the given attachment chain and then
    returns the name of that object.

    If no name can be found, an empty string is returned.

Arguments:

    Object - The object whose name we want

    Name - A unicode string that is already initialized with a buffer

Return Value:

    None

--*/
{
    //
    //  Get the base file system device object
    //

    DeviceObject = IoGetDeviceAttachmentBaseRef( DeviceObject );

    //
    //  Get the name of that object
    //

    IoTestGetObjectName( DeviceObject, Name );

    //
    //  Remove the reference added by IoGetDeviceAttachmentBaseRef
    //

    ObDereferenceObject( DeviceObject );
}

VOID
IoTestCacheDeviceName (
    IN PDEVICE_OBJECT DeviceObject
    ) 
/*++

Routine Description:

    This routines tries to set a name into the device extension of the given
    device object. 
    
    It will try and get the name from:
        - The device object
        - The disk device object if there is one

Arguments:

    DeviceObject - The object we want a name for

Return Value:

    None

--*/
{
    PIOTEST_DEVICE_EXTENSION devExt;

    ASSERT(IS_IOTEST_DEVICE_OBJECT( DeviceObject ));

    devExt = DeviceObject->DeviceExtension;

    //
    //  Get the name of the given device object.
    //

    IoTestGetBaseDeviceObjectName( DeviceObject, &(devExt->DeviceNames) );

    //
    //  If we didn't get a name and there is a REAL device object, lookup
    //  that name.
    //

    if ((devExt->DeviceNames.Length <= 0) && (NULL != devExt->DiskDeviceObject)) {

        IoTestGetObjectName( devExt->DiskDeviceObject, &(devExt->DeviceNames) );
    }
}

BOOLEAN
IoTestFindSubString (
    IN PUNICODE_STRING String,
    IN PUNICODE_STRING SubString
    )
/*++

Routine Description:
    This routine looks to see if SubString is a substring of String.

Arguments:
    String - the string to search in
    SubString - the substring to find in String

Return Value:
    Returns TRUE if the substring is found in string and FALSE otherwise.
    
--*/
{
    ULONG index;

    //
    //  First, check to see if the strings are equal.
    //

    if (RtlEqualUnicodeString( String, SubString, TRUE )) {

        return TRUE;
    }

    //
    //  String and SubString aren't equal, so now see if SubString
    //  in in String any where.
    //

    for (index = 0;
         index + SubString->Length <= String->Length;
         index++) {

        if (_wcsnicmp( &(String->Buffer[index]), SubString->Buffer, SubString->Length ) == 0) {

            //
            //  SubString is found in String, so return TRUE.
            //
            return TRUE;
        }
    }

    return FALSE;
}

VOID
IoTestStoreUserName (
    IN PIOTEST_DEVICE_EXTENSION DeviceExtension,
    IN PUNICODE_STRING UserName
    )
/*++

Routine Description:

    Stores the current device name in the device extension.  If
    this name is already in the device name list of this extension,
    it will not be added.  If there is already a name for this device, 
    the new device name is appended to the DeviceName in the device extension.
    
Arguments:

    DeviceExtension - The device extension that will store the
        device name.

    UserName - The device name as specified by the user to be stored.

Return Value:

    None

--*/
{
    //
    //  See if this UserName is already in the list of user names filespy
    //  keeps in its device extension.  If not, add it to the list.
    //

    if (!IoTestFindSubString( &(DeviceExtension->UserNames), UserName )) {

        //
        //  We didn't find this name in the list, so if there are no names 
        //  in the UserNames list, just append UserName.  Otherwise, append a
        //  delimiter then append UserName.
        //

        if (DeviceExtension->UserNames.Length == 0) {

            RtlAppendUnicodeStringToString( &DeviceExtension->UserNames, UserName );

        } else {

            RtlAppendUnicodeToString( &DeviceExtension->UserNames, L", " );
            RtlAppendUnicodeStringToString( &DeviceExtension->UserNames, UserName );
        }
    }

    //
    //  See if this UserName is already in the list of device names filespy
    //  keeps in its device extension.  If not, add it to the list.
    //

    if (!IoTestFindSubString( &(DeviceExtension->DeviceNames), UserName )) {

        //
        //  We didn't find this name in the list, so if there are no names 
        //  in the UserNames list, just append UserName.  Otherwise, append a
        //  delimiter then append UserName.
        //

        if (DeviceExtension->DeviceNames.Length == 0) {

            RtlAppendUnicodeStringToString( &DeviceExtension->DeviceNames, UserName );

        } else {

            RtlAppendUnicodeToString( &DeviceExtension->DeviceNames, L", " );
            RtlAppendUnicodeStringToString( &DeviceExtension->DeviceNames, UserName );
        }
    }
}

////////////////////////////////////////////////////////////////////////
//                                                                    //
//                        Debug support routines                      //
//                                                                    //
////////////////////////////////////////////////////////////////////////

VOID
IoTestDumpIrpOperation (
    IN BOOLEAN InOriginatingPath,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is for debugging and prints out a string to the
    debugger specifying what Irp operation is being seen.
    
Arguments:

    InOriginatingPath - TRUE if we are in the originating path
        for the IRP, FALSE if in the completion path.

    Irp - The IRP for this operation.
        
Return Value:

    None.
    
--*/
{
    CHAR irpMajorString[OPERATION_NAME_BUFFER_SIZE];
    CHAR irpMinorString[OPERATION_NAME_BUFFER_SIZE];
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation( Irp );

    GetIrpName(irpSp->MajorFunction,
               irpSp->MinorFunction,
               irpSp->Parameters.FileSystemControl.FsControlCode,
               irpMajorString,irpMinorString);


    if (InOriginatingPath) {

        DbgPrint( "IOTEST: Irp preoperation for %s %s\n", irpMajorString, irpMinorString );
            
    } else {
    
        DbgPrint( "IOTEST: Irp postoperation for %s %s\n", irpMajorString, irpMinorString );
    }
}

VOID
IoTestDumpFastIoOperation (
    IN BOOLEAN InPreOperation,
    IN FASTIO_TYPE FastIoOperation
    )
/*++

Routine Description:

    This routine is for debugging and prints out a string to the
    debugger specifying what FsFilter operation is being seen.
    
Arguments:

    InPreOperation - TRUE if we have not called down to the next
        device in the stack, FALSE otherwise.

    FastIoOperation - The code for the Fast Io operation.
    
Return Value:

    None.
    
--*/
{
    CHAR operationString[OPERATION_NAME_BUFFER_SIZE];

    GetFastioName(FastIoOperation,
               operationString);


    if (InPreOperation) {
    
        DbgPrint( "IOTEST: Fast IO preOperation for %s\n", operationString );

    } else {

        DbgPrint( "IOTEST: Fast IO postOperation for %s\n", operationString );
    }
}

VOID
IoTestDumpFsFilterOperation (
    IN BOOLEAN InPreOperationCallback,
    IN PFS_FILTER_CALLBACK_DATA Data
    )
/*++

Routine Description:

    This routine is for debugging and prints out a string to the
    debugger specifying what FsFilter operation is being seen.
    
Arguments:

    InPreOperationCallback - TRUE if we are in a preOperation 
        callback, FALSE otherwise.

    Data - The FS_FILTER_CALLBACK_DATA structure for this
        operation.
        
Return Value:

    None.
    
--*/
{
    CHAR operationString[OPERATION_NAME_BUFFER_SIZE];


    GetFsFilterOperationName(Data->Operation,operationString);

    if (InPreOperationCallback) {
    
        DbgPrint( "IOTEST: FsFilter preOperation for %s\n", operationString );

    } else {

        DbgPrint( "IOTEST: FsFilter postOperation for %s\n", operationString );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\iotest\filter\iotest.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    ioTest.c

Abstract:

    This is the main module of IoTest.

// @@BEGIN_DDKSPLIT

Author:

    Molly Brown (mollybro)  

// @@END_DDKSPLIT

Environment:

    Kernel mode

// @@BEGIN_DDKSPLIT

Revision History:

    Molly Brown (mollybro) 02-Dec-2000  
        Based on Filespy, created filter to test IO generation.

// @@END_DDKSPLIT
--*/

#include <ntifs.h>
#include <stdlib.h>
#include "ioTest.h"
#include "ioTestKern.h"

BOOLEAN gPending = TRUE;

//
// Global storage for this file system filter driver.
//

#if DBG
ULONG gIoTestDebugLevel = IOTESTDEBUG_DISPLAY_ATTACHMENT_NAMES | IOTESTDEBUG_ERROR | IOTESTDEBUG_TESTS;
#else
ULONG gIoTestDebugLevel = DEFAULT_IOTEST_DEBUG_LEVEL;
#endif

ULONG gIoTestAttachMode = IOTEST_ATTACH_ALL_VOLUMES;

PDEVICE_OBJECT gControlDeviceObject;

PDRIVER_OBJECT gIoTestDriverObject;

//
//  The list of device extensions for the volume device objects we are
//  attached to (the volumes we are spying on).  Note:  This list does NOT
//  include FileSystem control device objects we are attached to.  This
//  list is used to answer the question "Which volumes are we logging?"
//

FAST_MUTEX gIoTestDeviceExtensionListLock;
LIST_ENTRY gIoTestDeviceExtensionList;

//
// NOTE 1:  There are some cases where we need to hold both the 
//   gControlDeviceStateLock and the gOutputBufferLock at the same time.  In
//   these cases, you should acquire the gControlDeviceStateLock then the
//   gOutputBufferLock.
// NOTE 2:  The gControlDeviceStateLock MUST be a spinlock since we try to 
//   acquire it during the completion path in IoTestLog, which could be called at
//   DISPATCH_LEVEL (only KSPIN_LOCKs can be acquired at DISPATCH_LEVEL).
//

CONTROL_DEVICE_STATE gControlDeviceState = CLOSED;
KSPIN_LOCK gControlDeviceStateLock;

// NOTE:  Like the gControlDeviceStateLock, gOutputBufferLock MUST be a spinlock
//   since we try to acquire it during the completion path in IoTestLog, which 
//   could be called at DISPATCH_LEVEL (only KSPIN_LOCKs can be acquired at 
//   DISPATCH_LEVEL).
//
KSPIN_LOCK gOutputBufferLock;
LIST_ENTRY gOutputBufferList;

NPAGED_LOOKASIDE_LIST gFreeBufferList;

ULONG gLogSequenceNumber = 0;
KSPIN_LOCK gLogSequenceLock;

UNICODE_STRING gVolumeString;
UNICODE_STRING gOverrunString;
UNICODE_STRING gPagingIoString;

//
// NOTE:  Like above for the ControlDeviceLock, we must use KSPIN_LOCKs
//   to synchronize access to hash buckets since we may call try to
//   acquire them at DISPATCH_LEVEL.
//

LIST_ENTRY gHashTable[HASH_SIZE];
KSPIN_LOCK gHashLockTable[HASH_SIZE];
ULONG gHashMaxCounters[HASH_SIZE];
ULONG gHashCurrentCounters[HASH_SIZE];

HASH_STATISTICS gHashStat;

LONG gMaxRecordsToAllocate = DEFAULT_MAX_RECORDS_TO_ALLOCATE;
LONG gRecordsAllocated = 0;

LONG gMaxNamesToAllocate = DEFAULT_MAX_NAMES_TO_ALLOCATE;
LONG gNamesAllocated = 0;

LONG gStaticBufferInUse = FALSE;
CHAR gOutOfMemoryBuffer[RECORD_SIZE];


//
// Macro to test if we are logging for this device
// NOTE: We don't bother synchronizing to check the gControlDeviceState since
//   we can tolerate a stale value here.  We just look at it here to avoid 
//   doing the logging work if we can.  We synchronize to check the 
//   gControlDeviceState before we add the log record to the gOutputBufferList 
//   and discard the log record if the ControlDevice is no longer OPENED.
//

#define SHOULD_LOG(pDeviceObject) \
    ((gControlDeviceState == OPENED) && \
     (((PIOTEST_DEVICE_EXTENSION)(pDeviceObject)->DeviceExtension)->LogThisDevice))
     
//
//  Macro for validating the FastIo dispatch routines before calling
//  them in the FastIo pass through functions.
//

#define VALID_FAST_IO_DISPATCH_HANDLER(FastIoDispatchPtr, FieldName) \
    (((FastIoDispatchPtr) != NULL) && \
     (((FastIoDispatchPtr)->SizeOfFastIoDispatch) >= \
      (FIELD_OFFSET(FAST_IO_DISPATCH, FieldName) + sizeof(VOID *))) && \
     ((FastIoDispatchPtr)->FieldName != NULL))
    

//
//  list of known device types
//

const PCHAR DeviceTypeNames[] = {
    "",
    "BEEP",
    "CD_ROM",
    "CD_ROM_FILE_SYSTEM",
    "CONTROLLER",
    "DATALINK",
    "DFS",
    "DISK",
    "DISK_FILE_SYSTEM",
    "FILE_SYSTEM",
    "INPORT_PORT",
    "KEYBOARD",
    "MAILSLOT",
    "MIDI_IN",
    "MIDI_OUT",
    "MOUSE",
    "MULTI_UNC_PROVIDER",
    "NAMED_PIPE",
    "NETWORK",
    "NETWORK_BROWSER",
    "NETWORK_FILE_SYSTEM",
    "NULL",
    "PARALLEL_PORT",
    "PHYSICAL_NETCARD",
    "PRINTER",
    "SCANNER",
    "SERIAL_MOUSE_PORT",
    "SERIAL_PORT",
    "SCREEN",
    "SOUND",
    "STREAMS",
    "TAPE",
    "TAPE_FILE_SYSTEM",
    "TRANSPORT",
    "UNKNOWN",
    "VIDEO",
    "VIRTUAL_DISK",
    "WAVE_IN",
    "WAVE_OUT",
    "8042_PORT",
    "NETWORK_REDIRECTOR",
    "BATTERY",
    "BUS_EXTENDER",
    "MODEM",
    "VDM",
    "MASS_STORAGE",
    "SMB",
    "KS",
    "CHANGER",
    "SMARTCARD",
    "ACPI",
    "DVD",
    "FULLSCREEN_VIDEO",
    "DFS_FILE_SYSTEM",
    "DFS_VOLUME",
    "SERENUM",
    "TERMSRV",
    "KSEC"
};

//
//  We need this because the compiler doesn't like doing sizeof an externed
//  array in the other file that needs it (fspylib.c)
//

ULONG SizeOfDeviceTypeNames = sizeof( DeviceTypeNames );

//
//  Since functions in drivers are non-pagable by default, these pragmas 
//  allow the driver writer to tell the system what functions can be paged.
//
//  Use the PAGED_CODE() macro at the beginning of these functions'
//  implementations while debugging to ensure that these routines are
//  never called at IRQL > APC_LEVEL (therefore the routine cannot
//  be paged).
//

VOID
DriverUnload(
    IN PDRIVER_OBJECT DriverObject
    );


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(INIT, DriverUnload)
#pragma alloc_text(INIT, IoTestReadDriverParameters)
#pragma alloc_text(PAGE, IoTestClose)
#pragma alloc_text(PAGE, IoTestFsControl)
#pragma alloc_text(PAGE, IoTestFastIoCheckIfPossible)
#pragma alloc_text(PAGE, IoTestFastIoRead)
#pragma alloc_text(PAGE, IoTestFastIoWrite)
#pragma alloc_text(PAGE, IoTestFastIoQueryBasicInfo)
#pragma alloc_text(PAGE, IoTestFastIoQueryStandardInfo)
#pragma alloc_text(PAGE, IoTestFastIoLock)
#pragma alloc_text(PAGE, IoTestFastIoUnlockSingle)
#pragma alloc_text(PAGE, IoTestFastIoUnlockAll)
#pragma alloc_text(PAGE, IoTestFastIoUnlockAllByKey)
#pragma alloc_text(PAGE, IoTestFastIoDeviceControl)
#pragma alloc_text(PAGE, IoTestFastIoDetachDevice)
#pragma alloc_text(PAGE, IoTestFastIoQueryNetworkOpenInfo)
#pragma alloc_text(PAGE, IoTestFastIoMdlRead)
#pragma alloc_text(PAGE, IoTestFastIoPrepareMdlWrite)
#pragma alloc_text(PAGE, IoTestFastIoReadCompressed)
#pragma alloc_text(PAGE, IoTestFastIoWriteCompressed)
#pragma alloc_text(PAGE, IoTestFastIoQueryOpen)
#pragma alloc_text(PAGE, IoTestPreFsFilterOperation)
#pragma alloc_text(PAGE, IoTestPostFsFilterOperation)
#endif
 
NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
)
/*++

Routine Description:

    This is the initialization routine for the general purpose file system
    filter driver.  This routine creates the device object that represents 
    this driver in the system and registers it for watching all file systems 
    that register or unregister themselves as active file systems.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    The function value is the final status from the initialization operation.

--*/
{
    UNICODE_STRING nameString;
    NTSTATUS status;
    PFAST_IO_DISPATCH fastIoDispatch;
    ULONG i;
    UNICODE_STRING linkString;
    FS_FILTER_CALLBACKS fsFilterCallbacks;
    
    //////////////////////////////////////////////////////////////////////
    //                                                                  //
    //  General setup for all filter drivers.  This sets up the filter  //
    //  driver's DeviceObject and registers the callback routines for   //
    //  the filter driver.                                              //
    //                                                                  //
    //////////////////////////////////////////////////////////////////////

    //
    //  Read the custom parameters for IoTest from the registry
    //

    IoTestReadDriverParameters( RegistryPath );

#if DBG
    //DbgBreakPoint();
#endif

    //
    //  Save our Driver Object.
    //

    gIoTestDriverObject = DriverObject;
    gIoTestDriverObject->DriverUnload = DriverUnload;

    //
    // Create the device object that will represent the IoTest device.
    //

    RtlInitUnicodeString( &nameString, IOTEST_FULLDEVICE_NAME );
    
    //
    // Create the "control" device object.  Note that this device object does
    // not have a device extension (set to NULL).  Most of the fast IO routines
    // check for this condition to determine if the fast IO is directed at the
    // control device.
    //

    status = IoCreateDevice( DriverObject,
                             0,
                             &nameString,
                             FILE_DEVICE_DISK_FILE_SYSTEM,
                             0,
                             FALSE,
                             &gControlDeviceObject);

    if (!NT_SUCCESS( status )) {

        IOTEST_DBG_PRINT1( IOTESTDEBUG_ERROR,
                            "IOTEST (DriverEntry): Error creating IoTest device, error: %x\n",
                            status );

        return status;

    } else {

        RtlInitUnicodeString( &linkString, IOTEST_DOSDEVICE_NAME );
        status = IoCreateSymbolicLink( &linkString, &nameString );

        if (!NT_SUCCESS(status)) {

            //
            //  Remove the existing symbol link and try and create it again.
            //  If this fails then quit.
            //

            IoDeleteSymbolicLink( &linkString );
            status = IoCreateSymbolicLink( &linkString, &nameString );

            if (!NT_SUCCESS(status)) {

                IOTEST_DBG_PRINT0( IOTESTDEBUG_ERROR,
                                    "IOTEST (DriverEntry): IoCreateSymbolicLink failed\n" );
                IoDeleteDevice(gControlDeviceObject);
                return status;
            }
        }
    }

    //
    // Initialize the driver object with this device driver's entry points.
    //

    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {

        DriverObject->MajorFunction[i] = IoTestDispatch;
    }

    DriverObject->MajorFunction[IRP_MJ_CREATE] = IoTestCreate;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = IoTestClose;
    DriverObject->MajorFunction[IRP_MJ_FILE_SYSTEM_CONTROL] = IoTestFsControl;

    //
    // Allocate fast I/O data structure and fill it in.  This structure
    // is used to register the callbacks for IoTest in the fast I/O
    // data paths.
    //

    fastIoDispatch = ExAllocatePool( NonPagedPool, sizeof( FAST_IO_DISPATCH ) );

    if (!fastIoDispatch) {

        IoDeleteDevice( gControlDeviceObject );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory( fastIoDispatch, sizeof( FAST_IO_DISPATCH ) );
    fastIoDispatch->SizeOfFastIoDispatch = sizeof( FAST_IO_DISPATCH );
    fastIoDispatch->FastIoCheckIfPossible = IoTestFastIoCheckIfPossible;
    fastIoDispatch->FastIoRead = IoTestFastIoRead;
    fastIoDispatch->FastIoWrite = IoTestFastIoWrite;
    fastIoDispatch->FastIoQueryBasicInfo = IoTestFastIoQueryBasicInfo;
    fastIoDispatch->FastIoQueryStandardInfo = IoTestFastIoQueryStandardInfo;
    fastIoDispatch->FastIoLock = IoTestFastIoLock;
    fastIoDispatch->FastIoUnlockSingle = IoTestFastIoUnlockSingle;
    fastIoDispatch->FastIoUnlockAll = IoTestFastIoUnlockAll;
    fastIoDispatch->FastIoUnlockAllByKey = IoTestFastIoUnlockAllByKey;
    fastIoDispatch->FastIoDeviceControl = IoTestFastIoDeviceControl;
    fastIoDispatch->FastIoDetachDevice = IoTestFastIoDetachDevice;
    fastIoDispatch->FastIoQueryNetworkOpenInfo = IoTestFastIoQueryNetworkOpenInfo;
    fastIoDispatch->MdlRead = IoTestFastIoMdlRead;
    fastIoDispatch->MdlReadComplete = IoTestFastIoMdlReadComplete;
    fastIoDispatch->PrepareMdlWrite = IoTestFastIoPrepareMdlWrite;
    fastIoDispatch->MdlWriteComplete = IoTestFastIoMdlWriteComplete;
    fastIoDispatch->FastIoReadCompressed = IoTestFastIoReadCompressed;
    fastIoDispatch->FastIoWriteCompressed = IoTestFastIoWriteCompressed;
    fastIoDispatch->MdlReadCompleteCompressed = IoTestFastIoMdlReadCompleteCompressed;
    fastIoDispatch->MdlWriteCompleteCompressed = IoTestFastIoMdlWriteCompleteCompressed;
    fastIoDispatch->FastIoQueryOpen = IoTestFastIoQueryOpen;

    DriverObject->FastIoDispatch = fastIoDispatch;

    //
    //  Setup the callbacks for the operations we receive through
    //  the FsFilter interface.
    //

    fsFilterCallbacks.SizeOfFsFilterCallbacks = sizeof( FS_FILTER_CALLBACKS );
    fsFilterCallbacks.PreAcquireForSectionSynchronization = IoTestPreFsFilterOperation;
    fsFilterCallbacks.PostAcquireForSectionSynchronization = IoTestPostFsFilterOperation;
    fsFilterCallbacks.PreReleaseForSectionSynchronization = IoTestPreFsFilterOperation;
    fsFilterCallbacks.PostReleaseForSectionSynchronization = IoTestPostFsFilterOperation;
    fsFilterCallbacks.PreAcquireForCcFlush = IoTestPreFsFilterOperation;
    fsFilterCallbacks.PostAcquireForCcFlush = IoTestPostFsFilterOperation;
    fsFilterCallbacks.PreReleaseForCcFlush = IoTestPreFsFilterOperation;
    fsFilterCallbacks.PostReleaseForCcFlush = IoTestPostFsFilterOperation;
    fsFilterCallbacks.PreAcquireForModifiedPageWriter = IoTestPreFsFilterOperation;
    fsFilterCallbacks.PostAcquireForModifiedPageWriter = IoTestPostFsFilterOperation;
    fsFilterCallbacks.PreReleaseForModifiedPageWriter = IoTestPreFsFilterOperation;
    fsFilterCallbacks.PostReleaseForModifiedPageWriter = IoTestPostFsFilterOperation;

    status = FsRtlRegisterFileSystemFilterCallbacks( DriverObject, &fsFilterCallbacks );

    if (!NT_SUCCESS( status )) {

        DriverObject->FastIoDispatch = NULL;
        ExFreePool( fastIoDispatch );
        IoDeleteDevice( gControlDeviceObject );
        return status;
    }

    //////////////////////////////////////////////////////////////////////
    //                                                                  //
    //  Initialize global data structures that are used for IoTest's   //
    //  logging of I/O operations.                                      //
    //                                                                  //
    //////////////////////////////////////////////////////////////////////

    //
    //  A fast mutex was used in this case because the mutex is never acquired
    //  at DPC level or above.  Spinlocks were chosen in other cases because
    //  they are acquired at DPC level or above.  Another consideration is
    //  that on an MP machine, a spin lock will literally spin trying to 
    //  acquire the lock when the lock is already acquired.  Acquiring a
    //  previously acquired fast mutex will suspend the thread, thus freeing
    //  up the processor.
    //
    
    ExInitializeFastMutex( &gIoTestDeviceExtensionListLock );
    InitializeListHead( &gIoTestDeviceExtensionList );

    KeInitializeSpinLock( &gControlDeviceStateLock );

    InitializeListHead( &gOutputBufferList );

    KeInitializeSpinLock( &gOutputBufferLock );
    KeInitializeSpinLock( &gLogSequenceLock );


#ifndef MEMORY_DBG

    //
    //  When we aren't debugging our memory usage, we want to allocate 
    //  memory from a look-aside list for better performance.  Unfortunately,
    //  we cannot benefit from the memory debugging help of the Driver 
    //  Verifier if we allocate memory from a look-aside list.
    //

    ExInitializeNPagedLookasideList( &gFreeBufferList, 
                                     NULL/*ExAllocatePoolWithTag*/, 
                                     NULL/*ExFreePool*/, 
                                     0, 
                                     RECORD_SIZE, 
                                     MSFM_TAG, 
                                     100 );
#endif

    //
    //  Initialize the hash table
    //
        
    for (i = 0; i < HASH_SIZE; i++){

        InitializeListHead(&gHashTable[i]);
        KeInitializeSpinLock(&gHashLockTable[i]);
    }

    RtlInitUnicodeString(&gVolumeString, L"VOLUME");
    RtlInitUnicodeString(&gOverrunString, L"......");
    RtlInitUnicodeString(&gPagingIoString, L"Paging IO");

    //
    //  If we are supposed to attach to all devices, register a callback
    //  with IoRegisterFsRegistrationChange.
    //

    if (gIoTestAttachMode == IOTEST_ATTACH_ALL_VOLUMES) {
    
        status = IoRegisterFsRegistrationChange( DriverObject, IoTestFsNotification );
        
        if (!NT_SUCCESS( status )) {

            IOTEST_DBG_PRINT1( IOTESTDEBUG_ERROR,
                                "IOTEST (DriverEntry): Error registering FS change notification, status=%08x\n", 
                                status );

            DriverObject->FastIoDispatch = NULL;
            ExFreePool( fastIoDispatch );
            IoDeleteDevice( gControlDeviceObject );
            return status;
        }
    }

    //
    //  Clear the initializing flag on the control device object since we
    //  have now successfully initialized everything.
    //

    ClearFlag( gControlDeviceObject->Flags, DO_DEVICE_INITIALIZING );

    return STATUS_SUCCESS;
}


VOID
DriverUnload (
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    This routine is called when a driver can be unloaded.  This performs all of
    the necessary cleanup for unloading the driver from memory.  Note that an
    error can not be returned from this routine.
    
    When a request is made to unload a driver the IO System will cache that
    information and not actually call this routine until the following states
    have occurred:
    - All device objects which belong to this filter are at the top of their
      respective attachment chains.
    - All handle counts for all device objects which belong to this filter have
      gone to zero.

    WARNING: Microsoft does not officially support the unloading of File
             System Filter Drivers.  This is an example of how to unload
             your driver if you would like to use it during development.
             This should not be made available in production code.

Arguments:

    DriverObject - Driver object for this module

Return Value:

    None.

--*/

{
    PIOTEST_DEVICE_EXTENSION devExt;
    PFAST_IO_DISPATCH fastIoDispatch;
    NTSTATUS status;
    ULONG numDevices;
    ULONG i;
    LARGE_INTEGER interval;
    UNICODE_STRING linkString;
#   define DEVOBJ_LIST_SIZE 64
    PDEVICE_OBJECT devList[DEVOBJ_LIST_SIZE];

    ASSERT(DriverObject == gIoTestDriverObject);

    //
    //  Log we are unloading
    //

    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_DISPLAY_ATTACHMENT_NAMES )) {

        DbgPrint( "IOTEST (DriverUnload): Unloading Driver (%p)\n",DriverObject);
    }

    //
    //  Remove the symbolic link so no one else will be able to find it.
    //

    RtlInitUnicodeString( &linkString, IOTEST_DOSDEVICE_NAME );
    IoDeleteSymbolicLink( &linkString );

    //
    //  Don't get anymore file system change notifications
    //

    IoUnregisterFsRegistrationChange( DriverObject, IoTestFsNotification );

    //
    //  This is the loop that will go through all of the devices we are attached
    //  to and detach from them.  Since we don't know how many there are and
    //  we don't want to allocate memory (because we can't return an error)
    //  we will free them in chunks using a local array on the stack.
    //

    for (;;) {

        //
        //  Get what device objects we can for this driver.  Quit if there
        //  are not any more.
        //

        status = IoEnumerateDeviceObjectList(
                        DriverObject,
                        devList,
                        sizeof(devList),
                        &numDevices);

        if (numDevices <= 0)  {

            break;
        }

        numDevices = min( numDevices, DEVOBJ_LIST_SIZE );

        //
        //  First go through the list and detach each of the devices.
        //  Our control device object does not have a DeviceExtension and
        //  is not attached to anything so don't detach it.
        //

        for (i=0; i < numDevices; i++) {

            devExt = devList[i]->DeviceExtension;
            if (NULL != devExt) {

                IoDetachDevice( devExt->AttachedToDeviceObject );
            }
        }

        //
        //  The IO Manager does not currently add a refrence count to a device
        //  object for each outstanding IRP.  This means there is no way to
        //  know if there are any outstanding IRPs on the given device.
        //  We are going to wait for a reonsable amount of time for pending
        //  irps to complete.  
        //
        //  WARNING: This does not work 100% of the time and the driver may be
        //           unloaded before all IRPs are completed during high stress
        //           situations.  The system will fault if this occurs.  This
        //           is a sample of how to do this during testing.  This is
        //           not recommended for production code.
        //

        interval.QuadPart = -5 * (10 * 1000 * 1000);      //delay 5 seconds
        KeDelayExecutionThread( KernelMode, FALSE, &interval );

        //
        //  Now go back through the list and delete the device objects.
        //

        for (i=0; i < numDevices; i++) {

            //
            //  See if this is our control device object.  If not then cleanup
            //  the device extension.  If so then clear the global pointer
            //  that refrences it.
            //

            if (NULL != devList[i]->DeviceExtension) {

                IoTestCleanupMountedDevice( devList[i] );

            } else {

                ASSERT(devList[i] == gControlDeviceObject);
                ASSERT(gControlDeviceState == CLOSED);
                gControlDeviceObject = NULL;
            }

            //
            //  Delete the device object, remove refrence counts added by
            //  IoEnumerateDeviceObjectList.  Note that the delete does
            //  not actually occur until the refrence count goes to zero.
            //

            IoDeleteDevice( devList[i] );
            ObDereferenceObject( devList[i] );
        }
    }

    //
    //  Delete the look aside list.
    //

    ASSERT(IsListEmpty( &gIoTestDeviceExtensionList ));
    ExDeleteNPagedLookasideList( &gFreeBufferList );

    //
    //  Free our FastIO table
    //

    fastIoDispatch = DriverObject->FastIoDispatch;
    DriverObject->FastIoDispatch = NULL;
    ExFreePool( fastIoDispatch );
}


VOID
IoTestFsNotification (
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN FsActive
    )
/*++

Routine Description:

    This routine is invoked whenever a file system has either registered or
    unregistered itself as an active file system.

    For the former case, this routine creates a device object and attaches it
    to the specified file system's device object.  This allows this driver
    to filter all requests to that file system.

    For the latter case, this file system's device object is located,
    detached, and deleted.  This removes this file system as a filter for
    the specified file system.

Arguments:

    DeviceObject - Pointer to the file system's device object.

    FsActive - Boolean indicating whether the file system has registered
        (TRUE) or unregistered (FALSE) itself as an active file system.

Return Value:

    None.

--*/
{
    UNICODE_STRING name;
    WCHAR nameBuffer[DEVICE_NAMES_SZ];

    RtlInitEmptyUnicodeString( &name, nameBuffer, sizeof( nameBuffer ) );

    //
    //  Display the names of all the file system we are notified of
    //

    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_DISPLAY_ATTACHMENT_NAMES )) {

        IoTestGetBaseDeviceObjectName( DeviceObject, &name );
        DbgPrint( "IOTEST (IoTestFsNotification): %s       \"%wZ\" (%s)\n",
                  (FsActive) ? "Activating file system  " : "Deactivating file system",
                  &name,
                  GET_DEVICE_TYPE_NAME(DeviceObject->DeviceType));
    }

    //
    //  See if we want to ATTACH or DETACH from the given file system.
    //

    if (FsActive) {

        IoTestAttachToFileSystemDevice( DeviceObject, &name );

    } else {

        IoTestDetachFromFileSystemDevice( DeviceObject );
    }
}


NTSTATUS
IoTestPassThrough (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
)
/*++

Routine Description:

    This routine is the main dispatch routine for the general purpose file
    system driver.  It simply passes requests onto the next driver in the
    stack, which is presumably a disk file system, while logging any
    relevant information if logging is turned on for this DeviceObject.

Arguments:

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.
        
    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

Note:

    This routine passes the I/O request through to the next driver
    *without* removing itself from the stack (like sfilter) since it could
    want to see the result of this I/O request.
    
    To remain in the stack, we have to copy the caller's parameters to the
    next stack location.  Note that we do not want to copy the caller's I/O
    completion routine into the next stack location, or the caller's routine
    will get invoked twice.  This is why we NULL out the Completion routine.
    If we are logging this device, we set our own Completion routine.
    
--*/
{
    ASSERT( IS_IOTEST_DEVICE_OBJECT( DeviceObject ) );

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //

    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_IRP_OPS )) {

        IoTestDumpIrpOperation( TRUE, Irp );
    }

    //
    //  See if we should log this IRP
    //
    
    if (SHOULD_LOG( DeviceObject )) {
        PRECORD_LIST recordList;

        //
        // The ControlDevice is opened, so allocate the Record 
        // and log the Irp information if we have the memory.
        //

        recordList = IoTestNewRecord(0);

        if (recordList) {

            IoTestLogIrp( Irp, LOG_ORIGINATING_IRP, recordList );

            IoTestLog( recordList );
        }
    }

    //
    //  For the IoTest filter, we don't wait to see the outcome of the operation
    //  so just skip setting a completion routine.
    //

    IoSkipCurrentIrpStackLocation( Irp );

    //
    // Now call the next file system driver with the request.
    //
    
    return IoCallDriver( ((PIOTEST_DEVICE_EXTENSION)DeviceObject->DeviceExtension)->AttachedToDeviceObject, Irp );
}

#if 0
NTSTATUS
IoTestPassThroughCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
)
/*++

Routine Description:

    This routine is the completion routine IoTestPassThrough.  This is used
    to log the information that can only be gathered after the I/O request
    has been completed.

    Once we are done logging all the information we care about, we append
    the record to the gOutputBufferList to be returned to the user.
    
    Note: This routine will only be set if we were trying to log the
        specified device when the Irp originated and we were able to
        allocate a record to store this logging information.

Arguments:

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.
        
    Irp - Pointer to the request packet representing the I/O request.
    
    Context - Pointer to the RECORD_LIST structure in which we store the
        information we are logging.

Return Value:

    The function value is the status of the operation.

--*/
{
    PRECORD_LIST recordList;

    ASSERT( IS_IOTEST_DEVICE_OBJECT( DeviceObject ) );

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_IRP_OPS )) {

        IoTestDumpIrpOperation( FALSE, Irp );
    }
    
    recordList = (PRECORD_LIST)Context;

    if (SHOULD_LOG( DeviceObject )) {

        IoTestLogIrp( Irp, LOG_COMPLETION_IRP, recordList );
        
        //
        //  Add recordList to our gOutputBufferList so that it gets up to 
        //  the user
        //
        
        IoTestLog( recordList );       

    } else {

        if (recordList) {

            //
            //  Context is set with a RECORD_LIST, but we are no longer
            //  logging so free this record.
            //

            IoTestFreeRecord( recordList );
        }
    }
    
    //
    //  If the operation failed and this was a create, remove the name
    //  from the cache.
    //

    if (!NT_SUCCESS(Irp->IoStatus.Status)) {
        PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation( Irp );

        if ((IRP_MJ_CREATE == irpStack->MajorFunction) &&
            (irpStack->FileObject != NULL)) {

            IoTestNameDelete(irpStack->FileObject);
        }
    }
    
    //
    //  Propagate the IRP pending flag.  All completion routines
    //  need to do this.
    //

    if (Irp->PendingReturned) {
        
        IoMarkIrpPending( Irp );
    }

    return STATUS_SUCCESS;
}
#endif

NTSTATUS
IoTestDispatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
)
/*++

Routine Description:

    This function completes all requests on the gControlDeviceObject 
    (IoTest's device object) and passes all other requests on to the 
    IoTestPassThrough function.

Arguments:

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.
        
    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    If this is a request on the gControlDeviceObject, STATUS_SUCCESS 
    will be returned unless the device is already attached.  In that case,
    STATUS_DEVICE_ALREADY_ATTACHED is returned.

    If this is a request on a device other than the gControlDeviceObject,
    the function will return the value of IoTestPassThrough().

--*/
{
    ULONG status = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpStack;
    
    if (DeviceObject == gControlDeviceObject) {

        //
        //  A request is being made on our device object, gControlDeviceObject.
        //

        Irp->IoStatus.Information = 0;
    
        irpStack = IoGetCurrentIrpStackLocation( Irp );
       
        switch (irpStack->MajorFunction) {
        case IRP_MJ_DEVICE_CONTROL:

            //
            //  This is a private device control irp for our control device.
            //  Pass the parameter information along to the common routine
            //  use to service these requests.
            //
            
            status = IoTestCommonDeviceIoControl( irpStack->Parameters.DeviceIoControl.Type3InputBuffer,
                                               irpStack->Parameters.DeviceIoControl.InputBufferLength,
                                               Irp->UserBuffer,
                                               irpStack->Parameters.DeviceIoControl.OutputBufferLength,
                                               irpStack->Parameters.DeviceIoControl.IoControlCode,
                                               &Irp->IoStatus,
                                               irpStack->DeviceObject );
            break;

        case IRP_MJ_CLEANUP:
        
            //
            //  This is the cleanup that we will see when all references to a handle
            //  opened to filespy's control device object are cleaned up.  We don't
            //  have to do anything here since we wait until the actual IRP_MJ_CLOSE
            //  to clean up the name cache.  Just complete the IRP successfully.
            //

            status = STATUS_SUCCESS;

            break;
                
        default:

            status = STATUS_INVALID_DEVICE_REQUEST;
        }

        Irp->IoStatus.Status = status;

        //
        //  We have completed all processing for this IRP, so tell the 
        //  I/O Manager.  This IRP will not be passed any further down
        //  the stack since no drivers below IoTest care about this 
        //  I/O operation that was directed to IoTest.
        //

        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return status;
    }

    return IoTestPassThrough( DeviceObject, Irp );
}

NTSTATUS
IoTestCreate (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
)
/*++

Routine Description:

    This is the routine that is associated with IRP_MJ_CREATE irp.  If the 
    DeviceObject is the ControlDevice, we do the creation work for the 
    ControlDevice and complete the irp.  Otherwise, we pass through
    this irp for another device to complete.
    
    Note: Some of the code in this function duplicates the functions 
        IoTestDispatch and IoTestPassThrough, but a design decision was made that 
        it was worth the code duplication to break out the irp handlers 
        that can be pagable code.
    
Arguments:

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.
        
    Irp - Pointer to the request packet representing the I/O request.
    
Return Value:

    If DeviceObject == gControlDeviceObject, then this function will 
    complete the Irp and return the status of that completion.  Otherwise,
    this function returns the result of calling IoTestPassThrough.
    
--*/
{
    PIO_STACK_LOCATION currentIrpSp;
    KIRQL oldIrql;

    //
    //  See if they want to open the control device object for the filter.
    //  This will only allow one thread to have this object open at a time.
    //  All other requests will be failed.
    //

    if (DeviceObject == gControlDeviceObject) {
        ULONG status;

        //
        //  A CREATE request is being made on our gControlDeviceObject.
        //  See if someone else has it open.  If so, disallow this open.
        //

        KeAcquireSpinLock( &gControlDeviceStateLock, &oldIrql );

        if (gControlDeviceState != CLOSED) {

            Irp->IoStatus.Status = STATUS_DEVICE_ALREADY_ATTACHED;
            Irp->IoStatus.Information = 0;

        } else {

            Irp->IoStatus.Status = STATUS_SUCCESS;
            Irp->IoStatus.Information = FILE_OPENED;

            gControlDeviceState = OPENED;
        }

        KeReleaseSpinLock( &gControlDeviceStateLock, oldIrql );

        //
        // Since this is our gControlDeviceObject, we complete the
        // irp here.
        //

        status = Irp->IoStatus.Status;

        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return status;
    }

    ASSERT( IS_IOTEST_DEVICE_OBJECT( DeviceObject ) );

    //
    //
    // This is a CREATE so we need to invalidate the name currently
    // stored in the name cache for this FileObject.  We need to do
    // this as long as our ControlDevice is open so that we keep the
    // name cache up-to-date.
    //

    currentIrpSp = IoGetCurrentIrpStackLocation( Irp );

    if (OPENED == gControlDeviceState) {

        IoTestNameDelete(currentIrpSp->FileObject);
    }

    //
    // This is NOT our gControlDeviceObject, so let IoTestPassThrough handle
    // it appropriately
    //

    return IoTestPassThrough( DeviceObject, Irp );
}


NTSTATUS
IoTestClose (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This is the routine that is associated with IRP_MJ_CLOSE irp.  If the 
    DeviceObject is the ControlDevice, we do the necessary cleanup and
    complete the irp.  Otherwise, we pass through this irp for another device
    to complete.
    
Arguments:

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.
        
    Irp - Pointer to the request packet representing the I/O request.
    
Return Value:

    If DeviceObject == gControlDeviceObject, then this function will 
    complete the Irp and return the status of that completion.  Otherwise,
    this function returns the result of calling IoTestPassThrough.
    
--*/
{
    PFILE_OBJECT savedFileObject;
    NTSTATUS status;
 
    PAGED_CODE();

    //
    //  See if they are closing the control device object for the filter.
    //

    if (DeviceObject == gControlDeviceObject) {

        //
        //  A CLOSE request is being made on our gControlDeviceObject.
        //  Cleanup state.
        //

        IoTestCloseControlDevice();

        //
        //  We have completed all processing for this IRP, so tell the 
        //  I/O Manager.  This IRP will not be passed any further down
        //  the stack since no drivers below IoTest care about this 
        //  I/O operation that was directed to IoTest.
        //

        Irp->IoStatus.Status = STATUS_SUCCESS;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return STATUS_SUCCESS;
    }

    ASSERT( IS_IOTEST_DEVICE_OBJECT( DeviceObject ) );
 
    //
    //  Save a pointer to the file object we are closing so we can remove
    //  the name from our cache after we have completed the operation.
    //

    savedFileObject = IoGetCurrentIrpStackLocation(Irp)->FileObject;

    //
    //  Log (if it is turned on) and pass the request on.
    //

    status = IoTestPassThrough( DeviceObject, Irp );
    
    //
    // See if the FileObject's name is being
    // cached and remove it from the cache if it is.  We want to do this
    // as long as the ControlDevice is opened so that we purge the
    // cache as accurately as possible.
    //
 
    if (OPENED == gControlDeviceState) {
 
        IoTestNameDelete( savedFileObject );
    }
 
 
    return status;
}


//
//  Structures used to transfer context from IoTestFsControl to the associated
//  completion routine.  We needed this because we needed to pass allocated
//  LOGGING structure to the completion routine
//

typedef struct FS_CONTROL_COMPLETION_CONTEXT {
    PKEVENT WaitEvent;
    PRECORD_LIST RecordList;
    MINI_DEVICE_STACK DeviceObjects;
} FS_CONTROL_COMPLETION_CONTEXT, *PFS_CONTROL_COMPLETION_CONTEXT;



NTSTATUS
IoTestFsControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is invoked whenever an I/O Request Packet (IRP) w/a major
    function code of IRP_MJ_FILE_SYSTEM_CONTROL is encountered.  For most
    IRPs of this type, the packet is simply passed through.  However, for
    some requests, special processing is required.

Arguments:

    DeviceObject - Pointer to the device object for this driver.

    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

--*/

{
    PIOTEST_DEVICE_EXTENSION devExt = DeviceObject->DeviceExtension;
    PIOTEST_DEVICE_EXTENSION newDevExt;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation( Irp );
    PRECORD_LIST recordList = NULL;
    KEVENT waitEvent;
    NTSTATUS status;
    PVPB vpb;
    FS_CONTROL_COMPLETION_CONTEXT completionContext;

    PAGED_CODE();

    //
    //  If this is for our control device object, fail the operation
    //

    if (gControlDeviceObject == DeviceObject) {

        //
        //  If this device object is our control device object rather than 
        //  a mounted volume device object, then this is an invalid request.
        //

        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest( Irp, IO_NO_INCREMENT );

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    ASSERT(IS_IOTEST_DEVICE_OBJECT( DeviceObject ));

    //
    //  Begin by determining the minor function code for this file system control
    //  function.
    //

    if (irpSp->MinorFunction == IRP_MN_MOUNT_VOLUME) {

        //
        //  This is a mount request.  Create a device object that can be
        //  attached to the file system's volume device object if this request
        //  is successful.  We allocate this memory now since we can not return
        //  an error in the completion routine.
        //

        status = IoTestCreateDeviceObjects( DeviceObject, 
                                            irpSp->Parameters.MountVolume.Vpb->RealDevice, 
                                            &(completionContext.DeviceObjects) );
        
        if (NT_SUCCESS( status )) {

            //
            //  Since we have our own private completion routine we need to
            //  do our own logging of this operation, do it now.
            //

            if (SHOULD_LOG( DeviceObject )) {

                //
                // The ControlDevice is opened, so allocate the Record 
                // and log the Irp information if we have the memory.
                //

                recordList = IoTestNewRecord(0);

                if (recordList) {

                    IoTestLogIrp( Irp, LOG_ORIGINATING_IRP, recordList );
                }
            }

            //
            //  Get a new IRP stack location and set our mount completion
            //  routine.  Pass along the address of the device object we just
            //  created as its context.
            //

            KeInitializeEvent( &waitEvent, SynchronizationEvent, FALSE );

            IoCopyCurrentIrpStackLocationToNext( Irp );

            completionContext.WaitEvent = &waitEvent;
            completionContext.RecordList = recordList;

            IoSetCompletionRoutine( Irp,
                                    IoTestMountCompletion,
                                    &completionContext,     //context parameter
                                    TRUE,
                                    TRUE,
                                    TRUE );

            //
            //  Call the driver
            //

            status = IoCallDriver( devExt->AttachedToDeviceObject, Irp );

            //
            //  Wait for the completion routine to be called
            //

	        if (STATUS_PENDING == status) {

		        NTSTATUS localStatus = KeWaitForSingleObject(&waitEvent, Executive, KernelMode, FALSE, NULL);
		        ASSERT(STATUS_SUCCESS == localStatus);
	        }

            //
            //  Get the correct VPB from the real device object saved in our
            //  device extension.  We do this because the VPB in the IRP stack
            //  may not be the correct VPB when we get here.  The underlying
            //  file system may change VPBs if it detects a volume it has
            //  mounted previously.
            //

            newDevExt = completionContext.DeviceObjects.Bottom->DeviceExtension;
            vpb = newDevExt->DiskDeviceObject->Vpb;

            //
            //  If the operation succeeded and we are not alreayd attached,
            //  attach to the device object.
            //

            if (NT_SUCCESS( Irp->IoStatus.Status ) && 
                !IoTestIsAttachedToDevice( TOP_FILTER, vpb->DeviceObject, NULL )) {

                //
                //  The FileSystem has successfully completed the mount, which means
                //  it has created the DeviceObject to which we want to attach.  The
                //  Irp parameters contain the Vpb which allows us to get to the
                //  following two things:
                //      1. The device object created by the file system to represent
                //         the volume it just mounted.
                //      2. The device object of the StorageDeviceObject which we
                //         can use to get the name of this volume.  We will pass
                //         this into IoTestAttachToMountedDevice so that it can
                //         use it at needed.
                //

                status = IoTestAttachDeviceObjects( &(completionContext.DeviceObjects),
                                                    vpb->DeviceObject,
                                                    newDevExt->DiskDeviceObject );

                //
                //  This should never fail.
                //
        
                ASSERT( NT_SUCCESS( status ) );

            } else {

                //
                //  Display why mount failed.  Setup the buffers.
                //

                if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_DISPLAY_ATTACHMENT_NAMES )) {

                    RtlInitEmptyUnicodeString( &newDevExt->DeviceNames, 
                                               newDevExt->DeviceNamesBuffer, 
                                               sizeof( newDevExt->DeviceNamesBuffer ) );
                    IoTestGetObjectName( vpb->RealDevice, &newDevExt->DeviceNames );

                    if (!NT_SUCCESS( Irp->IoStatus.Status )) {

                        DbgPrint( "IOTEST (IoTestMountCompletion): Mount volume failure for      \"%wZ\", status=%08x\n",
                                  &newDevExt->DeviceNames,
                                  Irp->IoStatus.Status );

                    } else {

                        DbgPrint( "IOTEST (IoTestMountCompletion): Mount volume failure for      \"%wZ\", already attached\n",
                                  &newDevExt->DeviceNames );
                    }
                }
            }

            //
            //  Continue processing the operation
            //

            status = Irp->IoStatus.Status;

            IoCompleteRequest( Irp, IO_NO_INCREMENT );

            return status;

        } else {

            IOTEST_DBG_PRINT1( IOTESTDEBUG_ERROR,
                                "IOTEST (IoTestFsControl): Error creating volume device object, status=%08x\n", 
                                status );

            //
            //  Something went wrong so this volume cannot be filtered.  Simply
            //  allow the system to continue working normally, if possible.
            //

            return IoTestPassThrough( DeviceObject, Irp );
        }

    } else if (irpSp->MinorFunction == IRP_MN_LOAD_FILE_SYSTEM) {

        //
        //  This is a "load file system" request being sent to a file system
        //  recognizer device object.  This IRP_MN code is only sent to 
        //  file system recognizers.
        //

        IOTEST_DBG_PRINT1( IOTESTDEBUG_DISPLAY_ATTACHMENT_NAMES,
                            "IOTEST (IoTestFsControl): Loading File System, Detaching from \"%wZ\"\n",
                            &devExt->DeviceNames );

        //
        //  Since we have our own private completion routine we need to
        //  do our own logging of this operation, do it now.
        //

        if (SHOULD_LOG( DeviceObject )) {

            //
            // The ControlDevice is opened, so allocate the Record 
            // and log the Irp information if we have the memory.
            //

            recordList = IoTestNewRecord(0);

            if (recordList) {

                IoTestLogIrp( Irp, LOG_ORIGINATING_IRP, recordList );
            }
        }

        //
        //  Set a completion routine so we can delete the device object when
        //  the detach is complete.
        //

        KeInitializeEvent( &waitEvent, SynchronizationEvent, FALSE );

        IoCopyCurrentIrpStackLocationToNext( Irp );

        completionContext.WaitEvent = &waitEvent;
        completionContext.RecordList = recordList;

        IoSetCompletionRoutine(
            Irp,
            IoTestLoadFsCompletion,
            &completionContext,
            TRUE,
            TRUE,
            TRUE );

        //
        //  Detach from the recognizer device.
        //

        IoDetachDevice( devExt->AttachedToDeviceObject );

        //
        //  Call the driver
        //

        status = IoCallDriver( devExt->AttachedToDeviceObject, Irp );

        //
        //  Wait for the completion routine to be called
        //

	    if (STATUS_PENDING == status) {

		    NTSTATUS localStatus = KeWaitForSingleObject(&waitEvent, Executive, KernelMode, FALSE, NULL);
		    ASSERT(STATUS_SUCCESS == localStatus);
	    }

        //
        //  Display the name if requested
        //

        IOTEST_DBG_PRINT2( IOTESTDEBUG_DISPLAY_ATTACHMENT_NAMES,
                            "IOTEST (IoTestLoadFsCompletion): Detaching from recognizer  \"%wZ\", status=%08x\n",
                            &devExt->DeviceNames,
                            Irp->IoStatus.Status );

        //
        //  Check status of the operation
        //

        if (!NT_SUCCESS( Irp->IoStatus.Status )) {

            //
            //  The load was not successful.  Simply reattach to the recognizer
            //  driver in case it ever figures out how to get the driver loaded
            //  on a subsequent call.
            //

            IoAttachDeviceToDeviceStack( DeviceObject, devExt->AttachedToDeviceObject );

        } else {

            //
            //  The load was successful, delete the Device object attached to the
            //  recognizer.
            //

            IoTestCleanupMountedDevice( DeviceObject );
            IoDeleteDevice( DeviceObject );
        }

        //
        //  Continue processing the operation
        //

        status = Irp->IoStatus.Status;

        IoCompleteRequest( Irp, IO_NO_INCREMENT );

        return status;

    } else {

        //
        //  Simply pass this file system control request through.
        //

        return IoTestPassThrough( DeviceObject, Irp );
    }
}

#if 0
NTSTATUS
IoTestSetInformation (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    ASSERT( IS_IOTEST_DEVICE_OBJECT( DeviceObject ) );

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //

    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_IRP_OPS )) {

        IoTestDumpIrpOperation( TRUE, Irp );
    }

    //
    //  See if we should log this IRP
    //

    if (SHOULD_LOG( DeviceObject )) {
        PRECORD_LIST recordList;

        //
        // The ControlDevice is opened, so allocate the Record 
        // and log the Irp information if we have the memory.
        //

        recordList = IoTestNewRecord(0);

        if (recordList) {

            IoTestLogIrp( Irp, LOG_ORIGINATING_IRP, recordList );

            //
            //  Since we are logging this operation, we want to 
            //  call our completion routine.
            //

            IoCopyCurrentIrpStackLocationToNext( Irp );
            IoSetCompletionRoutine( Irp,
                                    IoTestPassThroughCompletion,
                                    (PVOID)recordList,
                                    TRUE,
                                    TRUE,
                                    TRUE);
        } else {

            //
            //  We could not get a record to log with so get this driver out
            //  of the driver stack and get to the next driver as quickly as
            //  possible.
            //

            IoSkipCurrentIrpStackLocation( Irp );
        }

    } else {

        //
        //  We are not logging so get this driver out of the driver stack and
        //  get to the next driver as quickly as possible.
        //

        IoSkipCurrentIrpStackLocation( Irp );
    }

    //
    // Now call the next file system driver with the request.
    //

    return IoCallDriver( ((PIOTEST_DEVICE_EXTENSION)DeviceObject->DeviceExtension)->AttachedToDeviceObject, Irp );
}
#endif

NTSTATUS
IoTestMountCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is invoked for the completion of a mount request.  If the
    mount was successful, then this file system attaches its device object to
    the file system's volume device object.  Otherwise, the interim device
    object is deleted.

Arguments:

    DeviceObject - Pointer to this driver's device object that was attached to
            the file system device object

    Irp - Pointer to the IRP that was just completed.

    Context - Pointer to the device object allocated during the down path so
            we wouldn't have to deal with errors here.

Return Value:

    The return value is always STATUS_SUCCESS.

--*/

{
    PKEVENT event = ((PFS_CONTROL_COMPLETION_CONTEXT)Context)->WaitEvent;
    PRECORD_LIST recordList = ((PFS_CONTROL_COMPLETION_CONTEXT)Context)->RecordList;

    ASSERT(IS_IOTEST_DEVICE_OBJECT( DeviceObject ));

    //
    //  Log the completion routine
    //

    if (SHOULD_LOG( DeviceObject )) {

        IoTestLogIrp( Irp, LOG_COMPLETION_IRP, recordList );
        
        //
        //  Add recordList to our gOutputBufferList so that it gets up to 
        //  the user
        //
        
        IoTestLog( recordList );       

    } else {

        if (recordList) {

            //
            //  Context is set with a RECORD_LIST, but we are no longer
            //  logging so free this record.
            //

            IoTestFreeRecord( recordList );
        }
    }

    //
    //  If an event routine is defined, signal it
    //

    KeSetEvent(event, IO_NO_INCREMENT, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
IoTestLoadFsCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is invoked upon completion of an FSCTL function to load a
    file system driver (as the result of a file system recognizer seeing
    that an on-disk structure belonged to it).  A device object has already
    been created by this driver (DeviceObject) so that it can be attached to
    the newly loaded file system.

Arguments:

    DeviceObject - Pointer to this driver's device object.

    Irp - Pointer to the I/O Request Packet representing the file system
          driver load request.

    Context - Context parameter for this driver, unused.

Return Value:

    The function value for this routine is always success.

--*/

{
    PKEVENT event = ((PFS_CONTROL_COMPLETION_CONTEXT)Context)->WaitEvent;
    PRECORD_LIST recordList = ((PFS_CONTROL_COMPLETION_CONTEXT)Context)->RecordList;

    ASSERT(IS_IOTEST_DEVICE_OBJECT( DeviceObject ));

    //
    //  Log the completion routine
    //

    if (SHOULD_LOG( DeviceObject )) {

        IoTestLogIrp( Irp, LOG_COMPLETION_IRP, recordList );
        
        //
        //  Add recordList to our gOutputBufferList so that it gets up to 
        //  the user
        //
        
        IoTestLog( recordList );       

    } else {

        if (recordList) {

            //
            //  Context is set with a RECORD_LIST, but we are no longer
            //  logging so free this record.
            //

            IoTestFreeRecord( recordList );
        }
    }

    //
    //  If an event routine is defined, signal it
    //

    KeSetEvent(event, IO_NO_INCREMENT, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}


BOOLEAN
IoTestFastIoCheckIfPossible (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN BOOLEAN CheckForReadOperation,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for checking to see
    whether fast I/O is possible for this file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be operated on.

    FileOffset - Byte offset in the file for the operation.

    Length - Length of the operation to be performed.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    LockKey - Provides the caller's key for file locks.

    CheckForReadOperation - Indicates whether the caller is checking for a
        read (TRUE) or a write operation.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.
    
--*/
{
    PDEVICE_OBJECT    deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN           returnValue = FALSE;
    PRECORD_LIST      recordList;
    BOOLEAN           shouldLog;
    
    PAGED_CODE();

    ASSERT( IS_IOTEST_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( TRUE, CHECK_IF_POSSIBLE );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = IoTestLogFastIoStart( CHECK_IF_POSSIBLE,
                                        DeviceObject,
                                        FileObject,
                                        FileOffset,
                                        Length,
                                        Wait );
        if (recordList != NULL) {
            
            IoTestLog(recordList);
        }
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PIOTEST_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        //
        //  We have a valid DeviceObject, so look at its FastIoDispatch
        //  table for the next driver's Fast IO routine.
        //

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoCheckIfPossible )) {

            returnValue = (fastIoDispatch->FastIoCheckIfPossible)( FileObject,
                                                                   FileOffset,
                                                                   Length,
                                                                   Wait,
                                                                   LockKey,
                                                                   CheckForReadOperation,
                                                                   IoStatus,
                                                                   deviceObject);
        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( FALSE, CHECK_IF_POSSIBLE );
    }
    
    return returnValue;
}

BOOLEAN
IoTestFastIoRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for reading from a
    file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be read.

    FileOffset - Byte offset in the file of the read.

    Length - Length of the read operation to be performed.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    LockKey - Provides the caller's key for file locks.

    Buffer - Pointer to the caller's buffer to receive the data read.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN returnValue = FALSE;
    PRECORD_LIST recordList;
    BOOLEAN shouldLog;

    PAGED_CODE();

    ASSERT( IS_IOTEST_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( TRUE, READ );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = IoTestLogFastIoStart( READ, 
                                        DeviceObject,
                                        FileObject, 
                                        FileOffset, 
                                        Length, 
                                        Wait );
        if (recordList != NULL) {
            
            IoTestLog(recordList);
        }
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PIOTEST_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoRead )) {

            returnValue = (fastIoDispatch->FastIoRead)( FileObject,
                                                        FileOffset,
                                                        Length,
                                                        Wait,
                                                        LockKey,
                                                        Buffer,
                                                        IoStatus,
                                                        deviceObject);
        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( FALSE, READ );
    }
    
    return returnValue;
}

BOOLEAN
IoTestFastIoWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for writing to a
    file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be written.

    FileOffset - Byte offset in the file of the write operation.

    Length - Length of the write operation to be performed.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    LockKey - Provides the caller's key for file locks.

    Buffer - Pointer to the caller's buffer that contains the data to be
        written.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    PAGED_CODE();

    ASSERT( IS_IOTEST_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( TRUE, WRITE );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = IoTestLogFastIoStart( WRITE,
                                        DeviceObject,
                                        FileObject,
                                        FileOffset,
                                        Length,
                                        Wait );
        if (recordList != NULL) {
            
            IoTestLog(recordList);
        }
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PIOTEST_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoWrite )) {

            returnValue = (fastIoDispatch->FastIoWrite)( FileObject,
                                                         FileOffset,
                                                         Length,
                                                         Wait,
                                                         LockKey,
                                                         Buffer,
                                                         IoStatus,
                                                         deviceObject);
        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( FALSE, WRITE );
    }
    
    return returnValue;
}
 
BOOLEAN
IoTestFastIoQueryBasicInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_BASIC_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for querying basic
    information about the file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be queried.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    Buffer - Pointer to the caller's buffer to receive the information about
        the file.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN returnValue = FALSE;
    PRECORD_LIST recordList;
    BOOLEAN shouldLog;

    PAGED_CODE();

    ASSERT( IS_IOTEST_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( TRUE, QUERY_BASIC_INFO );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = IoTestLogFastIoStart( QUERY_BASIC_INFO,
                                        DeviceObject,
                                        FileObject,
                                        NULL,
                                        0,
                                        Wait );
        if (recordList != NULL) {
            
            IoTestLog(recordList);
        }
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PIOTEST_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoQueryBasicInfo )) {

            returnValue = (fastIoDispatch->FastIoQueryBasicInfo)( FileObject,
                                                                  Wait,
                                                                  Buffer,
                                                                  IoStatus,
                                                                  deviceObject);
        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( FALSE, QUERY_BASIC_INFO );
    }
    
    return returnValue;
}
 
BOOLEAN
IoTestFastIoQueryStandardInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_STANDARD_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for querying standard
    information about the file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be queried.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    Buffer - Pointer to the caller's buffer to receive the information about
        the file.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    PAGED_CODE();

    ASSERT( IS_IOTEST_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( TRUE, QUERY_STANDARD_INFO );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = IoTestLogFastIoStart( QUERY_STANDARD_INFO,
                                        DeviceObject,
                                        FileObject,
                                        NULL,
                                        0,
                                        Wait );
        if (recordList != NULL) {
            
            IoTestLog(recordList);
        }
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PIOTEST_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;
    
    if (NULL != deviceObject) {
           
        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoQueryStandardInfo )) {

            returnValue = (fastIoDispatch->FastIoQueryStandardInfo)( FileObject,
                                                                     Wait,
                                                                     Buffer,
                                                                     IoStatus,
                                                                     deviceObject );

        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( FALSE, QUERY_STANDARD_INFO );
    }
    
    return returnValue;
}

BOOLEAN
IoTestFastIoLock (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    IN PEPROCESS ProcessId,
    IN ULONG Key,
    IN BOOLEAN FailImmediately,
    IN BOOLEAN ExclusiveLock,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for locking a byte
    range within a file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be locked.

    FileOffset - Starting byte offset from the base of the file to be locked.

    Length - Length of the byte range to be locked.

    ProcessId - ID of the process requesting the file lock.

    Key - Lock key to associate with the file lock.

    FailImmediately - Indicates whether or not the lock request is to fail
        if it cannot be immediately be granted.

    ExclusiveLock - Indicates whether the lock to be taken is exclusive (TRUE)
        or shared.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    PAGED_CODE();

    ASSERT( IS_IOTEST_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( TRUE, LOCK );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = IoTestLogFastIoStart( LOCK,
                                        DeviceObject,
                                        FileObject,
                                        FileOffset,
                                        0,
                                        0 );
        if (recordList != NULL) {
            
            IoTestLog(recordList);
        }
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PIOTEST_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoLock )) {

            returnValue = (fastIoDispatch->FastIoLock)( FileObject,
                                                        FileOffset,
                                                        Length,
                                                        ProcessId,
                                                        Key,
                                                        FailImmediately,
                                                        ExclusiveLock,
                                                        IoStatus,
                                                        deviceObject);

        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( FALSE, LOCK );
    }
    
    return returnValue;
}
 
BOOLEAN
IoTestFastIoUnlockSingle (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    IN PEPROCESS ProcessId,
    IN ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for unlocking a byte
    range within a file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be unlocked.

    FileOffset - Starting byte offset from the base of the file to be
        unlocked.

    Length - Length of the byte range to be unlocked.

    ProcessId - ID of the process requesting the unlock operation.

    Key - Lock key associated with the file lock.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    PAGED_CODE();

    ASSERT( IS_IOTEST_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( TRUE, UNLOCK_SINGLE );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = IoTestLogFastIoStart( UNLOCK_SINGLE,
                                        DeviceObject,
                                        FileObject,
                                        FileOffset,
                                        0,
                                        0 );
        if (recordList != NULL) {
            
            IoTestLog(recordList);
        }
    }


    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PIOTEST_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoUnlockSingle )) {

            returnValue = (fastIoDispatch->FastIoUnlockSingle)( FileObject,
                                                                FileOffset,
                                                                Length,
                                                                ProcessId,
                                                                Key,
                                                                IoStatus,
                                                                deviceObject);

        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( FALSE, UNLOCK_SINGLE );
    }
    
    return returnValue;
}
 
BOOLEAN
IoTestFastIoUnlockAll (
    IN PFILE_OBJECT FileObject,
    IN PEPROCESS ProcessId,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for unlocking all
    locks within a file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be unlocked.

    ProcessId - ID of the process requesting the unlock operation.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    PAGED_CODE();

    ASSERT( IS_IOTEST_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( TRUE, UNLOCK_ALL );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = IoTestLogFastIoStart( UNLOCK_ALL,
                                        DeviceObject,
                                        FileObject,
                                        NULL,
                                        0,
                                        0 );
        if (recordList != NULL) {
            
            IoTestLog(recordList);
        }
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PIOTEST_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoUnlockAll )) {

            returnValue = (fastIoDispatch->FastIoUnlockAll)( FileObject,
                                                             ProcessId,
                                                             IoStatus,
                                                             deviceObject);

        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( FALSE, UNLOCK_ALL );
    }
    
    return returnValue;
}

BOOLEAN
IoTestFastIoUnlockAllByKey (
    IN PFILE_OBJECT FileObject,
    IN PVOID ProcessId,
    IN ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for unlocking all
    locks within a file based on a specified key.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be unlocked.

    ProcessId - ID of the process requesting the unlock operation.

    Key - Lock key associated with the locks on the file to be released.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    PAGED_CODE();

    ASSERT( IS_IOTEST_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( TRUE, UNLOCK_ALL_BY_KEY );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = IoTestLogFastIoStart( UNLOCK_ALL_BY_KEY,
                                        DeviceObject,
                                        FileObject,
                                        NULL,
                                        0,
                                        0 );
        if (recordList != NULL) {
            
            IoTestLog(recordList);
        }
    }

    //
    // Pass through logic for this type of Fast I/O
    //
    
    deviceObject = ((PIOTEST_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoUnlockAllByKey )) {

            returnValue = (fastIoDispatch->FastIoUnlockAllByKey)( FileObject,
                                                                  ProcessId,
                                                                  Key,
                                                                  IoStatus,
                                                                  deviceObject);
        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( FALSE, UNLOCK_ALL_BY_KEY );
    }
    
    return returnValue;
}

BOOLEAN
IoTestFastIoDeviceControl (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for device I/O 
    control operations on a file.
    
    If this I/O is directed to gControlDevice, then the parameters specify
    control commands to IoTest.  These commands are interpreted and handled
    appropriately.

    If this is I/O directed at another DriverObject, this function simply 
    invokes the next driver's corresponding routine, or returns FALSE if 
    the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object representing the device to be
        serviced.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    InputBuffer - Optional pointer to a buffer to be passed into the driver.

    InputBufferLength - Length of the optional InputBuffer, if one was
        specified.

    OutputBuffer - Optional pointer to a buffer to receive data from the
        driver.

    OutputBufferLength - Length of the optional OutputBuffer, if one was
        specified.

    IoControlCode - I/O control code indicating the operation to be performed
        on the device.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

Notes:

    This function does not check the validity of the input/output buffers because
    the ioctl's are implemented as METHOD_BUFFERED.  In this case, the I/O manager
    does the buffer validation checks for us.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    PAGED_CODE();

    //
    // Get a pointer to the current location in the Irp. This is where
    // the function codes and parameters are located.
    //

    if (DeviceObject == gControlDeviceObject) {

        IoTestCommonDeviceIoControl( InputBuffer,
                                     InputBufferLength,
                                     OutputBuffer,
                                     OutputBufferLength,
                                     IoControlCode,
                                     IoStatus,
                                     DeviceObject );

        returnValue = TRUE;

    } else {

        ASSERT( IS_IOTEST_DEVICE_OBJECT( DeviceObject ) );

        //
        //  If the specified debug level is set, output what operation
        //  we are seeing to the debugger.
        //
        
        if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

            IoTestDumpFastIoOperation( TRUE, DEVICE_CONTROL );
        }
        
        //
        //  Perform filespy logging if we care about this device.
        //
        
        if (shouldLog = SHOULD_LOG(DeviceObject)) {

            //
            //
            // Log the necessary information for the start of the Fast I/O 
            // operation
            //

            recordList = IoTestLogFastIoStart( DEVICE_CONTROL,
                                            DeviceObject,
                                            FileObject,
                                            NULL,
                                            0,
                                            Wait );
            if (recordList != NULL) {
                
                IoTestLog(recordList);
            }
        }

        deviceObject = ((PIOTEST_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

        if (NULL != deviceObject) {

            fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

            if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoDeviceControl )) {

                returnValue = (fastIoDispatch->FastIoDeviceControl)( FileObject,
                                                                     Wait,
                                                                     InputBuffer,
                                                                     InputBufferLength,
                                                                     OutputBuffer,
                                                                     OutputBufferLength,
                                                                     IoControlCode,
                                                                     IoStatus,
                                                                     deviceObject);

            } else {

                IoStatus->Status = STATUS_SUCCESS;
            }
        }

        //
        //  If the specified debug level is set, output what operation
        //  we are seeing to the debugger.
        //
        
        if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

            IoTestDumpFastIoOperation( FALSE, DEVICE_CONTROL );
        }
    }
        
    return returnValue;
}


VOID
IoTestFastIoDetachDevice (
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice
)
/*++

Routine Description:

    This routine is invoked on the fast path to detach from a device that
    is being deleted.  This occurs when this driver has attached to a file
    system volume device object, and then, for some reason, the file system
    decides to delete that device (it is being dismounted, it was dismounted
    at some point in the past and its last reference has just gone away, etc.)

Arguments:

    SourceDevice - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

    TargetDevice - Pointer to the file system's volume device object.

Return Value:

    None.
    
--*/
{
    PRECORD_LIST recordList;
    BOOLEAN shouldLog;
    PIOTEST_DEVICE_EXTENSION devext;

    PAGED_CODE();

    ASSERT( IS_IOTEST_DEVICE_OBJECT( SourceDevice ) );

    devext = SourceDevice->DeviceExtension;

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( TRUE, DETACH_DEVICE );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(SourceDevice)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = IoTestLogFastIoStart( DETACH_DEVICE, 
                                        SourceDevice, 
                                        NULL, 
                                        NULL, 
                                        0, 
                                        0 );
        if (recordList != NULL) {
            
            IoTestLog(recordList);
        }
    }

    IOTEST_DBG_PRINT1( IOTESTDEBUG_DISPLAY_ATTACHMENT_NAMES,
                        "IOTEST (IoTestFastIoDetachDevice): Detaching from volume      \"%wZ\"\n",
                        &devext->DeviceNames );

    //
    // Detach from the file system's volume device object.
    //

    IoTestCleanupMountedDevice( SourceDevice );
    IoDetachDevice( TargetDevice );
    IoDeleteDevice( SourceDevice );

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( FALSE, DETACH_DEVICE );
    }
}
 
BOOLEAN
IoTestFastIoQueryNetworkOpenInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for querying network
    information about a file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be queried.

    Wait - Indicates whether or not the caller can handle the file system
        having to wait and tie up the current thread.

    Buffer - Pointer to a buffer to receive the network information about the
        file.

    IoStatus - Pointer to a variable to receive the final status of the query
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    PAGED_CODE();

    ASSERT( IS_IOTEST_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( TRUE, QUERY_NETWORK_OPEN_INFO );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = IoTestLogFastIoStart( QUERY_NETWORK_OPEN_INFO,
                                        DeviceObject,
                                        FileObject,
                                        NULL,
                                        0,
                                        Wait );
        if (recordList != NULL) {
            
            IoTestLog(recordList);
        }
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PIOTEST_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoQueryNetworkOpenInfo )) {

            returnValue = (fastIoDispatch->FastIoQueryNetworkOpenInfo)( FileObject,
                                                                        Wait,
                                                                        Buffer,
                                                                        IoStatus,
                                                                        deviceObject);

        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( FALSE, QUERY_NETWORK_OPEN_INFO );
    }
    
    return returnValue;
}

BOOLEAN
IoTestFastIoMdlRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for reading a file
    using MDLs as buffers.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object that is to be read.

    FileOffset - Supplies the offset into the file to begin the read operation.

    Length - Specifies the number of bytes to be read from the file.

    LockKey - The key to be used in byte range lock checks.

    MdlChain - A pointer to a variable to be filled in w/a pointer to the MDL
        chain built to describe the data read.

    IoStatus - Variable to receive the final status of the read operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    PAGED_CODE();

    ASSERT( IS_IOTEST_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( TRUE, MDL_READ );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = IoTestLogFastIoStart( MDL_READ,
                                        DeviceObject,
                                        FileObject,                  
                                        FileOffset,                  
                                        Length,
                                        0 );
        if (recordList != NULL) {
            
            IoTestLog(recordList);
        }
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PIOTEST_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlRead )) {

            returnValue = (fastIoDispatch->MdlRead)( FileObject,
                                                     FileOffset,
                                                     Length,
                                                     LockKey,
                                                     MdlChain,
                                                     IoStatus,
                                                     deviceObject);
        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( FALSE, MDL_READ );
    }

    return returnValue;
}
 
BOOLEAN
IoTestFastIoMdlReadComplete (
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for completing an
    MDL read operation.

    This function simply invokes the next driver's corresponding routine, if
    it has one.  It should be the case that this routine is invoked only if
    the MdlRead function is supported by the underlying driver, and
    therefore this function will also be supported, but this is not assumed
    by this driver.

Arguments:

    FileObject - Pointer to the file object to complete the MDL read upon.

    MdlChain - Pointer to the MDL chain used to perform the read operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.
    
--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    ASSERT( IS_IOTEST_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( TRUE, MDL_READ_COMPLETE );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = IoTestLogFastIoStart( MDL_READ_COMPLETE,
                                        DeviceObject,
                                        FileObject,
                                        NULL,
                                        0,
                                        0 );
        if (recordList != NULL) {
            
            IoTestLog(recordList);
        }
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PIOTEST_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlReadComplete )) {

            returnValue = (fastIoDispatch->MdlReadComplete)( FileObject,
                                                             MdlChain,
                                                             deviceObject);
        } 
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( FALSE, MDL_READ_COMPLETE );
    }
    
    return returnValue;
}
 
BOOLEAN
IoTestFastIoPrepareMdlWrite (
    IN  PFILE_OBJECT FileObject,
    IN  PLARGE_INTEGER FileOffset,
    IN  ULONG Length,
    IN  ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN  PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for preparing for an
    MDL write operation.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object that will be written.

    FileOffset - Supplies the offset into the file to begin the write 
        operation.

    Length - Specifies the number of bytes to be write to the file.

    LockKey - The key to be used in byte range lock checks.

    MdlChain - A pointer to a variable to be filled in w/a pointer to the MDL
        chain built to describe the data written.

    IoStatus - Variable to receive the final status of the write operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

// ISSUE-2000-04-26-mollybro Check if this will get an IRP if FALSE is returned 

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    PAGED_CODE();

    ASSERT( IS_IOTEST_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( TRUE, PREPARE_MDL_WRITE );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = IoTestLogFastIoStart( PREPARE_MDL_WRITE,
                                        DeviceObject,
                                        FileObject,
                                        FileOffset,
                                        Length,
                                        0 );
        if (recordList != NULL) {
            
            IoTestLog(recordList);
        }
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PIOTEST_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, PrepareMdlWrite )) {

            returnValue = (fastIoDispatch->PrepareMdlWrite)( FileObject,
                                                             FileOffset,
                                                             Length,
                                                             LockKey,
                                                             MdlChain,
                                                             IoStatus,
                                                             deviceObject);
        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( FALSE, PREPARE_MDL_WRITE );
    }
    
    return returnValue;
}
 
BOOLEAN
IoTestFastIoMdlWriteComplete (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for completing an
    MDL write operation.

    This function simply invokes the next driver's corresponding routine, if
    it has one.  It should be the case that this routine is invoked only if
    the PrepareMdlWrite function is supported by the underlying file system,
    and therefore this function will also be supported, but this is not
    assumed by this driver.

Arguments:

    FileObject - Pointer to the file object to complete the MDL write upon.

    FileOffset - Supplies the file offset at which the write took place.

    MdlChain - Pointer to the MDL chain used to perform the write operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    ASSERT( IS_IOTEST_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( TRUE, MDL_WRITE_COMPLETE );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = IoTestLogFastIoStart( MDL_WRITE_COMPLETE,
                                        DeviceObject,
                                        FileObject,
                                        FileOffset,
                                        0,
                                        0 );
        if (recordList != NULL) {
            
            IoTestLog(recordList);
        }
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PIOTEST_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlWriteComplete )) {

            returnValue = (fastIoDispatch->MdlWriteComplete)( FileObject,
                                                              FileOffset,
                                                              MdlChain,
                                                              deviceObject);

        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( FALSE, MDL_WRITE_COMPLETE );
    }
    
    return returnValue;
}
 
BOOLEAN
IoTestFastIoReadCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    OUT struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for reading 
    compressed data from a file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object that will be read.

    FileOffset - Supplies the offset into the file to begin the read operation.

    Length - Specifies the number of bytes to be read from the file.

    LockKey - The key to be used in byte range lock checks.

    Buffer - Pointer to a buffer to receive the compressed data read.

    MdlChain - A pointer to a variable to be filled in w/a pointer to the MDL
        chain built to describe the data read.

    IoStatus - Variable to receive the final status of the read operation.

    CompressedDataInfo - A buffer to receive the description of the 
        compressed data.

    CompressedDataInfoLength - Specifies the size of the buffer described by
        the CompressedDataInfo parameter.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    PAGED_CODE();

    ASSERT( IS_IOTEST_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( TRUE, READ_COMPRESSED );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = IoTestLogFastIoStart( READ_COMPRESSED,
                                        DeviceObject,
                                        FileObject,
                                        FileOffset,
                                        Length,
                                        0 );
        if (recordList != NULL) {
            
            IoTestLog(recordList);
        }
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PIOTEST_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoReadCompressed )) {

            returnValue = (fastIoDispatch->FastIoReadCompressed)( FileObject,
                                                                  FileOffset,
                                                                  Length,
                                                                  LockKey,
                                                                  Buffer,
                                                                  MdlChain,
                                                                  IoStatus,
                                                                  CompressedDataInfo,
                                                                  CompressedDataInfoLength,
                                                                  deviceObject);
        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( FALSE, READ_COMPRESSED );
    }

    return returnValue;
}
 
BOOLEAN
IoTestFastIoWriteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for writing 
    compressed data to a file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object that will be written.

    FileOffset - Supplies the offset into the file to begin the write 
        operation.

    Length - Specifies the number of bytes to be write to the file.

    LockKey - The key to be used in byte range lock checks.

    Buffer - Pointer to the buffer containing the data to be written.

    MdlChain - A pointer to a variable to be filled in w/a pointer to the MDL
        chain built to describe the data written.

    IoStatus - Variable to receive the final status of the write operation.

    CompressedDataInfo - A buffer to containing the description of the
        compressed data.

    CompressedDataInfoLength - Specifies the size of the buffer described by
        the CompressedDataInfo parameter.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    PAGED_CODE();

    ASSERT( IS_IOTEST_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( TRUE, WRITE_COMPRESSED );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //
        
        recordList = IoTestLogFastIoStart( WRITE_COMPRESSED,
                                        DeviceObject,
                                        FileObject,
                                        FileOffset,
                                        Length,
                                        0 );
        if (recordList != NULL) {
            
            IoTestLog(recordList);
        }
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PIOTEST_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoWriteCompressed )) {

            returnValue = (fastIoDispatch->FastIoWriteCompressed)( FileObject,
                                                                   FileOffset,
                                                                   Length,
                                                                   LockKey,
                                                                   Buffer,
                                                                   MdlChain,
                                                                   IoStatus,
                                                                   CompressedDataInfo,
                                                                   CompressedDataInfoLength,
                                                                   deviceObject);
        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( FALSE, WRITE_COMPRESSED );
    }
    
    return returnValue;
}
 
BOOLEAN
IoTestFastIoMdlReadCompleteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for completing an
    MDL read compressed operation.

    This function simply invokes the next driver's corresponding routine, if
    it has one.  It should be the case that this routine is invoked only if
    the read compressed function is supported by the underlying file system,
    and therefore this function will also be supported, but this is not 
    assumed by this driver.

Arguments:

    FileObject - Pointer to the file object to complete the compressed read
        upon.

    MdlChain - Pointer to the MDL chain used to perform the read operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.
    
--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    ASSERT( IS_IOTEST_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( TRUE, MDL_READ_COMPLETE_COMPRESSED );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = IoTestLogFastIoStart( MDL_READ_COMPLETE_COMPRESSED,
                                        DeviceObject,
                                        FileObject,
                                        NULL,
                                        0,
                                        0 );
        if (recordList != NULL) {
            
            IoTestLog(recordList);
        }
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PIOTEST_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlReadCompleteCompressed )) {

            returnValue = (fastIoDispatch->MdlReadCompleteCompressed)( FileObject,
                                                                       MdlChain,
                                                                       deviceObject);

        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( FALSE, MDL_READ_COMPLETE_COMPRESSED );
    }
    
    return returnValue;
}
 
BOOLEAN
IoTestFastIoMdlWriteCompleteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for completing a
    write compressed operation.

    This function simply invokes the next driver's corresponding routine, if
    it has one.  It should be the case that this routine is invoked only if
    the write compressed function is supported by the underlying file system,
    and therefore this function will also be supported, but this is not 
    assumed by this driver.

Arguments:

    FileObject - Pointer to the file object to complete the compressed write
        upon.

    FileOffset - Supplies the file offset at which the file write operation
        began.

    MdlChain - Pointer to the MDL chain used to perform the write operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN returnValue = FALSE;
    BOOLEAN shouldLog;

    ASSERT( IS_IOTEST_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( TRUE, MDL_WRITE_COMPLETE_COMPRESSED );
    }
    
    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = IoTestLogFastIoStart( MDL_WRITE_COMPLETE_COMPRESSED,
                                        DeviceObject,
                                        FileObject,
                                        FileOffset,
                                        0,
                                        0 );
        if (recordList != NULL) {
            
            IoTestLog(recordList);
        }
    }

    //
    // Pass through logic for this type of Fast I/O
    //
    
    deviceObject = ((PIOTEST_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlWriteCompleteCompressed )) {

            returnValue = (fastIoDispatch->MdlWriteCompleteCompressed)( FileObject,
                                                                        FileOffset, 
                                                                        MdlChain,
                                                                        deviceObject);

        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( FALSE, MDL_WRITE_COMPLETE_COMPRESSED );
    }
    
    return returnValue;
}
 
BOOLEAN
IoTestFastIoQueryOpen (
    IN PIRP Irp,
    OUT PFILE_NETWORK_OPEN_INFORMATION NetworkInformation,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for opening a file
    and returning network information it.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    Irp - Pointer to a create IRP that represents this open operation.  It is
        to be used by the file system for common open/create code, but not
        actually completed.

    NetworkInformation - A buffer to receive the information required by the
        network about the file being opened.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    PRECORD_LIST recordList;
    BOOLEAN result = FALSE;
    BOOLEAN shouldLog;

    PAGED_CODE();

    ASSERT( IS_IOTEST_DEVICE_OBJECT( DeviceObject ) );
    
    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( TRUE, QUERY_OPEN );
    }

    //
    //  Perform filespy logging if we care about this device.
    //
    
    if (shouldLog = SHOULD_LOG(DeviceObject)) {

        //
        // Log the necessary information for the start of the Fast I/O 
        // operation
        //

        recordList = IoTestLogFastIoStart( QUERY_OPEN,
                                        DeviceObject,
                                        NULL,
                                        NULL,
                                        0,
                                        0 );
        if (recordList != NULL) {
            
            IoTestLog(recordList);
        }
    }

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PIOTEST_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoQueryOpen )) {

            PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation( Irp );

            irpSp->DeviceObject = deviceObject;

            result = (fastIoDispatch->FastIoQueryOpen)( Irp,
                                                        NetworkInformation,
                                                        deviceObject );
            if (!result) {

                irpSp->DeviceObject = DeviceObject;
            }
        }
    }

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FAST_IO_OPS )) {

        IoTestDumpFastIoOperation( FALSE, QUERY_OPEN );
    }
    
    return result;
}

NTSTATUS
IoTestPreFsFilterOperation (
    IN PFS_FILTER_CALLBACK_DATA Data,
    OUT PVOID *CompletionContext
    )
/*++

Routine Description:

    This routine is the FS Filter pre-operation "pass through" routine.

Arguments:

    Data - The FS_FILTER_CALLBACK_DATA structure containing the information
        about this operation.
        
    CompletionContext - A context set by this operation that will be passed
        to the corresponding IoTestPostFsFilterOperation call.
        
Return Value:

    Returns STATUS_SUCCESS if the operation can continue or an appropriate
    error code if the operation should fail.

--*/
{

    PDEVICE_OBJECT deviceObject;
    PRECORD_LIST recordList = NULL;
    BOOLEAN shouldLog;

    UNREFERENCED_PARAMETER( CompletionContext );
    
    PAGED_CODE();

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //
    
    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FSFILTER_OPS )) {

        IoTestDumpFsFilterOperation( TRUE, Data );
    }

    deviceObject = Data->DeviceObject;

    ASSERT( IS_IOTEST_DEVICE_OBJECT( deviceObject ) );

    if (shouldLog = SHOULD_LOG( deviceObject )) {

        recordList = IoTestNewRecord(0);

        if (recordList != NULL) {

            //
            //  Log the necessary information for the start of this
            //  operation.
            //

            IoTestLogPreFsFilterOperation( Data, recordList );
            
            //
            //  Add recordList to our gOutputBufferList so that it gets up to 
            //  the user.  We don't have to worry about freeing the recordList
            //  at this time because it will get free when it is taken off
            //  gOutputBufferList.
            //

            IoTestLog(recordList);       
        }
    }

    return STATUS_SUCCESS;
}

VOID
IoTestPostFsFilterOperation (
    IN PFS_FILTER_CALLBACK_DATA Data,
    IN NTSTATUS OperationStatus,
    IN PVOID CompletionContext
    )
/*++

Routine Description:

    This routine is the FS Filter post-operation "pass through" routine.

Arguments:

    Data - The FS_FILTER_CALLBACK_DATA structure containing the information
        about this operation.
        
    OperationStatus - The status of this operation.        
    
    CompletionContext - A context that was set in the pre-operation 
        callback by this driver.
        
Return Value:

    None.
    
--*/
{

    PDEVICE_OBJECT deviceObject;

    PAGED_CODE();

    UNREFERENCED_PARAMETER( OperationStatus );
    UNREFERENCED_PARAMETER( CompletionContext );

    //
    //  If the specified debug level is set, output what operation
    //  we are seeing to the debugger.
    //

    if (FlagOn( gIoTestDebugLevel, IOTESTDEBUG_TRACE_FSFILTER_OPS )) {

        IoTestDumpFsFilterOperation( FALSE, Data );
    }

    deviceObject = Data->DeviceObject;

    ASSERT( IS_IOTEST_DEVICE_OBJECT( deviceObject ) );

#if 0
    if ((shouldLog = SHOULD_LOG( deviceObject )) &&
        (recordList != NULL)) {

        //
        //  Log the necessary information for the end of the Fast IO
        //  operation if we have a recordList.
        //

        IoTestLogPostFsFilterOperation( OperationStatus, recordList );

        //
        //  Add recordList to our gOutputBufferList so that it gets up to 
        //  the user.  We don't have to worry about freeing the recordList
        //  at this time because it will get free when it is taken off
        //  gOutputBufferList.
        //

        IoTestLog(recordList);       
        
    } else if (recordList != NULL) {

        //
        //  We are no longer logging for this device, so just
        //  free this recordList entry.
        //

        IoTestFreeRecord( recordList );
    }
#endif
}

NTSTATUS
IoTestCommonDeviceIoControl (
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This routine does the common processing of interpreting the Device IO Control
    request.

Arguments:

    FileObject - The file object related to this operation.
    
    InputBuffer - The buffer containing the input parameters for this control
        operation.
        
    InputBufferLength - The length in bytes of InputBuffer.
    
    OutputBuffer - The buffer to receive any output from this control operation.
    
    OutputBufferLength - The length in bytes of OutputBuffer.
    
    IoControlCode - The control code specifying what control operation this is.
    
    IoStatus - Receives the status of this operation.
    
    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.
        
Return Value:

    None.
    
--*/
{
    PWSTR deviceName = NULL;
    IOTESTVER fileIoTestVer;

    ASSERT( IoStatus != NULL );
    
    IoStatus->Status      = STATUS_SUCCESS;
    IoStatus->Information = 0;

    try {

        switch (IoControlCode) {
        case IOTEST_Reset:
            IoStatus->Status = STATUS_INVALID_PARAMETER;
            break;

        //
        //      Request to start logging on a device
        //                                      

        case IOTEST_StartLoggingDevice:

            if (InputBuffer == NULL || InputBufferLength <= 0) {

                IoStatus->Status = STATUS_INVALID_PARAMETER;
                break;
            }
            
            //
            // Copy the device name and add a null to ensure that it is null terminated
            //

            deviceName =  ExAllocatePool( NonPagedPool, InputBufferLength + sizeof(WCHAR) );

            if (NULL == deviceName) {

                IoStatus->Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
            
            RtlCopyMemory( deviceName, InputBuffer, InputBufferLength );
            deviceName[InputBufferLength / sizeof(WCHAR) - 1] = UNICODE_NULL;

            IoStatus->Status = IoTestStartLoggingDevice( DeviceObject,deviceName );
            break;  

        //
        //      Detach from a specified device
        //  

        case IOTEST_StopLoggingDevice:

            if (InputBuffer == NULL || InputBufferLength <= 0) {

                IoStatus->Status = STATUS_INVALID_PARAMETER;
                break;
            }
            
            //
            // Copy the device name and add a null to ensure that it is null terminated
            //

            deviceName =  ExAllocatePool( NonPagedPool, InputBufferLength + sizeof(WCHAR) );

            if (NULL == deviceName) {

                IoStatus->Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
            
            RtlCopyMemory( deviceName, InputBuffer, InputBufferLength );
            deviceName[InputBufferLength / sizeof(WCHAR) - 1] = UNICODE_NULL;

            IoStatus->Status = IoTestStopLoggingDevice( deviceName );
            break;  

        //
        //      List all the devices that we are currently
        //      monitoring
        //

        case IOTEST_ListDevices:

            if (OutputBuffer == NULL || OutputBufferLength <= 0) {

                IoStatus->Status = STATUS_INVALID_PARAMETER;
                break;
            }
                        
            IoStatus->Status = IoTestGetAttachList( OutputBuffer,
                                                    OutputBufferLength,
                                                    &IoStatus->Information);
            break;

        //
        //      Return entries from the log buffer
        //                                      

        case IOTEST_GetLog:

            if (OutputBuffer == NULL || OutputBufferLength == 0) {

                IoStatus->Status = STATUS_INVALID_PARAMETER;
                break;
            }

            IoTestGetLog( OutputBuffer, OutputBufferLength, IoStatus );
            break;

        //
        //      Return version of the IoTest filter driver
        //                                      

        case IOTEST_GetVer:

            if ((OutputBufferLength < sizeof(IOTESTVER)) || 
                (OutputBuffer == NULL)) {

                IoStatus->Status = STATUS_INVALID_PARAMETER;
                break;                    
            }
            
            fileIoTestVer.Major = IOTEST_MAJ_VERSION;
            fileIoTestVer.Minor = IOTEST_MIN_VERSION;
            
            RtlCopyMemory(OutputBuffer, &fileIoTestVer, sizeof(IOTESTVER));
            
            IoStatus->Information = sizeof (IOTESTVER);
            break;
        
        //
        //      Return hash table statistics
        //                                      

        case IOTEST_GetStats:

            if ((OutputBufferLength < sizeof(HASH_STATISTICS)) || 
                (OutputBuffer == NULL)) {

                IoStatus->Status = STATUS_INVALID_PARAMETER;
                break;                    
            }

            RtlCopyMemory( OutputBuffer, &gHashStat, sizeof (HASH_STATISTICS) );
            IoStatus->Information = sizeof (HASH_STATISTICS);
            break;

        //
        //     Tests
        //

        case IOTEST_ReadTest:

            if ((OutputBufferLength < sizeof( IOTEST_STATUS )) ||
                (OutputBuffer == NULL) ||
                (InputBufferLength < sizeof( IOTEST_READ_WRITE_PARAMETERS )) ||
                (InputBuffer == NULL )) {

                IoStatus->Status = STATUS_INVALID_PARAMETER;
                break;
            }

            IoTestReadTestDriver( InputBuffer,
                                  InputBufferLength,
                                  OutputBuffer,
                                  OutputBufferLength );

            IoStatus->Status = STATUS_SUCCESS;
            IoStatus->Information = sizeof( IOTEST_STATUS );
            break;

        case IOTEST_RenameTest:

            if ((OutputBufferLength < sizeof( IOTEST_STATUS )) ||
                (OutputBuffer == NULL) ||
                (InputBufferLength < sizeof( IOTEST_RENAME_PARAMETERS )) ||
                (InputBuffer == NULL )) {

                IoStatus->Status = STATUS_INVALID_PARAMETER;
                break;
            }

            IoTestRenameTestDriver( InputBuffer,
                                    InputBufferLength,
                                    OutputBuffer,
                                    OutputBufferLength );

            IoStatus->Status = STATUS_SUCCESS;
            IoStatus->Information = sizeof( IOTEST_STATUS );
            break;
            
        case IOTEST_ShareTest:

            if ((OutputBufferLength < sizeof( IOTEST_STATUS )) ||
                (OutputBuffer == NULL) ||
                (InputBufferLength < sizeof( IOTEST_SHARE_PARAMETERS )) ||
                (InputBuffer == NULL )) {

                IoStatus->Status = STATUS_INVALID_PARAMETER;
                break;
            }

            IoTestShareTestDriver( InputBuffer,
                                   InputBufferLength,
                                   OutputBuffer,
                                   OutputBufferLength );

            IoStatus->Status = STATUS_SUCCESS;
            IoStatus->Information = sizeof( IOTEST_STATUS );
            break;
            
        default:

            IoStatus->Status = STATUS_INVALID_PARAMETER;
            break;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {

        //
        // An exception was incurred while attempting to access
        // one of the caller's parameters.  Simply return an appropriate
        // error status code.
        //

        IoStatus->Status = GetExceptionCode();

    }

    if (NULL != deviceName) {

        ExFreePool( deviceName );
    }

  return IoStatus->Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\iotest\filter\iotestkern.h ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    ioTestKern.h

Abstract:
    Header file which contains the structures, type definitions,
    constants, global variables and function prototypes that are
    only visible within the kernel.

// @@BEGIN_DDKSPLIT

Author:

    Molly Brown (mollybro)  

// @@END_DDKSPLIT

Environment:

    Kernel mode

// @@BEGIN_DDKSPLIT

Revision History:

// @@END_DDKSPLIT
--*/
#ifndef __IOTESTKERN_H__
#define __IOTESTKERN_H__

#define DBGSTATIC

#define MSFM_TAG 'YPSF'             // memory allocation tag value
#define USE_LOOKASIDE_LIST 0        // do NOT use look aside lists (use Allocate Pool)

#ifndef INVALID_HANDLE_VALUE
#define INVALID_HANDLE_VALUE (HANDLE) -1
#endif

#define HASH_SIZE            128        // MUST be a power of 2

//
//  Macros for IoTest DbgPrint levels.
//

#if DBG
#define IOTEST_DBG_PRINT0( _dbgLevel, _string )          \
    {                                                     \
        if (FlagOn( gIoTestDebugLevel, (_dbgLevel) )) {  \
            DbgPrint( (_string) );                        \
        }                                                 \
    }

#define IOTEST_DBG_PRINT1( _dbgLevel, _formatString, _parm1 )  \
    {                                                           \
        if (FlagOn( gIoTestDebugLevel, (_dbgLevel) )) {        \
            DbgPrint( (_formatString), (_parm1) );              \
        }                                                       \
    }

#define IOTEST_DBG_PRINT2( _dbgLevel, _formatString, _parm1, _parm2 )  \
    {                                                                   \
        if (FlagOn( gIoTestDebugLevel, (_dbgLevel) )) {                \
            DbgPrint( (_formatString), (_parm1), (_parm2) );            \
        }                                                               \
    }

#define IOTEST_DBG_PRINT3( _dbgLevel, _formatString, _parm1, _parm2, _parm3 )  \
    {                                                                           \
        if (FlagOn( gIoTestDebugLevel, (_dbgLevel) )) {                        \
            DbgPrint( (_formatString), (_parm1), (_parm2), (_parm3) );          \
        }                                                                       \
    }

#else

#define IOTEST_DBG_PRINT0( _dbgLevel, _string )
#define IOTEST_DBG_PRINT1( _dbgLevel, _formatString, _parm1 ) 
#define IOTEST_DBG_PRINT2( _dbgLevel, _formatString, _parm1, _parm2 )
#define IOTEST_DBG_PRINT3( _dbgLevel, _formatString, _parm1, _parm2, _parm3 )

#endif

//---------------------------------------------------------------------------
//      Global variables
//---------------------------------------------------------------------------
#define IOTESTDEBUG_DISPLAY_ATTACHMENT_NAMES    0x00000001
#define IOTESTDEBUG_ERROR                       0x00000002
#define IOTESTDEBUG_TRACE_NAME_REQUESTS         0x00000004
#define IOTESTDEBUG_TRACE_IRP_OPS               0x00000010
#define IOTESTDEBUG_TRACE_FAST_IO_OPS           0x00000020
#define IOTESTDEBUG_TRACE_FSFILTER_OPS          0x00000040
#define IOTESTDEBUG_TESTS                       0x00000100

extern ULONG gIoTestDebugLevel;
extern ULONG gIoTestAttachMode;

extern PDEVICE_OBJECT gControlDeviceObject;
extern PDRIVER_OBJECT gIoTestDriverObject;

extern FAST_MUTEX gIoTestDeviceExtensionListLock;
extern LIST_ENTRY gIoTestDeviceExtensionList;

extern KSPIN_LOCK gOutputBufferLock;
extern LIST_ENTRY gOutputBufferList;

extern NPAGED_LOOKASIDE_LIST gFreeBufferList;

extern ULONG gLogSequenceNumber;
extern KSPIN_LOCK gLogSequenceLock;

extern UNICODE_STRING gVolumeString;
extern UNICODE_STRING gOverrunString;
extern UNICODE_STRING gPagingIoString;

extern LIST_ENTRY gHashTable[HASH_SIZE];
extern KSPIN_LOCK gHashLockTable[HASH_SIZE];
extern ULONG gHashMaxCounters[HASH_SIZE];
extern ULONG gHashCurrentCounters[HASH_SIZE];

extern HASH_STATISTICS gHashStat;

#define DEFAULT_MAX_RECORDS_TO_ALLOCATE 100;
#define DEFAULT_MAX_NAMES_TO_ALLOCATE   100;
#define DEFAULT_IOTEST_DEBUG_LEVEL     IOTESTDEBUG_ERROR;
#define MAX_RECORDS_TO_ALLOCATE         L"MaxRecords"
#define MAX_NAMES_TO_ALLOCATE           L"MaxNames"
#define DEBUG_LEVEL                     L"DebugFlags"
#define ATTACH_MODE                     L"AttachMode"


extern LONG gMaxRecordsToAllocate;
extern LONG gRecordsAllocated;
extern LONG gMaxNamesToAllocate;
extern LONG gNamesAllocated;

extern LONG gStaticBufferInUse;
extern CHAR gOutOfMemoryBuffer[RECORD_SIZE];

#define IOTEST_POOL_TAG    ' ToI'

//
//  Given a device type, return a valid name
//

extern const PCHAR DeviceTypeNames[];
extern ULONG SizeOfDeviceTypeNames;

#define GET_DEVICE_TYPE_NAME( _type ) \
            ((((_type) > 0) && ((_type) < (SizeOfDeviceTypeNames / sizeof(PCHAR)))) ? \
                DeviceTypeNames[ (_type) ] : \
                "[Unknown]")

//
//  Macro to test for device types we want to attach to
//

#define IS_DESIRED_DEVICE_TYPE(_type) \
    (((_type) == FILE_DEVICE_DISK_FILE_SYSTEM) || \
     ((_type) == FILE_DEVICE_CD_ROM_FILE_SYSTEM) || \
     ((_type) == FILE_DEVICE_NETWORK_FILE_SYSTEM))

//
// Returns the number of BYTES unused in the RECORD_LIST structure
//

#define REMAINING_NAME_SPACE(RecordList) \
    (USHORT)(RECORD_SIZE - \
            (((RecordList)->LogRecord.Length) + sizeof(LIST_ENTRY)))


//
// The maximum number of BYTES that can be used to store the file name in the
// RECORD_LIST structure
//

#define MAX_NAME_SPACE (RECORD_SIZE - SIZE_OF_RECORD_LIST)

#define HASH_FUNC(FileObject) \
    (((UINT_PTR)(FileObject) >> 8) & (HASH_SIZE - 1))

typedef struct _HASH_ENTRY {

    LIST_ENTRY List;
    PFILE_OBJECT FileObject;
    UNICODE_STRING Name;

} HASH_ENTRY, *PHASH_ENTRY;

#define USER_NAMES_SZ   64

//
// Define the device extension structure that the IoTest driver
// adds to each device object it is attached to.  It stores
// the context IoTest needs to perform its logging operations on
// a device.
//

typedef struct _IOTEST_DEVICE_EXTENSION {

    IOTEST_DEVICE_TYPE Type;    

    PDEVICE_OBJECT AttachedToDeviceObject;   // device object we are attached to
    PDEVICE_OBJECT DiskDeviceObject;         // the device object at the top of
                                             //   storage stack; used in 
                                             //   IoTestMountCompletion
    BOOLEAN LogThisDevice;
    BOOLEAN IsVolumeDeviceObject;            // if TRUE this is an attachment to
                                             // a volume device object, if FALSE
                                             // this is an attachment to a file
                                             // system control device object.
    LIST_ENTRY NextIoTestDeviceLink;        // linked list of devices we are
                                             //     attached to
    UNICODE_STRING DeviceNames;              // receives name of device
    UNICODE_STRING UserNames;                // names that the user used to 
                                             //   start logging this device
    WCHAR DeviceNamesBuffer[DEVICE_NAMES_SZ];// holds actual device names
    WCHAR UserNamesBuffer[USER_NAMES_SZ];    // holds actual user names

    //
    //  Note: We keep these two forms of the name so that we can build
    //    a nicer looking name when we are printing out file names.
    //    We want just the "c:" type device name at the beginning
    //    of a file name, not "\device\hardiskVolume1".
    //

} IOTEST_DEVICE_EXTENSION, *PIOTEST_DEVICE_EXTENSION;

typedef struct _MINI_DEVICE_STACK {
    
    PDEVICE_OBJECT Top;
    PDEVICE_OBJECT Bottom;

} MINI_DEVICE_STACK, *PMINI_DEVICE_STACK;

#define IS_IOTEST_DEVICE_OBJECT( _devObj )                               \
    (((_devObj) != NULL) &&                                               \
     ((_devObj)->DriverObject == gIoTestDriverObject) &&                 \
     ((_devObj)->DeviceExtension != NULL))
    
#define IS_TOP_FILTER_DEVICE_OBJECT( _devObj) \
    (IS_IOTEST_DEVICE_OBJECT(_devObj) && \
     (_devObj)->DeviceType == TOP_FILTER)

#define IS_BOTTOM_FILTER_DEVICE_OBJECT( _devObj) \
    (IS_IOTEST_DEVICE_OBJECT(_devObj) && \
     (_devObj)->DeviceType == BOTTOM_FILTER)

#define IO_TEST_TARGET_DEVICE( _devObj ) \
    (((PIOTEST_DEVICE_EXTENSION)((_devObj)->DeviceExtension))->AttachedToDeviceObject)

typedef enum _CONTROL_DEVICE_STATE {

    OPENED,
    CLOSED,
    CLEANING_UP

} CONTROL_DEVICE_STATE;

extern CONTROL_DEVICE_STATE gControlDeviceState;
extern KSPIN_LOCK gControlDeviceStateLock;

#ifdef USE_DO_HINT

#define IoTestCreateFile( F, D, O, I, A, FA, SA, CD, CO, EB, EL, OP, DO ) \
    IoCreateFileSpecifyDeviceObjectHint((F),                          \
                                        (D),                          \
                                        (O),                          \
                                        (I),                          \
                                        (A),                          \
                                        (FA),                         \
                                        (SA),                         \
                                        (CD),                         \
                                        (CO),                         \
                                        (EB),                         \
                                        (EL),                         \
                                        CreateFileTypeNone,           \
                                        NULL,                         \
                                        IO_NO_PARAMETER_CHECKING | (OP),     \
                                        (DO) );

#else

#define IoTestCreateFile( F, D, O, I, A, FA, SA, CD, CO, EB, EL, OP, DO ) \
    ZwCreateFile((F),                          \
                 (D),                          \
                 (O),                          \
                 (I),                          \
                 (A),                          \
                 (FA),                         \
                 (SA),                         \
                 (CD),                         \
                 (CO),                         \
                 (EB),                         \
                 (EL) );
#endif /* USE_DO_HINT */
////////////////////////////////////////////////////////////////////////
//                                                                    //
//    Prototypes for the routines this driver uses to filter the      //
//    the data that is being seen by this file systems.               //
//                                                                    //
//                   implemented in filespy.c                         //
//                                                                    //
////////////////////////////////////////////////////////////////////////

NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
);

VOID
DriverUnload(
    IN PDRIVER_OBJECT DriverObject
);

NTSTATUS
IoTestDispatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
);

NTSTATUS
IoTestPassThrough (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
);

NTSTATUS
IoTestPassThroughCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
);

NTSTATUS
IoTestCreate (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
);

NTSTATUS
IoTestClose (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

BOOLEAN
IoTestFastIoCheckIfPossible (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN BOOLEAN CheckForReadOperation,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
IoTestFastIoRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN        
IoTestFastIoWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
IoTestFastIoQueryBasicInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_BASIC_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
IoTestFastIoQueryStandardInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_STANDARD_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
IoTestFastIoLock (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    BOOLEAN FailImmediately,
    BOOLEAN ExclusiveLock,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
IoTestFastIoUnlockSingle (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
IoTestFastIoUnlockAll (
    IN PFILE_OBJECT FileObject,
    PEPROCESS ProcessId,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
IoTestFastIoUnlockAllByKey (
    IN PFILE_OBJECT FileObject,
    PVOID ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
IoTestFastIoDeviceControl (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);

VOID
IoTestFastIoDetachDevice (
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice
);

BOOLEAN
IoTestFastIoQueryNetworkOpenInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
IoTestFastIoMdlRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
IoTestFastIoMdlReadComplete (
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
IoTestFastIoPrepareMdlWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
IoTestFastIoMdlWriteComplete (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
IoTestFastIoReadCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    OUT struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
IoTestFastIoWriteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
IoTestFastIoMdlReadCompleteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
IoTestFastIoMdlWriteCompleteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
IoTestFastIoQueryOpen (
    IN PIRP Irp,
    OUT PFILE_NETWORK_OPEN_INFORMATION NetworkInformation,
    IN PDEVICE_OBJECT DeviceObject
);

NTSTATUS
IoTestPreFsFilterOperation (
    IN PFS_FILTER_CALLBACK_DATA Data,
    OUT PVOID *CompletionContext
);

VOID
IoTestPostFsFilterOperation (
    IN PFS_FILTER_CALLBACK_DATA Data,
    IN NTSTATUS OperationStatus,
    IN PVOID CompletionContext
);

NTSTATUS
IoTestCommonDeviceIoControl (
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);

//-----------------------------------------------------
//
//  This routines are only used if Filespy is attaching
//  to all volume in the system instead of attaching to
//  volumes on demand.
//
//-----------------------------------------------------

NTSTATUS
IoTestFsControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
);

NTSTATUS
IoTestSetInformation (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
);

VOID
IoTestFsNotification (
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN FsActive
);

NTSTATUS
IoTestMountCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
);

NTSTATUS
IoTestLoadFsCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
);

////////////////////////////////////////////////////////////////////////
//                                                                    //
//                  Library support routines                          //
//                   implemented in iotestlib.c                         //
//                                                                    //
////////////////////////////////////////////////////////////////////////

VOID
IoTestReadDriverParameters (
    IN PUNICODE_STRING RegistryPath
);

////////////////////////////////////////////////////////////////////////
//                                                                    //
//                  Memory allocation routines                        //
//                   implemented in iotestlib.c                         //
//                                                                    //
////////////////////////////////////////////////////////////////////////

PVOID
IoTestAllocateBuffer (
    IN OUT PLONG Counter,
    IN LONG MaxCounterValue,
    OUT PULONG RecordType
);

VOID
IoTestFreeBuffer (
    PVOID Buffer,
    PLONG Counter
);

////////////////////////////////////////////////////////////////////////
//                                                                    //
//                      Logging routines                              //
//                   implemented in iotestlib.c                         //
//                                                                    //
////////////////////////////////////////////////////////////////////////

PRECORD_LIST
IoTestNewRecord (
    ULONG AssignedSequenceNumber
);

VOID
IoTestFreeRecord (
    PRECORD_LIST Record
);

VOID
IoTestLogIrp (
    IN PIRP Irp,
    IN UCHAR LoggingFlags,
    OUT PRECORD_LIST RecordList
);

PRECORD_LIST
IoTestLogFastIoStart (
    IN FASTIO_TYPE FastIoType,
    IN PDEVICE_OBJECT DeviceObject,
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait
);

VOID
IoTestLogFastIoComplete (
    IN PIO_STATUS_BLOCK ReturnStatus,
    IN PRECORD_LIST RecordList
);

VOID
IoTestLogPreFsFilterOperation (
    IN PFS_FILTER_CALLBACK_DATA Data,
    OUT PRECORD_LIST RecordList
    );

VOID
IoTestLogPostFsFilterOperation (
    IN NTSTATUS OperationStatus,
    OUT PRECORD_LIST RecordList
    );

NTSTATUS
IoTestLog (
    IN PRECORD_LIST NewRecord
);

////////////////////////////////////////////////////////////////////////
//                                                                    //
//                    FileName cache routines                         //
//                    implemented in iotestlib.c                        //
//                                                                    //
////////////////////////////////////////////////////////////////////////

PHASH_ENTRY
IoTestHashBucketLookup (
    PLIST_ENTRY ListHead,
    PFILE_OBJECT FileObject
);

VOID
IoTestNameLookup (
    IN PRECORD_LIST RecordList,
    IN PFILE_OBJECT FileObject,
    IN ULONG LookupFlags,
    IN PIOTEST_DEVICE_EXTENSION DeviceExtension
);

VOID
IoTestNameDeleteAllNames (
    VOID
);

VOID
IoTestNameDelete (
    IN PFILE_OBJECT FileObject
);

BOOLEAN
IoTestGetFullPathName (
    IN PFILE_OBJECT FileObject,
    IN OUT PUNICODE_STRING FileName,
    IN PIOTEST_DEVICE_EXTENSION DeviceExtension,
    IN ULONG LookupFlags
);

NTSTATUS
IoTestQueryFileSystemForFileName (
    IN PFILE_OBJECT FileObject,
    IN PDEVICE_OBJECT NextDeviceObject,
    IN ULONG FileNameInfoLength,
    OUT PFILE_NAME_INFORMATION FileNameInfo,
    OUT PULONG ReturnedLength
);

NTSTATUS
IoTestQueryFileSystemForNameCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PKEVENT SynchronizingEvent
);

////////////////////////////////////////////////////////////////////////
//                                                                    //
//         Common attachment and detachment routines                  //
//              implemented in iotestlib.c                              //
//                                                                    //
////////////////////////////////////////////////////////////////////////

BOOLEAN
IoTestIsAttachedToDevice (
    IOTEST_DEVICE_TYPE DeviceType,
    PDEVICE_OBJECT DeviceObject,
    PDEVICE_OBJECT *AttachedDeviceObject OPTIONAL
);

NTSTATUS
IoTestAttachToMountedDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_OBJECT IoTestDeviceObject,
    IN PDEVICE_OBJECT DiskDeviceObject,
    IN IOTEST_DEVICE_TYPE DeviceType
);

VOID
IoTestCleanupMountedDevice (
    IN PDEVICE_OBJECT DeviceObject
    );

////////////////////////////////////////////////////////////////////////
//                                                                    //
//           Helper routine for turning on/off logging on demand      //
//                  implemented in iotestlib.c                          //
//                                                                    //
////////////////////////////////////////////////////////////////////////

NTSTATUS
IoTestGetDeviceObjectFromName (
    IN PUNICODE_STRING DeviceName,
    OUT PDEVICE_OBJECT *DeviceObject
);

////////////////////////////////////////////////////////////////////////
//                                                                    //
//                 Start/stop logging routines                        //
//                  implemented in iotestlib.c                          //
//                                                                    //
////////////////////////////////////////////////////////////////////////

NTSTATUS
IoTestStartLoggingDevice (
    PDEVICE_OBJECT DeviceObject,
    PWSTR UserDeviceName
);

NTSTATUS
IoTestStopLoggingDevice (
    PWSTR deviceName
);

////////////////////////////////////////////////////////////////////////
//                                                                    //
//       Attaching/detaching to all volumes in system routines        //
//                  implemented in iotestlib.c                          //
//                                                                    //
////////////////////////////////////////////////////////////////////////

NTSTATUS
IoTestCreateDeviceObjects (
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_OBJECT RealDeviceObject OPTIONAL,
    IN OUT PMINI_DEVICE_STACK Context
    );

NTSTATUS
IoTestAttachDeviceObjects (
    IN PMINI_DEVICE_STACK Context,
    IN PDEVICE_OBJECT MountedDevice,
    IN PDEVICE_OBJECT DiskDevice
    );

VOID
IoTestCleanupDeviceObjects (
    IN PMINI_DEVICE_STACK Context
    );
    
NTSTATUS
IoTestAttachToFileSystemDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PUNICODE_STRING Name
);

VOID
IoTestDetachFromFileSystemDevice (
    IN PDEVICE_OBJECT DeviceObject
);

NTSTATUS
IoTestEnumerateFileSystemVolumes (
    IN PDEVICE_OBJECT FSDeviceObject,
    IN PUNICODE_STRING Name
);

////////////////////////////////////////////////////////////////////////
//                                                                    //
//             Private Filespy IOCTLs helper routines                 //
//                  implemented in iotestlib.c                          //
//                                                                    //
////////////////////////////////////////////////////////////////////////

NTSTATUS
IoTestGetAttachList (
    PVOID buffer,
    ULONG bufferSize,
    PULONG_PTR returnLength
);

VOID
IoTestGetLog (
    OUT PVOID OutputBuffer,
    IN ULONG OutputBufferLength,
    OUT PIO_STATUS_BLOCK IoStatus
);

VOID
IoTestFlushLog (
);

VOID
IoTestCloseControlDevice (
);

////////////////////////////////////////////////////////////////////////
//                                                                    //
//               Device name tracking helper routines                 //
//                  implemented in iotestlib.c                          //
//                                                                    //
////////////////////////////////////////////////////////////////////////

VOID
IoTestGetObjectName (
    IN PVOID Object,
    IN OUT PUNICODE_STRING Name
);

VOID
IoTestGetBaseDeviceObjectName (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PUNICODE_STRING Name
);

VOID
IoTestCacheDeviceName (
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
IoTestFindSubString (
    IN PUNICODE_STRING String,
    IN PUNICODE_STRING SubString
);

VOID
IoTestStoreUserName (
    IN PIOTEST_DEVICE_EXTENSION DeviceExtension,
    IN PUNICODE_STRING UserName
);

////////////////////////////////////////////////////////////////////////
//                                                                    //
//                        Debug support routines                      //
//                       implemented in iotestlib.c                     //
//                                                                    //
////////////////////////////////////////////////////////////////////////

VOID
IoTestDumpIrpOperation (
    IN BOOLEAN InOriginatingPath,
    IN PIRP Irp
);

VOID
IoTestDumpFastIoOperation (
    IN BOOLEAN InPreOperation,
    IN FASTIO_TYPE FastIoOperation
);

VOID
IoTestDumpFsFilterOperation (
    IN BOOLEAN InPreOperationCallback,
    IN PFS_FILTER_CALLBACK_DATA Data
);

////////////////////////////////////////////////////////////////////////
//                                                                    //
//                        Test routines routines                      //
//                       implemented in iotestlib.c                     //
//                                                                    //
////////////////////////////////////////////////////////////////////////

NTSTATUS
IoTestFindTopDeviceObject (
    IN PUNICODE_STRING DriveName,
    OUT PDEVICE_OBJECT *IoTestDeviceObject
    );

NTSTATUS
IoTestReadTestDriver (
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN ULONG OutputBufferLength
    );

NTSTATUS
IoTestReadTest (
    IN PUNICODE_STRING FileName,
    IN PVOID FileData,
    IN ULONG FileDataLength,
    IN PDEVICE_OBJECT TargetDevice,
    OUT PIOTEST_STATUS TestStatus
    );

NTSTATUS
IoTestRenameTestDriver (
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN ULONG OutputBufferLength
    );

NTSTATUS
IoTestRenameTest (
    IN PUNICODE_STRING SourceFileName,
    IN PUNICODE_STRING TargetFileName,
    IN PDEVICE_OBJECT TargetDevice,
    OUT PIOTEST_STATUS TestStatus
    );

NTSTATUS
IoTestShareTestDriver (
    IN PVOID InputBuffer,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer,
    IN ULONG OutputBufferLength
    );

NTSTATUS
IoTestShareTest (
    IN PUNICODE_STRING FileName,
    IN PDEVICE_OBJECT DeviceObject,
    OUT PIOTEST_STATUS TestStatus
    );

NTSTATUS
IoTestPrepareDevicesForTest (
    IN PUNICODE_STRING DeviceName,
    OUT PDEVICE_OBJECT* IoTestTopDeviceObject
    );

VOID
IoTestCleanupDevicesForTest (
    IN PDEVICE_OBJECT IoTestTopDeviceObject
    );

NTSTATUS
IoTestCompareData (
    IN PCHAR OriginalData,
    IN PCHAR TestData,
    IN ULONG DataLength
    );


#endif /* __IOTESTKERN_H__ */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\iotest\lib\fsfilteroperationnames.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    irpName.c

Abstract:

    This module contains functions used to generate names for IRPs

// @@BEGIN_DDKSPLIT
Author:

    Neal Christiansen (NealCH) 27-Sep-2000

// @@END_DDKSPLIT

Environment:

    User mode


// @@BEGIN_DDKSPLIT
Revision History:

// @@END_DDKSPLIT
--*/

#include <ntifs.h>
#include <stdio.h>
#include "ioTestLib.h"


VOID
GetFsFilterOperationName (
    IN UCHAR FsFilterOperation,
    OUT PCHAR FsFilterOperationName
    )
/*++

Routine Description:

    This routine translates the given FsFilter Operation code into a printable
    string which is returned.  

Arguments:

    FsFilterOperation - the FsFilter operation code to translate
    FsFilterOperationName - a buffer at least OPERATION_NAME_BUFFER_SIZE
                characters long that receives the name.

Return Value:

    None.

--*/
{
    PCHAR operationString;
    CHAR nameBuf[OPERATION_NAME_BUFFER_SIZE];

    switch (FsFilterOperation) {

        case FS_FILTER_ACQUIRE_FOR_CC_FLUSH:
            operationString = "ACQUIRE_FOR_CC_FLUSH";
            break;

        case FS_FILTER_RELEASE_FOR_CC_FLUSH:
            operationString = "RELEASE_FOR_CC_FLUSH";
            break;

        case FS_FILTER_ACQUIRE_FOR_SECTION_SYNCHRONIZATION:
            operationString = "ACQUIRE_FOR_SECTION_SYNC";
            break;

        case FS_FILTER_RELEASE_FOR_SECTION_SYNCHRONIZATION:
            operationString = "RELEASE_FOR_SECTION_SYNC";
            break;

        case FS_FILTER_ACQUIRE_FOR_MOD_WRITE:
            operationString = "ACQUIRE_FOR_MOD_WRITE";
            break;

        case FS_FILTER_RELEASE_FOR_MOD_WRITE:
            operationString = "RELEASE_FOR_MOD_WRITE";
            break;

        default:
            sprintf(nameBuf,"Unknown FsFilter operation (%u)",FsFilterOperation);
            operationString = nameBuf;
    }

    strcpy(FsFilterOperationName,operationString);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\iotest\lib\iotestlib.h ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    ioTestLib.h

Abstract:

    This contains internal defintions from the fileSpy library
    
// @@BEGIN_DDKSPLIT
Author:

    Neal Christiansen (NealCH) 27-Sep-2000

// @@END_DDKSPLIT
Environment:

    Library used by both USER and KERNEL mode components

// @@BEGIN_DDKSPLIT
Revision History:

// @@END_DDKSPLIT
--*/

#ifndef __IOTESTLIB_H__
#define __IOTESTLIB_H__

#ifdef __cplusplus
extern "C" {
#endif

//
//  The types FASTIO that are available for the Type field of the 
//  RECORD_FASTIO structure.
//

typedef enum {

    CHECK_IF_POSSIBLE = 1,
    READ,
    WRITE,
    QUERY_BASIC_INFO,
    QUERY_STANDARD_INFO,
    LOCK,
    UNLOCK_SINGLE,
    UNLOCK_ALL,
    UNLOCK_ALL_BY_KEY,
    DEVICE_CONTROL,
    DETACH_DEVICE,
    QUERY_NETWORK_OPEN_INFO,
    MDL_READ,
    MDL_READ_COMPLETE,
    MDL_WRITE,
    MDL_WRITE_COMPLETE,
    READ_COMPRESSED,
    WRITE_COMPRESSED,
    MDL_READ_COMPLETE_COMPRESSED,
    PREPARE_MDL_WRITE,
    MDL_WRITE_COMPLETE_COMPRESSED,
    QUERY_OPEN,

    FASTIO_MAX_OPERATION=QUERY_OPEN
} FASTIO_TYPE/*, *PFASTIO_TYPE*/;

//
//  Size of return name buffers
//

#define OPERATION_NAME_BUFFER_SIZE 80

//
//  Function prototypes
//

extern
VOID
GetIrpName (
    IN UCHAR MajorCode,
    IN UCHAR MinorCode,
    IN ULONG FsctlCode,
    OUT PCHAR MajorCodeName,
    OUT PCHAR MinorCodeName);

extern
VOID
GetFastioName (
    IN FASTIO_TYPE FastioCode,
    OUT PCHAR FastioName);

extern
VOID
GetFsFilterOperationName (
    IN UCHAR FsFilterOperation,
    OUT PCHAR FsFilterOperationName);

//
//  Service definitions
//

#define IOTEST_SERVICE_NAME   L"IoTest"
#define IOTEST_SERVICE_ACCESS (STANDARD_RIGHTS_REQUIRED | \
                                SERVICE_QUERY_CONFIG | \
                                SERVICE_QUERY_STATUS | \
                                SERVICE_START)

//
//  These are copied from NTIFS.H because we need them in user mode.
//

#define IRP_MJ_CREATE                   0x00
#define IRP_MJ_CREATE_NAMED_PIPE        0x01
#define IRP_MJ_CLOSE                    0x02
#define IRP_MJ_READ                     0x03
#define IRP_MJ_WRITE                    0x04
#define IRP_MJ_QUERY_INFORMATION        0x05
#define IRP_MJ_SET_INFORMATION          0x06
#define IRP_MJ_QUERY_EA                 0x07
#define IRP_MJ_SET_EA                   0x08
#define IRP_MJ_FLUSH_BUFFERS            0x09
#define IRP_MJ_QUERY_VOLUME_INFORMATION 0x0a
#define IRP_MJ_SET_VOLUME_INFORMATION   0x0b
#define IRP_MJ_DIRECTORY_CONTROL        0x0c
#define IRP_MJ_FILE_SYSTEM_CONTROL      0x0d
#define IRP_MJ_DEVICE_CONTROL           0x0e
#define IRP_MJ_INTERNAL_DEVICE_CONTROL  0x0f
#define IRP_MJ_SHUTDOWN                 0x10
#define IRP_MJ_LOCK_CONTROL             0x11
#define IRP_MJ_CLEANUP                  0x12
#define IRP_MJ_CREATE_MAILSLOT          0x13
#define IRP_MJ_QUERY_SECURITY           0x14
#define IRP_MJ_SET_SECURITY             0x15
#define IRP_MJ_POWER                    0x16
#define IRP_MJ_SYSTEM_CONTROL           0x17
#define IRP_MJ_DEVICE_CHANGE            0x18
#define IRP_MJ_QUERY_QUOTA              0x19
#define IRP_MJ_SET_QUOTA                0x1a
#define IRP_MJ_PNP                      0x1b
#define IRP_MJ_MAXIMUM_FUNCTION         0x1b

#define IRP_MN_QUERY_DIRECTORY          0x01
#define IRP_MN_NOTIFY_CHANGE_DIRECTORY  0x02
#define IRP_MN_USER_FS_REQUEST          0x00
#define IRP_MN_MOUNT_VOLUME             0x01
#define IRP_MN_VERIFY_VOLUME            0x02
#define IRP_MN_LOAD_FILE_SYSTEM         0x03
#define IRP_MN_TRACK_LINK               0x04
#define IRP_MN_LOCK                     0x01
#define IRP_MN_UNLOCK_SINGLE            0x02
#define IRP_MN_UNLOCK_ALL               0x03
#define IRP_MN_UNLOCK_ALL_BY_KEY        0x04
#define IRP_MN_NORMAL                   0x00
#define IRP_MN_DPC                      0x01
#define IRP_MN_MDL                      0x02
#define IRP_MN_COMPLETE                 0x04
#define IRP_MN_COMPRESSED               0x08
#define IRP_MN_MDL_DPC                  (IRP_MN_MDL | IRP_MN_DPC)
#define IRP_MN_COMPLETE_MDL             (IRP_MN_COMPLETE | IRP_MN_MDL)
#define IRP_MN_COMPLETE_MDL_DPC         (IRP_MN_COMPLETE_MDL | IRP_MN_DPC)
#define IRP_MN_SCSI_CLASS               0x01
#define IRP_MN_START_DEVICE                 0x00
#define IRP_MN_QUERY_REMOVE_DEVICE          0x01
#define IRP_MN_REMOVE_DEVICE                0x02
#define IRP_MN_CANCEL_REMOVE_DEVICE         0x03
#define IRP_MN_STOP_DEVICE                  0x04
#define IRP_MN_QUERY_STOP_DEVICE            0x05
#define IRP_MN_CANCEL_STOP_DEVICE           0x06
#define IRP_MN_QUERY_DEVICE_RELATIONS       0x07
#define IRP_MN_QUERY_INTERFACE              0x08
#define IRP_MN_QUERY_CAPABILITIES           0x09
#define IRP_MN_QUERY_RESOURCES              0x0A
#define IRP_MN_QUERY_RESOURCE_REQUIREMENTS  0x0B
#define IRP_MN_QUERY_DEVICE_TEXT            0x0C
#define IRP_MN_FILTER_RESOURCE_REQUIREMENTS 0x0D
#define IRP_MN_READ_CONFIG                  0x0F
#define IRP_MN_WRITE_CONFIG                 0x10
#define IRP_MN_EJECT                        0x11
#define IRP_MN_SET_LOCK                     0x12
#define IRP_MN_QUERY_ID                     0x13
#define IRP_MN_QUERY_PNP_DEVICE_STATE       0x14
#define IRP_MN_QUERY_BUS_INFORMATION        0x15
#define IRP_MN_DEVICE_USAGE_NOTIFICATION    0x16
#define IRP_MN_SURPRISE_REMOVAL             0x17
#define IRP_MN_QUERY_LEGACY_BUS_INFORMATION 0x18
#define IRP_MN_WAIT_WAKE                    0x00
#define IRP_MN_POWER_SEQUENCE               0x01
#define IRP_MN_SET_POWER                    0x02
#define IRP_MN_QUERY_POWER                  0x03
#define IRP_MN_QUERY_ALL_DATA               0x00
#define IRP_MN_QUERY_SINGLE_INSTANCE        0x01
#define IRP_MN_CHANGE_SINGLE_INSTANCE       0x02
#define IRP_MN_CHANGE_SINGLE_ITEM           0x03
#define IRP_MN_ENABLE_EVENTS                0x04
#define IRP_MN_DISABLE_EVENTS               0x05
#define IRP_MN_ENABLE_COLLECTION            0x06
#define IRP_MN_DISABLE_COLLECTION           0x07
#define IRP_MN_REGINFO                      0x08
#define IRP_MN_EXECUTE_METHOD               0x09

//
//  Lists of IRP names and FASTIO names
//

extern PWCHAR IrpNameList[IRP_MJ_MAXIMUM_FUNCTION+1];
extern PWCHAR FastIoNameList[FASTIO_MAX_OPERATION];


#ifdef __cplusplus
}
#endif

#endif __IOTESTLIB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\iotest\lib\irpnames.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    irpName.c

Abstract:

    This module contains functions used to generate names for IRPs

// @@BEGIN_DDKSPLIT
Author:

    Neal Christiansen (NealCH) 27-Sep-2000

// @@END_DDKSPLIT

Environment:

    User mode


// @@BEGIN_DDKSPLIT
Revision History:

// @@END_DDKSPLIT
--*/

#include <ntifs.h>
#include <stdio.h>
#include "ioTestLib.h"

//
//  Globals
//

CHAR UnknownIrpMinor[] = "Unknown Irp minor code (%u)";


VOID
GetIrpName (
    IN UCHAR MajorCode,
    IN UCHAR MinorCode,
    IN ULONG FsctlCode,
    OUT PCHAR MajorCodeName,
    OUT PCHAR MinorCodeName
    )
/*++

Routine Description:

    This routine translates the given Irp codes into printable strings which
    are returned.  This guarentees to routine valid strings in each buffer.
    The MinorCode string may be a NULL string (not a null pointer).

Arguments:

    MajorCode - the IRP Major code of the operation
    MinorCode - the IRP Minor code of the operation
    FsctlCode - if this is an IRP_MJ_FILE_SYSTEM_CONTROL/IRP_MN_USER_FS_REQUEST
                operation then this is the FSCTL code whose name is also
                translated.  This name is returned as part of the MinorCode
                string.
    MajorCodeName - a string buffer at least OPERATION_NAME_BUFFER_SIZE
                characters long that receives the major code name.
    MinorCodeName - a string buffer at least OPERATION_NAME_BUFFER_SIZE
                characters long that receives the minor/fsctl code name.

Return Value:

    None.

--*/
{
    PCHAR irpMajorString;
    PCHAR irpMinorString = "";
    CHAR nameBuf[OPERATION_NAME_BUFFER_SIZE];

    switch (MajorCode) {
        case IRP_MJ_CREATE:
            irpMajorString = "IRP_MJ_CREATE";
            break;
        case IRP_MJ_CREATE_NAMED_PIPE:
            irpMajorString = "IRP_MJ_CREATE_NAMED_PIPE";
            break;
        case IRP_MJ_CLOSE:
            irpMajorString = "IRP_MJ_CLOSE";
            break;
        case IRP_MJ_READ:
            irpMajorString = "IRP_MJ_READ";
            switch (MinorCode) {
                case IRP_MN_NORMAL:
                    irpMinorString = "IRP_MN_NORMAL";
                    break;
                case IRP_MN_DPC:
                    irpMinorString = "IRP_MN_DPC";
                    break;
                case IRP_MN_MDL:
                    irpMinorString = "IRP_MN_MDL";
                    break;
                case IRP_MN_COMPLETE:
                    irpMinorString = "IRP_MN_COMPLETE";
                    break;
                case IRP_MN_COMPRESSED:
                    irpMinorString = "IRP_MN_COMPRESSED";
                    break;
                case IRP_MN_MDL_DPC:
                    irpMinorString = "IRP_MN_MDL_DPC";
                    break;
                case IRP_MN_COMPLETE_MDL:
                    irpMinorString = "IRP_MN_COMPLETE_MDL";
                    break;
                case IRP_MN_COMPLETE_MDL_DPC:
                    irpMinorString = "IRP_MN_COMPLETE_MDL_DPC";
                    break;
                default:
                    sprintf( nameBuf, UnknownIrpMinor, MinorCode );
                    irpMinorString = nameBuf;
            }
            break;

        case IRP_MJ_WRITE:
            irpMajorString = "IRP_MJ_WRITE";
            switch (MinorCode) {
                case IRP_MN_NORMAL:
                    irpMinorString = "IRP_MN_NORMAL";
                    break;
                case IRP_MN_DPC:
                    irpMinorString = "IRP_MN_DPC";
                    break;
                case IRP_MN_MDL:
                    irpMinorString = "IRP_MN_MDL";
                    break;
                case IRP_MN_COMPLETE:
                    irpMinorString = "IRP_MN_COMPLETE";
                    break;
                case IRP_MN_COMPRESSED:
                    irpMinorString = "IRP_MN_COMPRESSED";
                    break;
                case IRP_MN_MDL_DPC:
                    irpMinorString = "IRP_MN_MDL_DPC";
                    break;
                case IRP_MN_COMPLETE_MDL:
                    irpMinorString = "IRP_MN_COMPLETE_MDL";
                    break;
                case IRP_MN_COMPLETE_MDL_DPC:
                    irpMinorString = "IRP_MN_COMPLETE_MDL_DPC";
                    break;
                default:
                    sprintf(nameBuf,UnknownIrpMinor,MinorCode);
                    irpMinorString = nameBuf;
            }
            break;

        case IRP_MJ_QUERY_INFORMATION:
            irpMajorString = "IRP_MJ_QUERY_INFORMATION";
            break;
        case IRP_MJ_SET_INFORMATION:
            irpMajorString = "IRP_MJ_SET_INFORMATION";
            break;
        case IRP_MJ_QUERY_EA:
            irpMajorString = "IRP_MJ_QUERY_EA";
            break;
        case IRP_MJ_SET_EA:
            irpMajorString = "IRP_MJ_SET_EA";
            break;
        case IRP_MJ_FLUSH_BUFFERS:
            irpMajorString = "IRP_MJ_FLUSH_BUFFERS";
            break;
        case IRP_MJ_QUERY_VOLUME_INFORMATION:
            irpMajorString = "IRP_MJ_QUERY_VOLUME_INFORMATION";
            break;
        case IRP_MJ_SET_VOLUME_INFORMATION:
            irpMajorString = "IRP_MJ_SET_VOLUME_INFORMATION";
            break;
        case IRP_MJ_DIRECTORY_CONTROL:
            irpMajorString = "IRP_MJ_DIRECTORY_CONTROL";
            switch (MinorCode) {
                case IRP_MN_QUERY_DIRECTORY:
                    irpMinorString = "IRP_MN_QUERY_DIRECTORY";
                    break;
                case IRP_MN_NOTIFY_CHANGE_DIRECTORY:
                    irpMinorString = "IRP_MN_NOTIFY_CHANGE_DIRECTORY";
                    break;
                default:
                    sprintf(nameBuf,UnknownIrpMinor,MinorCode);
                    irpMinorString = nameBuf;
            }
            break;

        case IRP_MJ_FILE_SYSTEM_CONTROL:
            irpMajorString = "IRP_MJ_FILE_SYSTEM_CONTROL";
            switch (MinorCode) {
                case IRP_MN_USER_FS_REQUEST:
                    switch (FsctlCode) {
                        case FSCTL_REQUEST_OPLOCK_LEVEL_1:
                            irpMinorString = "FSCTL_REQUEST_OPLOCK_LEVEL_1";
                            break;
                        case FSCTL_REQUEST_OPLOCK_LEVEL_2:
                            irpMinorString = "FSCTL_REQUEST_OPLOCK_LEVEL_2";
                            break;
                        case FSCTL_REQUEST_BATCH_OPLOCK:
                            irpMinorString = "FSCTL_REQUEST_BATCH_OPLOCK";
                            break;
                        case FSCTL_OPLOCK_BREAK_ACKNOWLEDGE:
                            irpMinorString = "FSCTL_OPLOCK_BREAK_ACKNOWLEDGE";
                            break;
                        case FSCTL_OPBATCH_ACK_CLOSE_PENDING:
                            irpMinorString = "FSCTL_OPBATCH_ACK_CLOSE_PENDING";
                            break;
                        case FSCTL_OPLOCK_BREAK_NOTIFY:
                            irpMinorString = "FSCTL_OPLOCK_BREAK_NOTIFY";
                            break;
                        case FSCTL_LOCK_VOLUME:
                            irpMinorString = "FSCTL_LOCK_VOLUME";
                            break;
                        case FSCTL_UNLOCK_VOLUME:
                            irpMinorString = "FSCTL_UNLOCK_VOLUME";
                            break;
                        case FSCTL_DISMOUNT_VOLUME:
                            irpMinorString = "FSCTL_DISMOUNT_VOLUME";
                            break;
                        case FSCTL_IS_VOLUME_MOUNTED:
                            irpMinorString = "FSCTL_IS_VOLUME_MOUNTED";
                            break;
                        case FSCTL_IS_PATHNAME_VALID:
                            irpMinorString = "FSCTL_IS_PATHNAME_VALID";
                            break;
                        case FSCTL_MARK_VOLUME_DIRTY:
                            irpMinorString = "FSCTL_MARK_VOLUME_DIRTY";
                            break;
                        case FSCTL_QUERY_RETRIEVAL_POINTERS:
                            irpMinorString = "FSCTL_QUERY_RETRIEVAL_POINTERS";
                            break;
                        case FSCTL_GET_COMPRESSION:
                            irpMinorString = "FSCTL_GET_COMPRESSION";
                            break;
                        case FSCTL_SET_COMPRESSION:
                            irpMinorString = "FSCTL_SET_COMPRESSION";
                            break;
                        case FSCTL_MARK_AS_SYSTEM_HIVE:
                            irpMinorString = "FSCTL_MARK_AS_SYSTEM_HIVE";
                            break;
                        case FSCTL_OPLOCK_BREAK_ACK_NO_2:
                            irpMinorString = "FSCTL_OPLOCK_BREAK_ACK_NO_2";
                            break;
                        case FSCTL_INVALIDATE_VOLUMES:
                            irpMinorString = "FSCTL_INVALIDATE_VOLUMES";
                            break;
                        case FSCTL_QUERY_FAT_BPB:
                            irpMinorString = "FSCTL_QUERY_FAT_BPB";
                            break;
                        case FSCTL_REQUEST_FILTER_OPLOCK:
                            irpMinorString = "FSCTL_REQUEST_FILTER_OPLOCK";
                            break;
                        case FSCTL_FILESYSTEM_GET_STATISTICS:
                            irpMinorString = "FSCTL_FILESYSTEM_GET_STATISTICS";
                            break;
                        case FSCTL_GET_NTFS_VOLUME_DATA:
                            irpMinorString = "FSCTL_GET_NTFS_VOLUME_DATA";
                            break;
                        case FSCTL_GET_NTFS_FILE_RECORD:
                            irpMinorString = "FSCTL_GET_NTFS_FILE_RECORD";
                            break;
                        case FSCTL_GET_VOLUME_BITMAP:
                            irpMinorString = "FSCTL_GET_VOLUME_BITMAP";
                            break;
                        case FSCTL_GET_RETRIEVAL_POINTERS:
                            irpMinorString = "FSCTL_GET_RETRIEVAL_POINTERS";
                            break;
                        case FSCTL_MOVE_FILE:
                            irpMinorString = "FSCTL_MOVE_FILE";
                            break;
                        case FSCTL_IS_VOLUME_DIRTY:
                            irpMinorString = "FSCTL_IS_VOLUME_DIRTY";
                            break;
                        case FSCTL_ALLOW_EXTENDED_DASD_IO:
                            irpMinorString = "FSCTL_ALLOW_EXTENDED_DASD_IO";
                            break;
                        case FSCTL_FIND_FILES_BY_SID:
                            irpMinorString = "FSCTL_FIND_FILES_BY_SID";
                            break;
                        case FSCTL_SET_OBJECT_ID:
                            irpMinorString = "FSCTL_SET_OBJECT_ID";
                            break;
                        case FSCTL_GET_OBJECT_ID:
                            irpMinorString = "FSCTL_GET_OBJECT_ID";
                            break;
                        case FSCTL_DELETE_OBJECT_ID:
                            irpMinorString = "FSCTL_DELETE_OBJECT_ID";
                            break;
                        case FSCTL_SET_REPARSE_POINT:
                            irpMinorString = "FSCTL_SET_REPARSE_POINT";
                            break;
                        case FSCTL_GET_REPARSE_POINT:
                            irpMinorString = "FSCTL_GET_REPARSE_POINT";
                            break;
                        case FSCTL_DELETE_REPARSE_POINT:
                            irpMinorString = "FSCTL_DELETE_REPARSE_POINT";
                            break;
                        case FSCTL_ENUM_USN_DATA:
                            irpMinorString = "FSCTL_ENUM_USN_DATA";
                            break;
                        case FSCTL_SECURITY_ID_CHECK:
                            irpMinorString = "FSCTL_SECURITY_ID_CHECK";
                            break;
                        case FSCTL_READ_USN_JOURNAL:
                            irpMinorString = "FSCTL_READ_USN_JOURNAL";
                            break;
                        case FSCTL_SET_OBJECT_ID_EXTENDED:
                            irpMinorString = "FSCTL_SET_OBJECT_ID_EXTENDED";
                            break;
                        case FSCTL_CREATE_OR_GET_OBJECT_ID:
                            irpMinorString = "FSCTL_CREATE_OR_GET_OBJECT_ID";
                            break;
                        case FSCTL_SET_SPARSE:
                            irpMinorString = "FSCTL_SET_SPARSE";
                            break;
                        case FSCTL_SET_ZERO_DATA:
                            irpMinorString = "FSCTL_SET_ZERO_DATA";
                            break;
                        case FSCTL_QUERY_ALLOCATED_RANGES:
                            irpMinorString = "FSCTL_QUERY_ALLOCATED_RANGES";
                            break;
                        case FSCTL_SET_ENCRYPTION:
                            irpMinorString = "FSCTL_SET_ENCRYPTION";
                            break;
                        case FSCTL_ENCRYPTION_FSCTL_IO:
                            irpMinorString = "FSCTL_ENCRYPTION_FSCTL_IO";
                            break;
                        case FSCTL_WRITE_RAW_ENCRYPTED:
                            irpMinorString = "FSCTL_WRITE_RAW_ENCRYPTED";
                            break;
                        case FSCTL_READ_RAW_ENCRYPTED:
                            irpMinorString = "FSCTL_READ_RAW_ENCRYPTED";
                            break;
                        case FSCTL_CREATE_USN_JOURNAL:
                            irpMinorString = "FSCTL_CREATE_USN_JOURNAL";
                            break;
                        case FSCTL_READ_FILE_USN_DATA:
                            irpMinorString = "FSCTL_READ_FILE_USN_DATA";
                            break;
                        case FSCTL_WRITE_USN_CLOSE_RECORD:
                            irpMinorString = "FSCTL_WRITE_USN_CLOSE_RECORD";
                            break;
                        case FSCTL_EXTEND_VOLUME:
                            irpMinorString = "FSCTL_EXTEND_VOLUME";
                            break;
                        case FSCTL_QUERY_USN_JOURNAL:
                            irpMinorString = "FSCTL_QUERY_USN_JOURNAL";
                            break;
                        case FSCTL_DELETE_USN_JOURNAL:
                            irpMinorString = "FSCTL_DELETE_USN_JOURNAL";
                            break;
                        case FSCTL_MARK_HANDLE:
                            irpMinorString = "FSCTL_MARK_HANDLE";
                            break;
                        case FSCTL_SIS_COPYFILE:
                            irpMinorString = "FSCTL_SIS_COPYFILE";
                            break;
                        case FSCTL_SIS_LINK_FILES:
                            irpMinorString = "FSCTL_SIS_LINK_FILES";
                            break;
                        case FSCTL_HSM_MSG:
                            irpMinorString = "FSCTL_HSM_MSG";
                            break;
                        case FSCTL_HSM_DATA:
                            irpMinorString = "FSCTL_HSM_DATA";
                            break;
                        case FSCTL_RECALL_FILE:
                            irpMinorString = "FSCTL_RECALL_FILE";
                            break;
                        case FSCTL_READ_FROM_PLEX:
                            irpMinorString = "FSCTL_READ_FROM_PLEX";
                            break;
                        case FSCTL_FILE_PREFETCH:
                            irpMinorString = "FSCTL_FILE_PREFETCH";
                            break;
                        default:
                            sprintf(nameBuf,"Unknown FSCTL (%u)",MinorCode);
                            irpMinorString = nameBuf;
                            break;
                    }

                    sprintf(nameBuf,"%s (USER)",irpMinorString);
                    irpMinorString = nameBuf;
                    break;

                case IRP_MN_MOUNT_VOLUME:
                    irpMinorString = "IRP_MN_MOUNT_VOLUME";
                    break;
                case IRP_MN_VERIFY_VOLUME:
                    irpMinorString = "IRP_MN_VERIFY_VOLUME";
                    break;
                case IRP_MN_LOAD_FILE_SYSTEM:
                    irpMinorString = "IRP_MN_LOAD_FILE_SYSTEM";
                    break;
                case IRP_MN_TRACK_LINK:
                    irpMinorString = "IRP_MN_TRACK_LINK";
                    break;
                default:
                    sprintf(nameBuf,UnknownIrpMinor,MinorCode);
                    irpMinorString = nameBuf;
            }
            break;

        case IRP_MJ_DEVICE_CONTROL:
            irpMajorString = "IRP_MJ_DEVICE_CONTROL";
            switch (MinorCode) {
                case 0:
                    irpMinorString = "User request";
                    break;
                case IRP_MN_SCSI_CLASS:
                    irpMinorString = "IRP_MN_SCSI_CLASS";
                    break;
                default:
                    sprintf(nameBuf,UnknownIrpMinor,MinorCode);
                    irpMinorString = nameBuf;
            }
            break;

        case IRP_MJ_INTERNAL_DEVICE_CONTROL:
            irpMajorString = "IRP_MJ_INTERNAL_DEVICE_CONTROL";
            break;
        case IRP_MJ_SHUTDOWN:
            irpMajorString = "IRP_MJ_SHUTDOWN";
            break;
        case IRP_MJ_LOCK_CONTROL:
            irpMajorString = "IRP_MJ_LOCK_CONTROL";
            switch (MinorCode) {
                case IRP_MN_LOCK:
                    irpMinorString = "IRP_MN_LOCK";
                    break;
                case IRP_MN_UNLOCK_SINGLE:
                    irpMinorString = "IRP_MN_UNLOCK_SINGLE";
                    break;
                case IRP_MN_UNLOCK_ALL:
                    irpMinorString = "IRP_MN_UNLOCK_ALL";
                    break;
                case IRP_MN_UNLOCK_ALL_BY_KEY:
                    irpMinorString = "IRP_MN_UNLOCK_ALL_BY_KEY";
                    break;
                default:
                    sprintf(nameBuf,UnknownIrpMinor,MinorCode);
                    irpMinorString = nameBuf;
            }
            break;

        case IRP_MJ_CLEANUP:
            irpMajorString = "IRP_MJ_CLEANUP";
            break;
        case IRP_MJ_CREATE_MAILSLOT:
            irpMajorString = "IRP_MJ_CREATE_MAILSLOT";
            break;
        case IRP_MJ_QUERY_SECURITY:
            irpMajorString = "IRP_MJ_QUERY_SECURITY";
            break;
        case IRP_MJ_SET_SECURITY:
            irpMajorString = "IRP_MJ_SET_SECURITY";
            break;
        case IRP_MJ_POWER:
            irpMajorString = "IRP_MJ_POWER";
            switch (MinorCode) {
                case IRP_MN_WAIT_WAKE:
                    irpMinorString = "IRP_MN_WAIT_WAKE";
                    break;
                case IRP_MN_POWER_SEQUENCE:
                    irpMinorString = "IRP_MN_POWER_SEQUENCE";
                    break;
                case IRP_MN_SET_POWER:
                    irpMinorString = "IRP_MN_SET_POWER";
                    break;
                case IRP_MN_QUERY_POWER:
                    irpMinorString = "IRP_MN_QUERY_POWER";
                    break;
                default :
                    sprintf(nameBuf,UnknownIrpMinor,MinorCode);
                    irpMinorString = nameBuf;
            }
            break;

        case IRP_MJ_SYSTEM_CONTROL:
            irpMajorString = "IRP_MJ_SYSTEM_CONTROL";
            switch (MinorCode) {
                case IRP_MN_QUERY_ALL_DATA:
                    irpMinorString = "IRP_MN_QUERY_ALL_DATA";
                    break;
                case IRP_MN_QUERY_SINGLE_INSTANCE:
                    irpMinorString = "IRP_MN_QUERY_SINGLE_INSTANCE";
                    break;
                case IRP_MN_CHANGE_SINGLE_INSTANCE:
                    irpMinorString = "IRP_MN_CHANGE_SINGLE_INSTANCE";
                    break;
                case IRP_MN_CHANGE_SINGLE_ITEM:
                    irpMinorString = "IRP_MN_CHANGE_SINGLE_ITEM";
                    break;
                case IRP_MN_ENABLE_EVENTS:
                    irpMinorString = "IRP_MN_ENABLE_EVENTS";
                    break;
                case IRP_MN_DISABLE_EVENTS:
                    irpMinorString = "IRP_MN_DISABLE_EVENTS";
                    break;
                case IRP_MN_ENABLE_COLLECTION:
                    irpMinorString = "IRP_MN_ENABLE_COLLECTION";
                    break;
                case IRP_MN_DISABLE_COLLECTION:
                    irpMinorString = "IRP_MN_DISABLE_COLLECTION";
                    break;
                case IRP_MN_REGINFO:
                    irpMinorString = "IRP_MN_REGINFO";
                    break;
                case IRP_MN_EXECUTE_METHOD:
                    irpMinorString = "IRP_MN_EXECUTE_METHOD";
                    break;
                default :
                    sprintf(nameBuf,UnknownIrpMinor,MinorCode);
                    irpMinorString = nameBuf;
            }
            break;

        case IRP_MJ_DEVICE_CHANGE:
            irpMajorString = "IRP_MJ_DEVICE_CHANGE";
            break;
        case IRP_MJ_QUERY_QUOTA:
            irpMajorString = "IRP_MJ_QUERY_QUOTA";
            break;
        case IRP_MJ_SET_QUOTA:
            irpMajorString = "IRP_MJ_SET_QUOTA";
            break;
        case IRP_MJ_PNP:
            irpMajorString = "IRP_MJ_PNP";
            switch (MinorCode) {
                case IRP_MN_START_DEVICE:
                    irpMinorString = "IRP_MN_START_DEVICE";
                    break;
                case IRP_MN_QUERY_REMOVE_DEVICE:
                    irpMinorString = "IRP_MN_QUERY_REMOVE_DEVICE";
                    break;
                case IRP_MN_REMOVE_DEVICE:
                    irpMinorString = "IRP_MN_REMOVE_DEVICE";
                    break;
                case IRP_MN_CANCEL_REMOVE_DEVICE:
                    irpMinorString = "IRP_MN_CANCEL_REMOVE_DEVICE";
                    break;
                case IRP_MN_STOP_DEVICE:
                    irpMinorString = "IRP_MN_STOP_DEVICE";
                    break;
                case IRP_MN_QUERY_STOP_DEVICE:
                    irpMinorString = "IRP_MN_QUERY_STOP_DEVICE";
                    break;
                case IRP_MN_CANCEL_STOP_DEVICE:
                    irpMinorString = "IRP_MN_CANCEL_STOP_DEVICE";
                    break;
                case IRP_MN_QUERY_DEVICE_RELATIONS:
                    irpMinorString = "IRP_MN_QUERY_DEVICE_RELATIONS";
                    break;
                case IRP_MN_QUERY_INTERFACE:
                    irpMinorString = "IRP_MN_QUERY_INTERFACE";
                    break;
                case IRP_MN_QUERY_CAPABILITIES:
                    irpMinorString = "IRP_MN_QUERY_CAPABILITIES";
                    break;
                case IRP_MN_QUERY_RESOURCES:
                    irpMinorString = "IRP_MN_QUERY_RESOURCES";
                    break;
                case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
                    irpMinorString = "IRP_MN_QUERY_RESOURCE_REQUIREMENTS";
                    break;
                case IRP_MN_QUERY_DEVICE_TEXT:
                    irpMinorString = "IRP_MN_QUERY_DEVICE_TEXT";
                    break;
                case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:
                    irpMinorString = "IRP_MN_FILTER_RESOURCE_REQUIREMENTS";
                    break;
                case IRP_MN_READ_CONFIG:
                    irpMinorString = "IRP_MN_READ_CONFIG";
                    break;
                case IRP_MN_WRITE_CONFIG:
                    irpMinorString = "IRP_MN_WRITE_CONFIG";
                    break;
                case IRP_MN_EJECT:
                    irpMinorString = "IRP_MN_EJECT";
                    break;
                case IRP_MN_SET_LOCK:
                    irpMinorString = "IRP_MN_SET_LOCK";
                    break;
                case IRP_MN_QUERY_ID:
                    irpMinorString = "IRP_MN_QUERY_ID";
                    break;
                case IRP_MN_QUERY_PNP_DEVICE_STATE:
                    irpMinorString = "IRP_MN_QUERY_PNP_DEVICE_STATE";
                    break;
                case IRP_MN_QUERY_BUS_INFORMATION:
                    irpMinorString = "IRP_MN_QUERY_BUS_INFORMATION";
                    break;
                case IRP_MN_DEVICE_USAGE_NOTIFICATION:
                    irpMinorString = "IRP_MN_DEVICE_USAGE_NOTIFICATION";
                    break;
                case IRP_MN_SURPRISE_REMOVAL:
                    irpMinorString = "IRP_MN_SURPRISE_REMOVAL";
                    break;
                case IRP_MN_QUERY_LEGACY_BUS_INFORMATION:
                    irpMinorString = "IRP_MN_QUERY_LEGACY_BUS_INFORMATION";
                    break;
                default :
                    sprintf(nameBuf,UnknownIrpMinor,MinorCode);
                    irpMinorString = nameBuf;
            }
            break;

        default:
            sprintf(nameBuf,"Unknown Irp major code (%u)",MajorCode);
            irpMajorString = nameBuf;
    }

    strcpy(MajorCodeName,irpMajorString);
    strcpy(MinorCodeName,irpMinorString);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\iotest\user\iotestlog.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    fspyLog.c

Abstract:

    This module contains functions used to retrieve and see the log records
    recorded by filespy.sys.

// @@BEGIN_DDKSPLIT
Author:

    Molly Brown (MollyBro) 21-Apr-1999

// @@END_DDKSPLIT

Environment:

    User mode


// @@BEGIN_DDKSPLIT
Revision History:

// @@END_DDKSPLIT
--*/
#include <stdio.h>
#include <windows.h>
#include <stdlib.h>
#include <winioctl.h>
#include "ioTestLog.h"
#include "ioTestLib.h"

#define TIME_BUFFER_LENGTH 20
#define TIME_ERROR         L"time error"

#define FlagOn(F,SF) ( \
    (((F) & (SF)))     \
)

VOID
DumpLogRecord (
    PLOG_RECORD pLogRecord,
    PLOG_CONTEXT context
    )
{
    PRECORD_IRP pRecordIrp;
    PRECORD_FASTIO pRecordFastIo;
    PRECORD_FS_FILTER_OPERATION pRecordFsFilterOp;
    ULONG nameLength;

    //
    //  Calculate the length of the name in the log record.
    //
    
    nameLength = pLogRecord->Length - SIZE_OF_LOG_RECORD;

    //
    // A LOG_RECORD could have Irp or FastIo data in it.  This
    // is denoted in the low-order byte of the RecordType flag.
    //

    switch (GET_RECORD_TYPE(pLogRecord)) {
    case RECORD_TYPE_IRP:

        //
        // We've got an Irp record, so output this data correctly.
        //
        pRecordIrp = &(pLogRecord->Record.RecordIrp);

        if (context->LogToScreen) {

            IrpScreenDump( pLogRecord->DeviceType,
                           pLogRecord->SequenceNumber,
                           pLogRecord->Name,
                           nameLength,
                           pRecordIrp,
                           context->VerbosityFlags);
        }

        if (context->LogToFile) {

            IrpFileDump( pLogRecord->DeviceType,
                         pLogRecord->SequenceNumber,
                         pLogRecord->Name,
                         nameLength,
                         pRecordIrp, 
                         context->OutputFile,
                         context->VerbosityFlags);
        }
        break;

    case RECORD_TYPE_FASTIO:

        //
        // We've got a FastIo record, so output this data correctly.
        //

        pRecordFastIo = &(pLogRecord->Record.RecordFastIo);

        if (context->LogToScreen) {

            FastIoScreenDump( pLogRecord->DeviceType,
                              pLogRecord->SequenceNumber,
                              pLogRecord->Name,
                              nameLength,
                              pRecordFastIo);
        }

        if (context->LogToFile) {

            FastIoFileDump( pLogRecord->DeviceType,
                            pLogRecord->SequenceNumber,
                            pLogRecord->Name,
                            nameLength,
                            pRecordFastIo,
                            context->OutputFile);
        }
        break;

    case RECORD_TYPE_FS_FILTER_OP:

        //
        //  We've got a FsFilter operation record, so output this
        //  data correctly.
        //

        pRecordFsFilterOp = &(pLogRecord->Record.RecordFsFilterOp);

        if (context->LogToScreen) {

            FsFilterOperationScreenDump( pLogRecord->DeviceType,
                                         pLogRecord->SequenceNumber,
                                         pLogRecord->Name,
                                         nameLength,
                                         pRecordFsFilterOp );

        }

        if (context->LogToFile) {

            FsFilterOperationFileDump( pLogRecord->DeviceType,
                                       pLogRecord->SequenceNumber,
                                       pLogRecord->Name,
                                       nameLength,
                                       pRecordFsFilterOp,
                                       context->OutputFile );
        }
        break;
        
    default:

        printf("Filmon:  Unknown log record type\n");
    }

    //
    // The RecordType could also designate that we are out of memory
    // or hit our program defined memory limit, so check for these
    // cases.
    // 

    if (pLogRecord->RecordType & RECORD_TYPE_OUT_OF_MEMORY) {

        if (context->LogToScreen) {

            printf("M %08X SYSTEM OUT OF MEMORY\n", pLogRecord->SequenceNumber);
        }

        if (context->LogToFile) {

            fprintf(context->OutputFile, "M:\t%u", pLogRecord->SequenceNumber);
        }

    } else if (pLogRecord->RecordType & RECORD_TYPE_EXCEED_MEMORY_ALLOWANCE) {

        if (context->LogToScreen) {

            printf("M %08X EXCEEDED MEMORY ALLOWANCE\n", pLogRecord->SequenceNumber);
        }

        if (context->LogToFile) {

            fprintf(context->OutputFile, "M:\t%u", pLogRecord->SequenceNumber);
        }
    }

}

DWORD WINAPI 
VerifyCurrentLogRecords (
    PLOG_CONTEXT Context,
    PEXPECTED_OPERATION ExpectedOps
)
{
    CHAR buffer[BUFFER_SIZE];
    DWORD bytesReturned = 0;
    BOOL bResult;
    DWORD result;
    PLOG_RECORD pLogRecord;
    BOOL askForMore = TRUE;
    BOOL testPassed = FALSE;
    ULONG currentOp = 0;
#ifdef USE_DO_HINT    
    BOOL keepVerifying = TRUE;
#else
    BOOL seenFirstOp = FALSE;
#endif /* USE_DO_HINT */

    while (askForMore) {

        //
        // Check to see if we should shut down
        //

        if (Context->CleaningUp) {

            break;
        }

        //
        // Request log data from filespy
        //

        bResult = DeviceIoControl( Context->Device,
                                   IOTEST_GetLog,
                                   NULL,
                                   0,
                                   buffer,
                                   BUFFER_SIZE,
                                   &bytesReturned,
                                   NULL);

        if (!bResult) {

            result = GetLastError();
            printf("ERROR controlling device: 0x%x\n", result);
        }

        //
        // Buffer is filled with a series of LOG_RECORD structures, one
        // right after another.  Each LOG_RECORD says how long it is, so
        // we know where the next LOG_RECORD begins.
        //

        pLogRecord = (PLOG_RECORD) buffer;

        //
        // Logic to write record to screen and/or file
        //

        while ((BYTE *) pLogRecord < buffer + bytesReturned) {

            PRECORD_IRP pRecordIrp;

            DumpLogRecord( pLogRecord, Context );

            switch (GET_RECORD_TYPE(pLogRecord)) {
            case RECORD_TYPE_IRP:
                
                pRecordIrp = &(pLogRecord->Record.RecordIrp);

#ifdef USE_DO_HINT
                if (keepVerifying) {

                    if (pRecordIrp->IrpMajor == ExpectedOps[currentOp].Op) {
                        if(pLogRecord->DeviceType != ExpectedOps[currentOp].Device) {

                            keepVerifying = FALSE;
                            
                        } else {

                            currentOp ++;
                        }
                    }
                }

#else

                //
                //  If we are not using the DeviceObject hint, we expect to
                //  see log entries from both the TOP and BOTTOM filters 
                //  for each expected operation.  So that we don't have to 
                //  redefine the ExpectedOperation array, just ignore the
                //  device in the array and check to make sure that you see
                //  a log record for the TOP_FILTER then the BOTTOM_FILTER for
                //  each operation in the array.
                //
                
                if (!seenFirstOp) {
                    
                    if ((pLogRecord->DeviceType == TOP_FILTER) &&
                        (pRecordIrp->IrpMajor == ExpectedOps[currentOp].Op)) {

                        seenFirstOp = TRUE;
                    }
                    
                } else {
                
                    if ((pLogRecord->DeviceType == BOTTOM_FILTER) &&
                        (pRecordIrp->IrpMajor == ExpectedOps[currentOp].Op)) {

                        seenFirstOp = FALSE;
                        currentOp ++;
                    }
                }
#endif /* USE_DO_HINT */                

                break;

            default:
    
                //
                //  ignore
                //
                ;
            }

            //
            // Move to next LOG_RECORD
            //

            pLogRecord = (PLOG_RECORD) (((BYTE *) pLogRecord) + pLogRecord->Length);
        }

        if (bytesReturned == 0) {

            askForMore = FALSE;
        }
    }

    if (ExpectedOps[currentOp].Op == IRP_MJ_MAXIMUM_FUNCTION + 1) {

        testPassed = TRUE;
    }

    if (testPassed) {

        printf( "User log verification:\tPASSED - Expected operations seen.\n" );

    } else {

        printf( "User log verification:\tFAILED - Expected operations NOT seen.\n" );
    }

    return testPassed;
}

DWORD WINAPI 
RetrieveLogRecords (
    LPVOID lpParameter
)
{
    PLOG_CONTEXT context = (PLOG_CONTEXT)lpParameter;
    CHAR buffer[BUFFER_SIZE];
    DWORD bytesReturned = 0;
    BOOL bResult;
    DWORD result;
    PLOG_RECORD pLogRecord;

    printf("Log: Starting up\n");

    while (TRUE) {

        //
        // Check to see if we should shut down
        //

        if (context->CleaningUp) {

            break;
        }

        //
        // Request log data from filespy
        //

        bResult = DeviceIoControl( context->Device,
                                   IOTEST_GetLog,
                                   NULL,
                                   0,
                                   buffer,
                                   BUFFER_SIZE,
                                   &bytesReturned,
                                   NULL);

        if (!bResult) {

            result = GetLastError();
            printf("ERROR controlling device: 0x%x\n", result);
        }

        //
        // Buffer is filled with a series of LOG_RECORD structures, one
        // right after another.  Each LOG_RECORD says how long it is, so
        // we know where the next LOG_RECORD begins.
        //

        pLogRecord = (PLOG_RECORD) buffer;

        //
        // Logic to write record to screen and/or file
        //

        while ((BYTE *) pLogRecord < buffer + bytesReturned) {


            DumpLogRecord( pLogRecord, context );

            //
            // Move to next LOG_RECORD
            //

            pLogRecord = (PLOG_RECORD) (((BYTE *) pLogRecord) + pLogRecord->Length);
        }

        if (bytesReturned == 0) {

            Sleep( 500 );
        }
    }

    printf("Log: Shutting down\n");
    ReleaseSemaphore(context->ShutDown, 1, NULL);
    printf("Log: All done\n");
    return 0;
}

VOID
PrintIrpCode (
    UCHAR MajorCode,
    UCHAR MinorCode,
    ULONG FsControlCode,
    FILE *OutputFile,
    BOOLEAN PrintMajorCode
    )
{
    CHAR irpMajorString[OPERATION_NAME_BUFFER_SIZE];
    CHAR irpMinorString[OPERATION_NAME_BUFFER_SIZE];
    CHAR formatBuf[OPERATION_NAME_BUFFER_SIZE*2];


    GetIrpName(MajorCode,MinorCode,FsControlCode,irpMajorString,irpMinorString);

    if (OutputFile) {

        sprintf(formatBuf, "%s  %s", irpMajorString, irpMinorString);
        fprintf(OutputFile, "\t%-50s", formatBuf);

    } else {

        if (PrintMajorCode) {

            printf("%-31s ", irpMajorString);

        } else {

            if (irpMinorString[0] != 0) {

                printf("                                         %-35s\n",
                        irpMinorString);
            }
        }
    }
}

VOID
PrintFastIoType (
    FASTIO_TYPE Code,
    FILE *OutputFile
    )
{
    CHAR outputString[OPERATION_NAME_BUFFER_SIZE];

    GetFastioName(Code,outputString);

    if (OutputFile) {

        fprintf(OutputFile, "%-50s", outputString);

    } else {

        printf("%-31s ", outputString);
    }
}

VOID
PrintFsFilterOperation (
    UCHAR Operation,
    FILE *OutputFile
    )
{
    CHAR outputString[OPERATION_NAME_BUFFER_SIZE];

    GetFsFilterOperationName(Operation,outputString);

    if (OutputFile) {
    
        fprintf( OutputFile, "%-50s", outputString );
        
    } else {

        printf( "%-31s ", outputString );
    }
}

ULONG
FormatSystemTime (
    SYSTEMTIME *SystemTime,
    PWCHAR Buffer,
    ULONG BufferLength
)
/*++
Routine Name:

    FormatSystemTime

Routine Description:

    Formats the values in a SystemTime struct into the buffer
    passed in.  The resulting string is NULL terminated.  The format
    for the time is:
        hours:minutes:seconds:milliseconds

Arguments:

    SystemTime - the struct to format
    Buffer - the buffer to place the formatted time in
    BufferLength - the size of the buffer in characters

Return Value:

    The number of characters returned in Buffer.

--*/
{
    PWCHAR writePosition;
    ULONG returnLength = 0;

    writePosition = Buffer;

    if (BufferLength < TIME_BUFFER_LENGTH) {

        //
        // Buffer is too short so exit
        //

        return 0;
    }

    returnLength = swprintf( Buffer,
                             L"%02d:%02d:%02d:%03d",
                             SystemTime->wHour,
                             SystemTime->wMinute,
                             SystemTime->wSecond,
                             SystemTime->wMilliseconds);

    return returnLength;
}

VOID
IrpFileDump (
    IOTEST_DEVICE_TYPE DeviceType,
    ULONG SequenceNumber,
    PWCHAR Name,
    ULONG NameLength,
    PRECORD_IRP RecordIrp,
    FILE *File,
    ULONG VerbosityFlags
)
/*++
Routine Name:

    IrpFileDump

Routine Description:

    Prints a Irp log record to the specified file.  The output is in a tab
    delimited format with the fields in the following order:

    SequenceNumber, OriginatingTime, CompletionTime, IrpMajor, IrpMinor,
    IrpFlags, NoCache, Paging I/O, Synchronous, Synchronous paging, FileName,
    ReturnStatus, FileName


Arguments:

    SequenceNumber - the sequence number for this log record
    Name - the name of the file that this Irp relates to
    NameLength - the length of Name in bytes
    RecordIrp - the Irp record to print
    File - the file to print to

Return Value:

    None.

--*/
{
    FILETIME    localTime;
    SYSTEMTIME  systemTime;
    WCHAR       time[TIME_BUFFER_LENGTH];

    switch (DeviceType) {
    case TOP_FILTER:
        fprintf(File, "TOP\tI\t%08X", SequenceNumber);
        break;
    case BOTTOM_FILTER:
        fprintf(File, "BOT\tI\t%08X", SequenceNumber);
        break;
    default:
        fprintf(File, "UNK\tI\t%08X", SequenceNumber);
        break;       
    }

    //
    // Convert originating time
    //

    FileTimeToLocalFileTime( (FILETIME *)&(RecordIrp->OriginatingTime), &localTime );
    FileTimeToSystemTime( &localTime, &systemTime );

    if (FormatSystemTime( &systemTime, time, TIME_BUFFER_LENGTH )) {

        fprintf( File, "\t%-12S", time );

    } else {

        fprintf( File, "\t%-12S", TIME_ERROR );
    }

    fprintf( File, "\t%8x.%-4x ", RecordIrp->ProcessId, RecordIrp->ThreadId );

    PrintIrpCode( RecordIrp->IrpMajor, RecordIrp->IrpMinor, (ULONG)(ULONG_PTR)RecordIrp->Argument3, File, TRUE );

    fprintf( File, "\t%08p", RecordIrp->FileObject );

    //
    // Interpret set flags
    //

    fprintf( File, "\t%08lx ", RecordIrp->IrpFlags );
    fprintf( File, "%s", (RecordIrp->IrpFlags & IRP_NOCACHE) ? "N":"-" );
    fprintf( File, "%s", (RecordIrp->IrpFlags & IRP_PAGING_IO) ? "P":"-" );
    fprintf( File, "%s", (RecordIrp->IrpFlags & IRP_SYNCHRONOUS_API) ? "S":"-" );
    fprintf( File, "%s", (RecordIrp->IrpFlags & IRP_SYNCHRONOUS_PAGING_IO) ? "Y":"-" );

    if (FlagOn( VerbosityFlags, FS_VF_DUMP_PARAMETERS )) {

        fprintf( File,
                 "%p %p %p %p ", 
                 RecordIrp->Argument1,
                 RecordIrp->Argument2,
                 RecordIrp->Argument3,
                 RecordIrp->Argument4 );
        
        if (IRP_MJ_CREATE == RecordIrp->IrpMajor) {

            fprintf( File, "DesiredAccess->%08lx ", RecordIrp->DesiredAccess );
        }
    }

    fprintf( File, "\t%.*S", NameLength/sizeof(WCHAR), Name );
    fprintf( File, "\n" );
}

VOID
IrpScreenDump (
    IOTEST_DEVICE_TYPE DeviceType,
    ULONG SequenceNumber,
    PWCHAR Name,
    ULONG NameLength,
    PRECORD_IRP RecordIrp,
    ULONG VerbosityFlags
)
/*++
Routine Name:

    IrpScreenDump

Routine Description:

    Prints a Irp log record to the screen in the following order:
    SequenceNumber, OriginatingTime, CompletionTime, IrpMajor, IrpMinor,
    IrpFlags, NoCache, Paging I/O, Synchronous, Synchronous paging,
    FileName, ReturnStatus, FileName

Arguments:

    SequenceNumber - the sequence number for this log record
    Name - the file name to which this Irp relates
    NameLength - the length of Name in bytes
    RecordIrp - the Irp record to print

Return Value:

    None.

--*/
{
    FILETIME localTime;
    SYSTEMTIME systemTime;
    WCHAR time[TIME_BUFFER_LENGTH];

    switch (DeviceType) {
    case TOP_FILTER:
        printf("TOP I %08X", SequenceNumber);
        break;
    case BOTTOM_FILTER:
        printf("BOT I %08X", SequenceNumber);
        break;
    default:
        printf("UNK I %08X", SequenceNumber);
        break;       
    }

    //
    // Convert originating time
    //

    FileTimeToLocalFileTime( (FILETIME *)&(RecordIrp->OriginatingTime), &localTime );
    FileTimeToSystemTime( &localTime, &systemTime );

    if (FormatSystemTime( &systemTime, time, TIME_BUFFER_LENGTH )) {

        printf( "%-12S ", time );

    } else {

        printf( "%-12S ", TIME_ERROR );
    }

    printf( "%8x.%-4x ", RecordIrp->ProcessId, RecordIrp->ThreadId );

    PrintIrpCode( RecordIrp->IrpMajor, RecordIrp->IrpMinor, (ULONG)(ULONG_PTR)RecordIrp->Argument3, NULL, TRUE );

    printf( "%08p ", RecordIrp->FileObject );

    //
    // Interpret set flags
    //

    printf( "%08lx ", RecordIrp->IrpFlags );
    printf( "%s", (RecordIrp->IrpFlags & IRP_NOCACHE) ? "N":"-" );
    printf( "%s", (RecordIrp->IrpFlags & IRP_PAGING_IO) ? "P":"-" );
    printf( "%s", (RecordIrp->IrpFlags & IRP_SYNCHRONOUS_API) ? "S":"-" );
    printf( "%s ", (RecordIrp->IrpFlags & IRP_SYNCHRONOUS_PAGING_IO) ? "Y":"-" );

    if (FlagOn( VerbosityFlags, FS_VF_DUMP_PARAMETERS )) {

        printf( "%p %p %p %p  ", 
                RecordIrp->Argument1,
                RecordIrp->Argument2,
                RecordIrp->Argument3,
                RecordIrp->Argument4 );
        
        if (IRP_MJ_CREATE == RecordIrp->IrpMajor) {

            printf( "DesiredAccess->%08lx ", RecordIrp->DesiredAccess );
        }
    }

    printf( "%.*S", NameLength/sizeof(WCHAR), Name );
    printf( "\n" );
    PrintIrpCode( RecordIrp->IrpMajor, RecordIrp->IrpMinor, (ULONG)(ULONG_PTR)RecordIrp->Argument3, NULL, FALSE );
}

VOID
FastIoFileDump (
    IOTEST_DEVICE_TYPE DeviceType,
    ULONG SequenceNumber,
    PWCHAR Name,
    ULONG NameLength,
    PRECORD_FASTIO RecordFastIo,
    FILE *File
)
/*++
Routine Name:

    FastIoFileDump

Routine Description:

    Prints a FastIo log record to the specified file.  The output is in a tab
    delimited format with the fields in the following order:
    SequenceNumber, StartTime, CompletionTime, Fast I/O Type, FileName,
    Length, Wait, ReturnStatus, FileName

Arguments:

    SequenceNumber - the sequence number for this log record
    Name - the name of the file referenced by this Fast I/O operation
    NameLength - the length of name in bytes
    RecordFastIo - the FastIo record to print
    File - the file to print to

Return Value:

    None.

--*/
{
    SYSTEMTIME systemTime;
    FILETIME localTime;
    WCHAR time[TIME_BUFFER_LENGTH];

    switch (DeviceType) {
    case TOP_FILTER:
        fprintf(File, "TOP\tF\t%08X", SequenceNumber);
        break;
    case BOTTOM_FILTER:
        fprintf(File, "BOT\tF\t%08X", SequenceNumber);
        break;
    default:
        fprintf(File, "UNK\tF\t%08X", SequenceNumber);
        break;       
    }

    //
    // Convert start time
    //

    FileTimeToLocalFileTime( (FILETIME *)&(RecordFastIo->StartTime), &localTime );
    FileTimeToSystemTime( &localTime, &systemTime );

    if (FormatSystemTime( &systemTime, time, TIME_BUFFER_LENGTH )) {

        fprintf( File, "\t%-12S", time );

    } else {

        fprintf( File, "\t%-12S", TIME_ERROR );
    }

    fprintf( File, "\t%8x.%-4x ", RecordFastIo->ProcessId, RecordFastIo->ThreadId );

    fprintf( File, "\t" );
    PrintFastIoType( RecordFastIo->Type, File );

    fprintf( File, "\t%08p", RecordFastIo->FileObject );

    fprintf( File, "\t%s", (RecordFastIo->Wait)?"T":"F" );
    fprintf( File, "\t%08x", RecordFastIo->Length );
    fprintf( File, "\t%016I64x ", RecordFastIo->FileOffset );

    fprintf( File, "\t%.*S", NameLength/sizeof(WCHAR), Name );
    fprintf( File, "\n" );
}

VOID
FastIoScreenDump (
    IOTEST_DEVICE_TYPE DeviceType,
    ULONG SequenceNumber,
    PWCHAR Name,
    ULONG NameLength,
    PRECORD_FASTIO RecordFastIo
)
/*++
Routine Name:

    FastIoScreenDump

Routine Description:

    Prints a FastIo log record to the screen in the following order:
    SequenceNumber, StartTime, CompletionTime, Fast I/O Type, FileName,
    Length, Wait, ReturnStatus, FileName

Arguments:

    SequenceNumber - the sequence number for this log record
    Name - the name of the file referenced by this Fast I/O operation
    NameLength - the length of name in bytes
    RecordIrp - the Irp record to print

Return Value:

    None.

--*/
{
    SYSTEMTIME systemTime;
    FILETIME localTime;
    WCHAR time[TIME_BUFFER_LENGTH];

    switch (DeviceType) {
    case TOP_FILTER:
        printf("TOP F %08X", SequenceNumber);
        break;
    case BOTTOM_FILTER:
        printf("BOT F %08X", SequenceNumber);
        break;
    default:
        printf("UNK F %08X", SequenceNumber);
        break;       
    }
    
    //
    // Convert start time
    //

    FileTimeToLocalFileTime( (FILETIME *)&(RecordFastIo->StartTime), &localTime );
    FileTimeToSystemTime( &localTime, &systemTime );

    if (FormatSystemTime( &systemTime, time, TIME_BUFFER_LENGTH )) {

        printf( "%-12S ", time );

    } else {

        printf( "%-12S ", TIME_ERROR );
    }

    printf( "%8x.%-4x ", RecordFastIo->ProcessId, RecordFastIo->ThreadId );

    PrintFastIoType( RecordFastIo->Type, NULL );

    printf( "%08p ", RecordFastIo->FileObject );

    printf( "%s ", (RecordFastIo->Wait)?"T":"F" );
    printf( "%08x ", RecordFastIo->Length );
    printf( "%016I64x ", RecordFastIo->FileOffset );

    printf( "%.*S", NameLength/sizeof(WCHAR), Name );
    printf ("\n" );
}

VOID
FsFilterOperationFileDump (
    IOTEST_DEVICE_TYPE DeviceType,
    ULONG SequenceNumber,
    PWCHAR Name,
    ULONG NameLength,
    PRECORD_FS_FILTER_OPERATION RecordFsFilterOp,
    FILE *File
)
/*++
Routine Name:

    FsFilterOperationFileDump

Routine Description:

    Prints a FsFilterOperation log record to the specified file.  The output is in a tab
    delimited format with the fields in the following order:

    SequenceNumber, OriginatingTime, CompletionTime, ProcessId, ThreadId,
    Operation, FileObject, ReturnStatus, FileName

Arguments:

    SequenceNumber - the sequence number for this log record
    Name - the name of the file that this operation relates to
    NameLength - the length of Name in bytes
    RecordFsFilterOp - the FsFilter operation record to print
    File - the file to print to

Return Value:

    None.

--*/
{
    FILETIME    localTime;
    SYSTEMTIME  systemTime;
    WCHAR       time[TIME_BUFFER_LENGTH];

    switch (DeviceType) {
    case TOP_FILTER:
        fprintf(File, "TOP\tO\t%08X", SequenceNumber);
        break;
    case BOTTOM_FILTER:
        fprintf(File, "BOT\tO\t%08X", SequenceNumber);
        break;
    default:
        fprintf(File, "UNK\tO\t%08X", SequenceNumber);
        break;       
    }

    //
    // Convert originating time
    //

    FileTimeToLocalFileTime( (FILETIME *)&(RecordFsFilterOp->OriginatingTime), &localTime );
    FileTimeToSystemTime( &localTime, &systemTime );

    if (FormatSystemTime( &systemTime, time, TIME_BUFFER_LENGTH )) {

        fprintf( File, "\t%-12S", time );

    } else {

        fprintf( File, "\t%-12S", TIME_ERROR );
    }

    //
    //  Output the process and thread id
    //

    fprintf( File, "\t%8x.%-4x ", RecordFsFilterOp->ProcessId, RecordFsFilterOp->ThreadId );

    //
    //  Output the FsFilter operation parameters
    //
    
    PrintFsFilterOperation( RecordFsFilterOp->FsFilterOperation, File );

    fprintf( File, "\t%08p", RecordFsFilterOp->FileObject );
    fprintf( File, "\t%.*S", NameLength/sizeof(WCHAR), Name );
    fprintf( File, "\n" );
}

VOID
FsFilterOperationScreenDump (
    IOTEST_DEVICE_TYPE DeviceType,
    ULONG SequenceNumber,
    PWCHAR Name,
    ULONG NameLength,
    PRECORD_FS_FILTER_OPERATION RecordFsFilterOp
)
/*++
Routine Name:

    FsFilterOperationScreenDump

Routine Description:

    Prints a FsFilterOperation log record to the screen in the following order:
    
    SequenceNumber, OriginatingTime, CompletionTime, ProcessId, ThreadId,
    Operation, FileObject, ReturnStatus, FileName

Arguments:

    SequenceNumber - the sequence number for this log record
    Name - the file name to which this Irp relates
    NameLength - the length of name in bytes
    RecordFsFilterOp - the FsFilterOperation record to print

Return Value:

    None.

--*/
{
    FILETIME localTime;
    SYSTEMTIME systemTime;
    WCHAR time[TIME_BUFFER_LENGTH];

    switch (DeviceType) {
    case TOP_FILTER:
        printf("TOP O %08X", SequenceNumber);
        break;
    case BOTTOM_FILTER:
        printf("BOT O %08X", SequenceNumber);
        break;
    default:
        printf("UNK O %08X", SequenceNumber);
        break;       
    }

    //
    // Convert originating time
    //

    FileTimeToLocalFileTime( (FILETIME *)&(RecordFsFilterOp->OriginatingTime), &localTime );
    FileTimeToSystemTime( &localTime, &systemTime );

    if (FormatSystemTime( &systemTime, time, TIME_BUFFER_LENGTH )) {

        printf( "%-12S ", time );

    } else {

        printf( "%-12S ", TIME_ERROR );
    }

    printf( "%8x.%-4x ", RecordFsFilterOp->ProcessId, RecordFsFilterOp->ThreadId );

    PrintFsFilterOperation( RecordFsFilterOp->FsFilterOperation, NULL );

    //
    // Print FsFilter operation specific values.
    //

    printf( "%08p ", RecordFsFilterOp->FileObject );
    printf( "%.*S", NameLength/sizeof(WCHAR),Name );
    printf( "\n" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\iotest\user\iotestlog.h ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    log.h

Abstract:

    This module contains the structures and prototypes used by the user 
    program to retrieve and see the log records recorded by filespy.sys.
    
// @@BEGIN_DDKSPLIT
Author:

    Molly Brown (MollyBro) 21-Apr-1999

// @@END_DDKSPLIT
Environment:

    User mode


// @@BEGIN_DDKSPLIT
Revision History:

// @@END_DDKSPLIT
--*/
#ifndef __IOTESTLOG_H__
#define __IOTESTLOG_H__

#include <stdio.h>
#include "ioTest.h"

#define BUFFER_SIZE     4096

typedef struct _LOG_CONTEXT{
    HANDLE  Device;
    BOOLEAN LogToScreen;
    BOOLEAN LogToFile;
    ULONG   VerbosityFlags;     //  FS_VF_DUMP_PARAMETERS, etc.
    FILE   *OutputFile;

    BOOLEAN NextLogToScreen;

    // For synchronizing shutting down of both threads
    BOOLEAN CleaningUp;
    HANDLE  ShutDown;
}LOG_CONTEXT, *PLOG_CONTEXT;

DWORD WINAPI 
RetrieveLogRecords(
    LPVOID lpParameter
);
                
VOID
IrpFileDump(
    IOTEST_DEVICE_TYPE DeviceType,
    ULONG SequenceNumber,
    PWCHAR Name,
    ULONG NameLength,
    PRECORD_IRP RecordIrp,
    FILE *File,
    ULONG Verbosity
);

VOID
IrpScreenDump(
    IOTEST_DEVICE_TYPE DeviceType,
    ULONG SequenceNumber,
    PWCHAR Name,
    ULONG NameLength,
    PRECORD_IRP RecordIrp,
    ULONG Verbosity
);

VOID
FastIoFileDump(
    IOTEST_DEVICE_TYPE DeviceType,
    ULONG SequenceNumber,
    PWCHAR Name,
    ULONG NameLength,
    PRECORD_FASTIO RecordFastIo,
    FILE *File
);

VOID
FastIoScreenDump(
    IOTEST_DEVICE_TYPE DeviceType,
    ULONG SequenceNumber,
    PWCHAR Name,
    ULONG NameLength,
    PRECORD_FASTIO RecordFastIo
);

VOID
FsFilterOperationFileDump (
    IOTEST_DEVICE_TYPE DeviceType,
    ULONG SequenceNumber,
    PWCHAR Name,
    ULONG NameLength,
    PRECORD_FS_FILTER_OPERATION RecordFsFilterOp,
    FILE *File
);

VOID
FsFilterOperationScreenDump (
    IOTEST_DEVICE_TYPE DeviceType,
    ULONG SequenceNumber,
    PWCHAR Name,
    ULONG NameLength,
    PRECORD_FS_FILTER_OPERATION RecordFsFilterOp
);

#define IRP_NOCACHE                     0x00000001
#define IRP_PAGING_IO                   0x00000002
#define IRP_SYNCHRONOUS_API             0x00000004
#define IRP_SYNCHRONOUS_PAGING_IO       0x00000040

#define FS_FILTER_ACQUIRE_FOR_SECTION_SYNCHRONIZATION    (UCHAR)-1
#define FS_FILTER_RELEASE_FOR_SECTION_SYNCHRONIZATION    (UCHAR)-2
#define FS_FILTER_ACQUIRE_FOR_MOD_WRITE                  (UCHAR)-3
#define FS_FILTER_RELEASE_FOR_MOD_WRITE                  (UCHAR)-4
#define FS_FILTER_ACQUIRE_FOR_CC_FLUSH                   (UCHAR)-5
#define FS_FILTER_RELEASE_FOR_CC_FLUSH                   (UCHAR)-6

//
//  Verbosity flags.
//

#define FS_VF_DUMP_PARAMETERS           0x00000001

VOID
DisplayError (
   DWORD Code
   );

VOID
ReadTest (
    PLOG_CONTEXT Context,
    PWCHAR DriveName,
    ULONG  DriveNameLength,
    BOOLEAN TopOfStack
    );

VOID
RenameTest (
    PLOG_CONTEXT Context,
    PWCHAR DriveName,
    ULONG  DriveNameLength,
    BOOLEAN TopOfStack
    );

VOID
ShareTest (
    PLOG_CONTEXT Context,
    PWCHAR DriveName,
    ULONG  DriveNameLength,
    BOOLEAN TopOfStack
    );

DWORD WINAPI 
VerifyCurrentLogRecords (
    PLOG_CONTEXT Context,
    PEXPECTED_OPERATION ExpectedOps
);

#endif __IOTESTLOG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\iotest\lib\namelists.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    irpNameList.c

Abstract:

    This module contains an array of unicode IRP names.

// @@BEGIN_DDKSPLIT
Author:

    Neal Christiansen (NealCH) 29-Sep-2000

// @@END_DDKSPLIT

Environment:

    User mode


// @@BEGIN_DDKSPLIT
Revision History:

// @@END_DDKSPLIT
--*/

#include <ntifs.h>
#include "ioTestLib.h"

//
//  List of unicode irp names
//

PWCHAR IrpNameList[IRP_MJ_MAXIMUM_FUNCTION+1] = 
{
    L"IRP_MJ_CREATE",
    L"IRP_MJ_CREATE_NAMED_PIPE",
    L"IRP_MJ_CLOSE",
    L"IRP_MJ_READ",
    L"IRP_MJ_WRITE",
    L"IRP_MJ_QUERY_INFORMATION",
    L"IRP_MJ_SET_INFORMATION",
    L"IRP_MJ_QUERY_EA",
    L"IRP_MJ_SET_EA",
    L"IRP_MJ_FLUSH_BUFFERS",
    L"IRP_MJ_QUERY_VOLUME_INFORMATION",
    L"IRP_MJ_SET_VOLUME_INFORMATION",
    L"IRP_MJ_DIRECTORY_CONTROL",
    L"IRP_MJ_FILE_SYSTEM_CONTROL",
    L"IRP_MJ_DEVICE_CONTROL",
    L"IRP_MJ_INTERNAL_DEVICE_CONTROL",
    L"IRP_MJ_SHUTDOWN",
    L"IRP_MJ_LOCK_CONTROL",
    L"IRP_MJ_CLEANUP",
    L"IRP_MJ_CREATE_MAILSLOT",
    L"IRP_MJ_QUERY_SECURITY",
    L"IRP_MJ_SET_SECURITY",
    L"IRP_MJ_POWER",
    L"IRP_MJ_SYSTEM_CONTROL",
    L"IRP_MJ_DEVICE_CHANGE",
    L"IRP_MJ_QUERY_QUOTA",
    L"IRP_MJ_SET_QUOTA",
    L"IRP_MJ_PNP"
};


PWCHAR FastIoNameList[FASTIO_MAX_OPERATION] =
{
    L"CHECK_IF_POSSIBLE",
    L"READ",
    L"WRITE",
    L"QUERY_BASIC_INFO",
    L"QUERY_STANDARD_INFO",
    L"LOCK",
    L"UNLOCK_SINGLE",
    L"UNLOCK_ALL",
    L"UNLOCK_ALL_BY_KEY",
    L"DEVICE_CONTROL",
    L"DETACH_DEVICE",
    L"QUERY_NETWORK_OPEN_INFO",
    L"MDL_READ",
    L"MDL_READ_COMPLETE",
    L"MDL_WRITE",
    L"MDL_WRITE_COMPLETE",
    L"READ_COMPRESSED",
    L"WRITE_COMPRESSED",
    L"MDL_READ_COMPLETE_COMPRESSED",
    L"PREPARE_MDL_WRITE",
    L"MDL_WRITE_COMPLETE_COMPRESSED",
    L"QUERY_OPEN_STRING",
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\iotest\user\iotestuser.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    fspyUser.c

Abstract:

    This file contains the implementation for the main function of the 
    user application piece of IoTest.  This function is responsible for
    controlling the command mode available to the user to control the 
    kernel mode driver.
    
// @@BEGIN_DDKSPLIT
Author:

    George Jenkins (GeorgeJe)                       

// @@END_DDKSPLIT
Environment:

    User mode


// @@BEGIN_DDKSPLIT

Revision History:

    Molly Brown (MollyBro) 21-Apr-1999
        Broke out the logging code and added command mode functionality.

// @@END_DDKSPLIT
--*/

#include <windows.h>                
#include <stdlib.h>
#include <stdio.h>
#include <winioctl.h>
#include <string.h>
#include <crtdbg.h>
#include "ioTest.h"
#include "ioTestLog.h"
#include "ioTestLib.h"

#define SUCCESS              0
#define USAGE_ERROR          1
#define EXIT_INTERPRETER     2
#define EXIT_PROGRAM         4

#define INTERPRETER_EXIT_COMMAND1 "go"
#define INTERPRETER_EXIT_COMMAND2 "g"
#define PROGRAM_EXIT_COMMAND      "exit"

#define ToggleFlag(V, F) (V = (((V) & (F)) ? (V & (~F)) : (V | F)))

DWORD
InterpretCommand(
    int argc,
    char *argv[],
    PLOG_CONTEXT Context
);

BOOL
ListDevices(
    PLOG_CONTEXT Context
);

VOID
DisplayError (
   DWORD Code
   );

int _cdecl main(int argc, char *argv[])
{
    SC_HANDLE               hSCManager = NULL;
    SC_HANDLE               hService = NULL;
    SERVICE_STATUS_PROCESS  serviceInfo;
    DWORD                   bytesNeeded;
    HANDLE                  hDevice = INVALID_HANDLE_VALUE;
    DWORD                   result;
    LOG_CONTEXT             context;

    //
    // Initialize handle in case of error
    //

    context.ShutDown = NULL;
    context.VerbosityFlags = 0;

    //
    // Start the kernel mode driver through the service manager
    //
    
    hSCManager = OpenSCManager (NULL, NULL, SC_MANAGER_ALL_ACCESS) ;
    hService = OpenService( hSCManager,
                            IOTEST_SERVICE_NAME,
                            IOTEST_SERVICE_ACCESS);
    if (!QueryServiceStatusEx( hService,
                               SC_STATUS_PROCESS_INFO,
                               (UCHAR *)&serviceInfo,
                               sizeof(serviceInfo),
                               &bytesNeeded)) {
        result = GetLastError();
        DisplayError( result );
        goto Main_Exit;
    }

    if(serviceInfo.dwCurrentState != SERVICE_RUNNING) {
        //
        // Service hasn't been started yet, so try to start service
        //
        if (!StartService(hService, 0, NULL)) {
            result = GetLastError();
            printf("ERROR starting IoTest...\n");
            DisplayError( result );
            goto Main_Exit;
        }
    }
   
    //
    //  Open the device that is used to talk to IoTest.
    //
    
    hDevice = CreateFile( IOTEST_W32_DEVICE_NAME,
                          GENERIC_READ | GENERIC_WRITE,
                          0,
                          NULL,
                          OPEN_EXISTING,
                          FILE_ATTRIBUTE_NORMAL,
                          NULL);
    if (hDevice == INVALID_HANDLE_VALUE) {
        result = GetLastError();
        printf("ERROR opening device...\n");
        DisplayError( result );
        goto Main_Exit;
    }
    
    //
    //  Initialize the fields of the LOG_CONTEXT.
    //
    context.Device = hDevice;
    context.CleaningUp = FALSE;
    context.LogToScreen = TRUE;
    context.LogToFile = FALSE;
    context.OutputFile = NULL;

    //
    // Check the valid parameters for startup
    //
    InterpretCommand(argc - 1, &(argv[1]), &context);

    // 
    // Wait for everyone to shut down
    //
    if (context.LogToFile) {
        fclose(context.OutputFile);
    }

Main_Exit:
    // 
    // Clean up the data that is alway around and exit
    //
    if(hSCManager) {
        CloseServiceHandle(hSCManager);
    }
    if(hService) {
        CloseServiceHandle(hService);
    }
    if (hDevice != INVALID_HANDLE_VALUE) {
        CloseHandle(hDevice);
    }
    
    return 0;  

}


DWORD
InterpretCommand(
    int argc,
    char *argv[],
    PLOG_CONTEXT Context
)
{
    int         parmIndex;
    CHAR       *parm;      
    BOOL        bResult;
    DWORD       result;
    DWORD       returnValue = SUCCESS;
    CHAR        buffer[BUFFER_SIZE];
    DWORD       bufferLength;

    if (argc == 0) {

        goto InterpretCommand_Usage;
    }
    
    //
    // Interprete the command line parameters
    //
    for (parmIndex = 0; parmIndex < argc; parmIndex++) {
        parm = argv[parmIndex];
        if (parm[0] == '/') {
            //
            // Have the beginning of a switch
            //
            switch (parm[1]) {
            case 'l':
            case 'L':
                //
                // List all devices that are currently being monitored
                //
                bResult = ListDevices(Context);
                if (!bResult) {
                    result = GetLastError();
                    printf("ERROR listing devices...\n");
                    DisplayError( result );
                }
                
                break;

            case 'n':
            case 'N':
                //
                // Run RENAME test on specified drive
                //
                parmIndex++;
                if (parmIndex >= argc) {
                    //
                    // Not enough parameters
                    //
                    goto InterpretCommand_Usage;
                }
                parm = argv[parmIndex];
                printf("\tPerforming RENAME test on %s\n", parm);
                bufferLength = MultiByteToWideChar(
                    CP_ACP,
                    MB_ERR_INVALID_CHARS,
                    parm,
                    -1,
                    (LPWSTR)buffer,
                    BUFFER_SIZE/sizeof(WCHAR));

                RenameTest( Context, (LPWSTR)buffer, bufferLength * sizeof(WCHAR), FALSE );
                RenameTest( Context, (LPWSTR)buffer, bufferLength * sizeof(WCHAR), TRUE );
                
                break;

            case 'r':
            case 'R':
                //
                // Run READ test on specified drive
                //
                parmIndex++;
                if (parmIndex >= argc) {
                    //
                    // Not enough parameters
                    //
                    goto InterpretCommand_Usage;
                }
                parm = argv[parmIndex];
                printf("\tPerforming READ test on %s\n", parm);
                bufferLength = MultiByteToWideChar(
                    CP_ACP,
                    MB_ERR_INVALID_CHARS,
                    parm,
                    -1,
                    (LPWSTR)buffer,
                    BUFFER_SIZE/sizeof(WCHAR));

                ReadTest( Context, (LPWSTR)buffer, bufferLength * sizeof(WCHAR), FALSE );
                ReadTest( Context, (LPWSTR)buffer, bufferLength * sizeof(WCHAR), TRUE );
                
                break;

            case 'h':
            case 'H':
                //
                // Run SHARE test on specified drive
                //
                parmIndex++;
                if (parmIndex >= argc) {
                    //
                    // Not enough parameters
                    //
                    goto InterpretCommand_Usage;
                }
                parm = argv[parmIndex];
                printf("\tPerforming SHARE test on %s\n", parm);
                bufferLength = MultiByteToWideChar(
                    CP_ACP,
                    MB_ERR_INVALID_CHARS,
                    parm,
                    -1,
                    (LPWSTR)buffer,
                    BUFFER_SIZE/sizeof(WCHAR));

                ShareTest( Context, (LPWSTR)buffer, bufferLength * sizeof(WCHAR), FALSE );
                ShareTest( Context, (LPWSTR)buffer, bufferLength * sizeof(WCHAR), TRUE );
                
                break;

            case 's':
            case 'S':
                //
                // Output logging results to screen, save new value to
                // instate when command interpreter is exited.
                //
                if (Context->NextLogToScreen) {
                    printf("\tTurning off logging to screen\n");
                } else {
                    printf("\tTurning on logging to screen\n");
                }
                Context->NextLogToScreen = !Context->NextLogToScreen;
                break;

            case 'f':
            case 'F':
                //
                // Output logging results to file
                //
                if (Context->LogToFile) {
                    printf("\tStop logging to file \n");
                    Context->LogToFile = FALSE;
                    _ASSERT(Context->OutputFile);
                    fclose(Context->OutputFile);
                    Context->OutputFile = NULL;
                } else {
                    parmIndex++;
                    if (parmIndex >= argc) {
                        // Not enough parameters
                        goto InterpretCommand_Usage;
                    }
                    parm = argv[parmIndex];
                    printf("\tLog to file %s\n", parm);
                    Context->OutputFile = fopen(parm, "w");
                    _ASSERT(Context->OutputFile);
                    Context->LogToFile = TRUE;
                }
                break;

            case '?':
            default:
                //
                // Invalid switch, goto usage
                //
                goto InterpretCommand_Usage;
            }
        } else {
            //
            // Invalid parameter
            //
            goto InterpretCommand_Usage;
        }
    }

InterpretCommand_Exit:
    return returnValue;

InterpretCommand_Usage:
    printf("Usage: [[/r <drive>]...] [[/n <drive>]...] [[/h <drive>]...] [/l] [/s] [/f <file name>] \n"
           "\t[/r <drive>] runs the READ test on <drive>\n"
           "\t[/n <drive>] runs the RENAME test on <drive>\n"
           "\t[/h <drive>] runs the SHARE test on <drive>\n"
           "\n"
           "\t[/l] lists all the drives the monitor is currently attached to\n"
           "\t[/s] turns on and off showing logging output on the screen\n"
           "\t[/f <file name>] turns on and off logging to the specified file\n"
           );
    returnValue = USAGE_ERROR;
    goto InterpretCommand_Exit;
}

BOOL
ListDevices(
    PLOG_CONTEXT Context
)
{
    CHAR             buffer[BUFFER_SIZE];
    ULONG            bytesReturned;
    BOOL             returnValue;

    returnValue = DeviceIoControl(
        Context->Device,
        IOTEST_ListDevices,
        NULL,
        0,
        buffer,
        BUFFER_SIZE,
        &bytesReturned,
        NULL);

    if (returnValue) {
        PATTACHED_DEVICE device = (PATTACHED_DEVICE) buffer;


        printf("DEVICE NAME                       | LOGGING STATUS\n");
        printf("--------------------------------------------------\n");

        if (bytesReturned == 0) {
            printf("No devices attached\n");
        } else {
            while ((BYTE *)device < buffer + bytesReturned) {
                switch (device->DeviceType) {
                case TOP_FILTER:
                    printf(
                        "TOP %-30S| %s\n",
                        device->DeviceNames, 
                        (device->LoggingOn)?"ON":"OFF");
                    break;
                    
                case BOTTOM_FILTER:
                    printf(
                        "BOT %-30S| %s\n",
                        device->DeviceNames, 
                        (device->LoggingOn)?"ON":"OFF");
                    break;
                }
                device ++;
            }
        }
    }

    return returnValue;
}

VOID
DisplayError (
   DWORD Code
   )

/*++

Routine Description:

   This routine will display an error message based off of the Win32 error
   code that is passed in. This allows the user to see an understandable
   error message instead of just the code.

Arguments:

   Code - The error code to be translated.

Return Value:

   None.

--*/

{
   WCHAR                                    buffer[80] ;
   DWORD                                    count ;

   //
   // Translate the Win32 error code into a useful message.
   //

   count = FormatMessage (FORMAT_MESSAGE_FROM_SYSTEM,
                          NULL,
                          Code,
                          0,
                          buffer,
                          sizeof (buffer),
                          NULL) ;

   //
   // Make sure that the message could be translated.
   //

   if (count == 0) {

      printf("\nError could not be translated.\n Code: %d\n", Code) ;
      return;
   }
   else {

      //
      // Display the translated error.
      //

      printf("%S\n", buffer) ;
      return;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\latency\filter\latfastio.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    latFastIo.c

Abstract:

    This file contains all the Fast IO routines for the Latency Filter.
    
Author:

    Molly Brown (mollybro)  

Environment:

    Kernel mode

--*/

#include <latKernel.h>

#pragma alloc_text(PAGE, LatFastIoCheckIfPossible)
#pragma alloc_text(PAGE, LatFastIoRead)
#pragma alloc_text(PAGE, LatFastIoWrite)
#pragma alloc_text(PAGE, LatFastIoQueryBasicInfo)
#pragma alloc_text(PAGE, LatFastIoQueryStandardInfo)
#pragma alloc_text(PAGE, LatFastIoLock)
#pragma alloc_text(PAGE, LatFastIoUnlockSingle)
#pragma alloc_text(PAGE, LatFastIoUnlockAll)
#pragma alloc_text(PAGE, LatFastIoUnlockAllByKey)
#pragma alloc_text(PAGE, LatFastIoDeviceControl)
#pragma alloc_text(PAGE, LatFastIoDetachDevice)
#pragma alloc_text(PAGE, LatFastIoQueryNetworkOpenInfo)
#pragma alloc_text(PAGE, LatFastIoMdlRead)
#pragma alloc_text(PAGE, LatFastIoPrepareMdlWrite)
#pragma alloc_text(PAGE, LatFastIoMdlWriteComplete)
#pragma alloc_text(PAGE, LatFastIoReadCompressed)
#pragma alloc_text(PAGE, LatFastIoWriteCompressed)
#pragma alloc_text(PAGE, LatFastIoQueryOpen)

BOOLEAN
LatFastIoCheckIfPossible (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN BOOLEAN CheckForReadOperation,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for checking to see
    whether fast I/O is possible for this file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be operated on.

    FileOffset - Byte offset in the file for the operation.

    Length - Length of the operation to be performed.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    LockKey - Provides the caller's key for file locks.

    CheckForReadOperation - Indicates whether the caller is checking for a
        read (TRUE) or a write operation.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.
    
--*/
{
    PDEVICE_OBJECT    deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN           returnValue = FALSE;
    
    PAGED_CODE();

    ASSERT( IS_MY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PLATENCY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        //
        //  We have a valid DeviceObject, so look at its FastIoDispatch
        //  table for the next driver's Fast IO routine.
        //

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoCheckIfPossible )) {

            returnValue = (fastIoDispatch->FastIoCheckIfPossible)( FileObject,
                                                                   FileOffset,
                                                                   Length,
                                                                   Wait,
                                                                   LockKey,
                                                                   CheckForReadOperation,
                                                                   IoStatus,
                                                                   deviceObject);
        }
    }

    return returnValue;
}

BOOLEAN
LatFastIoRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for reading from a
    file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be read.

    FileOffset - Byte offset in the file of the read.

    Length - Length of the read operation to be performed.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    LockKey - Provides the caller's key for file locks.

    Buffer - Pointer to the caller's buffer to receive the data read.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN returnValue = FALSE;

    PAGED_CODE();
    
    ASSERT( IS_MY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PLATENCY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoRead )) {

            returnValue = (fastIoDispatch->FastIoRead)( FileObject,
                                                        FileOffset,
                                                        Length,
                                                        Wait,
                                                        LockKey,
                                                        Buffer,
                                                        IoStatus,
                                                        deviceObject);
        }
    }

    return returnValue;
}

BOOLEAN
LatFastIoWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for writing to a
    file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be written.

    FileOffset - Byte offset in the file of the write operation.

    Length - Length of the write operation to be performed.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    LockKey - Provides the caller's key for file locks.

    Buffer - Pointer to the caller's buffer that contains the data to be
        written.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN returnValue = FALSE;

    PAGED_CODE();
    
    ASSERT( IS_MY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PLATENCY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoWrite )) {

            returnValue = (fastIoDispatch->FastIoWrite)( FileObject,
                                                         FileOffset,
                                                         Length,
                                                         Wait,
                                                         LockKey,
                                                         Buffer,
                                                         IoStatus,
                                                         deviceObject);
        }
    }

    return returnValue;
}
 
BOOLEAN
LatFastIoQueryBasicInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_BASIC_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for querying basic
    information about the file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be queried.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    Buffer - Pointer to the caller's buffer to receive the information about
        the file.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN returnValue = FALSE;

    PAGED_CODE();
    
    ASSERT( IS_MY_DEVICE_OBJECT( DeviceObject ) );

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PLATENCY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoQueryBasicInfo )) {

            returnValue = (fastIoDispatch->FastIoQueryBasicInfo)( FileObject,
                                                                  Wait,
                                                                  Buffer,
                                                                  IoStatus,
                                                                  deviceObject);
        }
    }

    return returnValue;
}
 
BOOLEAN
LatFastIoQueryStandardInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_STANDARD_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for querying standard
    information about the file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be queried.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    Buffer - Pointer to the caller's buffer to receive the information about
        the file.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN returnValue = FALSE;

    PAGED_CODE();
    
    ASSERT( IS_MY_DEVICE_OBJECT( DeviceObject ) );

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PLATENCY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;
    
    if (NULL != deviceObject) {
           
        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoQueryStandardInfo )) {

            returnValue = (fastIoDispatch->FastIoQueryStandardInfo)( FileObject,
                                                                     Wait,
                                                                     Buffer,
                                                                     IoStatus,
                                                                     deviceObject );

        }
    }

    return returnValue;
}

BOOLEAN
LatFastIoLock (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    IN PEPROCESS ProcessId,
    IN ULONG Key,
    IN BOOLEAN FailImmediately,
    IN BOOLEAN ExclusiveLock,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for locking a byte
    range within a file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be locked.

    FileOffset - Starting byte offset from the base of the file to be locked.

    Length - Length of the byte range to be locked.

    ProcessId - ID of the process requesting the file lock.

    Key - Lock key to associate with the file lock.

    FailImmediately - Indicates whether or not the lock request is to fail
        if it cannot be immediately be granted.

    ExclusiveLock - Indicates whether the lock to be taken is exclusive (TRUE)
        or shared.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN returnValue = FALSE;

    PAGED_CODE();
    
    ASSERT( IS_MY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PLATENCY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoLock )) {

            returnValue = (fastIoDispatch->FastIoLock)( FileObject,
                                                        FileOffset,
                                                        Length,
                                                        ProcessId,
                                                        Key,
                                                        FailImmediately,
                                                        ExclusiveLock,
                                                        IoStatus,
                                                        deviceObject);

        }
    }

    return returnValue;
}
 
BOOLEAN
LatFastIoUnlockSingle (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    IN PEPROCESS ProcessId,
    IN ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for unlocking a byte
    range within a file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be unlocked.

    FileOffset - Starting byte offset from the base of the file to be
        unlocked.

    Length - Length of the byte range to be unlocked.

    ProcessId - ID of the process requesting the unlock operation.

    Key - Lock key associated with the file lock.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN returnValue = FALSE;

    PAGED_CODE();
    
    ASSERT( IS_MY_DEVICE_OBJECT( DeviceObject ) );

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PLATENCY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoUnlockSingle )) {

            returnValue = (fastIoDispatch->FastIoUnlockSingle)( FileObject,
                                                                FileOffset,
                                                                Length,
                                                                ProcessId,
                                                                Key,
                                                                IoStatus,
                                                                deviceObject);

        }
    }

    return returnValue;
}
 
BOOLEAN
LatFastIoUnlockAll (
    IN PFILE_OBJECT FileObject,
    IN PEPROCESS ProcessId,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for unlocking all
    locks within a file.

    This function simply invokes the file system's corresponding routine, or
    returns FALSE if the file system does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be unlocked.

    ProcessId - ID of the process requesting the unlock operation.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN returnValue = FALSE;

    PAGED_CODE();
    
    ASSERT( IS_MY_DEVICE_OBJECT( DeviceObject ) );

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PLATENCY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoUnlockAll )) {

            returnValue = (fastIoDispatch->FastIoUnlockAll)( FileObject,
                                                             ProcessId,
                                                             IoStatus,
                                                             deviceObject);

        }
    }

    return returnValue;
}

BOOLEAN
LatFastIoUnlockAllByKey (
    IN PFILE_OBJECT FileObject,
    IN PVOID ProcessId,
    IN ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for unlocking all
    locks within a file based on a specified key.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be unlocked.

    ProcessId - ID of the process requesting the unlock operation.

    Key - Lock key associated with the locks on the file to be released.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN returnValue = FALSE;

    PAGED_CODE();
    
    ASSERT( IS_MY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    // Pass through logic for this type of Fast I/O
    //
    
    deviceObject = ((PLATENCY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoUnlockAllByKey )) {

            returnValue = (fastIoDispatch->FastIoUnlockAllByKey)( FileObject,
                                                                  ProcessId,
                                                                  Key,
                                                                  IoStatus,
                                                                  deviceObject);
        }
    }

    return returnValue;
}

BOOLEAN
LatFastIoDeviceControl (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for device I/O 
    control operations on a file.
    
    If this I/O is directed to gControlDevice, then the parameters specify
    control commands to FileLat.  These commands are interpreted and handled
    appropriately.

    If this is I/O directed at another DriverObject, this function simply 
    invokes the next driver's corresponding routine, or returns FALSE if 
    the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object representing the device to be
        serviced.

    Wait - Indicates whether or not the caller is willing to wait if the
        appropriate locks, etc. cannot be acquired

    InputBuffer - Optional pointer to a buffer to be passed into the driver.

    InputBufferLength - Length of the optional InputBuffer, if one was
        specified.

    OutputBuffer - Optional pointer to a buffer to receive data from the
        driver.

    OutputBufferLength - Length of the optional OutputBuffer, if one was
        specified.

    IoControlCode - I/O control code indicating the operation to be performed
        on the device.

    IoStatus - Pointer to a variable to receive the I/O status of the
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

Notes:

    This function does not check the validity of the input/output buffers because
    the ioctl's are implemented as METHOD_BUFFERED.  In this case, the I/O manager
    does the buffer validation checks for us.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN returnValue = FALSE;

    PAGED_CODE();

    //
    // Get a pointer to the current location in the Irp. This is where
    // the function codes and parameters are located.
    //

    if (DeviceObject == Globals.ControlDeviceObject) {

        LatCommonDeviceIoControl( InputBuffer,
                                  InputBufferLength,
                                  OutputBuffer,
                                  OutputBufferLength,
                                  IoControlCode,
                                  IoStatus,
                                  DeviceObject );

        returnValue = TRUE;

    } else {

        ASSERT( IS_MY_DEVICE_OBJECT( DeviceObject ) );

        deviceObject = ((PLATENCY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

        if (NULL != deviceObject) {

            fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

            if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoDeviceControl )) {

                returnValue = (fastIoDispatch->FastIoDeviceControl)( FileObject,
                                                                     Wait,
                                                                     InputBuffer,
                                                                     InputBufferLength,
                                                                     OutputBuffer,
                                                                     OutputBufferLength,
                                                                     IoControlCode,
                                                                     IoStatus,
                                                                     deviceObject);

            } else {

                IoStatus->Status = STATUS_SUCCESS;
            }
        }
    }

    return returnValue;
}


VOID
LatFastIoDetachDevice (
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice
)
/*++

Routine Description:

    This routine is invoked on the fast path to detach from a device that
    is being deleted.  This occurs when this driver has attached to a file
    system volume device object, and then, for some reason, the file system
    decides to delete that device (it is being dismounted, it was dismounted
    at some point in the past and its last reference has just gone away, etc.)

Arguments:

    SourceDevice - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

    TargetDevice - Pointer to the file system's volume device object.

Return Value:

    None.
    
--*/
{
    PLATENCY_DEVICE_EXTENSION devext;

    PAGED_CODE();

    ASSERT( IS_MY_DEVICE_OBJECT( SourceDevice ) );

    devext = SourceDevice->DeviceExtension;

    LAT_DBG_PRINT2( DEBUG_DISPLAY_ATTACHMENT_NAMES,
                    "LATENCY (LatFastIoDetachDevice): Detaching from volume      \"%.*S\"\n",
                    devext->DeviceNames.Length / sizeof( WCHAR ),
                    devext->DeviceNames.Buffer );

    //
    //  Remove this device extension from the list of devices we are attached
    //  to if this is a volume device object.
    //
    
    if (devext->IsVolumeDeviceObject) {

        ExAcquireFastMutex( &Globals.DeviceExtensionListLock );
        RemoveEntryList( devext->NextLatencyDeviceLink );
        ExReleaseFastMutex( &Globals.DeviceExtensionListLock );
    }

    //
    // Detach from the file system's volume device object.
    //

    IoDetachDevice( TargetDevice );
    IoDeleteDevice( SourceDevice );
}
 
BOOLEAN
LatFastIoQueryNetworkOpenInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for querying network
    information about a file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object to be queried.

    Wait - Indicates whether or not the caller can handle the file system
        having to wait and tie up the current thread.

    Buffer - Pointer to a buffer to receive the network information about the
        file.

    IoStatus - Pointer to a variable to receive the final status of the query
        operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN returnValue = FALSE;

    PAGED_CODE();
    
    ASSERT( IS_MY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PLATENCY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoQueryNetworkOpenInfo )) {

            returnValue = (fastIoDispatch->FastIoQueryNetworkOpenInfo)( FileObject,
                                                                        Wait,
                                                                        Buffer,
                                                                        IoStatus,
                                                                        deviceObject);

        }
    }

    return returnValue;
}

BOOLEAN
LatFastIoMdlRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for reading a file
    using MDLs as buffers.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object that is to be read.

    FileOffset - Supplies the offset into the file to begin the read operation.

    Length - Specifies the number of bytes to be read from the file.

    LockKey - The key to be used in byte range lock checks.

    MdlChain - A pointer to a variable to be filled in w/a pointer to the MDL
        chain built to describe the data read.

    IoStatus - Variable to receive the final status of the read operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN returnValue = FALSE;

    PAGED_CODE();
    
    ASSERT( IS_MY_DEVICE_OBJECT( DeviceObject ) );

    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PLATENCY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlRead )) {

            returnValue = (fastIoDispatch->MdlRead)( FileObject,
                                                     FileOffset,
                                                     Length,
                                                     LockKey,
                                                     MdlChain,
                                                     IoStatus,
                                                     deviceObject);
        }
    }

    return returnValue;
}
 
BOOLEAN
LatFastIoMdlReadComplete (
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for completing an
    MDL read operation.

    This function simply invokes the next driver's corresponding routine, if
    it has one.  It should be the case that this routine is invoked only if
    the MdlRead function is supported by the underlying driver, and
    therefore this function will also be supported, but this is not assumed
    by this driver.

Arguments:

    FileObject - Pointer to the file object to complete the MDL read upon.

    MdlChain - Pointer to the MDL chain used to perform the read operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.
    
--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN returnValue = FALSE;
 
    ASSERT( IS_MY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PLATENCY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlReadComplete )) {

            returnValue = (fastIoDispatch->MdlReadComplete)( FileObject,
                                                             MdlChain,
                                                             deviceObject);
        } 
    }

    return returnValue;
}
 
BOOLEAN
LatFastIoPrepareMdlWrite (
    IN  PFILE_OBJECT FileObject,
    IN  PLARGE_INTEGER FileOffset,
    IN  ULONG Length,
    IN  ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN  PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for preparing for an
    MDL write operation.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object that will be written.

    FileOffset - Supplies the offset into the file to begin the write 
        operation.

    Length - Specifies the number of bytes to be write to the file.

    LockKey - The key to be used in byte range lock checks.

    MdlChain - A pointer to a variable to be filled in w/a pointer to the MDL
        chain built to describe the data written.

    IoStatus - Variable to receive the final status of the write operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

// ISSUE-2000-04-26-mollybro Check if this will get an IRP if FALSE is returned 

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN returnValue = FALSE;

    PAGED_CODE();
    
    ASSERT( IS_MY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PLATENCY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, PrepareMdlWrite )) {

            returnValue = (fastIoDispatch->PrepareMdlWrite)( FileObject,
                                                             FileOffset,
                                                             Length,
                                                             LockKey,
                                                             MdlChain,
                                                             IoStatus,
                                                             deviceObject);
        }
    }

    return returnValue;
}
 
BOOLEAN
LatFastIoMdlWriteComplete (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for completing an
    MDL write operation.

    This function simply invokes the next driver's corresponding routine, if
    it has one.  It should be the case that this routine is invoked only if
    the PrepareMdlWrite function is supported by the underlying file system,
    and therefore this function will also be supported, but this is not
    assumed by this driver.

Arguments:

    FileObject - Pointer to the file object to complete the MDL write upon.

    FileOffset - Supplies the file offset at which the write took place.

    MdlChain - Pointer to the MDL chain used to perform the write operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN returnValue = FALSE;

    PAGED_CODE();
    
    ASSERT( IS_MY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PLATENCY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlWriteComplete )) {

            returnValue = (fastIoDispatch->MdlWriteComplete)( FileObject,
                                                              FileOffset,
                                                              MdlChain,
                                                              deviceObject);

        }
    }

    return returnValue;
}
 
BOOLEAN
LatFastIoReadCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    OUT struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for reading 
    compressed data from a file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object that will be read.

    FileOffset - Supplies the offset into the file to begin the read operation.

    Length - Specifies the number of bytes to be read from the file.

    LockKey - The key to be used in byte range lock checks.

    Buffer - Pointer to a buffer to receive the compressed data read.

    MdlChain - A pointer to a variable to be filled in w/a pointer to the MDL
        chain built to describe the data read.

    IoStatus - Variable to receive the final status of the read operation.

    CompressedDataInfo - A buffer to receive the description of the 
        compressed data.

    CompressedDataInfoLength - Specifies the size of the buffer described by
        the CompressedDataInfo parameter.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN returnValue = FALSE;

    PAGED_CODE();
    
    ASSERT( IS_MY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PLATENCY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoReadCompressed )) {

            returnValue = (fastIoDispatch->FastIoReadCompressed)( FileObject,
                                                                  FileOffset,
                                                                  Length,
                                                                  LockKey,
                                                                  Buffer,
                                                                  MdlChain,
                                                                  IoStatus,
                                                                  CompressedDataInfo,
                                                                  CompressedDataInfoLength,
                                                                  deviceObject);
        }
    }

    return returnValue;
}
 
BOOLEAN
LatFastIoWriteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for writing 
    compressed data to a file.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    FileObject - Pointer to the file object that will be written.

    FileOffset - Supplies the offset into the file to begin the write 
        operation.

    Length - Specifies the number of bytes to be write to the file.

    LockKey - The key to be used in byte range lock checks.

    Buffer - Pointer to the buffer containing the data to be written.

    MdlChain - A pointer to a variable to be filled in w/a pointer to the MDL
        chain built to describe the data written.

    IoStatus - Variable to receive the final status of the write operation.

    CompressedDataInfo - A buffer to containing the description of the
        compressed data.

    CompressedDataInfoLength - Specifies the size of the buffer described by
        the CompressedDataInfo parameter.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN returnValue = FALSE;

    PAGED_CODE();
    
    ASSERT( IS_MY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PLATENCY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoWriteCompressed )) {

            returnValue = (fastIoDispatch->FastIoWriteCompressed)( FileObject,
                                                                   FileOffset,
                                                                   Length,
                                                                   LockKey,
                                                                   Buffer,
                                                                   MdlChain,
                                                                   IoStatus,
                                                                   CompressedDataInfo,
                                                                   CompressedDataInfoLength,
                                                                   deviceObject);
        }
    }

    return returnValue;
}
 
BOOLEAN
LatFastIoMdlReadCompleteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for completing an
    MDL read compressed operation.

    This function simply invokes the next driver's corresponding routine, if
    it has one.  It should be the case that this routine is invoked only if
    the read compressed function is supported by the underlying file system,
    and therefore this function will also be supported, but this is not 
    assumed by this driver.

Arguments:

    FileObject - Pointer to the file object to complete the compressed read
        upon.

    MdlChain - Pointer to the MDL chain used to perform the read operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.
    
--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN returnValue = FALSE;

    ASSERT( IS_MY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PLATENCY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlReadCompleteCompressed )) {

            returnValue = (fastIoDispatch->MdlReadCompleteCompressed)( FileObject,
                                                                       MdlChain,
                                                                       deviceObject);

        }
    }

    return returnValue;
}
 
BOOLEAN
LatFastIoMdlWriteCompleteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for completing a
    write compressed operation.

    This function simply invokes the next driver's corresponding routine, if
    it has one.  It should be the case that this routine is invoked only if
    the write compressed function is supported by the underlying file system,
    and therefore this function will also be supported, but this is not 
    assumed by this driver.

Arguments:

    FileObject - Pointer to the file object to complete the compressed write
        upon.

    FileOffset - Supplies the file offset at which the file write operation
        began.

    MdlChain - Pointer to the MDL chain used to perform the write operation.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN returnValue = FALSE;

    ASSERT( IS_MY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    // Pass through logic for this type of Fast I/O
    //
    
    deviceObject = ((PLATENCY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, MdlWriteCompleteCompressed )) {

            returnValue = (fastIoDispatch->MdlWriteCompleteCompressed)( FileObject,
                                                                        FileOffset, 
                                                                        MdlChain,
                                                                        deviceObject);

        }
    }

    return returnValue;
}
 
BOOLEAN
LatFastIoQueryOpen (
    IN PIRP Irp,
    OUT PFILE_NETWORK_OPEN_INFORMATION NetworkInformation,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine is the fast I/O "pass through" routine for opening a file
    and returning network information it.

    This function simply invokes the next driver's corresponding routine, or
    returns FALSE if the next driver does not implement the function.

Arguments:

    Irp - Pointer to a create IRP that represents this open operation.  It is
        to be used by the file system for common open/create code, but not
        actually completed.

    NetworkInformation - A buffer to receive the information required by the
        network about the file being opened.

    DeviceObject - Pointer to device object Filespy attached to the file system
        filter stack for the volume receiving this I/O request.

Return Value:

    Return TRUE if the request was successfully processed via the 
    fast i/o path.

    Return FALSE if the request could not be processed via the fast
    i/o path.  The IO Manager will then send this i/o to the file
    system through an IRP instead.

--*/
{
    PDEVICE_OBJECT deviceObject;
    PFAST_IO_DISPATCH fastIoDispatch;
    BOOLEAN result = FALSE;

    PAGED_CODE();
    
    ASSERT( IS_MY_DEVICE_OBJECT( DeviceObject ) );
    
    //
    // Pass through logic for this type of Fast I/O
    //

    deviceObject = ((PLATENCY_DEVICE_EXTENSION) (DeviceObject->DeviceExtension))->AttachedToDeviceObject;

    if (NULL != deviceObject) {

        fastIoDispatch = deviceObject->DriverObject->FastIoDispatch;

        if (VALID_FAST_IO_DISPATCH_HANDLER( fastIoDispatch, FastIoQueryOpen )) {

            PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation( Irp );

            irpSp->DeviceObject = deviceObject;

            result = (fastIoDispatch->FastIoQueryOpen)( Irp,
                                                        NetworkInformation,
                                                        deviceObject );
            if (!result) {

                irpSp->DeviceObject = DeviceObject;
            }
        }
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\iotest\user\iotestusersup.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    ioTestUserSup.c

Abstract:

    
// @@BEGIN_DDKSPLIT
Author:

    George Jenkins (GeorgeJe)                       

// @@END_DDKSPLIT
Environment:

    User mode


// @@BEGIN_DDKSPLIT

Revision History:

    Molly Brown (MollyBro) 21-Apr-1999
        Broke out the logging code and added command mode functionality.

// @@END_DDKSPLIT
--*/

#include <windows.h>                
#include <stdlib.h>
#include <stdio.h>
#include <winioctl.h>
#include <string.h>
#include <crtdbg.h>
#include "ioTest.h"
#include "ioTestLog.h"
#include "ioTestLib.h"

#define NT_SUCCESS(Status) ((LONG)(Status) >= 0)

#define TEST_DIRECTORY_NAME L"\\ioTest"

#define READ_TEST_FILE_NAME TEST_DIRECTORY_NAME L"\\read.txt"
#define READ_TEST_DATA L"Hello world!"

EXPECTED_OPERATION gExpectedReadOperationsTop[] = { { TOP_FILTER, IRP_MJ_CREATE },
                                                    { BOTTOM_FILTER, IRP_MJ_CREATE },
                                                    { TOP_FILTER, IRP_MJ_READ },
                                                    { BOTTOM_FILTER, IRP_MJ_READ },
                                                    { TOP_FILTER, IRP_MJ_CLEANUP },
                                                    { BOTTOM_FILTER, IRP_MJ_CLEANUP },
                                                    { BOTTOM_FILTER, IRP_MJ_MAXIMUM_FUNCTION + 1 } };
EXPECTED_OPERATION gExpectedReadOperationsDirected[] = { { BOTTOM_FILTER, IRP_MJ_CREATE },
                                                         { BOTTOM_FILTER, IRP_MJ_READ },
                                                         { BOTTOM_FILTER, IRP_MJ_CLEANUP },
                                                         { BOTTOM_FILTER, IRP_MJ_MAXIMUM_FUNCTION + 1 } };

#define WRITE_TEST_FILE_NAME TEST_DIRECTORY_NAME L"\\write.txt"
#define WRITE_TEST_DATA L"Good morning!"

EXPECTED_OPERATION gExpectedWriteOperationsTop[] = { { TOP_FILTER, IRP_MJ_CREATE },
                                                     { BOTTOM_FILTER, IRP_MJ_CREATE },
                                                     { TOP_FILTER, IRP_MJ_WRITE },
                                                     { BOTTOM_FILTER, IRP_MJ_WRITE },
                                                     { TOP_FILTER, IRP_MJ_CLEANUP },
                                                     { BOTTOM_FILTER, IRP_MJ_CLEANUP },
                                                     { BOTTOM_FILTER, IRP_MJ_MAXIMUM_FUNCTION + 1 } };
EXPECTED_OPERATION gExpectedWriteOperationsDirected[] = { { BOTTOM_FILTER, IRP_MJ_CREATE },
                                                          { BOTTOM_FILTER, IRP_MJ_WRITE },
                                                          { BOTTOM_FILTER, IRP_MJ_CLEANUP },
                                                          { BOTTOM_FILTER, IRP_MJ_MAXIMUM_FUNCTION + 1 } };

#define RENAME_SOURCE_FILE_NAME TEST_DIRECTORY_NAME L"\\renameSource.txt"
#define RENAME_TARGET_FILE_NAME TEST_DIRECTORY_NAME L"\\renameTarget.txt"

EXPECTED_OPERATION gExpectedRenameOperationsTop[] = { { TOP_FILTER, IRP_MJ_CREATE },
                                                      { BOTTOM_FILTER, IRP_MJ_CREATE },
                                                      { TOP_FILTER, IRP_MJ_SET_INFORMATION },
                                                      { BOTTOM_FILTER, IRP_MJ_SET_INFORMATION },
                                                      { TOP_FILTER, IRP_MJ_CLEANUP },
                                                      { BOTTOM_FILTER, IRP_MJ_CLEANUP },
                                                      { BOTTOM_FILTER, IRP_MJ_MAXIMUM_FUNCTION + 1 } };
EXPECTED_OPERATION gExpectedRenameOperationsDirected[] = { { BOTTOM_FILTER, IRP_MJ_CREATE },
                                                           { BOTTOM_FILTER, IRP_MJ_SET_INFORMATION },
                                                           { BOTTOM_FILTER, IRP_MJ_CLEANUP },
                                                           { BOTTOM_FILTER, IRP_MJ_MAXIMUM_FUNCTION + 1 } };

#define SHARE_FILE_NAME TEST_DIRECTORY_NAME L"\\share.txt"

EXPECTED_OPERATION gExpectedShareOperationsTop[] = { { TOP_FILTER, IRP_MJ_CREATE },
                                                     { BOTTOM_FILTER, IRP_MJ_CREATE },
                                                     { TOP_FILTER, IRP_MJ_CLEANUP },
                                                     { BOTTOM_FILTER, IRP_MJ_CLEANUP },
                                                     { BOTTOM_FILTER, IRP_MJ_MAXIMUM_FUNCTION + 1 } };
EXPECTED_OPERATION gExpectedShareOperationsDirected[] = { { BOTTOM_FILTER, IRP_MJ_CREATE },
                                                          { BOTTOM_FILTER, IRP_MJ_CLEANUP },
                                                          { BOTTOM_FILTER, IRP_MJ_MAXIMUM_FUNCTION + 1 } };
BOOL
CreateTestDirectory (
    PWCHAR DriveName,
    ULONG DriveNameLength
    )
{
    WCHAR testDirName[MAX_PATH];
    DWORD result;
    BOOL bResult;

    if (sizeof( TEST_DIRECTORY_NAME ) + DriveNameLength > MAX_PATH) {

        printf ("Can't create test directory -- name buffer too small\n");
        return FALSE;
    }

    wcscpy( testDirName, DriveName );
    wcscat( testDirName, TEST_DIRECTORY_NAME );

    bResult = CreateDirectory( testDirName,
                               NULL );

    if (!bResult) {

        result = GetLastError();
        if (result != ERROR_ALREADY_EXISTS) {

            DisplayError( result );
            return FALSE;
        }
    }

    return TRUE;
    
}

VOID
DumpTestResultBanner (
    PWCHAR TestName,
    BOOL Begin
    )
{
    if (Begin) {

        printf( "***BEGIN %S TEST RESULTS***\n", TestName );

    } else {

        printf( "***END %S TEST RESULTS***\n", TestName );
    }
}

VOID
DumpKernelResults (
    PIOTEST_STATUS TestStatus
    )
{
    printf( "Kernel verification: " );
    
    if (NT_SUCCESS( TestStatus->TestResult )) {

        printf( "\tTest PASSED\n" );
        
    } else {

        switch( TestStatus->Phase ) {
        case IoTestSetup:
            printf( "\tTest failed in SETUP phase with status 0x%08x\n",
                    TestStatus->TestResult );
            break;

        case IoTestAction:
            printf( "\tTest failed in ACTION phase with status 0x%08x\n",
                    TestStatus->TestResult );
            break;

        case IoTestValidation:
            printf( "\tTest failed in VALIDATION phase with status 0x%08x\n",
                    TestStatus->TestResult );
            break;

        case IoTestCleanup:
            printf( "\tTest failed in CLEANUP phase with status 0x%08x\n",
                    TestStatus->TestResult );
            break;

        case IoTestCompleted:
            printf( "\tTest failed in COMPLETED phase with status 0x%08x\n",
                    TestStatus->TestResult );
            break;

        default:
            printf( "\tTest failed in UNKNOWN phase with status 0x%08x\n",
                    TestStatus->TestResult );
            break;

        }
    }
}

VOID
ReadTest (
    PLOG_CONTEXT Context,
    PWCHAR DriveName,
    ULONG  DriveNameLength,
    BOOLEAN TopOfStack
    )
{
    HANDLE testFile = INVALID_HANDLE_VALUE;
    PIOTEST_READ_WRITE_PARAMETERS parms = NULL;
    DWORD parmsLength;
    IOTEST_STATUS testStatus;
    BOOL bResult;
    DWORD bytesReturned;
    DWORD result;

    bResult = CreateTestDirectory( DriveName, DriveNameLength );

    if (!bResult) {

        goto ReadTest_Cleanup;
    }

    //
    //  Setup parms
    //

    parmsLength = sizeof( IOTEST_READ_WRITE_PARAMETERS ) + sizeof( READ_TEST_DATA );
    parms = malloc (parmsLength);

    if (parms == NULL) {

        printf( "Insufficient resources to run READ test\n" );
        goto ReadTest_Cleanup;
    }

    CopyMemory( parms->DriveNameBuffer, DriveName, DriveNameLength );
    parms->DriveNameLength = DriveNameLength;

    if ((sizeof( READ_TEST_FILE_NAME ) + DriveNameLength) >
        MAX_PATH ) {

        //
        //  The READ test file name is longer than our FileNameBuffer,
        //  so return an error and quit.
        //

        printf( "READ Test file name is too long.\n" );
        goto ReadTest_Cleanup;
    }

    //
    //  We've got enough room, so build up the file name.
    //
    
    wcscpy( parms->FileNameBuffer, parms->DriveNameBuffer );
    wcscat( parms->FileNameBuffer, READ_TEST_FILE_NAME );
    parms->FileNameLength = wcslen( parms->FileNameBuffer ) * sizeof( WCHAR );

    parms->FileDataLength = sizeof( READ_TEST_DATA );
    CopyMemory( parms->FileData, READ_TEST_DATA, parms->FileDataLength );

    parms->Flags = 0;
    
    if (TopOfStack) {

        parms->Flags |= IO_TEST_TOP_OF_STACK;
    }

    //
    //  Create test file
    //

    testFile = CreateFile( parms->FileNameBuffer,
                           GENERIC_WRITE,
                           0,
                           NULL,
                           CREATE_ALWAYS,
                           FILE_ATTRIBUTE_NORMAL,
                           NULL );

    if (testFile == INVALID_HANDLE_VALUE) {

        result = GetLastError();
        printf ("Error opening READ test file.\n");
        DisplayError( result );
        goto ReadTest_Cleanup;
    }
    
    //
    //  Write data to test file
    //

    bResult = WriteFile( testFile,
                         READ_TEST_DATA,
                         sizeof( READ_TEST_DATA ),
                         &bytesReturned,
                         NULL );

    if (!bResult) {
        result = GetLastError();
        printf("ERROR writing data READ test file...\n");
        DisplayError( result );
        goto ReadTest_Cleanup;
    }

    CloseHandle( testFile );
    testFile = INVALID_HANDLE_VALUE;
        
    //
    //  Send message down to filter
    //
    
    bResult = DeviceIoControl( Context->Device,
                               IOTEST_ReadTest,
                               parms,
                               parmsLength,
                               &testStatus,
                               sizeof( testStatus ),
                               &bytesReturned,
                               NULL);
    
    if (!bResult) {
        result = GetLastError();
        printf("ERROR running READ test...\n");
        DisplayError( result );
        goto ReadTest_Cleanup;
    }

    //
    //  Print out the result of the kernel verification tests.
    //

    DumpTestResultBanner( L"READ", TRUE );
    
    DumpKernelResults( &testStatus );
    
    //
    //  Read and verify log
    //

    if (TopOfStack) {
        
        VerifyCurrentLogRecords( Context, 
                                 gExpectedReadOperationsTop );

    } else {

        VerifyCurrentLogRecords( Context, 
                                 gExpectedReadOperationsDirected );
    }    
    
    DumpTestResultBanner( L"READ", FALSE );
    
ReadTest_Cleanup:

    if (testFile != INVALID_HANDLE_VALUE) {

        CloseHandle( testFile );
    }

    if (parms != NULL) {

        free( parms );
    }

    return;
}

VOID
RenameTest (
    PLOG_CONTEXT Context,
    PWCHAR DriveName,
    ULONG  DriveNameLength,
    BOOLEAN TopOfStack
    )
{
    BOOL bResult;
    IOTEST_RENAME_PARAMETERS parms;
    IOTEST_STATUS testStatus;
    HANDLE sourceFile;
    HANDLE targetFile;
    DWORD bytesReturned;
    DWORD result;
    
    bResult = CreateTestDirectory( DriveName, DriveNameLength );

    if (!bResult) {

        goto RenameTest_Cleanup;
    }

    //
    //  Setup parameters
    //

    CopyMemory( &(parms.DriveNameBuffer), DriveName, DriveNameLength );
    parms.DriveNameLength = DriveNameLength;

    if ((sizeof( RENAME_SOURCE_FILE_NAME ) + DriveNameLength) >
        MAX_PATH ) {

        //
        //  The RENAME test source file name is longer than our 
        //  SourceFileNameBuffer, so return an error and quit.
        //

        printf( "RENAME Test source file name is too long.\n" );
        goto RenameTest_Cleanup;
    }

    //
    //  We've got enough room, so build up the source file name.
    //
    
    wcscpy( parms.SourceFileNameBuffer, parms.DriveNameBuffer );
    wcscat( parms.SourceFileNameBuffer, RENAME_SOURCE_FILE_NAME );
    parms.SourceFileNameLength = wcslen( parms.SourceFileNameBuffer ) * sizeof( WCHAR );
    
    if ((sizeof( RENAME_TARGET_FILE_NAME ) + DriveNameLength) >
        MAX_PATH ) {

        //
        //  The RENAME test target file name is longer than our 
        //  TargetFileNameBuffer, so return an error and quit.
        //

        printf( "RENAME Test target file name is too long.\n" );
        goto RenameTest_Cleanup;
    }

    //
    //  We've got enough room, so build up the source file name.
    //
    
    wcscpy( parms.TargetFileNameBuffer, parms.DriveNameBuffer );
    wcscat( parms.TargetFileNameBuffer, RENAME_TARGET_FILE_NAME );
    parms.TargetFileNameLength = wcslen( parms.TargetFileNameBuffer ) * sizeof( WCHAR );

    parms.Flags = 0;
    
    if (TopOfStack) {

        parms.Flags |= IO_TEST_TOP_OF_STACK;
    }

    //
    //  Setup source file
    //

    sourceFile = CreateFile( RENAME_SOURCE_FILE_NAME,
                             GENERIC_WRITE,
                             0,
                             NULL,
                             CREATE_ALWAYS,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL );

    if (sourceFile == INVALID_HANDLE_VALUE) {

        result = GetLastError();
        printf ("Error opening RENAME test source file.\n");
        DisplayError( result );
        goto RenameTest_Cleanup;
    }

    CloseHandle( sourceFile );
    sourceFile = INVALID_HANDLE_VALUE;

    //
    //  Make sure that the target file does NOT exist.
    //
    
    targetFile = CreateFile( RENAME_TARGET_FILE_NAME,
                             GENERIC_ALL,
                             0,
                             NULL,
                             OPEN_EXISTING,
                             FILE_FLAG_DELETE_ON_CLOSE,
                             NULL );

    if (targetFile == INVALID_HANDLE_VALUE) {

        result = GetLastError();

        if (result != ERROR_ALREADY_EXISTS &&
            result != ERROR_FILE_NOT_FOUND) {
            
            printf ("Error opening RENAME test target file.\n");
            DisplayError( result );
            goto RenameTest_Cleanup;
        }
        
    } else {

        //
        //  The file does exist, so lets delete by closing the handle.
        //

        CloseHandle( targetFile );
        targetFile = INVALID_HANDLE_VALUE;
    }

    //
    //  Send message down to filter
    //
    
    bResult = DeviceIoControl( Context->Device,
                               IOTEST_RenameTest,
                               &parms,
                               sizeof( parms ),
                               &testStatus,
                               sizeof( testStatus ),
                               &bytesReturned,
                               NULL);
    
    if (!bResult) {
        result = GetLastError();
        printf("ERROR running RENAME test...\n");
        DisplayError( result );
        goto RenameTest_Cleanup;
    }

    //
    //  Display test results.
    //

    DumpTestResultBanner( L"RENAME", TRUE );

    DumpKernelResults( &testStatus );

    //
    //  Read and verify logs
    //
    
    if (TopOfStack) {
        
        VerifyCurrentLogRecords( Context, 
                                 gExpectedRenameOperationsTop );

    } else {

        VerifyCurrentLogRecords( Context, 
                                 gExpectedRenameOperationsDirected );
    }    
    
    //
    //  Verify that the sourceFile is no longer present.
    //

    sourceFile = CreateFile( RENAME_SOURCE_FILE_NAME,
                             GENERIC_ALL,
                             0,
                             NULL,
                             OPEN_EXISTING,
                             FILE_FLAG_DELETE_ON_CLOSE,
                             NULL );

    if (sourceFile == INVALID_HANDLE_VALUE) {

        printf( "User test verification:\tPASSED - Source file no longer present.\n" );

    } else {
    
        printf( "User test verification:\tFAILED - Source test file still exists.\n" );
        CloseHandle( sourceFile );
    }

    //
    //  Verify that the targetFile is present
    //
    
    targetFile = CreateFile( RENAME_TARGET_FILE_NAME,
                             GENERIC_ALL,
                             0,
                             NULL,
                             OPEN_EXISTING,
                             FILE_FLAG_DELETE_ON_CLOSE,
                             NULL );

    if (targetFile == INVALID_HANDLE_VALUE) {

        result = GetLastError();
        
        printf( "User test verification:\tFAILED - Unexpected error trying to open target file %d.\n",
                result );
        
    } else {
    
        printf( "User test verification:\tPASSED - Target test file exists.\n" );
        CloseHandle( targetFile );
        targetFile = INVALID_HANDLE_VALUE;
    }

    DumpTestResultBanner( L"RENAME", FALSE );
                             
RenameTest_Cleanup:

    if (sourceFile != INVALID_HANDLE_VALUE) {

        CloseHandle( sourceFile );
    }

    if (targetFile != INVALID_HANDLE_VALUE) {

        CloseHandle( targetFile );
    }

    return;
}

VOID
ShareTest (
    PLOG_CONTEXT Context,
    PWCHAR DriveName,
    ULONG  DriveNameLength,
    BOOLEAN TopOfStack
    )
{
    BOOL bResult;
    IOTEST_SHARE_PARAMETERS parms;
    IOTEST_STATUS testStatus;
    HANDLE file;
    DWORD bytesReturned;
    DWORD result;
    
    bResult = CreateTestDirectory( DriveName, DriveNameLength );

    if (!bResult) {

        goto ShareTest_Cleanup;
    }

    //
    //  Setup parameters
    //

    CopyMemory( &(parms.DriveNameBuffer), DriveName, DriveNameLength );
    parms.DriveNameLength = DriveNameLength;

    if ((sizeof( SHARE_FILE_NAME ) + DriveNameLength) >
        MAX_PATH ) {

        //
        //  The RENAME test source file name is longer than our 
        //  SourceFileNameBuffer, so return an error and quit.
        //

        printf( "SHARE Test file name is too long.\n" );
        goto ShareTest_Cleanup;
    }

    //
    //  We've got enough room, so build up the source file name.
    //
    
    wcscpy( parms.FileNameBuffer, parms.DriveNameBuffer );
    wcscat( parms.FileNameBuffer, SHARE_FILE_NAME );
    parms.FileNameLength = wcslen( parms.FileNameBuffer ) * sizeof( WCHAR );

    parms.Flags = 0;
    
    if (TopOfStack) {

        parms.Flags |= IO_TEST_TOP_OF_STACK;
    }
    
    //
    //  Setup source file
    //

    file = CreateFile( SHARE_FILE_NAME,
                       GENERIC_WRITE,
                       0,
                       NULL,
                       CREATE_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL );

    if (file == INVALID_HANDLE_VALUE) {

        result = GetLastError();
        printf ("Error opening SHARE test file.\n");
        DisplayError( result );
        goto ShareTest_Cleanup;
    }

    //
    //  Send message down to filter
    //
    
    bResult = DeviceIoControl( Context->Device,
                               IOTEST_ShareTest,
                               &parms,
                               sizeof( parms ),
                               &testStatus,
                               sizeof( testStatus ),
                               &bytesReturned,
                               NULL);
    
    if (!bResult) {
        result = GetLastError();
        printf("ERROR running SHARE test...\n");
        DisplayError( result );
        goto ShareTest_Cleanup;
    }

    //
    //  Display test results.
    //

    DumpTestResultBanner( L"SHARE", TRUE );

    DumpKernelResults( &testStatus );

    //
    //  Read and verify logs
    //
    
    if (TopOfStack) {
        
        VerifyCurrentLogRecords( Context, 
                                 gExpectedShareOperationsTop );

    } else {

        VerifyCurrentLogRecords( Context, 
                                 gExpectedShareOperationsDirected );
    }    
    
    DumpTestResultBanner( L"SHARE", FALSE );
                             
ShareTest_Cleanup:

    if (file != INVALID_HANDLE_VALUE) {

        CloseHandle( file );
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\latency\filter\latency.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    latency.c

Abstract:

    This filter is written as a test filter that can be
    placed anywhere in the filter stack to pend operations
    and add latency.

    It has two mode:
    	* attach on demand
    	* attach to all volumes in system

    Once it is attached, the amount of latency added to operations
    can be controlled through the user mode program.
    
Author:

    Molly Brown (mollybro)  

Environment:

    Kernel mode

--*/

#include <latKernel.h>
#include <latency.h>

//
// Global storage for this file system filter driver.
//

LATENCY_GLOBALS Globals;
KSPIN_LOCK GlobalsLock;

//
//  list of known device types
//

const PCHAR DeviceTypeNames[] = {
    "",
    "BEEP",
    "CD_ROM",
    "CD_ROM_FILE_SYSTEM",
    "CONTROLLER",
    "DATALINK",
    "DFS",
    "DISK",
    "DISK_FILE_SYSTEM",
    "FILE_SYSTEM",
    "INPORT_PORT",
    "KEYBOARD",
    "MAILSLOT",
    "MIDI_IN",
    "MIDI_OUT",
    "MOUSE",
    "MULTI_UNC_PROVIDER",
    "NAMED_PIPE",
    "NETWORK",
    "NETWORK_BROWSER",
    "NETWORK_FILE_SYSTEM",
    "NULL",
    "PARALLEL_PORT",
    "PHYSICAL_NETCARD",
    "PRINTER",
    "SCANNER",
    "SERIAL_MOUSE_PORT",
    "SERIAL_PORT",
    "SCREEN",
    "SOUND",
    "STREAMS",
    "TAPE",
    "TAPE_FILE_SYSTEM",
    "TRANSPORT",
    "UNKNOWN",
    "VIDEO",
    "VIRTUAL_DISK",
    "WAVE_IN",
    "WAVE_OUT",
    "8042_PORT",
    "NETWORK_REDIRECTOR",
    "BATTERY",
    "BUS_EXTENDER",
    "MODEM",
    "VDM",
    "MASS_STORAGE",
    "SMB",
    "KS",
    "CHANGER",
    "SMARTCARD",
    "ACPI",
    "DVD",
    "FULLSCREEN_VIDEO",
    "DFS_FILE_SYSTEM",
    "DFS_VOLUME",
    "SERENUM",
    "TERMSRV",
    "KSEC"
};

//
//  We need this because the compiler doesn't like doing sizeof an externed
//  array in the other file that needs it (fspylib.c)
//

ULONG SizeOfDeviceTypeNames = sizeof( DeviceTypeNames );

//
//  Since functions in drivers are non-pagable by default, these pragmas 
//  allow the driver writer to tell the system what functions can be paged.
//
//  Use the PAGED_CODE() macro at the beginning of these functions'
//  implementations while debugging to ensure that these routines are
//  never called at IRQL > APC_LEVEL (therefore the routine cannot
//  be paged).
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, LatFsControl)
#pragma alloc_text(PAGE, LatCommonDeviceIoControl)
#endif

NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
)
/*++

Routine Description:

    This is the initialization routine for the general purpose file system
    filter driver.  This routine creates the device object that represents 
    this driver in the system and registers it for watching all file systems 
    that register or unregister themselves as active file systems.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    The function value is the final status from the initialization operation.

--*/
{
    UNICODE_STRING nameString;
    NTSTATUS status;
    PFAST_IO_DISPATCH fastIoDispatch;
    ULONG i;
    UNICODE_STRING linkString;
    
    //////////////////////////////////////////////////////////////////////
    //                                                                  //
    //  General setup for all filter drivers.  This sets up the filter  //
    //  driver's DeviceObject and registers the callback routines for   //
    //  the filter driver.                                              //
    //                                                                  //
    //////////////////////////////////////////////////////////////////////

#if DBG
    DbgBreakPoint();
#endif

	//
	//  Initialize our Globals structure.
	//

	KeInitializeSpinLock( &GlobalsLock );

#if DBG
	Globals.DebugLevel = DEBUG_ERROR | DEBUG_DISPLAY_ATTACHMENT_NAMES;
#else
	Globals.DebugLevel = 0;
#endif

	Globals.AttachMode = LATENCY_ATTACH_ALL_VOLUMES;
	Globals.DriverObject = DriverObject;
	
	ExInitializeFastMutex( &(Globals.DeviceExtensionListLock) );
	
    //
    // Create the device object that will represent the Latency device.
    //

    RtlInitUnicodeString( &nameString, LATENCY_FULLDEVICE_NAME );
    
    //
    // Create the "control" device object.  Note that this device object does
    // not have a device extension (set to NULL).  Most of the fast IO routines
    // check for this condition to determine if the fast IO is directed at the
    // control device.
    //

    status = IoCreateDevice( DriverObject,
                             0,
                             &nameString,
                             FILE_DEVICE_DISK_FILE_SYSTEM,
                             0,
                             FALSE,
                             &(Globals.ControlDeviceObject));

    if (!NT_SUCCESS( status )) {

        LAT_DBG_PRINT1( DEBUG_ERROR,
                        "LATENCY (DriverEntry): Error creating Latency device, error: %x\n",
                        status );

        return status;

    } else {

        RtlInitUnicodeString( &linkString, LATENCY_DOSDEVICE_NAME );
        status = IoCreateSymbolicLink( &linkString, &nameString );

        if (!NT_SUCCESS(status)) {

            LAT_DBG_PRINT0( DEBUG_ERROR,
                            "LATENCY (DriverEntry): IoCreateSymbolicLink failed\n" );
            IoDeleteDevice(Globals.ControlDeviceObject);
            return status;
        }
    }

    //
    // Initialize the driver object with this device driver's entry points.
    //

    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {

        DriverObject->MajorFunction[i] = LatDispatch;
    }

    //
    // Allocate fast I/O data structure and fill it in.  This structure
    // is used to register the callbacks for Latency in the fast I/O
    // data paths.
    //

    fastIoDispatch = ExAllocatePool( NonPagedPool, sizeof( FAST_IO_DISPATCH ) );

    if (!fastIoDispatch) {

        IoDeleteDevice( Globals.ControlDeviceObject );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory( fastIoDispatch, sizeof( FAST_IO_DISPATCH ) );
    fastIoDispatch->SizeOfFastIoDispatch = sizeof( FAST_IO_DISPATCH );
    fastIoDispatch->FastIoCheckIfPossible = LatFastIoCheckIfPossible;
    fastIoDispatch->FastIoRead = LatFastIoRead;
    fastIoDispatch->FastIoWrite = LatFastIoWrite;
    fastIoDispatch->FastIoQueryBasicInfo = LatFastIoQueryBasicInfo;
    fastIoDispatch->FastIoQueryStandardInfo = LatFastIoQueryStandardInfo;
    fastIoDispatch->FastIoLock = LatFastIoLock;
    fastIoDispatch->FastIoUnlockSingle = LatFastIoUnlockSingle;
    fastIoDispatch->FastIoUnlockAll = LatFastIoUnlockAll;
    fastIoDispatch->FastIoUnlockAllByKey = LatFastIoUnlockAllByKey;
    fastIoDispatch->FastIoDeviceControl = LatFastIoDeviceControl;
    fastIoDispatch->FastIoDetachDevice = LatFastIoDetachDevice;
    fastIoDispatch->FastIoQueryNetworkOpenInfo = LatFastIoQueryNetworkOpenInfo;
    fastIoDispatch->MdlRead = LatFastIoMdlRead;
    fastIoDispatch->MdlReadComplete = LatFastIoMdlReadComplete;
    fastIoDispatch->PrepareMdlWrite = LatFastIoPrepareMdlWrite;
    fastIoDispatch->MdlWriteComplete = LatFastIoMdlWriteComplete;
    fastIoDispatch->FastIoReadCompressed = LatFastIoReadCompressed;
    fastIoDispatch->FastIoWriteCompressed = LatFastIoWriteCompressed;
    fastIoDispatch->MdlReadCompleteCompressed = LatFastIoMdlReadCompleteCompressed;
    fastIoDispatch->MdlWriteCompleteCompressed = LatFastIoMdlWriteCompleteCompressed;
    fastIoDispatch->FastIoQueryOpen = LatFastIoQueryOpen;

    DriverObject->FastIoDispatch = fastIoDispatch;

	//
	//  This filter doesn't care about any of the FsFilter operations.  Therefore
	//  this filter doesn't need to register with 
	//  FsRtlRegisterFileSystemFilterCallbacks.
    //

    //
    //  Read the custom parameters for Latency Filter from the registry
    //
    LatReadDriverParameters( RegistryPath );

    //
    //  If we are supposed to attach to all devices, register a callback
    //  with IoRegisterFsRegistrationChange.
    //

    if (Globals.AttachMode == LATENCY_ATTACH_ALL_VOLUMES) {
    
        status = IoRegisterFsRegistrationChange( DriverObject, LatFsNotification );
        
        if (!NT_SUCCESS( status )) {

            LAT_DBG_PRINT1( DEBUG_ERROR,
                            "LATENCY (DriverEntry): Error registering FS change notification, status=%08x\n", 
                            status );
            ExFreePool( fastIoDispatch );
            IoDeleteDevice( Globals.ControlDeviceObject );
            return status;
        }
    }

    //
    //  Clear the initializing flag on the control device object since we
    //  have now successfully initialized everything.
    //

    ClearFlag( Globals.ControlDeviceObject->Flags, DO_DEVICE_INITIALIZING );

    return STATUS_SUCCESS;
}

NTSTATUS
LatDispatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
)
/*++

Routine Description:

    This function completes all requests on the Globals.ControlDeviceObject 
    and passes all other requests on to the SpyPassThrough function.

Arguments:

    DeviceObject - Pointer to device object Latency Filter attached to the file system
        filter stack for the volume receiving this I/O request.
        
    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    If this is a request on the gControlDeviceObject, STATUS_SUCCESS 
    will be returned unless the device is already attached.  In that case,
    STATUS_DEVICE_ALREADY_ATTACHED is returned.

    If this is a request on a device other than the gControlDeviceObject,
    the function will return the value of SpyPassThrough().

--*/
{
    ULONG status = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpStack;
    
    if (DeviceObject == Globals.ControlDeviceObject) {

        //
        //  A request is being made on our device object, gControlDeviceObject.
        //

        Irp->IoStatus.Information = 0;
    
        irpStack = IoGetCurrentIrpStackLocation( Irp );
       
        switch (irpStack->MajorFunction) {
        case IRP_MJ_CREATE:
        
            status = STATUS_SUCCESS;
            Irp->IoStatus.Information = FILE_OPENED;
        	break;
        	
        case IRP_MJ_DEVICE_CONTROL:

            //
            //  This is a private device control irp for our control device.
            //  Pass the parameter information along to the common routine
            //  use to service these requests.
            //
            
            status = LatCommonDeviceIoControl( irpStack->Parameters.DeviceIoControl.Type3InputBuffer,
                                               irpStack->Parameters.DeviceIoControl.InputBufferLength,
                                               Irp->UserBuffer,
                                               irpStack->Parameters.DeviceIoControl.OutputBufferLength,
                                               irpStack->Parameters.DeviceIoControl.IoControlCode,
                                               &Irp->IoStatus,
                                               irpStack->DeviceObject );
            break;

        case IRP_MJ_CLEANUP:
        
            //
            //  This is the cleanup that we will see when all references to a handle
            //  opened to Latency's control device object are cleaned up.  We don't
            //  have to do anything here since we wait until the actual IRP_MJ_CLOSE
            //  to clean up the name cache.  Just complete the IRP successfully.
            //

            status = STATUS_SUCCESS;
            break;
                
		case IRP_MJ_CLOSE:

			status = STATUS_SUCCESS;
			break;
			
        default:

            status = STATUS_INVALID_DEVICE_REQUEST;
        }

        Irp->IoStatus.Status = status;

        //
        //  We have completed all processing for this IRP, so tell the 
        //  I/O Manager.  This IRP will not be passed any further down
        //  the stack since no drivers below Latency care about this 
        //  I/O operation that was directed to the Latency Filter.
        //

        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return status;
    }

    return LatPassThrough( DeviceObject, Irp );
}

NTSTATUS
LatPassThrough (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
)
/*++

Routine Description:

    This routine is the main dispatch routine for the general purpose file
    system driver.  It simply passes requests onto the next driver in the
    stack, which is presumably a disk file system, while logging any
    relevant information if logging is turned on for this DeviceObject.

Arguments:

    DeviceObject - Pointer to device object Latency attached to the file system
        filter stack for the volume receiving this I/O request.
        
    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

Note:

	This routine passes the I/O request through to the next driver
	and sets up to pend the operation if we are pending the given
	operation.
	
    To remain in the stack, we have to copy the caller's parameters to the
    next stack location.  Note that we do not want to copy the caller's I/O
    completion routine into the next stack location, or the caller's routine
    will get invoked twice.  This is why we NULL out the Completion routine.
    If we are logging this device, we set our own Completion routine.
    
--*/
{
	PLATENCY_DEVICE_EXTENSION devExt;
	
    ASSERT( IS_MY_DEVICE_OBJECT( DeviceObject ) );

    //
    //  See if we should pend this IRP
    //
    
	if (LatShouldPendThisIo( devExt, Irp )) {

		//
		//  Pend this operation 
		//
		
		IoCompleteRequest( Irp, STATUS_PENDING );

		//
		//  Queue to a worker thread to sleep and
		//  continue later.
		//

		IoCopyCurrentIrpStackLocationToNext( Irp );
		IoSetCompletionRoutine( Irp,
								LatAddLatencyCompletion,
								NULL,
								TRUE,
								TRUE,
								TRUE );
								
	} else {

		//
		//  We are not pending this operation so get out
		//  of the stack.
		//

		IoSkipCurrentIrpStackLocation( Irp );
	}

    devExt = DeviceObject->DeviceExtension;
    
	return IoCallDriver( devExt->AttachedToDeviceObject, Irp );
}

NTSTATUS
LatFsControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
)
/*++

Routine Description:

    This routine is the handler for all Fs Controls that are directed to 
    devices that LatFilter cares about.  LatFilter itself does not support
    any FS Controls.

    It is through this path that the filter is notified of mounts, dismounts
    and new file systems loading.

Arguments:

    DeviceObject - Pointer to device object Latency attached to the file system
        filter stack for the volume receiving this I/O request.
        
    Irp - Pointer to the request packet representing the I/O request.

Return Value:

    The function value is the status of the operation.

Note:

	This routine passes the I/O request through to the next driver
	and sets up to pend the operation if we are pending the given
	operation.
	
    To remain in the stack, we have to copy the caller's parameters to the
    next stack location.  Note that we do not want to copy the caller's I/O
    completion routine into the next stack location, or the caller's routine
    will get invoked twice.  This is why we NULL out the Completion routine.
    If we are logging this device, we set our own Completion routine.
    
--*/
{
    PLATENCY_DEVICE_EXTENSION devExt = DeviceObject->DeviceExtension;
    PDEVICE_OBJECT newLatencyDeviceObject;
    PLATENCY_DEVICE_EXTENSION newDevExt;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation( Irp );
    NTSTATUS status;

    PAGED_CODE();

    //
    //  If this is for our control device object, fail the operation
    //

    if (Globals.ControlDeviceObject == DeviceObject) {

        //
        //  If this device object is our control device object rather than 
        //  a mounted volume device object, then this is an invalid request.
        //

        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest( Irp, IO_NO_INCREMENT );

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

    //
    //  Begin by determining the minor function code for this file system control
    //  function.
    //

    switch (irpSp->MinorFunction) {

    case IRP_MN_MOUNT_VOLUME:

        //
        //  This is a mount request.  Create a device object that can be
        //  attached to the file system's volume device object if this request
        //  is successful.  We allocate this memory now since we can not return
        //  an error in the completion routine.
        //

        status = IoCreateDevice( Globals.DriverObject,
                                 sizeof( LATENCY_DEVICE_EXTENSION ),
                                 (PUNICODE_STRING) NULL,
                                 DeviceObject->DeviceType,
                                 0,
                                 FALSE,
                                 &newLatencyDeviceObject );

        if (NT_SUCCESS( status )) {

            //
            //  We need to save the RealDevice object pointed to by the vpb
            //  parameter because this vpb may be changed by the underlying
            //  file system.  Both FAT and CDFS may change the VPB address if
            //  the volume being mounted is one they recognize from a previous
            //  mount.
            //

            newDevExt = newLatencyDeviceObject->DeviceExtension;
            LatResetDeviceExtension( newDevExt );
            newDevExt->DiskDeviceObject = irpSp->Parameters.MountVolume.Vpb->RealDevice;

            //
            //  Get a new IRP stack location and set our mount completion
            //  routine.  Pass along the address of the device object we just
            //  created as its context.
            //

            IoCopyCurrentIrpStackLocationToNext( Irp );

            IoSetCompletionRoutine( Irp,
                                    LatMountCompletion,
                                    newLatencyDeviceObject,
                                    TRUE,
                                    TRUE,
                                    TRUE );

        } else {

            LAT_DBG_PRINT1( DEBUG_ERROR,
                            "LATENCY (LatFsControl): Error creating volume device object, status=%08x\n", 
                            status );

            //
            //  Something went wrong so this volume cannot be filtered.  Simply
            //  allow the system to continue working normally, if possible.
            //

            IoSkipCurrentIrpStackLocation( Irp );
        }

        status = IoCallDriver( DeviceObject, Irp );

        break;

    case IRP_MN_LOAD_FILE_SYSTEM:

        //
        //  This is a "load file system" request being sent to a file system
        //  recognizer device object.  This IRP_MN code is only sent to 
        //  file system recognizers.
        //

        LAT_DBG_PRINT2( DEBUG_DISPLAY_ATTACHMENT_NAMES,
                        "LATENCY (LatFsControl): Loading File System, Detaching from \"%.*S\"\n",
                        devExt->DeviceNames.Length / sizeof( WCHAR ),
                        devExt->DeviceNames.Buffer );

        //
        //  Set a completion routine so we can delete the device object when
        //  the detach is complete.
        //

        IoCopyCurrentIrpStackLocationToNext( Irp );

        IoSetCompletionRoutine(
            Irp,
            LatLoadFsCompletion,
            DeviceObject,
            TRUE,
            TRUE,
            TRUE );

        //
        //  Detach from the recognizer device.
        //

        IoDetachDevice( devExt->AttachedToDeviceObject );

        status = IoCallDriver( devExt->AttachedToDeviceObject, Irp );

    default:

        //
        //  Simply treat this as the pass through case and call
        //  the common routine to do this.
        //

        status = LatPassThrough( DeviceObject, Irp );
    }

    return status;
}

VOID
LatFsNotification (
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN FsActive
    )
/*++

Routine Description:

    This routine is invoked whenever a file system has either registered or
    unregistered itself as an active file system.

    For the former case, this routine creates a device object and attaches it
    to the specified file system's device object.  This allows this driver
    to filter all requests to that file system.

    For the latter case, this file system's device object is located,
    detached, and deleted.  This removes this file system as a filter for
    the specified file system.

Arguments:

    DeviceObject - Pointer to the file system's device object.

    FsActive - Boolean indicating whether the file system has registered
        (TRUE) or unregistered (FALSE) itself as an active file system.

Return Value:

    None.

--*/
{
    UNICODE_STRING name;
    WCHAR nameBuffer[DEVICE_NAMES_SZ];

    PAGED_CODE();

    RtlInitEmptyUnicodeString( &name, nameBuffer, sizeof( nameBuffer ) );

    //
    //  Display the names of all the file system we are notified of
    //

    if (FlagOn( Globals.DebugLevel, DEBUG_DISPLAY_ATTACHMENT_NAMES )) {

        LatGetBaseDeviceObjectName( DeviceObject, &name );
        DbgPrint( "LATENCY (LatFsNotification): %s   \"%.*S\" (%s)\n",
                  (FsActive) ? "Activating file system  " : "Deactivating file system",
                  name.Length / sizeof( WCHAR ),
                  name.Buffer,
                  GET_DEVICE_TYPE_NAME(DeviceObject->DeviceType));
    }

    //
    //  See if we want to ATTACH or DETACH from the given file system.
    //

    if (FsActive) {

        LatAttachToFileSystemDevice( DeviceObject, &name );

    } else {

        LatDetachFromFileSystemDevice( DeviceObject );
    }
}

NTSTATUS
LatAddLatencyCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is invoked for the completion of a mount request.  If the
    mount was successful, then this file system attaches its device object to
    the file system's volume device object.  Otherwise, the interim device
    object is deleted.

Arguments:

    DeviceObject - Pointer to this driver's device object that was attached to
            the file system device object

    Irp - Pointer to the IRP that was just completed.

    Context - Pointer to the device object allocated during the down path so
            we wouldn't have to deal with errors here.

Return Value:

    The return value is always STATUS_SUCCESS.

--*/
{
    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Irp );
    UNREFERENCED_PARAMETER( Context );
    return STATUS_SUCCESS;
}

NTSTATUS
LatMountCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is invoked for the completion of a mount request.  If the
    mount was successful, then this file system attaches its device object to
    the file system's volume device object.  Otherwise, the interim device
    object is deleted.

Arguments:

    DeviceObject - Pointer to this driver's device object that was attached to
            the file system device object

    Irp - Pointer to the IRP that was just completed.

    Context - Pointer to the device object allocated during the down path so
            we wouldn't have to deal with errors here.

Return Value:

    The return value is always STATUS_SUCCESS.

--*/

{
    PDEVICE_OBJECT latencyDeviceObject = (PDEVICE_OBJECT) Context;
    PLATENCY_DEVICE_EXTENSION devExt = latencyDeviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpSp = IoGetCurrentIrpStackLocation( Irp );
    PVPB diskDeviceVpb;
    NTSTATUS status;

    UNREFERENCED_PARAMETER( DeviceObject );
    ASSERT(IS_MY_DEVICE_OBJECT( latencyDeviceObject ));

    //
    //  We can not use the VPB parameter in the IRP stack because the base file
    //  system might be using a different vpb (it will do this when a volume is
    //  detected which has been previously mounted and still has cached state).  
    //  Get the VPB from the "real" device object in the IRP stack.
    //

    diskDeviceVpb = devExt->DiskDeviceObject->Vpb;

    //
    //  Determine whether or not the request was successful and act accordingly.
    //  Also  see if we are already attached to the given device object.  This
    //  can occur when the underlying filesystem detects a volume it has cached
    //  state for.
    //

    if (NT_SUCCESS( Irp->IoStatus.Status ) && 
        !LatIsAttachedToDevice( diskDeviceVpb->DeviceObject, NULL )) {

        //
        //  The FileSystem has successfully completed the mount, which means
        //  it has created the DeviceObject to which we want to attach.  The
        //  Irp parameters contains the Vpb which allows us to get to the
        //  following two things:
        //      1. The device object created by the file system to represent
        //         the volume it just mounted.
        //      2. The device object of the StorageDeviceObject which we
        //         can use to get the name of this volume.  We wukk pass
        //         this into SpyAttachToMountedDevice so that it can
        //         use it at needed.
        //

        status = LatAttachToMountedDevice( diskDeviceVpb->DeviceObject, 
                                           latencyDeviceObject,
                                           devExt->DiskDeviceObject );

        //
        //  Since we are in the completion path, we can't fail this attachment.
        //
        
        ASSERT( NT_SUCCESS( status ) );

        //
        //  We complete initialization of this device object, so now clear
        //  the initializing flag.
        //

        ClearFlag( latencyDeviceObject->Flags, DO_DEVICE_INITIALIZING );

    } else {

        //
        //  Display what mount failed.  Setup the buffers.
        //

        if (FlagOn( Globals.DebugLevel, DEBUG_DISPLAY_ATTACHMENT_NAMES )) {

            RtlInitEmptyUnicodeString( &devExt->DeviceNames, 
                                       devExt->DeviceNamesBuffer, 
                                       sizeof( devExt->DeviceNamesBuffer ) );
            LatGetObjectName( diskDeviceVpb->RealDevice, &devExt->DeviceNames );
            
            if (!NT_SUCCESS( Irp->IoStatus.Status )) {

                LAT_DBG_PRINT3( DEBUG_ERROR,
                				"LATENCY (LatMountCompletion): Mount volume failure for   \"%.*S\", status=%08x\n",
                                devExt->DeviceNames.Length / sizeof( WCHAR ),
                                devExt->DeviceNames.Buffer,
                                Irp->IoStatus.Status );

            } else {

                LAT_DBG_PRINT2( DEBUG_ERROR,
                				"LATENCY (LatMountCompletion): Mount volume failure for   \"%.*S\", already attached\n",
	                            devExt->DeviceNames.Length / sizeof( WCHAR ),
      		                    devExt->DeviceNames.Buffer );
            }
        }

        //
        //  The mount request failed.  Cleanup and delete the device
        //  object we created
        //

        IoDeleteDevice( latencyDeviceObject );
    }

    //
    //  If pending was returned, propagate it to the caller.
    //

    if (Irp->PendingReturned) {

        IoMarkIrpPending( Irp );
    }

    return STATUS_SUCCESS;
}

NTSTATUS
LatLoadFsCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is invoked upon completion of an FSCTL function to load a
    file system driver (as the result of a file system recognizer seeing
    that an on-disk structure belonged to it).  A device object has already
    been created by this driver (DeviceObject) so that it can be attached to
    the newly loaded file system.

Arguments:

    DeviceObject - Pointer to this driver's device object.

    Irp - Pointer to the I/O Request Packet representing the file system
          driver load request.

    Context - Context parameter for this driver, unused.

Return Value:

    The function value for this routine is always success.

--*/

{
    PLATENCY_DEVICE_EXTENSION devExt = DeviceObject->DeviceExtension;

    UNREFERENCED_PARAMETER( Context );
    ASSERT(IS_MY_DEVICE_OBJECT( DeviceObject ));

    //
    //  Display the name if requested
    //

    LAT_DBG_PRINT3( DEBUG_DISPLAY_ATTACHMENT_NAMES,
                    "LATENCY (LatLoadFsCompletion): Detaching from recognizer  \"%.*S\", status=%08x\n",
                    devExt->DeviceNames.Length / sizeof( WCHAR ),
                    devExt->DeviceNames.Buffer,
                    Irp->IoStatus.Status );

    //
    //  Check status of the operation
    //

    if (!NT_SUCCESS( Irp->IoStatus.Status )) {

        //
        //  The load was not successful.  Simply reattach to the recognizer
        //  driver in case it ever figures out how to get the driver loaded
        //  on a subsequent call.
        //

        IoAttachDeviceToDeviceStack( DeviceObject, 
                                     devExt->AttachedToDeviceObject );

    } else {

        //
        //  The load was successful, delete the Device object attached to the
        //  recognizer.
        //

        IoDeleteDevice( DeviceObject );
    }

    //
    //  If pending was returned, then propagate it to the caller.
    //

    if (Irp->PendingReturned) {

        IoMarkIrpPending( Irp );
    }

    return STATUS_SUCCESS;
}


NTSTATUS
LatCommonDeviceIoControl (
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
)
/*++

Routine Description:

    This routine does the common processing of interpreting the Device IO Control
    request.

Arguments:

    FileObject - The file object related to this operation.
    
    InputBuffer - The buffer containing the input parameters for this control
        operation.
        
    InputBufferLength - The length in bytes of InputBuffer.
    
    OutputBuffer - The buffer to receive any output from this control operation.
    
    OutputBufferLength - The length in bytes of OutputBuffer.
    
    IoControlCode - The control code specifying what control operation this is.
    
    IoStatus - Receives the status of this operation.
    
    DeviceObject - Pointer to device object Latency attached to the file system
        filter stack for the volume receiving this I/O request.
        
Return Value:

    None.
    
--*/
{
    PWSTR deviceName = NULL;
    LATENCYVER latencyVer;
    PLATENCY_SET_CLEAR setClear;
    PLATENCY_DEVICE_EXTENSION devExt;

    PAGED_CODE();

    ASSERT( IoStatus != NULL );
    ASSERT( IS_MY_DEVICE_OBJECT( DeviceObject ) );

    devExt = DeviceObject->DeviceExtension;
    
    IoStatus->Status = STATUS_SUCCESS;
    IoStatus->Information = 0;

    try {

        switch (IoControlCode) {
        case LATENCY_Reset:

            LatResetDeviceExtension( devExt );
            IoStatus->Status = STATUS_SUCCESS;
            break;

        //
        //      Request to start logging on a device
        //                                      

        case LATENCY_EnableLatency:

            if (InputBuffer == NULL || InputBufferLength <= 0) {

                IoStatus->Status = STATUS_INVALID_PARAMETER;
                break;
            }
            
            //
            // Copy the device name and add a null to ensure that it is null terminated
            //

            deviceName =  ExAllocatePool( NonPagedPool, InputBufferLength + sizeof(WCHAR) );

            if (NULL == deviceName) {

                IoStatus->Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
            
            RtlCopyMemory( deviceName, InputBuffer, InputBufferLength );
            deviceName[InputBufferLength / sizeof(WCHAR) - 1] = UNICODE_NULL;

            IoStatus->Status = LatEnable( DeviceObject, deviceName );
            break;  

        //
        //      Detach from a specified device
        //  

        case LATENCY_DisableLatency:

            if (InputBuffer == NULL || InputBufferLength <= 0) {

                IoStatus->Status = STATUS_INVALID_PARAMETER;
                break;
            }
            
            //
            // Copy the device name and add a null to ensure that it is null terminated
            //

            deviceName =  ExAllocatePool( NonPagedPool, InputBufferLength + sizeof(WCHAR) );

            if (NULL == deviceName) {

                IoStatus->Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
            
            RtlCopyMemory( deviceName, InputBuffer, InputBufferLength );
            deviceName[InputBufferLength / sizeof(WCHAR) - 1] = UNICODE_NULL;

            IoStatus->Status = LatDisable( deviceName );
            break;  

        //
        //      List all the devices that we are currently
        //      monitoring
        //

        case LATENCY_ListDevices:

            if (OutputBuffer == NULL || OutputBufferLength <= 0) {

                IoStatus->Status = STATUS_INVALID_PARAMETER;
                break;
            }


/* ISSUE-2000-09-21-mollybro 

    TODO : Implement LatGetAttachList.
    
*/

              IoStatus->Status = STATUS_SUCCESS;
//            IoStatus->Status = LatGetAttachList( OutputBuffer,
//                                                 OutputBufferLength,
//                                                 &IoStatus->Information);
            break;

        //
        //      Return version of the Latency filter driver
        //                                      

        case LATENCY_GetVer:

            if ((OutputBufferLength < sizeof(LATENCYVER)) || 
                (OutputBuffer == NULL)) {

                IoStatus->Status = STATUS_INVALID_PARAMETER;
                break;                    
            }
            
            latencyVer.Major = LATENCY_MAJ_VERSION;
            latencyVer.Minor = LATENCY_MIN_VERSION;
            
            RtlCopyMemory(OutputBuffer, &latencyVer, sizeof(LATENCYVER));
            
            IoStatus->Information = sizeof (LATENCYVER);
            break;
        
        case LATENCY_SetLatency:

            if (InputBuffer == NULL || 
                InputBufferLength <= sizeof( LATENCY_SET_CLEAR )) {

                IoStatus->Status = STATUS_INVALID_PARAMETER;
                break;
            }

            setClear = (PLATENCY_SET_CLEAR)InputBuffer;
            devExt->Operations[setClear->IrpCode].MillisecondDelay = setClear->Milliseconds;
            
            break;
            
        case LATENCY_ClearLatency:
        
        default:

            IoStatus->Status = STATUS_INVALID_PARAMETER;
            break;
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {

        //
        // An exception was incurred while attempting to access
        // one of the caller's parameters.  Simply return an appropriate
        // error status code.
        //

        IoStatus->Status = GetExceptionCode();

    }

    if (NULL != deviceName) {

        ExFreePool( deviceName );
    }

  return IoStatus->Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\latency\filter\latkernel.h ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    latKernel.h

Abstract:

    The header file containing information needed by the
    kernel mode of the latency filter driver.
    
Author:

    Molly Brown (mollybro)  

Environment:

    Kernel mode

--*/
#include <ntifs.h>
#include <stdlib.h>


#ifndef __LATKERNEL_H__
#define __LATKERNEL_H__

typedef struct _LATENCY_GLOBALS {

	ULONG DebugLevel;
	ULONG AttachMode;

	PDRIVER_OBJECT DriverObject;
	PDEVICE_OBJECT ControlDeviceObject;

	//
	//  The list of device extensions for the device objects
	//  we have attached to mounted volumes that we could
	//  be adding latency to.  
	//

	FAST_MUTEX DeviceExtensionListLock;
	LIST_ENTRY DeviceExtensionList;

	BOOLEAN FilterOn;

} LATENCY_GLOBALS, *PLATENCY_GLOBALS;

extern LATENCY_GLOBALS Globals;
extern KSPIN_LOCK GlobalsLock;

typedef struct _PENDING_STATUS {

	BOOLEAN PendOperation;
	BOOLEAN RandomFailure;
	ULONG FailureRate;
	ULONG MillisecondDelay;

} PENDING_STATUS, *PPENDING_STATUS;

typedef struct _OPERATION_NODE {

    //
    //  Array of PENDING_STATUS structures that describes
    //  the state for each operation at this level.
    //
    
    PENDING_STATUS Op[];

    //
    //  Pointer to a child operation node, if one exists,
    //  that allows finer grained control over the sub-operations
    //  
    
    struct _OPERATION_NODE *ChildOpNode;

} OPERATION_NODE, *POPERATION_NODE;
    
#define DEVICE_NAMES_SZ  100
#define USER_NAMES_SZ   64

typedef struct _LATENCY_DEVICE_EXTENSION {

    BOOLEAN Enabled;
    BOOLEAN IsVolumeDeviceObject;
    
	PDEVICE_OBJECT AttachedToDeviceObject;
	PDEVICE_OBJECT DiskDeviceObject;

	PLIST_ENTRY NextLatencyDeviceLink;

    UNICODE_STRING DeviceNames;              // receives name of device
    UNICODE_STRING UserNames;                // names that the user used to 
                                             //   start logging this device

	OPERATION_NODE IrpMajorOps[];            // The memory for the IrpMj code operation
	                                         //   nodes and any sub-operation node will be
	                                         //   allocated contiguously with the device
	                                         //   extension.	

    WCHAR DeviceNamesBuffer[DEVICE_NAMES_SZ];// holds actual device names
    WCHAR UserNamesBuffer[USER_NAMES_SZ];    // holds actual user names

    //
    //  Note: We keep these two forms of the name so that we can build
    //    a nicer looking name when we are printing out file names.
    //    We want just the "c:" type device name at the beginning
    //    of a file name, not "\device\hardiskVolume1".
    //
	
} LATENCY_DEVICE_EXTENSION, *PLATENCY_DEVICE_EXTENSION;

#define IS_MY_DEVICE_OBJECT( _devObj )                     \
    (((_devObj) != NULL) &&                                \
     ((_devObj)->DriverObject == Globals.DriverObject) &&  \
     ((_devObj)->DeviceExtension != NULL))

//
// Macro to test if we are logging for this device
// NOTE: We don't bother synchronizing to check the Globals.FilterOn since
//   we can tolerate a stale value here.  We just look at it here to avoid 
//   doing the logging work if we can.
//

#define SHOULD_PEND(pDeviceObject) \
    ((Globals.FilterOn) && \
     (((PLATENCY_DEVICE_EXTENSION)(pDeviceObject)->DeviceExtension)->Enabled))
     
//
//  Macro for validating the FastIo dispatch routines before calling
//  them in the FastIo pass through functions.
//

#define VALID_FAST_IO_DISPATCH_HANDLER(FastIoDispatchPtr, FieldName) \
    (((FastIoDispatchPtr) != NULL) && \
     (((FastIoDispatchPtr)->SizeOfFastIoDispatch) >= \
      (FIELD_OFFSET(FAST_IO_DISPATCH, FieldName) + sizeof(VOID *))) && \
     ((FastIoDispatchPtr)->FieldName != NULL))

//
//  list of known device types
//

extern const PCHAR DeviceTypeNames[];

//
//  We need this because the compiler doesn't like doing sizeof an externed
//  array in the other file that needs it (latlib.c)
//

extern ULONG SizeOfDeviceTypeNames;

#define GET_DEVICE_TYPE_NAME( _type ) \
            ((((_type) > 0) && ((_type) < (SizeOfDeviceTypeNames / sizeof(PCHAR)))) ? \
                DeviceTypeNames[ (_type) ] : \
                "[Unknown]")

//
//  Macro to test for device types we want to attach to
//

#define IS_DESIRED_DEVICE_TYPE(_type) \
    (((_type) == FILE_DEVICE_DISK_FILE_SYSTEM) || \
     ((_type) == FILE_DEVICE_CD_ROM_FILE_SYSTEM) || \
     ((_type) == FILE_DEVICE_NETWORK_FILE_SYSTEM))

//
//  Macros for Latency DbgPrint levels.
//

#if DBG
#define LAT_DBG_PRINT0( _dbgLevel, _string )          \
    {                                                     \
        if (FlagOn( Globals.DebugLevel, (_dbgLevel) )) {  \
            DbgPrint( (_string) );                        \
        }                                                 \
    }

#define LAT_DBG_PRINT1( _dbgLevel, _formatString, _parm1 )  \
    {                                                           \
        if (FlagOn( Globals.DebugLevel, (_dbgLevel) )) {        \
            DbgPrint( (_formatString), (_parm1) );              \
        }                                                       \
    }

#define LAT_DBG_PRINT2( _dbgLevel, _formatString, _parm1, _parm2 )  \
    {                                                                   \
        if (FlagOn( Globals.DebugLevel, (_dbgLevel) )) {                \
            DbgPrint( (_formatString), (_parm1), (_parm2) );            \
        }                                                               \
    }

#define LAT_DBG_PRINT3( _dbgLevel, _formatString, _parm1, _parm2, _parm3 )  \
    {                                                                           \
        if (FlagOn( Globals.DebugLevel, (_dbgLevel) )) {                        \
            DbgPrint( (_formatString), (_parm1), (_parm2), (_parm3) );          \
        }                                                                       \
    }

#else

#define LAT_DBG_PRINT0( _dbgLevel, _string )
#define LAT_DBG_PRINT1( _dbgLevel, _formatString, _parm1 ) 
#define LAT_DBG_PRINT2( _dbgLevel, _formatString, _parm1, _parm2 )
#define LAT_DBG_PRINT3( _dbgLevel, _formatString, _parm1, _parm2, _parm3 )

#endif

//
//  Debug flags
//
#define DEBUG_ERROR                       0x00000001
#define DEBUG_DISPLAY_ATTACHMENT_NAMES    0x00000020

//
//  Pool tags
//

#define LATENCY_POOL_TAG    'FtaL'

///////////////////////////////////////////////////////////////
//                                                           //
//  Prototypes for Latency.c                                 //
//                                                           //
///////////////////////////////////////////////////////////////

NTSTATUS
DriverEntry (
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
);

NTSTATUS
LatDispatch (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
);

NTSTATUS
LatPassThrough (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
);

NTSTATUS
LatFsControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
);

VOID
LatFsNotification (
    IN PDEVICE_OBJECT DeviceObject,
    IN BOOLEAN FsActive
);

NTSTATUS
LatAddLatencyCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
LatMountCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );
    
NTSTATUS
LatLoadFsCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
LatCommonDeviceIoControl (
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);


///////////////////////////////////////////////////////////////
//                                                           //
//  Prototypes for LatFastIo.c                               //
//                                                           //
///////////////////////////////////////////////////////////////

BOOLEAN
LatFastIoCheckIfPossible (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN BOOLEAN CheckForReadOperation,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
LatFastIoRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN        
LatFastIoWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN BOOLEAN Wait,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
LatFastIoQueryBasicInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_BASIC_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
LatFastIoQueryStandardInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_STANDARD_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
LatFastIoLock (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    BOOLEAN FailImmediately,
    BOOLEAN ExclusiveLock,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
LatFastIoUnlockSingle (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PLARGE_INTEGER Length,
    PEPROCESS ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
LatFastIoUnlockAll (
    IN PFILE_OBJECT FileObject,
    PEPROCESS ProcessId,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
LatFastIoUnlockAllByKey (
    IN PFILE_OBJECT FileObject,
    PVOID ProcessId,
    ULONG Key,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
LatFastIoDeviceControl (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    IN PVOID InputBuffer OPTIONAL,
    IN ULONG InputBufferLength,
    OUT PVOID OutputBuffer OPTIONAL,
    IN ULONG OutputBufferLength,
    IN ULONG IoControlCode,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);

VOID
LatFastIoDetachDevice (
    IN PDEVICE_OBJECT SourceDevice,
    IN PDEVICE_OBJECT TargetDevice
);

BOOLEAN
LatFastIoQueryNetworkOpenInfo (
    IN PFILE_OBJECT FileObject,
    IN BOOLEAN Wait,
    OUT PFILE_NETWORK_OPEN_INFORMATION Buffer,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
LatFastIoMdlRead (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
LatFastIoMdlReadComplete (
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
LatFastIoPrepareMdlWrite (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
LatFastIoMdlWriteComplete (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
LatFastIoReadCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    OUT PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    OUT struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
LatFastIoWriteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN ULONG Length,
    IN ULONG LockKey,
    IN PVOID Buffer,
    OUT PMDL *MdlChain,
    OUT PIO_STATUS_BLOCK IoStatus,
    IN struct _COMPRESSED_DATA_INFO *CompressedDataInfo,
    IN ULONG CompressedDataInfoLength,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
LatFastIoMdlReadCompleteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
LatFastIoMdlWriteCompleteCompressed (
    IN PFILE_OBJECT FileObject,
    IN PLARGE_INTEGER FileOffset,
    IN PMDL MdlChain,
    IN PDEVICE_OBJECT DeviceObject
);

BOOLEAN
LatFastIoQueryOpen (
    IN PIRP Irp,
    OUT PFILE_NETWORK_OPEN_INFORMATION NetworkInformation,
    IN PDEVICE_OBJECT DeviceObject
);

///////////////////////////////////////////////////////////////
//                                                           //
//  Prototypes for LatLib.c                                  //
//                                                           //
///////////////////////////////////////////////////////////////

VOID
LatReadDriverParameters (
    IN PUNICODE_STRING RegistryPath
    );
    
NTSTATUS
LatAttachToFileSystemDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PUNICODE_STRING Name
    );
    
VOID
LatDetachFromFileSystemDevice (
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
LatEnumerateFileSystemVolumes (
    IN PDEVICE_OBJECT FSDeviceObject,
    IN PUNICODE_STRING Name
    );
    
BOOLEAN
LatIsAttachedToDevice (
    PDEVICE_OBJECT DeviceObject,
    PDEVICE_OBJECT *AttachedDeviceObject OPTIONAL
);

NTSTATUS
LatAttachToMountedDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN PDEVICE_OBJECT LatencyDeviceObject,
    IN PDEVICE_OBJECT DiskDeviceObject
);

VOID
LatGetObjectName (
    IN PVOID Object,
    IN OUT PUNICODE_STRING Name
);

VOID
LatGetBaseDeviceObjectName (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PUNICODE_STRING Name
);

VOID
LatCacheDeviceName (
    IN PDEVICE_OBJECT DeviceObject
);

NTSTATUS
LatGetDeviceObjectFromName (
    IN PUNICODE_STRING DeviceName,
    OUT PDEVICE_OBJECT *DeviceObject
);

NTSTATUS
LatEnable (
    IN PDEVICE_OBJECT DeviceObject,
    IN PWSTR UserDeviceName
);

NTSTATUS
LatDisable (
    IN PWSTR DeviceName
);

VOID
LatResetDeviceExtension (
    PLATENCY_DEVICE_EXTENSION DeviceExtension
);


/////////////////////////////////////////////////////////////////
//                                                             //
//  Arrays to track the number of operations and suboperations //
//  there are in the system.                                   //
//                                                             //
/////////////////////////////////////////////////////////////////

//
//  For each IRP_MJ code, there can be 0 or more IRP_MN codes.
//  For each IRP_MN code, there can be 0 or more FS|IO CTL codes.
//

typedef struct _COUNT_NODE {
    ULONG Count;
    struct _COUNT_NODE *ChildCount;
} COUNT_NODE, *PCOUNT_NODE;

COUNT_NODE ChildrenOfIrpMajorCodes [] = {
        { 0, NULL },    // IRP_MJ_CREATE                   0x00
        { 0, NULL },    // IRP_MJ_CREATE_NAMED_PIPE        0x01
        { 0, NULL },    // IRP_MJ_CLOSE                    0x02
        { 9, NULL },    // IRP_MJ_READ                     0x03
        { 9, NULL },    // IRP_MJ_WRITE                    0x04
        { 0, NULL },    // IRP_MJ_QUERY_INFORMATION        0x05
        { 0, NULL },    // IRP_MJ_SET_INFORMATION          0x06
        { 0, NULL },    // IRP_MJ_QUERY_EA                 0x07
        { 0, NULL },    // IRP_MJ_SET_EA                   0x08
        { 0, NULL },    // IRP_MJ_FLUSH_BUFFERS            0x09
        { 0, NULL },    // IRP_MJ_QUERY_VOLUME_INFORMATION 0x0a
        { 0, NULL },    // IRP_MJ_SET_VOLUME_INFORMATION   0x0b
        { 3, NULL },    // IRP_MJ_DIRECTORY_CONTROL        0x0c
        { 5,            // IRP_MJ_FILE_SYSTEM_CONTROL      0x0d
            { 
            }
        { 2, NULL },    // IRP_MJ_DEVICE_CONTROL           0x0e
        { 0, NULL },    // IRP_MJ_INTERNAL_DEVICE_CONTROL  0x0f
        { 0, NULL },    // IRP_MJ_SHUTDOWN                 0x10
        { 5, NULL },    // IRP_MJ_LOCK_CONTROL             0x11
        { 0, NULL },    // IRP_MJ_CLEANUP                  0x12
        { 0, NULL },    // IRP_MJ_CREATE_MAILSLOT          0x13
        { 0, NULL },    // IRP_MJ_QUERY_SECURITY           0x14
        { 0, NULL },    // IRP_MJ_SET_SECURITY             0x15
        { 4, NULL },    // IRP_MJ_POWER                    0x16
        { 12, NULL },   // IRP_MJ_SYSTEM_CONTROL           0x17
        { 0, NULL },    // IRP_MJ_DEVICE_CHANGE            0x18
        { 0, NULL },    // IRP_MJ_QUERY_QUOTA              0x19
        { 0, NULL },    // IRP_MJ_SET_QUOTA                0x1a
        { 24, NULL },   // IRP_MJ_PNP                      0x1b
        { 0, NULL },    // IRP_MJ_MAXIMUM_FUNCTION         0x1b
    
    };
    
#endif /* LATKERNEL_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\latency\inc\latency.h ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    latency.h

Abstract:

    The header file containing information needed by both the 
    user mode and kernel mode of the latency filter driver.
    
Author:

    Molly Brown (mollybro)  

Environment:

    Kernel mode

--*/

#ifndef __LATENCY_H__
#define __LATENCY_H__

//
//  Enable these warnings in the code.
//

#pragma warning(error:4100)   // Unreferenced formal parameter
#pragma warning(error:4101)   // Unreferenced local variable


#define LATENCY_Reset              (ULONG) CTL_CODE( FILE_DEVICE_DISK_FILE_SYSTEM, 0x00, METHOD_BUFFERED, FILE_WRITE_ACCESS )
#define LATENCY_EnableLatency      (ULONG) CTL_CODE( FILE_DEVICE_DISK_FILE_SYSTEM, 0x01, METHOD_BUFFERED, FILE_READ_ACCESS )
#define LATENCY_DisableLatency     (ULONG) CTL_CODE( FILE_DEVICE_DISK_FILE_SYSTEM, 0x02, METHOD_BUFFERED, FILE_READ_ACCESS )
#define LATENCY_GetLog             (ULONG) CTL_CODE( FILE_DEVICE_DISK_FILE_SYSTEM, 0x03, METHOD_BUFFERED, FILE_READ_ACCESS )
#define LATENCY_GetVer             (ULONG) CTL_CODE( FILE_DEVICE_DISK_FILE_SYSTEM, 0x04, METHOD_BUFFERED, FILE_READ_ACCESS )
#define LATENCY_ListDevices        (ULONG) CTL_CODE( FILE_DEVICE_DISK_FILE_SYSTEM, 0x05, METHOD_BUFFERED, FILE_READ_ACCESS )
#define LATENCY_SetLatency         (ULONG) CTL_CODE( FILE_DEVICE_DISK_FILE_SYSTEM, 0x06, METHOD_BUFFERED, FILE_READ_ACCESS )
#define LATENCY_ClearLatency       (ULONG) CTL_CODE( FILE_DEVICE_DISK_FILE_SYSTEM, 0x07, METHOD_BUFFERED, FILE_READ_ACCESS )

#define LATENCY_DRIVER_NAME     L"LATENCY.SYS"
#define LATENCY_DEVICE_NAME     L"LatencyFilter"
#define LATENCY_W32_DEVICE_NAME L"\\\\.\\LatencyFilter"
#define LATENCY_DOSDEVICE_NAME  L"\\DosDevices\\LatencyFilter"
#define LATENCY_FULLDEVICE_NAME L"\\Device\\LatencyFilter"
    
#define LATENCY_MAJ_VERSION 1
#define LATENCY_MIN_VERSION 0

typedef struct _LATENCYVER {
    USHORT Major;
    USHORT Minor;
} LATENCYVER, *PLATENCYVER;

typedef struct _LATENCY_ENABLE_DISABLE {

    UNICODE_STRING DeviceName;
    UCHAR DeviceNameBuffer[];

} LATENCY_ENABLE_DISABLE, *PLATENCY_ENABLE_DISABLE;

typedef struct _LATENCY_SET_CLEAR {

    UCHAR IrpCode;
    ULONG Milliseconds;
    UNICODE_STRING DeviceName;
    UCHAR DeviceNameBuffer[];

} LATENCY_SET_CLEAR, *PLATENCY_SET_CLEAR;

#define LATENCY_ATTACH_ALL_VOLUMES 1
#define LATENCY_ATTACH_ON_DEMAND   0

#endif /* __LATENCY_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\fs\fltsamples\latency\filter\latlib.c ===
/*++

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    latLib.c

Abstract:

    This file contains all the support routines for the Latency Filter.
    
Author:

    Molly Brown (mollybro)  

Environment:

    Kernel mode

--*/

#include <latKernel.h>

////////////////////////////////////////////////////////////////////////
//                                                                    //
//         Helper routine for reading inital driver parameters        //
//         from registry.                                             //
//                                                                    //
////////////////////////////////////////////////////////////////////////

VOID
LatReadDriverParameters (
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    This routine tries to read the Latency-specific parameters from
    the registry.  These values will be found in the registry location
    indicated by the RegistryPath passed in.

Arguments:

    RegistryPath - the path key which contains the values that are
        the Latency parameters

Return Value:

    None.

--*/
{
    UNREFERENCED_PARAMETER( RegistryPath );
/*
    OBJECT_ATTRIBUTES attributes;
    HANDLE driverRegKey;
    NTSTATUS status;
    ULONG bufferSize, resultLength;
    PVOID buffer = NULL;
    UNICODE_STRING valueName;
    PKEY_VALUE_PARTIAL_INFORMATION pValuePartialInfo;

    //
    //  All the global values are already set to default values.  Any
    //  values we read from the registry will override these defaults.
    //
    
    //
    //  Do the initial setup to start reading from the registry.
    //

    InitializeObjectAttributes( &attributes,
								RegistryPath,
								OBJ_CASE_INSENSITIVE,
								NULL,
								NULL);

    status = ZwOpenKey( &driverRegKey,
						KEY_READ,
						&attributes);

    if (!NT_SUCCESS(status)) {

        driverRegKey = NULL;
        goto SpyReadDriverParameters_Exit;
    }

    bufferSize = sizeof( KEY_VALUE_PARTIAL_INFORMATION ) + sizeof( ULONG );
    buffer = ExAllocatePool( NonPagedPool, bufferSize );

    if (NULL == buffer) {

        goto SpyReadDriverParameters_Exit;
    }

    //
    // Read the gMaxRecordsToAllocate from the registry
    //

    RtlInitUnicodeString(&valueName, MAX_RECORDS_TO_ALLOCATE);

    status = ZwQueryValueKey( driverRegKey,
							  &valueName,
							  KeyValuePartialInformation,
							  buffer,
							  bufferSize,
							  &resultLength);

    if (NT_SUCCESS(status)) {

        pValuePartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION) buffer;
        ASSERT(pValuePartialInfo->Type == REG_DWORD);
        gMaxRecordsToAllocate = *((PLONG)&(pValuePartialInfo->Data));

    }

    //
    // Read the gMaxNamesToAllocate from the registry
    //

    RtlInitUnicodeString(&valueName, MAX_NAMES_TO_ALLOCATE);

    status = ZwQueryValueKey( driverRegKey,
							  &valueName,
							  KeyValuePartialInformation,
							  buffer,
							  bufferSize,
							  &resultLength);

    if (NT_SUCCESS(status)) {

        pValuePartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION) buffer;
        ASSERT(pValuePartialInfo->Type == REG_DWORD);
        gMaxNamesToAllocate = *((PLONG)&(pValuePartialInfo->Data));

    }

    //
    // Read the initial debug setting from the registry
    //

    RtlInitUnicodeString(&valueName, DEBUG_LEVEL);

    status = ZwQueryValueKey( driverRegKey,
                              &valueName,
                              KeyValuePartialInformation,
                              buffer,
                              bufferSize,
                              &resultLength );

    if (NT_SUCCESS( status )) {

        pValuePartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION) buffer;
        ASSERT( pValuePartialInfo->Type == REG_DWORD );
        gFileSpyDebugLevel = *((PULONG)&(pValuePartialInfo->Data));
        
    }
    
    //
    // Read the attachment mode setting from the registry
    //

    RtlInitUnicodeString(&valueName, ATTACH_MODE);

    status = ZwQueryValueKey( driverRegKey,
                              &valueName,
                              KeyValuePartialInformation,
                              buffer,
                              bufferSize,
                              &resultLength );

    if (NT_SUCCESS( status )) {

        pValuePartialInfo = (PKEY_VALUE_PARTIAL_INFORMATION) buffer;
        ASSERT( pValuePartialInfo->Type == REG_DWORD );
        gFileSpyAttachMode = *((PULONG)&(pValuePartialInfo->Data));
        
    }
    
    goto SpyReadDriverParameters_Exit;

SpyReadDriverParameters_Exit:

    if (NULL != buffer) {

        ExFreePool(buffer);
    }

    if (NULL != driverRegKey) {

        ZwClose(driverRegKey);
    }

    return;
*/
}

BOOLEAN
LatShouldPendThisIo (
    IN PLATENCY_DEVICE_EXTENSION DeviceExtension,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine checks to see if this operation should be pending.
    This decision is based on the operation state for this device,
    if this operation is allowed to be pended, and, if random failure is
    set, if this operation should fail based on random failure rate.

Argument:

    DeviceExtension - The latency device extension for this
        device object.

    Irp