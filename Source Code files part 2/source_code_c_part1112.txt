);
                }
                MftMappings[ArraySize].Start = xStart;
                MftMappings[ArraySize].Count = xCount;
                ArraySize++;

                SegmentsInMft++;
            }
        } while(AttrListEntry->TypeCode == $DATA);
    } else {
        printf(".");
    }

    return(TRUE);
}


BOOL
pNtfsTransferVolumeBitmap(
    IN HPARTITION       PartitionHandle,
    IN PARTITION_IMAGE *PartitionImage,
    IN UINT             OutputFileHandle
    )
{
    FPFILE_RECORD_SEGMENT BitmapFrsBuffer;
    FPATTRIBUTE_RECORD Record;
    BOOL b;
    ULONG Frn;

    //
    // Allocate a scratch buffer for the volume bitmap frs,
    // then locate the frs for the volume bitmap and read it in.
    //
    BitmapFrsBuffer = malloc(SectorsPerFrs * 512);
    if(!BitmapFrsBuffer) {
        fprintf(stderr,"\n%s\n",textOOM);
        return(FALSE);
    }

    if(!pNtfsReadFrs(PartitionHandle,PartitionImage,BIT_MAP_FILE_NUMBER,BitmapFrsBuffer)) {
        free(BitmapFrsBuffer);
        return(FALSE);
    }

    printf(".");

    //
    // Attempt to locate a $DATA attribute for the volume bitmap.
    // If there is none, get the attribute list.
    //
    Record = pNtfsLocateAttributeRecord(BitmapFrsBuffer,$DATA);
    printf(".");
    if(!Record) {

        b = pNtfsSearchFrsForAttrList(
                PartitionHandle,
                PartitionImage,
                BitmapFrsBuffer,
                $DATA,
                &Frn
                );

        if(!b) {
            free(BitmapFrsBuffer);
            return(FALSE);
        }

        b = pNtfsReadFrs(PartitionHandle,PartitionImage,Frn,BitmapFrsBuffer);
        if(!b) {
            free(BitmapFrsBuffer);
            return(FALSE);
        }

        printf(".");

        Record = pNtfsLocateAttributeRecord(BitmapFrsBuffer,$DATA);
        if(!Record) {
            fprintf(stderr,"\n");
            fprintf(stderr,textNtfsCorrupt,0);
            fprintf(stderr,"\n");
            free(BitmapFrsBuffer);
            return(FALSE);
        }
    }

    printf(".\n");

    b = pNtfsReadWholeAttribute(
            PartitionHandle,
            PartitionImage,
            Record,
            NULL,
            OutputFileHandle
            );

    free(BitmapFrsBuffer);
    return(b);
}


BOOL
pNtfsProcessVolumeBitmap(
    IN OUT PARTITION_IMAGE *PartitionImage,
    IN     UINT             FileHandle
    )
{
    ULONG LastUsed;
    ULONG TotalUsed;
    ULONG BaseCluster;
    UINT Offset;
    UINT Read;
    ULONG i;
    extern BYTE BitValue[8];

    //
    // Rewind the file
    //
    DosSeek(FileHandle,0,DOSSEEK_START);

    LastUsed = 0;
    TotalUsed = 0;
    BaseCluster = 0;

    for(i=0; i<PartitionImage->ClusterCount; i++,Offset++) {
        //
        // Reload bitmap buffer if necessary
        //
        if(!(i % (512*8))) {

            if(_dos_read(FileHandle,IoBuffer,512,&Read) || (Read != 512)) {
                fprintf(stderr,"\n%s\n",textFileReadFailed);
                return(FALSE);
            }

            printf(textProcessingNtfsBitmap,100*i/PartitionImage->ClusterCount);
            printf("\r");

            Offset = 0;
            if(i) {
                BaseCluster += (512*8);
            }
        }

        if(((FPBYTE)IoBuffer)[Offset/8] & BitValue[Offset%8]) {
            TotalUsed++;
            LastUsed = i;
        }
    }

    PartitionImage->UsedClusterCount = TotalUsed;
    PartitionImage->LastUsedCluster = LastUsed;

    //
    // Calculate the number of sectors in the bitmap.
    // It's impossible for an NTFS drive to have none used since
    // all fs data structures are part of clusters, so we don't worry
    // about boundary cases.
    //
    i = (LastUsed / (8*512)) + 1;

    //
    // Truncate the output file.
    //
    if((DosSeek(FileHandle,i*512,DOSSEEK_START) != i*512)
    || _dos_write(FileHandle,IoBuffer,0,&Read)) {
        fprintf(stderr,"\n%s\n",textFileWriteError);
        return(FALSE);

    }

    printf(textProcessingNtfsBitmap,100);
    printf("\n");
    return(TRUE);
}


BOOL
pNtfsMultiSectorFixup(
    IN OUT FPVOID Buffer
    )
{
    UINT Size,Offset;
    FPUINT p,q;

    Offset = ((FPMULTI_SECTOR_HEADER)Buffer)->UpdateArrayOfs;
    Size = ((FPMULTI_SECTOR_HEADER)Buffer)->UpdateArraySize;
    if(!Size) {
        fprintf(stderr,"\n");
        fprintf(stderr,textNtfsCorrupt,1);
        fprintf(stderr,"\n");
        return(FALSE);
    }

    p = (FPUINT)((FPBYTE)Buffer + Offset) + 1;
    q = (FPUINT)((FPBYTE)Buffer + SEQUENCE_NUMBER_STRIDE) - 1;

    while(--Size) {

        *q = *p++;

        q = (FPUINT)((FPBYTE)q + SEQUENCE_NUMBER_STRIDE);
    }

    return(TRUE);
}


FPATTRIBUTE_RECORD
pNtfsLocateAttributeRecord(
    IN FPFILE_RECORD_SEGMENT FrsBuffer,
    IN ULONG                 TypeCode
    )
{
    FPATTRIBUTE_RECORD Attr;

    Attr = (FPATTRIBUTE_RECORD)((FPBYTE)FrsBuffer + FrsBuffer->FirstAttribute);

    while(Attr->TypeCode != $END) {

        if((Attr->TypeCode == TypeCode) && !Attr->NameLength) {
            return(Attr);
        }

        Attr = (FPATTRIBUTE_RECORD)((FPBYTE)Attr + Attr->RecordLength);
    }

    return(NULL);
}


BOOL
pNtfsReadWholeAttribute(
    IN  HPARTITION          PartitionHandle,
    IN  PARTITION_IMAGE    *PartitionImage,
    IN  FPATTRIBUTE_RECORD  Attribute,
    OUT FPVOID              Buffer,             OPTIONAL
    IN  UINT                OutputFileHandle    OPTIONAL
    )
{
    FPRESIDENT_ATTRIBUTE_FORM Resident;
    FPNONRESIDENT_ATTRIBUTE_FORM NonResident;
    ULONG ClusterCount;
    UINT RunLength;
    ULONG Vcn,Lcn,Lbn;
    UINT Sectors;
    BYTE x;
    UINT Written;
    ULONG SectorsDone;
    ULONG OriginalCount;

    if(Attribute->FormCode == RESIDENT_FORM) {

        Resident = (FPRESIDENT_ATTRIBUTE_FORM)((FPBYTE)Attribute + offsetof(ATTRIBUTE_RECORD,FormUnion));

        if(Buffer) {
            if(Resident->ValueLength > ATTR_LIST_BUFFER_SIZE) {
                fprintf(stderr,"\n");
                fprintf(stderr,textNtfsUnsupportedConfig,3);
                fprintf(stderr,"\n");
                return(FALSE);
            }

            memmove(
                Buffer,
                (FPBYTE)Attribute + Resident->ValueOffset,
                (UINT)Resident->ValueLength
                );

            return(TRUE);
        } else {
            fprintf(stderr,"\n");
            fprintf(stderr,textNtfsUnsupportedConfig,4);
            fprintf(stderr,"\n");
            return(FALSE);
        }
    }

    NonResident = (FPNONRESIDENT_ATTRIBUTE_FORM)((FPBYTE)Attribute + offsetof(ATTRIBUTE_RECORD,FormUnion));

    ClusterCount = NonResident->HighestVcn + 1;
    if(Buffer && ((ClusterCount * PartitionImage->SectorsPerCluster * 512) > (ULONG)ATTR_LIST_BUFFER_SIZE)) {
        fprintf(stderr,"\n");
        fprintf(stderr,textNtfsUnsupportedConfig,5);
        fprintf(stderr,"\n");
        return(FALSE);
    }

    Vcn = 0;

    if(!Buffer) {

        OriginalCount = ClusterCount * PartitionImage->SectorsPerCluster;
        SectorsDone = 0;

        printf(textNtfsBuildingBitmap,0);
        printf("\r");
    }

    while(ClusterCount) {

        pNtfsComputeLcn(Vcn,Attribute,&Lcn,&RunLength);

        if(ClusterCount < (ULONG)RunLength) {
            RunLength = (UINT)ClusterCount;
        }

        Sectors = RunLength * PartitionImage->SectorsPerCluster;
        Lbn = Lcn * PartitionImage->SectorsPerCluster;
        while(Sectors) {

            x = (BYTE)((Sectors > 32) ? 32 : Sectors);

            if(!ReadPartition(PartitionHandle,Lbn,x,IoBuffer)) {
                fprintf(stderr,"\n");
                fprintf(stderr,textReadFailedAtSector,Lbn);
                fprintf(stderr,"\n");
                return(FALSE);
            }

            if(Buffer) {
                memmove(Buffer,IoBuffer,x*512);
                (FPBYTE)Buffer += x*512;
            } else {
                if(_dos_write(OutputFileHandle,IoBuffer,x*512,&Written) || (Written != x*512U)) {
                    fprintf(stderr,"\n%s\n",textFileWriteError);
                    return(FALSE);
                }
            }

            Sectors -= x;
            Lbn += x;

            if(!Buffer) {
                SectorsDone += x;
                printf(textNtfsBuildingBitmap,100 * SectorsDone / OriginalCount);
                printf("\r");
            }
        }

        Vcn += RunLength;
        ClusterCount -= RunLength;
    }

    if(!Buffer) {
        printf("\n");
    }

    return(TRUE);
}


BOOL
pNtfsComputeMftLcn(
    IN  HPARTITION  PartitionHandle,
    IN  ULONG       Vcn,
    OUT ULONG      *Lcn
    )
{
    UINT Segment;
    FPMFT_MAPPING MftMapping;
    BYTE Remaining;
    FPBYTE Buffer;
    FPATTRIBUTE_RECORD Attribute;
    UINT RunLength;

    MftMapping = MftMappings;
    for(Segment=0; Segment<SegmentsInMft; Segment++) {

        Remaining = SectorsPerFrs;
        Buffer = (FPBYTE)MftLcnFrsScratchBuffer;

        while(Remaining) {

            if(!ReadPartition(PartitionHandle,MftMapping->Start,MftMapping->Count,IoBuffer)) {
                fprintf(stderr,"\n");
                fprintf(stderr,textReadFailedAtSector,MftMapping->Start);
                fprintf(stderr,"\n");
                return(FALSE);
            }

            memmove(Buffer,IoBuffer,MftMapping->Count*512);

            Remaining -= MftMapping->Count;
            Buffer += MftMapping->Count*512;
            MftMapping++;
        }

        if(!pNtfsMultiSectorFixup(MftLcnFrsScratchBuffer)) {
            return(FALSE);
        }

        Attribute = pNtfsLocateAttributeRecord(MftLcnFrsScratchBuffer,$DATA);
        if(!Attribute) {
            fprintf(stderr,"\n");
            fprintf(stderr,textNtfsCorrupt,2);
            fprintf(stderr,"\n");
            return(FALSE);
        }

        if(pNtfsComputeLcn(Vcn,Attribute,Lcn,&RunLength)) {
            return(TRUE);
        }
    }

    //
    // Didn't find it, something is wrong
    //
    fprintf(stderr,"\n");
    fprintf(stderr,textNtfsCorrupt,3);
    fprintf(stderr,"\n");
    return(FALSE);
}


BOOL
pNtfsComputeLcn(
    IN  ULONG               Vcn,
    IN  FPATTRIBUTE_RECORD  Attribute,
    OUT ULONG              *Lcn,
    OUT UINT               *RunLength
    )
{
    FPNONRESIDENT_ATTRIBUTE_FORM NonResident;
    FPBYTE p;
    ULONG CurrentLcn,CurrentVcn,NextVcn;
    BYTE x1,x2;

    //
    // Make sure we're non-resident
    //
    if(Attribute->FormCode == RESIDENT_FORM) {
        return(FALSE);
    }

    //
    // Address the nonresident info
    //
    NonResident = (FPNONRESIDENT_ATTRIBUTE_FORM)((FPBYTE)Attribute + offsetof(ATTRIBUTE_RECORD,FormUnion));

    //
    // See if the desired VCN is in range
    //
    if((Vcn > NonResident->HighestVcn) || (Vcn < NonResident->LowestVcn)) {
        return(FALSE);
    }

    p = (FPBYTE)Attribute + NonResident->MappingPairOffset;
    CurrentLcn = 0;
    CurrentVcn = NonResident->LowestVcn;

    //
    // The loop condition checks the count byte
    //
    while(*p) {

        CurrentLcn += pNtfsLcnFromMappingPair(p);
        NextVcn = CurrentVcn + pNtfsVcnFromMappingPair(p);

        if(Vcn < NextVcn) {
            //
            // Found it.
            //
            *RunLength = (UINT)(NextVcn - Vcn);
            *Lcn = (Vcn - CurrentVcn) + CurrentLcn;
            return(TRUE);
        }

        CurrentVcn = NextVcn;

        x1 = *p;
        x2 = x1 & (BYTE)0xf;
        x1 >>= 4;

        p += x1+x2+1;
    }

    return(FALSE);
}


ULONG
pNtfsLcnFromMappingPair(
    IN FPBYTE p
    )
{
    BYTE v,l;
    long x;

    v = *p & (BYTE)0xf;
    l = (BYTE)(*p >> 4);
    if(!l) {
        return(0);
    }

    p += v + l;

    x = *(FPCHAR)p;
    l--;
    p--;

    while(l) {

        x <<= 8;
        x |= *p;

        p--;
        l--;
    }

    return(x);
}


ULONG
pNtfsVcnFromMappingPair(
    IN FPBYTE p
    )
{
    BYTE v;
    long x;

    v = *p & (BYTE)0xf;
    if(!v) {
        return(0);
    }

    p += v;

    x = *(FPCHAR)p;
    v--;
    p--;

    while(v) {

        x <<= 8;
        x |= *p;

        p--;
        v--;
    }

    return(x);
}


BOOL
pNtfsReadFrs(
    IN  HPARTITION       PartitionHandle,
    IN  PARTITION_IMAGE *PartitionImage,
    IN  ULONG            FileNumber,
    OUT FPVOID           Buffer
    )
{
    if(!pNtfsReadMftSectors(PartitionHandle,PartitionImage,FileNumber*SectorsPerFrs,Buffer)) {
        return(FALSE);
    }

    pNtfsMultiSectorFixup(Buffer);
    return(TRUE);
}


BOOL
pNtfsReadMftSectors(
    IN  HPARTITION       PartitionHandle,
    IN  PARTITION_IMAGE *PartitionImage,
    IN  ULONG            Vbn,
    OUT FPBYTE           Buffer
    )
{
    BYTE Remaining;
    BYTE Count;
    ULONG Vcn;
    BYTE r;
    ULONG Lcn;
    ULONG Lbn;
    ULONG NextVbn;

    Remaining = SectorsPerFrs;

    while(Remaining) {
        //
        // Get VCN
        //
        Vcn = Vbn / PartitionImage->SectorsPerCluster;
        r = (BYTE)(Vbn % PartitionImage->SectorsPerCluster);

        if(!pNtfsComputeMftLcn(PartitionHandle,Vcn,&Lcn)) {
            return(FALSE);
        }

        Lbn = (Lcn * PartitionImage->SectorsPerCluster) + r;

        //
        // Read in only a single cluster at a time to avoid problems
        // with fragmented runs in the mft.
        //
        if(Remaining > PartitionImage->SectorsPerCluster) {

            Count = PartitionImage->SectorsPerCluster;
            Remaining -= PartitionImage->SectorsPerCluster;
            NextVbn = Vbn + PartitionImage->SectorsPerCluster;

        } else {
            //
            // No need to worry about NextVbn since we'll break out of
            // the loop (Remaining will be 0).
            //
            Count = Remaining;
            Remaining = 0;
        }

        if(!ReadPartition(PartitionHandle,Lbn,Count,IoBuffer)) {
            fprintf(stderr,"\n");
            fprintf(stderr,textReadFailedAtSector,Lbn);
            fprintf(stderr,"\n");
            return(FALSE);
        }
        memmove(Buffer,IoBuffer,Count*512);
        Buffer += Count*512;

        Vbn = NextVbn;
    }

    return(TRUE);
}


BOOL
pNtfsSearchFrsForAttrList(
    IN  HPARTITION             PartitionHandle,
    IN  PARTITION_IMAGE       *PartitionImage,
    IN  FPFILE_RECORD_SEGMENT  FrsBuffer,
    IN  ULONG                  TypeCode,
    OUT ULONG                 *Frn
    )
{
    FPATTRIBUTE_RECORD Record;
    FPATTRIBUTE_LIST_ENTRY Attribute;
    BOOL b;

    Record = pNtfsLocateAttributeRecord(FrsBuffer,$ATTRIBUTE_LIST);
    if(!Record) {
        fprintf(stderr,"\n");
        fprintf(stderr,textNtfsCorrupt,4);
        fprintf(stderr,"\n");
        return(FALSE);
    }

    //
    // Got it, now read the attribute list into the attribute list
    // scratch buffer
    //
    b = pNtfsReadWholeAttribute(
            PartitionHandle,
            PartitionImage,
            Record,
            AttrListBuffer,
            0
            );

    if(!b) {
        return(FALSE);
    }

    Attribute = AttrListBuffer;

    nextrec:

    if(Attribute->TypeCode == TypeCode) {
        *Frn = Attribute->SegmentReference.LowPart;
        return(TRUE);
    }

    if(Attribute->TypeCode == $END) {
        fprintf(stderr,"\n");
        fprintf(stderr,textNtfsCorrupt,5);
        fprintf(stderr,"\n");
        return(FALSE);
    }

    if(!Attribute->Length) {
        fprintf(stderr,"\n");
        fprintf(stderr,textNtfsCorrupt,6);
        fprintf(stderr,"\n");
        return(FALSE);
    }

    Attribute = (FPATTRIBUTE_LIST_ENTRY)((FPBYTE)Attribute + Attribute->Length);
    goto nextrec;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\mpk\enduser\text.c ===
#include "enduser.h"


char *textCantLoadFont;
char *textNoXmsManager;
char *textXmsMemoryError;
char *textFatalError1;
char *textFatalError2;
char *textReadFailedAtSector;
char *textWriteFailedAtSector;
char *textCantFindMasterDisk;
char *textOOM;
char *textCantOpenMasterDisk;
char *textCantFindMPKBoot;
char *textNoOsImages;
char *textSelectLanguage;
char *textConfirmLanguage1;
char *textConfirmLanguage2;
char *textRebootPrompt1;
char *textRebootPrompt2;
char *textSelectOsPrompt;
char *textConfirmOs1;
char *textConfirmOs2;
char *textPleaseWaitRestoring;
char *textValidatingImage;
char *textChecksumFail;
char *textChecksumOk;


char *textLangName0,*textLangName1,*textLangName2,*textLangName3;
char *textLangName4,*textLangName5,*textLangName6,*textLangName7;
char *textLangName8,*textLangName9;

char *textOsName0,*textOsName1,*textOsName2,*textOsName3,*textOsName4;
char *textOsName5,*textOsName6,*textOsName7,*textOsName8,*textOsName9;

char *textOsDesc0,*textOsDesc1,*textOsDesc2,*textOsDesc3,*textOsDesc4;
char *textOsDesc5,*textOsDesc6,*textOsDesc7,*textOsDesc8,*textOsDesc9;


MESSAGE_STRING TextMessages[] = { { &textCantLoadFont,       0  },
                                  { &textNoXmsManager,       1  },
                                  { &textXmsMemoryError,     2  },
                                  { &textFatalError1,        3  },
                                  { &textFatalError2,        4  },
                                  { &textReadFailedAtSector, 5  },
                                  { &textWriteFailedAtSector,6  },
                                  { &textCantFindMasterDisk, 7  },
                                  { &textOOM,                8  },
                                  { &textCantOpenMasterDisk, 9  },
                                  { &textCantFindMPKBoot,    10 },
                                  { &textNoOsImages,         11 },
                                  { &textSelectLanguage,     12 },
                                  { &textConfirmLanguage1,   13 },
                                  { &textConfirmLanguage2,   14 },
                                  { &textRebootPrompt1,      15 },
                                  { &textRebootPrompt2,      16 },
                                  { &textSelectOsPrompt,     17 },
                                  { &textConfirmOs1,         20 },
                                  { &textConfirmOs2,         21 },
                                  { &textPleaseWaitRestoring,24 },
                                  { &textValidatingImage,    25 },
                                  { &textChecksumFail,       26 },
                                  { &textChecksumOk,         27 },

                                  { &textLangName0, TEXT_LANGUAGE_NAME_BASE+0 },
                                  { &textLangName1, TEXT_LANGUAGE_NAME_BASE+1 },
                                  { &textLangName2, TEXT_LANGUAGE_NAME_BASE+2 },
                                  { &textLangName3, TEXT_LANGUAGE_NAME_BASE+3 },
                                  { &textLangName4, TEXT_LANGUAGE_NAME_BASE+4 },
                                  { &textLangName5, TEXT_LANGUAGE_NAME_BASE+5 },
                                  { &textLangName6, TEXT_LANGUAGE_NAME_BASE+6 },
                                  { &textLangName7, TEXT_LANGUAGE_NAME_BASE+7 },
                                  { &textLangName8, TEXT_LANGUAGE_NAME_BASE+8 },
                                  { &textLangName9, TEXT_LANGUAGE_NAME_BASE+9 },

                                  { &textOsName0, TEXT_OS_NAME_BASE+0 },
                                  { &textOsName1, TEXT_OS_NAME_BASE+1 },
                                  { &textOsName2, TEXT_OS_NAME_BASE+2 },
                                  { &textOsName3, TEXT_OS_NAME_BASE+3 },
                                  { &textOsName4, TEXT_OS_NAME_BASE+4 },
                                  { &textOsName5, TEXT_OS_NAME_BASE+5 },
                                  { &textOsName6, TEXT_OS_NAME_BASE+6 },
                                  { &textOsName7, TEXT_OS_NAME_BASE+7 },
                                  { &textOsName8, TEXT_OS_NAME_BASE+8 },
                                  { &textOsName9, TEXT_OS_NAME_BASE+9 },

                                  { &textOsDesc0, TEXT_OS_DESC_BASE+0 },
                                  { &textOsDesc1, TEXT_OS_DESC_BASE+1 },
                                  { &textOsDesc2, TEXT_OS_DESC_BASE+2 },
                                  { &textOsDesc3, TEXT_OS_DESC_BASE+3 },
                                  { &textOsDesc4, TEXT_OS_DESC_BASE+4 },
                                  { &textOsDesc5, TEXT_OS_DESC_BASE+5 },
                                  { &textOsDesc6, TEXT_OS_DESC_BASE+6 },
                                  { &textOsDesc7, TEXT_OS_DESC_BASE+7 },
                                  { &textOsDesc8, TEXT_OS_DESC_BASE+8 },
                                  { &textOsDesc9, TEXT_OS_DESC_BASE+9 }
                                };

unsigned
GetTextCount(
    VOID
    )
{
    return(sizeof(TextMessages)/sizeof(TextMessages[0]));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\mpk\imagpart\fat.c ===
#include "imagpart.h"

//
// FAT boot sector.
//
#pragma pack(1)
typedef struct FAT_BOOT_SECTOR {
    BYTE   Jump[3];                 // offset = 0x00   0
    UCHAR  Oem[8];                  // offset = 0x03   3
    USHORT BytesPerSector;          // offset = 0x0b   11
    BYTE   SectorsPerCluster;       // offset = 0x0d   13
    USHORT ReservedSectors;         // offset = 0x0e   14
    BYTE   Fats;                    // offset = 0x10   16
    USHORT RootEntries;             // offset = 0x11   17
    USHORT Sectors;                 // offset = 0x13   19
    BYTE   Media;                   // offset = 0x15   21
    USHORT SectorsPerFat;           // offset = 0x16   22
    USHORT SectorsPerTrack;         // offset = 0x18   24
    USHORT Heads;                   // offset = 0x1a   26
    ULONG  HiddenSectors;           // offset = 0x1c   28
    ULONG  LargeSectors;            // offset = 0x20   32
    BYTE   PhysicalDriveNumber;     // offset = 0x24   36
    BYTE   Reserved;                // offset = 0x25   37
    BYTE   Signature;               // offset = 0x26   38
    ULONG  Id;                      // offset = 0x27   39
    UCHAR  VolumeLabel[11];         // offset = 0x2B   43
    UCHAR  SystemId[8];             // offset = 0x36   54
    BYTE   BootStrap[510-62];       // offset = 0x3e   62
    BYTE   AA55Signature[2];        // offset = 0x1fe  510
} FAT_BOOT_SECTOR,_far *FPFAT_BOOT_SECTOR;
#pragma pack()


typedef enum {
    Fat12,
    Fat16,
    Fat32
} FatSize;


FatSize
pFatDetermineFatSize(
    IN FPFAT_BOOT_SECTOR BootSector
    );

ULONG
pFatClusterCount(
    IN FPFAT_BOOT_SECTOR BootSector
    );

ULONG
pFatFirstClusterSector(
    IN FPFAT_BOOT_SECTOR BootSector
    );

ULONG
pFatSectorsPerFat(
    IN FPFAT_BOOT_SECTOR BootSector
    );



BOOL
FatIsFat(
    IN HPARTITION PartitionHandle
    )
{
    FPFAT_BOOT_SECTOR BootSector;

    if(!ReadPartition(PartitionHandle,0,1,IoBuffer)) {
        return(FALSE);
    }

    BootSector = IoBuffer;

    if(BootSector->Sectors) {
        BootSector->LargeSectors = 0;
    }

    //
    // Check various fields for permissible values.
    //
    if((BootSector->Jump[0] != 0x49)        // Fujitsu FMR
    && (BootSector->Jump[0] != 0xe9)
    && (BootSector->Jump[0] != 0xeb)) {
        return(FALSE);
    }

    if(BootSector->BytesPerSector != 512) {
       return(FALSE);
    }

    if((BootSector->SectorsPerCluster !=  1)
    && (BootSector->SectorsPerCluster !=  2)
    && (BootSector->SectorsPerCluster !=  4)
    && (BootSector->SectorsPerCluster !=  8)
    && (BootSector->SectorsPerCluster != 16)
    && (BootSector->SectorsPerCluster != 32)
    && (BootSector->SectorsPerCluster != 64)
    && (BootSector->SectorsPerCluster != 128)) {

        return(FALSE);
    }

    if(!BootSector->ReservedSectors || !BootSector->Fats) {
        return(FALSE);
    }

    if(!BootSector->Sectors && !BootSector->LargeSectors) {
        return(FALSE);
    }

    if((BootSector->Media != 0x00)       // FMR (formatted by OS/2)
    && (BootSector->Media != 0x01)       // FMR (floppy, formatted by DOS)
    && (BootSector->Media != 0xf0)
    && (BootSector->Media != 0xf8)
    && (BootSector->Media != 0xf9)
    && (BootSector->Media != 0xfa)       // FMR
    && (BootSector->Media != 0xfb)
    && (BootSector->Media != 0xfc)
    && (BootSector->Media != 0xfd)
    && (BootSector->Media != 0xfe)
    && (BootSector->Media != 0xff)) {

        return(FALSE);
    }

    if(BootSector->SectorsPerFat && !BootSector->RootEntries) {
        return(FALSE);
    }

    return(TRUE);
}


BOOL
FatInitializeVolumeData(
    IN  HPARTITION  PartitionHandle,
    OUT ULONG      *TotalSectorCount,
    OUT ULONG      *NonClusterSectors,
    OUT ULONG      *ClusterCount,
    OUT BYTE       *SectorsPerCluster
    )
{
    FPFAT_BOOT_SECTOR BootSector;

    if(!ReadPartition(PartitionHandle,0,1,IoBuffer)) {
        fprintf(stderr,"\n");
        fprintf(stderr,textReadFailedAtSector,0L);
        fprintf(stderr,"\n");
        return(FALSE);
    }

    BootSector = IoBuffer;

    *TotalSectorCount = BootSector->Sectors
                      ? (ULONG)BootSector->Sectors
                      : BootSector->LargeSectors;

    *ClusterCount = pFatClusterCount(BootSector);

    *NonClusterSectors = pFatFirstClusterSector(BootSector);

    *SectorsPerCluster = BootSector->SectorsPerCluster;

    return(TRUE);
}


BOOL
FatBuildClusterBitmap(
    IN     HPARTITION       PartitionHandle,
    IN     UINT             FileHandle,
    IN OUT PARTITION_IMAGE *PartitionImage
    )
{
    FPFAT_BOOT_SECTOR BootSector;
    FatSize fatsize;
    ULONG CurrentFatSectorBase;
    ULONG FatSectorsLeft;
    ULONG CurrentCluster;
    ULONG SectorsPerFat;
    BYTE c;
    USHORT ClusterLimit;
    USHORT i;
    USHORT x1;
    ULONG x2;

    printf(textScanningFat,0L);
    printf("\r");

    if(!ReadPartition(PartitionHandle,0,1,IoBuffer)) {
        fprintf(stderr,"\n");
        fprintf(stderr,textReadFailedAtSector,0L);
        fprintf(stderr,"\n");
        return(FALSE);
    }

    BootSector = IoBuffer;

    fatsize = pFatDetermineFatSize(BootSector);

    CurrentFatSectorBase = BootSector->ReservedSectors;
    SectorsPerFat = pFatSectorsPerFat(BootSector);
    FatSectorsLeft = SectorsPerFat;
    CurrentCluster = 0;

    InitClusterBuffer((FPBYTE)IoBuffer + (3*512),FileHandle);

    while(CurrentCluster < PartitionImage->ClusterCount) {
        //
        // Read next block of fat sectors. Deal with 3 at a time so
        // we never get partial 12-bit fat entries.
        //
        c = 3;
        if((ULONG)c > FatSectorsLeft) {
            c = (BYTE)FatSectorsLeft;
        }

        if(!ReadPartition(PartitionHandle,CurrentFatSectorBase,c,IoBuffer)) {
            fprintf(stderr,"\n");
            fprintf(stderr,textReadFailedAtSector,CurrentFatSectorBase);
            fprintf(stderr,"\n");
            return(FALSE);
        }

        //
        // Figure out how many clusters are described by the 3 sectors
        // of the FAT we just read in
        //
        switch(fatsize) {
        case Fat12:
            ClusterLimit = 1024;
            break;
        case Fat16:
            ClusterLimit = 768;
            break;
        case Fat32:
            ClusterLimit = 384;
            break;
        }

        if((CurrentCluster + ClusterLimit) > PartitionImage->ClusterCount) {
            ClusterLimit = (USHORT)(PartitionImage->ClusterCount - CurrentCluster);
        }

        //
        // Fat values:
        //
        //  0                     - free cluster
        //  1                     - (unused)
        //  [ffff]ff0 - [ffff]ff6 - (reserved)
        //  [ffff]ff7             - bad cluster
        //  [ffff]ff8 - [ffff]fff - last cluster of file
        //
        //  All other values      - used cluster
        //

        switch(fatsize) {

        case Fat12:

            for(i=0; i<ClusterLimit; i++,CurrentCluster++) {

                x1 = *(FPUSHORT)((FPBYTE)IoBuffer + (3 * i / 2));
                if(i & 1) {
                    x1 >>= 4;
                } else {
                    x1 &= 0xfffU;
                }

                if((((x1 > 1) && (x1 <= 0xfefU)) || (x1 >= 0xff8U)) && (CurrentCluster >= 2)) {
                    PartitionImage->LastUsedCluster = CurrentCluster-2;
                    PartitionImage->UsedClusterCount++;
                    if(!MarkClusterUsed(CurrentCluster-2)) {
                        return(FALSE);
                    }
                }
            }
            break;

        case Fat16:

            for(i=0; i<ClusterLimit; i++,CurrentCluster++) {

                x1 = ((FPUSHORT)IoBuffer)[i];

                if((((x1 > 1) && (x1 <= 0xffefU)) || (x1 >= 0xfff8U)) && (CurrentCluster >= 2)) {
                    PartitionImage->LastUsedCluster = CurrentCluster-2;
                    PartitionImage->UsedClusterCount++;
                    if(!MarkClusterUsed(CurrentCluster-2)) {
                        return(FALSE);
                    }
                }
            }
            break;

        case Fat32:

            for(i=0; i<ClusterLimit; i++,CurrentCluster++) {

                x2 = ((FPULONG)IoBuffer)[i] & 0xfffffffU;

                if((((x2 > 1) && (x2 <= 0xfffffefUL)) || (x2 >= 0xffffff8UL)) && (CurrentCluster >= 2)) {
                    PartitionImage->LastUsedCluster = CurrentCluster-2;
                    PartitionImage->UsedClusterCount++;
                    if(!MarkClusterUsed(CurrentCluster-2)) {
                        return(FALSE);
                    }
                }
            }
            break;
        }

        CurrentFatSectorBase += c;
        FatSectorsLeft -= c;

        printf(textScanningFat,100 * (SectorsPerFat - FatSectorsLeft) / SectorsPerFat);
        printf("\r");
    }

    printf("\n");

    if(!FlushClusterBuffer()) {
        return(FALSE);
    }

    return(TRUE);
}


FatSize
pFatDetermineFatSize(
    IN FPFAT_BOOT_SECTOR BootSector
    )
{
    //
    // For fat32 the # of root dir entries in the bpb is 0.
    //
    if(!BootSector->SectorsPerFat) {
        return(Fat32);
    }

    //
    // See whether we overflow a 12-bit fat and return result.
    //
    return((pFatClusterCount(BootSector) < 4087L) ? Fat12 : Fat16);
}


ULONG
pFatClusterCount(
    IN FPFAT_BOOT_SECTOR BootSector
    )
{
    ULONG s;

    //
    // Calculate the number of sectors that are in the data area,
    // which is the size of the volume minus the number of sectors
    // that are not in the data area.
    //
    s = BootSector->Sectors ? (ULONG)BootSector->Sectors : BootSector->LargeSectors;
    s -= pFatFirstClusterSector(BootSector);

    return(s / BootSector->SectorsPerCluster);
}


ULONG
pFatFirstClusterSector(
    IN FPFAT_BOOT_SECTOR BootSector
    )
{
    ULONG s;

    //
    // Calculate the number of sectors that are not
    // part of the data area. This includes reserved sectors,
    // sectors used for the fats, and in the non-fat32 case,
    // sectors used for the root directory.
    //
    // Note that for fat32 the # of root dir entries in the bpb is 0.
    //
    s = BootSector->ReservedSectors;
    s += BootSector->Fats * pFatSectorsPerFat(BootSector);
    s += BootSector->RootEntries / 16;

    return(s);
}


ULONG
pFatSectorsPerFat(
    IN FPFAT_BOOT_SECTOR BootSector
    )
{
    ULONG SectorsPerFat;

    SectorsPerFat = BootSector->SectorsPerFat
                  ? (ULONG)BootSector->SectorsPerFat
                  : *(FPULONG)((FPBYTE)BootSector + 0x24);      // large sectors per fat

    return(SectorsPerFat);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\mpk\imagpart\ntfs.h ===
#define $ATTRIBUTE_LIST     0x20
#define $DATA               0x80
#define $END                0xffffffff

#define SEQUENCE_NUMBER_STRIDE  0x200

#define BIT_MAP_FILE_NUMBER 6


typedef struct _MFT_SEGMENT_REFERENCE {
    ULONG LowPart;
    ULONG HighPart;
    UINT  SeqNo;
} MFT_SEGMENT_REFERENCE, _far *FPMFT_SEGMENT_REFERENCE;


typedef struct _MULTI_SECTOR_HEADER {
    ULONG Signature;
    UINT  UpdateArrayOfs;
    UINT  UpdateArraySize;
} MULTI_SECTOR_HEADER, _far *FPMULTI_SECTOR_HEADER;


typedef struct _FILE_RECORD_SEGMENT {
    MULTI_SECTOR_HEADER   Header;
    ULONG                 Lsn;
    ULONG                 Lsnh;
    UINT                  SequenceNumber;
    UINT                  ReferenceCount;
    UINT                  FirstAttribute;
    UINT                  Flags;
    ULONG                 FirstFreeByte;
    ULONG                 BytesAvailable;
    MFT_SEGMENT_REFERENCE BaseFRS;
    UINT                  NextInstance;
} FILE_RECORD_SEGMENT, _far *FPFILE_RECORD_SEGMENT;

#define FILE_RECORD_SEGMENT_IN_USE 0x0001


typedef struct _ATTRIBUTE_RECORD {
    ULONG TypeCode;
    ULONG RecordLength;
    BYTE  FormCode;
    BYTE  NameLength;
    UINT  NameOffset;
    UINT  Flags;
    UINT  Instance;
    BYTE  FormUnion;
} ATTRIBUTE_RECORD, _far *FPATTRIBUTE_RECORD;

#define RESIDENT_FORM       0
#define NONRESIDENT_FORM    1


typedef struct _RESIDENT_ATTRIBUTE_FORM {
    ULONG ValueLength;
    UINT  ValueOffset;
    BYTE  ResidentFlags;
    BYTE  Reserved;
} RESIDENT_ATTRIBUTE_FORM, _far *FPRESIDENT_ATTRIBUTE_FORM;


typedef struct _NONRESIDENT_ATTRIBUTE_FORM {
    ULONG LowestVcn;
    ULONG LowestVcnh;
    ULONG HighestVcn;
    ULONG HighestVcnh;
    UINT  MappingPairOffset;
    UINT  Reserved[3];
    ULONG AllocatedLength;
    ULONG AllocatedLengthh;
    ULONG FileSize;
    ULONG FileSizeh;
    ULONG ValidDataLength;
    ULONG ValidDataLengthh;
} NONRESIDENT_ATTRIBUTE_FORM, _far *FPNONRESIDENT_ATTRIBUTE_FORM;



typedef struct _ATTRIBUTE_LIST_ENTRY {
    ULONG                 TypeCode;
    UINT                  Length;
    BYTE                  NameLength;
    BYTE                  NameOffset;
    ULONG                 LowestVcn;
    ULONG                 LowestVcnh;
    MFT_SEGMENT_REFERENCE SegmentReference;
    UINT                  Instance;
    UINT                  Name;
} ATTRIBUTE_LIST_ENTRY, _far *FPATTRIBUTE_LIST_ENTRY;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\mpk\imagpart\imagpart.h ===
#include <mytypes.h>
#include <partio.h>
#include <msgfile.h>
#include <misclib.h>
#include <partimag.h>

#include <stdio.h>
#include <string.h>
#include <dos.h>


extern FPVOID IoBuffer;

extern char *textPartOpenError;
extern char *textFileWriteError;
extern char *textFileReadFailed;
extern char *textReadFailedAtSector;
extern char *textOOM;
extern char *textScanningFat;
extern char *textNtfsUnsupportedConfig;
extern char *textNtfsCorrupt;
extern char *textInitNtfsDataStruct;
extern char *textNtfsBuildingBitmap;
extern char *textProcessingNtfsBitmap;
extern char *textUnsupportedFs;


typedef enum {
    FilesystemFat,
    FilesystemNtfs,
    FilesystemOther
} FilesystemType;


BOOL
BuildClusterBitmap(
    IN FilesystemType   FsType,
    IN HPARTITION       PartitionHandle,
    IN UINT             FileHandle,
    IN PARTITION_IMAGE *PartitionImage
    );

VOID
InitClusterBuffer(
    IN FPBYTE _512ByteBuffer,
    IN UINT   FileHandle
    );

BOOL
MarkClusterUsed(
    IN ULONG Cluster
    );

BOOL
FlushClusterBuffer(
    VOID
    );

BOOL
InitClusterMap(
    OUT FPBYTE _512ByteBuffer,
    IN  UINT   FileHandle,
    IN  ULONG  LastUsedCluster
    );

BOOL
GetNextClusterRun(
    OUT ULONG *StartCluster,
    OUT ULONG *ClusterCount
    );



BOOL
FatIsFat(
    IN HPARTITION PartitionHandle
    );

BOOL
FatInitializeVolumeData(
    IN  HPARTITION  PartitionHandle,
    OUT ULONG      *TotalSectorCount,
    OUT ULONG      *NonClusterSectors,
    OUT ULONG      *ClusterCount,
    OUT BYTE       *SectorsPerCluster
    );

BOOL
FatBuildClusterBitmap(
    IN     HPARTITION       PartitionHandle,
    IN     UINT             FileHandle,
    IN OUT PARTITION_IMAGE *PartitionImage
    );


BOOL
NtfsIsNtfs(
    IN HPARTITION PartitionHandle
    );

BOOL
NtfsInitializeVolumeData(
    IN  HPARTITION  PartitionHandle,
    OUT ULONG      *TotalSectorCount,
    OUT ULONG      *NonClusterSectors,
    OUT ULONG      *ClusterCount,
    OUT BYTE       *SectorsPerCluster
    );

BOOL
NtfsBuildClusterBitmap(
    IN     HPARTITION       PartitionHandle,
    IN     UINT             FileHandle,
    IN OUT PARTITION_IMAGE *PartitionImage
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\mpk\enduser\restore.c ===
#include "enduser.h"


//
// Partition image structure for the partition being restored.
//
PARTITION_IMAGE PartitionImage;

//
// Number of sectors to zap to wipe out an image
// 0.98 MB of 512-byte sectors
//
#define ZAP_MAX 2000

//
// Maximum size of FAT32 fats

#define MAX_FAT32_TABLE_SIZE (16*1024*1024-65536)
#define MAX_FAT32_ENTRIES ((16*1024*1024-65536)/4)


VOID
RelocateClusterBitmap(
    IN HDISK DiskHandle,
    IN ULONG ImageStart
    );

VOID
RelocateBootPartition(
    IN HDISK  DiskHandle,
    IN USHORT Cylinders,
    IN ULONG  ExtendedCount
    );

VOID
FixUpBpb(
    IN HDISK  DiskHandle,
    IN BYTE   SectorsPerTrack,
    IN USHORT Heads,
    IN ULONG  StartSector
    );

VOID
RemoveNonSelectedOsData(
    IN HDISK DiskHandle
    );

VOID
CreatePartitionTableEntry(
    IN  HDISK   DiskHandle,
    IN  USHORT  Cylinders,
    IN  ULONG   DiskSectorCount,
    IN  ULONG   StartSector,
    OUT ULONG  *LastSector,
    IN  BOOL    Relocating
    );

VOID
TellUserToWait(
    VOID
    );

VOID
StartGauge(
    VOID
    );

BOOL
TestImage(
    IN  HDISK  DiskHandle,
    IN  ULONG  StartSector
    );

BOOL
MungeParametersForFat32Extend(
    IN  HDISK   DiskHandle,
    IN  USHORT  Cylinders,
    IN  BYTE    SectorsPerTrack,
    IN  ULONG   SourceStart,
    IN  ULONG   *TargetStart,
    IN  FPMASTER_DISK pMasterDisk,
    IN  FPPARTITION_IMAGE pPartitionImage,
    IN  VOID    *TemporaryBuffer
    );

VOID
AdjustTargetStart(
    IN  HDISK   DiskHandle,
    IN  BYTE    SectorsPerTrack,
    IN  ULONG   *TargetStart,
    IN  VOID    *TemporaryBuffer
    );

ULONG
ComputeClusters(
    IN  ULONG        ClusterSize,
    IN  ULONG        Sectors,
    IN  ULONG        SectorSize,
    IN  ULONG        ReservedSectors,
    IN  ULONG        Fats
    );

BOOL
IsUnknownPartition(
    IN BYTE SysId 
    );

VOID
RestoreUsersDisk(
    IN HDISK DiskHandle
    )

/*++

Routine Description:

    This is the top-level routine concerned with restoring the user's
    disk so it seems as if only a single os was ever preinstalled on it.

Arguments:

    DiskHandle - supplies open disk handle to master/target hard disk.

Return Value:

    None. Does not return if error.

--*/

{
    ULONG SourceStart;
    ULONG TargetStart;
    BYTE Int13Unit;
    BYTE SectorsPerTrack;
    USHORT Heads;
    USHORT Cylinders;
    ULONG ExtendedCount;
    UINT DiskId;
    ULONG LastSector;
    FPFAT32_BOOT_SECTOR pFat32BootSect;
    FPPARTITION_IMAGE pFat32ImgHdr;

    TellUserToWait();

    GetDiskInfoByHandle(
        DiskHandle,
        &Int13Unit,
        &SectorsPerTrack,
        &Heads,
        &Cylinders,
        &ExtendedCount,
        &DiskId
        );

    SourceStart = MasterDiskInfo.ImageStartSector[MasterDiskInfo.SelectionOrdinal];
    TargetStart = SectorsPerTrack;

    _Log("Starting restore: SourceStart = 0x%lx, TargetStart = 0x%lx\n",SourceStart,TargetStart);

    //
    // Read the partition image information structure off the disk
    // to determine how large the image is. Cache it away somewhere safe.
    //
    if(MasterDiskInfo.State >= MDS_CACHED_IMAGE_HEADER) {
        _Log("Have cached partition image header, fetching from disk\n");
        if(!ReadDisk(DiskHandle,2,1,(FPBYTE)IoBuffer+512)) {
            FatalError(textReadFailedAtSector,1,2L);
        }

    } else {

        //
        // Ok, figure out where we can start laying down the partition.
        //
        _Log("TargetStart is %d, adjusting...\n",TargetStart);
        AdjustTargetStart( DiskHandle, 
            SectorsPerTrack,
            &TargetStart,
            (BYTE*)IoBuffer+4096);
        _Log("New TargetStart is %d.\n",TargetStart);

        //
        // pull the first two sectors of the image in
        //
        if(!ReadDisk(DiskHandle,SourceStart,2,(FPBYTE)IoBuffer+512)) {
            FatalError(textReadFailedAtSector,2,SourceStart);
        }
        
        //
        // the first will be the image header, the second could be a fat32 boot sector
        //

        pFat32BootSect = (FPFAT32_BOOT_SECTOR)((BYTE*)IoBuffer+1024);
        //
        // We need to adjust the target start to compensate for a preserved
        // eisa/hiber partition
        //

        if( IsFat32(pFat32BootSect) ) {
            // 
            // if it is a fat32 boot sector, then we store away some useful things we will
            // use when we call MungeParametersForFat32Extend.
            //

            pFat32ImgHdr = (FPPARTITION_IMAGE)((BYTE*)IoBuffer+512);
            pFat32ImgHdr->Fat32ReservedSectors = pFat32BootSect->PackedBpb.ReservedSectors;

#if 0
            //
            // this is not necessarily 0x20
            //
            if(pFat32ImgHdr->Fat32ReservedSectors != 0x20) {
                FatalError(textReadFailedAtSector,2,SourceStart);
            }
#endif
            
            //
            // since this is a Fat32 image, we determine how big we can expand it,
            // where we can start the expansion, and how big the new FATs need to be.
            //
            // We use IoBuffer+4096 as a convenient temporary work bufer.
            //
            // This will fill in the Fat32 fields of the partition image (pFat32ImageHdr)
            // header which we will store away safely in the next step.
            //
            MungeParametersForFat32Extend(DiskHandle,
                                          Cylinders,
                                          SectorsPerTrack,
                                          SourceStart,
                                          &TargetStart,
                                          &MasterDiskInfo,
                                          (FPPARTITION_IMAGE)pFat32ImgHdr,
                                          (BYTE*)IoBuffer+4096);

        }

        //
        // Save it.
        //
        if(!CmdLineArgs.Test) {
            if(!WriteDisk(DiskHandle,2,1,(FPBYTE)IoBuffer+512)) {
                FatalError(textWriteFailedAtSector,1,2L);
            }
        }
        _Log("Successfully cached partition image header\n");

        //
        // Clobbers first sector of IoBuffer
        //
        if(!CmdLineArgs.Test) {
            UpdateMasterDiskState(DiskHandle,MDS_CACHED_IMAGE_HEADER);
            _Log("Master disk state updated to indicate cached partition image header\n");
        }
    }
    
    SourceStart++;
    memmove(&PartitionImage,(FPBYTE)IoBuffer+512,sizeof(PARTITION_IMAGE));

    _Log("Image header for image to be restored --\n");
    _Log("   Signature:         0x%lx\n",PartitionImage.Signature);
    _Log("   Size:              %u\n",PartitionImage.Size);
    _Log("   NonClusterSectors: 0x%lx\n",PartitionImage.NonClusterSectors);
    _Log("   ClusterCount:      0x%lx\n",PartitionImage.ClusterCount);
    _Log("   TotalSectorCount:  0x%lx\n",PartitionImage.TotalSectorCount);
    _Log("   LastUsedCluster:   0x%lx\n",PartitionImage.LastUsedCluster);
    _Log("   UsedClusterCount:  0x%lx\n",PartitionImage.UsedClusterCount);
    _Log("   SectorsPerCluster: %u\n",PartitionImage.SectorsPerCluster);
    _Log("   SystemId:          %u\n",PartitionImage.SystemId);
    _Log("\n");

    if(CmdLineArgs.Test) {
        // validate the disk image first.
        TestImage(DiskHandle,SourceStart-1);
        TellUserToWait();
    }

    StartGauge();

    //
    // Fix up things so that no one can get back the data for the OSes
    // they didn't install.
    //
    RemoveNonSelectedOsData(DiskHandle);

    XmsInit();

    //
    // Relocate the cluster bitmap if necessary
    //
    RelocateClusterBitmap(DiskHandle,SourceStart);

    //
    // Relocate the boot partition if necessary.
    //
    RelocateBootPartition(DiskHandle,Cylinders,ExtendedCount);

    //
    // Transfer the partition data from the image to the start of
    // the hard drive.
    //
    ExpandImage(DiskHandle,SectorsPerTrack,SourceStart,TargetStart);

    XmsTerminate();

    TellUserToWait();

    //
    // Next, fix up the BPB's geometry-related fields.
    //
    FixUpBpb(DiskHandle,SectorsPerTrack,Heads,TargetStart);

    //
    // The next step is to create the partition table entry that describes
    // the partition we are restoring and remove the one for the bootable
    // partition.
    //
    CreatePartitionTableEntry(
        DiskHandle,
        Cylinders,
        ExtendedCount,
        TargetStart,
        &LastSector,
        FALSE
        );

    //
    // Now we're done. As a single final step, we recreate the
    // mirror boot sector for NTFS. Note that there is a window for failure
    // in this operation, but there's no good way around this. If we write
    // this sector before now we risk wiping out the bootstrap program.
    //
    if(PartitionImage.SystemId == 7) {
        if(ReadDisk(DiskHandle,TargetStart,1,IoBuffer)) {
            if(!CmdLineArgs.Test) {
                if(!WriteDisk(DiskHandle,LastSector,1,IoBuffer)) {
                    FatalError(textWriteFailedAtSector,1,LastSector);
                }
            }
        } else {
            FatalError(textReadFailedAtSector,1,TargetStart);
        }
    }
}


VOID
RemoveNonSelectedOsData(
    IN HDISK DiskHandle
    )
{
    UINT i;
    ULONG SectorCount;
    ULONG OriginalCount;
    ULONG CurrentSector;
    PPARTITION_IMAGE p;

    //
    // See if we've already done this step.
    //
    if(!CmdLineArgs.Test && (MasterDiskInfo.State >= MDS_REMOVED_OTHERS)) {
        _Log("Already removed non-selected OS data\n");
        GaugeDelta(ZAP_MAX * (MasterDiskInfo.ImageCount-1));
        return;
    }

    //
    // Scribble over the first 1 MB or so of each image. This takes out
    // some significant file system data structures and some data.
    // We also take out the partition image header itself, but we do that
    // last so if we restart we'll be able to complete operating on the
    // image we were working on.
    //
    p = IoBuffer;
    for(i=0; i<MasterDiskInfo.ImageCount; i++) {

        if(i == MasterDiskInfo.SelectionOrdinal) {
            continue;
        }

        CurrentSector = MasterDiskInfo.ImageStartSector[i];
        if(!ReadDisk(DiskHandle,CurrentSector++,1,IoBuffer)) {
            FatalError(textReadFailedAtSector,1,CurrentSector-1);
        }

        //
        // If the sector is not a valid partition image header,
        // then we assume we've already taken it out in a previous pass
        // and we don't worry about it.
        //
        if(p->Signature == PARTITION_IMAGE_SIGNATURE) {

            _Log("Removing non-selected OS data for image %u\n",i);

            SectorCount = p->NonClusterSectors + (p->UsedClusterCount * p->SectorsPerCluster);
            if(SectorCount > ZAP_MAX) {
                SectorCount = ZAP_MAX;
            }
            OriginalCount = SectorCount;

            memset(IoBuffer,0,63*512);
            while(SectorCount >= 63) {
                if(!CmdLineArgs.Test) {
                    if(!WriteDisk(DiskHandle,CurrentSector,63,IoBuffer)) {
                        FatalError(textWriteFailedAtSector,63,CurrentSector);
                    }
                }
                CurrentSector += 63;
                SectorCount -= 63;
                GaugeDelta(63);
            }
            if(SectorCount) {
                if(!CmdLineArgs.Test) {
                    if(!WriteDisk(DiskHandle,CurrentSector,(BYTE)SectorCount,IoBuffer)) {
                        FatalError(textWriteFailedAtSector,(unsigned)SectorCount,CurrentSector);
                    }
                }
                GaugeDelta(SectorCount);
            }

            //
            // Now take out the image header.
            //
            if(!CmdLineArgs.Test) {
                if(!WriteDisk(DiskHandle,MasterDiskInfo.ImageStartSector[i],1,IoBuffer)) {
                    FatalError(textWriteFailedAtSector,1,MasterDiskInfo.ImageStartSector[i]);
                }
            }

            //
            // We allowed for ZAP_MAX sectors in the gauge but there might
            // have been less than that in the image (strange case, but possible).
            //
            if(OriginalCount < (ULONG)ZAP_MAX) {
                GaugeDelta((ULONG)ZAP_MAX - OriginalCount);
            }
        } else {
            _Log("Non-selected OS data for image %u previously removed\n",i);
            GaugeDelta(ZAP_MAX);
        }
    }

    //
    // Update state to indicate that we've done this step.
    //
    if(!CmdLineArgs.Test) {
        _Log("Updating master disk state to indicate non-selected os data removed...\n");
        UpdateMasterDiskState(DiskHandle,MDS_REMOVED_OTHERS);
        _Log("Master disk state updated to indicate non-selected os data removed\n");
    }
}


VOID
RelocateClusterBitmap(
    IN HDISK DiskHandle,
    IN ULONG ImageStart
    )
{
    ULONG BitmapSize;
    ULONG Read;
    ULONG Target;
    BOOL Xms;

    //
    // Figure out how large the cluster bitmap is in sectors.
    //
    BitmapSize = (PartitionImage.LastUsedCluster/CLUSTER_BITS_PER_SECTOR) + 1;
    _Log("Cluster bitmap is 0x%lx sectors\n",BitmapSize);

    //
    // If we've already done this step, nothing to do.
    //
    if(!CmdLineArgs.Test && (MasterDiskInfo.State >= MDS_RELOCATED_BITMAP)) {
        _Log("Already relocated cluster bitmap\n");
        GaugeDelta(2*BitmapSize);
        return;
    }

    ImageStart += PartitionImage.NonClusterSectors
                    + (PartitionImage.SectorsPerCluster * PartitionImage.UsedClusterCount);

    if(PartitionImage.Flags & PARTIMAGE_RELOCATE_BITMAP) {

        //
        // Figure out where the bitmap will be relocated to.
        //
        Target = PartitionImage.BitmapRelocationStart;

        MasterDiskInfo.ClusterBitmapStart = CmdLineArgs.Test ? ImageStart : Target;

        _Log("Cluster bitmap to be relocated from sector 0x%lx to sector 0x%lx\n",ImageStart,Target);

        //
        // Note that there's no overlap problem so we just flat out
        // transfer the bitmap from beginning to end.
        //
        while(BitmapSize) {

            XmsIoDiskRead(DiskHandle,ImageStart,BitmapSize,&Read,&Xms);

            XmsIoDiskWrite(DiskHandle,Target,0,Read,Xms);

            BitmapSize -= Read;
            ImageStart += Read;
            Target += Read;
        }
    } else {
        _Log("No need to relocate cluster bitmap\n");
        MasterDiskInfo.ClusterBitmapStart = ImageStart;
    }

    //
    // Note that we update state to indicate that this is done even if we
    // don't actually relocate the cluster bitmap, for completeness and
    // tracking of what's going on.
    //
    if(!CmdLineArgs.Test) {
        _Log("Updating master disk state to indicate cluster bitmap relocated...\n");
        UpdateMasterDiskState(DiskHandle,MDS_RELOCATED_BITMAP);
        _Log("Master disk state updated to indicate cluster bitmap relocated\n");
    }
}


VOID
RelocateBootPartition(
    IN HDISK  DiskHandle,
    IN USHORT Cylinders,
    IN ULONG  ExtendedCount
    )
{
    ULONG Read;
    ULONG Target;
    ULONG ImageStart;
    ULONG Count;
    BOOL Xms;

    if(PartitionImage.Flags & PARTIMAGE_RELOCATE_BOOT) {
        //
        // If we've already done this step, nothing to do.
        //
        if(!CmdLineArgs.Test && (MasterDiskInfo.State >= MDS_RELOCATED_BOOT)) {

            _Log("Already relocated boot partition\n");
            GaugeDelta(2*MasterDiskInfo.StartupPartitionSectorCount);

        } else {

            //
            // Figure out where the boot partition will be relocated to.
            //
            Target = PartitionImage.BootRelocationStart;
            ImageStart = MasterDiskInfo.StartupPartitionStartSector;
            Count = MasterDiskInfo.StartupPartitionSectorCount;

            if(!CmdLineArgs.Test) {
                MasterDiskInfo.StartupPartitionStartSector = Target;
            }

            _Log(
                "Cluster bitmap to be relocated from sector 0x%lx to sector 0x%lx\n",
                ImageStart,
                Target
                );

            //
            // Note that there's no overlap problem so we just flat out
            // transfer the boot partition from end to end.
            //
            while(Count) {

                XmsIoDiskRead(DiskHandle,ImageStart,Count,&Read,&Xms);

                XmsIoDiskWrite(DiskHandle,Target,0,Read,Xms);

                Count -= Read;
                ImageStart += Read;
                Target += Read;
            }

            if(!CmdLineArgs.Test) {
                _Log("Updating master disk state to indicate boot part relocated...\n");
                UpdateMasterDiskState(DiskHandle,MDS_RELOCATED_BOOT);
                _Log("Master disk state updated to indicate boot part relocated\n");
            }
        }

        //
        // Ok, it's been transferred. Fix up the mbr to point at it.
        // Note that CreatePartitionTableEntry updates master disk state but is protected by
        // checking aginst CmdLineArgs.Test.
        //
        if(CmdLineArgs.Test || (MasterDiskInfo.State < MDS_RELOCATED_BOOT_MBR)) {

            CreatePartitionTableEntry(
                DiskHandle,
                Cylinders,
                ExtendedCount,
                MasterDiskInfo.StartupPartitionStartSector,
                &Target,
                TRUE
                );
        }

    } else {
        _Log("No need to relocate boot partition\n");
    }
}


VOID
FixUpBpb(
    IN HDISK  DiskHandle,
    IN BYTE   SectorsPerTrack,
    IN USHORT Heads,
    IN ULONG  StartSector
    )
{
    USHORT      BackupBootSectorOfs;

    //
    // See if we've already done this step.
    //
    if(!CmdLineArgs.Test && (MasterDiskInfo.State >= MDS_UPDATED_BPB)) {
        _Log("Already fixed up BPB\n");
        return;
    }

    if(!ReadDisk(DiskHandle,StartSector,1,IoBuffer)) {
        FatalError(textReadFailedAtSector,1,StartSector);
    }

    if(PartitionImage.Fat32ReservedSectors) {
        //
        // this is a FAT32 partition, we munge some extra stuff in the BPB
        // when we do the partition expansion
        //
        FPFAT32_BOOT_SECTOR pBootSect = IoBuffer;
        ULONG               FatSectorCount;

        pBootSect->PackedBpb.LargeSectors = PartitionImage.Fat32AdjustedSectorCount;

        
        FatSectorCount = PartitionImage.Fat32AdjustedFatTableEntryCount / (512/4);
        FatSectorCount = (PartitionImage.Fat32AdjustedFatTableEntryCount % (512/4)) ? 
                                FatSectorCount++ : FatSectorCount;

        pBootSect->PackedBpb.LargeSectorsPerFat = FatSectorCount;
        BackupBootSectorOfs = pBootSect->PackedBpb.BackupBootSector;

    }

    //
    // Slam the relevent fields.
    //
    *(FPUSHORT)&((FPBYTE)IoBuffer)[24] = SectorsPerTrack;
    *(FPUSHORT)&((FPBYTE)IoBuffer)[26] = Heads;
    *(FPULONG)&((FPBYTE)IoBuffer)[28] = StartSector;
    //
    // Want to do this but for fat32 it's in a different place
    // so it's dangerous
    //
    //*(FPBYTE)&((FPBYTE)IoBuffer)[36] = Int13Unit;

    if(!CmdLineArgs.Test) {
        if(!WriteDisk(DiskHandle,StartSector,1,IoBuffer)) {
            FatalError(textWriteFailedAtSector,1,StartSector);
        }
        if( PartitionImage.Fat32ReservedSectors ) {
            //
            // Fat32 has a backup boot sector 
            //
            if(!WriteDisk(DiskHandle,StartSector+BackupBootSectorOfs,1,IoBuffer)) {
                FatalError(textWriteFailedAtSector,1,StartSector+BackupBootSectorOfs);
            }
            _Log("Successfully fixed up FAT32 mirror BPB\n");
        }
    }       

    _Log("Successfully fixed up BPB\n");

    if(PartitionImage.Fat32ReservedSectors) {
        //
        // FAT32 case.
        //

        ULONG           NewFreeClusterCount;
        ULONG           OldFreeClusterCount;
        USHORT          FsInfoSectorOfs;
        FPFSINFO_SECTOR pFsInfoSector;

        //
        // need to fixup the FsInfoSector to reflect the new free space count.
        //

        OldFreeClusterCount = PartitionImage.ClusterCount - PartitionImage.UsedClusterCount;
        NewFreeClusterCount = PartitionImage.Fat32AdjustedFatTableEntryCount - PartitionImage.UsedClusterCount;

        FsInfoSectorOfs = ((FPFAT32_BOOT_SECTOR)IoBuffer)->PackedBpb.FsInfoSector;

        //
        // ok, get FSINFO in.
        //

        if(!ReadDisk(DiskHandle,StartSector+FsInfoSectorOfs,1,IoBuffer)) {
            FatalError(textReadFailedAtSector,1,StartSector+FsInfoSectorOfs);
        }

        //
        // now verify it is, in fact, an FSINFO sector.
        //
        pFsInfoSector = (FPFSINFO_SECTOR)IoBuffer;

        if(pFsInfoSector->FsInfoSignature != FSINFO_SIGNATURE ||
           pFsInfoSector->SectorBeginSignature != FSINFO_SECTOR_BEGIN_SIGNATURE ||
           pFsInfoSector->SectorEndSignature != FSINFO_SECTOR_END_SIGNATURE 
            ) {
            FatalError(textReadFailedAtSector,1,StartSector+FsInfoSectorOfs);        
        }

        //
        // validate our old free cluster count
        //
        
        if( OldFreeClusterCount != pFsInfoSector->FreeClusterCount ) {
            FatalError(textReadFailedAtSector,1,StartSector+FsInfoSectorOfs);
        }

        //
        // now drop in our new freespace count.
        //

        pFsInfoSector->FreeClusterCount = NewFreeClusterCount;

        //
        // Write FSINFO sect back out. Twice. (the two copies are identical.)
        //
        if(!CmdLineArgs.Test) {
            if(!WriteDisk(DiskHandle,StartSector+FsInfoSectorOfs,1,IoBuffer)) {
                FatalError(textWriteFailedAtSector,1,StartSector+FsInfoSectorOfs);
            }

            if(!WriteDisk(DiskHandle,StartSector+BackupBootSectorOfs+FsInfoSectorOfs,1,IoBuffer)) {
                FatalError(textWriteFailedAtSector,1,StartSector+BackupBootSectorOfs+FsInfoSectorOfs);
            }
        }

        _Log("Successfully fixed up FsInfoSector(s)\n");
    }    

    if(!CmdLineArgs.Test) {
        _Log("Updating master disk state to indicate BPB fixed up...\n");
        UpdateMasterDiskState(DiskHandle,MDS_UPDATED_BPB);
        _Log("Master disk state updated to indicate BPB fixed up\n");
    }
}


VOID
CreatePartitionTableEntry(
    IN  HDISK   DiskHandle,
    IN  USHORT  Cylinders,
    IN  ULONG   DiskSectorCount,
    IN  ULONG   StartSector,
    OUT ULONG  *LastSector,
    IN  BOOL    Relocating
    )
{
    unsigned i;
    USHORT SectorsPerCylinder;
    USHORT r;
    ULONG EndSector;
    BOOL Overflow;
    ULONG C;
    BYTE H;
    BYTE S;

    struct {
        BYTE Active;
        BYTE StartH;
        BYTE StartS;
        BYTE StartC;
        BYTE SysId;
        BYTE EndH;
        BYTE EndS;
        BYTE EndC;
        ULONG Start;
        ULONG Count;
    } *PartTabEnt,*TheEntry;


    if(!DiskSectorCount) {
        DiskSectorCount = (ULONG)MasterDiskInfo.OriginalSectorsPerTrack
                        * (ULONG)MasterDiskInfo.OriginalHeads
                        * (ULONG)Cylinders;
    }
    SectorsPerCylinder = MasterDiskInfo.OriginalHeads * MasterDiskInfo.OriginalSectorsPerTrack;

    //
    // Read the MBR
    //
    if(!ReadDisk(DiskHandle,0,1,IoBuffer)) {
        FatalError(textReadFailedAtSector,1,0L);
    }

    //
    // Traverse the MBR, trying to find the MPK boot partition.
    // Also make sure all entries are inactive.
    //
    TheEntry = NULL;
    for(i=0; i<4; i++) {
        PartTabEnt = (FPVOID)((FPBYTE)IoBuffer + 0x1be + (i*16));

        if(PartTabEnt->SysId
        && (PartTabEnt->Start == MasterDiskInfo.StartupPartitionStartSector)
        && !TheEntry) {
            TheEntry = PartTabEnt;
        }

        PartTabEnt->Active = 0;
    }

    if(!TheEntry) {
        //
        // Couldn't find it, something is seriously corrupt.
        //
        FatalError(textCantFindMPKBoot);
    }

    if(Relocating) {
        EndSector = StartSector + MasterDiskInfo.StartupPartitionSectorCount;
    } else {
        if( PartitionImage.Fat32ReservedSectors ) {
            // 
            // FAT32 resize case
            //
            EndSector = PartitionImage.Fat32AdjustedSectorCount + StartSector;
        } else {
            EndSector = PartitionImage.TotalSectorCount + StartSector;
        }
        
        //
        // Refigure the end sector so it's aligned to a cylinder boundary.
        //
        if(r = (USHORT)(EndSector % SectorsPerCylinder)) {
            EndSector += SectorsPerCylinder - r;
        }
        //
        // In some cases NT reports the disk is 1 or 2 cylinders
        // larger than int13 reports. Thus we may have a volume that
        // spans beyond the end of the disk as reported by int13.
        // If we cap the end of the partition to the size reported
        // by int13 in this case, we will end up with a partition
        // whose size in the partition table is smaller than the
        // size recorded in the BPB. NTFS is particular will then
        // refuse to mount the drive and you get inaccassible boot device.
        // BIOSes will typically allow I/O to these "extra" cylinders
        // even though they're not reported via int13 function 8, so this
        // shouldn't be a problem.
        //
        //if(EndSector > DiskSectorCount) {
        //    EndSector = DiskSectorCount;
        //}
    }

    TheEntry->Active = 0x80;
    TheEntry->Start = StartSector;
    TheEntry->Count = EndSector - StartSector;

    //
    // Calculate start CHS values.
    //
    C = StartSector / SectorsPerCylinder;
    if(C >= (ULONG)Cylinders) {
        C = Cylinders - 1;
        H = (BYTE)(MasterDiskInfo.OriginalHeads - 1);
        S = (BYTE)(MasterDiskInfo.OriginalSectorsPerTrack - 1);
    } else {
        H = (BYTE)((StartSector % SectorsPerCylinder) / MasterDiskInfo.OriginalSectorsPerTrack);
        S = (BYTE)((StartSector % SectorsPerCylinder) % MasterDiskInfo.OriginalSectorsPerTrack);
    }

    TheEntry->StartC = (BYTE)C;
    TheEntry->StartH = H;
    TheEntry->StartS = (BYTE)((S + 1) | (((USHORT)C & 0x300) >> 2));

    //
    // Similarly for the end.
    //
    EndSector--;
    *LastSector = EndSector;
    C = EndSector / SectorsPerCylinder;
    if(C >= (ULONG)Cylinders) {
        C = Cylinders - 1;
        H = (BYTE)(MasterDiskInfo.OriginalHeads - 1);
        S = (BYTE)(MasterDiskInfo.OriginalSectorsPerTrack - 1);
        Overflow = TRUE;
    } else {
        H = (BYTE)((EndSector % SectorsPerCylinder) / MasterDiskInfo.OriginalSectorsPerTrack);
        S = (BYTE)((EndSector % SectorsPerCylinder) % MasterDiskInfo.OriginalSectorsPerTrack);
        Overflow = FALSE;
    }

    TheEntry->EndC = (BYTE)C;
    TheEntry->EndH = H;
    TheEntry->EndS = (BYTE)((S + 1) | (((USHORT)C & 0x300) >> 2));

    if(!Relocating) {
        TheEntry->SysId = PartitionImage.SystemId;
    }
    if(Overflow) {
        switch(TheEntry->SysId) {
        case 1:
        case 4:
        case 6:
            //
            // Regular FAT12/FAT12/BIGFAT --> XINT13 FAT
            //
            TheEntry->SysId = 0xe;
            break;

        case 0xb:
            //
            // FAT32 --> XINT13 FAT32
            //
            TheEntry->SysId = 0xc;
            break;
        }
    } else {
        switch(TheEntry->SysId) {
        case 0xc:
            //
            // XINT13 FAT32 --> FAT32
            //
            TheEntry->SysId = 0xb;
            break;

        case 0xe:
            //
            // XINT13 FAT --> regular FAT
            //
            if(Relocating) {
                if(MasterDiskInfo.StartupPartitionSectorCount >= 65536L) {
                    TheEntry->SysId = 6;
                } else {
                    if(MasterDiskInfo.StartupPartitionSectorCount >= 32680L) {
                        TheEntry->SysId = 4;
                    } else {
                        TheEntry->SysId = 1;
                    }
                }
            } else {
                if(PartitionImage.TotalSectorCount >= 65536L) {
                    TheEntry->SysId = 6;
                } else {
                    if(PartitionImage.TotalSectorCount >= 32680L) {
                        TheEntry->SysId = 4;
                    } else {
                        TheEntry->SysId = 1;
                    }
                }
            }
            break;
        }
    }

    //
    // Write the MBR.
    //
    // Note that after the MBR has been updated, the system will no longer
    // boot into this program. Thus the master disk state is now irrelevent.
    // But just for completeness, we track that we completed this operation.
    //
    if(!CmdLineArgs.Test) {
        if(!WriteDisk(DiskHandle,0,1,IoBuffer)) {
            FatalError(textWriteFailedAtSector,1,0L);
        }
    }

    if(!CmdLineArgs.Test) {
        UpdateMasterDiskState(DiskHandle,Relocating ? MDS_RELOCATED_BOOT_MBR : MDS_UPDATED_MBR);
    }
}


VOID
TellUserToWait(
    VOID
    )
{
    FPCHAR p,q;
    char c;
    UINT line;
    INT maxlen;

    DispClearClientArea(NULL);

    //
    // This could be more than one line. We want the message centered
    // and left-aligned. Determine the longest line length and center
    // the entire message based on that length.
    //
    maxlen = 0;
    p = textPleaseWaitRestoring;
    do {
        //
        // Locate the next newline or terminator
        //
        for(q=p; (*q != '\n') && *q; q++);

        //
        // See if this line is maximum length seen so far.
        //
        if((q-p) > maxlen) {
            maxlen = q-p;
        }

        p = q+1;

    } while(*q);

    //
    // Second pass actually prints it out.
    //
    p = textPleaseWaitRestoring;
    line = 1;
    do {
        for(q=p; (*q != '\n') && *q; q++);

        //
        // Nul-terminate the line in preparation for printing it out.
        //
        c = *q;
        *q = 0;

        DispPositionCursor((BYTE)((80-maxlen)/2),(BYTE)(TEXT_TOP_LINE+line));
        DispWriteString(p);
        line++;

        *q = c;
        p = q+1;

    } while(*q);
}


VOID
StartGauge(
    VOID
    )
{
    ULONG SectorCount;

    //
    // Figure out how many sectors we will transfer in total.
    // This includes
    //
    // a) relocating the cluster bitmap
    // b) relocating the boot partition
    // c) transferring the actual data
    // d) zapping unselected OS images
    //
    SectorCount = 0;

    if(PartitionImage.Flags & PARTIMAGE_RELOCATE_BITMAP) {
        SectorCount += (PartitionImage.LastUsedCluster/CLUSTER_BITS_PER_SECTOR) + 1;
    }

    if(PartitionImage.Flags & PARTIMAGE_RELOCATE_BOOT) {
        SectorCount += MasterDiskInfo.StartupPartitionSectorCount;
    }

    SectorCount += PartitionImage.NonClusterSectors;

    SectorCount += PartitionImage.SectorsPerCluster * PartitionImage.UsedClusterCount;

    SectorCount *= 2;

    SectorCount += ZAP_MAX * (MasterDiskInfo.ImageCount-1);

    GaugeInit(SectorCount);
}

BOOL
TestImage(
    IN  HDISK  DiskHandle,
    IN  ULONG  StartSector
    )
{
    FPVOID Buffer,OriginalBuffer;
    ULONG CurrentSector;
    ULONG ImageCRC;
    ULONG CalcCRC;
    ULONG BytesCRC;

    ULONG SectorsRemaining;
    ULONG TotalSectors;
    ULONG BitmapSize;
    BYTE  Count;

    DispClearClientArea(NULL);
    DispPositionCursor(TEXT_LEFT_MARGIN,TEXT_TOP_LINE);

    DispWriteString(textValidatingImage);
    _Log("Validating image...\n");
    DispWriteString("\n\n");
    
    // need to allocate aligned buffer
    if(!AllocTrackBuffer(63,&Buffer,&OriginalBuffer)) {
        FatalError(textOOM);
        return FALSE;
    }

    CalcCRC = CRC32_INITIAL_VALUE;
    BytesCRC = 0;

    // read inital sector to get info
    CurrentSector = StartSector;
    if( ReadDisk( DiskHandle, CurrentSector, 1, Buffer ) ) {
        ImageCRC = ((PPARTITION_IMAGE)Buffer)->CRC;

        BitmapSize = ((PPARTITION_IMAGE)Buffer)->LastUsedCluster;

        BitmapSize = (BitmapSize % (8*512)) ? BitmapSize/(8*512)+1 : BitmapSize/(8*512);
        
        SectorsRemaining = ((PPARTITION_IMAGE)Buffer)->NonClusterSectors // fs structs
            + ((PPARTITION_IMAGE)Buffer)->SectorsPerCluster
            * ((PPARTITION_IMAGE)Buffer)->UsedClusterCount // data area
            + BitmapSize; // image cluster bitmap

        ((PPARTITION_IMAGE)Buffer)->CRC = 0;
        ((PPARTITION_IMAGE)Buffer)->BitmapRelocationStart = 0;
        ((PPARTITION_IMAGE)Buffer)->BootRelocationStart = 0;
        ((PPARTITION_IMAGE)Buffer)->Flags = 0;

        TotalSectors = SectorsRemaining;
    } else {
        FatalError(textReadFailedAtSector,1,CurrentSector);
        return FALSE;
    }

    CurrentSector++;
    
    // update the computed CRC
    CalcCRC = CRC32Compute( Buffer, 512, CalcCRC);
    BytesCRC += 512;

    GaugeInit(SectorsRemaining);

    // loop reading the entire file, updating the CRC
    while (SectorsRemaining) {
        Count = (BYTE) ((SectorsRemaining > 63L) ? 63L : SectorsRemaining);

        if( ReadDisk( DiskHandle, CurrentSector, Count , Buffer ) ) {
            CalcCRC = CRC32Compute( Buffer, Count*512, CalcCRC);            
            BytesCRC += Count*512;
        } else {
            FatalError(textReadFailedAtSector,Count,CurrentSector);
            return FALSE;
        }        
        SectorsRemaining -= Count;
        CurrentSector += Count;

        // print progress
        GaugeDelta(Count);
    }
    // compare with stored CRC    
    DispClearClientArea(NULL);
    DispPositionCursor(TEXT_LEFT_MARGIN,TEXT_TOP_LINE);
    _Log("Image file checksum = 0x%08lx\n",CalcCRC);
    if( CalcCRC != ImageCRC ) {
        FatalError(textChecksumFail);
        _Log("** WARNING ** checksum does not match original checksum 0x%08lx\n",ImageCRC);        
        return FALSE;
    } else {
        DispWriteString(textChecksumOk);
    }
    _Log("Image checksum ok.\n");
    free(OriginalBuffer);
    return TRUE;
}

BOOL
MungeParametersForFat32Extend(
    IN  HDISK   DiskHandle,
    IN  USHORT  Cylinders,
    IN  BYTE    SectorsPerTrack,
    IN  ULONG   SourceStart,
    IN  ULONG   *TargetStart,
    IN  FPMASTER_DISK pMasterDisk,
    IN  FPPARTITION_IMAGE pPartitionImage,
    IN  VOID    *TemporaryBuffer
    )
{
    ULONG SectorsPerCylinder;
    USHORT ReservedSectorCount;
    ULONG NewSectorCount;
    ULONG NewFatSize;
    ULONG ClusterSize;

    //
    // check for FAT32
    //
    if( pPartitionImage->SystemId == 0x0b || pPartitionImage->SystemId == 0x0c ) {

        SectorsPerCylinder = pMasterDisk->OriginalHeads * pMasterDisk->OriginalSectorsPerTrack;

        //
        // get the reserved sector count and the cluster size from the header
        //
        
        ReservedSectorCount = pPartitionImage->Fat32ReservedSectors;
        ClusterSize = pPartitionImage->SectorsPerCluster;        

        //
        // Read the boot sector of the image
        //
        if(!ReadDisk(DiskHandle,SourceStart+1,1,TemporaryBuffer)) {
            FatalError(textReadFailedAtSector,1,0L);
        }

        //
        // Need to save away the original FAT32 fat size.
        //
        if( IsFat32( TemporaryBuffer ) ) {
            pPartitionImage->Fat32OriginalFatTableSectCount = 
                    ((FPFAT32_BOOT_SECTOR)TemporaryBuffer)->PackedBpb.LargeSectorsPerFat;
        } else {
            //
            // If we're here, and this isn't FAT32, we're in trouble.
            //
            FatalError(textCantFindMasterDisk);
        }

        //
        // calculate the max size of the new partition
        //  = (total cylinder count - the new start) * (sectors/cyl)
        //
        // we assume the new partition will extend to the end of the disk.
        //

        NewSectorCount = Cylinders * SectorsPerCylinder - *TargetStart;

        //
        // given this number of sectors, calculate how many clusters we can make
        // and how many FAT entries we need to track them
        //
        NewFatSize = ComputeClusters(
                                    ClusterSize*512,        // # of bytes in a cluster
                                    NewSectorCount,         // # of sectors in partition
                                    512,                    // sector size in bytes
                                    ReservedSectorCount,    // reserved sector count
                                    2                       // # of Fats
                                    );                   
                
        if( NewFatSize < MAX_FAT32_ENTRIES  ) {
            //
            // if this will fit in a 16MB-64K FAT, then leave it alone.
            //
        } else {
            //
            // otherwise we clip the partition size to the max allowed.
            //
            NewFatSize = MAX_FAT32_ENTRIES;
            NewSectorCount = ReservedSectorCount + MAX_FAT32_ENTRIES/256 + MAX_FAT32_ENTRIES * ClusterSize;
            
        }

        pPartitionImage->Fat32AdjustedFatTableEntryCount = NewFatSize;
        pPartitionImage->Fat32AdjustedSectorCount = NewSectorCount;
    }

    return TRUE;
}
                           
VOID
AdjustTargetStart(
    IN  HDISK   DiskHandle,
    IN  BYTE    SectorsPerTrack,
    IN  ULONG   *TargetStart,
    IN  VOID    *TemporaryBuffer
    )
{
    unsigned i;
    BOOL foundUnknown;
    FPPARTITION_TABLE_ENTRY pPartitionTab;

    //
    // Read the MBR
    //
    if(!ReadDisk(DiskHandle,0,1,TemporaryBuffer)) {
        FatalError(textReadFailedAtSector,1,0L);
    }

    //
    // Validate that it is a good MBR.
    //
    if( ((FPMBR)TemporaryBuffer)->AA55Signature != BOOT_RECORD_SIGNATURE ) {
        FatalError(textReadFailedAtSector,1,0L);
        _Log("   WARNING: The MBR was invalid!");
    }

    //
    // now inspect the MBR, and check for an unrecognized partition.
    //
    pPartitionTab = ((FPMBR)TemporaryBuffer)->PartitionTable;

    foundUnknown = FALSE;
    for(i=0; i<4; i++) {
        if( IsUnknownPartition(pPartitionTab[i].SysId) ) {

            //
            // we assume the EISA config/hiber partition is at the start of the disk
            // adjust the start of the image restore to the cylinder past the end of it
            //
            foundUnknown = TRUE;           
        }
    }        

    _Log("   The master disk claims %ld sectors were reserved for EISA and hiber partitions.\n",
                MasterDiskInfo.FreeSpaceStart);

    if(foundUnknown == FALSE && MasterDiskInfo.FreeSpaceStart ) {    
        //
        // eh? How did FreeSpaceStart get set without having a partition there?
        //
        _Log("   WARNING: The master disk claims disk space was reserved for \n");
        _Log("            EISA/hiber partition when one does not appear to exist!\n");

        FatalError(textCantOpenMasterDisk);

    }
     
    if(MasterDiskInfo.FreeSpaceStart) {
        //
        // MasterDiskInfo.FreeSpaceStart will be non-zero if we discovered a non-recognized
        // partition when we built the master disk. The target start sector should be adjusted
        // to this number.
        //
        *TargetStart = MasterDiskInfo.FreeSpaceStart;
    }

    //
    // otherwise we should just leave the target start sector alone.
    //

    return;
}


//
// modified from \nt\private\utils\ufat\src\rfatsa.cxx
//
ULONG
ComputeClusters(
    IN  ULONG        ClusterSize,
    IN  ULONG        Sectors,
    IN  ULONG        SectorSize,
    IN  ULONG        ReservedSectors,
    IN  ULONG        Fats
    )
/*++

Routine Description:

    This routine computes the number of clusters on a volume given
    the cluster size, volume size and the fat type.

Arguments:

    ClusterSize - Supplies the size of a cluster in number of bytes.

    Sectors - Supplies the total number of sectors in the volume.

    SectorSize - Supplies the size of a sector in number of bytes.

    ReservedSectors - Supplies the number of reserved sectors.

    Fats - Supplies the number of copies of fat for this volume.

Return Value:

    ULONG - The total number of clusters for the given configuration.

++*/
{
    ULONG entries_per_sec; //  Number of FAT entries per sector.
    ULONG fat_entry_size;  //  Size of each FAT entry in number of BITS.
    ULONG sectors_left;    //  Number of sectors left for consideration.
    ULONG sec_per_clus;    //  Sectors per cluster.
    ULONG increment = 1;   //  Increment step size in number of FAT sectors.
    ULONG clusters = 0;    //  Number of clusters in total.
    ULONG temp;            //  Temporary place-holder for optimizing certain
                           //  computations.

    sectors_left = Sectors - ReservedSectors;
    sec_per_clus = ClusterSize / SectorSize;

    //
    //  The Fat entry size is 32 bits, since we only support FAT32
    //

    fat_entry_size = 32;

    //
    //  Compute the number of FAT entries a sector can hold.
    //	  NOTE that fat_entry_size is the size in BITS,
    //	  this is the reason for the "* 8" (bits per byte).
    //

    entries_per_sec = (SectorSize * 8) / fat_entry_size;

    //
    //  Compute a sensible increment step size to begin with.
    //

    while (Sectors / (increment * entries_per_sec * sec_per_clus) > 1) {
        increment *= 2;
    }

    //
    //  We have to handle the first sector of FAT entries
    //  separately because the first two entries are reserved.
    //  Kind of yucky, isn't it?
    //

    temp = Fats + ((entries_per_sec - 2) * sec_per_clus);

    if (sectors_left < temp) {

        return (sectors_left - Fats) / sec_per_clus;

    } else {

        sectors_left -= temp;
        clusters += entries_per_sec - 2;

        while (increment && sectors_left) {

            temp = (Fats + entries_per_sec * sec_per_clus) * increment;

            if (sectors_left < temp) {

                //
                //  If the increment step is only one, try to utilize the remaining sectors
                //  as much as possible.
                //

                if (increment == 1) {

                    //
                    // Additional clusters may be possible after allocating
                    // one more sector of fat.
                    //
                    if ( sectors_left > Fats) {
                        temp = (sectors_left - Fats) / sec_per_clus;
                        if (temp > 0) {
                            clusters += temp;
                        }
                    }

                }

                //
                // Cut the increment step by half if it is too big.
                //

                increment /= 2;

            } else {

                sectors_left -= temp;
                clusters += increment * entries_per_sec;

            }

        }
        return clusters;
    }
    FatalError("This line should never be executed.");

    return 0;
}

BOOL
IsUnknownPartition(
    IN BYTE SysId 
    )
{
    if( SysId != 0x00 && // not unused
        SysId != 0x01 &&
        SysId != 0x04 &&
        SysId != 0x06 &&
        SysId != 0x07 &&
        SysId != 0x0b &&
        SysId != 0x0c &&
        SysId != 0x0e ) {
        return TRUE;
    }
   
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\mpk\imagpart\cluster.c ===
#include "imagpart.h"


BOOL
BuildClusterBitmap(
    IN     FilesystemType   FsType,
    IN     HPARTITION       PartitionHandle,
    IN     UINT             FileHandle,
    IN OUT PARTITION_IMAGE *PartitionImage
    )

/*++

Routine Description:

    This routine builds a bitmap representing all clusters in the
    source volume, 1 bit per cluster (0=unused, 1=used). The bitmap
    is written into a file.

Arguments:

    FsType - supplies the type of the file system

    PartitionHandle - supplies handle to source partition

    FileHandle - supplies handle for output file. It is assumed that
        this file is empty. On output this file is rewound to offset 0.

    PartitionImage - supplies information about the source partition.
        On output, the following fields are filled in:

            LastUsedCluster
            UsedClusterCount

Return Value:

    Boolean value indicating outcome. If false, a message will have been
    printed out explaining why.

--*/

{
    BOOL b;

    if(FsType == FilesystemFat) {
        b = FatBuildClusterBitmap(PartitionHandle,FileHandle,PartitionImage);
    } else {
        if(FsType == FilesystemNtfs) {
            b = NtfsBuildClusterBitmap(PartitionHandle,FileHandle,PartitionImage);
        } else {
            fprintf(stderr,"\n%s\n",textUnsupportedFs);
            b = FALSE;
        }
    }

    if(b) {
        DosSeek(FileHandle,0,DOSSEEK_START);
    }

    return(b);
}


FPBYTE _ClusterBuffer;
ULONG _BaseCluster;
UINT _ClusterFileHandle;
ULONG _LastUsedCluster;
ULONG _NextClusterToExamine;
BYTE BitValue[8] = { 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80 };

VOID
InitClusterBuffer(
    IN FPBYTE _512ByteBuffer,
    IN UINT   FileHandle
    )
{
    _ClusterBuffer = _512ByteBuffer;
    _BaseCluster = 0L;
    _ClusterFileHandle = FileHandle;

    memset(_512ByteBuffer,0,512);
}


BOOL
MarkClusterUsed(
    IN ULONG Cluster
    )
{
    unsigned Written;
    BOOL NeedToZero;

    //
    // See if the cluster we're updating is past the end of what
    // we're currently buffering. Note that it could be way beyond.
    //
    NeedToZero = TRUE;
    while(Cluster >= _BaseCluster+(8*512)) {

        if(_dos_write(_ClusterFileHandle,_ClusterBuffer,512,&Written) || (Written != 512)) {
            fprintf(stderr,"\n%s\n",textFileWriteError);
            return(FALSE);
        }

        _BaseCluster += 8*512;

        if(NeedToZero) {
            memset(_ClusterBuffer,0,512);
            NeedToZero = FALSE;
        }
    }

    //
    // Set the relevent bit.
    //
    Cluster -= _BaseCluster;
    _ClusterBuffer[Cluster/8] |= BitValue[Cluster%8];

    return(TRUE);
}


BOOL
FlushClusterBuffer(
    VOID
    )
{
    unsigned Written;
    unsigned u;
    BOOL b;

    u = _dos_write(_ClusterFileHandle,_ClusterBuffer,512,&Written);

    b = (!u && (Written == 512));

    if(!b) {
        fprintf(stderr,"\n%s\n",textFileWriteError);
    }
    return(b);
}


BOOL
InitClusterMap(
    OUT FPBYTE _512ByteBuffer,
    IN  UINT   FileHandle,
    IN  ULONG  LastUsedCluster
    )
{
    unsigned Read;

    _ClusterBuffer = _512ByteBuffer;
    _ClusterFileHandle = FileHandle;
    _BaseCluster = 0L;
    _NextClusterToExamine = 0L;
    _LastUsedCluster = LastUsedCluster;

    if(_dos_read(FileHandle,_ClusterBuffer,512,&Read) || (Read != 512)) {
        fprintf(stderr,"\n%s\n",textFileReadFailed);
        return(FALSE);
    }

    return(TRUE);
}


BOOL
GetNextClusterRun(
    OUT ULONG *StartCluster,
    OUT ULONG *ClusterCount
    )
{
    UINT cluster;
    unsigned Read;
    BOOL b;

    *ClusterCount=0;

    //
    // Scan forward for the next 1 bit
    //
    while(_NextClusterToExamine <= _LastUsedCluster) {

        //
        // Reload the cluster buffer if necessary.
        //
        if(_NextClusterToExamine && !(_NextClusterToExamine % (512*8))) {
            if(_dos_read(_ClusterFileHandle,_ClusterBuffer,512,&Read) || (Read != 512)) {
                fprintf(stderr,"\n%s\n",textFileReadFailed);
                return(FALSE);
            }
            _BaseCluster += 512*8;
        }

        cluster = (UINT)(_NextClusterToExamine - _BaseCluster);

        //
        // To simplify things, the run will not span into the next sector
        // of the cluster map.
        //
        b = FALSE;

        while((_ClusterBuffer[cluster/8] & BitValue[cluster%8])
        && (cluster < (512*8)) && (_NextClusterToExamine <= _LastUsedCluster)) {

            if(!b) {
                *StartCluster = _NextClusterToExamine;
                b = TRUE;
            }
            *ClusterCount += 1;
            cluster++;
            _NextClusterToExamine++;
        }

        if(b) {
            return(TRUE);
        }

        _NextClusterToExamine++;
    }

    //
    // No more used clusters.
    //
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\mpk\inc\makepart.h ===
INT
_far
MakePartitionAtStartOfDisk(
    IN  HDISK  DiskHandle,
    OUT FPVOID SectorBuffer,
    IN  ULONG  MinimumSectorCount,
    IN  UINT   PartitionClass,
    IN  BYTE   SystemId         OPTIONAL
    );

//
// Values for PartitionClass.
//
// KEEP IN SYNC with iolib\disk.inc!
//
#define PARTCLASS_FAT       1
#define PARTCLASS_FAT32     2
#define PARTCLASS_NTFS      3
#define PARTCLASS_OTHER     4



INT
_far
MakePartitionAtEndOfEmptyDisk(
    IN  HDISK  DiskHandle,
    OUT FPVOID SectorBuffer,
    IN  ULONG  MinimumSectorCount,
    IN  BOOL   NewMasterBootCode
    );



INT
_far
ReinitializePartitionTable(
    IN  HDISK  DiskHandle,
    OUT FPVOID SectorBuffer
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\mpk\inc\mytypes.h ===
typedef unsigned char UCHAR,BYTE,_far *FPUCHAR,_far *FPBYTE;
typedef unsigned short USHORT,_far *FPUSHORT;
typedef unsigned long ULONG,_far *FPULONG;
typedef unsigned int UINT,_far *FPUINT;

typedef char CHAR,_far *FPCHAR;

typedef int INT,_far *FPINT;
typedef void VOID,_far *FPVOID;


typedef int BOOL;
#define TRUE  1
#define FALSE 0

#define IN
#define OUT
#define OPTIONAL

//
// Program return codes
//
#define SUCCESS 0
#define FAILURE 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\mpk\inc\partio.h ===
typedef ULONG HPARTITION;

UINT
_far
InitializePartitionList(
    VOID
    );

HPARTITION
_far
OpenPartition(
    IN UINT PartitionId
    );

VOID
_far
ClosePartition(
    IN HPARTITION PartitionHandle
    );

BOOL
_far
GetPartitionInfoById(
    IN  UINT    PartitionId,
    IN  UINT    Reserved,
    OUT FPUINT  DiskId,
    OUT FPBYTE  SystemId,
    OUT FPULONG StartSector,
    OUT FPULONG SectorCount
    );

BOOL
_far
GetPartitionInfoByHandle(
    IN  HPARTITION PartitionHandle,
    OUT FPUINT     DiskId,
    OUT FPBYTE     SystemId,
    OUT FPULONG    StartSector,
    OUT FPULONG    SectorCount
    );

BOOL
_far
ReadPartition(
    IN  HPARTITION PartitionHandle,
    IN  ULONG      StartSector,
    IN  BYTE       SectorCount,
    OUT FPVOID     Buffer
    );

BOOL
_far
WritePartition(
    IN HPARTITION PartitionHandle,
    IN ULONG      StartSector,
    IN BYTE       SectorCount,
    IN FPVOID     Buffer
    );

//
// Structure for partition table entry
//

typedef struct _PARTITION_TABLE_ENTRY{
    BYTE Active;
    BYTE StartH;
    BYTE StartS;
    BYTE StartC;
    BYTE SysId;
    BYTE EndH;
    BYTE EndS;
    BYTE EndC;
    ULONG Start;
    ULONG Count;
} PARTITION_TABLE_ENTRY, _far * FPPARTITION_TABLE_ENTRY;

//
// Define structure for an on-disk master boot record.
//
#define NUM_PARTITION_TABLE_ENTRIES 4
#define BOOT_RECORD_SIGNATURE          (0xaa55)

typedef struct _MBR {

    UCHAR       BootCode[440];

    UCHAR       NTFTSignature[4];

    UCHAR       Filler[2];

    PARTITION_TABLE_ENTRY PartitionTable[NUM_PARTITION_TABLE_ENTRIES];

    UINT        AA55Signature;

} MBR, _far *FPMBR;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\mpk\inc\diskio.h ===
typedef ULONG HDISK;

UINT
_far
InitializeDiskList(
    VOID
    );

HDISK
_far
OpenDisk(
    IN UINT DiskId
    );

VOID
_far
CloseDisk(
    IN HDISK DiskHandle
    );

BOOL
_far
ReadDisk(
    IN  HDISK  DiskHandle,
    IN  ULONG  StartSector,
    IN  BYTE   SectorCount,
    OUT FPVOID Buffer
    );

BOOL
_far
WriteDisk(
    IN HDISK  DiskHandle,
    IN ULONG  StartSector,
    IN BYTE   SectorCount,
    IN FPVOID Buffer
    );

BOOL
_far
GetDiskInfoByHandle(
    IN  HDISK    DiskHandle,
    OUT FPBYTE   Int13UnitNumber,
    OUT FPBYTE   SectorsPerTrack,
    OUT FPUSHORT Heads,
    OUT FPUSHORT Cylinders,
    OUT FPULONG  ExtendedSectorCount,
    OUT FPUINT   DiskId
    );

BOOL
_far
GetDiskInfoById(
    IN  UINT     DiskId,
    IN  UINT     Reserved,
    OUT FPBYTE   Int13UnitNumber,
    OUT FPBYTE   SectorsPerTrack,
    OUT FPUSHORT Heads,
    OUT FPUSHORT Cylinders,
    OUT FPULONG  ExtendedSectorCount
    );

VOID
_far
DisableExtendedInt13(
    IN BYTE Int13Unit OPTIONAL
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\mpk\inc\misclib.h ===
//
// FAT/FAT32 boot sectors.
//
#pragma pack(1)

/*
typedef struct _PACKED_BPB_EX {
    UCHAR  BytesPerSector[2];                       // offset = 0x000  0
    UCHAR  SectorsPerCluster[1];                    // offset = 0x002  2
    UCHAR  ReservedSectors[2];                      // offset = 0x003  3
    UCHAR  Fats[1];                                 // offset = 0x005  5
    UCHAR  RootEntries[2];                          // offset = 0x006  6
    UCHAR  Sectors[2];                              // offset = 0x008  8
    UCHAR  Media[1];                                // offset = 0x00A 10
    UCHAR  SectorsPerFat[2];                        // offset = 0x00B 11
    UCHAR  SectorsPerTrack[2];                      // offset = 0x00D 13
    UCHAR  Heads[2];                                // offset = 0x00F 15
    UCHAR  HiddenSectors[4];                        // offset = 0x011 17
    UCHAR  LargeSectors[4];                         // offset = 0x015 21
    UCHAR  LargeSectorsPerFat[4];                   // offset = 0x019 25
    UCHAR  ExtendedFlags[2];                        // offset = 0x01D 29
    UCHAR  FsVersion[2];                            // offset = 0x01F 31
    UCHAR  RootDirFirstCluster[4];                  // offset = 0x021 33
    UCHAR  FsInfoSector[2];                         // offset = 0x025 37
    UCHAR  BackupBootSector[2];                     // offset = 0x027 39
    UCHAR  Reserved[12];                            // offset = 0x029 41
} PACKED_BPB_EX;                   // sizeof = 0x035 53
*/

typedef struct _PACKED_BPB_EX {
    USHORT  BytesPerSector;                       // offset = 0x000  0
    UCHAR   SectorsPerCluster;                    // offset = 0x002  2
    USHORT  ReservedSectors;                      // offset = 0x003  3
    UCHAR   Fats;                                 // offset = 0x005  5
    USHORT  RootEntries;                          // offset = 0x006  6
    USHORT  Sectors;                              // offset = 0x008  8
    UCHAR   Media;                                // offset = 0x00A 10
    USHORT  SectorsPerFat;                        // offset = 0x00B 11
    USHORT  SectorsPerTrack;                      // offset = 0x00D 13
    USHORT  Heads;                                // offset = 0x00F 15
    ULONG   HiddenSectors;                        // offset = 0x011 17
    ULONG   LargeSectors;                         // offset = 0x015 21
    ULONG   LargeSectorsPerFat;                   // offset = 0x019 25
    USHORT  ExtendedFlags;                        // offset = 0x01D 29
    USHORT  FsVersion;                            // offset = 0x01F 31
    ULONG   RootDirFirstCluster;                  // offset = 0x021 33
    USHORT  FsInfoSector;                         // offset = 0x025 37
    USHORT  BackupBootSector;                     // offset = 0x027 39
    UCHAR   Reserved[12];                         // offset = 0x029 41
} PACKED_BPB_EX;                   // sizeof = 0x035 53

typedef PACKED_BPB_EX _far *FPPACKED_BPB_EX;

typedef struct _PACKED_BOOT_SECTOR_EX {
    UCHAR Jump[3];                                  // offset = 0x000   0
    UCHAR Oem[8];                                   // offset = 0x003   3
    PACKED_BPB_EX PackedBpb;       // offset = 0x00B  11
    UCHAR PhysicalDriveNumber;                      // offset = 0x040  64
    UCHAR CurrentHead;                              // offset = 0x041  65
    UCHAR Signature;                                // offset = 0x042  66
    UCHAR Id[4];                                    // offset = 0x043  67
    UCHAR VolumeLabel[11];                          // offset = 0x047  71
    UCHAR SystemId[8];                              // offset = 0x058  88
} FAT32_BOOT_SECTOR;                                // sizeof = 0x060  96

typedef FAT32_BOOT_SECTOR _far *FPFAT32_BOOT_SECTOR;

//
//  Define the FAT32 FsInfo sector.
//

typedef struct _FSINFO_SECTOR {
    ULONG SectorBeginSignature;                     // offset = 0x000   0
    UCHAR ExtraBootCode[480];                       // offset = 0x004   4
    ULONG FsInfoSignature;                          // offset = 0x1e4 484
    ULONG FreeClusterCount;                         // offset = 0x1e8 488
    ULONG NextFreeCluster;                          // offset = 0x1ec 492
    UCHAR Reserved[12];                             // offset = 0x1f0 496
    ULONG SectorEndSignature;                       // offset = 0x1fc 508
} FSINFO_SECTOR, _far *FPFSINFO_SECTOR;

#define FSINFO_SECTOR_BEGIN_SIGNATURE   0x41615252
#define FSINFO_SECTOR_END_SIGNATURE     0xAA550000

#define FSINFO_SIGNATURE                0x61417272

#pragma pack()

BOOL 
_far
IsFat32(
    VOID *buf
    );

typedef
BOOL
(*PDISKSEL_VALIDATION_ROUTINE) (
    IN USHORT DiskId
    );

INT
_far
SelectDisk(
    IN  UINT                         DiskCount,
    IN  FPCHAR                       Prompt,
    IN  PDISKSEL_VALIDATION_ROUTINE  Validate,          OPTIONAL
    OUT char                        *AlternateResponse, OPTIONAL
    IN  FPCHAR                       textDisk,
    IN  FPCHAR                       textPaddedMbCount,
    IN  FPCHAR                       textInvalidSelection,
    IN  FPCHAR                       textMasterDisk
    );

INT
_far
SelectPartition(
    IN  UINT    PartitionCount,
    IN  CHAR   *Prompt,
    OUT CHAR   *AlternateResponse, OPTIONAL
    IN  FPCHAR  textDisk,
    IN  FPCHAR  textPaddedMbCount,
    IN  FPCHAR  textInvalidSelection
    );

BOOL
_far
ConfirmOperation(
    IN FPCHAR ConfirmationText,
    IN char   textYesChar,
    IN char   textNoChar
    );

BOOL
_far
AllocTrackBuffer(
    IN  BYTE         SectorsPerTrack,
    OUT FPVOID _far *AlignedBuffer,
    OUT FPVOID _far *Buffer
    );

VOID
_far
FlushDisks(
    VOID
    );

ULONG
_far
DosSeek(
    IN unsigned Handle,
    IN ULONG    Offset,
    IN BYTE     Origin
    );

#define DOSSEEK_START   0
#define DOSSEEK_CURRENT 1
#define DOSSEEK_END     2

//** Must use this as initial value for CRC
#define CRC32_INITIAL_VALUE 0L

/***    CRC32Compute - Compute 32-bit
 *
 *  Entry:
 *      pb    - Pointer to buffer to computer CRC on
 *      cb    - Count of bytes in buffer to CRC
 *      crc32 - Result from previous CRC32Compute call (on first call
 *              to CRC32Compute, must be CRC32_INITIAL_VALUE!!!!).
 *
 *  Exit:
 *      Returns updated CRC value.
 */
ULONG 
_far
CRC32Compute(
    IN FPBYTE   pb, 
    IN ULONG    cb, 
    IN ULONG    crc32
    );

VOID
_far
RebootSystem(
    VOID
    );


unsigned
_far
GetGlobalCodepage(
    VOID
    );

BOOL
_far
SetGlobalCodepage(
    IN unsigned Codepage
    );

unsigned
_far
GetScreenCodepage(
    VOID
    );

BOOL
_far
SetScreenCodepage(
    IN unsigned Codepage
    );


typedef struct _CMD_LINE_ARGS {
    UINT LanguageCount;
    BOOL Test;
    BOOL Quiet;
    BOOL Reinit;
    BOOL DebugLog;
    BYTE MasterDiskInt13Unit;
    char _far *FileListFile;
    char _far *ImageFile;
} CMD_LINE_ARGS, _far *FPCMD_LINE_ARGS;

BOOL
ParseArgs(
    IN  int             argc,
    IN  FPCHAR          argv[],
    IN  BOOL            Strict,
    IN  FPCHAR          AllowedSwitchChars,
    OUT FPCMD_LINE_ARGS CmdLineArgs
    );

//
// Compression stuff
//
typedef enum {
    CompressNone,
    CompressMrci1,
    CompressMrci2,
    CompressMax
} CompressionType;


BOOL
CompressAndSave(
    IN  CompressionType Type,
    IN  FPBYTE          Data,
    IN  unsigned        DataSize,
    OUT FPBYTE          CompressScratchBuffer,
    IN  unsigned        BufferSize,
    IN  UINT            FileHandle
    );


//
// Logging stuff
//
VOID
_LogStart(
    IN char *FileName
    );

VOID
_LogEnd(
    VOID
    );

VOID
_Log(
    IN char *FormatString,
    ...
    );

VOID
_LogSetFlags(
    IN unsigned Flags
    );

//
// If this flag is set the log file will be closed
// and reopened after every call to _Log(). Useful
// if a reboot is expected to occur.
//
#define LOGFLAG_CLOSE_REOPEN    0x0001
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\mpk\inc\msgfile.h ===
typedef struct _MESSAGE_STRING {

    FPCHAR _far *String;
    UINT Id;

} MESSAGE_STRING, _far *FPMESSAGE_STRING;


BOOL
GetTextForProgram(
    IN     FPCHAR           Argv0,
    IN OUT FPMESSAGE_STRING Messages,
    IN     UINT             MessageCount
    );


//
// Lower-level routine
//
BOOL
PatchMessagesFromFile(
    IN     FPCHAR           Filename,
    IN OUT FPMESSAGE_STRING Messages,
    IN     UINT             MessageCount
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\mpk\inc\displib.h ===
//
// Default VGA pixel values
//
#define VGAPIX_BLACK         0
#define VGAPIX_BLUE          1
#define VGAPIX_GREEN         2
#define VGAPIX_CYAN          3
#define VGAPIX_RED           4
#define VGAPIX_MAGENTA       5
#define VGAPIX_YELLOW        6
#define VGAPIX_LIGHT_GRAY    7
#define VGAPIX_DARK_GRAY     8
#define VGAPIX_LIGHT_BLUE    9
#define VGAPIX_LIGHT_GREEN   10
#define VGAPIX_LIGHT_CYAN    11
#define VGAPIX_LIGHT_RED     12
#define VGAPIX_LIGHT_MAGENTA 13
#define VGAPIX_LIGHT_YELLOW  14
#define VGAPIX_WHITE         15

//
// Illegal value, used to make pixels transparent
//
#define VGAPIX_TRANSPARENT   16


VOID
_far
VgaInit(
    VOID
    );

VOID
_far
VgaClearScreen(
    IN BYTE PixelValue
    );

VOID
_far
VgaClearRegion(
    IN USHORT x,
    IN USHORT y,
    IN USHORT w,
    IN USHORT h,
    IN BYTE   PixelValue
    );

VOID
_far
VgaBitBlt(
    IN USHORT x,
    IN USHORT y,
    IN USHORT w,
    IN USHORT h,
    IN USHORT BytesPerRow,
    IN BOOL   IsColor,
    IN FPBYTE PixelMap,
    IN FPVOID Data
    );

BOOL
_far
VgaDisplayBitmapFromFile(
    IN FPCHAR Filename,
    IN USHORT x,
    IN USHORT y,
    IN FPVOID ScratchBuffer,
    IN UINT   ScratchBufferSize
    );

FPVOID
_far
VgaSaveBlock(
    IN  USHORT   x,
    IN  USHORT   y,
    IN  USHORT   w,
    IN  USHORT   h,
    OUT FPUSHORT BytesPerRow
    );

BOOL
_far
FontLoadAndInit(
    IN FPCHAR Filename
    );

VOID
_far
FontGetInfo(
    OUT FPBYTE Width,
    OUT FPBYTE Height
    );

VOID
_far
FontWriteChar(
    IN UCHAR  c,
    IN USHORT x,
    IN USHORT y,
    IN BYTE   ForegroundPixelValue,
    IN BYTE   BackgroundPixelValue
    );

VOID
_far
FontWriteString(
    IN UCHAR  *String,
    IN USHORT  x,
    IN USHORT  y,
    IN BYTE    ForegroundPixelValue,
    IN BYTE    BackgroundPixelValue
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\mpk\inc\partimag.h ===
//
// This structure is header information for a partition blob.
// It is padded to sector length when written.
//
#define PARTITION_IMAGE_SIGNATURE       0x52ab4cf9L

typedef struct _PARTITION_IMAGE {
    //
    // Signature
    //
    ULONG Signature;

    //
    // Size of the this structure
    //
    UINT Size;

    //
    // Number of sectors at the start of the partition
    // that are not part of a cluster. This is also the
    // start sector number of the cluster area.
    //
    ULONG NonClusterSectors;

    //
    // Total number of clusters in the cluster area of the volume,
    // used and unused.
    //
    ULONG ClusterCount;

    //
    // Number of sectors in the original partition containing the volume.
    //
    ULONG TotalSectorCount;

    //
    // The last used cluster on the volume.
    //
    ULONG LastUsedCluster;

    //
    // The number of (used) clusters in the image
    //
    ULONG UsedClusterCount;

    //
    // Start sectors for relocation of cluster bitmap and boot partition.
    // Valid when the PARTIMAGE_RELOCATE_xxx flags are set (see below).
    // Filled in by makemast.exe when the image is transferred to disk.
    //
    ULONG BitmapRelocationStart;
    ULONG BootRelocationStart;

    //
    // Number of sectors in a cluster.
    //
    BYTE SectorsPerCluster;

    //
    // System id byte of the partition, for the partition table.
    //
    BYTE SystemId;

    //
    // Flags
    //
    UINT Flags;

    //
    // CRC32 for the file
    //
    ULONG CRC;

    //
    // Reserved Sector count for FAT32 ONLY
    //
    USHORT Fat32ReservedSectors;

    //
    // Adjusted sector count for FAT32 ONLY
    //
    ULONG Fat32AdjustedSectorCount;

    //
    // Original FAT table size for FAT32 ONLY
    //
    ULONG Fat32OriginalFatTableSectCount;

    //
    // Adjusted FAT table size for FAT32 ONLY
    //
    ULONG Fat32AdjustedFatTableEntryCount;


} PARTITION_IMAGE, *PPARTITION_IMAGE, _far *FPPARTITION_IMAGE;

//
// These flags indicate that there's not enough free space at the end
// of the volume for the boot partition and/or cluster bitmap and thus
// these two things will have to be relocated to free space within
// the volume before we start the restore process.
//
#define PARTIMAGE_RELOCATE_BITMAP  0x0001
#define PARTIMAGE_RELOCATE_BOOT    0x0002


//
// This structure is written onto physical sector 1 (just past the mbr)
// on a master disk. It a) indicates that the disk is a master disk and
// b) gives information about each partition image available to the
// end-user. It is also padded to sector length when written.
//
#define MAX_PARTITION_IMAGES    10

typedef struct _MASTER_DISK {
    //
    // Signature
    //
    ULONG Signature;

    //
    // Size of this structure
    //
    UINT Size;

    //
    // State info
    //
    UINT State;

    //
    // Start sector of the MPK boot partition. We could get this
    // from the MBR also but we stash it here for verification and
    // convenience.
    //
    ULONG StartupPartitionStartSector;
    ULONG StartupPartitionSectorCount;

    //
    // Count of partition images
    //
    UINT ImageCount;

    //
    // LBA sector numbers of start of each image
    //
    ULONG ImageStartSector[MAX_PARTITION_IMAGES];

    //
    // State-dependent information.
    //
    UINT SelectedLanguage;
    UINT SelectionOrdinal;
    ULONG ClusterBitmapStart;
    ULONG NonClusterSectorsDone;
    ULONG ForwardXferSectorCount;
    ULONG ReverseXferSectorCount;

    //
    // Geometry information used when the master disk was created.
    // At end-user time this geometry must match.
    //
    USHORT OriginalHeads;
    BYTE OriginalSectorsPerTrack;

    //
    // Used for preserving EISA/hiber partitions at the beginning and end of disks.
    // These are filled in by makemast when it figures out where the partition restores
    // can go.
    //

    ULONG   FreeSpaceStart;

    // currently this field is unused, as we do not support preserving partitions
    // at the end of the disk, since this is where the MPK partition goes
    ULONG   FreeSpaceEnd;   

} MASTER_DISK, *PMASTER_DISK, _far *FPMASTER_DISK;

#define MASTER_DISK_SIGNATURE 0x98fc2304L

//
// Master disk states. Note that these *must* be in sequence order.
//
#define MDS_NONE                0
#define MDS_GOT_LANGUAGE        10
#define MDS_GOT_OS_CHOICE       20
#define MDS_CACHED_IMAGE_HEADER 30
#define MDS_REMOVED_OTHERS      40
#define MDS_RELOCATED_BITMAP    50
#define MDS_RELOCATED_BOOT      53
#define MDS_RELOCATED_BOOT_MBR  57
#define MDS_DID_NONCLUSTER_DATA 60
#define MDS_DID_XFER_FORWARD    63
#define MDS_DID_XFER_REVERSE    67
#define MDS_UPDATED_BPB         70
#define MDS_UPDATED_MBR         80


BOOL
_far
IsMasterDisk(
    IN  UINT   DiskId,
    OUT FPVOID IoBuffer
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\mpk\iolib\bootcode.c ===
#include "\nt\public\sdk\inc\bootmbr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\mpk\iolib\disk.inc ===
;
; Per-disk structure. The code in diskio.asm builds a linked list of
; structures that use these as their header. The remainder of each
; item in the linked list is specific to the type of disk
; (currently only int13 units are supported).
;
DISK_INFO STRUC
    ;
    ; Pointer to next structure in the linked list.
    ;
    DiskInfoNextl   dw ?
    DiskInfoNexth   dw ?

    ;
    ; Disk id/ordinal. These start at 0 and count upwards.
    ;
    DiskInfoDiskId      dw ?

    DiskInfoDiskOpen    db ?

DISK_INFO ENDS

    DiskInfoNext        equ dword ptr DiskInfoNextl




PARTCLASS_FAT   equ     1
PARTCLASS_FAT32 equ     2
PARTCLASS_NTFS  equ     3
PARTCLASS_OTHER equ     4
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\mpk\iolib\diskio.asm ===
DOSSEG
        .MODEL LARGE

include disk.inc

        .DATA?
        public DiskList
        DiskList dd ?


        .CODE
        ASSUME ds:NOTHING

        extrn InitializeInt13DiskList:far
        extrn OpenInt13Disk:far
        extrn CloseInt13Disk:far
        extrn Int13DiskIo:far
        extrn GetInt13DiskInfo:far

.386

;++
;
; UINT
; _far
; InitializeDiskList(
;     VOID
;     );
;
; Routine Description:
;
;       This routine initializes internal data structures necessary so that
;       other disk-related routines in this module can be called.
;
;       A data structure for each disk (currently int13 units only) is built
;       and saved away. The structure contains various info such as
;       drive geometry.
;
;       This routine may be called multiple times. Subsequent calls after
;       the first simply return the disk count.
;
; Arguments:
;
;       None.
;
; Return Value:
;
;       Total count of all hard drives that we can deal with.
;       0 if an error occurs.
;
;--

        public _InitializeDiskList
_InitializeDiskList proc far

        push    ds
        push    si

        ;
        ; See if we're initialized yet by counting items in the DiskList
        ; linked list. If 0, then assume not initialized yet.
        ;
        mov     ax,DGROUP
        mov     ds,ax
        mov     si,OFFSET DGROUP:DiskList

        mov     ax,0

idl1:
        .errnz DiskInfoNextl

        mov     cx,[si].DiskInfoNextl
        or      cx,[si].DiskInfoNexth
        jz      idl2
        inc     ax
        lds     si,[si].DiskInfoNext
        jmp     short idl1
idl2:
        cmp     ax,0
        jne     idl3

        ;
        ; Currently we deal with int13 disks only.
        ;
        push    ax                      ; disk ids start at 0
        call    InitializeInt13DiskList
        add     sp,2

idl3:
        pop     si
        pop     ds
        retf

_InitializeDiskList endp


;++
;
; HDISK
; _far
; OpenDisk(
;     IN UINT DiskId
;     );
;
; Routine Description:
;
;       This routine "opens" a disk so that i/o can be performed to it.
;       Housekeeping such as locking, etc, is performed.
;       A disk can be opened only once at a time.
;
; Arguments:
;
;       DiskId - supplies an ordinal value for the disk to be opened.
;               Range is 0 - n-1, where n is the value returned by
;               InitializeDiskList().
;
; Return Value:
;
;       Handle, or 0 if an error occurs.
;
;--

DiskId equ word ptr [bp+6]

        public _OpenDisk
_OpenDisk proc far

        push    bp
        mov     bp,sp

        push    ds
        push    si

        ;
        ; Locate the disk record corresponding to this disk id.
        ;
        mov     ax,DiskId
        call    far ptr pLocateDiskRecord
        mov     cx,si
        or      cx,dx
        mov     ax,0
        jz      od_done                 ; dx:ax already 0 for error return

od_gotrec:
        ;
        ; Make sure disk is not already open
        ;
        cmp     [si].DiskInfoDiskOpen,al
        jz      @f
        mov     dx,ax                   ; dx:ax = 0
        jnz     od_done                 ; disk already open, error.
@@:
        ;
        ; Int13 disks only for now.
        ;
        push    ds
        push    si
        call    OpenInt13Disk
        pop     si
        pop     ds

        cmp     ax,0
        jnz     @f
        mov     dx,ax
        jz      od_done                 ; error, dx:ax set for return

@@:     inc     [si].DiskInfoDiskOpen
        mov     dx,ds
        mov     ax,si                   ; dx:ax = handle for return

od_done:
        pop     si
        pop     ds

        leave
        retf

_OpenDisk endp


;++
;
; VOID
; _far
; CloseDisk(
;     IN HDISK DiskHandle
;     );
;
; Routine Description:
;
;       This routine "closes" a disk previously opened by OpenDisk().
;       Housekeeping such as unlocking, etc, is performed.
;
; Arguments:
;
;       DiskHandle - supplies the handle of the disk to be closed,
;               as previously opened by OpenDisk().
;
; Return Value:
;
;       None.
;
;--

DiskHandle  equ dword ptr [bp+6]

        public _CloseDisk
_CloseDisk proc far

        push    bp
        mov     bp,sp

        push    ds
        push    si

        lds     si,DiskHandle

        cmp     [si].DiskInfoDiskOpen,0
        jz      cd_done                 ; not open, nothing to do

        ;
        ; Int13 disks only for now
        ;
        push    ds
        push    si
        call    CloseInt13Disk
        pop     si
        pop     ds                      ; ds:si -> disk record

        dec     [si].DiskInfoDiskOpen

cd_done:
        pop     si
        pop     ds
        leave
        retf

_CloseDisk endp


;++
;
; BOOL
; _far
; GetDiskInfoByHandle(
;       IN  HDISK    DiskHandle,
;       OUT FPBYTE   Int13UnitNumber,
;       OUT FPBYTE   SectorsPerTrack,
;       OUT FPUSHORT Heads,
;       OUT FPUSHORT Cylinders,
;       OUT FPULONG  ExtendedSectorCount,
;       OUT FPUINT   DiskId
;       );
;
; BOOL
; _far
; GetDiskInfoById(
;       IN  UINT     DiskId,
;       IN  UINT     Reserved,
;       OUT FPBYTE   Int13UnitNumber,
;       OUT FPBYTE   SectorsPerTrack,
;       OUT FPUSHORT Heads,
;       OUT FPUSHORT Cylinders,
;       OUT FPULONG  ExtendedSectorCount
;       );
;
; Routine Description:
;
;       These routines fetch information about a disk.
;
; Arguments:
;
; Return Value:
;
;       non-0 - success
;       0 - failure
;
;--

DiskHandle      equ dword ptr [bp+6]
DiskId          equ word  ptr [bp+6]
Int13UnitNumber equ dword ptr [bp+10]
SectorsPerTrack equ dword ptr [bp+14]
Heads           equ dword ptr [bp+18]
Cylinders       equ dword ptr [bp+22]
ExtendedSecCnt  equ dword ptr [bp+26]
pDiskId         equ dword ptr [bp+30]

        public _GetDiskInfoById
_GetDiskInfoById proc far

        push    bp
        mov     bp,sp

        push    ds
        push    si

        ;
        ; Locate the disk record.
        ;
        mov     ax,DiskId
        call    far ptr pLocateDiskRecord
        cmp     dx,0
        jnz     gdi_do_it
        cmp     si,0
        jnz     gdi_do_it
        mov     ax,dx
        jz      gdi_done

gdi_do_it:
        ;
        ; Int13 disks are the only ones supported now so we can
        ; just call the int13-specific disk info routine.
        ;
        push    ExtendedSecCnt
        push    Cylinders
        push    Heads
        push    SectorsPerTrack
        push    Int13UnitNumber
        push    ds
        push    si
        call    GetInt13DiskInfo
        add     sp,24
        mov     ax,1

gdi_done:
        pop     si
        pop     ds
        leave
        retf

_GetDiskInfoById endp


        public _GetDiskInfoByHandle
_GetDiskInfoByHandle proc far

        push    bp
        mov     bp,sp

        push    ds
        push    si

        ;
        ; Make sure the disk is open.
        ;
        lds     si,DiskHandle
        cmp     [si].DiskInfoDiskOpen,0
        jz      @f

        ;
        ; Set disk id in caller's variable
        ;
        mov     ax,[si].DiskInfoDiskId
        lds     si,pDiskId
        mov     [si],ax
        lds     si,DiskHandle
        jmp     short gdi_do_it

@@:     mov     ax,0
        jz      gdi_done

_GetDiskInfoByHandle endp


;++
;
; BOOL
; _far
; ReadDisk(
;     IN  HDISK DiskHandle,
;     IN  ULONG StartSector,
;     IN  BYTE  SectorCount,
;     OUT PVOID Buffer
;     );
;
; BOOL
; _far
; WriteDisk(
;     IN HDISK DiskHandle,
;     IN ULONG StartSector,
;     IN BYTE  SectorCount,
;     IN PVOID Buffer
;     );
;
; Routine Description:
;
;       These routines perform i/o to a disk previously opened with
;       OpenDisk().
;
; Arguments:
;
;       DiskHandle - supplies the handle of the disk to be read/written,
;               as previously opened by OpenDisk().
;
;       StartSector - supplies the physical start sector where the read/write
;               is to begin.
;
;       SectorCount - supplies the number of sectors to be read/written.
;
;       Buffer - supplies a buffer for the transfer.
;
; Return Value:
;
;       non-0 - success
;       0 - failure
;
;--

DiskHandle  equ dword ptr [bp+6]
StartSector equ dword ptr [bp+10]
SectorCount equ word  ptr [bp+14]
Buffer      equ dword ptr [bp+16]

        public _WriteDisk
_WriteDisk label far

        mov     ax,1
        jmp     short DiskIo

        public _ReadDisk
_ReadDisk label far

        mov     ax,0

DiskIo proc far

        push    bp
        mov     bp,sp

        push    ds
        push    si

        lds     si,DiskHandle
        cmp     [si].DiskInfoDiskOpen,0
        jnz     @f
        mov     ax,0                    ; not open, error out
        jz      rd_done

        ;
        ; Int13 disks only for now
        ;
@@:     push    ax
        push    Buffer
        push    SectorCount
        push    StartSector             ; only care about low byte
        push    ds
        push    si
        call    Int13DiskIo
        add     sp,16

rd_done:
        pop     si
        pop     ds
        leave
        retf

DiskIo endp


;++
;
; PVOID
; _far
; pLocateDiskRecord(
;     IN UINT DiskId
;     );
;
; Routine Description:
;
;       Internal routine.
;
;       This routine locates a disk record in the linked list
;       of all disk records as prepared by InitializeDiskList().
;
; Arguments:
;
;       DiskId - supplies an ordinal value identifying the disk.
;               Valid range is 0 - n-1, where n is the number returned
;               from InitializeDiskList().
;
;               This parameter is passed in ax, not on the stack.
;
; Return Value:
;
;       NULL if record not located.
;       Otherwise fills ds:si and dx:si with a far pointer to the
;       disk record.
;
;--
pLocateDiskRecord proc far

        mov     dx,DGROUP
        mov     ds,dx
        mov     si,offset DGROUP:[DiskList]       ; ds:si = &DiskList

        ;
        ; Note that this code depends on the link field in the
        ; disk record structure being first!
        ;
        .errnz  DiskInfoNext
ldr_loop:
        lds     si,[si].DiskInfoNext
        mov     dx,ds
        cmp     dx,0
        jz      ldr_done                        ; end of list, we're done
        cmp     [si].DiskInfoDiskId,ax
        jz      ldr_done
        jmp     short ldr_loop

ldr_done:
        retf

pLocateDiskRecord endp

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\mpk\iolib\partit.inc ===
;
; This structure is used internally to track partitions
; we've located when we examined all the disks we care about.
;
PART_INFO STRUC
    ;
    ; For linked list. THIS MUST BE FIRST. LocatePartitionRecord
    ; depends on this being true.
    ;
    PartInfoNextl          dw ?
    PartInfoNexth          dw ?

    ;
    ; Ordinal used by clients to uniquely identify the partition.
    ;
    PartInfoOrdinal        dw ?

    ;
    ; Disk id of disk the partition is on.
    ;
    PartInfoDiskId         dw ?

    ;
    ; Physical start sector and sector count,
    ; and system id from partition table entry for the partition
    ;
    PartInfoStartSectorl   dw ?
    PartInfoStartSectorh   dw ?
    PartInfoSectorCountl   dw ?
    PartInfoSectorCounth   dw ?
    PartInfoSystemId       db ?

    PartInfoPartOpen       db ?
    PartInfoDiskHandlel    dw ?
    PartInfoDiskHandleh    dw ?

PART_INFO ENDS

    PartInfoNext           equ dword ptr PartInfoNextl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\mpk\iolib\makepart.asm ===
DOSSEG
        .MODEL LARGE

include disk.inc
include partit.inc

        .DATA
        extrn _x86BootCode:far

        .DATA?
        extrn PartitionList:dword
        extrn PartitionListCount:word

        .CODE
        ASSUME ds:NOTHING

        extrn _malloc:far
        extrn _free:far
        extrn _qsort:far
        extrn _ReadDisk:far
        extrn _WriteDisk:far
        extrn _GetDiskInfoByHandle:far

.386

;++
;
; INT
; _far
; MakePartitionAtStartOfDisk(
;     IN  HDISK  DiskHandle,
;     OUT FPVOID SectorBuffer,
;     IN  ULONG  MinimumSectorCount,
;     IN  UINT   PartitionClass,
;     IN  BYTE   SystemId         OPTIONAL
;     );
;
; Routine Description:
;
;       This routine makes a new primary partition of at least
;       a given number of sectors. The partition may be larger
;       to keep it aligned on the proper cyl/track boundary.
;
;       Only int13 disk units are supported.
;
; Arguments:
;
;       DiskHandle - supplies a disk handle as returned by OpenDisk().
;
;       SectorBuffer - supplies a pointer to a buffer suitable for use
;               for i/o of a single sector. This buffer must not
;               cross a DMA boundary, but the caller is responsible
;               for ensuring this.
;
;       MinimumSectorCount - supplies the minimum number of sectors
;               that the partition should contain.
;
;       PartitionClass - supplies a value indicating what class of system id
;               should be used for the partition.
;
;               PARTCLASS_FAT - creates a type 1, 4, or 6, or e partition
;                       depending on size and availability of xint13
;                       services for the drive.
;
;               PARTCLASS_FAT32 - creates a type b or c partition depending
;                       on availability of xint13 services for the drive.
;
;               PARTCLASS_NTFS - creates a type 7 partition.
;
;               PARTCLASS_OTHER - create a partition whose type is given by
;                       the SystemId parameter.
;
;       SystemId - if PartitionClass is PARTCLASS_OTHER, supplies the
;               system id for the partition. Ignored otherwise.
;
; Return Value:
;
;       Partition id of newly created partition, or -1 if failure.
;
;--

DiskHandle          equ dword ptr [bp+6]
DiskHandlel         equ word  ptr [bp+6]
DiskHandleh         equ word  ptr [bp+8]
SectorBuffer        equ dword ptr [bp+10]
SectorBufferl       equ word  ptr [bp+10]
SectorBufferh       equ word  ptr [bp+12]
MinimumSectorCount  equ dword ptr [bp+14]
MinimumSectorCountl equ word  ptr [bp+14]
MinimumSectorCounth equ word  ptr [bp+16]
PartitionClass      equ word  ptr [bp+18]
SystemId            equ byte  ptr [bp+20]

ExtSecCnth          equ word  ptr [bp-2]
ExtSecCntl          equ word  ptr [bp-4]
ExtSecCnt           equ dword ptr [bp-4]
Cylinders           equ word  ptr [bp-6]
Heads               equ word  ptr [bp-8]
SectorsPerTrack     equ byte  ptr [bp-9]
Int13UnitNumber     equ byte  ptr [bp-10]
SectorsPerCylinder  equ word  ptr [bp-12]
DiskSizeh           equ word  ptr [bp-14]
DiskSizel           equ word  ptr [bp-16]
DiskSize            equ dword ptr [bp-16]
DiskId              equ word  ptr [bp-18]
Tableh              equ word  ptr [bp-20]
Tablel              equ word  ptr [bp-22]
Table               equ dword ptr [bp-22]
FreeStarth          equ word  ptr [bp-24]
FreeStartl          equ word  ptr [bp-26]
FreeStart           equ dword ptr [bp-26]

START_AND_SIZE STRUC
    PartStartl dw ?
    PartStarth dw ?
    PartSizel  dw ?
    PartSizeh  dw ?
START_AND_SIZE ENDS

        public _MakePartitionAtStartOfDisk
_MakePartitionAtStartOfDisk proc far

        push    bp
        mov     bp,sp
        sub     sp,26

        push    ds
        push    es
        push    bx
        push    si
        push    di

        ;
        ; Get disk info. This also makes sure the handle is open,
        ; calculates the number of sectors we can address on the disk,
        ; and the number of sectors in a cylinder.
        ;
        call    near ptr pGetDiskValues
        jnc     @f
        mov     ax,0ffffh
        jc      done2

        ;
        ; Allocate a buffer for our table.
        ; Make sure ds addresses DGROUP for crt
        ;
@@:     push    ds
        push    DGROUP
        pop     ds
        push    5 * SIZE START_AND_SIZE
        call    _malloc
        add     sp,2
        pop     ds
        mov     cx,ax
        or      cx,dx
        jnz     @f
        dec     ax                      ; ax = -1 for error return
        jmp     done2
@@:     mov     Tableh,dx
        mov     Tablel,ax

        ;
        ; Read sector 0 of the disk.
        ;
        push    SectorBuffer
        push    1
        push    0
        push    0
        push    DiskHandle
        call    _ReadDisk
        add     sp,14
        cmp     ax,0
        jne     @f
        dec     ax
        jmp     done1                   ; ax = -1 for error exit

        ;
        ; Make sure the MBR is valid.
        ;
@@:     lds     si,SectorBuffer
        cmp     word ptr [si+510],0aa55h
        je      @f
        mov     ax,0ffffh
        jmp     done1

        ;
        ; Zero out the start/offset table.
        ;
@@:     les     di,Table                ; es:di -> local start/size table
        mov     ax,0
        mov     cx,4*(SIZE START_AND_SIZE)
        cld
        rep stosb

        ;
        ; Build the start/offset table.
        ;
        mov     cx,4                    ; cx = loop count
        add     si,1beh                 ; ds:si -> start of partition table
        mov     di,Tablel               ; es:di -> local start/size table
nextent:
        cmp     byte ptr [si+4],0
        jnz     @f
        add     si,16
        loop    nextent
        jmp     short chkfull
@@:     add     si,8                    ; ds:si -> relative sector field
        movsw                           ; start low
        movsw                           ; start high
        movsw                           ; count low
        movsw                           ; count high
        inc     al                      ; remember number of used entries
        loop    nextent

        ;
        ; See if the partition table is full.
        ;
chkfull:
        cmp     al,4
        jne     @f
        mov     ax,0ffffh
        je      done1

        ;
        ; Sort the local start/size table. Before calling crt
        ; make sure ds addresses DGROUP.
        ;
@@:     push    ds
        push    DGROUP
        pop     ds
        push    ax                      ; save table length
        push    SEG CompareStartSize
        push    OFFSET CompareStartSize ; compare routine pointer
        push    SIZE START_AND_SIZE     ; size of each element
        push    ax                      ; number of elements to sort
        push    Table                   ; array of elements to sort
        call    _qsort
        add     sp,12
        pop     bx                      ; restore table length
        pop     ds

        ;
        ; Put a "fence" entry at the end of the table
        ; for space at the end of the disk.
        ;
        mov     al,SIZE START_AND_SIZE
        mul     bl                      ; ax = byte offset to fence entry
        inc     bl                      ; account for fence entry
        les     di,Table
        add     di,ax                   ; es:di -> fence entry
        mov     ax,DiskSizel
        mov     es:[di].PartStartl,ax
        mov     ax,DiskSizeh
        mov     es:[di].PartStarth,ax
        mov     es:[di].PartSizel,1
        mov     es:[di].PartSizeh,0

        ;
        ; Initialize for loop. The first space starts on the first sector
        ; of the second head.
        ;
        mov     al,SectorsPerTrack
        cbw
        mov     FreeStartl,ax
        mov     FreeStarth,0

        mov     cl,bl
        xor     ch,ch                   ; cx = # entries in table
        les     di,Table                ; es:di -> start/offset table
        jmp     short aligned1

        ;
        ; Get the start of the partition and align to cylinder boundary
        ;
nextspace:
        mov     dx,FreeStarth
        mov     ax,FreeStartl           ; dx:ax = start of free space
        div     SectorsPerCylinder      ; dx = sector within cylinder
        cmp     dx,0                    ; already aligned?
        jz      aligned1                ; yes
        mov     bx,SectorsPerCylinder
        sub     bx,dx                   ; bx = adjustment to next boundary
        add     FreeStartl,bx
        adc     FreeStarth,0            ; FreeStart now aligned

aligned1:
        mov     dx,es:[di].PartStarth
        mov     ax,es:[di].PartStartl   ; dx:ax = start of partition
        sub     ax,FreeStartl
        sbb     dx,FreeStarth           ; dx:ax = size of free space
        push    ax
        push    dx

        ;
        ; Now make sure the end of the free space is aligned.
        ;
        add     ax,FreeStartl
        adc     dx,FreeStarth           ; dx:ax = first sector past free space
        div     SectorsPerCylinder      ; dx = sector within cylinder (may be 0)
        mov     bx,dx
        pop     dx
        pop     ax                      ; dx:ax = size of free space
        sub     ax,bx
        sbb     dx,0                    ; dx:ax = size of aligned free space
        js      nextspace1              ; just in case

        ;
        ; Check the free space to see if it's large enough.
        ;
        cmp     dx,MinimumSectorCounth
        ja      makepart                ; it's large enough
        jb      nextspace1
        cmp     ax,MinimumSectorCountl
        jae     makepart
nextspace1:
        mov     ax,es:[di].PartStartl
        add     ax,es:[di].PartSizel
        mov     FreeStartl,ax
        mov     ax,es:[di].PartStarth
        adc     ax,es:[di].PartSizeh
        mov     FreeStarth,ax           ; next space is after this partition
        add     di,SIZE START_AND_SIZE  ; point at next table entry
        loop    nextspace
        mov     ax,cx                   ; no room, set ax for error return
        dec     ax
        jmp     done1

        ;
        ; If we get here, we've found a free space that will work
        ; for our partition.
        ;
        ; FreeStart has the start of the free space.
        ;
makepart:
        mov     ax,FreeStartl
        add     ax,MinimumSectorCountl
        mov     dx,FreeStarth
        adc     dx,MinimumSectorCounth

        div     SectorsPerCylinder      ; dx = sector within cylinder
        cmp     dx,0                    ; aligned already?
        jz      @f                      ; yes
        mov     bx,SectorsPerCylinder
        sub     bx,dx                   ; bx = adjustment to next cyl boundary
        add     MinimumSectorCountl,bx
        adc     MinimumSectorCounth,0

        ;
        ; Now MinimumSectorCount has the actual sector count.
        ; Find a free table entry. We know there is one or else
        ; we'd have errored out a while ago.
        ;
@@:     lds     si,SectorBuffer
        add     si,1beh                 ; ds:si -> partition table
@@:     cmp     byte ptr [si+4],0
        jz      makepart1
        add     si,16
        jmp     short @b

makepart1:
        mov     ax,FreeStartl
        mov     dx,FreeStarth
        mov     [si+8],ax
        mov     [si+10],dx
        add     si,1
        call    pMakeCHS
        mov     ax,MinimumSectorCountl
        mov     dx,MinimumSectorCounth
        mov     [si+11],ax
        mov     [si+13],dx
        add     ax,FreeStartl
        adc     dx,FreeStarth
        sub     ax,1
        sbb     dx,0
        add     si,4
        call    pMakeCHS                ; al = xint13 required flag
        sub     si,1                    ; ds:si -> system id byte

        ;
        ; Figure out the partition id.
        ; al is xint13 required flag
        ;
        mov     dx,PartitionClass
        mov     ah,SystemId
        call    pDetermineSystemId
        mov     [si],al                 ; store away system id

        sub     si,4                    ; ds:si -> partition table entry
        call    pNewPartitionRecord
        cmp     ax,0ffffh
        je      done1                   ; error, bail now

        ;
        ; Phew. Write out the master boot sector.
        ;
        push    ax                      ; save partition id
        push    SectorBuffer
        push    1
        push    0
        push    0
        push    DiskHandle
        call    _WriteDisk
        add     sp,14                   ; ax set for return
        pop     dx                      ; dx = partition id
        cmp     ax,0                    ; error?
        jne     @f                      ; no
        dec     ax                      ; ax = -1 for error return
        jmp     short done1
@@:     mov     ax,dx                   ; ax = partition id for return

done1:
        push    ax
        push    Table
        push    DGROUP
        pop     ds                      ; address DGROUP for crt
        call    _free
        add     sp,4
        pop     ax

done2:
        pop     di
        pop     si
        pop     bx
        pop     es
        pop     ds

        leave
        retf

_MakePartitionAtStartOfDisk endp

Comparand1 equ dword ptr [bp+6]
Comparand2 equ dword ptr [bp+10]

CompareStartSize proc far

        push    bp
        mov     bp,sp

        push    ds
        push    es
        push    di
        push    si

        lds     si,Comparand1
        les     di,Comparand2

        mov     dx,es:[di].PartStarth
        mov     ax,es:[di].PartStartl

        cmp     [si].PartStarth,dx
        jb      less1
        ja      greater1

        cmp     [si].PartStartl,ax
        jb      less1
        ja      greater1

        xor     ax,ax
        jmp     short compdone

less1:
        mov     ax,0ffffh
        jmp     short compdone

greater1:
        mov     ax,1

compdone:
        pop     si
        pop     di
        pop     es
        pop     ds

        leave
        retf

CompareStartSize endp


;++
;
; INT
; _far
; MakePartitionAtEndOfEmptyDisk(
;       IN  HDISK  DiskHandle,
;       OUT FPVOID SectorBuffer,
;       IN  ULONG  MinimumSectorCount,
;       IN  BOOL   NewMasterBootCode
;       );
;
; Routine Description:
;
;       This routine creates an partition at the very end of a disk.
;       The disk MUST be completely empty. If no valid MBR exists,
;       one will be created.
;
;       The partition will be made active.
;
; Arguments:
;
;       DiskHandle - supplies handle to open disk, from OpenDisk().
;
;       SectorBuffer - supplies a pointer to a buffer suitable for use
;               for i/o of a single sector. This buffer must not
;               cross a DMA boundary, but the caller is responsible
;               for ensuring this.
;
;       MinimumSectorCount - supplies minimum number of sectors
;               for the partition. The actual size may be larger
;               to account for rounding, etc.
;
;               This routine does NOT properly deal with partitions
;               that start on cylinder 0 or are larger than the size
;               of the disk! The caller must ensure that these cases
;               do not occur.
;
;       NewMasterBootCode - if non-0, then new master boot code will
;               be written regardless of the current state of the MBR.
;
; Return Value:
;
;       Partition id of newly created partition.
;       -1 means failure
;
;--

DiskHandle          equ dword ptr [bp+6]
DiskHandlel         equ word  ptr [bp+6]
DiskHandleh         equ word  ptr [bp+8]
SectorBuffer        equ dword ptr [bp+10]
SectorBufferl       equ word  ptr [bp+10]
SectorBufferh       equ word  ptr [bp+12]
MinimumSectorCount  equ dword ptr [bp+14]
MinimumSectorCountl equ word  ptr [bp+14]
MinimumSectorCounth equ word  ptr [bp+16]
NewMasterBootCode   equ word  ptr [bp+18]

ExtSecCnth          equ word  ptr [bp-2]
ExtSecCntl          equ word  ptr [bp-4]
ExtSecCnt           equ dword ptr [bp-4]
Cylinders           equ word  ptr [bp-6]
Heads               equ word  ptr [bp-8]
SectorsPerTrack     equ byte  ptr [bp-9]
Int13UnitNumber     equ byte  ptr [bp-10]
SectorsPerCylinder  equ word  ptr [bp-12]
DiskSizeh           equ word  ptr [bp-14]
DiskSizel           equ word  ptr [bp-16]
DiskSize            equ dword ptr [bp-16]
DiskId              equ word  ptr [bp-18]

        public _MakePartitionAtEndOfEmptyDisk
_MakePartitionAtEndOfEmptyDisk proc far

        push    bp
        mov     bp,sp
        sub     sp,18

        push    ds
        push    es
        push    bx
        push    si
        push    di

        ;
        ; Get disk info. This also makes sure the handle is open,
        ; calculates the number of sectors we can address on the disk,
        ; and the number of sectors in a cylinder.
        ;
        call    near ptr pGetDiskValues
        jnc     @f
        mov     ax,0ffffh
        jc      mpaod_4

@@:
        ;
        ; Read the mbr.
        ;
        push    SectorBuffer
        push    1
        push    0
        push    0
        push    DiskHandle
        call    _ReadDisk
        add     sp,14
        cmp     ax,0
        jne     @f
        dec     ax                      ; ax = -1 for error return
        jmp     mpaod_4

        ;
        ; Check the mbr. If not valid, make it valid.
        ;
@@:     les     di,SectorBuffer
        cmp     NewMasterBootCode,0
        jnz     makembr                 ; caller wants new master boot code
        cmp     byte ptr es:[di+510],055h
        jne     makembr
        cmp     byte ptr es:[di+511],0aah
        je      mbrok
makembr:
        mov     byte ptr es:[di+510],055h
        mov     byte ptr es:[di+511],0aah
        mov     si,offset DGROUP:_x86BootCode
        mov     cx,1b8h/2               ; don't overwrite NTFT sig or table
        rep     movsw

mbrok:
        ;
        ; Make sure all entries are empty.
        ;
        lds     si,SectorBuffer
        add     si,1beh
        mov     cx,0
        mov     ax,cx
        dec     ax                      ; ax = -1
        cmp     [si+04h],cl
        jnz     mpaod_4
        cmp     [si+14h],cl
        jnz     mpaod_4
        cmp     [si+24h],cl
        jnz     mpaod_4
        cmp     [si+34h],cl
        jnz     mpaod_4

        ;
        ; Calculate the starting sector. We don't worry about aligning
        ; the end sector because in the conventional int13 case we
        ; calculated the disk size based on cylinder count, which means
        ; it is guaranteed to be aligned; in the xint13 case CHS isn't
        ; even relevent and in any case there won't be any partitions
        ; on the disk after this one.
        ;
        mov     ax,DiskSizel
        sub     ax,MinimumSectorCountl
        mov     dx,DiskSizeh
        sbb     dx,MinimumSectorCounth  ; dx:ax = start sector of partition
        mov     [si+8],ax
        mov     [si+10],dx              ; save in partition table
        div     SectorsPerCylinder      ; ax = cyl, dx = sector within cyl
        sub     [si+8],dx               ; note: dx is zero if already aligned
        sbb     [si+10],cx              ; partition table has aligned start
        mov     ax,MinimumSectorCountl
        add     ax,dx                   ; grow to account for alignment
        mov     [si+12],ax
        mov     ax,MinimumSectorCounth
        adc     ax,cx
        mov     [si+14],ax              ; put adjusted size in partition table

        ;
        ; Make the partition active.
        ;
        mov     byte ptr [si],80h

        ;
        ; Fill in CHS values for the partition
        ;
        mov     ax,[si+8]
        mov     dx,[si+10]              ; dx:ax = start sector
        inc     si                      ; ds:si -> start CHS in part table
        call    pMakeCHS
        mov     ax,[si+7]
        add     ax,[si+11]
        mov     dx,[si+9]
        adc     dx,[si+13]
        sub     ax,1
        sbb     dx,0                    ; dx:ax = last sector
        add     si,4                    ; ds:si -> end CHS in part table
        call    pMakeCHS                ; al = overflow flag

        ;
        ; Figure out the system id.
        ; al is xint13 required flag
        ;
        mov     dx,PARTCLASS_FAT
        call    pDetermineSystemId
        mov     [si-1],al               ; store away system id

        ;
        ; Build a partition record for this guy and add to list.
        ;
        sub     si,5                    ; ds:si -> partition table entry
        call    pNewPartitionRecord
        cmp     ax,0ffffh
        je      mpaod_4                 ; error, ax set for return

        ;
        ; The mbr is ready, write it out.
        ;
        push    ax
        push    SectorBuffer
        push    1
        push    0
        push    0
        push    DiskHandle
        call    _WriteDisk
        add     sp,14
        mov     dx,ax
        pop     ax                      ; ax = partition id
        cmp     dx,0                    ; write error?
        jnz     mpaod_4                 ; no, ax = partition id for exit
        mov     ax,0ffffh               ; set ax for error return

mpaod_4:
        pop     di
        pop     si
        pop     bx
        pop     es
        pop     ds

        leave
        retf

_MakePartitionAtEndOfEmptyDisk endp


;++
;
; INT
; _far
; ReinitializePartitionTable(
;       IN  HDISK  DiskHandle,
;       OUT FPVOID SectorBuffer
;       );
;
; Routine Description:
;
;       This routine wipes a disk completely clean by clearning
;       the partition table and writing new boot code.
;
;       NOTE: after this routine, partition ids may change!
;
; Arguments:
;
;       DiskHandle - supplies handle to open disk, from OpenDisk().
;
;       SectorBuffer - supplies a pointer to a buffer suitable for use
;               for i/o of a single sector. This buffer must not
;               cross a DMA boundary, but the caller is responsible
;               for ensuring this.
;
; Return Value:
;
;       The new number of total partitions, -1 if error
;
;--

DiskHandle          equ dword ptr [bp+6]
SectorBuffer        equ dword ptr [bp+10]

        public _ReinitializePartitionTable
_ReinitializePartitionTable proc far

        push    bp
        mov     bp,sp

        push    ds
        push    es
        push    si
        push    di
        pushf

        ;
        ; This is very simple. Move template boot code
        ; into the sector buffer and write it out.
        ;
        les     di,SectorBuffer
        push    DGROUP
        pop     ds
        mov     si,OFFSET DGROUP:_x86BootCode
        mov     cx,512/2

        cld
        rep     movsw

        push    SectorBuffer
        push    1
        push    0
        push    0
        push    DiskHandle
        call    _WriteDisk
        add     sp,14
        cmp     ax,0
        jnz     rpt2
        dec     ax                      ; ax = -1 for return
        jmp     short rpt8

        ;
        ; Now go through the partition list, removing all entries that were
        ; on this disk.
        ;
rpt2:
        les     di,DiskHandle
        mov     bx,es:[di].DiskInfoDiskId       ; bx = id of disk we're wiping
        mov     dx,[PartitionListCount]
        mov     si,OFFSET DGROUP:PartitionList  ; ds:si = &PartitionList
        .errnz  PartInfoNext

rpt3:
        mov     cx,[si].PartInfoNextl
        or      cx,[si].PartInfoNexth
        jz      rpt5                    ; done
        les     di,[si].PartInfoNext    ; es:di -> current, ds:si -> prev
        cmp     es:[di].PartInfoDiskId,bx ; partition on disk we wiped?
        jne     rpt4                    ; no

        dec     dx                      ; one fewer total partitions

        mov     ax,es:[di].PartInfoNextl
        mov     [si].PartInfoNextl,ax
        mov     ax,es:[di].PartInfoNexth
        mov     [si].PartInfoNexth,ax   ; prev->next = current->next

        push    bx
        push    ds
        push    DGROUP
        pop     ds                      ; make sure we're addressing DGROUP
        push    es
        push    di
        call    _free                   ; free(current)
        add     sp,4
        pop     ds
        pop     bx                      ; restore disk id

        jmp     short rpt3

rpt4:   mov     ax,es
        mov     ds,ax
        mov     si,di                   ; prev = current
        jmp     short rpt3

rpt5:
        push    DGROUP
        pop     ds
        mov     [PartitionListCount],dx ; save new count
        mov     ax,dx                   ; ax = return value

        ;
        ; Now reassign partition ids so they are contiguous.
        ;
        mov     si,OFFSET DGROUP:PartitionList
rpt6:   mov     cx,[si].PartInfoNextl
        or      cx,[si].PartInfoNexth
        jz      rpt8
        dec     dx
        lds     si,[si].PartInfoNext
        mov     [si].PartInfoDiskId,dx
        jmp     short rpt6

rpt8:
        popf
        pop     di
        pop     si
        pop     es
        pop     ds

        leave
        retf

_ReinitializePartitionTable endp



;
; dx:ax = sector to translate
; ds:si -> CHS bytes
;
pMakeCHS proc near

        div     SectorsPerCylinder      ; ax = cylinder, dx = sector in cyl

        cmp     ax,Cylinders            ; overflow?
        jb      chsok                   ; no, continue

        push    1                       ; overflow flag
        mov     ax,Cylinders
        dec     ax                      ; store max cylinder in table
        jmp     short chs1

chsok:
        push    0                       ; no overflow flag
chs1:   mov     cx,ax
        xchg    cl,ch
        shl     cl,6

        ;
        ; small divide is acceptable here since head is 1-255, sector is
        ; 1-63 (and thus max sector within cyl is (63*256)-1).
        ;
        mov     ax,dx
        div     SectorsPerTrack         ; al = head, ah = sector
        inc     ah                      ; sector is 1-based
        or      cl,ah                   ; cx has cyl/sector in int13 format

storechs:
        mov     [si+1],cx               ; store in partition table entry
        mov     [si],al                 ; store head in partition table entry

        pop     ax                      ; return overflow flag
        ret

pMakeCHS endp


;
; ds:si -> partition table entry with lba and sysid fields filled in
; preserves none
; returns new part ordinal or -1
;
pNewPartitionRecord proc near

        ;
        ; Allocate a new partition record
        ;
        push    ds
        push    si
        push    DGROUP
        pop     ds
        mov     si,OFFSET DGROUP:PartitionListCount
        push    [si]                    ; save count for later
        inc     word ptr [si]
        push    SIZE PART_INFO
        call    _malloc
        add     sp,2
        pop     bx                      ; restore partition count
        pop     si
        pop     ds                      ; ds:si -> partition table entry
        mov     cx,ax
        or      cx,dx
        jnz     @f                      ; malloc ok
        mov     ax,0ffffh
        jz      npr_done                ; return failure

@@:     push    bx
        mov     cx,DGROUP
        mov     es,cx
        mov     di,OFFSET DGROUP:PartitionList ; es:di = &PartitionList

        .errnz PartInfoNext
        mov     cx,es:[di]              ; get current head of list in bx:cx
        mov     bx,es:[di+2]

        mov     es:[di],ax
        mov     es:[di+2],dx            ; insert new record at head of list

        mov     es,dx
        mov     di,ax                   ; es:di -> new record
        mov     es:[di].PartInfoNextl,cx
        mov     es:[di].PartInfoNexth,bx

        mov     ax,DiskId
        mov     es:[di].PartInfoDiskId,ax
        pop     ax                      ; partition ordinal, also return val
        mov     es:[di].PartInfoOrdinal,ax
        mov     cx,[si+8]
        mov     es:[di].PartInfoStartSectorl,cx
        mov     cx,[si+10]
        mov     es:[di].PartInfoStartSectorh,cx
        mov     cx,[si+12]
        mov     es:[di].PartInfoSectorCountl,cx
        mov     cx,[si+14]
        mov     es:[di].PartInfoSectorCounth,cx
        mov     cl,[si+4]
        mov     es:[di].PartInfoSystemId,cl

        ;
        ; Indicate partition not open
        ;
        mov     es:[di].PartInfoPartOpen,0
        mov     es:[di].PartInfoDiskHandlel,0
        mov     es:[di].PartInfoDiskHandleh,0

npr_done:
        ret

pNewPartitionRecord endp


;
; No params, nested in top-level routines above
;
pGetDiskValues proc near

        ;
        ; Get disk info. This also makes sure the handle is open.
        ;
        push    ss
        lea     bx,DiskId
        push    bx
        push    ss
        lea     bx,ExtSecCnt
        push    bx
        push    ss
        lea     bx,Cylinders
        push    bx
        push    ss
        lea     bx,Heads
        push    bx
        push    ss
        lea     bx,SectorsPerTrack
        push    bx
        push    ss
        lea     bx,Int13UnitNumber
        push    bx
        push    DiskHandle
        call    _GetDiskInfoByHandle
        add     sp,28
        cmp     ax,0
        jnz     @f
        stc
        ret

        ;
        ; Calculate the number of sectors we can address on the disk.
        ; Also precalculate the number of sectors in a cylinder.
        ;
@@:     mov     al,SectorsPerTrack
        cbw
        mul     Heads                   ; ax = sectors per cylinder, dx = 0
        mov     SectorsPerCylinder,ax
        cmp     ExtSecCntl,dx
        jnz     usexcnt
        cmp     ExtSecCnth,dx
        jnz     usexcnt
        mul     Cylinders               ; dx:ax = sectors on disk
        jmp     short storsize
usexcnt:
        mov     dx,ExtSecCnth
        mov     ax,ExtSecCntl
storsize:
        mov     DiskSizeh,dx
        mov     DiskSizel,ax
        clc
gv3:    ret

pGetDiskValues endp


;
; No params, nested in top-level routines above
; al = xint13 required flag
; dx = partition class
; ah = sysid if unknown class
;
; returns system id in al
;
pDetermineSystemId proc near

        cmp     dx,PARTCLASS_FAT
        jne     tryfat32
        cmp     al,0
        je      @f
        mov     al,0eh                  ; type e = fat xint13
        jmp     short gotsysid
@@:     cmp     MinimumSectorCounth,0
        jne     bigfat
        cmp     MinimumSectorCountl,32680
        jb      fat12
        mov     al,4                    ; type 4 = fat16
        jmp     short gotsysid
fat12:  mov     al,1                    ; type 1 = fat12
        jmp     short gotsysid
bigfat: mov     al,6                    ; type 6 = huge fat
        jmp     short gotsysid

tryfat32:
        cmp     dx,PARTCLASS_FAT32
        jne     tryntfs
        cmp     al,0
        jne     @f
        mov     al,0bh                  ; type b = fat32 non-xint13
        jmp     short gotsysid
@@:     mov     al,0ch                  ; type c = fat32 xint13
        jmp     short gotsysid

tryntfs:
        cmp     dx,PARTCLASS_NTFS
        jne     othersys
        mov     al,7                    ; type 7 = ntfs
        jmp     short gotsysid

othersys:
        mov     al,ah

gotsysid:
        ret

pDetermineSystemId endp

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\mpk\makemast\applyimg.c ===
#include <mytypes.h>
#include <diskio.h>
#include <misclib.h>
#include <makepart.h>
#include <partimag.h>
#include <msgfile.h>

#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include <dos.h>
#include <share.h>
#include <string.h>

#include "makemast.h"


PARTITION_IMAGE PartitionImage;
ULONG TotalSectorsToTransfer;
ULONG TotalSectorsDone;

BOOL
TransferNonClusterData(
    IN HDISK    DiskHandle,
    IN unsigned FileHandle,
    IN ULONG    TargetStart
    );

BOOL
ExpandClusters(
    IN HDISK    DiskHandle,
    IN unsigned FileHandle,
    IN ULONG    TargetStart
    );

BOOL
InitializeClusterMap(
    IN unsigned FileHandle
    );

BOOL
GetClusterRun(
    IN  unsigned  FileHandle,
    OUT ULONG    *StartCluster,
    OUT ULONG    *ClusterCount
    );


BOOL
ApplyImage(
    IN HDISK  DiskHandle,
    IN ULONG  TargetStart,
    IN ULONG  MaxSize,
    IN BYTE   SectorsPerTrack,
    IN USHORT Heads
    )
{
    unsigned FileHandle;
    unsigned Read;

    printf("\n");
    printf(textTransferringFile,CmdLineArgs.ImageFile,0);
    printf("\r");

    //
    // Open the source file, read the image header, and validate it.
    //
    if(_dos_open(CmdLineArgs.ImageFile,SH_DENYWR,&FileHandle)) {
        fprintf(stderr,"\n%s\n",textCantAccessImageFile);
        return(FALSE);
    }

    if(_dos_read(FileHandle,&PartitionImage,sizeof(PARTITION_IMAGE),&Read)
    || (Read != sizeof(PARTITION_IMAGE))
    || (PartitionImage.Signature != PARTITION_IMAGE_SIGNATURE)
    || (PartitionImage.Size != sizeof(PARTITION_IMAGE))) {

        _dos_close(FileHandle);
        fprintf(stderr,"\n%s\n",textInvalidImageFile);
        return(FALSE);
    }

    //
    // Make sure we've got the space.
    //
    if(PartitionImage.TotalSectorCount > MaxSize) {

        _dos_close(FileHandle);
        fprintf(stderr,"\n");
        fprintf(stderr,textImageFileTooBig,PartitionImage.TotalSectorCount,MaxSize);
        fprintf(stderr,"\n");
        return(FALSE);
    }

    TotalSectorsToTransfer = PartitionImage.NonClusterSectors
                           + (PartitionImage.SectorsPerCluster*PartitionImage.UsedClusterCount);

    TotalSectorsDone = 0;

    //
    // Transfer non-cluster data from the image.
    //
    if(!TransferNonClusterData(DiskHandle,FileHandle,TargetStart)) {
        _dos_close(FileHandle);
        return(FALSE);
    }

    //
    // Expand out cluster data from the image.
    //
    if(!ExpandClusters(DiskHandle,FileHandle,TargetStart)) {
        _dos_close(FileHandle);
        return(FALSE);
    }

    //
    // Fix up BPB.
    //
    if(!ReadDisk(DiskHandle,TargetStart,1,IoBuffer)) {
        _dos_close(FileHandle);
        fprintf(stderr,"\n");
        fprintf(stderr,textDiskReadError,TargetStart);
        fprintf(stderr,"\n");
        return(FALSE);
    }

    *(FPUSHORT)&((FPBYTE)IoBuffer)[24] = SectorsPerTrack;
    *(FPUSHORT)&((FPBYTE)IoBuffer)[26] = Heads;
    *(FPULONG)&((FPBYTE)IoBuffer)[28] = TargetStart;

    if(!WriteDisk(DiskHandle,TargetStart,1,IoBuffer)) {
        _dos_close(FileHandle);
        fprintf(stderr,"\n");
        fprintf(stderr,textDiskWriteError,TargetStart);
        fprintf(stderr,"\n");
        return(FALSE);
    }

    _dos_close(FileHandle);
    return(TRUE);
}


BOOL
TransferNonClusterData(
    IN HDISK    DiskHandle,
    IN unsigned FileHandle,
    IN ULONG    TargetStart
    )
{
    ULONG NonClusterSectorsDone;
    ULONG Count;
    unsigned Read;

    //
    // Seek past partition image header
    //
    if(DosSeek(FileHandle,512,DOSSEEK_START) != 512) {
        fprintf(stderr,"\n%s\n",textCantAccessImageFile);
        return(FALSE);
    }

    //
    // Now transfer the non-cluster data
    //
    NonClusterSectorsDone = 0;
    while(NonClusterSectorsDone < PartitionImage.NonClusterSectors) {

        Count = PartitionImage.NonClusterSectors - NonClusterSectorsDone;
        if(Count > 63) {
            Count = 63;
        }

        if(_dos_read(FileHandle,IoBuffer,(unsigned)Count*512,&Read) || (Read != ((unsigned)Count*512))) {
            fprintf(stderr,"\n%s\n",textCantAccessImageFile);
            return(FALSE);
        }

        if(!WriteDisk(DiskHandle,TargetStart,(BYTE)Count,IoBuffer)) {
            fprintf(stderr,"\n");
            fprintf(stderr,textDiskWriteError,TargetStart);
            fprintf(stderr,"\n");
            return(FALSE);
        }

        TargetStart += Count;
        NonClusterSectorsDone += Count;
        TotalSectorsDone += Count;

        printf(textTransferringFile,CmdLineArgs.ImageFile,100*TotalSectorsDone/TotalSectorsToTransfer);
        printf("\r");
    }

    return(TRUE);
}


BOOL
ExpandClusters(
    IN HDISK    DiskHandle,
    IN unsigned FileHandle,
    IN ULONG    TargetStart
    )
{
    ULONG Start,Count;
    ULONG TargetSector;
    BYTE u;
    unsigned Read;

    if(!InitializeClusterMap(FileHandle)) {
        return(FALSE);
    }

    //
    // Seek to start of cluster data in input file.
    //
    Start = (1 + PartitionImage.NonClusterSectors) * 512;
    if(DosSeek(FileHandle,Start,DOSSEEK_START) != Start) {
        fprintf(stderr,"\n%s\n",textCantAccessImageFile);
        return(FALSE);
    }

    //
    // Get a run of clusters. If there are no more clusters left, we're done.
    //
    nextrun:
    if(!GetClusterRun(FileHandle,&Start,&Count)) {
        return(FALSE);
    }
    if(!Count) {
        return(TRUE);
    }
    Count *= PartitionImage.SectorsPerCluster;

    //
    // Calculate the offset of the data in the source file and
    // the starting sector number of the target.
    //
    TargetSector = TargetStart + PartitionImage.NonClusterSectors + (Start*PartitionImage.SectorsPerCluster);

    while(Count) {

        u = (BYTE)((Count > 63L) ? 63L : Count);

        if(_dos_read(FileHandle,IoBuffer,u*512U,&Read) || (Read != (u*512U))) {

            fprintf(stderr,"\n%s\n",textCantAccessImageFile);
            return(FALSE);
        }

        if(!WriteDisk(DiskHandle,TargetSector,u,IoBuffer)) {
            fprintf(stderr,"\n");
            fprintf(stderr,textDiskWriteError,TargetSector);
            fprintf(stderr,"\n");
            return(FALSE);
        }

        TargetSector += u;
        Count -= u;

        TotalSectorsDone += u;

        printf(textTransferringFile,CmdLineArgs.ImageFile,100*TotalSectorsDone/TotalSectorsToTransfer);
        printf("\r");
    }

    //
    // Process additional clusters.
    //
    goto nextrun;
}

////////////////////////////////////////////////////

ULONG _ClusterSectorFileOffset;
ULONG _NextClusterToExamine;
ULONG _ClusterBufferBase;
BYTE _ClusterBuffer[512];

extern BYTE BitValue[8];


BOOL
InitializeClusterMap(
    IN unsigned FileHandle
    )
{
    unsigned read;

    //
    // Figure out where in the file the cluster bitmap starts.
    //
    _ClusterSectorFileOffset = PartitionImage.NonClusterSectors
                             + (PartitionImage.UsedClusterCount * PartitionImage.SectorsPerCluster)
                             + 1;

    _ClusterSectorFileOffset *= 512;

    //
    // Read the first sector of the cluster bitmap. Read into IoBuffer to avoid
    // DMA boundary issues.
    //
    if((DosSeek(FileHandle,_ClusterSectorFileOffset,DOSSEEK_START) != _ClusterSectorFileOffset)
    || _dos_read(FileHandle,IoBuffer,512,&read) || (read != 512)) {

        fprintf(stderr,"\n%s\n",textCantAccessImageFile);
        return(FALSE);
    }
    memmove(_ClusterBuffer,IoBuffer,512);

    _NextClusterToExamine = 0;
    _ClusterBufferBase = 0;
    return(TRUE);
}


BOOL
GetClusterRun(
    IN  unsigned  FileHandle,
    OUT ULONG    *StartCluster,
    OUT ULONG    *ClusterCount
    )
{
    ULONG Offset;
    UINT cluster;
    BOOL b;

    *ClusterCount = 0;

    //
    // Locate the next 1 bit in the map.
    //
    while(_NextClusterToExamine <= PartitionImage.LastUsedCluster) {

        //
        // Reload the cluster buffer if necessary. Preserve file pointer!
        //
        if(_NextClusterToExamine && !(_NextClusterToExamine % (8*512))) {

            _ClusterSectorFileOffset += 512;

            if(((Offset = DosSeek(FileHandle,0,DOSSEEK_CURRENT)) == (ULONG)(-1))
            || (DosSeek(FileHandle,_ClusterSectorFileOffset,DOSSEEK_START) != _ClusterSectorFileOffset)
            || _dos_read(FileHandle,IoBuffer,512,&cluster)
            || (cluster != 512)
            || (DosSeek(FileHandle,Offset,DOSSEEK_START) != Offset)) {

                fprintf(stderr,"\n%s\n",textCantAccessImageFile);
                return(FALSE);
            }

            memmove(_ClusterBuffer,IoBuffer,512);

            _ClusterBufferBase += 8*512;
        }

        cluster = (UINT)(_NextClusterToExamine - _ClusterBufferBase);

        //
        // See if this bit is one, which starts a run of used clusters.
        // To simplify things, we won't return a run that spans sectors
        // in the cluster bitmap.
        //
        b = FALSE;

        while((_ClusterBuffer[cluster/8] & BitValue[cluster%8])
        && (cluster < (8*512))
        && (_NextClusterToExamine <= PartitionImage.LastUsedCluster)) {

            if(!b) {
                *StartCluster = _NextClusterToExamine;
                b = TRUE;
            }

            *ClusterCount += 1;
            cluster++;
            _NextClusterToExamine++;
        }

        if(b) {
            return(TRUE);
        }

        _NextClusterToExamine++;
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\mpk\iolib\i13disk.asm ===
DOSSEG
        .MODEL LARGE

include disk.inc

;
; Disk record structure specific to int13-visible disks.
;
INT13_DISK_INFO STRUC
    ;
    ; First part is a DiskInfo structure
    ;
    DiskInfo               db SIZE DISK_INFO DUP (?)

    ;
    ; Int13 unit number and drive geometry for drive.
    ;
    Int13DiskUnit          db ?
    Int13SectorsPerTrack   db ?
    Int13Heads             dw ?
    Int13Cylinders         dw ?
    Int13xSectorCountl     dw ?
    Int13xSectorCounth     dw ?

INT13_DISK_INFO ENDS


        .DATA?
        extrn DiskList:dword

        ;
        ; Table of drives for which xint13 is disabled
        ; 128 units at 1 bit each = 128 bits = 16 bytes = 8 words
        ;
        ; We support this solely by returning a zero
        ; extended sector count from pGetExtendedInt13SectorCount;
        ; this forces everyone else into regular int13 mode.
        ;
        xInt13DisableTable db 16 dup (?)

        .CODE
        ASSUME ds:NOTHING

        extrn _malloc:far

.386

;++
;
; UINT
; _far
; InitializeInt13DiskList(
;     IN UINT FirstDiskId
;     );
;
; Routine Description:
;
;       This routine determines the number of int13 disk units and
;       gathers information about each, which is saved in a structure.
;       The structures are stored in a linked list whose head is
;       the DiskList global variable.
;
; Arguments:
;
;       FirstDiskId - supplies the id to be used for the first disk.
;
; Return Value:
;
;       non-0 - success
;       0 - failure
;
;--

FirstDiskId equ word ptr [bp+6]

        public InitializeInt13DiskList
InitializeInt13DiskList proc far

        push    bp
        mov     bp,sp

        push    ds
        push    es
        push    bx
        push    si
        push    di

        mov     ah,8
        mov     dl,80h
        int     13h
        jnc     @f
        xor     dl,dl
@@:     or      dl,80h
        xor     dh,dh
        mov     di,dx                   ; di = int13 disk limit
        mov     si,80h                  ; si = current int13 disk

nextdisk:
        cmp     si,di
        je      ildoneok                ; no more disks

        push    ds
        push    DGROUP
        pop     ds                      ; crt needs ds to address _DATA
        push    SIZE INT13_DISK_INFO
        call    _malloc
        add     sp,2
        pop     ds
        mov     cx,ax
        or      cx,dx
        jz      ildone                  ; ax already 0 for error return

        push    ax
        push    dx                      ; save disk record pointer
        push    si                      ; save current int13 unit #
        push    di                      ; save int13 unit # limit

        mov     dx,si                   ; dl = int13 unit #
        mov     ah,8
        int     13h
        pop     di                      ; di = int13 disk limit
        pop     bx                      ; bl = int13 unit #, bh = 0
        pop     ds
        pop     si                      ; ds:si -> new disk record
        jnc     @f
        mov     ax,0
        jmp     short ildone

        ;
        ; Store int13 unit number in disk record.
        ; Also generate a disk id.
        ;
@@:     mov     ax,bx
        sub     ax,80h
        add     ax,FirstDiskId
        mov     [si].DiskInfo.DiskInfoDiskId,ax
        mov     [si].DiskInfo.DiskInfoDiskOpen,bh ; bh=0, set disk not open
        mov     [si].Int13DiskUnit,bl

        ;
        ; Max head is in in dh, convert to count in dx
        ;
        shr     dx,8
        inc     dx
        mov     [si].Int13Heads,dx

        ;
        ; Deal with sectors per track in cl
        ;
        mov     al,cl
        and     al,3fh
        mov     [si].Int13SectorsPerTrack,al

        ;
        ; Deal with cylinder count wierdness
        ;
        xchg    ch,cl
        shr     ch,6
        inc     cx
        mov     [si].Int13Cylinders,cx

        ;
        ; Fetch extended int13 count. Comes back as 0 if xint13
        ; not supported for the drive.
        ;
        push    bx
        call    far ptr pGetExtendedInt13SectorCount
        pop     cx                      ; cl = int13 unit#, ch = 0
        mov     [si].Int13xSectorCountl,ax
        mov     [si].Int13xSectorCounth,dx

        ;
        ; Now link the disk record into the linked list.
        ;
        mov     dx,di                   ; dx = int13 unit # limit

        mov     ax,DGROUP
        mov     es,ax
        mov     di,OFFSET DGROUP:DiskList ; es:di = &DiskList

        mov     ax,es:[di]
        mov     [si].DiskInfo.DiskInfoNextl,ax
        mov     ax,es:[di+2]
        mov     [si].DiskInfo.DiskInfoNexth,ax

        mov     es:[di],si
        mov     ax,ds
        mov     es:[di+2],ax

        mov     di,dx                   ; di = int13 unit # limit
        mov     si,cx                   ; si = int13 unit #
        inc     si
        jmp     nextdisk

ildoneok:
        mov     ax,si
        sub     ax,80h                  ; ax = int13 disk count

ildone:
        pop     di
        pop     si
        pop     bx
        pop     es
        pop     ds
        leave
        retf

InitializeInt13DiskList endp


;++
;
; BOOL
; _far
; OpenInt13Disk(
;     IN FPINT13_DISK_INFO DiskRecord
;     );
;
; Routine Description:
;
;       This routine "opens" an int13 disk.
;       Housekeeping such as locking, etc, is performed.
;
;       It is assumed that a disk can be opened only once at a time,
;       but the caller is responsible for enforcing this.
;
; Arguments:
;
;       DiskRecord - supplies a far pointer to the disk record struct
;               for the disk to be opened.
;
; Return Value:
;
;       non-0 - success
;       0 - failure
;
;--

DiskRecord equ dword ptr [bp+6]

        public OpenInt13Disk
OpenInt13Disk proc far

        ;
        ; BUGBUG perform locking for OSR2
        ;
        mov     ax,1
        retf

OpenInt13Disk endp


;++
;
; VOID
; _far
; CloseInt13Disk(
;     IN FPINT13_DISK_INFO DiskRecord
;     );
;
; Routine Description:
;
;       This routine "closes" an int13 disk previously opened with
;       OpenInt13Disk. Housekeeping such as locking, etc, is performed.
;
; Arguments:
;
;       DiskRecord - supplies a far pointer to the disk record struct
;               for the disk to be closed.
;
; Return Value:
;
;       None.
;
;--

DiskRecord equ dword ptr [bp+6]

        public CloseInt13Disk
CloseInt13Disk proc far

        ;
        ; BUGBUG perform unlocking for OSR2
        ;
        retf

CloseInt13Disk endp


;
; BOOL
; _far
; pInt13Read(
;     IN  FPINT13_DISK_INFO DiskRecord,
;     IN  ULONG             StartSector,
;     IN  BYTE              SectorCount,
;     OUT FPVOID            Buffer
;     );
;
; BOOL
; _far
; pInt13Read(
;     IN FPINT13_DISK_INFO DiskRecord,
;     IN ULONG             StartSector,
;     IN BYTE              SectorCount,
;     IN FPVOID            Buffer
;     );
;

DiskRecord   equ dword ptr [bp+6]
StartSectorl equ word  ptr [bp+10]
StartSectorh equ word  ptr [bp+12]
SectorCount  equ byte  ptr [bp+14]
Buffer       equ dword ptr [bp+16]

        public pInt13Read
pInt13Read label far

        mov     ah,2
        jmp     short pInt13IO

        public pInt13Write
pInt13Write label far

        mov     ah,3

pInt13IO proc far

        push    bp
        mov     bp,sp

        push    ds
        push    es
        push    bx
        push    si
        push    di

        push    ax

        lds     si,DiskRecord

        ;
        ; Calculate sectors per cylinder, which is a max of 63*256 = 16128,
        ; which fits in a word register. But we do a full 32-bit multiply,
        ; because the heads count could be 256 (which doesn't fit in al).
        ;
        mov     al,[si].Int13SectorsPerTrack
        cbw                                     ; ax = sectors per track
        mul     [si].Int13Heads                 ; ax = sectors per cylinder

        mov     bx,ax                           ; bx = sectors per cylinder
        mov     dx,StartSectorh
        mov     ax,StartSectorl                 ; dx:ax = start sector
        div     bx                              ; ax = cyl, dx = sector in cyl

        ;
        ; Set up the cylinder in cx in int13 format:
        ;
        ;       ch = bits 0-7 of the cylinder
        ;       bits 6,7 of cl = bits 8,9 of the cylinder
        ;
        mov     cx,ax
        xchg    cl,ch
        shl     cl,6

        ;
        ; Now calculate the head and sector. The head is max 255
        ; and the sector is max 62, meaning we can do a 16-bit divide.
        ;
        mov     ax,dx                           ; ax = sector within cylinder
        div     [si].Int13SectorsPerTrack       ; al = head, ah = sector

        ;
        ; Pack everything into int13 format.
        ;
        inc     ah                              ; sector is 1-based (1-63)
        or      cl,ah
        mov     dh,al                           ; dh = head

        mov     dl,[si].Int13DiskUnit

        les     bx,Buffer
        pop     ax                              ; ah = operation (2 or 3)
        mov     al,SectorCount

        int     13h

        setnc   al
        cbw

        pop     di
        pop     si
        pop     bx
        pop     es
        pop     ds

        leave
        retf

pInt13IO endp


;
; BOOL
; _far
; pXInt13Read(
;     IN  FPINT13_DISK_INFO DiskRecord,
;     IN  ULONG             StartSector,
;     IN  BYTE              SectorCount,
;     OUT FPVOID            Buffer
;     );
;
; BOOL
; _far
; pXInt13Read(
;     IN FPINT13_DISK_INFO DiskRecord,
;     IN ULONG             StartSector,
;     IN BYTE              SectorCount,
;     IN FPVOID            Buffer
;     );
;

DiskRecord  equ dword ptr [bp+6]
StartSector equ dword ptr [bp+10]
SectorCount equ byte  ptr [bp+14]
Buffer      equ dword ptr [bp+16]

        public pXInt13Read
pXInt13Read label far

        mov     ah,42h
        jmp     short pXInt13IO

        public pXInt13Write
pXInt13Write label far

        mov     ax,4300h        ; need to clear bit 0 (verify flag)

pXInt13IO proc far

        push    bp
        mov     bp,sp

        push    ds
        push    es
        push    bx
        push    si
        push    di

        lds     si,DiskRecord   ; ds:si -> disk record
        mov     dl,[si].Int13DiskUnit

        push    0               ; high dword of sector # is 0
        push    0
        push    StartSector
        push    Buffer
        mov     bl,SectorCount  ; sector count
        xor     bh,bh           ; make sure high byte is 0
        push    bx
        push    16              ; packet size

        push    ss
        pop     ds
        mov     si,sp           ; ds:si -> param packet on stack

        int     13h             ; ax already set up from above

        setnc   al
        cbw                     ; ax: 0=failure, 1=success
        add     sp,16           ; get rid of param packet on stack

        pop     di
        pop     si
        pop     bx
        pop     es
        pop     ds

        leave
        retf

pXInt13IO endp


;++
;
; BOOL
; _far
; Int13DiskIo(
;     IN     FPINT13_DISK_INFO DiskRecord
;     IN     ULONG             StartSector,
;     IN     BYTE              SectorCount,
;     IN OUT FPVOID            Buffer,
;     IN     BOOL              Write
;     );
;
; Routine Description:
;
;       This routine performs disk i/o using int13 services, automatically
;       using extended int13 services if available for the drive.
;
;       This routine DOES ensure that i/o will not cross a track boundary
;       to ensure maximum compatibility with various BIOSes out there.
;
; Arguments:
;
;       DiskRecord - supplies pointer to the disk record structure for the
;               disk to be read from or written to.
;
;       StartSector - supplies the physical start sector where the transfer
;               is to start.
;
;       SectorCount - supplies the number of sectors to be transfered.
;
;       Buffer - supplies the target buffer for reads or the data for write.
;
;       Write - non-0 means write operation, 0 means read operation.
;
; Return Value:
;
;       non-0 - success
;       0 - failure
;
;--

DiskRecord      equ dword ptr [bp+6]
StartSector     equ dword ptr [bp+10]
StartSectorl    equ word  ptr [bp+10]
StartSectorh    equ word  ptr [bp+12]
SectorCount     equ byte  ptr [bp+14]
Buffer          equ dword ptr [bp+16]
Bufferl         equ word  ptr [bp+18]
Bufferh         equ word  ptr [bp+18]
Write           equ word  ptr [bp+20]

IoRoutine       equ dword ptr [bp-4]
IoRoutinel      equ word  ptr [bp-4]
IoRoutineh      equ word  ptr [bp-2]

        public Int13DiskIo
Int13DiskIo proc far

        push    bp
        mov     bp,sp
        sub     sp,4

        push    ds
        push    es
        push    bx
        push    si
        push    di

        ;
        ; Address the disk record structure to determine
        ; which set of int13 services to use (standard or extended).
        ; We'll use extended if they are supported for the drive.
        ; Even in that case, however, we'll do i/o a track at a time
        ; to ensure maximum compatibility.
        ;
        lds     si,DiskRecord
        mov     ax,Write
        cmp     [si].Int13xSectorCountl,0
        jnz     io_xint13
        cmp     [si].Int13xSectorCounth,0
        jnz     io_xint13

        cmp     ax,1
        je      @f
        mov     dx,SEG pInt13Read
        mov     ax,OFFSET pInt13Read
        jmp     short store_io
@@:     mov     dx,SEG pInt13Write
        mov     ax,OFFSET pInt13Write
        jmp     short store_io
io_xint13:
        cmp     ax,1
        je      @f
        mov     dx,SEG pXInt13Read
        mov     ax,OFFSET pXInt13Read
        jmp     short store_io
@@:     mov     dx,SEG pXInt13Write
        mov     ax,OFFSET pXInt13Write
store_io:
        mov     IoRoutinel,ax
        mov     IoRoutineh,dx

        ;
        ; Figure out how many sectors are left in the first track.
        ; Note that this calculation can overflow, since the sector
        ; can be very large (like in the xint13 case) and thus the
        ; absolute track number can easily be > 64k. To get around this
        ; we calculate the cylinder and remainder first, and then
        ; degenerate the remainder into track and sector.
        ;
        ; Max sectors per cylinder = 63*256, which fits in a word register.
        ;
        mov     al,[si].Int13SectorsPerTrack
        cbw
        mul     [si].Int13Heads                 ; ax = sectors per cylinder
        mov     cx,ax                           ; cx = sectors per cylinder
        mov     dx,StartSectorh
        mov     ax,StartSectorl                 ; dx:ax = lba start sector
        div     cx                              ; dx = sector within cylinder
        mov     ax,dx                           ; ax = sector within cylinder
        div     [si].Int13SectorsPerTrack       ; ah = sector in track
        mov     al,[si].Int13SectorsPerTrack
        sub     al,ah                           ; al = sectors left in track
        cbw                                     ; ah = 0

nexttrack:
        cmp     al,SectorCount                  ; see if we need that many
        jbe     @f
        mov     al,SectorCount

@@:     push    Buffer
        push    ax                              ; al = count, ah = 0
        mov     di,ax                           ; save sector count
        push    StartSector
        push    ds
        push    si
        call    IoRoutine
        add     sp,14
        cmp     ax,0
        jz      iodone                          ; ax already 0 for error exit

        mov     ax,di                           ; al = #sectors we just read, ah = 0
        add     StartSectorl,ax                 ; adjust start sector
        adc     StartSectorh,0
        sub     SectorCount,al                  ; adjust sector count
        jz      iodone                          ; ax already non-0 for success return

        ;
        ; To avoid segment wraps, we'll do arithmetic on the segment
        ; instead of the offset. The maximum number of sectors per track
        ; is 3fh. Each sector is 200h bytes, which expressed as the offset
        ; to the next segment is 20h = 2^5. Thus shifting the sector count
        ; left by 5 yields a result between 20h and 7e0h, which we add
        ; to the segment of the transfer address.
        ;
        ; Note that at this point ah = 0.
        ;
        shl     ax,5
        add     Bufferh,ax

        mov     al,[si].Int13SectorsPerTrack
        cbw                                     ; ax = whole track for next read
        jmp     short nexttrack

iodone:
        pop     di
        pop     si
        pop     bx
        pop     es
        pop     ds

        leave
        retf

Int13DiskIo endp


;++
;
; ULONG
; _far
; pGetExtendedInt13SectorCount(
;     IN BYTE Int13Unit
;     );
;
; Routine Description:
;
;       This routine determines the number of sectors available on an int13
;       disk via extended int13 services.
;
; Arguments:
;
;       Int13Unit - supplies the int13 unit # for the disk.
;
; Return Value:
;
;       0 - extended int13 services not available for drive.
;       non-0 - number of sectors available for i/o via xint13 on the drive.
;
;--

Int13Unit equ byte ptr [bp+6]

pGetExtendedInt13SectorCount proc far

        push    bp
        mov     bp,sp
        sub     sp,26

        push    ds
        push    es
        push    bx
        push    si
        push    di

        ;
        ; See if xint13 is disabled for this unit.
        ;
        push    DGROUP
        pop     ds
        mov     si,OFFSET DGROUP:xInt13DisableTable
        mov     al,Int13Unit
        and     al,7fh
        cbw                             ; ah = 0
        mov     bx,ax                   ; bh = 0
        and     al,7                    ; al = bit offset within byte
        shr     bl,3                    ; bx = offset to byte
        bt      [si+bx],al              ; see if disabled bit set
        jc      notpresent              ; bit set, don't use xint13

        ;
        ; check extensions present
        ;
        mov     ah,41h
        mov     bx,55aah
        mov     dl,Int13Unit
        int     13h
        jc      notpresent
        cmp     bx,0aa55h
        jne     notpresent
        test    cx,1
        jz      notpresent

        ;
        ; now we think the extensions are present, go get
        ; extended geometry. Note that there are plenty of
        ; broken BIOSes out there that will return success to this
        ; call even though they don't really support extended int13.
        ; So we zero out the buffer ourselves first. If the BIOS
        ; doesn't fill the buffer the extended sector count will
        ; be returned as zero, which is what we want.
        ;
        mov     ax,ss
        mov     ds,ax
        mov     es,ax
        lea     di,[bp-24]              ; don't bother with first word (size)
        xor     ax,ax
        mov     cx,12                   ; 24 bytes
        cld
        rep stosw
        lea     si,[bp-26]
        mov     word ptr [si],26        ; set up size of info buffer

        mov     ah,48h
        mov     dl,Int13Unit
        int     13h
        jc      notpresent

        ;
        ; OK, everything worked, return sector count.
        ;
        mov     ax,[bp-10]
        mov     dx,[bp-8]
        jmp     short xdone

notpresent:
        xor     ax,ax
        mov     dx,ax

xdone:
        pop     di
        pop     si
        pop     bx
        pop     es
        pop     ds
        leave
        ret

pGetExtendedInt13SectorCount endp


;++
;
; VOID
; _far
; DisableExtendedInt13(
;     IN BYTE Int13Unit OPTIONAL
;     );
;
; Routine Description:
;
;       This routine disables use of extended int13 services on a particular
;       int13 disk unit, or for all int13 disk units. This works by forcing
;       the extended sector count to 0, which in a chain reaction ensures
;       that no one will ever invoke an xint13 service for that unit.
;
;       This routine MUST be called before InitializeDiskList or it will
;       have no effect!
;
; Arguments:
;
;       Int13Unit - supplies the int13 unit # on which to disable xint13.
;               (The high bit is assumed set and ignored.) If this value
;               is 0, xint13 is disabled for all drives.
;
; Return Value:
;
;       None.
;
;--

Int13Unit equ byte ptr [bp+6]

        public _DisableExtendedInt13
_DisableExtendedInt13 proc far

        push    bp
        mov     bp,sp

        push    es
        push    bx
        push    di

        ;
        ; Address the xint13 disabled list table.
        ;
        push    DGROUP
        pop     es
        mov     di,OFFSET DGROUP:xInt13DisableTable

        ;
        ; See if we're supposed to disable for all disks.
        ;
        mov     al,Int13Unit
        cmp     al,0
        jz      allunits

        ;
        ; One unit only, take care of it here.
        ;
        and     al,7fh
        cbw                             ; ah = 0
        mov     bx,ax                   ; bh = 0
        and     al,7                    ; al = bit offset within byte
        shr     bl,3                    ; bx = offset to byte
        bts     es:[di+bx],al
        jmp     dxidone

allunits:
        ;
        ; Set all bits in the table to 1
        ;
        cbw                             ; ax = 0
        dec     ax                      ; ax = ff
        mov     cx,8                    ; 8 words = 16 bytes = 128 bits
        cld
        rep stosw

dxidone:
        pop     di
        pop     bx
        pop     es
        leave
        ret

_DisableExtendedInt13 endp


;++
;
; VOID
; _far
; GetInt13DiskInfo(
;       IN  FPINT13_DISK_INFO DiskRecord,
;       OUT FPBYTE            Int13UnitNumber,
;       OUT FPBYTE            SectorsPerTrack,
;       OUT FPUSHORT          Heads,
;       OUT FPUSHORT          Cylinders,
;       OUT FPULONG           ExtendedSectorCount
;       );
;
; Routine Description:
;
;       These routines fetches information about a disk.
;
; Arguments:
;
; Return Value:
;
;       None.
;
;--

DiskRecord      equ dword ptr [bp+6]
Int13UnitNumber equ dword ptr [bp+10]
SectorsPerTrack equ dword ptr [bp+14]
Heads           equ dword ptr [bp+18]
Cylinders       equ dword ptr [bp+22]
ExtendedSecCnt  equ dword ptr [bp+26]

        public GetInt13DiskInfo
GetInt13DiskInfo proc far

        push    bp
        mov     bp,sp

        push    ds
        push    es
        push    si
        push    di

        lds     si,DiskRecord
        add     si,Int13DiskUnit
        cld

        les     di,Int13UnitNumber
        movsb

        .errnz  (Int13SectorsPerTrack - Int13DiskUnit) - 1
        les     di,SectorsPerTrack
        movsb

        .errnz  (Int13Heads - Int13SectorsPerTrack) - 1
        les     di,Heads
        movsw

        .errnz  (Int13Cylinders - Int13Heads) - 2
        les     di,Cylinders
        movsw

        .errnz  (Int13xSectorCountl - Int13Cylinders) - 2
        les     di,ExtendedSecCnt
        movsw
        movsw

        pop     di
        pop     si
        pop     es
        pop     ds

        leave
        retf

GetInt13DiskInfo endp

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\mpk\iolib\partio.asm ===
DOSSEG
        .MODEL LARGE

include partit.inc

        .DATA?
        public PartitionList
        PartitionList dd ?
        public PartitionListCount
        PartitionListCount dw ?

        .CODE
        ASSUME ds:NOTHING

        extrn _InitializeDiskList:far
        extrn _OpenDisk:far
        extrn _CloseDisk:far
        extrn _ReadDisk:far
        extrn _WriteDisk:far
        extrn _malloc:far
        extrn _free:far

.386

;++
;
; UINT
; _far
; InitializePartitionList(
;     VOID
;     );
;
; Routine Description:
;
;       This routine initializes internal data structures necessary so that
;       other partition-related routines in this module can be called.
;
;       All int13 disks are enumerated to find all primary and extended
;       partitions. A data structure is build for each partition/logical drive
;       and relevent information is saved away.
;
; Arguments:
;
;       None.
;
; Return Value:
;
;       Total count of all partitions on all disks that we can deal with.
;       0 if an error occurs.
;
;--

SectorBufferh   equ word ptr [bp-2]
SectorBufferl   equ word ptr [bp-4]
CurrentSectorh  equ word ptr [bp-6]
CurrentSectorl  equ word ptr [bp-8]
NextSectorh     equ word ptr [bp-10]
NextSectorl     equ word ptr [bp-12]
ExtStarth       equ word ptr [bp-14]
ExtStartl       equ word ptr [bp-16]
DiskHandleh     equ word ptr [bp-18]
DiskHandlel     equ word ptr [bp-20]
PartCount       equ word ptr [bp-22]
InMbr           equ byte ptr [bp-24]


        public _InitializePartitionList
_InitializePartitionList proc far

        push    bp
        mov     bp,sp
        sub     sp,24

        push    ds
        push    es
        push    bx
        push    si
        push    di

        mov     PartCount,0

        ;
        ; Allocate a sector buffer. Note that we havn'e overwritten ds
        ; so it is addressing _DATA, which is required by the crt.
        ;
        push    512
        call    _malloc
        add     sp,2
        mov     cx,ax
        or      cx,dx
        jz      exit                    ; ax already 0 for error exit
        mov     SectorBufferl,ax
        mov     SectorBufferh,dx

        ;
        ; _InitializeDiskList could return 0 in case of
        ; failure but the code below will then simply execute
        ; zero iterations of its loop.
        ;
        call    _InitializeDiskList
        mov     si,ax                   ; si is limit of disk ids
        mov     di,0                    ; di is current disk id

nextdisk:
        cmp     si,di
        je      done

        ;
        ; Open this disk.
        ;
        push    di
        call    _OpenDisk
        add     sp,2
        mov     cx,ax
        or      cx,dx
        jz      exit                    ; open failed, bail out
        mov     DiskHandlel,ax
        mov     DiskHandleh,dx          ; save disk handle

        ;
        ; Read partition table for this disk
        ;
        xor     ax,ax
        mov     NextSectorl,ax
        mov     NextSectorh,ax
        mov     ExtStartl,ax
        mov     ExtStarth,ax
        mov     InMbr,1

nextptable:
        ;
        ; Read current mbr/ebr
        ;
        push    SectorBufferh
        push    SectorBufferl
        push    1
        mov     ax,NextSectorh
        mov     CurrentSectorh,ax
        push    ax
        mov     ax,NextSectorl
        mov     CurrentSectorl,ax
        push    ax
        push    DiskHandleh
        push    DiskHandlel
        call    _ReadDisk
        add     sp,14
        cmp     ax,0
        jz      exit                    ; ax already 0 for error exit

        mov     NextSectorl,0
        mov     NextSectorh,0

        mov     bx,SectorBufferl
        add     bx,1beh
        mov     ax,SectorBufferh
        mov     es,ax                   ; es:bx -> first partition table entry
        mov     cx,4
nextent:
        cmp     byte ptr es:[bx+4],0
        jz      nextent1                ; unused entry
        cmp     byte ptr es:[bx+4],5
        je      gotlink
        cmp     byte ptr es:[bx+4],0fh
        jnz     gotentry
gotlink:
        ;
        ; Link-type partition, track next ebr location
        ;
        mov     ax,ExtStartl
        add     ax,es:[bx+8]
        mov     NextSectorl,ax
        mov     ax,ExtStarth
        adc     ax,es:[bx+10]
        mov     NextSectorh,ax

        cmp     InMbr,1
        jne     nextent1

        mov     ax,es:[bx+8]
        mov     ExtStartl,ax
        mov     ax,es:[bx+10]
        mov     ExtStarth,ax

        jmp     nextent1

gotentry:
        mov     ax,CurrentSectorl
        add     ax,es:[bx+8]
        mov     dx,CurrentSectorh
        adc     dx,es:[bx+10]

        push    cx
        push    bx
        push    es

        ;
        ; Before calling crt ensure that ds addresses _DATA
        ;
        push    ds
        mov     ax,DGROUP
        mov     ds,ax
        push    SIZE PART_INFO
        call    _malloc
        add     sp,2
        pop     ds

        pop     es
        pop     bx

        mov     cx,ax
        or      cx,dx
        pop     cx                      ; does not affect flags
        jz      exit                    ; ax already 0 for error exit

        push    si
        push    ds
        mov     ds,dx
        mov     si,ax                   ; ds:si -> new partition record

        mov     ax,PartCount
        mov     [si].PartInfoOrdinal,ax
        inc     PartCount

        mov     ax,CurrentSectorl
        add     ax,es:[bx+8]
        mov     [si].PartInfoStartSectorl,ax
        mov     ax,CurrentSectorh
        adc     ax,es:[bx+10]
        mov     [si].PartInfoStartSectorh,ax

        mov     ax,es:[bx+12]
        mov     [si].PartInfoSectorCountl,ax
        mov     ax,es:[bx+14]
        mov     [si].PartInfoSectorCounth,ax

        mov     al,es:[bx+4]
        mov     [si].PartInfoSystemId,al

        mov     [si].PartInfoDiskId,di

        mov     [si].PartInfoPartOpen,0
        mov     [si].PartInfoDiskHandlel,0
        mov     [si].PartInfoDiskHandleh,0

        ;
        ; Insert at head of linked list
        ;
        push    es
        push    di

        mov     ax,DGROUP
        mov     es,ax
        mov     di,OFFSET DGROUP:[PartitionList] ; es:di = &PartitionList

        mov     ax,es:[di]
        mov     [si].PartInfoNextl,ax
        mov     ax,es:[di+2]
        mov     [si].PartInfoNexth,ax   ; Record->Next = PartitionList

        mov     es:[di],si
        mov     es:[di+2],dx            ; PartitionList = Record

        pop     di
        pop     es

        pop     ds
        pop     si                      ; restore int13 unit limit

nextent1:
        add     bx,16
        dec     cx
        jz      @f
        jmp     nextent
@@:
        mov     InMbr,0

        ;
        ; If we found a link entry, follow it. Otherwise we're done
        ; with this disk.
        ;
        cmp     NextSectorl,0
        jnz     nextptable
        cmp     NextSectorh,0
        jnz     nextptable

        push    DiskHandleh
        push    DiskHandlel
        call    _CloseDisk
        add     sp,4

        inc     di
        jmp     nextdisk

done:
        push    DGROUP
        pop     ds                      ; address DGROUP for crt
        push    SectorBufferh
        push    SectorBufferl
        call    _free
        add     sp,4
        mov     ax,PartCount

        mov     si,OFFSET DGROUP:PartitionListCount
        mov     [si],ax                 ; save count in global var

exit:
        pop     di
        pop     si
        pop     bx
        pop     es
        pop     ds

        leave
        retf

_InitializePartitionList endp



;++
;
; BOOL
; _far
; GetPartitionInfoById(
;     IN  UINT    PartitionId,
;     IN  UINT    Reserved,
;     OUT FPUINT  DiskId,
;     OUT FPBYTE  SystemId,
;     OUT FPULONG StartSector,
;     OUT FPULONG SectorCount
;     );
;
; BOOL
; _far
; GetPartitionInfoByHandle(
;     IN  HPARTITION PartitionHandle,
;     OUT FPUINT     DiskId,
;     OUT FPBYTE     SystemId,
;     OUT FPULONG    StartSector,
;     OUT FPULONG    SectorCount
;     );
;
; Routine Description:
;
;       These routines retrieve information about a particular partition,
;       either by an ordinal id (range: 0 - n-1 where n is the value returned
;       by InitializePartitionList()), or by a handle returned from
;       OpenPartition().
;
; Arguments:
;
;       PartitionId/PartitionHandle - supplies ordinal id or handle that
;               identifies the partition whose information is of interest.
;
;       Reserved - unused.
;
;       DiskId - receives the disk id of the disk where the partition is.
;
;       SystemId - receives the system id of the partition from the
;               partition table, if known, or 0 if not.
;
;       StartSector - recieves the absolute physical start sector on the
;               drive where the partition lives.
;
;       SectorCount - recieves the number of sectors in the partition.
;
; Return Value:
;
;       0 - failure
;       non-0 - success and caller's variables filled in
;
;--

PartitionId         equ word  ptr [bp+6]
PartitionHandle     equ dword ptr [bp+6]
DiskId              equ dword ptr [bp+10]
SystemId            equ dword ptr [bp+14]
StartSector         equ dword ptr [bp+18]
SectorCount         equ dword ptr [bp+22]

        public _GetPartitionInfoById
_GetPartitionInfoById proc far

        push    bp
        mov     bp,sp

        push    ds
        push    es
        push    si
        push    di

        ;
        ; Locate the partition record for the requested partition.
        ; The far pointer comes back in dx:si and ds:si.
        ;
        mov     ax,PartitionId
        call    far ptr pLocatePartitionRecord
        cmp     dx,0
        jnz     get_p_id
        cmp     si,0
        jz      error1

        ;
        ; Transfer the relevent fields to the caller's variables.
        ;
get_p_id:
        les     di,DiskId
        mov     ax,[si].PartInfoDiskId
        mov     es:[di],ax

        les     di,SystemId
        mov     al,[si].PartInfoSystemId
        mov     es:[di],al

        les     di,StartSector
        mov     ax,[si].PartInfoStartSectorl
        mov     es:[di],ax
        mov     ax,[si].PartInfoStartSectorh
        mov     es:[di+2],ax

        les     di,SectorCount
        mov     ax,[si].PartInfoSectorCountl
        mov     es:[di],ax
        mov     ax,[si].PartInfoSectorCounth
        mov     es:[di+2],ax

        mov     ax,1
        jmp     short exit1

error1:
        xor     ax,ax

exit1:
        pop     di
        pop     si
        pop     es
        pop     ds

        leave
        retf

_GetPartitionInfoById endp


        public _GetPartitionInfoByHandle
_GetPartitionInfoByHandle label far

        push    bp
        mov     bp,sp

        push    ds
        push    es
        push    si
        push    di

        ;
        ; Make sure it's open, if not give error.
        ;
        lds     si,PartitionHandle
        cmp     [si].PartInfoPartOpen,0
        jne     short get_p_id
        je      error1


;++
;
; HPARTITION
; _far
; OpenPartition(
;     IN UINT PartitionId
;     );
;
; Routine Description:
;
;       This routine 'opens' a partition so that subsequent io may be
;       performed on it.
;
;       Note that a partition can be open only once at a time.
;
;       Note that this routine also opens the underlying disk.
;       Disks can be opened only once at a time, thus this routine will
;       fail if the disk is already open.
;
; Arguments:
;
;       PartitionId - supplies an ordinal value identifying the partition.
;               Valid range is 0 - n-1, where n is the number returned
;               from InitializePartitionList().
;
; Return Value:
;
;       If successful, returns a value to be used as a handle to the
;       partition for subsequent i/o with other routines in this module.
;       If failure, returns 0.
;
;--
PartitionId         equ word  ptr [bp+6]

        public _OpenPartition
_OpenPartition proc far

        push    bp
        mov     bp,sp

        push    ds
        push    si

        ;
        ; Locate the partition record for the requested partition.
        ; The far pointer comes back in dx:si and ds:si.
        ;
        mov     ax,PartitionId
        call    far ptr pLocatePartitionRecord
        mov     cx,si
        or      cx,dx
        jnz     @f
        mov     ax,cx           ; dx:ax = 0
        jz      o_p_3

        ;
        ; Make sure the partition is not already open.
        ;
@@:     cmp     [si].PartInfoPartOpen,0
        je      @f
        mov     ax,0
        mov     dx,ax
        jne     o_p_3

        ;
        ; Open the underlying disk.
        ;
@@:     push    [si].PartInfoDiskId
        call    _OpenDisk
        add     sp,2
        mov     cx,ax
        or      cx,dx
        jz      o_p_3

        ;
        ; Remember disk handle, that the partition is open,
        ; and return the pointer to the partition record as the handle.
        ;
        mov     [si].PartInfoDiskHandlel,ax
        mov     [si].PartInfoDiskHandleh,dx

        inc     [si].PartInfoPartOpen

        mov     dx,ds
        mov     ax,si

o_p_3:
        pop     si
        pop     ds

        leave
        retf

_OpenPartition endp


;++
;
; VOID
; _far
; ClosePartition(
;     IN HPARTITION PartitionHandle
;     );
;
; Routine Description:
;
;       This routine 'closes' a partition previously opened by
;       OpenPartition.
;
;       This routine also releases its handle to the disk that
;       contains the partition.
;
; Arguments:
;
;       PartitionHandle - supplies a handle previously returned by
;               OpenPartition().
;
; Return Value:
;
;       None.
;
;--
PartitionHandle equ dword ptr [bp+6]

        public _ClosePartition
_ClosePartition proc far

        push    bp
        mov     bp,sp

        push    ds
        push    si

        ;
        ; If not open, nothing to do.
        ;
        lds     si,PartitionHandle
        cmp     [si].PartInfoPartOpen,0
        je      c_p_3

        ;
        ; Close the disk.
        ;
        push    [si].PartInfoDiskHandleh
        push    [si].PartInfoDiskHandlel
        call    _CloseDisk
        add     sp,4

        ;
        ; Indicate partition closed
        ;
        mov     cx,0
        mov     [si].PartInfoPartOpen,cl
        mov     [si].PartInfoDiskHandlel,cx
        mov     [si].PartInfoDiskHandleh,cx

c_p_3:
        pop     si
        pop     ds
        leave
        retf

_ClosePartition endp


;++
;
; BOOL
; _far
; ReadPartition(
;     IN  HPARTITION PartitionHandle,
;     IN  ULONG      StartSector,
;     IN  BYTE       SectorCount,
;     OUT FPVOID     Buffer
;     );
;
; BOOL
; _far
; WritePartition(
;     IN HPARTITION PartitionHandle,
;     IN ULONG      StartSector,
;     IN BYTE       SectorCount,
;     IN FPVOID     Buffer
;     );
;
; Routine Description:
;
;       These routines read from or write to a partition previously opened by
;       OpenPartition. I/Os use the proper method for the disk,
;       ie, int13, xint13, etc. This routine also ensures that
;       I/O doesn't cross a track boundary.
;
;       This routine does NOT however, worry about DMA boundaries.
;       The caller must take care of this.
;
; Arguments:
;
;       StartSector - supplies the 0-based sector relative to the start
;               of the partition where I/O is to start.
;
;       SectorCount - supplies the number of sectors to be transferred.
;
; Return Value:
;
;       0 - failure
;       non-0 - success
;
;--

PartitionHandle equ dword ptr [bp+6]
StartSector     equ dword ptr [bp+10]
StartSectorl    equ word  ptr [bp+10]
StartSectorh    equ word  ptr [bp+12]
SectorCount     equ           [bp+14]
Buffer          equ dword ptr [bp+16]
Bufferh         equ word  ptr [bp+18]

IoRoutine       equ dword ptr [bp-4]
IoRoutinel      equ word ptr  [bp-4]
IoRoutineh      equ word ptr  [bp-2]

        public _ReadPartition
_ReadPartition label far

        mov     dx,SEG _ReadDisk
        mov     ax,OFFSET _ReadDisk
        jmp     short PartitionIo

        public _WritePartition
_WritePartition label far

        mov     dx,SEG _WriteDisk
        mov     ax,OFFSET _WriteDisk

PartitionIo proc far

        push    bp
        mov     bp,sp
        sub     sp,4

        push    ds
        push    es
        push    bx
        push    si
        push    di

        ;
        ; The partition handle is actually a far pointer to
        ; the partition data record. Make sure it's open.
        ;
        lds     si,PartitionHandle              ; ds:si -> partition record
        cmp     [si].PartInfoPartOpen,0
        jne     @f
        xor     ax,ax
        jmp     short iodone

        ;
        ; Store the i/o routine pointer, passed to us in dx:ax.
        ;
@@:     mov     IoRoutineh,dx
        mov     IoRoutinel,ax

        ;
        ; Adjust the start sector to be disk-based instead of
        ; partition-based.
        ;
        mov     ax,[si].PartInfoStartSectorl
        add     StartSectorl,ax
        mov     ax,[si].PartInfoStartSectorh
        adc     StartSectorh,ax                 ; StartSector is physical sector#

        ;
        ; Call the disk routine to do the read.
        ;
        push    Buffer
        push    SectorCount
        push    StartSector
        push    [si].PartInfoDiskHandleh
        push    [si].PartInfoDiskHandlel
        call    IoRoutine
        add     sp,14

iodone:
        pop     di
        pop     si
        pop     bx
        pop     es
        pop     ds

        leave
        retf

PartitionIo endp

;++
;
; PVOID
; _far
; pLocatePartitionRecord(
;     IN UINT PartitionId
;     );
;
; Routine Description:
;
;
;       Internal routine.
;
;       This routine locates a partition record in the linked list
;       of all partition records as prepared by InitializePartitionList().
;
; Arguments:
;
;       PartitionId - supplies an ordinal value identifying the partition.
;               Valid range is 0 - n-1, where n is the number returned
;               from InitializePartitionList().
;
;               This parameter is passed in ax, not on the stack.
;
; Return Value:
;
;       NULL if record not located.
;       Otherwise fills ds:si and dx:si with a far pointer to the
;       partition record.
;
;--
pLocatePartitionRecord proc far

        mov     dx,DGROUP
        mov     ds,dx
        mov     si,OFFSET PartitionList         ; ds:si = &PartitionList

        ;
        ; Note that this code depends on the link field in the
        ; partition record structure being first!
        ;
        .errnz  PartInfoNext
lpr_loop:
        lds     si,[si].PartInfoNext
        mov     dx,ds
        cmp     dx,0
        jz      lpr_done                        ; end of list, we're done
        cmp     [si].PartInfoOrdinal,ax
        jz      lpr_done
        jmp     short lpr_loop

lpr_done:
        ret

pLocatePartitionRecord endp

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\mpk\makemast\makemast.h ===
extern char *textCantAccessImageFile;
extern char *textDiskReadError;
extern char *textDiskWriteError;
extern char *textTransferringFile;
extern char *textInvalidImageFile;
extern char *textImageFileTooBig;

extern FPVOID IoBuffer;

extern CMD_LINE_ARGS CmdLineArgs;

BOOL
ApplyImage(
    IN HDISK  DiskHandle,
    IN ULONG  TargetStart,
    IN ULONG  MaxSize,
    IN BYTE   SectorsPerTrack,
    IN USHORT Heads
    );


//
// 1 maximally sized cylinder
//
#define BOOT_IMAGE_SIZE (63*256)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\mpk\makemast\makemast.c ===
#include <mytypes.h>
#include <diskio.h>
#include <partio.h>
#include <misclib.h>
#include <makepart.h>
#include <partimag.h>
#include <msgfile.h>

#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include <dos.h>
#include <share.h>
#include <string.h>

#include "makemast.h"


#define xERROR      0
#define xPROCEED    1
#define xBAIL       2

FPVOID IoBuffer,UnalignedBuffer;
CMD_LINE_ARGS CmdLineArgs;
ULONG CheckSum;
ULONG ImageCheckSum;
ULONG BytesCRC;
ULONG FreeSpaceStart;
ULONG FreeSpaceEnd;

//
// Extra space needed for worst case disk expansion.
// 
// 16MB - 64K is the largest FAT that Win98 scandisk can handle, thus
// we only support a FAT table up to that size.
//
// So at worst we'll need to reserve twice that amount of space (32MB) in front to prevent
// the cluster restores from trashing our bitmap and MPK startup partitions.
//
// Fat32ResizeMaxOffset will be set to 0 if the partition isn't FAT32

#define FAT32_SPACE_TO_LEAVE 65535

ULONG Fat32ResizeMaxOffset;

//
// Text for the program
//
char *textNoDisks;
char *textSelectDiskPrompt;
char *textCantOpenDisk;
char *textOOM;
char *textDiskReadError;
char *textDiskWriteError;
char *textSureWipeMaster;
char *textSureWipeDisk;
char *textMbrIoFailed;
char *textRebootPrompt;
char *textDone;
char *textDisk;
char *textPaddedMbCount;
char *textInvalidSelection;
char *textMaster;
char *textYesNo;
char *textMasterDiskCorrupt;
char *textUsage;
char *textMasterDiskFull;
char *textRoomForNImages;
char *textEnterImageFilename;
char *textInvalidImageFile;
char *textImageFileTooBig;
char *textCantAccessImageFile;
char *textTransferringFile;
char *textCantOpenFile;
char *textReadingListFromFile;
char *textGeometryMismatch;
char *textTooFragmented;
char *textChecksum;
char *textChecksumFail;
char *textBytesProcessed;
char *textChecksumOK;
char *textTooManyPartitions;
char *textFoundExistingPartitions;
char *textExpandedImageFileTooBig;
char *textFreeSpaceNeedsToBeHere;

MESSAGE_STRING TextMessages[] = { { &textNoDisks, 1 },
                                  { &textSelectDiskPrompt, 2 },
                                  { &textCantOpenDisk, 3 },
                                  { &textOOM, 4 },
                                  { &textDiskReadError, 5 },
                                  { &textDiskWriteError, 6 },
                                  { &textSureWipeMaster, 7 },
                                  { &textSureWipeDisk, 8 },
                                  { &textMbrIoFailed, 9 },
                                  { &textRebootPrompt, 10 },
                                  { &textDone, 11 },
                                  { &textDisk, 12 },
                                  { &textPaddedMbCount, 13 },
                                  { &textInvalidSelection, 14 },
                                  { &textMaster, 15 },
                                  { &textYesNo, 16 },
                                  { &textMasterDiskCorrupt, 17 },
                                  { &textUsage, 18 },
                                  { &textMasterDiskFull, 19 },
                                  { &textRoomForNImages, 20 },
                                  { &textEnterImageFilename, 21 },
                                  { &textInvalidImageFile, 22 },
                                  { &textImageFileTooBig, 23 },
                                  { &textCantAccessImageFile, 24 },
                                  { &textTransferringFile, 25 },
                                  { &textCantOpenFile, 26 },
                                  { &textReadingListFromFile, 27 },
                                  { &textGeometryMismatch, 28 },
                                  { &textTooFragmented, 29 },
                                  { &textChecksum, 30 },
                                  { &textChecksumFail, 31 },
                                  { &textBytesProcessed, 32 },
                                  { &textChecksumOK, 33 },
                                  { &textTooManyPartitions, 34 },
                                  { &textFoundExistingPartitions, 35 },
                                  { &textExpandedImageFileTooBig,36 },
                                  { &textFreeSpaceNeedsToBeHere,37 }                                  
                                };


BOOL
DoIt(
    IN UINT DiskId
    );

BOOL
SetUpMasterDisk(
    IN HDISK  DiskHandle,
    IN USHORT SectorCount,
    IN BOOL   Init
    );

BOOL
TransferImages(
    IN HDISK DiskHandle
    );

BOOL
DetermineRelocations(
    IN UINT          FileHandle,
    IN HDISK         DiskHandle,
    IN ULONG         ImageStartSector,
    IN ULONG         ImageSectorCount,
    IN FPMASTER_DISK MasterDisk
    );

BOOL
NeedToRelocClusterBitmap(
    IN     FPMASTER_DISK     MasterDisk,
    IN OUT FPPARTITION_IMAGE PartitionImage,
    IN     ULONG             ImageStart,
    IN     UINT              FileHandle,
    IN OUT FPBYTE            ClusterBuffer
    );

BOOL
NeedToRelocBootPart(
    IN     FPMASTER_DISK     MasterDisk,
    IN OUT FPPARTITION_IMAGE PartitionImage,
    IN     UINT              FileHandle,
    IN OUT FPBYTE            ClusterBuffer
    );

BOOL
IsClusterRunFree(
    IN     UINT              FileHandle,
    IN     FPPARTITION_IMAGE PartitionImage,
    IN     ULONG             StartCluster,
    IN     ULONG             ClusterCount,
    IN OUT FPBYTE            ClusterBuffer,
    OUT    BOOL             *Free
    );

BOOL
IsRunGoodForRelocations(
    IN     ULONG          ImageStart,
    IN     ULONG          ImageLength,
    IN     FPMASTER_DISK  MasterDisk,
    IN OUT ULONG         *RunStart,
    IN     ULONG          RunLength,
    IN     ULONG          SectorsNeeded
    );

BOOL 
DetermineIfEisaPartitionExists(
    IN HDISK                    DiskHandle,
    IN VOID*                    IoBuffer,
    IN FPPARTITION_TABLE_ENTRY  pPartitionTable
    );

ULONG
DetermineHighestSectOccupied(
    IN FPPARTITION_TABLE_ENTRY pPartitionTable,
    IN BYTE SectorsPerTrack,
    IN USHORT Heads
    );

BOOL
RestorePartitionTable(
    IN HDISK                    DiskHandle,
    IN VOID*                    IoBuffer,
    IN FPPARTITION_TABLE_ENTRY  pPartitionTable
    );

BYTE
FindFirstUnusedEntry(
    IN FPPARTITION_TABLE_ENTRY  pPartitionTable
    );

BOOL
IsUnknownPartition(
    BYTE SysId 
    );
int
main(
    IN int argc,
    IN char *argv[]
    )
{
    UINT DiskCount;
    UINT Selection;
    BOOL b;
    UINT u;
    BYTE Int13Unit;
    ULONG dontcare;

    if(!GetTextForProgram(argv[0],TextMessages,sizeof(TextMessages)/sizeof(TextMessages[0]))) {
        fprintf(stderr,"Unable to find messages for program\n");
        return(FAILURE);
    }

    if(!ParseArgs(argc,argv,TRUE,"DFIMQRXY",&CmdLineArgs)) {
        fprintf(stderr,textUsage);
        fprintf(stderr,"\n");
        return(FAILURE);
    }

    //
    // Initialize.
    //
    DiskCount = InitializeDiskList();
    if(!DiskCount) {
        fprintf(stderr,"%s\n",textNoDisks);
        return(FAILURE);
    }
    _Log("%u disks\n",DiskCount);

    //
    // We don't check return code because zero partitions
    // is a perfectly valid case.
    //
    InitializePartitionList();

    //
    // Allocate a maximally-sized i/o buffer
    //
    if(!AllocTrackBuffer(63,&IoBuffer,&UnalignedBuffer)) {
        fprintf(stderr,"%s\n",textOOM);
        return(FAILURE);
    }

    //
    // Select disk.
    //
    Selection = (UINT)(-1);
    if(CmdLineArgs.MasterDiskInt13Unit) {
        for(u=0; u<DiskCount; u++) {

            GetDiskInfoById(
                u,
                0,
                &Int13Unit,
                (FPBYTE)&dontcare,
                (FPUSHORT)&dontcare,
                (FPUSHORT)&dontcare,
                &dontcare
                );

            if(Int13Unit == CmdLineArgs.MasterDiskInt13Unit) {
                Selection = u;
                break;
            }
        }
    }

    if(Selection == (UINT)(-1)) {
        Selection = SelectDisk(
                        DiskCount,
                        textSelectDiskPrompt,
                        NULL,
                        NULL,
                        textDisk,
                        textPaddedMbCount,
                        textInvalidSelection,
                        textMaster
                        );
    }

    //
    // Do our thing.
    //
    printf("\n");
    if(b = DoIt(Selection)) {

        printf("\n%s\n",textDone);
    }

    return(b ? SUCCESS : FAILURE);
}


BOOL
DoIt(
    IN UINT DiskId
    )
{
    HDISK DiskHandle;
    BOOL Init;
    BOOL b;

    //
    // Determine whether this disk is already a master disk, and if so,
    // what to do about it.
    //
    // If selected disk is not a master disk, offer to make it one.
    // If selected disk is a master disk, offer to reinitialize it.
    //
    if(IsMasterDisk(DiskId,IoBuffer)) {
        _Log("Selected disk is already a master disk\n");
        if(CmdLineArgs.Quiet) {
            Init = CmdLineArgs.Reinit;
        } else {
            Init = ConfirmOperation(textSureWipeMaster,textYesNo[0],textYesNo[1]);
        }
    } else {
        _Log("Selected disk is not already a master disk\n");
        if(!CmdLineArgs.Quiet && !ConfirmOperation(textSureWipeDisk,textYesNo[0],textYesNo[1])) {
            return(TRUE);
        }
        Init = TRUE;
    }

    //
    // Open the disk.
    //
    DiskHandle = OpenDisk(DiskId);
    if(!DiskHandle) {
        fprintf(stderr,"%s\n",textCantOpenDisk);
        return(FALSE);
    }

    if(!SetUpMasterDisk(DiskHandle,BOOT_IMAGE_SIZE,Init)) {
        CloseDisk(DiskHandle);
        return(FALSE);
    }

    //
    // Now transfer images to the master disk.
    //
    b = TransferImages(DiskHandle);

    CloseDisk(DiskHandle);

    return(b);
}


BOOL
SetUpMasterDisk(
    IN HDISK  DiskHandle,
    IN USHORT SectorCount,
    IN BOOL   Init
    )
{
    PMASTER_DISK p;
    UINT PartId;
    UINT DiskId;
    BYTE SystemId;
    BYTE Unit;
    BYTE SectorsPerTrack;
    USHORT Heads;
    USHORT Cylinders;
    ULONG ExtendedSectorCount;
    ULONG StartSector;
    ULONG Count;
//    ULONG DontCare;
    BOOL bPreserveEisaPartition;
    PARTITION_TABLE_ENTRY PartitionTable[NUM_PARTITION_TABLE_ENTRIES];    
                                                // there are a maxiumum of 4 entries in 
                                                // the partition table.

    p = (FPMASTER_DISK)IoBuffer;
        
    //
    // First get some hardware values.
    //    
    GetDiskInfoByHandle(
        DiskHandle,
        &Unit,
        &SectorsPerTrack,
        &Heads,
        (FPUSHORT)&Cylinders,
        &ExtendedSectorCount,
        &DiskId
        );

    //
    // We need to figure out if an eisa/hiber partition exists, and we need to 
    // know the lowest possible cylinder we can write images to.
    //

    memset(PartitionTable, 0, sizeof(PARTITION_TABLE_ENTRY)*4);

    // note: DetermineIfEisaPartitionExists trashes the first 512 bytes of IoBuffer
    bPreserveEisaPartition = DetermineIfEisaPartitionExists(DiskHandle,IoBuffer,PartitionTable);
    if(bPreserveEisaPartition) {
        //
        // Save away the range of free cylinders.
        //                
        FreeSpaceStart = DetermineHighestSectOccupied(PartitionTable,SectorsPerTrack,Heads);
        _Log("Existing unknown partitions found.\n");
        printf("%s\n",textFoundExistingPartitions);        
        if( FindFirstUnusedEntry(PartitionTable) == -1 ) {
            printf("%s\n",textTooManyPartitions);
            return(FALSE);
        }

    } else {
        //
        // FreeSpaceStart is ignored if it is zero.
        //
        FreeSpaceStart = 0;
    }

    //
    // The assumption for now is that we don't support preserving partitions at the end of 
    // the disk.
    //
    FreeSpaceEnd = ExtendedSectorCount;

    _Log("Free space starts sector %ld\n", FreeSpaceStart);
    _Log("Free space ends sector %ld\n", FreeSpaceEnd);

    if( FreeSpaceStart > FreeSpaceEnd ) {
        //
        // The logic that determines FreeSpaceStart assumes that all the existing partitions
        // on the disk are at the beginning of the disk and the free space is contiguous after
        // the last pre-existing unknown partition. 
        //
        fprintf(stderr,textFreeSpaceNeedsToBeHere);
        fprintf(stderr,"\n");
        _Log(textFreeSpaceNeedsToBeHere);
        _Log("\n");
        return(FALSE);
    }
    //
    // Clear out the partition table and then create a new partition
    // of the requested size at the end of the disk.
    // We also slam in our boot code.
    //
    // Once we've done that, slam in our special data structure
    // on sector 1.
    //

    if(Init) {
        _Log("Initializing the disk... \n");

        if(ReinitializePartitionTable(DiskHandle,IoBuffer) == -1) {
            fprintf(stderr,"%s\n",textMbrIoFailed);
            return(FALSE);
        }        
        PartId = MakePartitionAtEndOfEmptyDisk(DiskHandle,IoBuffer,SectorCount,TRUE);
        if(PartId != (UINT)(-1)) {

            GetPartitionInfoById(
                PartId,
                0,
                &DiskId,
                &SystemId,
                &StartSector,
                &Count
                );

        } else {
            fprintf(stderr,"%s\n",textMbrIoFailed);
            return(FALSE);
        }

        if( bPreserveEisaPartition ) {
            //
            // We put the partitions we want to save back into the partition table.
            //
            if(!RestorePartitionTable(DiskHandle,IoBuffer,PartitionTable)) {
                return FALSE;
            }
        }
        memset(p,0,512);

        p->StartupPartitionStartSector = StartSector;
        p->StartupPartitionSectorCount = Count;
        p->Signature = MASTER_DISK_SIGNATURE;
        p->Size = sizeof(MASTER_DISK);
        p->FreeSpaceStart = FreeSpaceStart;
        p->FreeSpaceEnd = FreeSpaceEnd;

    } else {
        //
        // Reinitialize only selected fields
        //
        if(!ReadDisk(DiskHandle,1,1,p)) {
            fprintf(stderr,textDiskReadError,1L);
            fprintf(stderr,"\n");
            return(FALSE);
        }

        p->State = MDS_NONE;
        p->SelectedLanguage = 0;
        p->SelectionOrdinal = 0;
        p->ClusterBitmapStart = 0;
        p->NonClusterSectorsDone = 0;
        p->ForwardXferSectorCount = 0;
        p->ReverseXferSectorCount = 0;        
    }
    
    //
    // Store away or validate the disk geometry.
    //
    if(!Init) {
        _Log("Checking disk geometry...\n");
        //
        // Validate that this matches the original geometry values
        //
        if((SectorsPerTrack != p->OriginalSectorsPerTrack)
        || (Heads != p->OriginalHeads)) {

            fprintf(stderr,"\n%s\n",textGeometryMismatch);
        }
        _Log("%d sectors per track, %d heads.\n", SectorsPerTrack, Heads);
        _Log("Master disk geometry matches values recorded in master disk.\n");
    } else {
        _Log("Setting disk geometry...\n");
        p->OriginalSectorsPerTrack = SectorsPerTrack;
        p->OriginalHeads = Heads;
        _Log("%d sectors per track, %d heads.\n", SectorsPerTrack, Heads);
    }

    //
    // Save it out to disk.
    //

    if(!WriteDisk(DiskHandle,1,1,p)) {
        fprintf(stderr,textDiskWriteError,1L);
        fprintf(stderr,"\n");
        return(FALSE);
    }
    
    //
    // Apply the boot image if specified.
    //
    if(CmdLineArgs.ImageFile) {
        if(!ApplyImage(DiskHandle,p->StartupPartitionStartSector,p->StartupPartitionSectorCount,SectorsPerTrack,Heads)) {
            return(FALSE);
        }
        printf("\n\n");
    }

    return(TRUE);
}


BOOL
TransferImages(
    IN HDISK DiskHandle
    )
{
    PPARTITION_IMAGE Images;
    FPMASTER_DISK MasterDisk;
    ULONG NextImageEnd;
    UINT u,Limit;
    UINT FileHandle;
    UINT Read;
    ULONG FileSize;
    ULONG Sector;
    UINT NewImages;
    FPCHAR Filenames;
    FPCHAR p;
    ULONG OriginalSize;
    FPBYTE New;
    FILE *FileList;
    BOOL b;    

    //
    // Retrieve the master disk structure. Leave it in the last sector
    // of the i/o buffer.
    //
    if(!ReadDisk(DiskHandle,1,1,(FPBYTE)IoBuffer+(62*512))) {
        fprintf(stderr,textDiskReadError,1L);
        fprintf(stderr,"\n");
        return(FALSE);
    }
    MasterDisk = (FPVOID)((FPBYTE)IoBuffer+(62*512));

    //
    // Allocate a buffer for the image headers.
    //
    Images = malloc(MasterDisk->ImageCount * sizeof(PARTITION_IMAGE));
    if(!Images) {
        fprintf(stderr,"%s\n",textOOM);
    }

    //
    // Read each existing image's header.
    //
    NextImageEnd = MasterDisk->StartupPartitionStartSector;
    for(u=0; u<MasterDisk->ImageCount; u++) {

        if(!ReadDisk(DiskHandle,MasterDisk->ImageStartSector[u],1,IoBuffer)) {
            fprintf(stderr,textDiskReadError,MasterDisk->ImageStartSector[u]);
            fprintf(stderr,"\n");
            return(FALSE);
        }

        memmove(&Images[u],IoBuffer,sizeof(PARTITION_IMAGE));

        //
        // Sanity check
        //
        if((Images[u].Signature != PARTITION_IMAGE_SIGNATURE)
        || (Images[u].Size != sizeof(PARTITION_IMAGE))) {

            fprintf(stderr,textMasterDiskCorrupt,MasterDisk->ImageStartSector[u]);
            fprintf(stderr,"\n");
            return(FALSE);
        }

        NextImageEnd = MasterDisk->ImageStartSector[u];
    }

    //
    // Make sure there's room for new images.
    //
    if(MasterDisk->ImageCount >= MAX_PARTITION_IMAGES) {
        fprintf(stderr,textMasterDiskFull,MasterDisk->ImageCount);
        fprintf(stderr,"\n");
        return(FALSE);
    } else {
        //
        // Prompt the user for partition image filenames.
        //
        // Open and validate each file, and make sure there's room on the disk
        // for the image. We don't leave the files open since under DOS
        // we might run out of file handles, and we don't want to transfer
        // the data now (it could take a long time and we want to let the user
        // go get a cup of coffee or something). Actual data transfer
        // takes place in a separate loop.
        //
        // We leave 1 track + 128 sectors free at the start of the disk.
        // The track is for the MBR and the other is used for transfers where
        // the max transfer size is for one 64K cluster (we ensure that
        // no transfer's write range overlaps its read). Because we're not
        // totally confident that the geometry we've got now is the one that
        // will be in effect on the end-user's machine, we maximize
        // the track size.
        //
        Filenames = malloc(0);
        if(!Filenames) {
            fprintf(stderr,"%s\n",textOOM);
            return(FALSE);
        }
        p = Filenames;
        Limit = MAX_PARTITION_IMAGES - MasterDisk->ImageCount;
        NewImages = 0;
        printf(textRoomForNImages,Limit);
        printf("\n");
        if(CmdLineArgs.FileListFile) {
            FileList = fopen(CmdLineArgs.FileListFile,"rt");
            if(!FileList) {
                fprintf(stderr,textCantOpenFile,CmdLineArgs.FileListFile);
                fprintf(stderr,"\n");
                return(FALSE);
            }
            printf(textReadingListFromFile,CmdLineArgs.FileListFile);
            printf("\n");
        }

        for(u=0; u<Limit; u++) {

            prompt:

            if(CmdLineArgs.FileListFile) {
                if(fgets((FPBYTE)IoBuffer+512,256,FileList)) {
                    //
                    // Strip trailing spaces and newline
                    //
                    Read = strlen((FPBYTE)IoBuffer+512);
                    while(Read
                    && (   (((FPBYTE)IoBuffer+512)[Read-1] == '\n')
                        || (((FPBYTE)IoBuffer+512)[Read-1] == ' ')
                        || (((FPBYTE)IoBuffer+512)[Read-1] == '\t'))) {

                        ((FPBYTE)IoBuffer+512)[--Read] = 0;
                    }

                    if(*((FPBYTE)IoBuffer+512)) {
                        printf("   %s\n",(FPBYTE)IoBuffer+512);
                    }
                } else {
                    //
                    // Force us to bust out of the filename read loop
                    //
                    *((FPBYTE)IoBuffer+512) = 0;
                }
            } else {
                printf(textEnterImageFilename,u+1);
                printf(" ");

                gets((FPBYTE)IoBuffer+512);
            }

            if(*((FPBYTE)IoBuffer+512)) {

                if(_dos_open((FPBYTE)IoBuffer+512,SH_DENYWR,&FileHandle)) {
                    printf("%s\n",textInvalidImageFile);
                    goto prompt;
                }

                if(_dos_read(FileHandle,IoBuffer,512,&Read)
                || (Read != 512)
                || ((FileSize = DosSeek(FileHandle,0,DOSSEEK_END)) == (ULONG)(-1))
                || (FileSize % 512)
                || (((FPPARTITION_IMAGE)IoBuffer)->Signature != PARTITION_IMAGE_SIGNATURE)
                || (((FPPARTITION_IMAGE)IoBuffer)->Size != sizeof(PARTITION_IMAGE))) {

                    _dos_close(FileHandle);
                    printf("%s\n",textInvalidImageFile);
                    goto prompt;
                }

                FileSize /= 512;


                //
                // BUGBUG we should reserve at least 32MB worth of sectors to prevent
                // overlapping with the expanded FAT table in the Fat32 case.
                //
                // As well, we need to have the capability to preserve a hiber partition.
                // FreeSpaceStart describes how many sectors we need to leave at the
                // beginning of the disk to avoid stomping on such a partition.
                //
                // FreeSpaceStart was determined in SetupMasterDisk()
                //

                #define RESERVE (63+128+FAT32_SPACE_TO_LEAVE)
                
                if((NextImageEnd - RESERVE - FreeSpaceStart) < FileSize) {
                    _dos_close(FileHandle);
                    fprintf(stderr,textImageFileTooBig,FileSize,NextImageEnd-RESERVE);
                    fprintf(stderr,"\n");
                    goto prompt;
                }
                
                //
                // Now check that the disk is at least big enough to contain the real size
                // of the image.
                //
                if( FreeSpaceEnd - FreeSpaceStart <  ((FPPARTITION_IMAGE)IoBuffer)->TotalSectorCount ) {
                    _dos_close(FileHandle);
                    fprintf(stderr,textExpandedImageFileTooBig,
                            ((FPPARTITION_IMAGE)IoBuffer)->TotalSectorCount,
                            FreeSpaceEnd - FreeSpaceStart);
                    fprintf(stderr,"\n");
                    _Log(textExpandedImageFileTooBig,
                            ((FPPARTITION_IMAGE)IoBuffer)->TotalSectorCount,
                            FreeSpaceEnd - FreeSpaceStart);
                    _Log("\n");
                    goto prompt;
                }

                //
                // It's OK. Remember the filename.
                //

                New = realloc(Filenames,(p - Filenames) + strlen((FPBYTE)IoBuffer+512) + 1);
                if(!New) {
                    fprintf(stderr,"%s\n",textOOM);
                    return(FALSE);
                }
                p += New - Filenames;
                Filenames = New;
                strcpy(p,(FPBYTE)IoBuffer+512);
                p += strlen(p)+1;

                MasterDisk->ImageStartSector[MasterDisk->ImageCount+u] = NextImageEnd - FileSize;
                NextImageEnd -= FileSize;

                NewImages++;

            } else {
                break;
            }
        }
    }

    //
    // Now transfer the data for new images.
    //
    printf("\n");
    for(p=Filenames,u=0; u<NewImages; u++,p+=strlen(p)+1) {

        printf(textTransferringFile,p,0);
        printf("\r");

        _Log("\nProcessing image %s...\n",p);

        if(_dos_open(p,SH_DENYWR,&FileHandle)) {
            fprintf(stderr,"\n%s\n",textCantAccessImageFile);
            return(FALSE);
        }

        CheckSum = CRC32_INITIAL_VALUE;
        BytesCRC = 0;

        if((FileSize = DosSeek(FileHandle,0,DOSSEEK_END)) == (ULONG)(-1)) {

            _dos_close(FileHandle);
            fprintf(stderr,"\n%s\n",textCantAccessImageFile);
            return(FALSE);
        }

        FileSize /= 512;
        OriginalSize = FileSize;
        Sector = MasterDisk->ImageStartSector[MasterDisk->ImageCount+u];

        b = DetermineRelocations(
                FileHandle,
                DiskHandle,
                Sector,
                FileSize,
                MasterDisk
                );

        if(!b) {
            _dos_close(FileHandle);
            return(FALSE);
        }

        FileSize--;
        Sector++;

        while(FileSize) {

            Limit = (FileSize > 62L) ? 62 : (UINT)FileSize;

            if(_dos_read(FileHandle,IoBuffer,Limit*512,&Read) || (Read != (Limit*512))) {
                _dos_close(FileHandle);
                fprintf(stderr,"\n%s\n",textCantAccessImageFile);
                return(FALSE);
            }

            CheckSum = CRC32Compute( IoBuffer, Limit*512, CheckSum);
            BytesCRC += Limit*512;

            if(!WriteDisk(DiskHandle,Sector,(BYTE)Limit,IoBuffer)) {
                _dos_close(FileHandle);
                fprintf(stderr,"\n");
                fprintf(stderr,textDiskWriteError,Sector);
                fprintf(stderr,"\n");
                return(FALSE);
            }            

            FileSize -= Limit;
            Sector += Limit;
            
            printf(textTransferringFile,p,100*(OriginalSize-FileSize)/OriginalSize);
            printf("\r");
        }

        _dos_close(FileHandle);
        
        printf(textChecksum, p, CheckSum );
        _Log(textChecksum, p, CheckSum );
        _Log("\n");
        printf("\n");     
        printf( textBytesProcessed,BytesCRC );
        _Log( textBytesProcessed,BytesCRC );
        _Log("\n");
        printf("\n");     

        if( CheckSum != ImageCheckSum ) {
            printf(textChecksumFail,ImageCheckSum);    
            _Log(textChecksumFail,ImageCheckSum);
        } else {
            printf(textChecksumOK);
            _Log(textChecksumOK);
        }

        printf("\n");
        _Log("\n");
    }

    MasterDisk->ImageCount += NewImages;
    if(!WriteDisk(DiskHandle,1,1,(FPBYTE)IoBuffer+(62*512))) {
        fprintf(stderr,textDiskWriteError,1L);
        fprintf(stderr,"\n");
        return(FALSE);
    }

    free(Filenames);
    free(Images);
    return(TRUE);
}


BYTE BitValue[8] = { 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80 };

BOOL
DetermineRelocations(
    IN UINT          FileHandle,
    IN HDISK         DiskHandle,
    IN ULONG         ImageStartSector,
    IN ULONG         ImageSectorCount,
    IN FPMASTER_DISK MasterDisk
    )

/*++

Routine Description:

    This routine determines where there is unused space in the volume
    being imaged that will allow relocation of the cluster bitmap
    and the mpk boot partition somewhere on the disk.

Arguments:

Return Value:

--*/

{
    UINT Read;
    FPPARTITION_IMAGE p;
    FPBYTE ClusterBuffer;
    ULONG SectorsNeeded;
    ULONG Count;
    ULONG Cluster;
    ULONG Base;
    BOOL On;
    BOOL InRun;
    ULONG Start;
    BOOL b;

    //
    // Set up pointers.
    //
    p = IoBuffer;
    ClusterBuffer = (FPBYTE)IoBuffer + 512;

    //
    // Read the partition image header from the file.
    //
    if(DosSeek(FileHandle,0,DOSSEEK_START)) {
        fprintf(stderr,"\n%s\n",textCantAccessImageFile);
        return(FALSE);
    }

    if(_dos_read(FileHandle,p,512,&Read) || (Read != 512)) {
        fprintf(stderr,"\n%s\n",textCantAccessImageFile);
        return(FALSE);
    }
    
    //
    // Calculate the checksum of the header.
    //

    ImageCheckSum = ((PPARTITION_IMAGE)p)->CRC;

    ((PPARTITION_IMAGE)p)->CRC = 0;    
    CheckSum = CRC32Compute( (FPBYTE)p, 512, CheckSum);
    BytesCRC += 512;
    ((PPARTITION_IMAGE)p)->CRC = ImageCheckSum;

    //
    // determine whether this is a FAT32 image
    //

    if(DosSeek(FileHandle,512,DOSSEEK_START) == (ULONG)(-1)) {
        _dos_close(FileHandle);
        printf("%s\n",textInvalidImageFile);
        return FALSE;
    }

    if( _dos_read(FileHandle,ClusterBuffer,512,&Read)
        || (Read != 512) )
    {
        _dos_close(FileHandle);
        printf("%s\n",textInvalidImageFile);
        return FALSE;
    }                

    if( IsFat32(ClusterBuffer) ) {
        Fat32ResizeMaxOffset = FAT32_SPACE_TO_LEAVE;
        _Log("The image is a FAT32 volume, setting up resizing...\n\n");
    } else {
        // we don't support resizing
        Fat32ResizeMaxOffset = 0;
        _Log("The image is not a FAT32 volume, resizing disabled...\n\n");
    }

    //
    // Determine whether the cluster bitmap will need to be relocated
    // and whether the boot partition will need to be relocated.
    // Track how many contiguous sectors are needed to relocate
    // the stuff we need to relocate. If we don't need to relocate
    // anything, we're done.
    //

    p->Flags &= ~(PARTIMAGE_RELOCATE_BITMAP | PARTIMAGE_RELOCATE_BOOT);
    p->BitmapRelocationStart = 0;
    p->BootRelocationStart = 0;
    SectorsNeeded = 0;

    if(!NeedToRelocClusterBitmap(MasterDisk,p,ImageStartSector,FileHandle,ClusterBuffer)) {
        return(FALSE);
    }

    if(p->Flags & PARTIMAGE_RELOCATE_BITMAP) {
        SectorsNeeded += (p->LastUsedCluster/(8*512)) + 1;
        _Log("Need to relocate bitmap\n");
    }

    if(!NeedToRelocBootPart(MasterDisk,p,FileHandle,ClusterBuffer)) {
        return(FALSE);
    }

    if(p->Flags & PARTIMAGE_RELOCATE_BOOT) {
        SectorsNeeded += MasterDisk->StartupPartitionSectorCount;
        _Log("Need to relocate boot\n");
    }
    
    if( p->Flags & PARTIMAGE_RELOCATE_BOOT || p->Flags & PARTIMAGE_RELOCATE_BITMAP ) {    
        SectorsNeeded += Fat32ResizeMaxOffset;
        _Log("Need to add maximum possible %ld sectors to compensate for FAT32 fat growth.\n", Fat32ResizeMaxOffset);
    }

    if(SectorsNeeded) {

        _Log("0x%lx sectors needed for relocation\n",SectorsNeeded);

        b = FALSE;

        //
        // Seek the input file to the beginning of the cluster bitmap.
        //
        Start = (1 + p->NonClusterSectors + (p->SectorsPerCluster * p->UsedClusterCount)) * 512;

        if(DosSeek(FileHandle,Start,DOSSEEK_START) != Start) {
            fprintf(stderr,"\n%s\n",textCantAccessImageFile);
            return(FALSE);
        }

        Count = 0;

        for(Cluster=0; Cluster <= p->LastUsedCluster; Cluster++,Base++) {

            //
            // Reload the cluster buffer if necessary.
            //
            if(!(Cluster % (512*8))) {
                if(_dos_read(FileHandle,ClusterBuffer,512,&Read) || (Read != 512)) {
                    fprintf(stderr,"\n%s\n",textCantAccessImageFile);
                    return(FALSE);
                }

                Base = 0;
            }

            On = (ClusterBuffer[Base/8] & BitValue[Base%8]) ? TRUE : FALSE;

            //
            // Do something special before we examine the first cluster's bit,
            // to force a state transition.
            //
            if(!Cluster) {
                InRun = !On;
            }

            if(On == InRun) {
                //
                // Used/unused state didn't change. If we're not in a used run,
                // keep track of the size.
                //
                if(!On) {
                    Count += p->SectorsPerCluster;
                }
            } else {
                if(On) {
                    //
                    // First 1 bit in a used run. The current free run is now
                    // exhausted, so examine it.
                    //
                    if(Count) {

                        b = IsRunGoodForRelocations(
                                ImageStartSector,
                                ImageSectorCount,
                                MasterDisk,
                                &Start,
                                Count,
                                SectorsNeeded
                                );

                        if(b) {
                            //
                            // for FAT32 Fat32ResizeMaxOffset will be != 0
                            // this lets us offset the relocation to account
                            // for possible FAT expansion.
                            //
                            // If there is an EISA/hiber partition, we need to
                            // offset the start of the relocation by FreeSpaceStart,
                            // otherwise we might get stomped when we're restoring
                            // the partition image.  
                            //

                            Start = Start + Fat32ResizeMaxOffset + FreeSpaceStart;

                            if(p->Flags & PARTIMAGE_RELOCATE_BOOT) {
                                _Log("Boot will be relocated to 0x%lx\n",Start);
                                p->BootRelocationStart = Start;
                                Start += MasterDisk->StartupPartitionSectorCount;
                            }
                            if(p->Flags & PARTIMAGE_RELOCATE_BITMAP) {
                                _Log("Bitmap will be relocated to 0x%lx\n",Start);
                                p->BitmapRelocationStart = Start;
                            }
                            break;
                        }
                    }
                } else {
                    //
                    // First 0 bit in an unused run.
                    //
                    Count = p->SectorsPerCluster;
                    Start = (ULONG)(MasterDisk->OriginalSectorsPerTrack) + p->NonClusterSectors
                          + (Cluster * p->SectorsPerCluster);
                }

                InRun = On;
            }
        }

    } else {
        b = TRUE;
    }

    if(b) {
        //
        // Restore the file pointer to just after the partition image
        // header sector.
        //
        if(DosSeek(FileHandle,512,DOSSEEK_START) != 512) {
            fprintf(stderr,"\n%s\n",textCantAccessImageFile);
            return(FALSE);
        }

        //
        // Write out the partition image header.
        //
        if(!WriteDisk(DiskHandle,ImageStartSector,1,p)) {
            fprintf(stderr,"\n");
            fprintf(stderr,textDiskWriteError,ImageStartSector);
            fprintf(stderr,"\n");
            return(FALSE);
        }

    } else {
        fprintf(stderr,"\n%s\n",textTooFragmented);
    }

    return(b);
}


BOOL
NeedToRelocClusterBitmap(
    IN     FPMASTER_DISK     MasterDisk,
    IN OUT FPPARTITION_IMAGE PartitionImage,
    IN     ULONG             ImageStart,
    IN     UINT              FileHandle,
    IN OUT FPBYTE            ClusterBuffer
    )
{
    ULONG ClusterBitmapStart;
    ULONG ClusterBitmapSize;
    ULONG Cluster0Sector;
    ULONG FirstUnused;
    ULONG FirstCluster;
    ULONG LastCluster;
    ULONG NeededClusters;
    BOOL b;

    //
    // Figure out where the cluster bitmap starts on-disk and
    // how many sectors it occupies. We offset the start by 
    // Fat32ResizeMaxOffset sectors at the front of the allocation
    // in order to anticipate FAT expansion.
    //
    // Fat32ResizeMaxOffset will be zero for a non-FAT32 image and 
    // will have no effect in that case.  
    //
    ClusterBitmapStart = ImageStart
                       + 1
                       + PartitionImage->NonClusterSectors
                       + (PartitionImage->UsedClusterCount * PartitionImage->SectorsPerCluster)
                       - Fat32ResizeMaxOffset;

    ClusterBitmapSize = (PartitionImage->LastUsedCluster/(8*512)) + 1 + Fat32ResizeMaxOffset;

    _Log("On-disk cluster bitmap start/size = 0x%lx/0x%lx\n",ClusterBitmapStart,ClusterBitmapSize);

    //
    // Calculate the first physical sector corresponding to cluster 0
    // in the restored volume, and the first sector past the last
    // used cluster in the restored volume.
    //
    Cluster0Sector = MasterDisk->OriginalSectorsPerTrack + PartitionImage->NonClusterSectors + FreeSpaceStart;
    FirstUnused = Cluster0Sector + ((PartitionImage->LastUsedCluster+1) * PartitionImage->SectorsPerCluster);

    _Log("Volume cluster 0 sector = 0x%lx\n",Cluster0Sector);
    _Log("Volume first unused sector = 0x%lx\n",FirstUnused);

    //
    // If the cluster bitmap overlaps or could potentially overlap
    // with the area on the disk where the non-cluster data will get
    // restored, then it must be relocated.
    //
    if(ClusterBitmapStart < Cluster0Sector ) {
        _Log("Cluster bitmap is in volume non-cluster data\n");
        PartitionImage->Flags |= PARTIMAGE_RELOCATE_BITMAP;
        return(TRUE);
    }

    //
    // If the cluster bitmap is in space we know for sure is free, then
    // it does not need to be relocated. 
    //
    // If we are preserving an EISA/hiber partition, we need to adjust
    // by FreeSpaceStart sectors.
    //
    if(ClusterBitmapStart >= FirstUnused) {
        _Log("Cluster bitmap is past end of used space in volume\n");
        return(TRUE);
    }

    //
    // Figure out which clusters in the restored volume are occupied by the
    // on-disk cluster bitmap.
    //
    FirstCluster = (ClusterBitmapStart - Cluster0Sector) 
                        / PartitionImage->SectorsPerCluster;

    LastCluster = (((ClusterBitmapStart + ClusterBitmapSize) - 1) - Cluster0Sector)
                / PartitionImage->SectorsPerCluster;

    _Log("First/last clusters used by cluster bitmap: 0x%lx/0x%lx\n",FirstCluster,LastCluster);

    if(LastCluster > PartitionImage->LastUsedCluster) {
        LastCluster = PartitionImage->LastUsedCluster;
        _Log("(last cluster adjusted to 0x%lx)\n",LastCluster);
    }

    NeededClusters = (LastCluster - FirstCluster) + 1;
    _Log("Need 0x%lx clusters free in volume to encompass cluster bitmap\n",NeededClusters);

    //
    // Determine whether these clusters are free in the volume
    //

    if(!IsClusterRunFree(FileHandle,PartitionImage,FirstCluster,NeededClusters,ClusterBuffer,&b)) {
        return(FALSE);
    }

    if(b) {
        _Log("Needed clusters for bitmap are free\n");
    } else {
        _Log("Needed clusters for bitmap are not free\n");
        PartitionImage->Flags |= PARTIMAGE_RELOCATE_BITMAP;
    }

    return(TRUE);
}


BOOL
NeedToRelocBootPart(
    IN     FPMASTER_DISK     MasterDisk,
    IN OUT FPPARTITION_IMAGE PartitionImage,
    IN     UINT              FileHandle,
    IN OUT FPBYTE            ClusterBuffer
    )
{
    ULONG Cluster0Sector;
    ULONG FirstUnused;
    ULONG FirstCluster;
    ULONG LastCluster;
    ULONG NeededClusters;
    ULONG StartupPartitionStartSector;
    ULONG StartupPartitionSectorCount;
    BOOL b;

    //
    // Calculate the first physical sector corresponding to cluster 0
    // in the restored volume, and the first physical sector past the last
    // used cluster in the restored volume.
    //
    Cluster0Sector = MasterDisk->OriginalSectorsPerTrack + PartitionImage->NonClusterSectors + FreeSpaceStart;
    FirstUnused = Cluster0Sector + ((PartitionImage->LastUsedCluster+1) * PartitionImage->SectorsPerCluster);

    _Log("Volume cluster 0 sector = 0x%lx\n",Cluster0Sector);
    _Log("Volume first unused sector = 0x%lx\n",FirstUnused);

    //
    // If the boot partition is in space we know for sure is free, then
    // it does not need to be relocated.
    //
    // We offset the start of the MPK boot partition by Fat32ResizeMaxOffset 
    // sectors at the front of the allocation in order to anticipate FAT expansion.
    //
    // Fat32ResizeMaxOffset will be zero for a non-FAT32 image and 
    // will have no effect in that case.  
    //
    StartupPartitionStartSector = MasterDisk->StartupPartitionStartSector - Fat32ResizeMaxOffset;
    StartupPartitionSectorCount = MasterDisk->StartupPartitionSectorCount + Fat32ResizeMaxOffset;

    if(StartupPartitionStartSector >= FirstUnused) {
        _Log("Boot partition is past end of used space in volume\n");
        return(TRUE);
    }

    //
    // Figure out which clusters in the restored volume are occupied by the
    // boot partition.
    //
    FirstCluster = (StartupPartitionStartSector - Cluster0Sector)
                 / PartitionImage->SectorsPerCluster;

    LastCluster = (((StartupPartitionStartSector + StartupPartitionSectorCount) - 1) - Cluster0Sector)
                / PartitionImage->SectorsPerCluster;

    _Log("First/last clusters used by boot partition: 0x%lx/0x%lx\n",FirstCluster,LastCluster);

    if(LastCluster > PartitionImage->LastUsedCluster) {
        LastCluster = PartitionImage->LastUsedCluster;
        _Log("(last cluster adjusted to 0x%lx)\n",LastCluster);
    }

    NeededClusters = (LastCluster - FirstCluster) + 1;
    _Log("Need 0x%lx clusters free in volume to encompass boot partition.\n",NeededClusters);

    //
    // Determine whether these clusters are free in the volume
    //
    if(!IsClusterRunFree(FileHandle,PartitionImage,FirstCluster,NeededClusters,ClusterBuffer,&b)) {
        return(FALSE);
    }

    if(b) {
        _Log("Needed clusters for boot partition are free\n");
    } else {
        _Log("Needed clusters for boot partition are not free\n");
        PartitionImage->Flags |= PARTIMAGE_RELOCATE_BOOT;
    }

    return(TRUE);
}


BOOL
IsClusterRunFree(
    IN     UINT              FileHandle,
    IN     FPPARTITION_IMAGE PartitionImage,
    IN     ULONG             StartCluster,
    IN     ULONG             ClusterCount,
    IN OUT FPBYTE            ClusterBuffer,
    OUT    BOOL             *Free
    )
{
    ULONG Count;
    UINT Bit;
    ULONG Offset;
    UINT Read;

    *Free = FALSE;

    _Log("   Checking if cluster run is free: start 0x%lx, length 0x%lx\n",StartCluster,ClusterCount);

    //
    // Calculate the offset in the file to the sector of the
    // cluster bitmap continaing the entry for the start cluster.
    //
    Offset = 1 + PartitionImage->NonClusterSectors
           + (PartitionImage->UsedClusterCount * PartitionImage->SectorsPerCluster);

    Offset += StartCluster / (8*512);

    _Log("   Offset in image file to cluster bitmap = 0x%lx sectors\n",Offset);

    Offset *= 512;

    if(DosSeek(FileHandle,Offset,DOSSEEK_START) != Offset) {
        fprintf(stderr,"\n%s\n",textCantAccessImageFile);
        return(FALSE);
    }

    if(_dos_read(FileHandle,ClusterBuffer,512,&Read) || (Read != 512)) {
        fprintf(stderr,"\n%s\n",textCantAccessImageFile);
        return(FALSE);
    }

    Offset = (StartCluster % (8*512)) / 8;
    Bit = (UINT)(StartCluster % 8);
    Count = 0;

    _Log("   Start byte/bit in cluster buffer: %u/%u\n",Offset,Bit);

    while((StartCluster < PartitionImage->LastUsedCluster) && !(ClusterBuffer[Offset] & BitValue[Bit])) {

        if(++Count == ClusterCount) {
            _Log("   Range is free\n");
            *Free = TRUE;
            return(TRUE);
        }

        StartCluster++;

        Bit++;
        if(Bit == 8) {
            Bit = 0;
            Offset++;
            if((Offset == 512) && (StartCluster < PartitionImage->LastUsedCluster)) {

                if(_dos_read(FileHandle,ClusterBuffer,512,&Read) || (Read != 512)) {
                    fprintf(stderr,"\n%s\n",textCantAccessImageFile);
                    return(FALSE);
                }

                Offset = 0;
            }
        }
    }

    _Log("   Range is not free\n");
    return(TRUE);
}


BOOL
IsRunGoodForRelocations(
    IN     ULONG          ImageStart,
    IN     ULONG          ImageLength,
    IN     FPMASTER_DISK  MasterDisk,
    IN OUT ULONG         *RunStart,
    IN     ULONG          RunLength,
    IN     ULONG          SectorsNeeded
    )
{
    ULONG RunEnd;
    ULONG ImageEnd;

    _Log("   Check if run is ok for reloc, run start = 0x%lx, len = 0x%lx\n",*RunStart,RunLength);

    //
    // Firstly, the run has to be large enough.
    //
    if(RunLength < SectorsNeeded) {
        _Log("   Run is too small\n");
        return(FALSE);
    }

    _Log("      Image start = 0x%lx, length = 0x%lx\n",ImageStart,ImageLength);
    _Log("      Boot start = 0x%lx, length = 0x%lx\n",MasterDisk->StartupPartitionStartSector,MasterDisk->StartupPartitionSectorCount);

    //
    // Secondly, the run must not overlap the on-disk image.
    //
    if((*RunStart + SectorsNeeded) > ImageStart) {
        //
        // There's not enough space at the start of the run.
        // We need to see whether there's enough space at the end.
        //
        _Log("   Not enough space at head of run\n");

        RunEnd = *RunStart + RunLength;
        ImageEnd = ImageStart + ImageLength;

        if((RunEnd - SectorsNeeded) < ImageEnd) {
            //
            // Not enough space at the end either.
            //
            _Log("   Not enough space at end either\n");
            return(FALSE);
        }

        //
        // There could be enough space at the end of the run.
        // Adjust the run parameters in preparation for checking for
        // overlap with the boot partition.
        //
        if(*RunStart < ImageEnd) {
            _Log("   Run starts inside image, adjusting run start\n");
            *RunStart = ImageEnd;
        } else {
            _Log("   Run is entirely past end of image\n");
        }

        //
        // Note: we don't check for the case where the run is somehow
        // further out on the disk than the bootup partition. We assume
        // the start of the boot partition is a magic boundary.
        //
        if((*RunStart + SectorsNeeded) <= MasterDisk->StartupPartitionStartSector) {
            _Log("   Run is acceptable\n");
            return(TRUE);
        } else {
            _Log("   Run overlaps boot partition\n");
            return(FALSE);
        }

    } else {
        //
        // There's enough space at the start of the run.
        // We assume that the image is nearer to the start of the disk
        // than than the boot partition is, so in this case we don't
        // need to check anything else, we're done.
        //
        _Log("   There's enough space at head of run\n");
        return(TRUE);
    }
}

BOOL 
DetermineIfEisaPartitionExists(
    IN HDISK                    DiskHandle,
    IN VOID*                    IoBuffer,
    IN FPPARTITION_TABLE_ENTRY  pPartitionTable
    )
{
    UCHAR i;
    BOOL found;

    //
    // Suck in the MBR
    //
    if(!ReadDisk(DiskHandle,0,1,IoBuffer)) {
        fprintf(stderr,textDiskReadError,0);
        fprintf(stderr,"\n");
        return(FALSE);
    }

    //
    // Validate that it is a good MBR.
    //
    if( ((FPMBR)IoBuffer)->AA55Signature != BOOT_RECORD_SIGNATURE ) {
        fprintf(stderr,textDiskReadError,0);
        _Log("   WARNING: The MBR was invalid!");
        return FALSE;
    }

    //
    // Save away the partition table into the buffer we were passed.
    //
    memcpy(pPartitionTable,
           ((FPMBR)IoBuffer)->PartitionTable,
           sizeof(PARTITION_TABLE_ENTRY) * NUM_PARTITION_TABLE_ENTRIES);

    //
    // Now walk the entries, looking for non-recognized partition types. 
    // We assume these are EISA or hiber partitions.
    //

    found = FALSE;
    for( i=0; i<NUM_PARTITION_TABLE_ENTRIES;i++ ) {
        if( IsUnknownPartition(pPartitionTable[i].SysId) ) {
            //
            // Non-recognized, keep it.
            //
            found = TRUE;
        } else {
            //
            // nuke the partition
            //
            memset( &(pPartitionTable[i]), 0, sizeof(PARTITION_TABLE_ENTRY) );
        }
    }

    //
    // If these exist, return true. Otherwise return false.
    //
    return found;
}

ULONG
DetermineHighestSectOccupied(
    IN FPPARTITION_TABLE_ENTRY pPartitionTable,
    IN BYTE SectorsPerTrack,
    IN USHORT Heads
    )
{
    UINT    i;
    ULONG   OccupiedSect;
    ULONG   tempSect;

    //
    // Walk the partition table, look for the highest used cylinder.
    // Since this is called to preserve EISA or hiber partitions, we
    // can assume they reside at the beginning of the disk.
    //
    OccupiedSect = 0;
    _Log("Determining highest occupied sector...\n");

    for( i=0; i<NUM_PARTITION_TABLE_ENTRIES;i++ ) {
        if( IsUnknownPartition( pPartitionTable[i].SysId )) {
            //
            // Non-recognized!
            //
            _Log("A non-recognized partition exists!\n");
            tempSect = (pPartitionTable[i].Start + pPartitionTable[i].Count);
            if( OccupiedSect < tempSect  ) {
                //
                // track align the highest used sector -- anything below this is off limits
                //
                OccupiedSect = tempSect;
                _Log("New highest occupied sector is %ld\n",OccupiedSect);
                if(OccupiedSect % SectorsPerTrack) {
                    OccupiedSect = OccupiedSect + (SectorsPerTrack - (OccupiedSect % SectorsPerTrack));
                }
            }                      
        }    
    }
    _Log("Highest occupied sector (track-aligned) is %ld\n",OccupiedSect);
    return OccupiedSect;
}


BOOL
RestorePartitionTable(
    IN HDISK                    DiskHandle,
    IN VOID*                    IoBuffer,
    IN FPPARTITION_TABLE_ENTRY  pPartitionTable
    )
{
    int i,j;
    FPMBR theMBR = ((FPMBR)IoBuffer);

    //
    // Load the MBR back in, drop our old partition info back in.
    //
    if(!ReadDisk(DiskHandle,0,1,IoBuffer) ) {
        fprintf(stderr,textDiskReadError,0);
        fprintf(stderr,"\n");
        return(FALSE);
    }
        
    
    //
    // Validate that it is a good MBR.
    //
    if( theMBR->AA55Signature != BOOT_RECORD_SIGNATURE ) {
        fprintf(stderr,textDiskReadError,0);
        _Log("   WARNING: The MBR was invalid!");
        return FALSE;
    }
    
    //
    // Restore the original partitions.
    //
    for(i=0;i<NUM_PARTITION_TABLE_ENTRIES;i++){
        if(IsUnknownPartition(pPartitionTable[i].SysId)
           && (pPartitionTable[i].SysId != 0)) {
            j = FindFirstUnusedEntry(theMBR->PartitionTable);
            if( j != -1 ) {            
                memcpy(&(theMBR->PartitionTable[j]),
                       &(pPartitionTable[i]),
                       sizeof(PARTITION_TABLE_ENTRY));
            } else {
                fprintf(stderr,textTooManyPartitions);
                fprintf(stderr,"\n");
                return(FALSE);
            }
        }
    }

    if(!WriteDisk(DiskHandle,0,1,IoBuffer)) {
        fprintf(stderr,textDiskWriteError,0);
        fprintf(stderr,"\n");
        return(FALSE);
    }

    return TRUE;
}

BOOL
IsUnknownPartition(
    IN BYTE SysId 
    )
{
    if( SysId != 0x00 && // not unused
        SysId != 0x01 &&
        SysId != 0x04 &&
        SysId != 0x06 &&
        SysId != 0x07 &&
        SysId != 0x0b &&
        SysId != 0x0c &&
        SysId != 0x0e ) {
        return TRUE;
    }

    return FALSE;
}

BYTE
FindFirstUnusedEntry(
    IN FPPARTITION_TABLE_ENTRY  pPartitionTable
    ) 
{
    BYTE i;

    for(i=0;i<NUM_PARTITION_TABLE_ENTRIES;i++){
        if(pPartitionTable[i].SysId == 0) {
            return i;
        }
    }
    
    return -1;                           
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\mpk\misclib\codepage.asm ===
DOSSEG
        .MODEL LARGE

        .CODE

        ConDevName db 'CON',0

.286

;++
;
;   unsigned
;   _far
;   GetGlobalCodepage(
;       VOID
;       );
;
; Routine Description:
;
;    Fetch the active global codepage
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    0 - error
;    non-0 - codepage
;
;--

        public _GetGlobalCodepage
_GetGlobalCodepage proc far

        push    bp
        mov     bp,sp

        push    ds
        push    es
        push    bx
        push    si
        push    di

        mov     ax,6601h
        int     21h
        mov     ax,0                    ; don't clobber carry
        jc      ggexit
        mov     ax,bx
ggexit:
        pop     di
        pop     si
        pop     bx
        pop     es
        pop     ds

        leave
        retf

_GetGlobalCodepage endp


;++
;
;   unsigned
;   _far
;   GetScreenCodepage(
;       VOID
;       );
;
; Routine Description:
;
;    Fetch the active codepage in use for the screen (device CON).
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    0 - error
;    non-0 - codepage
;
;--

getcp_packet   equ byte ptr [bp-30]
getcp_codepage equ word ptr [bp-28]

        public _GetScreenCodepage
_GetScreenCodepage proc far

        push    bp
        mov     bp,sp
        sub     sp,30

        push    ds
        push    es
        push    bx
        push    si
        push    di

        ;
        ; Open CON
        ;
        push    cs
        pop     ds
        mov     dx,offset CS:ConDevName ; ds:dx -> device name
        mov     ax,3d02h
        int     21h
        jnc     @f
        mov     ax,0                    ; preserves carry
        jmp     short gsdone

@@:     mov     bx,ax                   ; bx = handle to CON device
        push    bx                      ; save handle for later
        mov     ax,440ch                ; generic char device ioctl
        mov     cx,36ah                 ; query selected codepage for console
        push    ss
        pop     ds
        lea     dx,getcp_packet         ; ds:dx -> return packet
        int     21h
        mov     ax,0                    ; assume error
        pop     bx                      ; bx = CON device handle
        jc      gsdone1
        mov     ax,getcp_codepage       ; ax = active codepage for CON device

gsdone1:
        push    ax                      ; save return code
        mov     ah,3eh                  ; bx set from above
        int     21h                     ; close CON device
        pop     ax                      ; restore return code

gsdone:
        pop     di
        pop     si
        pop     bx
        pop     es
        pop     ds

        leave
        retf

_GetScreenCodepage endp


;++
;
;   BOOL
;   _far
;   SetGlobalCodepage(
;       IN unsigned Codepage
;       );
;
; Routine Description:
;
;    Set the active global codepage (equivalent to chcp x).
;
; Arguments:
;
;    Codepage - supplies the codepage id
;
; Return Value:
;
;    Boolean value indicating outcome.
;
;--

Codepage equ word ptr [bp+6]

        public _SetGlobalCodepage
_SetGlobalCodepage proc far

        push    bp
        mov     bp,sp

        push    ds
        push    es
        push    bx
        push    si
        push    di

        mov     ax,6602h
        mov     bx,Codepage
        int     21h
        mov     ax,0                    ; don't clobber carry
        jc      sgexit
        inc     ax
sgexit:
        pop     di
        pop     si
        pop     bx
        pop     es
        pop     ds

        leave
        retf

_SetGlobalCodepage endp

;++
;
;   BOOL
;   _far
;   SetScreenCodepage(
;       IN unsigned Codepage
;       );
;
; Routine Description:
;
;    Set the active codepage for the screen (equivalent to
;    mode con cp select=x).
;
; Arguments:
;
;    Codepage - supplies the codepage id
;
; Return Value:
;
;    Boolean value indicating outcome.
;
;--

Codepage equ word ptr [bp+6]

setcp_packet   equ word ptr [bp-4]
setcp_codepage equ word ptr [bp-2]

        public _SetScreenCodepage
_SetScreenCodepage proc far

        push    bp
        mov     bp,sp
        sub     sp,4

        push    ds
        push    es
        push    bx
        push    si
        push    di

        ;
        ; Open CON
        ;
        push    cs
        pop     ds
        mov     dx,offset CS:ConDevName ; ds:dx -> device name
        mov     ax,3d02h
        int     21h
        jnc     @f
        mov     ax,0                    ; preserves carry
        jmp     short ssdone

@@:     mov     bx,ax                   ; bx = handle to CON device
        push    bx                      ; save handle for later
        mov     cx,34ah                 ; set selected codepage for console
        push    ss
        pop     ds
        lea     dx,setcp_packet         ; ds:dx -> param packet
        mov     ax,Codepage
        mov     setcp_codepage,ax
        mov     setcp_packet,2
        mov     ax,440ch                ; generic char device ioctl
        int     21h
        mov     ax,0                    ; assume error, ax = FALSE
        pop     bx                      ; bx = CON device handle
        jc      ssdone1
        inc     ax                      ; ax = TRUE;

ssdone1:
        push    ax                      ; save return code
        mov     ah,3eh                  ; bx set from above
        int     21h                     ; close CON device
        pop     ax                      ; restore return code

ssdone:
        pop     di
        pop     si
        pop     bx
        pop     es
        pop     ds

        leave
        retf

_SetScreenCodepage endp

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\mpk\misclib\confirm.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    confirm.c

Abstract:

    Routine to allow the user to confirm an operation
    with a y/n response.

Author:

    Ted Miller (tedm) 29-May-1997

Revision History:

--*/

#include <mytypes.h>
#include <misclib.h>

#include <stdio.h>
#include <conio.h>
#include <ctype.h>


BOOL
_far
ConfirmOperation(
    IN FPCHAR ConfirmationText,
    IN char   textYesChar,
    IN char   textNoChar
    )
{
    char c;

    printf(ConfirmationText);
    printf(" ");

    prompt:

    c = (char)getch();

    if(toupper(c) == toupper(textYesChar)) {
        printf("%c\n\n",c);
        return(TRUE);
    }

    if(toupper(c) == toupper(textNoChar)) {
        printf("%c\n\n",c);
        return(FALSE);
    }

    goto prompt;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\mpk\misclib\compress.c ===
#include <mytypes.h>
#include <misclib.h>
#include <dos.h>
#include <string.h>
#define BIT16
#include "mrcicode.h"



unsigned
CompressData(
    IN  CompressionType Type,
    IN  FPBYTE          Data,
    IN  unsigned        DataSize,
    OUT FPBYTE          CompressedData,
    IN  unsigned        BufferSize
    )
{
    unsigned u;

    switch(Type) {

    case CompressNone:
    default:
        //
        // Force caller to do something intelligent, such as
        // writing directly out of the uncompressed buffer.
        // This avoids an extra memory move.
        //
        u = (unsigned)(-1);
        break;

    case CompressMrci1:
        u = Mrci1MaxCompress(Data,DataSize,CompressedData,BufferSize);
        break;

    case CompressMrci2:
        u = Mrci2MaxCompress(Data,DataSize,CompressedData,BufferSize);
        break;
    }

    return(u);
}


unsigned
DecompressData(
    IN  CompressionType Type,
    IN  FPBYTE          CompressedData,
    IN  unsigned        CompressedDataSize,
    OUT FPBYTE          DecompressedData,
    IN  unsigned        BufferSize
    )
{
    unsigned u;

    switch(Type) {

    case CompressNone:
        if(BufferSize >= CompressedDataSize) {
            memmove(DecompressedData,CompressedData,CompressedDataSize);
            u = CompressedDataSize;
        } else {
            u = (unsigned)(-1);
        }
        break;

    case CompressMrci1:
        u = Mrci1Decompress(CompressedData,CompressedDataSize,DecompressedData,BufferSize);
        break;

    case CompressMrci2:
        u = Mrci2Decompress(CompressedData,CompressedDataSize,DecompressedData,BufferSize);
        break;

    default:
        u = (unsigned)(-1);
        break;
    }

    return(u);
}


BOOL
CompressAndSave(
    IN  CompressionType Type,
    IN  FPBYTE          Data,
    IN  unsigned        DataSize,
    OUT FPBYTE          CompressScratchBuffer,
    IN  unsigned        BufferSize,
    IN  UINT            FileHandle
    )
{
    unsigned u;
    unsigned Size;
    unsigned Written;
    FPBYTE p;

    //
    // Need high bit for private use so max data size is 32K.
    // Also disallow 0.
    //
    if(!DataSize || (DataSize > 32768)) {
        return(FALSE);
    }

    //
    // Compress the data.
    //
    u = CompressData(Type,Data,DataSize,CompressScratchBuffer,BufferSize);
    if((u == (unsigned)(-1)) || ((u + sizeof(unsigned)) >= DataSize)) {
        //
        // Data expanded or didn't compress enough to make it
        // worthwhile to store it in compressed form.
        //
        // Store the data size minus 1 with the high bit set to indicate
        // that the data is not compressed.
        //
        Size = DataSize;
        u = (DataSize - 1) | 0x8000;
        p = Data;
    } else {
        //
        // Data has compressed nicely. Store the data size minus 1.
        //
        Size = u;
        u = u-1;
        p = CompressScratchBuffer;
    }

    //
    // Write the header to the file, unless compression type is none.
    //
    if(Type != CompressNone) {
        if(_dos_write(FileHandle,&u,sizeof(unsigned),&Written) || (Written != sizeof(unsigned))) {
            return(FALSE);
        }
    }

    //
    // Write the data to the file.
    //
    if(_dos_write(FileHandle,p,Size,&Written) || (Written != Size)) {
        return(FALSE);
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\mpk\misclib\dosseek.asm ===
DOSSEG
        .MODEL LARGE

        .CODE

.286

Handle  equ word ptr [bp+6]
Offsetl equ word ptr [bp+8]
Offseth equ word ptr [bp+10]
Origin  equ byte ptr [bp+12]

        public _DosSeek
_DosSeek proc far

        push    bp
        mov     bp,sp

        push    si
        push    di
        push    bx
        push    ds
        push    es

        mov     ah,42h
        mov     al,Origin
        mov     bx,Handle
        mov     cx,Offseth
        mov     dx,Offsetl

        int     21h
        jnc     @f              ; dx:ax already set for return

        mov     ax,0ffh
        cwd                     ; -1 error return

@@:
        pop     es
        pop     ds
        pop     bx
        pop     di
        pop     si

        leave
        retf

_DosSeek endp

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\mpk\misclib\mastdisk.c ===
#include <mytypes.h>
#include <misclib.h>
#include <diskio.h>
#include <partimag.h>


BOOL
_far
IsMasterDisk(
    IN  UINT   DiskId,
    OUT FPVOID IoBuffer
    )
{
    BOOL b;
    HDISK hDisk;
    PMASTER_DISK p;

    b = FALSE;
    if(hDisk = OpenDisk(DiskId)) {

        if(ReadDisk(hDisk,1,1,IoBuffer)) {

            p = IoBuffer;

            if((p->Signature == MASTER_DISK_SIGNATURE)
            && (p->Size == sizeof(MASTER_DISK))
            && p->StartupPartitionStartSector) {

                b = TRUE;
            }
        }

        CloseDisk(hDisk);
    }

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\mpk\misclib\disksel.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    disksel.c

Abstract:

    Routine to allow the user to select a disk
    from a list of disks. The UI is a simple character-based
    deal.

Author:

    Ted Miller (tedm) 29-May-1997

Revision History:

--*/

#include <mytypes.h>
#include <misclib.h>
#include <diskio.h>
#include <partimag.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>


typedef
BOOL
(*PDISKSEL_VALIDATION_ROUTINE) (
    IN USHORT DiskId
    );


INT
_far
SelectDisk(
    IN  UINT                         DiskCount,
    IN  FPCHAR                       Prompt,
    IN  PDISKSEL_VALIDATION_ROUTINE  Validate,          OPTIONAL
    OUT char                        *AlternateResponse, OPTIONAL
    IN  FPCHAR                       textDisk,
    IN  FPCHAR                       textPaddedMbCount,
    IN  FPCHAR                       textInvalidSelection,
    IN  FPCHAR                       textMasterDisk
    )
{
    UINT i,l;
    BYTE Int13Unit;
    BYTE SectorsPerTrack;
    USHORT Heads;
    USHORT Cylinders;
    ULONG SectorCount;
    UINT Selection;
    CHAR line[256];
    FPVOID Buffer,OriginalBuffer;

    if(!AllocTrackBuffer(1,&Buffer,&OriginalBuffer)) {
        Buffer = NULL;
        OriginalBuffer = NULL;
    }

    select:
    printf("\n\n");

    for(i=0; i<DiskCount; i++) {

        if(Validate ? Validate(i) : TRUE) {

            printf("%2u) ",i+1);

            GetDiskInfoById(
                i,
                0,
                &Int13Unit,
                &SectorsPerTrack,
                &Heads,
                &Cylinders,
                &SectorCount
                );

            if(!SectorCount) {
                SectorCount = (ULONG)Heads * (ULONG)Cylinders * (ULONG)SectorsPerTrack;
            }

            printf(" ");
            if(Int13Unit) {
                printf(textDisk);
                printf(" ");
                printf("%2x",Int13Unit);
            } else {
                l = strlen(textDisk) + 3;
                while(l) {
                    printf(" ");
                    l--;
                }
            }
            printf("  ");
            printf(textPaddedMbCount,SectorCount / 2048);

            if(Buffer && IsMasterDisk(i,Buffer)) {
                printf("   %s",textMasterDisk);
            }

            printf("\n");
        }
    }

    printf("\n%s ",Prompt);
    gets(line);
    Selection = atoi(line);

    if(!Selection || (Selection > DiskCount)) {
        if(AlternateResponse) {
            strcpy(AlternateResponse,line);
            if(OriginalBuffer) {
                free(OriginalBuffer);
            }
            return(-1);
        } else {
            printf("\n\n%s\n",textInvalidSelection);
            goto select;
        }
    }

    if(Validate && !Validate(Selection-1)) {
        printf("\n\n%s\n",textInvalidSelection);
        goto select;
    }

    if(OriginalBuffer) {
        free(OriginalBuffer);
    }
    return(Selection-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\mpk\misclib\log.c ===
#include <mytypes.h>
#include <misclib.h>

#include <stdio.h>
#include <malloc.h>
#include <string.h>
#include <stdarg.h>


char *_LogFilename;
FILE *_LogFile;
unsigned _LogFlags;


VOID
_LogStart(
    IN char *FileName
    )
{
    if(_LogFilename = strdup(FileName)) {
        // changed to append to match requested behavior
        if(_LogFile = fopen(_LogFilename,"at")) {
            _Log("\n*** Logging started\n\n");
        } else {
            free(_LogFilename);
        }
    }
}


VOID
_LogEnd(
    VOID
    )
{
    if(_LogFile) {
        _Log("\n*** Logging terminated\n\n");
        //fflush(_LogFile);
        fclose(_LogFile);
        _LogFile = NULL;
    }
}


VOID
_LogSetFlags(
    IN unsigned Flags
    )
{
    _LogFlags = Flags;
}


VOID
_Log(
    IN char *FormatString,
    ...
    )
{
    va_list arglist;

    if(!_LogFile) {
        return;
    }

    va_start(arglist,FormatString);

    vfprintf(_LogFile,FormatString,arglist);

    va_end(arglist);

    //fflush(_LogFile);
    if(_LogFlags & LOGFLAG_CLOSE_REOPEN) {
        fclose(_LogFile);
        _LogFile = fopen(_LogFilename,"at");
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\mpk\misclib\flush.asm ===
DOSSEG
        .MODEL LARGE

        .CODE

.286

        public _FlushDisks
_FlushDisks proc far

        push    ds
        push    es
        pusha
        mov     ah,0dh
        int     21h
        popa
        pop     es
        pop     ds
        retf

_FlushDisks endp

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\mpk\misclib\mrcicode.c ===
/*
 *  Microsoft Confidential
 *  Copyright (c) 1994 Microsoft Corporation
 *  All Rights Reserved.
 *
 *  MRCICODE.C
 *
 *  MRCI 1 & MRCI 2 maxcompress and decompress functions
 */
#define BIT16
#include "mrcicode.h"                   /* prototype verification */

#define NDEBUG                          /* turn off assertions */
#include <assert.h>                     /* use NDEBUG to inhibit */
#include <setjmp.h>                     /* fast overflow recovery */

#define LOGCHASH        (13)            /* Log of max. no. of hash buckets */
#define CHASH           (1U << LOGCHASH) /* Reasonably large table */

#define hash(w)         ((w) & (CHASH - 1))
                                        /* Simply toss the high-order bits */
#define word(p)         ((p)[0] + (((p)[1]) << 8))
                                        /* Return word at location */

#define BITMASK(x)      ((1 << x) - 1)  /* returns lower 'x' bits set */

#define LOGDISPSMALL    (6)             /* Number of bits in small disp */
#define LOGDISPMED      (8)             /* Number of bits in medium disp */
#define LOGDISPBIG      (12)            /* Number of bits in big displacement */

#define MAXDISPSMALL    ((1 << LOGDISPSMALL) - 1)
                                        /* Maximum small displacement */
#define MAXDISPMED      ((1 << LOGDISPMED) + MAXDISPSMALL)
                                        /* Maximum medium displacement */
#define MAXDISPBIG      ((1 << LOGDISPBIG) + MAXDISPMED)
                                        /* Maximum big displacement */

#define MINDISPSMALL    (0)             /* Minimum small displacement */
#define MINDISPMED      (MAXDISPSMALL + 1)
                                        /* Minimum medium displacement */
#define MINDISPBIG      (MAXDISPMED + 1)/* Minimum big displacement */

#define DISPMAX         (MAXDISPBIG - 1)/* MAXDISPBIG is our end marker */

#define MINMATCH1       (2)             /* Minimum match length for MRCI1 */
#define MINMATCH2       (3)             /* Minimum match length for MRCI2 */
#define MAXMATCH        (512)           /* Maximum match length */

#define EOB             (0)             /* length used to mean end of block */

#define SECTOR          (512)           /* blocking factor */

#define SIG_SIZE        (4)             /* # of block type prefix bytes */


/* local variables */

#ifdef BIT16
#define     FARBSS      _far
#else
#define     FARBSS
#endif

static unsigned abits;                  /* Array of bits */
static unsigned cbitsleft;              /* Number of bits in abits */
static unsigned char FAR *pCompressed;  /* pointer into compressed data */
static unsigned cCompressed;            /* # bytes remaining @ pCompressed */
static jmp_buf bailout;                 /* longjmp if cCompressed exceeded */

static unsigned FARBSS ahash[CHASH];    /* Hash table */
static unsigned FARBSS alink[MAXDISPBIG];  /* Links */


/* compression internal functions */

#ifdef BIT16
#define  FAST  _near _pascal            /* speed up local calls */
#else
#define  FAST
#endif

static void FAST inithash(void);
static void FAST charbuf(unsigned c);
static void FAST putbits(unsigned bits,unsigned cbits);
static void FAST outlength(unsigned cb);

static void FAST mrci1outsingle(unsigned ch);
static void FAST mrci1outstring(unsigned disp,unsigned cb);

static void FAST mrci2outsingle(unsigned ch);
static void FAST mrci2outstring(unsigned disp,unsigned cb);


/* decompression internal functions */

static unsigned FAST getbit(void);
static unsigned FAST getbits(unsigned cbits);
static void FAST expandstring(unsigned char FAR **ppchout,unsigned disp,
        unsigned cb);


/*
 *  (compress) Reset the hash tables between blocks.
 */

static void FAST inithash(void)
{
    unsigned FAR *entry;
    int i;

    entry = ahash;
    i = CHASH;

    do
    {
        *entry++ = (unsigned) -1;       /* Mark all entries as empty */
    } while (--i);
}


/*
 *  (compress) Add a character to compressed output buffer.
 */

static void FAST charbuf(unsigned c)
{
    if (cCompressed-- == 0)             /* make sure there's room */
    {
        longjmp(bailout,1);             /* Data expanding! */
    }

    *pCompressed++ = (unsigned char) c; /* Put character into buffer */
}


/*
 *  (compress) Write n bits to the compressed bitstream.
 */

static void FAST putbits(unsigned ab,unsigned cbits)
{
    do                                  /* Loop to emit bits */
    {
        if (cbits > cbitsleft)          /* if not enough space */
        {
            cbits -= cbitsleft;         /* doing partial */

            abits |= (ab << (8 - cbitsleft));
                                        /* Put bits in output buffer */

            ab >>= cbitsleft;           /* clip sent bits */

            charbuf(abits);             /* Emit the buffer */
            cbitsleft = 8;              /* Reset buffer count */
            abits = 0;                  /* Reset buffer */
        }
        else                            /* can do all in one pass */
        {
            abits |= ((ab & BITMASK(cbits)) << (8 - cbitsleft));
                                        /* Put bits in output buffer */

            cbitsleft -= cbits;         /* used up some buffer */

            if (cbitsleft == 0)         /* If buffer full */
            {
                charbuf(abits);         /* Emit the buffer */
                cbitsleft = 8;          /* Reset buffer count */
                abits = 0;              /* Reset buffer */
            }

            break;                      /* we've done all cbits */
        }
    } while (cbits);                    /* repeat until done */
}


/*
 *  (compress) Encode a length into the compressed stream.
 */

static void FAST outlength(unsigned cb)
{
    unsigned alogbits, clogbits;
    unsigned avaluebits, cvaluebits;

    assert(cb >= 2);                    /* Length must be at least two */
    assert(cb <= MAXMATCH);

    if (cb <= 2)
    {
        alogbits = 1;
        clogbits = 1;
        cvaluebits = 0;
    }
    else if (cb <= 4)
    {
        alogbits = 1 << 1;
        clogbits = 2;
        avaluebits = cb - 3;
        cvaluebits = 1;
    }
    else if (cb <= 8)
    {
        alogbits = 1 << 2;
        clogbits = 3;
        avaluebits = cb - 5;
        cvaluebits = 2;
    }
    else if (cb <= 16)
    {
        alogbits = 1 << 3;
        clogbits = 4;
        avaluebits = cb - 9;
        cvaluebits = 3;
    }
    else if (cb <= 32)
    {
        alogbits = 1 << 4;
        clogbits = 5;
        avaluebits = cb - 17;
        cvaluebits = 4;
    }
    else if (cb <= 64)
    {
        alogbits = 1 << 5;
        clogbits = 6;
        avaluebits = cb - 33;
        cvaluebits = 5;
    }
    else if (cb <= 128)
    {
        alogbits = 1 << 6;
        clogbits = 7;
        avaluebits = cb - 65;
        cvaluebits = 6;
    }
    else if (cb <= 256)
    {
        alogbits = 1 << 7;
        clogbits = 8;
        avaluebits = cb - 129;
        cvaluebits = 7;
    }
    else /* (cb <= 512) */
    {
        alogbits = 1 << 8;
        clogbits = 9;
        avaluebits = cb - 257;
        cvaluebits = 8;
    }

    putbits(alogbits,clogbits);

    if (cvaluebits)
    {
        putbits(avaluebits,cvaluebits);
    }
}


/*
 *  (MRCI1 compress) Encode a literal into the compressed stream.
 */

static void FAST mrci1outsingle(unsigned ch)
{
    ch = (ch << 2) | ((ch & 0x80) ? 1 : 2);

    putbits(ch,9);
}


/*
 *  (MRCI2 compress) Encode a literal into the compressed stream.
 */

static void FAST mrci2outsingle(unsigned ch)
{
    if (ch & 0x80)
    {
        putbits((ch << 2) | 3,9);
    }
    else
    {
        putbits(ch << 1,8);
    }
}


/*
 *  (MRCI1 compress) Encode a match into the compressed stream.
 */

static void FAST mrci1outstring(unsigned disp,unsigned cb)
{
    assert(((cb >= MINMATCH1) && (disp != 0) && (disp < MAXDISPBIG)) ||
            ((cb == EOB) && (disp == MAXDISPBIG)));

    if (disp <= MAXDISPSMALL)
    {
        putbits(((disp - MINDISPSMALL) << 2),LOGDISPSMALL + 2);
                                        /* Put small displacement */
    }
    else if (disp <= MAXDISPMED)
    {
        putbits(((disp - MINDISPMED) << 3) | 3,LOGDISPMED + 3);
                                        /* Put medium displacement */
    }
    else
    {
        putbits(((disp - MINDISPBIG) << 3) | 7,LOGDISPBIG + 3);
                                        /* Put big displacement */
    }

    if (cb != EOB)                      /* If not an end marker */
    {
        outlength(cb);                  /* Emit the match length */
    }
}


/*
 *  (MRCI2 compress) Encode a match into the compressed stream.
 */

static void FAST mrci2outstring(unsigned disp,unsigned cb)
{
    assert(((cb >= MINMATCH2) && (disp != 0) && (disp < MAXDISPBIG)) ||
            ((cb == EOB) && (disp == MAXDISPBIG)));

    if (disp <= MAXDISPSMALL)
    {
        putbits(((disp - MINDISPSMALL) << 3) | 1,LOGDISPSMALL + 3);
                                        /* Put small displacement */
    }
    else if (disp <= MAXDISPMED)
    {
        putbits(((disp - MINDISPMED) << 4) | 5,LOGDISPMED + 4);
                                        /* Put medium displacement */
    }
    else
    {
        putbits(((disp - MINDISPBIG) << 4) | 13,LOGDISPBIG + 4);
                                        /* Put big displacement */
    }

    if (cb != EOB)                      /* If not an end marker */
    {
        outlength(cb - 1);              /* Emit the match length */
    }
}


/*
 *  (MRCI1) MaxCompress
 */

unsigned Mrci1MaxCompress(unsigned char FAR *pchbase,unsigned cchunc,
        unsigned char FAR *pchcmpBase,unsigned cchcmpMax)
{
    unsigned cchbest;                   /* Length of best match */
    unsigned cchmatch;                  /* Length of this match */
    unsigned ibest;                     /* Position of best match */
    unsigned icur;                      /* Current position */
    unsigned ihash;                     /* Hash table index */
    unsigned ilink;                     /* Link index */
    unsigned char FAR *pch;             /* Char pointer */
    unsigned char FAR *pch2;            /* Char pointer */
    unsigned char FAR *pchend;          /* End of input (-> last valid) */
    unsigned cch;                       /* per-pass limit */

    cbitsleft = 8;                      /* Buffer is empty */
    abits = 0;
    pCompressed = pchcmpBase;           /* Initialize pointer */

    if (cchunc < cchcmpMax)
    {
        cCompressed = cchunc;           /* limit to source size */
    }
    else
    {
        cCompressed = cchcmpMax;        /* limit to max size offered */
    }

    if (cCompressed < SIG_SIZE)
    {
        return((unsigned) -1);
    }

    *pCompressed++ = 'D';
    *pCompressed++ = 'S';
    *pCompressed++ = '\x00';
    *pCompressed++ = '\x01';

    cCompressed -= SIG_SIZE;

    pch = pchbase;                      /* Initialize */

    if (cchunc-- == 0)
    {
        return(0);                      /* Do nothing to empty buffer */
    }

    inithash();                         /* Initialize tables */

    if (setjmp(bailout) != 0)           /* If failure */
    {
        return((unsigned) -1);          /* Data expanded */
    }

    cchbest = 0;                        /* no match yet */
    icur = 0;                           /* Initialize */

    for (cch = SECTOR - 1; cch <= (cchunc + SECTOR - 1); cch += SECTOR)
    {
        assert(cchbest == 0);           /* must always start with no match */

        if (cch > cchunc)
        {
            cch = cchunc;               /* limit to exact req count */
        }

        pchend = &pchbase[cch];         /* Remember end of buffer */

        while (icur < cch)              /* While at least two chars left */
        {
            /* update hash tables for this character */

            ihash = hash(word(&pchbase[icur]));
                                        /* Get hash index */
            ilink = ahash[ihash];       /* Get link index */
            ahash[ihash] = icur;        /* Remember position */
            alink[icur % MAXDISPBIG] = ilink;
                                        /* Chain on rest of list */

            /* walk hash chain looking for matches */

            while (ilink < icur && icur - ilink <= DISPMAX)
            {                           /* While link is valid and in range */
                pch = &pchbase[icur];   /* Point at first byte */
                pch2 = &pchbase[ilink]; /* Point at first byte */

                if (pch[cchbest] == pch2[cchbest] && word(pch) == word(pch2))
                {                       /* If we have a possible best match */
                    pch += 2;           /* Skip first pair */
                    pch2 += 2;          /* Skip first pair */

                    while (pch <= pchend)  /* Loop to find end of match */
                    {
                        if (*pch != *pch2++)
                        {
                            break;      /* Break if mismatch */
                        }
                        pch++;          /* Skip matching character */
                    }

                    if ((cchmatch = (unsigned)(pch - pchbase) - icur) > cchbest)
                    {                   /* If new best match */
                        cchbest = cchmatch;  /* Remember length */
                        ibest = ilink;  /* Remember position */

                        assert((pch-1) <= pchend);

                        if (pch > pchend)
                        {
                            break;      /* Break if we can't do any better */
                        }
                    }
                }

                assert((alink[ilink % MAXDISPBIG] == (unsigned) -1) ||
                        (alink[ilink % MAXDISPBIG] < ilink));

                ilink = alink[ilink % MAXDISPBIG];
                                        /* Get next link */
            }   /* until end of hash chain reached */

            if (cchbest >= MINMATCH1)   /* If we have a string match */
            {
                mrci1outstring(icur - ibest,cchbest);
                                        /* Describe matching string */
#ifdef VXD
                if (icur + cchbest >= cch )  /* If end of sector reached */
#else
                if (icur + cchbest >= cchunc)  /* If end of buffer reached */
#endif
                {
                    icur += cchbest;    /* Advance the index */
                    cchbest = 0;        /* reset for next match */
                    break;              /* Done if buffer exhausted */
                }

                icur++;                 /* Skip to first unhashed pair */
#ifdef VXD
                /* avoid re-seeding all of a big match */

                if (cchbest > MAXDISPSMALL)
                {                       /* If big match */
                    icur += cchbest - MAXDISPSMALL - 1;
                                        /* Skip ahead */
                    cchbest = MAXDISPSMALL + 1;
                                        /* Use shorter length */
                }
#endif
                /* update hash tables for each add't char in string */

                ibest = icur % MAXDISPBIG;  /* Get current link table index */

                while (--cchbest != 0)  /* Loop to reseed link table */
                {
                    ihash = hash(word(&pchbase[icur]));
                                        /* Get hash index */
                    ilink = ahash[ihash];  /* Get link index */
                    ahash[ihash] = icur++;  /* Remember position */
                    alink[ibest] = ilink;  /* Chain on rest of list */

                    if (++ibest < MAXDISPBIG)
                    {
                        continue;       /* Loop if we haven't wrapped yet */
                    }

                    ibest = 0;          /* Wrap to zero */
                }

                assert(cchbest == 0);   /* Counter must be 0 */
            }
            else
            {
                mrci1outsingle(pchbase[icur++]);
                                        /* Else output single character */
                cchbest = 0;            /* Reset counter */
            }
        }

        assert(icur == cch || icur == cch + 1);
                                        /* Must be at or past last character */
        if (icur == cch)
        {
#ifndef VXD
            ihash = hash(word(&pchbase[icur]));
                                        /* Get hash index */
            ilink = ahash[ihash];       /* Get link index */
            ahash[ihash] = icur;        /* Remember position */
            alink[icur % MAXDISPBIG] = ilink;
                                        /* Chain on rest of list */
#endif
            mrci1outsingle(pchbase[icur++]);  /* Output last character */
        }

        assert(icur == cch + 1);        /* Must be past last character */

        mrci1outstring(MAXDISPBIG,EOB);  /* Put out an end marker */
    }

    if (cbitsleft != 8)
    {
        charbuf(abits);                 /* Flush bit buffer */
    }

    if ((unsigned) (pCompressed - pchcmpBase) > cchunc)
    {
        return((unsigned) -1);          /* data expanded or not smaller */
    }

    return(pCompressed - pchcmpBase);   /* Return compressed size */
}


/*
 *  (MRCI2) MaxCompress
 */

unsigned Mrci2MaxCompress(unsigned char FAR *pchbase,unsigned cchunc,
        unsigned char FAR *pchcmpBase,unsigned cchcmpMax)
{
    unsigned cchbest;                   /* Length of best match */
    unsigned cchmatch;                  /* Length of this match */
    unsigned ibest;                     /* Position of best match */
    unsigned icur;                      /* Current position */
    unsigned ihash;                     /* Hash table index */
    unsigned ilink;                     /* Link index */
    unsigned char FAR *pch;             /* Char pointer */
    unsigned char FAR *pch2;            /* Char pointer */
    unsigned char FAR *pchend;          /* End of input (-> last valid) */
    unsigned cch;                       /* per-pass limit */

    cbitsleft = 8;                      /* Buffer is empty */
    abits = 0;
    pCompressed = pchcmpBase;           /* Initialize pointer */

    if (cchunc < cchcmpMax)
    {
        cCompressed = cchunc;           /* limit to source size */
    }
    else
    {
        cCompressed = cchcmpMax;        /* limit to max size offered */
    }

    if (cCompressed < SIG_SIZE)
    {
        return((unsigned) -1);
    }

    *pCompressed++ = 'J';
    *pCompressed++ = 'M';
    *pCompressed++ = '\x00';
    *pCompressed++ = '\x01';

    cCompressed -= SIG_SIZE;

    pch = pchbase;                      /* Initialize */

    if (cchunc-- == 0)
    {
        return(0);                      /* Do nothing to empty buffer */
    }

    inithash();                         /* Initialize tables */

    if (setjmp(bailout) != 0)           /* If failure */
    {
        return((unsigned) -1);          /* Data expanded */
    }

    cchbest = 0;                        /* no match yet */
    icur = 0;                           /* Initialize */

    for (cch = SECTOR - 1; cch <= (cchunc + SECTOR - 1); cch += SECTOR)
    {
        assert(cchbest == 0);           /* must always start with no match */

        if (cch > cchunc)
        {
            cch = cchunc;               /* limit to exact req count */
        }

        pchend = &pchbase[cch];         /* Remember end of buffer */

        while (icur < cch)              /* While at least two chars left */
        {
            /* update hash tables for this character */

            ihash = hash(word(&pchbase[icur]));
                                        /* Get hash index */
            ilink = ahash[ihash];       /* Get link index */
            ahash[ihash] = icur;        /* Remember position */
            alink[icur % MAXDISPBIG] = ilink;
                                        /* Chain on rest of list */

            /* walk hash chain looking for matches */

            while (ilink < icur && icur - ilink <= DISPMAX)
            {                           /* While link is valid and in range */
                pch = &pchbase[icur];   /* Point at first byte */
                pch2 = &pchbase[ilink]; /* Point at first byte */

                if (pch[cchbest] == pch2[cchbest] && word(pch) == word(pch2))
                {                       /* If we have a possible best match */
                    pch += 2;           /* Skip first pair */
                    pch2 += 2;          /* Skip first pair */

                    while (pch <= pchend)  /* Loop to find end of match */
                    {
                        if (*pch != *pch2++)
                        {
                            break;      /* Break if mismatch */
                        }
                        pch++;          /* Skip matching character */
                    }

                    if ((cchmatch = (unsigned)(pch - pchbase) - icur) > cchbest)
                    {                   /* If new best match */
                        cchbest = cchmatch;  /* Remember length */
                        ibest = ilink;  /* Remember position */

                        assert((pch-1) <= pchend);

                        if (pch > pchend)
                        {
                            break;      /* Break if we can't do any better */
                        }
                    }
                }

                assert((alink[ilink % MAXDISPBIG] == (unsigned) -1) ||
                        (alink[ilink % MAXDISPBIG] < ilink));

                ilink = alink[ilink % MAXDISPBIG];
                                        /* Get next link */
            }   /* until end of hash chain reached */

            if (cchbest >= MINMATCH2)   /* If we have a string match */
            {
                mrci2outstring(icur - ibest,cchbest);
                                        /* Describe matching string */
#ifdef VXD
                if (icur + cchbest >= cch )  /* If end of sector reached */
#else
                if (icur + cchbest >= cchunc)  /* If end of buffer reached */
#endif
                {
                    icur += cchbest;    /* Advance the index */
                    cchbest = 0;        /* reset for next match */
                    break;              /* Done if buffer exhausted */
                }

                icur++;                 /* Skip to first unhashed pair */
#ifdef VXD
                /* avoid re-seeding all of a big match */

                if (cchbest > MAXDISPSMALL)
                {                       /* If big match */
                    icur += cchbest - MAXDISPSMALL - 1;
                                        /* Skip ahead */
                    cchbest = MAXDISPSMALL + 1;
                                        /* Use shorter length */
                }
#endif
                /* update hash tables for each add't char in string */

                ibest = icur % MAXDISPBIG;  /* Get current link table index */

                while (--cchbest != 0)  /* Loop to reseed link table */
                {
                    ihash = hash(word(&pchbase[icur]));
                                        /* Get hash index */
                    ilink = ahash[ihash];  /* Get link index */
                    ahash[ihash] = icur++;  /* Remember position */
                    alink[ibest] = ilink;  /* Chain on rest of list */

                    if (++ibest < MAXDISPBIG)
                    {
                        continue;       /* Loop if we haven't wrapped yet */
                    }

                    ibest = 0;          /* Wrap to zero */
                }

                assert(cchbest == 0);   /* Counter must be 0 */
            }
            else
            {
                mrci2outsingle(pchbase[icur++]);
                                        /* Else output single character */
                cchbest = 0;            /* Reset counter */
            }
        }

        assert(icur == cch || icur == cch + 1);
                                        /* Must be at or past last character */
        if (icur == cch)
        {
#ifndef VXD
            ihash = hash(word(&pchbase[icur]));
                                        /* Get hash index */
            ilink = ahash[ihash];       /* Get link index */
            ahash[ihash] = icur;        /* Remember position */
            alink[icur % MAXDISPBIG] = ilink;
                                        /* Chain on rest of list */
#endif
            mrci2outsingle(pchbase[icur++]);  /* Output last character */
        }

        assert(icur == cch + 1);        /* Must be past last character */

        mrci2outstring(MAXDISPBIG,EOB);  /* Put out an end marker */
    }

    if (cbitsleft != 8)
    {
        charbuf(abits);                 /* Flush bit buffer */
    }

    if ((unsigned) (pCompressed - pchcmpBase) > cchunc)
    {
        return((unsigned) -1);          /* data expanded or not smaller */
    }

    return(pCompressed - pchcmpBase);   /* Return compressed size */
}


/*
 *  (decompress) Get a single bit from the compressed input stream.
 */

static unsigned FAST getbit(void)
{
    unsigned bit;                       /* Bit */

    if (cbitsleft)                      /* If bits available */
    {
        cbitsleft--;                    /* Decrement bit count */

        bit = abits & 1;                /* Get a bit */

        abits >>= 1;                    /* Remove it */
    }
    else                                /* no bits available */
    {
        if (cCompressed-- == 0)         /* If buffer empty */
        {
            longjmp(bailout,1);         /* input overrun */
        }

        cbitsleft = 7;                  /* Reset count */

        abits = *pCompressed++;         /* Get a byte */

        bit = abits & 1;                /* Get a bit */

        abits >>= 1;                    /* Remove it */
    }

    return(bit);                        /* Return the bit */
}


/*
 *  (decompress) Get multiple bits from the compressed input stream.
 */

static unsigned FAST getbits(unsigned cbits)
{
    unsigned bits;                      /* Bits to return */
    unsigned cbitsdone;                 /* number of bits added so far */
    unsigned cbitsneeded;               /* number of bits still needed */

    if (cbits <= cbitsleft)             /* If we have enough bits */
    {
        bits = abits;                   /* Get the bits */
        cbitsleft -= cbits;             /* Decrement bit count */
        abits >>= cbits;                /* Remove used bits */
    }
    else                                /* If we'll need to read more bits */
    {
        bits = 0;                       /* No bits set yet */
        cbitsdone = 0;                  /* no bits added yet */
        cbitsneeded = cbits;            /* bits needed */

        do
        {
            if (cbitsleft == 0)         /* If no bits ready */
            {
                if (cCompressed-- == 0) /* count down used */
                {
                    longjmp(bailout,1); /* if input overrun */
                }

                cbitsleft = 8;          /* Reset count */

                abits = *pCompressed++;  /* Get 8 new bits */
            }

            bits |= (abits << cbitsdone);  /* copy bits for output */

            if (cbitsleft >= cbitsneeded)  /* if enough now */
            {
                cbitsleft -= cbitsneeded;  /* reduce bits remaining available */
                abits >>= cbitsneeded;  /* discard used bits */
                break;                  /* got them */
            }
            else                        /* if not enough yet */
            {
                cbitsneeded -= cbitsleft;  /* reduce bits still needed */
                cbitsdone += cbitsleft;  /* increase shift for future bits */
                cbitsleft = 0;          /* reduce bits remaining available */
            }
        } while (cbitsneeded);          /* go back if more bits needed */
    }

    return(bits & BITMASK(cbits));      /* Return the bits */
}


/*
 *  (decompress) Expand a match.
 *
 *  Note: source overwrite is required (so we can't memcpy or memmove)
 */

static void FAST expandstring(unsigned char FAR **ppchout,unsigned disp,
        unsigned cb)
{
    unsigned char FAR *source;
    unsigned char FAR *target;

    assert(cb != 0);

    target = *ppchout;                  /* where the bytes go */
    source = target - disp;             /* where the bytes come from */

    *ppchout += cb;                     /* Update the output pointer */

    while (cb--)
    {
        *target++ = *source++;
    }
}


/*
 *  (MRCI1) Decompress
 */

unsigned Mrci1Decompress(unsigned char FAR *pchin,unsigned cchin,
        unsigned char FAR *pchdecBase,unsigned cchdecMax)
{
    unsigned b;                         /* A byte */
    unsigned length;                    /* Length of match */
    unsigned disp;                      /* Displacement */
    unsigned char FAR *pchout;          /* Output buffer pointer */

    abits = 0;                          /* Bit buffer is empty */
    cbitsleft = 0;                      /* No bits read yet */
    pCompressed = pchin;                /* setup source pointer */
    cCompressed = cchin;                /* setup source counter */

    if ((cCompressed <= SIG_SIZE) ||    /* must have a signature */
            (*pCompressed++ != 'D') || (*pCompressed++ != 'S'))
    {
        return((unsigned) -1);          /* Data corrupted */
    }

    pCompressed += 2;                   /* ignore flags */
    cCompressed -= SIG_SIZE;

    pchout = pchdecBase;                /* Point at output buffer */

    if (setjmp(bailout) != 0)           /* If failure */
    {
        return((unsigned) -1);          /* Data corrupted */
    }

    for (;;)
    {
        b = getbits(2);                 /* get two bits */

        if (b == 1)                     /* If single byte 128..255 */
        {                               /* Get the rest of byte */
            *pchout++ = (unsigned char) (getbits(7) | 0x80);
            continue;                   /* Next token */
        }

        if (b == 2)                     /* If single byte 0..127 */
        {                               /* Get the rest of byte */
            *pchout++ = (unsigned char) getbits(7);
            continue;                   /* Next token */
        }

        if (b == 0)
        {
            disp = getbits(6) + MINDISPSMALL;
        }
        else  /* b == 3 */
        {
            if (getbit() == 0)
            {
                disp = getbits(8) + MINDISPMED;
            }
            else
            {
                disp = getbits(12) + MINDISPBIG;
            }
        }

        if (disp == MAXDISPBIG)
        {
            if ((unsigned) (pchout - pchdecBase) >= cchdecMax)
            {
                break;                  /* End marker found */
            }
            else
            {
                continue;               /* End sector found */
            }
        }

        length = 0;                     /* Initialize */

        while (getbit() == 0)
        {
            length++;                   /* Count the leading zeroes */
        }

        assert(b <= 15);                /* Cannot be too big */

        if (length)
        {
            length = getbits(length) + (1 << length) + 1;
        }
        else
        {
            length = 2;
        }

        expandstring(&pchout,disp,length);  /* Copy the match */
    }

    return((pchout - pchdecBase));      /* Return decompressed size */
}


/*
 *  (MRCI2) Decompress
 */

unsigned Mrci2Decompress(unsigned char FAR *pchin,unsigned cchin,
        unsigned char FAR *pchdecBase,unsigned cchdecMax)
{
    unsigned length;                    /* Length of match */
    unsigned disp;                      /* Displacement */
    unsigned char FAR *pchout;          /* Output buffer pointer */

    abits = 0;                          /* Bit buffer is empty */
    cbitsleft = 0;                      /* No bits read yet */
    pCompressed = pchin;                /* setup source pointer */
    cCompressed = cchin;                /* setup source counter */

    if ((cCompressed <= SIG_SIZE) ||    /* must have a signature */
            (*pCompressed++ != 'J') || (*pCompressed++ != 'M'))
    {
        return((unsigned) -1);          /* Data corrupted */
    }

    pCompressed += 2;                   /* ignore flags */
    cCompressed -= SIG_SIZE;

    pchout = pchdecBase;                /* Point at output buffer */

    if (setjmp(bailout) != 0)           /* If failure */
    {
        return((unsigned) -1);          /* Data corrupted */
    }

    for (;;)
    {
        if (getbit() == 0)              /* literal 00..7F */
        {
            *pchout++ = (unsigned char) getbits(7);

            continue;                   /* Next token */
        }

        if (getbit() == 1)              /* literal 80..FF */
        {
            *pchout++ = (unsigned char)(getbits(7) | 0x80);

            continue;                   /* Next token */
        }

        if (getbit() == 0)
        {
            disp = getbits(6) + MINDISPSMALL;
        }
        else
        {
            if (getbit() == 0)
            {
                disp = getbits(8) + MINDISPMED;
            }
            else
            {
                disp = getbits(12) + MINDISPBIG;
            }
        }

        if (disp == MAXDISPBIG)
        {
            if ((unsigned) (pchout - pchdecBase) >= cchdecMax)
            {
                break;                  /* End marker found */
            }
            else
            {
                continue;               /* End sector found */
            }
        }

        length = 0;                     /* Initialize */

        while (getbit() == 0)
        {
            length++;                   /* Count the leading zeroes */
        }

        assert(length <= 15);           /* Cannot be too big */

        if (length)
        {
            length = getbits(length) + (1 << length) + 1;
        }
        else
        {
            length = 2;
        }

        expandstring(&pchout,disp,length + 1);  /* Copy the match */
    }

    return((pchout - pchdecBase));      /* Return decompressed size */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\mpk\misclib\mrcicode.h ===
/*
 *  Microsoft Confidential
 *  Copyright (c) 1994 Microsoft Corporation
 *  All Rights Reserved.
 *
 *  MRCICODE.H
 *
 *  MRCI 1 & MRCI 2 maxcompress and decompress functions
 */

#ifdef BIT16
#define     FAR     _far
#else
#define     FAR
#endif

#ifdef __cplusplus
extern "C"
{
#endif

extern unsigned Mrci1MaxCompress(unsigned char FAR *pchbase,unsigned cchunc,
        unsigned char FAR *pchcmpBase,unsigned cchcmpMax);

extern unsigned Mrci1Decompress(unsigned char FAR *pchin,unsigned cchin,
        unsigned char FAR *pchdecBase,unsigned cchdecMax);

extern unsigned Mrci2MaxCompress(unsigned char FAR *pchbase,unsigned cchunc,
        unsigned char FAR *pchcmpBase,unsigned cchcmpMax);

extern unsigned Mrci2Decompress(unsigned char FAR *pchin,unsigned cchin,
        unsigned char FAR *pchdecBase,unsigned cchdecMax);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\mpk\misclib\msgfile.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    msgfile.c

Abstract:

    Routines to load and process a text message file.

    The message file is in the following format:

    [<id>]
    text

    [<id>]
    text

    etc.

    Notes:

    1) Lines in the file before the first section are ignored. This is the
       only mechanism for comments in the file.

    2) To be recognized as a section name, the [ must be the first
       character on the line, and there cannot be any spaces between
       the [ and the ]. The number must be a decimal number in the range
       0 - 65535 inclusive.

    3) Trailing space at the end of a line is ignored.

    4) Empty lines at the trail end of a message are ignored completely.
       Empty means a newline only or whitespace and a newline only.

    5) The final newline in a message is ignored but internal ones
       are kept. Thus in the following example, message #3 is the 4 line
       message "\nThis\nis\n\na\n\nmessage"

       [3]

       This
       is

       a

       message

       [4]

Author:

    Ted Miller (tedm) 20 June 1997

Revision History:

--*/

#include <mytypes.h>
#include <msgfile.h>

#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <string.h>


#define MAX_LINE_LEN    100
#define MAX_MSG_LEN     5000


BOOL
PatchMessagesFromFile(
    IN     FPCHAR           Filename,
    IN OUT FPMESSAGE_STRING Messages,
    IN     UINT             MessageCount
    );

BOOL
ProcessMessage(
    IN char             *msg,
    IN UINT              MsgNumber,
    IN FPMESSAGE_STRING  Messages,
    IN UINT              MessageCount
    );


BOOL
GetTextForProgram(
    IN     FPCHAR           Argv0,
    IN OUT FPMESSAGE_STRING Messages,
    IN     UINT             MessageCount
    )
{
    char Filename[256];
    char *p;

    strcpy(Filename,Argv0);

    if(p = strrchr(Filename,'\\')) {
        p++;
    } else {
        p = Filename;
    }

    if(p = strchr(p,'.')) {
        *p = 0;
    }

    strcat(p,".msg");

    return(PatchMessagesFromFile(Filename,Messages,MessageCount));
}


BOOL
PatchMessagesFromFile(
    IN     FPCHAR           Filename,
    IN OUT FPMESSAGE_STRING Messages,
    IN     UINT             MessageCount
    )
{
    FILE *hFile;
    char line[MAX_LINE_LEN];
    char *msg;
    char *End;
    UINT MsgNumber;
    unsigned long l;
    unsigned u;
    BOOL Valid;

    msg = malloc(MAX_MSG_LEN);
    if(!msg) {
        return(FALSE);
    }

    //
    // Open the file.
    //
    hFile = fopen(Filename,"rt");
    if(!hFile) {
        free(msg);
        return(FALSE);
    }

    MsgNumber = (UINT)(-1);
    Valid = TRUE;

    while(Valid && fgets(line,MAX_LINE_LEN,hFile)) {

        if(line[0] == '[') {
            //
            // New message. Terminate the current one and then make sure
            // the section name specifies a valid number.
            //
            if(MsgNumber != (UINT)(-1)) {
                Valid = ProcessMessage(msg,MsgNumber,Messages,MessageCount);
            }

            if(Valid) {
                l = strtoul(&line[1],&End,10);
                if((l > 65535L) || (*End != ']')) {
                    Valid = FALSE;
                } else {
                    MsgNumber = (UINT)l;
                    msg[0] = 0;
                }
            }
        } else {
            //
            // Ignore lines in the file before the first section
            //
            if(MsgNumber != (UINT)(-1)) {
                //
                // Strip out trailing space. Account for the newline that
                // fgets leaves in the buffer.
                //
                u = strlen(line);
                while(u && ((line[u-1] == ' ') || (line[u-1] == '\t') || (line[u-1] == '\n'))) {
                    u--;
                }

                //
                // Put a newline back at the end of the line.
                //
                line[u++] = '\n';
                line[u] = 0;

                if((strlen(msg) + u) < MAX_MSG_LEN) {
                    strcat(msg,line);
                }
            }
        }
    }

    //
    // Check loop termination condition to see whether we read the whole
    // file correctly.
    //
    if(Valid && ferror(hFile)) {
        Valid = FALSE;
    }
    fclose(hFile);

    //
    // Process pending messsage if there is one.
    //
    if(Valid && (MsgNumber != (UINT)(-1))) {
        if(!ProcessMessage(msg,MsgNumber,Messages,MessageCount)) {
            Valid = FALSE;
        }
    }

    free(msg);
    return(Valid);
}


BOOL
ProcessMessage(
    IN char             *msg,
    IN UINT              MsgNumber,
    IN FPMESSAGE_STRING  Messages,
    IN UINT              MessageCount
    )
{
    UINT m;
    unsigned u;
    FPVOID p;

    //
    // Strip out trailing newline(s).
    //
    u = strlen(msg);
    while(u && (msg[u-1] == '\n')) {
        msg[--u] = 0;
    }

    //
    // Locate the relevent message in the caller's table.
    //
    for(m=0; m<MessageCount; m++) {
        if(Messages[m].Id == MsgNumber) {

            //
            // If the message fits in place, put it there.
            // Otherwise allocate memory and copy it.
            //
            if(!(*Messages[m].String) || (u > strlen(*Messages[m].String))) {
                p = malloc(u+1);
                if(!p) {
                    return(FALSE);
                }
                if(*Messages[m].String) {
                    free(*Messages[m].String);
                }
                *Messages[m].String = p;
            }

            strcpy(*Messages[m].String,msg);
            break;
        }
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\mpk\misclib\parsearg.c ===
#include <mytypes.h>
#include <misclib.h>
#include <diskio.h>

#include <stdlib.h>
#include <string.h>
#include <memory.h>
#include <ctype.h>




BOOL
ParseArgs(
    IN  int             argc,
    IN  FPCHAR          argv[],
    IN  BOOL            Strict,
    IN  FPCHAR          AllowedSwitchChars,
    OUT FPCMD_LINE_ARGS CmdLineArgs
    )
{
    char *arg;
    char c;

    memset(CmdLineArgs,0,sizeof(CmdLineArgs));

    if(!argc) {
        return(TRUE);
    }

    while(--argc) {

        arg = *(++argv);

        if((*arg == '-') || (*arg == '/')) {

            c = (char)toupper(arg[1]);
            if(strchr(AllowedSwitchChars,c)) {

                switch(c) {

                case 'D':
                case 'Y':   // to match requested behavior
                    if((arg[2] == ':') && arg[3]) {
                        _LogStart(&arg[3]);
                    } else {
                        if(Strict) {
                            return(FALSE);
                        }
                    }
                    break;

                case 'F':

                    if((arg[2] == ':') && arg[3] && !CmdLineArgs->FileListFile) {
                        CmdLineArgs->FileListFile = &arg[3];
                    } else {
                        if(Strict) {
                            return(FALSE);
                        }
                    }
                    break;

                case 'I':

                    if((arg[2] == ':') && arg[3] && !CmdLineArgs->ImageFile) {
                        CmdLineArgs->ImageFile = &arg[3];
                    } else {
                        if(Strict) {
                            return(FALSE);
                        }
                    }
                    break;

                case 'L':

                    if(arg[2] == ':') {
                        CmdLineArgs->LanguageCount = atoi(&arg[3]);
                    } else {
                        if(Strict) {
                            return(FALSE);
                        }
                    }
                    break;

                case 'M':

                    if(arg[2] == ':') {
                        CmdLineArgs->MasterDiskInt13Unit = (BYTE)strtoul(&arg[3],NULL,0);
                    } else {
                        if(Strict) {
                            return(FALSE);
                        }
                    }
                    break;

                case 'Q':

                    CmdLineArgs->Quiet = TRUE;
                    break;

                case 'R':

                    CmdLineArgs->Reinit = TRUE;
                    break;

                case 'T':

                    CmdLineArgs->Test = TRUE;
                    break;

                case 'X':
                    if(arg[2] == ':') {
                        DisableExtendedInt13((BYTE)strtoul(&arg[3],NULL,0));
                    } else {
                        //
                        // Disable xint13 for all devices
                        //
                        DisableExtendedInt13(0);
                    }
                    break;

                default:
                    if(Strict) {
                        return(FALSE);
                    }
                    break;
                }
            } else {
                if(Strict) {
                    return(FALSE);
                }
            }
        } else {
            if(Strict) {
                return(FALSE);
            }
        }
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\mpk\misclib\partsel.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    partsel.c

Abstract:

    Routine to allow the user to select a partition
    from a list of partitions. The UI is a simple character-based
    deal.

Author:

    Ted Miller (tedm) 29-May-1997

Revision History:

--*/

#include <mytypes.h>
#include <misclib.h>
#include <partio.h>
#include <diskio.h>

#include <stdio.h>
#include <stdlib.h>
#include <string.h>



INT
_far
SelectPartition(
    IN  UINT    PartitionCount,
    IN  CHAR   *Prompt,
    OUT CHAR   *AlternateResponse, OPTIONAL
    IN  FPCHAR  textDisk,
    IN  FPCHAR  textPaddedMbCount,
    IN  FPCHAR  textInvalidSelection
    )
{
    UINT i,l;
    UINT DiskId;
    BYTE SysId;
    ULONG StartSector;
    ULONG SectorCount;
    BYTE Int13Unit;
    BYTE SectorsPerTrack;
    USHORT Heads;
    USHORT Cylinders;
    ULONG ExtendedSectorCount;
    UINT Selection;
    CHAR line[256];

    select:
    printf("\n\n");

    for(i=0; i<PartitionCount; i++) {

        printf("%2u) ",i+1);

        GetPartitionInfoById(
            i,
            0,
            &DiskId,
            &SysId,
            &StartSector,
            &SectorCount
            );

        GetDiskInfoById(
            DiskId,
            0,
            &Int13Unit,
            &SectorsPerTrack,
            &Heads,
            &Cylinders,
            &ExtendedSectorCount
            );

        printf(" ");
        if(Int13Unit) {
            printf(textDisk);
            printf(" ");
            printf("%2x",Int13Unit);
        } else {
            l = strlen(textDisk) + 3;
            while(l) {
                printf(" ");
                l--;
            }
        }
        printf("   ");

        switch(SysId) {
        case 1:
            printf(" FAT12 ");
            break;

        case 4:
            printf(" FAT16 ");
            break;

        case 6:
            printf("BIGFAT ");
            break;

        case 7:
            printf("  NTFS ");
            break;

        case 0xb:
            printf(" FAT32 ");
            break;

        case 0xc:
            printf("XFAT32 ");
            break;

        case 0xe:
            printf("XINT13 ");
            break;

        default:
            printf("       ");
            break;
        }

        printf("   ");
        printf(textPaddedMbCount,SectorCount / 2048);

        printf("\n");
    }

    printf("\n");
    printf(Prompt);
    printf(" ");
    gets(line);
    Selection = atoi(line);

    if(!Selection || (Selection > PartitionCount)) {
        if(AlternateResponse) {
            Selection = 0;
            strcpy(AlternateResponse,line);
        } else {
            printf("\n%s\n\n",textInvalidSelection);
            goto select;
        }
    }

    return(Selection-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\mpk\misclib\reboot.asm ===
DOSSEG
        .MODEL LARGE

        CRTL            equ 4
        ALT             equ 8
        DEL             equ 53h

        INTERCEPT       equ 4f00h

        WARM_BOOT_CODE  equ 1234h


ROM_DATA SEGMENT AT 040h
        org 17h
KB_FLAG LABEL BYTE
        org 72h
WARM_BOOT_FLAG LABEL WORD
ROM_DATA ENDS


        .CODE
        ASSUME ds:nothing, es:nothing
.286

        public _RebootSystem
_RebootSystem proc far

        mov     ax,3515h
        int     21h                     ; Get int 15h vector in ES:BX
        mov     ax,es                   ; AX == Segment
        or      ax,bx                   ; Is this a NULL ptr
        mov     ax,seg ROM_DATA
        mov     ds,ax                   ; ds addresses ROM BIOS data area
        assume  ds:ROM_DATA
        jz      WarmBoot                ; If zero we can't do an int 15h

DoInt15:
        mov     KB_FLAG,CRTL+ALT
        mov     ax,INTERCEPT OR DEL     ; keyboard intercept, del key
        int     15h                     ; Put Ctrl/Alt/Del into key buffer

WarmBoot:
        cli
        cld

        mov     WARM_BOOT_FLAG,WARM_BOOT_CODE
        push    0ffffh
        push    0
        retf                            ; to processor power-on at ffff:0.

_RebootSystem ENDP

        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\msoobci\compinst.c ===
/*++

Copyright (c) Microsoft Corporation. All Rights Reserved.

Module Name:

    msoobci.c

Abstract:

    Exception Pack installer helper DLL
    Can be used as a co-installer, or called via setup app, or RunDll32 stub

    This DLL is for internal distribution of exception packs to update
    OS components.

Author:

    Jamie Hunter (jamiehun) 2001-11-27

Revision History:

    Jamie Hunter (jamiehun) 2001-11-27

        Initial Version

--*/
#include "msoobcip.h"

typedef struct _CALLBACKDATA {
    PVOID pDefContext; // context for default queue callback
    LPCTSTR Media;     // where old root was
    LPCTSTR Store;     // where new root is
    BOOL    PreCopy;   // if using PreCopy section
} CALLBACKDATA;

HRESULT
HandleReboot(
    IN DWORD   Flags
    )
/*++

Routine Description:

    Prompt for and execute reboot

Arguments:

    Flags - how reboot should be handled

Return Value:

    INST_S_REBOOT
    INST_S_REBOOTING

--*/

{
    if(Flags & COMP_FLAGS_NOPROMPTREBOOT) {
        //
        // TODO
        // if set, reboot unconditionally
        //
        HANDLE Token;
        BOOL b;
        TOKEN_PRIVILEGES NewPrivileges;
        LUID Luid;

        //
        // we need to "turn on" reboot privilege
        // if any of this fails, try reboot anyway
        //
        if(!OpenProcessToken(GetCurrentProcess(),TOKEN_ADJUST_PRIVILEGES,&Token)) {
            goto try_reboot;
        }

        if(!LookupPrivilegeValue(NULL,SE_SHUTDOWN_NAME,&Luid)) {
            CloseHandle(Token);
            goto try_reboot;
        }

        NewPrivileges.PrivilegeCount = 1;
        NewPrivileges.Privileges[0].Luid = Luid;
        NewPrivileges.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

        AdjustTokenPrivileges(
                Token,
                FALSE,
                &NewPrivileges,
                0,
                NULL,
                NULL
                );

        CloseHandle(Token);

    try_reboot:

        //
        // attempt reboot - inform system that this is planned hardware install
        //
        if(ExitWindowsEx(EWX_REBOOT,
                            SHTDN_REASON_FLAG_PLANNED
                                |SHTDN_REASON_MAJOR_SOFTWARE
                                |SHTDN_REASON_MINOR_INSTALLATION)) {
            return INST_S_REBOOTING;
        }

    } else if(Flags & COMP_FLAGS_PROMPTREBOOT) {
        //
        // TODO
        // if set, prompt for reboot
        //
        if(IsInteractiveWindowStation()) {
            if(SetupPromptReboot(NULL,NULL,FALSE) & SPFILEQ_REBOOT_IN_PROGRESS) {
                return INST_S_REBOOTING;
            }
        }
    }
    return INST_S_REBOOT;
}

HRESULT
WINAPI
InstallInfSectionW(
    IN LPCTSTR InfPath,
    IN LPCWSTR SectionName, OPTIONAL
    IN DWORD   Flags
    )
/*++

Routine Description:

    Does an install along lines of InstallHinfSection

Arguments:

    InfPath - full path to INF file
    SectionName - name of section including any decoration

Return Value:

    status as hresult

--*/
{
    TCHAR SectionNameBuffer[LINE_LEN];
    TCHAR ServiceSection[LINE_LEN+32];
    HINF  hInf = INVALID_HANDLE_VALUE;
    HSPFILEQ hFileQueue = INVALID_HANDLE_VALUE;
    PVOID QueueContext = NULL;
    DWORD Status = NO_ERROR;
    BOOL reboot = FALSE;
    BOOL needUninstallInf = FALSE;
    INT res;
    INFCONTEXT InfLine;
    DWORD InstFlags;

    //
    // Some decisions are version based
    //

    //
    // Load the inf file
    //
    hInf = SetupOpenInfFile(InfPath, NULL, INF_STYLE_WIN4, NULL);
    if(hInf == INVALID_HANDLE_VALUE) {
        Status = GetLastError();
        goto final;
    }

    if(!SectionName) {
        //
        // determine section name
        //
        if(!SetupDiGetActualSectionToInstall(hInf,
                                             KEY_DEFAULTINSTALL,
                                             SectionNameBuffer,
                                             ARRAY_SIZE(SectionNameBuffer),
                                             NULL,
                                             NULL)) {
            Status = GetLastError();
            goto final;
        }
        SectionName = SectionNameBuffer;
    }

    //
    // Check to see if the install section has a "Reboot" line.
    // or otherwise reboot forced
    //
    if((Flags & COMP_FLAGS_NEEDSREBOOT)
       || (SetupFindFirstLine(hInf, SectionName, KEY_REBOOT, &InfLine))) {
        reboot = TRUE;
    }

    //
    // See if UI allowed
    //
    if(((Flags & COMP_FLAGS_NOUI)==0) && !IsInteractiveWindowStation()) {
        Flags |= COMP_FLAGS_NOUI;
    }

    //
    // Load any layout file
    //
    SetupOpenAppendInfFile(NULL, hInf, NULL);

    //
    // Create a setup file queue and initialize the default queue callback.
    //
    hFileQueue = SetupOpenFileQueue();
    if(hFileQueue == INVALID_HANDLE_VALUE) {
        Status = GetLastError();
        goto final;
    }
    QueueContext = SetupInitDefaultQueueCallbackEx(
                       NULL,
                       ((Flags & COMP_FLAGS_NOUI) ? INVALID_HANDLE_VALUE : NULL),
                       0,
                       0,
                       0
                      );

    if(!QueueContext) {
        Status = GetLastError();
        goto final;
    }

    if(!SetupInstallFilesFromInfSection(hInf,
                                        NULL,
                                        hFileQueue,
                                        SectionName,
                                        NULL,
                                        0              // SP_COPY_xxxx
                                        )) {
        Status = GetLastError();
        goto final;
    }
    //
    // Commit file queue.
    //
    if(!SetupCommitFileQueue(NULL, hFileQueue, SetupDefaultQueueCallback, QueueContext)) {
        Status = GetLastError();
        goto final;
    }

    //
    // Note, if the INF contains a (non-NULL) ClassGUID, then it will have
    // been installed into %windir%\Inf during the above queue committal.
    // We make no effort to subsequently uninstall it (and its associated
    // PNF and CAT) if something fails below.
    //
    needUninstallInf = TRUE;

    InstFlags = SPINST_ALL;
    if(g_VerInfo.dwMajorVersion < 5) {
        InstFlags = 0x1f;
    }

    if(!SetupInstallFromInfSection(NULL,
                                    hInf,
                                    SectionName,
                                    InstFlags &~ SPINST_FILES,
                                    NULL,           // HKEY_xxxx
                                    NULL,           // no copying...
                                    0,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL
                                    )) {
        Status = GetLastError();
        goto final;
    }
    lstrcpyn(ServiceSection,SectionName,LINE_LEN);
    lstrcat(ServiceSection,KEY_DOTSERVICES);
    //
    // If services section exists, install it
    //
    if(SetupFindFirstLine(hInf, ServiceSection, NULL, &InfLine)) {
        if(!SetupInstallServicesFromInfSection(hInf,ServiceSection,0)) {
            Status = GetLastError();
            goto final;
        }
        if(GetLastError() == ERROR_SUCCESS_REBOOT_REQUIRED) {
            reboot = TRUE;
        }
    }
    res = SetupPromptReboot(hFileQueue, NULL, TRUE);
    if((res!=-1) && (res & SPFILEQ_REBOOT_RECOMMENDED)) {
        reboot = TRUE;
    }

  final:

    if(QueueContext) {
        SetupTermDefaultQueueCallback(QueueContext);
    }
    if(hFileQueue != INVALID_HANDLE_VALUE) {
        SetupCloseFileQueue(hFileQueue);
    }
    if(hInf != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile(hInf);
    }
    if(Status == NO_ERROR) {
        //
        // are we meant to prompt for reboot?
        //
        if(reboot) {
            return HandleReboot(Flags);
        } else {
            return S_OK;
        }
    }
    if(needUninstallInf) {
        //
        // call SetupUninstallOEMInf ?
        //
    }
    return HRESULT_FROM_SETUPAPI(Status);
}

HRESULT
WINAPI
InstallInfSectionA(
    IN LPCSTR  InfPath,
    IN LPCSTR  SectionName, OPTIONAL
    IN DWORD   Flags
    )
{
    TCHAR OutPath[MAX_PATH];
    TCHAR OutSection[LINE_LEN]; // as per friendly name
    INT sz;
    if(InfPath) {
        sz = MultiByteToWideChar(CP_ACP,0,InfPath,-1,OutPath,ARRAY_SIZE(OutPath));
        if(!sz) {
            return E_INVALIDARG;
        }
    }
    if(SectionName) {
        sz = MultiByteToWideChar(CP_ACP,0,SectionName,-1,OutSection,ARRAY_SIZE(OutSection));
        if(!sz) {
            return E_INVALIDARG;
        }
    }
    return InstallInfSection(InfPath ? OutPath : NULL,
                                SectionName ? OutSection : NULL,
                                Flags);
}


HRESULT
AttemptStoreCopy(
    IN CALLBACKDATA *pCallbackData,
    IN LPCTSTR Root,   OPTIONAL
    IN LPCTSTR Source,
    IN LPCTSTR Target  OPTIONAL
    )
/*++

Routine Description:

    Copy from source to target, redirected to the expack store

Arguments:

    pCallbackData - as passed to PreCopyQueueCallback
    Root - root to source directory
    Source - source, relative to Root
    Target - target name

Return Value:

    status as hresult

--*/
{
    TCHAR FullSource[MAX_PATH];
    TCHAR FullTarget[MAX_PATH];
    LPTSTR SubDir;
    LPTSTR BaseName;
    LPTSTR DestName;
    LPCTSTR p;
    DWORD dwStatus;
    HRESULT hrStatus;

    if(Root) {
        lstrcpyn(FullSource,Root,MAX_PATH);
        hrStatus = ConcatPath(FullSource,MAX_PATH,Source);
        if(!SUCCEEDED(hrStatus)) {
            return hrStatus;
        }
    } else {
        lstrcpyn(FullSource,Source,MAX_PATH);
    }
    //
    // we want to determine the source sub-directory
    //
    SubDir = FullSource;
    p = pCallbackData->Media;
    while(*p && (*p == *SubDir)) {
        p = CharNext(p);
        SubDir = CharNext(SubDir);
    }
    if(*p || ((*SubDir != TEXT('\\')) && (*SubDir != TEXT('/')))) {
        //
        // not a sub-directory of media
        //
        DebugPrint(TEXT("Not copying \"%s\" (not subdirectory of \"%s\")"),FullSource,pCallbackData->Media);
        return E_FAIL;
    }
    lstrcpyn(FullTarget,pCallbackData->Store,MAX_PATH);
    hrStatus = ConcatPath(FullTarget,MAX_PATH,SubDir);
    if(!SUCCEEDED(hrStatus)) {
        return hrStatus;
    }
    if(Target) {
        //
        // change final name of this
        //
        BaseName = GetBaseName(Target);
        DestName = GetBaseName(FullTarget);
        if(((DestName-FullTarget)+lstrlen(BaseName))>=MAX_PATH) {
            return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        }
        lstrcpy(DestName,BaseName);
    }
    if(GetFileAttributes(FullTarget)!=INVALID_FILE_ATTRIBUTES) {
        //
        // allow file to be replaced
        //
        SetFileAttributes(FullTarget,FILE_ATTRIBUTE_NORMAL);
    }
    MakeSureParentPathExists(FullTarget);
    if(CopyFile(FullSource,FullTarget,FALSE)) {
        return S_OK;
    }
    dwStatus = GetLastError();
    return HRESULT_FROM_WIN32(dwStatus);
}

UINT
CALLBACK
PreCopyQueueCallback(
    IN PVOID Context,
    IN UINT Notification,
    IN UINT_PTR Param1,
    IN UINT_PTR Param2
    )
/*++

Routine Description:

    Intent is to copy files from existing media to final media
    Copy all files

Arguments:

    FileName - name of file to scan

Return Value:

    status as hresult

--*/
{
    CALLBACKDATA * pCallbackData = (CALLBACKDATA *)Context;

    switch(Notification) {
        case SPFILENOTIFY_NEEDMEDIA:
            {
                UINT res;
                SOURCE_MEDIA *pMedia = (SOURCE_MEDIA *)Param1;
                SOURCE_MEDIA MediaCopy = *pMedia;
                LPCTSTR Path = NULL;
                //
                // get the media in place - let default callback do this
                // however we can't deal with media location being changed
                // so don't allow it
                //
                MediaCopy.Flags |= SP_COPY_NOSKIP|SP_COPY_NOBROWSE;
                res= SetupDefaultQueueCallback(pCallbackData->pDefContext,
                                                 Notification,
                                                 (UINT_PTR)&MediaCopy,
                                                 Param2);
                if(res==FILEOP_DOIT) {
                    //
                    // typical case
                    // SourcePath unchanged
                    //
                    Path = pMedia->SourcePath;
                } else if(res == FILEOP_NEWPATH) {
                    //
                    // alternative case
                    // we said above we don't want this
                    //
                    SetLastError(ERROR_CANCELLED);
                    return FILEOP_ABORT;
                } else if(res == FILEOP_SKIP) {
                    //
                    // skip
                    // we said above we don't want this
                    //
                    SetLastError(ERROR_CANCELLED);
                    return FILEOP_ABORT;
                } else {
                    //
                    // existing failure case
                    //
                    return res;
                }
                //
                // if the tag exists at source media, copy it
                // if the sourcefile exists at source media, copy it now
                // (it might reference a cab file)
                //
                AttemptStoreCopy(pCallbackData,Path,pMedia->Tagfile,NULL);
                AttemptStoreCopy(pCallbackData,Path,pMedia->SourceFile,NULL);
            }
            return FILEOP_DOIT;

        case SPFILENOTIFY_STARTCOPY:
            {
                UINT res;
                FILEPATHS *pPaths = (FILEPATHS*)Param1;
                if(pCallbackData->PreCopy) {
                    //
                    // we want the target name (PRECOPY case)
                    //
                    AttemptStoreCopy(pCallbackData,NULL,pPaths->Source,pPaths->Target);
                } else {
                    //
                    // we want the source name
                    //
                    AttemptStoreCopy(pCallbackData,NULL,pPaths->Source,NULL);
                }
            }
            return FILEOP_SKIP;

        case SPFILENOTIFY_STARTDELETE:
            return FILEOP_SKIP;

        case SPFILENOTIFY_STARTRENAME:
            return FILEOP_SKIP;


        default:
            return SetupDefaultQueueCallback(pCallbackData->pDefContext,
                                             Notification,
                                             Param1,
                                             Param2);
    }
}

HRESULT
InstallExceptionPackFromInf(
    IN LPCTSTR InfPath,
    IN LPCTSTR Media,
    IN LPCTSTR Store,
    IN DWORD   Flags
    )
/*++

Routine Description:

    Assume INF installed into INF directory
    all decisions made
    media/store known

Arguments:

    InfPath - name of Inf in Media location
    Media   - InfPath less InfName
    Store   - expack store
    Flags   - various flags

Return Value:

    status as hresult

--*/
{
    TCHAR SectionName[LINE_LEN];
    TCHAR PrecopySectionName[LINE_LEN];
    HINF hInf;
    HSPFILEQ hFileQueue = INVALID_HANDLE_VALUE;
    PVOID QueueContext = NULL;
    CALLBACKDATA CallbackData;
    DWORD Status;

    //
    // exception packs must be moved to a component-specific store
    // run through a file-install to see what files we have to copy
    // and use that list to determine source media
    //
    hInf = SetupOpenInfFile(InfPath, NULL, INF_STYLE_WIN4, NULL);
    if(hInf == INVALID_HANDLE_VALUE) {
        Status = GetLastError();
        goto final;
    }
    if(!SetupDiGetActualSectionToInstall(hInf,
                                         KEY_DEFAULTINSTALL,
                                         SectionName,
                                         ARRAY_SIZE(SectionName),
                                         NULL,
                                         NULL)) {
        Status = GetLastError();
        goto final;
    }
    SetupOpenAppendInfFile(NULL,hInf,NULL);
    hFileQueue = SetupOpenFileQueue();
    if(hFileQueue == INVALID_HANDLE_VALUE) {
        Status = GetLastError();
        goto final;
    }

    if((lstrlen(SectionName)+10)>LINE_LEN) {
        Status = ERROR_INSUFFICIENT_BUFFER;
        goto final;
    }
    lstrcpy(PrecopySectionName,SectionName);
    lstrcat(PrecopySectionName,KEY_DOTPRECOPY);


    QueueContext = SetupInitDefaultQueueCallbackEx(
                       NULL,
                       ((Flags & COMP_FLAGS_NOUI) ? INVALID_HANDLE_VALUE : NULL),
                       0,
                       0,
                       0
                      );

    if(!QueueContext) {
        Status = GetLastError();
        goto final;
    }
    ZeroMemory(&CallbackData,sizeof(CallbackData));
    CallbackData.pDefContext = QueueContext;
    CallbackData.Store = Store;
    CallbackData.Media = Media;


    if(SetupGetLineCount(hInf,PrecopySectionName)>0) {
        //
        // do the pre-copy install via this section instead
        //
        CallbackData.PreCopy = TRUE;
        if(!SetupInstallFilesFromInfSection(hInf,
                                            NULL,
                                            hFileQueue,
                                            PrecopySectionName,
                                            NULL,
                                            0              // SP_COPY_xxxx
                                            )) {
            Status = GetLastError();
            goto final;
        }
    } else {
        CallbackData.PreCopy = FALSE;
        if(!SetupInstallFilesFromInfSection(hInf,
                                            NULL,
                                            hFileQueue,
                                            SectionName,
                                            NULL,
                                            0              // SP_COPY_xxxx
                                            )) {
            Status = GetLastError();
            goto final;
        }
    }


    //
    // Commit file queue, this will get the files to the store
    //
    if(!SetupCommitFileQueue(NULL, hFileQueue, PreCopyQueueCallback, &CallbackData)) {
        Status = GetLastError();
        goto final;
    }
    if(hFileQueue != INVALID_HANDLE_VALUE) {
        SetupCloseFileQueue(hFileQueue);
        hFileQueue = INVALID_HANDLE_VALUE;
    }
    if(hInf != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile(hInf);
        hInf = INVALID_HANDLE_VALUE;
    }
    //
    // now install files from here to final destination
    // this should be relatively quick so don't bother with UI
    //
    if(!(Flags & COMP_FLAGS_NOINSTALL)) {
        return InstallInfSection(InfPath,
                                 SectionName,
                                 COMP_FLAGS_NOUI);
    }
    return S_OK;

    //
    // TODO - move files to component directory
    //
final:
    if(QueueContext) {
        SetupTermDefaultQueueCallback(QueueContext);
    }
    if(hFileQueue != INVALID_HANDLE_VALUE) {
        SetupCloseFileQueue(hFileQueue);
    }
    if(hInf != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile(hInf);
    }
    return HRESULT_FROM_SETUPAPI(Status);
}

DWORD
DownlevelQueryInfOriginalFileInformation(
    IN  HINF                   hInf,
    PSP_INF_INFORMATION        InfInformation,
    PSP_ORIGINAL_FILE_INFO     OriginalFileInfo
    )
/*++

Routine Description:

    Emulates SetupQueryInfOriginalFileInformation
    we need to look in hINF to determine catalog name
    only partial implementation enough to support x86
    (will degrade on other architectures)

Arguments:

    hInf                        - handle to open INF file
    InfInformation              - information obtained about original INF
    pInfOriginalFileInformation - fill with inf/catalog names

Return Value:

    status as DWORD (not HRESULT)

--*/
{
    //
    // in downlevel case, filename is name of file we opened
    // catalog is referenced in the INF
    //
    // get basename of the INF
    // (actually returns full name, but we'll deal with it right)
    //
    INFCONTEXT InfLine;
    SYSTEM_INFO SysInfo;
    TCHAR KeyName[LINE_LEN];

    if(!SetupQueryInfFileInformation(InfInformation,
                                        0,
                                        OriginalFileInfo->OriginalInfName,
                                        ARRAY_SIZE(OriginalFileInfo->OriginalInfName),
                                        NULL)) {
        return GetLastError();
    }
    //
    // now determine name of catalog
    //
    GetSystemInfo(&SysInfo);
    if(SysInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL) {
        //
        // look for .NTx86
        // only makes sence for x86
        // which is the only architecture we'll migrate Win9x/NT4 to Win2k+
        //
        lstrcpy(KeyName,INFSTR_KEY_CATALOGFILE);
        lstrcat(KeyName,TEXT(".NTx86"));
        if(SetupFindFirstLine(hInf,INFSTR_SECT_VERSION,KeyName,&InfLine)) {
            if(SetupGetStringField(&InfLine,
                                    1,
                                    OriginalFileInfo->OriginalCatalogName,
                                    ARRAY_SIZE(OriginalFileInfo->OriginalCatalogName),
                                    NULL)) {
                return NO_ERROR;
            }
        }
    }
    //
    // look for .NT (even on 9x, as the exception pack will be re-parsed
    // on NT)
    //
    lstrcpy(KeyName,INFSTR_KEY_CATALOGFILE);
    lstrcat(KeyName,TEXT(".NT"));
    if(SetupFindFirstLine(hInf,INFSTR_SECT_VERSION,KeyName,&InfLine)) {
        if(SetupGetStringField(&InfLine,
                                1,
                                OriginalFileInfo->OriginalCatalogName,
                                ARRAY_SIZE(OriginalFileInfo->OriginalCatalogName),
                                NULL)) {
            return NO_ERROR;
        }
    }
    //
    // finally look for undecorated
    //
    if(SetupFindFirstLine(hInf,INFSTR_SECT_VERSION,INFSTR_KEY_CATALOGFILE,&InfLine)) {
        if(SetupGetStringField(&InfLine,
                                1,
                                OriginalFileInfo->OriginalCatalogName,
                                ARRAY_SIZE(OriginalFileInfo->OriginalCatalogName),
                                NULL)) {
            return NO_ERROR;
        }
    }
    //
    // no catalog
    //
    OriginalFileInfo->OriginalCatalogName[0] = TEXT('\0');
    return NO_ERROR;
}

HRESULT
GetInfOriginalFileInformation(
    IN  HINF                   hInf,
    OUT PSP_ORIGINAL_FILE_INFO pInfOriginalFileInformation
    )
/*++

Routine Description:

    Given a handle to an INF, determine names of inf and catalog files

Arguments:

    hInf                        - handle to open INF file
    pInfOriginalFileInformation - inf/catalog names

Return Value:

    status as hresult

--*/
{
    PSP_INF_INFORMATION pInfInformation = NULL;
    DWORD InfInformationSize;
    DWORD Status;

    InfInformationSize = 8192;
    pInfInformation = (PSP_INF_INFORMATION)malloc(InfInformationSize);
    if (pInfInformation == NULL) {
        return E_OUTOFMEMORY;
    }
    if(!SetupGetInfInformation(hInf,INFINFO_INF_SPEC_IS_HINF,pInfInformation,InfInformationSize,&InfInformationSize)) {
        PVOID TempBuf;
        Status = GetLastError();
        if(Status != ERROR_INSUFFICIENT_BUFFER) {
            free(pInfInformation);
            return HRESULT_FROM_SETUPAPI(Status);
        }
        TempBuf = realloc(pInfInformation,InfInformationSize);
        if(!TempBuf) {
            free(pInfInformation);
            return E_OUTOFMEMORY;
        }
    }
    if(!SetupGetInfInformation(hInf,INFINFO_INF_SPEC_IS_HINF,pInfInformation,InfInformationSize,&InfInformationSize)) {
        Status = GetLastError();
        free(pInfInformation);
        return HRESULT_FROM_SETUPAPI(Status);
    }
    pInfOriginalFileInformation->cbSize = sizeof(SP_ORIGINAL_FILE_INFO);
    if((g_VerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) && (g_VerInfo.dwMajorVersion >= 5)) {
        //
        // Win2k+ - have SetupAPI tell us the information (we're querying oem*.inf)
        //
        if (!QueryInfOriginalFileInformation(pInfInformation,0,NULL,pInfOriginalFileInformation)) {
            Status = GetLastError();
            free(pInfInformation);
            return HRESULT_FROM_SETUPAPI(Status);
        }
    } else {
        //
        // <Win2k - querying source INF, get information from there
        //
        Status = DownlevelQueryInfOriginalFileInformation(hInf,pInfInformation,pInfOriginalFileInformation);
        if(Status != NO_ERROR) {
            free(pInfInformation);
            return HRESULT_FROM_SETUPAPI(Status);
        }
    }
    free(pInfInformation);
    return S_OK;
}

HRESULT
DeleteDirectoryRecursive(
    IN LPCTSTR Path
    )
/*++

Routine Description:

    delete specified directory recursively

Arguments:

    Path - path of the directory to delete

Return Value:

    as HRESULT
    S_FALSE if directory doesn't exist
    S_OK    if directory deleted
    other error if, eg, files in use

--*/
{
    TCHAR Wildcard[MAX_PATH];
    TCHAR Target[MAX_PATH];
    HRESULT hrStatus;
    DWORD Status;
    HRESULT hrFirstError = S_FALSE;
    HANDLE hFind;
    WIN32_FIND_DATA FindData;

    //
    // enumerate the directory
    //
    lstrcpyn(Wildcard,Path,MAX_PATH);
    hrStatus = ConcatPath(Wildcard,MAX_PATH,TEXT("\\*.*"));
    if(!SUCCEEDED(hrStatus)) {
        return hrStatus;
    }
    hFind = FindFirstFile(Wildcard,&FindData);
    if(hFind != INVALID_HANDLE_VALUE) {
        hrFirstError = S_OK;
        do {
            if(lstrcmp(FindData.cFileName,TEXT(".")) == 0) {
                continue;
            }
            if(lstrcmp(FindData.cFileName,TEXT("..")) == 0) {
                continue;
            }
            lstrcpyn(Target,Path,MAX_PATH);
            hrStatus = ConcatPath(Target,MAX_PATH,FindData.cFileName);
            if(SUCCEEDED(hrStatus)) {
                if(FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {
                    hrStatus = DeleteDirectoryRecursive(Target);
                    if(SUCCEEDED(hrFirstError) && !SUCCEEDED(hrStatus)) {
                        hrFirstError = hrStatus;
                    }
                } else {
                    SetFileAttributes(Target,FILE_ATTRIBUTE_NORMAL);
                    if(!DeleteFile(Target)) {
                        Status = GetLastError();
                        if(SUCCEEDED(hrFirstError)) {
                            hrFirstError = HRESULT_FROM_WIN32(Status);
                        }
                    }
                }
            } else if(SUCCEEDED(hrFirstError)) {
                hrFirstError = hrStatus;
            }
        } while (FindNextFile(hFind,&FindData));
        FindClose(hFind);
    }
    //
    // now delete this directory
    //

    SetFileAttributes(Path,FILE_ATTRIBUTE_NORMAL);
    if(RemoveDirectory(Path) || !SUCCEEDED(hrFirstError)) {
        return hrFirstError;
    }
    Status = GetLastError();
    if((Status == ERROR_PATH_NOT_FOUND) || (Status == ERROR_FILE_NOT_FOUND)) {
        return hrFirstError;
    }
    return HRESULT_FROM_WIN32(Status);
}

HRESULT
RevertStore(
    IN LPCTSTR BackupDir,
    IN LPCTSTR TargetDir
    )
/*++

Routine Description:

    moves contents from backup back to original location
    overwriting files/directories if needed

Arguments:

    BackupDir - directory restoring from
    TargetDir - directory restoring to

Return Value:

    as HRESULT
    S_OK    if backup created
    other error if, eg, files in use

--*/
{
    TCHAR Wildcard[MAX_PATH];
    TCHAR Source[MAX_PATH];
    TCHAR Target[MAX_PATH];
    HRESULT hrStatus;
    HRESULT hrFirstError = S_FALSE;
    DWORD Status;
    DWORD dwRes;
    HANDLE hFind;
    WIN32_FIND_DATA FindData;

    lstrcpyn(Wildcard,BackupDir,MAX_PATH);
    hrStatus = ConcatPath(Wildcard,MAX_PATH,TEXT("\\*.*"));
    if(!SUCCEEDED(hrStatus)) {
        return hrStatus;
    }
    hFind = FindFirstFile(Wildcard,&FindData);
    if(hFind != INVALID_HANDLE_VALUE) {
        hrFirstError = S_OK;
        do {
            if(lstrcmp(FindData.cFileName,TEXT(".")) == 0) {
                continue;
            }
            if(lstrcmp(FindData.cFileName,TEXT("..")) == 0) {
                continue;
            }
            lstrcpyn(Source,BackupDir,MAX_PATH);
            hrStatus = ConcatPath(Source,MAX_PATH,FindData.cFileName);
            if(!SUCCEEDED(hrStatus)) {
                if(SUCCEEDED(hrFirstError)) {
                    hrFirstError = hrStatus;
                }
                continue;
            }
            lstrcpyn(Target,TargetDir,MAX_PATH);
            hrStatus = ConcatPath(Target,MAX_PATH,FindData.cFileName);
            if(!SUCCEEDED(hrStatus)) {
                if(SUCCEEDED(hrFirstError)) {
                    hrFirstError = hrStatus;
                }
                continue;
            }
            //
            // does target exist?
            //
            dwRes = GetFileAttributes(Target);
            if(dwRes != INVALID_FILE_ATTRIBUTES) {
                if(dwRes & FILE_ATTRIBUTE_DIRECTORY) {
                    //
                    // revert store recursively
                    //
                    hrStatus = RevertStore(Source,Target);
                    if(!SUCCEEDED(hrStatus)) {
                        if(SUCCEEDED(hrFirstError)) {
                            hrFirstError = hrStatus;
                        }
                        continue;
                    }
                } else {
                    SetFileAttributes(Target,FILE_ATTRIBUTE_NORMAL);
                    if(!DeleteFile(Target)) {
                        Status = GetLastError();
                    }
                }
            }
            if(!MoveFile(Source,Target)) {
                Status = GetLastError();
                hrStatus = HRESULT_FROM_WIN32(Status);
                if(SUCCEEDED(hrFirstError)) {
                    hrFirstError = hrStatus;
                }
            }
        } while (FindNextFile(hFind,&FindData));
        FindClose(hFind);
    }
    //
    // now attempt to remove the backup directory
    //
    if(RemoveDirectory(BackupDir) || !SUCCEEDED(hrFirstError)) {
        return hrFirstError;
    }
    Status = GetLastError();
    if((Status == ERROR_PATH_NOT_FOUND) || (Status == ERROR_FILE_NOT_FOUND)) {
        return hrFirstError;
    }
    return HRESULT_FROM_WIN32(Status);
}

HRESULT
BackupStore(
    IN LPCTSTR Path,
    OUT LPTSTR BackupDir,
    OUT DWORD BackupDirLen
    )
/*++

Routine Description:

    moves contents to new backup, ideally to \\$BACKUP$
    returns name of backup

Arguments:

    Path         - path of the store
    BackupDir    - filled with directory containing backup
    BackupDirLen - containing length of BackupDir

Return Value:

    as HRESULT
    S_OK    if backup created
    other error if, eg, files in use

--*/
{
    TCHAR Wildcard[MAX_PATH];
    TCHAR Source[MAX_PATH];
    TCHAR Target[MAX_PATH];
    HRESULT hrStatus;
    DWORD Status;
    HANDLE hFind;
    WIN32_FIND_DATA FindData;
    int i;
    int len;

    lstrcpyn(BackupDir,Path,BackupDirLen);
    hrStatus = ConcatPath(BackupDir,BackupDirLen,TEXT("\\$BACKUP$"));
    if(!SUCCEEDED(hrStatus)) {
        //
        // obviously path is too big, no point ignoring
        // as we'd fail elsewhere
        //
        return hrStatus;
    }
    len = lstrlen(BackupDir);
    if((BackupDirLen-len)<5) {
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }

    //
    // first, if there's a backup, try and delete it
    //
    hrStatus = DeleteDirectoryRecursive(BackupDir);
    if(SUCCEEDED(hrStatus)) {
        hrStatus = MakeSurePathExists(BackupDir);
    }
    if((hrStatus == HRESULT_FROM_WIN32(ERROR_WRITE_PROTECT)) ||
       (hrStatus == HRESULT_FROM_WIN32(ERROR_INVALID_ACCESS))) {
        //
        // no point even trying again
        //
        return hrStatus;
    }
    for(i = 0;!SUCCEEDED(hrStatus) && i<1000;i++) {
        _sntprintf(BackupDir+len,5,TEXT(".%03u"),i);
        hrStatus = DeleteDirectoryRecursive(BackupDir);
        if(SUCCEEDED(hrStatus)) {
            hrStatus = MakeSurePathExists(BackupDir);
        }
    }
    if(!SUCCEEDED(hrStatus)) {
        return hrStatus;
    }
    //
    // now we have a backup directory, move all the files there
    //
    lstrcpyn(Wildcard,Path,MAX_PATH);
    hrStatus = ConcatPath(Wildcard,MAX_PATH,TEXT("\\*.*"));
    if(!SUCCEEDED(hrStatus)) {
        return hrStatus;
    }
    hrStatus = S_FALSE;
    hFind = FindFirstFile(Wildcard,&FindData);
    if(hFind != INVALID_HANDLE_VALUE) {
        do {
            if(lstrcmp(FindData.cFileName,TEXT(".")) == 0) {
                continue;
            }
            if(lstrcmp(FindData.cFileName,TEXT("..")) == 0) {
                continue;
            }
            if(_tcsnicmp(FindData.cFileName,TEXT("$BACKUP$"),8) == 0) {
                //
                // a/the backup directory
                //
                continue;
            }
            lstrcpyn(Source,Path,MAX_PATH);
            hrStatus = ConcatPath(Source,MAX_PATH,FindData.cFileName);
            if(!SUCCEEDED(hrStatus)) {
                break;
            }
            lstrcpyn(Target,BackupDir,MAX_PATH);
            hrStatus = ConcatPath(Target,MAX_PATH,FindData.cFileName);
            if(!SUCCEEDED(hrStatus)) {
                break;
            }
            if(!MoveFile(Source,Target)) {
                Status = GetLastError();
                hrStatus = HRESULT_FROM_WIN32(Status);
            }
            if(!SUCCEEDED(hrStatus)) {
                break;
            }
            hrStatus = S_OK;
        } while (FindNextFile(hFind,&FindData));
        FindClose(hFind);
    }
    if(!SUCCEEDED(hrStatus)) {
        RevertStore(BackupDir,Path);
    }
    return hrStatus;
}

HRESULT
WINAPI
InstallComponentW(
    IN LPCTSTR InfPath,
    IN DWORD   Flags,
    IN const GUID * CompGuid, OPTIONAL
    IN INT VerMajor,           OPTIONAL
    IN INT VerMinor,           OPTIONAL
    IN INT VerBuild,           OPTIONAL
    IN INT VerQFE,             OPTIONAL
    IN LPCTSTR Name           OPTIONAL
    )
/*++

Routine Description:

    exported for call by setup routine
    install a component with a given version assumed
    show progress while pulling files from original location

Arguments:

    InfPath - path to INF file
    Flags   - flags
                COMP_FLAGS_NOINSTALL      - place in store, don't install
                COMP_FLAGS_NOUI           - don't show any UI
                COMP_FLAGS_NOPROMPTREBOOT - reboot if needed (no prompt)
                COMP_FLAGS_PROMPTREBOOT   - prompt for reboot if needed
                COMP_FLAGS_NEEDSREBOOT    - assume reboot needed

    CompGuid - if NULL, use GUID specified in INF (ComponentId)
               else verify against GUID specified in INF
    VerMajor/VerMinor/VerBuild/VerQFE
             - if -1, use version specified in INF (ComponentVersion)
               else use this version and verify against version if specified in INF
    Name
            - if NULL, use name specified in INF (ComponentName)
              else use this component name.

Return Value:

    status as hresult

--*/
{
    HINF hInf = INVALID_HANDLE_VALUE;
    INFCONTEXT InfLine;
    TCHAR Buffer[MAX_PATH*3];
    TCHAR FriendlyName[DESC_SIZE];
    TCHAR NewStore[MAX_PATH];
    TCHAR OldStore[MAX_PATH];
    TCHAR MediaRoot[MAX_PATH];
    TCHAR GuidString[64];
    LPTSTR BaseName;
    LPTSTR SubDir;
    DWORD Status = NO_ERROR; // set Status or hrStatus
    DWORD DwRes;
    UINT  UiRes;
    HRESULT hrStatus = S_OK;
    GUID InfGuid;
    INT InfVerMajor,InfVerMinor,InfVerBuild,InfVerQFE;
    BOOL PrevReg = FALSE;
    BOOL NeedProxy = FALSE;
    BOOL CanRevert = FALSE;
    BOOL BackedUp = FALSE;
    SETUP_OS_COMPONENT_DATA OsComponentData;
    SETUP_OS_EXCEPTION_DATA OsExceptionData;
    SETUP_OS_COMPONENT_DATA NewOsComponentData;
    SETUP_OS_EXCEPTION_DATA NewOsExceptionData;
    SP_ORIGINAL_FILE_INFO InfOriginalFileInformation;

    //
    // validate args
    //
    if((InfPath == NULL)
       || (VerMajor<-1)
       || (VerMajor>65535)
       || (VerMinor<-1)
       || (VerMinor>65535)
       || (VerBuild<-1)
       || (VerBuild>65535)
       || (VerQFE<-1)
       || (VerQFE>65535)
       || (lstrlen(InfPath)>=MAX_PATH)
       || (Name && (lstrlen(Name)>=ARRAY_SIZE(FriendlyName)))) {
        return E_INVALIDARG;
    }
    //
    // open the INF, we're going to do some information finding
    //
    hInf = SetupOpenInfFile(InfPath,NULL,INF_STYLE_WIN4,NULL);
    if(hInf == INVALID_HANDLE_VALUE) {
        Status = GetLastError();
        goto final;
    }
    //
    // get various information about this exception pack
    // We want to know about the exception pack
    // check classguid is correct
    // get componentid
    // get version if exists, and validate against any passed in
    // get description if exists (overwritten by that passed in)
    //

    //
    // CLASSGUID={F5776D81-AE53-4935-8E84-B0B283D8BCEF}
    //
    if(!SetupFindFirstLine(hInf,INFSTR_SECT_VERSION,INFSTR_KEY_CLASSGUID,&InfLine)) {
        Status = GetLastError();
        goto final;
    }
    if(!SetupGetStringField(&InfLine,1,Buffer,MAX_PATH,NULL)) {
        Status = GetLastError();
        goto final;
    }
    if(_tcsicmp(Buffer,TEXT("{F5776D81-AE53-4935-8E84-B0B283D8BCEF}"))!=0) {
        hrStatus = SPAPI_E_CLASS_MISMATCH;
        goto final;
    }
    //
    // determine what component the INF says
    // ComponentId must exist for exception packs
    //
    if(!SetupFindFirstLine(hInf,INFSTR_SECT_VERSION,KEY_COMPONENTID,&InfLine)) {
        Status = GetLastError();
        goto final;
    }
    if(!SetupGetStringField(&InfLine,1,Buffer,MAX_PATH,NULL)) {
        Status = GetLastError();
        goto final;
    }
    hrStatus = GuidFromString(Buffer,&InfGuid);
    if(SUCCEEDED(hrStatus)) {
        hrStatus = S_OK;
    } else {
        goto final;
    }
    if(CompGuid && !IsEqualGUID(CompGuid,&InfGuid)) {
        //
        // mismatched
        //
        hrStatus = E_INVALIDARG;
        goto final;
    }
    //
    // determine version - optional, just for msoobci
    // but if not specified in INF in DriverVer = <date>,<version>
    // must be passed in
    //
    if(SetupFindFirstLine(hInf,INFSTR_SECT_VERSION,INFSTR_DRIVERVERSION_SECTION,&InfLine)) {
        if(!SetupGetStringField(&InfLine,2,Buffer,MAX_PATH,NULL)) {
            Status = GetLastError();
            goto final;
        }
        hrStatus = VersionFromString(Buffer,&InfVerMajor,&InfVerMinor,&InfVerBuild,&InfVerQFE);
        if(hrStatus == S_FALSE) {
            hrStatus = E_INVALIDARG;
            goto final;
        }
        if(SUCCEEDED(hrStatus)) {
            hrStatus = S_OK;
        } else {
            goto final;
        }
        if(VerMajor>=0) {
            if(VerMajor != InfVerMajor) {
                hrStatus = E_INVALIDARG;
                goto final;
            }
            if(VerMinor>=0) {
                if(VerMinor != InfVerMinor) {
                    hrStatus = E_INVALIDARG;
                    goto final;
                }
                if(VerBuild>=0) {
                    if(VerBuild != InfVerBuild) {
                        hrStatus = E_INVALIDARG;
                        goto final;
                    }
                    if(VerQFE>=0) {
                        if(VerQFE != InfVerQFE) {
                            hrStatus = E_INVALIDARG;
                            goto final;
                        }
                    }
                } else if(VerQFE != -1) {
                    //
                    // VerQFE must be -1
                    //
                    hrStatus = E_INVALIDARG;
                    goto final;
                }
            } else if((VerBuild != -1) || (VerQFE != -1)) {
                //
                // VerBuild & VerQFE must be -1
                //
                hrStatus = E_INVALIDARG;
                goto final;
            }
        } else if((VerMinor != -1) || (VerBuild != -1) || (VerQFE != -1)) {
            //
            // VerMinor, VerBuild & VerQFE must be -1
            //
            hrStatus = E_INVALIDARG;
            goto final;
        }
    } else {
        //
        // must be specified
        //
        if((VerMajor<0) || (VerMinor<0) || (VerBuild<0) || (VerQFE<0)) {
            hrStatus = E_INVALIDARG;
            goto final;
        }
        InfVerMajor = VerMajor;
        InfVerMinor = VerMinor;
        InfVerBuild = VerBuild;
        InfVerQFE = VerQFE;
    }
    //
    // determine friendly name
    // use Class= entry in INF (must always be specified)
    // if Name not defined, use class name instead
    //
    if(!SetupFindFirstLine(hInf,INFSTR_SECT_VERSION,INFSTR_KEY_CLASS,&InfLine)) {
        Status = GetLastError();
        goto final;
    }
    if(!Name) {
        if(!SetupGetStringField(&InfLine,1,FriendlyName,ARRAY_SIZE(FriendlyName),NULL)) {
            Status = GetLastError();
            goto final;
        }
        Name = FriendlyName;
    }

    //
    // we might not need to update this package after all
    //
    ZeroMemory(&OsComponentData,sizeof(OsComponentData));
    OsComponentData.SizeOfStruct = sizeof(OsComponentData);
    ZeroMemory(&OsExceptionData,sizeof(OsExceptionData));
    OsExceptionData.SizeOfStruct = sizeof(OsExceptionData);
    if(QueryRegisteredOsComponent(&InfGuid,&OsComponentData,&OsExceptionData)) {
        //
        // already registered? see if we supercede
        //
        if(((Flags & COMP_FLAGS_FORCE)==0) && (CompareCompVersion(InfVerMajor,InfVerMinor,InfVerBuild,InfVerQFE,&OsComponentData)<=0)) {
            VerbosePrint(TEXT("Not installing %s, %u.%u.%u.%u <= %u.%u.%u.%u"),
                                InfPath,
                                InfVerMajor,InfVerMinor,InfVerBuild,InfVerQFE,
                                OsComponentData.VersionMajor,
                                OsComponentData.VersionMinor,
                                OsComponentData.BuildNumber,
                                OsComponentData.QFENumber);
            hrStatus = S_FALSE;
            goto final;
        }
        PrevReg = TRUE;
    }

    //
    // determine MediaRoot and INF basename
    //
    DwRes= GetFullPathName(InfPath,MAX_PATH,MediaRoot,&BaseName);
    if(DwRes == 0) {
        Status = GetLastError();
        goto final;
    } else if(DwRes >= MAX_PATH) {
        Status = ERROR_INSUFFICIENT_BUFFER;
        goto final;
    }
    if((BaseName == NULL) || (BaseName == InfPath) || !BaseName[0]) {
        hrStatus = E_INVALIDARG;
        goto final;
    }
    if(BaseName[-1] != TEXT('\\')) {
        hrStatus = E_INVALIDARG;
        goto final;
    }
    //
    // split off MediaRoot and BaseName
    //
    BaseName[-1] = TEXT('\0');
    //
    // get Windows directory
    //
    UiRes = GetRealWindowsDirectory(Buffer,MAX_PATH);
    if(UiRes == 0) {
        Status = GetLastError();
        goto final;
    } else if(UiRes >= MAX_PATH) {
        Status = ERROR_INSUFFICIENT_BUFFER;
        goto final;
    }
    if(!SUCCEEDED(ConcatPath(Buffer,MAX_PATH,TEXT("\\")))) {
        Status = ERROR_INSUFFICIENT_BUFFER;
        goto final;
    }
    SubDir = Buffer+lstrlen(Buffer);
    //
    // c:\windows\
    // ^-buffer   ^-subdir
    // we'll do a number of operations using the subdir part of this buffer
    //
    // if PrevReg is TRUE, we most likely have access to previous package
    // so that we can install prev package to revert back to it
    // we expect this package to be in the windows directory as per spec
    // if it's not, then the old package might not still be around
    //
    if(PrevReg && _tcsncmp(OsExceptionData.ExceptionInfName,Buffer,SubDir-Buffer)==0) {
        //
        // it's a sub-directory of %windir%
        // now check for presence of INF and CAT files
        //
        DwRes = GetFileAttributes(OsExceptionData.ExceptionInfName);
        if(DwRes != INVALID_FILE_ATTRIBUTES) {
            DwRes = GetFileAttributes(OsExceptionData.CatalogFileName);
            if(DwRes != INVALID_FILE_ATTRIBUTES) {
                //
                // both present, looks good
                //
                CanRevert = TRUE;
            }
        }
    }

    //
    // determine final path/name of INF and catalog
    // We must place it directly in %windir%\<comp>
    // (WFP relies on this!!!!)
    // we'll backup what's there so that we can restore it later if needed
    //
    hrStatus = StringFromGuid(&InfGuid,GuidString,ARRAY_SIZE(GuidString));
    if(!SUCCEEDED(hrStatus)) {
        goto final;
    }
    hrStatus = S_OK;
    _sntprintf(SubDir,MAX_PATH,TEXT("%s\\%s"),
                                TEXT("RegisteredPackages"),
                                GuidString
                                );
    if((lstrlen(Buffer)+16)>MAX_PATH) {
        Status = ERROR_INSUFFICIENT_BUFFER;
        goto final;
    }
    lstrcpy(NewStore,Buffer);

    if(CanRevert) {
        hrStatus = BackupStore(NewStore,OldStore,ARRAY_SIZE(OldStore));
        if(!SUCCEEDED(hrStatus)) {
            //
            // if we failed backup, that means there's something bad
            // such as files in the store in use
            // probability is that we'll fail later
            // so fail gracefully now instead of badly later
            //
            goto final;
        }
        hrStatus = S_OK;
    }

    //
    // see if %windir%\INF\<BaseName> is there?
    //
    lstrcpy(SubDir,TEXT("INF\\"));
    if(!SUCCEEDED(ConcatPath(Buffer,MAX_PATH,BaseName))) {
        Status = ERROR_INSUFFICIENT_BUFFER;
        goto final;
    }
    DwRes = GetFileAttributes(Buffer);
    if(DwRes != INVALID_FILE_ATTRIBUTES) {
        //
        // replacing an existing INF
        // to work around a cache bug, we'll kick the actuall install
        // off in another process
        //
        NeedProxy = TRUE;
    }

    hrStatus = MakeSurePathExists(NewStore);
    if(!SUCCEEDED(hrStatus)) {
        goto final;
    }

    //
    // install INF into %windir%\INF directory noting location the files
    // should be
    //
    if((g_VerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) && (g_VerInfo.dwMajorVersion >= 5)) {
        //
        // only do this on Win2k+
        // this will have SetupAPI tell us the original name and the catalog
        // name
        //
        if(CopyOEMInf(InfPath,NewStore,SPOST_PATH,0,NULL,0,NULL,NULL)) {
            //
            // Switch to the INF that's in %windir%\INF directory
            //
            SetupCloseInfFile(hInf);
            hInf = SetupOpenInfFile(Buffer,NULL,INF_STYLE_WIN4,NULL);
            if(hInf == INVALID_HANDLE_VALUE) {
                Status = GetLastError();
                goto final;
            }
        } else {
            Status = GetLastError();
            goto final;
        }
    }
    //
    // now find out what the catalog name would be
    //
    hrStatus = GetInfOriginalFileInformation(hInf,&InfOriginalFileInformation);
    if(!SUCCEEDED(hrStatus)) {
        goto final;
    }
    if((InfOriginalFileInformation.OriginalInfName[0]==TEXT('\0'))
       ||(InfOriginalFileInformation.OriginalCatalogName[0]==TEXT('\0'))) {
        //
        // shouldn't happen
        //
        hrStatus = E_FAIL;
        goto final;
    }

    ZeroMemory(&NewOsExceptionData,sizeof(NewOsExceptionData));
    NewOsExceptionData.SizeOfStruct = sizeof(NewOsExceptionData);
    //
    // INF name
    //
    BaseName = GetBaseName(InfOriginalFileInformation.OriginalInfName);
    lstrcpyn(NewOsExceptionData.ExceptionInfName,NewStore,ARRAY_SIZE(NewOsExceptionData.ExceptionInfName));
    if(!SUCCEEDED(ConcatPath(NewOsExceptionData.ExceptionInfName,ARRAY_SIZE(NewOsExceptionData.ExceptionInfName),BaseName))) {
        Status = ERROR_INSUFFICIENT_BUFFER;
        goto final;
    }
    lstrcpy(Buffer,MediaRoot);
    if(!SUCCEEDED(ConcatPath(Buffer,MAX_PATH,BaseName))) {
        Status = ERROR_INSUFFICIENT_BUFFER;
        goto final;
    }
    if(!CopyFile(Buffer,NewOsExceptionData.ExceptionInfName,FALSE)) {
        Status = GetLastError();
        goto final;
    }
    //
    // CAT name
    //
    BaseName = GetBaseName(InfOriginalFileInformation.OriginalCatalogName);
    lstrcpyn(NewOsExceptionData.CatalogFileName,NewStore,ARRAY_SIZE(NewOsExceptionData.CatalogFileName));
    if(!SUCCEEDED(ConcatPath(NewOsExceptionData.CatalogFileName,ARRAY_SIZE(NewOsExceptionData.CatalogFileName),BaseName))) {
        Status = ERROR_INSUFFICIENT_BUFFER;
        goto final;
    }
    lstrcpy(Buffer,MediaRoot);
    if(!SUCCEEDED(ConcatPath(Buffer,MAX_PATH,BaseName))) {
        Status = ERROR_INSUFFICIENT_BUFFER;
        goto final;
    }
    if(!CopyFile(Buffer,NewOsExceptionData.CatalogFileName,FALSE)) {
        Status = GetLastError();
        goto final;
    }

    //
    // WFP may query exception pack as a source to restore files that are replaced
    // change registration so if WFP does get in loop, it goes to the right place
    //
    if(PrevReg) {
        UnRegisterOsComponent(&InfGuid);
    }
    ZeroMemory(&NewOsComponentData,sizeof(NewOsComponentData));
    NewOsComponentData.SizeOfStruct = sizeof(NewOsComponentData);
    NewOsComponentData.ComponentGuid = InfGuid;
    lstrcpyn(NewOsComponentData.FriendlyName,Name,ARRAY_SIZE(NewOsComponentData.FriendlyName));
    NewOsComponentData.VersionMajor = (WORD)InfVerMajor;
    NewOsComponentData.VersionMinor = (WORD)InfVerMinor;
    NewOsComponentData.BuildNumber  = (WORD)InfVerBuild;
    NewOsComponentData.QFENumber    = (WORD)InfVerQFE;
    if(!RegisterOsComponent(&NewOsComponentData,&NewOsExceptionData)) {
        Status = GetLastError();
        goto final;
    }
    if(((Flags & COMP_FLAGS_NOUI)==0) && !IsInteractiveWindowStation()) {
        Flags |= COMP_FLAGS_NOUI;
    }

    if(NeedProxy) {
        //
        // A bug in Win2k/XP means that we have problems if replacing an existing
        // exception-pack component
        //
        hrStatus = ProxyInstallExceptionPackFromInf(InfPath,MediaRoot,NewStore,Flags);
    } else {
        hrStatus = InstallExceptionPackFromInf(InfPath,MediaRoot,NewStore,Flags);
    }
    if(!SUCCEEDED(hrStatus)) {
        //
        // not sure best thing to do here, but
        // the component that we had above is definately invalid
        //
        UnRegisterOsComponent(&InfGuid);
        if(PrevReg) {
            RegisterOsComponent(&OsComponentData,&OsExceptionData);
        }
        if(BackedUp) {
            //
            // we got part through and failed. Re-install the old component
            // to revert whatever we did
            //
            RevertStore(OldStore,NewStore);
            BackedUp = FALSE;
            InstallInfSection(OsExceptionData.ExceptionInfName,NULL,COMP_FLAGS_NOUI);
        }
        goto final;
    } else {
        //
        // don't need backup any more
        //
        if(BackedUp) {
            DeleteDirectoryRecursive(OldStore);
            BackedUp = FALSE;
        }
    }
    //
    // succeeded
    //
    Status = NO_ERROR;
    if(hrStatus == INST_S_REBOOT) {
        hrStatus = HandleReboot(Flags);
    } else {
        hrStatus = S_OK;
    }


  final:
    if(hInf != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile(hInf);
    }
    if((hrStatus == S_OK) && Status != NO_ERROR) {
        hrStatus = HRESULT_FROM_SETUPAPI(Status);
    }
    if(BackedUp) {
        //
        // we need to revert the backup
        //
        RevertStore(OldStore,NewStore);
    }
    return hrStatus;
}

HRESULT
WINAPI
InstallComponentA(
    IN LPCSTR InfPath,
    IN DWORD   Flags,
    IN const GUID * CompGuid, OPTIONAL
    IN INT VerMajor,           OPTIONAL
    IN INT VerMinor,           OPTIONAL
    IN INT VerBuild,           OPTIONAL
    IN INT VerQFE,             OPTIONAL
    IN LPCSTR Name            OPTIONAL
    )
{
    TCHAR OutPath[MAX_PATH];
    TCHAR OutDesc[DESC_SIZE]; // as per friendly name
    INT sz;
    if(InfPath) {
        sz = MultiByteToWideChar(CP_ACP,0,InfPath,-1,OutPath,ARRAY_SIZE(OutPath));
        if(!sz) {
            return E_INVALIDARG;
        }
    }
    if(Name) {
        sz = MultiByteToWideChar(CP_ACP,0,Name,-1,OutDesc,ARRAY_SIZE(OutDesc));
        if(!sz) {
            return E_INVALIDARG;
        }
    }
    return InstallComponent(InfPath ? OutPath : NULL,
                            Flags,
                            CompGuid,
                            VerMajor,
                            VerMinor,
                            VerBuild,
                            VerQFE,
                            Name ? OutDesc : NULL);
}

VOID
WINAPI
DoInstallW(
    IN HWND      Window,
    IN HINSTANCE ModuleHandle,
    IN PCTSTR    CommandLine,
    IN INT       ShowCommand
    )
/*++

Routine Description:

    exported for call by rundll32

Arguments:

    Window       - parent window (not used)
    ModuleHandle - not used
    CommandLine  - see below
    ShowCommand  - not used

    CommandLine -
        "InfPath;Flags;GUID;High.Low.Build.QFE;Name" (; - CMD_SEP)

Return Value:

    none

--*/
{
    TCHAR InfPath[MAX_PATH];
    TCHAR Desc[DESC_SIZE];
    TCHAR Hold[64];
    INT VerMajor = -1;
    INT VerMinor = -1;
    INT VerBuild = -1;
    INT VerQFE = -1;
    GUID Guid;
    DWORD Flags = 0;
    LPGUID pGuid = NULL;
    LPTSTR pDesc = NULL;
    LPCTSTR pCmd = CommandLine;
    LPCTSTR pEnd;
    HRESULT hResult = S_OK;

    //
    // break CommandLine up into relevent parts
    // First InfPath
    //
    pEnd = _tcschr(pCmd,CMD_SEP);
    if(!pEnd) {
        pEnd = pCmd+lstrlen(pCmd);
    }
    if((pEnd == pCmd) || ((pEnd-pCmd)>=MAX_PATH)) {
        hResult = E_INVALIDARG;
        goto final;
    }
    CopyMemory(InfPath,pCmd,(pEnd-pCmd)*sizeof(TCHAR));
    InfPath[pEnd-pCmd] = TEXT('\0');
    if(*pEnd == CMD_SEP) {
        pCmd = pEnd+1;
        if((*pCmd == CMD_SEP) || (*pCmd == TEXT('\0'))) {
            //
            // skip
            //
            pEnd = pCmd;
        } else {
            //
            // Flags
            //
            Flags = (DWORD)_tcstoul(pCmd,&(LPTSTR)pEnd,0);
            if((*pEnd != CMD_SEP) && (*pEnd != TEXT('\0'))) {
                hResult = E_INVALIDARG;
                goto final;
            }
        }
    }
    if(*pEnd == CMD_SEP) {
        pCmd = pEnd+1;
        if((*pCmd == CMD_SEP) || (*pCmd == TEXT('\0'))) {
            //
            // skip
            //
            pEnd = pCmd;
        } else {
            //
            // Guid
            //
            pEnd = _tcschr(pCmd,CMD_SEP);
            if(!pEnd) {
                pEnd = pCmd+lstrlen(pCmd);
            }
            if((pEnd-pCmd)>=ARRAY_SIZE(Hold)) {
                hResult = E_INVALIDARG;
                goto final;
            }
            CopyMemory(Hold,pCmd,(pEnd-pCmd)*sizeof(TCHAR));
            Hold[pEnd-pCmd] = TEXT('\0');
            hResult = GuidFromString(Hold,&Guid);
            if(!SUCCEEDED(hResult)) {
                goto final;
            }
            pGuid = &Guid;
        }
    }
    if(*pEnd == CMD_SEP) {
        pCmd = pEnd+1;
        if((*pCmd == CMD_SEP) || (*pCmd == TEXT('\0'))) {
            //
            // skip
            //
            pEnd = pCmd;
        } else {
            //
            // Version
            //
            pEnd = _tcschr(pCmd,CMD_SEP);
            if(!pEnd) {
                pEnd = pCmd+lstrlen(pCmd);
            }
            if((pEnd-pCmd)>=ARRAY_SIZE(Hold)) {
                hResult = E_INVALIDARG;
                goto final;
            }
            CopyMemory(Hold,pCmd,(pEnd-pCmd)*sizeof(TCHAR));
            Hold[pEnd-pCmd] = TEXT('\0');
            hResult = VersionFromString(Hold,&VerMajor,&VerMinor,&VerBuild,&VerQFE);
            if(!SUCCEEDED(hResult)) {
                goto final;
            }
            if(hResult == S_FALSE) {
                VerMajor = VerMinor = VerBuild = VerQFE = -1;
            }
        }
    }
    if(*pEnd == CMD_SEP) {
        pCmd = pEnd+1;
        pEnd = pCmd+lstrlen(pCmd);
        if(pEnd != pCmd) {
            if((pEnd-pCmd) >= ARRAY_SIZE(Desc)) {
                hResult = E_INVALIDARG;
                goto final;
            }
            CopyMemory(Desc,pCmd,(pEnd-pCmd)*sizeof(TCHAR));
            Desc[pEnd-pCmd] = TEXT('\0');
            pDesc = Desc;
        }
    }
    hResult = InstallComponent(InfPath,Flags,pGuid,VerMajor,VerMinor,VerBuild,VerQFE,pDesc);

  final:
    if(SUCCEEDED(hResult)) {
        //
        // deal with specific success scenarios
        //
    } else {
        //
        // an error occurred
        //
        DebugPrint(TEXT("DoInstall failed with error: 0x%08x"),hResult);
    }
}


VOID
WINAPI
DoInstallA(
    IN HWND      Window,
    IN HINSTANCE ModuleHandle,
    IN PCSTR     CommandLine,
    IN INT       ShowCommand
    )
{
    TCHAR OutLine[MAX_PATH*2];
    INT sz;
    sz = MultiByteToWideChar(CP_ACP,0,CommandLine,-1,OutLine,ARRAY_SIZE(OutLine));
    if(!sz) {
        DebugPrint(TEXT("DoInstallA was passed too big a command line"));
        return;
    }
    DoInstall(Window,ModuleHandle,OutLine,ShowCommand);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\mpk\misclib\trackbuf.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    trackbuf.c

Abstract:

    Routine to allocate a buffer suitable for i/o a track
    at a time.

Author:

    Ted Miller (tedm) 29-May-1997

Revision History:

--*/

#include <mytypes.h>
#include <misclib.h>

#include <malloc.h>


BOOL
_far
AllocTrackBuffer(
    IN  BYTE         SectorsPerTrack,
    OUT FPVOID _far *AlignedBuffer,
    OUT FPVOID _far *Buffer
    )
{
    FPVOID p;
    ULONG u;

    //
    //
    // We allocate twice the size we need because we will need to ensure
    // that the buffer doesn't cross a 64K physical boundary.
    // NOTE: sectors per track is assumed to be max 63!
    //
    if(SectorsPerTrack > 63) {
        return(FALSE);
    }

    p = malloc(SectorsPerTrack * 512 * 2);
    if(!p) {
        return(FALSE);
    }

    //
    // Calculate physical address of buffer.
    //
    u = ((ULONG)p & 0xffffL) + (((ULONG)p >> 16) << 4);

    //
    // Figure out whether the buffer crosses a 64k boundary.
    // If it does, we allocated enough to relocate it
    // to the next 64k boundary.
    //
    if((u & 0xf0000L) != ((u + (512*SectorsPerTrack)) & 0xf0000L)) {

        u = (u & 0xf0000L) + 0x10000;
    }

    //
    // Convert back to seg:offset. The conversion guarantees that
    // the offset will be in the range 0-f.
    //
    *AlignedBuffer = (FPVOID)(((u >> 4) << 16) + (u & 0xf));
    *Buffer = p;

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\msoobci\devinst.c ===
/*++

Copyright (c) Microsoft Corporation. All Rights Reserved.

Module Name:

    msoobci.c

Abstract:

    Exception Pack installer helper DLL
    Can be used as a co-installer, or called via setup app, or RunDll32 stub

    This DLL is for internal distribution of exception packs to update
    OS components.

Author:

    Jamie Hunter (jamiehun) 2001-11-27

Revision History:

    Jamie Hunter (jamiehun) 2001-11-27

        Initial Version

--*/
#include "msoobcip.h"


typedef struct _INST_POSTPROCESSING_INFO {
    DWORD Flags;
} INST_POSTPROCESSING_INFO;

DWORD
CALLBACK
DriverInstallComponents (
    IN     DI_FUNCTION               InstallFunction,
    IN     HDEVINFO                  DeviceInfoSet,
    IN     PSP_DEVINFO_DATA          DeviceInfoData,
    IN OUT PCOINSTALLER_CONTEXT_DATA Context
    )
/*++

Routine Description:

    co-installer callback
    catch the moment of call to DIF_INSTALLDEVICE
    Consider installing exception packs at this point
    If we succeed, we may need to restart device install

Arguments:

    InstallFunction - DIF_INSTALLDEVICE
    DeviceInfoSet/DeviceInfoData - describes device


Return Value:

    status, normally NO_ERROR

--*/
{
    DWORD Status = NO_ERROR;

    if((g_VerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) && (g_VerInfo.dwMajorVersion >= 5)) {
        //
        // we should only be executing co-installers on Win2k+
        // but this is an added sanity check
        //
        switch (InstallFunction)
        {
        case DIF_INSTALLDEVICE:
            VerbosePrint(TEXT("handling DIF_INSTALLDEVICE"));
            if(Context->PostProcessing) {
                Status = DoDriverInstallComponentsPostProcessing(DeviceInfoSet,DeviceInfoData,Context);
            } else {
                Status = DoDriverInstallComponents(DeviceInfoSet,DeviceInfoData,Context);
            }
            VerbosePrint(TEXT("finished DIF_INSTALLDEVICE with status=0x%08x"),Status);
            break;

        default:
            break;
        }
    }
    return Status;
}


DWORD
DoDriverInstallComponents (
    IN     HDEVINFO          DeviceInfoSet,
    IN     PSP_DEVINFO_DATA  DeviceInfoData,
    IN OUT PCOINSTALLER_CONTEXT_DATA Context
    )
/*++

Routine Description:

    co-installer callback
    enumerate all the components sections

Arguments:

    DeviceInfoSet/DeviceInfoData - describes device
    Context - callback context


Return Value:

    status, normally NO_ERROR

--*/
{
    SP_DRVINFO_DATA        DriverInfoData;
    SP_DRVINFO_DETAIL_DATA DriverInfoDetailData;
    HINF                   InfFile = INVALID_HANDLE_VALUE;
    DWORD                  AndFlags = (DWORD)(-1);
    DWORD                  OrFlags  = (DWORD)0;
    INFCONTEXT             CompLine;
    TCHAR                  InstallSectionName[LINE_LEN];
    TCHAR                  CompSectionName[LINE_LEN];
    DWORD                  FieldIndex;
    DWORD                  FieldCount;
    DWORD                  Status;
    DWORD                  FinalStatus = NO_ERROR;
    INST_POSTPROCESSING_INFO PostProcess;

    ZeroMemory(&PostProcess,sizeof(PostProcess));

    //
    // determine selected driver
    // and INF
    //
    DriverInfoData.cbSize = sizeof(SP_DRVINFO_DATA);
    if (!SetupDiGetSelectedDriver( DeviceInfoSet,
                                   DeviceInfoData,
                                   &DriverInfoData)) {
        Status = GetLastError();
        DebugPrint(TEXT("Fail: SetupDiGetSelectedDriver, Error: 0x%08x"),Status);
        goto clean;
    }

    DriverInfoDetailData.cbSize = sizeof(SP_DRVINFO_DETAIL_DATA);
    if (!SetupDiGetDriverInfoDetail(DeviceInfoSet,
                                    DeviceInfoData,
                                    &DriverInfoData,
                                    &DriverInfoDetailData,
                                    sizeof(SP_DRVINFO_DETAIL_DATA),
                                    NULL)) {
        Status = GetLastError();
        if (Status == ERROR_INSUFFICIENT_BUFFER) {
            //
            // We don't need the extended information.  Ignore.
            //
        } else {
            DebugPrint(TEXT("Fail: SetupDiGetDriverInfoDetail, 0xError: %08x"),Status);
            goto clean;
        }
    }
    InfFile = SetupOpenInfFile(DriverInfoDetailData.InfFileName,
                               NULL,
                               INF_STYLE_WIN4,
                               NULL);
    if (InfFile == INVALID_HANDLE_VALUE) {
        Status = GetLastError();
        DebugPrint(TEXT("Fail: SetupOpenInfFile"));
        goto clean;
    }

    if(!SetupDiGetActualSectionToInstall(InfFile,
                                         DriverInfoDetailData.SectionName,
                                         InstallSectionName,
                                         LINE_LEN,
                                         NULL,
                                         NULL)) {

        Status = GetLastError();
        DebugPrint(TEXT("Fail: SetupDiGetActualSectionToInstall, Error: 0x%08x"),Status);
        goto clean;
    }

    //
    // look for one or more Components= entries in INF section
    //
    if (SetupFindFirstLine(InfFile,
                           InstallSectionName,
                           KEY_COMPONENTS,
                           &CompLine)) {
        VerbosePrint(TEXT("Components keyword found in %s"),DriverInfoDetailData.InfFileName);
        do {
            //
            // Components = section,section,...
            // first section @ index 1.
            //
            FieldCount = SetupGetFieldCount(&CompLine);
            for(FieldIndex = 1;FieldIndex<=FieldCount;FieldIndex++) {
                if(SetupGetStringField(&CompLine,
                                       FieldIndex,
                                       CompSectionName,
                                       LINE_LEN,
                                       NULL)) {
                    //
                    // we have a listed section
                    //
                    Status = DoDriverComponentsSection(InfFile,
                                                       CompSectionName,
                                                       &AndFlags,
                                                       &OrFlags);
                    if(Status != NO_ERROR) {
                        FinalStatus = Status;
                        goto clean;
                    }
                } else {
                    Status = GetLastError();
                    DebugPrint(TEXT("Fail: SetupGetStringField, Error: 0x%08x"),Status);
                    //
                    // non-fatal
                    //
                }
            }
        } while (SetupFindNextMatchLine(&CompLine,
                                        KEY_COMPONENTS,
                                        &CompLine));

        //
        // handle AndFlags/OrFlags here
        //
        if(OrFlags & (FLAGS_REBOOT|FLAGS_REINSTALL)) {
            //
            // reboot is required
            //
            HMACHINE hMachine = NULL;
            SP_DEVINFO_LIST_DETAIL_DATA DevInfoListDetail;
            SP_DEVINSTALL_PARAMS DeviceInstallParams;
            DeviceInstallParams.cbSize = sizeof(DeviceInstallParams);

            if(SetupDiGetDeviceInstallParams(DeviceInfoSet,
                                              DeviceInfoData,
                                              &DeviceInstallParams)) {
                //
                // set reboot flags
                //
                DeviceInstallParams.Flags |= DI_NEEDRESTART|DI_NEEDREBOOT;
                SetupDiSetDeviceInstallParams(DeviceInfoSet,
                                                DeviceInfoData,
                                                &DeviceInstallParams);

            }
            DevInfoListDetail.cbSize = sizeof(DevInfoListDetail);
            if(GetDeviceInfoListDetail(DeviceInfoSet,&DevInfoListDetail)) {
                hMachine = DevInfoListDetail.RemoteMachineHandle;
            }
            Set_DevNode_Problem_Ex(DeviceInfoData->DevInst,
                                      CM_PROB_NEED_RESTART,
                                      CM_SET_DEVINST_PROBLEM_OVERRIDE,
                                      hMachine);
        }
        if(OrFlags & FLAGS_REINSTALL) {
            //
            // we'll need to mark the device as needing reinstall when we go through post-processing
            //
            FinalStatus = ERROR_DI_POSTPROCESSING_REQUIRED;
            PostProcess.Flags |= POSTFLAGS_REINSTALL;
        }
    }

clean:

    if (InfFile != INVALID_HANDLE_VALUE) {
        SetupCloseInfFile(InfFile);
    }

    if(FinalStatus == ERROR_DI_POSTPROCESSING_REQUIRED) {
        //
        // data to use during post-processing
        //
        INST_POSTPROCESSING_INFO *pPostProcess = malloc(sizeof(INST_POSTPROCESSING_INFO));
        if(!pPostProcess) {
            return ERROR_OUTOFMEMORY;
        }
        *pPostProcess = PostProcess;
        Context->PrivateData = pPostProcess;
    }

    return FinalStatus;
}

DWORD
DoDriverInstallComponentsPostProcessing (
    IN     HDEVINFO          DeviceInfoSet,
    IN     PSP_DEVINFO_DATA  DeviceInfoData,
    IN OUT PCOINSTALLER_CONTEXT_DATA Context
    )
/*++

Routine Description:

    co-installer callback
    enumerate all the components sections

Arguments:

    DeviceInfoSet/DeviceInfoData - describes device
    Context - callback context


Return Value:

    status, normally NO_ERROR

--*/
{
    INST_POSTPROCESSING_INFO PostProcess;
    SP_DEVINFO_LIST_DETAIL_DATA DevInfoListDetail;
    HMACHINE hMachine = NULL;

    if(!Context->PrivateData) {
        return Context->InstallResult;
    }
    PostProcess = *(INST_POSTPROCESSING_INFO*)(Context->PrivateData);
    free(Context->PrivateData);
    Context->PrivateData = NULL;

    DevInfoListDetail.cbSize = sizeof(DevInfoListDetail);
    if(GetDeviceInfoListDetail(DeviceInfoSet,&DevInfoListDetail)) {
        hMachine = DevInfoListDetail.RemoteMachineHandle;
    }

    if(PostProcess.Flags & POSTFLAGS_REINSTALL) {

        Set_DevNode_Problem_Ex(DeviceInfoData->DevInst,
                                  CM_PROB_REINSTALL,
                                  CM_SET_DEVINST_PROBLEM_OVERRIDE,
                                  hMachine);
    }

    return Context->InstallResult;
}

DWORD
DoDriverComponentsSection(
    IN     HINF    InfFile,
    IN     LPCTSTR CompSectionName,
    IN OUT DWORD  *AndFlags,
    IN OUT DWORD  *OrFlags
    )
/*++

Routine Description:

    enumerate all the component entries in component section
    component entry consists of
    filename,flags,identity,version
    filename is absolute directory, eg, %1%\foo.inf
    flags - bit 16 set indicating Exception Pack
            bit 0 set indicating device install needs restarting
    identity - component GUID
    version  - component version

Arguments:

    InfFile - handle to INF file
    CompSectionName - handle to components section
    AndFlags/OrFlags - accumulated flags

Return Value:

    status, normally NO_ERROR

--*/
{
    INFCONTEXT             EntryLine;
    TCHAR                  Path[MAX_PATH];
    DWORD                  Flags;
    INT                    FieldVal;
    DWORD                  SubFlags;
    DWORD                  Status;

    if (!SetupFindFirstLine(InfFile,
                            CompSectionName,
                            NULL,
                           &EntryLine)) {
        //
        // section was empty
        //
        VerbosePrint(TEXT("Section [%s] is empty"),CompSectionName);
        return NO_ERROR;
    }
    VerbosePrint(TEXT("Processing components section [%s]"),CompSectionName);
    do {
        if(!SetupGetStringField(&EntryLine,COMPFIELD_NAME,Path,MAX_PATH,NULL)) {
            Status = GetLastError();
            DebugPrint(TEXT("- Fail: SetupGetStringField(1), Error: 0x%08x"),Status);
            return NO_ERROR;
        }
        VerbosePrint(TEXT("Processing component %s"),Path);
        if(SetupGetIntField(&EntryLine,COMPFIELD_FLAGS,&FieldVal)) {
            Flags = (DWORD)FieldVal;
        } else {
            Status = GetLastError();
            DebugPrint(TEXT("- Fail: SetupGetIntField(2), Error: 0x%08x"),Status);
            return NO_ERROR;
        }
        SubFlags = Flags & ~ FLAGS_METHOD;
        switch(Flags & FLAGS_METHOD) {
            case FLAGS_EXPACK:
                Status = DoDriverExPack(&EntryLine,Path,&SubFlags);
                break;
            case FLAGS_QFE:
                Status = DoDriverQfe(&EntryLine,Path,&SubFlags);
                break;
            default:
                DebugPrint(TEXT("- Fail: Invalid component type"));
                Status = ERROR_INVALID_DATA;
                break;
        }
        if(Status != NO_ERROR) {
            return Status;
        }
        if(SubFlags & FLAGS_INSTALLED) {
            *AndFlags &= SubFlags;
            *OrFlags |= SubFlags;
        }
    } while (SetupFindNextLine(&EntryLine,&EntryLine));

    return NO_ERROR;
}

DWORD
DoDriverExPack(
    IN     INFCONTEXT  *EntryLine,
    IN     LPCTSTR      PathName,
    IN OUT DWORD       *Flags
    )
/*++

Routine Description:

    queries and potentially installs exception-pack component

Arguments:

    EntryLine - context for remaining information
    PathName  - name of exception pack INF (param 1)
    SubFlags  - flags passed in (param 2) sans type of install

    component entry consists of
    filename,flags,identity,version
    filename is absolute directory, eg, %1%\foo.inf
    identity - component GUID
    version  - component version

Return Value:

    status, normally NO_ERROR
    if return value >= 0x80000000 then it's a HRESULT error

--*/
{
    TCHAR   CompIdentity[64]; // expecting a GUID
    TCHAR   CompVersion[64];  // major.minor
    TCHAR   CompDesc[DESC_SIZE];     // description
    GUID    ComponentGuid;
    INT     VerMajor = -1;
    INT     VerMinor = -1;
    INT     VerBuild = -1;
    INT     VerQFE = -1;
    DWORD   Status;
    DWORD   dwLen;
    HRESULT hrStatus;
    SETUP_OS_COMPONENT_DATA OsComponentData;
    SETUP_OS_EXCEPTION_DATA OsExceptionData;
    UINT uiRes;
    TCHAR SrcPath[MAX_PATH];
    TCHAR NewSrcPath[MAX_PATH];
    TCHAR CompOsVerRange[128];
    LPTSTR ToVerPart;
    LPTSTR SrcName;
    BOOL PreInst = FALSE;

    VerbosePrint(TEXT("- %s is an exception pack"),PathName);
    //
    // now read in identity and version
    // we can then check to see if an apropriate version installed
    //

    if(!SetupGetStringField(EntryLine,COMPFIELD_COMP,CompIdentity,ARRAY_SIZE(CompIdentity),NULL)) {
        Status = GetLastError();
        DebugPrint(TEXT("- Fail: SetupGetStringField(3), Error: 0x%08x"),Status);
        return Status;
    }
    if(!SetupGetStringField(EntryLine,COMPFIELD_VER,CompVersion,ARRAY_SIZE(CompVersion),NULL)) {
        Status = GetLastError();
        DebugPrint(TEXT("- Fail: SetupGetStringField(4), Error: 0x%08x"),Status);
        return Status;
    }
    if(!SetupGetStringField(EntryLine,COMPFIELD_DESC,CompDesc,ARRAY_SIZE(CompDesc),NULL)) {
        CompDesc[0] = TEXT('\0');
    }
    if(SetupGetStringField(EntryLine,COMPFIELD_OSVER,CompOsVerRange,ARRAY_SIZE(CompOsVerRange),NULL)) {
        //
        // need to verify OS version range, do that now
        //
        int maj_f,min_f,build_f,qfe_f;
        int maj_t,min_t,build_t,qfe_t;

        ToVerPart = _tcschr(CompOsVerRange,TEXT('-'));
        if(ToVerPart) {
            *ToVerPart = TEXT('\0');
            ToVerPart++;
        }
        hrStatus = VersionFromString(CompOsVerRange,&maj_f,&min_f,&build_f,&qfe_f);
        if(!SUCCEEDED(hrStatus)) {
            return (DWORD)hrStatus;
        }
        if((hrStatus == S_FALSE) || (qfe_f != 0)) {
            return ERROR_INVALID_PARAMETER;
        }
        if(ToVerPart) {
            hrStatus = VersionFromString(ToVerPart,&maj_t,&min_t,&build_t,&qfe_t);
            if(!SUCCEEDED(hrStatus)) {
                return (DWORD)hrStatus;
            }
            if((hrStatus == S_FALSE) || (qfe_t != 0)) {
                return ERROR_INVALID_PARAMETER;
            }
            if(CompareVersion(maj_f,
                                min_f,
                                build_f>0 ? build_f : -1,
                                0,
                                g_VerInfo.dwMajorVersion,
                                g_VerInfo.dwMinorVersion,
                                g_VerInfo.dwBuildNumber,
                                0) > 0) {
                VerbosePrint(TEXT("- Skipped (OS < %u.%u.%u)"),
                                maj_f,min_f,build_f);
                return NO_ERROR;
            } else if(CompareVersion(maj_t,
                                min_t,
                                build_t>0 ? build_t : -1,
                                0,
                                g_VerInfo.dwMajorVersion,
                                g_VerInfo.dwMinorVersion,
                                g_VerInfo.dwBuildNumber,
                                0) < 0) {
                VerbosePrint(TEXT("- Skipped (OS > %u.%u.%u)"),
                                maj_t,min_t,build_t);
                return NO_ERROR;
            }
        } else {
            if(CompareVersion(maj_f,
                                min_f,
                                build_f,
                                0,
                                g_VerInfo.dwMajorVersion,
                                g_VerInfo.dwMajorVersion,
                                g_VerInfo.dwMajorVersion,
                                0) != 0) {
                VerbosePrint(TEXT("- Skipped (OS != %u.%u.%u)"),
                                maj_f,min_f,build_f);
                return NO_ERROR;
            }
        }
    }
    //
    // fold CompIdentity into a GUID
    //
    hrStatus = GuidFromString(CompIdentity,&ComponentGuid);
    if(!SUCCEEDED(hrStatus)) {
        return (DWORD)hrStatus;
    }
    //
    // and version
    //
    hrStatus = VersionFromString(CompVersion,&VerMajor,&VerMinor,&VerBuild,&VerQFE);
    if(hrStatus == S_FALSE) {
        return ERROR_INVALID_PARAMETER;
    }
    if(!SUCCEEDED(hrStatus)) {
        return (DWORD)hrStatus;
    }
    //
    // now do a component check
    //
    ZeroMemory(&OsComponentData,sizeof(OsComponentData));
    OsComponentData.SizeOfStruct = sizeof(OsComponentData);
    ZeroMemory(&OsExceptionData,sizeof(OsExceptionData));
    OsExceptionData.SizeOfStruct = sizeof(OsExceptionData);
    if(QueryRegisteredOsComponent(&ComponentGuid,&OsComponentData,&OsExceptionData)) {
        //
        // maybe already registered?
        //
        if(CompareCompVersion(VerMajor,VerMinor,VerBuild,VerQFE,&OsComponentData)<=0) {
            VerbosePrint(TEXT("- Skipped, %u.%u.%u.%u <= %u.%u.%u.%u"),
                                VerMajor,VerMinor,VerBuild,VerQFE,
                                OsComponentData.VersionMajor,
                                OsComponentData.VersionMinor,
                                OsComponentData.BuildNumber,
                                OsComponentData.QFENumber);
            return NO_ERROR;
        }
    }
    VerbosePrint(TEXT("- Install, %u.%u.%u.%u > %u.%u.%u.%u"),
                                VerMajor,VerMinor,VerBuild,VerQFE,
                                OsComponentData.VersionMajor,
                                OsComponentData.VersionMinor,
                                OsComponentData.BuildNumber,
                                OsComponentData.QFENumber);
    //
    // we need to make sure component INF media is in
    // prompt for media if interactive and INF cannot be found
    //
    dwLen = GetFullPathName(PathName,MAX_PATH,SrcPath,&SrcName);
    if(dwLen >= MAX_PATH) {
        return ERROR_INSUFFICIENT_BUFFER;
    }
    if(SrcName == SrcPath) {
        //
        // shouldn't happen
        //
        return ERROR_INVALID_DATA;
    }
    *CharPrev(SrcPath,SrcName) = TEXT('\0');
    uiRes = SetupPromptForDisk(
                    NULL, // parent
                    NULL, // title
                    CompDesc[0] ? CompDesc : NULL, // disk name
                    SrcPath, // path to source
                    SrcName, // name of file
                    NULL,    // tag file
                    IDF_CHECKFIRST|IDF_NOCOMPRESSED|IDF_NOSKIP,
                    NewSrcPath,
                    ARRAY_SIZE(NewSrcPath),
                    NULL);

    switch(uiRes) {
        case DPROMPT_SUCCESS:
            break;
        case DPROMPT_CANCEL:
        case DPROMPT_SKIPFILE:
            return ERROR_FILE_NOT_FOUND;
        case DPROMPT_BUFFERTOOSMALL:
            return ERROR_INSUFFICIENT_BUFFER;
        case DPROMPT_OUTOFMEMORY:
            return ERROR_OUTOFMEMORY;
        default:
            //
            // shouldn't happen
            //
            return ERROR_INVALID_DATA;
    }

    hrStatus = ConcatPath(NewSrcPath,MAX_PATH,SrcName);
    if(!SUCCEEDED(hrStatus)) {
        return (DWORD)hrStatus;
    }
    hrStatus = InstallComponent(NewSrcPath,
                                COMP_FLAGS_NOUI,
                                &ComponentGuid,
                                VerMajor,
                                VerMinor,
                                VerBuild,
                                VerQFE,
                                CompDesc[0] ? CompDesc : NULL);
    if(!SUCCEEDED(hrStatus)) {
        return (DWORD)hrStatus;
    }
    //
    // if install was not skipped, we get S_OK, else S_FALSE
    //
    if(hrStatus == S_OK) {
        *Flags |= FLAGS_INSTALLED;
    } else if(hrStatus == INST_S_REBOOT) {
        *Flags |= FLAGS_INSTALLED|FLAGS_REBOOT;
    }
    return NO_ERROR;
}

DWORD
CheckQfe(
    IN     INT          SpNum,
    IN     LPCTSTR      QfeNum
    )
/*++

Routine Description:

    This is pretty dirty, it knows where the QFE #'s will go
    in registry for Win2k/WinXP so checks there
    this saves us running the QFE unless we need to
    (assumption is that target OS version already checked)

Arguments:

    SpNum - service pack # that fix should be in
    QfeNum - QfeNum of fix

Return Value:

    ERROR_INVALID_PARAMETER if version not supported
    NO_ERROR if QFE installed
    other status if QFE might not be installed

--*/
{
    HKEY hKey;
    TCHAR KeyPath[MAX_PATH*2];
    LONG res;
    //
    // what about the SP level?
    //
    if(g_VerInfo.wServicePackMajor >= SpNum) {
        VerbosePrint(TEXT("- Skipped (SP >= %u)"),SpNum);
        return NO_ERROR;
    }
    if((g_VerInfo.dwMajorVersion == 5) && (g_VerInfo.dwMinorVersion == 0)) {
        //
        // check for QFE presence on Windows 2000
        //
        _sntprintf(KeyPath,ARRAY_SIZE(KeyPath),
                            TEXT("Software\\Microsoft\\Updates\\Windows 2000\\SP%u\\%s"),
                            SpNum,
                            QfeNum);
        res = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                            KeyPath,
                            0,
                            KEY_READ,
                            &hKey);
        if(res == NO_ERROR) {
            RegCloseKey(hKey);
        }
        return (DWORD)res;
    } else if((g_VerInfo.dwMajorVersion == 5) && (g_VerInfo.dwMinorVersion == 1)) {
            //
            // check for QFE presence on Windows XP
            //
            _sntprintf(KeyPath,ARRAY_SIZE(KeyPath),
                                TEXT("Software\\Microsoft\\Updates\\Windows XP\\SP%u\\%s"),
                                SpNum,
                                QfeNum);
            res = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                KeyPath,
                                0,
                                KEY_READ,
                                &hKey);
            if(res == NO_ERROR) {
                RegCloseKey(hKey);
            }
            return (DWORD)res;
    } else {
        return ERROR_INVALID_PARAMETER;
    }
}

DWORD
DoDriverQfe(
    IN     INFCONTEXT  *EntryLine,
    IN     LPCTSTR      PathName,
    IN OUT DWORD       *Flags
    )
/*++

Routine Description:

    queries and potentially installs QFE

Arguments:

    EntryLine - context for remaining information
    PathName  - name of exception pack INF (param 1)
    SubFlags  - flags passed in (param 2) sans type of install

    component entry consists of
    <path\name>,<flags>,<osver>,<os-sp>,<qfenum>
    filename is absolute directory, eg, %1%\foo.exe
    <flags> indicates what to do if qfe installed
    <osver> indicates os version QFE is for, eg, 5.0
    <os-sp> indicates service pack QFE is in, eg, 1
    <qfenum> indicates the qfe number as found in registry

Return Value:

    status, normally NO_ERROR
    if return value >= 0x80000000 then it's a HRESULT error

--*/
{
    TCHAR   QfeOs[64]; // expecting major.minor
    TCHAR   QfeNum[64];  // some descriptive name
    INT     QfeSp;
    INT     VerMaj,VerMin,VerBuild,VerQfe;
    TCHAR Buffer[MAX_PATH];
    TCHAR CmdLine[MAX_PATH*3];
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInfo;
    DWORD ExitCode;
    DWORD Status;
    HRESULT hrStatus;
    UINT uiRes;
    DWORD dwLen;
    TCHAR SrcPath[MAX_PATH];
    TCHAR NewSrcPath[MAX_PATH];
    LPTSTR SrcName;

    VerbosePrint(TEXT("- %s is a QFE"),PathName);

    if(!SetupGetStringField(EntryLine,COMPFIELD_QFEOS,QfeOs,ARRAY_SIZE(QfeOs),NULL)) {
        Status = GetLastError();
        DebugPrint(TEXT("- Fail: SetupGetStringField(3), Error: 0x%08x"),Status);
        return Status;
    }
    if(!SetupGetIntField(EntryLine,COMPFIELD_QFESP,&QfeSp)) {
        Status = GetLastError();
        DebugPrint(TEXT("- Fail: SetupGetIntField(4), Error: 0x%08x"),Status);
        return Status;
    }
    if(!SetupGetStringField(EntryLine,COMPFIELD_QFENUM,QfeNum,ARRAY_SIZE(QfeNum),NULL)) {
        Status = GetLastError();
        DebugPrint(TEXT("- Fail: SetupGetStringField(5), Error: 0x%08x"),Status);
        return Status;
    }
    //
    // see if QFE is targeted at this version?
    //
    hrStatus = VersionFromString(QfeOs,&VerMaj,&VerMin,&VerBuild,&VerQfe);
    if(!SUCCEEDED(hrStatus)) {
        return (DWORD)hrStatus;
    }
    if((hrStatus == S_FALSE) || (VerBuild != 0) || (VerQfe != 0)) {
        return ERROR_INVALID_PARAMETER;
    }
    if(CompareVersion(VerMaj,
                        VerMin,
                        0,
                        0,
                        g_VerInfo.dwMajorVersion,
                        g_VerInfo.dwMinorVersion,
                        0,
                        0) != 0) {
        VerbosePrint(TEXT("- Skipped (OS != %u.%u)"),VerMaj,VerMin);
        return NO_ERROR;
    }
    //
    // see if the Qfe needs to be installed on this OS
    //
    Status = CheckQfe(QfeSp,QfeNum);
    if(Status == ERROR_INVALID_PARAMETER) {
        //
        // invalid parameter because in invalid version was
        // specified
        //
        DebugPrint(TEXT("- Cannot install QFE's for %u.%u"),
                            g_VerInfo.dwMajorVersion,
                            g_VerInfo.dwMinorVersion);
        return Status;
    }
    //
    // ok, has the QFE already been installed?
    //
    if(Status == NO_ERROR) {
        return NO_ERROR;
    }

    //
    // we need to make sure component INF media is in
    // prompt for media if interactive and INF cannot be found
    //
    dwLen = GetFullPathName(PathName,MAX_PATH,SrcPath,&SrcName);
    if(dwLen >= MAX_PATH) {
        return ERROR_INSUFFICIENT_BUFFER;
    }
    if(SrcName == SrcPath) {
        //
        // shouldn't happen
        //
        return ERROR_INVALID_DATA;
    }
    *CharPrev(SrcPath,SrcName) = TEXT('\0');
    uiRes = SetupPromptForDisk(
                    NULL, // parent
                    NULL, // title
                    QfeNum, // disk name
                    SrcPath, // path to source
                    SrcName, // name of file
                    NULL,    // tag file
                    IDF_CHECKFIRST|IDF_NOCOMPRESSED|IDF_NOSKIP,
                    NewSrcPath,
                    ARRAY_SIZE(NewSrcPath),
                    NULL);

    switch(uiRes) {
        case DPROMPT_SUCCESS:
            break;
        case DPROMPT_CANCEL:
        case DPROMPT_SKIPFILE:
            return ERROR_FILE_NOT_FOUND;
        case DPROMPT_BUFFERTOOSMALL:
            return ERROR_INSUFFICIENT_BUFFER;
        case DPROMPT_OUTOFMEMORY:
            return ERROR_OUTOFMEMORY;
        default:
            //
            // shouldn't happen
            //
            return ERROR_INVALID_DATA;
    }

    hrStatus = ConcatPath(NewSrcPath,MAX_PATH,SrcName);
    if(!SUCCEEDED(hrStatus)) {
        return (DWORD)hrStatus;
    }

    // now build up command line
    //
    lstrcpy(CmdLine,NewSrcPath);
    lstrcat(CmdLine,TEXT(" -n -o -z -q"));

    ZeroMemory(&StartupInfo,sizeof(StartupInfo));
    StartupInfo.cb = sizeof(StartupInfo);
    ZeroMemory(&ProcessInfo,sizeof(ProcessInfo));

    //
    // kick off rundll32 process to install QFE
    //
    if(!CreateProcess(NewSrcPath,
                      CmdLine,
                      NULL,
                      NULL,
                      FALSE, // don't inherit handles
                      CREATE_NO_WINDOW,    // creation flags
                      NULL, // environment
                      NULL, // directory
                      &StartupInfo,
                      &ProcessInfo
                      )) {
        return GetLastError();
    }
    if(WaitForSingleObject(ProcessInfo.hProcess,INFINITE) == WAIT_OBJECT_0) {
        //
        // process terminated 'fine', retrieve status from shared data
        //
        if(GetExitCodeProcess(ProcessInfo.hProcess,&ExitCode)) {
            Status = (DWORD)ExitCode;
        } else {
            Status = GetLastError();
        }
    } else {
        //
        // failure
        //
        Status = ERROR_INVALID_PARAMETER;
    }
    CloseHandle(ProcessInfo.hThread);
    CloseHandle(ProcessInfo.hProcess);

    if(Status != NO_ERROR) {
        return Status;
    }
    if(CheckQfe(QfeSp,QfeNum)!=NO_ERROR) {
        //
        // sanity check failed
        //
        return E_UNEXPECTED;
    }

    //
    // if install was not skipped, we get S_OK, else S_FALSE
    //
#if 0
    if(hrStatus == S_OK) {
        *Flags |= FLAGS_INSTALLED;
    } else if(hrStatus == INST_S_REBOOT) {
    }
#endif
    *Flags |= FLAGS_INSTALLED|FLAGS_REBOOT;

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\msoobci\msoobci.c ===
/*++

Copyright (c) Microsoft Corporation. All Rights Reserved.

Module Name:

    msoobci.c

Abstract:

    Exception Pack installer helper DLL
    Can be used as a co-installer, or called via setup app, or RunDll32 stub

    This DLL is for internal distribution of exception packs to update
    OS components.

Author:

    Jamie Hunter (jamiehun) 2001-11-27

Revision History:

    Jamie Hunter (jamiehun) 2001-11-27

        Initial Version

--*/
#include "msoobcip.h"

//
// globals
//
HANDLE          g_DllHandle;
OSVERSIONINFOEX g_VerInfo;


VOID
DebugPrint(
    IN PCTSTR format,
    IN ...                         OPTIONAL
    )
/*++

Routine Description:

    Send a formatted string to the debugger.

Arguments:

    format - standard printf format string.

Return Value:

    NONE.

--*/
{
    TCHAR buf[1200];    // wvsprintf maxes at 1024.
    va_list arglist;

    va_start(arglist, format);
    lstrcpy(buf,TEXT("MSOOBCI: "));
    wvsprintf(buf+lstrlen(buf), format, arglist);
    lstrcat(buf,TEXT("\n"));
    OutputDebugString(buf);
}

//
// Called by CRT when _DllMainCRTStartup is the DLL entry point
//
BOOL
WINAPI
DllMain(
    IN HANDLE DllHandle,
    IN DWORD  Reason,
    IN LPVOID Reserved
    )
{
    switch(Reason) {
        case DLL_PROCESS_ATTACH:
            //
            // global initialization
            // - make a note of DllHandle
            // - make a note of OS version
            //
            g_DllHandle = DllHandle;
            ZeroMemory(&g_VerInfo,sizeof(g_VerInfo));
            g_VerInfo.dwOSVersionInfoSize = sizeof(g_VerInfo);
            if(!GetVersionEx((LPOSVERSIONINFO)&g_VerInfo)) {
                g_VerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
                if(!GetVersionEx((LPOSVERSIONINFO)&g_VerInfo)) {
                    return FALSE;
                }
            }
            break;
    }

    return TRUE;
}

HRESULT
GuidFromString(
    IN  LPCTSTR GuidString,
    OUT GUID   *GuidBinary
    )
/*++

Routine Description:

    Convert a GUID from String form to Binary form

Arguments:

    GuidString - string form
    GuidBinary - filled with binary form

Return Value:

    S_OK or E_INVALIDARG

--*/
{
    HRESULT res;
    TCHAR String[64];
    lstrcpyn(String,GuidString,ARRAY_SIZE(String));
    res = IIDFromString(String,GuidBinary);
    return res;
}

HRESULT
StringFromGuid(
    IN  GUID   *GuidBinary,
    OUT LPTSTR GuidString,
    IN  DWORD  BufferSize
    )
/*++

Routine Description:

    Convert a GUID from Binary form to String form

Arguments:

    GuidBinary - binary form
    GuidString - filled with string form
    BufferSize - length of GuidString buffer

Return Value:

    S_OK or E_INVALIDARG

--*/
{
    int res;
    res = StringFromGUID2(GuidBinary,GuidString,(int)BufferSize);
    if(res == 0) {
        return E_INVALIDARG;
    }
    return S_OK;
}


HRESULT
VersionFromString(
    IN  LPCTSTR VerString,
    OUT INT * VerMajor,
    OUT INT * VerMinor,
    OUT INT * VerBuild,
    OUT INT * VerQFE
    )
/*++

Routine Description:

    Convert a high.low string to VerHigh and VerLow

Arguments:

    VerString - string form
    VerMajor/VerMinor/VerBuild/VerQFE - components of version

Return Value:

    S_OK or E_INVALIDARG

--*/
{
    HRESULT res;
    LPTSTR VerPtr;
    long val;

    *VerMajor = *VerMinor = *VerBuild = *VerQFE = 0;
    //
    // skip leading white space
    //
    while((VerString[0] == TEXT(' ')) ||
          (VerString[0] == TEXT('\t'))) {
        VerString++;
    }
    if(VerString[0] == TEXT('\0')) {
        //
        // wildcard
        //
        return S_FALSE;
    }
    //
    // get version major part (decimal)
    //
    if(!((VerString[0]>= TEXT('0')) &&
         (VerString[0]<= TEXT('9')))) {
        return E_INVALIDARG;
    }
    val = _tcstol(VerString,&VerPtr,10);
    if((VerPtr == VerString) ||
       ((VerPtr-VerString)>5) ||
       (val>65535) ||
       (val<0)) {
        return E_INVALIDARG;
    }
    *VerMajor = (WORD)val;

    //
    // followed by .decimal
    // (version minor part)
    //
    if((VerPtr[0] != TEXT('.')) ||
       !((VerPtr[1]>= TEXT('0')) &&
         (VerPtr[1]<= TEXT('9')))) {
        return E_INVALIDARG;
    }
    VerString = VerPtr+1;
    val = _tcstol(VerString,&VerPtr,10);
    if((VerPtr == VerString) ||
       ((VerPtr-VerString)>5) ||
       (val>65535) ||
       (val<0)) {
        return E_INVALIDARG;
    }
    *VerMinor = (WORD)val;

    //
    // followed by .decimal
    // (version build, optional)
    //
    if(VerPtr[0] == TEXT('.')) {
        if(!((VerPtr[1]>= TEXT('0')) &&
             (VerPtr[1]<= TEXT('9')))) {
            return E_INVALIDARG;
        }
        VerString = VerPtr+1;
        val = _tcstol(VerString,&VerPtr,10);
        if((VerPtr == VerString) ||
           ((VerPtr-VerString)>5) ||
           (val>65535) ||
           (val<0)) {
            return E_INVALIDARG;
        }
        *VerBuild = (WORD)val;
    }

    //
    // followed by .decimal
    // (version qfe, optional)
    //
    if(VerPtr[0] == TEXT('.')) {
        if(!((VerPtr[1]>= TEXT('0')) &&
             (VerPtr[1]<= TEXT('9')))) {
            return E_INVALIDARG;
        }
        VerString = VerPtr+1;
        val = _tcstol(VerString,&VerPtr,10);
        if((VerPtr == VerString) ||
           ((VerPtr-VerString)>5) ||
           (val>65535) ||
           (val<0)) {
            return E_INVALIDARG;
        }
        *VerQFE = (WORD)val;

    }

    //
    // trailing white space
    //
    VerString = VerPtr;
    while((VerString[0] == TEXT(' ')) ||
          (VerString[0] == TEXT('\t'))) {
        VerString++;
    }
    //
    // not well formed?
    //
    if(VerString[0] != TEXT('\0')) {
        return E_INVALIDARG;
    }
    return S_OK;
}

int
CompareCompVersion(
    IN INT VerMajor,
    IN INT VerMinor,
    IN INT VerBuild,
    IN INT VerQFE,
    IN PSETUP_OS_COMPONENT_DATA SetupOsComponentData
    )
/*++

Routine Description:

    Compare a version against component information

Arguments:

    VerMajor/VerMinor/VerBuild/VerQFE - version to check against
        (can have wildcards)

    SetupOsComponentData - component version

Return Value:

    -1, version not as good as component
    0, version equiv to component
    1, version better than component
--*/
{
    return CompareVersion(VerMajor,
                            VerMinor,
                            VerBuild,
                            VerQFE,
                            SetupOsComponentData->VersionMajor,
                            SetupOsComponentData->VersionMinor,
                            SetupOsComponentData->BuildNumber,
                            SetupOsComponentData->QFENumber
                            );
}

int
CompareVersion(
    IN INT VerMajor,
    IN INT VerMinor,
    IN INT VerBuild,
    IN INT VerQFE,
    IN INT OtherMajor,
    IN INT OtherMinor,
    IN INT OtherBuild,
    IN INT OtherQFE
    )
/*++

Routine Description:

    Compare a version against component information

Arguments:

    VerMajor/VerMinor/VerBuild/VerQFE - version to check
        (can have wildcards)

    OtherMajor/OtherMinor/OtherBuid/OtherQFE - version to check against

Return Value:

    -1, version not as good as component
    0, version equiv to component
    1, version better than component
--*/
{
    if((VerMajor==-1)||(OtherMajor==-1)) {
        return 0;
    }
    if(VerMajor<OtherMajor) {
        return -1;
    }
    if(VerMajor>OtherMajor) {
        return 1;
    }
    if((VerMinor==-1)||(OtherMinor==-1)) {
        return 0;
    }
    if(VerMinor<OtherMinor) {
        return -1;
    }
    if(VerMinor>OtherMinor) {
        return 1;
    }
    if((VerBuild==-1)||(OtherBuild==-1)) {
        return 0;
    }
    if(VerBuild<OtherBuild) {
        return -1;
    }
    if(VerBuild>OtherBuild) {
        return 1;
    }
    if((VerQFE==-1)||(OtherQFE==-1)) {
        return 0;
    }
    if(VerQFE<OtherQFE) {
        return -1;
    }
    if(VerQFE>OtherQFE) {
        return 1;
    }
    return 0;
}

HRESULT
MakeSurePathExists(
    IN LPTSTR Path
    )
/*++

Routine Description:

    Make sure named directory exists

Arguments:

    Path - path to directory to create, must be a writable buffer

Return Value:

    status as hresult
    S_OK    - path created
    S_FALSE - path already exists

--*/
{
    DWORD dwResult;
    DWORD Status;
    HRESULT hrStatus;

    dwResult = GetFileAttributes(Path);
    if((dwResult != (DWORD)(-1)) && ((dwResult & FILE_ATTRIBUTE_DIRECTORY)!=0)) {
        //
        // directory exists
        //
        return S_FALSE;
    }
    hrStatus = MakeSureParentPathExists(Path);
    if(!SUCCEEDED(hrStatus)) {
        return hrStatus;
    }
    if(!CreateDirectory(Path,NULL)) {
        Status = GetLastError();
        return HRESULT_FROM_WIN32(Status);
    }
    return S_OK;
}

HRESULT
MakeSureParentPathExists(
    IN LPTSTR Path
    )
/*++

Routine Description:

    Make sure parent of named directory/file exists

Arguments:

    Path - path to directory to create, must be a writable buffer

Return Value:

    status as hresult
    S_OK    - path created
    S_FALSE - path already exists

--*/
{
    HRESULT hrStatus;
    LPTSTR Split;
    LPTSTR Base;
    TCHAR Save;

    //
    // make sure we don't try to create the root
    //
    if((_istalpha(Path[0]) && (Path[1]==TEXT(':')))
       && ((Path[2] == TEXT('\\'))  || (Path[2] == TEXT('/')))
       && (Path[3] != TEXT('\0'))) {
        Base = Path+3;
    } else {
        //
        // at this time, this code expects X:\... format
        //
        return E_FAIL;
    }
    Split = GetSplit(Base);
    if(Split == Base) {
        //
        // strange, should have succeeded
        //
        return E_FAIL;
    }
    Save = *Split;
    *Split = TEXT('\0');
    hrStatus = MakeSurePathExists(Path);
    *Split = Save;
    return hrStatus;
}

LPTSTR GetBaseName(
    IN LPCTSTR FileName
    )
/*++

Routine Description:

    Given a full path, return basename portion

Arguments:

    FileName - full or partial path

Return Value:

    status as hresult

--*/
{
    LPTSTR BaseName = (LPTSTR)FileName;

    for(; *FileName; FileName = CharNext(FileName)) {
        switch (*FileName) {
            case TEXT(':'):
            case TEXT('/'):
            case TEXT('\\'):
                BaseName = (LPTSTR)CharNext(FileName);
                break;
        }
    }
    return BaseName;
}

LPTSTR GetSplit(
    IN LPCTSTR FileName
    )
/*++

Routine Description:

    Split path at last '/' or '\\' (similar to GetBaseName)

Arguments:

    FileName - full or partial path

Return Value:

    status as hresult

--*/
{
    LPTSTR SplitPos = (LPTSTR)FileName;

    for(SplitPos; *FileName; FileName = CharNext(FileName)) {
        switch (*FileName) {
            case TEXT('/'):
            case TEXT('\\'):
                SplitPos = (LPTSTR)FileName;
                break;
        }
    }
    return SplitPos;
}

BOOL
WINAPI
IsInteractiveWindowStation(
    )
/*++

Routine Description:

    Determine if we are running on an interactive station vs non-interactive
    // station (i.e., service)

Arguments:

    none

Return Value:

    True if interactive

--*/
{
    HWINSTA winsta;
    USEROBJECTFLAGS flags;
    BOOL interactive = TRUE; // true unless we determine otherwise
    DWORD lenNeeded;

    winsta = GetProcessWindowStation();
    if(!winsta) {
        return interactive;
    }
    if(GetUserObjectInformation(winsta,UOI_FLAGS,&flags,sizeof(flags),&lenNeeded)) {
        interactive = (flags.dwFlags & WSF_VISIBLE) ? TRUE : FALSE;
    }
    //
    // don't call CLoseWindowStation
    //
    return interactive;
}

BOOL
WINAPI
IsUserAdmin(
    VOID
    )

/*++

Routine Description:

    This routine returns TRUE if the caller's process has admin privs

    Caller is NOT expected to be impersonating anyone and IS
    expected to be able to open their own process and process
    token.

    Though we could use CheckTokenMembership
    this function has to work on NT4

Arguments:

    None.

Return Value:

    TRUE - Caller has Administrator privs.

    FALSE - Caller does not have Administrator privs.

--*/

{
    BOOL fAdmin = FALSE;
    HANDLE  hToken = NULL;
    DWORD dwStatus;
    DWORD dwACLSize;
    DWORD cbps = sizeof(PRIVILEGE_SET);
    PACL pACL = NULL;
    PSID psidAdmin = NULL;
    PSECURITY_DESCRIPTOR psdAdmin = NULL;
    PRIVILEGE_SET ps;
    GENERIC_MAPPING gm;
    SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
    BOOL Impersonated = FALSE;

    //
    // Prepare some memory
    //
    ZeroMemory(&ps, sizeof(ps));
    ZeroMemory(&gm, sizeof(gm));

    //
    // Get the Administrators SID
    //
    if (AllocateAndInitializeSid(&sia, 2,
                        SECURITY_BUILTIN_DOMAIN_RID,
                        DOMAIN_ALIAS_RID_ADMINS,
                        0, 0, 0, 0, 0, 0, &psidAdmin) ) {
        //
        // Get the Asministrators Security Descriptor (SD)
        //
        psdAdmin = malloc(SECURITY_DESCRIPTOR_MIN_LENGTH);
        if (psdAdmin) {
            if(InitializeSecurityDescriptor(psdAdmin,SECURITY_DESCRIPTOR_REVISION)) {
                //
                // Compute size needed for the ACL then allocate the
                // memory for it
                //
                dwACLSize = sizeof(ACCESS_ALLOWED_ACE) + 8 +
                            GetLengthSid(psidAdmin) - sizeof(DWORD);
                pACL = (PACL)malloc(dwACLSize);
                if(pACL) {
                    //
                    // Initialize the new ACL
                    //
                    if(InitializeAcl(pACL, dwACLSize, ACL_REVISION2)) {
                        //
                        // Add the access-allowed ACE to the DACL
                        //
                        if(AddAccessAllowedAce(pACL,ACL_REVISION2,
                                             (ACCESS_READ | ACCESS_WRITE),psidAdmin)) {
                            //
                            // Set our DACL to the Administrator's SD
                            //
                            if (SetSecurityDescriptorDacl(psdAdmin, TRUE, pACL, FALSE)) {
                                //
                                // AccessCheck is downright picky about what is in the SD,
                                // so set the group and owner
                                //
                                SetSecurityDescriptorGroup(psdAdmin,psidAdmin,FALSE);
                                SetSecurityDescriptorOwner(psdAdmin,psidAdmin,FALSE);

                                //
                                // Initialize GenericMapping structure even though we
                                // won't be using generic rights
                                //
                                gm.GenericRead = ACCESS_READ;
                                gm.GenericWrite = ACCESS_WRITE;
                                gm.GenericExecute = 0;
                                gm.GenericAll = ACCESS_READ | ACCESS_WRITE;

                                //
                                // AccessCheck requires an impersonation token, so lets
                                // indulge it
                                //
                                Impersonated = ImpersonateSelf(SecurityImpersonation);

                                if (OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, FALSE, &hToken)) {

                                    if (!AccessCheck(psdAdmin, hToken, ACCESS_READ, &gm,
                                                    &ps,&cbps,&dwStatus,&fAdmin)) {

                                        fAdmin = FALSE;
                                    }
                                    CloseHandle(hToken);
                                }
                            }
                        }
                    }
                    free(pACL);
                }
            }
            free(psdAdmin);
        }
        FreeSid(psidAdmin);
    }
    if(Impersonated) {
        RevertToSelf();
    }

    return(fAdmin);
}

HRESULT
ConcatPath(
    IN LPTSTR Path,
    IN DWORD  Len,
    IN LPCTSTR NewPart
    )
/*++

Routine Description:

    Concat NewPart onto Path

Arguments:

    Path - existing path
    Len  - length of buffer
    NewPart - part to append

Return Value:

    status as hresult

--*/
{
    LPTSTR end = Path+lstrlen(Path);
    TCHAR c;
    BOOL add_slash = FALSE;
    BOOL pre_slash = FALSE;
    c = *CharPrev(Path,end);
    if((c!= TEXT('\\')) && (c!= TEXT('/'))) {
        add_slash = TRUE;
    }
    if(NewPart) {
        c = NewPart[0];
        if((c== TEXT('\\')) || (c== TEXT('/'))) {
            if(add_slash) {
                add_slash = FALSE;
            } else {
                NewPart = CharNext(NewPart);
            }
        }
    }
    if((DWORD)((end-Path)+lstrlen(NewPart)+(add_slash?1:0)) >= Len) {
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
    }
    if(add_slash) {
        end[0] = TEXT('\\');
        end++;
    }
    if(NewPart) {
        lstrcpy(end,NewPart);
    } else {
        end[0] = TEXT('\0');
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\msoobci\msoobci.h ===
/*++

Copyright (c) Microsoft Corporation. All Rights Reserved.

Module Name:

    msoobci.h

Abstract:

    Exception Pack installer helper DLL

    Public API header

Author:

    Jamie Hunter (jamiehun) 2001-11-27

Revision History:

    Jamie Hunter (jamiehun) 2001-11-27

        Initial Version

--*/

#ifndef __MSOOBCI_H__
#define __MSOOBCI_H__

//
// DriverInstallComponents is a standard co-installer entrypoint
// return status is WinError form, as expected by SetupAPI
//

DWORD
CALLBACK
DriverInstallComponents (
    IN     DI_FUNCTION               InstallFunction,
    IN     HDEVINFO                  DeviceInfoSet,
    IN     PSP_DEVINFO_DATA          DeviceInfoData,
    IN OUT PCOINSTALLER_CONTEXT_DATA Context
    );

//
// InstallComponent is a generic entry point
// return status is HRESULT form, providing success codes
//
// CompGuid - if NULL, use GUID specified in INF (ComponentId)
//            else verify against GUID specified in INF
// VerMajor/VerMinor/VerBuild/VerQFE
//          - if -1, use version specified in INF (ComponentVersion)
//            else use this version and verify against version if specified in INF
// Name
//          - if NULL, use name specified in INF (ComponentName)
//            else use this component name.
//

#define INST_S_REBOOT    ((HRESULT)(0x20000100)) // 'success' code that indicates reboot required
#define INST_S_REBOOTING ((HRESULT)(0x20000101)) // indicates reboot in progress

#define COMP_FLAGS_NOINSTALL      0x00000001    // place in store, don't install
#define COMP_FLAGS_NOUI           0x00000002    // don't show any UI
#define COMP_FLAGS_NOPROMPTREBOOT 0x00000004    // reboot if needed (no prompt)
#define COMP_FLAGS_PROMPTREBOOT   0x00000008    // prompt for reboot if needed
#define COMP_FLAGS_NEEDSREBOOT    0x00000010    // assume reboot needed
#define COMP_FLAGS_FORCE          0x00000020    // don't do version check

HRESULT
WINAPI
InstallComponentA(
    IN LPCSTR InfPath,
    IN DWORD   Flags,
    IN const GUID * CompGuid,  OPTIONAL
    IN INT VerMajor,           OPTIONAL
    IN INT VerMinor,           OPTIONAL
    IN INT VerBuild,           OPTIONAL
    IN INT VerQFE,             OPTIONAL
    IN LPCSTR Name             OPTIONAL
    );

HRESULT
WINAPI
InstallComponentW(
    IN LPCWSTR InfPath,
    IN DWORD   Flags,
    IN const GUID * CompGuid,  OPTIONAL
    IN INT VerMajor,           OPTIONAL
    IN INT VerMinor,           OPTIONAL
    IN INT VerBuild,           OPTIONAL
    IN INT VerQFE,             OPTIONAL
    IN LPCWSTR Name            OPTIONAL
    );

#ifdef UNICODE
#define InstallComponent InstallComponentW
#else
#define InstallComponent InstallComponentA
#endif


//
// DoInstall is a RunDll32 entrypoint.
// CommandLine = "InfPath;Flags;GUID;Version;Name"
// where version has format High.Low.Build.QFE
//
// calls InstallComponent, but drops return status
//

VOID
WINAPI
DoInstallA(
    IN HWND      Window,
    IN HINSTANCE ModuleHandle,
    IN PCSTR     CommandLine,
    IN INT       ShowCommand
    );

VOID
WINAPI
DoInstallW(
    IN HWND      Window,
    IN HINSTANCE ModuleHandle,
    IN PCWSTR    CommandLine,
    IN INT       ShowCommand
    );

#ifdef UNICODE
#define DoInstall DoInstallW
#else
#define DoInstall DoInstallA
#endif

//
// lower-level install API's
// install from specified section of specified INF
// if SectionName not specified, install from (potentially decorated)
// "DefaultInstall"
//

HRESULT
WINAPI
InstallInfSectionA(
    IN LPCSTR  InfPath,
    IN LPCSTR  SectionName, OPTIONAL
    IN DWORD   Flags
    );

HRESULT
WINAPI
InstallInfSectionW(
    IN LPCWSTR InfPath,
    IN LPCWSTR SectionName, OPTIONAL
    IN DWORD   Flags
    );

#ifdef UNICODE
#define InstallInfSection InstallInfSectionW
#else
#define InstallInfSection InstallInfSectionA
#endif

//
// check to see if current user has admin rights
// Caller is NOT expected to be impersonating anyone and IS
// expected to be able to open their own process and process
// token.
//
BOOL
WINAPI
IsUserAdmin(
    VOID
    );

//
// see if process is running in an interactive window station
// (ie, can show dialogs and get input off user)
//
BOOL
WINAPI
IsInteractiveWindowStation(
    VOID
    );




#endif // __MSOOBCI_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\msoobci\msoobcip.h ===
/*++

Copyright (c) Microsoft Corporation. All Rights Reserved.

Module Name:

    msoobcip.h

Abstract:

    Exception Pack installer helper DLL
    Can be used as a co-installer, or called via setup app, or RunDll32 stub

    This DLL is for internal distribution of exception packs to update
    OS components.

Author:

    Jamie Hunter (jamiehun) 2001-11-27

Revision History:

    Jamie Hunter (jamiehun) 2001-11-27

        Initial Version

--*/
#define _SETUPAPI_VER 0x0500
#include <windows.h>
#include <setupapi.h>
#include <cfgmgr32.h>
#include <infstr.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <malloc.h>
#include <objbase.h>
#include <lm.h>
#include <excppkg.h>
#include <msoobci.h>


//
// Keywords
//
#define KEY_REBOOT                  TEXT("Reboot")
#define KEY_DOTSERVICES             TEXT(".Services")
#define KEY_DOTPRECOPY              TEXT(".Precopy")
#define KEY_COMPONENTID             TEXT("ComponentID")
#define KEY_DEFAULTINSTALL          TEXT("DefaultInstall")
#define KEY_COMPONENTS              TEXT("Components")

#define CMD_SEP         TEXT(';')    // character used for DoInstall
#define DESC_SIZE       (64)         // size of exception pack description

//
// common
//
#define COMPFIELD_NAME  (1)
#define COMPFIELD_FLAGS (2)
//
// expack
//
// <path\name>,<flags>,<comp>,<ver>,<desc>,<osver>-<osver>
//
#define COMPFIELD_COMP  (3)
#define COMPFIELD_VER   (4)
#define COMPFIELD_DESC  (5)
#define COMPFIELD_OSVER (6)
//
// qfe
//
// <path\name>,<flags>,<osver>,<os-sp>,<qfenum>
//
#define COMPFIELD_QFEOS  (3)
#define COMPFIELD_QFESP  (4)
#define COMPFIELD_QFENUM (5)


#define FLAGS_METHOD    0xffff0000
#define FLAGS_EXPACK    0x00010000   // method = exception pack
#define FLAGS_QFE       0x00020000   // method = QFE
#define FLAGS_REINSTALL 0x00000001   // indicates need to reinstall
#define FLAGS_REBOOT    0x00000002   // set if reboot required
#define FLAGS_INSTALLED 0x80000000   // (not user) set if a component installed


#define POSTFLAGS_REINSTALL 0x00000001 // postprocessing - set problem to reinstall

#define ARRAY_SIZE(x) (sizeof(x)/sizeof((x)[0]))

extern HANDLE g_DllHandle;
extern OSVERSIONINFOEX g_VerInfo;

VOID
DebugPrint(
    PCTSTR format,
    ...                                 OPTIONAL
    );

#if DBG
//
// real DebugPrint
//
#define VerbosePrint DebugPrint

#else
//
// don't want VerbosePrint
// below define has intentional side effect(s)
// VerbosePrint(TEXT("text"),foo) -> 1?0:(TEXT("text"),foo) -> 0 -> nothing
//
#define VerbosePrint /* (...) */    1?0: /* (...) */

#endif // DBG


DWORD
DoDriverInstallComponents (
    IN     HDEVINFO          DeviceInfoSet,
    IN     PSP_DEVINFO_DATA  DeviceInfoData,
    IN OUT PCOINSTALLER_CONTEXT_DATA Context
    );

DWORD
DoDriverInstallComponentsPostProcessing (
    IN     HDEVINFO          DeviceInfoSet,
    IN     PSP_DEVINFO_DATA  DeviceInfoData,
    IN OUT PCOINSTALLER_CONTEXT_DATA Context
    );

DWORD
DoDriverComponentsSection(
    IN     HINF    InfFile,
    IN     LPCTSTR CompSectionName,
    IN OUT DWORD  *AndFlags,
    IN OUT DWORD  *OrFlags
    );

DWORD
DoDriverExPack(
    IN     INFCONTEXT  *EntryLine,
    IN     LPCTSTR      PathName,
    IN OUT DWORD       *Flags
    );

DWORD
DoDriverQfe(
    IN     INFCONTEXT  *EntryLine,
    IN     LPCTSTR      PathName,
    IN OUT DWORD       *Flags
    );

HRESULT
StringFromGuid(
    IN  GUID   *GuidBinary,
    OUT LPTSTR GuidString,
    IN  DWORD  BufferSize
    );

HRESULT
GuidFromString(
    IN  LPCTSTR GuidString,
    OUT GUID   *GuidBinary
    );

HRESULT
VersionFromString(
    IN  LPCTSTR VerString,
    OUT INT * VerMajor,
    OUT INT * VerMinor,
    OUT INT * VerBuild,
    OUT INT * VerQFE
    );

int
CompareVersion(
    IN INT VerMajor,
    IN INT VerMinor,
    IN INT VerBuild,
    IN INT VerQFE,
    IN INT OtherMajor,
    IN INT OtherMinor,
    IN INT OtherBuild,
    IN INT OtherQFE
    );

int
CompareCompVersion(
    IN INT VerMajor,
    IN INT VerMinor,
    IN INT VerBuild,
    IN INT VerQFE,
    IN PSETUP_OS_COMPONENT_DATA SetupOsComponentData
    );

BOOL
WINAPI
QueryRegisteredOsComponent(
    IN  LPGUID ComponentGuid,
    OUT PSETUP_OS_COMPONENT_DATA SetupOsComponentData,
    OUT PSETUP_OS_EXCEPTION_DATA SetupOsExceptionData
    );

BOOL
WINAPI
RegisterOsComponent (
    IN const PSETUP_OS_COMPONENT_DATA ComponentData,
    IN const PSETUP_OS_EXCEPTION_DATA ExceptionData
    );

BOOL
WINAPI
UnRegisterOsComponent (
    IN const LPGUID ComponentGuid
    );


UINT
GetRealWindowsDirectory(
    LPTSTR lpBuffer,  // buffer to receive directory name
    UINT uSize        // size of name buffer
    );

BOOL QueryInfOriginalFileInformation(
  PSP_INF_INFORMATION InfInformation,
  UINT InfIndex,
  PSP_ALTPLATFORM_INFO AlternatePlatformInfo,
  PSP_ORIGINAL_FILE_INFO OriginalFileInfo
);

BOOL CopyOEMInf(
  PCTSTR SourceInfFileName,
  PCTSTR OEMSourceMediaLocation,
  DWORD OEMSourceMediaType,
  DWORD CopyStyle,
  PTSTR DestinationInfFileName,
  DWORD DestinationInfFileNameSize,
  PDWORD RequiredSize,
  PTSTR *DestinationInfFileNameComponent
);


HRESULT
MakeSureParentPathExists(
    IN LPTSTR Path
    );

HRESULT
MakeSurePathExists(
    IN LPTSTR Path
    );

LPTSTR GetSplit(
    IN LPCTSTR FileName
    );

LPTSTR GetBaseName(
    IN LPCTSTR FileName
    );

HRESULT
ConcatPath(
    IN LPTSTR Path,
    IN DWORD  Len,
    IN LPCTSTR NewPart
    );

HRESULT
InstallExceptionPackFromInf(
    IN LPCTSTR InfPath,
    IN LPCTSTR Media,
    IN LPCTSTR Store,
    IN DWORD   Flags
    );

HRESULT
ProxyInstallExceptionPackFromInf(
    IN LPCTSTR InfPath,
    IN LPCTSTR Media,
    IN LPCTSTR Store,
    IN DWORD   Flags
    );

CONFIGRET
Set_DevNode_Problem_Ex(
    IN DEVINST   dnDevInst,
    IN ULONG     ulProblem,
    IN  ULONG    ulFlags,
    IN  HMACHINE hMachine
    );

BOOL
GetDeviceInfoListDetail(
    IN HDEVINFO  DeviceInfoSet,
    OUT PSP_DEVINFO_LIST_DETAIL_DATA  DeviceInfoSetDetailData
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ntcab\inc\ntcabapi.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    ntcabapi.h

Abstract:

    This is the public header file for
    the nt cab file api.

Author:

    Wesley Witt (wesw) 29-Sept-1998

Revision History:

--*/

typedef struct _NTCAB_ENUM_DATA {
    DWORD FileAttributes;
    DWORD FileSize;
    DWORD CompressedFileSize;
    FILETIME CreationTime;
    FILETIME LastAccessTime;
    FILETIME LastWriteTime;
    PCWSTR FileName;
} NTCAB_ENUM_DATA, *PNTCAB_ENUM_DATA;


typedef BOOL (CALLBACK *PNTCABFILEENUM)(const PNTCAB_ENUM_DATA EnumData,ULONG_PTR Context);


PVOID
NtCabInitialize(
    void
    );

BOOL
NtCabClose(
    IN PVOID hCab
    );

BOOL
NtCabCreateNewCabFile(
    IN PVOID hCab,
    IN PCWSTR CabFileName
    );

BOOL
NtCabCompressOneFile(
    IN PVOID hCab,
    IN PCWSTR FileName
    );

BOOL
NtCabReplaceOneFile(
    IN PVOID hCab,
    IN PCWSTR FileName
    );

BOOL
NtCabExtractOneFile(
    IN PVOID hCab,
    IN PCWSTR FileName,
    IN PCWSTR OutputFileName
    );

BOOL
NtCabOpenCabFile(
    IN PVOID hCab,
    IN PCWSTR CabFileName
    );

BOOL
NtCabEnumerateFiles(
    IN PVOID hCab,
    IN PNTCABFILEENUM UserEnumFunc,
    IN ULONG_PTR Context
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\msoobci\proxyinst.c ===
/*++

Copyright (c) Microsoft Corporation. All Rights Reserved.

Module Name:

    proxyinst.c

Abstract:

    Exception Pack installer helper DLL
    Can be used as a co-installer, or called via setup app, or RunDll32 stub

    This DLL is for internal distribution of exception packs to update
    OS components.

Author:

    Jamie Hunter (jamiehun) 2001-11-27

Revision History:

    Jamie Hunter (jamiehun) 2001-11-27

        Initial Version

--*/
#include "msoobcip.h"

typedef struct _PROXY_DATA {
    TCHAR InfPath[MAX_PATH];
    TCHAR Media[MAX_PATH];
    TCHAR Store[MAX_PATH];
    DWORD Flags;
    HRESULT hrStatus;
} PROXY_DATA, * PPROXY_DATA;


HRESULT
ProxyInstallExceptionPackFromInf(
    IN LPCTSTR InfPath,
    IN LPCTSTR Media,
    IN LPCTSTR Store,
    IN DWORD   Flags
    )
/*++

Routine Description:

    Kicks off another process, and calls RemoteInstallExceptionPackFromInf in
    remote process.
    (Bug workaround)
    Otherwise as InstallExceptionPackFromInf

Arguments:

    InfPath - name of Inf in Media location
    Media   - InfPath less InfName
    Store   - expack store
    Flags   - various flags

Return Value:

    status as hresult

--*/
{
    HANDLE hMapping = NULL;
    DWORD Status;
    HRESULT hrStatus;
    PPROXY_DATA pData = NULL;
    TCHAR ExecName[MAX_PATH];
    TCHAR Buffer[MAX_PATH];
    TCHAR CmdLine[MAX_PATH*3];
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInfo;
    SECURITY_ATTRIBUTES Security;
    UINT uiRes;
    //
    // create a mapped region of shared data
    //

    ZeroMemory(&Security,sizeof(Security));
    Security.nLength = sizeof(Security);
    Security.lpSecurityDescriptor = NULL; // default
    Security.bInheritHandle = TRUE;

    hMapping = CreateFileMapping(INVALID_HANDLE_VALUE,
                                 &Security,
                                 PAGE_READWRITE|SEC_COMMIT,
                                 0,
                                 sizeof(PROXY_DATA),
                                 NULL);
    if(hMapping == NULL) {
        Status = GetLastError();
        return HRESULT_FROM_WIN32(Status);
    }

    pData = MapViewOfFile(
                        hMapping,
                        FILE_MAP_ALL_ACCESS,
                        0,
                        0,
                        sizeof(PROXY_DATA)
                        );

    if(!pData) {
        Status = GetLastError();
        hrStatus = HRESULT_FROM_WIN32(Status);
        goto final;
    }
    ZeroMemory(pData,sizeof(PROXY_DATA));
    lstrcpyn(pData->InfPath,InfPath,MAX_PATH);
    lstrcpyn(pData->Media,Media,MAX_PATH);
    lstrcpyn(pData->Store,Store,MAX_PATH);
    pData->Flags = Flags;
    pData->hrStatus = E_UNEXPECTED;

    //
    // invoke the remote function
    //
    uiRes = GetSystemDirectory(ExecName,MAX_PATH);
    if(uiRes>=MAX_PATH) {
        hrStatus = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto final;
    }
    ConcatPath(ExecName,MAX_PATH,TEXT("rundll32.exe"));

    uiRes = GetModuleFileName(g_DllHandle,CmdLine,MAX_PATH);
    if(uiRes>=MAX_PATH) {
        hrStatus = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto final;
    }
    //
    // convert this to short name to ensure no spaces in path
    // (hacky)
    //
    uiRes = GetShortPathName(CmdLine,Buffer,MAX_PATH);
    if(uiRes>=MAX_PATH) {
        hrStatus = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto final;
    }
    //
    // now build up command line
    //
    lstrcpy(CmdLine,ExecName);
    lstrcat(CmdLine,TEXT(" "));
    lstrcat(CmdLine,Buffer);
    _stprintf(Buffer,TEXT(",ProxyRemoteInstall 0x%08x"),(ULONG_PTR)hMapping);
    lstrcat(CmdLine,Buffer);

    ZeroMemory(&StartupInfo,sizeof(StartupInfo));
    StartupInfo.cb = sizeof(StartupInfo);
    ZeroMemory(&ProcessInfo,sizeof(ProcessInfo));

    //
    // kick off rundll32 process to run our ProxyRemoteInstall entrypoint
    //
    if(!CreateProcess(ExecName,
                      CmdLine,
                      NULL,
                      NULL,
                      TRUE, // inherit handles
                      CREATE_NO_WINDOW,    // creation flags
                      NULL, // environment
                      NULL, // directory
                      &StartupInfo,
                      &ProcessInfo
                      )) {
        Status = GetLastError();
        hrStatus = HRESULT_FROM_WIN32(Status);
        goto final;
    }
    if(WaitForSingleObject(ProcessInfo.hProcess,INFINITE) == WAIT_OBJECT_0) {
        //
        // process terminated 'fine', retrieve status from shared data
        //
        hrStatus = pData->hrStatus;
    } else {
        //
        // failure
        //
        hrStatus = E_UNEXPECTED;
    }
    CloseHandle(ProcessInfo.hThread);
    CloseHandle(ProcessInfo.hProcess);

final:
    if(pData) {
        UnmapViewOfFile(pData);
    }
    if(hMapping) {
        CloseHandle(hMapping);
    }
    return hrStatus;
}


VOID
ProxyRemoteInstallHandle(
    IN HANDLE    hShared
    )
/*++

Routine Description:

    Given a handle to a memory mapped file
    marshell all the parameters to invoke InstallExceptionPackFromInf
    and marshell result back

Arguments:

    hShared - handle to memory mapped file

Return Value:

    none, status returned via shared memory region

--*/
{
    PPROXY_DATA pData = NULL;

    try {

        //
        // Map the whole region
        //
        pData = MapViewOfFile(
                            hShared,
                            FILE_MAP_ALL_ACCESS,
                            0,
                            0,
                            sizeof(PROXY_DATA)
                            );

        if(pData) {
            pData->hrStatus = InstallExceptionPackFromInf(pData->InfPath,pData->Media,pData->Store,pData->Flags);
            UnmapViewOfFile(pData);
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        if(pData) {
            UnmapViewOfFile(pData);
        }
    }
}


VOID
WINAPI
ProxyRemoteInstallW(
    IN HWND      Window,
    IN HINSTANCE ModuleHandle,
    IN PCWSTR    CommandLine,
    IN INT       ShowCommand
    )
/*++

Routine Description:

    Remote side of the proxy install process

Arguments:

    Window       - ignored
    ModuleHandle - ignored
    CommandLine  - "0xXXXX" - shared handle
    ShowCommand  - ignored

Return Value:

    none, status returned via shared memory region

--*/
{
    ULONG_PTR val = wcstol(CommandLine,NULL,0);
    ProxyRemoteInstallHandle((HANDLE)val);
}


VOID
WINAPI
ProxyRemoteInstallA(
    IN HWND      Window,
    IN HINSTANCE ModuleHandle,
    IN PCSTR     CommandLine,
    IN INT       ShowCommand
    )
/*++

Routine Description:

    Remote side of the proxy install process

Arguments:

    Window       - ignored
    ModuleHandle - ignored
    CommandLine  - "0xXXXX" - shared handle
    ShowCommand  - ignored

Return Value:

    none, status returned via shared memory region

--*/
{
    ULONG_PTR val = strtol(CommandLine,NULL,0);
    ProxyRemoteInstallHandle((HANDLE)val);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\msoobci\stubs.c ===
/*++

Copyright (c) Microsoft Corporation. All Rights Reserved.

Module Name:

    stubs.c

Abstract:

    Stubs for various API's

Author:

    Jamie Hunter (jamiehun) 2001-11-27

Revision History:

    Jamie Hunter (jamiehun) 2001-11-27

        Initial Version

--*/
#include "msoobcip.h"

#define MODULE_SYSSETUP TEXT("syssetup.dll")
#define MODULE_KERNEL32 TEXT("kernel32.dll")
#define MODULE_SETUPAPI TEXT("setupapi.dll")
#define NAME_SetupQueryRegisteredOsComponent  "SetupQueryRegisteredOsComponent"
#define NAME_GetSystemWindowsDirectory        "GetSystemWindowsDirectoryW"
#define NAME_SetupRegisterOsComponent         "SetupRegisterOsComponent"
#define NAME_SetupUnRegisterOsComponent       "SetupUnRegisterOsComponent"
#define NAME_SetupCopyOEMInf                  "SetupCopyOEMInfW"
#define NAME_SetupQueryInfOriginalFileInformation "SetupQueryInfOriginalFileInformationW"
#define NAME_SetupDiGetDeviceInfoListDetail   "SetupDiGetDeviceInfoListDetailW"
#define NAME_CM_Set_DevNode_Problem_Ex        "CM_Set_DevNode_Problem_Ex"

typedef BOOL (WINAPI *API_SetupQueryRegisteredOsComponent)(LPGUID,PSETUP_OS_COMPONENT_DATA,PSETUP_OS_EXCEPTION_DATA);
typedef BOOL (WINAPI *API_SetupRegisterOsComponent)(PSETUP_OS_COMPONENT_DATA,PSETUP_OS_EXCEPTION_DATA);
typedef BOOL (WINAPI *API_SetupUnRegisterOsComponent)(LPGUID);
typedef BOOL (WINAPI *API_GetSystemWindowsDirectory)(LPTSTR,UINT);
typedef BOOL (WINAPI *API_SetupQueryInfOriginalFileInformation)(PSP_INF_INFORMATION,UINT,PSP_ALTPLATFORM_INFO,PSP_ORIGINAL_FILE_INFO);
typedef BOOL (WINAPI *API_SetupCopyOEMInf)(PCTSTR,PCTSTR,DWORD,DWORD,PTSTR,DWORD,PDWORD,PTSTR*);
typedef BOOL (WINAPI *API_SetupDiGetDeviceInfoListDetail)(HDEVINFO,PSP_DEVINFO_LIST_DETAIL_DATA);
typedef CONFIGRET (WINAPI *API_CM_Set_DevNode_Problem_Ex)(DEVINST,ULONG,ULONG,HMACHINE);



FARPROC
GetModProc(
    IN OUT HMODULE * phModule,
    IN LPCTSTR ModuleName,
    IN LPCSTR ApiName
    )
/*++

Routine Description:

    Demand-load specific API
    combines LoadLibrary with GetProcAddress

Arguments:

    phModule - if points to NULL, replaced by handle to module ModuleName
    ModuleName - valid if phModule points to NULL
    ApiName - name of API to load

Return Value:

    procedure, or NULL

--*/
{
    HMODULE hMod = *phModule;
    if(!hMod) {
        HMODULE hModPrev;
        //
        // need to load
        //
        hMod = LoadLibrary(ModuleName);
        if(hMod == NULL) {
            //
            // error linking to module
            //
            return NULL;
        }
        hModPrev = InterlockedCompareExchangePointer(phModule,hMod,NULL);
        if(hModPrev) {
            //
            // someone else set phModule
            //
            FreeLibrary(hMod);
            hMod = hModPrev;
        }
    }
    return GetProcAddress(hMod,ApiName);
}

FARPROC
GetSysSetupProc(
    IN LPCSTR ApiName
    )
/*++

Routine Description:

    Demand-load specific API from syssetup.dll
    1st time side-effect is that we'll load and keep syssetup.dll in memory
    ok to not deref syssetup.dll when dll exists.

Arguments:

    ApiName - name of API to load

Return Value:

    procedure, or NULL

--*/
{
    static HMODULE hSysSetupDll = NULL;
    return GetModProc(&hSysSetupDll,MODULE_SYSSETUP,ApiName);
}

FARPROC
GetSetupApiProc(
    IN LPCSTR ApiName
    )
/*++

Routine Description:

    Demand-load specific API from setupapi.dll
    1st time side-effect is that we'll ref and keep setupapi.dll in memory
    ok to not deref syssetup.dll when dll exists.

Arguments:

    ApiName - name of API to load

Return Value:

    procedure, or NULL

--*/
{
    static HMODULE hSetupApiDll = NULL;
    return GetModProc(&hSetupApiDll,MODULE_SETUPAPI,ApiName);
}

FARPROC
GetKernelProc(
    IN LPCSTR ApiName
    )
/*++

Routine Description:

    Demand-load specific API from kernel32.dll
    1st time side-effect is that we'll load and keep kernel32.dll in memory
    (it's in memory anyway)
    ok to not deref kernel32.dll when dll exists.

Arguments:

    ApiName - name of API to load

Return Value:

    procedure, or NULL

--*/
{
    static HMODULE hKernel32Dll = NULL;
    return GetModProc(&hKernel32Dll,MODULE_KERNEL32,ApiName);
}

BOOL
WINAPI
QueryRegisteredOsComponent(
    IN  LPGUID ComponentGuid,
    OUT PSETUP_OS_COMPONENT_DATA SetupOsComponentData,
    OUT PSETUP_OS_EXCEPTION_DATA SetupOsExceptionData
    )
/*++

Routine Description:

    Demand-load and use SetupQueryRegisteredOsComponent from syssetup.dll, or
    use static version if not available

Arguments:

    as SetupQueryRegisteredOsComponent

Return Value:

    as SetupQueryRegisteredOsComponent

--*/
{
    static API_SetupQueryRegisteredOsComponent Func_SetupQueryRegisteredOsComponent = NULL;
    if(!Func_SetupQueryRegisteredOsComponent) {
        Func_SetupQueryRegisteredOsComponent = (API_SetupQueryRegisteredOsComponent)GetSysSetupProc(NAME_SetupQueryRegisteredOsComponent);
        if(!Func_SetupQueryRegisteredOsComponent) {
            Func_SetupQueryRegisteredOsComponent = SetupQueryRegisteredOsComponent; // static
        }
    }
    return Func_SetupQueryRegisteredOsComponent(ComponentGuid,SetupOsComponentData,SetupOsExceptionData);
}

BOOL
WINAPI
RegisterOsComponent (
    IN const PSETUP_OS_COMPONENT_DATA ComponentData,
    IN const PSETUP_OS_EXCEPTION_DATA ExceptionData
    )
/*++

Routine Description:

    Demand-load and use SetupRegisterOsComponent from syssetup.dll, or
    use static version if not available

Arguments:

    as SetupRegisterOsComponent

Return Value:

    as SetupRegisterOsComponent

--*/
{
    static API_SetupRegisterOsComponent Func_SetupRegisterOsComponent = NULL;
    if(!Func_SetupRegisterOsComponent) {
        Func_SetupRegisterOsComponent = (API_SetupRegisterOsComponent)GetSysSetupProc(NAME_SetupRegisterOsComponent);
        if(!Func_SetupRegisterOsComponent) {
            Func_SetupRegisterOsComponent = SetupRegisterOsComponent; // static
        }
    }
    return Func_SetupRegisterOsComponent(ComponentData,ExceptionData);
}


BOOL
WINAPI
UnRegisterOsComponent (
    IN const LPGUID ComponentGuid
    )
/*++

Routine Description:

    Demand-load and use SetupUnRegisterOsComponent from syssetup.dll, or
    use static version if not available

Arguments:

    as SetupUnRegisterOsComponent

Return Value:

    as SetupUnRegisterOsComponent

--*/
{
    static API_SetupUnRegisterOsComponent Func_SetupUnRegisterOsComponent = NULL;
    if(!Func_SetupUnRegisterOsComponent) {
        Func_SetupUnRegisterOsComponent = (API_SetupUnRegisterOsComponent)GetSysSetupProc(NAME_SetupUnRegisterOsComponent);
        if(!Func_SetupUnRegisterOsComponent) {
            Func_SetupUnRegisterOsComponent = SetupUnRegisterOsComponent; // static
        }
    }
    return Func_SetupUnRegisterOsComponent(ComponentGuid);
}

UINT
GetRealWindowsDirectory(
    LPTSTR lpBuffer,  // buffer to receive directory name
    UINT uSize        // size of name buffer
    )
/*++

Routine Description:

    Use GetSystemWindowsDirectory if it exists
    otherwise use GetWindowsDirectory

Arguments:

    as GetSystemWindowsDirectory

Return Value:

    as GetSystemWindowsDirectory

--*/
{
    static API_GetSystemWindowsDirectory Func_GetSystemWindowsDirectory = NULL;

    if(!Func_GetSystemWindowsDirectory) {
        Func_GetSystemWindowsDirectory = (API_GetSystemWindowsDirectory)GetKernelProc(NAME_GetSystemWindowsDirectory);
        if(!Func_GetSystemWindowsDirectory) {
            Func_GetSystemWindowsDirectory = GetWindowsDirectory; // static
        }
    }
    return Func_GetSystemWindowsDirectory(lpBuffer,uSize);
}

BOOL Downlevel_SetupQueryInfOriginalFileInformation(
  PSP_INF_INFORMATION InfInformation,
  UINT InfIndex,
  PSP_ALTPLATFORM_INFO AlternatePlatformInfo,
  PSP_ORIGINAL_FILE_INFO OriginalFileInfo
)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

BOOL QueryInfOriginalFileInformation(
  PSP_INF_INFORMATION InfInformation,
  UINT InfIndex,
  PSP_ALTPLATFORM_INFO AlternatePlatformInfo,
  PSP_ORIGINAL_FILE_INFO OriginalFileInfo
)
{
    static API_SetupQueryInfOriginalFileInformation Func_SetupQueryInfOriginalFileInformation = NULL;

    if(!Func_SetupQueryInfOriginalFileInformation) {
        Func_SetupQueryInfOriginalFileInformation = (API_SetupQueryInfOriginalFileInformation)GetSetupApiProc(NAME_SetupQueryInfOriginalFileInformation);
        if(!Func_SetupQueryInfOriginalFileInformation) {
            Func_SetupQueryInfOriginalFileInformation = Downlevel_SetupQueryInfOriginalFileInformation;
        }
    }
    return Func_SetupQueryInfOriginalFileInformation(InfInformation,InfIndex,AlternatePlatformInfo,OriginalFileInfo);
}

BOOL
WINAPI
Downlevel_SetupCopyOEMInf(
  PCTSTR SourceInfFileName,
  PCTSTR OEMSourceMediaLocation,
  DWORD OEMSourceMediaType,
  DWORD CopyStyle,
  PTSTR DestinationInfFileName,
  DWORD DestinationInfFileNameSize,
  PDWORD RequiredSize,
  PTSTR *DestinationInfFileNameComponent
)
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

BOOL CopyOEMInf(
  PCTSTR SourceInfFileName,
  PCTSTR OEMSourceMediaLocation,
  DWORD OEMSourceMediaType,
  DWORD CopyStyle,
  PTSTR DestinationInfFileName,
  DWORD DestinationInfFileNameSize,
  PDWORD RequiredSize,
  PTSTR *DestinationInfFileNameComponent
)
{
    static API_SetupCopyOEMInf Func_SetupCopyOEMInf = NULL;

    if(!Func_SetupCopyOEMInf) {
        Func_SetupCopyOEMInf = (API_SetupCopyOEMInf)GetSetupApiProc(NAME_SetupCopyOEMInf);
        if(!Func_SetupCopyOEMInf) {
            Func_SetupCopyOEMInf = Downlevel_SetupCopyOEMInf; // static
        }
    }
    return Func_SetupCopyOEMInf(SourceInfFileName,
                                OEMSourceMediaLocation,
                                OEMSourceMediaType,
                                CopyStyle,
                                DestinationInfFileName,
                                DestinationInfFileNameSize,
                                RequiredSize,
                                DestinationInfFileNameComponent
                                );
}

BOOL
WINAPI
Downlevel_SetupDiGetDeviceInfoListDetail(
    IN HDEVINFO  DeviceInfoSet,
    OUT PSP_DEVINFO_LIST_DETAIL_DATA  DeviceInfoSetDetailData
    )
{
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return FALSE;
}

BOOL
GetDeviceInfoListDetail(
    IN HDEVINFO  DeviceInfoSet,
    OUT PSP_DEVINFO_LIST_DETAIL_DATA  DeviceInfoSetDetailData
    )
{
    static API_SetupDiGetDeviceInfoListDetail Func_SetupDiGetDeviceInfoListDetail = NULL;

    if(!Func_SetupDiGetDeviceInfoListDetail) {
        Func_SetupDiGetDeviceInfoListDetail = (API_SetupDiGetDeviceInfoListDetail)GetSetupApiProc(NAME_SetupDiGetDeviceInfoListDetail);
        if(!Func_SetupDiGetDeviceInfoListDetail) {
            Func_SetupDiGetDeviceInfoListDetail = Downlevel_SetupDiGetDeviceInfoListDetail; // static
        }
    }
    return Func_SetupDiGetDeviceInfoListDetail(DeviceInfoSet,DeviceInfoSetDetailData);

}

CONFIGRET
WINAPI
Downlevel_CM_Set_DevNode_Problem_Ex(
    IN DEVINST   dnDevInst,
    IN ULONG     ulProblem,
    IN  ULONG    ulFlags,
    IN  HMACHINE hMachine
    )
{
    return CR_SUCCESS;
}

CONFIGRET
Set_DevNode_Problem_Ex(
    IN DEVINST   dnDevInst,
    IN ULONG     ulProblem,
    IN  ULONG    ulFlags,
    IN  HMACHINE hMachine
    )
{
    static API_CM_Set_DevNode_Problem_Ex Func_CM_Set_DevNode_Problem_Ex = NULL;

    if(!Func_CM_Set_DevNode_Problem_Ex) {
        Func_CM_Set_DevNode_Problem_Ex = (API_CM_Set_DevNode_Problem_Ex)GetSetupApiProc(NAME_CM_Set_DevNode_Problem_Ex);
        if(!Func_CM_Set_DevNode_Problem_Ex) {
            Func_CM_Set_DevNode_Problem_Ex = Downlevel_CM_Set_DevNode_Problem_Ex; // static
        }
    }
    return Func_CM_Set_DevNode_Problem_Ex(dnDevInst,ulProblem,ulFlags,hMachine);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ntcab\lib\compress.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    compress.c

Abstract:

    This module contains the code to compress a file
    into a cab file.

Author:

    Wesley Witt (wesw) 29-Sept-1998

Revision History:

--*/

#include <ntcabp.h>
#pragma hdrstop



BOOL
NtCabCompressOneFile(
    IN PCAB_INSTANCE_DATA CabInst,
    IN PCWSTR FileName
    )
{
    NTSTATUS Status;
    HANDLE hFile;
    DWORD FileSize;
    DWORD Bytes = 0;
    DWORD BytesRead;
    DWORD BytesCompressed;
    DWORD Length = 0;
    PCAB_DIR_ENTRY CabDir;
    ULONG i;
    BY_HANDLE_FILE_INFORMATION fi;
    WCHAR ShortFileName[32];


    hFile = CreateFile(
        FileName,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );
    if (hFile == INVALID_HANDLE_VALUE) {
        return GetLastError();
    }

    FileSize = GetFileSize( hFile, NULL );

    BytesRead = sizeof(CAB_DIR_ENTRY) + (sizeof(ULONG)*64);
    CabDir = (PCAB_DIR_ENTRY) malloc( BytesRead );
    if (CabDir == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    ZeroMemory( CabDir, BytesRead );

    GetFileInformationByHandle( hFile, &fi );

    CabDir->FileAttributes = fi.dwFileAttributes;
    CabDir->CreationTime = fi.ftCreationTime;
    CabDir->LastAccessTime = fi.ftLastAccessTime;
    CabDir->LastWriteTime = fi.ftLastWriteTime;
    CabDir->FileSize = FileSize;
    if (MapFileAndCheckSum( (PWSTR)FileName, &i, &CabDir->ChkSum ) != CHECKSUM_SUCCESS) {
        CabDir->ChkSum = 0;
    }
    CabDir->Offset = SetFilePointer( CabInst->hCab, 0, NULL, FILE_CURRENT );
    if (GetShortPathName( FileName, ShortFileName, sizeof(ShortFileName)/sizeof(WCHAR) ) == 0) {
        return FALSE;
    }
    wcscpy( CabDir->FileName, ShortFileName );
    i = 0;

    while (Bytes < FileSize) {
        BytesRead = min( CabInst->ReadBufSize, FileSize-Bytes );
        Status = ReadFile(
            hFile,
            CabInst->ReadBuf,
            BytesRead,
            &BytesRead,
            NULL
            );
        Bytes += BytesRead;
        Status = RtlCompressBuffer(
            COMPRESSION_FLAGS,
            CabInst->ReadBuf,
            BytesRead,
            CabInst->CompressBuf,
            CabInst->CompressBufSize,
            4096,
            &BytesCompressed,
            CabInst->WorkSpace
            );
        Status = WriteFile(
            CabInst->hCab,
            CabInst->CompressBuf,
            BytesCompressed,
            &BytesRead,
            NULL
            );
        Length += BytesRead;
        CabDir->Segment[i++] = BytesRead;
        CabDir->CompressedFileSize += BytesRead;
    }

    CabDir->Segments = i;
    InsertTailList( &CabInst->CabDir, &CabDir->Next );

    CloseHandle( hFile );

    CabInst->CabNum += 1;

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ntcab\lib\create.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    ccreate.c

Abstract:

    This module contains the code to create a
    new cab file.

Author:

    Wesley Witt (wesw) 29-Sept-1998

Revision History:

--*/

#include <ntcabp.h>
#pragma hdrstop



BOOL
NtCabCreateNewCabFile(
    IN PCAB_INSTANCE_DATA CabInst,
    IN PCWSTR CabFileName
    )
{
    NTSTATUS Status;
    HANDLE hCab;
    DWORD Bytes;
    CAB_HEADER CabHeader;


    CabInst->NewCabFile = TRUE;

    CabInst->hCab = CreateFile(
        CabFileName,
        GENERIC_WRITE | GENERIC_READ,
        0,
        NULL,
        CREATE_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );
    if (CabInst->hCab == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    CabHeader.Signature = NTCAB_SIGNATURE;
    CabHeader.Version = NTCAB_VERSION;
    CabHeader.DirOffset = 0;

    Status = WriteFile(
        CabInst->hCab,
        &CabHeader,
        sizeof(CAB_HEADER),
        &Bytes,
        NULL
        );

    InitializeListHead( &CabInst->CabDir );

    CabInst->CabFileName = _wcsdup( CabFileName );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ntcab\lib\enum.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    enum.c

Abstract:

    This module contains the code to enumerate
    the files in a cab file.

Author:

    Wesley Witt (wesw) 29-Sept-1998

Revision History:

--*/

#include <ntcabp.h>
#pragma hdrstop



BOOL
NtCabEnumerateFiles(
    IN PCAB_INSTANCE_DATA CabInst,
    IN PNTCABFILEENUM UserEnumFunc,
    IN ULONG_PTR Context
    )
{
    PLIST_ENTRY Next;
    PCAB_DIR_ENTRY CabDir;
    NTCAB_ENUM_DATA EnumData;
    BOOL Abort = FALSE;



    Next = CabInst->CabDir.Flink;
    while ((ULONG_PTR)Next != (ULONG_PTR)&CabInst->CabDir) {
        CabDir = CONTAINING_RECORD( Next, CAB_DIR_ENTRY, Next );
        Next = CabDir->Next.Flink;
        EnumData.FileAttributes = CabDir->FileAttributes;
        EnumData.CompressedFileSize = CabDir->CompressedFileSize;
        EnumData.CreationTime = CabDir->CreationTime;
        EnumData.LastAccessTime = CabDir->LastAccessTime;
        EnumData.LastWriteTime = CabDir->LastWriteTime;
        EnumData.FileName = CabDir->FileName;
        if (!UserEnumFunc( &EnumData, Context )) {
            Abort = TRUE;
            break;
        }
    }

    if (Abort) {
        SetLastError(ERROR_REQUEST_ABORTED);
    } else {
        SetLastError(ERROR_NO_MORE_FILES);
    }
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ntcab\lib\init.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    init.c

Abstract:

    This module contains the code to initialize
    the cab file engine.

Author:

    Wesley Witt (wesw) 29-Sept-1998

Revision History:

--*/

#include <ntcabp.h>
#pragma hdrstop


PVOID
NtCabInitialize(
    void
    )
{
    ULONG CompressBufferWorkSpaceSize;
    ULONG CompressFragmentWorkSpaceSize;
    PCAB_INSTANCE_DATA CabInst;


    CabInst = malloc( sizeof(CAB_INSTANCE_DATA) );
    ZeroMemory( CabInst, sizeof(CAB_INSTANCE_DATA) );

    RtlGetCompressionWorkSpaceSize(
        COMPRESSION_FLAGS,
        &CompressBufferWorkSpaceSize,
        &CompressFragmentWorkSpaceSize
        );

    CabInst->WorkSpace = (LPBYTE) malloc( CompressBufferWorkSpaceSize );
    ZeroMemory( CabInst->WorkSpace, CompressBufferWorkSpaceSize );

    CabInst->ReadBufSize = 4096*16;
    CabInst->ReadBuf = (LPBYTE) malloc( CabInst->ReadBufSize );

    CabInst->CompressBufSize = CabInst->ReadBufSize*2;
    CabInst->CompressBuf = (LPBYTE) malloc( CabInst->CompressBufSize );

    return CabInst;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ntcab\lib\ntcabp.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    ntcabp.h

Abstract:

    This is the private header file used
    by the nt cab file engine.

Author:

    Wesley Witt (wesw) 29-Sept-1998

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <windows.h>
#include <imagehlp.h>

#include <ntcabapi.h>


#define ALIGNMENT_VALUE         (512)
#define ROUNDUP_ALIGNMENT(_x)   (((_x)+(ALIGNMENT_VALUE-1)) & ~(ALIGNMENT_VALUE-1))
#define ROUNDDOWN_ALIGNMENT(_x) ((_x) & ~(ALIGNMENT_VALUE-1))

#define COMPRESSION_FLAGS       (COMPRESSION_FORMAT_LZNT1|COMPRESSION_ENGINE_STANDARD)

#define NTCAB_SIGNATURE         (DWORD)'NTCB'
#define NTCAB_VERSION           0x00010001

typedef struct _CAB_HEADER {
    DWORD Signature;
    DWORD Version;
    DWORD DirOffset;
} CAB_HEADER, *PCAB_HEADER;

typedef struct _CAB_DIR_ENTRY {
    LIST_ENTRY Next;
    DWORD ChkSum;
    DWORD Offset;
    DWORD FileSize;
    DWORD CompressedFileSize;
    DWORD Segments;
    DWORD FileAttributes;
    FILETIME CreationTime;
    FILETIME LastAccessTime;
    FILETIME LastWriteTime;
    WCHAR FileName[16];
    DWORD Segment[0];
} CAB_DIR_ENTRY, *PCAB_DIR_ENTRY;

typedef struct _CAB_INSTANCE_DATA {
    LPBYTE WorkSpace;
    LPBYTE ReadBuf;
    ULONG ReadBufSize;
    LPBYTE CompressBuf;
    ULONG CompressBufSize;
    LIST_ENTRY CabDir;
    ULONG CabNum;
    HANDLE hCab;
    BOOL NewCabFile;
    LPWSTR CabFileName;
    ULONG CabDirOffset;
} CAB_INSTANCE_DATA, *PCAB_INSTANCE_DATA;

PCAB_DIR_ENTRY
FindFileInCab(
    IN PCAB_INSTANCE_DATA CabInst,
    IN PCWSTR FileName
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ntcab\lib\extract.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    extract.c

Abstract:

    This module contains the code to extract
    a file from a cab file.

Author:

    Wesley Witt (wesw) 29-Sept-1998

Revision History:

--*/

#include <ntcabp.h>
#pragma hdrstop



PCAB_DIR_ENTRY
FindFileInCab(
    IN PCAB_INSTANCE_DATA CabInst,
    IN PCWSTR FileName
    )
{
    PLIST_ENTRY Next;
    PCAB_DIR_ENTRY CabDir;
    BOOL Found = FALSE;


    Next = CabInst->CabDir.Flink;
    while ((ULONG_PTR)Next != (ULONG_PTR)&CabInst->CabDir) {
        CabDir = CONTAINING_RECORD( Next, CAB_DIR_ENTRY, Next );
        Next = CabDir->Next.Flink;
        if (_wcsicmp( CabDir->FileName, FileName ) == 0) {
            Found = TRUE;
            break;
        }
    }

    if (Found) {
        return CabDir;
    }

    return NULL;
}



BOOL
NtCabExtractOneFile(
    IN PCAB_INSTANCE_DATA CabInst,
    IN PCWSTR FileName,
    IN PCWSTR OutputFileName
    )
{
    HANDLE hFile;
    ULONG i;
    BOOL rVal;
    DWORD Bytes = 0;
    DWORD BytesRead;
    NTSTATUS Status;
    PCAB_DIR_ENTRY CabDir;
    WCHAR ShortFileName[32];


    //if (GetShortPathName( FileName, ShortFileName, sizeof(ShortFileName)/sizeof(WCHAR) ) == 0) {
    //    return FALSE;
    //}
    wcscpy(ShortFileName,FileName);

    CabDir = FindFileInCab( CabInst, ShortFileName );
    if (CabDir == NULL) {
        return FALSE;
    }

    if (SetFilePointer( CabInst->hCab, CabDir->Offset, NULL, FILE_BEGIN ) == 0xffffffff) {
        return FALSE;
    }

    if (OutputFileName == NULL) {
        OutputFileName = ShortFileName;
    }

    hFile = CreateFile(
        OutputFileName,
        GENERIC_WRITE,
        0,
        NULL,
        CREATE_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );
    if (hFile == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    for (i=0; i<CabDir->Segments; i++) {
        BytesRead = CabDir->Segment[i];
        rVal = ReadFile(
            CabInst->hCab,
            CabInst->CompressBuf,
            BytesRead,
            &BytesRead,
            NULL
            );
        if (!rVal) {
            CloseHandle( hFile );
            return FALSE;
        }
        Bytes += BytesRead;
        Status = RtlDecompressBuffer (
            COMPRESSION_FORMAT_LZNT1,
            CabInst->ReadBuf,
            CabInst->ReadBufSize,
            CabInst->CompressBuf,
            BytesRead,
            &BytesRead
            );
        if (Status != STATUS_SUCCESS) {
            CloseHandle( hFile );
            return FALSE;
        }
        rVal = WriteFile(
            hFile,
            CabInst->ReadBuf,
            BytesRead,
            &BytesRead,
            NULL
            );
    }

    SetFileTime(
        hFile,
        &CabDir->CreationTime,
        &CabDir->LastAccessTime,
        &CabDir->LastWriteTime
        );

    CloseHandle( hFile );

    if (CabDir->ChkSum != 0) {
        if (MapFileAndCheckSum( (PWSTR)OutputFileName, &i, &Bytes ) != CHECKSUM_SUCCESS) {
            Bytes = 0;
        }
        if (Bytes != CabDir->ChkSum) {
            DeleteFile( OutputFileName );
            SetLastError( ERROR_INVALID_DATA );
            return FALSE;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ntcab\lib\openclose.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    openclose.c

Abstract:

    This module contains the code to open and
    close a cab file.

Author:

    Wesley Witt (wesw) 29-Sept-1998

Revision History:

--*/

#include <ntcabp.h>
#pragma hdrstop


BOOL
NtCabOpenCabFile(
    IN PCAB_INSTANCE_DATA CabInst,
    IN PCWSTR CabFileName
    )
{
    BOOL rVal;
    HANDLE hCab;
    DWORD Bytes;
    DWORD FileSize;
    PULONG Lengths;
    DWORD i;
    PLIST_ENTRY Next;
    PCAB_DIR_ENTRY CabDir;
    CAB_HEADER CabHeader;


    CabInst->hCab = CreateFile(
        CabFileName,
        GENERIC_WRITE | GENERIC_READ,
        0,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );
    if (CabInst->hCab == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    FileSize = GetFileSize( CabInst->hCab, NULL );

    rVal = ReadFile(
        CabInst->hCab,
        &CabHeader,
        sizeof(CAB_HEADER),
        &Bytes,
        NULL
        );
    if (!rVal) {
        CloseHandle( CabInst->hCab );
        return FALSE;
    }

    if ((CabHeader.Signature != NTCAB_SIGNATURE) ||
        (CabHeader.Version != NTCAB_VERSION))
    {
        return FALSE;
    }

    CabInst->CabDirOffset = CabHeader.DirOffset;

    if (SetFilePointer( CabInst->hCab, CabInst->CabDirOffset, NULL, FILE_BEGIN ) == 0xffffffff) {
        CloseHandle( CabInst->hCab );
        return FALSE;
    }

    InitializeListHead( &CabInst->CabDir );

    rVal = ReadFile(
        CabInst->hCab,
        &CabInst->CabNum,
        sizeof(ULONG),
        &Bytes,
        NULL
        );
    Lengths = (PULONG) malloc( CabInst->CabNum * sizeof(ULONG) );
    if (Lengths == NULL) {
        CloseHandle( CabInst->hCab );
        return FALSE;
    }
    rVal = ReadFile(
        CabInst->hCab,
        Lengths,
        CabInst->CabNum * sizeof(ULONG),
        &Bytes,
        NULL
        );
    for (i=0; i<CabInst->CabNum; i++) {
        Bytes = sizeof(CAB_DIR_ENTRY) + (sizeof(ULONG)*Lengths[i]);
        CabDir = (PCAB_DIR_ENTRY) malloc( Bytes );
        if (CabDir == NULL) {
            CloseHandle( CabInst->hCab );
            return FALSE;
        }
        rVal = ReadFile(
            CabInst->hCab,
            CabDir,
            Lengths[i],
            &Bytes,
            NULL
            );
        ZeroMemory( &CabDir->Next, sizeof(LIST_ENTRY) );
        InsertTailList( &CabInst->CabDir, &CabDir->Next );
    }

    CabInst->CabFileName = _wcsdup( CabFileName );

    return TRUE;
}


BOOL
NtCabClose(
    IN PCAB_INSTANCE_DATA CabInst
    )
{
    NTSTATUS Status;
    DWORD Bytes;
    DWORD DirOffset;
    PULONG Lengths;
    DWORD i;
    PLIST_ENTRY Next;
    PCAB_DIR_ENTRY CabDir;
    CAB_HEADER CabHeader;


    if (CabInst->NewCabFile) {
        if (IsListEmpty(&CabInst->CabDir)) {
            return FALSE;
        }
        DirOffset = SetFilePointer( CabInst->hCab, 0, NULL, FILE_END );
        Lengths = (PULONG) malloc( CabInst->CabNum * sizeof(ULONG) );
        if (Lengths == NULL) {
            CloseHandle( CabInst->hCab );
            return FALSE;
        }
        i = 0;
        Next = CabInst->CabDir.Flink;
        while ((ULONG_PTR)Next != (ULONG_PTR)&CabInst->CabDir) {
            CabDir = CONTAINING_RECORD( Next, CAB_DIR_ENTRY, Next );
            Next = CabDir->Next.Flink;
            Lengths[i] = (CabDir->Segments * sizeof(ULONG)) + sizeof(CAB_DIR_ENTRY);
            i += 1;
        }
        Status = WriteFile(
            CabInst->hCab,
            &CabInst->CabNum,
            sizeof(ULONG),
            &Bytes,
            NULL
            );
        Status = WriteFile(
            CabInst->hCab,
            Lengths,
            CabInst->CabNum * sizeof(ULONG),
            &Bytes,
            NULL
            );
        i = 0;
        Next = CabInst->CabDir.Flink;
        while ((ULONG_PTR)Next != (ULONG_PTR)&CabInst->CabDir) {
            CabDir = CONTAINING_RECORD( Next, CAB_DIR_ENTRY, Next );
            Next = CabDir->Next.Flink;
            Status = WriteFile(
                CabInst->hCab,
                CabDir,
                Lengths[i++],
                &Bytes,
                NULL
                );
        }
        SetFilePointer( CabInst->hCab, 0, NULL, FILE_BEGIN );

        CabHeader.Signature = NTCAB_SIGNATURE;
        CabHeader.Version = NTCAB_VERSION;
        CabHeader.DirOffset = DirOffset;

        Status = WriteFile(
            CabInst->hCab,
            &CabHeader,
            sizeof(CAB_HEADER),
            &Bytes,
            NULL
            );
    }

    CloseHandle( CabInst->hCab );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ntcab\tool\ntcab.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    ntcab.c

Abstract:

    This is the source module for the nt
    cab file tool.  This tool allows for the
    creation and modification of nt cab files.

Author:

    Wesley Witt (wesw) 29-Sept-1998

Revision History:

--*/

#include <windows.h>
#include <stdio.h>
#include "ntcabapi.h"



void
Usage(
    void
    )
{
    printf( "\nMicrosoft (R) NT Cabinet Tool\n" );
    printf( "Copyright (c) Microsoft Corp 1998. All rights reserved.\n\n" );
    printf( "Usage: NTCAB [options] cabfile [@list] [files]\n\n" );
    printf( "Options:\n" );
    printf( "  -c  Create a new cab file\n" );
    printf( "  -a  Add a file to the cabinet\n" );
    printf( "  -x  Extract a file from the cabinet\n" );
}


BOOL
UserEnumFunc(
    const PNTCAB_ENUM_DATA EnumData,
    ULONG_PTR Context
    )
{
    printf( "%ws\n", EnumData->FileName );
    return TRUE;
}


int __cdecl wmain( int argc, WCHAR *argv[] )
{
    PVOID hCab;
    ULONG i;
    HANDLE hFile;
    HANDLE hMap;
    PCHAR FileList;
    PCHAR s,e;
    WCHAR FileName[MAX_PATH];
    BOOL CreateNewCab = FALSE;
    BOOL ExtractFile = FALSE;
    BOOL AddFile = FALSE;
    BOOL ListFile = FALSE;


    //
    // process any options
    //

    for (i=1; i<(ULONG)argc; i++) {
        if (argv[i][0] == L'/' || argv[i][0] == L'-') {
            switch (towlower(argv[i][1])) {
                case L'c':
                    CreateNewCab = TRUE;
                    break;

                case L'x':
                    ExtractFile = TRUE;
                    break;

                case L'a':
                    AddFile = TRUE;
                    break;

                case L'l':
                    ListFile = TRUE;
                    break;

                case L'?':
                    Usage();
                    return 0;

                default:
                    return -1;
            }
        }
    }

    if (ListFile) {
        hCab = NtCabInitialize();
        if (hCab == NULL) {
            return -1;
        }

        if (!NtCabOpenCabFile( hCab, argv[2] )) {
            return -1;
        }

        NtCabEnumerateFiles( hCab, UserEnumFunc, 0 );

        NtCabClose( hCab );
        return 0;
    }

    if (ExtractFile) {
        hCab = NtCabInitialize();
        if (hCab == NULL) {
            return -1;
        }

        if (!NtCabOpenCabFile( hCab, argv[2] )) {
            return -1;
        }

        if (!NtCabExtractOneFile( hCab, argv[3], NULL )) {
            return -1;
        }

        NtCabClose( hCab );
        return 0;
    }

    if (AddFile) {
        hCab = NtCabInitialize();
        if (hCab == NULL) {
            return -1;
        }

        if (!NtCabOpenCabFile( hCab, argv[2] )) {
            return -1;
        }

        if (!NtCabReplaceOneFile( hCab, argv[3] )) {
            return -1;
        }

        NtCabClose( hCab );
        return 0;
    }

    if (CreateNewCab) {
        hCab = NtCabInitialize();
        if (hCab == NULL) {
            return -1;
        }

        if (!NtCabCreateNewCabFile( hCab, argv[2] )) {
            return -1;
        }

        if (argv[3][0] == L'@') {

            //
            // use a response file for the file list
            //

            hFile = CreateFile(
                &argv[3][1],
                GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );
            if (hFile == INVALID_HANDLE_VALUE) {
                return -1;
            }

            hMap = CreateFileMapping(
                hFile,
                NULL,
                PAGE_WRITECOPY,
                0,
                0,
                NULL
                );
            if (hMap == NULL) {
                return -1;
            }

            FileList = MapViewOfFile(
                hMap,
                FILE_MAP_COPY,
                0,
                0,
                0
                );
            if (FileList == NULL) {
                return -1;
            }

            s = FileList;
            while(1) {
                e = strchr(s,'\r');
                if (e == NULL) {
                    break;
                }
                *e = 0;
                MultiByteToWideChar(
                    CP_ACP,
                    MB_PRECOMPOSED,
                    s,
                    -1,
                    FileName,
                    sizeof(FileName)/sizeof(WCHAR)
                    );
                NtCabCompressOneFile( hCab, FileName );
                s = e + 2;
            }
        } else {

            //
            // use a file list off the command line
            //

            for (i=3; i<(ULONG)argc; i++) {
                NtCabCompressOneFile( hCab, argv[i] );
            }

        }

        NtCabClose( hCab );
        return 0;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ntcab\lib\replace.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    replace.c

Abstract:

    This module contains the code to replace
    a file in the cab file.

Author:

    Wesley Witt (wesw) 29-Sept-1998

Revision History:

--*/

#include <ntcabp.h>
#pragma hdrstop



BOOL
NtCabReplaceOneFile(
    IN PCAB_INSTANCE_DATA CabInst,
    IN PCWSTR FileName
    )
{
    BOOL rVal;
    NTSTATUS Status;
    HANDLE hFileTmp;
    HANDLE hFile;
    PCAB_DIR_ENTRY CabDir;
    PCAB_DIR_ENTRY CabDirNew;
    WCHAR TempPath[MAX_PATH];
    WCHAR TempFileName[MAX_PATH];
    DWORD Bytes = 0;
    DWORD BytesRead;
    ULONG FileSize;
    ULONG i;
    DWORD BytesCompressed;
    LPWSTR s;


    //
    // file the file to replace
    //

    CabDir = FindFileInCab( CabInst, FileName );
    if (CabDir == NULL) {
        return FALSE;
    }

    //
    // open the new data file
    //

    hFile = CreateFile(
        FileName,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );
    if (hFile == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    FileSize = GetFileSize( hFile, NULL );

    if (FileSize < CabDir->FileSize) {
        //
        // do an inplace update - this is the fast code path
        //

        //
        // position the cabfile to the data for the old file
        //

        SetFilePointer( CabInst->hCab, CabDir->Offset, NULL, FILE_BEGIN );

        //
        // create a directory for the new cab file
        //

        BytesRead = sizeof(CAB_DIR_ENTRY) + (sizeof(ULONG)*64);
        CabDirNew = (PCAB_DIR_ENTRY) malloc( BytesRead );
        if (CabDirNew == NULL) {
            return FALSE;
        }

        ZeroMemory( CabDirNew, BytesRead );

        CabDirNew->Offset = SetFilePointer( CabInst->hCab, 0, NULL, FILE_CURRENT );
        wcscpy( CabDirNew->FileName, FileName );
        i = 0;

        Bytes = 0;
        FileSize = GetFileSize( hFile, NULL );

        //
        // copy the data from the new data file into
        // the new cab file, compressing it as we go
        //

        while (Bytes < FileSize) {
            BytesRead = min( CabInst->ReadBufSize, FileSize-Bytes );
            Status = ReadFile(
                hFile,
                CabInst->ReadBuf,
                BytesRead,
                &BytesRead,
                NULL
                );
            Bytes += BytesRead;
            Status = RtlCompressBuffer(
                COMPRESSION_FLAGS,
                CabInst->ReadBuf,
                BytesRead,
                CabInst->CompressBuf,
                CabInst->CompressBufSize,
                4096,
                &BytesCompressed,
                CabInst->WorkSpace
                );
            Status = WriteFile(
                CabInst->hCab,
                CabInst->CompressBuf,
                BytesCompressed,
                &BytesRead,
                NULL
                );
            CabDirNew->Segment[i++] = BytesRead;
            CabDirNew->CompressedFileSize += BytesRead;
        }

        CabDirNew->Segments = i;

        //
        // put the new file in the dir list and
        // remove the old file from the list
        //

        RemoveEntryList( &CabDir->Next );
        InsertTailList( &CabInst->CabDir, &CabDirNew->Next );

        //
        // truncate the dir entries
        //

        SetFilePointer( CabInst->hCab, CabInst->CabDirOffset, NULL, FILE_BEGIN );
        SetEndOfFile( CabInst->hCab );
        FlushFileBuffers( CabInst->hCab );

        //
        // trick the close function to rebuild the dirs
        //

        CabInst->NewCabFile = TRUE;

        return TRUE;
    }

    //
    // create a file name for the temporary cab file
    //

    GetTempPath( sizeof(TempPath)/sizeof(WCHAR), TempPath );
    GetTempFileName( TempPath, L"cab", 0, TempFileName );

    //
    // create the new temporary cab file
    //

    hFileTmp = CreateFile(
        TempFileName,
        GENERIC_WRITE,
        0,
        NULL,
        CREATE_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );
    if (hFileTmp == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    //
    // set the existing cab file pointer to the beginning
    //

    SetFilePointer( CabInst->hCab, 0, NULL, FILE_BEGIN );

    FileSize = CabDir->Offset;
    Bytes = 0;

    //
    // copy the data from the beginning of the cab file
    // to the first byte of the file that needs replacing
    //

    while(Bytes<FileSize) {
        BytesRead = min( CabInst->ReadBufSize, FileSize-Bytes );
        rVal = ReadFile(
            CabInst->hCab,
            CabInst->ReadBuf,
            BytesRead,
            &BytesRead,
            NULL
            );
        Bytes += BytesRead;
        rVal = WriteFile(
            hFileTmp,
            CabInst->ReadBuf,
            BytesRead,
            &BytesRead,
            NULL
            );
    }

    //
    // create a directory for the new cab file
    //

    BytesRead = sizeof(CAB_DIR_ENTRY) + (sizeof(ULONG)*64);
    CabDirNew = (PCAB_DIR_ENTRY) malloc( BytesRead );
    if (CabDirNew == NULL) {
        return FALSE;
    }

    ZeroMemory( CabDirNew, BytesRead );

    CabDirNew->Offset = SetFilePointer( CabInst->hCab, 0, NULL, FILE_CURRENT );
    wcscpy( CabDirNew->FileName, FileName );
    i = 0;

    Bytes = 0;
    FileSize = GetFileSize( hFile, NULL );

    //
    // copy the data from the new data file into
    // the new cab file, compressing it as we go
    //

    while (Bytes < FileSize) {
        BytesRead = min( CabInst->ReadBufSize, FileSize-Bytes );
        Status = ReadFile(
            hFile,
            CabInst->ReadBuf,
            BytesRead,
            &BytesRead,
            NULL
            );
        Bytes += BytesRead;
        Status = RtlCompressBuffer(
            COMPRESSION_FLAGS,
            CabInst->ReadBuf,
            BytesRead,
            CabInst->CompressBuf,
            CabInst->CompressBufSize,
            4096,
            &BytesCompressed,
            CabInst->WorkSpace
            );
        Status = WriteFile(
            hFileTmp,
            CabInst->CompressBuf,
            BytesCompressed,
            &BytesRead,
            NULL
            );
        CabDirNew->Segment[i++] = BytesRead;
        CabDirNew->CompressedFileSize += BytesRead;
    }

    CabDirNew->Segments = i;

    //
    // skip the data for the original file
    //

    Bytes = SetFilePointer( CabInst->hCab, CabDir->CompressedFileSize, NULL, FILE_CURRENT );

    //
    // set up the file size for the remaining data minus the dir
    //

    FileSize = CabInst->CabDirOffset - Bytes;
    Bytes = 0;

    //
    // copy the remaining data
    //

    while(Bytes<FileSize) {
        BytesRead = min( CabInst->ReadBufSize, FileSize-Bytes );
        rVal = ReadFile(
            CabInst->hCab,
            CabInst->ReadBuf,
            BytesRead,
            &BytesRead,
            NULL
            );
        Bytes += BytesRead;
        rVal = WriteFile(
            hFileTmp,
            CabInst->ReadBuf,
            BytesRead,
            &BytesRead,
            NULL
            );
    }

    //
    // put the new file in the dir list and
    // remove the old file from the list
    //

    RemoveEntryList( &CabDir->Next );
    InsertTailList( &CabInst->CabDir, &CabDirNew->Next );

    //
    // close the new cab file and the new data file
    //

    CloseHandle( hFile );
    CloseHandle( hFileTmp );

    //
    // copy the new cab as the old cab file
    //

    CabInst->NewCabFile = TRUE;

    CloseHandle( CabInst->hCab );
    DeleteFile( CabInst->CabFileName );
    MoveFile( TempFileName, CabInst->CabFileName );

    //
    // reopen the cab file so we can re-write the
    // dir when it is closed
    //

    CabInst->hCab = CreateFile(
        CabInst->CabFileName,
        GENERIC_WRITE | GENERIC_READ,
        0,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );
    if (CabInst->hCab == INVALID_HANDLE_VALUE) {
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ntoc\ntoc.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    ntoc.h

Abstract:

    This file contains the ntoc header stuff.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 7-Aug-1997

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <wingdip.h>
#include <setupapi.h>
#include <ocmanage.h>
#include <tapi.h>
#include <stdio.h>
#include <stdlib.h>
#include "resource.h"
#include "ntocmsg.h"


typedef enum {
    WizPageTapiLoc,
    //WizPageDisplay,
    WizPageDateTime,
    WizPageWelcome,
    //WizPageReinstall,
    WizPageFinal,
    WizPageMaximum    
} WizPage;


extern HINSTANCE hInstance;
extern SETUP_INIT_COMPONENT SetupInitComponent;


#if DBG

#define Assert(exp)         if(!(exp)) {AssertError(TEXT(#exp),TEXT(__FILE__),__LINE__);}
#define DebugPrint(_x_)     dprintf _x_

#define DebugStop(_x_)      {\
                                dprintf _x_;\
                                dprintf(TEXT("Stopping at %s @ %d"),TEXT(__FILE__),__LINE__);\
                                __try {\
                                    DebugBreak();\
                                } __except (UnhandledExceptionFilter(GetExceptionInformation())) {\
                                }\
                            }

#else

#define Assert(exp)
#define DebugPrint(_x_)
#define DebugStop(_x_)

#endif

void
dprintf(
    LPTSTR Format,
    ...
    );

VOID
AssertError(
    LPTSTR Expression,
    LPTSTR File,
    ULONG  LineNumber
    );


//
// prototypes
//

LRESULT
CommonWizardProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    DWORD buttonFlags
    );


void
WelcomeInit(
    void
    );

void
WelcomeCommit(
    void
    );

LRESULT
WelcomeDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

void
ReinstallInit(
    void
    );

void
ReinstallCommit(
    void
    );

LRESULT
ReinstallDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );



void
FinishInit(
    void
    );

void
FinishCommit(
    void
    );

LRESULT
FinishDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );


void
TapiInit(
    void
    );

void
TapiCommitChanges(
    void
    );

LRESULT
TapiLocDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

void
DisplayInit(
    void
    );

void
DisplayCommitChanges(
    void
    );

LRESULT
DisplayDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

void
DateTimeInit(
    void
    );

void
DateTimeCommitChanges(
    void
    );

LRESULT
DateTimeDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );

HKEY
OpenRegistryKey(
    HKEY hKey,
    LPTSTR KeyName,
    BOOL CreateNewKey,
    REGSAM SamDesired
    );

LPTSTR
GetRegistryString(
    HKEY hKey,
    LPTSTR ValueName,
    LPTSTR DefaultValue
    );

LPTSTR
GetRegistryStringExpand(
    HKEY hKey,
    LPTSTR ValueName,
    LPTSTR DefaultValue
    );

DWORD
GetRegistryDword(
    HKEY hKey,
    LPTSTR ValueName
    );

BOOL
SetRegistryDword(
    HKEY hKey,
    LPTSTR ValueName,
    DWORD Value
    );

BOOL
SetRegistryString(
    HKEY hKey,
    LPTSTR ValueName,
    LPTSTR Value
    );

BOOL
SetRegistryStringExpand(
    HKEY hKey,
    LPTSTR ValueName,
    LPTSTR Value
    );

BOOL
SetRegistryStringMultiSz(
    HKEY hKey,
    LPTSTR ValueName,
    LPTSTR Value,
    DWORD Length
    );

BOOL 
RunningAsAdministrator(
	VOID
	);

int
FmtMessageBox(
    HWND hwnd,
    UINT fuStyle,
    BOOL fSound,
    DWORD dwTitleID,
    DWORD dwTextID,
    ...
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ntoc\datetime.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    datetime.cpp

Abstract:

    This file implements the date & time page.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 1-Dec-1997

--*/

#include "ntoc.h"
#pragma hdrstop

#define MYDEBUG 0

#define TIMER_ID                1
#define OPEN_TLEN               450    /* < half second */
#define TZNAME_SIZE             128
#define TZDISPLAYZ              128
#define REGKEY_TIMEZONES        L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Time Zones"
#define   REGVAL_TZ_DISPLAY     L"Display"
#define   REGVAL_TZ_STD         L"Std"
#define   REGVAL_TZ_DAYLIGHT    L"Dlt"
#define   REGVAL_TZ_TZI         L"TZI"
#define   REGVAL_TZ_INDEX       L"Index"
#define   REGVAL_TZ_INDEXMAP    L"IndexMapping"
#define REGKEY_TIMEZONE_INFO    L"System\\CurrentControlSet\\Control\\TimeZoneInformation"
#define   REGVAL_TZNOAUTOTIME   L"DisableAutoDaylightTimeSet"


typedef struct tagTZINFO
{
    LIST_ENTRY       ListEntry;
    WCHAR            szDisplayName[TZDISPLAYZ];
    WCHAR            szStandardName[TZNAME_SIZE];
    WCHAR            szDaylightName[TZNAME_SIZE];
    int              ReferenceIndex;
    LONG             Bias;
    LONG             StandardBias;
    LONG             DaylightBias;
    SYSTEMTIME       StandardDate;
    SYSTEMTIME       DaylightDate;

} TZINFO, *PTZINFO;

LIST_ENTRY ZoneList;
SYSTEMTIME SelectedTime;
SYSTEMTIME SelectedDate;
BOOL ChangeTime;
BOOL ChangeDate;
PTZINFO CurrZone;
BOOL AllowAutoDST;
INT gUnattenedTimeZone = -1;
BOOL DateTimeBadUnattend;


HWND  ghWnd;               // global copy of the handle to the wizard page. This
                           // is required by DateTimeCommitChanges during an
                           // unattended installation.


BOOL
ReadZoneData(
    PTZINFO zone,
    HKEY key,
    LPCWSTR keyname
    )
{
    WCHAR mapinfo[16];
    DWORD len;

    len = sizeof(zone->szDisplayName);

    if (RegQueryValueEx( key,
                         REGVAL_TZ_DISPLAY,
                         0,
                         NULL,
                         (LPBYTE)zone->szDisplayName,
                         &len ) != ERROR_SUCCESS)
    {
        return (FALSE);
    }

    //
    //  Under NT, the keyname is the "Standard" name.  Values stored
    //  under the keyname contain the other strings and binary info
    //  related to the time zone.  Every time zone must have a standard
    //  name, therefore, we save registry space by using the Standard
    //  name as the subkey name under the "Time Zones" key.
    //
    len = sizeof(zone->szStandardName);

    if (RegQueryValueEx( key,
                         REGVAL_TZ_STD,
                         0,
                         NULL,
                         (LPBYTE)zone->szStandardName,
                         &len ) != ERROR_SUCCESS)
    {
        //
        //  Use keyname if can't get StandardName value.
        //
        lstrcpyn( zone->szStandardName,
                  keyname,
                  sizeof(zone->szStandardName) );
    }

    len = sizeof(zone->szDaylightName);

    if (RegQueryValueEx( key,
                         REGVAL_TZ_DAYLIGHT,
                         0,
                         NULL,
                         (LPBYTE)zone->szDaylightName,
                         &len ) != ERROR_SUCCESS)
    {
        return (FALSE);
    }

    len = sizeof(zone->ReferenceIndex);

    if (RegQueryValueEx( key,
                         REGVAL_TZ_INDEX,
                         0,
                         NULL,
                         (LPBYTE)&zone->ReferenceIndex,
                         &len ) != ERROR_SUCCESS)
    {
        return (FALSE);
    }

    len = sizeof(zone->Bias) +
          sizeof(zone->StandardBias) +
          sizeof(zone->DaylightBias) +
          sizeof(zone->StandardDate) +
          sizeof(zone->DaylightDate);

    if (RegQueryValueEx( key,
                         REGVAL_TZ_TZI,
                         0,
                         NULL,
                         (LPBYTE)&zone->Bias,
                         &len ) != ERROR_SUCCESS)
    {
        return (FALSE);
    }

    return (TRUE);
}


#if MYDEBUG
void
PrintZones(
    void
    )
{
    PLIST_ENTRY NextZone;
    PTZINFO zone;
    NextZone = ZoneList.Flink;
    if (NextZone) {
        DebugPrint(( L"----------------- time zone list -------------------------------------\n" ));
        while (NextZone != &ZoneList) {
            zone = CONTAINING_RECORD( NextZone, TZINFO, ListEntry );
            NextZone = zone->ListEntry.Flink;
            DebugPrint(( L"%03d  %s", zone->ReferenceIndex, zone->szDisplayName ));
        }
    }
}
#endif


void
AddZoneToList(
    PTZINFO zone
    )
{
    PLIST_ENTRY NextZone;
    PTZINFO ThisZone;


    if (IsListEmpty( &ZoneList )) {
        InsertHeadList( &ZoneList, &zone->ListEntry );
        return;
    }

    NextZone = ZoneList.Flink;
    while (NextZone != &ZoneList)
    {
        ThisZone = CONTAINING_RECORD( NextZone, TZINFO, ListEntry );
        NextZone = ThisZone->ListEntry.Flink;
        if (ThisZone->ReferenceIndex > zone->ReferenceIndex) {
            InsertTailList( &ThisZone->ListEntry, &zone->ListEntry );
            return;
        }
    }
    InsertTailList( &ZoneList, &zone->ListEntry );
}


int
BuildTimeZoneList(
    void
    )
{
    HKEY key = NULL;
    int count = -1;



    InitializeListHead( &ZoneList );

    if (RegOpenKey( HKEY_LOCAL_MACHINE, REGKEY_TIMEZONES, &key ) == ERROR_SUCCESS)
    {
        WCHAR name[TZNAME_SIZE];
        PTZINFO zone = NULL;
        int i;

        count = 0;

        for (i = 0; RegEnumKey( key, i, name, TZNAME_SIZE ) == ERROR_SUCCESS; i++)
        {
            HKEY subkey = NULL;

            if (!zone &&
                ((zone = (PTZINFO)LocalAlloc(LPTR, sizeof(TZINFO))) == NULL))
            {
                break;
            }

            if (RegOpenKey(key, name, &subkey) == ERROR_SUCCESS)
            {
                //
                //  Each sub key name under the Time Zones key is the
                //  "Standard" name for the Time Zone.
                //
                lstrcpyn(zone->szStandardName, name, TZNAME_SIZE);

                if (ReadZoneData(zone, subkey, name))
                {
                    AddZoneToList(zone);
                    zone = NULL;
                    count++;
                }

                RegCloseKey(subkey);
            }
        }

        RegCloseKey(key);
    }

    return count;
}


void
DateTimeInit(
    void
    )
{
    DWORD d;

    BuildTimeZoneList();

#if MYDEBUG
    PrintZones();
#endif

    if ((SetupInitComponent.SetupData.OperationFlags & SETUPOP_BATCH) == 0) {
        return;
    }

    HINF InfHandle = SetupInitComponent.HelperRoutines.GetInfHandle(
        INFINDEX_UNATTENDED,
        SetupInitComponent.HelperRoutines.OcManagerContext
        );
    if (InfHandle == NULL) {
        DateTimeBadUnattend = TRUE;
        return;
    }

    INFCONTEXT InfLine;

    if (!SetupFindFirstLine(InfHandle, L"GuiUnattended", L"TimeZone", &InfLine )) {

        DateTimeBadUnattend = TRUE;

        return;
    }

    if (SetupGetIntField( &InfLine, 1, (PINT)&d )) {
        gUnattenedTimeZone = (INT) d;
    } else {
        DateTimeBadUnattend = TRUE;
    }
}


void
SetAllowLocalTimeChange(
    BOOL fAllow
    )
{
    HKEY key = NULL;

    if (fAllow)
    {
        //
        //  Remove the disallow flag from the registry if it exists.
        //
        if (RegOpenKey( HKEY_LOCAL_MACHINE, REGKEY_TIMEZONE_INFO, &key ) == ERROR_SUCCESS)
        {
            RegDeleteValue(key, REGVAL_TZNOAUTOTIME);
        }
    }
    else
    {
        //
        //  Add/set the nonzero disallow flag.
        //
        if (RegCreateKey( HKEY_LOCAL_MACHINE, REGKEY_TIMEZONE_INFO, &key ) == ERROR_SUCCESS)
        {
            DWORD value = 1;

            RegSetValueEx( key,
                           REGVAL_TZNOAUTOTIME,
                           0,
                           REG_DWORD,
                           (LPBYTE)&value,
                           sizeof(value) );
        }
    }

    if (key)
    {
        RegCloseKey(key);
    }
}


BOOL
GetAllowLocalTimeChange(
    void
    )
{
    //
    //  Assume allowed until we see a disallow flag.
    //
    BOOL result = TRUE;
    HKEY key;

    if (RegOpenKey( HKEY_LOCAL_MACHINE, REGKEY_TIMEZONE_INFO, &key ) == ERROR_SUCCESS)
    {
        //
        //  Assume no disallow flag until we see one.
        //
        DWORD value = 0;
        DWORD len = sizeof(value);
        DWORD type;

        if ((RegQueryValueEx( key,
                              REGVAL_TZNOAUTOTIME,
                              NULL,
                              &type,
                              (LPBYTE)&value,
                              &len ) == ERROR_SUCCESS) &&
            ((type == REG_DWORD) || (type == REG_BINARY)) &&
            (len == sizeof(value)) && value)
        {
            //
            //  Okay, we have a nonzero value, it is either:
            //
            //  1) 0xFFFFFFFF
            //      this is set in an inf file for first boot to prevent
            //      the base from performing any cutovers during setup.
            //
            //  2) some other value
            //      this signifies that the user actualy disabled cutovers
            //     *return that local time changes are disabled
            //
            if (value != 0xFFFFFFFF)
            {
                result = FALSE;
            }
        }

        RegCloseKey(key);
    }

    return (result);
}


void
SetTheTimezone(
    BOOL bAutoMagicTimeChange,
    PTZINFO ptzi
    )
{
    TIME_ZONE_INFORMATION tzi;
    HCURSOR hCurOld;

    if (!ptzi)
    {
        return;
    }

    tzi.Bias = ptzi->Bias;

    if ((bAutoMagicTimeChange == 0) || (ptzi->StandardDate.wMonth == 0))
    {
        //
        //  Standard Only.
        //
        tzi.StandardBias = ptzi->StandardBias;
        tzi.DaylightBias = ptzi->StandardBias;
        tzi.StandardDate = ptzi->StandardDate;
        tzi.DaylightDate = ptzi->StandardDate;

        lstrcpy(tzi.StandardName, ptzi->szStandardName);
        lstrcpy(tzi.DaylightName, ptzi->szStandardName);
    }
    else
    {
        //
        //  Automatically adjust for Daylight Saving Time.
        //
        tzi.StandardBias = ptzi->StandardBias;
        tzi.DaylightBias = ptzi->DaylightBias;
        tzi.StandardDate = ptzi->StandardDate;
        tzi.DaylightDate = ptzi->DaylightDate;

        lstrcpy(tzi.StandardName, ptzi->szStandardName);
        lstrcpy(tzi.DaylightName, ptzi->szDaylightName);
    }

    SetAllowLocalTimeChange( bAutoMagicTimeChange );
    SetTimeZoneInformation( &tzi );
}

void
DateTimeApplyChanges(
    void
    )
{
    SYSTEMTIME SysTime;


    if (SetupInitComponent.SetupData.OperationFlags & SETUPOP_NTUPGRADE) {
        return;
    }

    // Note that in the unattended case we will never have ChangeTime set
    // as the page never is used except for the timezone stuff. There is 
    // no support to set date/time via unattend.

    if (ChangeTime) {
        SysTime.wHour = SelectedTime.wHour;
        SysTime.wMinute = SelectedTime.wMinute;
        SysTime.wSecond = SelectedTime.wSecond;
        SysTime.wMilliseconds = SelectedTime.wMilliseconds;
    } else {
        GetLocalTime( &SysTime );
    }


    // If this is an unattended setup the PSN_WIZNEXT never arrived so it is
    // necessary to check the state of ICD_DAYTIME which was set by DateTimeOnInitDialog().

    if ((SetupInitComponent.SetupData.OperationFlags & SETUPOP_BATCH) && gUnattenedTimeZone != -1) {
       // This is unattended.

       AllowAutoDST = IsDlgButtonChecked( ghWnd, IDC_DAYLIGHT ) != 0;
    }
    else
    {
       // This is NOT UNATTENDED. SelectedDate was initialized when PSN_WIZNEXT
       // was processed.

       SysTime.wYear        = SelectedDate.wYear;
       SysTime.wMonth       = SelectedDate.wMonth;
       SysTime.wDayOfWeek   = SelectedDate.wDayOfWeek;
       SysTime.wDay         = SelectedDate.wDay;
    }

    // Function SetLocalTime uses Time Zone information so it is IMPERATIVE that
    // SetTheTimezone get called before SetLocalTime.

    SetTheTimezone( AllowAutoDST, CurrZone );

    SetLocalTime( &SysTime );

}


void
DateTimeCommitChanges(
    void
    )
{
    return;
}



/////////////////////////////////////////////////////////////////////////////
//++
//
// GetTimeZoneReferenceIndexFromRegistry
//
// Routine Description:
//    This funecion extracts the Time Zone reference index from information that
//    is stored in the registry.
//
// Arguments:
//    None
//
// Return Value:
//    The Time Zone reference index. If no valid reference index is deduced
//    this function will return zero.
//
// Note:
//    The logic performed by the following function was originally implemented in
//    DateTimeOnInitDialog.
//
//--
/////////////////////////////////////////////////////////////////////////////

int GetTimeZoneReferenceIndexFromRegistry( void )
{
   int   xReferenceIndex;

   HKEY hKey;

   // Attempt to open the Time Zones registry key.

   if ( RegOpenKey( HKEY_LOCAL_MACHINE, REGKEY_TIMEZONES, &hKey ) == ERROR_SUCCESS )
   {
      // The following call to RegQueryValueEx retrieves the size, in bytes, of
      // the IndexMapping registry value, in parameter "index".

      int   xIndexMapSize;

      if ( RegQueryValueEx( hKey, REGVAL_TZ_INDEXMAP, 0, NULL, NULL,
                            (LPDWORD) &xIndexMapSize ) == ERROR_SUCCESS )
      {
         // Allocate memory for the IndexMap registry value.

         LPWSTR wszIndexMap;

         wszIndexMap = (LPWSTR) LocalAlloc( LPTR, xIndexMapSize );

         // Was a buffer allocated successfully?

         if ( wszIndexMap != (LPWSTR) NULL )
         {
            // This call to RegQueryValueEx retrieves the IndexMap value into
            // the buffer, wszIndexMap.

            if ( RegQueryValueEx( hKey, REGVAL_TZ_INDEXMAP, 0, NULL,
                                  (LPBYTE) wszIndexMap,
                                  (LPDWORD) &xIndexMapSize ) == ERROR_SUCCESS )
            {
               // Get the language identifier.

               WCHAR wszLangStr[32];

               if ( GetLocaleInfo( LOCALE_USER_DEFAULT,
                                   LOCALE_ILANGUAGE, wszLangStr,
                                   sizeof( wszLangStr )/sizeof( WCHAR ) ) > 0 )
               {
                  LPWSTR lang = wszLangStr;

                  LPWSTR map = wszIndexMap;

                  while ( *lang == L'0' ) lang++;

                  while ( *map )
                  {
                     if ( _wcsicmp( lang, map ) == 0 )
                     {
                        while ( *map ) map++;

                        map++;

                        xReferenceIndex = _wtol( map );

                        break;
                     }

                     while ( *map ) map++;

                     map++;

                     while ( *map ) map++;

                     map++;
                  }      // end of while loop
               }      // language identifier obtained?
            }      // IndexMapping reg value queried?

            LocalFree( wszIndexMap );
         }   // memory allocated for ImageMap reg value retrieval?
         else
         {
            xReferenceIndex = 0;
         }   // memory allocated for ImageMap reg value retrieval?
      }   // Size of ImageMap obtained?
      else
      {
         xReferenceIndex = 0;
      }   // Size of ImageMap obtained?

      RegCloseKey( hKey );
   }   // TimeZones reg key opened?
   else
   {
      xReferenceIndex = 0;
   }   // TimeZones reg key opened?

   return ( xReferenceIndex );
}



BOOL
DateTimeOnInitDialog(
                    IN HWND hwnd,
                    IN HWND hwndFocus,
                    IN LPARAM lParam
                    )
{
   PLIST_ENTRY NextZone;
   PTZINFO zone;
   HWND combo;
   WCHAR LangStr[32];
   int DesiredZone = 0;
   int index;
   HKEY hKey;
   LPWSTR IndexMap;

   ghWnd = hwnd;           // initialize the global copy of the handle to the
                           // wizard page. ghWnd is used by DateTimeCommitChanges()
                           // during unattended setup.

   SetTimer( hwnd, TIMER_ID, OPEN_TLEN, 0 );

   if ( (SetupInitComponent.SetupData.OperationFlags & SETUPOP_BATCH) && gUnattenedTimeZone != -1 )
   {
      //
      // We've got an unattended time zone value
      //

      // If everything were perfect DesiredZone will exactly match the ReferenceIndex
      // member of one of the TZINFO structures in ZoneList. Note that ZoneList was
      // built by BuildTimeZoneList.

      DesiredZone = gUnattenedTimeZone;
   }
   else
   {
      //
      // Base the default zone on the locale
      //

      // Extract the reference index for the desired time zone from the registry.

      DesiredZone = GetTimeZoneReferenceIndexFromRegistry();
   }  // Time zone specified in unattended setup answer file?
#if MYDEBUG
         DebugPrint(( L"DesiredZone = %03d", DesiredZone ));
#endif


   combo = GetDlgItem( hwnd, IDC_TIMEZONE );

   SetWindowRedraw( combo, FALSE );

   PTZINFO pTimeZoneInfo = (PTZINFO) NULL;

   // Note that ZoneList was built by BuildTimeZoneList.

   NextZone = ZoneList.Flink;

   if ( NextZone )
   {
      // Add time zones to the combo box.

      while ( NextZone != &ZoneList )
      {
         zone = CONTAINING_RECORD( NextZone, TZINFO, ListEntry );
         NextZone = zone->ListEntry.Flink;

         index = ComboBox_AddString( combo, zone->szDisplayName );

#if MYDEBUG
         DebugPrint(( L"%03d,%03d  %s", index, zone->ReferenceIndex, zone->szDisplayName ));
#endif

         if ( index < 0 )
         {
            break;
         }

         ComboBox_SetItemData( combo, index, (LPARAM)zone );

         if ( DesiredZone == zone->ReferenceIndex )
         {
            pTimeZoneInfo = zone;
#if MYDEBUG
            DebugPrint(( L"    Found DesiredZone" ));
#endif

         }
      }     // end of while loop
   }

   // Was a time zone that matched DesiredZone identified?

   if ( pTimeZoneInfo != (PTZINFO) NULL )
   {
      // Set the GLOBAL Time Zone Info structure pointer.

      CurrZone = pTimeZoneInfo;
   }
   else
   {
      // The fact that pTimeZoneInfo remained unchanged from its' initialized state
      // means that DesiredZone is not meaningfull.

      // Was DesiredZone obtained from the unattended setup answer file?

      if ( gUnattenedTimeZone != -1 )
      {
         // DesiredZone was obtained from the answer file. Since it is not meaningfull,
         // attempt to deduce it from registry information. Deducing DesiredZone from
         // information in the registry is the default action for ATTENDED setup.

         DesiredZone = GetTimeZoneReferenceIndexFromRegistry();
      }  // Was DesiredZone obtained from the answer file?

      // Is DesiredZone meaningfull now?

      if ( DesiredZone != 0 )
      {
         // Scan the list of Time Zones for one that matches DesiredZone.

         NextZone = ZoneList.Flink;

         if ( NextZone )
         {
            while ( NextZone != &ZoneList )
            {
               zone = CONTAINING_RECORD( NextZone, TZINFO, ListEntry );

               NextZone = zone->ListEntry.Flink;

#if MYDEBUG
               DebugPrint(( L"%03d,%03d  %s", index, zone->ReferenceIndex, zone->szDisplayName ));
#endif

               if ( DesiredZone == zone->ReferenceIndex )
               {
                  pTimeZoneInfo = zone;
               }
            }   // end of while loop
         }  // Is NextZone legal?
      }  // Is DesiredZone meaningfull now?

      // Was a time zone that matched DesiredZone identified?

      Assert( pTimeZoneInfo != (PTZINFO) NULL );

      if ( pTimeZoneInfo != (PTZINFO) NULL )
      {
         // Set the GLOBAL Time Zone Info structure pointer.

         CurrZone = pTimeZoneInfo;
      }
      else
      {
         // Use the first Time Zone in the list as a default.

         CurrZone = CONTAINING_RECORD( ZoneList.Flink, TZINFO, ListEntry );
#if MYDEBUG
         DebugPrint(( L"Couldn't find default timzone" ));
#endif

      }  // Was a time zone that matched DesiredZone identified?

   }  // Was a time zone that matched DesiredZone identified?

   index = ComboBox_FindString( combo, 0, CurrZone->szDisplayName );
   if ( index == CB_ERR )
   {
      index = 0;
   }

   ComboBox_SetCurSel( combo, index );

   EnableWindow( GetDlgItem( hwnd, IDC_DAYLIGHT ), CurrZone->StandardDate.wMonth != 0 );
   CheckDlgButton( hwnd, IDC_DAYLIGHT, GetAllowLocalTimeChange() );

   SetWindowRedraw(combo, TRUE);

   return FALSE;
}


BOOL
DateTimeOnCommand(
    IN HWND hwnd,
    IN DWORD NotifyCode,
    IN DWORD ControlId,
    IN HWND hwndControl
    )
{
    if (NotifyCode == CBN_SELCHANGE && ControlId == IDC_TIMEZONE) {
        CurrZone = (PTZINFO) ComboBox_GetItemData( hwndControl, ComboBox_GetCurSel( hwndControl ) );
        EnableWindow( GetDlgItem( hwnd, IDC_DAYLIGHT ), CurrZone->StandardDate.wMonth != 0 );
        if (CurrZone->StandardDate.wMonth != 0) {
            CheckDlgButton( hwnd, IDC_DAYLIGHT, TRUE );
        } else {
            CheckDlgButton( hwnd, IDC_DAYLIGHT, FALSE );
        }
        return FALSE;
    }

    return TRUE;
}


BOOL
DateTimeOnNotify(
    IN HWND hwnd,
    IN WPARAM ControlId,
    IN LPNMHDR pnmh
    )
{
    switch( pnmh->code ) {
        case PSN_SETACTIVE:
            if (SetupInitComponent.SetupData.OperationFlags & SETUPOP_NTUPGRADE) {
                SetWindowLongPtr( hwnd, DWLP_MSGRESULT, -1 );
                return TRUE;
            }

            if ((SetupInitComponent.SetupData.OperationFlags & SETUPOP_BATCH) && DateTimeBadUnattend) {
                // No unattend value for time date in the unattend case.
                // make sure the wizard is shown.
                // note: When we get out here, only the next button is enabled.
                SetupInitComponent.HelperRoutines.ShowHideWizardPage(
                                        SetupInitComponent.HelperRoutines.OcManagerContext,
                                        TRUE);
                return FALSE;
            }

            if ((SetupInitComponent.SetupData.OperationFlags & SETUPOP_BATCH) && gUnattenedTimeZone != -1) {
                //
                // we're in unattend mode
                //
                DateTimeApplyChanges();
                SetWindowLongPtr( hwnd, DWLP_MSGRESULT, -1 );
                return TRUE;
            }

            // If we get here the user needs  has click next or back.
            // Make sure the wizard page is showing.
            // For Whistler GUI mode we try to hide wizard pages and show a background
            // billboard if there is only a progress bar.
            //
            SetupInitComponent.HelperRoutines.ShowHideWizardPage(
                                        SetupInitComponent.HelperRoutines.OcManagerContext,
                                        TRUE);

            PropSheet_SetWizButtons(GetParent(hwnd), PSWIZB_BACK | PSWIZB_NEXT);

            break;

        case DTN_DATETIMECHANGE:
            if (ControlId == IDC_TIME_PICKER) {
                KillTimer( hwnd, TIMER_ID );
                ChangeTime = TRUE;
            } else if (ControlId == IDC_DATE_PICKER) {
                ChangeDate = TRUE;
            }
            break;

        case PSN_WIZNEXT:
            SendDlgItemMessage( hwnd, IDC_TIME_PICKER, DTM_GETSYSTEMTIME, 0, (LPARAM)&SelectedTime );
            SendDlgItemMessage( hwnd, IDC_DATE_PICKER, DTM_GETSYSTEMTIME, 0, (LPARAM)&SelectedDate );
            AllowAutoDST = IsDlgButtonChecked( hwnd, IDC_DAYLIGHT ) != 0;
            DateTimeApplyChanges();
            break;
    }

    return FALSE;
}


BOOL
DateTimeOnTimer(
    IN HWND hwnd
    )
{
    SYSTEMTIME CurrTime;
    GetLocalTime( &CurrTime );
    SendDlgItemMessage( hwnd, IDC_TIME_PICKER, DTM_SETSYSTEMTIME, GDT_VALID, (LPARAM)&CurrTime );
    return FALSE;
}


LRESULT
DateTimeDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{

    CommonWizardProc( hwnd, message, wParam, lParam, WizPageDateTime );

    switch( message ) {
        case WM_INITDIALOG:
            return DateTimeOnInitDialog( hwnd, (HWND)wParam, lParam );

        case WM_COMMAND:
            return DateTimeOnCommand( hwnd, HIWORD(wParam), LOWORD(wParam), (HWND)lParam );

        case WM_TIMER:
            return DateTimeOnTimer( hwnd );

        case WM_NOTIFY:
            return DateTimeOnNotify( hwnd, wParam, (LPNMHDR) lParam );
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ntoc\registry.cpp ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    registry.c

Abstract:

    This module provides a generic table driven access
    to the registry.

Author:

    Wesley Witt (wesw) 9-June-1996


Revision History:

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>

#define StringSize(_s) (( _s ) ? (_tcslen( _s ) + 1) * sizeof(TCHAR) : 0)


LPTSTR
StringDup(
    LPTSTR String
    )
{
    LPTSTR NewString;

    if (!String) {
        return NULL;
    }

    NewString = (LPTSTR) LocalAlloc( LPTR, (_tcslen( String ) + 1) * sizeof(TCHAR) );
    if (!NewString) {
        return NULL;
    }

    _tcscpy( NewString, String );

    return NewString;
}


HKEY
OpenRegistryKey(
    HKEY hKey,
    LPTSTR KeyName,
    BOOL CreateNewKey,
    REGSAM SamDesired
    )
{
    LONG    Rslt;
    HKEY    hKeyNew;
    DWORD   Disposition;


    if (CreateNewKey) {
        Rslt = RegCreateKeyEx(
            hKey,
            KeyName,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            SamDesired == 0 ? KEY_ALL_ACCESS : SamDesired,
            NULL,
            &hKeyNew,
            &Disposition
            );
        if (Rslt != ERROR_SUCCESS) {
            //
            // could not open the registry key
            //
            return NULL;
        }

    } else {
        Rslt = RegOpenKeyEx(
            hKey,
            KeyName,
            0,
            SamDesired == 0 ? KEY_ALL_ACCESS : SamDesired,
            &hKeyNew
            );
        if (Rslt != ERROR_SUCCESS) {
            //
            // could not open the registry key
            //
            return NULL;
        }
    }

    return hKeyNew;
}


LPTSTR
GetRegistryStringValue(
    HKEY hKey,
    DWORD RegType,
    LPTSTR ValueName,
    LPTSTR DefaultValue
    )
{
    BOOL    Success = FALSE;
    DWORD   Size;
    LONG    Rslt;
    DWORD   Type;
    LPBYTE  Buffer = NULL;
    LPBYTE  ExpandBuffer = NULL;


    Rslt = RegQueryValueEx(
        hKey,
        ValueName,
        NULL,
        &Type,
        NULL,
        &Size
        );
    if (Rslt != ERROR_SUCCESS) {
        if (Rslt == ERROR_FILE_NOT_FOUND) {
            Size = StringSize( DefaultValue );
        } else {
            goto exit;
        }
    }

    Buffer = (LPBYTE) LocalAlloc( LPTR, Size );
    if (!Buffer) {
        goto exit;
    }

    Rslt = RegQueryValueEx(
        hKey,
        ValueName,
        NULL,
        &Type,
        Buffer,
        &Size
        );
    if (Rslt != ERROR_SUCCESS) {
        if (Rslt != ERROR_FILE_NOT_FOUND) {
            goto exit;
        }
        //
        // create the value since it doesn't exist
        //
        _tcscpy( (LPTSTR) Buffer, DefaultValue );

        Rslt = RegSetValueEx(
            hKey,
            ValueName,
            0,
            RegType,
            Buffer,
            Size
            );
        if (Rslt != ERROR_SUCCESS) {
            //
            // could not set the registry value
            //
            goto exit;
        }
    }
    if (RegType == REG_EXPAND_SZ) {
        Rslt = ExpandEnvironmentStrings( (LPTSTR) Buffer, NULL, 0 );
        if (!Rslt) {
            goto exit;
        }

        ExpandBuffer = (LPBYTE) LocalAlloc( LPTR, (Rslt + 1) * sizeof(WCHAR) );
        if (!ExpandBuffer) {
            goto exit;
        }

        Rslt = ExpandEnvironmentStrings( (LPTSTR) Buffer, (LPTSTR) ExpandBuffer, Rslt );
        if (Rslt == 0) {
            LocalFree( ExpandBuffer );
            goto exit;
        }
        LocalFree( Buffer );
        Buffer = ExpandBuffer;
    }

    Success = TRUE;

exit:
    if (!Success) {
        LocalFree( Buffer );
        return StringDup( DefaultValue );
    }

    return (LPTSTR) Buffer;
}


LPTSTR
GetRegistryString(
    HKEY hKey,
    LPTSTR ValueName,
    LPTSTR DefaultValue
    )
{
    return GetRegistryStringValue( hKey, REG_SZ, ValueName, DefaultValue );
}


LPTSTR
GetRegistryStringExpand(
    HKEY hKey,
    LPTSTR ValueName,
    LPTSTR DefaultValue
    )
{
    return GetRegistryStringValue( hKey, REG_EXPAND_SZ, ValueName, DefaultValue );
}


DWORD
GetRegistryDword(
    HKEY hKey,
    LPTSTR ValueName
    )
{
    DWORD   Size = sizeof(DWORD);
    LONG    Rslt;
    DWORD   Type;
    DWORD   Value = 0;


    Rslt = RegQueryValueEx(
        hKey,
        ValueName,
        NULL,
        &Type,
        (LPBYTE) &Value,
        &Size
        );
    if (Rslt != ERROR_SUCCESS) {
        //
        // create the value since it doesn't exist
        //
        Value = 0;

        Rslt = RegSetValueEx(
            hKey,
            ValueName,
            0,
            REG_DWORD,
            (LPBYTE) &Value,
            Size
            );
        if (Rslt != ERROR_SUCCESS) {
            //
            // could not set the registry value
            //
            Value = 0;
        }
    }

    return Value;
}


DWORD
GetSubKeyCount(
    HKEY hKey
    )
{
    DWORD KeyCount = 0;
    LONG Rval;


    Rval = RegQueryInfoKey( hKey, NULL, NULL, NULL, &KeyCount, NULL, NULL, NULL, NULL, NULL, NULL, NULL );
    if (Rval != ERROR_SUCCESS) {
        return 0;
    }

    return KeyCount;
}


DWORD
GetMaxSubKeyLen(
    HKEY hKey
    )
{
    DWORD MaxSubKeyLen = 0;
    LONG Rval;


    Rval = RegQueryInfoKey( hKey, NULL, NULL, NULL, NULL, &MaxSubKeyLen, NULL, NULL, NULL, NULL, NULL, NULL );
    if (Rval != ERROR_SUCCESS) {
        return 0;
    }

    return MaxSubKeyLen;
}


BOOL
SetRegistryDword(
    HKEY hKey,
    LPTSTR ValueName,
    DWORD Value
    )
{
    LONG    Rslt;


    Rslt = RegSetValueEx(
        hKey,
        ValueName,
        0,
        REG_DWORD,
        (LPBYTE) &Value,
        sizeof(DWORD)
        );
    if (Rslt != ERROR_SUCCESS) {
        return FALSE;
    }

    return TRUE;
}


BOOL
SetRegistryStringValue(
    HKEY hKey,
    DWORD RegType,
    LPTSTR ValueName,
    LPTSTR Value,
    LONG Length
    )
{
    LONG    Rslt;


    Rslt = RegSetValueEx(
        hKey,
        ValueName,
        0,
        RegType,
        (LPBYTE) Value,
        Length == -1 ? StringSize( Value ) : Length
        );
    if (Rslt != ERROR_SUCCESS) {
        return FALSE;
    }

    return TRUE;
}


BOOL
SetRegistryString(
    HKEY hKey,
    LPTSTR ValueName,
    LPTSTR Value
    )
{
    return SetRegistryStringValue( hKey, REG_SZ, ValueName, Value, -1 );
}


BOOL
SetRegistryStringExpand(
    HKEY hKey,
    LPTSTR ValueName,
    LPTSTR Value
    )
{
    return SetRegistryStringValue( hKey, REG_EXPAND_SZ, ValueName, Value, -1 );
}


BOOL
SetRegistryStringMultiSz(
    HKEY hKey,
    LPTSTR ValueName,
    LPTSTR Value,
    DWORD Length
    )
{
    return SetRegistryStringValue( hKey, REG_MULTI_SZ, ValueName, Value, Length );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ntoc\ntoc.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    ntoc.cpp

Abstract:

    This file implements the NT OC Manager DLL.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 7-Aug-1997

--*/

#include "ntoc.h"
#pragma hdrstop


//
// types
//

typedef void (*PWIZINIT)(void);
typedef void (*PWIZCOMMIT)(void);

//
// structures
//

typedef struct _WIZPAGE {
    DWORD           ButtonState;
    DWORD           PageId;
    DWORD           DlgId;
    DLGPROC         DlgProc;
    DWORD           Title;
    DWORD           SubTitle;
    DWORD           WizPageType;
    PWIZINIT        WizInit;
    PWIZCOMMIT      WizCommit;
    DWORDLONG       Modes;            
} WIZPAGE, *PWIZPAGE;


//
// globals
//

WIZPAGE SetupWizardPages[WizPageMaximum] =
{    
    {
        PSWIZB_NEXT,
        WizPageTapiLoc,
        IDD_TAPI_LOCATIONS,
        (DLGPROC)TapiLocDlgProc,
        IDS_TAPILOC_TITLE,
        IDS_TAPILOC_SUBTITLE,
        WizPagesEarly,
        TapiInit,
        TapiCommitChanges,
        -1
    },
/*
    {
        PSWIZB_NEXT,
        WizPageDisplay,
        IDD_DISPLAY,
        (DLGPROC)DisplayDlgProc,
        IDS_DISPLAY_TITLE,
        IDS_DISPLAY_SUBTITLE,
        WizPagesEarly,
        DisplayInit,
        DisplayCommitChanges,
        -1
    },
*/
    {
        PSWIZB_NEXT,
        WizPageDateTime,
        IDD_DATETIME,
        (DLGPROC)DateTimeDlgProc,
        IDS_DATETIME_TITLE,
        IDS_DATETIME_SUBTITLE,
        WizPagesEarly,
        DateTimeInit,
        DateTimeCommitChanges,
        -1
    },

    {
        PSWIZB_NEXT,
        WizPageWelcome,
        IDD_NTOC_WELCOME,
        (DLGPROC)WelcomeDlgProc,
        0,
        0,
        WizPagesWelcome,
        WelcomeInit,
        WelcomeCommit,
        SETUPOP_STANDALONE
    },
/*
    {
        PSWIZB_NEXT,
        WizPageReinstall,
        IDD_REINSTALL,
        (DLGPROC)ReinstallDlgProc,
        0,
        0,
        WizPagesEarly,
        ReinstallInit,
        ReinstallCommit,
        SETUPOP_STANDALONE
    },
*/
    {
        PSWIZB_FINISH,
        WizPageFinal,
        IDD_NTOC_FINISH,
        (DLGPROC)FinishDlgProc,
        0,
        0,
        WizPagesFinal,
        FinishInit,
        FinishCommit,
        SETUPOP_STANDALONE
    }

};


DWORD NtOcWizardPages[] =
{
    WizPageTapiLoc,
    // WizPageDisplay,
    WizPageDateTime,
    WizPageWelcome,
    //WizPageReinstall,
    WizPageFinal

};

//DWORD NtOcWrapPages[] =
//{
//}

#define MAX_NTOC_PAGES (sizeof(NtOcWizardPages)/sizeof(NtOcWizardPages[0]))
//#define MAX_NTOC_WRAP_PAGES (sizeof(NtOcWrapPages)/sizeof(NtOcWrapPages[0]))


HINSTANCE hInstance;
HPROPSHEETPAGE WizardPageHandles[WizPageMaximum];
PROPSHEETPAGE WizardPages[WizPageMaximum];
//HPROPSHEETPAGE WrapPageHandles[WizPageMaximum];
//PROPSHEETPAGE WizardPages[WizPageMaximum];
SETUP_INIT_COMPONENT SetupInitComponent;




extern "C"
DWORD
NtOcDllInit(
    HINSTANCE hInst,
    DWORD     Reason,
    LPVOID    Context
    )
{
    if (Reason == DLL_PROCESS_ATTACH) {
        hInstance = hInst;
        DisableThreadLibraryCalls( hInstance );
        InitCommonControls();
    }

    return TRUE;
}


DWORD
NtOcSetupProc(
    IN LPCVOID ComponentId,
    IN LPCVOID SubcomponentId,
    IN UINT Function,
    IN UINT Param1,
    IN OUT PVOID Param2
    )
{
    DWORD i;
    DWORD cnt;
    DWORD WizPageCount = 0;
    WCHAR TitleBuffer[256];
    PSETUP_REQUEST_PAGES SetupRequestPages;


    switch( Function ) {
        case OC_PREINITIALIZE:
            return OCFLAG_UNICODE;

        case OC_INIT_COMPONENT:
            if (OCMANAGER_VERSION <= ((PSETUP_INIT_COMPONENT)Param2)->OCManagerVersion) {
                ((PSETUP_INIT_COMPONENT)Param2)->ComponentVersion = OCMANAGER_VERSION;
            } else {
                return ERROR_CALL_NOT_IMPLEMENTED;
            }
            CopyMemory( &SetupInitComponent, (LPVOID)Param2, sizeof(SETUP_INIT_COMPONENT) );
            for (i=0; i<MAX_NTOC_PAGES; i++) {
                if (SetupWizardPages[NtOcWizardPages[i]].WizInit &&
                     (SetupWizardPages[NtOcWizardPages[i]].Modes & 
                     SetupInitComponent.SetupData.OperationFlags)) {
                    SetupWizardPages[NtOcWizardPages[i]].WizInit();
                }
            }
            if ((SetupInitComponent.SetupData.OperationFlags & SETUPOP_STANDALONE)) {
                        if (!RunningAsAdministrator()) {
                                FmtMessageBox(NULL,
                                          MB_ICONINFORMATION | MB_OK | MB_SETFOREGROUND,
                                          FALSE,
                                              ID_DSP_TXT_CHANGE_SETTINGS,
                                          ID_DSP_TXT_ADMIN_CHANGE);
                        return ERROR_CANCELLED;
                        }       
            }
            return 0;

        case OC_REQUEST_PAGES:

            SetupRequestPages = (PSETUP_REQUEST_PAGES) Param2;

            //
            // if this isn't gui-mode setup, then let's supply the welcome and finish pages
            //
            // Note that this code path "short circuits" inside this if statement
            //
            if ((SetupInitComponent.SetupData.OperationFlags & SETUPOP_STANDALONE)) {

                switch (Param1) {
                    case WizPagesWelcome:                    
                        i = WizPageWelcome;
                        cnt = 1;
                        break;
                    case WizPagesFinal:
                        cnt = 1;
                        i = WizPageFinal;
                        break;
//                  case WizPagesEarly:
//                      cnt = 1;
//                      i = WizPageReinstall;
//                      break;
                    default:
                        cnt = 0;
                        i = 0;
                        break;
                }

                if (cnt > SetupRequestPages->MaxPages) {
                    return cnt;
                }

                if (cnt == 0) {
                    goto getallpages;
                }
               

                WizardPages[WizPageCount].dwSize             = sizeof(PROPSHEETPAGE);
//                if (i == WizPageReinstall) {
//                    WizardPages[WizPageCount].dwFlags            = PSP_DEFAULT | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
//                } else {
                    WizardPages[WizPageCount].dwFlags            = PSP_DEFAULT | PSP_HIDEHEADER;
//                }
                WizardPages[WizPageCount].hInstance          = hInstance;
                WizardPages[WizPageCount].pszTemplate        = MAKEINTRESOURCE(SetupWizardPages[NtOcWizardPages[i]].DlgId);
                WizardPages[WizPageCount].pszIcon            = NULL;
                WizardPages[WizPageCount].pszTitle           = NULL;
                WizardPages[WizPageCount].pfnDlgProc         = SetupWizardPages[NtOcWizardPages[i]].DlgProc;
                WizardPages[WizPageCount].lParam             = 0;
                WizardPages[WizPageCount].pfnCallback        = NULL;
                WizardPages[WizPageCount].pcRefParent        = NULL;

                WizardPages[WizPageCount].pszHeaderTitle     = NULL;
                WizardPages[WizPageCount].pszHeaderSubTitle  = NULL;

                if (SetupWizardPages[NtOcWizardPages[i]].Title) {
                    if (LoadString(
                            hInstance,
                            SetupWizardPages[NtOcWizardPages[i]].Title,
                            TitleBuffer,
                            sizeof(TitleBuffer)/sizeof(WCHAR)
                            ))
                    {
                        WizardPages[WizPageCount].pszHeaderTitle = _wcsdup( TitleBuffer );
                    }
                }

                if (SetupWizardPages[NtOcWizardPages[i]].SubTitle) {
                    if (LoadString(
                            hInstance,
                            SetupWizardPages[NtOcWizardPages[i]].SubTitle,
                            TitleBuffer,
                            sizeof(TitleBuffer)/sizeof(WCHAR)
                            ))
                    {
                        WizardPages[WizPageCount].pszHeaderSubTitle = _wcsdup( TitleBuffer );
                    }
                }

                WizardPageHandles[WizPageCount] = CreatePropertySheetPage( &WizardPages[WizPageCount] );
                if (WizardPageHandles[WizPageCount]) {
                    SetupRequestPages->Pages[WizPageCount] = WizardPageHandles[WizPageCount];
                    WizPageCount += 1;
                }

                return WizPageCount;


            }

getallpages:
            for (i=0,cnt=0; i<MAX_NTOC_PAGES; i++) {
                
                if ((SetupWizardPages[NtOcWizardPages[i]].WizPageType == Param1) &&
                    (SetupInitComponent.SetupData.OperationFlags & SetupWizardPages[NtOcWizardPages[i]].Modes)) {
                    cnt += 1;
                }

            }

            // if this is not gui mode setup, don't display pages

            if ((SetupInitComponent.SetupData.OperationFlags & SETUPOP_STANDALONE)) {
                cnt = 0;
            }

            if (cnt == 0) {
                return cnt;
            }

            if (cnt > SetupRequestPages->MaxPages) {
                return cnt;
            }

            for (i=0; i<MAX_NTOC_PAGES; i++) {
                if ((SetupWizardPages[NtOcWizardPages[i]].WizPageType != Param1) &&
                    (SetupInitComponent.SetupData.OperationFlags & SetupWizardPages[NtOcWizardPages[i]].Modes) == 0) {
                    continue;
                }

                WizardPages[WizPageCount].dwSize             = sizeof(PROPSHEETPAGE);
                WizardPages[WizPageCount].dwFlags            = PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE;
                WizardPages[WizPageCount].hInstance          = hInstance;
                WizardPages[WizPageCount].pszTemplate        = MAKEINTRESOURCE(SetupWizardPages[NtOcWizardPages[i]].DlgId);
                WizardPages[WizPageCount].pszIcon            = NULL;
                WizardPages[WizPageCount].pszTitle           = NULL;
                WizardPages[WizPageCount].pfnDlgProc         = SetupWizardPages[NtOcWizardPages[i]].DlgProc;
                WizardPages[WizPageCount].lParam             = 0;
                WizardPages[WizPageCount].pfnCallback        = NULL;
                WizardPages[WizPageCount].pcRefParent        = NULL;
                WizardPages[WizPageCount].pszHeaderTitle     = NULL;
                WizardPages[WizPageCount].pszHeaderSubTitle  = NULL;

                if (SetupWizardPages[NtOcWizardPages[i]].Title) {
                    if (LoadString(
                            hInstance,
                            SetupWizardPages[NtOcWizardPages[i]].Title,
                            TitleBuffer,
                            sizeof(TitleBuffer)/sizeof(WCHAR)
                            ))
                    {
                        WizardPages[WizPageCount].pszHeaderTitle = _wcsdup( TitleBuffer );
                    }
                }

                if (SetupWizardPages[NtOcWizardPages[i]].SubTitle) {
                    if (LoadString(
                            hInstance,
                            SetupWizardPages[NtOcWizardPages[i]].SubTitle,
                            TitleBuffer,
                            sizeof(TitleBuffer)/sizeof(WCHAR)
                            ))
                    {
                        WizardPages[WizPageCount].pszHeaderSubTitle = _wcsdup( TitleBuffer );
                    }
                }

                WizardPageHandles[WizPageCount] = CreatePropertySheetPage( &WizardPages[WizPageCount] );
                if (WizardPageHandles[WizPageCount]) {
                    SetupRequestPages->Pages[WizPageCount] = WizardPageHandles[WizPageCount];
                    WizPageCount += 1;
                }
            }

            return WizPageCount;

        case OC_QUERY_SKIP_PAGE:
            
            // if this is gui mode setup and the system is NT Workstation, 
            // skip the select components page

            if (SetupInitComponent.SetupData.ProductType == PRODUCT_WORKSTATION) {
                if (!(SetupInitComponent.SetupData.OperationFlags & SETUPOP_STANDALONE)) {
                    return TRUE;
                }
            }

            return FALSE;

        case OC_COMPLETE_INSTALLATION:

            // if this is not gui mode setup, do nothing, else commit the pages

            if ((SetupInitComponent.SetupData.OperationFlags & SETUPOP_STANDALONE)) {
                break;
            }

            for (i=0; i<MAX_NTOC_PAGES; i++) {
                if (SetupWizardPages[NtOcWizardPages[i]].WizCommit) {
                    SetupWizardPages[NtOcWizardPages[i]].WizCommit();
                }
            }
            break;

        case OC_QUERY_STATE:

            // we are always installed
                        
            return SubcompOn;
                        
        default:
            break;
    }

    return 0;
}

/*---------------------------------------------------------------------------*\
  Function: RunningAsAdministrator()
|*---------------------------------------------------------------------------*|
  Description: Checks whether we are running as administrator on the machine
  or not
\*---------------------------------------------------------------------------*/
BOOL 
RunningAsAdministrator(
        VOID
        )
{
#ifdef _CHICAGO_
    return TRUE;
#else
    BOOL   fAdmin;
    HANDLE  hThread;
    TOKEN_GROUPS *ptg = NULL;
    DWORD  cbTokenGroups;
    DWORD  dwGroup;
    PSID   psidAdmin;
    
    SID_IDENTIFIER_AUTHORITY SystemSidAuthority= SECURITY_NT_AUTHORITY;
    
    // First we must open a handle to the access token for this thread.
    
    if ( !OpenThreadToken ( GetCurrentThread(), TOKEN_QUERY, FALSE, &hThread))
    {
        if ( GetLastError() == ERROR_NO_TOKEN)
        {
            // If the thread does not have an access token, we'll examine the
            // access token associated with the process.
            
            if (! OpenProcessToken ( GetCurrentProcess(), TOKEN_QUERY, 
                         &hThread))
                return ( FALSE);
        }
        else 
            return ( FALSE);
    }
    
    // Then we must query the size of the group information associated with
    // the token. Note that we expect a FALSE result from GetTokenInformation
    // because we've given it a NULL buffer. On exit cbTokenGroups will tell
    // the size of the group information.
    
    if ( GetTokenInformation ( hThread, TokenGroups, NULL, 0, &cbTokenGroups))
        return ( FALSE);
    
    // Here we verify that GetTokenInformation failed for lack of a large
    // enough buffer.
    
    if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER)
        return ( FALSE);
    
    // Now we allocate a buffer for the group information.
    // Since _alloca allocates on the stack, we don't have
    // to explicitly deallocate it. That happens automatically
    // when we exit this function.
    
    if ( ! ( ptg= (TOKEN_GROUPS *)malloc ( cbTokenGroups))) 
        return ( FALSE);
    
    // Now we ask for the group information again.
    // This may fail if an administrator has added this account
    // to an additional group between our first call to
    // GetTokenInformation and this one.
    
    if ( !GetTokenInformation ( hThread, TokenGroups, ptg, cbTokenGroups,
          &cbTokenGroups) )
    {
        free(ptg);
        return ( FALSE);
    }
    
    // Now we must create a System Identifier for the Admin group.
    
    if ( ! AllocateAndInitializeSid ( &SystemSidAuthority, 2, 
            SECURITY_BUILTIN_DOMAIN_RID, 
            DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0, &psidAdmin) )
    {
        free(ptg);
        return ( FALSE);
    }
    
    // Finally we'll iterate through the list of groups for this access
    // token looking for a match against the SID we created above.
    
    fAdmin= FALSE;
    
    for ( dwGroup= 0; dwGroup < ptg->GroupCount; dwGroup++)
    {
        if ( EqualSid ( ptg->Groups[dwGroup].Sid, psidAdmin))
        {
            fAdmin = TRUE;
            
            break;
        }
    }
    
    // Before we exit we must explicity deallocate the SID we created.
    
    FreeSid ( psidAdmin);
    free(ptg);
    
    return ( fAdmin);
#endif //_CHICAGO_
}



LRESULT
CommonWizardProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam,
    DWORD   WizardId
    )

/*++

Routine Description:

    Common procedure for handling wizard pages:

Arguments:

    hDlg - Identifies the wizard page
    message - Specifies the message
    wParam - Specifies additional message-specific information
    lParam - Specifies additional message-specific information
    WizardId - Indicate which wizard page this is for

Return Value:

    NULL - Message is processed and the dialog procedure should return FALSE
    Otherwise - Message is not completely processed and
        The return value is a pointer to the user mode memory structure

--*/

{

    switch (message) {

    case WM_NOTIFY:

        switch (((NMHDR *) lParam)->code) {

            case PSN_SETACTIVE:
                PropSheet_SetWizButtons( GetParent(hDlg), 
                                         SetupWizardPages[WizardId].ButtonState
                                       );
            break;

            default:
                ;
                
        }

        break;

    default:
        ;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ntoc\resource.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    resource.h

Abstract:

    This file contains all manafest contants for the NTOC resource file.

Author:

    Wesley Witt (wesw) 7-Aug-1997

Environment:

    User Mode

--*/

#define WIZARD_WIDTH                         304
#define WIZARD_HEIGTH                        140

#define IDC_STATIC                           -1

#define IDD_TAPI_LOCATIONS                   501
#define IDD_DISPLAY                          502
#define IDD_DATETIME                         503
#define IDD_NTOC_WELCOME                     504
#define IDD_NTOC_FINISH                      505
#define IDD_REINSTALL                        506

#define IDC_COUNTRY_LIST                     201
#define IDC_AREA_CODE                        202
#define IDC_LONG_DISTANCE                    203
#define IDC_TONE                             204
#define IDC_PULSE                            205
#define IDC_SCREENSAMPLE                     206
#define IDC_DSP_CLRPALGRP                    207
#define IDC_DSP_COLORBOX                     208
#define IDC_DSP_COLORBAR                     209
#define IDC_DSP_DSKAREAGRP                   210
#define IDC_DSP_AREA_SB                      211
#define IDC_DSP_X_BY_Y                       212
#define IDC_DSP_FONTSIZEGRP                  213
#define IDC_DSP_FONTSIZE                     214
#define IDC_DSP_REFFREQGRP                   215
#define IDC_DSP_FREQ                         216
#define IDC_DSP_LIST_ALL                     217
#define IDC_DSP_TEST                         218
#define IDC_DSP_CHANGE                       219
#define IDC_MONITOR_BITMAP                   220
#define IDC_TEST                             221
#define IDC_DATE_PICKER                      222
#define IDC_TIME_PICKER                      223
#define IDC_TIMEZONE                         224
#define IDC_DAYLIGHT                         225
#define IDC_REFRESH_RATE                     226
#define IDT_TITLE                            227

#define IDS_TAPILOC_TITLE                    301
#define IDS_TAPILOC_SUBTITLE                 302
#define IDS_DISPLAY_TITLE                    303
#define IDS_DISPLAY_SUBTITLE                 304
#define IDS_RESOLUTION_FMT                   305
#define IDS_COLOR_RED                        306
#define IDS_COLOR_GREEN                      307
#define IDS_COLOR_BLUE                       308
#define IDS_COLOR_YELLOW                     309
#define IDS_COLOR_MAGENTA                    310
#define IDS_COLOR_CYAN                       311
#define IDS_COLOR_WHITE                      312
#define IDS_RED_SHADES                       313
#define IDS_GREEN_SHADES                     314
#define IDS_BLUE_SHADES                      315
#define IDS_GRAY_SHADES                      316
#define IDS_PATTERN_HORZ                     317
#define IDS_PATTERN_VERT                     318
#define IDS_UNAVAILABLE                      319
#define IDS_DATETIME_TITLE                   320
#define IDS_DATETIME_SUBTITLE                321
#define IDS_DEFAULT_LOCATION_NAME            322
#define IDS_LARGEFONT_NAME                   323
#define IDS_LARGEFONT_SIZE                   324


//#define IDB_MONITOR_BITMAP                   401
//#define IDB_COLORBAR_BITMAP                  402

#define IDI_DATE                             601
#define IDI_TIMEZONE                         602
#define IDI_MODEM                            603
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ocmanage\common\dll.c ===
#include "precomp.h"
#pragma hdrstop


HMODULE MyModuleHandle;

//
// Called by CRT when _DllMainCRTStartup is the DLL entry point
//
BOOL
WINAPI
DllMain(
    IN HANDLE DllHandle,
    IN DWORD  Reason,
    IN LPVOID Reserved
    )
{
    BOOL b;

    UNREFERENCED_PARAMETER(Reserved);

    b = TRUE;

    switch(Reason) {

    case DLL_PROCESS_ATTACH:
        InitCommonControls();
        MyModuleHandle = DllHandle;
        //
        // Fall through to process first thread
        //

    case DLL_THREAD_ATTACH:

        break;

    case DLL_PROCESS_DETACH:

        break;

    case DLL_THREAD_DETACH:

        break;
    }

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ntoc\util.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    util.cpp

Abstract:

    This file implements utility functions.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 3-Dec-1997

--*/

#include "ntoc.h"
#pragma hdrstop

WCHAR gpszError[] = L"Unknown Error";

void
dprintf(
    LPTSTR Format,
    ...
    )

/*++

Routine Description:

    Prints a debug string

Arguments:

    format      - printf() format string
    ...         - Variable data

Return Value:

    None.

--*/

{
    WCHAR buf[1024];
    DWORD len;
    va_list arg_ptr;


    va_start(arg_ptr, Format);

    _vsnwprintf(buf, sizeof(buf)/sizeof(buf[0]), Format, arg_ptr);

    len = wcslen( buf );
    if (buf[len-1] != L'\n') {
        buf[len] = L'\r';
        buf[len+1] = L'\n';
        buf[len+2] = 0;
    }

    OutputDebugString( buf );
}


VOID
AssertError(
    LPTSTR Expression,
    LPTSTR File,
    ULONG  LineNumber
    )

/*++

Routine Description:

    Thie function is use together with the Assert MACRO.
    It checks to see if an expression is FALSE.  if the
    expression is FALSE, then you end up here.

Arguments:

    Expression  - The text of the 'C' expression
    File        - The file that caused the assertion
    LineNumber  - The line number in the file.

Return Value:

    None.

--*/

{
    dprintf(
        L"Assertion error: [%s]  %s @ %d\n",
        Expression,
        File,
        LineNumber
        );

    __try {
        DebugBreak();
    } __except (UnhandledExceptionFilter(GetExceptionInformation())) {
        // Nothing to do in here.
    }
}

/***************************************************************************\
*
*     FUNCTION: FmtMessageBox(HWND hwnd, int dwTitleID, UINT fuStyle,
*                   BOOL fSound, DWORD dwTextID, ...);
*
*     PURPOSE:  Formats messages with FormatMessage and then displays them
*               in a message box
*
*     PARAMETERS:
*               hwnd        - parent window for message box
*               fuStyle     - MessageBox style
*               fSound      - if TRUE, MessageBeep will be called with fuStyle
*               dwTitleID   - Message ID for optional title, "Error" will
*                             be displayed if dwTitleID == -1
*               dwTextID    - Message ID for the message box text
*               ...         - optional args to be embedded in dwTextID
*                             see FormatMessage for more details
* History:
* 22-Apr-1993 JonPa         Created it.
\***************************************************************************/
int
FmtMessageBox(
    HWND hwnd,
    UINT fuStyle,
    BOOL fSound,
    DWORD dwTitleID,
    DWORD dwTextID,
    ...
    )
{

    LPTSTR pszMsg;
    LPTSTR pszTitle;
    int idRet;

    va_list marker;

    va_start(marker, dwTextID);

    if (!FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                           FORMAT_MESSAGE_FROM_HMODULE |
                           FORMAT_MESSAGE_MAX_WIDTH_MASK,
                       hInstance,
                       dwTextID,
                       0,
                       (LPTSTR)&pszMsg,
                       1,
                       &marker)) {

        pszMsg = gpszError;

    }

    va_end(marker);

    GetLastError();

    pszTitle = NULL;

    if (dwTitleID != -1) {

        FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                          FORMAT_MESSAGE_FROM_HMODULE |
                          FORMAT_MESSAGE_MAX_WIDTH_MASK |
                          FORMAT_MESSAGE_ARGUMENT_ARRAY,
                      hInstance,
                      dwTitleID,
                      0,
                      (LPTSTR)&pszTitle,
                      1,
                      NULL);
                      //(va_list *)&pszTitleStr);

    }

    //
    // Turn on the beep if requested
    //

    if (fSound) {
        MessageBeep(fuStyle & (MB_ICONASTERISK | MB_ICONEXCLAMATION |
                MB_ICONHAND | MB_ICONQUESTION | MB_OK));
    }

    idRet = MessageBox(hwnd, pszMsg, pszTitle, fuStyle);

    if (pszTitle != NULL)
        LocalFree(pszTitle);

    if (pszMsg != gpszError)
        LocalFree(pszMsg);

    return idRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ntoc\welcome.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    tapi.cpp

Abstract:

    This file implements the welcome and finish pages.

Environment:

    WIN32 User Mode

Author:

    Andrew Ritz (andrewr) 24-July-1998

--*/

#include "ntoc.h"
#pragma hdrstop

HFONT hBigFont = NULL;

HFONT
GetBigFont(
    void
    ) 
{

    LOGFONT         LargeFont;
    NONCLIENTMETRICS ncm = {0};
    WCHAR           FontName[100];
    WCHAR           FontSize[30];
    int             iFontSize;
    HDC             hdc;
    HFONT           hFont = NULL;
    
    //
    // get the large fonts for wizard97
    // 
    ncm.cbSize = sizeof(ncm);
    SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);

    CopyMemory((LPVOID* )&LargeFont,(LPVOID *) &ncm.lfMessageFont,sizeof(LargeFont) );

    
    LoadStringW(hInstance,IDS_LARGEFONT_NAME,FontName,sizeof(FontName)/sizeof(WCHAR) );
    LoadStringW(hInstance,IDS_LARGEFONT_SIZE,FontSize,sizeof(FontSize)/sizeof(WCHAR) );

    iFontSize = wcstoul( FontSize, NULL, 10 );

    // make sure we at least have some basic font
    if (*FontName == 0 || iFontSize == 0) {
        lstrcpy(FontName,TEXT("MS Shell Dlg") );
        iFontSize = 18;
    }

    lstrcpy(LargeFont.lfFaceName, FontName);        
    LargeFont.lfWeight   = FW_BOLD;

    if ((hdc = GetDC(NULL))) {
        LargeFont.lfHeight = 0 - (GetDeviceCaps(hdc,LOGPIXELSY) * iFontSize / 72);
        hFont = CreateFontIndirect(&LargeFont);
        ReleaseDC( NULL, hdc);
    }

    return hFont;

}


void    
WelcomeInit(
    void
    ) 
{
    
    if (!hBigFont) {
        hBigFont = GetBigFont();
    }

    return;

}

void    
WelcomeCommit(
    void
    ) 
{
    
    return;

}

#if 0
void    
ReinstallInit(
    void
    ) 
{
    
    if (!hBigFont) {
        hBigFont = GetBigFont();
    }

    return;

}

void    
ReinstallCommit(
    void
    ) 
{
    
    return;

}
#endif


void    
FinishInit(
    void
    ) 
{
    
    if (!hBigFont) {
        hBigFont = GetBigFont();
    }

    return;

}

void    
FinishCommit(
    void
    ) 
{
    
    return;

}



LRESULT
WelcomeDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static BOOL FirstTime = TRUE;
    CommonWizardProc( hwnd, message, wParam, lParam, WizPageWelcome );
    
    switch( message ) {
        case WM_INITDIALOG:
            
            if (hBigFont) {
                SetWindowFont(GetDlgItem(hwnd,IDT_TITLE), hBigFont, TRUE);        
            }
            break;

        case WM_NOTIFY:

            switch (((NMHDR *) lParam)->code) {
            
                case PSN_SETACTIVE:
#if 0
                    if (SetupInitComponent.SetupData.OperationFlags &  SETUPOP_BATCH) {
                        PropSheet_PressButton( GetParent(hwnd), PSBTN_NEXT );
                        return TRUE;
                    }
#else
                    if (SetupInitComponent.SetupData.OperationFlags &  SETUPOP_BATCH) {
                        PropSheet_PressButton( GetParent(hwnd), PSBTN_NEXT );
                        return TRUE;
                    }
                    
                    if (FirstTime) {
                        SetWindowLongPtr( hwnd, DWLP_MSGRESULT, -1 );                        
                        FirstTime = FALSE;
                        return TRUE;
                    }                                  
#endif

                break;
    
            }
            break;
    }

    return FALSE;
}

LRESULT
FinishDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    CommonWizardProc( hwnd, message, wParam, lParam, WizPageFinal );

    switch( message ) {
        case WM_INITDIALOG:
            //PropSheet_SetWizButtons( GetParent(hwnd), PSWIZB_FINISH );

            //
            // don't allow cancel on the finish page...it's too late
            //
            ShowWindow(GetDlgItem(GetParent(hwnd),IDCANCEL),SW_HIDE);


            if (hBigFont) {
                SetWindowFont(GetDlgItem(hwnd,IDT_TITLE), hBigFont, TRUE);        
            }
            break;

        case WM_NOTIFY:

            switch (((NMHDR *) lParam)->code) {
            
                case PSN_SETACTIVE:
            
                    if (SetupInitComponent.SetupData.OperationFlags &  SETUPOP_BATCH) {
                        PropSheet_PressButton( GetParent(hwnd), PSBTN_FINISH );
                        return TRUE;
                    }
        
                }

            break;

    }

    return FALSE;
}

#if 0
LRESULT
ReinstallDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    CommonWizardProc( hwnd, message, wParam, lParam, WizPageReinstall );

    switch( message ) {
        case WM_INITDIALOG:
            //PropSheet_SetWizButtons( GetParent(hwnd), PSWIZB_BACK | PSWIZB_NEXT );

            break;

        case WM_NOTIFY:
        
        switch (((NMHDR *) lParam)->code) {
        
            case PSN_SETACTIVE:
                //if (!NoChanges) {
                //    SetWindowLong( hDlg, DWL_MSGRESULT, -1 );
                //}
            break;
        
            case PSN_WIZNEXT:
                if (IsDlgButtonChecked(hwnd,IDYES)) {
                    
                    SetupInitComponent.HelperRoutines.SetSetupMode(
                        SetupInitComponent.HelperRoutines.OcManagerContext , 
                        SETUPMODE_REINSTALL | SetupInitComponent.HelperRoutines.GetSetupMode( SetupInitComponent.HelperRoutines.OcManagerContext )
                        );
                    
                }

                break;

            default:
               ;
        };

        default:
        ;

    };

    return FALSE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ntoc\tapi.cpp ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    tapi.cpp

Abstract:

    This file implements the tapi dialing location page.

Environment:

    WIN32 User Mode

Author:

    Wesley Witt (wesw) 7-Aug-1997

--*/

#include "ntoc.h"
#pragma hdrstop


//
// constants
//

#define MY_SET_FOCUS                    (WM_USER+1000)

#define REGKEY_LOCATIONS                L"Software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Locations"
#define REGVAL_NUMENTRIES               L"NumEntries"

#define INTL_SECTION                    L"intl"
#define INTL_COUNTRY                    L"iCountry"

#define REGKEY_LOCATION                 L"Location1"

#define REGVAL_CURRENT_ID               L"CurrentID"
#define REGVAL_NEXT_ID                  L"NextID"
#define REGVAL_NUM_ENTRIES              L"NumEntries"
#define REGVAL_COUNTRY                  L"Country"
#define REGVAL_FLAGS                    L"Flags"
#define REGVAL_ID                       L"ID"
#define REGVAL_AREA_CODE                L"AreaCode"
#define REGVAL_DISABLE_CALL_WAITING     L"DisableCallWaiting"
#define REGVAL_LONG_DISTANCE_ACCESS     L"LongDistanceAccess"
#define REGVAL_NAME                     L"Name"
#define REGVAL_OUTSIDE_ACCESS           L"OutsideAccess"

#define REGKEY_PROVIDERS                L"Software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Providers"
#define REGVAL_NUMPROVIDERS             L"NumProviders"
#define REGVAL_NEXTPROVIDERID           L"NextProviderID"
#define REGVAL_PROVIDERFILENAME         L"ProviderFileName"
#define REGVAL_PROVIDERID               L"ProviderID"

#define TAPILOC_SECTION                 L"TapiLocation"
#define TPILOC_COUNTRY_CODE             L"CountryCode"
#define TPILOC_DIALING                  L"Dialing"
#define TPILOC_TONE                     L"Tone"
#define TPILOC_AREA_CODE                L"AreaCode"
#define TPILOC_ACCESS                   L"LongDistanceAccess"

#define LOCATION_USETONEDIALING         0x00000001
#define LOCATION_USECALLINGCARD         0x00000002
#define LOCATION_HASCALLWAITING         0x00000004
#define LOCATION_ALWAYSINCLUDEAREACODE  0x00000008

#define MAX_TAPI_STRING                 32
#define PROVIDER_FILE_NAME_LEN          14  // Provider's file name has the DOS
                                            // form (8.3)

//
// structures
//

typedef struct _TAPI_LOCATION_INFO {
    BOOL            Valid;
    DWORD           Country;
    DWORD           Flags;
    WCHAR           AreaCode[MAX_TAPI_STRING+1];
    WCHAR           LongDistanceAccess[MAX_TAPI_STRING+1];
} TAPI_LOCATION_INFO, *PTAPI_LOCATION_INFO;

typedef struct _TAPI_SERVICE_PROVIDER
{
    DWORD           dwProviderID;
    WCHAR           szProviderName[PROVIDER_FILE_NAME_LEN];
}TAPI_SERVICE_PROVIDER, *PTAPI_SERVICE_PROVIDER;


//
// globals
//

TAPI_LOCATION_INFO TapiLoc;
LPLINECOUNTRYLIST LineCountry;
BOOL TapiBadUnattend;
WCHAR DefaultLocationName[MAX_PATH];


BOOL
IsDeviceModem(
    LPLINEDEVCAPS LineDevCaps
    )
{
    LPTSTR DeviceClassList;
    BOOL UnimodemDevice = FALSE;

    if (LineDevCaps->dwDeviceClassesSize && LineDevCaps->dwDeviceClassesOffset) {
        DeviceClassList = (LPTSTR)((LPBYTE) LineDevCaps + LineDevCaps->dwDeviceClassesOffset);
        while (*DeviceClassList) {
            if (wcscmp(DeviceClassList,TEXT("comm/datamodem")) == 0) {
                UnimodemDevice = TRUE;
                break;
            }
            DeviceClassList += (wcslen(DeviceClassList) + 1);
        }
    }

    if ((!(LineDevCaps->dwBearerModes & LINEBEARERMODE_VOICE)) ||
        (!(LineDevCaps->dwBearerModes & LINEBEARERMODE_PASSTHROUGH))) {
            //
            // unacceptable modem device type
            //
            UnimodemDevice = FALSE;
    }

    return UnimodemDevice;
}


LPLINEDEVCAPS
MyLineGetDevCaps(
    HLINEAPP hLineApp,
    DWORD    TapiApiVersion,
    DWORD    DeviceId
    )
{
    DWORD LineDevCapsSize;
    LPLINEDEVCAPS LineDevCaps = NULL;
    LONG Rslt = ERROR_SUCCESS;
    DWORD LocalTapiApiVersion;
    LINEEXTENSIONID  lineExtensionID;


    Rslt = lineNegotiateAPIVersion(
            hLineApp,
            DeviceId,
            0x00010003,
            TapiApiVersion,
            &LocalTapiApiVersion,
            &lineExtensionID
            );


    //
    // allocate the initial linedevcaps structure
    //

    LineDevCapsSize = sizeof(LINEDEVCAPS) + 4096;
    LineDevCaps = (LPLINEDEVCAPS) LocalAlloc( LPTR, LineDevCapsSize );
    if (!LineDevCaps) {
        return NULL;
    }

    LineDevCaps->dwTotalSize = LineDevCapsSize;

    Rslt = lineGetDevCaps(
        hLineApp,
        DeviceId,
        LocalTapiApiVersion,
        0,
        LineDevCaps
        );

    if (Rslt != 0) {
        //
        // lineGetDevCaps() can fail with error code 0x8000004b
        // if a device has been deleted and tapi has not been
        // cycled.  this is caused by the fact that tapi leaves
        // a phantom device in it's device list.  the error is
        // benign and the device can safely be ignored.
        //
        if (Rslt != LINEERR_INCOMPATIBLEAPIVERSION) {
            DebugPrint(( TEXT("lineGetDevCaps() failed, ec=0x%08x"), Rslt ));
        }
        goto exit;
    }

    if (LineDevCaps->dwNeededSize > LineDevCaps->dwTotalSize) {

        //
        // re-allocate the linedevcaps structure
        //

        LineDevCapsSize = LineDevCaps->dwNeededSize;

        LocalFree( LineDevCaps );

        LineDevCaps = (LPLINEDEVCAPS) LocalAlloc( LPTR, LineDevCapsSize );
        if (!LineDevCaps) {
            Rslt = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }

        Rslt = lineGetDevCaps(
            hLineApp,
            DeviceId,
            LocalTapiApiVersion,
            0,
            LineDevCaps
            );

        if (Rslt != 0) {
            DebugPrint(( TEXT("lineGetDevCaps() failed, ec=0x%08x"), Rslt ));
            goto exit;
        }

    }

exit:
    if (Rslt != ERROR_SUCCESS) {
        LocalFree( LineDevCaps );
        LineDevCaps = NULL;
    }

    return LineDevCaps;
}



LPLINECOUNTRYLIST
MyLineGetCountry(
    void
    )
{
    #define DEFAULT_COUNTRY_SIZE 65536

    LPLINECOUNTRYLIST LineCountry = (LPLINECOUNTRYLIST) LocalAlloc( LPTR, DEFAULT_COUNTRY_SIZE );
    if (!LineCountry) {
      SetLastError(ERROR_NOT_ENOUGH_MEMORY);
      return NULL;
    }

    LineCountry->dwTotalSize = DEFAULT_COUNTRY_SIZE;
    if (lineGetCountry( 0, 0x00020001, LineCountry ) != 0) {
        return NULL;
    }

    if (LineCountry->dwNeededSize > LineCountry->dwTotalSize) {
        DWORD Size = LineCountry->dwNeededSize;
        LocalFree( LineCountry );
        LineCountry = (LPLINECOUNTRYLIST) LocalAlloc( LPTR, Size );
        if (!LineCountry) {
           SetLastError(ERROR_NOT_ENOUGH_MEMORY);
           return(NULL);
        }
        if (lineGetCountry( 0, 0x00020001, LineCountry ) != 0) {
            return NULL;
        }
    }

    return LineCountry;
}


static TAPI_SERVICE_PROVIDER DefaultProviders[] = {(DWORD)-1, L"unimdm.tsp",
                                                   (DWORD)-1, L"kmddsp.tsp",
                                                   (DWORD)-1, L"ndptsp.tsp",
                                                   (DWORD)-1, L"ipconf.tsp",
                                                   (DWORD)-1, L"h323.tsp",
                                                   (DWORD)-1, L"hidphone.tsp"};
#define NUM_DEFAULT_PROVIDERS           (sizeof(DefaultProviders)/sizeof(DefaultProviders[0]))

void
TapiInitializeProviders (void)
{
 DWORD dwNextProviderID = 1;
 DWORD dwExistingProviders = 0;
 DWORD dwMaxProviderID = 0;
 DWORD dwNextProviderNr = 0;
 HKEY  hKeyProviders = NULL;
 DWORD cbData, i, j;
 WCHAR szProviderFileName[24];  // Enough to hold "ProviderFileNameXXXXX\0"
 WCHAR szProviderID[16];        // Enough to hold "ProviderIDxxxxx\0"
 WCHAR szFileName[24];          // Enough to hold "ProviderFileNameXXXXX\0"
 WCHAR *pProviderFileNameNumber, *pProviderIDNumber;
 PTAPI_SERVICE_PROVIDER Providers = NULL, pProvider;

    // First, create / open the Providers key.
    if (ERROR_SUCCESS !=
        RegCreateKeyEx (HKEY_LOCAL_MACHINE, REGKEY_PROVIDERS, 0, NULL, REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS, NULL, &hKeyProviders, &cbData))
    {
        return;
    }

    // Initialize value names and pointers
    lstrcpy (szProviderFileName, REGVAL_PROVIDERFILENAME);
    lstrcpy (szProviderID, REGVAL_PROVIDERID);
    pProviderFileNameNumber = szProviderFileName + lstrlen (szProviderFileName);
    pProviderIDNumber = szProviderID + lstrlen (szProviderID);

    if (REG_CREATED_NEW_KEY == cbData)
    {
        // This means that there are no providers
        // in the registry yet. Go and add all the
        // default ones.
        goto _AddDefaultProviders;
    }

    // Now compute how big a provider array we have to allocate,
    // by looking at how many values there are in the providers key;
    // we divide this number by 2, because each provider will have a file
    // name and an ID.
    if (ERROR_SUCCESS !=
        RegQueryInfoKey (hKeyProviders,
                         NULL, NULL, NULL, NULL, NULL, NULL,
                         &dwExistingProviders,
                         NULL, NULL, NULL, NULL))
    {
        goto _CountProviders;
    }
    dwExistingProviders >>= 1;   // divide by 2
    if (0 == dwExistingProviders)
    {
        // This means that there are no providers
        // in the registry yet. Go and add all the
        // default ones.
        goto _AddDefaultProviders;
    }
    dwExistingProviders++;       // just in case

    // Allocate a provider array with enough entries.
    Providers = (PTAPI_SERVICE_PROVIDER)LocalAlloc (LPTR, dwExistingProviders*sizeof(TAPI_SERVICE_PROVIDER));
    if (NULL == Providers)
    {
        // we couldn't allocate memory, so skip
        // looking for providers and just go and
        // install the default ones.
        goto _AddDefaultProviders;
    }

    // Next, figure out the number of providers already
    // installed, and the next provider ID
    // Instead of reading NumProviders from the registry,
    // try to open each ProviderIDxxx and ProviderFileNameXXX.
    // Do this just in case the registry is not in a good state.
    // Also, store the provider (unless it's t1632tsp) in the
    // array.
_CountProviders:
    pProvider = Providers;
    dwExistingProviders = 0;
    for (i = 0; TRUE; i++)
    {
     BOOL bFound;
        wsprintf (pProviderFileNameNumber, L"%d", i);
        lstrcpy (pProviderIDNumber, pProviderFileNameNumber);

        cbData = sizeof (szFileName);
        if (ERROR_SUCCESS !=
            RegQueryValueEx (hKeyProviders, szProviderFileName, NULL, NULL, (PBYTE)szFileName, &cbData))
        {
            break;
        }
        cbData = sizeof (dwNextProviderID);
        if (ERROR_SUCCESS !=
            RegQueryValueEx (hKeyProviders, szProviderID, NULL, NULL, (PBYTE)&dwNextProviderID, &cbData))
        {
            // We couldn't read this provider's ID. We must skip it.
            continue;
        }

        // Look for the current provider in the list
        // of default providers
        bFound = FALSE;
        for (j = 0; j < NUM_DEFAULT_PROVIDERS; j++)
        {
            if (0 == lstrcmpi (DefaultProviders[j].szProviderName, szFileName))
            {
                DefaultProviders[j].dwProviderID = dwNextProviderID;
                bFound = TRUE;
                break;
            }
        }

        if (!bFound)
        {
            // We have a provider that was installed by the user on the previous NT installation.
            pProvider->dwProviderID = dwNextProviderID;
            lstrcpy (pProvider->szProviderName, szFileName);
            pProvider++;
            dwExistingProviders++;
        }

        if (dwNextProviderID > dwMaxProviderID)
        {
            dwMaxProviderID = dwNextProviderID;
        }
    }
    dwNextProviderID = dwMaxProviderID + 1;

    // We got a list of all providers that were installed before.
    // Clean up the Providers key.
    for (i = 0; TRUE; i++)
    {
        cbData = sizeof(szFileName)/sizeof(WCHAR);
        if (ERROR_SUCCESS !=
            RegEnumValue (hKeyProviders, i, szFileName, &cbData, NULL, NULL, NULL, NULL))
        {
            break;
        }

        RegDeleteValue (hKeyProviders, szFileName);
    }

_AddDefaultProviders:
    for (i = 0, pProvider = DefaultProviders;
         i < NUM_DEFAULT_PROVIDERS;
         i++, pProvider++)
    {
        // Found a provider that has to be added.
        // Compute it's value names.
        wsprintf (pProviderFileNameNumber, L"%d", dwNextProviderNr);
        lstrcpy (pProviderIDNumber, pProviderFileNameNumber);
        if (ERROR_SUCCESS ==
            RegSetValueEx (hKeyProviders, szProviderFileName, 0, REG_SZ, (PBYTE)pProvider->szProviderName,
                           (lstrlen(pProvider->szProviderName)+1)*sizeof(WCHAR)))
        {
         DWORD dwRet;
            if ((DWORD)-1 == pProvider->dwProviderID)
            {
                if (ERROR_SUCCESS == (dwRet =
                    RegSetValueEx (hKeyProviders, szProviderID, 0, REG_DWORD,
                                   (PBYTE)&dwNextProviderID, sizeof(dwNextProviderID))))
                {
                    dwNextProviderID++;
                }
            }
            else
            {
                dwRet = RegSetValueEx (hKeyProviders, szProviderID, 0, REG_DWORD,
                                       (PBYTE)&pProvider->dwProviderID, sizeof(pProvider->dwProviderID));
            }
            if (ERROR_SUCCESS == dwRet)
            {
                dwNextProviderNr++;
            }
            else
            {
                RegDeleteValue (hKeyProviders, szProviderFileName);
            }
        }
    }

    // Now, add all the providers again. We do this because the
    // IDs were REG_BINARY on win98 and have to be REG_DWORD on NT5.
    for (i = 0, pProvider = Providers;
         i < dwExistingProviders;
         i++, pProvider++)
    {
        // Found a provider that has to be added.
        // Compute it's value names.
        wsprintf (pProviderFileNameNumber, L"%d", dwNextProviderNr);
        lstrcpy (pProviderIDNumber, pProviderFileNameNumber);
        if (ERROR_SUCCESS ==
            RegSetValueEx (hKeyProviders, szProviderFileName, 0, REG_SZ,
                           (PBYTE)pProvider->szProviderName,
                           (lstrlen(pProvider->szProviderName)+1)*sizeof(WCHAR)))
        {
            if (ERROR_SUCCESS ==
                RegSetValueEx (hKeyProviders, szProviderID, 0, REG_DWORD,
                               (PBYTE)&pProvider->dwProviderID,
                               sizeof(pProvider->dwProviderID)))
            {
                dwNextProviderNr++;
            }
            else
            {
                RegDeleteValue (hKeyProviders, szProviderFileName);
            }
        }
    }

    // Finally, update NumProviders and NextProviderID.
    RegSetValueEx (hKeyProviders, REGVAL_NUMPROVIDERS, 0, REG_DWORD,
                   (PBYTE)&dwNextProviderNr, sizeof(dwNextProviderNr));
    RegSetValueEx (hKeyProviders, REGVAL_NEXTPROVIDERID, 0, REG_DWORD,
                   (PBYTE)&dwNextProviderID, sizeof(dwNextProviderID));

    RegCloseKey (hKeyProviders);

    if (NULL != Providers)
    {
        LocalFree (Providers);
    }
}

void
CopyTsecFile (
    void
    )
{
    TCHAR               szWndDir[MAX_PATH];
    TCHAR               szSrc[MAX_PATH];
    TCHAR               szDest[MAX_PATH];
    TCHAR               szBuf[MAX_PATH];
    HANDLE              hFileIn = INVALID_HANDLE_VALUE;
    HANDLE              hFileOut = INVALID_HANDLE_VALUE;
    const TCHAR         szTsecSrc[] = TEXT("\\tsec.ini");
    const TCHAR         szTsecDest[] = TEXT("\\TAPI\\tsec.ini");
    DWORD               dwBytesRead, dwBytesWritten;
    BOOL                bError = FALSE;

    if (GetWindowsDirectory (szWndDir, sizeof(szWndDir)/sizeof(TCHAR)) == 0 ||
        lstrlen(szWndDir) + lstrlen(szTsecSrc) >= sizeof(szSrc)/sizeof(TCHAR) ||
        lstrlen(szWndDir) + lstrlen(szTsecDest) >= sizeof(szDest)/sizeof(TCHAR))
    {
        goto ExitHere;
    }

    lstrcpy (szSrc, szWndDir);
    lstrcat (szSrc, szTsecSrc);
    lstrcpy (szDest, szWndDir);
    lstrcat (szDest, szTsecDest);

    hFileIn = CreateFile (
        szSrc,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );
    hFileOut = CreateFile (
        szDest,
        GENERIC_WRITE,
        FILE_SHARE_READ,
        NULL,
        CREATE_NEW,
        FILE_ATTRIBUTE_NORMAL,
        NULL);
    if (hFileIn == INVALID_HANDLE_VALUE || hFileOut == INVALID_HANDLE_VALUE)
    {
        goto ExitHere;
    }

    do
    {
        if (!ReadFile (
            hFileIn,
            (LPVOID) szBuf,
            sizeof(szBuf),
            &dwBytesRead,
            NULL)
            )
        {
            bError = TRUE;
            dwBytesRead = 0;
        }
        if (dwBytesRead != 0)
        {
            if (!WriteFile (
                hFileOut,
                (LPVOID) szBuf,
                dwBytesRead,
                &dwBytesWritten,
                NULL
                ) ||
                dwBytesRead != dwBytesWritten)
            {
                bError = TRUE;
            }

        }
    } while (dwBytesRead != 0);

    //
    //  Be extra careful not to loose any data, delete
    //  old file only if we are sure no error happened
    //
    if (!bError)
    {
        CloseHandle (hFileIn);
        hFileIn = INVALID_HANDLE_VALUE;
        DeleteFile (szSrc);
    }

ExitHere:
    if (hFileIn != INVALID_HANDLE_VALUE)
    {
        CloseHandle (hFileIn);
    }
    if (hFileOut != INVALID_HANDLE_VALUE)
    {
        CloseHandle (hFileOut);
    }
}

void
TapiInit(
    void
    )
{
    if (SetupInitComponent.SetupData.OperationFlags & SETUPOP_STANDALONE) {
        return;
    }

    CopyTsecFile();

    TapiInitializeProviders ();

    LineCountry = MyLineGetCountry();
    LoadString( hInstance, IDS_DEFAULT_LOCATION_NAME, DefaultLocationName, sizeof(DefaultLocationName)/sizeof(WCHAR) );
}


void
TapiCommitChanges(
    void
    )
{
    HKEY hKey, hKeyLoc;

    if (SetupInitComponent.SetupData.OperationFlags & SETUPOP_STANDALONE) {
        return;
    }

    if (SetupInitComponent.SetupData.OperationFlags & SETUPOP_NTUPGRADE) {
        return;
    }

    if (TapiLoc.Valid) {
        hKey = OpenRegistryKey( HKEY_LOCAL_MACHINE, REGKEY_LOCATIONS, TRUE, KEY_ALL_ACCESS );
        if (hKey) {
            SetRegistryDword( hKey, REGVAL_CURRENT_ID, 1 );
            SetRegistryDword( hKey, REGVAL_NEXT_ID, 2 );
//            SetRegistryDword( hKey, REGVAL_NUM_ENTRIES, 1 );

            hKeyLoc = OpenRegistryKey( hKey, REGKEY_LOCATION, TRUE, KEY_ALL_ACCESS );
            if (hKeyLoc) {

                SetRegistryDword( hKeyLoc, REGVAL_COUNTRY, TapiLoc.Country );
                SetRegistryDword( hKeyLoc, REGVAL_FLAGS, TapiLoc.Flags );
//                SetRegistryDword( hKeyLoc, REGVAL_ID, 1 );

                SetRegistryString( hKeyLoc, REGVAL_AREA_CODE, TapiLoc.AreaCode );
                SetRegistryString( hKeyLoc, REGVAL_DISABLE_CALL_WAITING, L"" );
                SetRegistryString( hKeyLoc, REGVAL_LONG_DISTANCE_ACCESS, TapiLoc.LongDistanceAccess );
                SetRegistryString( hKeyLoc, REGVAL_NAME, DefaultLocationName );
                SetRegistryString( hKeyLoc, REGVAL_OUTSIDE_ACCESS, TapiLoc.LongDistanceAccess );

                RegCloseKey( hKeyLoc );
            }
            RegCloseKey( hKey );
        }
    }
}

INT
IsCityCodeOptional(
    LPLINECOUNTRYENTRY pEntry
    )
{
#define AREACODE_DONTNEED   0
#define AREACODE_REQUIRED   1
#define AREACODE_OPTIONAL   2

    if (pEntry  && pEntry->dwLongDistanceRuleSize && pEntry->dwLongDistanceRuleOffset )
    {
        LPWSTR  pLongDistanceRule;
        pLongDistanceRule = (LPTSTR)((PBYTE)LineCountry + pEntry->dwLongDistanceRuleOffset);

        if (wcschr(pLongDistanceRule, L'F') != NULL) return AREACODE_REQUIRED;
        if (wcschr(pLongDistanceRule, L'I') == NULL) return AREACODE_DONTNEED;
    }

    return AREACODE_OPTIONAL;
}



BOOL
TapiOnInitDialog(
    IN HWND hwnd,
    IN HWND hwndFocus,
    IN LPARAM lParam
    )
{
    SendDlgItemMessage( hwnd, IDC_AREA_CODE, EM_LIMITTEXT, MAX_TAPI_STRING, 0 );
    SendDlgItemMessage( hwnd, IDC_LONG_DISTANCE, EM_LIMITTEXT, MAX_TAPI_STRING, 0 );

    CheckRadioButton( hwnd, IDC_TONE, IDC_PULSE, IDC_TONE );

    if (LineCountry) {
        DWORD CurrCountryCode = GetProfileInt( INTL_SECTION, INTL_COUNTRY, 1 );
        LPLINECOUNTRYENTRY LineCountryEntry = (LPLINECOUNTRYENTRY) ((LPBYTE)LineCountry + LineCountry->dwCountryListOffset);
        DWORD Selection = 0;
        DWORD Index;
        LPWSTR CountryName ;
        for (DWORD i=0; i<LineCountry->dwNumCountries; i++) {
            CountryName = (LPWSTR) ((LPBYTE)LineCountry + LineCountryEntry[i].dwCountryNameOffset);
            Index = (DWORD)SendDlgItemMessage( hwnd, IDC_COUNTRY_LIST, CB_ADDSTRING, 0, (LPARAM)CountryName );
            SendDlgItemMessage( hwnd, IDC_COUNTRY_LIST, CB_SETITEMDATA, Index, i );
            if (LineCountryEntry[i].dwCountryID == CurrCountryCode) {
                Selection = i;
            }
        }
        CountryName = (LPWSTR) ((LPBYTE)LineCountry + LineCountryEntry[Selection].dwCountryNameOffset);
        Selection = (DWORD)SendDlgItemMessage( hwnd, IDC_COUNTRY_LIST, CB_FINDSTRING, 0, (LPARAM) CountryName );
        SendDlgItemMessage( hwnd, IDC_COUNTRY_LIST, CB_SETCURSEL, Selection, 0 );

    }

    PostMessage( hwnd, MY_SET_FOCUS, 0, (LPARAM) GetDlgItem( hwnd, IDC_AREA_CODE ) );

    return TRUE;
}


VOID
ValidateAndSetWizardButtons( HWND hwnd )
{

    BOOL AreaCodeOk;

    {
        DWORD CurrCountry = (DWORD)SendDlgItemMessage( hwnd, IDC_COUNTRY_LIST, CB_GETCURSEL, 0, 0 );
        LPLINECOUNTRYENTRY CntryFirstEntry = NULL;
        INT AreaCodeInfo = 0;
        WCHAR Buffer[MAX_TAPI_STRING+1];

        GetDlgItemText( hwnd, IDC_AREA_CODE, Buffer, MAX_TAPI_STRING );
        CurrCountry = (DWORD)SendDlgItemMessage( hwnd, IDC_COUNTRY_LIST, CB_GETITEMDATA, CurrCountry, 0 );
        CntryFirstEntry = (LPLINECOUNTRYENTRY)((LPBYTE)LineCountry + LineCountry->dwCountryListOffset);
        AreaCodeInfo = IsCityCodeOptional( CntryFirstEntry + CurrCountry );

        AreaCodeOk = TRUE;

        //
        // If the area code is required, then there must be a value in the Buffer.
        //
        // Otherwise, it's OK.
        //
        if ( ( AreaCodeInfo == AREACODE_REQUIRED ) && ( *Buffer == UNICODE_NULL ) ){
           AreaCodeOk = FALSE;
        }
    }

    if ( TapiLoc.Valid )
        AreaCodeOk = TRUE;

    PropSheet_SetWizButtons(GetParent(hwnd), PSWIZB_BACK | ( AreaCodeOk ? PSWIZB_NEXT : 0 ) );

}


BOOL
TapiOnCommand(
    IN HWND hwnd,
    IN DWORD NotifyCode,
    IN DWORD ControlId,
    IN HWND hwndControl
    )
{
    // If the area code changed, or the country code changed
    if ((NotifyCode == EN_CHANGE && ControlId == IDC_AREA_CODE) ||
        (NotifyCode == CBN_SELCHANGE && ControlId == IDC_COUNTRY_LIST)) {
        ValidateAndSetWizardButtons(hwnd);
    }

    return TRUE;
}


BOOL
TapiOnNotify(
    IN HWND hwnd,
    IN WPARAM ControlId,
    IN LPNMHDR pnmh
    )
{
    switch (pnmh->code ) {
        case PSN_SETACTIVE:
            {
                HKEY hKey;
                DWORD NumEntries, Size;
                WCHAR buf[MAX_TAPI_STRING+1];
                BOOL OverrideMissingAreaCode = FALSE;

                if (SetupInitComponent.SetupData.OperationFlags & SETUPOP_NTUPGRADE) {
                    SetWindowLongPtr( hwnd, DWLP_MSGRESULT, -1 );     // don't activate this page
                    return TRUE;
                }

                if (RegOpenKey( HKEY_LOCAL_MACHINE, REGKEY_LOCATIONS, &hKey ) == ERROR_SUCCESS) {
                    Size = sizeof(DWORD);
                    if (RegQueryValueEx( hKey, REGVAL_NUMENTRIES, NULL, NULL, (LPBYTE)&NumEntries, &Size ) == ERROR_SUCCESS) {
                        if (NumEntries > 0 && !TapiLoc.Valid) {
                            SetWindowLongPtr( hwnd, DWLP_MSGRESULT, -1 );     // don't activate this page
                            return TRUE;
                        }
                    }
                    RegCloseKey( hKey );
                }

                // Look at the existing values on the page to see if everything
                // is OK to go to the next page
                ValidateAndSetWizardButtons(hwnd);

                TapiLoc.Valid = FALSE;

                HLINEAPP hLineApp;
                LINEINITIALIZEEXPARAMS LineInitializeExParams;
                DWORD TapiDevices = 0, ModemDevices = 0;
                DWORD LocalTapiApiVersion = 0x00020000;
                DWORD Rval;

                LineInitializeExParams.dwTotalSize      = sizeof(LINEINITIALIZEEXPARAMS);
                LineInitializeExParams.dwNeededSize     = 0;
                LineInitializeExParams.dwUsedSize       = 0;
                LineInitializeExParams.dwOptions        = LINEINITIALIZEEXOPTION_USEEVENT;
                LineInitializeExParams.Handles.hEvent   = NULL;
                LineInitializeExParams.dwCompletionKey  = 0;

                Rval = lineInitializeEx(
                    &hLineApp,
                    hInstance,
                    NULL,
                    TEXT("Setup"),
                    &TapiDevices,
                    &LocalTapiApiVersion,
                    &LineInitializeExParams
                    );

                if (Rval == 0) {
                    for (DWORD i=0; i< TapiDevices; i++ ) {
                        LPLINEDEVCAPS ldc = MyLineGetDevCaps( hLineApp, LocalTapiApiVersion, i );
                        if (ldc) {
                            if (IsDeviceModem(ldc)) {
                                ModemDevices++;
                            }

                            LocalFree( ldc );
                        }
                    }

                    lineShutdown( hLineApp );
                }

                // If lineInitilaizeEx failed or there are no modem devices installed
                // then suppress this wizard page.

                if ( Rval != 0 || ModemDevices == 0 )
                {
                   SetWindowLongPtr( hwnd, DWLP_MSGRESULT, -1 );         // don't activate this page
                   return TRUE;
                }
            }

            if (SetupInitComponent.SetupData.OperationFlags & SETUPOP_BATCH) {
                //
                // unattended mode
                //

                WCHAR Buf[MAX_TAPI_STRING+1];

                TapiLoc.Country = GetPrivateProfileInt(
                                      TAPILOC_SECTION,
                                      TPILOC_COUNTRY_CODE,
                                      1,
                                      SetupInitComponent.SetupData.UnattendFile
                                      );

                GetPrivateProfileString(
                    TAPILOC_SECTION,
                    TPILOC_DIALING,
                    TPILOC_TONE,
                    Buf,
                    MAX_TAPI_STRING,
                    SetupInitComponent.SetupData.UnattendFile
                    );

                if (_wcsicmp( Buf, TPILOC_TONE ) == 0) {
                    TapiLoc.Flags = LOCATION_USETONEDIALING;
                } else {
                    TapiLoc.Flags = 0;
                }

                GetPrivateProfileString(
                    TAPILOC_SECTION,
                    TPILOC_AREA_CODE,
                    L"1",
                    TapiLoc.AreaCode,
                    MAX_TAPI_STRING,
                    SetupInitComponent.SetupData.UnattendFile
                    );

                GetPrivateProfileString(
                    TAPILOC_SECTION,
                    TPILOC_ACCESS,
                    L"",
                    TapiLoc.LongDistanceAccess,
                    MAX_TAPI_STRING,
                    SetupInitComponent.SetupData.UnattendFile
                    );

                TapiLoc.Valid = TRUE;

                SetWindowLongPtr( hwnd, DWLP_MSGRESULT, -1 );     // don't activate this page
                return TRUE;
            }

            // If we get here the user needs  has click next or back.
            // Make sure the wizard page is showing.
            // For Whistler GUI mode we try to hide wizard pages and show a background
            // billboard if there is only a progress bar.
            //
            SetupInitComponent.HelperRoutines.ShowHideWizardPage(
                                        SetupInitComponent.HelperRoutines.OcManagerContext,
                                        TRUE);

            PostMessage( hwnd, MY_SET_FOCUS, 0, (LPARAM) GetDlgItem( hwnd, IDC_AREA_CODE ) );
            break;

        case PSN_WIZNEXT:
            {
                DWORD CurrCountry = (DWORD)SendDlgItemMessage( hwnd, IDC_COUNTRY_LIST, CB_GETCURSEL, 0, 0 );
                CurrCountry = (DWORD)SendDlgItemMessage( hwnd, IDC_COUNTRY_LIST, CB_GETITEMDATA, CurrCountry, 0 );
                LPLINECOUNTRYENTRY LineCountryEntry = (LPLINECOUNTRYENTRY) ((LPBYTE)LineCountry + LineCountry->dwCountryListOffset);

                TapiLoc.Country = LineCountryEntry[CurrCountry].dwCountryID;

                GetDlgItemText( hwnd, IDC_AREA_CODE, TapiLoc.AreaCode, MAX_TAPI_STRING );
                GetDlgItemText( hwnd, IDC_LONG_DISTANCE, TapiLoc.LongDistanceAccess, MAX_TAPI_STRING );

                if (IsDlgButtonChecked( hwnd, IDC_TONE )) {
                    TapiLoc.Flags = LOCATION_USETONEDIALING;
                } else {
                    TapiLoc.Flags = 0;
                }


                //
                // If an area code was not set but the areacode is required, then
                // fail to continue "going next."
                //
                if ((TapiLoc.AreaCode[0] == 0) &&
                    (IsCityCodeOptional(LineCountryEntry + CurrCountry) == AREACODE_REQUIRED)) {
                    SetWindowLongPtr( hwnd, DWLP_MSGRESULT, -1 );
                    return TRUE;
                }

                TapiLoc.Valid = TRUE;
            }

            break;
    }

    return FALSE;
}


LRESULT
TapiLocDlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    CommonWizardProc( hwnd, message, wParam, lParam, WizPageTapiLoc );

    switch( message ) {
        case WM_INITDIALOG:
            return TapiOnInitDialog( hwnd, (HWND)wParam, lParam );

        case WM_COMMAND:
            return TapiOnCommand( hwnd, HIWORD(wParam), LOWORD(wParam), (HWND)lParam );

        case WM_NOTIFY:
            return TapiOnNotify( hwnd, wParam, (LPNMHDR) lParam );

        case MY_SET_FOCUS:
            SetFocus( (HWND) lParam );
            SendMessage( (HWND) lParam, EM_SETSEL, 0, MAKELPARAM( 0, -1 ) );
            return FALSE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ocmanage\common\oc.h ===
//
// Need to include below 3 files for "IsNEC_98", even if DEBUGPERFTRACE does not defined.
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>


#include <windows.h>

#include <prsht.h>

#include <commctrl.h>

#ifdef PRERELEASE
#ifdef DBG
#include <objbase.h>
#endif
#endif

#include <setupapi.h>
#include <spapip.h>

#include <ocmanage.h>
#include <ocmgrlib.h>

#include <tchar.h>
#include <stddef.h>
#include <stdlib.h>
#include <assert.h>

#include <winnls.h>

#ifdef UNICODE
    #include <sfcapip.h>
#endif

#include "msg.h"
#include "res.h"

#if DBG

#define MYASSERT( exp ) \
    if (!(exp)) \
        RtlAssert( #exp, __FILE__, __LINE__, NULL )

#else

#define MYASSERT( exp )

#endif // DBG

//
// Names of wizard page types.
//
extern LPCTSTR WizardPagesTypeNames[WizPagesTypeMax];

//
// Window handle of wizard dialog. Set when the OC Manager client
// calls OcRememberWizardDialogHandle.
//
extern HWND WizardDialogHandle;

//
// Name of sections and keys in infs.
//
extern LPCTSTR szComponents;
extern LPCTSTR szOptionalComponents;
extern LPCTSTR szExtraSetupFiles;
extern LPCTSTR szNeeds;
extern LPCTSTR szParent;
extern LPCTSTR szIconIndex;
extern LPCTSTR szTip;
extern LPCTSTR szOptionDesc;
extern LPCTSTR szInstalledFlag;

//
// Key in registry where private component data is kept.
// We form a unique name within this key for the OC Manager
// instantiation.
//
extern LPCTSTR szPrivateDataRoot;
extern LPCTSTR szMasterInfs;
extern LPCTSTR szSubcompList;

//
// Other string constants.
//
extern LPCTSTR szSetupDir;
extern LPCTSTR szOcManagerErrors;
//
// DLL module handle.
//
extern HMODULE MyModuleHandle;

//
// for debugging
//
extern DWORD gDebugLevel;

//
// Define structure describing an optional component.
//
typedef struct _OPTIONAL_COMPONENT {
    //
    // String id of name of inf file in the OC Manager's
    // InfListStringTable string table. If -1, then
    // the subcomponent does not appear on the OC page.
    //
    LONG InfStringId;

    //
    // Backpointer to top level component
    //
    LONG TopLevelStringId;

    //
    // String id of parent component, -1 if none.
    //
    LONG ParentStringId;

    //
    // String id of first child, -1 if none.
    //
    LONG FirstChildStringId;

    //
    // Count of children.
    //
    UINT ChildrenCount;

    //
    // String id of next sibling, -1 if none.
    //
    LONG NextSiblingStringId;

    //
    // String ids of needs and needed by.
    //
    PLONG NeedsStringIds;
    UINT NeedsCount;
    PLONG NeededByStringIds;
    UINT NeededByCount;

    // String ids of exclude and excluded by

    PLONG ExcludeStringIds;
    UINT ExcludeCount;
    PLONG ExcludedByStringIds;
    UINT ExcludedByCount;

    //
    // Misc flags.
    //
    UINT InternalFlags;

    //
    // Approximation of required disk space.
    //
    LONGLONG SizeApproximation;

    //
    // Icon index of the component.
    // -1 means we're supposed to get it from the component itself.
    // -2 means we're supposed to use IconDll and IconResource
    //
    UINT IconIndex;
    TCHAR IconDll[MAX_PATH];
    TCHAR IconResource[50];

    //
    // Selection state (SELSTATE_xxx constants).
    //
    UINT SelectionState;
    UINT OriginalSelectionState;

    // Installation Flag as obtained from the inf

    UINT InstalledState;

    //
    // Mode bits.
    //
    UINT ModeBits;

    //
    // Human-readable stuff describing the component.
    //
    TCHAR Description[MAXOCDESC];
    TCHAR Tip[MAXOCTIP];

    //
    // From here down, stuff is meaningful only for top-level components.
    //

    //
    // Stuff describing the OC's installation DLL and how to call it.
    //
    TCHAR InstallationDllName[MAX_PATH];
    CHAR InterfaceFunctionName[MAX_PATH];

    HMODULE InstallationDll;
    POCSETUPPROC InstallationRoutine;

    //
    // Version of the OC Manager to which this component was written.
    //
    UINT ExpectedVersion;

    // this flag indicates whether the subcomponent was intialialized

    BOOL Exists;

    // points to the helper context for this component

    struct _HELPER_CONTEXT *HelperContext;

    //
    // Flags: ANSI/Unicode, etc.
    //
    UINT Flags;

} OPTIONAL_COMPONENT, *POPTIONAL_COMPONENT;

//
// locale info
//
typedef struct _LOCALE {
    LCID    lcid;
    TCHAR   DecimalSeparator[4];
} LOCALE, *PLOCALE;

extern LOCALE locale;

//
// Indices for installation states.
//
#define INSTSTATE_NO         0
#define INSTSTATE_UNKNOWN    1
#define INSTSTATE_YES        2

//
// Flags for InternalFlags member of OPTIONAL_COMPONENT structure.
//
#define OCFLAG_PROCESSED        0x00000001
#define OCFLAG_ANYORIGINALLYON  0x00000002
#define OCFLAG_ANYORIGINALLYOFF 0x00000004
#define OCFLAG_HIDE             0x00000008
#define OCFLAG_STATECHANGE      0x00000010
#define OCFLAG_TOPLEVELITEM     0x00000020
#define OCFLAG_NEWITEM          0x00000040
#define OCFLAG_NOWIZARDPAGES    0x00000080
#define OCFLAG_APPROXSPACE      0x00000100
#define OCFLAG_NOQUERYSKIPPAGES 0x00000200
#define OCFLAG_NOEXTRAROUTINES  0x00000400



// indicates an exception when calling a component

#define ERROR_CALL_COMPONENT   -666

//
// values to sync copies with the OS
//
#define OC_ALLOWRENAME              TEXT("AllowProtectedRenames")


//
// Define structure describing a per-component inf.
//
typedef struct _OC_INF {
    //
    // Handle to open inf file.
    //
    HINF Handle;

} OC_INF, *POC_INF;


//
// Define structure corresponding to an instance of the OC Manager.
// This is actually somewhat broken, in that this actually closely corresponds
// to a master OC INF, and we might want to consider breaking out the string
// tables into another structure, so we can more easily achieve a unified
// namespace if we have multiple master OC INFs at play simultaneously.
//
typedef struct _OC_MANAGER {
        //
    // Callbacks into OC Manaer client.
    //
    OCM_CLIENT_CALLBACKS Callbacks;

    //
    // Handle of Master OC INF.
    //
    HINF MasterOcInf;

    //
    // unattended inf handle
    //
    HINF UnattendedInf;

    //
    // Master OC Inf file, and unattended file
    //
    TCHAR MasterOcInfPath[MAX_PATH];
    TCHAR UnattendedInfPath[MAX_PATH];

    // we run from whatever directory the master inf is in

    TCHAR SourceDir[MAX_PATH];

    //
    // Name of "suite" -- in other words, a shortname that
    // is unique to the master OC inf that this structure represents.
    // We base it on the name of the master OC inf itself.
    //
    TCHAR SuiteName[MAX_PATH];

    //
    // page titles
    //
    TCHAR SetupPageTitle[MAX_PATH];

    // window title

    TCHAR WindowTitle[MAX_PATH];

    //
    // List of per-component OC INFs currently loaded.
    // Each inf's name is in the string table and the extra data
    // for each is an OC_INF structure.
    //
    PVOID InfListStringTable;

    //
    // String table for names of all components and subcomponents.
    // Extra data for each is an OPTIONAL_COMPONENT structure.
    //
    PVOID ComponentStringTable;

    //
    // pointer to OcSetupPage structure so we can free this data
    // if the user cancels before we get to the wizard page.
    //
    PVOID OcSetupPage;

    //
    // Setup mode (custom, typical, etc)
    //
    UINT SetupMode;

    //
    // List of top-level optional component string IDs.
    // This is necessary because we need to preserve ordering
    // from the master OC Inf.
    //
    UINT TopLevelOcCount;
    PLONG TopLevelOcStringIds;
    UINT TopLevelParentOcCount;
    PLONG TopLevelParentOcStringIds;


    //
    // Are there subcomponents on the details page?
    //
    BOOL SubComponentsPresent;

    //
    // Each element in this array points to an array that
    // gives ordering for querying wizard pages from the optional components.
    //
    PLONG WizardPagesOrder[WizPagesTypeMax];

    //
    // Subkey relative to szPrivateDataRoot where private
    // data for components plugged into the OC will live.
    // 2 8-char DWORD representations plus a separator and nul.
    //
    TCHAR PrivateDataSubkey[18];
    HKEY hKeyPrivateData;
    HKEY hKeyPrivateDataRoot;

    //
    // If we are completing installation, this item is the window handle
    // of the progress text control.
    //
    HWND ProgressTextWindow;

    //
    // String id of component currently processing an interface routine.
    // -1 means the OC manager is not currently processing one.
    //
    LONG CurrentComponentStringId;

    // Component Ids of aborted components

    PLONG AbortedComponentIds;
    UINT  AbortedCount;

    //
    // Various flags
    //
    UINT InternalFlags;

    //
    // setup data
    //

    SETUP_DATA SetupData;

} OC_MANAGER, *POC_MANAGER;

//
// Flags for InternalFlags member of OC_MANAGER structure
//
#define OCMFLAG_ANYORIGINALLYON     0x00000001
#define OCMFLAG_ANYORIGINALLYOFF    0x00000002
#define OCMFLAG_ANYDELAYEDMOVES     0x00000004
#define OCMFLAG_NEWINF              0x00000008
#define OCMFLAG_USERCANCELED        0x00000010
#define OCMFLAG_FILEABORT           0x00000020
#define OCMFLAG_NOPREOCPAGES        0x00000040
#define OCMFLAG_KILLSUBCOMPS        0x00000080
#define OCMFLAG_ANYINSTALLED        0x00000100
#define OCMFLAG_ANYUNINSTALLED      0x00000200
#define OCMFLAG_RUNQUIET            0x00000400
#define OCMFLAG_LANGUAGEAWARE       0x00000800

//
// Define structure we use to get back to a particular component
// when a component calls a helper routine asynchronously (for routines
// such as get and set private data).
//
// As each component is initialized it gets one of these structures.
//
typedef struct _HELPER_CONTEXT {
    POC_MANAGER OcManager;
    LONG ComponentStringId;
} HELPER_CONTEXT, *PHELPER_CONTEXT;


//
// Macros for callbacks. Assumes there is a local variable called OcManager
// that is of type POC_MANAGER.
//
#define OcFillInSetupDataA(p)   OcManager->Callbacks.FillInSetupDataA(p)
#ifdef UNICODE
#define OcFillInSetupDataW(p)   OcManager->Callbacks.FillInSetupDataW(p)
#endif
#define OcLogError              OcManager->Callbacks.LogError

//
// Global table of helper routines.
//

extern OCMANAGER_ROUTINESA HelperRoutinesA;
#ifdef UNICODE
extern OCMANAGER_ROUTINESW HelperRoutinesW;
#endif

extern EXTRA_ROUTINESA ExtraRoutinesA;
#ifdef UNICODE
extern EXTRA_ROUTINESW ExtraRoutinesW;
#endif

// ocm phase ids for reporting errors with

typedef enum {
    pidCallComponent = 0,
    pidLoadComponent,
    pidPreInit,
    pidInitComponent,
    pidRequestPages,
    pidCalcDiskSpace,
    pidQueueFileOps,
    pidQueryStepCount,
    pidCompleteInstallation,
    pidExtraRoutines
} pid;


//
// Misc routines.
//
VOID
pOcGetApproximateDiskSpace(
    IN POC_MANAGER OcManager
    );

LONG
pOcGetTopLevelComponent(
    IN POC_MANAGER OcManager,
    IN LONG        StringId
    );

VOID
pOcTickSetupGauge(
    IN OUT POC_MANAGER OcManager
    );

UINT
_LogError(
    IN POC_MANAGER  OcManager,
    IN OcErrorLevel ErrorLevel,
    IN UINT         MessageId,
    ...
    );

UINT
pOcCreateComponentSpecificMiniIcon(
    IN POC_MANAGER OcManager,
    IN LONG        ComponentId,
    IN LPCTSTR     Subcomponent,
    IN UINT        Width,
    IN UINT        Height,
    IN LPCTSTR     DllName,         OPTIONAL
    IN LPCTSTR     ResourceId       OPTIONAL
    );

VOID
pOcUpdateParentSelectionStates(
    IN POC_MANAGER OcManager,
    IN HWND        ListBox,             OPTIONAL
    IN LONG        SubcomponentStringId
    );

VOID
pOcFormSuitePath(
    IN  LPCTSTR SuiteName,
    IN  LPCTSTR FileName,   OPTIONAL
    OUT LPTSTR  FullPath
    );

BOOL
OcHelperConfirmCancel(
    IN HWND ParentWindow
    );

BOOL
pOcDoesAnyoneWantToSkipPage(
    IN OUT POC_MANAGER   OcManager,
    IN     OcManagerPage WhichPage
    );

VOID
pOcExternalProgressIndicator(
    IN PHELPER_CONTEXT OcManagerContext,
    IN BOOL            ExternalIndicator
    );

BOOL
pConvertStringToLongLong(
    IN  PCTSTR   String,
    OUT PLONGLONG Value
    );

VOID
pOcFreeOcSetupPage(
    IN PVOID SetupPageData
    );

HRESULT
FTestForOutstandingCoInits(
    VOID
    );

//
// wrapper for calling components
//
DWORD
CallComponent(
    IN     POC_MANAGER OcManager,
    IN     POPTIONAL_COMPONENT Oc,
    IN     LPCVOID ComponentId,
    IN     LPCVOID SubcomponentId,
    IN     UINT    Function,
    IN     UINT_PTR Param1,
    IN OUT PVOID   Param2
    );

//
// Interfacing routines.
//
UINT
OcInterfacePreinitialize(
    IN OUT POC_MANAGER OcManager,
    IN     LONG        ComponentId
    );

UINT
OcInterfaceInitComponent(
    IN OUT POC_MANAGER OcManager,
    IN     LONG        ComponentId
    );

UINT
OcInterfaceExtraRoutines(
    IN OUT POC_MANAGER OcManager,
    IN     LONG        ComponentId
    );

SubComponentState
OcInterfaceQueryState(
    IN OUT POC_MANAGER OcManager,
    IN     LONG        ComponentId,
    IN     LPCTSTR     Subcomponent,
    IN     UINT        WhichState
    );

BOOL
OcInterfaceSetLanguage(
    IN OUT POC_MANAGER OcManager,
    IN     LONG        ComponentId,
    IN     WORD        LanguageId
    );

HBITMAP
OcInterfaceQueryImage(
    IN OUT POC_MANAGER      OcManager,
    IN     LONG             ComponentId,
    IN     LPCTSTR          Subcomponent,
    IN     SubComponentInfo WhichImage,
    IN     UINT             DesiredWidth,
    IN     UINT             DesiredHeight
    );

HBITMAP
OcInterfaceQueryImageEx(
    IN OUT POC_MANAGER      OcManager,
    IN     LONG             ComponentId,
    IN     LPCTSTR          Subcomponent,
    IN     SubComponentInfo WhichImage,
    IN     UINT             DesiredWidth,
    IN     UINT             DesiredHeight
    );



VOID
OcInterfaceWizardCreated(
    IN OUT POC_MANAGER OcManager,
    IN     LONG        ComponentId,
    IN     HWND        DialogHandle
    );

UINT
OcInterfaceRequestPages(
    IN OUT POC_MANAGER           OcManager,
    IN     LONG                  ComponentId,
    IN     WizardPagesType       WhichPages,
    OUT    PSETUP_REQUEST_PAGES *RequestPages
    );

BOOL
OcInterfaceQuerySkipPage(
    IN OUT POC_MANAGER   OcManager,
    IN     LONG          ComponentId,
    IN     OcManagerPage WhichPage
    );

BOOL
OcInterfaceNeedMedia(
    IN OUT POC_MANAGER   OcManager,
    IN     LONG          ComponentId,
    IN     PSOURCE_MEDIA SourceMedia,
    OUT    LPTSTR        NewPath
    );

BOOL
OcInterfaceFileBusy(
    IN OUT POC_MANAGER   OcManager,
    IN     LONG          ComponentId,
    IN     PFILEPATHS    FIlePaths,
    OUT    LPTSTR        NewPath
    );

BOOL
OcInterfaceQueryChangeSelState(
    IN OUT POC_MANAGER OcManager,
    IN     LONG        ComponentId,
    IN     LPCTSTR     Subcomponent,
    IN     BOOL        Selected,
    IN     UINT        Flags
    );

UINT
OcInterfaceCalcDiskSpace(
    IN OUT POC_MANAGER OcManager,
    IN     LONG        ComponentId,
    IN     LPCTSTR     Subcomponent,
    IN     HDSKSPC     DiskSpaceList,
    IN     BOOL        AddingToList
    );

UINT
OcInterfaceQueueFileOps(
    IN OUT POC_MANAGER OcManager,
    IN     LONG        ComponentId,
    IN     LPCTSTR     Subcomponent,
    IN     HSPFILEQ    FileQueue
    );

UINT
OcInterfaceQueryStepCount(
    IN OUT POC_MANAGER OcManager,
    IN     LONG        ComponentId,
    IN     LPCTSTR     Subcomponent,
    OUT    PUINT       StepCount
    );

UINT
OcInterfaceCompleteInstallation(
    IN OUT POC_MANAGER OcManager,
    IN     LONG        ComponentId,
    IN     LPCTSTR     Subcomponent,
    IN     BOOL        PreQueueCommit
    );

VOID
OcInterfaceCleanup(
    IN OUT POC_MANAGER OcManager,
    IN     LONG        ComponentId
    );

DWORD
StandAloneSetupAppInterfaceRoutine(
    IN     LPCVOID ComponentId,
    IN     LPCVOID SubcomponentId,
    IN     UINT    Function,
    IN     UINT_PTR Param1,
    IN OUT PVOID   Param2
    );

//
// Persistent state fetch/store
//
BOOL
pOcFetchInstallStates(
    IN POC_MANAGER OcManager
    );

BOOL
pOcRememberInstallStates(
    IN POC_MANAGER OcManager
    );

BOOL
pOcSetOneInstallState(
    IN POC_MANAGER OcManager,
    IN LONG        StringId
    );

BOOL
pOcRemoveComponent(
    IN POC_MANAGER OcManager,
    IN LONG        ComponentId,
    IN DWORD       PhaseId
    );

BOOL
pOcComponentWasRemoved(
    IN POC_MANAGER OcManager,
    IN LONG        ComponentId
    );

BOOL
pOcHelperReportExternalError(
    IN POC_MANAGER OcManager,
    IN LONG     ComponentId,
    IN LONG     SubcomponentId,   OPTIONAL
    IN DWORD_PTR MessageId,
    IN DWORD    Flags,
    ...
    );
//
// Use this flag to call OcHelperReportExternalError and use
// a Message ID defined in the OCManage.dll
//
#define ERRFLG_OCM_MESSAGE   0x80000000

BOOL
OcHelperClearExternalError (
    IN POC_MANAGER   OcManager,
    IN LONG ComponentId,
    IN LONG SubcomponentId   OPTIONAL
    );


//
// Debuging stuff
//
#if DBG
#define _OC_DBG
#endif

//
// should not be defined for retail release!!!
//
#if PRERELEASE
#define _OC_DBG
#endif

VOID
_ErrOut(
    IN LPCTSTR Format,
    ...
    );

VOID
_WrnOut(
    IN LPCTSTR Format,
    ...
    );

VOID
_TrcOut(
    IN LPCTSTR Format,
    ...
    );

#define ERR(x)      _ErrOut  x

//
// these guys are switched out in a free build.
//
#ifdef _OC_DBG
    #define TRACE(x)    _TrcOut x
    #define WRN(x)      _WrnOut x
    #define DBGOUT(x)   \
                        if (gDebugLevel >= 100) _TrcOut  x
#else
    #define TRACE(x)
    #define WRN(x)
    #define DBGOUT(x)
#endif

// Normally a call to tmbox is for debug tracing and all such calls
// should be removed before checking in.  However, if called through
// the mbox() macro, this indicates the call is meant to ship.

DWORD
tmbox(
      LPCTSTR fmt,
      ...
      );

#define mbox tmbox
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ocmanage\common\ocdskspc.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    ocdskspc.c

Abstract:

    Routines to ask subcomponents for the approximate amount
    of disk space they take up.

Author:

    Ted Miller (tedm) 17-Sep-1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


VOID
pOcGetChildrenApproximateDiskSpace(
    IN     POC_MANAGER  OcManager,
    IN     LONG         TopLevelOcId,
    IN     LONG         CurrentOcId,
    IN     LPCTSTR      DriveSpec
    )

/*++

Routine Description:

    Worker routine for pOcGetApproximateDiskSpace(). This routine recursively
    iterates through a hierarchy of subcomponents, asking leaf components
    for their space (via the OC_CALC_DISK_SPACE interface routine) and amalgamating
    child results at non-leaf nodes.

    We use the OC_CALC_DISK_SPACE interface routine with an the "ignore-on-disk"
    disk space list, to trick the components into telling us how much space their
    files take up.

Arguments:

    OcManager - supplies OC Manager context.

    TopLevelOcId - supplies string id in the component string table for the
        top-level subcomponent at the root of the hierarchy whose disk space
        is being summed.

    CurrentOcId - supplies string id for subcomponent whose disk space is
        being summed.

    DriveSpec - supplies drive spec of drive we care about for space calculations,
        ie, the drive where the system is installed.

    AccumulatedSpace - receives the summed space for all the children of the
        current subcomponent, or the component itself if it's a leaf node.

Return Value:

    None.

--*/

{
    HDSKSPC DiskSpaceList;
    LONGLONG Space = 0;
    LONG Id;
    OPTIONAL_COMPONENT CurrentOc;
    OPTIONAL_COMPONENT Oc;

    pSetupStringTableGetExtraData(
        OcManager->ComponentStringTable,
        CurrentOcId,
        &CurrentOc,
        sizeof(OPTIONAL_COMPONENT)
        );

    if(CurrentOc.FirstChildStringId == -1) {

        if ( TopLevelOcId == pOcGetTopLevelComponent(OcManager,CurrentOcId) ){

            //
            // only get the approximate disk space if we haven't already retreived it from their inf
            //
            if ((CurrentOc.InternalFlags & OCFLAG_APPROXSPACE) ==0) {

                //
                // This oc is a child/leaf component.
                // Create an ignore-disk disk space list and ask
                // the component dll to add its files to it.
                //
                if(DiskSpaceList = SetupCreateDiskSpaceList(0,0,SPDSL_IGNORE_DISK | SPDSL_DISALLOW_NEGATIVE_ADJUST)) {

                    OcInterfaceCalcDiskSpace(
                        OcManager,
                        pOcGetTopLevelComponent(OcManager,CurrentOcId),
                        pSetupStringTableStringFromId(OcManager->ComponentStringTable,CurrentOcId),
                        DiskSpaceList,
                        TRUE
                        );

                    if(!SetupQuerySpaceRequiredOnDrive(DiskSpaceList,DriveSpec,&Space,0,0)) {
                        Space = 0;
                    }
            
                    SetupDestroyDiskSpaceList(DiskSpaceList);
                }
                DBGOUT((
                   TEXT("OCM: pOcGetChildrenApproximateDiskSpace COMP(%s) SUB(%s)\n"),
                    pSetupStringTableStringFromId( OcManager->ComponentStringTable,  TopLevelOcId),
                    pSetupStringTableStringFromId( OcManager->ComponentStringTable,  CurrentOcId)
                ));
                DBGOUT((TEXT("OCM: Space=%#lx%08lx\n"),(LONG)(Space>>32),(LONG)Space));

                //
                // Now store the required space we just calculated
                //
                CurrentOc.SizeApproximation = Space;

                pSetupStringTableSetExtraData(
                    OcManager->ComponentStringTable,
                    CurrentOcId,
                    &CurrentOc,
                    sizeof(OPTIONAL_COMPONENT)
                    );
            }
        }

    } else {
        //
        // Parent component. Do all the children, accumulating the result.
        //

        Id = CurrentOc.FirstChildStringId;

        do {
            pOcGetChildrenApproximateDiskSpace(OcManager,TopLevelOcId,Id,DriveSpec);

            pSetupStringTableGetExtraData(
                OcManager->ComponentStringTable,
                Id,
                &Oc,
                sizeof(OPTIONAL_COMPONENT)
                );

            Id = Oc.NextSiblingStringId;

        } while(Id != -1);

        //
        // Now store the required space we just calculated
        //
        CurrentOc.SizeApproximation = Space;

        pSetupStringTableSetExtraData(
            OcManager->ComponentStringTable,
            CurrentOcId,
            &CurrentOc,
            sizeof(OPTIONAL_COMPONENT)
            );
    }

}

VOID
pOcSumApproximateDiskSpace(
    IN     POC_MANAGER  OcManager,
    IN     LONG         CurrentOcId,
    IN OUT LONGLONG    *AccumulatedSpace
    )

/*++

Routine Description:

    Worker routine for pOcGetApproximateDiskSpace(). This routine recursively
    iterates through a hierarchy of subcomponents, adding up leaf components
    for their space via the stored Estimated Amount

Arguments:

    OcManager - supplies OC Manager context.

    CurrentOcId - supplies string id for subcomponent whose disk space is
        being summed.

    AccumulatedSpace - receives the summed space for all the children of the
        current subcomponent, or the component itself if it's a leaf node.

Return Value:

    None.

--*/

{
    LONGLONG Space;
    LONG Id;
    OPTIONAL_COMPONENT CurrentOc;
    OPTIONAL_COMPONENT Oc;

    pSetupStringTableGetExtraData(
        OcManager->ComponentStringTable,
        CurrentOcId,
        &CurrentOc,
        sizeof(OPTIONAL_COMPONENT)
        );

    if(CurrentOc.FirstChildStringId == -1) {
        DBGOUT((TEXT("Child ")));

        Space = CurrentOc.SizeApproximation;
    } else {
        //
        // Parent component. Do all the children, accumulating the result.
        //
        Space = 0;
        DBGOUT((TEXT("Parent ")));
        DBGOUT((
            TEXT("SUB(%s)"),
            pSetupStringTableStringFromId( OcManager->ComponentStringTable,  CurrentOcId)
            ));
        DBGOUT((TEXT("Space=%#lx%08lx\n"),(LONG)(Space>>32),(LONG)Space));

        Id = CurrentOc.FirstChildStringId;

        do {
            pOcSumApproximateDiskSpace(OcManager,Id,&Space);

            pSetupStringTableGetExtraData(
                OcManager->ComponentStringTable,
                Id,
                &Oc,
                sizeof(OPTIONAL_COMPONENT)
                );

            Id = Oc.NextSiblingStringId;

        } while(Id != -1);

    }

    *AccumulatedSpace += Space;

    CurrentOc.SizeApproximation = Space;
    pSetupStringTableSetExtraData(
            OcManager->ComponentStringTable,
            CurrentOcId,
            &CurrentOc,
            sizeof(OPTIONAL_COMPONENT)
           );

    DBGOUT((TEXT(" SUB(%s)"),
           pSetupStringTableStringFromId( OcManager->ComponentStringTable,  CurrentOcId)));

    DBGOUT((TEXT(" Space=%#lx%08lx "),(LONG)(Space>>32),(LONG)Space));
    DBGOUT((TEXT(" AccumulatedSpace=%#lx%08lx\n"),(LONG)(*AccumulatedSpace>>32),(LONG)*AccumulatedSpace));

}


VOID
pOcGetApproximateDiskSpace(
    IN POC_MANAGER OcManager
    )

/*++

Routine Description:

    This routine is used to get an approximate disk space usage number
    for display in the oc page. This number bears no relation to what is
    currently on the disk; rather it merely reflects the approximate of space
    the component takes up in an absolute, independent sense, when installed.

Arguments:

    OcManager - supplies OC Manager context.

Return Value:

    None.

--*/

{
    UINT iChild,n;
    TCHAR Drive[MAX_PATH];
    LONGLONG Space;
    OPTIONAL_COMPONENT Oc;

    // We check the return code of GetWindowsDirectory to make Prefix happy.

    if (0 == GetWindowsDirectory(Drive,MAX_PATH))
        return;

    Drive[2] = 0;

    //
    // Iterate through top-level components. We only care about
    // ones that have per-component infs, since those are the
    // only ones that will show up in the OC Page.
    //
    for(n=0; n<OcManager->TopLevelOcCount; n++) {

        pSetupStringTableGetExtraData(
            OcManager->ComponentStringTable,
            OcManager->TopLevelOcStringIds[n],
            &Oc,
            sizeof(OPTIONAL_COMPONENT)
            );

        if(Oc.InfStringId != -1) {
            for(iChild=0;
                iChild<OcManager->TopLevelParentOcCount;
                iChild++)
            {
            //
            // Now call the component dll for each child subcomponent.
            //

                pOcGetChildrenApproximateDiskSpace(
                    OcManager,
                    OcManager->TopLevelOcStringIds[n],
                    OcManager->TopLevelParentOcStringIds[iChild],
                    Drive
                    );
            }
        }
    }

    // Now final pass Sum the all the information in to parent nodes

    for(n=0; n<OcManager->TopLevelParentOcCount; n++) {

        pSetupStringTableGetExtraData(
            OcManager->ComponentStringTable,
            OcManager->TopLevelParentOcStringIds[n],
            &Oc,
            sizeof(OPTIONAL_COMPONENT)
            );
        Space = 0;
        pOcSumApproximateDiskSpace(
                OcManager,
                OcManager->TopLevelParentOcStringIds[n],
                &Space
             );
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ocmanage\common\ochelper.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    ochelper.c

Abstract:

    Helper/callback routines, available to plug-in components
    when processing interface routine calls.

Author:

    Ted Miller (tedm) 13-Sep-1996

Revision History:

--*/


#include "precomp.h"
#pragma hdrstop

#include <stdio.h>
#include <stdarg.h>

//
// Window handle of wizard dialog. Set when the OC Manager client
// calls OcRememberWizardDialogHandle.
//
HWND WizardDialogHandle;

VOID 
OcHelperShowHideWizardPage(
    IN PVOID OcManagerContext,
    IN BOOL bShow
    )
{
    POC_MANAGER p = ((PHELPER_CONTEXT)OcManagerContext)->OcManager;
    if (p->Callbacks.ShowHideWizardPage)
    {
        // If we have a callback, hide the wizard.
        p->Callbacks.ShowHideWizardPage(bShow);
    }
}


VOID
OcHelperTickGauge(
    IN PVOID OcManagerContext
    )

/*++

Routine Description:

    Function used while processing the OC_COMPLETE_INSTALLATION Interface function
    to step the progress gauge being run by the OC Manager.
    Ignored at other times.

Arguments:

    OcManagerContext - supplies OC Manager context information the component gets
        from the OcManagerContext field of the OCMANAGER_ROUTINES structure.

Return Value:

    None.

--*/

{
    pOcTickSetupGauge(((PHELPER_CONTEXT)OcManagerContext)->OcManager);
}


VOID
#ifdef UNICODE
OcHelperSetProgressTextW(
#else
OcHelperSetProgressTextA(
#endif
    IN PVOID   OcManagerContext,
    IN LPCTSTR Text
    )

/*++

Routine Description:

    Function used while processing the OC_COMPLETE_INSTALLATION Interface function
    to change the text associated with the progress gauge being run by
    the OC Manager. Ignored at other times.

Arguments:

    OcManagerContext - supplies OC Manager context information the component gets
        from the OcManagerContext field of the OCMANAGER_ROUTINES structure.

    Text - Supplies the text for the progress gauge. The component should try to
        respect the current language parameters established by OC_SET_LANGUAGE.
        The OC Manager will make a copy of the string and truncate it as necessary.

Return Value:

    None.

--*/

{
    POC_MANAGER p = ((PHELPER_CONTEXT)OcManagerContext)->OcManager;

#ifdef DEBUGPERFTRACE
    static DWORD lasttickcount = 0;
    static DWORD currenttickcount = 0;
    static DWORD diff, lastdiff;

    if (!lasttickcount)
        lasttickcount = GetTickCount();

    lasttickcount = currenttickcount;
    currenttickcount = GetTickCount();
    lastdiff = diff;
    diff = currenttickcount - lasttickcount;
    TRACE(( TEXT("SetProgressText at %d (last = %d, diff = %d, last diff = %d)\n"), currenttickcount, lasttickcount, diff, lastdiff ));
    if (diff > 1000*3) {
        WRN(( TEXT("It's been > 3 seconds since the last tick count update...the user is getting impatient.\n") ));
    }

#endif

    if(p->ProgressTextWindow) {
        SetWindowText(p->ProgressTextWindow,Text);
    }
}


#ifdef UNICODE
VOID
OcHelperSetProgressTextA(
    IN PVOID  OcManagerContext,
    IN LPCSTR Text
    )

/*++

Routine Description:

    ANSI version of OcHelperSetProgressText().

Arguments:

Return Value:

--*/

{
    LPCWSTR p;

    if(p = pSetupAnsiToUnicode(Text)){
        OcHelperSetProgressTextW(OcManagerContext,p);
        pSetupFree(p);
    }
}
#endif


UINT
_OcHelperSetPrivateData(
    IN PVOID   OcManagerContext,
    IN LPCVOID Name,
    IN PVOID   Data,
    IN UINT    Size,
    IN UINT    Type,
    IN BOOL    IsNativeCharWidth
    )
{
    PHELPER_CONTEXT HelperContext;
    DWORD rc;
    DWORD Disposition;
    HKEY hKey;
    LONG id;

    HelperContext = OcManagerContext;

    //
    // Fetch the component id. If we're processing an interface routine
    // then use the component id of the active component. Otherwise
    // resort to the component id stored in the helper context.
    //
    if(HelperContext->OcManager->CurrentComponentStringId == -1) {
        id = HelperContext->ComponentStringId;
    } else {
        id = HelperContext->OcManager->CurrentComponentStringId;
    }

    rc = RegCreateKeyEx(
            HelperContext->OcManager->hKeyPrivateData,
            pSetupStringTableStringFromId(HelperContext->OcManager->ComponentStringTable,id),
            0,
            NULL,
            REG_OPTION_VOLATILE,
            KEY_SET_VALUE,
            NULL,
            &hKey,
            &Disposition
            );

    if(rc == NO_ERROR) {
        if(IsNativeCharWidth) {
            rc = RegSetValueEx(hKey,Name,0,Type,Data,Size);
        } else {
            rc = RegSetValueExA(hKey,Name,0,Type,Data,Size);
        }
        RegCloseKey(hKey);
    }

    return(rc);
}


UINT
#ifdef UNICODE
OcHelperSetPrivateDataW(
#else
OcHelperSetPrivateDataA(
#endif
    IN PVOID   OcManagerContext,
    IN LPCTSTR Name,
    IN PVOID   Data,
    IN UINT    Size,
    IN UINT    Type
    )

/*++

Routine Description:

    Function to set a named datum that can then be retrieved later
    by the component or by any other component, via the GetPrivateData
    helper routine.

    This routine can be called at any time.

Arguments:

    OcManagerContext - supplies OC Manager context information the component gets
        from the OcManagerContext field of the OCMANAGER_ROUTINES structure.

    Name - Supplies a name for the datum. If a datum with this name
        already exists for the component, it is overwritten.

    Data - Supplies the data itself. The OC Manager makes a copy of the data
        so the component need not ensure that this buffer remains valid.

    Size - Supplies the size in bytes of the data.

    Type - Supplies the type of the data. Components should use the standard registry
        type names (REG_SZ, REG_BINARY, etc.) to facilitate inter-component
        data sharing.

Return Value:

    Win32 error code indicating outcome; NO_ERROR means success.

--*/

{
    return(_OcHelperSetPrivateData(OcManagerContext,Name,Data,Size,Type,TRUE));
}


#ifdef UNICODE
UINT
OcHelperSetPrivateDataA(
    IN PVOID  OcManagerContext,
    IN LPCSTR Name,
    IN PVOID  Data,
    IN UINT   Size,
    IN UINT   Type
    )

/*++

Routine Description:

    ANSI version of OcHelperSetPrivateData().

Arguments:

Return Value:

--*/

{
    return(_OcHelperSetPrivateData(OcManagerContext,Name,Data,Size,Type,FALSE));
}
#endif


UINT
_OcHelperGetPrivateData(
    IN     PVOID   OcManagerContext,
    IN     LPCTSTR ComponentId,     OPTIONAL
    IN     LPCVOID Name,
    OUT    PVOID   Data,            OPTIONAL
    IN OUT PUINT   Size,
    OUT    PUINT   Type,
    IN     BOOL    IsNativeCharWidth
    )
{
    PHELPER_CONTEXT HelperContext;
    PCTSTR ComponentName;
    DWORD rc;
    DWORD Disposition;
    HKEY hKey;
    LONG id;

    HelperContext = OcManagerContext;

    //
    // Figure out the name of the component that owns the data.
    //
    if(ComponentId) {
        ComponentName = ComponentId;
    } else {
        if(HelperContext->OcManager->CurrentComponentStringId == -1) {
            id = HelperContext->ComponentStringId;
        } else {
            id = HelperContext->OcManager->CurrentComponentStringId;
        }
        ComponentName = pSetupStringTableStringFromId(
                            HelperContext->OcManager->ComponentStringTable,
                            id
                            );
        if (!ComponentName) {
           rc = GetLastError();
           goto exit;
        }
    }

    rc = RegCreateKeyEx(
            HelperContext->OcManager->hKeyPrivateData,
            ComponentName,
            0,
            NULL,
            REG_OPTION_VOLATILE,
            KEY_QUERY_VALUE,
            NULL,
            &hKey,
            &Disposition
            );

    if(rc == NO_ERROR) {
        if(IsNativeCharWidth) {
            rc = RegQueryValueEx(hKey,Name,0,Type,Data,Size);
        } else {
            rc = RegQueryValueExA(hKey,Name,0,Type,Data,Size);
        }
        if(rc == ERROR_MORE_DATA) {
            rc = ERROR_INSUFFICIENT_BUFFER;
        }
        RegCloseKey(hKey);
    }

exit:
    return(rc);
}

UINT
#ifdef UNICODE
OcHelperGetPrivateDataW(
#else
OcHelperGetPrivateDataA(
#endif
    IN     PVOID   OcManagerContext,
    IN     LPCTSTR ComponentId,     OPTIONAL
    IN     LPCTSTR Name,
    OUT    PVOID   Data,            OPTIONAL
    IN OUT PUINT   Size,
    OUT    PUINT   Type
    )

/*++

Routine Description:

    Function to retrieve a named datum that was previously set via
    SetPrivateData by the component or by any other component.

    This routine can be called at any time.

Arguments:

    OcManagerContext - supplies OC Manager context information the component gets
        from the OcManagerContext field of the OCMANAGER_ROUTINES structure.

    ComponentId - Supplies the short descriptive name of the component
        (as specified in OC.INF) that set/owns the datum to be retrieved.
        NULL means the current component.

    Name - Supplies the name of the datum to be retrieved.

    Data - If specified, receives the data. If not specified, the routine puts
        the required size in Size and returns NO_ERROR.

    Size - On input, supplies the size of the buffer pointed to by Data
        (ignored if Data is not specified). On output, receives the size of
        the data stored, or the required size if the buffer is not large enough.

    Type - Upon successful completion receives the type of the datum.

Return Value:

    NO_ERROR: If Data was specified, the requested datum had been placed in
        the caller's buffer. If Data was not specified, then the required size
        has been placed in the UINT pointed to by Size.

    ERROR_INSUFFICIENT_BUFFER: the specified buffer size is too small
        to contain the datum. The required size has been placed in the UINT
        pointed to by Size.

    Other Win32 error codes indicate additional error cases, such as the
    datum not being found, etc.

--*/

{
    return(_OcHelperGetPrivateData(OcManagerContext,ComponentId,Name,Data,Size,Type,TRUE));
}


#ifdef UNICODE
UINT
OcHelperGetPrivateDataA(
    IN     PVOID  OcManagerContext,
    IN     LPCSTR ComponentId,  OPTIONAL
    IN     LPCSTR Name,
    OUT    PVOID  Data,         OPTIONAL
    IN OUT PUINT  Size,
    OUT    PUINT  Type
    )

/*++

Routine Description:

    ANSI version of OcHelperGetPrivateData().

Arguments:

Return Value:

--*/

{
    LPCWSTR component;
    UINT u;

    if(ComponentId) {
        component = pSetupAnsiToUnicode(ComponentId);
        if(!component) {
            u = ERROR_NOT_ENOUGH_MEMORY;
            goto c0;
        }
    } else {
        component = NULL;
    }

    u = _OcHelperGetPrivateData(OcManagerContext,component,Name,Data,Size,Type,FALSE);

    if(component) {
        pSetupFree(component);
    }
c0:
    return(u);
}
#endif


UINT
OcHelperSetSetupMode(
    IN PVOID OcManagerContext,
    IN DWORD SetupMode
    )

/*++

Routine Description:

    Function that can be used at any time while a component is
    processing any Interface function or any of its wizard pages.
    It is used to set the current setup mode. It is expected that if a
    component supplies a setup mode page, it will use this routine to
    inform the OC Manager of the setup mode the user chose.

Arguments:

    OcManagerContext - supplies OC Manager context information the component gets
        from the OcManagerContext field of the OCMANAGER_ROUTINES structure.

    SetupMode - Supplies a numeric value that indicates the setup mode. This may be
        any of the 4 standard values (minimal, laptop, custom, or typical).
        It can also be any other private value that has meaning to a suite or bundle.
        In that case the low 8 bits are interpreted as one of the standard values
        so the mode can be meaningful to other components and the OC Manager,
        who know nothing about private mode types. The component setting the mode
        should attempt to set this as reasonably as possible. The upper 24 bits are
        essentially private mode data.

Return Value:

    The return value is the previous mode.

--*/

{
    POC_MANAGER p = ((PHELPER_CONTEXT)OcManagerContext)->OcManager;
    UINT Mode;

    Mode = p->SetupMode;
    p->SetupMode = SetupMode;

    return(Mode);
}


UINT
OcHelperGetSetupMode(
    IN PVOID OcManagerContext
    )

/*++

Routine Description:

    Function that can be used at any time while a component is processing
    any Interface function or any of its wizard pages. It is used to query
    the current setup mode. Note that this can be a private mode type,
    in which case the low 8 bits of the mode value can be interpreted as one of
    the standard 4 mode types and the upper 24 bits are private mode data.
    The mode can also be unknown. See section 3.2.1 for a list of standard
    mode types.

Arguments:

    OcManagerContext - supplies OC Manager context information the component gets
        from the OcManagerContext field of the OCMANAGER_ROUTINES structure.

Return Value:

    The return value is the current mode.

--*/

{
    POC_MANAGER p = ((PHELPER_CONTEXT)OcManagerContext)->OcManager;

    return(p->SetupMode);
}


BOOL
#ifdef UNICODE
OcHelperQuerySelectionStateW(
#else
OcHelperQuerySelectionStateA(
#endif
    IN PVOID   OcManagerContext,
    IN LPCTSTR SubcomponentId,
    IN UINT    StateType
    )

/*++

Routine Description:

    Function that can be used at any time.
    It is used determine the selection status of a particular subcomponent.

Arguments:

    OcManagerContext - supplies OC Manager context information the component gets
        from the OcManagerContext field of the OCMANAGER_ROUTINES structure.

    SubcomponentId - Supplies a subidentifier meaningful to the component
        being called. The OC Manager imposes no semantics on this subidentifier.

    StateType - supplies a constant indicating which state is to be returned
        (original or current).

Return Value:

    Boolean value indicating whether the subcomponent is selected
    for installation. If FALSE, GetLastError() will return something other than
    NO_ERROR if an error occurred, such as SubcomponentId being invalid.

--*/

{
    POC_MANAGER p = ((PHELPER_CONTEXT)OcManagerContext)->OcManager;
    OPTIONAL_COMPONENT Oc;
    LONG l;
    BOOL b;

    l = pSetupStringTableLookUpStringEx(
            p->ComponentStringTable,
            (LPTSTR)SubcomponentId,
            STRTAB_CASE_INSENSITIVE,
            &Oc,
            sizeof(OPTIONAL_COMPONENT)
            );

    if(l == -1) {
        SetLastError(ERROR_INVALID_NAME);
        return(FALSE);
    }

    switch(StateType) {

    case OCSELSTATETYPE_ORIGINAL:

        b = (Oc.OriginalSelectionState != SELSTATE_NO);
        SetLastError(NO_ERROR);
        break;

    case OCSELSTATETYPE_CURRENT:

        b = (Oc.SelectionState != SELSTATE_NO);
        SetLastError(NO_ERROR);
        break;

    case OCSELSTATETYPE_FINAL:

        b = (Oc.SelectionState != SELSTATE_NO);
        SetLastError(NO_ERROR);
        break;

    default:

        b = FALSE;
        SetLastError(ERROR_INVALID_PARAMETER);
        break;
    }

    return(b);
}

#ifdef UNICODE
OcHelperQuerySelectionStateA(
    IN PVOID  OcManagerContext,
    IN LPCSTR SubcomponentId,
    IN UINT   StateType
    )
{
    LPCWSTR id;
    DWORD d;
    BOOL b;

    id = pSetupAnsiToUnicode(SubcomponentId);
    if(!id) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

    b = OcHelperQuerySelectionStateW(OcManagerContext,id,StateType);
    d = GetLastError();

    pSetupFree(id);

    SetLastError(d);
    return(b);
}
#endif


UINT
#ifdef UNICODE
OcHelperCallPrivateFunctionW(
#else
OcHelperCallPrivateFunctionA(
#endif
    IN     PVOID   OcManagerContext,
    IN     LPCTSTR ComponentId,
    IN     LPCTSTR SubcomponentId,
    IN     UINT    Function,
    IN     UINT    Param1,
    IN OUT PVOID   Param2,
    OUT    PUINT   Result
    )

/*++

Routine Description:

    Function that can be used at any time while a component is
    processing any Interface function. It is used to call another component's
    interface entry point to perform some private function. This function
    cannot be used to call a standard interface function, nor can it be used
    to call a function in the DLL of the component making the call.

Arguments:

    OcManagerContext - supplies OC Manager context information the component gets
        from the OcManagerContext field of the OCMANAGER_ROUTINES structure.

    ComponentId - Supplies the short descriptive name of the component
        (as specified in OC.INF) to be called. This may not be the name of
        the current component.

    SubcomponentId - Supplies a subidentifier meaningful to the component
        being called. The OC Manager imposes no semantics on this subidentifier.

    Function - Supplies a function code meaningful to the component being called.
        This may not be one of the standard interface function codes.

    Param1, Param2 - Supply values meaningful to the component being called.
        The OC Manager imposes no semantics on these values.

    Result - If the OC Manager is successful in calling the other component,
        then this receives the return value from the other component's
        interface routine.

Return Value:

    Win32 error code indicating outcome. If NO_ERROR, then the other component
    was called and the result is stored in Result. If not NO_ERROR,
    then the other component was not called.

    ERROR_BAD_ENVIRONMENT - the function was called when the component is not
        processing an interface routine, or the caller is attempting to
        call a routine in itself.

    ERROR_INVALID_FUNCTION - Function is less then OC_PRIVATE_BASE.

    ERROR_ACCESS_DENIED - the requested component has no interface entry point.

--*/

{
    POC_MANAGER p = ((PHELPER_CONTEXT)OcManagerContext)->OcManager;
    BOOL b;
    LONG l;
    UINT i;
    OPTIONAL_COMPONENT OtherOc;
    LONG PreviousCurrentComponentStringId;

    //
    // Validate that we are processing an interface function and
    // that the requested function is not a standard function,
    // and that the caller wants to call a different component.
    //
    if(Function < OC_PRIVATE_BASE) {
        return(ERROR_INVALID_FUNCTION);
    }

    l = pSetupStringTableLookUpStringEx(
            p->ComponentStringTable,
            (PTSTR)ComponentId,
            STRTAB_CASE_INSENSITIVE,
            &OtherOc,
            sizeof(OPTIONAL_COMPONENT)
            );

    if(l == -1) {
        return(ERROR_INVALID_FUNCTION);
    }

    //
    // Make sure the component is top-level.
    //
    for(b=FALSE,i=0; !b && (i<p->TopLevelOcCount); i++) {
        if(p->TopLevelOcStringIds[i] == l) {
            b = TRUE;
        }
    }

    if((l == p->CurrentComponentStringId) || (p->CurrentComponentStringId == -1) || !b) {
        return(ERROR_BAD_ENVIRONMENT);
    }

    //
    // Make sure the component has an entry point.
    //
    if(!OtherOc.InstallationRoutine) {
        return(ERROR_ACCESS_DENIED);
    }

    //
    // Call the other component.
    //

#ifdef UNICODE
    //
    // If necessary, convert component and subcomponent to ansi
    //
    if(OtherOc.Flags & OCFLAG_ANSI) {

        LPCSTR comp,subcomp;

        comp = pSetupUnicodeToAnsi(ComponentId);
        if(!comp) {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
        if(SubcomponentId) {
            subcomp = pSetupUnicodeToAnsi(SubcomponentId);
            if(!subcomp) {
                pSetupFree(comp);
                return(ERROR_NOT_ENOUGH_MEMORY);
            }
        } else {
            subcomp = NULL;
        }

        PreviousCurrentComponentStringId = p->CurrentComponentStringId;
        p->CurrentComponentStringId = l;

        *Result = CallComponent(p, &OtherOc, comp, subcomp, Function, Param1, Param2);

        pSetupFree(comp);
        if(subcomp) {
            pSetupFree(subcomp);
        }
    } else
#endif
    {
        PreviousCurrentComponentStringId = p->CurrentComponentStringId;
        p->CurrentComponentStringId = l;

        *Result = CallComponent(p, &OtherOc, ComponentId, SubcomponentId, Function, Param1, Param2);
    }

    p->CurrentComponentStringId = PreviousCurrentComponentStringId;

    return(NO_ERROR);
}


#ifdef UNICODE
UINT
OcHelperCallPrivateFunctionA(
    IN     PVOID  OcManagerContext,
    IN     LPCSTR ComponentId,
    IN     LPCSTR SubcomponentId,
    IN     UINT   Function,
    IN     UINT   Param1,
    IN OUT PVOID  Param2,
    OUT    PUINT  Result
    )

/*++

Routine Description:

    ANSI version of OcHelperCallPrivateFunction().

Arguments:

Return Value:

--*/

{
    LPCWSTR comp,subcomp;
    UINT u;

    comp = pSetupAnsiToUnicode(ComponentId);
    if(!comp) {
        u = ERROR_NOT_ENOUGH_MEMORY;
        goto c0;
    }

    if(SubcomponentId) {
        subcomp = pSetupAnsiToUnicode(SubcomponentId);
        if(!subcomp) {
            u = ERROR_NOT_ENOUGH_MEMORY;
            goto c1;
        }
    } else {
        subcomp = NULL;
    }

    u = OcHelperCallPrivateFunctionW(
            OcManagerContext,
            comp,
            subcomp,
            Function,
            Param1,
            Param2,
            Result
            );

    if(subcomp) {
        pSetupFree(subcomp);
    }
c1:
    pSetupFree(comp);
c0:
    return(u);
}
#endif


BOOL
OcHelperConfirmCancel(
    IN HWND ParentWindow
    )

/*++

Routine Description:

    Ask the user whether he's sure he wants to cancel.

Arguments:

    ParentWindow - supplies window handle of parent window for ui

Return Value:

    TRUE if user wants to cancel. FALSE if not.

--*/

{
    TCHAR Message[1000];
    TCHAR Caption[200];
    int i;

    FormatMessage(
        FORMAT_MESSAGE_FROM_HMODULE,
        MyModuleHandle,
        MSG_QUERY_CANCEL,
        0,
        Message,
        sizeof(Message)/sizeof(TCHAR),
        NULL
        );

    LoadString(MyModuleHandle,IDS_SETUP,Caption,sizeof(Caption)/sizeof(TCHAR));

    i = MessageBox(
            ParentWindow,
            Message,
            Caption,
            MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2 | MB_SETFOREGROUND
            );

    return(i == IDYES);
}


HWND
OcHelperQueryWizardDialogHandle(
    IN PVOID OcManagerContext
    )
{
    UNREFERENCED_PARAMETER(OcManagerContext);

    return(WizardDialogHandle);
}


BOOL
OcHelperSetReboot(
    IN PVOID OcManagerContext,
    IN BOOL  Reserved
    )
{
    POC_MANAGER p = ((PHELPER_CONTEXT)OcManagerContext)->OcManager;
    UNREFERENCED_PARAMETER(Reserved);

    p->Callbacks.SetReboot();
    return(FALSE);
}


VOID
OcRememberWizardDialogHandle(
    IN PVOID OcManagerContext,
    IN HWND  DialogHandle
    )

/*++

Routine Description:

    This routine is called by the OC Manager client to inform the
    common library of the wizard's dialog handle.

    We will also turn around and notify all top-level components
    of the wizard dialog handle.

    Before doing so, we write the title into the window header.

Arguments:

    OcManagerContext - value returned from OcInitialize().

    DialogHandle - supplies the dialog handle of the wizard.

Return Value:

    None.

--*/

{
    UINT i;
    POC_MANAGER OcManager;

    WizardDialogHandle = DialogHandle;
    OcManager = OcManagerContext;

    if (*OcManager->WindowTitle) {
        SetWindowText(WizardDialogHandle, OcManager->WindowTitle);
    }

    for(i=0; i<OcManager->TopLevelOcCount; i++) {
        OcInterfaceWizardCreated(OcManager,OcManager->TopLevelOcStringIds[i],DialogHandle);
    }
}


HINF
OcHelperGetInfHandle(
    IN UINT  InfIndex,
    IN PVOID OcManagerContext
    )

/*++

Routine Description:

    This routine returns a handle to a well-known inf file that
    has been opened by oc manager.

Arguments:

    InfIndex - supplies value indicating which inf's handle is desired

    OcManagerContext - value returned from OcInitialize().

Return Value:

    Handle to INF, NULL if error.

--*/

{
    POC_MANAGER OcManager = ((PHELPER_CONTEXT)OcManagerContext)->OcManager;

    return((InfIndex == INFINDEX_UNATTENDED) ? OcManager->UnattendedInf : NULL);
}


BOOL
OcHelperClearExternalError (
    IN POC_MANAGER   OcManager,
    IN LONG ComponentId,
    IN LONG SubcomponentId   OPTIONAL
    )
 {
    LONG l;
    DWORD d;
    HKEY hKey;
    LPCTSTR  pValueName;

    //
    // If Subcomponetid is Zero then use the ComponentId
    //
    if ( SubcomponentId ) {
        pValueName = pSetupStringTableStringFromId(OcManager->ComponentStringTable,SubcomponentId);
    } else {
        pValueName = pSetupStringTableStringFromId(OcManager->ComponentStringTable,ComponentId);
    }

    if (!pValueName) {
        return ERROR_FILE_NOT_FOUND;
    }

    //
    // Attempt to open the key if successful delete it
    //
    l = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            szOcManagerErrors,
            0,
            KEY_QUERY_VALUE | KEY_SET_VALUE,
            &hKey
            );

    //
    // If an errror Key does not exist
    //
    if(l != NO_ERROR) {
        d = l;
        goto c1;
    }

    //
    // Delete this Subcomponent Key
    //
    l = RegDeleteValue( hKey, pValueName);
    d = l;

    RegCloseKey(hKey);

c1:
    SetLastError(d);
    return(d == NO_ERROR);
}

BOOL
_OcHelperReportExternalError(
    IN PVOID    OcManagerContext,
    IN LPCTSTR  ComponentId,
    IN LPCTSTR  SubcomponentId,   OPTIONAL
    IN DWORD_PTR MessageId,
    IN DWORD    Flags,
    IN va_list *arglist,
    IN BOOL     NativeCharWidth
    )
{
    POC_MANAGER OcManager = ((PHELPER_CONTEXT)OcManagerContext)->OcManager;
    HMODULE Module;
    OPTIONAL_COMPONENT Oc;
    LONG l;
    DWORD d;
    DWORD flags;
    LPTSTR MessageBuffer=NULL;
    LPCTSTR KeyValue;
    TCHAR fallback[20];
    HKEY hKey;
    DWORD Size;
    TCHAR *p;
    BOOL fmErr = FALSE;

    if ( ComponentId == NULL ) {
        //
        // if Component ID is null use the Suite Inf name
        //
        KeyValue = OcManager->SuiteName;

        //
        // if the message isn't preformatted, we have to retreive an error
        // from a component dll.  But if a component id wasn't specified, then
        // we cannot retrieve from a comopnent dll.  In that case, assume
        // that the message is to be retreived from the main OCM dll.
        //
        ZeroMemory( &Oc, sizeof(OPTIONAL_COMPONENT));
        if ((Flags & ERRFLG_PREFORMATTED) == 0) {
           Flags |= ERRFLG_OCM_MESSAGE;
        }

    } else {
        //
        // If SubcomponentId was Optional use the ComponentId
        //
        if ( SubcomponentId ) {
           KeyValue = SubcomponentId;
        } else {
           KeyValue = ComponentId;
        }

        // Look up the string in the master component table.
        // If it's not there, bail now.
        //
        l = pSetupStringTableLookUpStringEx(
            OcManager->ComponentStringTable,
            (PTSTR)ComponentId,
            STRTAB_CASE_INSENSITIVE,
            &Oc,
            sizeof(OPTIONAL_COMPONENT)
            );

        if(l == -1) {
            d = ERROR_INVALID_DATA;
            goto c0;
        }
    }

    //
    // Determine flags for FormatMessage
    //
    flags = FORMAT_MESSAGE_ALLOCATE_BUFFER;
    if(Flags & ERRFLG_SYSTEM_MESSAGE) {
        flags |= FORMAT_MESSAGE_FROM_SYSTEM;
    } else {
        flags |= FORMAT_MESSAGE_FROM_HMODULE;
    }
    if(Flags & ERRFLG_IGNORE_INSERTS) {
        flags |= FORMAT_MESSAGE_IGNORE_INSERTS;
    }
    if(Flags & ERRFLG_OCM_MESSAGE) {
        flags |= FORMAT_MESSAGE_FROM_HMODULE;

    }

    //
    // Format the message.
    //
#ifdef UNICODE
    if(!NativeCharWidth) {
        if (Flags & ERRFLG_PREFORMATTED ) {
            MessageBuffer = (LPTSTR) MessageId;
        } else {
            try {
                d = FormatMessageA(
                    flags,
                    Flags & ERRFLG_OCM_MESSAGE?MyModuleHandle:Oc.InstallationDll,         // ignored if system message
                    (DWORD)MessageId,
                    0,
                    (LPSTR)&MessageBuffer,
                    0,
                    arglist
                    );
            } except(EXCEPTION_EXECUTE_HANDLER) {
                fmErr = TRUE;
            }
            if (fmErr) {
                d = ERROR_INVALID_DATA;
                goto c0;
            }
            if(d) {
                //
                // Need to convert resulting message from ansi to unicode
                // so we can deal with it below. The LocalAlloc below overallocates
                // if some of the ansi chars are double-byte chars, too bad.
                //
                l = lstrlen(MessageBuffer)+1;
                if(p = (PVOID)LocalAlloc(LMEM_FIXED,l*sizeof(WCHAR))) {

                    d = MultiByteToWideChar(CP_ACP,MB_PRECOMPOSED,(LPSTR)MessageBuffer,-1,p,l);
                    if ( ! Flags & ERRFLG_PREFORMATTED ) {
                        LocalFree((HLOCAL)MessageBuffer);
                    }
                    if(d) {
                        MessageBuffer = p;
                    } else {
                        LocalFree((HLOCAL)p);
                    }

                } else {
                    if ( ! Flags & ERRFLG_PREFORMATTED ) {
                        LocalFree((HLOCAL)MessageBuffer);
                    }
                    d = 0;
                }
            }
        }

    } else
#endif
    {
        if (Flags & ERRFLG_PREFORMATTED ) {
            MessageBuffer = (LPTSTR) MessageId;
            d = 1;
        } else {
            try {
                d = FormatMessage(
                    flags,
                    Flags & ERRFLG_OCM_MESSAGE?MyModuleHandle:Oc.InstallationDll,         // ignored if system message
                    (DWORD)MessageId,
                    0,
                    (LPTSTR)&MessageBuffer,
                    0,
                    arglist
                    );
            } except(EXCEPTION_EXECUTE_HANDLER) {
                fmErr = TRUE;
            }
            if (fmErr) {
                d = ERROR_INVALID_DATA;
                goto c0;
            }
        }
        if(!d) {
            //
            // Put *something* in there
            //
            wsprintf(
                fallback,
                TEXT("#%s0x%x"),
                (Flags & ERRFLG_SYSTEM_MESSAGE) ? TEXT("SYS") : TEXT(""),
                MessageId
                );

            MessageBuffer = fallback;
        }
    }

    l = RegCreateKeyEx(
            HKEY_LOCAL_MACHINE,
            szOcManagerErrors,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_QUERY_VALUE | KEY_SET_VALUE,
            NULL,
            &hKey,
            &d
            );

    if(l != NO_ERROR) {
        d = l;
        goto c1;
    }

    //
    // Figure out how large of a buffer we need to encompass
    // the existing key and the string we're going to add to the end.
    //
    l = RegQueryValueEx(hKey,KeyValue,NULL,NULL,NULL,&Size);
    if(l == NO_ERROR) {
        if(Size == 0) {
            Size = 1;           // terminating nul
        }
    } else {
        Size = sizeof(TCHAR);   // terminating nul
    }

    Size += ((lstrlen(MessageBuffer) + 1) * sizeof(TCHAR));

    //
    // Allocate a buffer, read in the existing entry, and add the string
    // to the end.
    //
    p = (PVOID)LocalAlloc(LMEM_FIXED,Size);
    if(!p) {
        d = ERROR_NOT_ENOUGH_MEMORY;
        goto c2;
    }

    l = RegQueryValueEx(hKey,KeyValue,NULL,NULL,(BYTE *)p,&Size);
    if(l == NO_ERROR) {
        Size /= sizeof(TCHAR);
        if(Size == 0) {
            Size = 1;
        }
    } else {
        Size = 1;
    }
    lstrcpy(p+(Size-1),MessageBuffer);
    Size += lstrlen(MessageBuffer);
    p[Size++] = 0;

    d = RegSetValueEx(hKey,KeyValue,0,REG_MULTI_SZ,(CONST BYTE *)p,Size*sizeof(TCHAR));

    LocalFree((HLOCAL)p);
c2:
    RegCloseKey(hKey);
c1:
    if(MessageBuffer && MessageBuffer != fallback && MessageBuffer != (LPTSTR)MessageId ) {
        LocalFree((HLOCAL)MessageBuffer);
        d = 0;
    }
c0:
    SetLastError(d);
    return(d == NO_ERROR);
}


BOOL
pOcHelperReportExternalError(
    IN POC_MANAGER OcManager,
    IN LONG     ComponentId,
    IN LONG     SubcomponentId,   OPTIONAL
    IN DWORD_PTR MessageId,
    IN DWORD    Flags,
    ...
    )
{
    BOOL b;
    DWORD d;
    va_list arglist;
    HELPER_CONTEXT OcManagerContext;
    OcManagerContext.OcManager = OcManager;

    va_start(arglist,Flags);

    b = _OcHelperReportExternalError(
            &OcManagerContext,
            ComponentId ? pSetupStringTableStringFromId(OcManager->ComponentStringTable,ComponentId):NULL,
            SubcomponentId ? pSetupStringTableStringFromId(OcManager->ComponentStringTable,SubcomponentId):NULL,
            MessageId,
            Flags,
            &arglist,
            TRUE
            );

    d = GetLastError();

    va_end(arglist);

    SetLastError(d);
    return(b);
}



BOOL
#ifdef UNICODE
OcHelperReportExternalErrorW(
#else
OcHelperReportExternalErrorA(
#endif
    IN PVOID   OcManagerContext,
    IN LPCTSTR ComponentId,
    IN LPCTSTR SubcomponentId,   OPTIONAL
    IN DWORD_PTR MessageId,
    IN DWORD   Flags,
    ...
    )
{
    BOOL b;
    DWORD d;

    va_list arglist;

    va_start(arglist,Flags);

    b = _OcHelperReportExternalError(
            OcManagerContext,
            ComponentId,
            SubcomponentId,
            MessageId,
            Flags,
            &arglist,
            TRUE
            );

    d = GetLastError();

    va_end(arglist);

    SetLastError(d);
    return(b);
}


#ifdef UNICODE
BOOL
OcHelperReportExternalErrorA(
    IN PVOID  OcManagerContext,
    IN LPCSTR ComponentId,
    IN LPCSTR SubcomponentId,   OPTIONAL
    IN DWORD_PTR MessageId,
    IN DWORD  Flags,
    ...
    )
{
    LPCWSTR componentId,subcomponentId;
    DWORD d;
    BOOL b;
    va_list arglist;

    if (ComponentId) {
        componentId = pSetupAnsiToUnicode(ComponentId);
        if(!componentId) {
            d = ERROR_NOT_ENOUGH_MEMORY;
            b = FALSE;
            goto e0;
        }
    } else {
        componentId = NULL;
    }

    if(SubcomponentId) {
        subcomponentId = pSetupAnsiToUnicode(SubcomponentId);
        if(!subcomponentId) {
            d = ERROR_NOT_ENOUGH_MEMORY;
            b = FALSE;
            goto e1;
        }
    } else {
        subcomponentId = NULL;
    }

    va_start(arglist,Flags);

    b = _OcHelperReportExternalError(
            OcManagerContext,
            componentId,
            subcomponentId,
            MessageId,
            Flags,
            &arglist,
            FALSE
            );

    d = GetLastError();

    va_end(arglist);


    if(subcomponentId) {
        pSetupFree(subcomponentId);
    }

e1:
    if (componentId) {
        pSetupFree(componentId);
    }
e0:
    SetLastError(d);
    return(b);
}
#endif


#if 0
BOOL
#ifdef UNICODE
OcHelperSetSelectionStateW(
#else
OcHelperSetSelectionStateA(
#endif
    IN PVOID   OcManagerContext,
    IN LPCTSTR SubcomponentId,
    IN UINT    WhichState,
    IN UINT    NewState
    )

/*++

Routine Description:

    Function that can be used at any time.
    It is used determine the selection status of a particular subcomponent.

Arguments:

    OcManagerContext - supplies OC Manager context information the component gets
        from the OcManagerContext field of the OCMANAGER_ROUTINES structure.

    SubcomponentId - Supplies a subidentifier meaningful to the component
        being called. The OC Manager imposes no semantics on this subidentifier.

    StateType - supplies a constant indicating which state is to be returned
        (original or current).

Return Value:

    Boolean value indicating whether the subcomponent is selected
    for installation. If FALSE, GetLastError() will return something other than
    NO_ERROR if an error occurred, such as SubcomponentId being invalid.

--*/

{
    POC_MANAGER p = ((PHELPER_CONTEXT)OcManagerContext)->OcManager;
    OPTIONAL_COMPONENT Oc;
    LONG l;
    BOOL b;
    UINT *state;

    l = pSetupStringTableLookUpStringEx(
            p->ComponentStringTable,
            (LPTSTR)SubcomponentId,
            STRTAB_CASE_INSENSITIVE,
            &Oc,
            sizeof(OPTIONAL_COMPONENT)
            );

    if(l == -1) {
        SetLastError(ERROR_INVALID_NAME);
        return(FALSE);
    }

    switch (WhichState) {

    case OCSELSTATETYPE_ORIGINAL:
        state = &Oc.
        break;

    case OCSELSTATETYPE_CURRENT:
        state = &Oc.
        break;

    case OCSELSTATETYPE_FINAL:
        state = &Oc.
        break;

    default:
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    if (NewState != SubcompOn && NewState != SubcompOff) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    *state = NewState;

    pOcSetStatesStringWorker(l, NewState, OcPage);

    return(b);
}
#endif

BOOL
#ifdef UNICODE
OcLogErrorW(
#else
OcLogErrorA(
#endif
    IN PVOID  OcManagerContext,
    IN DWORD  ErrorLevel,
    IN LPCTSTR Msg,
    ...
    )
{
    TCHAR sz[5000];
    va_list arglist;
    POC_MANAGER p = ((PHELPER_CONTEXT)OcManagerContext)->OcManager;

    va_start(arglist, Msg);
    _vstprintf(sz, Msg, arglist);
    va_end(arglist);

    return p->Callbacks.LogError(ErrorLevel, sz);
}


#ifdef UNICODE
BOOL
OcLogErrorA(
    IN PVOID  OcManagerContext,
    IN DWORD  ErrorLevel,
    IN LPCSTR Msg,
    ...
    )
{
    PWSTR p;
    BOOL b;
    char sz[5000];
    va_list arglist;

    va_start(arglist, Msg);
    vsprintf(sz, Msg, arglist);
    va_end(arglist);

    p = pSetupAnsiToUnicode(sz);
    if (p) {
        b = OcLogErrorW(OcManagerContext, ErrorLevel, p);
        pSetupFree(p);
    } else {
        b = FALSE;
    }

    return(b);
}
#endif



//
// Now that we've got all the routines defined, we can build a table
// of routines.
//
OCMANAGER_ROUTINESA HelperRoutinesA = { NULL,                     // Context, filled in later.
                                        OcHelperTickGauge,
                                        OcHelperSetProgressTextA,
                                        OcHelperSetPrivateDataA,
                                        OcHelperGetPrivateDataA,
                                        OcHelperSetSetupMode,
                                        OcHelperGetSetupMode,
                                        OcHelperQuerySelectionStateA,
                                        OcHelperCallPrivateFunctionA,
                                        OcHelperConfirmCancel,
                                        OcHelperQueryWizardDialogHandle,
                                        OcHelperSetReboot,
                                        OcHelperGetInfHandle,
                                        OcHelperReportExternalErrorA,
                                        OcHelperShowHideWizardPage
                                      };

#ifdef UNICODE
OCMANAGER_ROUTINESW HelperRoutinesW = { NULL,                     // Context, filled in later.
                                        OcHelperTickGauge,
                                        OcHelperSetProgressTextW,
                                        OcHelperSetPrivateDataW,
                                        OcHelperGetPrivateDataW,
                                        OcHelperSetSetupMode,
                                        OcHelperGetSetupMode,
                                        OcHelperQuerySelectionStateW,
                                        OcHelperCallPrivateFunctionW,
                                        OcHelperConfirmCancel,
                                        OcHelperQueryWizardDialogHandle,
                                        OcHelperSetReboot,
                                        OcHelperGetInfHandle,
                                        OcHelperReportExternalErrorW,
                                        OcHelperShowHideWizardPage
                                      };
#endif

EXTRA_ROUTINESA ExtraRoutinesA = { sizeof(EXTRA_ROUTINESA),
                                   OcLogErrorA
                                 };

#ifdef UNICODE
EXTRA_ROUTINESW ExtraRoutinesW = { sizeof(EXTRA_ROUTINESW),
                                   OcLogErrorW
                                 };
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ocmanage\common\ocinterf.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    ocinterf.c

Abstract:

    Routines to interface with optional components via the OC Manager
    interface routine exported from the component's installation DLL.

Author:

    Ted Miller (tedm) 16-Sep-1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef DEBUGPERFTRACE

#define RES_BUFFER   512
#define MAX_LOGLINE  1024
#define EOL_LENGTH 3
#define BUFFER_SIZE 64*1024

VOID
DebugLogPerf(
    VOID
    )
{
    LPTSTR                      lpProcessName;
    NTSTATUS                    Status;
    ULONG                       Offset1;
    PUCHAR                      CurrentBuffer;
    PSYSTEM_PROCESS_INFORMATION ProcessInfo;
    LPTSTR                      lpTemp;//[RES_BUFFER];
    HMODULE                     hNtDll;
    LONG_PTR                    (*NtQSI)(); // Ptr to NtQuerySystemInformation
    HANDLE                      hProcessName;
    TCHAR                       szLogLine[MAX_LOGLINE+EOL_LENGTH];
    LPCTSTR                     szResBuf = TEXT("%7i%20ws->%10u%10u%10u%10u%10u%10u%10u\r\n");


    if ((hNtDll = LoadLibrary(TEXT("NTDLL.DLL"))) == NULL)
    {
        return;
    }

    NtQSI = GetProcAddress(hNtDll, "NtQuerySystemInformation" );
    if( NtQSI == NULL )
    {
        FreeLibrary(hNtDll);
        return;
    }


    //header for mem area
    TRACE (( TEXT("Proc ID           Proc.Name   Wrkng.Set PagedPool  NonPgdPl  Pagefile    Commit   Handles   Threads\n") ));

    /* grab all process information */
    /* log line format, all comma delimited,CR delimited:
    pid,name,WorkingSetSize,QuotaPagedPoolUsage,QuotaNonPagedPoolUsage,PagefileUsage,CommitCharge<CR>
    log all process information */

    /* from pmon */
    Offset1 = 0;
    if ((CurrentBuffer = VirtualAlloc (NULL,
                                  BUFFER_SIZE,
                                  MEM_COMMIT,
                                  PAGE_READWRITE)) != NULL)
    {
        /* from memsnap */
        /* get commit charge */
        /* get all of the status information */
        Status = (NTSTATUS)(*NtQSI)(
                          SystemProcessInformation,
                          CurrentBuffer,
                          BUFFER_SIZE,
                          NULL );

        if (NT_SUCCESS(Status)){
                for (;;)
                {

                    /* get process info from buffer */
                    ProcessInfo = (PSYSTEM_PROCESS_INFORMATION)&CurrentBuffer[Offset1];
                    Offset1 += ProcessInfo->NextEntryOffset;
                    if (ProcessInfo->ImageName.Buffer) {
                        if (!lstrcmpi(ProcessInfo->ImageName.Buffer, TEXT("sysocmgr.exe")) ||
                            !lstrcmpi(ProcessInfo->ImageName.Buffer, TEXT("setup.exe")) ) {
                            wsprintf(szLogLine,
                             szResBuf,
                             ProcessInfo->UniqueProcessId,
                             ProcessInfo->ImageName.Buffer,
                             ProcessInfo->WorkingSetSize / 1024,
                             ProcessInfo->QuotaPagedPoolUsage / 1024,
                             ProcessInfo->QuotaNonPagedPoolUsage / 1024,
                             ProcessInfo->PagefileUsage / 1024,
                             ProcessInfo->PrivatePageCount / 1024,
                             ProcessInfo->HandleCount,
                             ProcessInfo->NumberOfThreads );

                            TRACE(( szLogLine ));
                        }
                    }
#if 0
                    // if buffer is null then it's idle process or unknown
                    if (!ProcessInfo->ImageName.Buffer)
                    {
                        if (ProcessInfo->UniqueProcessId == (HANDLE)0)
                            lpTemp = TEXT("Idle");
                        else
                            lpTemp = TEXT("Unknown");

                        wsprintf(szLogLine,
                                     szResBuf,
                                     ProcessInfo->UniqueProcessId,
                                     lpTemp,
                                     ProcessInfo->WorkingSetSize / 1024,
                                     ProcessInfo->QuotaPagedPoolUsage / 1024,
                                     ProcessInfo->QuotaNonPagedPoolUsage / 1024,
                                     ProcessInfo->PagefileUsage / 1024,
                                     ProcessInfo->PrivatePageCount / 1024,
                                     ProcessInfo->HandleCount,
                                     ProcessInfo->NumberOfThreads );
                    }
                    else
                    {
                        wsprintf(szLogLine,
                             szResBuf,
                             ProcessInfo->UniqueProcessId,
                             ProcessInfo->ImageName.Buffer,
                             ProcessInfo->WorkingSetSize / 1024,
                             ProcessInfo->QuotaPagedPoolUsage / 1024,
                             ProcessInfo->QuotaNonPagedPoolUsage / 1024,
                             ProcessInfo->PagefileUsage / 1024,
                             ProcessInfo->PrivatePageCount / 1024,
                             ProcessInfo->HandleCount,
                             ProcessInfo->NumberOfThreads );
                    }

                    TRACE(( szLogLine ));
#endif
                    if (ProcessInfo->NextEntryOffset == 0)
                    {
                        break;
                    }
                }
            //status failed
        }
        /* free mem */
        VirtualFree(CurrentBuffer,0,MEM_RELEASE);
    }

    //tail for mem area
    TRACE(( TEXT("\n") ));

    FreeLibrary(hNtDll);

}

#endif

#ifdef UNICODE

NTSYSAPI
BOOLEAN
NTAPI
RtlValidateProcessHeaps (
    VOID
    );

#define ASSERT_HEAP_IS_VALID(_x_)  sapiAssert(RtlValidateProcessHeaps && _x_)

#else

#define ASSERT_HEAP_IS_VALID(_x_)

#endif


DWORD gecode;
PVOID geaddr;

DWORD
efilter(
    LPEXCEPTION_POINTERS ep
    )

/*++

Routine Description:

    handles exception during calls to oc component routines


Arguments:

    ep - exception information

Return Value:

    always 1 - execute the handler

--*/

{
    gecode = ep->ExceptionRecord->ExceptionCode;
    geaddr = ep->ExceptionRecord->ExceptionAddress;

    return EXCEPTION_EXECUTE_HANDLER;
}


BOOL
pOcInterface(
    IN  POC_MANAGER  OcManager,
    OUT PUINT        Result,
    IN  LONG         ComponentId,
    IN  LPCTSTR      Subcomponent,      OPTIONAL
    IN  UINT         Function,
    IN  UINT_PTR     Param1,
    IN  PVOID        Param2
    )

/*++

Routine Description:

    Perform the actual call to the OC interface routine.

    Converts Unicode component/subcomponent names to ANSI if needed.

Arguments:

    OcManager - supplies OC Manager context structure.

    Result -

    ComponentId -

    Remaining arguments specify parameters to be passed directly to
    the interface.

Return Value:

    TRUE if the interface routine was successfully called and returned
        without faulting. LastError() is preserved in this case.

    FALSE otherwise.

--*/

{
    LONG OldComponentStringId;
    BOOL b;
    LPCTSTR Component;
    OPTIONAL_COMPONENT Oc;
    LPCVOID comp,subcomp;
#ifdef UNICODE
    CHAR AnsiComp[500];
    CHAR AnsiSub[500];
#endif

    //
    // Get the name of the component and the optional component data
    // from the string table.
    //
    // Though it would be strange, it is possible that this will fail,
    // so we do a little checking for robustness.
    //
    Component = pSetupStringTableStringFromId(OcManager->ComponentStringTable,ComponentId);
    b = pSetupStringTableGetExtraData(OcManager->ComponentStringTable,ComponentId,&Oc,sizeof(OPTIONAL_COMPONENT));
    if(!Component || !b || !Oc.InstallationRoutine) {
        return(FALSE);
    }

    OldComponentStringId = OcManager->CurrentComponentStringId;
    OcManager->CurrentComponentStringId = ComponentId;

#ifdef UNICODE
    //
    // If necessary, convert component name and subcomponent name to ANSI.
    //
    if((Function != OC_PREINITIALIZE) && (Oc.Flags & OCFLAG_ANSI)) {

        WideCharToMultiByte(CP_ACP,0,Component,-1,AnsiComp,sizeof(AnsiComp),NULL,NULL);
        comp = AnsiComp;

        if(Subcomponent) {
            WideCharToMultiByte(CP_ACP,0,Subcomponent,-1,AnsiSub,sizeof(AnsiSub),NULL,NULL);
            subcomp = AnsiSub;
        } else {
            subcomp = NULL;
        }
    } else
#endif
    {
        comp = Component;
        subcomp = Subcomponent;
    }

    *Result = CallComponent(OcManager, &Oc, comp, subcomp, Function, Param1, Param2);

    b = (*Result == ERROR_CALL_COMPONENT) ? FALSE : TRUE;

    OcManager->CurrentComponentStringId = OldComponentStringId;

    return b;
}

DWORD
CallComponent(
    IN     POC_MANAGER OcManager,
    IN     POPTIONAL_COMPONENT Oc,
    IN     LPCVOID ComponentId,
    IN     LPCVOID SubcomponentId,
    IN     UINT    Function,
    IN     UINT_PTR Param1,
    IN OUT PVOID   Param2
    )

/*++

Routine Description:

    Calls a component's interface routine with a try-except block.

Arguments:

    Oc - supplies a pointer to the component description structure

    ComponentId - string description of the component

    SubcomponentId - string description of the subcomponent

    Function - notification being sent to the component

    Param1 - differs with each function

    Param2 - differs with each function

Return Value:

    Component return value.  Meaning differs with each function.

--*/

{
    DWORD result;
    BOOL  exception = FALSE;
    TCHAR *comp;
    LONG id;
    int i;
#ifdef DEBUGPERFTRACE
    DWORD tick;
#endif

    // don't call dead components

    id = OcManager->CurrentComponentStringId;
    sapiAssert(id > 0);

    if (pOcComponentWasRemoved(OcManager, id))
        return NO_ERROR;

    sapiAssert(Oc->InstallationRoutine);

#ifdef PRERELEASE
#ifdef DBG
    ASSERT_HEAP_IS_VALID("The process heap was corrupted before calling the component.");

#if 0
    if (FTestForOutstandingCoInits() != S_OK) {
        sapiAssert( FALSE && "There is an unbalanced call to CoInitialize()");
    }
#endif

#endif
#endif

#ifdef DEBUGPERFTRACE
    TRACE(( TEXT("before calling component\n") ));
    DebugLogPerf();
    tick = GetTickCount();
    TRACE(( TEXT("calling component, %d:\n"), tick ));
#endif

    try {

        result = Oc->InstallationRoutine(ComponentId, SubcomponentId, Function, Param1, Param2);

    } except(efilter(GetExceptionInformation())) {

        exception = TRUE;
    }

#ifdef DEBUGPERFTRACE
    TRACE(( TEXT("after calling component, %d (time = %d)\n"),GetTickCount(), GetTickCount() - tick));
    DebugLogPerf();
#endif

#ifdef PRERELEASE
#ifdef DBG
    ASSERT_HEAP_IS_VALID("The process heap was corrupted after calling the component.  If you did not get an assertion before calling the component, this indicates an error in the component.  Click yes and get a stack trace to detect the component.");

#if 0
    if (FTestForOutstandingCoInits() != S_OK) {
        sapiAssert( FALSE && "There is an unbalanced call to CoInitialize()");
    }
#endif
#endif
#endif


    if (exception) {

#ifdef UNICODE
        if (Oc->Flags & OCFLAG_ANSI)
            comp = pSetupAnsiToUnicode(ComponentId);
        else
#endif
            comp = (TCHAR *)ComponentId;

        _LogError(
            OcManager,
            OcErrLevError|MB_ICONEXCLAMATION|MB_OK,
            MSG_OC_EXCEPTION_IN_COMPONENT,
             comp,
             Oc->InstallationRoutine,
             Function,
             Param1,
             Param2,
             gecode,
             geaddr
            );

#ifdef UNICODE
        if (Oc->Flags & OCFLAG_ANSI)
            pSetupFree(comp);
#endif

        sapiAssert(0);
        pOcRemoveComponent(OcManager, id, pidCallComponent);
        result = ERROR_CALL_COMPONENT;
    }

    return result;
}

UINT
OcInterfacePreinitialize(
    IN OUT POC_MANAGER OcManager,
    IN     LONG        ComponentId
    )

/*++

Routine Description:

    Sets up and calls the OC_PREINITIALIZE function for a
    given component.

Arguments:

    OcManager - supplies a pointer to the context data structure
        for the OC Manager.

    ComponentId - supplies the string id of the component whose
        interface routine is to be called. This is for a string in
        the ComponentStringTable string table (a handle to which
        is in the OcManager structure).

Return Value:

    Flags bitfield (OCFLAG_xxx) for the component. 0 means error.

--*/

{
    BOOL b;
    UINT FlagsIn;
    UINT FlagsOut;
    OPTIONAL_COMPONENT Oc;
#ifdef UNICODE
    CHAR AnsiName[250];
    LPCWSTR UnicodeName;
#endif

    TRACE((
        TEXT("OCM: OC_PREINITIALIZE Component %s..."),
        pSetupStringTableStringFromId(OcManager->ComponentStringTable,ComponentId)
        ));

    //
    // Set up input flags.
    //
    FlagsIn = OCFLAG_ANSI;
#ifdef UNICODE
    FlagsIn |= OCFLAG_UNICODE;

    UnicodeName = pSetupStringTableStringFromId(OcManager->ComponentStringTable,ComponentId);
    if(!UnicodeName) {
        return(0);
    }

    WideCharToMultiByte(CP_ACP,0,UnicodeName,-1,AnsiName,sizeof(AnsiName),NULL,NULL);
#endif

    b = pOcInterface(
            OcManager,
            &FlagsOut,
            ComponentId,
#ifdef UNICODE
            (LPCTSTR)AnsiName,
#else
            NULL,
#endif
            OC_PREINITIALIZE,
            FlagsIn,
            0
            );

    TRACE(( TEXT("...%x (retval %s)\n"), FlagsOut, b ? TEXT("TRUE") : TEXT("FALSE") ));

    if(!b) {
        goto error;
    }

    //
    // If neither flag is set, error.
    //
    if(!(FlagsOut & (OCFLAG_ANSI | OCFLAG_UNICODE))) {
        goto error;
    }

#ifdef UNICODE
    //
    // Use Unicode if it is supported by the component.
    //
    if(FlagsOut & OCFLAG_UNICODE) {
        FlagsOut = OCFLAG_UNICODE;
    }
#else
    //
    // If ANSI is not supported then we've got a problem.
    //
    if(FlagsOut & OCFLAG_ANSI) {
        FlagsOut = OCFLAG_ANSI;
    } else {
        goto error;
    }
#endif

    goto eof;

error:
    pOcRemoveComponent(OcManager, ComponentId, pidPreInit);
    FlagsOut = 0;

eof:
    return(FlagsOut);
}


UINT
OcInterfaceInitComponent(
    IN OUT POC_MANAGER OcManager,
    IN     LONG        ComponentId
    )

/*++

Routine Description:

    Sets up and calls the OC_INIT_COMPONENT interface function for a
    given component.

Arguments:

    OcManager - supplies a pointer to the context data structure
        for the OC Manager.

    ComponentId - supplies the string id of the component whose
        interface routine is to be called. This is for a string in
        the ComponentStringTable string table (a handle to which
        is in the OcManager structure).

Return Value:

    Win32 error indicating value returned by the component.

--*/

{
    OPTIONAL_COMPONENT Oc;
    OC_INF OcInf;
    BOOL b;
    SETUP_INIT_COMPONENTA InitDataA;
#ifdef UNICODE
    SETUP_INIT_COMPONENTW InitDataW;
#endif
    UINT u;
    PUINT pu;
    PHELPER_CONTEXT HelperContext;

#ifdef UNICODE
    ZeroMemory( &InitDataW, sizeof( InitDataW ));
#else
    ZeroMemory( &InitDataA, sizeof( InitDataA ));
#endif

    TRACE((
        TEXT("OCM: OC_INIT_COMPONENT Component %s..."),
        pSetupStringTableStringFromId(OcManager->ComponentStringTable,ComponentId)
        ));

    HelperContext = pSetupMalloc(sizeof(HELPER_CONTEXT));
    if(!HelperContext) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }
    HelperContext->OcManager = OcManager;
    HelperContext->ComponentStringId = ComponentId;

    //
    // Fetch the optional component data.
    //
    b = pSetupStringTableGetExtraData(
            OcManager->ComponentStringTable,
            ComponentId,
            &Oc,
            sizeof(OPTIONAL_COMPONENT)
            );

    if(b) {
        if(Oc.InfStringId == -1) {
            OcInf.Handle = NULL;
            b = TRUE;
        } else {
            b = pSetupStringTableGetExtraData(
                    OcManager->InfListStringTable,
                    Oc.InfStringId,
                    &OcInf,
                    sizeof(OC_INF)
                    );
        }
    }

    if(!b) {
        //
        // Strange case, should never get here.
        //
        pSetupFree(HelperContext);
        return(ERROR_INVALID_PARAMETER);
    }

    //
    // Set up the main part of the initialization structure
    // and the HelperRoutines table.
    //
    // Also set up the SetupData part of the initialization structure.
    // This is specific to the environment in which the OC Manager
    // common library is linked, so we call out to a routine that
    // lives elsewhere to do this part.
    //
#ifdef UNICODE
    if(Oc.Flags & OCFLAG_UNICODE) {
        InitDataW.HelperRoutines = HelperRoutinesW;
        InitDataW.OCManagerVersion = OCMANAGER_VERSION;
        InitDataW.ComponentVersion = 0;
        InitDataW.OCInfHandle = OcManager->MasterOcInf;
        InitDataW.ComponentInfHandle = OcInf.Handle;

        InitDataW.HelperRoutines.OcManagerContext = HelperContext;

        OcFillInSetupDataW(&InitDataW.SetupData);

        pu = &InitDataW.ComponentVersion;

        b = pOcInterface(OcManager,&u,ComponentId,NULL,OC_INIT_COMPONENT,0,&InitDataW);
    } else
#endif
    {
        InitDataA.HelperRoutines = HelperRoutinesA;
        InitDataA.OCManagerVersion = OCMANAGER_VERSION;
        InitDataA.ComponentVersion = 0;
        InitDataA.OCInfHandle = OcManager->MasterOcInf;
        InitDataA.ComponentInfHandle = OcInf.Handle;

        InitDataA.HelperRoutines.OcManagerContext = HelperContext;

        OcFillInSetupDataA(&InitDataA.SetupData);

        pu = &InitDataA.ComponentVersion;

        b = pOcInterface(OcManager,&u,ComponentId,NULL,OC_INIT_COMPONENT,0,&InitDataA);
    }

    TRACE(( TEXT("...returns %d, expect version %x\n"), u, *pu ));

    if(b) {
        if(u == NO_ERROR) {
            //
            // Remember the version of the OC Manager that the
            // component expects to be dealing with.
            //
            Oc.ExpectedVersion = *pu;
            Oc.HelperContext = HelperContext;

            pSetupStringTableSetExtraData(
                OcManager->ComponentStringTable,
                ComponentId,
                &Oc,
                sizeof(OPTIONAL_COMPONENT)
                );
        }
    } else {
        u = ERROR_INVALID_PARAMETER;
    }

    if(u != NO_ERROR) {
        pSetupFree(HelperContext);
        pOcRemoveComponent(OcManager, ComponentId, pidInitComponent);
    }

    return(u);
}


UINT
OcInterfaceExtraRoutines(
    IN OUT POC_MANAGER OcManager,
    IN     LONG        ComponentId
    )

/*++

Routine Description:

    Sets up and calls the OC_EXTRA_ROUTINES interface function for a
    given component.

Arguments:

    OcManager - supplies a pointer to the context data structure
        for the OC Manager.

    ComponentId - supplies the string id of the component whose
        interface routine is to be called. This is for a string in
        the ComponentStringTable string table (a handle to which
        is in the OcManager structure).

Return Value:

    Win32 error indicating value returned by the component.

--*/

{
    BOOL b;
    UINT u;
    PVOID param2;
    OPTIONAL_COMPONENT Oc;

    TRACE((
        TEXT("OC: OC_EXTRA_ROUTINES Component %s\n"),
        pSetupStringTableStringFromId(OcManager->ComponentStringTable,ComponentId)
        ));

    //
    // Fetch the optional component data.
    //
    b = pSetupStringTableGetExtraData(
            OcManager->ComponentStringTable,
            ComponentId,
            &Oc,
            sizeof(OPTIONAL_COMPONENT)
            );

    if(!b) {
        //
        // Strange case, should never get here.
        //
        return ERROR_INVALID_PARAMETER;
    }

#ifdef UNICODE
    if (Oc.Flags & OCFLAG_UNICODE)
        b = pOcInterface(OcManager, &u, ComponentId, NULL, OC_EXTRA_ROUTINES, 0, &ExtraRoutinesW);
    else
#endif
        b = pOcInterface(OcManager, &u, ComponentId, NULL, OC_EXTRA_ROUTINES, 0, &ExtraRoutinesA);

    TRACE(( TEXT("...returns %d (retval %s)\n"),
            u,
            b ? TEXT("TRUE") : TEXT("FALSE") ));

    if (!b)
        u = ERROR_INVALID_PARAMETER;
    if(u != NO_ERROR)
        pOcRemoveComponent(OcManager, ComponentId, pidExtraRoutines);

    return u;
}


SubComponentState
OcInterfaceQueryState(
    IN OUT POC_MANAGER OcManager,
    IN     LONG        ComponentId,
    IN     LPCTSTR     Subcomponent,
    IN     UINT        WhichState
    )

/*++

Routine Description:

    Sets up and calls OC_QUERY_STATE interface routine.

Arguments:

    OcManager - supplies oc manager context

    ComponentId - supplies the string id for the top-level component
        whose subcomponent is being detected/queried

    Subcomponent - supplies the name of the subcomponent whose
        state is to be detected/queried.

    WhichState - one of OCSELSTATETYPE_ORIGINAL or OCSELSTATETYPE_CURRENT.

Return Value:

    Member of the SubComponentState enum indicating what to do.
    If an error occurs, SubcompUseOcManagerDefault will be returned.
    There is no error return.

--*/

{
    SubComponentState s;

    TRACE((
        TEXT("OCM: OC_QUERY_STATE Comp(%s) Sub(%s)"),
        pSetupStringTableStringFromId(OcManager->ComponentStringTable,ComponentId),
        Subcomponent == NULL ? TEXT("NULL") : Subcomponent
        ));

    if(pOcInterface(OcManager,(PUINT)&s,ComponentId,Subcomponent,OC_QUERY_STATE,WhichState,0)) {
        TRACE(( TEXT("...returns TRUE (%d state)\n"), s ));
        if((s != SubcompOn) && (s != SubcompOff)) {
            s = SubcompUseOcManagerDefault;
        }
    } else {
        TRACE(( TEXT("...returns FALSE\n") ));
        s = SubcompUseOcManagerDefault;
    }

    return(s);
}


BOOL
OcInterfaceSetLanguage(
    IN OUT POC_MANAGER OcManager,
    IN     LONG        ComponentId,
    IN     WORD        LanguageId
    )

/*++

Routine Description:

    Sets up and calls the OC_SET_LANGUAGE interface function for a
    given component.

Arguments:

    OcManager - supplies a pointer to the context data structure
        for the OC Manager.

    ComponentId - supplies the string id of the component whose
        interface routine is to be called. This is for a string in
        the ComponentStringTable string table (a handle to which
        is in the OcManager structure).

    LanguageId - supplies the Win32 language id to pass to the component.

Return Value:

    TRUE if the component indicated it could support the language.
    FALSE otherwise.

--*/

{
    LPCTSTR p;
    BOOL b;
    BOOL Result = FALSE;

    TRACE((
        TEXT("OCM: OC_SET_LANGUAGE Comp(%s)LanguageId %d..."),
        pSetupStringTableStringFromId(OcManager->ComponentStringTable,ComponentId),
        LanguageId
        ));

    b = pOcInterface(OcManager,&Result,ComponentId,NULL,OC_SET_LANGUAGE,LanguageId,NULL);

    TRACE(( TEXT("...returns %d (retval %s)\n"),
            Result ? TEXT("TRUE") : TEXT("FALSE"),
            b ? TEXT("TRUE") : TEXT("FALSE") ));

    if(!b) {
        Result = FALSE;
    }

    return(Result);
}


HBITMAP
OcInterfaceQueryImage(
    IN OUT POC_MANAGER      OcManager,
    IN     LONG             ComponentId,
    IN     LPCTSTR          Subcomponent,
    IN     SubComponentInfo WhichImage,
    IN     UINT             DesiredWidth,
    IN     UINT             DesiredHeight
    )

/*++

Routine Description:

    Sets up and calls the OC_QUERY_IMAGE interface function for a
    given component.

Arguments:

    OcManager - supplies a pointer to the context data structure
        for the OC Manager.

    ComponentId - supplies the string id of the component whose
        interface routine is to be called. This is for a string in
        the ComponentStringTable string table (a handle to which
        is in the OcManager structure).

    Subcomponent - supplies the name of the subcomponent for which
        to request the image.

    WhichImage - specifies which image is desired.

    DesiredWidth - specifies desired width, in pixels, of the bitmap.

    DesiredHeight - specifies desired height, in pixels, of the bitmap.

Return Value:

    GDI handle to the bitmap as returned by the component,
    or NULL if an error occurred.

--*/

{
    LPCTSTR p;
    BOOL b;
    HBITMAP Bitmap = NULL;

    TRACE((
        TEXT("OCM: OC_QUERY_IMAGE Comp(%s) Sub(%s)..."),
        pSetupStringTableStringFromId(OcManager->ComponentStringTable,ComponentId),
        Subcomponent == NULL ? TEXT("NULL") : Subcomponent
        ));

    b = pOcInterface(
            OcManager,
            (PUINT)&Bitmap,
            ComponentId,
            Subcomponent,
            OC_QUERY_IMAGE,
            WhichImage,
            LongToPtr(MAKELONG(DesiredWidth,DesiredHeight))
            );

    TRACE(( TEXT("...returns %s, (retval 0x%08x)\n"),
            b ? TEXT("TRUE") : TEXT("FALSE"),
            (ULONG_PTR)Bitmap ));

    if(!b) {
        Bitmap = NULL;
    }

    return(Bitmap);
}


HBITMAP
OcInterfaceQueryImageEx(
    IN OUT POC_MANAGER      OcManager,
    IN     LONG             ComponentId,
    IN     LPCTSTR          Subcomponent,
    IN     SubComponentInfo WhichImage,
    IN     UINT             DesiredWidth,
    IN     UINT             DesiredHeight
    )

/*++

Routine Description:

    Sets up and calls the OC_QUERY_IMAGE interface function for a
    given component.

Arguments:

    OcManager - supplies a pointer to the context data structure
        for the OC Manager.

    ComponentId - supplies the string id of the component whose
        interface routine is to be called. This is for a string in
        the ComponentStringTable string table (a handle to which
        is in the OcManager structure).

    Subcomponent - supplies the name of the subcomponent for which
        to request the image.

    WhichImage - specifies which image is desired.

    DesiredWidth - specifies desired width, in pixels, of the bitmap.

    DesiredHeight - specifies desired height, in pixels, of the bitmap.

Return Value:

    GDI handle to the bitmap as returned by the component,
    or NULL if an error occurred.

--*/

{
    LPCTSTR p;
    BOOL b;
    BOOL Result = FALSE;
    HBITMAP Bitmap = NULL;
    OC_QUERY_IMAGE_INFO QueryImageInfo;

    QueryImageInfo.SizeOfStruct = sizeof(QueryImageInfo);
    QueryImageInfo.ComponentInfo = WhichImage;
    QueryImageInfo.DesiredWidth = DesiredWidth;
    QueryImageInfo.DesiredHeight = DesiredHeight;

    TRACE((
        TEXT("OCM: OC_QUERY_IMAGE_EX Comp(%s) Sub(%s)..."),
        pSetupStringTableStringFromId(OcManager->ComponentStringTable,ComponentId),
        Subcomponent == NULL ? TEXT("NULL") : Subcomponent
        ));

    b = pOcInterface(
            OcManager,
            &Result,
            ComponentId,
            Subcomponent,
            OC_QUERY_IMAGE_EX,
            (UINT_PTR)&QueryImageInfo,
            &Bitmap
            );

    TRACE(( TEXT("...returns %s, (retval = %s)\n"),
            Result ? TEXT("TRUE") : TEXT("FALSE"),
            b ? TEXT("TRUE") : TEXT("FALSE") ));

    if(!b) {
        Bitmap = NULL;
    }

    return((Result == TRUE) ? Bitmap : NULL);
}


UINT
OcInterfaceRequestPages(
    IN OUT POC_MANAGER           OcManager,
    IN     LONG                  ComponentId,
    IN     WizardPagesType       WhichPages,
    OUT    PSETUP_REQUEST_PAGES *RequestPages
    )

/*++

Routine Description:

    Sets up and calls the OC_REQUEST_PAGES interface function for a
    given component.

    Note that this routine does not enforce any policy regarding whether
    the component is *supposed* to be asked for pages, ordering, etc.
    The caller is expected to do that.

Arguments:

    OcManager - supplies a pointer to the context data structure
        for the OC Manager.

    ComponentId - supplies the string id of the component whose
        interface routine is to be called. This is for a string in
        the ComponentStringTable string table (a handle to which
        is in the OcManager structure).

    WhichPages - specifies which set of pages is to be requested.

    RequestPages - on successful return, receives a pointer to
        a SETUP_REQUEST_PAGES structure containing a count and handles
        for returned pages. The caller can free this structure with
        pSetupFree() when it is no longer needed.

Return Value:

    Win32 error code indicating outcome.

--*/

{
    UINT PageCount;
    PSETUP_REQUEST_PAGES pages;
    PVOID p;
    BOOL b;
    UINT ec;

    //
    // Start with room for 10 pages.
    //
    #define INITIAL_PAGE_CAPACITY  10


    TRACE((
        TEXT("OCM: OC_REQUEST_PAGES Component %s..."),
        pSetupStringTableStringFromId(OcManager->ComponentStringTable,ComponentId)
        ));

    pages = pSetupMalloc(offsetof(SETUP_REQUEST_PAGES,Pages)
                + (INITIAL_PAGE_CAPACITY * sizeof(HPROPSHEETPAGE)));

    if(!pages) {
        return(ERROR_NOT_ENOUGH_MEMORY);
    }

    pages->MaxPages = INITIAL_PAGE_CAPACITY;

    b = pOcInterface(
            OcManager,
            &PageCount,
            ComponentId,
            NULL,
            OC_REQUEST_PAGES,
            WhichPages,
            pages
            );

    if(b && (PageCount != (UINT)(-1)) && (PageCount > INITIAL_PAGE_CAPACITY)) {

        p = pSetupRealloc(
                pages,
                offsetof(SETUP_REQUEST_PAGES,Pages) + (PageCount * sizeof(HPROPSHEETPAGE))
                );

        if(p) {
            pages = p;
        } else {
            pSetupFree(pages);
            return(ERROR_NOT_ENOUGH_MEMORY);
        }

        pages->MaxPages = PageCount;

        b = pOcInterface(
                OcManager,
                &PageCount,
                ComponentId,
                NULL,
                OC_REQUEST_PAGES,
                WhichPages,
                pages
                );
    }

    TRACE(( TEXT("...returns %d pages (retval %s)\n"),
            PageCount,
            b ? TEXT("TRUE") : TEXT("FALSE") ));

    if(!b) {
        pSetupFree(pages);
        return ERROR_CALL_COMPONENT;
    }

    if(PageCount == (UINT)(-1)) {
        ec = GetLastError();
        pSetupFree(pages);
        pOcRemoveComponent(OcManager, ComponentId, pidRequestPages);
        return(ec);
    }

    //
    // Success. Realloc the array down to its final size and return.
    //
    p = pSetupRealloc(
            pages,
            offsetof(SETUP_REQUEST_PAGES,Pages) + (PageCount * sizeof(HPROPSHEETPAGE))
            );

    if(p) {
        pages = p;
        pages->MaxPages = PageCount;
        *RequestPages = pages;
        return(NO_ERROR);
    }

    pSetupFree(pages);
    return(ERROR_NOT_ENOUGH_MEMORY);
}


BOOL
OcInterfaceQuerySkipPage(
    IN OUT POC_MANAGER   OcManager,
    IN     LONG          ComponentId,
    IN     OcManagerPage WhichPage
    )

/*++

Routine Description:

    This routine asks a component dll (identified by a top-level
    component's string id) whether it wants to skip displaying
    a particular page that is owned by the oc manager.

Arguments:

    OcManager - supplies OC Manager context

    ComponentId - supplies string id of a top-level component

    WhichPage - supplies a value indicating which page oc manager
        is asking the component about.

Return Value:

    Boolean value indicating whether the component wants to skip
    the page.

--*/

{
    BOOL Result;
    BOOL b;

    TRACE((
        TEXT("OCM: OC_QUERY_SKIP_PAGE Component %s Page %d..."),
        pSetupStringTableStringFromId(OcManager->ComponentStringTable,ComponentId),
        WhichPage
        ));

    //
    // Send out the notification to the component DLL.
    //
    b = pOcInterface(
            OcManager,
            &Result,
            ComponentId,
            NULL,
            OC_QUERY_SKIP_PAGE,
            WhichPage,
            NULL
            );

    TRACE(( TEXT("...returns %x (retval %s)\n"),
            Result,
            b ? TEXT("TRUE") : TEXT("FALSE") ));

    if(b) {
        b = Result;
    } else {
        //
        // Error calling component, don't skip page.
        //
        b = FALSE;
    }

    return(b);
}


BOOL
OcInterfaceNeedMedia(
    IN OUT POC_MANAGER   OcManager,
    IN     LONG          ComponentId,
    IN     PSOURCE_MEDIA SourceMedia,
    OUT    LPTSTR        NewPath
    )

/*++

Routine Description:

    This routine invokes the OC_NEED_MEDIA interface entry point
    for a (top-level) component.

Arguments:

    OcManager - supplies OC Manager context

    ComponentId - supplies string id of top level component

    SourceMedia - supplies setupapi source media description

    NewPath - receives path where files on media are to be found

Return Value:

    Boolean value indicating outcome.

--*/

{
    BOOL Result;
    BOOL b;

    TRACE((
        TEXT("OCM: OC_NEED_MEDIA Component %s..."),
        pSetupStringTableStringFromId(OcManager->ComponentStringTable,ComponentId)
        ));

    //
    // Send out the notification to the component DLL.
    //
    b = pOcInterface(
            OcManager,
            &Result,
            ComponentId,
            NULL,
            OC_NEED_MEDIA,
            (UINT_PTR)SourceMedia,
            NewPath
            );

    TRACE(( TEXT("...returns %x (retval %s, NewPath %s)\n"),
            Result,
            b ? TEXT("TRUE") : TEXT("FALSE"),
            NewPath ? NewPath : TEXT("NULL")
         ));


    if(b) {
        b = Result;
    }

    return(b);
}

BOOL
OcInterfaceFileBusy(
    IN OUT POC_MANAGER   OcManager,
    IN     LONG          ComponentId,
    IN     PFILEPATHS    FilePaths,
    OUT    LPTSTR        NewPath
    )

/*++

Routine Description:

    This routine invokes the OC_FILE_BUSY interface entry point
    for a (top-level) component.

Arguments:

    OcManager - supplies OC Manager context

    ComponentId - supplies string id of top level component

    SourceMedia - supplies setupapi source media description

    NewPath - receives path where files on media are to be found

Return Value:

    Boolean value indicating outcome.

--*/

{
    BOOL Result;
    BOOL b;

    TRACE((
        TEXT("OCM: OC_FILE_BUSY Component %s..."),
        pSetupStringTableStringFromId(OcManager->ComponentStringTable,ComponentId)
        ));

    //
    // Send out the notification to the component DLL.
    //
    b = pOcInterface(
            OcManager,
            &Result,
            ComponentId,
            NULL,
            OC_FILE_BUSY,
            (UINT_PTR)FilePaths,
            NewPath
            );

    TRACE(( TEXT("...returns %x (retval %s, newpath %s)\n"),
            Result,
            b ? TEXT("TRUE") : TEXT("FALSE"),
            NewPath ? NewPath : TEXT("NULL") ));

    if(b) {
        b = Result;
    }

    return(b);
}


BOOL
OcInterfaceQueryChangeSelState(
    IN OUT POC_MANAGER OcManager,
    IN     LONG        ComponentId,
    IN     LPCTSTR     Subcomponent,
    IN     BOOL        Selected,
    IN     UINT        Flags
    )

/*++

Routine Description:

    Sets up and calls the OC_QUERY_CHANGE_SEL_STATE interface function
    for a given component and subcomponent.

Arguments:

    OcManager - supplies a pointer to the context data structure
        for the OC Manager.

    ComponentId - supplies the string id of the component whose
        interface routine is to be called. This is for a string in
        the ComponentStringTable string table (a handle to which
        is in the OcManager structure).

    Subcomponent - supplies the name of the subcomponent whose
        selection state is potentially to be changed.

    Selected - if TRUE then the proposed new selection state is
        "selected." If FALSE then the proposed new selection state
        is "unselected."

    Flags - supplies misc flags to be passed to the interface routine
        as param2.

Return Value:

    TRUE if the new selection state should be accepted.

--*/

{
    BOOL b;
    UINT Result;

    TRACE((
        TEXT("OCM: OC_QUERY_CHANGE_SEL_STATE Comp(%s) Sub(%s) State %d..."),
        pSetupStringTableStringFromId(OcManager->ComponentStringTable,ComponentId),
        Subcomponent == NULL ? TEXT("NULL") : Subcomponent,
        Selected
        ));

    b = pOcInterface(
            OcManager,
            &Result,
            ComponentId,
            Subcomponent,
            OC_QUERY_CHANGE_SEL_STATE,
            Selected,
            UlongToPtr((Flags & OCQ_ACTUAL_SELECTION))
            );

    TRACE(( TEXT("...returns %x (retval %s)\n"),
            Result,
            b ? TEXT("TRUE") : TEXT("FALSE") ));

    if(!b) {
        //
        // If we can't call the component for some reason,
        // allow the new state.
        //
        Result = TRUE;
    }

    return(Result);
}


VOID
OcInterfaceWizardCreated(
    IN OUT POC_MANAGER OcManager,
    IN     LONG        ComponentId,
    IN     HWND        DialogHandle
    )

/*++

Routine Description:

    Sets up and calls the OC_WIZARD_CREATED interface function
    for a given component.

Arguments:

    OcManager - supplies a pointer to the context data structure
        for the OC Manager.

    ComponentId - supplies the string id of the component whose
        interface routine is to be called. This is for a string in
        the ComponentStringTable string table (a handle to which
        is in the OcManager structure).

    DialogHandle - Supplies wizard dialog handle.

Return Value:

    None.

--*/

{
    UINT Result;
    BOOL b;

    TRACE((
        TEXT("OCM: OC_WIZARD_CREATED Component %s..."),
        pSetupStringTableStringFromId(OcManager->ComponentStringTable,ComponentId)
        ));

    b = pOcInterface(
                OcManager,
                &Result,
                ComponentId,
                NULL,
                OC_WIZARD_CREATED,
                0,
                DialogHandle
                );

    TRACE(( TEXT("...returns %x (retval %s)\n"),
            Result,
            b ? TEXT("TRUE") : TEXT("FALSE") ));

}


UINT
OcInterfaceCalcDiskSpace(
    IN OUT POC_MANAGER OcManager,
    IN     LONG        ComponentId,
    IN     LPCTSTR     Subcomponent,
    IN     HDSKSPC     DiskSpaceList,
    IN     BOOL        AddingToList
    )

/*++

Routine Description:

    Sets up and calls the OC_CALC_DISK_SPACE interface function for a
    given component and subcomponent.

Arguments:

    OcManager - supplies a pointer to the context data structure
        for the OC Manager.

    ComponentId - supplies the string id of the component whose
        interface routine is to be called. This is for a string in
        the ComponentStringTable string table (a handle to which
        is in the OcManager structure).

    Subcomponent - supplies the name of the subcomponent whose files
        are to be added or removed. This may be NULL, such as when
        there is no per-component inf.

    DiskSpaceList - supplies a SETUPAPI disk space list handle.

    AddingToList - if TRUE, the component is being directed to add
        files for the (sub)component. If FALSE, the component is
        being directed to remove files.

Return Value:

    Win32 error code indicating outcome.

--*/

{
    BOOL b;
    UINT Result;

    TRACE((
        TEXT("OCM: OC_CALC_DISK_SPACE Comp(%s) Sub(%s) AddtoList(%s)..."),
        pSetupStringTableStringFromId(OcManager->ComponentStringTable,ComponentId),
        Subcomponent == NULL ? TEXT("NULL") : Subcomponent,
        AddingToList ? TEXT("Yes") : TEXT("No")
        ));

    b = pOcInterface(
            OcManager,
            &Result,
            ComponentId,
            Subcomponent,
            OC_CALC_DISK_SPACE,
            AddingToList,
            DiskSpaceList
            );

    TRACE(( TEXT("...returns %x (retval %s)\n"),
            Result,
            b ? TEXT("TRUE") : TEXT("FALSE") ));

    if(!b) {
        pOcRemoveComponent(OcManager, ComponentId, pidCalcDiskSpace);
        Result = ERROR_INVALID_PARAMETER;
    }

    return(Result);
}


UINT
OcInterfaceQueueFileOps(
    IN OUT POC_MANAGER OcManager,
    IN     LONG        ComponentId,
    IN     LPCTSTR     Subcomponent,
    IN     HSPFILEQ    FileQueue
    )

/*++

Routine Description:

    Sets up and calls the OC_QUEUE_FILE_OPS interface function for a
    given component and subcomponent.

Arguments:

    OcManager - supplies a pointer to the context data structure
        for the OC Manager.

    ComponentId - supplies the string id of the component whose
        interface routine is to be called. This is for a string in
        the ComponentStringTable string table (a handle to which
        is in the OcManager structure).

    Subcomponent - supplies the name of the subcomponent whose file ops
        are to be queued. This may be NULL, such as when there is no
        per-component inf.

    FileQueue - supplies a SETUPAPI file queue handle.

Return Value:

    Win32 error code indicating outcome.

--*/

{
    UINT Result;

    TRACE((
        TEXT("OCM: OC_QUEUE_FILE_OPS Comp(%s) Sub(%s)..."),
        pSetupStringTableStringFromId(OcManager->ComponentStringTable,ComponentId),
        Subcomponent == NULL ? TEXT("NULL") : Subcomponent
        ));

    if(!pOcInterface(OcManager,&Result,ComponentId,Subcomponent,OC_QUEUE_FILE_OPS,0,FileQueue)) {
        pOcRemoveComponent(OcManager, ComponentId, pidQueueFileOps);
        TRACE(( TEXT("...(returns %x initially) "), Result ));
        Result = ERROR_INVALID_PARAMETER;
    }

    TRACE(( TEXT("...returns %x\n"), Result ));


    return(Result);
}


UINT
OcInterfaceQueryStepCount(
    IN OUT POC_MANAGER OcManager,
    IN     LONG        ComponentId,
    IN     LPCTSTR     Subcomponent,
    OUT    PUINT       StepCount
    )

/*++

Routine Description:

    Sets up and calls the OC_QUERY_STEP_COUNT interface function for a
    given component and subcomponent.

Arguments:

    OcManager - supplies a pointer to the context data structure
        for the OC Manager.

    ComponentId - supplies the string id of the component whose
        interface routine is to be called. This is for a string in
        the ComponentStringTable string table (a handle to which
        is in the OcManager structure).

    Subcomponent - supplies the name of the subcomponent whose step count
        is to be determined. This may be NULL, such as when there is no
        per-component inf.

    StepCount - if the routine returns NO_ERROR then StepCount receives
        the number of steps as returned by the component's interface routine.

Return Value:

    Win32 error code indicating outcome.

--*/

{
    UINT Result;

    TRACE((
        TEXT("OCM: OC_QUERY_STEP_COUNT Comp(%s) Sub(%s)..."),
        pSetupStringTableStringFromId(OcManager->ComponentStringTable,ComponentId),
        Subcomponent == NULL ? TEXT("NULL") : Subcomponent
        ));

    if(pOcInterface(OcManager,StepCount,ComponentId,Subcomponent,OC_QUERY_STEP_COUNT,0,0)) {

        if(*StepCount == (UINT)(-1)) {
            Result = GetLastError();
        } else {
            Result = NO_ERROR;
        }
    } else {
        Result = ERROR_INVALID_PARAMETER;
    }

    TRACE(( TEXT("...returns %s (%d steps)\n"),
            Result ? TEXT("TRUE") : TEXT("FALSE"),
            *StepCount ));

    if (Result != NO_ERROR) {
        pOcRemoveComponent(OcManager, ComponentId, pidQueryStepCount);
    }

    return(Result);
}


UINT
OcInterfaceCompleteInstallation(
    IN OUT POC_MANAGER OcManager,
    IN     LONG        ComponentId,
    IN     LPCTSTR     Subcomponent,
    IN     BOOL        PreQueueCommit
    )

/*++

Routine Description:

    Sets up and calls the OC_ABOUT_TO_COMMIT_QUEUE or
    OC_COMPLETE_INSTALLATION interface function for a given
    component and subcomponent.

Arguments:

    OcManager - supplies a pointer to the context data structure
        for the OC Manager.

    ComponentId - supplies the string id of the component whose
        interface routine is to be called. This is for a string in
        the ComponentStringTable string table (a handle to which
        is in the OcManager structure).

    Subcomponent - supplies the name of the subcomponent whose
        installation is to be completed. This may be NULL,
        such as when there is no per-component inf.

    PreQueueCommit - if non-0, then OC_ABOUT_TO_COMMIT_QUEUE is sent.
        If 0, then OC_COMPLETE_INSTALLATION is sent.

Return Value:

    Win32 error code indicating outcome.

--*/

{
    UINT Result;
    BOOL b;
    LPTSTR p;
    TCHAR DisplayText[300],FormatString[200];
    OPTIONAL_COMPONENT Oc;
    HELPER_CONTEXT Helper;

    TRACE((
        TEXT("OCM:%s Comp(%s) Sub(%s)..."),
        PreQueueCommit ? TEXT("OC_ABOUT_TO_COMMIT_QUEUE") : TEXT("OC_COMPLETE_INSTALLATION"),
        pSetupStringTableStringFromId(OcManager->ComponentStringTable,ComponentId),
        Subcomponent == NULL ? TEXT("NULL") : Subcomponent
        ));

    //
    // update the installation text for this component
    //
    __try {
        if (pSetupStringTableGetExtraData(
                    OcManager->ComponentStringTable,
                    ComponentId,
                    &Oc,
                    sizeof(OPTIONAL_COMPONENT)
                    ) && (*Oc.Description != 0)) {
            p = Oc.Description;
        } else if ((p = pSetupStringTableStringFromId(OcManager->ComponentStringTable, ComponentId)) != NULL) {

        } else {
            p = TEXT("Component");
        }


        LoadString(
               MyModuleHandle,
               PreQueueCommit
                ? IDS_CONFIGURE_FORMAT
                : IDS_INSTALL_FORMAT,
               FormatString,
               sizeof(FormatString)/sizeof(TCHAR)
               );
        wsprintf(DisplayText,FormatString,p);

        Helper.OcManager = OcManager;
        Helper.ComponentStringId = ComponentId;

        #ifdef UNICODE
        HelperRoutinesW.SetProgressText(&Helper,DisplayText);
        #else
        HelperRoutinesA.SetProgressText(&Helper,DisplayText);
        #endif

    } __except (EXCEPTION_EXECUTE_HANDLER) {
        ERR(( TEXT("OCM: OcCompleteInstallation exception, ec = 0x%08x\n"), GetExceptionCode() ));
    }


    b = pOcInterface(
            OcManager,
            &Result,
            ComponentId,
            Subcomponent,
            PreQueueCommit ? OC_ABOUT_TO_COMMIT_QUEUE : OC_COMPLETE_INSTALLATION,
            0,
            0
            );

    TRACE(( TEXT("...returns %x (retval %s)\n"),
            Result,
            b ? TEXT("TRUE") : TEXT("FALSE") ));

    if(!b) {
        Result = ERROR_INVALID_PARAMETER;
    }

    // Don't shutdown the component if it returns an error.
    // Let them deal with it in OC_QUERY_STATE(SELSTATETYPE_FINAL)

    return(Result);
}


VOID
OcInterfaceCleanup(
    IN OUT POC_MANAGER OcManager,
    IN     LONG        ComponentId
    )

/*++

Routine Description:

    Sets up and calls the OC_CLEANUP interface function for a
    given component, to inform the component that it is about to be unloaded.

Arguments:

    OcManager - supplies a pointer to the context data structure
        for the OC Manager.

    ComponentId - supplies the string id of the component whose
        interface routine is to be called. This is for a string in
        the ComponentStringTable string table (a handle to which
        is in the OcManager structure).

Return Value:

    None.

--*/

{
    UINT DontCare;
    BOOL b;

    TRACE((
        TEXT("OCM: OC_CLEANUP Comp(%s)..."),
        pSetupStringTableStringFromId(OcManager->ComponentStringTable,ComponentId)
        ));


    b = pOcInterface(OcManager,&DontCare,ComponentId,NULL,OC_CLEANUP,0,0);

    TRACE(( TEXT("...returns %x (retval %s)\n"),
            DontCare,
            b ? TEXT("TRUE") : TEXT("FALSE") ));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ocmanage\common\ocmisc.c ===
#include "precomp.h"
#pragma hdrstop

// determines whether trace statements are printed

#define DBL_UNDEFINED   ((DWORD)-1)
#define REGKEY_SETUP    TEXT("SOFTWARE\\microsoft\\windows\\currentversion\\setup")
#define REGVAL_DBLEVEL  TEXT("OC Manager Debug Level")

DWORD gDebugLevel = DBL_UNDEFINED;

//
// OC_MANAGER pointer for debugging/logging
//
extern POC_MANAGER gLastOcManager;


VOID
_DbgOut(
    DWORD Severity,
    LPCTSTR txt
    );


DWORD
GetDebugLevel(
    VOID
    )
{
    DWORD rc;
    DWORD err;
    DWORD size;
    DWORD type;
    HKEY  hkey;

    err = RegOpenKey(HKEY_LOCAL_MACHINE,
                     REGKEY_SETUP,
                     &hkey);

    if (err != ERROR_SUCCESS)
        return 0;

    size = sizeof(DWORD);
    err = RegQueryValueEx(hkey,
                          REGVAL_DBLEVEL,
                          0,
                          &type,
                          (LPBYTE)&rc,
                          &size);

    if (err != ERROR_SUCCESS || type != REG_DWORD)
        rc = 0;

    RegCloseKey(hkey);

    return rc;
}


UINT
_LogError(
    IN POC_MANAGER  OcManager,
    IN OcErrorLevel ErrorLevel,
    IN UINT         MessageId,
    ...
    )
{
    TCHAR str[5000];
    DWORD d;
    va_list arglist;

    va_start(arglist,MessageId);

    d = FormatMessage(
            FORMAT_MESSAGE_FROM_HMODULE,
            MyModuleHandle,
            MessageId,
            0,
            str,
            sizeof(str)/sizeof(TCHAR),
            &arglist
            );

    va_end(arglist);

    if(!d) {
        FormatMessage(
            FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
            MyModuleHandle,
            MSG_NOT_FOUND,
            0,
            str,
            sizeof(str)/sizeof(TCHAR),
            (va_list *)&MessageId
            );
    }


    if ( OcManager->SetupData.OperationFlags & SETUPOP_BATCH) {
        ErrorLevel |= OcErrBatch;
    }
    return OcLogError(ErrorLevel,str);
}


VOID
_TrcOut(
    IN LPCTSTR Format,
    ...
    )
{
    TCHAR str[5000];
    va_list arglist;

    va_start(arglist,Format);
    wvsprintf(str,Format,arglist);
    va_end(arglist);

    _DbgOut(OcErrTrace,str);
}


VOID
_WrnOut(
    LPCTSTR Format,
    ...
    )
{
    TCHAR str[5000];
    va_list arglist;

    va_start(arglist,Format);
    wvsprintf(str,Format,arglist);
    va_end(arglist);

    _DbgOut(OcErrLevWarning,str);

}


VOID
_ErrOut(
    IN LPCTSTR Format,
    ...
    )
{
    TCHAR str[5000];
    va_list arglist;

    va_start(arglist,Format);
    wvsprintf(str,Format,arglist);
    va_end(arglist);

    _DbgOut(OcErrLevFatal,str);
}


VOID
_DbgOut(
    DWORD Severity,
    IN LPCTSTR txt
    )
{
#if 0
    TCHAR str[5000];
    va_list arglist;

    va_start(arglist,Format);
    wvsprintf(str,Format,arglist);
    va_end(arglist);
#endif
    if (gDebugLevel == DBL_UNDEFINED)
        gDebugLevel = GetDebugLevel();

    //
    // for those people that *dont* want to see this debugger output, they can munge the registry
    // to something between 50 and 100 to disable this.
    // if we don't log some information on checked builds then we'll miss too many errors the first
    // time around
    //
    if ( (gDebugLevel > 0) && (gDebugLevel < 50) )
        return;

    if (gLastOcManager) {
        gLastOcManager->Callbacks.LogError(Severity, txt);
    } else {
        OutputDebugString(TEXT("OCMANAGE: "));
        OutputDebugString(txt);
        OutputDebugString(TEXT("\n"));
    }


}


UINT
pOcCreateComponentSpecificMiniIcon(
    IN POC_MANAGER OcManager,
    IN LONG        ComponentId,
    IN LPCTSTR     Subcomponent,
    IN UINT        Width,
    IN UINT        Height,
    IN LPCTSTR     DllName,         OPTIONAL
    IN LPCTSTR     ResourceId       OPTIONAL
    )
{
    HBITMAP BitmapFromComponent;
    HBITMAP NewBitmap;
    HBITMAP MaskBitmap;
    HBITMAP OldBitmap1,OldBitmap2;
    HDC MemDc1,MemDc2;
    COLORREF BackgroundColor;
    UINT Index;
    BITMAP BitmapInfo;
    BOOL b;
    HMODULE hMod;

    Index = DEFAULT_ICON_INDEX;

    //
    // If a dll name is given then fetch the bitmap from there.
    // Otherwise, call down to the component to get the bitmap.
    //
    BitmapFromComponent = NULL;
    if(DllName && ResourceId) {
        if(hMod = LoadLibraryEx(DllName,NULL,LOAD_LIBRARY_AS_DATAFILE)) {
            BitmapFromComponent = LoadBitmap(hMod,ResourceId);
            FreeLibrary(hMod);
        }
    } else {
        //
        // first try OC_QUERY_IMAGE_EX for the bitmap
        //
        BitmapFromComponent = OcInterfaceQueryImageEx(
                        OcManager,
                        ComponentId,
                        Subcomponent,
                        SubCompInfoSmallIcon,
                        Width,
                        Height
                        );

#ifndef _WIN64
        //
        // OC_QUERY_IMAGE is broken for 64 bits, so only call this if we
        // do not get an image reported for the component on 32 bit targets.
        //
        if (!BitmapFromComponent) {

            BitmapFromComponent = OcInterfaceQueryImage(
                                    OcManager,
                                    ComponentId,
                                    Subcomponent,
                                    SubCompInfoSmallIcon,
                                    Width,
                                    Height
                                    );
        }
#else
        if (!BitmapFromComponent) {
            DbgPrintEx(
                DPFLTR_SETUP_ID,
                DPFLTR_ERROR_LEVEL,
                "No bitmap defined for component.  Ensure that component is handling OC_QUERY_IMAGE_EX callback\n");
        }
#endif
    }

    if(!BitmapFromComponent) {
        goto c0;
    }

    //
    // Copy the bitmap given to us by the component.
    // At the same time, make sure it's the right size.
    //
    MemDc1 = CreateCompatibleDC(NULL);
    if(!MemDc1) {
        goto c1;
    }
    MemDc2 = CreateCompatibleDC(NULL);
    if(!MemDc2) {
        goto c2;
    }

    if(!GetObject(BitmapFromComponent,sizeof(BitmapInfo),&BitmapInfo)) {
        goto c3;
    }

    NewBitmap = CreateBitmap(Width,Height,BitmapInfo.bmPlanes,BitmapInfo.bmBitsPixel,NULL);
    if(!NewBitmap) {
        goto c3;
    }

    OldBitmap1 = SelectObject(MemDc1,BitmapFromComponent);
    if(!OldBitmap1) {
        goto c4;
    }
    OldBitmap2 = SelectObject(MemDc2,NewBitmap);
    if(!OldBitmap2) {
        goto c5;
    }

    b = StretchBlt(
            MemDc2,
            0,0,
            Width,Height,
            MemDc1,
            0,0,
            BitmapInfo.bmWidth,
            BitmapInfo.bmHeight,
            SRCCOPY
            );

    if(!b) {
        goto c6;
    }

    //
    // Now make the mask.
    //
    // The mask bitmap is monochrome. Pixels in the image bitmap that are
    // the image bitmap's background color will be white in the mask;
    // other pixels in the mask will be black. Assume the upper-left pixel
    // of the image bitmap is the background color.
    //
    BackgroundColor = GetPixel(MemDc2,0,0);
    if(BackgroundColor == CLR_INVALID) {
        goto c6;
    }

    MaskBitmap = CreateBitmap(Width,Height,1,1,NULL);
    if(!MaskBitmap) {
        goto c6;
    }

    if(!SelectObject(MemDc1,MaskBitmap)) {
        goto c7;
    }

    if(SetBkColor(MemDc2,BackgroundColor) == CLR_INVALID) {
        goto c7;
    }
    if(!BitBlt(MemDc1,0,0,Width,Height,MemDc2,0,0,SRCCOPY)) {
        goto c7;
    }

    //
    // Black out all of the transparent parts of the image, in preparation
    // for drawing.
    //
    SetBkColor(MemDc2,RGB(0,0,0));
    SetTextColor(MemDc2,RGB(255,255,255));
    if(!BitBlt(MemDc2,0,0,Width,Height,MemDc1,0,0,SRCAND)) {
        goto c7;
    }

    //
    // Before we call pSetupAddMiniIconToList we have to make sure
    // neither bitmap is selected into a DC.
    //
    SelectObject(MemDc1,OldBitmap1);
    SelectObject(MemDc2,OldBitmap2);
    Index = pSetupAddMiniIconToList(NewBitmap,MaskBitmap);
    if(Index == -1) {
        Index = DEFAULT_ICON_INDEX;
    }

c7:
    DeleteObject(MaskBitmap);
c6:
    SelectObject(MemDc2,OldBitmap2);
c5:
    SelectObject(MemDc1,OldBitmap1);
c4:
    DeleteObject(NewBitmap);
c3:
    DeleteDC(MemDc2);
c2:
    DeleteDC(MemDc1);
c1:
    DeleteObject(BitmapFromComponent);
c0:
    return(Index);
}


BOOL
pConvertStringToLongLong(
    IN  PCTSTR           String,
    OUT PLONGLONG        OutValue
    )

/*++

Routine Description:

Arguments:

Return Value:

Remarks:

    Hexadecimal numbers are also supported.  They must be prefixed by '0x' or '0X', with no
    space allowed between the prefix and the number.

--*/

{
    LONGLONG Value;
    UINT c;
    BOOL Neg;
    UINT Base;
    UINT NextDigitValue;
    LONGLONG OverflowCheck;
    BOOL b;

    if(!String || !OutValue) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    if(*String == TEXT('-')) {
        Neg = TRUE;
        String++;
    } else {
        Neg = FALSE;
        if(*String == TEXT('+')) {
            String++;
        }
    }

    if((*String == TEXT('0')) &&
       ((*(String+1) == TEXT('x')) || (*(String+1) == TEXT('X')))) {
        //
        // The number is in hexadecimal.
        //
        Base = 16;
        String += 2;
    } else {
        //
        // The number is in decimal.
        //
        Base = 10;
    }

    for(OverflowCheck = Value = 0; *String; String++) {

        c = (UINT)*String;

        if((c >= (UINT)'0') && (c <= (UINT)'9')) {
            NextDigitValue = c - (UINT)'0';
        } else if(Base == 16) {
            if((c >= (UINT)'a') && (c <= (UINT)'f')) {
                NextDigitValue = (c - (UINT)'a') + 10;
            } else if ((c >= (UINT)'A') && (c <= (UINT)'F')) {
                NextDigitValue = (c - (UINT)'A') + 10;
            } else {
                break;
            }
        } else {
            break;
        }

        Value *= Base;
        Value += NextDigitValue;

        //
        // Check for overflow.  For decimal numbers, we check to see whether the
        // new value has overflowed into the sign bit (i.e., is less than the
        // previous value.  For hexadecimal numbers, we check to make sure we
        // haven't gotten more digits than will fit in a DWORD.
        //
        if(Base == 16) {
            if(++OverflowCheck > (sizeof(LONGLONG) * 2)) {
                break;
            }
        } else {
            if(Value < OverflowCheck) {
                break;
            } else {
                OverflowCheck = Value;
            }
        }
    }

    if(*String) {
        SetLastError(ERROR_INVALID_DATA);
        return(FALSE);
    }

    if(Neg) {
        Value = 0-Value;
    }
    b = TRUE;
    try {
        *OutValue = Value;
    } except(EXCEPTION_EXECUTE_HANDLER) {
        b = FALSE;
    }
    if(!b) {
        SetLastError(ERROR_INVALID_PARAMETER);
    }
    return(b);
}


DWORD
tmbox(
      LPCTSTR fmt,
      ...
      )
{
    TCHAR  text[1024];
    TCHAR  caption[256];

    va_list vaList;

    sapiAssert(fmt);

    va_start(vaList, fmt);
    wvsprintf(text, fmt, vaList);
    va_end(vaList);

    *caption = 0;
    LoadString(MyModuleHandle, IDS_SETUP, caption, sizeof(caption)/sizeof(TCHAR));
    sapiAssert(*caption);

    return MessageBox(WizardDialogHandle,
                      text,
                      caption,
                      MB_ICONINFORMATION | MB_OK);
}

#ifdef PRERELEASE
#ifdef DBG
HRESULT
FTestForOutstandingCoInits(
    VOID
    )
/*++

Routine Description: Determines is there was an unitialized call to OleInitialize()

Arguments:
                NONE

Return Value:
                an HRESULT code

Remarks:
                Don't call this function in the release version.

--*/

{
    HRESULT hInitRes = ERROR_SUCCESS;

#if defined(UNICODE) || defined(_UNICODE)
    // perform a defensive check
    hInitRes = CoInitializeEx( NULL, COINIT_MULTITHREADED );
    if ( SUCCEEDED(hInitRes) )
    {
        CoUninitialize();
    }
    else
    {
        goto FTestForOutstandingCoInits_Exit;
    }

    hInitRes = CoInitializeEx( NULL, COINIT_APARTMENTTHREADED );
    if ( SUCCEEDED(hInitRes) )
    {
        CoUninitialize();
    }
    else
    {
        goto FTestForOutstandingCoInits_Exit;
    }
#endif

    // it worked out OK
    hInitRes = NOERROR;
    goto FTestForOutstandingCoInits_Exit;

FTestForOutstandingCoInits_Exit:
    return hInitRes;
}

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ocmanage\common\ocmanage.c ===
#include "precomp.h"
#pragma hdrstop


//
// Names of wizard page types, do not change order unless
// the WizardPagesType enum is changed.
//
LPCTSTR WizardPagesTypeNames[WizPagesTypeMax] = { TEXT("Welcome"), TEXT("Mode"),
                                                  TEXT("Early")  , TEXT("Prenet"),
                                                  TEXT("Postnet"), TEXT("Late"),
                                                  TEXT("Final")
                                                };

//
// Name of sections and keys in infs.
//
LPCTSTR szComponents = TEXT("Components");
LPCTSTR szOptionalComponents = TEXT("Optional Components");
LPCTSTR szExtraSetupFiles = TEXT("ExtraSetupFiles");
LPCTSTR szNeeds = TEXT("Needs");
LPCTSTR szExclude = TEXT("Exclude");
LPCTSTR szParent = TEXT("Parent");
LPCTSTR szIconIndex = TEXT("IconIndex");
LPCTSTR szModes = TEXT("Modes");
LPCTSTR szTip = TEXT("Tip");
LPCTSTR szOptionDesc = TEXT("OptionDesc");
LPCTSTR szInstalledFlag = TEXT("InstalledFlag");
LPCTSTR szHide = TEXT("HIDE");
LPCTSTR szOSSetupOnly = TEXT("OSSetupOnly");
LPCTSTR szStandaloneOnly = TEXT("StandaloneOnly");
LPCTSTR szPageTitle = TEXT("PageTitles");
LPCTSTR szSetupTitle = TEXT("SetupPage");
LPCTSTR szGlobal = TEXT("Global");
LPCTSTR szWindowTitle = TEXT("WindowTitle");
LPCTSTR szWindowTitleAlone = TEXT("WindowTitle.StandAlone");
LPCTSTR szSizeApproximation = TEXT("SizeApproximation");
LPCTSTR szWindowTitleInternal = TEXT("*");

//
// Key in registry where private component data is kept.
// We form a unique name within this key for the OC Manager
// instantiation.
//
LPCTSTR szOcManagerRoot   = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager");
LPCTSTR szPrivateDataRoot = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\TemporaryData");
LPCTSTR szMasterInfs      = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\MasterInfs");
LPCTSTR szSubcompList     = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\Subcomponents");
LPCTSTR szOcManagerErrors = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\Errors");

//
// Other string constants.
//
LPCTSTR szSetupDir = TEXT("Setup");

//
// locale information
//
LOCALE locale;

// Structure used for string table callback when
// building a subcomponent list.
//
typedef struct _BUILDSUBCOMPLIST_PARAMS {
    POC_MANAGER OcManager;
    UINT Pass;
} BUILDSUBCOMPLIST_PARAMS, *PBUILDSUBCOMPLIST_PARAMS;

//
// oc manager pointer for debugging/logging
//
POC_MANAGER gLastOcManager = NULL;

UINT
pOcQueryOrSetNewInf(
    IN  PCTSTR MasterOcInfName,
    OUT PTSTR  SuiteName,
    IN  DWORD  Operation
    );

VOID
pOcDestroyPerOcData(
    IN POC_MANAGER OcManager
    );

BOOL
pOcDestroyPerOcDataStringCB(
    IN PVOID               StringTable,
    IN LONG                StringId,
    IN PCTSTR              String,
    IN POPTIONAL_COMPONENT Oc,
    IN UINT                OcSize,
    IN LPARAM              Unused
    );

VOID
pOcClearAllErrorStates(
    IN POC_MANAGER OcManager
    );

BOOL
FileExists(
    IN  PCTSTR           FileName,
    OUT PWIN32_FIND_DATA FindData   OPTIONAL
    )

/*++

Routine Description:

    Determine if a file exists and is accessible.
    Errormode is set (and then restored) so the user will not see
    any pop-ups.

Arguments:

    FileName - supplies full path of file to check for existance.

    FindData - if specified, receives find data for the file.

Return Value:

    TRUE if the file exists and is accessible.
    FALSE if not. GetLastError() returns extended error info.

--*/

{
    WIN32_FIND_DATA findData;
    HANDLE FindHandle;
    UINT OldMode;
    DWORD Error;

    OldMode = SetErrorMode(SEM_FAILCRITICALERRORS);

    FindHandle = FindFirstFile(FileName,&findData);
    if(FindHandle == INVALID_HANDLE_VALUE) {
        Error = GetLastError();
    } else {
        FindClose(FindHandle);
        if(FindData) {
            *FindData = findData;
        }
        Error = NO_ERROR;
    }

    SetErrorMode(OldMode);

    SetLastError(Error);
    return (Error == NO_ERROR);
}

VOID
pOcFormSuitePath(
    IN  LPCTSTR SuiteName,
    IN  LPCTSTR FileName,   OPTIONAL
    OUT LPTSTR  FullPath
    )

/*++

Routine Description:

    Forms the name of the directory in the OS tree where per-suite
    infs and installation dlls are kept (system32\setup).

    Optionally also appends the name of a file to the path.

Arguments:

    SuiteName - shortname for the suite.

    FileName - optionally specifies the name of a file in the per-suite
        directory.

    FullPath - receives the full path of the per-suite directory (or the
        file within the directory). This buffer should be MAX_PATH TCHAR
        elements.

Return Value:

    None.

--*/

{
    UNREFERENCED_PARAMETER(SuiteName);

    GetSystemDirectory(FullPath,MAX_PATH);

    pSetupConcatenatePaths(FullPath,szSetupDir,MAX_PATH,NULL);

    //
    // We put all such files in a single flat directory.
    // This makes life easier for components that want to share
    // installation pieces, such as infs, dlls, etc.
    //
    // There are potential name conflict issues but we blow them off.
    //
    //pSetupConcatenatePaths(FullPath,SuiteName,MAX_PATH,NULL);

    if(FileName) {
        pSetupConcatenatePaths(FullPath,FileName,MAX_PATH,NULL);
    }
}


BOOL
pOcBuildSubcomponentListStringCB(
    IN PVOID                    StringTable,
    IN LONG                     StringId,
    IN PCTSTR                   String,
    IN POC_INF                  OcInf,
    IN UINT                     OcInfSize,
    IN PBUILDSUBCOMPLIST_PARAMS Params
    )

/*++

Routine Description:

    String table callback, worker routine for pOcBuildSubcomponentLists.

    This routine examines the loaded per-component infs and builds the
    subcomponent hierarchies that are described therein via the Parent=
    lines in the various per-component sections.

Arguments:

    Standard string table callback args.

Return Value:

    Boolean indicating outcome. If FALSE, an error will have been logged.
    FALSE also stops the string table enumeration and causes pSetupStringTableEnum()
    to return FALSE.

--*/

{
    OPTIONAL_COMPONENT OptionalComponent;
    OPTIONAL_COMPONENT AuxOc;
    INFCONTEXT LineContext;
    INFCONTEXT SublineContext;
    LPCTSTR SubcompName;
    LPCTSTR  ModuleFlags;
    LPCTSTR p;
    LONG l;
    LONG CurrentStringId;
    UINT u,n;
    INT IconIndex;
    POC_MANAGER OcManager = Params->OcManager;

    if(SetupFindFirstLine(OcInf->Handle,szOptionalComponents,NULL,&LineContext)) {

        do {
            if((SubcompName = pSetupGetField(&LineContext,1)) && *SubcompName) {

                l = pSetupStringTableLookUpStringEx(
                        Params->OcManager->ComponentStringTable,
                        (PTSTR)SubcompName,
                        STRTAB_CASE_INSENSITIVE,
                        &OptionalComponent,
                        sizeof(OPTIONAL_COMPONENT)
                        );

                if(Params->Pass == 0) {

                    //
                    // First pass. Add subcomponents listed in [Optional Components]
                    // to the string table. Each one has an associated OPTIONAL_COMPONENT
                    // structure. Top-level components already exist in the table,
                    // so we are careful here about how we overwrite existing entries.
                    //
                    if(l == -1) {
                        ZeroMemory(&OptionalComponent,sizeof(OPTIONAL_COMPONENT));

                        OptionalComponent.ParentStringId = -1;
                        OptionalComponent.FirstChildStringId = -1;
                        OptionalComponent.NextSiblingStringId = -1;
                        OptionalComponent.InfStringId = StringId;
                        OptionalComponent.Exists = FALSE;
                    }

                    if (OptionalComponent.Exists) {
                        _LogError(OcManager,
                                  OcErrLevError,
                                  MSG_OC_DUPLICATE_COMPONENT,
                                  SubcompName);
                        continue;
                    }

                    OptionalComponent.Exists = TRUE;

                    // Get the second Field of the Optional components line
                    // Determine if this component is hidden or not

                    ModuleFlags = pSetupGetField(&LineContext,2);
                    if (ModuleFlags) {
                        if (OcManager->SetupData.OperationFlags & SETUPOP_STANDALONE)
                            p = szOSSetupOnly;
                        else
                            p = szStandaloneOnly;
                        if (!_tcsicmp(ModuleFlags, szHide) || !_tcsicmp(ModuleFlags, p))
                            OptionalComponent.InternalFlags |= OCFLAG_HIDE;
                    }

                    //
                    // Fetch the description, tip, and iconindex.
                    //
                    if(SetupFindFirstLine(OcInf->Handle,SubcompName,szOptionDesc,&SublineContext)
                    && (p = pSetupGetField(&SublineContext,1))) {

                        lstrcpyn(OptionalComponent.Description,p,MAXOCDESC);
                    } else {
                        OptionalComponent.Description[0] = 0;
                    }

                    if(SetupFindFirstLine(OcInf->Handle,SubcompName,szTip,&SublineContext)
                    && (p = pSetupGetField(&SublineContext,1))) {

                        lstrcpyn(OptionalComponent.Tip,p,MAXOCTIP);
                    } else {
                        OptionalComponent.Tip[0] = 0;
                    }

                    if(SetupFindFirstLine(OcInf->Handle,SubcompName,szIconIndex,&SublineContext)
                    && (p = pSetupGetField(&SublineContext,1))) {

                        LPCTSTR p2,p3;

                        //
                        // If we have fields 2 and 3 then assume we've got a dll
                        // and resource name. Otherwise it's an index or *.
                        //
                        if((p2 = pSetupGetField(&SublineContext,2))
                        && (p3 = pSetupGetField(&SublineContext,3))) {

                            lstrcpyn(
                                OptionalComponent.IconDll,
                                p2,
                                sizeof(OptionalComponent.IconDll)/sizeof(TCHAR)
                                );

                            lstrcpyn(
                                OptionalComponent.IconResource,
                                p3,
                                sizeof(OptionalComponent.IconResource)/sizeof(TCHAR)
                                );

                            IconIndex = -2;

                        } else {
                            //
                            // If the icon index is * then stick -1 in there
                            // as a special marker value for later.
                            // Otherwise we call SetupGetIntField because it will
                            // validate the field for us.
                            //
                            if((p[0] == TEXT('*')) && (p[1] == 0)) {
                                IconIndex = -1;
                            } else {
                                if(!SetupGetIntField(&SublineContext,1,&IconIndex)) {
                                    IconIndex = DEFAULT_ICON_INDEX;
                                } else {
                                    if (IconIndex < 0 || IconIndex > 66)
                                        IconIndex = DEFAULT_ICON_INDEX;
                                }
                            }
                        }
                    } else {
                        //
                        // No icon index.
                        //
                        IconIndex = DEFAULT_ICON_INDEX;
                    }
                    OptionalComponent.IconIndex = IconIndex;

                    //
                    // if the InstalledFlag is specified, check it
                    // and set the original selection state accordingly
                    //
                    OptionalComponent.InstalledState = INSTSTATE_UNKNOWN;
                    if(SetupFindFirstLine(OcInf->Handle,SubcompName,szInstalledFlag,&SublineContext)
                    && (p = pSetupGetField(&SublineContext,1))) {
                        TCHAR regkey[MAXOCIFLAG];
                        lstrcpyn(regkey,p,MAXOCIFLAG);
                        if (p = pSetupGetField(&SublineContext,2)) {
                            TCHAR regval[MAXOCIFLAG];
                            TCHAR buf[MAXOCIFLAG];
                            HKEY  hkey;
                            DWORD size;
                            DWORD type;
                            DWORD rc;
                            lstrcpyn(regval,p,MAXOCIFLAG);
                            if (RegOpenKey(HKEY_LOCAL_MACHINE, regkey, &hkey) == ERROR_SUCCESS) {
                                size = sizeof(buf);
                                rc = RegQueryValueEx(hkey,
                                                     regval,
                                                     NULL,
                                                     &type,
                                                     (LPBYTE)buf,
                                                     &size);
                                RegCloseKey(hkey);
                                if (rc == ERROR_SUCCESS) {
                                    OptionalComponent.InstalledState = INSTSTATE_YES;
                                } else {
                                    OptionalComponent.InstalledState = INSTSTATE_NO;
                                }
                            }
                        }
                    }

                    //
                    // Fetch the list of modes in which the subcomponent should be
                    // on by default. For future expandability, we'll accept any
                    // mode values up to 31, which is the number of bits we can fit
                    // in out UINT bitfield/
                    //
                    if(SetupFindFirstLine(OcInf->Handle,SubcompName,szModes,&SublineContext)) {
                        n = SetupGetFieldCount(&SublineContext);
                        for(u=0; u<n; u++) {
                            if(SetupGetIntField(&SublineContext,u+1,&IconIndex)
                            && ((DWORD)IconIndex < 32)) {

                                OptionalComponent.ModeBits |= (1 << IconIndex);
                            }
                        }
                    }

                    //
                    // As an optimization, fetch the size approximation, if they
                    // supplied one.If they didn't supply this then we have to
                    // query them for disk space
                    //
                    //
                    if(SetupFindFirstLine(OcInf->Handle,SubcompName,szSizeApproximation,&SublineContext)
                       && (p = pSetupGetField(&SublineContext,1))) {
                        //
                        // we have the text version of something that needs to be converted into
                        // a LONGLONG...
                        //
                        pConvertStringToLongLong(p,&OptionalComponent.SizeApproximation);
                        OptionalComponent.InternalFlags |= OCFLAG_APPROXSPACE;
                    }


                    // Find the The "TopLevelParent" for this Node
                    // Search the list if TopLevelComponent looking for
                    // the "INF string id" that matches the Inf String ID
                    // of this component.

                    for(u=0; u<OcManager->TopLevelOcCount; u++) {
                        pSetupStringTableGetExtraData(
                            OcManager->ComponentStringTable,
                            OcManager->TopLevelOcStringIds[u],
                            &AuxOc,
                            sizeof(OPTIONAL_COMPONENT)
                            );

                        if(AuxOc.InfStringId == StringId) {
                            // Found it and save to the current component
                             OptionalComponent.TopLevelStringId = OcManager->TopLevelOcStringIds[u];
                             u=(UINT)-1;
                             break;
                        }
                    }
                       // Check Found the Right String ID.
                    if(u != (UINT)-1) {
                        _LogError(OcManager,OcErrLevFatal,MSG_OC_OOM);
                        return(FALSE);
                    }


                } else {

                    // Pass Two - Discover Needs and Parentage
                    // Two passs First to collect all the names second to
                    // create the needs and parent links

                    CurrentStringId = l;

                    //
                    // Deal with the needs.
                    //
                    if(SetupFindFirstLine(OcInf->Handle,SubcompName,szNeeds,&SublineContext)) {

                        n = 0;
                        u = 0;
                        while(p = pSetupGetField(&SublineContext,n+1)) {
                            //
                            // Ignore unless the subcomponent is in the string table.
                            //
                            l = pSetupStringTableLookUpStringEx(
                                    Params->OcManager->ComponentStringTable,
                                    (PTSTR)p,
                                    STRTAB_CASE_INSENSITIVE,
                                    &AuxOc,
                                    sizeof(OPTIONAL_COMPONENT)
                                    );

                            if(l != -1) {
                                //
                                // Grow the needs array and put this item in it.
                                //
                                if(OptionalComponent.NeedsStringIds) {
                                    p = pSetupRealloc(
                                            OptionalComponent.NeedsStringIds,
                                            (OptionalComponent.NeedsCount+1) * sizeof(LONG)
                                            );
                                } else {
                                    OptionalComponent.NeedsCount = 0;
                                    p = pSetupMalloc(sizeof(LONG));
                                }

                                if(p) {
                                    OptionalComponent.NeedsStringIds = (PVOID)p;
                                    OptionalComponent.NeedsStringIds[OptionalComponent.NeedsCount++] = l;
                                } else {
                                    _LogError(OcManager,OcErrLevFatal,MSG_OC_OOM);
                                    return(FALSE);
                                }

                                //
                                // Insert this component in the needed component's neededby array.
                                //
                                if(AuxOc.NeededByStringIds) {
                                    p = pSetupRealloc(
                                            AuxOc.NeededByStringIds,
                                            (AuxOc.NeededByCount+1) * sizeof(LONG)
                                            );
                                } else {
                                    AuxOc.NeededByCount = 0;
                                    p = pSetupMalloc(sizeof(LONG));
                                }

                                if(p) {
                                    AuxOc.NeededByStringIds = (PVOID)p;
                                    AuxOc.NeededByStringIds[AuxOc.NeededByCount++] = CurrentStringId;
                                } else {
                                    _LogError(OcManager,OcErrLevFatal,MSG_OC_OOM);
                                    return(FALSE);
                                }

                                pSetupStringTableSetExtraData(
                                    Params->OcManager->ComponentStringTable,
                                    l,
                                    &AuxOc,
                                    sizeof(OPTIONAL_COMPONENT)
                                    );
                            }

                            n++;
                        }
                    }

                    //
                    // Deal with the excludes.
                    //
                    if(SetupFindFirstLine(OcInf->Handle,SubcompName,szExclude,&SublineContext)) {

                        n = 0;
                        u = 0;
                        while(p = pSetupGetField(&SublineContext,n+1)) {
                            //
                            // Ignore unless the subcomponent is in the string table.
                            //
                            l = pSetupStringTableLookUpStringEx(
                                    Params->OcManager->ComponentStringTable,
                                    (PTSTR)p,
                                    STRTAB_CASE_INSENSITIVE,
                                    &AuxOc,
                                    sizeof(OPTIONAL_COMPONENT)
                                    );

                            if(l != -1) {
                                //
                                // Grow the exclude array and put this item in it.
                                //
                                if(OptionalComponent.ExcludeStringIds) {
                                    p = pSetupRealloc(
                                            OptionalComponent.ExcludeStringIds,
                                            (OptionalComponent.ExcludeCount+1) * sizeof(LONG)
                                            );
                                } else {
                                    OptionalComponent.ExcludeCount = 0;
                                    p = pSetupMalloc(sizeof(LONG));
                                }

                                if(p) {
                                    OptionalComponent.ExcludeStringIds = (PVOID)p;
                                    OptionalComponent.ExcludeStringIds[OptionalComponent.ExcludeCount++] = l;
                                } else {
                                    _LogError(OcManager,OcErrLevFatal,MSG_OC_OOM);
                                    return(FALSE);
                                }

                                //
                                // Insert this component in the excluded component's excludedby array.
                                //
                                if(AuxOc.ExcludedByStringIds) {
                                    p = pSetupRealloc(
                                            AuxOc.ExcludedByStringIds,
                                            (AuxOc.ExcludedByCount+1) * sizeof(LONG)
                                            );
                                } else {
                                    AuxOc.ExcludedByCount = 0;
                                    p = pSetupMalloc(sizeof(LONG));
                                }

                                if(p) {
                                    AuxOc.ExcludedByStringIds = (PVOID)p;
                                    AuxOc.ExcludedByStringIds[AuxOc.ExcludedByCount++] = CurrentStringId;
                                } else {
                                    _LogError(OcManager,OcErrLevFatal,MSG_OC_OOM);
                                    return(FALSE);
                                }

                                pSetupStringTableSetExtraData(
                                    Params->OcManager->ComponentStringTable,
                                    l,
                                    &AuxOc,
                                    sizeof(OPTIONAL_COMPONENT)
                                    );
                            }

                            n++;
                        }
                    }

                    //
                    // Figure out parentage. Ignore specified parent unless it exists
                    // in the string table. We also note in the parent that it has children.
                    //
                    if(SetupFindFirstLine(OcInf->Handle,SubcompName,szParent,&SublineContext)
                    && (p = (PVOID)pSetupGetField(&SublineContext,1))) {

                        l = pSetupStringTableLookUpStringEx(
                                Params->OcManager->ComponentStringTable,
                                (PTSTR)p,
                                STRTAB_CASE_INSENSITIVE,
                                &AuxOc,
                                sizeof(OPTIONAL_COMPONENT)
                                );

                        if(l != -1) {
                            //
                            // l is the string id of the parent, and AuxOc is filled with
                            // the parent's optional component data.
                            //
                            OptionalComponent.ParentStringId = l;

                            if(AuxOc.FirstChildStringId == -1) {
                                //
                                // This parent has no children yet.
                                // Set the current component as its (first) child.
                                // Note that in this case the current component does not yet
                                // have any siblings.
                                //
                                AuxOc.FirstChildStringId = CurrentStringId;
                                AuxOc.ChildrenCount = 1;

                                pSetupStringTableSetExtraData(
                                    Params->OcManager->ComponentStringTable,
                                    l,
                                    &AuxOc,
                                    sizeof(OPTIONAL_COMPONENT)
                                    );

                            } else {
                                //
                                // The parent already has children.
                                // Increment the parent's count of children, then
                                // walk the siblings list and add the new component to the end.
                                //
                                AuxOc.ChildrenCount++;

                                pSetupStringTableSetExtraData(
                                    Params->OcManager->ComponentStringTable,
                                    l,
                                    &AuxOc,
                                    sizeof(OPTIONAL_COMPONENT)
                                    );

                                l = AuxOc.FirstChildStringId;

                                pSetupStringTableGetExtraData(
                                    Params->OcManager->ComponentStringTable,
                                    AuxOc.FirstChildStringId,
                                    &AuxOc,
                                    sizeof(OPTIONAL_COMPONENT)
                                    );

                                while(AuxOc.NextSiblingStringId != -1) {

                                    l = AuxOc.NextSiblingStringId;

                                    pSetupStringTableGetExtraData(
                                        Params->OcManager->ComponentStringTable,
                                        l,
                                        &AuxOc,
                                        sizeof(OPTIONAL_COMPONENT)
                                        );
                                }

                                AuxOc.NextSiblingStringId = CurrentStringId;

                                pSetupStringTableSetExtraData(
                                    Params->OcManager->ComponentStringTable,
                                    l,
                                    &AuxOc,
                                    sizeof(OPTIONAL_COMPONENT)
                                    );
                            }

                        }
                    } else {    // a node with out a parent a new Top Level node

                        // Finally Add this String ID to the Component Strings list
                        //  UINT TopLevelParentOcCount;
                        //  PLONG TopLevelParentOcStringIds;

                         if(OcManager->TopLevelParentOcStringIds != NULL) {
                         p = pSetupRealloc(
                                OcManager->TopLevelParentOcStringIds,
                                (OcManager->TopLevelParentOcCount+1)
                                    * sizeof(OcManager->TopLevelParentOcStringIds)
                                );
                         } else {
                            OcManager->TopLevelParentOcCount = 0;
                            p = pSetupMalloc(sizeof(LONG));
                         }

                         if(p) {
                            OcManager->TopLevelParentOcStringIds = (PVOID)p;
                            OcManager->TopLevelParentOcStringIds[OcManager->TopLevelParentOcCount++] = CurrentStringId;

                         } else {
                            _LogError(OcManager,OcErrLevFatal,MSG_OC_OOM);
                            return(FALSE);

                        }

                    }
                }

                //
                // Now add the subcomponent to the string table.
                // We overwrite the extra data, which is not harmful since
                // we specifically fetched it earlier.
                //

                l = pSetupStringTableAddStringEx(
                        Params->OcManager->ComponentStringTable,
                        (PTSTR)SubcompName,
                        STRTAB_NEW_EXTRADATA | STRTAB_CASE_INSENSITIVE,
                        &OptionalComponent,
                        sizeof(OPTIONAL_COMPONENT)
                        );

                if(l == -1) {
                    _LogError(OcManager,OcErrLevFatal,MSG_OC_OOM);
                    return(FALSE);
                }
            }
        } while(SetupFindNextLine(&LineContext,&LineContext));
    }

    return(TRUE);
}


BOOL
pOcBuildSubcomponentLists(
    IN OUT POC_MANAGER OcManager,
    IN     PVOID       Log
    )

/*++

Routine Description:

    This routine examines the loaded per-component infs and builds the
    subcomponent hierarchies that are described therein via the Parent=
    lines in the various per-component sections.

Arguments:

    OcManager - supplies a pointer to the context data structure
        for the OC Manager.

    Log - supplies a handle to use to log errors.

Return Value:

    Boolean indicating outcome. If FALSE, an error will have been logged.

--*/

{
    OC_INF OcInf;
    BOOL b;
    BUILDSUBCOMPLIST_PARAMS s;

    s.OcManager = OcManager;

    //
    // We make 2 passes. The first adds all the subcomponent names to
    // the string table. The second computes parentage. If we don't do
    // it this way then we might have ordering problems.
    //
    s.Pass = 0;
    b = pSetupStringTableEnum(
            OcManager->InfListStringTable,
            &OcInf,
            sizeof(OC_INF),
            (PSTRTAB_ENUM_ROUTINE)pOcBuildSubcomponentListStringCB,
            (LPARAM)&s
            );

    if(b) {
        s.Pass = 1;
        b = pSetupStringTableEnum(
                OcManager->InfListStringTable,
                &OcInf,
                sizeof(OC_INF),
                (PSTRTAB_ENUM_ROUTINE)pOcBuildSubcomponentListStringCB,
                (LPARAM)&s
                );
    }
    return(b);
}


BOOL
pOcInitPaths(
    IN OUT POC_MANAGER OcManager,
    IN     PCTSTR MasterInfName
    )
{
    TCHAR  path[MAX_PATH];
    TCHAR *p;

    //
    // 1. look for master INF in specified directory.
    // 2. look in %systemroot%\system32\Setup directory.
    // 3. look in %systemroot%\inf directory.
    //
    if (!FileExists(MasterInfName, NULL)) {
        pOcFormSuitePath(NULL, NULL, path);
        p = _tcsrchr(MasterInfName, TEXT('\\'));
        if (!p)
            p = (TCHAR *)MasterInfName;
        pSetupConcatenatePaths(path, p, MAX_PATH, NULL);
        if (!FileExists(path, NULL)) {
#ifdef UNICODE
            HMODULE hMod;
            FARPROC pGetSystemWindowsDirectory;
            hMod = LoadLibrary(L"kernel32.dll");
            if (hMod) {
                pGetSystemWindowsDirectory = GetProcAddress(hMod,"GetSystemWindowsDirectoryW");
                if (!pGetSystemWindowsDirectory) {
                    pGetSystemWindowsDirectory = GetProcAddress(hMod,"GetWindowsDirectoryW");
                }

                if (pGetSystemWindowsDirectory) {
                    pGetSystemWindowsDirectory( path, MAX_PATH );
                } else {
                    GetWindowsDirectory(path,MAX_PATH);
                }

                FreeLibrary(hMod);
            }

#else
            GetWindowsDirectory(path,MAX_PATH);
#endif
            pSetupConcatenatePaths(path,TEXT("INF"),MAX_PATH,NULL);
            pSetupConcatenatePaths(path,p,MAX_PATH,NULL);
            if (!FileExists(path, NULL))
                return FALSE;
        }
    } else {
        _tcscpy(path, MasterInfName);
    }

    _tcscpy(OcManager->MasterOcInfPath, path);
    return TRUE;
}

BOOL
pOcInstallSetupComponents(
    IN POPTIONAL_COMPONENT Oc,
    IN OUT POC_MANAGER OcManager,
    IN     PCTSTR      Component,
    IN     PCTSTR      DllName,         OPTIONAL
    IN     PCTSTR      InfName,         OPTIONAL
    IN     HWND        OwnerWindow,
    IN     PVOID       Log
    )

/*++

Routine Description:

    This routine makes sure that all files required for installation of
    a component listed in a master oc inf are properly installed in
    a well-known location.

    If the master OC inf is in the system inf directory, then we assume
    that all files are already in their proper locations and we do nothing.

    Otherwise we copy all installation files into system32\setup.
    Files copied include the per-component inf (if any), the installation dll,
    and all files listed on the ExtraSetupFiles= line in the [<component>]
    section in the master OC inf.

    Do not call this routine if the registry setting indicates that the
    master OC inf has been processed before.

Arguments:

    OcManager - supplies a pointer to the context data structure
        for the OC Manager.

    MasterOcInfName - supplies the full Win32 path of the master OC inf file.

    Component - supplies the shortname of the component we care about.

    DllName - supplies the name of the component's installation dll, if any.

    InfName - supplies the name of the component's per-component inf,
        if any.

    OwnerWindow - supplies the handle of the window to own any UI which may be
        popped up by this routine.

    Log - supplies a handle to use to log errors.

Return Value:

    Boolean indicating outcome. If FALSE, an error will have been logged.

--*/

{
    TCHAR Path[MAX_PATH];
    TCHAR TargetPath[MAX_PATH];
    TCHAR InfPath[MAX_PATH];
    PTCHAR p;
    UINT u;
    HSPFILEQ FileQueue;
    PVOID QueueContext;
    INFCONTEXT InfLine;
    BOOL b;
    TCHAR FileName[MAX_PATH];
    DWORD n;

    b = FALSE;

    //
    // All of the installation files are expected to be sourced
    // in the same directory as the master oc inf itself.
    //
    // We'll stick all the installation files for the component
    // in %windir%\system32\setup so we know where to get at them later.
    //
    // If the master inf is in the inf directory, then we instead
    // assume that the the component is tightly integrated into
    // the system and that the installation files are already in
    // the system32 directory.
    //

    if (!GetWindowsDirectory(Path,MAX_PATH) ||
        !pSetupConcatenatePaths(Path,TEXT("INF"),MAX_PATH,NULL)) {
        _LogError(OcManager,OcErrLevFatal,MSG_OC_OOM);
        goto c0;
    }

    u = lstrlen(Path);

    pOcFormSuitePath(OcManager->SuiteName,NULL,TargetPath);

    lstrcpy(InfPath, OcManager->MasterOcInfPath);
    if (p = _tcsrchr(InfPath, TEXT('\\')))
        *p = 0;

    if (_tcsicmp(InfPath, Path) && _tcsicmp(InfPath, TargetPath)) {

        //
        // Inf is not in inf directory, so need to copy files.
        //
        FileQueue = SetupOpenFileQueue();
        if(FileQueue == INVALID_HANDLE_VALUE) {
            _LogError(OcManager,OcErrLevFatal,MSG_OC_OOM);
            goto c0;
        }

        //
        // We will use the silent feature; no progress gauge but
        // we want errors to be displayed. Pass INVALID_HANDLE_VALUE
        // to get this behavior.
        //
        QueueContext = SetupInitDefaultQueueCallbackEx(OwnerWindow,INVALID_HANDLE_VALUE,0,0,0);
        if(!QueueContext) {
            _LogError(OcManager,OcErrLevFatal,MSG_OC_OOM);
            goto c1;
        }

        //
        // Form source and target paths
        //
        lstrcpy(Path,OcManager->MasterOcInfPath);
        if(p = _tcsrchr(Path,TEXT('\\'))) {
            *p = 0;
        }

        //
        // Queue dll, and, if specified, inf
        //
        if (DllName && *DllName) {
            if ( (OcManager->SetupMode & SETUPMODE_PRIVATE_MASK) == SETUPMODE_REMOVEALL ) {
                b = SetupQueueDelete(
                    FileQueue,      // handle to the file queue
                    TargetPath,     // path to the file to delete
                    DllName         // optional, additional path info
                );
            } else {

                BOOL bCopyFile = TRUE;
                // check if the file is present, it may not have to be for
                // defered installs, where the suite will provide the Exe usally on demand
                // via Web download

                if (Oc &&  Oc->InterfaceFunctionName[0] == 0 ) {

                    // No functin name means external setup

                    lstrcpy(FileName,Path);
                    pSetupConcatenatePaths(FileName, Oc->InstallationDllName, MAX_PATH, NULL);

                    bCopyFile = (GetFileAttributes(FileName)  == -1) ? FALSE: TRUE;
                    b=TRUE;

                    // bCopyFile=TRUE if we found the file

                }
                if( bCopyFile ) {
                    b = SetupQueueCopy(
                        FileQueue,
                        Path,
                        NULL,
                        DllName,
                        NULL,
                        NULL,
                        TargetPath,
                        NULL,
                        SP_COPY_SOURCEPATH_ABSOLUTE
                        );
                }
            }
            if(!b) {
                _LogError(OcManager,OcErrLevFatal,MSG_OC_OOM);
                goto c2;
            }
        }

        if(InfName && *InfName) {
            if ( (OcManager->SetupMode & SETUPMODE_PRIVATE_MASK) == SETUPMODE_REMOVEALL ) {
                b = SetupQueueDelete(
                    FileQueue,      // handle to the file queue
                    TargetPath,     // path to the file to delete
                    InfName         // optional, additional path info
                );
            } else {
                b = SetupQueueCopy(
                    FileQueue,
                    Path,
                    NULL,
                    InfName,
                    NULL,
                    NULL,
                    TargetPath,
                    NULL,
                    SP_COPY_SOURCEPATH_ABSOLUTE
                    );
            }
            if(!b) {
                _LogError(OcManager,OcErrLevFatal,MSG_OC_OOM);
                goto c2;
            }
        }

        //
        // Queue each extra installation file.
        //
        if(SetupFindFirstLine(OcManager->MasterOcInf,Component,szExtraSetupFiles,&InfLine)) {
            n = 1;
            while(SetupGetStringField(&InfLine,n++,FileName,MAX_PATH,NULL)) {

                if ( (OcManager->SetupMode & SETUPMODE_PRIVATE_MASK) == SETUPMODE_REMOVEALL ) {
                    b = SetupQueueDelete(
                        FileQueue,      // handle to the file queue
                        TargetPath,     // path to the file to delete
                        FileName        // optional, additional path info
                    );
                } else {
                     b = SetupQueueCopy(
                            FileQueue,
                            Path,
                            NULL,
                            FileName,
                            NULL,
                            NULL,
                            TargetPath,
                            NULL,
                            SP_COPY_SOURCEPATH_ABSOLUTE
                            );
                }

                if(!b) {
                    _LogError(OcManager,OcErrLevFatal,MSG_OC_OOM);
                    goto c2;
                }
            }
        }

        //
        // Commit the queue.
        //
        b = SetupCommitFileQueue(OwnerWindow,FileQueue,SetupDefaultQueueCallback,QueueContext);
        if(!b) {
            _LogError(OcManager,OcErrLevError,MSG_OC_CANT_COPY_SETUP_FILES,GetLastError());
            goto c2;
        }

        //
        // Make a note that this OC inf is now "known."
        //
        u = pOcQueryOrSetNewInf(OcManager->MasterOcInfPath,OcManager->SuiteName,infSet);
        if(u != NO_ERROR) {
            _LogError(OcManager,OcErrLevWarning,MSG_OC_CANT_WRITE_REGISTRY,u);
        }

c2:
        SetupTermDefaultQueueCallback(QueueContext);
c1:
        SetupCloseFileQueue(FileQueue);
c0:
        ;
    } else {
        b = TRUE;
    }

    return(b);
}


BOOL
pOcLoadMasterOcInf(
    IN OUT POC_MANAGER OcManager,
    IN     DWORD       Flags,
    IN     PVOID       Log
    )

/*++

Routine Description:

    This routine loads the master OC inf and builds up the list of
    top-level optional components and some of the associated data
    inclucing the name of the installation inf, dll and the entry point.
    The per-components infs and dlls are not actually loaded
    by this routine.

    The wizard page ordering stuff is also initialized in the
    OC Manager data structure.

Arguments:

    OcManager - supplies a pointer to the context data structure
        for the OC Manager.

    Flags - if OCINIT_FORCENEWINF, then behave as if the master OC inf is new.
            if OCINIT_KILLSUBCOMPS, then delete all applicable subcomponent
                entries from the registry before processing.

    Log - supplies a handle to use to log errors.

Return Value:

    Boolean indicating outcome. If FALSE, an error will have been logged.

--*/

{
    BOOL b;
    INFCONTEXT InfContext;
    PCTSTR ComponentName;
    PCTSTR DllName;
    PCTSTR ModuleFlags;
    DWORD OtherFlags;
    PCTSTR EntryName;
    PCTSTR InfName;
    LPCTSTR chkflag;
    OPTIONAL_COMPONENT Oc;
    LONG Id;
    PVOID p;
    UINT i,j;
    UINT ActualCount;
    WizardPagesType ReplacePages[4] = {WizPagesWelcome,WizPagesMode,WizPagesFinal,-1},
                    AddPages[5] = {WizPagesEarly,WizPagesPrenet,WizPagesPostnet,WizPagesLate,-1};
    WizardPagesType *PageList;
    PCTSTR SectionName;
    BOOL NewInf;
    TCHAR ComponentsSection[100];
    TCHAR setupdir[MAX_PATH];


    // First check and see if the setup cache directory exists.
    // If not, then we should create it on this run.

    pOcFormSuitePath(NULL, NULL, setupdir);
    sapiAssert(*setupdir);
    if (!FileExists(setupdir, NULL))
        Flags |= OCINIT_FORCENEWINF;

    //
    // Always run pOcQueryOrSetNewInf in case it has side effects.
    //
    if (Flags & OCINIT_KILLSUBCOMPS)
        pOcQueryOrSetNewInf(OcManager->MasterOcInfPath, OcManager->SuiteName, infReset);
    NewInf = !pOcQueryOrSetNewInf(OcManager->MasterOcInfPath,OcManager->SuiteName,infQuery);
    if(Flags & OCINIT_FORCENEWINF) {
        NewInf = TRUE;
        OcManager->InternalFlags |= OCMFLAG_NEWINF;
    }
    if (Flags & OCINIT_KILLSUBCOMPS)
        OcManager->InternalFlags |= OCMFLAG_KILLSUBCOMPS;
    if (Flags & OCINIT_RUNQUIET)
        OcManager->InternalFlags |= OCMFLAG_RUNQUIET;
    if (Flags & OCINIT_LANGUAGEAWARE)
        OcManager->InternalFlags |= OCMFLAG_LANGUAGEAWARE;

    OcManager->MasterOcInf = SetupOpenInfFile(OcManager->MasterOcInfPath,NULL,INF_STYLE_WIN4,&i);
    if(OcManager->MasterOcInf == INVALID_HANDLE_VALUE) {
        _LogError(OcManager,OcErrLevFatal,MSG_OC_CANT_OPEN_INF,OcManager->MasterOcInfPath,GetLastError(),i);
        b = FALSE;
        goto c0;
    }

    //
    // Get the number of lines in the [Components] section and allocate
    // arrays in the OC Manager context structure accordingly. This may
    // overallocate the arrays (in case of duplicates, invalid lines, etc)
    // but we won't worry about that here.
    //
    lstrcpy(ComponentsSection,szComponents);
    OcManager->TopLevelOcCount = (UINT)(-1);
#if defined(_AMD64_)
    lstrcat(ComponentsSection,TEXT(".amd64"));
#elif defined(_X86_)
    lstrcat(ComponentsSection,TEXT(".w95"));
    OcManager->TopLevelOcCount = SetupGetLineCount(OcManager->MasterOcInf,ComponentsSection);
    if(OcManager->TopLevelOcCount == (UINT)(-1)) {
        lstrcpy(ComponentsSection,szComponents);
        lstrcat(ComponentsSection,TEXT(".x86"));
    }
#elif defined(_IA64_)
    lstrcat(ComponentsSection,TEXT(".ia64"));
#else
#error Unknown platform!
#endif
    if(OcManager->TopLevelOcCount == (UINT)(-1)) {
        OcManager->TopLevelOcCount = SetupGetLineCount(OcManager->MasterOcInf,ComponentsSection);
    }
    if(OcManager->TopLevelOcCount == (UINT)(-1)) {
        lstrcpy(ComponentsSection,szComponents);
        OcManager->TopLevelOcCount = SetupGetLineCount(OcManager->MasterOcInf,ComponentsSection);
    }
    if(OcManager->TopLevelOcCount == (UINT)(-1)) {
        _LogError(OcManager,OcErrLevFatal,MSG_OC_INF_INVALID_NO_SECTION,OcManager->MasterOcInfPath,szComponents);
        b = FALSE;
        goto c1;
    }

    if (OcManager->TopLevelOcCount < 1) {
        _LogError(OcManager,OcErrLevFatal,MSG_OC_OOM);
        goto c1;
    }

    if(p = pSetupRealloc(OcManager->TopLevelOcStringIds,OcManager->TopLevelOcCount*sizeof(LONG))) {

        OcManager->TopLevelOcStringIds = p;

        for(i=0; i<WizPagesTypeMax; i++) {

            if(p = pSetupRealloc(OcManager->WizardPagesOrder[i],OcManager->TopLevelOcCount*sizeof(LONG))) {
                OcManager->WizardPagesOrder[i] = p;
            } else {
                _LogError(OcManager,OcErrLevFatal,MSG_OC_OOM);
                b = FALSE;
                goto c1;
            }
        }
    } else {
        _LogError(OcManager,OcErrLevFatal,MSG_OC_OOM);
        goto c1;
    }

    // get global info -
    if ((OcManager->SetupData.OperationFlags & SETUPOP_STANDALONE) &&
        SetupFindFirstLine(
                  OcManager->MasterOcInf,
                  szGlobal,
                  szWindowTitleAlone,
                  &InfContext)) {
        // the main window title
        SetupGetStringField(
                    &InfContext,
                    1,                          // index of the field to get
                    OcManager->WindowTitle,     // optional, receives the field
                    sizeof(OcManager->WindowTitle), // size of the provided buffer
                    NULL);
        if( !lstrcmpi( OcManager->WindowTitle, szWindowTitleInternal)) {
            //This will happen when we load sysoc.inf For MUI.
            LoadString(MyModuleHandle,IDS_OCM_WINDOWTITLE,OcManager->WindowTitle,sizeof(OcManager->WindowTitle)/sizeof(TCHAR));
        }
    } else if(SetupFindFirstLine(
                  OcManager->MasterOcInf,
                  szGlobal,
                  szWindowTitle,
                  &InfContext)) {

        // the main window title
        SetupGetStringField(
                    &InfContext,
                    1,                          // index of the field to get
                    OcManager->WindowTitle,     // optional, receives the field
                    sizeof(OcManager->WindowTitle), // size of the provided buffer
                    NULL);
    } else {
        *OcManager->WindowTitle = 0;
    }

    //
    // Go through the [Components] section. Each line in there is a top-level
    // component spec, giving dll name, entry point name, and optionally
    // the name of the per-component inf.
    //
    if(!SetupFindFirstLine(OcManager->MasterOcInf,ComponentsSection,NULL,&InfContext)) {
        _LogError(OcManager,OcErrLevFatal,MSG_OC_INF_INVALID_NO_SECTION,OcManager->MasterOcInfPath,ComponentsSection);
        b = FALSE;
        goto c1;
    }

    ActualCount = 0;

    do {
        //
        // Get pointers to each field in each line. Ignore invalid lines.
        //
        if(ComponentName = pSetupGetField(&InfContext,0)) {

            DllName = pSetupGetField(&InfContext,1);
            if(DllName && !*DllName) {
                DllName = NULL;
            }
            EntryName = pSetupGetField(&InfContext,2);
            if(EntryName && !*EntryName) {
                EntryName = NULL;
            }

            //
            // An empty string for the inf name is the same as
            // not specifying the inf at all.
            //
            if((InfName = pSetupGetField(&InfContext,3)) && *InfName) {

                Id = pSetupStringTableAddString(
                        OcManager->InfListStringTable,
                        (PTSTR)InfName,
                        STRTAB_CASE_INSENSITIVE
                        );

                if(Id == -1) {
                    _LogError(OcManager,OcErrLevFatal,MSG_OC_OOM);
                    goto c1;
                }
            } else {
                Id = -1;
            }

            // Get the Flags Field
            ModuleFlags = pSetupGetField(&InfContext,4);
            if(ModuleFlags && !*ModuleFlags) {
                ModuleFlags = NULL;
            }

            OtherFlags = 0;
            SetupGetIntField(&InfContext,5,&OtherFlags);

            ZeroMemory(&Oc,sizeof(OPTIONAL_COMPONENT));

            //
            // These guys are top-level. Also remember the string id
            // of the inf name in the inf string table.
            //
            Oc.FirstChildStringId = -1;
            Oc.NextSiblingStringId = -1;
            Oc.ParentStringId = -1;
            Oc.InfStringId = Id;

            // Show flags allows up to have a component that is hidden
            // Only on one flags now so keep processing simple

            Oc.Exists = FALSE;
            Oc.InternalFlags |= OCFLAG_TOPLEVELITEM;

            if (ModuleFlags) {
                if (OcManager->SetupData.OperationFlags & SETUPOP_STANDALONE)
                    chkflag = szOSSetupOnly;
                else
                    chkflag = szStandaloneOnly;
                if (!_tcsicmp(ModuleFlags, szHide) || !_tcsicmp(ModuleFlags, chkflag))
                    Oc.InternalFlags |= OCFLAG_HIDE;
            }

            if (OtherFlags & OCFLAG_NOWIZPAGES) {
                Oc.InternalFlags |= OCFLAG_NOWIZARDPAGES;
            }

            if (OtherFlags & OCFLAG_NOQUERYSKIP) {
                Oc.InternalFlags |= OCFLAG_NOQUERYSKIPPAGES;
            }

            if (OtherFlags & OCFLAG_NOEXTRAFLAGS) {
                Oc.InternalFlags |= OCFLAG_NOEXTRAROUTINES;
            }

            if(DllName) {
                lstrcpyn(Oc.InstallationDllName,DllName,MAX_PATH);
            } else {
                Oc.InstallationDllName[0] = 0;
            }

            //
            // Interface Function Name is always ANSI -- there's no
            // Unicode version of GetProcAddress.
            //
            if(EntryName) {
#ifdef UNICODE
                WideCharToMultiByte(CP_ACP,0,EntryName,-1,Oc.InterfaceFunctionName,MAX_PATH,NULL,NULL);
#else
                lstrcpyn(Oc.InterfaceFunctionName,EntryName,MAX_PATH);
#endif
            } else {
                Oc.InterfaceFunctionName[0] = 0;
            }

            Id = pSetupStringTableAddStringEx(
                    OcManager->ComponentStringTable,
                    (PTSTR)ComponentName,
                    STRTAB_CASE_INSENSITIVE | STRTAB_NEW_EXTRADATA,
                    &Oc,
                    sizeof(OPTIONAL_COMPONENT)
                    );

            if(Id == -1) {
                //
                // OOM adding string
                //
                _LogError(OcManager,OcErrLevFatal,MSG_OC_OOM);
                goto c1;
            }

            OcManager->TopLevelOcStringIds[ActualCount++] = Id;

        }
    } while(SetupFindNextLine(&InfContext,&InfContext));

    //
    // Shrink down the various arrays.
    //
    OcManager->TopLevelOcStringIds = pSetupRealloc(OcManager->TopLevelOcStringIds,ActualCount*sizeof(LONG));
    for(i=0; i<WizPagesTypeMax; i++) {
        OcManager->WizardPagesOrder[i] = pSetupRealloc(OcManager->WizardPagesOrder[i],ActualCount*sizeof(LONG));
    }
    OcManager->TopLevelOcCount = ActualCount;

    //
    // Now for each wizard page type figure out the ordering.
    //
    for(i=0; i<2; i++) {

        SectionName = i ? TEXT("PageAdd") : TEXT("PageReplace");

        for(PageList = i ? AddPages : ReplacePages; *PageList != -1; PageList++) {

            b = SetupFindFirstLine(
                    OcManager->MasterOcInf,
                    SectionName,
                    WizardPagesTypeNames[*PageList],
                    &InfContext
                    );

            //
            // Check for the "default" string, which is the same as if the line
            // had not been specified at all.
            //
            if(b
            && (ComponentName = pSetupGetField(&InfContext,1))
            && !lstrcmpi(ComponentName,TEXT("Default"))) {

                b = FALSE;
            }

            if(b) {
                //
                // Make sure the array is padded with -1's,
                //
                FillMemory(
                    OcManager->WizardPagesOrder[*PageList],
                    OcManager->TopLevelOcCount * sizeof(LONG),
                    (BYTE)(-1)
                    );

                //
                // Now process each element on the line, but don't allow
                // overflowing the array.
                //
                j = 1;
                ActualCount = 0;

                while((ActualCount < OcManager->TopLevelOcCount)
                && (ComponentName = pSetupGetField(&InfContext,j)) && *ComponentName) {

                    Id = pSetupStringTableLookUpString(
                            OcManager->ComponentStringTable,
                            (PTSTR)ComponentName,
                            STRTAB_CASE_INSENSITIVE
                            );

                    if(Id == -1) {
                        //
                        // Invalid component. Log error and keep going.
                        //
                        _LogError(OcManager,
                            OcErrLevWarning,
                            MSG_OC_INVALID_COMP_IN_SECT,
                            OcManager->MasterOcInfPath,
                            SectionName,
                            ComponentName
                            );

                    } else {
                        //
                        // Remember the string id for this component.
                        //
                        OcManager->WizardPagesOrder[*PageList][ActualCount++] = Id;
                    }

                    j++;
                }

            } else {
                //
                // Default ordering, which is the order in which the components
                // were listed in the [Components] section
                //
                CopyMemory(
                    OcManager->WizardPagesOrder[*PageList],
                    OcManager->TopLevelOcStringIds,
                    OcManager->TopLevelOcCount * sizeof(LONG)
                    );
            }
        }
    }

    // get the caption for various pages

    if(SetupFindFirstLine(OcManager->MasterOcInf,szPageTitle,szSetupTitle,&InfContext)) {

        // Found it
        SetupGetStringField(
                    &InfContext,
                    1,                          // index of the field to get
                    OcManager->SetupPageTitle,  // optional, receives the field
                    sizeof(OcManager->SetupPageTitle), // size of the provided buffer
                    NULL);

    }

    return(TRUE);

c1:
    sapiAssert(OcManager->MasterOcInf != INVALID_HANDLE_VALUE);
    SetupCloseInfFile(OcManager->MasterOcInf);
c0:
    return(b);
}


BOOL
pOcSetOcManagerDirIds(
    IN HINF    InfHandle,
    IN LPCTSTR MasterOcInfName,
    IN LPCTSTR ComponentName
    )

/*++

Routine Description:

    This routine sets up the pre-defined OC Manager directory ids for
    per-component infs.

    DIRID_OCM_MASTERINF
    DIRID_OCM_MASTERINF_PLAT
    DIRID_OCM_MASTERINF_COMP
    DIRID_OCM_MASTERINF_COMP_PLAT

Arguments:

    InfHandle - supplies handle to open inf file

    MasterOcInfName - win32 path to master oc inf

    ComponentName - simple shortname for the component

Return Value:

    Boolean value indicating outcome. If FALSE, caller can assume OOM.

--*/

{
    TCHAR Path[MAX_PATH];
    TCHAR *p;
#if defined(_AMD64_)
    LPCTSTR Platform = TEXT("AMD64");
#elif defined(_X86_)
    LPCTSTR Platform = (IsNEC_98) ? TEXT("NEC98") : TEXT("I386");
#elif defined(_IA64_)
    LPCTSTR Platform = TEXT("IA64");
#else
#error "No Target Architecture"
#endif


    lstrcpy(Path,MasterOcInfName);
    if(p = _tcsrchr(Path,TEXT('\\'))) {
        *p = 0;
    } else {
        //
        // Something is very broken
        //
        return(FALSE);
    }

    if(!SetupSetDirectoryId(InfHandle,DIRID_OCM_MASTERINF,Path)) {
        return(FALSE);
    }

    if(!SetupSetDirectoryIdEx(InfHandle,DIRID_OCM_PLATFORM,Platform,SETDIRID_NOT_FULL_PATH,0,0)) {
        return(FALSE);
    }

    if(!SetupSetDirectoryIdEx(
        InfHandle,DIRID_OCM_PLATFORM_ALTERNATE,
#ifdef _X86_
        TEXT("X86"),
#else
        Platform,
#endif
        SETDIRID_NOT_FULL_PATH,0,0)) {

        return(FALSE);
    }

    if(!SetupSetDirectoryIdEx(InfHandle,DIRID_OCM_COMPONENT,ComponentName,SETDIRID_NOT_FULL_PATH,0,0)) {
        return(FALSE);
    }

    return(TRUE);
}


BOOL
pOcLoadInfsAndDlls(
    IN OUT POC_MANAGER OcManager,
    OUT    PBOOL       Canceled,
    IN     PVOID       Log
    )

/*++

Routine Description:

    Loads per-component INFs and installation DLLs.

    This includes invoking the preinitialization and initialization
    entry points in the DLLs.

Arguments:

    OcManager - supplies OC manager context structure

    Cancelled - receives a flag that is valid when this routine fails,
        indicating whether the failure was caused by a component
        canceling.

    Log - supplies a handle to use to log errors.

Return Value:

    Boolean value indicating outcome

--*/

{
    UINT i;
    OPTIONAL_COMPONENT Oc;
    OC_INF OcInf;
    UINT ErrorLine;
    UINT Flags;
    UINT ErrorCode;
    PCTSTR InfName;
    PCTSTR ComponentName;
    TCHAR Library[MAX_PATH];
    BOOL b;
    INFCONTEXT Context;

    *Canceled = FALSE;

    //
    // The top-level component strctures have everything we need.
    // Spin through them.
    //
    for(i=0; i<OcManager->TopLevelOcCount; i++) {

        //
        // Get the OC data from the string table.
        //
        pSetupStringTableGetExtraData(
            OcManager->ComponentStringTable,
            OcManager->TopLevelOcStringIds[i],
            &Oc,
            sizeof(OPTIONAL_COMPONENT)
            );

        if(Oc.InfStringId == -1) {
            //
            // The master OC inf specified that this component has no per-component inf.
            //
            OcInf.Handle = INVALID_HANDLE_VALUE;

        } else {
            //
            // Load the per-component INF if it has not already been loaded.
            //
            pSetupStringTableGetExtraData(OcManager->InfListStringTable,Oc.InfStringId,&OcInf,sizeof(OC_INF));

            if(!OcInf.Handle) {

               InfName = pSetupStringTableStringFromId(OcManager->InfListStringTable,Oc.InfStringId);
               if (!InfName) {
                  _LogError(OcManager,OcErrLevError,MSG_OC_OOM);
                  return(FALSE);
               }

                if(OcManager->InternalFlags & OCMFLAG_NEWINF) {

                    // First try the directory the master inf is in

               lstrcpy(Library, OcManager->SourceDir);
                    pSetupConcatenatePaths(Library, InfName, MAX_PATH, NULL);

                } else {
                    pOcFormSuitePath(OcManager->SuiteName,InfName,Library);
                }

                if(FileExists(Library, NULL)) {
                   OcInf.Handle = SetupOpenInfFile(Library,NULL,INF_STYLE_WIN4,&ErrorLine);
               } else {
                   //
                   // Use standard inf search rules if the inf can't be found
                   // in the special suite directory.
                   //
                   OcInf.Handle = SetupOpenInfFile(InfName,NULL,INF_STYLE_WIN4,&ErrorLine);
               }

               if(OcInf.Handle == INVALID_HANDLE_VALUE) {
                   //
                   // Log error.
                   //
                   _LogError(OcManager,OcErrLevError,MSG_OC_CANT_OPEN_INF,InfName,GetLastError(),ErrorLine);
                   return(FALSE);
               } else {

                   // open the layout file

                   SetupOpenAppendInfFile(NULL, OcInf.Handle, NULL);

                   //
                   // Remember inf handle and set OC Manager DIRIDs.
                   //
                   pSetupStringTableSetExtraData(
                       OcManager->InfListStringTable,
                       Oc.InfStringId,
                       &OcInf,
                       sizeof(OC_INF)
                       );

                   b = pOcSetOcManagerDirIds(
                           OcInf.Handle,
                           OcManager->MasterOcInfPath,
                           pSetupStringTableStringFromId(OcManager->ComponentStringTable,OcManager->TopLevelOcStringIds[i])
                           );

                   if(!b) {
                       _LogError(OcManager,OcErrLevError,MSG_OC_OOM);
                       return(FALSE);
                   }
                   OcManager->SubComponentsPresent = TRUE;
               }
            }
        }

        //
        // Load the DLL and get the entry point address.
        // We make no attempt to track duplicates like we do for infs --
        // the underlying OS does that for us.
        //
        // The dll could be either in the special suite directory for this
        // master oc inf, or in a standard place. LoadLibraryEx does
        // exactly what we want.
        //
        if(Oc.InstallationDllName[0] && Oc.InterfaceFunctionName[0]) {

            if (OcManager->InternalFlags & OCMFLAG_NEWINF) {

                // First try the directory the master inf is in

                lstrcpy(Library, OcManager->SourceDir);
                pSetupConcatenatePaths(Library, Oc.InstallationDllName, MAX_PATH, NULL);
                Oc.InstallationDll = LoadLibraryEx(Library,NULL,LOAD_WITH_ALTERED_SEARCH_PATH);

            }
            // Try the Setup Directory

            if (! Oc.InstallationDll ) {
                pOcFormSuitePath(OcManager->SuiteName,Oc.InstallationDllName,Library);
                Oc.InstallationDll = LoadLibraryEx(Library,NULL,LOAD_WITH_ALTERED_SEARCH_PATH);
            }

            // lastly try anywhere in the path
            if ( ! Oc.InstallationDll ) {
                Oc.InstallationDll = LoadLibraryEx(Oc.InstallationDllName,NULL,LOAD_WITH_ALTERED_SEARCH_PATH);
            }

            //
            // Failure is taken care of below....
            //
            if (Oc.InstallationDll) {
                Oc.InstallationRoutine = (POCSETUPPROC)GetProcAddress(
                                                Oc.InstallationDll,
                                                Oc.InterfaceFunctionName);
            } else {
                Oc.InstallationRoutine = NULL;
            }
        } else {
            Oc.InstallationDll = MyModuleHandle;
            Oc.InstallationRoutine = StandAloneSetupAppInterfaceRoutine;
        }

        if(Oc.InstallationDll && Oc.InstallationRoutine) {
            //
            // Success. Call the init-related entry points. Note that we can't call
            // any entry point except the preinit one until after we've stored
            // the ansi/unicode flag into the OPTIONAL_COMPONENT structure.
            //
            // Also note that before we do this we have to store the Oc structure,
            // otherwise the interface routine is NULL and we fault.
            //

            pSetupStringTableSetExtraData(
                OcManager->ComponentStringTable,
                OcManager->TopLevelOcStringIds[i],
                &Oc,
                sizeof(OPTIONAL_COMPONENT)
                );

            Oc.Flags = OcInterfacePreinitialize(OcManager,OcManager->TopLevelOcStringIds[i]);
            if(!Oc.Flags) {
                //
                // If this fails, then assume the DLL is written for a different
                // platform or version, for example a Unicode/ANSI problem.
                //
                _LogError(OcManager,
                    OcErrLevError,
                    MSG_OC_DLL_PREINIT_FAILED,
                    pSetupStringTableStringFromId(
                        OcManager->ComponentStringTable,
                        OcManager->TopLevelOcStringIds[i]
                        ),
                    Oc.InstallationDllName
                    );

                return(FALSE);
            }
        } else {

            //
            // Failure, log error.
            //
            _LogError(OcManager,
                OcErrLevError,
                MSG_OC_DLL_LOAD_FAIL,
                Oc.InstallationDllName,
                Oc.InterfaceFunctionName,
                GetLastError()
                );

            return(FALSE);
        }

        //
        // Set the OC data back into the string table.
        // After this we can call other interface entry points since
        // the ansi/unicode flag will now be stored in the OPTIONAL_COMPONENT
        // structure for the component.
        //
        pSetupStringTableSetExtraData(
            OcManager->ComponentStringTable,
            OcManager->TopLevelOcStringIds[i],
            &Oc,
            sizeof(OPTIONAL_COMPONENT)
            );

        ErrorCode = OcInterfaceInitComponent(
                        OcManager,
                        OcManager->TopLevelOcStringIds[i]
                        );

        if(ErrorCode == NO_ERROR) {
            // Send down extra helper routines.
            if ((Oc.InternalFlags & OCFLAG_NOEXTRAROUTINES)==0) {
                ErrorCode = OcInterfaceExtraRoutines(
                                OcManager,
                                OcManager->TopLevelOcStringIds[i]
                                );
            }
        }

        if(ErrorCode == NO_ERROR) {
            if (OcManager->InternalFlags & OCMFLAG_LANGUAGEAWARE) {
                //
                // Send down a set-language request.
                // Ignore the result.
                //
                OcInterfaceSetLanguage(
                    OcManager,
                    OcManager->TopLevelOcStringIds[i],
                    LANGIDFROMLCID(GetThreadLocale())
                    );
            }
        } else {
            if(ErrorCode == ERROR_CANCELLED) {
                // cancel will stop oc manager only if
                // we aren't running in gui-mode setup
                *Canceled = TRUE;
                if (OcManager->SetupData.OperationFlags & SETUPOP_STANDALONE)
                    return FALSE;
            } else {
                _LogError(OcManager,
                    OcErrLevError,
                    MSG_OC_DLL_INIT_FAILED,
                    pSetupStringTableStringFromId(
                        OcManager->ComponentStringTable,
                        OcManager->TopLevelOcStringIds[i]
                        )
                    );
            }

            pOcRemoveComponent(OcManager, OcManager->TopLevelOcStringIds[i], pidLoadComponent);
        }
    }

    //
    // Now go gather additional information about subcomponents
    // (descriptions, parentage, needs=, etc).
    //
    return(pOcBuildSubcomponentLists(OcManager,Log));
}


BOOL
pOcUnloadInfsAndDlls(
    IN OUT POC_MANAGER OcManager,
    IN     PVOID       Log
    )

/*++

Routine Description:

    Unloads per-component INFs and installation DLLs that were
    previously loaded by pOcLoadInfsAndDlls().

    This routine does NOT call the interface entry points to
    uninitialize the installation DLLs.

Arguments:

    OcManager - supplies OC manager context structure

    Log - supplies a handle to use to log errors.

Return Value:

    Boolean value indicating outcome.
    If FALSE, an error will have been logged to indicate what failed.

--*/

{
    OPTIONAL_COMPONENT Oc;
    OC_INF OcInf;
    UINT i;

    //
    // Unload Dlls.
    //
    for(i=0; i<OcManager->TopLevelOcCount; i++) {

        pSetupStringTableGetExtraData(
            OcManager->ComponentStringTable,
            OcManager->TopLevelOcStringIds[i],
            &Oc,
            sizeof(OPTIONAL_COMPONENT)
            );

        if(Oc.InstallationDll && (Oc.InstallationDll != MyModuleHandle)) {
            FreeLibrary(Oc.InstallationDll);
            Oc.InstallationDll = NULL;
        }

        Oc.InstallationRoutine = NULL;
        Oc.InstallationDllName[0] = 0;
        Oc.InterfaceFunctionName[0]= 0;

        if(Oc.InfStringId != -1) {

            pSetupStringTableGetExtraData(
                OcManager->InfListStringTable,
                Oc.InfStringId,
                &OcInf,
                sizeof(OC_INF)
                );

            if(OcInf.Handle && (OcInf.Handle != INVALID_HANDLE_VALUE)) {

                SetupCloseInfFile(OcInf.Handle);
                OcInf.Handle = INVALID_HANDLE_VALUE;

                pSetupStringTableSetExtraData(
                    OcManager->InfListStringTable,
                    Oc.InfStringId,
                    &OcInf,
                    sizeof(OC_INF)
                    );
            }

            Oc.InfStringId = -1;
        }

        pSetupStringTableSetExtraData(
            OcManager->ComponentStringTable,
            OcManager->TopLevelOcStringIds[i],
            &Oc,
            sizeof(OPTIONAL_COMPONENT)
            );
    }

    return(TRUE);
}


BOOL
pOcManagerInitPrivateDataStore(
    IN OUT POC_MANAGER OcManager,
    IN     PVOID       Log
    )

/*++

Routine Description:

    Initializes the private data store for components.
    The registry is used as the backing store for private data.
    We make use of volatile keys to help ensure that this data is temporary
    in nature.

Arguments:

    OcManager - supplies OC Manager context stucture.

    Log - supplies a handle to use to log errors.

Return Value:

    Boolean value indicating outcome. If FALSE an error will have
    been logged.

--*/

{
    LONG l;
    DWORD Disposition;

    //
    // Start out by forming a unique name for this instantiation
    // of the OC Manager.
    //
    wsprintf(OcManager->PrivateDataSubkey,TEXT("%x:%x"),GetCurrentProcessId(),OcManager);

    //
    // Open/create the private data root. Save the handle.
    //
    l = RegCreateKeyEx(
            HKEY_LOCAL_MACHINE,
            szPrivateDataRoot,
            0,
            NULL,
            REG_OPTION_VOLATILE,
            KEY_CREATE_SUB_KEY | KEY_ENUMERATE_SUB_KEYS | KEY_QUERY_VALUE | KEY_SET_VALUE,
            NULL,
            &OcManager->hKeyPrivateDataRoot,
            &Disposition
            );

    if(l != NO_ERROR) {
        OcManager->hKeyPrivateDataRoot = NULL;
        OcManager->hKeyPrivateData = NULL;
        _LogError(OcManager,OcErrLevWarning,MSG_OC_CREATE_KEY_FAILED,szPrivateDataRoot,l);
        return(FALSE);
    }

    //
    // Get rid of the private data tree if it already exists for some reason.
    //
    if(Disposition == REG_OPENED_EXISTING_KEY) {
        pSetupRegistryDelnode(OcManager->hKeyPrivateDataRoot,OcManager->PrivateDataSubkey);
    }

    //
    // Create the private data tree. Save the handle.
    //
    l = RegCreateKeyEx(
            OcManager->hKeyPrivateDataRoot,
            OcManager->PrivateDataSubkey,
            0,
            NULL,
            REG_OPTION_VOLATILE,
            KEY_CREATE_SUB_KEY | KEY_QUERY_VALUE | KEY_SET_VALUE,
            NULL,
            &OcManager->hKeyPrivateData,
            &Disposition
            );

    if(l != NO_ERROR) {
        RegCloseKey(OcManager->hKeyPrivateDataRoot);
        OcManager->hKeyPrivateDataRoot = NULL;
        OcManager->hKeyPrivateData = NULL;
        _LogError(OcManager,OcErrLevWarning,MSG_OC_CREATE_KEY_FAILED,OcManager->PrivateDataSubkey,l);
        return(FALSE);
    }

    return(TRUE);
}


VOID
pOcManagerTearDownPrivateDataStore(
    IN OUT POC_MANAGER OcManager
    )
{
    RegCloseKey(OcManager->hKeyPrivateData);
    pSetupRegistryDelnode(OcManager->hKeyPrivateDataRoot,OcManager->PrivateDataSubkey);
    RegCloseKey(OcManager->hKeyPrivateDataRoot);

    OcManager->hKeyPrivateDataRoot = NULL;
    OcManager->hKeyPrivateData = NULL;
}


UINT
pOcQueryOrSetNewInf(
    IN  PCTSTR MasterOcInfName,
    OUT PTSTR  SuiteName,
    IN  DWORD  operation
    )

/*++

Routine Description:

    Determine whether a master OC inf has been encountered before,
    or remember that a master inf has been encountered.

    This information is stored in the registry.

Arguments:

    MasterOcInfName - supplies the full Win32 path of the master OC inf.

    SuiteName - receives the filename part of the .inf, without any
        extension. This is suitable for use as a tag representing the
        suite that the master INF is for. This buffer should be
        MAX_PATH TCHAR elements.

    QueryOnly - if TRUE, then the routine is to query whether the
        master inf has been previously processed. If FALSE, then
        the routine is to remember that the inf has been processed.

Return Value:

    If QueryOnly is TRUE:

        TRUE if the INF has been encountered before, FALSE if not.

    If QueryOnly is FALSE:

        Win32 error code indicating outcome.

--*/

{
    PTCHAR p;
    HKEY hKey;
    LONG l;
    DWORD Type;
    DWORD Size;
    DWORD Data;

    //
    // Form the suite name. The MasterOcInfName is expected to be
    // a full path so this is pretty easy. We'll try to be at least
    // a little more robust.
    //
    if(p = _tcsrchr(MasterOcInfName,TEXT('\\'))) {
        p++;
    } else {
        p = (PTCHAR)MasterOcInfName;
    }
    lstrcpyn(SuiteName,p,MAX_PATH);
    if(p = _tcsrchr(SuiteName,TEXT('.'))) {
        *p = 0;
    }

    //
    // Look in the registry to see if there is a value entry
    // with the suite name in there.
    //

    l = RegCreateKeyEx(
            HKEY_LOCAL_MACHINE,
            szMasterInfs,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            (operation == infQuery) ? KEY_QUERY_VALUE : KEY_SET_VALUE,
            NULL,
            &hKey,
            &Type
            );

    if (l != NO_ERROR)
        return (operation == infQuery) ? 0 : l;

    // do the job

    switch (operation) {

    case infQuery:
        Size = sizeof(DWORD);
        l = RegQueryValueEx(hKey,SuiteName,NULL,&Type,(LPBYTE)&Data,&Size);
        if((l == NO_ERROR) && (Type == REG_DWORD) && Data)
            l = TRUE;
        else
            l = FALSE;
        break;

    case infSet:
        Data = 1;
        l = RegSetValueEx(hKey,SuiteName,0,REG_DWORD,(LPBYTE)&Data,sizeof(DWORD));
        break;

    case infReset:
        l = RegDeleteValue(hKey,SuiteName);
        break;
    }

    RegCloseKey(hKey);

    return l;
}


PVOID
OcInitialize(
    IN  POCM_CLIENT_CALLBACKS Callbacks,
    IN  LPCTSTR               MasterOcInfName,
    IN  UINT                  Flags,
    OUT PBOOL                 ShowError,
    IN  PVOID                 Log
    )

/*++

Routine Description:

    Initializes the OC Manager. The master OC INF is loaded and
    processed, which includes INFs, loading setup interface DLLs and
    querying interface entry points. A set of in-memory structures
    is built up.

    If the OC INF hasn't been processed before then we copy the
    installation files for the component(s) into %windir%\system32\setup.
    Files are expected to be in the same directory as the OC inf.

Arguments:

    Callbacks - supplies a set of routines used by the OC Manager
        to perform various functions.

    MasterOcInfName - supplies the full Win32 path of the master OC inf.

    Flags - supplies various flags that control operation.

    ShowError - receives a flag that is valid if this routine fails,
        advising the caller whether he should show an error message.

    Log - supplies a handle to use to log errors.

Return Value:

    Opaque pointer to internal context structure or NULL if failure.
    If NULL, an error will have been logged to indicate what failed.

--*/

{
    POC_MANAGER OcManager;
    UINT i;
    HKEY hKey;
    DWORD DontCare;
    LONG l;
    BOOL Canceled;
    BOOL rc;
    TCHAR *p;

    *ShowError = TRUE;

    // init the wizard handle

    WizardDialogHandle = NULL;

    //
    // Allocate a new OC MANAGER structure
    //
    OcManager = pSetupMalloc(sizeof(OC_MANAGER));
    if(!OcManager) {
        //
        // Make the callback work
        //
        OC_MANAGER ocm;
        ocm.Callbacks = *Callbacks;
        _LogError(&ocm,OcErrLevFatal,MSG_OC_OOM);
        goto c0;
    }
    ZeroMemory(OcManager,sizeof(OC_MANAGER));

    OcManager->Callbacks = *Callbacks;

    OcManager->CurrentComponentStringId = -1;
    OcManager->SetupMode = SETUPMODE_CUSTOM;
    OcManager->UnattendedInf = INVALID_HANDLE_VALUE;

    gLastOcManager = (POC_MANAGER) OcManager;

    if (!pOcInitPaths(OcManager, MasterOcInfName)) {
        _LogError(OcManager,OcErrLevFatal,MSG_OC_MASTER_INF_LOAD_FAILED);
        goto c1;
    }

    sapiAssert(*OcManager->MasterOcInfPath);

#ifdef UNICODE
    OcFillInSetupDataW(&(OcManager->SetupData));
#else
    OcFillInSetupDataA(&(OcManager->SetupData));
#endif

    // Say the user canceled until we successfully complete an install
    // This will prevent Inf Files from being copied to system32\setup

    OcManager->InternalFlags |= OCMFLAG_USERCANCELED;

    // Make sure the OC Manager key exists in the registry as a non-volatile key.
    // Other parts of the code deal in volatile keys so some care is needed to
    // avoid getting a volatile key under which we want to create non-volatile entries.
    //
    l = RegCreateKeyEx(
            HKEY_LOCAL_MACHINE,
            szOcManagerRoot,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            KEY_CREATE_SUB_KEY | KEY_QUERY_VALUE | KEY_SET_VALUE,
            NULL,
            &hKey,
            &DontCare
            );

    if(l == NO_ERROR) {
        RegCloseKey(hKey);
    } else {
        _LogError(OcManager,OcErrLevWarning,MSG_OC_CREATE_KEY_FAILED,szOcManagerRoot,l);
    }

    // get the locale info

    locale.lcid = GetSystemDefaultLCID();
    GetLocaleInfo(locale.lcid,
                  LOCALE_SDECIMAL,
                  locale.DecimalSeparator,
                  sizeof(locale.DecimalSeparator)/sizeof(TCHAR));

    //
    // Initialize string tables.
    //
    OcManager->InfListStringTable = pSetupStringTableInitializeEx(sizeof(OC_INF),0);
    if(!OcManager->InfListStringTable) {
        _LogError(OcManager,OcErrLevFatal,MSG_OC_OOM);
        goto c1;
    }

    OcManager->ComponentStringTable = pSetupStringTableInitializeEx(sizeof(OPTIONAL_COMPONENT),0);
    if(!OcManager->ComponentStringTable) {
        _LogError(OcManager,OcErrLevFatal,MSG_OC_OOM);
        goto c2;
    }

    //
    // Initialize various arrays. We alloc 0-length blocks here to allow
    // realloc later without special casing.
    //
    OcManager->TopLevelOcStringIds = pSetupMalloc(0);
    if(!OcManager->TopLevelOcStringIds) {
        _LogError(OcManager,OcErrLevFatal,MSG_OC_OOM);
        goto c3;
    }

    for(i=0; i<WizPagesTypeMax; i++) {
        OcManager->WizardPagesOrder[i] = pSetupMalloc(0);
        if(!OcManager->WizardPagesOrder[i]) {
            _LogError(OcManager,OcErrLevFatal,MSG_OC_OOM);
            goto c4;
        }
    }

    //
    // Initialize the private data store.
    //
    if(!pOcManagerInitPrivateDataStore(OcManager,Log)) {
        _LogError(OcManager,OcErrLevFatal,MSG_OC_PRIVATEDATASTORE_INIT_FAILED);
        goto c4;
    }

    //
    // Load the master OC inf.
    //
    if(!pOcLoadMasterOcInf(OcManager, Flags, Log)) {
        _LogError(OcManager,OcErrLevFatal,MSG_OC_MASTER_INF_LOAD_FAILED);
        goto c5;
    }

    // set the source path

    lstrcpy(OcManager->SourceDir, OcManager->MasterOcInfPath);
    if (p = _tcsrchr(OcManager->SourceDir, TEXT('\\')))
        *p = 0;
    else
       GetCurrentDirectory(MAX_PATH, OcManager->SourceDir);

    //
    // Load the unattend file
    //
    if(OcManager->SetupData.UnattendFile[0]) {
        OcManager->UnattendedInf = SetupOpenInfFile(
                                        OcManager->SetupData.UnattendFile,
                                        NULL,
                                        INF_STYLE_WIN4,
                                        NULL
                                        );

        if (OcManager->UnattendedInf == INVALID_HANDLE_VALUE && GetLastError() == ERROR_WRONG_INF_STYLE) {
            OcManager->UnattendedInf = SetupOpenInfFile(
                                            OcManager->SetupData.UnattendFile,
                                            NULL,
                                            INF_STYLE_OLDNT,
                                            NULL
                                            );
        }

        if(OcManager->UnattendedInf == INVALID_HANDLE_VALUE) {
            _LogError(OcManager,OcErrLevFatal,MSG_OC_CANT_OPEN_INF,OcManager->SetupData.UnattendFile,GetLastError());
            goto c6;
        }
    }


    //
    // Load component infs and DLLs.
    //
    rc = pOcLoadInfsAndDlls(OcManager, &Canceled, Log);

    //
    // Error already logged if necessary
    //
    if (Canceled)
        *ShowError = FALSE;

    if (!rc)
        goto c6;

    pOcClearAllErrorStates(OcManager);

    if(!pOcFetchInstallStates(OcManager)) {
        //
        // Error already logged.
        //
        goto c6;
    }


   //
    // Ask the components to give up a rough estimate
    // of their sizes so we can say something meaningful in the list boxes.
    //

    pOcGetApproximateDiskSpace(OcManager);
    return(OcManager);

c6:
    sapiAssert(OcManager->MasterOcInf != INVALID_HANDLE_VALUE);
    SetupCloseInfFile(OcManager->MasterOcInf);
    if (OcManager->UnattendedInf != INVALID_HANDLE_VALUE)
        SetupCloseInfFile(OcManager->UnattendedInf);
c5:
    //
    // Tear down private data store.
    //
    pOcManagerTearDownPrivateDataStore(OcManager);

c4:
    if(OcManager->TopLevelOcStringIds) {
        pSetupFree(OcManager->TopLevelOcStringIds);

        for(i=0; OcManager->WizardPagesOrder[i] && (i<WizPagesTypeMax); i++) {
            pSetupFree(OcManager->WizardPagesOrder[i]);
        }
    }

    // free up the list of aborted components

    if (OcManager->AbortedComponentIds) {
        pSetupFree(OcManager->AbortedComponentIds);
    }

c3:
    pOcDestroyPerOcData(OcManager);
    pSetupStringTableDestroy(OcManager->ComponentStringTable);
c2:
    pSetupStringTableDestroy(OcManager->InfListStringTable);
c1:
    pSetupFree(OcManager);
c0:
    return(NULL);
}

VOID
OcTerminate(
    IN OUT PVOID *OcManagerContext
    )

/*++

Routine Description:

    This routine shuts down the OC Manager, including calling the subcomponents
    to clean themselves up, release resources, etc.

Arguments:

    OcManagerContext - in input, supplies a pointer to a context value returned
        by OcInitialize. On output, receives NULL.

Return Value:

    None.

--*/

{
    POC_MANAGER OcManager;
    UINT u;
    BOOL b;
    OPTIONAL_COMPONENT Oc;
    OC_INF OcInf;
    LPCTSTR ComponentName;
    LPCTSTR InfName;

    sapiAssert(OcManagerContext && *OcManagerContext);
    OcManager = *OcManagerContext;
    *OcManagerContext = NULL;

    //
    // Run down the top-level OCs, calling the dlls to indicate that we're done.
    // We don't tear down any infrastructure until after we've told all the dlls
    // that we're done.
    //
    for(u=0; u<OcManager->TopLevelOcCount; u++) {
        OcInterfaceCleanup(OcManager,OcManager->TopLevelOcStringIds[u]);
    }

    // if the user did not cancel setup
    //
    if (!(OcManager->InternalFlags & OCMFLAG_USERCANCELED)){

        //
        // Remember persistent install state.
        //
        pOcRememberInstallStates(OcManager);

        // copy the master INF file over

        if ( OcManager->InternalFlags & OCMFLAG_NEWINF ) {
            b = pOcInstallSetupComponents(
                        NULL,
                        OcManager,
                        OcManager->SuiteName,
                        NULL,
                        _tcsrchr(OcManager->MasterOcInfPath,TEXT('\\')), //  InfName,
                        NULL,
                        NULL
                );
        }
    }
    //
    // Run down the top-level OCs and free DLLs and per-component infs.
    //
    for(u=0; u<OcManager->TopLevelOcCount; u++) {

        ComponentName =   pSetupStringTableStringFromId(      // ComponentName
                        OcManager->ComponentStringTable,
                        OcManager->TopLevelOcStringIds[u]);

        pSetupStringTableGetExtraData(
            OcManager->ComponentStringTable,
            OcManager->TopLevelOcStringIds[u],
            &Oc,
            sizeof(OPTIONAL_COMPONENT)
            );

        if(Oc.InstallationDll && (Oc.InstallationDll != MyModuleHandle)) {
            //FreeLibrary(Oc.InstallationDll);
        }

        if(Oc.InfStringId != -1) {

            pSetupStringTableGetExtraData(
                OcManager->InfListStringTable,
                Oc.InfStringId,
                &OcInf,
                sizeof(OC_INF)
                );

            if(OcInf.Handle && (OcInf.Handle != INVALID_HANDLE_VALUE)) {
                SetupCloseInfFile(OcInf.Handle);

                //
                // Mark the handle as closed, is to components are shareing
                // the same INF file, should only close the file once.
                //
                OcInf.Handle = INVALID_HANDLE_VALUE;
                pSetupStringTableSetExtraData(
                    OcManager->InfListStringTable,
                    Oc.InfStringId,
                    &OcInf,
                    sizeof(OC_INF)
                );
            }
        }
        // This is a new install and we did not cancel out of setup
        // copy the setup components to the setup dir otherwise a canceled
        // setup will leave an upgrade dead in the water.

        if ( ( (OcManager->InternalFlags & OCMFLAG_NEWINF )
               || ( (OcManager->SetupMode & SETUPMODE_PRIVATE_MASK) == SETUPMODE_REMOVEALL ) )
             && (! (OcManager->InternalFlags & OCMFLAG_USERCANCELED))){

            if (Oc.InfStringId == -1) {
                InfName = NULL;
            } else {
                InfName = pSetupStringTableStringFromId(OcManager->InfListStringTable,
                                                  Oc.InfStringId);
            }

            b = pOcInstallSetupComponents(
                    &Oc,
                    OcManager,
                    ComponentName,
                    Oc.InstallationDllName,
                    InfName,
                    NULL,
                    NULL
            );
            if(!b) {
                _LogError(OcManager,OcErrLevFatal,MSG_OC_CANT_INSTALL_SETUP,ComponentName);
            }
        }


    }

    //
    // Free string tables.
    //
    pOcDestroyPerOcData(OcManager);
    pSetupStringTableDestroy(OcManager->ComponentStringTable);
    pSetupStringTableDestroy(OcManager->InfListStringTable);

    //
    // Free the wizard page ordering arrays.
    //
    for(u=0; u<WizPagesTypeMax; u++) {
        if(OcManager->WizardPagesOrder[u]) {
            pSetupFree(OcManager->WizardPagesOrder[u]);
        }
    }

    //
    // Tear down the private data store.
    //
    pOcManagerTearDownPrivateDataStore(OcManager);

    //
    // Free the master oc inf and finally the oc manager context structure itself.
    //
    sapiAssert(OcManager->MasterOcInf != INVALID_HANDLE_VALUE);
    SetupCloseInfFile(OcManager->MasterOcInf);
    if (OcManager->UnattendedInf && OcManager->UnattendedInf != INVALID_HANDLE_VALUE)
        SetupCloseInfFile(OcManager->UnattendedInf);

    // If this is a remove all then Delete the master inf file too!
    if (    !(OcManager->InternalFlags & OCMFLAG_USERCANCELED)
        &&  ( (OcManager->SetupMode & SETUPMODE_PRIVATE_MASK)
                == SETUPMODE_REMOVEALL )) {

        TCHAR InFSuitePath[MAX_PATH];

        // Se do it this way, so if you run remove all from the
        // orginal source location we don't blow away that copy of the
        // suite inf file.

        pOcFormSuitePath(NULL,OcManager->MasterOcInfPath,InFSuitePath);
        DeleteFile(InFSuitePath);
    }

    // free up the list of aborted components

    if (OcManager->AbortedComponentIds) {
        pSetupFree(OcManager->AbortedComponentIds);
    }

    if (OcManager->TopLevelOcStringIds) {
        pSetupFree(OcManager->TopLevelOcStringIds);
    }

    if (OcManager->TopLevelParentOcStringIds) {
        pSetupFree(OcManager->TopLevelParentOcStringIds);
    }

    //
    // free the oc manager context structure itself.
    //
    pSetupFree(OcManager);

    gLastOcManager = NULL;
}


BOOL
OcSubComponentsPresent(
    IN PVOID OcManagerContext
   )

/*++

Routine Description:

    This routine tells the caller if there are any
    subcomponents available on the details page.

Arguments:

    OcManager - supplies pointer to OC Manager context structure.

Return Value:

    TRUE = yes, there are subcomponents
    FALSE = no way

--*/

{
    POC_MANAGER OcManager = (POC_MANAGER)OcManagerContext;

    if (!OcManagerContext) {
        return FALSE;
    }
    return OcManager->SubComponentsPresent;
}


VOID
pOcDestroyPerOcData(
    IN POC_MANAGER OcManager
    )

/*++

Routine Description:

    This routine frees all data allocated as part of the per-subcomponent
    data structures. The component list string table is enumerated;
    the OPTIONAL_COMPONENT structures have several pointers for arrays
    that must be freed.

Arguments:

    OcManager - supplies pointer to OC Manager context structure.

Return Value:

    None.

--*/

{
    OPTIONAL_COMPONENT OptionalComponent;

    pSetupStringTableEnum(
        OcManager->ComponentStringTable,
        &OptionalComponent,
        sizeof(OPTIONAL_COMPONENT),
        pOcDestroyPerOcDataStringCB,
        0
        );
}


BOOL
pOcDestroyPerOcDataStringCB(
    IN PVOID               StringTable,
    IN LONG                StringId,
    IN PCTSTR              String,
    IN POPTIONAL_COMPONENT Oc,
    IN UINT                OcSize,
    IN LPARAM              Unused
    )

/*++

Routine Description:

    String table callback routine that is the worker routine for
    pOcDestroyPerOcData.

Arguments:

    Standard string table callback arguments.

Return Value:

    Always returns TRUE to continue enumeration.

--*/

{
    UNREFERENCED_PARAMETER(StringTable);
    UNREFERENCED_PARAMETER(StringId);
    UNREFERENCED_PARAMETER(String);
    UNREFERENCED_PARAMETER(OcSize);
    UNREFERENCED_PARAMETER(Unused);

    if(Oc->NeedsStringIds) {
        pSetupFree(Oc->NeedsStringIds);
    }
    if(Oc->NeededByStringIds) {
        pSetupFree(Oc->NeededByStringIds);
    }

    if (Oc->ExcludeStringIds){
        pSetupFree(Oc->ExcludeStringIds);
    }
    if(Oc->ExcludedByStringIds){
        pSetupFree(Oc->ExcludedByStringIds);
    }
    if (Oc->HelperContext) {
        pSetupFree(Oc->HelperContext);
    }

    return(TRUE);
}


BOOL
pOcClearAllErrorStatesCB(
    IN PVOID               StringTable,
    IN LONG                StringId,
    IN PCTSTR              String,
    IN POPTIONAL_COMPONENT Oc,
    IN UINT                OcSize,
    IN LPARAM              OcManager
    )
{
    UNREFERENCED_PARAMETER(StringTable);
    UNREFERENCED_PARAMETER(StringId);
    UNREFERENCED_PARAMETER(String);
    UNREFERENCED_PARAMETER(OcSize);

    OcHelperClearExternalError ((POC_MANAGER)OcManager, StringId ,0);

    return(TRUE);
}

VOID
pOcClearAllErrorStates(
    IN POC_MANAGER OcManager
    )

/*++

Routine Description:

    This routine clears out the past registry entries for error reports
    for all components

Arguments:

    OcManagerContext - in input, supplies a pointer to a context value returned
        by OcInitialize. On output, receives NULL.

Return Value:

    None.

--*/
{
    OPTIONAL_COMPONENT OptionalComponent;

    pSetupStringTableEnum(
        OcManager->ComponentStringTable,
        &OptionalComponent,
        sizeof(OPTIONAL_COMPONENT),
        pOcClearAllErrorStatesCB,
        (LPARAM)OcManager
        );


}

BOOL
pOcRemoveComponent(
    IN POC_MANAGER OcManager,
    IN LONG        ComponentId,
    IN DWORD       PhaseId
    )

/*++

Routine Description:

    This routine adds a specified component to the list of aborted components,
    preventing it's entry function from being called any more.

Arguments:

    OcManager - in input, supplies a pointer to a context value returned
        by OcInitialize. On output, receives NULL.

    ComponentId - in input, this string names the faulty component to be removed

Return Value:

    None.

--*/
{
    PVOID p;
    OPTIONAL_COMPONENT Oc;

    // test for valid component to remove

    if (ComponentId <= 0)
        return FALSE;

    if (pOcComponentWasRemoved(OcManager, ComponentId))
        return FALSE;

    // add component to list of aborted components

    if (!OcManager->AbortedCount) {
        OcManager->AbortedComponentIds = pSetupMalloc(sizeof(UINT));
        if (!OcManager->AbortedComponentIds)
            return FALSE;
    }

    OcManager->AbortedCount++;
    p = pSetupRealloc(OcManager->AbortedComponentIds, sizeof(UINT) * OcManager->AbortedCount);
    if (!p) {
        OcManager->AbortedCount--;
        return FALSE;
    }

    OcManager->AbortedComponentIds = (UINT *)p;
    OcManager->AbortedComponentIds[OcManager->AbortedCount - 1] = ComponentId;

    // stop display of component in the listbox, if it isn't too late

    pSetupStringTableGetExtraData(
        OcManager->ComponentStringTable,
        ComponentId,
        &Oc,
        sizeof(OPTIONAL_COMPONENT)
        );

    Oc.InternalFlags |= OCFLAG_HIDE;

    pSetupStringTableSetExtraData(
        OcManager->ComponentStringTable,
        ComponentId,
        &Oc,
        sizeof(OPTIONAL_COMPONENT)
        );

    _LogError(OcManager,
              OcErrLevInfo | OcErrBatch,
              MSG_OC_REMOVE_COMPONENT,
              pSetupStringTableStringFromId(OcManager->ComponentStringTable,ComponentId),
              PhaseId
              );

    return TRUE;
}

BOOL
pOcComponentWasRemoved(
    IN POC_MANAGER OcManager,
    IN LONG        ComponentId
    )

/*++

Routine Description:

    This routine indicates if a components has been aborted.

Arguments:

    OcManager - in input, supplies a pointer to a context value returned
        by OcInitialize. On output, receives NULL.

    ComponentId - in input, this string names the component to check for

Return Value:

    BOOL - true if it was aborted - else false

--*/
{
    UINT i;

    for (i = 0; i < OcManager->AbortedCount; i++) {
        if (OcManager->AbortedComponentIds[i] == ComponentId) {
            return TRUE;
        }
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ocmanage\common\ocpage.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    ocpage.c

Abstract:

    Routines to run an optional component selection wizard page
    and friends (details, have disk, etc).

Author:

    Ted Miller (tedm) 17-Sep-1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// Maximum number of levels in the OC hierarchy.
// 10 is really generous.
//
#define MAX_OC_LEVELS   10

//
// Max number of depenedent components displayed
// in the remove components Msgbox
//
#define MAX_DISPLAY_IDS 10
//
// Window messages.
//
#define WMX_SELSTATECHANGE  (WM_APP+0)

//
// Internal flag to force routines to turn components on or off
//
#define OCQ_FORCE               0x40000000
#define OCQ_SKIPDISKCALC        0x20000000
#define OCQ_COLLECT_NEEDS       0x10000000
#define OCO_COLLECT_NODEPENDENT 0x80000000

//
// Structure used to track parentage within the optional component page.
//
typedef struct _OCPAGE {
    //
    // OC Manager structure.
    //
    POC_MANAGER OcManager;

    //
    // Parent string id.
    //
    LONG ParentStringId;

    //
    // Information about the dialog controls on main wizard page
    // and on "details" pages.
    //
    OC_PAGE_CONTROLS WizardPageControlsInfo;
    OC_PAGE_CONTROLS DetailsPageControlsInfo;

    //
    // Pointer to actual set of controls in use.
    //
    POC_PAGE_CONTROLS ControlsInfo;

    //
    // Disk space list to use when interacting with OC DLLs.
    //
    HDSKSPC DiskSpaceList;

    //
    // Flag indicating whether we've set initial states.
    //
    BOOL AlreadySetInitialStates;

    //
    // Format string for 'space needed' text, fetched from the
    // dialog at init time (something like "%u.%u MB").
    //
    TCHAR SpaceNeededTextFormat[64];

    //
    // Format string for 'x or y components selected' text, fetched from the
    // dialog at init time (something like "%u of %u components selected").
    //
    TCHAR InstalledCountTextFormat[100];

    //
    // String ids that we collect during selection changes to ask
    // the user if it is Ok to change these as well
    //
    PLONG StringIds;
    UINT  StringIdsCount;

    //
    // Values we sock away in case the user cancels at an OC details page,
    // so we can easily restore things.
    //
    HDSKSPC OldDiskSpaceList;
    PVOID OldComponentStrTab;

} OCPAGE, *POCPAGE;


//
// Structure used when enumerating the component string table to populate
// the list box.
//
typedef struct _POPULATE_ENUM_PARAMS {
    //
    // Master context structure.
    //
    POCPAGE OcPage;

    //
    // List box being populated.
    //
    HWND ListBox;

    //
    // String ID of desired parent. This is how we deal with only
    // those subcomponents we actually care about.
    //
    LONG DesiredParent;

} POPULATE_ENUM_PARAMS, *PPOPULATE_ENUM_PARAMS;

WNDPROC OldListBoxProc;

INT_PTR
CALLBACK
pOcPageDlgProc(
              IN HWND   hdlg,
              IN UINT   msg,
              IN WPARAM wParam,
              IN LPARAM lParam
              );

BOOL
pAskUserOkToChange(
                  IN HWND    hDlg,
                  IN LONG    OcStringId,
                  IN POCPAGE OcPage,
                  IN BOOL   TurningOn
                  );

VOID
pOcDrawLineInListBox(
                    IN POCPAGE         OcPage,
                    IN DRAWITEMSTRUCT *Params
                    );

VOID
pOcListBoxHighlightChanged(
                          IN     HWND    hdlg,
                          IN OUT POCPAGE OcPage,
                          IN     HWND    ListBox
                          );

VOID
pOcSetInstalledCountText(
                        IN HWND                hdlg,
                        IN POCPAGE             OcPage,
                        IN POPTIONAL_COMPONENT OptionalComponent,   OPTIONAL
                        IN LONG                OcStringId
                        );

VOID
pOcListBoxChangeSelectionState(
                              IN     HWND    hdlg,
                              IN OUT POCPAGE OcPage,
                              IN     HWND    ListBox
                              );

VOID
pOcInvalidateRectInListBox(
                          IN HWND    ListBox,
                          IN LPCTSTR OptionalComponent    OPTIONAL
                          );

BOOL
pChangeSubcomponentState(
                        IN  POCPAGE OcPage,
                        IN  HWND    ListBox,
                        IN  LONG    SubcomponentStringId,
                        IN  UINT    Pass,
                        IN  UINT    NewState,
                        IN  UINT    Flags
                        );

VOID
pOcUpdateParentSelectionStates(
                              IN POC_MANAGER OcManager,
                              IN HWND        ListBox,             OPTIONAL
                              IN LONG        SubcomponentStringId
                              );

VOID
pOcUpdateSpaceNeededText(
                        IN POCPAGE OcPage,
                        IN HWND    hdlg
                        );

BOOL
pOcIsDiskSpaceOk(
                IN POCPAGE OcPage,
                IN HWND    hdlg
                );

LRESULT
pOcListBoxSubClassWndProc(
                         IN HWND   hwnd,
                         IN UINT   msg,
                         IN WPARAM wParam,
                         IN LPARAM lParam
                         );

BOOL
pOcPagePopulateListBox(
                      IN POCPAGE OcPage,
                      IN HWND    ListBox,
                      IN LONG    DesiredParent
                      );

BOOL
pOcPopulateListBoxStringTableCB(
                               IN PVOID                 StringTable,
                               IN LONG                  StringId,
                               IN LPCTSTR               String,
                               IN POPTIONAL_COMPONENT   OptionalComponent,
                               IN UINT                  OptionalComponentSize,
                               IN PPOPULATE_ENUM_PARAMS Params
                               );

LONG
pOcGetTopLevelComponent(
                       IN POC_MANAGER OcManager,
                       IN LONG        StringId
                       );

VOID
pOcGetMbAndMbTenths(
                   IN  LONGLONG Number,
                   OUT PUINT    MbCount,
                   OUT PUINT    MbTenthsCount
                   );

VOID
pOcSetStates(
            IN OUT POCPAGE OcPage
            );

BOOL
pOcSetStatesStringWorker(
                        IN LONG         StringId,
                        IN UINT         OverRideState,
                        IN POCPAGE      OcPage
                        );

BOOL
pOcSetStatesStringCB(
                    IN PVOID               StringTable,
                    IN LONG                StringId,
                    IN LPCTSTR             String,
                    IN POPTIONAL_COMPONENT Oc,
                    IN UINT                OcSize,
                    IN LPARAM              lParam
                    );

BOOL
pOcSetStatesStringCB2(
                     IN PVOID               StringTable,
                     IN LONG                StringId,
                     IN LPCTSTR             String,
                     IN POPTIONAL_COMPONENT Oc,
                     IN UINT                OcSize,
                     IN LPARAM              lParam
                     );

BOOL
pOcSetNeededComponentState(
                          IN LONG         StringId,
                          IN UINT         OverRideState,
                          IN POCPAGE      OcPage
                          );

UINT
GetComponentState(
                 IN POCPAGE OcPage,
                 IN LONG    StringId
                 );

#ifdef _OC_DBG
VOID
pOcPrintStates(
              IN POCPAGE OcPage
              );
#endif

HPROPSHEETPAGE
OcCreateOcPage(
              IN PVOID             OcManagerContext,
              IN POC_PAGE_CONTROLS WizardPageControlsInfo,
              IN POC_PAGE_CONTROLS DetailsPageControlsInfo
              )

/*++

Routine Description:

    This routine creates the optional component selection page using
    a particular dialog template.

Arguments:

    OcManagerContext - supplies Optional Component Manager context,
        as returned by OcInitialize().

    WizardPageControlsInfo - supplies information about the controls in the
        template for the top-level/wizard page.

    DetailsPageControlsInfo - supplies information about the controls in the
        template for the top-level/wizard page.

Return Value:

    Handle to newly created property sheet page, or NULL if failure
    (assume out of memory in this case).

--*/

{
    PROPSHEETPAGE Page;
    HPROPSHEETPAGE hPage;
    POCPAGE OcPage;
    TCHAR buffer[256];

    //
    // Allocate and initialize the OCPAGE structure.
    //
    OcPage = pSetupMalloc(sizeof(OCPAGE));
    if (!OcPage) {
        goto c0;
    }
    ZeroMemory(OcPage,sizeof(OCPAGE));

    OcPage->OcManager = OcManagerContext;
    OcPage->WizardPageControlsInfo = *WizardPageControlsInfo;
    OcPage->DetailsPageControlsInfo = *DetailsPageControlsInfo;
    OcPage->ControlsInfo = &OcPage->WizardPageControlsInfo;
    OcPage->ParentStringId = -1;

    //
    // Create the disk space list object.
    //
    OcPage->DiskSpaceList = SetupCreateDiskSpaceList(0,0,SPDSL_DISALLOW_NEGATIVE_ADJUST);
    if (!OcPage->DiskSpaceList) {
        goto c1;
    }

    //
    // Initialize the property sheet page parameters.
    //
    Page.dwSize = sizeof(PROPSHEETPAGE);
    Page.dwFlags = PSP_DEFAULT;
    Page.hInstance = WizardPageControlsInfo->TemplateModule;
    Page.pszTemplate = WizardPageControlsInfo->TemplateResource;
    Page.pfnDlgProc = pOcPageDlgProc;
    Page.lParam = (LPARAM)OcPage;
    Page.pszHeaderTitle = NULL;
    Page.pszHeaderSubTitle = NULL;

    if (WizardPageControlsInfo->HeaderText) {
        if (LoadString(Page.hInstance,
                       WizardPageControlsInfo->HeaderText,
                       buffer,
                       sizeof(buffer) / sizeof(TCHAR)))
        {
            Page.dwFlags |= PSP_USEHEADERTITLE;
            Page.pszHeaderTitle = _tcsdup(buffer);
        }
    }

    if (WizardPageControlsInfo->SubheaderText) {
        if (LoadString(Page.hInstance,
                       WizardPageControlsInfo->SubheaderText,
                       buffer,
                       sizeof(buffer) / sizeof(TCHAR)))
        {
            Page.dwFlags |= PSP_USEHEADERSUBTITLE;
            Page.pszHeaderSubTitle = _tcsdup(buffer);
        }
    }

    //
    // Create the property sheet page itself.
    //
    hPage = CreatePropertySheetPage(&Page);
    if (!hPage) {
        goto c2;
    }

    return (hPage);

    c2:
    if (Page.pszHeaderTitle) {
        free((LPTSTR)Page.pszHeaderTitle);
    }
    if (Page.pszHeaderSubTitle) {
        free((LPTSTR)Page.pszHeaderSubTitle);
    }
    SetupDestroyDiskSpaceList(OcPage->DiskSpaceList);
    c1:
    pSetupFree(OcPage);
    c0:
    return (NULL);
}


INT_PTR
CALLBACK
pOcPageDlgProc(
              IN HWND   hdlg,
              IN UINT   msg,
              IN WPARAM wParam,
              IN LPARAM lParam
              )

/*++

Routine Description:

    Dialog procedure for the OC selection page.

Arguments:

    Standard dialog procedure arguments.

Return Value:

    Standard dialog procedure return value.

--*/

{
    BOOL b;
    POCPAGE OcPage;
    NMHDR *NotifyParams;
    HWND ListBox;
    HIMAGELIST ImageList;
    static BOOL UserClickedCancelOnThisPage = FALSE;
    MSG msgTemp;
    HCURSOR OldCursor;

    //
    // Get pointer to OcPage data structure. If we haven't processed
    // WM_INITDIALOG yet, then this will be NULL, but it's still pretty
    // convenient to do this here once instead of all over the place below.
    //
    if (OcPage = (POCPAGE)GetWindowLongPtr(hdlg,DWLP_USER)) {
        ListBox = GetDlgItem(hdlg,OcPage->ControlsInfo->ListBox);
    } else {
        ListBox = NULL;
    }
    b = FALSE;

    switch (msg) {

        case WM_INITDIALOG:

            //
            // Get the pointer to the OC Manager context structure and stick it
            // in a window long.
            //
            OcPage = (POCPAGE)((PROPSHEETPAGE *)lParam)->lParam;
            ListBox = GetDlgItem(hdlg,OcPage->ControlsInfo->ListBox);
            SetWindowLongPtr(hdlg,DWLP_USER,(LPARAM)OcPage);

            //
            // Subclass the listview.
            //
            OldListBoxProc = (WNDPROC)SetWindowLongPtr(ListBox,GWLP_WNDPROC,(LONG_PTR)pOcListBoxSubClassWndProc);

            //
            // Populate the listbox.
            //
            pOcPagePopulateListBox(OcPage,ListBox,OcPage->ParentStringId);

            //
            // Fetch the space needed text.
            //
            GetDlgItemText(
                          hdlg,
                          OcPage->ControlsInfo->SpaceNeededText,
                          OcPage->SpaceNeededTextFormat,
                          sizeof(OcPage->SpaceNeededTextFormat)/sizeof(TCHAR)
                          );

            GetDlgItemText(
                          hdlg,
                          OcPage->ControlsInfo->InstalledCountText,
                          OcPage->InstalledCountTextFormat,
                          sizeof(OcPage->InstalledCountTextFormat)/sizeof(TCHAR)
                          );

            pOcUpdateSpaceNeededText(OcPage,hdlg);

            //
            // If this has a parent component, then assume it's a details page
            // and set the window title to the description of the parent.
            // If it has no parent, then assume it's the top-level guy and
            // set the instructions text, which is too long for the rc file.
            //
            if (OcPage->ParentStringId == -1) {

                TCHAR Instr[1024];

                FormatMessage(
                             FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_IGNORE_INSERTS,
                             MyModuleHandle,
                             MSG_OC_PAGE_INSTRUCTIONS,
                             0,
                             Instr,
                             sizeof(Instr)/sizeof(TCHAR),
                             NULL
                             );

                SetDlgItemText(hdlg,OcPage->ControlsInfo->InstructionsText,Instr);

            } else {

                OPTIONAL_COMPONENT Oc;

                pSetupStringTableGetExtraData(
                                       OcPage->OcManager->ComponentStringTable,
                                       OcPage->ParentStringId,
                                       &Oc,
                                       sizeof(OPTIONAL_COMPONENT)
                                       );

                SetWindowText(hdlg,Oc.Description);

                //
                // Set component list header
                //
                {
                    TCHAR FormatString[150];
                    TCHAR Title[1000];

                    LoadString(
                              MyModuleHandle,
                              IDS_SUBCOMP_OF,
                              FormatString,
                              sizeof(FormatString)/sizeof(TCHAR)
                              );

                    wsprintf(Title,FormatString,Oc.Description);
                    SetDlgItemText(hdlg,OcPage->ControlsInfo->ComponentHeaderText,Title);
                }
            }

            b = TRUE;
            break;

        case WM_DESTROY:

            if (OcPage && OcPage->ControlsInfo == &OcPage->WizardPageControlsInfo) {

                if (UserClickedCancelOnThisPage) {

                    pOcFreeOcSetupPage(OcPage->OcManager->OcSetupPage);
                    OcPage->OcManager->OcSetupPage = NULL;
                }

                SetupDestroyDiskSpaceList(OcPage->DiskSpaceList);
                OcPage->DiskSpaceList = NULL;

                if (OcPage->StringIds) {
                    pSetupFree(OcPage->StringIds);
                    OcPage->StringIds = NULL;
                }

                pSetupFree(OcPage);
                SetWindowLongPtr(hdlg,DWLP_USER,(LPARAM)NULL);
                break;
            }

            break;

        case WM_MEASUREITEM:
            //
            // Height is height of text/small icon, plus space for a border.
            //
            {
                HDC hdc;
                SIZE size;
                int cy;

                hdc = GetDC(hdlg);
                if (hdc) {
                   SelectObject(hdc,(HFONT)SendMessage(GetParent(hdlg),WM_GETFONT,0,0));
                   GetTextExtentPoint32(hdc,TEXT("W"),1,&size);
                   ReleaseDC(hdlg,hdc);
                } else {
                   size.cy = 0;
                }

                cy = GetSystemMetrics(SM_CYSMICON);

                ((MEASUREITEMSTRUCT *)lParam)->itemHeight = max(size.cy,cy)
                                                            + (2*GetSystemMetrics(SM_CYBORDER));
            }
            b = TRUE;
            break;

        case WM_DRAWITEM:

            pOcDrawLineInListBox(OcPage,(DRAWITEMSTRUCT *)lParam);
            b = TRUE;
            break;

        case WM_COMMAND:

            switch (LOWORD(wParam)) {

                case IDOK:

                    if (HIWORD(wParam) == BN_CLICKED) {
                        //
                        // Only possible from details dialog.
                        //
                        EndDialog(hdlg,TRUE);
                        b = TRUE;
                    }
                    break;

                case IDCANCEL:

                    if (HIWORD(wParam) == BN_CLICKED) {
                        //
                        // Only possible from details dialog.
                        //
                        EndDialog(hdlg,FALSE);
                        b = TRUE;
                    }
                    break;

                default:

                    if ((LOWORD(wParam) == OcPage->ControlsInfo->DetailsButton) && (HIWORD(wParam) == BN_CLICKED)) {
                        //
                        // Details button. Fake out WM_INITDIALOG so lParam is right.
                        //
                        OCPAGE NewOcPage;
                        PROPSHEETPAGE Page;
                        int i;

                        SetCursor(LoadCursor(NULL,IDC_WAIT));

                        i = (int)SendMessage(ListBox,LB_GETCURSEL,0,0);

                        NewOcPage = *OcPage;
                        NewOcPage.ControlsInfo = &NewOcPage.DetailsPageControlsInfo;
                        NewOcPage.ParentStringId = (LONG)SendMessage(ListBox,LB_GETITEMDATA,i,0);

                        //
                        // Preserve the disk space list and component string table
                        // in case the user cancels the details page. Then we can
                        // easily restore things.
                        //
                        OcPage->OldDiskSpaceList = SetupDuplicateDiskSpaceList(
                                                                              NewOcPage.DiskSpaceList,
                                                                              0,0,0
                                                                              );

                        OcPage->OldComponentStrTab = pSetupStringTableDuplicate(
                                                                         OcPage->OcManager->ComponentStringTable
                                                                         );


                        Page.lParam = (LPARAM)&NewOcPage;

                        i = (int)DialogBoxParam(
                                               NewOcPage.DetailsPageControlsInfo.TemplateModule,
                                               NewOcPage.DetailsPageControlsInfo.TemplateResource,
                                               hdlg,
                                               pOcPageDlgProc,
                                               (LPARAM)&Page
                                               );

                        if (i == TRUE) {

                            SetupDestroyDiskSpaceList(OcPage->OldDiskSpaceList);
                            OcPage->DiskSpaceList = NewOcPage.DiskSpaceList;

                            pSetupStringTableDestroy(OcPage->OldComponentStrTab);
                            OcPage->OldComponentStrTab = NULL;

                            //
                            // Force repaint of the listbox, which redraws the checkboxes.
                            //
                            pOcInvalidateRectInListBox(ListBox,NULL);

                            //
                            // Update count of installed subcomponents.
                            //
                            pOcSetInstalledCountText(
                                                    hdlg,
                                                    OcPage,
                                                    NULL,
                                                    (LONG)SendMessage(ListBox,LB_GETITEMDATA,SendMessage(ListBox,LB_GETCURSEL,0,0),0)
                                                    );

                        } else {

                            pSetupStringTableDestroy(OcPage->OcManager->ComponentStringTable);
                            OcPage->OcManager->ComponentStringTable = OcPage->OldComponentStrTab;

                            SetupDestroyDiskSpaceList(NewOcPage.DiskSpaceList);
                            NewOcPage.DiskSpaceList = NULL;
                            OcPage->DiskSpaceList = OcPage->OldDiskSpaceList;
                        }
                        OcPage->OldDiskSpaceList = NULL;
                        OcPage->OldComponentStrTab = NULL;

                        //
                        // It won't hurt anything to do this even in the cancel/failure case,
                        // and this will update the space available.
                        //
                        pOcUpdateSpaceNeededText(OcPage,hdlg);

                        SetCursor(LoadCursor(NULL,IDC_ARROW));

                        b = TRUE;
                    }

                    if (LOWORD(wParam) == OcPage->ControlsInfo->ListBox) {

                        switch (HIWORD(wParam)) {

                            case LBN_DBLCLK:
                                //
                                // Double-click is the same as hitting the details button.
                                // First make sure the details button is enabled.
                                //
                                if (IsWindowEnabled(GetDlgItem(hdlg,OcPage->ControlsInfo->DetailsButton))) {

                                    SetCursor(LoadCursor(NULL,IDC_WAIT));

                                    PostMessage(
                                               hdlg,
                                               WM_COMMAND,
                                               MAKEWPARAM(OcPage->ControlsInfo->DetailsButton,BN_CLICKED),
                                               (LPARAM)GetDlgItem(hdlg,OcPage->ControlsInfo->DetailsButton)
                                               );

                                    SetCursor(LoadCursor(NULL,IDC_ARROW));
                                }
                                b = TRUE;
                                break;

                            case LBN_SELCHANGE:

                                SetCursor(LoadCursor(NULL,IDC_WAIT));
                                pOcListBoxHighlightChanged(hdlg,OcPage,ListBox);
                                SetCursor(LoadCursor(NULL,IDC_ARROW));
                                b = TRUE;
                                break;
                        }
                    }
            }
            break;

        case WM_NOTIFY:

            NotifyParams = (NMHDR *)lParam;

            switch (NotifyParams->code) {

                case PSN_QUERYCANCEL:
                    if (OcPage->OcManager->SetupData.OperationFlags & SETUPOP_STANDALONE) {

                        b = FALSE;
                        OcPage->OcManager->InternalFlags |= OCMFLAG_USERCANCELED;
                        UserClickedCancelOnThisPage = TRUE;

                        SetWindowLongPtr(
                                        hdlg,
                                        DWLP_MSGRESULT,
                                        b
                                        );
                    }

                    b = TRUE;
                    break;

                case PSN_SETACTIVE:

                    //
                    // Set states based on mode bits, if necessary.
                    //

                    OldCursor = SetCursor(LoadCursor (NULL, IDC_WAIT));

                    if (!OcPage->AlreadySetInitialStates) {
                        if ( OcPage->DiskSpaceList  ) {
                            SetupDestroyDiskSpaceList(OcPage->DiskSpaceList);
                            OcPage->DiskSpaceList=NULL;
                        }
                        OcPage->DiskSpaceList = SetupCreateDiskSpaceList(0,0,SPDSL_DISALLOW_NEGATIVE_ADJUST);
                        sapiAssert(OcPage->DiskSpaceList);

                        pOcSetStates(OcPage);
                        OcPage->AlreadySetInitialStates = TRUE;
                    }
#ifdef _OC_DBG
                    pOcPrintStates(OcPage);
#endif
                    pOcUpdateSpaceNeededText(OcPage,hdlg);

                    //
                    // we want to empty the message cue to make sure that
                    // people will see this page, and not accidentally click
                    // next because they were antsy
                    //
                    while (PeekMessage(&msgTemp,NULL,WM_MOUSEFIRST,WM_MOUSELAST,PM_REMOVE));
                    while (PeekMessage(&msgTemp,NULL,WM_KEYFIRST,WM_KEYLAST,PM_REMOVE));
                    SetCursor(OldCursor);

                    if (OcPage->OcManager->SetupData.OperationFlags & SETUPOP_STANDALONE) {
                        ShowWindow(GetDlgItem(GetParent(hdlg),IDCANCEL),SW_SHOW);
                        EnableWindow(GetDlgItem(GetParent(hdlg),IDCANCEL),TRUE);
                    } else {
                        ShowWindow(GetDlgItem(GetParent(hdlg),IDCANCEL),SW_HIDE);
                        EnableWindow(GetDlgItem(GetParent(hdlg),IDCANCEL),FALSE);
                    }

                    // turn off 'back' button if this is the first page

                    PropSheet_SetWizButtons(GetParent(hdlg),
                                            (OcPage->OcManager->InternalFlags & OCMFLAG_NOPREOCPAGES) ? PSWIZB_NEXT : PSWIZB_BACK | PSWIZB_NEXT);

                    //
                    // See whether any component wants to skip this page
                    // or if we are running in unattended mode.
                    // If so, disallow activation and move to next page;
                    // if not then fall through to allow activation of the page.
                    //
                    if (((OcPage->OcManager->SetupData.OperationFlags & SETUPOP_BATCH)
                         || pOcDoesAnyoneWantToSkipPage(OcPage->OcManager,OcPageComponentHierarchy))
                        && pOcIsDiskSpaceOk(OcPage,hdlg)) {

                        //
                        // Skiping this page...
                        // Set Initial State to false because when we
                        // back up from the next page we will go to the
                        // Previos page.
                        //
                        OcPage->AlreadySetInitialStates = FALSE;
                        SetWindowLongPtr(hdlg,DWLP_MSGRESULT,-1);
                    } else {
                        SetWindowLongPtr(hdlg,DWLP_MSGRESULT,0);
                    }
                    b = TRUE;
                    break;

                case PSN_WIZNEXT:
                    //
                    // Check disk space. If not OK, stop here.
                    // Otherwise allow advancing.
                    //
                    SetWindowLongPtr(hdlg,DWLP_MSGRESULT,pOcIsDiskSpaceOk(OcPage,hdlg) ? 0 : -1);
                    b = TRUE;
                    break;

                case PSN_KILLACTIVE:
                    //
                    // Restore the wizard's cancel button if we removed it earlier
                    //
                    if (OcPage->OcManager->SetupData.OperationFlags & SETUPOP_STANDALONE) {
                        ShowWindow(GetDlgItem(GetParent(hdlg),IDCANCEL),SW_SHOW);
                        EnableWindow(GetDlgItem(GetParent(hdlg),IDCANCEL),TRUE);
                    }
                    // pass through

                case PSN_WIZBACK:
                case PSN_WIZFINISH:
                    //
                    // Allow activation/motion.
                    //
                    SetWindowLongPtr(hdlg,DWLP_MSGRESULT,0);
                    b = TRUE;
                    break;
            }
            break;

        case WMX_SELSTATECHANGE:
            //
            // User changed the selection state of an item.
            //
            SetCursor(LoadCursor(NULL,IDC_WAIT));
            pOcListBoxChangeSelectionState(hdlg,OcPage,ListBox);

            pOcSetInstalledCountText(
                                    hdlg,
                                    OcPage,
                                    NULL,
                                    (LONG)SendMessage(ListBox,LB_GETITEMDATA,SendMessage(ListBox,LB_GETCURSEL,0,0),0)
                                    );

            SetCursor(LoadCursor(NULL,IDC_ARROW));
            b = TRUE;

            break;
    }

    return (b);
}


LRESULT
pOcListBoxSubClassWndProc(
                         IN HWND   hwnd,
                         IN UINT   msg,
                         IN WPARAM wParam,
                         IN LPARAM lParam
                         )

/*++

Routine Description:

    Subclass window procecure for listbox controls to handle the following:

    - Highlighting/selection of an item when the user clicks its state icon

    - Spacebar needs to be interpreted as a click on the state icon.

Arguments:

    Standard window procedure arguments.

Return Value:

    Standard window procedure return value.

--*/

{
    int index;
    LRESULT l;

    if (OldListBoxProc == NULL) {
        OutputDebugString(TEXT("Warning: old list box proc is NULL\n"));
        sapiAssert(FALSE && "Warning: old list box proc is NULL\n");
    }

    switch (msg) {

        case WM_LBUTTONDOWN:
            //
            // We want to let the standard list box window proc
            // set selection regardless of what else we do.
            //
            l = CallWindowProc(OldListBoxProc,hwnd,msg,wParam,lParam);

            //
            // If we're over a state icon, then toggle selection state.
            //
            if (LOWORD(lParam) < GetSystemMetrics(SM_CXSMICON)) {
                if (SendMessage(hwnd, LB_ITEMFROMPOINT, 0, lParam) < SendMessage(hwnd, LB_GETCOUNT, 0, 0)) {
                    PostMessage(GetParent(hwnd),WMX_SELSTATECHANGE,0,0);
                }
            }
            break;

        case WM_LBUTTONDBLCLK:
            //
            // Ignore double-clicks over the state icon.
            //
            if (LOWORD(lParam) < GetSystemMetrics(SM_CXSMICON)) {
                l = 0;
            } else {
                l = CallWindowProc(OldListBoxProc,hwnd,msg,wParam,lParam);
            }
            break;

        case WM_KEYDOWN:
            //
            // Catch space bar and treat as a click on the state icon.
            //
            if (wParam == VK_SPACE) {
                PostMessage(GetParent(hwnd),WMX_SELSTATECHANGE,0,0);
                l = 0;
            } else {
                l = CallWindowProc(OldListBoxProc,hwnd,msg,wParam,lParam);
            }
            break;

        default:
            //
            // Let the standard listview window proc handle it.
            //
            l = CallWindowProc(OldListBoxProc,hwnd,msg,wParam,lParam);
            break;
    }

    return (l);
}


VOID
pOcDrawLineInListBox(
                    IN POCPAGE         OcPage,
                    IN DRAWITEMSTRUCT *Params
                    )

/*++

Routine Description:

    Paint a line in the owner-draw listbox, including a state icon,
    mini-icon, and text.

Arguments:

    OcPage - supplies OC page context.

    Params - supplies the draw-item structure.

Return Value:

    None.

--*/

{
    TCHAR Text[MAXOCDESC];
    TCHAR Text2[128];
    SIZE Size;
    int OldMode;
    DWORD OldBackColor,OldTextColor;
    OPTIONAL_COMPONENT Oc;
    UINT IconId;
    int x;
    UINT Length;
    UINT Mb,Tenths;
    TCHAR Dll[MAX_PATH];
    LPCTSTR pDll,Resource;
    LPTSTR p;

    if ((int)Params->itemID < 0) {
        return;
    }

    pSetupStringTableGetExtraData(
                           OcPage->OcManager->ComponentStringTable,
                           (LONG)Params->itemData,
                           &Oc,
                           sizeof(OPTIONAL_COMPONENT)
                           );

    Length = (UINT)SendMessage(Params->hwndItem,LB_GETTEXT,Params->itemID,(LPARAM)Text),
             GetTextExtentPoint32(Params->hDC,Text,Length,&Size);

    if (Params->itemAction != ODA_FOCUS) {

        OldMode = GetBkMode(Params->hDC);

        OldBackColor = SetBkColor(
                                 Params->hDC,
                                 GetSysColor((Params->itemState & ODS_SELECTED) ? COLOR_HIGHLIGHT : COLOR_WINDOW)
                                 );

        OldTextColor = SetTextColor(
                                   Params->hDC,
                                   GetSysColor((Params->itemState & ODS_SELECTED) ? COLOR_HIGHLIGHTTEXT : COLOR_WINDOWTEXT)
                                   );

        //
        // Fill in the background (before mini-icon is drawn!)
        //
        ExtTextOut(Params->hDC,0,0,ETO_OPAQUE,&Params->rcItem,NULL,0,NULL);

        //
        // Draw check box mini-icon.
        //
        switch (Oc.SelectionState) {

            case SELSTATE_NO:
                IconId = 13;
                break;

            case SELSTATE_YES:
                IconId = 12;
                break;

            case SELSTATE_PARTIAL:
                IconId = 25;
                break;

            default:
                IconId = 0;
                break;
        }

        x = SetupDiDrawMiniIcon(
                               Params->hDC,
                               Params->rcItem,
                               IconId,
                               (Params->itemState & ODS_SELECTED) ? MAKELONG(DMI_BKCOLOR, COLOR_HIGHLIGHT) : 0
                               );

        Params->rcItem.left += x;

        //
        // Draw mini-icon for this OC and move string accordingly
        //
        if ((INT)Oc.IconIndex < 0) {
            //
            // Component-supplied miniicon. We query the component dll for the bitmap,
            // which gets added to the mini icon list in setupapi, and thus we can
            // use SetupDiDrawMiniIcon(). Save the index for future use -- we only
            // go through this code path once per subcomponent.
            //
            if (Oc.IconIndex == (UINT)(-2)) {

                pOcFormSuitePath(OcPage->OcManager->SuiteName,Oc.IconDll,Dll);
                pDll = Dll;
                Resource = MAKEINTRESOURCE(_tcstoul(Oc.IconResource,&p,10));
                //
                // If the char that stopped the conversion in _tcstoul is
                // not the terminating nul then the value is not a valid
                // base-10 number; assume it's a name in string form.
                //
                if (*p) {
                    Resource = Oc.IconResource;
                }
            } else {
                pDll = NULL;
                Resource = NULL;
            }

            Oc.IconIndex = pOcCreateComponentSpecificMiniIcon(
                                                             OcPage->OcManager,
                                                             pOcGetTopLevelComponent(OcPage->OcManager,(LONG)Params->itemData),
                                                             pSetupStringTableStringFromId(
                                                                                    OcPage->OcManager->ComponentStringTable,
                                                                                    (LONG)Params->itemData
                                                                                    ),
                                                             x-2,
                                                             GetSystemMetrics(SM_CYSMICON),
                                                             pDll,
                                                             Resource
                                                             );

            pSetupStringTableSetExtraData(
                                   OcPage->OcManager->ComponentStringTable,
                                   (LONG)Params->itemData,
                                   &Oc,
                                   sizeof(OPTIONAL_COMPONENT)
                                   );
        }

        x = SetupDiDrawMiniIcon(
                               Params->hDC,
                               Params->rcItem,
                               Oc.IconIndex,
                               (Params->itemState & ODS_SELECTED) ? MAKELONG(DMI_BKCOLOR, COLOR_HIGHLIGHT) : 0
                               );

        //
        // Draw the text transparently on top of the background
        //
        SetBkMode(Params->hDC,TRANSPARENT);

        ExtTextOut(
                  Params->hDC,
                  x + Params->rcItem.left,
                  Params->rcItem.top + ((Params->rcItem.bottom - Params->rcItem.top) - Size.cy) / 2,
                  0,
                  NULL,
                  Text,
                  Length,
                  NULL
                  );

        pOcGetMbAndMbTenths(Oc.SizeApproximation,&Mb,&Tenths);
        LoadString(MyModuleHandle,IDS_MB_AND_TENTHS,Text2,sizeof(Text2)/sizeof(TCHAR));
        wsprintf(Text,Text2,Mb,locale.DecimalSeparator,Tenths);
        GetTextExtentPoint32(Params->hDC,Text,lstrlen(Text),&Size);
        Params->rcItem.left = Params->rcItem.right - Size.cx - 8;

        ExtTextOut(
                  Params->hDC,
                  Params->rcItem.left,
                  Params->rcItem.top + ((Params->rcItem.bottom - Params->rcItem.top) - Size.cy) / 2,
                  0,
                  NULL,
                  Text,
                  lstrlen(Text),
                  NULL
                  );

        //
        // Restore hdc colors.
        //
        SetBkColor(Params->hDC,OldBackColor);
        SetTextColor(Params->hDC,OldTextColor);
        SetBkMode(Params->hDC,OldMode);
    }

    if ((Params->itemAction == ODA_FOCUS) || (Params->itemState & ODS_FOCUS)) {
        DrawFocusRect(Params->hDC,&Params->rcItem);
    }
}


VOID
pOcListBoxHighlightChanged(
                          IN     HWND    hdlg,
                          IN OUT POCPAGE OcPage,
                          IN     HWND    ListBox
                          )

/*++

Routine Description:

    This routine handles a change in the highlight in the listbox
    control in the oc page. It enables or disables the details button
    based on whether the newly selected component has children
    subcomponents, and changes the tip text.

Arguments:

    hdlg - supplies window handle of OC page

    OcPage - supplies OC page context structure

    ListBox - supplies window handle of list view control in hdlg

Return Value:

    None.

--*/

{
    int i;
    OPTIONAL_COMPONENT Oc;

    //
    // Fetch the optional component data for the highlighted/slected item.
    //
    i = (int)SendMessage(ListBox,LB_GETCURSEL,0,0);
    if (i < 0) {
        return;
    }

    pSetupStringTableGetExtraData(
                           OcPage->OcManager->ComponentStringTable,
                           (LONG)SendMessage(ListBox,LB_GETITEMDATA,i,0),
                           &Oc,
                           sizeof(OPTIONAL_COMPONENT)
                           );

    //
    // Enable/disable the details button.
    // The selected item's lParam is the string id for the selected item.
    //
    EnableWindow(
                GetDlgItem(hdlg,OcPage->ControlsInfo->DetailsButton),
                Oc.FirstChildStringId != -1
                );

    //
    // Change the tip text.
    //
    SetDlgItemText(hdlg,OcPage->ControlsInfo->TipText,Oc.Tip);

    //
    // Set up the count of installed subcomponents.
    //
    pOcSetInstalledCountText(hdlg,OcPage,&Oc,0);
}


VOID
pOcSetInstalledCountText(
                        IN HWND                hdlg,
                        IN POCPAGE             OcPage,
                        IN POPTIONAL_COMPONENT OptionalComponent,   OPTIONAL
                        IN LONG                OcStringId
                        )
{
    TCHAR Text[256];
    UINT TotalCount;
    UINT SelectedCount;
    HWND TextWindow;
    DWORD Args[2];
    OPTIONAL_COMPONENT Oc;
    BOOL b;

    if (OptionalComponent) {
        Oc = *OptionalComponent;
    } else {
        pSetupStringTableGetExtraData(
                               OcPage->OcManager->ComponentStringTable,
                               OcStringId,
                               &Oc,
                               sizeof(OPTIONAL_COMPONENT)
                               );
    }

    TextWindow = GetDlgItem(hdlg,OcPage->ControlsInfo->InstalledCountText);

    //
    // Set up the count ("1 of 3 items selected").
    // If this is not a parent component, then hide that text item.
    //
    if (Oc.FirstChildStringId == -1) {
        ShowWindow(TextWindow,SW_HIDE);
    } else {
        ShowWindow(TextWindow,SW_SHOW);

        //
        // Examine all child components to see how many of them are in
        // a selected state (selected or partially selected). We only count
        // direct children, not children of children, etc.
        //
        TotalCount = 0;
        SelectedCount = 0;
        b = TRUE;

        pSetupStringTableGetExtraData(
                               OcPage->OcManager->ComponentStringTable,
                               Oc.FirstChildStringId,
                               &Oc,
                               sizeof(OPTIONAL_COMPONENT)
                               );

        do {
            TotalCount++;
            if (Oc.SelectionState != SELSTATE_NO) {
                SelectedCount++;
            }

            if (Oc.NextSiblingStringId == -1) {
                b = FALSE;
            } else {
                pSetupStringTableGetExtraData(
                                       OcPage->OcManager->ComponentStringTable,
                                       Oc.NextSiblingStringId,
                                       &Oc,
                                       sizeof(OPTIONAL_COMPONENT)
                                       );
            }
        } while (b);

        Args[0] = SelectedCount;
        Args[1] = TotalCount;

        //
        // Use FormatMessage since order of numbers could change from
        // language to language; wsprintf isn't good enough.
        //
        FormatMessage(
                     FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                     OcPage->InstalledCountTextFormat,
                     0,
                     0,
                     Text,
                     sizeof(Text)/sizeof(TCHAR),
                     (va_list *)Args
                     );

        SetWindowText(TextWindow,Text);
    }
}


VOID
pOcListBoxChangeSelectionState(
                              IN     HWND    hdlg,
                              IN OUT POCPAGE OcPage,
                              IN     HWND    ListBox
                              )

/*++

Routine Description:

    This routine handles a change in selection state for an item.
    Selection state refers to whether the user has placed or cleared
    a checkbox next to an item in the listbox.

    It is assumed that the currently highlighted item is the one
    we want to operate on.

    Selecting/deselecting a component involves calling through the
    installation DLL interface to inform the component's installation DLL
    that a change in selection state has taken place, updating disk space
    requirements, etc.

Arguments:

    hdlg - supplies window handle of OC page

    OcPage - supplies OC page context structure

    ListBox - supplies window handle of listbox control in hdlg

Return Value:

    None.

--*/

{
    OPTIONAL_COMPONENT Oc;
    BOOL TurningOn;
    DWORD b;
//  UINT  state;
    int i;
    LONG StringId;

    //
    // Fetch the optional component data for the highlighted/slected item.
    //
    i = (int)SendMessage(ListBox,LB_GETCURSEL,0,0);
    if (i < 0) {
        return;
    }

    StringId = (LONG)SendMessage(ListBox,LB_GETITEMDATA,i,0);

    //
    // Figure out whether the item is being turned on or off.
    // If the state is deselected then we're turning it on.
    // Otherwise it's partially or fully selected and we're turning it off.
    //
    pSetupStringTableGetExtraData(
                           OcPage->OcManager->ComponentStringTable,
                           StringId,
                           &Oc,
                           sizeof(OPTIONAL_COMPONENT)
                           );

    TurningOn = (Oc.SelectionState == SELSTATE_NO);
    //
    // Tell the user about needs and validate that he wants to continue.
    // turn on or off the needed components.
    //

    OcPage->StringIds = NULL;
    OcPage->StringIdsCount = 0;

    //
    // Do it.
    //
    if (TurningOn) {
        b = pChangeSubcomponentState(OcPage,
                                     ListBox,
                                     StringId,
                                     1,
                                     SELSTATE_YES,
                                     OCQ_ACTUAL_SELECTION|OCQ_COLLECT_NEEDS);

        if (b) {
            if (b = pAskUserOkToChange(hdlg, StringId, OcPage, TurningOn)) {
                pChangeSubcomponentState(OcPage,
                                         ListBox,
                                         StringId,
                                         2,
                                         SELSTATE_YES,
                                         OCQ_ACTUAL_SELECTION);
            }
        }
    } else {
        b = pChangeSubcomponentState(OcPage,
                                     ListBox,
                                     StringId,
                                     1,
                                     SELSTATE_NO,
                                     OCQ_ACTUAL_SELECTION|OCQ_COLLECT_NEEDS);

        if (b) {
            if (b = pAskUserOkToChange(hdlg, StringId, OcPage, TurningOn)) {
                pChangeSubcomponentState(OcPage,
                                         ListBox,
                                         StringId,
                                         2,
                                         SELSTATE_NO,
                                         OCQ_ACTUAL_SELECTION);
            }
        }
    }

    if (b) {
        //
        // Refresh space needed text.
        //
        pOcUpdateSpaceNeededText(OcPage,hdlg);
    }
}

BOOL
pAskUserOkToChange(
                  IN HWND    hDlg,
                  IN LONG    SubcomponentStringId,
                  IN POCPAGE OcPage,
                  IN BOOL AddComponents
                  )

/*++

Routine Description:

    This routine asks the user if it ok to turn off all needed subcomponents

Arguments:

    hDlg                 - parent dialog handle for the messagebox
    SubcomponentStringId - string id of the component that is being changed
    OcPage        - supplies OC page context info.
    AddComponents - TRUE if we're adding components, FALSE if they are being
                    removed

Return Value:

    Boolean value indicating whether the routine was successful.

--*/

{
    BOOL b = TRUE;
    UINT n;
    UINT Id;
    TCHAR buffer[2024];
    TCHAR caption[256];
    LPCTSTR pArgs;
    OPTIONAL_COMPONENT OptionalComponent;

    //
    // Only display warning if there are dependents or
    // user is removing components
    //
    if ( OcPage->StringIdsCount == 0 || AddComponents ) {
        return b;
    }

    pSetupStringTableGetExtraData(
                           OcPage->OcManager->ComponentStringTable,
                           SubcomponentStringId,
                           &OptionalComponent,
                           sizeof(OPTIONAL_COMPONENT));

    //
    // Format the first Half of the message with the component name
    //
    pArgs = OptionalComponent.Description;

    n = FormatMessage(
                     FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                     MyModuleHandle,
                     MSG_OC_PAGE_DEPENDENTS1,
                     0,
                     buffer,
                     sizeof(buffer)/sizeof(TCHAR),
                     (va_list *)&pArgs
                     );


    //
    // Add each dependent component to the message
    // Only add as many components as we have room for
    // Leave roon on the end of buffer for the last message.
    //

    for (Id = 0; Id < OcPage->StringIdsCount
        && n < (sizeof(buffer)/sizeof(TCHAR) - 200 ); Id++)  {

        //
        // Only allow so many components in the messgebox, otherwise will
        // be larger then a VGA display
        //
        if ( Id > MAX_DISPLAY_IDS ) {

            n = lstrlen(buffer);
            FormatMessage(
                         FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                         MyModuleHandle,
                         MSG_OC_PAGE_DEPENDENTS2,
                         0,
                         &buffer[n],
                         (sizeof(buffer)-n)/sizeof(TCHAR),
                         (va_list *)NULL
                         );
            break;

        }
        pSetupStringTableGetExtraData(
                               OcPage->OcManager->ComponentStringTable,
                               OcPage->StringIds[Id],
                               &OptionalComponent,
                               sizeof(OPTIONAL_COMPONENT)
                               );

        //
        // Skip this item if it is a dependent of the Parent, we can arrive
        // at this situation when dependents of the parent needs other
        // dependents. The Collection code can not detect this.
        //
        if (  OptionalComponent.ParentStringId != SubcomponentStringId ) {
            OPTIONAL_COMPONENT ParentOc;
            UINT ParentId;

            //
            // Scan the parentenal chain until we find a match or run out of parents
            // if there is a match then this dependent is the same dependent as the
            // the target component
            //
            ParentId = OptionalComponent.ParentStringId;
            while (ParentId != -1) {

                pSetupStringTableGetExtraData(
                                       OcPage->OcManager->ComponentStringTable,
                                       ParentId,
                                       &ParentOc,
                                       sizeof(OPTIONAL_COMPONENT)
                                       );

                if ( ParentOc.ParentStringId == SubcomponentStringId ) {
                    goto skip;
                }
                ParentId = ParentOc.ParentStringId;
            }


            n += lstrlen(OptionalComponent.Description);
            lstrcat(buffer, OptionalComponent.Description);
            lstrcat(buffer, _T("\n"));
            b = FALSE;
            skip:;

        }
    }

    //
    // Continue if any components got by the Parent and dependent screen
    //
    if ( ! b ) {
        //
        // Add the last half of the message
        //
        n = lstrlen(buffer);
        FormatMessage(
                     FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                     MyModuleHandle,
                     MSG_OC_PAGE_DEPENDENTS3,
                     0,
                     &buffer[n],
                     (sizeof(buffer)-n)/sizeof(TCHAR),
                     (va_list *)NULL
                     );

        //
        // Returns codes from MessageBox()
        //
        *caption = 0;
        LoadString(MyModuleHandle, IDS_SETUP, caption, sizeof(caption)/sizeof(TCHAR));
        sapiAssert(*caption);

        b = (MessageBox(hDlg,
                        buffer,
                        caption,
                        MB_APPLMODAL | MB_ICONINFORMATION | MB_YESNO) == IDYES);
    }

    if (OcPage->StringIds) {
        pSetupFree(OcPage->StringIds);
        OcPage->StringIds = NULL;
        OcPage->StringIdsCount = 0;

    }
    return b;
}

BOOL
pChangeSubcomponentState(
                        IN  POCPAGE OcPage,
                        IN  HWND    ListBox,
                        IN  LONG    SubcomponentStringId,
                        IN  UINT    Pass,
                        IN  UINT    NewState,
                        IN  UINT    Flags
                        )

/*++

Routine Description:

    This routine turns on or off a subcomponent and all needed subcomponents
    and child subcomponents.

Arguments:

    OcPage - supplies OC page context info.

    SubcomponentStringId - supplies string id for subcomponent to be turned on.

    Pass - Supplies an ordinal value that controls operation of this routine.

        Pass = 1: do not actually turn on the subcomponents, but instead
                  perform a dry-run wherein subcomponent installation DLLs
                  are asked whether they will allow the selection.

        Pass = 2: actually turn on the subcomponents and update the
                  selection state in the optional component structure.

    NewState - indicates the new state, SELSTATE_YES or SELSTATE_NO.

    Flags - supplies misc flags

Return Value:

    Boolean value indicating whether the routine was successful.

--*/

{
    UINT n;
    BOOL b;
    BOOL any;
    LONG l;
    UINT SaveState;
    UINT state;
    OPTIONAL_COMPONENT Subcomponent;
    OPTIONAL_COMPONENT OptionalComponent;

    state = NewState;

    pSetupStringTableGetExtraData(
                           OcPage->OcManager->ComponentStringTable,
                           SubcomponentStringId,
                           &OptionalComponent,
                           sizeof(OPTIONAL_COMPONENT)
                           );

    //
    // If the subcomponent is already in the desired state, do nothing.
    //
    if ((OptionalComponent.SelectionState == NewState)
        || (OptionalComponent.InternalFlags & OCFLAG_STATECHANGE)) {
        return (TRUE);
    }

    //
    // Save the state so we can back out in case of failure,
    // then set the "state change in progress" flag.
    //
    SaveState = OptionalComponent.SelectionState;
    OptionalComponent.InternalFlags |= OCFLAG_STATECHANGE;
    pSetupStringTableSetExtraData(
                           OcPage->OcManager->ComponentStringTable,
                           SubcomponentStringId,
                           &OptionalComponent,
                           sizeof(OPTIONAL_COMPONENT)
                           );

    // ask the component whether it will allow being turned on.

    b = OcInterfaceQueryChangeSelState(
                                      OcPage->OcManager,
                                      pOcGetTopLevelComponent(OcPage->OcManager,SubcomponentStringId),
                                      pSetupStringTableStringFromId(OcPage->OcManager->ComponentStringTable,SubcomponentStringId),
                                      (NewState != SELSTATE_NO),
                                      (Pass == 1) ? Flags : Flags  & ~(OCQ_ACTUAL_SELECTION)
                                      );

    if (!b)
        goto Backout_ExtraData;

    //
    // Next, turn on needed/needed-by components.
    // and turn off excluded/excluded-by components
    //
    if (NewState == SELSTATE_YES) {
        for (n=0; n<OptionalComponent.NeedsCount; n++) {
            b = pChangeSubcomponentState(
                                        OcPage,
                                        ListBox,
                                        OptionalComponent.NeedsStringIds[n],
                                        Pass,
                                        NewState,
                                        Flags & ~(OCQ_ACTUAL_SELECTION|OCO_COLLECT_NODEPENDENT));

            if (!b) {
                goto Backout_ExtraData;
            }
        }
    } else if (NewState == SELSTATE_NO) {
        for (n=0; n<OptionalComponent.NeededByCount; n++) {
            b = pChangeSubcomponentState(
                                        OcPage,
                                        ListBox,
                                        OptionalComponent.NeededByStringIds[n],
                                        Pass,
                                        NewState,
                                        Flags & ~(OCQ_ACTUAL_SELECTION|OCO_COLLECT_NODEPENDENT));

            if (!b) {
                goto Backout_ExtraData;
            }
        }
    }

    // handle exclusives

    if (NewState != SELSTATE_NO) {
        for (n=0; n<OptionalComponent.ExcludedByCount; n++) {
            b = pChangeSubcomponentState(
                                        OcPage,
                                        ListBox,
                                        OptionalComponent.ExcludedByStringIds[n],
                                        Pass,
                                        SELSTATE_NO,
                                        Flags & OCO_COLLECT_NODEPENDENT & ~(OCQ_ACTUAL_SELECTION));

            if (!b) {
                goto Backout_ExtraData;
            }
        }
        for (n=0; n<OptionalComponent.ExcludeCount; n++) {
            b = pChangeSubcomponentState(
                                        OcPage,
                                        ListBox,
                                        OptionalComponent.ExcludeStringIds[n],
                                        Pass,
                                        SELSTATE_NO,
                                        Flags & OCO_COLLECT_NODEPENDENT & ~(OCQ_ACTUAL_SELECTION));

            if (!b) {
                goto Backout_ExtraData;
            }
        }
    }

    //
    // Turn off Collect needs if this is the top level selection or the
    // dependent of the toplevel item
    //
    if ( Flags & OCQ_ACTUAL_SELECTION ) {
        Flags |= OCO_COLLECT_NODEPENDENT;
    }

    //
    // Now turn on/off all subcomponents.
    //
    any = (OptionalComponent.FirstChildStringId == -1) ? TRUE : FALSE;
    for (l = OptionalComponent.FirstChildStringId; l != -1; l = Subcomponent.NextSiblingStringId) {
        b = pChangeSubcomponentState(
                                    OcPage,
                                    ListBox,
                                    l,
                                    Pass,
                                    NewState,
                                    Flags  & ~OCQ_ACTUAL_SELECTION);

        if (b)
            any = TRUE;

        pSetupStringTableGetExtraData(
                               OcPage->OcManager->ComponentStringTable,
                               l,
                               &Subcomponent,
                               sizeof(OPTIONAL_COMPONENT)
                               );
    }

    // if all changes were rejected - fail

    if (!any) {
        b = FALSE;
        goto Backout_ExtraData;
    }

    // load the return value and do the work

    b = TRUE;

    switch (Pass) {

        case 1:
            //
            // Component says it's ok add this string ID to the list of Dependents
            // Only if the user is making the selection
            //
            if (    (Flags & OCQ_COLLECT_NEEDS)         // Are we checking
                    &&  !(Flags & OCO_COLLECT_NODEPENDENT ) // dependents of the Selection
                    &&  !(Flags & OCQ_ACTUAL_SELECTION )    // The current selections
               ) {

                LONG *p;
                INT count = (INT)OcPage->StringIdsCount;
                BOOL Found = FALSE;

                //
                // Search the list of dependent components
                // Skip if the current component or the parent of the current component
                // All ready is in the list
                //
                while (count--  ) {

                    if ( (OcPage->StringIds[count] == SubcomponentStringId)
                         || (OcPage->StringIds[count] == OptionalComponent.ParentStringId) ){
                        Found = TRUE;
                        break;
                    }
                }

                if ( !Found ) {
                    if (OcPage->StringIds) {
                        p = pSetupRealloc(
                                     OcPage->StringIds,
                                     (OcPage->StringIdsCount+1) * sizeof(LONG)
                                     );
                    } else {
                        OcPage->StringIdsCount = 0;
                        p = pSetupMalloc(sizeof(LONG));
                    }
                    if (p) {
                        OcPage->StringIds = (PVOID)p;
                        OcPage->StringIds[OcPage->StringIdsCount++] = SubcomponentStringId;
                    } else {
                        _LogError(OcPage->OcManager,OcErrLevFatal,MSG_OC_OOM);
                        return (FALSE);
                    }
                }
            }
            goto Backout_ExtraData;
            break;

        case 2:
            //
            // In pass 2, we update the states in the optional component structures
            // and request the component DLL put its stuff on the disk space list.
            // (The component itself is called only for leaf nodes. We do not call
            // down to the subcomponent's DLL for parent components).
            //

            // check one more time to see if the state change wasn't as expected

            if (OptionalComponent.FirstChildStringId != -1)
                state = GetComponentState(OcPage, SubcomponentStringId);

            OptionalComponent.SelectionState = state;
            OptionalComponent.InternalFlags &= ~OCFLAG_STATECHANGE;

            pSetupStringTableSetExtraData(
                                   OcPage->OcManager->ComponentStringTable,
                                   SubcomponentStringId,
                                   &OptionalComponent,
                                   sizeof(OPTIONAL_COMPONENT)
                                   );

            if (ListBox) {
                pOcInvalidateRectInListBox(ListBox,OptionalComponent.Description);
            }

            if ((OptionalComponent.FirstChildStringId == -1) && !(Flags & OCQ_SKIPDISKCALC)) {

                OcInterfaceCalcDiskSpace(
                                        OcPage->OcManager,
                                        pOcGetTopLevelComponent(OcPage->OcManager,SubcomponentStringId),
                                        pSetupStringTableStringFromId(OcPage->OcManager->ComponentStringTable,SubcomponentStringId),
                                        OcPage->DiskSpaceList,
                                        (NewState != SELSTATE_NO)
                                        );
            }

            pOcUpdateParentSelectionStates(OcPage->OcManager,ListBox,SubcomponentStringId);
            b = TRUE;
            break;
    }

    return (b);

    Backout_ExtraData:

    OptionalComponent.SelectionState = SaveState;
    OptionalComponent.InternalFlags &= ~OCFLAG_STATECHANGE;

    pSetupStringTableSetExtraData(
                           OcPage->OcManager->ComponentStringTable,
                           SubcomponentStringId,
                           &OptionalComponent,
                           sizeof(OPTIONAL_COMPONENT)
                           );

    return (b);
}


VOID
pOcUpdateParentSelectionStates(
                              IN POC_MANAGER OcManager,
                              IN HWND        ListBox,             OPTIONAL
                              IN LONG        SubcomponentStringId
                              )

/*++

Routine Description:

    Examines parent subcomponents of a given component and determines
    the parent states. For example if only some of a parent's children
    are selected, then the parent's state is partially selected.

    Structures are updated and if necessary the relevent items in the
    list box are invalidated to force their checkboxes to be repainted.

Arguments:

    OcManager - supplies OC Manager page context.

    ListBox - supplies window handle of list box.

    SubcomponentStringId - supplies string identifier in the component
        string table, for the subcomponent whose parent(s) state(s) are
        to be checked and updated.

Return Value:

    None.

--*/

{
    UINT Count;
    UINT FullySelectedCount;
    UINT DeselectedCount;
    LONG l,m;
    OPTIONAL_COMPONENT OptionalComponent,Subcomponent;
    BOOL Changed;

    pSetupStringTableGetExtraData(
                           OcManager->ComponentStringTable,
                           SubcomponentStringId,
                           &OptionalComponent,
                           sizeof(OPTIONAL_COMPONENT)
                           );


    for (l = OptionalComponent.ParentStringId; l != -1; l = OptionalComponent.ParentStringId) {

        pSetupStringTableGetExtraData(
                               OcManager->ComponentStringTable,
                               l,
                               &OptionalComponent,
                               sizeof(OPTIONAL_COMPONENT)
                               );

        //
        // Examine all children of this parent subcomponent.
        // If all of them are fully selected, then the parent state is
        // fully selected. If all of them are deselected then the parent state
        // is deselected. Any other case means partially selected.
        //
        Count = 0;
        FullySelectedCount = 0;
        DeselectedCount = 0;

        for (m = OptionalComponent.FirstChildStringId; m != -1; m = Subcomponent.NextSiblingStringId) {

            pSetupStringTableGetExtraData(
                                   OcManager->ComponentStringTable,
                                   m,
                                   &Subcomponent,
                                   sizeof(OPTIONAL_COMPONENT)
                                   );

            //
            // Only count viewable components
            //
            if (!(Subcomponent.InternalFlags & OCFLAG_HIDE)) {
                Count++;

                if (Subcomponent.SelectionState == SELSTATE_YES) {
                    FullySelectedCount++;
                } else {
                    if (Subcomponent.SelectionState == SELSTATE_NO) {
                        DeselectedCount++;
                    }
                }
            }
        }

        if (Count && (Count == FullySelectedCount)) {
            Changed = (OptionalComponent.SelectionState != SELSTATE_YES);
            OptionalComponent.SelectionState = SELSTATE_YES;
        } else {
            if (Count == DeselectedCount) {
                Changed = (OptionalComponent.SelectionState != SELSTATE_NO);
                OptionalComponent.SelectionState = SELSTATE_NO;
            } else {
                Changed = (OptionalComponent.SelectionState != SELSTATE_PARTIAL);
                OptionalComponent.SelectionState = SELSTATE_PARTIAL;
            }
        }

        pSetupStringTableSetExtraData(
                               OcManager->ComponentStringTable,
                               l,
                               &OptionalComponent,
                               sizeof(OPTIONAL_COMPONENT)
                               );

        //
        // Force repaint of the list to get the checkbox state right
        // if the state changed and the item is in the current listbox.
        //
        if (Changed && ListBox) {
            pOcInvalidateRectInListBox(ListBox,OptionalComponent.Description);
        }
    }
}


VOID
pOcInvalidateRectInListBox(
                          IN HWND    ListBox,
                          IN LPCTSTR OptionalComponentName    OPTIONAL
                          )
{
    int i;
    RECT Rect;

    if (OptionalComponentName) {

        i = (int)SendMessage(
                            ListBox,
                            LB_FINDSTRINGEXACT,
                            (WPARAM)(-1),
                            (LPARAM)OptionalComponentName
                            );

        if (i >= 0) {
            SendMessage(ListBox,LB_GETITEMRECT,i,(LPARAM)&Rect);
            InvalidateRect(ListBox,&Rect,FALSE);
        }
    } else {
        InvalidateRect(ListBox,NULL,FALSE);
    }
}


VOID
pOcUpdateSpaceNeededText(
                        IN POCPAGE OcPage,
                        IN HWND    hdlg
                        )

/*++

Routine Description:

    Updates the space needed/space available text on the current
    oc page. Assumes that space needed and available refer to the drive
    where the system is installed.

Arguments:

    OcPage - supplies OC page context.

    hdlg - supplies handle to current oc page dialog.

Return Value:

    None.

--*/

{
    TCHAR Text[128];
    LONGLONG Value;
    DWORD ValueMB;
    DWORD ValueMBTenths;
    TCHAR Drive[MAX_PATH];
    BOOL b;
    DWORD spc,bps,freeclus,totalclus;

    // We check the return code of GetWindowsDirectory to make Prefix happy.

    if (0 == GetWindowsDirectory(Drive,MAX_PATH))
        return;


    //
    // Needed first.
    //
    Drive[2] = 0;
    b = SetupQuerySpaceRequiredOnDrive(OcPage->DiskSpaceList,Drive,&Value,0,0);
    if (!b || (Value < 0)) {
        Value = 0;
    }

    pOcGetMbAndMbTenths(Value,&ValueMB,&ValueMBTenths);
    wsprintf(Text,OcPage->SpaceNeededTextFormat,ValueMB,locale.DecimalSeparator,ValueMBTenths);
    SetDlgItemText(hdlg,OcPage->ControlsInfo->SpaceNeededText,Text);

    //
    // Available next.
    //
    Drive[2] = TEXT('\\');
    Drive[3] = 0;

    if (GetDiskFreeSpace(Drive,&spc,&bps,&freeclus,&totalclus)) {
        Value = ((LONGLONG)(spc*bps)) * freeclus;
    } else {
        Value = 0;
    }

    pOcGetMbAndMbTenths(Value,&ValueMB,&ValueMBTenths);
    wsprintf(Text,OcPage->SpaceNeededTextFormat,ValueMB,locale.DecimalSeparator,ValueMBTenths);
    SetDlgItemText(hdlg,OcPage->ControlsInfo->SpaceAvailableText,Text);
}


BOOL
pOcIsDiskSpaceOk(
                IN POCPAGE OcPage,
                IN HWND    hdlg
                )

/*++

Routine Description:

    This routine checks the space required against the space available,
    for the system drive only (that's the only one the user sees on the
    oc page so it's the only one we check here).

    If there's not enough space, a message box is generated.

Arguments:

    OcPage - supplies OC page context structure.

    hdlg - supplies handle to page in oc manager wizard.

Return Value:

    Boolean value indicating whether disk space is sufficient.

--*/

{
    BOOL b;
    TCHAR Drive[3*MAX_PATH];
    TCHAR caption[256];
    LONGLONG FreeSpace,NeededSpace;
    ULARGE_INTEGER freespace,totalspace,unused;
    DWORD spc,bps,freeclus,totclus;
    HMODULE k32;
    BOOL (WINAPI * pGetSpace)(LPCTSTR,PULARGE_INTEGER,PULARGE_INTEGER,PULARGE_INTEGER);

    if (!GetWindowsDirectory(Drive,MAX_PATH)) {
       return(FALSE);
    }

    b = FALSE;

    if (k32 = LoadLibrary(TEXT("KERNEL32"))) {

        pGetSpace = (PVOID)GetProcAddress(
                                         k32,
#ifdef UNICODE
                                         "GetDiskFreeSpaceExW"
#else
                                         "GetDiskFreeSpaceExA"
#endif
                                         );

        if (pGetSpace) {
            if (b = pGetSpace(Drive,&freespace,&totalspace,&unused)) {
                FreeSpace = (LONGLONG)freespace.QuadPart;
            }
        }

        FreeLibrary(k32);
    }

    if (!b) {
        Drive[3] = 0;
        if (GetDiskFreeSpace(Drive,&spc,&bps,&freeclus,&totclus)) {
            FreeSpace = (LONGLONG)(spc * bps * (DWORDLONG)freeclus);
        } else {
            FreeSpace = 0;
        }
    }

    Drive[2] = 0;
    b = SetupQuerySpaceRequiredOnDrive(OcPage->DiskSpaceList,Drive,&NeededSpace,0,0);
    if (!b || (NeededSpace < 0)) {
        NeededSpace = 0;
    }

    if (FreeSpace < NeededSpace) {

        spc = (DWORD)(UCHAR)Drive[0];

        FormatMessage(
                     FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                     MyModuleHandle,
                     MSG_OC_PAGE_NODISKSPACE,
                     0,
                     Drive,
                     sizeof(Drive)/sizeof(TCHAR),
                     (va_list *)&spc
                     );

        OcPage->OcManager->Callbacks.LogError(OcErrLevInfo, Drive, NULL);

        //
        // If Batch mode log the error and ignore
        //
        if ( OcPage->OcManager->SetupData.OperationFlags & SETUPOP_BATCH ) {
            b = TRUE;
        } else {
            *caption = 0;
            LoadString(MyModuleHandle, IDS_SETUP, caption, sizeof(caption)/sizeof(TCHAR));
            sapiAssert(*caption);

            MessageBox(WizardDialogHandle,
                       Drive,
                       caption,
                       MB_ICONINFORMATION | MB_OK);

            b = FALSE;
        }

    } else {
        b = TRUE;
    }

    return (b);
}


BOOL
pOcPagePopulateListBox(
                      IN POCPAGE OcPage,
                      IN HWND    ListBox,
                      IN LONG    DesiredParent
                      )

/*++

Routine Description:

    This routine add one item to a listbox control for every subcomponent
    that has a given subcomponent as its parent. (In other words it populates
    the listbox for a specific level in the hierarchy.)

    This includes handling the small icons and selection state icons.

    The 0th element is selected.

Arguments:

    OcPage - supplies OC page context structure.

    List - supplies handle to list box control to be populated.

    DesiredParent - supplies string id of subcomponent that is the parent
        of the level we care about. -1 indicates the topmost level.

Return Value:

    Boolean value indicating whether population was successful.
    If FALSE, the caller can assume OOM.

--*/

{
    OPTIONAL_COMPONENT OptionalComponent;
    POPULATE_ENUM_PARAMS EnumParams;
    BOOL b;

    //
    // The string table enum callback does the real work.
    //
    EnumParams.OcPage = OcPage;
    EnumParams.ListBox = ListBox;
    EnumParams.DesiredParent = DesiredParent;

    b = pSetupStringTableEnum(
                       OcPage->OcManager->ComponentStringTable,
                       &OptionalComponent,
                       sizeof(OPTIONAL_COMPONENT),
                       (PSTRTAB_ENUM_ROUTINE)pOcPopulateListBoxStringTableCB,
                       (LPARAM)&EnumParams
                       );

    SendMessage(ListBox,LB_SETCURSEL,0,0);
    PostMessage(
               GetParent(ListBox),
               WM_COMMAND,
               MAKEWPARAM(OcPage->ControlsInfo->ListBox,LBN_SELCHANGE),
               (LPARAM)ListBox
               );
    return (b);
}


BOOL
pOcPopulateListBoxStringTableCB(
                               IN PVOID                 StringTable,
                               IN LONG                  StringId,
                               IN LPCTSTR               String,
                               IN POPTIONAL_COMPONENT   OptionalComponent,
                               IN UINT                  OptionalComponentSize,
                               IN PPOPULATE_ENUM_PARAMS Params
                               )

/*++

Routine Description:

    String table enumeration callback routine, used when populating
    the listbox with items for subcomponents that are relevent at
    a given level in the OC hierarchy.

    We check to see whether the parent of the optional component is
    the parent we care about before processing. If so, we add the item
    to the listbox.

Arguments:

    Standard string table enumeration callback routine arguments.

Return Value:

    Boolean value indicating whether enumeration should continue.

--*/

{
    int i;
    BOOL b;

    //
    // If the parent is not the desired parent, nothing to do.
    //
    if ((OptionalComponent->InfStringId == -1)
        || (OptionalComponent->ParentStringId != Params->DesiredParent)
        || (OptionalComponent->InternalFlags & OCFLAG_HIDE)) {
        return (TRUE);
    }

    //
    // Initialize the item structure that tells the listview control
    // what to do.
    //
    b = FALSE;
    i = (int)SendMessage(Params->ListBox,LB_ADDSTRING,0,(LPARAM)OptionalComponent->Description);
    if (i != -1) {
        b = (SendMessage(Params->ListBox,LB_SETITEMDATA,i,StringId) != LB_ERR);
    }

    return (b);
}


LONG
pOcGetTopLevelComponent(
                       IN POC_MANAGER OcManager,
                       IN LONG        StringId
                       )

/*++

Routine Description:

    Given a string id for an optional component subcomponent,
    locate the top-level component for the subcomponent.

    The top-level component is the subcomponent whose parent is -1.

Arguments:

    OcManager - supplies OC Manager context structure.

    StringId - supplies id for subcomponent whose top-level parent is desired.
        Note that StringId may itself be a top-level subcomponent.

Return Value:

    String ID of top-level subcomponent.

--*/

{
    OPTIONAL_COMPONENT Oc;

    pSetupStringTableGetExtraData(
                           OcManager->ComponentStringTable,
                           StringId,
                           &Oc,
                           sizeof(OPTIONAL_COMPONENT)
                           );

    // if the result is 0, then the component is
    // a top level component without an inf file

    if (!Oc.TopLevelStringId)
        return StringId;
    else
        return Oc.TopLevelStringId;
}


VOID
pOcGetMbAndMbTenths(
                   IN  LONGLONG Number,
                   OUT PUINT    MbCount,
                   OUT PUINT    MbTenthsCount
                   )

/*++

Routine Description:

    This routine figures out how many MB and how many tenths of a MB
    are in a number. These values are properly rounded (not truncated)
    and are based on 1MB = 1024*1024.

Arguments:

    Number - supplies number to be examined.

    MbCount - receives rounded number of MB units in Number.

    MbTenthsCount - receives rounded number of tenths of MB in Number.

Return Value:

    None. MbCount and MbTenthsCount filled are in.

--*/

{
    UINT ValueMB;
    UINT ValueMBTenths;
    UINT ValueMBHundredths;

#define _1MB    (1024*1024)

    //
    // Figure out how many whole 1MB units are in the number.
    //
    ValueMB = (UINT)(Number / _1MB);

    //
    // Figure out how many whole hundredths of 1MB units are in
    // the number. Do it in such a way as to not lose any accuracy.
    // ValueMBHundredths will be 0-99 and ValueMBTenths will be 0-9.
    //
    ValueMBHundredths = (UINT)(((Number % _1MB) * 100) / _1MB);
    ValueMBTenths = ValueMBHundredths / 10;

    //
    // If the one's place in the number of hundredths is >=5,
    // then round up the tenths. That might in turn cause is to round
    // up the the next whole # of MB.
    //
    if ((ValueMBHundredths % 10) >= 5) {
        if (++ValueMBTenths == 10) {
            ValueMBTenths = 0;
            ValueMB++;
        }
    }

    //
    // Done.
    //
    *MbCount = ValueMB;
    *MbTenthsCount = ValueMBTenths;
}


UINT
OcGetUnattendComponentSpec(
                          IN POC_MANAGER OcManager,
                          IN LPCTSTR     Component
                          )
{
    LPCTSTR p;
    LPCTSTR szOn = TEXT("ON");
    LPCTSTR szOff = TEXT("OFF");
    LPCTSTR szDefault = TEXT("DEFAULT");

    extern LPCTSTR szComponents;    // defined in ocmanage.c
    INFCONTEXT InfLine;

    UINT NewState = SubcompUseOcManagerDefault;

    if (SetupFindFirstLine(OcManager->UnattendedInf,szComponents,Component,&InfLine)) {
        //
        // Get State parameter from as the first field
        //
        if (p = pSetupGetField(&InfLine,1)) {
            //
            // Found Something now Decode it
            //
            if (!lstrcmpi(p,szOn)) {
                NewState = SubcompOn;
            } else if (!lstrcmpi(p,szOff)) {
                NewState = SubcompOff;
            } else if (!lstrcmpi(p,szDefault)) {
                NewState = SubcompUseOcManagerDefault;
            } else {
                WRN((TEXT("OcGetUnattendComponentSpec: Unknown Component State(%s)\n"),p));
            }
        }
    }

    return NewState;
}

BOOL
pOcClearStateChange(
                   IN PVOID               StringTable,
                   IN LONG                StringId,
                   IN LPCTSTR             String,
                   IN POPTIONAL_COMPONENT Oc,
                   IN UINT                OcSize,
                   IN LPARAM              lParam
                   )
{
    POCPAGE OcPage = (POCPAGE) lParam;
    int i;

    UNREFERENCED_PARAMETER(StringTable);
    UNREFERENCED_PARAMETER(OcSize);

    //
    // clear the State change flag
    //
    Oc->InternalFlags &= ~OCFLAG_STATECHANGE;

    pSetupStringTableSetExtraData(
                           OcPage->OcManager->ComponentStringTable,
                           StringId,
                           Oc,
                           sizeof(OPTIONAL_COMPONENT)
                           );

    return TRUE;

}

VOID
pOcSetStates(
            IN OUT POCPAGE OcPage
            )

/*++

Routine Description:

    Set current states for all components.

    If all components were initially off (indicating that this is a
    first-time install) then this routine initializes the current states
    of each leaf component based on the mode bits gathered from the
    per-component infs.

    Otherwise (not a first-time install) query the dll if any
    to determine the current state.

    No confirmations are sent to component dlls as subcomponents are
    set to the selected state, but we do send the calcdiskspace
    notifications.

Arguments:

    OcPage - supplies current oc context.

Return Value:

    None.

--*/

{
    OPTIONAL_COMPONENT Oc;
    UINT i;
    UINT tli;
    UINT StringID;

    //
    // Process each top level parent item in the tree
    //
    for ( tli = 0; tli < OcPage->OcManager->TopLevelOcCount; tli++)

        for (i=0; i<OcPage->OcManager->TopLevelParentOcCount; i++) {

            pSetupStringTableGetExtraData(
                                   OcPage->OcManager->ComponentStringTable,
                                   OcPage->OcManager->TopLevelParentOcStringIds[i],
                                   &Oc,
                                   sizeof(OPTIONAL_COMPONENT)
                                   );

            //
            // Traverse the list in the order defined inf fil
            //
            if ( OcPage->OcManager->TopLevelOcStringIds[tli]
                 == pOcGetTopLevelComponent(OcPage->OcManager,OcPage->OcManager->TopLevelParentOcStringIds[i])) {
                //
                // Call each top level item, Each top level item then will call it's
                // suboridiates and Needs and or Needed by components
                //
                pOcSetStatesStringWorker(OcPage->OcManager->TopLevelParentOcStringIds[i], SubcompUseOcManagerDefault, OcPage );
            }
        }

    //
    // Clear the OCFLAG_STATECHANGE Flag
    //
    pSetupStringTableEnum(
                   OcPage->OcManager->ComponentStringTable,
                   &Oc,
                   sizeof(OPTIONAL_COMPONENT),
                   pOcSetStatesStringCB2,
                   (LPARAM)OcPage
                   );
}


BOOL
pOcSetStatesStringWorker(
                        IN LONG         StringId,
                        IN UINT         OverRideState,
                        IN POCPAGE      OcPage
                        )
{
    OPTIONAL_COMPONENT Oc, Subcomponent;
    LPCTSTR String;
    SubComponentState s;
    UINT NewState;
    UINT l;


    pSetupStringTableGetExtraData(
                           OcPage->OcManager->ComponentStringTable,
                           StringId,
                           &Oc,
                           sizeof(OPTIONAL_COMPONENT)
                           );


    //
    // Deal only with leaf components.
    //
    if (Oc.FirstChildStringId != -1) {

        //
        // Now turn on all subcomponents.
        //
        for (l = Oc.FirstChildStringId; l != -1; l = Oc.NextSiblingStringId) {

            pOcSetStatesStringWorker( l, OverRideState, OcPage );
            //
            // Get the next Depenend in the list
            //
            pSetupStringTableGetExtraData(
                                   OcPage->OcManager->ComponentStringTable,
                                   l,
                                   &Oc,
                                   sizeof(OPTIONAL_COMPONENT)
                                   );
        }
        pOcUpdateParentSelectionStates(OcPage->OcManager,NULL,StringId);


    } else {
        //
        // Don't process the same node twice
        //
        if (  Oc.InternalFlags & OCFLAG_STATECHANGE ) {
            return TRUE;
        }

        String =  pSetupStringTableStringFromId(OcPage->OcManager->ComponentStringTable,StringId);
        //
        // Not initial install case. Call out to component dll to find out
        // whether state needs to be set.
        //

        s = OcInterfaceQueryState(
                                 OcPage->OcManager,
                                 pOcGetTopLevelComponent(OcPage->OcManager,StringId),String, OCSELSTATETYPE_CURRENT);

        if ( (OcPage->OcManager->SetupMode & SETUPMODE_PRIVATE_MASK) == SETUPMODE_REMOVEALL )
        {
            // If Remove all Override all install states and mark the compoent to be
            // removed
            NewState    =    SELSTATE_NO;

        } else {
            //
            // If needs or Needby relationtionships are driving this path
            // OverRideState May be something other then Default
            //
            if ( OverRideState != SubcompUseOcManagerDefault ) {
                s = OverRideState;
            }
            //
            // If the component returned Default and we are in Batch Mode
            // Get the the Spec from the Unattended file
            //
            if ( s == SubcompUseOcManagerDefault
                 && OcPage->OcManager->SetupData.OperationFlags & SETUPOP_BATCH  ){
                s = OcGetUnattendComponentSpec(OcPage->OcManager, String);
            }

            if (s == SubcompUseOcManagerDefault) {
                if (Oc.InternalFlags & (OCFLAG_ANYORIGINALLYON | OCFLAG_ANYORIGINALLYOFF)) {

                    NewState = Oc.OriginalSelectionState;

                } else {

                    if ((1 << (OcPage->OcManager->SetupMode & SETUPMODE_STANDARD_MASK)) & Oc.ModeBits) {
                        //
                        // Allow Modes= lines to act an override condition if it ON
                        //
                        NewState = SELSTATE_YES;
                        s = SubcompOn;
                    } else {
                        NewState = SELSTATE_NO;
                    }
                }
            } else {
                NewState = (s == SubcompOn ? SELSTATE_YES: SELSTATE_NO);
            }
        }

        DBGOUT((
               TEXT("SubComp=%s, Original=%d, Current=%d, NewState=%s\n"),
               String,
               Oc.OriginalSelectionState,
               s,
               (NewState == SELSTATE_YES) ? TEXT("ON") : TEXT("OFF")
               ));

        //
        // Save the current state of the component
        //
        Oc.SelectionState = NewState;
        Oc.InternalFlags |= OCFLAG_STATECHANGE;

        if ( NewState == SELSTATE_YES ) {
            //
            // Make a pass over the Needs
            //
            for (l=0; l<Oc.NeedsCount; l++) {

                if (!pOcSetNeededComponentState( Oc.NeedsStringIds[l], OverRideState, OcPage ))
                    return TRUE;

                pSetupStringTableGetExtraData(
                                       OcPage->OcManager->ComponentStringTable,
                                       Oc.NeedsStringIds[l],
                                       &Subcomponent,
                                       sizeof(OPTIONAL_COMPONENT)
                                       );
            }
        }

        pSetupStringTableSetExtraData(
                               OcPage->OcManager->ComponentStringTable,
                               StringId,
                               &Oc,
                               sizeof(OPTIONAL_COMPONENT)
                               );

        if ( NewState == SELSTATE_YES ) {
            //
            // Make a pass over the Needs
            //
            for (l=0; l<Oc.NeedsCount; l++) {

                pOcSetStatesStringWorker( Oc.NeedsStringIds[l], s, OcPage );

                pSetupStringTableGetExtraData(
                                       OcPage->OcManager->ComponentStringTable,
                                       Oc.NeedsStringIds[l],
                                       &Subcomponent,
                                       sizeof(OPTIONAL_COMPONENT)
                                       );
            }
        } else {
            //
            // Make a pass over the NeedsBy - turning off components
            //
            for (l=0; l<Oc.NeededByCount; l++) {
                pOcSetStatesStringWorker( Oc.NeededByStringIds[l], s, OcPage );

                pSetupStringTableGetExtraData(
                                       OcPage->OcManager->ComponentStringTable,
                                       Oc.NeededByStringIds[l],
                                       &Subcomponent,
                                       sizeof(OPTIONAL_COMPONENT)
                                       );
            }
        }
    }

    pOcUpdateParentSelectionStates(OcPage->OcManager,NULL,StringId);

    return TRUE;
}


BOOL
pOcSetNeededComponentState(
                          IN LONG         StringId,
                          IN UINT         OverRideState,
                          IN POCPAGE      OcPage
                          )
{
    OPTIONAL_COMPONENT Oc, Subcomponent;
    LPCTSTR String;
    SubComponentState s;
    UINT NewState;
    UINT l;
    BOOL b;

    // first find any components this one needs

    pSetupStringTableGetExtraData(
                           OcPage->OcManager->ComponentStringTable,
                           StringId,
                           &Oc,
                           sizeof(OPTIONAL_COMPONENT)
                           );

    for (l=0; l<Oc.NeedsCount; l++) {

        if (!pOcSetNeededComponentState( Oc.NeedsStringIds[l], OverRideState, OcPage ))
            return TRUE;

        pSetupStringTableGetExtraData(
                               OcPage->OcManager->ComponentStringTable,
                               Oc.NeedsStringIds[l],
                               &Subcomponent,
                               sizeof(OPTIONAL_COMPONENT)
                               );
    }

    // now handle this one

    pSetupStringTableGetExtraData(
                           OcPage->OcManager->ComponentStringTable,
                           StringId,
                           &Oc,
                           sizeof(OPTIONAL_COMPONENT)
                           );

    String =  pSetupStringTableStringFromId(OcPage->OcManager->ComponentStringTable,StringId);

    b = OcInterfaceQueryChangeSelState(
                                      OcPage->OcManager,
                                      pOcGetTopLevelComponent(OcPage->OcManager,StringId),
                                      String,
                                      TRUE,
                                      0
                                      );

    if (b) {
        NewState = SELSTATE_YES;
        s = SubcompOn;
    } else {
        NewState = SELSTATE_NO;
        s = SubcompOff;
    }

    DBGOUT(( TEXT("SubComp=%s, Original=%d, Current=%d, NewState=%s\n"),
             String,
             Oc.OriginalSelectionState,
             s,
             (NewState == SELSTATE_YES) ? TEXT("ON") : TEXT("OFF")
           ));


    //
    // Save the current state of the component
    //
    Oc.SelectionState = NewState;
    Oc.InternalFlags |= OCFLAG_STATECHANGE;

    pSetupStringTableSetExtraData(
                           OcPage->OcManager->ComponentStringTable,
                           StringId,
                           &Oc,
                           sizeof(OPTIONAL_COMPONENT)
                           );

    pOcUpdateParentSelectionStates(OcPage->OcManager,NULL,StringId);

    return b;
}


BOOL
pOcSetStatesStringCB2(
                     IN PVOID               StringTable,
                     IN LONG                StringId,
                     IN LPCTSTR             String,
                     IN POPTIONAL_COMPONENT Oc,
                     IN UINT                OcSize,
                     IN LPARAM              lParam
                     )
{
    POCPAGE OcPage;
    int i;

    UNREFERENCED_PARAMETER(StringTable);
    UNREFERENCED_PARAMETER(OcSize);

    OcPage = (POCPAGE)lParam;
    //
    // clear the State change flag left over from
    // the pOcSetStatesStringWorker
    //
    Oc->InternalFlags &= ~OCFLAG_STATECHANGE;
    pSetupStringTableSetExtraData(
                           OcPage->OcManager->ComponentStringTable,
                           StringId,
                           Oc,
                           sizeof(OPTIONAL_COMPONENT)
                           );

    //
    // Deal only with leaf components.
    //
    if (Oc->FirstChildStringId != -1) {
        return (TRUE);
    }

    i = 0;

    if (OcPage->OcManager->InternalFlags & OCMFLAG_ANYORIGINALLYON) {
        //
        // Not initial install case. Deal with disk space based on
        // original state.
        //
        if (Oc->OriginalSelectionState == SELSTATE_YES) {
            if (Oc->SelectionState == SELSTATE_NO) {
                //
                // Turning off what was previously on
                //
                i = 1;
            }
        } else {
            if (Oc->SelectionState == SELSTATE_YES) {
                //
                // Turning on what was previous off
                //
                i = 2;
            }
        }

    } else {
        //
        // Initial install case. If a component is on, do its disk space calc.
        // If a component is off, we assume it's not already there and so
        // we do nothing relating to its disk space requirements.
        //
        if (Oc->SelectionState == SELSTATE_YES) {
            i = 2;
        }
    }

    if (i) {
        OcInterfaceCalcDiskSpace(
                                OcPage->OcManager,
                                pOcGetTopLevelComponent(OcPage->OcManager,StringId),
                                String,
                                OcPage->DiskSpaceList,
                                i-1
                                );
    }

    return (TRUE);
}


BOOL
pOcDoesAnyoneWantToSkipPage(
                           IN OUT POC_MANAGER   OcManager,
                           IN     OcManagerPage WhichPage
                           )
{
    UINT u;

    for (u=0; u<OcManager->TopLevelOcCount; u++) {

        OPTIONAL_COMPONENT Oc;

        pSetupStringTableGetExtraData(
            OcManager->ComponentStringTable,
            OcManager->TopLevelOcStringIds[u],
            &Oc,
            sizeof(OPTIONAL_COMPONENT)
            );

        if ((Oc.InternalFlags & OCFLAG_NOQUERYSKIPPAGES) == 0) {

            if (OcInterfaceQuerySkipPage(OcManager,OcManager->TopLevelOcStringIds[u],WhichPage)) {
                return (TRUE);
            }
        }
    }

    return (FALSE);
}

UINT
GetComponentState(
                 IN POCPAGE OcPage,
                 IN LONG    StringId
                 )
{
    LONG id;
    UINT rc;
    UINT state;
    SubComponentState s;
    OPTIONAL_COMPONENT Oc;

    pSetupStringTableGetExtraData(
                           OcPage->OcManager->ComponentStringTable,
                           StringId,
                           &Oc,
                           sizeof(OPTIONAL_COMPONENT)
                           );

    if (Oc.FirstChildStringId == -1)
        return Oc.SelectionState;

    // We have a parent; do all the children

    rc = SELSTATE_INIT;
    for (id = Oc.FirstChildStringId; id != -1; id = Oc.NextSiblingStringId) {

        state = GetComponentState(OcPage, id);

        if (state == SELSTATE_PARTIAL)
            return state;

        if (rc == SELSTATE_INIT)
            rc = state;

        if (rc != state)
            return SELSTATE_PARTIAL;

        pSetupStringTableGetExtraData(
                               OcPage->OcManager->ComponentStringTable,
                               id,
                               &Oc,
                               sizeof(OPTIONAL_COMPONENT)
                               );
    }

    return rc;
}




#ifdef _OC_DBG

VOID
pOcPrintStatesWorker(
                    IN LPCTSTR Offset,
                    IN POCPAGE OcPage,
                    IN LONG    StringId
                    )
{
    SubComponentState s;
    OPTIONAL_COMPONENT Oc;

    pSetupStringTableGetExtraData(
                           OcPage->OcManager->ComponentStringTable,
                           StringId,
                           &Oc,
                           sizeof(OPTIONAL_COMPONENT)
                           );

    DBGOUT(( TEXT("%32s\n"),
             pSetupStringTableStringFromId(OcPage->OcManager->ComponentStringTable,StringId)
           ));

    //
    // Deal only with leaf components.
    //
    if (Oc.FirstChildStringId == -1) {

        DBGOUT((
               TEXT("  Orignial(%s) Current(%s) ANYORIGINALLYON (%s) Mode (%d)\n"),
               (Oc.OriginalSelectionState  == SELSTATE_YES ? TEXT("Yes") : TEXT("No")),
               (Oc.SelectionState          == SELSTATE_YES ? TEXT("Yes") : TEXT("No")),
               (Oc.InternalFlags & OCFLAG_ANYORIGINALLYON) ? TEXT("TRUE") : TEXT("FALSE"),
               SETUPMODE_STANDARD_MASK & Oc.ModeBits
               ));

    } else {
        //
        // We have a parent; do all the children
        //
        LONG Id;

        for (Id = Oc.FirstChildStringId; Id != -1; Id = Oc.NextSiblingStringId) {

            pOcPrintStatesWorker(
                                Offset,
                                OcPage,
                                Id
                                );

            pSetupStringTableGetExtraData(
                                   OcPage->OcManager->ComponentStringTable,
                                   Id,
                                   &Oc,
                                   sizeof(OPTIONAL_COMPONENT)
                                   );
        }
    }
}


VOID
pOcPrintStates(
              IN POCPAGE OcPage
              )
{
    OPTIONAL_COMPONENT Oc;
    DWORD i;

    for (i=0; i<OcPage->OcManager->TopLevelOcCount; i++) {

        pOcPrintStatesWorker(
                            TEXT(" "),
                            OcPage,
                            OcPage->OcManager->TopLevelOcStringIds[i]
                            );
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ocmanage\common\ocwizard.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    ocwizard.c

Abstract:

    Routines to query wizard pages from OC DLLs and manage the results.

    No wizard is actually displayed by this routine -- that is up to
    whoever links to the OC Manager common library.

Author:

    Ted Miller (tedm) 17-Sep-1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


UINT
OcGetWizardPages(
    IN  PVOID                OcManagerContext,
    OUT PSETUP_REQUEST_PAGES Pages[WizPagesTypeMax]
    )

/*++

Routine Description:

    Request wizard pages from OC DLL's, according to ordering and omission
    rules specified in the master OC inf.

    Pages are returned in the form of wizard page handles in SETUP_REQUEST_PAGES
    data structures.

Arguments:

    OcManagerContext - supplies OC Manager context structure, returned by
        OcInitialize().

    Pages - points to a block of memory that can hold WizPagesTypeMax pointers to
        SETUP_REQUEST_PAGES structures. On successful completion, that array is
        filled in with such pointers.

Return Value:

    Win32 error code indicating outcome.

--*/

{
    WizardPagesType PageType;
    UINT n;
    LONG Id;
    UINT e,ErrorCode;
    POC_MANAGER OcManager;
    PSETUP_REQUEST_PAGES p,pages;
    OPTIONAL_COMPONENT Component;

    //
    // The context actually points at the OC_MANAGER structure.
    //
    OcManager = OcManagerContext;

    //
    // The ordering arrays for each wizard page type are
    // stored away for us in the OC_MANAGER data structure.
    //
    ErrorCode = NO_ERROR;
    for(PageType=0; PageType<WizPagesTypeMax; PageType++) {
        //
        // Allocate an empty list of pages for this page type.
        //
        Pages[PageType] = pSetupMalloc(offsetof(SETUP_REQUEST_PAGES,Pages));
        if(Pages[PageType]) {

            Pages[PageType]->MaxPages = 0;

            for(n=0;
                   (n < OcManager->TopLevelOcCount)
                && ((Id = OcManager->WizardPagesOrder[PageType][n]) != -1);
                n++)
            {

                //
                // Call the component and ask for its pages of the current type.
                // If this succeeds, merge the pages of this type from the
                // component into the master list for this component.
                //

                pSetupStringTableGetExtraData(
                        OcManager->ComponentStringTable,
                        Id,
                        &Component,
                        sizeof(OPTIONAL_COMPONENT)
                        );

                if ((Component.InternalFlags & OCFLAG_NOWIZARDPAGES) == 0) {

                    e = OcInterfaceRequestPages(OcManager,Id,PageType,&pages);
                    if(e == NO_ERROR) {

                        p = pSetupRealloc(
                                Pages[PageType],
                                  offsetof(SETUP_REQUEST_PAGES,Pages)
                                + ((Pages[PageType]->MaxPages + pages->MaxPages) * sizeof(HPROPSHEETPAGE))
                                );

                        if(p) {
                            Pages[PageType] = p;

                            CopyMemory(
                                &p->Pages[p->MaxPages],
                                pages->Pages,
                                pages->MaxPages * sizeof(HPROPSHEETPAGE)
                                );

                            Pages[PageType]->MaxPages += pages->MaxPages;

                            pSetupFree(pages);

                        } else {
                            e = ERROR_NOT_ENOUGH_MEMORY;
                        }
                    }
                } else {
                    e = NO_ERROR;
                }

                if (e == ERROR_CALL_COMPONENT) {
                    continue;   // could be a dead component, just go on
                }

                if((e != NO_ERROR) && (ErrorCode == NO_ERROR)) {
                    ErrorCode = e;
                }
            }
        } else {
            if(ErrorCode == NO_ERROR) {
                ErrorCode = ERROR_NOT_ENOUGH_MEMORY;
            }
        }
    }

    // set flag if there are no pages before the oc page

    if (OcManager->SetupData.OperationFlags & SETUPOP_STANDALONE) {
        if (!Pages[WizPagesWelcome]->MaxPages
                && !Pages[WizPagesMode]->MaxPages) {
            OcManager->InternalFlags |= OCMFLAG_NOPREOCPAGES;
        }
    }

    return(ErrorCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ocmanage\common\ocsetup.c ===
#include "precomp.h"
#pragma hdrstop
#include <stdio.h>


typedef struct _SETUP_PAGE {
    POC_MANAGER OcManager;
    SETUP_PAGE_CONTROLS ControlsInfo;
    HSPFILEQ FileQueue;
    PVOID QueueContext;
    UINT StepCount;

    BOOL ForceExternalProgressIndicator;

    PUINT ComponentTickCounts;
    PUINT ComponentMaxTickCounts;
    LONG CurrentTopLevelComponentIndex;

    BOOL AllowCancel;

    HWND hdlg;

    BOOL UserClickedCancel;

    DWORD RefCount;

} SETUP_PAGE, *PSETUP_PAGE;

#define WMX_SETUP           (WM_APP+4537)
#define WMX_TICK            (WM_APP+4538)

#define OCSETUPSTATE_INIT       0
#define OCSETUPSTATE_QUEUE      1
#define OCSETUPSTATE_GETSTEP    2
#define OCSETUPSTATE_DOIT       3
#define OCSETUPSTATE_COPYDONE   4
#define OCSETUPSTATE_DONE       100
#define OCSETUPSTATE_COPYABORT  101


typedef struct _GEN_THREAD_PARAMS {
    HWND hdlg;
    PSETUP_PAGE SetupPage;
    BOOL Async;
} GEN_THREAD_PARAMS, *PGEN_THREAD_PARAMS;

TCHAR g_LastFileCopied[MAX_PATH];

#ifdef UNICODE
HANDLE hSfp = NULL;
#endif

HANDLE WorkerThreadHandle = NULL;

INT_PTR
SetupPageDialogProc(
                   IN HWND   hdlg,
                   IN UINT   msg,
                   IN WPARAM wParam,
                   IN LPARAM lParam
                   );

BOOL
pOcSetupInitialize(
                  IN OUT PSETUP_PAGE SetupPage,
                  IN     HWND        hdlg
                  );

VOID
pOcSetupStartWorkerThread(
                         IN OUT PSETUP_PAGE            SetupPage,
                         IN     HWND                   hdlg,
                         IN     LPTHREAD_START_ROUTINE ThreadRoutine
                         );

DWORD
pOcSetupQueue(
             IN PGEN_THREAD_PARAMS Params
             );

UINT
pOcSetupQueueWorker(
                   IN PSETUP_PAGE SetupPage,
                   IN LONG        StringId,
                   IN LONG        TopLevelStringId
                   );

DWORD
pOcSetupGetStepCount(
                    IN PGEN_THREAD_PARAMS Params
                    );

UINT
pOcSetupGetStepCountWorker(
                          IN PSETUP_PAGE SetupPage,
                          IN LONG        StringId,
                          IN LONG        TopLevelStringId
                          );

DWORD
pOcSetupDoIt(
            IN PGEN_THREAD_PARAMS Params
            );

VOID
pOcPreOrPostCommitProcessing(
                            IN OUT PSETUP_PAGE SetupPage,
                            IN     BOOL        PreCommit
                            );

VOID
pOcTopLevelPreOrPostCommitProcessing(
                                    IN PSETUP_PAGE SetupPage,
                                    IN BOOL        PreCommit
                                    );

VOID
pOcSetupDoItWorker(
                  IN PSETUP_PAGE SetupPage,
                  IN LONG        StringId,
                  IN LONG        TopLevelStringId,
                  IN BOOL        PreCommit
                  );

BOOL
pOcMarkUnprocessedStringCB(
                          IN PVOID               StringTable,
                          IN LONG                StringId,
                          IN PCTSTR              String,
                          IN POPTIONAL_COMPONENT Oc,
                          IN UINT                OcSize,
                          IN LPARAM              Unused
                          );

VOID
_pOcExternalProgressIndicator(
                             IN PSETUP_PAGE SetupPage,
                             IN BOOL        ExternalIndicator,
                             IN HWND        hdlg
                             );


extern POC_MANAGER gLastOcManager;
WNDPROC OldProgressProc;

BOOL
NewProgessProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    switch (msg)
    {
        case PBM_DELTAPOS:
        case PBM_SETRANGE:
        case PBM_SETRANGE32:
        case PBM_STEPIT:
        case PBM_SETPOS:
        case PBM_SETSTEP:
            // If we have a callback, use it.
            if ((gLastOcManager) &&
                (gLastOcManager->Callbacks.BillboardProgressCallback))
            {
                gLastOcManager->Callbacks.BillboardProgressCallback(msg, wParam, lParam);
            }
            break;
    }
    return (BOOL)CallWindowProc(OldProgressProc,hdlg,msg,wParam,lParam);
}

HPROPSHEETPAGE
OcCreateSetupPage(
                 IN PVOID                OcManagerContext,
                 IN PSETUP_PAGE_CONTROLS ControlsInfo
                 )

/*++

Routine Description:

    This routine creates the wizard page used for progress and installation
    completion.

Arguments:

    OcManagerContext - supplies OC Manager context returned by OcInitialize.

    ControlsInfo - supplies information about the dialog template and
        control information.

Return Value:

    Handle to property sheet page, or NULL if error (such as out of memory).

--*/

{
    PROPSHEETPAGE Page;
    HPROPSHEETPAGE PageHandle;
    PSETUP_PAGE SetupPage;
    TCHAR buffer[256];
    POC_MANAGER OcManager = (POC_MANAGER)OcManagerContext;

    SetupPage = pSetupMalloc(sizeof(SETUP_PAGE));
    if (!SetupPage) {
        return (NULL);
    }
    ZeroMemory(SetupPage,sizeof(SETUP_PAGE));

    SetupPage->OcManager = OcManagerContext;
    SetupPage->ControlsInfo = *ControlsInfo;
    SetupPage->CurrentTopLevelComponentIndex = -1;
    SetupPage->ForceExternalProgressIndicator = ControlsInfo->ForceExternalProgressIndicator;
    SetupPage->AllowCancel = ControlsInfo->AllowCancel;
    InterlockedIncrement( &SetupPage->RefCount );

    SetupPage->ComponentTickCounts = pSetupMalloc(SetupPage->OcManager->TopLevelOcCount * sizeof(UINT));
    if (!SetupPage->ComponentTickCounts) {
        pSetupFree(SetupPage);
        return (NULL);
    }

    SetupPage->ComponentMaxTickCounts = pSetupMalloc(SetupPage->OcManager->TopLevelOcCount * sizeof(UINT));
    if (!SetupPage->ComponentMaxTickCounts) {
        pSetupFree(SetupPage->ComponentTickCounts);
        pSetupFree(SetupPage);
        return (NULL);
    }

    Page.dwSize = sizeof(PROPSHEETPAGE);
    Page.dwFlags = PSP_DEFAULT;
    Page.hInstance = ControlsInfo->TemplateModule;
    Page.pszTemplate = ControlsInfo->TemplateResource;
    Page.pfnDlgProc = SetupPageDialogProc;
    Page.lParam = (LPARAM)SetupPage;
    Page.pszHeaderTitle = NULL;
    Page.pszHeaderSubTitle = NULL;

    if (SetupPage->OcManager->SetupPageTitle[0]) {
        Page.dwFlags |= PSP_USETITLE;
        Page.pszTitle = SetupPage->OcManager->SetupPageTitle;
    }

    if (ControlsInfo->HeaderText) {
        if (LoadString(Page.hInstance,
                       ControlsInfo->HeaderText,
                       buffer,
                       sizeof(buffer) / sizeof(TCHAR)))
        {
            Page.dwFlags |= PSP_USEHEADERTITLE;
            Page.pszHeaderTitle = _tcsdup(buffer);
        }
    }

    if (ControlsInfo->SubheaderText) {
        if (LoadString(Page.hInstance,
                       ControlsInfo->SubheaderText,
                       buffer,
                       sizeof(buffer) / sizeof(TCHAR)))
        {
            Page.dwFlags |= PSP_USEHEADERSUBTITLE;
            Page.pszHeaderSubTitle = _tcsdup(buffer);
        }
    }

    PageHandle = CreatePropertySheetPage(&Page);
    if (!PageHandle) {
        pSetupFree(SetupPage->ComponentTickCounts);
        pSetupFree(SetupPage->ComponentMaxTickCounts);
        pSetupFree(SetupPage);
        if (Page.pszHeaderTitle) {
            free((LPTSTR)Page.pszHeaderTitle);
        }
        if (Page.pszHeaderSubTitle) {
            free((LPTSTR)Page.pszHeaderSubTitle);
        }
    } else {
        OcManager->OcSetupPage = (PVOID) SetupPage;

    }



    return (PageHandle);
}

VOID
pOcFreeOcSetupPage(
    IN PVOID pSetupPage
    )
/*++

Routine Description:

    This routine frees the setup page when it's not needed anymore.
    The routine uses a ref-count, and the page is only freed when the
    refcount drops to zero.

Arguments:

    SetupPage - pointer to structure to be freed


Return Value:

    None.

--*/
{
    PSETUP_PAGE SetupPage = (PSETUP_PAGE)pSetupPage;

    sapiAssert( SetupPage != NULL );

//    TRACE(( TEXT("pOcFreeOcSetupPage: Refcount = %d\n"), SetupPage->RefCount ));

    if (!InterlockedDecrement( &SetupPage->RefCount )) {

//        TRACE(( TEXT("pOcFreeOcSetupPage: Refcount = 0, freeing SetupPage\n") ));

        if (SetupPage->QueueContext) {
            SetupTermDefaultQueueCallback(SetupPage->QueueContext);
        }
        if (SetupPage->FileQueue) {
            SetupCloseFileQueue(SetupPage->FileQueue);
        }

        pSetupFree(SetupPage->ComponentTickCounts);
        pSetupFree(SetupPage->ComponentMaxTickCounts);
        pSetupFree(SetupPage);
    }



    return;
}


BOOL
pOcDisableCancel(
    IN HWND hdlg
    )
/*++

Routine Description:

    This routine disables cancelling of ocm setup.

Arguments:

    hdlg - window handle to the ocm dialog


Return Value:

    TRUE if we succeed, else FALSE

--*/
{
    HMENU hMenu;

    //
    // hide the cancel button
    //
    EnableWindow(GetDlgItem(GetParent(hdlg),IDCANCEL),FALSE);
    ShowWindow(GetDlgItem(GetParent(hdlg),IDCANCEL),SW_HIDE);

    if(hMenu = GetSystemMenu(GetParent(hdlg),FALSE)) {
        EnableMenuItem(hMenu,SC_CLOSE,MF_BYCOMMAND|MF_GRAYED);
    }

    return TRUE;


}


VOID
PumpMessageQueue(
    VOID
    )
{
    MSG msg;

    while(PeekMessage(&msg,NULL,0,0,PM_REMOVE)) {
        DispatchMessage(&msg);
    }

}


INT_PTR
SetupPageDialogProc(
                   IN HWND   hdlg,
                   IN UINT   msg,
                   IN WPARAM wParam,
                   IN LPARAM lParam
                   )
{
    BOOL b;
    NMHDR *NotifyParams;
    PSETUP_PAGE SetupPage;
    DWORD Timeout;
    DWORD WaitProcStatus;
    BOOL KeepWaiting = TRUE;

    //
    // Get pointer to SetupPage data structure. If we haven't processed
    // WM_INITDIALOG yet, then this will be NULL, but it's still pretty
    // convenient to do this here once instead of all over the place below.
    //
    SetupPage = (PSETUP_PAGE)GetWindowLongPtr(hdlg,DWLP_USER);
    b = FALSE;

    switch (msg) {

        case WM_INITDIALOG:
            //
            // Get the pointer to the Setup Page context structure and stick it
            // in a window long.
            //
            SetWindowLongPtr(hdlg,DWLP_USER,((PROPSHEETPAGE *)lParam)->lParam);
            b = TRUE;
            //
            // eat any extra press button messages
            // this is necessary because netsetup is broken
            // it is posting an extra PSM_PRESSBUTTON message
            // to the wizard.
            //
            {
                MSG msg;
                HWND hwnd=GetParent(hdlg);
                while (PeekMessage(&msg,hwnd,PSM_PRESSBUTTON,PSM_PRESSBUTTON,PM_REMOVE)){}
            }

            break;

        case WM_SYSCOMMAND:
            if (!SetupPage->AllowCancel && wParam == SC_CLOSE) {
                return TRUE;
            }

            b = FALSE;
            break;
        case WM_DESTROY:

            PumpMessageQueue();

            if (WorkerThreadHandle) {

                BOOL Done = FALSE;

                do{

                    switch (MsgWaitForMultipleObjects( 1, &WorkerThreadHandle, FALSE, 60*1000*20, QS_ALLINPUT)){
                    
                    case WAIT_OBJECT_0+1:
                        //
                        // Messages in the queue.
                        //
                        PumpMessageQueue();
                        break;
                    
                    case WAIT_TIMEOUT:
                    case WAIT_OBJECT_0:
                    default:
                        Done = TRUE;
                        break;
                    }

                }while( !Done );

                CloseHandle( WorkerThreadHandle );
            }

            if (SetupPage) {

                pOcFreeOcSetupPage( SetupPage );

            }

            SetWindowLongPtr(hdlg,DWLP_USER,(LPARAM)NULL);

            break;

        case WM_NOTIFY:

            NotifyParams = (NMHDR *)lParam;
            switch (NotifyParams->code) {

                case PSN_SETACTIVE:
#ifdef UNICODE
                    if (SetupPage->OcManager->Callbacks.SetupPerfData)
                        SetupPage->OcManager->Callbacks.SetupPerfData(TEXT(__FILE__),__LINE__,L"BEGIN_SECTION",L"OCSetup");
#endif
                    // activate the cancel button accordingly

                    if (SetupPage->AllowCancel) {
                        ShowWindow(GetDlgItem(GetParent(hdlg),IDCANCEL),SW_SHOW);
                        EnableWindow(GetDlgItem(GetParent(hdlg),IDCANCEL),TRUE);
                    } else {
                        ShowWindow(GetDlgItem(GetParent(hdlg),IDCANCEL),SW_HIDE);
                        EnableWindow(GetDlgItem(GetParent(hdlg),IDCANCEL),FALSE);
                    }

                    if (SetupPage->OcManager->Callbacks.ShowHideWizardPage)
                    {
                        // If we have a callback, hide the wizard.
                        SetupPage->OcManager->Callbacks.ShowHideWizardPage(FALSE);
                    }
                    OldProgressProc = (WNDPROC)SetWindowLongPtr(GetDlgItem(hdlg,SetupPage->ControlsInfo.ProgressBar),
                                                                GWLP_WNDPROC,
                                                                (LONG_PTR)NewProgessProc);

                    //
                    // Post a message that causes us to start the installation process.
                    //
                    PostMessage(hdlg,WMX_SETUP,OCSETUPSTATE_INIT,0);

                    //
                    // Accept activation.
                    //
                    SetWindowLongPtr(hdlg,DWLP_MSGRESULT,0);
                    b = TRUE;
                    break;

                case PSN_KILLACTIVE:
                    //
                    // Restore the wizard's cancel button if we removed it earlier
                    //
                    if (!SetupPage->AllowCancel) {
                        ShowWindow(GetDlgItem(GetParent(hdlg),IDCANCEL),SW_SHOW);
                        EnableWindow(GetDlgItem(GetParent(hdlg),IDCANCEL),TRUE);
                    }

                    //
                    // Accept deactivation.
                    //
                    SetWindowLongPtr(hdlg,DWLP_MSGRESULT,0);
                    b = TRUE;
                    break;

                case PSN_QUERYCANCEL:

                    if (!SetupPage->AllowCancel) {
                        SetWindowLongPtr(hdlg,DWLP_MSGRESULT,TRUE);
                        return(TRUE);
                    }
                    if ( (SetupPage->OcManager->InternalFlags & OCMFLAG_FILEABORT )
                         || (OcHelperConfirmCancel(hdlg) )){
                        b = TRUE;

                        SetupPage->OcManager->InternalFlags |= OCMFLAG_USERCANCELED;
                        SetupPage->UserClickedCancel = TRUE;

                    }

                    SetWindowLongPtr(hdlg,DWLP_MSGRESULT,!b);
                    b = TRUE;
                    break;
            }
            break;

        case WMX_SETUP:

            switch (wParam) {

                case OCSETUPSTATE_INIT:
                    //
                    // Initialize.
                    //
                    if (SetupPage->ForceExternalProgressIndicator) {
                        _pOcExternalProgressIndicator(SetupPage,TRUE,hdlg);
                    }

                    PropSheet_SetWizButtons(GetParent(hdlg),0);

                    //
                    // If this a remove all, disable the cancel button early
                    //
                    if ((SetupPage->OcManager->SetupMode & SETUPMODE_PRIVATE_MASK) == SETUPMODE_REMOVEALL) {
                        if (!SetupPage->AllowCancel) {
                            EnableWindow(GetDlgItem(GetParent(hdlg),IDCANCEL),FALSE);
                            ShowWindow(GetDlgItem(GetParent(hdlg),IDCANCEL),SW_HIDE);
                        }
                    }

                    if (pOcSetupInitialize(SetupPage,hdlg)) {
                        PostMessage(hdlg,WMX_SETUP,OCSETUPSTATE_QUEUE,0);
                    } else {
                        PostMessage(hdlg,WMX_SETUP,OCSETUPSTATE_COPYABORT,0);
                    }
                    break;

                case OCSETUPSTATE_QUEUE:
                    //
                    // Queue files for installation.
                    //
                    pOcSetupStartWorkerThread(SetupPage,hdlg,pOcSetupQueue);
                    break;

                case OCSETUPSTATE_GETSTEP:
                    //
                    // Figure out step counts.
                    //
                    pOcSetupStartWorkerThread(SetupPage,hdlg,pOcSetupGetStepCount);
                    break;

                case OCSETUPSTATE_DOIT:

                    //
                    // Quick init of the gas guage here, because the file queue could be
                    // empty, in which case we never get WMX_TICK with wParam=0.
                    //
                    SendDlgItemMessage(
                                      hdlg,
                                      SetupPage->ControlsInfo.ProgressBar,
                                      PBM_SETRANGE,
                                      0,
                                      MAKELPARAM(0,SetupPage->StepCount)
                                      );
                    SendDlgItemMessage(
                                      hdlg,
                                      SetupPage->ControlsInfo.ProgressBar,
                                      PBM_SETPOS,
                                      0,
                                      0
                                      );

                    SetCursor(LoadCursor(NULL,IDC_ARROW));

                    //
                    // Commit the file queue and let the OCs install themselves.
                    //
                    pOcSetupStartWorkerThread(SetupPage,hdlg,pOcSetupDoIt);
                    break;


                    //
                    // Unrecoverable error in copyfile phase, abort the setup
                    //
                case OCSETUPSTATE_COPYABORT:

                    SetupPage->OcManager->InternalFlags |= OCMFLAG_FILEABORT;

                    if (SetupPage->AllowCancel
                        && SetupPage->OcManager->SetupData.OperationFlags & SETUPOP_STANDALONE) {
                        PropSheet_PressButton(GetParent(hdlg),PSBTN_CANCEL);
                    } else {
                        PropSheet_PressButton(GetParent(hdlg),PSBTN_NEXT);
                    }

                    break;


                case OCSETUPSTATE_COPYDONE:
                    //
                    // Get rid of the wizard's cancel button
                    //

                    //
                    // AndrewR -- we've already committed the file queue
                    // at this point, so we should not allow the user to cancel
                    // (since:
                    //  a) in an uninstall scenario the file state and
                    // configuration state will be out of sync
                    //  b) we don't call all of the OC components to let them know
                    // about the cancel event, and we don't want only some of the
                    // components to get a complete installation callback
                    //
                    //if(!SetupPage->AllowCancel) {
                    SetupPage->AllowCancel = FALSE;
                    pOcDisableCancel(hdlg);

                    // }
                    break;

                case OCSETUPSTATE_DONE:
                    //
                    // Done. Advance to next page in wizard.
                    //
                    PropSheet_SetWizButtons(GetParent(hdlg),PSWIZB_NEXT);
                    PropSheet_PressButton(GetParent(hdlg),PSBTN_NEXT);
#ifdef UNICODE
                    if (SetupPage->OcManager->Callbacks.SetupPerfData)
                        SetupPage->OcManager->Callbacks.SetupPerfData(TEXT(__FILE__),__LINE__,L"END_SECTION",L"OCSetup");
#endif

                    // un-subclass the progress bar. just in case
                    SetWindowLongPtr(GetDlgItem(hdlg,SetupPage->ControlsInfo.ProgressBar),
                                     GWLP_WNDPROC,
                                     (LONG_PTR)OldProgressProc);
                    //
                    // Clear user canceled flag,
                    //
                    SetupPage->OcManager->InternalFlags &= ~ OCMFLAG_USERCANCELED;
                    break;
            }

            b = TRUE;
            break;

        case WMX_TICK:

            switch (wParam) {

                case 0:
                    //
                    // The setup API queue commit routine is telling us how many 
                    // files are to be copied. We do nothing in this case, as we
                    // set the progress guage manually so that we also count
                    // delete operations in our progress guage.
                    //
                    break;

                case 1:
                    //
                    // File copied.
                    //
                    SendDlgItemMessage(hdlg,SetupPage->ControlsInfo.ProgressBar,PBM_DELTAPOS,1,0);
                    break;

                case 10:

                    //
                    // We got our private message telling us how many files are
                    // to be processed.  see comments above in the 0 case.
                    //
                    SendDlgItemMessage(
                                          hdlg,
                                          SetupPage->ControlsInfo.ProgressBar,
                                          PBM_SETRANGE,
                                          0,
                                          MAKELPARAM(0,lParam)
                                          );
                    break;

                case 500:
                    //
                    // Incoming tick request from component dll. Don't allow a broken component dll
                    // to tick the gauge more than it said it wanted to.
                    //
                    if ((SetupPage->CurrentTopLevelComponentIndex != -1)
                        && (SetupPage->ComponentTickCounts[SetupPage->CurrentTopLevelComponentIndex]
                            < SetupPage->ComponentMaxTickCounts[SetupPage->CurrentTopLevelComponentIndex])) {

                        SetupPage->ComponentTickCounts[SetupPage->CurrentTopLevelComponentIndex]++;

                        SendDlgItemMessage(hdlg,SetupPage->ControlsInfo.ProgressBar,PBM_DELTAPOS,1,0);
                    }
                    break;
            }

            b = TRUE;
            break;
    }

    return (b);
}


VOID
pOcTickSetupGauge(
                 IN POC_MANAGER OcManager
                 )

/*++

Routine Description:

    The tick gauge OC helper/callback routine calls this routine.

Arguments:

    OcManager - supplies OC Manager context.

Return Value:

    None.

--*/

{
    //
    // The ProgressTextWindow is non-NULL if we are in
    // the installation-completion phase.
    //
    if (OcManager->ProgressTextWindow) {
        SendMessage(GetParent(OcManager->ProgressTextWindow),WMX_TICK,500,0);
    }
}


BOOL
pOcSetupInitialize(
                  IN OUT PSETUP_PAGE SetupPage,
                  IN     HWND        hdlg
                  )
{
    TCHAR Text[128];

    LoadString(MyModuleHandle,IDS_INITIALIZING,Text,sizeof(Text)/sizeof(TCHAR));
    SetDlgItemText(hdlg,SetupPage->ControlsInfo.ProgressText,Text);

    // If, update the text on the billboard for the progress bar.
    if (SetupPage->OcManager->Callbacks.BillBoardSetProgressText)
    {
        SetupPage->OcManager->Callbacks.BillBoardSetProgressText(Text);
    }

    //
    // Create a setup file queue.
    //
    SetupPage->FileQueue = SetupOpenFileQueue();
    if (SetupPage->FileQueue == INVALID_HANDLE_VALUE) {

        _LogError(SetupPage->OcManager,OcErrLevFatal,MSG_OC_OOM);

        SetupPage->FileQueue = NULL;
        return (FALSE);
    }

    SetupPage->QueueContext = SetupInitDefaultQueueCallbackEx(hdlg,hdlg,WMX_TICK,0,0);
    if (!SetupPage->QueueContext) {

        _LogError(SetupPage->OcManager,OcErrLevFatal,MSG_OC_OOM);

        SetupCloseFileQueue(SetupPage->FileQueue);
        SetupPage->FileQueue = NULL;
        return (FALSE);
    }

    return (TRUE);
}


VOID
pOcSetupStartWorkerThread(
                         IN OUT PSETUP_PAGE            SetupPage,
                         IN     HWND                   hdlg,
                         IN     LPTHREAD_START_ROUTINE ThreadRoutine
                         )
{
    PGEN_THREAD_PARAMS pParams;
    GEN_THREAD_PARAMS Params;
    HANDLE h;
    DWORD id;

    if (WorkerThreadHandle) {
        CloseHandle( WorkerThreadHandle );
        WorkerThreadHandle = NULL;
    }

    if (pParams = pSetupMalloc(sizeof(GEN_THREAD_PARAMS))) {

        pParams->SetupPage = SetupPage;
        pParams->SetupPage->hdlg = hdlg;
        pParams->hdlg = hdlg;
        pParams->Async = TRUE;

        h = CreateThread(NULL,0,ThreadRoutine,pParams,0,&id);
        if (!h) {
            pSetupFree(pParams);
        } else {
            WorkerThreadHandle = h;
        }

    } else {
        h = NULL;
    }

    if (!h) {

        //
        // Just try it synchronously.
        //
        Params.SetupPage = SetupPage;
        Params.hdlg = hdlg;
        Params.Async = FALSE;
        ThreadRoutine(&Params);
    }
}

//
// a debugging routine that makes it easy to cancel at any phase of setup
//
/*
VOID CancelRoutine(
    VOID
    )
{
    static int i = 0;
    TCHAR dbg[100];

    wsprintf( dbg, TEXT("cancel routine iteration number %i \n"), i);
    OutputDebugString( dbg );

    OutputDebugString( TEXT(" waiting 5 seconds for cancel ... \n" ));
    Sleep( 1000 * 5 );
    OutputDebugString( TEXT(" done waiting for cancel ... \n" ));

    i++;
}
*/

BOOL
CheckForQueueCancel(
                   PSETUP_PAGE SetupPage
                   )
{
    BOOL bRet;

    //CancelRoutine();

    bRet = SetupPage->UserClickedCancel;

    return (bRet);
}

DWORD
pOcSetupQueue(
             IN PGEN_THREAD_PARAMS Params
             )
{
    UINT Err;
    unsigned i,child;
    OPTIONAL_COMPONENT Oc;
    TCHAR Text[128];
    DWORD RetVal;

    InterlockedIncrement( &Params->SetupPage->RefCount );

    LoadString(MyModuleHandle,IDS_BUILDINGCOPYLIST,Text,sizeof(Text)/sizeof(TCHAR));

#ifdef UNICODE
    if (Params->SetupPage->OcManager->Callbacks.SetupPerfData)
        Params->SetupPage->OcManager->Callbacks.SetupPerfData(TEXT(__FILE__),__LINE__,L"BEGIN_SECTION",Text);

    // If, update the text on the billboard for the progress bar.
    if (Params->SetupPage->OcManager->Callbacks.BillBoardSetProgressText)
    {
        Params->SetupPage->OcManager->Callbacks.BillBoardSetProgressText(Text);
    }
#endif
    SetDlgItemText(Params->hdlg,Params->SetupPage->ControlsInfo.ProgressText,Text);

    if (CheckForQueueCancel(Params->SetupPage)) {
        RetVal = NO_ERROR;
        goto exit;
    }

    //
    // Handle each component.
    //
    for (i=0; i<Params->SetupPage->OcManager->TopLevelOcCount; i++) {

        pSetupStringTableGetExtraData(
                               Params->SetupPage->OcManager->ComponentStringTable,
                               Params->SetupPage->OcManager->TopLevelOcStringIds[i],
                               &Oc,
                               sizeof(OPTIONAL_COMPONENT)
                               );

        //
        // Call the component dll once for the entire component.
        //
        Err = OcInterfaceQueueFileOps(
                                     Params->SetupPage->OcManager,
                                     Params->SetupPage->OcManager->TopLevelOcStringIds[i],
                                     NULL,
                                     Params->SetupPage->FileQueue
                                     );

        if (Err != NO_ERROR) {
            //
            // Notify user and continue.
            //
            _LogError(
                     Params->SetupPage->OcManager,
                     OcErrLevError,
                     MSG_OC_CANT_QUEUE_FILES,
                     Oc.Description,
                     Err
                     );
        }

        if (CheckForQueueCancel(Params->SetupPage)) {
            RetVal = NO_ERROR;
            goto exit;
        }

        //
        // Process each top level parent item in the tree
        //
        for (child=0; child<Params->SetupPage->OcManager->TopLevelParentOcCount; child++) {

            Err = pOcSetupQueueWorker(
                                     Params->SetupPage,
                                     Params->SetupPage->OcManager->TopLevelParentOcStringIds[child],
                                     Params->SetupPage->OcManager->TopLevelOcStringIds[i]
                                     );

            if (Err != NO_ERROR) {
                //
                // Notification is handled in the worker routine so nothing to do here.
                //
            }
        }

        if (CheckForQueueCancel(Params->SetupPage)) {
            RetVal = NO_ERROR;
            goto exit;
        }

    }

    if (CheckForQueueCancel(Params->SetupPage)) {
        RetVal = NO_ERROR;
        goto exit;
    }

    PostMessage(Params->hdlg,WMX_SETUP,OCSETUPSTATE_GETSTEP,0);

exit:

#ifdef UNICODE
    if (Params->SetupPage->OcManager->Callbacks.SetupPerfData)
        Params->SetupPage->OcManager->Callbacks.SetupPerfData(TEXT(__FILE__),__LINE__,L"END_SECTION",Text);
#endif
    pOcFreeOcSetupPage( Params->SetupPage );

    if (Params->Async) {
        pSetupFree(Params);
    }

    return (RetVal);
}


UINT
pOcSetupQueueWorker(
                   IN PSETUP_PAGE SetupPage,
                   IN LONG        StringId,
                   IN LONG        TopLevelStringId
                   )
{
    OPTIONAL_COMPONENT Oc;
    UINT Err;
    LONG Id;

    //
    // Fetch extra data for this subcomponent.
    //
    pSetupStringTableGetExtraData(
                           SetupPage->OcManager->ComponentStringTable,
                           StringId,
                           &Oc,
                           sizeof(OPTIONAL_COMPONENT)
                           );

    //
    // If it's a child, call the component dll.
    // If it's a parent, then spin through its children.
    //
    if (Oc.FirstChildStringId == -1) {

        if (TopLevelStringId == pOcGetTopLevelComponent(SetupPage->OcManager,StringId)) {

            Err = OcInterfaceQueueFileOps(
                                         SetupPage->OcManager,
                                         pOcGetTopLevelComponent(SetupPage->OcManager,StringId),
                                         pSetupStringTableStringFromId(SetupPage->OcManager->ComponentStringTable,StringId),
                                         SetupPage->FileQueue
                                         );

            if (Err != NO_ERROR) {
                //
                // Notify user and continue.
                //
                _LogError(
                         SetupPage->OcManager,
                         OcErrLevError,
                         MSG_OC_CANT_QUEUE_FILES,
                         Oc.Description,
                         Err
                         );
            }
        }
    } else {

        for (Id = Oc.FirstChildStringId; Id != -1; Id = Oc.NextSiblingStringId) {

            Err = pOcSetupQueueWorker(SetupPage,Id,TopLevelStringId);
            if (Err != NO_ERROR) {
                //
                // Notification is handled in the worker routine so nothing to do here.
                //
            }

            pSetupStringTableGetExtraData(
                                   SetupPage->OcManager->ComponentStringTable,
                                   Id,
                                   &Oc,
                                   sizeof(OPTIONAL_COMPONENT)
                                   );
        }
    }

    return (NO_ERROR);
}


DWORD
pOcSetupGetStepCount(
                    IN PGEN_THREAD_PARAMS Params
                    )
{
    UINT Err;
    unsigned i,child;
    OPTIONAL_COMPONENT Oc;
    UINT StepCount;
    TCHAR Text[128];
    UINT Count;

    InterlockedIncrement( &Params->SetupPage->RefCount );

    LoadString(MyModuleHandle,IDS_PREPARING,Text,sizeof(Text)/sizeof(TCHAR));
    SetDlgItemText(Params->hdlg,Params->SetupPage->ControlsInfo.ProgressText,Text);
#ifdef UNICODE
    // If, update the text on the billboard for the progress bar.
    if (Params->SetupPage->OcManager->Callbacks.BillBoardSetProgressText)
    {
        Params->SetupPage->OcManager->Callbacks.BillBoardSetProgressText(Text);
    }
    if (Params->SetupPage->OcManager->Callbacks.SetupPerfData)
        Params->SetupPage->OcManager->Callbacks.SetupPerfData(TEXT(__FILE__),__LINE__,L"BEGIN_SECTION",Text);
#endif

    Params->SetupPage->StepCount = 0;

    //
    // Handle each component.
    //
    for (i=0; i<Params->SetupPage->OcManager->TopLevelOcCount; i++) {

        //
        // Call the component dll once for the entire component.
        // Ignore any error. Later we call per-subcomponent and we'll
        // assume that any component that gives us an error has 1 step.
        //
        Err = OcInterfaceQueryStepCount(
                                       Params->SetupPage->OcManager,
                                       Params->SetupPage->OcManager->TopLevelOcStringIds[i],
                                       NULL,
                                       &Count
                                       );

        StepCount = ((Err == NO_ERROR) ? Count : 0);

        //
        // For each top level parent item in the tree find all the children
        // that belong to this component
        //
        for (child=0; child<Params->SetupPage->OcManager->TopLevelParentOcCount; child++) {

            //
            // Now call the component dll for each child subcomponent.
            //
            StepCount += pOcSetupGetStepCountWorker(
                                                   Params->SetupPage,
                                                   Params->SetupPage->OcManager->TopLevelParentOcStringIds[child],
                                                   Params->SetupPage->OcManager->TopLevelOcStringIds[i]
                                                   );
        }

        if (!StepCount) {
            //
            // Make sure each component has at least one step.
            //
            StepCount = 1;
        }

        Params->SetupPage->StepCount += StepCount;
        Params->SetupPage->ComponentTickCounts[i] = 0;
        Params->SetupPage->ComponentMaxTickCounts[i] = StepCount;
    }

    if (CheckForQueueCancel(Params->SetupPage)) {
        goto exit;
    }

    PostMessage(Params->hdlg,WMX_SETUP,OCSETUPSTATE_DOIT,0);

exit:

#ifdef UNICODE
    if (Params->SetupPage->OcManager->Callbacks.SetupPerfData)
        Params->SetupPage->OcManager->Callbacks.SetupPerfData(TEXT(__FILE__),__LINE__,L"END_SECTION",Text);
#endif
    pOcFreeOcSetupPage( Params->SetupPage );

    if (Params->Async) {
        pSetupFree(Params);
    }


    return (0);
}


UINT
pOcSetupGetStepCountWorker(
                          IN PSETUP_PAGE SetupPage,
                          IN LONG        StringId,
                          IN LONG        TopLevelStringId
                          )
{
    OPTIONAL_COMPONENT Oc;
    UINT Err;
    LONG Id;
    UINT Count;
    UINT TotalCount;

    TotalCount = 0;
    Count = 0;

    //
    // Fetch extra data for this subcomponent.
    //
    pSetupStringTableGetExtraData(
                           SetupPage->OcManager->ComponentStringTable,
                           StringId,
                           &Oc,
                           sizeof(OPTIONAL_COMPONENT)
                           );

    //
    // If it's a child, call the component dll.
    // If it's a parent, then spin through its children.
    //
    if (Oc.FirstChildStringId == -1) {

        //
        // Only call the leaf node if the top level component matches
        //
        if (TopLevelStringId == pOcGetTopLevelComponent(SetupPage->OcManager,StringId)) {

            Err = OcInterfaceQueryStepCount(
                                           SetupPage->OcManager,
                                           pOcGetTopLevelComponent(SetupPage->OcManager,StringId),
                                           pSetupStringTableStringFromId(SetupPage->OcManager->ComponentStringTable,StringId),
                                           &Count
                                           );

            if (Err == NO_ERROR) {
                TotalCount = Count;
            }
        }

    } else {

        for (Id = Oc.FirstChildStringId; Id != -1; Id = Oc.NextSiblingStringId) {

            TotalCount += pOcSetupGetStepCountWorker(SetupPage,Id,TopLevelStringId);

            pSetupStringTableGetExtraData(
                                   SetupPage->OcManager->ComponentStringTable,
                                   Id,
                                   &Oc,
                                   sizeof(OPTIONAL_COMPONENT)
                                   );
        }
    }

    return (TotalCount);
}

BOOL
pOcSetRenamesFlag(
                 IN POC_MANAGER OcManager
                 )
{
    HKEY hKey;
    long rslt = ERROR_SUCCESS;
#ifdef UNICODE
    rslt = RegOpenKeyEx(
                       HKEY_LOCAL_MACHINE,
                       TEXT("System\\CurrentControlSet\\Control\\Session Manager"),
                       0,
                       KEY_SET_VALUE,
                       &hKey);

    if (rslt == ERROR_SUCCESS) {
        DWORD Value = 1;
        rslt = RegSetValueEx(
                            hKey,
                            OC_ALLOWRENAME,
                            0,
                            REG_DWORD,
                            (LPBYTE)&Value,
                            sizeof(DWORD));

        RegCloseKey(hKey);

        if (rslt != ERROR_SUCCESS) {
            TRACE(( TEXT("couldn't RegSetValueEx, ec = %d\n"), rslt ));
        }

    } else {
        TRACE(( TEXT("couldn't RegOpenKeyEx, ec = %d\n"), rslt ));
    }
#endif

    return (rslt == ERROR_SUCCESS);

}

BOOL
pOcAttemptQueueAbort(
                    IN UINT Notification,
                    IN PUINT rc
                    )
{
    //
    // user has asked to abort installation.  We need to hand this request to
    // setupapi, but setupapi only handles this request from certain
    //  notifications
    //

    BOOL bHandled = FALSE;


    switch (Notification) {
        case SPFILENOTIFY_STARTQUEUE:
        case SPFILENOTIFY_STARTSUBQUEUE:
            SetLastError(ERROR_CANCELLED);
            *rc = 0;
            bHandled = TRUE;
            break;

        case SPFILENOTIFY_STARTDELETE:
        case SPFILENOTIFY_STARTBACKUP:
        case SPFILENOTIFY_STARTRENAME:
        case SPFILENOTIFY_STARTCOPY:
        case SPFILENOTIFY_NEEDMEDIA:
        case SPFILENOTIFY_COPYERROR:
        case SPFILENOTIFY_DELETEERROR:
        case SPFILENOTIFY_RENAMEERROR:
        case SPFILENOTIFY_BACKUPERROR:
            SetLastError(ERROR_CANCELLED);
            *rc = FILEOP_ABORT;
            bHandled = TRUE;
            break;
        case SPFILENOTIFY_FILEEXTRACTED:
        case SPFILENOTIFY_NEEDNEWCABINET:
        case SPFILENOTIFY_QUEUESCAN:
            SetLastError(ERROR_CANCELLED);
            *rc = ERROR_CANCELLED;
            bHandled = TRUE;
            break;
    };

    return (bHandled);

}

UINT
OcManagerQueueCallback1(
                       IN PVOID Context,
                       IN UINT  Notification,
                       IN UINT_PTR Param1,
                       IN UINT_PTR Param2
                       )
{
    PSETUP_PAGE SetupPage = Context;
    UINT i;
    BOOL b;
    TCHAR Text[MAX_PATH*2];
    PFILEPATHS pFile = (PFILEPATHS) Param1;
    PSOURCE_MEDIA sm = (PSOURCE_MEDIA)Param1;
    static BOOL UserClickedCancel;
    UINT rc = 0;
    UINT retval;

    //
    // We handle the user cancelling at the beginning of the queue callback.
    // If the user has cancelled then we don't execute any code, we just return
    // until we get a callback that allows us to cancel.
    //
    // There is a window in this code where the user might cancel after we
    // check for cancelling but before the queue callback code executes.  If we fall into
    // the WM_DESTROY block in our window proc when this occurs, we cannot send any more
    // messages to our window.  Use PostMessage below to guard against that.

    top:
    if (UserClickedCancel) {
        pOcAttemptQueueAbort(Notification,&rc);
        return (rc);
    }

    if (SetupPage->UserClickedCancel) {
        UserClickedCancel = TRUE;
    }

    if (UserClickedCancel) {
        goto top;
    }

    switch (Notification) {

        case SPFILENOTIFY_STARTSUBQUEUE:
            //
            // Tell the user what's going on.
            //
            switch (Param1) {
                case FILEOP_DELETE:
                    i = IDS_DELETING;
                    break;
                case FILEOP_RENAME:
                    i = IDS_RENAME;
                    break;
                case FILEOP_COPY:
                    i = IDS_COPYING;
                    break;
                default:
                    i = (UINT)(-1);
                    break;
            }

            if (i != (UINT)(-1)) {
                LoadString(MyModuleHandle,i,Text,sizeof(Text)/sizeof(TCHAR));
                SetDlgItemText(SetupPage->hdlg,SetupPage->ControlsInfo.ProgressText,Text);

                // If, update the text on the billboard for the progress bar.
                if (SetupPage->OcManager->Callbacks.BillBoardSetProgressText)
                {
                    SetupPage->OcManager->Callbacks.BillBoardSetProgressText(Text);
                }

            }

            break;

        case  SPFILENOTIFY_STARTCOPY:
            lstrcpy( g_LastFileCopied, pFile->Target );
#ifdef UNICODE
            // fall through...
        case  SPFILENOTIFY_STARTDELETE:
        case  SPFILENOTIFY_STARTRENAME:
            if ((SetupPage->OcManager->SetupData.OperationFlags & SETUPOP_STANDALONE)) {
                if (!hSfp) {
                    hSfp = SfcConnectToServer( NULL );
                }
                if (hSfp) {
                    if (SfcIsFileProtected(hSfp,pFile->Target)) {
                        SfcFileException(
                                        hSfp,
                                        (PWSTR) pFile->Target,
                                        SFC_ACTION_REMOVED
                                        );
                    }
                }
            }
#endif
            break;

        case  SPFILENOTIFY_ENDCOPY:
            if (pFile->Win32Error == NO_ERROR) {
                _LogError(SetupPage->OcManager,
                          OcErrLevInfo,
                          MSG_OC_LOG_FILE_COPIED,
                          pFile->Source,
                          pFile->Target);
            } else {
                TRACE(( TEXT("OC:OcManagerQueueCallback Copy Error: %s --> %s (%d)\n"),
                        pFile->Source,
                        pFile->Target,
                        pFile->Win32Error));

                _LogError(SetupPage->OcManager,
                          OcErrLevInfo,
                          MSG_OC_LOG_FILE_COPY_FAILED,
                          pFile->Source,
                          pFile->Target,
                          pFile->Win32Error);
            }
            break;

        case  SPFILENOTIFY_ENDDELETE:   // fall through
        case SPFILENOTIFY_ENDRENAME:
        case SPFILENOTIFY_ENDBACKUP:
            //
            // tick the progress gauge manually since setupapi doesn't do it 
            // for us.
            //
            SendMessage(SetupPage->hdlg,WMX_TICK,1,0);

            break;

        case  SPFILENOTIFY_DELETEERROR:    //    0x00000007
            TRACE(( TEXT("OC:OcManagerQueueCallback Delete Error: %s (%d)\n"),
                    pFile->Target,
                    pFile->Win32Error));
            break;

        case  SPFILENOTIFY_RENAMEERROR:    //    0x0000000a
            TRACE(( TEXT("OC:OcManagerQueueCallback Rename Error: %s (%d)\n"),
                    pFile->Target,
                    pFile->Win32Error));
            break;

        case  SPFILENOTIFY_COPYERROR:      //    0x0000000d
            TRACE(( TEXT("OC:OcManagerQueueCallback Copy Error: %s (%d)\n"),
                    pFile->Target,
                    pFile->Win32Error));

            break;

        case SPFILENOTIFY_NEEDMEDIA:
            TRACE(( TEXT("OC:OcManagerQueueCallback Need Media: %s - %s (%s)\n"),
                    sm->SourcePath,
                    sm->SourceFile,
                    sm->Tagfile));
            break;

        case SPFILENOTIFY_FILEOPDELAYED:
            TRACE(( TEXT("OC:OcManagerQueueCallback FileOpDelayed: %s\n"), pFile->Target ));
            //
            // We want to remember that there was at least one file
            // with a delayed-move, but we still want to let the
            // default callback get this notification also.
            //
            SetupPage->OcManager->InternalFlags |= OCMFLAG_ANYDELAYEDMOVES;
            SetupPage->OcManager->Callbacks.SetReboot();
            pOcSetRenamesFlag(SetupPage->OcManager);

            for (i=0; (i<SetupPage->OcManager->TopLevelOcCount); i++) {
                OcInterfaceFileBusy(
                                   SetupPage->OcManager,
                                   SetupPage->OcManager->TopLevelOcStringIds[i],
                                   (PFILEPATHS)Param1,
                                   (LPTSTR)Param2
                                   );
            }

            break;
    }

    return (SetupDefaultQueueCallback(SetupPage->QueueContext, Notification, Param1, Param2));

}


DWORD
pOcSetupDoIt(
            IN PGEN_THREAD_PARAMS Params
            )
{
    BOOL b;
    TCHAR Text[256];
    TCHAR LogText[256];
    OPTIONAL_COMPONENT Oc;
    POC_MANAGER OcManager;
    BOOL AllowCancel;
    UINT LastError = ERROR_SUCCESS;
    DWORD TotalFileCount,PartialCount;

    TRACE(( TEXT("at pOcSetupDoIt entry\n") ));

    InterlockedIncrement( &Params->SetupPage->RefCount );
    //
    // Call components to let them do pre-commit processing.
    //
    LoadString(MyModuleHandle,IDS_PREQUEUECONFIG,Text,sizeof(Text)/sizeof(TCHAR));
    SetDlgItemText(Params->hdlg,Params->SetupPage->ControlsInfo.ProgressText,Text);
#ifdef UNICODE
    // If, update the text on the billboard for the progress bar.
    if (Params->SetupPage->OcManager->Callbacks.BillBoardSetProgressText)
    {
        Params->SetupPage->OcManager->Callbacks.BillBoardSetProgressText(Text);
    }
    // Save it, because "Text" is used below and we would not end up with a matchin END_SECTION
    lstrcpy(LogText, Text);
    if (Params->SetupPage->OcManager->Callbacks.SetupPerfData)
        Params->SetupPage->OcManager->Callbacks.SetupPerfData(TEXT(__FILE__),__LINE__,L"BEGIN_SECTION",LogText);
#endif

    Params->SetupPage->OcManager->ProgressTextWindow = GetDlgItem(
                                                                 Params->hdlg,
                                                                 Params->SetupPage->ControlsInfo.ProgressText
                                                                 );

    if (CheckForQueueCancel(Params->SetupPage)) {
        goto exit;
    }

    //
    // send OC_ABOUT_TO_COMMIT_QUEUE message
    //
    pOcPreOrPostCommitProcessing(Params->SetupPage,TRUE);

    OcManager = Params->SetupPage->OcManager;
    AllowCancel = Params->SetupPage->AllowCancel;
    OcManager->ProgressTextWindow = NULL;

    if (CheckForQueueCancel(Params->SetupPage)) {
        goto exit;
    }

    //
    // Commit the file queue. We get the total number of file operations
    // so we can scale the progress indicator properly.  We do this manually
    // as setupapi only returns back the total number of copy operations, and
    // we want status on delete operations as well.
    //
    TotalFileCount = 0;
    PartialCount = 0;
    if (SetupGetFileQueueCount(Params->SetupPage->FileQueue,
		       FILEOP_COPY,
                       &PartialCount)) {
        TotalFileCount += PartialCount;
    }

    PartialCount = 0;

    if (SetupGetFileQueueCount(Params->SetupPage->FileQueue,
		       FILEOP_RENAME,
                       &PartialCount)) {
        TotalFileCount += PartialCount;
    }

    PartialCount = 0;

    if (SetupGetFileQueueCount(Params->SetupPage->FileQueue,
		       FILEOP_DELETE,
                       &PartialCount)) {
        TotalFileCount += PartialCount;
    }

    //
    // if the OC file queue is ever backup aware, add in the count
    // of files to be backed up here.
    //

    TRACE(( TEXT("OCM: %d file operations to complete\n"), TotalFileCount ));

    //
    // scale the progress gauge
    //
    PostMessage(Params->hdlg,
                WMX_TICK,
                10,Params->SetupPage->StepCount + TotalFileCount);
    

    // If, update the text on the billboard for the progress bar.
    if (Params->SetupPage->OcManager->Callbacks.BillBoardSetProgressText)
    {
        Params->SetupPage->OcManager->Callbacks.BillBoardSetProgressText(Text);
    }

    b = FALSE;

    while (! b) {
        DWORD ScanResult;

        LoadString(MyModuleHandle,IDS_FILESCAN,Text,sizeof(Text)/sizeof(TCHAR));
        SetDlgItemText(Params->hdlg,Params->SetupPage->ControlsInfo.ProgressText,Text);

        b = SetupScanFileQueue(Params->SetupPage->FileQueue,
                               SPQ_SCAN_FILE_VALIDITY | SPQ_SCAN_PRUNE_COPY_QUEUE,
                               Params->hdlg,
                               NULL,
                               NULL,
                               &ScanResult);

        //
        // if the scan result is 1, then there isn't anything to commit, the entire
        // file queue has been pruned. So we skip it.
        //
        if (ScanResult != 1) {

            if( IsWindow( Params->hdlg ) ){
                LoadString(MyModuleHandle,IDS_FILEOPS,Text,sizeof(Text)/sizeof(TCHAR));
                SetDlgItemText(Params->SetupPage->hdlg,Params->SetupPage->ControlsInfo.ProgressText,Text);
            }

            if (CheckForQueueCancel(Params->SetupPage)) {
                goto exit;
            }

            b = SetupCommitFileQueue(
                                    Params->hdlg,
                                    Params->SetupPage->FileQueue,
                                    OcManagerQueueCallback1,
                                    Params->SetupPage
                                    );

            LastError =  GetLastError();

#ifdef UNICODE
            if (hSfp) {
                SfcClose(hSfp);
            }
#endif

        }

        if (!b) {

            TRACE(( TEXT("OC:SetupCommitFileQueue failed (LE=%d), last file copied was %s\n"),
                    LastError,
                    g_LastFileCopied ));

            pOcHelperReportExternalError(
                                        OcManager,
                                        0,               // defaults to Master Inf file
                                        0,
                                        MSG_OC_CANT_COMMIT_QUEUE,
                                        ERRFLG_OCM_MESSAGE,
                                        LastError
                                        );

            if ( LastError == ERROR_CANCELLED ||
                 LastError == ERROR_CONTROL_ID_NOT_FOUND ||
                 LastError == ERROR_OPERATION_ABORTED) {
                //
                // User canceled from a SetupAPI provided Dialog
                // when CallBack Returns FILEOP_ABORT LastError reports
                // ERROR_CONTROL_ID_NOT_FOUND if User aborts in SetupApi
                // find File Dialog you get ERROR_CANCELLED
                //

                if ( AllowCancel &&
                     (OcManager->SetupData.OperationFlags & SETUPOP_STANDALONE)) {
                    _LogError(
                             OcManager,
                             OcErrLevError|MB_ICONEXCLAMATION|MB_OK,
                             MSG_OC_USER_CANCELED,
                             LastError
                             );
                }
                //
                // this will force the cancel of setup
                //
                LastError = IDCANCEL;

            } else {

                //
                // Warn the user that it might be hazzardous to continue after copy error
                //
                LastError = _LogError(
                                     OcManager,
                                     OcErrLevError|MB_ICONEXCLAMATION|MB_OKCANCEL|MB_DEFBUTTON2,
                                     MSG_OC_CANT_COMMIT_QUEUE,
                                     LastError
                                     );

            }
            //
            // Abort the setup if the user pressed Cancel or
            // Batch mode log the error and cancel out of setup
            //
            if ( LastError == IDCANCEL
                 || OcManager->SetupData.OperationFlags & SETUPOP_BATCH) {
                PostMessage(Params->hdlg,WMX_SETUP,OCSETUPSTATE_COPYABORT,0);
                goto exit;
            } else if ( LastError == IDOK ) {
                b = TRUE;
            }

        }

    }

    //
    // put a message in the log so we know we completed all file operations
    //
    _LogError(OcManager,
              OcErrLevInfo,
              MSG_OC_LOG_QUEUE_COMPLETE
             );

    //
    // Tell the UI that we are done with the file operations
    //
    PostMessage(Params->hdlg,WMX_SETUP,OCSETUPSTATE_COPYDONE,0);
#ifdef UNICODE
    if (Params->SetupPage->OcManager->Callbacks.SetupPerfData)
        Params->SetupPage->OcManager->Callbacks.SetupPerfData(TEXT(__FILE__),__LINE__,L"END_SECTION",LogText);
#endif

    //
    // Call components to let them do post-commit processing.
    //
    LoadString(MyModuleHandle,IDS_CONFIGURING,Text,sizeof(Text)/sizeof(TCHAR));
    SetDlgItemText(Params->hdlg,Params->SetupPage->ControlsInfo.ProgressText,Text);
#ifdef UNICODE
    // If, update the text on the billboard for the progress bar.
    if (Params->SetupPage->OcManager->Callbacks.BillBoardSetProgressText)
    {
        Params->SetupPage->OcManager->Callbacks.BillBoardSetProgressText(Text);
    }
    if (Params->SetupPage->OcManager->Callbacks.SetupPerfData)
        Params->SetupPage->OcManager->Callbacks.SetupPerfData(TEXT(__FILE__),__LINE__,L"BEGIN_SECTION",Text);
#endif
    Params->SetupPage->OcManager->ProgressTextWindow = GetDlgItem(
                                                                 Params->hdlg,
                                                                 Params->SetupPage->ControlsInfo.ProgressText
                                                                 );

    if (CheckForQueueCancel(Params->SetupPage)) {
        goto exit;
    }

    pOcPreOrPostCommitProcessing(Params->SetupPage,FALSE);

    if (CheckForQueueCancel(Params->SetupPage)) {
        goto exit;
    }

    Params->SetupPage->OcManager->ProgressTextWindow = NULL;

    PostMessage(Params->hdlg,WMX_SETUP,OCSETUPSTATE_DONE,0);

#ifdef UNICODE
    if (Params->SetupPage->OcManager->Callbacks.SetupPerfData)
        Params->SetupPage->OcManager->Callbacks.SetupPerfData(TEXT(__FILE__),__LINE__,L"END_SECTION",Text);
#endif
exit:

    TRACE(( TEXT("at pOcSetupDoIt exit\n") ));

    pOcFreeOcSetupPage( Params->SetupPage );

    if (Params->Async) {
        pSetupFree(Params);
    }

    return (0);
}


VOID
pOcPreOrPostCommitProcessing(
                            IN OUT PSETUP_PAGE SetupPage,
                            IN     BOOL        PreCommit
                            )

/*++

Routine Description:

    Handle processing and notification to the component dlls before or after
    the file queue is committed. This involves calling interface dlls once
    for each top-level component, and then once for each subcomponent.

    The ordering for the top-level components is the order that the
    components were listed in the master oc inf.

    The ordering for leaf components is generally random within each
    top-level hierarchy, but 'detours' are taken when components are
    needed by other components. This ensures that components are
    called in the correct order to faciliate uninstall-type actions.

Arguments:

    SetupPage - supplies context data structure.
    PreCommit - TRUE indicates OC_ABOUT_TO_COMMIT_QUEUE is to be called,
                otherwise OC_COMPLETE_INSTALLATION is to be called.

Return Value:

    None. Errors are logged.

--*/

{
    OPTIONAL_COMPONENT Oc,AuxOc;
    unsigned i,child;

    //
    // Call each component at the "top-level" (ie, no subcomponent).
    //
    pOcTopLevelPreOrPostCommitProcessing(SetupPage,PreCommit);

    if (CheckForQueueCancel(SetupPage)) {
        return;
    }

    if (!PreCommit) {
        //
        // Make sure the components are marked as unprocessed.
        //

        MYASSERT(SetupPage->OcManager->ComponentStringTable);
        //
        // if this doesn't exist then something is hosed.
        //
        if (!SetupPage->OcManager->ComponentStringTable) {
            return;
        }
        pSetupStringTableEnum(
                       SetupPage->OcManager->ComponentStringTable,
                       &Oc,
                       sizeof(OPTIONAL_COMPONENT),
                       pOcMarkUnprocessedStringCB,
                       0
                       );
    }

    //
    // Call component dlls for each child subcomponent.
    //
    for (i=0; i<SetupPage->OcManager->TopLevelOcCount; i++) {


        pSetupStringTableGetExtraData(
                               SetupPage->OcManager->ComponentStringTable,
                               SetupPage->OcManager->TopLevelOcStringIds[i],
                               &Oc,
                               sizeof(OPTIONAL_COMPONENT)
                               );

        for (child=0; child<SetupPage->OcManager->TopLevelParentOcCount; child++) {

            pOcSetupDoItWorker(
                              SetupPage,
                              SetupPage->OcManager->TopLevelParentOcStringIds[child],
                              SetupPage->OcManager->TopLevelOcStringIds[i],
                              PreCommit
                              );
        }
    }
}


VOID
pOcTopLevelPreOrPostCommitProcessing(
                                    IN PSETUP_PAGE SetupPage,
                                    IN BOOL        PreCommit
                                    )

/*++

Routine Description:

    Call the OC_COMPLETE_INSTALLATION or OC_ABOUT_TO_COMMIT_QUEUE
    interface routine once for each top-level component.

Arguments:

    SetupPage - supplies context structure.

    PreCommit - if 0, then call OC_COMPLETE_INSTALLATION. Otherwise
        call OC_ABOUT_TO_COMMIT_QUEUE.

Return Value:

    None. Errors are logged.

--*/
{
    unsigned i;
    OPTIONAL_COMPONENT Oc;
    UINT Err;

    for (i=0; i<SetupPage->OcManager->TopLevelOcCount; i++) {

        pSetupStringTableGetExtraData(
                               SetupPage->OcManager->ComponentStringTable,
                               SetupPage->OcManager->TopLevelOcStringIds[i],
                               &Oc,
                               sizeof(OPTIONAL_COMPONENT)
                               );

        SetupPage->CurrentTopLevelComponentIndex = i;

        Err = OcInterfaceCompleteInstallation(
                                             SetupPage->OcManager,
                                             SetupPage->OcManager->TopLevelOcStringIds[i],
                                             NULL,
                                             PreCommit
                                             );

        if (Err != NO_ERROR) {
            _LogError(
                     SetupPage->OcManager,
                     OcErrLevError,
                     MSG_OC_COMP_INST_FAIL,
                     Oc.Description,
                     Err
                     );

            pOcHelperReportExternalError(
                                        SetupPage->OcManager,
                                        SetupPage->OcManager->TopLevelOcStringIds[i],
                                        0,
                                        MSG_OC_COMP_INST_FAIL,
                                        ERRFLG_OCM_MESSAGE,
                                        Oc.Description,
                                        Err
                                        );
        }
    }
}


VOID
pOcSetupDoItWorker(
                  IN PSETUP_PAGE SetupPage,
                  IN LONG        StringId,
                  IN LONG        TopLevelStringId,
                  IN BOOL        PreCommit
                  )
/*++

Routine Description:

    Call the OC_COMPLETE_INSTALLATION or OC_ABOUT_TO_COMMIT_QUEUE
    interface routine for each child of a given top-level component.

Arguments:

    SetupPage - supplies context structure.

    StringId - ID for the child component to be called

    TopLevelStringId - ID for the child's parent

    PreCommit - if 0, then call OC_COMPLETE_INSTALLATION. Otherwise
        call OC_ABOUT_TO_COMMIT_QUEUE.

Return Value:

    None. Errors are logged.

--*/
{
    OPTIONAL_COMPONENT Oc;
    UINT Err;
    LONG Id;
    unsigned i;
    LONG TopLevelIndex;
    UINT SelectionState;
    UINT InstalledState;

    //
    // Figure out the index of the top-level component associated with this
    // subcomponent.
    //
    Id = pOcGetTopLevelComponent(SetupPage->OcManager,StringId);
    TopLevelIndex = -1;
    for (i=0; i<SetupPage->OcManager->TopLevelOcCount; i++) {
        if (SetupPage->OcManager->TopLevelOcStringIds[i] == Id) {
            TopLevelIndex = i;
            break;
        }
    }

    //
    // Fetch extra data for this subcomponent.
    //
    pSetupStringTableGetExtraData(
                           SetupPage->OcManager->ComponentStringTable,
                           StringId,
                           &Oc,
                           sizeof(OPTIONAL_COMPONENT)
                           );

    if (Oc.FirstChildStringId == -1) {
        //
        // Leaf subcomponent.
        //
        // In the precommit case, check the subcomponents this subcomponent
        // is needed by; if there are any, process them first.
        //
        // In the postcommit case, check the subcomponents this subcomponent
        // needs; if there are any, process them first.
        //
        if (PreCommit) {
            for (i=0; i<Oc.NeededByCount; i++) {
                pOcSetupDoItWorker(
                                  SetupPage,
                                  Oc.NeededByStringIds[i],
                                  pOcGetTopLevelComponent(SetupPage->OcManager,Oc.NeededByStringIds[i]),
                                  TRUE
                                  );
            }
        } else {
            for (i=0; i<Oc.NeedsCount; i++) {
                if (Oc.NeedsStringIds[i] != StringId) {
                    pOcSetupDoItWorker(
                                      SetupPage,
                                      Oc.NeedsStringIds[i],
                                      pOcGetTopLevelComponent(SetupPage->OcManager,Oc.NeedsStringIds[i]),
                                      FALSE
                                      );
                }
            }
        }

        //
        // Fetch extra data for this subcomponent again as it might have
        // changed in the recursive call we just made.
        //
        pSetupStringTableGetExtraData(
                               SetupPage->OcManager->ComponentStringTable,
                               StringId,
                               &Oc,
                               sizeof(OPTIONAL_COMPONENT)
                               );

        //
        // If not processed already, process now.
        //
        if (!(Oc.InternalFlags & OCFLAG_PROCESSED)) {

            Oc.InternalFlags |= OCFLAG_PROCESSED;
            pSetupStringTableSetExtraData(
                                   SetupPage->OcManager->ComponentStringTable,
                                   StringId,
                                   &Oc,
                                   sizeof(OPTIONAL_COMPONENT)
                                   );

            SetupPage->CurrentTopLevelComponentIndex = TopLevelIndex;

            //
            // Set current install state to not installed, pending successful
            // outcome of the installation routine.
            //
            if (!PreCommit) {
                SelectionState = Oc.SelectionState;
                Oc.SelectionState = SELSTATE_NO;
                pOcSetOneInstallState(SetupPage->OcManager,StringId);
            }

            Err = OcInterfaceCompleteInstallation(
                                                 SetupPage->OcManager,
                                                 pOcGetTopLevelComponent(SetupPage->OcManager,StringId),
                                                 pSetupStringTableStringFromId(SetupPage->OcManager->ComponentStringTable,StringId),
                                                 PreCommit
                                                 );

            // Ignore error and ask the component
            // for the actual installation state.

            if (!PreCommit) {

                Oc.SelectionState = (Err) ? Oc.OriginalSelectionState : SelectionState;

                InstalledState = OcInterfaceQueryState(
                                                      SetupPage->OcManager,
                                                      pOcGetTopLevelComponent(SetupPage->OcManager,StringId),
                                                      pSetupStringTableStringFromId(SetupPage->OcManager->ComponentStringTable,StringId),
                                                      OCSELSTATETYPE_FINAL
                                                      );

                switch (InstalledState) {
                    case SubcompOn:
                        SelectionState = SELSTATE_YES;
                        break;
                    case SubcompOff:
                        SelectionState = SELSTATE_NO;
                        break;
                    default:
                        SelectionState = Oc.SelectionState;
                        break;
                }

                Oc.SelectionState = SelectionState;
                pSetupStringTableSetExtraData(
                                       SetupPage->OcManager->ComponentStringTable,
                                       StringId,
                                       &Oc,
                                       sizeof(OPTIONAL_COMPONENT)
                                       );

                pOcSetOneInstallState(SetupPage->OcManager,StringId);
            }

        }
    } else {
        //
        // Parent component. Spin through the children.
        //
        for (Id = Oc.FirstChildStringId; Id != -1; Id = Oc.NextSiblingStringId) {

            pOcSetupDoItWorker(SetupPage,Id,TopLevelStringId,PreCommit);

            pSetupStringTableGetExtraData(
                                   SetupPage->OcManager->ComponentStringTable,
                                   Id,
                                   &Oc,
                                   sizeof(OPTIONAL_COMPONENT)
                                   );
        }
    }
}


BOOL
pOcMarkUnprocessedStringCB(
                          IN PVOID               StringTable,
                          IN LONG                StringId,
                          IN PCTSTR              String,
                          IN POPTIONAL_COMPONENT Oc,
                          IN UINT                OcSize,
                          IN LPARAM              Unused
                          )

/*++

Routine Description:

    String table callback routine. Clears the OCFLAG_PROCESSED flag in
    the OPTIONAL_COMPONENT structure that is passed to it.

Arguments:

    String string table callback arguments.

Return Value:

    Always returns TRUE to continue enumeration.

--*/

{
    Oc->InternalFlags &= ~OCFLAG_PROCESSED;
    pSetupStringTableSetExtraData(StringTable,StringId,Oc,OcSize);
    return (TRUE);
}


VOID
_pOcExternalProgressIndicator(
                             IN PSETUP_PAGE SetupPage,
                             IN BOOL        ExternalIndicator,
                             IN HWND        hdlg
                             )
{
    POC_MANAGER OcManager;
    HWND Animation;

    OcManager = SetupPage->OcManager;

    EnableWindow(
                GetDlgItem(hdlg,SetupPage->ControlsInfo.ProgressBar),
                !ExternalIndicator
                );

    if (SetupPage->ForceExternalProgressIndicator) {
        ShowWindow(
                  GetDlgItem(hdlg,SetupPage->ControlsInfo.ProgressBar),
                  ExternalIndicator ? SW_HIDE : SW_SHOW
                  );

        ShowWindow(
                  GetDlgItem(hdlg,SetupPage->ControlsInfo.ProgressLabel),
                  ExternalIndicator ? SW_HIDE : SW_SHOW
                  );
    }

    Animation = GetDlgItem(hdlg,SetupPage->ControlsInfo.AnimationControl);

    sapiAssert( Animation != NULL );

    if (!ExternalIndicator) {
        Animate_Stop(Animation);
        Animate_Close(Animation);
    }

    EnableWindow(Animation,ExternalIndicator);
    ShowWindow(Animation,ExternalIndicator ? SW_SHOW : SW_HIDE);

    if (ExternalIndicator) {
        Animate_Open(Animation,MAKEINTRESOURCE(SetupPage->ControlsInfo.AnimationResource));
        Animate_Play(Animation,0,-1,-1);
    }
}


VOID
pOcExternalProgressIndicator(
                            IN PHELPER_CONTEXT OcManagerContext,
                            IN BOOL            ExternalIndicator
                            )
{
    POC_MANAGER OcManager;
    HWND hdlg;
    PSETUP_PAGE SetupPage;

    OcManager = OcManagerContext->OcManager;

    if (OcManager->ProgressTextWindow
        && (hdlg = GetParent(OcManager->ProgressTextWindow))
        && (SetupPage = (PSETUP_PAGE)GetWindowLongPtr(hdlg,DWLP_USER))
        && !SetupPage->ForceExternalProgressIndicator) {

        _pOcExternalProgressIndicator(SetupPage,ExternalIndicator,hdlg);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ocmanage\common\res.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by res.rc
//
#define IDS_INITIALIZING                1
#define IDS_BUILDINGCOPYLIST            2
#define IDS_PREPARING                   3
#define IDS_PREQUEUECONFIG				4
#define IDS_FILEOPS						5
#define IDS_COPYING                     6
#define	IDS_RENAME						7
#define	IDS_DELETING					8
#define IDS_CONFIGURING                 9
#define IDS_MB_AND_TENTHS               10
#define IDS_EXTERNAL_INST               11
#define IDS_EXTERNAL_UNINST             12
#define IDS_EXTERNAL_SETUP              13
#define IDS_SETUP                       14
#define IDS_EXTERNAL_UPGRADE            15
#define IDS_EXTERNAL_EXAMINE            16
#define IDS_SUBCOMP_OF                  17
#define IDS_INSTALL_FORMAT              18
#define IDS_CONFIGURE_FORMAT            19
#define IDS_OCM_DESCRIPTION             20
#define IDS_FILESCAN                    21
#define IDS_OCM_WINDOWTITLE             22

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ocmanage\common\ocstalon.c ===
#include "precomp.h"
#pragma hdrstop
#include <io.h>

typedef struct _STANDALONE_COMP {
    struct _STANDALONE_COMP *Next;
    LPTSTR ComponentId;
    HINF Inf;
    OCMANAGER_ROUTINES HelperRoutines;

} STANDALONE_COMP, *PSTANDALONE_COMP;


PSTANDALONE_COMP StandaloneComponents = NULL;

DWORD
InvokeStandAloneInstaller(
    IN LPCTSTR ComponentId,
    IN BOOL    PreQueueCommit
    );

DWORD
WaitOnApp(
    IN  HANDLE Process,
    OUT PDWORD ExitCode
    );


void
SetSuiteCurrentDir(
    IN PSTANDALONE_COMP Standalone
        )
{
    TCHAR   NewPath[MAX_PATH];
    LPTSTR p;
    PHELPER_CONTEXT pContext = (PHELPER_CONTEXT) Standalone->HelperRoutines.OcManagerContext;
    
    _tcscpy(NewPath,pContext->OcManager->MasterOcInfPath);
    p = _tcsrchr(NewPath,TEXT('\\'));
    if (p) {
        *p = 0;
    }

    SetCurrentDirectory(NewPath);

}

BOOL
CheckIfExistAndAskForMedia(
    IN PSTANDALONE_COMP Standalone,
    IN LPTSTR ExePath,
    IN LPCTSTR Description
    )
{
    // Check to see if the Exe even exits... if not ask the
    PHELPER_CONTEXT pContext = (PHELPER_CONTEXT) Standalone->HelperRoutines.OcManagerContext;
    SOURCE_MEDIA Media;
    TCHAR   NewPath[MAX_PATH*3];
    LPTSTR p;
    BOOL b = FALSE;
    UINT    i;


    // Prepare Exe file name, Strip off arguments
    // Can't have spaces in Exe name.
    
    _tcscpy(NewPath,ExePath);
    
    p = _tcschr(NewPath,TEXT(' '));
    if(!p) {
        p = _tcschr(NewPath,TEXT('\t'));
    }
    if(p) {
        *p = 0;
    }

    // Check if we can find the file -
    // Assumes that we have right CD or full path
    i = GetFileAttributes(NewPath);

    if ( i == -1 ) {
            
        // now backup to file part, strip off path leave file name.
        
        p = _tcsrchr(NewPath,TEXT('\\'));
        if (!p) {
            p = NewPath;
        }
        
        Media.Reserved = NULL;  //      PCWSTR
        Media.Description= Description; //      PCWSTR
        
        Media.SourcePath = NULL;        //  PCWSTR
        Media.SourceFile = p;       //  PCWSTR
        Media.Tagfile  = p; //      PCWSTR  may be NULL
        Media.Flags = 0;                // DWORD  subset of SP_COPY_xxx

        for(b=FALSE,i=0; (i<pContext->OcManager->TopLevelOcCount) && !b; i++) {

             b = OcInterfaceNeedMedia(
                  pContext->OcManager,
                  pContext->OcManager->TopLevelOcStringIds[i],
                  &Media,
                  (LPTSTR)NewPath
               );
            if (b) {
                // Now we have a new Path to the file
                // get the last segment of the path
                
                p = _tcsrchr(ExePath,TEXT('\\'));
                if (p) {
                    _tcscat(NewPath,p);
                } else {
                    _tcscat(NewPath,TEXT("\\"));
                    _tcscat(NewPath,ExePath);
                }
                // Rewrite path
                _tcscpy(ExePath,NewPath);
                break;
            }
        }
    }
    return b;
}

DWORD
StandAloneSetupAppInterfaceRoutine(
    IN     LPCVOID ComponentId,
    IN     LPCVOID SubcomponentId,
    IN     UINT    Function,
    IN     UINT_PTR Param1,
    IN OUT PVOID   Param2
    )
{
    DWORD d;
    PSTANDALONE_COMP Standalone,Prev;

    switch(Function) {

    case OC_PREINITIALIZE:
        //
        // Run with native character width.
        //
        #ifdef UNICODE
        d = OCFLAG_UNICODE;
        #else
        d = OCFLAG_ANSI;
        #endif
        break;

        
    case OC_INIT_COMPONENT:
        //
        // Inform OC Manager of the version we want.
        //
        ((PSETUP_INIT_COMPONENT)Param2)->ComponentVersion = OCMANAGER_VERSION;

        d = ERROR_NOT_ENOUGH_MEMORY;
        if(Standalone = pSetupMalloc(sizeof(STANDALONE_COMP))) {
            if(Standalone->ComponentId = pSetupMalloc((lstrlen(ComponentId)+1) * sizeof(TCHAR))) {

                lstrcpy(Standalone->ComponentId,ComponentId);

                Standalone->Inf = ((PSETUP_INIT_COMPONENT)Param2)->ComponentInfHandle;
                Standalone->HelperRoutines = ((PSETUP_INIT_COMPONENT)Param2)->HelperRoutines;

                Standalone->Next = StandaloneComponents;
                StandaloneComponents = Standalone;

                d = NO_ERROR;
            } else {
                pSetupFree(Standalone);
            }
        }

        break;

    case OC_SET_LANGUAGE:
        d = TRUE;
        break;

    case OC_QUERY_IMAGE:
        d = 0;
        break;

    case OC_REQUEST_PAGES:
        //
        // This component has no pages.
        //
        d = 0;
        break;

    case OC_QUERY_SKIP_PAGE:

        d = FALSE;
        break;

    case OC_QUERY_STATE:
    {
        DWORD dSetupMode;
        
        //
        // Allow selection state transition.
        //
        for(Standalone=StandaloneComponents; Standalone; Standalone=Standalone->Next) {
            if(!lstrcmpi(ComponentId,Standalone->ComponentId)) {
                break;
            }
        }

        dSetupMode = Standalone->HelperRoutines.GetSetupMode(
                    Standalone->HelperRoutines.OcManagerContext);
        //
        // Use default if we have no option...
        //
    
        d = SubcompUseOcManagerDefault;

        if (Param1 == OCSELSTATETYPE_CURRENT) {

            switch(dSetupMode & SETUPMODE_PRIVATE_MASK) {
            default:
                d = SubcompUseOcManagerDefault;
                break;
            case SETUPMODE_REMOVEALL:
                d = SubcompOff;
                break;
                    
            case SETUPMODE_ADDEXTRACOMPS:
            case SETUPMODE_ADDREMOVE:
            case SETUPMODE_UPGRADEONLY:
            case SETUPMODE_REINSTALL:
                d = Standalone->HelperRoutines.QuerySelectionState(
                    Standalone->HelperRoutines.OcManagerContext,
                        SubcomponentId,
                        OCSELSTATETYPE_ORIGINAL) ? SubcompOn : SubcompOff;
                     break;
            }
       }

        break;
    }
    case OC_QUERY_CHANGE_SEL_STATE:
            d = TRUE;
        break;

    case OC_CALC_DISK_SPACE:

        for(Standalone=StandaloneComponents; Standalone; Standalone=Standalone->Next) {
            if(!lstrcmpi(ComponentId,Standalone->ComponentId)) {
                break;
            }
        }

        if(Standalone) {

            INFCONTEXT Context;

            if(SetupFindFirstLine(Standalone->Inf,ComponentId,TEXT("DiskSpaceEstimate"),&Context)) {

                LONGLONG Space;
                int SpaceMB;
                BOOL b;
                TCHAR Path[MAX_PATH];

                if(SetupGetIntField(&Context,1,&SpaceMB)) {

                    Space = (LONGLONG)SpaceMB * (1024*1024);
                    if(!Param1) {
                        Space = 0 - Space;
                    }

                    GetWindowsDirectory(Path,MAX_PATH);
                    Path[3] = 0;

                    b = SetupAdjustDiskSpaceList((HDSKSPC)Param2,Path,Space,0,0);

                    d = b ? NO_ERROR : GetLastError();
                } else {
                    d = ERROR_INVALID_DATA;
                }
            }
        } else {
            d = NO_ERROR;
        }

        break;

    case OC_QUEUE_FILE_OPS:
        //
        // No files to queue.
        //
        d = NO_ERROR;
        break;

    case OC_NOTIFICATION_FROM_QUEUE:
        d = 0;
        break;

    case OC_QUERY_STEP_COUNT:
        //
        // Just use 1 step.
        //
        d = 1;
        break;

    case OC_ABOUT_TO_COMMIT_QUEUE:
    case OC_COMPLETE_INSTALLATION:

        // Figure out whether state changed, and if so, invoke
        // the install/uninstall cmd line. Just to be safe, we ignore
        // any requests that are not for the component as a whole,
        // since these were not supposed to have been specified in the first place.
        //
        d = SubcomponentId
          ? NO_ERROR
          : InvokeStandAloneInstaller(ComponentId,Function == OC_ABOUT_TO_COMMIT_QUEUE);

        break;

    case OC_CLEANUP:
        //
        // Return value is ignored.
        //
        Prev = NULL;
        for(Standalone=StandaloneComponents; Standalone; Standalone=Standalone->Next) {

            if(!lstrcmpi(ComponentId,Standalone->ComponentId)) {
                if(Prev) {
                    Prev->Next = Standalone->Next;
                } else {
                    StandaloneComponents = Standalone->Next;
                }

                pSetupFree(Standalone->ComponentId);
                pSetupFree(Standalone);
                break;
            }

            Prev = Standalone;
        }
        break;

    default:
        //
        // Return something sane.
        //
        d = 0;
        break;
    }

    return(d);
}


DWORD
RunStandaloneCmd(
    IN PSTANDALONE_COMP Standalone,
    IN LPCTSTR          Description,
    IN LPCTSTR          cmd
    )
{
    STARTUPINFO         StartupInfo;
    PROCESS_INFORMATION ProcessInfo;
    TCHAR               ExePath[3*MAX_PATH];
    DWORD               ExitCode;
    BOOL                b;

    ZeroMemory(&StartupInfo,sizeof(STARTUPINFO));
    ZeroMemory(&ProcessInfo,sizeof(PROCESS_INFORMATION));

    StartupInfo.cb = sizeof(STARTUPINFO);

    lstrcpyn(ExePath,cmd,3*MAX_PATH);

    pOcExternalProgressIndicator(Standalone->HelperRoutines.OcManagerContext,TRUE);

    // We will try two times to invoke the external setup. For both attempt the Current
    // Directory is set the same directory of where the suite.inf file is located.
    // In the first attempt we invoke the command line as we find it from the Standalone
    // inf file. An for almost all cases this will work. If we fail in that invokcation we
    // ask the suite dll for a "Needs Media" can allow them to tell us where the Standalone exe is.

    // This accounts the two following form of commands
    // InstalledCmd = "wpie15-x86.exe /Q:A /R:NG"
    // UninstallCmd = "RunDll32 ADVPACK.DLL,LaunchINFSection %17%\enuwpie.inf,WebPostUninstall,5"

    // Where Wpie15-x86.exe will be found in the Current Directory, and if it's not we will ask the
    // suite to provide it. (Web Download) or in the second case where a system dll must be executed
    // to uninstall the product. What's not covered here is if we fail to do a createProcess on the
    // second form of command.

    b = FALSE;
    while( ! b) {
        b = CreateProcess(
            NULL,
            ExePath,
            NULL,
            NULL,
            FALSE,
            0,
            NULL,
            NULL,               // Sysocmgr set CD to sourcedir
            &StartupInfo,
            &ProcessInfo
            );

        // If we failed to start the external setup, try asking the suite where
        // to find this
        if ( ! b) {
            if ( ! CheckIfExistAndAskForMedia(Standalone, ExePath, Description)) {
                // if the Suite could not locate the exe thengive up
                break;
            }
        }
    }

    if (!b) {
        pOcExternalProgressIndicator(Standalone->HelperRoutines.OcManagerContext,FALSE);
        return GetLastError();
    }

    CloseHandle(ProcessInfo.hThread);
    WaitOnApp(ProcessInfo.hProcess,&ExitCode);
    CloseHandle(ProcessInfo.hProcess);
    pOcExternalProgressIndicator(Standalone->HelperRoutines.OcManagerContext,FALSE);

    return NO_ERROR;
}

DWORD
InvokeStandAloneInstaller(
    IN LPCTSTR ComponentId,
    IN BOOL    PreQueueCommit
    )
{
    PSTANDALONE_COMP Standalone;
    BOOL OldState,NewState;
    LPCTSTR Key;
    INFCONTEXT Context;
    LPCTSTR CmdLine;
    TCHAR CurDir[MAX_PATH];
    BOOL b;
    LPCTSTR Description;
    TCHAR Text[150];
    TCHAR Text2[350];
    TCHAR *p;
    DWORD ExitCode;
    DWORD d;
    DWORD dSetupMode;

    //
    // Find the component.
    //
    for(Standalone=StandaloneComponents; Standalone; Standalone=Standalone->Next) {
        if(!lstrcmpi(ComponentId,Standalone->ComponentId)) {
            break;
        }
    }

    if(!Standalone) {
        d = NO_ERROR;
        goto c0;
    }

    //
    // Determine whether this component wants to be invoked pre or post-queue.
    // If this doesn't match the notification we're processing then bail.
    //
    b = FALSE;
    if(SetupFindFirstLine(Standalone->Inf,ComponentId,TEXT("InvokeBeforeQueueCommit"),&Context)
    && SetupGetIntField(&Context,1,&d)) {
        b = (d != 0);
    }
    if((b == FALSE) != (PreQueueCommit == FALSE)) {
        d = NO_ERROR;
        goto c0;
    }

    OldState = Standalone->HelperRoutines.QuerySelectionState(
                    Standalone->HelperRoutines.OcManagerContext,
                    ComponentId,
                    OCSELSTATETYPE_ORIGINAL
                    );

    NewState = Standalone->HelperRoutines.QuerySelectionState(
                    Standalone->HelperRoutines.OcManagerContext,
                    ComponentId,
                    OCSELSTATETYPE_CURRENT
                    );

    dSetupMode = Standalone->HelperRoutines.GetSetupMode(
                    Standalone->HelperRoutines.OcManagerContext);


    // Qualify this setup mode and see if we do anything
    // if no change in state

    // SETUPMODE_UPGRADE
    //                   SETUPMODE_UPGRADEONLY
    //                   SETUPMODE_ADDEXTRACOMPS
    //
    // SETUPMODE_MAINTANENCE
    //                   SETUPMODE_ADDREMOVE
    //                   SETUPMODE_REINSTALL
    //                   SETUPMODE_REMOVEALL
    // SETUPMODE_FRESH


    d = NO_ERROR;

    if ( NewState == OldState ) {

        // no change in slected state What we do depends on the secondary setup modes
        // if Setupmode is AddRemove or Removeall then Skip this

        if ( NewState == 0) {
            goto c0;        // do nothing
        }

        // Mask off Public mode bits
        //
        dSetupMode &= SETUPMODE_PRIVATE_MASK;
        if ( dSetupMode == SETUPMODE_ADDREMOVE || dSetupMode == SETUPMODE_REMOVEALL ) {
            goto c0;        // do nothing
        }
        // What remains here is NewState=1
        // and Reinstall and Upgrade
    }


    Description = NULL;
    if(SetupFindFirstLine(Standalone->Inf,ComponentId,TEXT("OptionDesc"),&Context)) {
        Description = pSetupGetField(&Context,1);
    }
    if(Description) {

        LoadString(
            MyModuleHandle,
            OldState ? (NewState ? IDS_EXTERNAL_UPGRADE : IDS_EXTERNAL_UNINST)
                     : (NewState ? IDS_EXTERNAL_INST : IDS_EXTERNAL_EXAMINE),
            Text,
            sizeof(Text)/sizeof(TCHAR)
            );

        wsprintf(Text2,Text,Description);

        Standalone->HelperRoutines.SetProgressText(
            Standalone->HelperRoutines.OcManagerContext,
            Text2
            );
    } else {
        Standalone->HelperRoutines.SetProgressText(
            Standalone->HelperRoutines.OcManagerContext,
            TEXT("")
            );
    }

    if(OldState == NewState) {
        Key = OldState ? TEXT("InstalledCmd") : TEXT("UninstalledCmd");
    } else {
        Key = OldState ? TEXT("UninstallCmd") : TEXT("InstallCmd");
    }

    d = NO_ERROR;

    if(!SetupFindFirstLine(Standalone->Inf,ComponentId,Key,&Context))
        goto c0;

    // The current Directory to the Suite's Inf Path, with Initial installs "-N" option
    // this may on the CD, with Mainatiance mode it will be the %systemroot%\system32\setup

    SetSuiteCurrentDir(Standalone);

    do {
        if (!(CmdLine = pSetupGetField(&Context,1)))
            break;
        d = RunStandaloneCmd(Standalone, Description, CmdLine);
        if (d != NO_ERROR)
            break;
    } while (SetupFindNextMatchLine(&Context,Key,&Context));

c0:
    Standalone->HelperRoutines.TickGauge(
        Standalone->HelperRoutines.OcManagerContext
        );

    return d;
 }


DWORD
WaitOnApp(
    IN  HANDLE Process,
    OUT PDWORD ExitCode
    )
{
    DWORD dw;
    BOOL Done;
    MSG msg;

    //
    // Process any messages that may already be in the queue.
    //  
    while(PeekMessage(&msg,NULL,0,0,PM_REMOVE)) {
        DispatchMessage(&msg);
    }

    //
    // Wait for process to terminate or more messages in the queue.
    //
    Done = FALSE;
    do {
        switch(MsgWaitForMultipleObjects(1,&Process,FALSE,INFINITE,QS_ALLINPUT)) {

        case WAIT_OBJECT_0:
            //
            // Process has terminated.
            //
            dw = GetExitCodeProcess(Process,ExitCode) ? NO_ERROR : GetLastError();
            Done = TRUE;
            break;

        case WAIT_OBJECT_0+1:
            //
            // Messages in the queue.
            //
            while(PeekMessage(&msg,NULL,0,0,PM_REMOVE)) {
                DispatchMessage(&msg);
            }
            break;

        default:
            //
            // Error.
            //
            dw = GetLastError();
            Done = TRUE;
            break;
        }
    } while(!Done);

    return(dw);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ocmanage\common\ocstate.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    ocstate.c

Abstract:

    Routines to remember and restore the install state of subcomponents.

Author:

    Ted Miller (tedm) 17-Oct-1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


typedef struct _I_S_PARAMS {
    HKEY hKey;
    BOOL Set;
    BOOL AnyError;
    BOOL Simple;
    POC_MANAGER OcManager;
} I_S_PARAMS, *PI_S_PARAMS;


BOOL
pOcPersistantInstallStatesWorker(
    IN POC_MANAGER OcManager,
    IN BOOL        Set,
    IN LONG        ComponentStringId
    );

BOOL
pOcInitInstallStatesStringTableCB(
    IN PVOID               StringTable,
    IN LONG                StringId,
    IN PCTSTR              String,
    IN POPTIONAL_COMPONENT Oc,
    IN UINT                OcStructSize,
    IN PI_S_PARAMS         Params
    );


BOOL
pOcFetchInstallStates(
    IN POC_MANAGER OcManager
    )

/*++

Routine Description:

    This routine retreives stored installation state for all leaf child
    subcomponents, from the registry. It does NOT set or manipulate parent
    selection states.

    Both the selection state and original selection state memebers of the
    optional component structures are set (to the same value) by this routine.

Arguments:

    OcManager - supplies OC Manager context info.

Return Value:

    Boolean value indicating outcome. If FALSE then some catastrophic
    registry error occurred.

--*/

{
    return(pOcPersistantInstallStatesWorker(OcManager,FALSE,-1));
}


BOOL
pOcRememberInstallStates(
    IN POC_MANAGER OcManager
    )

/*++

Routine Description:

    This routine stores installation state for all leaf child
    subcomponents, into the registry. It does NOT set or manipulate parent
    selection states.

    The current selection state is stored, and then the original state is
    reset to the current state.

Arguments:

    OcManager - supplies OC Manager context info.

Return Value:

    Boolean value indicating outcome. If FALSE then some catastrophic
    registry error occurred.

--*/

{
    return(pOcPersistantInstallStatesWorker(OcManager,TRUE,-1));
}


BOOL
pOcSetOneInstallState(
    IN POC_MANAGER OcManager,
    IN LONG        StringId
    )

/*++

Routine Description:

    This routine stores installation state for one single leaf child
    subcomponent, into the registry.

    The current selection state is stored. The original selection state
    is not manipulated.

Arguments:

    OcManager - supplies OC Manager context info.

Return Value:

    Boolean value indicating outcome. If FALSE then some catastrophic
    registry error occurred.

--*/

{
    return(pOcPersistantInstallStatesWorker(OcManager,TRUE,StringId));
}


BOOL
pOcPersistantInstallStatesWorker(
    IN POC_MANAGER OcManager,
    IN BOOL        Set,
    IN LONG        ComponentStringId
    )

/*++

Routine Description:

    Worker routine for fetching and remembering installation states.
    If opens/creates the key used in the registry for persistent state info,
    the enumerates the component string table to examine each subcomponent
    and either fetch or set the install state.

Arguments:

    OcManager - supplies OC Manager context info.

    Set - if 0 then query state from the registry and store in the
        OPTIONAL_COMPONENT structures. If non-0 then set state into registry.
        If 0 then query. Component DLLs will be sent OC_DETECT_INITIAL_STATE
        notifications.

Return Value:

    Boolean value indicating outcome. If FALSE then some catastrophic
    registry error occurred.

--*/

{
    OPTIONAL_COMPONENT Oc;
    LONG l;
    DWORD Disposition;
    I_S_PARAMS Params;

    l = RegCreateKeyEx(
            HKEY_LOCAL_MACHINE,
            szSubcompList,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            (Set || (OcManager->InternalFlags & OCMFLAG_KILLSUBCOMPS)) ? KEY_SET_VALUE : KEY_QUERY_VALUE,
            NULL,
            &Params.hKey,
            &Disposition
            );

    if(l != NO_ERROR) {

        _LogError(
            OcManager,
            Set ? OcErrLevError : OcErrLevFatal,
            MSG_OC_CREATE_KEY_FAILED,
            szSubcompList,
            l
            );

        return(FALSE);
    }

    Params.Set = Set;
    Params.AnyError = FALSE;
    Params.OcManager = OcManager;

    if(ComponentStringId == -1) {
        //
        // Enumerate whole table and operate on each leaf node.
        //
        Params.Simple = FALSE;

        pSetupStringTableEnum(
            OcManager->ComponentStringTable,
            &Oc,
            sizeof(OPTIONAL_COMPONENT),
            (PSTRTAB_ENUM_ROUTINE)pOcInitInstallStatesStringTableCB,
            (LPARAM)&Params
            );

    } else {
        //
        // Operate on one single subcomponent.
        //
        Params.Simple = TRUE;

        if (!pOcComponentWasRemoved(OcManager, ComponentStringId)) {

            pSetupStringTableGetExtraData(
                OcManager->ComponentStringTable,
                ComponentStringId,
                &Oc,
                sizeof(OPTIONAL_COMPONENT)
                );

            pOcInitInstallStatesStringTableCB(
                OcManager->ComponentStringTable,
                ComponentStringId,
                pSetupStringTableStringFromId(OcManager->ComponentStringTable,ComponentStringId),
                &Oc,
                sizeof(OPTIONAL_COMPONENT),
                &Params
                );
        }
    }

    RegCloseKey(Params.hKey);

    return(!Params.AnyError);
}


BOOL
pOcInitInstallStatesStringTableCB(
    IN PVOID               StringTable,
    IN LONG                StringId,
    IN PCTSTR              String,
    IN POPTIONAL_COMPONENT Oc,
    IN UINT                OcStructSize,
    IN PI_S_PARAMS         Params
    )
{
    LONG l;
    DWORD Type;
    DWORD Data;
    DWORD Size;
    SubComponentState s;

    //
    // If this is not a leaf/child component, ignore it.
    //
    if(Oc->FirstChildStringId == -1) {

        if(Params->Set) {

            Data = (Oc->SelectionState == SELSTATE_NO) ? 0 : 1;

            if( ((Params->OcManager)->SetupMode & SETUPMODE_PRIVATE_MASK) == SETUPMODE_REMOVEALL ) {

                RegDeleteValue(Params->hKey,String);

            } else {
                l = RegSetValueEx(Params->hKey,String,0,REG_DWORD,(CONST BYTE *)&Data,sizeof(DWORD));
                if(l != NO_ERROR) {

                   Params->AnyError = TRUE;

                    _LogError(
                        Params->OcManager,
                        OcErrLevError,
                        MSG_OC_CANT_REMEMBER_STATE,
                        Oc->Description,
                        l
                        );
                }
            }
        } else {

            // kill the entry from the registry before starting, if indicated

            if (Params->OcManager->InternalFlags & OCMFLAG_KILLSUBCOMPS)
                l = RegDeleteValue(Params->hKey,String);

            // Check the registery and see if we have dealt with this component before
            // Data should contain 0/1 depending on the current installed state
            //
            // If the entry does not exist the data type/size is not valid
            // then we don't have Prior knowlege of component.
            //
            // also check the inf settting for installation state
            
            Size = sizeof(DWORD);

            l = RegQueryValueEx(Params->hKey,String,NULL,&Type,(LPBYTE)&Data,&Size);

            switch (Oc->InstalledState)
            {
            case INSTSTATE_YES:
                Data = 1;
                break;
            case INSTSTATE_NO:
                Data = 0;
                break;
            }

            if((l != NO_ERROR) || (Size != sizeof(DWORD)) || ((Type != REG_DWORD) && (Type != REG_BINARY))) {

                // Nope, never seen it, Set Data to Uninstalled
                // and flag this item as new

                Data = 0;
                Oc->InternalFlags |= OCFLAG_NEWITEM;

            } else {

                // have seen it before, Data contains it's current install state
                // Flag this component that it had an initial install state
                Oc->InternalFlags |= OCFLAG_ANYORIGINALLYON;
            }

            //
            // Now call out to the component dll to ask whether it wants to
            // override the value we decided on.
            //
            s = OcInterfaceQueryState(
                Params->OcManager,
                pOcGetTopLevelComponent(Params->OcManager,StringId),
                String,
                OCSELSTATETYPE_ORIGINAL
                );

            switch(s) {
            case SubcompUseOcManagerDefault:
                Oc->SelectionState = Data ? SELSTATE_YES : SELSTATE_NO;
                break;
            case SubcompOn:
                Oc->SelectionState = SELSTATE_YES;
                Oc->InternalFlags |= OCFLAG_ANYORIGINALLYON;
                break;
            case SubcompOff:
                Oc->SelectionState = SELSTATE_NO;
                Oc->InternalFlags |= OCFLAG_ANYORIGINALLYOFF;
                break;
            }
        }

        pSetupStringTableSetExtraData(StringTable,StringId,Oc,OcStructSize);

        if(!Params->Simple) {

            Oc->OriginalSelectionState = Oc->SelectionState;
            pSetupStringTableSetExtraData(StringTable,StringId,Oc,OcStructSize);

            pOcUpdateParentSelectionStates(Params->OcManager,NULL,StringId);
        }
    }

    return(TRUE);
}

/*
 * this function is exported to allow external code to
 * access the installation states
 */

UINT
OcComponentState(
    LPCTSTR component,
    UINT    operation,
    DWORD  *val
    )
{
    HKEY hkey;
    LONG rc;
    DWORD dw;
    DWORD size;

    sapiAssert(val);

    rc = RegCreateKeyEx(
            HKEY_LOCAL_MACHINE,
            szSubcompList,
            0,
            NULL,
            REG_OPTION_NON_VOLATILE,
            (operation == infQuery) ? KEY_QUERY_VALUE : KEY_SET_VALUE,
            NULL,
            &hkey,
            &dw
            );

    if (rc != ERROR_SUCCESS)
        return rc;

    switch (operation) {

    case infQuery:
        rc = RegQueryValueEx(hkey, component, NULL, &dw, (LPBYTE)val, &size);
        if (rc == ERROR_FILE_NOT_FOUND) {
            *val = 0;
            rc = ERROR_SUCCESS;
        }
        break;

    case infSet:
        if (*val == SELSTATE_NO || *val == SELSTATE_YES) {
            dw = (*val == SELSTATE_NO) ? 0 : 1;
            rc = RegSetValueEx(hkey, component, 0, REG_DWORD, (CONST BYTE *)&dw, sizeof(DWORD));
            break;
        }
        // pass through

    default:
        rc = ERROR_INVALID_PARAMETER;
        break;
    }

    RegCloseKey(hkey);

    *val = (*val == 0) ? SELSTATE_NO : SELSTATE_YES;

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ocmanage\common\unicode\precomp.h ===
#include "oc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ocmanage\generic\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.inc

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Pat Styles (patst)  Jan-20-1998

!ENDIF

INCLUDES=..;..\..\inc;..\..\..\inc

MAJORCOMP=ocgen

TARGETPATH=..\..\obj
TARGETTYPE=DYNLINK

DLLDEF=..\ocgen.def
DLLENTRY=DllMain
USE_MSVCRT=1

SOURCES=            \
  ..\ocgen.cpp      \
  ..\util.cpp       \
  ..\ocgen.rc

TARGETLIBS=$(SDK_LIB_PATH)\user32.lib       \
         $(SDK_LIB_PATH)\gdi32.lib          \
         $(SDK_LIB_PATH)\kernel32.lib       \
         $(SDK_LIB_PATH)\advapi32.lib       \
         $(SDK_LIB_PATH)\comctl32.lib       \
         $(SDK_LIB_PATH)\ole32.lib          \
         $(SDK_LIB_PATH)\shlwapi.lib        \
         $(SDK_LIB_PATH)\netapi32.lib       \
         $(SDK_LIB_PATH)\setupapi.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ocmanage\common\ansi\precomp.h ===
#include "oc.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ocmanage\common\sources.inc ===
MAJORCOMP=ocmanage

!include $(PROJECT_ROOT)\ntsetup\sources.inc

TARGETPATH=..\..\$(_OBJ_DIR)
TARGETTYPE=DYNLINK

INCLUDES=..;..\..\inc;$(WINDOWS_INC_PATH);$(BASE_INC_PATH)



DLLDEF=..\ocmanage.def
DLLENTRY=_DllMainCRTStartup

PASS0_HEADERDIR=$(O)
PASS0_SOURCEDIR=$(O)

SOURCES=\
        ..\dll.c        \
        ..\msg.mc       \
        ..\oc.rc        \
        ..\ocdskspc.c   \
        ..\ochelper.c   \
        ..\ocinterf.c   \
        ..\ocmanage.c   \
        ..\ocmisc.c     \
        ..\ocpage.c     \
        ..\ocsetup.c    \
        ..\ocstalon.c   \
        ..\ocstate.c    \
        ..\ocwizard.c

TARGETLIBS= \
         $(SDK_LIB_PATH)\user32.lib         \
         $(SDK_LIB_PATH)\gdi32.lib          \
         $(SDK_LIB_PATH)\kernel32.lib       \
         $(SDK_LIB_PATH)\advapi32.lib       \
!if $(PRERELEASE)
         $(SDK_LIB_PATH)\ole32.lib          \
!endif
         $(BASE_LIB_PATH)\spapip.lib
         

PRECOMPILED_INCLUDE=precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj

LINKER_FLAGS=/SWAPRUN:CD
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ocmanage\generic\util.cpp ===
/*
 *  Copyright (c) 1996  Microsoft Corporation
 *
 *  Module Name:
 *
 *      util.cpp
 *
 *  Abstract:
 *
 *      This file communicates with  exchange
 *
 *  Author:
 *
 *      Pat Styles (patst) 25-March-1997
 *
 *  Environment:
 *
 *    User Mode
 */

#define _UTIL_CPP_
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <assert.h>
#include <tchar.h>
#include <time.h>
#include "ocgen.h"
#pragma hdrstop

TCHAR glabel[] = TEXT("\n[OCGEN] ");

// for logging

#define gsLogFile           TEXT("%windir%\\ocgen.log")
#define gsLogCompletionMsg  TEXT(" - complete\r\n")
#define gsLogInitMsg        TEXT("\r\n\r\nInitialize setup: OCGEN.DLL %s %s\r\n")

// for trace statements

#define gsTrace             TEXT("OCGEN.DLL: Trace")

typedef enum {

    nPreInit,               // OC_PREINITIALIZE
    nInit,                  // OC_INIT_COMPONENT
    nSetLang,               // OC_SET_LANGUAGE
    nQueryImage,            // OC_QUERY_IMAGE
    nRequestPages,          // OC_REQUEST_PAGES
    nQueryChangeSel,        // OC_QUERY_CHANGE_SEL_STATE
    nCalcSpace,             // OC_CALC_DISK_SPACE
    nQueueFile,             // OC_QUEUE_FILE_OPS
    nQueueNot,              // OC_NOTIFICATION_FROM_QUEUE
    nQueryStep,             // OC_QUERY_STEP_COUNT
    nComplete,              // OC_COMPLETE_INSTALLATION
    nCleanup,               // OC_CLEANUP
    nQueryState,            // OC_QUERY_STATE
    nNeedMedia,             // OC_NEED_MEDIA
    nAboutToCommit,         // OC_ABOUT_TO_COMMIT_QUEUE
    nQuerySkip,             // OC_QUERY_SKIP_PAGE  
    nWizardCreated,         // OC_WIZARD_CREATED
    nExtraRoutines,         // OC_EXTRA_ROUTINES
    nMaximum
} notifications;

typedef struct _OcMsgs {
    DWORD  msg;
    TCHAR *desc;
} OcMsgs;

OcMsgs gMsgs[nMaximum] = {
    {OC_PREINITIALIZE,          TEXT("OC_PREINITIALIZE")},
    {OC_INIT_COMPONENT,         TEXT("OC_INIT_COMPONENT")},
    {OC_SET_LANGUAGE,           TEXT("OC_SET_LANGUAGE")},
    {OC_QUERY_IMAGE,            TEXT("OC_QUERY_IMAGE")},
    {OC_REQUEST_PAGES,          TEXT("OC_REQUEST_PAGES")},
    {OC_QUERY_CHANGE_SEL_STATE, TEXT("OC_QUERY_CHANGE_SEL_STATE")},
    {OC_CALC_DISK_SPACE,        TEXT("OC_CALC_DISK_SPACE")},
    {OC_QUEUE_FILE_OPS,         TEXT("OC_QUEUE_FILE_OPS")},
    {OC_NOTIFICATION_FROM_QUEUE,TEXT("OC_NOTIFICATION_FROM_QUEUE")},
    {OC_QUERY_STEP_COUNT,       TEXT("OC_QUERY_STEP_COUNT")},
    {OC_COMPLETE_INSTALLATION,  TEXT("OC_COMPLETE_INSTALLATION")},
    {OC_CLEANUP,                TEXT("OC_CLEANUP")},
    {OC_QUERY_STATE,            TEXT("OC_QUERY_STATE")},
    {OC_NEED_MEDIA,             TEXT("OC_NEED_MEDIA")},
    {OC_ABOUT_TO_COMMIT_QUEUE,  TEXT("OC_ABOUT_TO_COMMIT_QUEUE")},
    {OC_QUERY_SKIP_PAGE,        TEXT("OC_QUERY_SKIP_PAGE")},
    {OC_WIZARD_CREATED,         TEXT("OC_WIZARD_CREATED")},
    {OC_EXTRA_ROUTINES,         TEXT("OC_EXTRA_ROUTINES")}
};

TCHAR gUnknown[] = TEXT("Unknown Notification: ");

// determines whether or not to display debug info

DWORD gDebugLevel = (DWORD)-1;

// forward reference

TCHAR *NotificationText(DWORD msg);
BOOL  CheckLevel(DWORD level);

/*
 * DebugTrace()
 */

void DebugTrace(DWORD level, const TCHAR *text)
{
    if (!CheckLevel(level))
        return;

    OutputDebugString(text);
}

/*
 * DebugTraceNL()
 *
 * precedes a trace statement with a newline and id prefix
 */

void DebugTraceNL(DWORD level, const TCHAR *text)
{
    DebugTrace(level, glabel);
    DebugTrace(level, text);
}

/*
 * NotificationText()
 */

TCHAR *NotificationText(DWORD msg)
{
    int i;
    static TCHAR desc[S_SIZE];

    for (i = 0; i < nMaximum; i++)
    {
        if (gMsgs[i].msg == msg)
            return gMsgs[i].desc;
    }

    wsprintf(desc, TEXT("OC_%d: "), msg);
    return desc;
}

/*
 * DebugTraceOCNotification()
 */

void DebugTraceOCNotification(DWORD msg, const TCHAR *component)
{
    DebugTraceNL(1, NotificationText(msg));
    DebugTrace(1, TEXT(": "));
    DebugTrace(1, component);
    DebugTrace(1, TEXT(" - "));
}

/*
 * DebugTraceFileCopy()
 */

void DebugTraceFileCopy(const TCHAR *file)
{
    DebugTraceNL(5, TEXT("TreeCopy: FILE="));
    DebugTrace(5, file);
}

/*
 * DebugTraceFileCopyError()
 */

void DebugTraceFileCopyError()
{
    TCHAR buf[S_SIZE];
    
    _stprintf(buf, FMT(" FAILURE CODE:[%d] "), GetLastError());
    DebugTrace(5, buf);
}

/*
 * DebugTraceDirCopy()
 */

void DebugTraceDirCopy(const TCHAR *dir)
{
    DebugTraceNL(3, TEXT("TreeCopy: DIR="));
    DebugTrace(3, dir);
}


/*
 * CheckLevel()
 */

BOOL CheckLevel(DWORD level)
{
    if (gDebugLevel == (DWORD)-1)
        gDebugLevel = SysGetDebugLevel();

    return (gDebugLevel >= level);
}

/*
 * MsgBox
 *
 */

DWORD MsgBox(HWND hwnd, UINT textID, UINT type, ... )
{
    static BOOL initialize = true;
    static TCHAR caption[S_SIZE];
    TCHAR  text[S_SIZE];
    TCHAR  format[S_SIZE];
    int    len;

    va_list vaList;

    assert(hwnd && textID && type);

    if (initialize)
    {
        len = LoadString(ghinst, IDS_DIALOG_CAPTION, caption, S_SIZE);
        assert(len);
        if (!len) {
            _tcscpy( caption, TEXT("Setup"));
        }
        initialize = false;
    }

    len = LoadString(ghinst, textID, format, S_SIZE);
    assert(len);
    if (!len) {
        _tcscpy( format, TEXT("Unknown Error"));
    }

    va_start(vaList, type);
    tvsprintf(text, format, vaList);
    va_end(vaList);

    return MessageBox(hwnd, text, caption, type);
}

DWORD MsgBox(HWND hwnd, TCHAR *fmt, TCHAR *caption, UINT type, ... )
{
    TCHAR  text[S_SIZE];

    va_list vaList;

    assert(hwnd && text && caption && type);

    va_start(vaList, type);
    tvsprintf(text, fmt, vaList);
    va_end(vaList);

    return MessageBox(hwnd, text, caption, type);
}

DWORD MBox(LPCTSTR fmt, LPCTSTR caption, ... )
{
    TCHAR  text[S_SIZE];

    va_list vaList;

    assert(fmt && caption);

    va_start(vaList, caption);
    tvsprintf(text, fmt, vaList);
    va_end(vaList);

    return MessageBox(ghwnd, text, caption, MB_ICONINFORMATION | MB_OK);
}

DWORD TMBox(LPCTSTR fmt, ... )
{
    TCHAR  text[S_SIZE];

    va_list vaList;

    assert(fmt);

    va_start(vaList, fmt);
    tvsprintf(text, fmt, vaList);
    va_end(vaList);

    return MessageBox(ghwnd, text, gsTrace, MB_ICONINFORMATION | MB_OK);
}

/*
 * SysGetDebugLevel()
 */

DWORD SysGetDebugLevel()
{
    DWORD rc;
    DWORD err;
    DWORD size;
    DWORD type;
    HKEY  hkey;

    err = RegOpenKey(HKEY_LOCAL_MACHINE, 
                     TEXT("SOFTWARE\\microsoft\\windows\\currentversion\\setup"), 
                     &hkey);

    if (err != ERROR_SUCCESS)
        return 0;

    size = sizeof(DWORD);
    err = RegQueryValueEx(hkey,
                          TEXT("OCGen Debug Level"),
                          0,
                          &type,
                          (LPBYTE)&rc,
                          &size);

    if (err != ERROR_SUCCESS || type != REG_DWORD)
        rc = 0;

    RegCloseKey(hkey);

    return rc;
}

/*
 * TCharStringToAnsiString
 */

DWORD TCharStringToAnsiString(TCHAR *tsz ,char *asz)
{
    DWORD count;

    assert(tsz && asz);

#ifdef UNICODE
    count = WideCharToMultiByte(CP_ACP,
                                0,
                                tsz,
                                -1,
                                NULL,
                                0,
                                NULL,
                                NULL);

    if (!count || count > S_SIZE)
        return count;

    return WideCharToMultiByte(CP_ACP,
                               0,
                               tsz,
                               -1,
                               asz,
                               count,
                               NULL,
                               NULL);
#else
    _tcscpy(asz, tsz);
    return _tcslen(asz);
#endif
}

void logOCNotification(DWORD msg, const TCHAR *component)
{
    log(FMT("[%s - %s]"), component, NotificationText(msg));
}

void logOCNotificationCompletion()
{
    log(gsLogCompletionMsg);
}

void loginit()
{
    HANDLE hfile;
    TCHAR  logfile[MAX_PATH];
    char   fmt[S_SIZE];
    char   output[S_SIZE];
    char   time[S_SIZE];
    char   date[S_SIZE];
    DWORD  bytes;

//#ifdef DEBUG
    TCharStringToAnsiString(gsLogInitMsg, fmt);
    _strdate(date);
    _strtime(time);
    sprintf(output, fmt, date, time);

    // open the log file

    ExpandEnvironmentStrings(gsLogFile, logfile, MAX_PATH);

    hfile = CreateFile(logfile,
                       GENERIC_WRITE,
                       0,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL);

    if (hfile == INVALID_HANDLE_VALUE)
        hfile = CreateFile(logfile,
                           GENERIC_WRITE,
                           0,
                           NULL,
                           CREATE_ALWAYS,
                           0,
                           NULL);

    if (hfile != INVALID_HANDLE_VALUE)
    {
        SetFilePointer(hfile, 0, NULL, FILE_END);
        WriteFile(hfile, output, strlen(output) * sizeof(char), &bytes, NULL);
        CloseHandle(hfile);
    }
//#endif
}

void log(TCHAR *fmt, ...)
{
    TCHAR  logfile[MAX_PATH];
    TCHAR  text[S_SIZE];
    char   output[S_SIZE];
    DWORD  bytes;
    HANDLE hfile;

    va_list vaList;

//#ifdef DEBUG
    assert(fmt);

    // create the output string

    va_start(vaList, fmt);
    tvsprintf(text, fmt, vaList);
    va_end(vaList);

    TCharStringToAnsiString(text, output);

    // create the log file name in the root directory

    ExpandEnvironmentStrings(gsLogFile, logfile, MAX_PATH);

    // open the log file

    hfile = CreateFile(logfile,
                       GENERIC_WRITE,
                       0,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL);

    if (hfile != INVALID_HANDLE_VALUE)
    {
        SetFilePointer(hfile, 0, NULL, FILE_END);
        WriteFile(hfile, output, strlen(output) * sizeof(char), &bytes, NULL);
        CloseHandle(hfile);
    }
//#endif
}

void AssureTrailingBackslash(TCHAR *path)
{
    TCHAR *p;
    
    assert(path && *path);

    p = path + _tcslen(path) - 1;
    if (*p != TEXT('\\'))
        _tcscat(path, TEXT("\\"));
}

BOOL IsNT()
{
    DWORD dwver;

    dwver = GetVersion();

    if (dwver < 0x8000000)
        return TRUE;

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ocmanage\generic\resource.h ===
/*
 *  Copyright (c) 1996  Microsoft Corporation
 *
 *  Module Name:
 *
 *      resource.h
 *
 *  Abstract:
 *
 *      This file contains all resources defines for ocgen.dll
 *
 *  Author:
 *
 *      Pat Styles (patst) 21-Nov-1996
 *
 *  Environment:
 *
 *    User Mode
 */

#ifdef _RESOURCE_H_
 #error "resource.h already included!"
#else
 #define _RESOURCE_H_
#endif

#define IDS_DIALOG_CAPTION  1

// !!! WARNING !!! Don't change the resource ID, unless you
// also change the corresponding ID in the affected INF files.
// 
#define IDB_ROOT_AUTO_UPDATE                  1001      // DSIE: Bitmap ID for RootAU.INF
#define IDB_ROOT_IE                           1002
#define IDB_ROOT_WMP                          1003      // ZachD: Bitmap ID for WMPOCM.inf
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ocmanage\generic\ocgen.h ===
/*
 *  Copyright (c) 1996  Microsoft Corporation
 *
 *  Module Name:
 *
 *      ocgen.h
 *
 *  Abstract:
 *
 *      This file defines oc manager generic component
 *
 *  Author:
 *
 *      Pat Styles (patst) Jan-20-1998
 *
 *  Environment:
 *
 *    User Mode
 */

#ifdef _OCGEN_H_
 #error "ocgen.h already included!"
#else
 #define _OCGEN_H_
#endif

#ifndef _WINDOWS_H_
 #include <windows.h>
#endif

#ifndef _TCHAR_H_
 #include <tchar.h>
#endif

#ifndef _SETUPAPI_H_
 #include <setupapi.h>
#endif

#ifndef _OCMANAGE_H_
 #include "ocmanage.h"
#endif

#ifndef _PRSHT_H_
 #include <prsht.h>
#endif

#ifndef _RESOURCE_H_
 #include "resource.h"
#endif

/*-[ types and defines ]-----------------------------------*/

// unicode version is for NT only.

#ifdef UNICODE
 #define NT
#endif
#ifdef ANSI
 #define WIN95
#endif

// just my preference

#define true    TRUE
#define false   FALSE

// to help root out hard coded strings that don't belong

#define FMT     TEXT

#define NullString(a)   *(a) = TCHAR('\0')

// standard buffer sizes

#define S_SIZE           1024
#define SBUF_SIZE        (S_SIZE * sizeof(TCHAR))

// per component data

typedef struct _PER_COMPONENT_DATA {
    struct _PER_COMPONENT_DATA *Next;
    LPCTSTR ComponentId;
    HINF hinf;
    DWORDLONG Flags;
    LANGID LanguageId;
    TCHAR *SourcePath;
    OCMANAGER_ROUTINES HelperRoutines;
    EXTRA_ROUTINES ExtraRoutines;
    HSPFILEQ queue;
    LONG UnattendedOverride;
} PER_COMPONENT_DATA, *PPER_COMPONENT_DATA;

/*-[ functions ]-------------------------------------------*/

// just for utility

#ifdef UNICODE
 #define tsscanf swscanf
 #define tvsprintf vswprintf
#else
 #define tsscanf sscanf
 #define tvsprintf vsprintf
#endif

// from util.cpp

DWORD MsgBox(HWND hwnd, UINT textID, UINT type, ... );
DWORD MsgBox(HWND hwnd, LPCTSTR fmt, LPCTSTR caption, UINT type, ... );
DWORD MBox(LPCTSTR fmt, LPCTSTR caption, ... );
DWORD TMBox(LPCTSTR fmt, ... );
#define mbox MBox
#define tmbox TMBox
void logOCNotification(DWORD msg, const TCHAR *component);
void logOCNotificationCompletion();
void loginit();
void log(TCHAR *fmt, ...);
void AssureTrailingBackslash(TCHAR *path);
BOOL IsNT();

#if defined(__cplusplus)
  extern "C" {
#endif

// from ocgen.cpp

BOOL  ToBeInstalled(TCHAR *component);
BOOL  WasInstalled(TCHAR *component);
DWORD SetupCurrentUser();
DWORD GetMyVersion(DWORD *major, DWORD *minor);
VOID  ReplaceExplorerStartMenuBitmap(VOID);
DWORD OcLog(LPCTSTR ComponentId, UINT level, LPCTSTR sz);

DWORD SysGetDebugLevel();

// from util.cpp

void DebugTraceNL(DWORD level, const TCHAR *text);
void DebugTrace(DWORD level, const TCHAR *text);
void DebugTraceOCNotification(DWORD msg, const TCHAR *component);
void DebugTraceFileCopy(const TCHAR *file);
void DebugTraceFileCopyError();
void DebugTraceDirCopy(const TCHAR *dir);

#if defined(__cplusplus)
  }
#endif

/*-[ global data ]-----------------------------------------*/

#ifndef _OCGEN_CPP_
#define EXTERN extern
#else
 #define EXTERN
#endif

// general stuff

EXTERN HINSTANCE  ghinst;  // app instance handle
EXTERN HWND       ghwnd;   // wizard window handle

// per-component info storage

EXTERN PPER_COMPONENT_DATA gcd;     // array of all components we are installing
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ocmanage\generic\ocgen.cpp ===
/*
 *  Copyright (c) 1996  Microsoft Corporation
 *
 *  Module Name:
 *
 *      ocgen.cpp
 *
 *  Abstract:
 *
 *      This file handles all messages passed by the OC Manager
 *
 *  Author:
 *
 *      Pat Styles (patst) Jan-20-1998
 *
 *  Environment:
 *
 *    User Mode
 */

#define _OCGEN_CPP_
#include <stdlib.h>
#include <assert.h>
#include <tchar.h>
#include <objbase.h>
#include <shlwapi.h>
#include <lm.h>
#include "ocgen.h"
#pragma hdrstop

// also referred to in ocgen.h        // forward reference

DWORD OnPreinitialize();
DWORD OnInitComponent(LPCTSTR ComponentId, PSETUP_INIT_COMPONENT psc);
DWORD OnSetLanguage();
DWORD_PTR OnQueryImage();
DWORD OnSetupRequestPages(UINT type, PVOID srp);
DWORD OnQuerySelStateChange(LPCTSTR ComponentId, LPCTSTR SubcomponentId, UINT state, UINT flags);
DWORD OnCalcDiskSpace(LPCTSTR ComponentId, LPCTSTR SubcomponentId, DWORD addComponent, HDSKSPC dspace);
DWORD OnQueueFileOps(LPCTSTR ComponentId, LPCTSTR SubcomponentId, HSPFILEQ queue);
DWORD OnNotificationFromQueue();
DWORD OnQueryStepCount();
DWORD OnCompleteInstallation(LPCTSTR ComponentId, LPCTSTR SubcomponentId);
DWORD OnCleanup();
DWORD OnQueryState(LPCTSTR ComponentId, LPCTSTR SubcomponentId, UINT state);
DWORD OnNeedMedia();
DWORD OnAboutToCommitQueue(LPCTSTR ComponentId, LPCTSTR SubcomponentId);
DWORD OnQuerySkipPage();
DWORD OnWizardCreated();
DWORD OnExtraRoutines(LPCTSTR ComponentId, PEXTRA_ROUTINES per);

PPER_COMPONENT_DATA AddNewComponent(LPCTSTR ComponentId);
PPER_COMPONENT_DATA LocateComponent(LPCTSTR ComponentId);
VOID  RemoveComponent(LPCTSTR ComponentId);
BOOL  StateInfo(PPER_COMPONENT_DATA cd, LPCTSTR SubcomponentId, BOOL *state);
DWORD RegisterServers(HINF hinf, LPCTSTR component, DWORD state);
DWORD EnumSections(HINF hinf, const TCHAR *component, const TCHAR *key, DWORD index, INFCONTEXT *pic, TCHAR *name);
DWORD RegisterServices(PPER_COMPONENT_DATA cd, LPCTSTR component, DWORD state);
DWORD CleanupNetShares(PPER_COMPONENT_DATA cd, LPCTSTR component, DWORD state);
DWORD RunExternalProgram(PPER_COMPONENT_DATA cd, LPCTSTR component, DWORD state);

// for registering dlls

typedef HRESULT (__stdcall *pfn)(void);

#define KEYWORD_REGSVR       TEXT("RegSvr")
#define KEYWORD_UNREGSVR     TEXT("UnregSvr")
#define KEYWORD_UNINSTALL    TEXT("Uninstall")
#define KEYWORD_SOURCEPATH   TEXT("SourcePath")
#define KEYWORD_DELSHARE     TEXT("DelShare")
#define KEYWORD_ADDSERVICE   TEXT("AddService")
#define KEYWORD_DELSERVICE   TEXT("DelService")
#define KEYWORD_SHARENAME    TEXT("Share")
#define KEYWORD_RUN          TEXT("Run")
#define KEYVAL_SYSTEMSRC     TEXT("SystemSrc")
#define KEYWORD_COMMANDLINE  TEXT("CommandLine")
#define KEYWORD_TICKCOUNT    TEXT("TickCount")

// Services keywords/options
#define KEYWORD_SERVICENAME  TEXT("ServiceName")
#define KEYWORD_DISPLAYNAME  TEXT("DisplayName")
#define KEYWORD_SERVICETYPE  TEXT("ServiceType")
#define KEYWORD_STARTTYPE    TEXT("StartType")
#define KEYWORD_ERRORCONTROL TEXT("ErrorControl")
#define KEYWORD_IMAGEPATH    TEXT("BinaryPathName")
#define KEYWORD_LOADORDER    TEXT("LoadOrderGroup")
#define KEYWORD_DEPENDENCIES TEXT("Dependencies")
#define KEYWORD_STARTNAME    TEXT("ServiceStartName")
#define KEYWORD_PASSWORD     TEXT("Password")

#define KEYVAL_ON            TEXT("on")
#define KEYVAL_OFF           TEXT("off")
#define KEYVAL_DEFAULT       TEXT("default")

const char gszRegisterSvrRoutine[]   = "DllRegisterServer";
const char gszUnregisterSvrRoutine[] = "DllUnregisterServer";
BOOL g_fRebootNeed = FALSE;

PPER_COMPONENT_DATA _cd;

void av()
{
    _cd = NULL;
    _cd->hinf = NULL;
}


/*
 * called by CRT when _DllMainCRTStartup is the DLL entry point
 */

BOOL
WINAPI
DllMain(
    IN HINSTANCE hinstance,
    IN DWORD     reason,
    IN LPVOID    reserved
    )
{
    BOOL b;

    UNREFERENCED_PARAMETER(reserved);

    b = true;

    switch(reason)
    {
    case DLL_PROCESS_ATTACH:
        ghinst = hinstance;
        loginit();

        // Fall through to process first thread

    case DLL_THREAD_ATTACH:
        b = true;
        break;

    case DLL_PROCESS_DETACH:
        break;

    case DLL_THREAD_DETACH:
        break;
    }

    return(b);
}


DWORD_PTR
OcEntry(
    IN     LPCTSTR ComponentId,
    IN     LPCTSTR SubcomponentId,
    IN     UINT    Function,
    IN     UINT    Param1,
    IN OUT PVOID   Param2
    )
{
    DWORD_PTR rc;

    DebugTraceOCNotification(Function, ComponentId);
    logOCNotification(Function, ComponentId);

    switch(Function)
    {
    case OC_PREINITIALIZE:
        rc = OnPreinitialize();
        break;

    case OC_INIT_COMPONENT:
        rc = OnInitComponent(ComponentId, (PSETUP_INIT_COMPONENT)Param2);
        break;

    case OC_EXTRA_ROUTINES:
        rc = OnExtraRoutines(ComponentId, (PEXTRA_ROUTINES)Param2);
        break;

    case OC_SET_LANGUAGE:
        rc = OnSetLanguage();
        break;

    case OC_QUERY_IMAGE:
        rc = OnQueryImage();
        break;

    case OC_REQUEST_PAGES:
        rc = OnSetupRequestPages(Param1, Param2);
        break;

    case OC_QUERY_CHANGE_SEL_STATE:
        rc = OnQuerySelStateChange(ComponentId, SubcomponentId, Param1, (UINT)((UINT_PTR)Param2));
        break;

    case OC_CALC_DISK_SPACE:
        rc = OnCalcDiskSpace(ComponentId, SubcomponentId, Param1, Param2);
        break;

    case OC_QUEUE_FILE_OPS:
        rc = OnQueueFileOps(ComponentId, SubcomponentId, (HSPFILEQ)Param2);
        break;

    case OC_NOTIFICATION_FROM_QUEUE:
        rc = OnNotificationFromQueue();
        break;

    case OC_QUERY_STEP_COUNT:
        rc = OnQueryStepCount();
        break;

    case OC_COMPLETE_INSTALLATION:
        rc = OnCompleteInstallation(ComponentId, SubcomponentId);
        break;

    case OC_CLEANUP:
        rc = OnCleanup();
        break;

    case OC_QUERY_STATE:
    rc = OnQueryState(ComponentId, SubcomponentId, Param1);
        break;

    case OC_NEED_MEDIA:
        rc = OnNeedMedia();
        break;

    case OC_ABOUT_TO_COMMIT_QUEUE:
        rc = OnAboutToCommitQueue(ComponentId,SubcomponentId);
        break;

    case OC_QUERY_SKIP_PAGE:
        rc = OnQuerySkipPage();
        break;

    case OC_WIZARD_CREATED:
        rc = OnWizardCreated();
        break;

    default:
        rc = NO_ERROR;
        break;
    }

    DebugTrace(1, TEXT("processing completed"));
    logOCNotificationCompletion();

    return rc;
}

/*-------------------------------------------------------*/
/*
 * OC Manager message handlers
 *
 *-------------------------------------------------------*/


/* OnPreinitialize()
 *
 * handler for OC_PREINITIALIZE
 */

DWORD
OnPreinitialize(
    VOID
    )
{
#ifdef ANSI
    return OCFLAG_ANSI;
#else
    return OCFLAG_UNICODE;
#endif
}

/*
 * OnInitComponent()
 *
 * handler for OC_INIT_COMPONENT
 */

DWORD OnInitComponent(LPCTSTR ComponentId, PSETUP_INIT_COMPONENT psc)
{
    PPER_COMPONENT_DATA cd;
    INFCONTEXT context;
    TCHAR buf[256];
    HINF hinf;
    BOOL rc;

 // assert(0);
 // av();

    // add component to linked list

    if (!(cd = AddNewComponent(ComponentId)))
        return ERROR_NOT_ENOUGH_MEMORY;

    // store component inf handle

    cd->hinf = (psc->ComponentInfHandle == INVALID_HANDLE_VALUE)
                                           ? NULL
                                           : psc->ComponentInfHandle;

    // open the inf

    if (cd->hinf)
        SetupOpenAppendInfFile(NULL, cd->hinf,NULL);

    // copy helper routines and flags

    cd->HelperRoutines = psc->HelperRoutines;

    cd->Flags = psc->SetupData.OperationFlags;

    cd->SourcePath = NULL;

#if 0
    // Setup the SourcePath.  Read inf and see if we should use the NT setup source.
    // If so, set to null and setupapi will take care of this for us.  If there is
    // something specified in the inf, use it, otherwise use what is passed to us.

    *buf = 0;
    rc = SetupFindFirstLine(cd->hinf,
                            ComponentId,
                            KEYWORD_SOURCEPATH,
                            &context);

    if (rc) {

        rc = SetupGetStringField(&context,
                                 1,
                                 buf,
                                 sizeof(buf) / sizeof(TCHAR),
                                 NULL);

    }

    if (!_tcsicmp(buf, KEYVAL_SYSTEMSRC)) {

        cd->SourcePath = NULL;

    } else {

        cd->SourcePath = (TCHAR *)LocalAlloc(LMEM_FIXED, SBUF_SIZE);
        if (!cd->SourcePath)
            return ERROR_CANCELLED;

        if (!*buf)
            _tcscpy(cd->SourcePath, psc->SetupData.SourcePath);
        else
            ExpandEnvironmentStrings(buf, cd->SourcePath, S_SIZE);
    }

#endif

    // play

    srand(GetTickCount());

    return NO_ERROR;
}

/*
 * OnExtraRoutines()
 *
 * handler for OC_EXTRA_ROUTINES
 */

DWORD OnExtraRoutines(LPCTSTR ComponentId, PEXTRA_ROUTINES per)
{
    PPER_COMPONENT_DATA cd;

    if (!(cd = LocateComponent(ComponentId)))
        return NO_ERROR;

    memcpy(&cd->ExtraRoutines, per, per->size);

    return NO_ERROR;
}

/*
 * OnSetLanguage()
 *
 * handler for OC_SET_LANGUAGE
 */

DWORD OnSetLanguage()
{
    return false;
}

/*
 * OnSetLanguage()
 *
 * handler for OC_SET_LANGUAGE
 */

DWORD_PTR OnQueryImage()
{
    return (DWORD_PTR)LoadBitmap(NULL,MAKEINTRESOURCE(32754));     // OBM_CLOSE
}

/*
 * OnSetupRequestPages
 *
 * Prepares wizard pages and returns them to the OC Manager
 */

DWORD OnSetupRequestPages(UINT type, PVOID srp)
{
    return 0;
}

/*
 * OnWizardCreated()
 */

DWORD OnWizardCreated()
{
    return NO_ERROR;
}

/*
 * OnQuerySkipPage()
 *
 * don't let the user deselect the sam component
 */

DWORD OnQuerySkipPage()
{
    return false;
}

/*
 * OnQuerySelStateChange()
 *
 * don't let the user deselect the sam component
 */

DWORD OnQuerySelStateChange(LPCTSTR ComponentId,
                            LPCTSTR SubcomponentId,
                            UINT    state,
                            UINT    flags)
{
    DWORD rc = true;

#if 0
//  if (!(flags & OCQ_ACTUAL_SELECTION)) {
        if (!_tcsicmp(SubcomponentId, TEXT("three"))) {
            if (!state) {
                return false;
            }
        }
        if (!_tcsicmp(ComponentId, TEXT("three"))) {
            if (!state) {
                return false;
            }
        }
        if (!_tcsicmp(SubcomponentId, TEXT("gs7"))) {
            if (state) {
                return false;
            }
        }
        if (!_tcsicmp(ComponentId, TEXT("gs7"))) {
            if (state) {
                return false;
            }
        }
//  }
#endif

    if (!rc && (flags & OCQ_ACTUAL_SELECTION))
        MessageBeep(MB_ICONEXCLAMATION);

    return rc;
}

/*
 * OnCalcDiskSpace()
 *
 * handler for OC_ON_CALC_DISK_SPACE
 */

DWORD OnCalcDiskSpace(LPCTSTR ComponentId,
                      LPCTSTR SubcomponentId,
                      DWORD addComponent,
                      HDSKSPC dspace)
{
    DWORD rc = NO_ERROR;
    TCHAR section[S_SIZE];
    PPER_COMPONENT_DATA cd;

    //
    // Param1 = 0 if for removing component or non-0 if for adding component
    // Param2 = HDSKSPC to operate on
    //
    // Return value is Win32 error code indicating outcome.
    //
    // In our case the private section for this component/subcomponent pair
    // is a simple standard inf install section, so we can use the high-level
    // disk space list api to do what we want.
    //

    if (!(cd = LocateComponent(ComponentId)))
        return NO_ERROR;

    _tcscpy(section, SubcomponentId);

    if (addComponent)
    {
        rc = SetupAddInstallSectionToDiskSpaceList(dspace,
                                                   cd->hinf,
                                                   NULL,
                                                   section,
                                                   0,
                                                   0);
    }
    else
    {
        rc = SetupRemoveInstallSectionFromDiskSpaceList(dspace,
                                                        cd->hinf,
                                                        NULL,
                                                        section,
                                                        0,
                                                        0);
    }

    if (!rc)
        rc = GetLastError();
    else
        rc = NO_ERROR;

    return rc;
}

/*
 * OnQueueFileOps()
 *
 * handler for OC_QUEUE_FILE_OPS
 */

DWORD OnQueueFileOps(LPCTSTR ComponentId, LPCTSTR SubcomponentId, HSPFILEQ queue)
{
    PPER_COMPONENT_DATA cd;
    BOOL                state;
    BOOL                rc;
    INFCONTEXT          context;
    TCHAR               section[256];
    TCHAR               srcpathbuf[256];
    TCHAR              *srcpath;

    if (!(cd = LocateComponent(ComponentId)))
        return NO_ERROR;

    if (!SubcomponentId || !*SubcomponentId)
        return NO_ERROR;

    cd->queue = queue;

    if (!StateInfo(cd, SubcomponentId, &state))
        return NO_ERROR;

    wsprintf(section, SubcomponentId);

    rc = TRUE;
    if (!state) {
        // being uninstalled. Fetch uninstall section name.
        rc = SetupFindFirstLine(cd->hinf,
                                SubcomponentId,
                                KEYWORD_UNINSTALL,
                                &context);

        if (rc) {
            rc = SetupGetStringField(&context,
                                     1,
                                     section,
                                     sizeof(section) / sizeof(TCHAR),
                                     NULL);
        }

        // also, unregister the dlls and kill services before deletion

        SetupInstallServicesFromInfSection(cd->hinf, section, 0);
        SetupInstallFromInfSection(NULL,cd->hinf,section,SPINST_UNREGSVR,NULL,NULL,0,NULL,NULL,NULL,NULL);        
    }

    if (rc) {
        // if uninstalling, don't use version checks
        rc = SetupInstallFilesFromInfSection(cd->hinf,
                                             NULL,
                                             queue,
                                             section,
                                             cd->SourcePath,
                                             state ? SP_COPY_NEWER : 0);
    }

    if (!rc)
        return GetLastError();

    return NO_ERROR;
}

/*
 * OnNotificationFromQueue()
 *
 * handler for OC_NOTIFICATION_FROM_QUEUE
 *
 * NOTE: although this notification is defined,
 * it is currently unimplemented in oc manager
 */

DWORD OnNotificationFromQueue()
{
    return NO_ERROR;
}

/*
 * OnQueryStepCount
 *
 * handler forOC_QUERY_STEP_COUNT
 */

DWORD OnQueryStepCount()
{
    return 2;
}

/*
 * OnCompleteInstallation
 *
 * handler for OC_COMPLETE_INSTALLATION
 */

DWORD OnCompleteInstallation(LPCTSTR ComponentId, LPCTSTR SubcomponentId)
{
    PPER_COMPONENT_DATA cd;
    INFCONTEXT          context;
    TCHAR               section[256];
    BOOL                state;
    BOOL                rc;
    DWORD               Error = NO_ERROR;

    // Do post-installation processing in the cleanup section.
    // This way we know all compoents queued for installation
    // have beein installed before we do our stuff.

    if (!(cd = LocateComponent(ComponentId)))
        return NO_ERROR;

    if (!SubcomponentId || !*SubcomponentId)
        return NO_ERROR;

    if (!StateInfo(cd, SubcomponentId, &state))
        return NO_ERROR;

    wsprintf(section, SubcomponentId);

    rc = TRUE;
    if (!state) {
        // being uninstalled. Fetch uninstall section name.
        rc = SetupFindFirstLine(cd->hinf,
                                SubcomponentId,
                                KEYWORD_UNINSTALL,
                                &context);

        if (rc) {
            rc = SetupGetStringField(&context,
                                     1,
                                     section,
                                     sizeof(section) / sizeof(TCHAR),
                                     NULL);
        }
    }

    if (state) { 
        //
        // installation
        //

        if (rc) {
            // process the inf file
            rc = SetupInstallFromInfSection(NULL,                                // hwndOwner
                                            cd->hinf,                            // inf handle
                                            section,                             // name of component
                                            SPINST_ALL & ~SPINST_FILES,
                                            NULL,                                // relative key root
                                            NULL,                                // source root path
                                            0,                                   // copy flags
                                            NULL,                                // callback routine
                                            NULL,                                // callback routine context
                                            NULL,                                // device info set
                                            NULL);                               // device info struct
    
            if (rc) {
                rc = SetupInstallServicesFromInfSection(cd->hinf, section, 0);
                Error = GetLastError();        
            
                if (!rc && Error == ERROR_SECTION_NOT_FOUND) {
                    rc = TRUE;
                    Error = NO_ERROR;
                }
            
                if (rc) {
                    if (Error == ERROR_SUCCESS_REBOOT_REQUIRED) {
                        cd->HelperRoutines.SetReboot(cd->HelperRoutines.OcManagerContext,TRUE);
                    }
                    Error = NO_ERROR;
                    rc = RunExternalProgram(cd, section, state);            
                }
            }
        }

    } else { 
        
        //
        // uninstallation
        //
    
        if (rc)
        {

            rc = RunExternalProgram(cd, section, state);

        }
        if (rc) {
            
            rc = CleanupNetShares(cd, section, state);

        }
    }

    if (!rc && (Error == NO_ERROR) ) {
        Error = GetLastError( );
    }

    return Error;
}

/*
 * OnCleanup()
 *
 * handler for OC_CLEANUP
 */

DWORD OnCleanup()
{
    return NO_ERROR;
}

/*
 * OnQueryState()
 *
 * handler for OC_QUERY_STATE
 */

DWORD OnQueryState(LPCTSTR ComponentId,
                   LPCTSTR SubcomponentId,
                   UINT    state)
{
    PPER_COMPONENT_DATA cd;

#if 0
    if (!_tcsicmp(SubcomponentId, TEXT("alone2"))
            || !_tcsicmp(ComponentId, TEXT("alone2"))) {
        if (state == OCSELSTATETYPE_CURRENT) {
            if (!_tcsicmp(SubcomponentId, TEXT("alone2"))) {
                return SubcompOff;
            }
        }
    }
#endif
#if 0
	if (state == OCSELSTATETYPE_FINAL) {
        if (!_tcsicmp(SubcomponentId, TEXT("four"))) {
            tmbox(SubcomponentId);
        }
    }
#endif

    return SubcompUseOcManagerDefault;
}

/*
 * OnNeedMedia()
 *
 * handler for OC_NEED_MEDIA
 */

DWORD OnNeedMedia()
{
    return false;
}

/*
 * OnAboutToCommitQueue()
 *
 * handler for OC_ABOUT_TO_COMMIT_QUEUE
 */

DWORD OnAboutToCommitQueue(LPCTSTR ComponentId, LPCTSTR SubcomponentId)
{
    PPER_COMPONENT_DATA cd;
    BOOL                state;
    BOOL                rc;
    INFCONTEXT          context;
    TCHAR               section[256];
    TCHAR               srcpathbuf[256];
    TCHAR              *srcpath;

    if (!(cd = LocateComponent(ComponentId)))
        return NO_ERROR;

    if (!SubcomponentId || !*SubcomponentId)
        return NO_ERROR;

    if (!StateInfo(cd, SubcomponentId, &state))
        return NO_ERROR;

    //
    // only do stuff on uninstall
    //
    if (state) {
        return NO_ERROR;
    }

    // Fetch uninstall section name.
    rc = SetupFindFirstLine(
                    cd->hinf,
                    SubcomponentId,
                    KEYWORD_UNINSTALL,
                    &context);

    if (rc) {
        rc = SetupGetStringField(
                     &context,
                     1,
                     section,
                     sizeof(section) / sizeof(TCHAR),
                     NULL);
    }

    if (rc) 
        rc = SetupInstallServicesFromInfSection(cd->hinf, section, 0);

    if (rc) {
        rc = SetupInstallFromInfSection(
                    NULL,
                    cd->hinf,
                    section,
                    SPINST_ALL & ~SPINST_FILES,
                    NULL,
                    NULL,
                    0,
                    NULL,
                    NULL,
                    NULL,
                    NULL);        
    }
    
    if (rc) {
       SetLastError(NO_ERROR);
    }
    return GetLastError();

}

/*
 * AddNewComponent()
 *
 * add new compononent to the top of the component list
 */

PPER_COMPONENT_DATA AddNewComponent(LPCTSTR ComponentId)
{
    PPER_COMPONENT_DATA data;

    data = (PPER_COMPONENT_DATA)LocalAlloc(LPTR,sizeof(PER_COMPONENT_DATA));
    if (!data)
        return data;

    data->ComponentId = (TCHAR *)LocalAlloc(LMEM_FIXED,
            (_tcslen(ComponentId) + 1) * sizeof(TCHAR));

    if(data->ComponentId)
    {
        _tcscpy((TCHAR *)data->ComponentId, ComponentId);

        // Stick at head of list
        data->Next = gcd;
        gcd = data;
    }
    else
    {
        LocalFree((HLOCAL)data);
        data = NULL;
    }

    return(data);
}

/*
 * LocateComponent()
 *
 * returns a compoent struct that matches the
 * passed component id.
 */

PPER_COMPONENT_DATA LocateComponent(LPCTSTR ComponentId)
{
    PPER_COMPONENT_DATA p;

    for (p = gcd; p; p=p->Next)
    {
        if (!_tcsicmp(p->ComponentId, ComponentId))
            return p;
    }

    return NULL;
}

/*
 * RemoveComponent()
 *
 * yanks a component from our linked list of components
 */

VOID RemoveComponent(LPCTSTR ComponentId)
{
    PPER_COMPONENT_DATA p, prev;

    for (prev = NULL, p = gcd; p; prev = p, p = p->Next)
    {
        if (!_tcsicmp(p->ComponentId, ComponentId))
        {
            LocalFree((HLOCAL)p->ComponentId);

            if (p->SourcePath)
                LocalFree((HLOCAL)p->SourcePath);

            if (prev)
                prev->Next = p->Next;
            else
                gcd = p->Next;

            LocalFree((HLOCAL)p);

            return;
        }
    }
}

// loads current selection state info into "state" and
// returns whether the selection state was changed

BOOL
StateInfo(
    PPER_COMPONENT_DATA cd,
    LPCTSTR             SubcomponentId,
    BOOL               *state
    )
{
    BOOL rc = TRUE;

    assert(state);

	// otherwise, check for a change in installation state
		
    *state = cd->HelperRoutines.QuerySelectionState(cd->HelperRoutines.OcManagerContext,
                                                    SubcomponentId,
                                                    OCSELSTATETYPE_CURRENT);

    if (*state == cd->HelperRoutines.QuerySelectionState(cd->HelperRoutines.OcManagerContext,
                                                         SubcomponentId,
                                                         OCSELSTATETYPE_ORIGINAL))
    {
        // no change
        rc = FALSE;
    }

	// if this is gui mode setup, presume the state has changed to force
	// an installation (or uninstallation)

	if (!(cd->Flags & SETUPOP_STANDALONE) && *state)
		rc = TRUE;

    return rc;
}

#if 0

//
// Andrewr -- get rid of RegisterServices and RegisterServers and have the oc gen component use setupapi instead.
//            this reduces the amount of redundant code
//

DWORD RegisterServices(
    PPER_COMPONENT_DATA cd,
    LPCTSTR component,
    DWORD state)
{
    INFCONTEXT  ic;
    TCHAR       buf[MAX_PATH];
    TCHAR       path[MAX_PATH];
    TCHAR       sname[S_SIZE];
    TCHAR       file[MAX_PATH];
    DWORD       section;
    ULONG       size;
	pfn         pfreg;
    HINSTANCE   hinst;
    HRESULT     hr;
    TCHAR      *keyword;
    SC_HANDLE   schSystem;

    schSystem = OpenSCManager( NULL, NULL, SC_MANAGER_ALL_ACCESS );
    if ( !schSystem ) {
        DWORD dwError = GetLastError( );

        if( !IsNT() && ( ERROR_CALL_NOT_IMPLEMENTED == dwError ) )
        {
            return( NO_ERROR );
        }
        else
        {
            return( dwError );
        }
    }

    if (state) {
        keyword = KEYWORD_ADDSERVICE;
    } else {
        keyword = KEYWORD_DELSERVICE;
    }

    for (section = 1;
         EnumSections(cd->hinf, component, keyword, section, &ic, sname);
         section++)
    {
        INFCONTEXT  sic;
        SC_HANDLE   schService;

        CHAR Temp[SBUF_SIZE];
        TCHAR ServiceName[ SBUF_SIZE ];
        TCHAR DisplayName[ SBUF_SIZE ];
        DWORD ServiceType;
        DWORD StartType;
        DWORD ErrorControl;
        TCHAR ImagePath[ SBUF_SIZE ];
        TCHAR LoadOrder[ SBUF_SIZE ];
        TCHAR Dependencies[ SBUF_SIZE ];
        TCHAR StartName[ SBUF_SIZE ];
        TCHAR Password[ SBUF_SIZE ];

        BOOL fDisplayName  = FALSE;
        BOOL fServiceType  = FALSE;
        BOOL fStartType    = FALSE;
        BOOL fErrorControl = FALSE;
        BOOL fLoadOrder    = FALSE;
        BOOL fDependencies = FALSE;
        BOOL fStartName    = FALSE;
        BOOL fPassword     = FALSE;
        BOOL fDontReboot   = FALSE;

        //
        // Must have ServiceName
        //
        if (!SetupFindFirstLine(cd->hinf, sname, KEYWORD_SERVICENAME, &sic))
        {
            log( TEXT("OCGEN: %s INF error - unable to find %s\r\n"), keyword, KEYWORD_SERVICENAME );
            continue;
        }

        if (!SetupGetStringField(&sic, 1, ServiceName, SBUF_SIZE, NULL))
        {
            log( TEXT("OCGEN: %s INF error - unable to find %s\r\n"), keyword, KEYWORD_SERVICENAME );
            continue;
        }

        if (SetupFindFirstLine(cd->hinf, sname, KEYWORD_STARTTYPE, &sic))
        {
            if (SetupGetStringFieldA(&sic, 1, Temp, SBUF_SIZE, NULL))
            {
                StartType = atoi( Temp );
                fStartType = TRUE;
            }
        }

        if ( state )
        {
            if (SetupFindFirstLine(cd->hinf, sname, KEYWORD_DISPLAYNAME, &sic))
            {
                if (SetupGetStringField(&sic, 1, DisplayName, SBUF_SIZE, NULL))
                {
                    fDisplayName = TRUE;
                }
            }

            if (SetupFindFirstLine(cd->hinf, sname, KEYWORD_SERVICETYPE, &sic))
            {
                if (SetupGetStringFieldA(&sic, 1, Temp, SBUF_SIZE, NULL))
                {
                    ServiceType = atoi( Temp );
                    fServiceType = TRUE;
                }
            }

            if (SetupFindFirstLine(cd->hinf, sname, KEYWORD_ERRORCONTROL, &sic))
            {
                if (SetupGetStringFieldA(&sic, 1, Temp, SBUF_SIZE, NULL))
                {
                    ErrorControl = atoi( Temp );
                    fErrorControl = TRUE;
                }
            }

            //
            // Must have ImagePath
            //
            if (!SetupFindFirstLine(cd->hinf, sname, KEYWORD_IMAGEPATH, &sic))
            {
                log( TEXT("OCGEN: %s INF error - unable to find %s\r\n"), keyword, KEYWORD_IMAGEPATH );
                continue;
            }

            if (!SetupGetStringField(&sic, 1, ImagePath, SBUF_SIZE, NULL))
            {
                log( TEXT("OCGEN: %s INF error - unable to find %s\r\n"), keyword, KEYWORD_IMAGEPATH );
                continue;
            }

            if (SetupFindFirstLine(cd->hinf, sname, KEYWORD_LOADORDER, &sic))
            {
                if (SetupGetStringField(&sic, 1, LoadOrder, SBUF_SIZE, NULL))
                {
                    fLoadOrder = TRUE;
                }
            }

            if (SetupFindFirstLine(cd->hinf, sname, KEYWORD_DEPENDENCIES, &sic))
            {
                if (SetupGetStringField(&sic, 1, Dependencies, SBUF_SIZE-1, NULL))
                {
                    LPTSTR psz = Dependencies;
                    // needs to be a double-null terminated string
                    Dependencies[ lstrlen(Dependencies) + 1] = TEXT('\0');

                    // change commas into NULL characters
                    while ( *psz )
                    {
                        if ( *psz == TEXT(',') )
                        {
                            *psz = TEXT('\0');
                        }
                        psz++;
                    }
                    fDependencies = TRUE;
                }
            }

            if (SetupFindFirstLine(cd->hinf, sname, KEYWORD_STARTNAME, &sic))
            {
                if (SetupGetStringField(&sic, 1, StartName, SBUF_SIZE, NULL))
                {
                    fStartName = TRUE;
                }
            }

            if (SetupFindFirstLine(cd->hinf, sname, KEYWORD_PASSWORD, &sic))
            {
                if (SetupGetStringField(&sic, 1, Password, SBUF_SIZE, NULL))
                {
                    fPassword = TRUE;
                }
            }

            schService = CreateService(
                        schSystem,
                        ServiceName,
                        ( fDisplayName == TRUE  ? DisplayName   : ServiceName ),
                        STANDARD_RIGHTS_REQUIRED | SERVICE_START,
                        ( fServiceType == TRUE  ? ServiceType   : SERVICE_WIN32_OWN_PROCESS),
                        ( fStartType == TRUE    ? StartType     : SERVICE_AUTO_START),
                        ( fErrorControl == TRUE ? ErrorControl  : SERVICE_ERROR_NORMAL),
                        ImagePath,
                        (fLoadOrder == TRUE     ? LoadOrder     : NULL),
                        NULL,   // tag id
                        ( fDependencies == TRUE ? Dependencies  : NULL ),
                        ( fStartName == TRUE    ? StartName     : NULL),
                        ( fPassword == TRUE     ? Password      : NULL ));

            if ( !schService )
            {
                DWORD Error = GetLastError( );
                log( TEXT("OCGEN: CreateService() error 0x%08x\r\n"), Error );
                return Error;
            }

            if ( (!fStartType)
               || ( fStartType && StartType == SERVICE_AUTO_START ))
            {
                if( !StartService( schService, 0, NULL ) )
                {
                    DWORD Error = GetLastError( );
                    switch ( Error )
                    {
                    case ERROR_SERVICE_EXISTS:
                        {
                            log( TEXT("OCGEN: %s was already exists.\r\n"), ServiceName );

                            if ( fStartType && StartType == SERVICE_BOOT_START )
                            {
                                fDontReboot = TRUE;
                            }
                        }
                        break;

                    case ERROR_SERVICE_ALREADY_RUNNING:
                        {
                            log( TEXT("OCGEN: %s was already started.\r\n"), ServiceName );

                            if ( fStartType && StartType == SERVICE_BOOT_START )
                            {
                                fDontReboot = TRUE;
                            }
                        }
                        break;

                    default:
                        log( TEXT("OCGEN: StartService() error 0x%08x\r\n"), Error );
                        return Error;
                    }
                }
            }
        }
        else
        {
            schService = OpenService( schSystem,
                                      ServiceName,
                                      STANDARD_RIGHTS_REQUIRED | DELETE );
            if ( schService )
            {
                SERVICE_STATUS ss;
                DeleteService( schService );
                ControlService( schService, SERVICE_CONTROL_STOP, &ss );
            }

        }

        //
        // BOOT drivers require a reboot unless they were already started.
        //
        if ( schService
           && fStartType && StartType == SERVICE_BOOT_START
           && fDontReboot == FALSE)
        {
            cd->HelperRoutines.SetReboot(cd->HelperRoutines.OcManagerContext, NULL);
        }

        if ( schService )
        {
            CloseServiceHandle( schService );
        }
    }

    return NO_ERROR;
}
#endif
#if 0

DWORD
RegisterServers(
    HINF    hinf,
    LPCTSTR component,
    DWORD   state
    )
{
    INFCONTEXT  ic;
    TCHAR       buf[MAX_PATH];
    TCHAR       path[MAX_PATH];
    TCHAR       sname[S_SIZE];
    TCHAR       file[MAX_PATH];
    DWORD       section;
    ULONG       size;
	pfn         pfreg;
    HINSTANCE   hinst;
    HRESULT     hr;
    TCHAR      *keyword;
    LPCSTR      routine;

    CoInitialize(NULL);

    if (state) {
        keyword = KEYWORD_REGSVR;
        routine = (LPCSTR)gszRegisterSvrRoutine;
    } else {
        keyword = KEYWORD_UNREGSVR;
        routine = (LPCSTR)gszUnregisterSvrRoutine;
    }

    for (section = 1;
         EnumSections(hinf, component, keyword, section, &ic, sname);
         section++)
    {
        if (!SetupGetTargetPath(hinf, NULL, sname, path, sizeof(path), &size))
            continue;
        PathAddBackslash(path);

        do {
            // get fully qualified path to dll to register

            if (!SetupGetStringField(&ic, 0, buf, sizeof(buf), NULL))
                continue;

            _tcscpy(file, path);
            _tcscat(file, buf);

            // call the dll's RegisterServer routine

            if (!(hinst = LoadLibrary(file)))
                continue;

            if (!(pfreg = (pfn)GetProcAddress(hinst, routine)))
                continue;

            hr = pfreg();
            assert(hr == NO_ERROR);

            FreeLibrary(hinst);

            // on to the next

        } while (SetupFindNextLine(&ic, &ic));
    }

	CoUninitialize();

    return TRUE;
}
#endif

                                          /*
 * EnumSections()
 *
 * finds the name of a section for a specified keyword
 */

DWORD
EnumSections(
    HINF hinf,
    const TCHAR *component,
    const TCHAR *key,
    DWORD index,
    INFCONTEXT *pic,
    TCHAR *name
    )
{
    TCHAR section[S_SIZE];

    if (!SetupFindFirstLine(hinf, component, NULL, pic))
        return 0;

    if (!SetupFindNextMatchLine(pic, key, pic))
        return 0;

    if (index > SetupGetFieldCount(pic))
        return 0;

    if (!SetupGetStringField(pic, index, section, SBUF_SIZE, NULL))
        return 0;

    if (name)
        _tcscpy(name, section);

    return SetupFindFirstLine(hinf, section, NULL, pic);
}


DWORD
OcLog(
      LPCTSTR ComponentId,
      UINT level,
      LPCTSTR sz
      )
{
    TCHAR fmt[5000];
    PPER_COMPONENT_DATA cd;

    if (!(cd = LocateComponent(ComponentId)))
        return NO_ERROR;

    assert(cd->ExtraRoutines.LogError);
    assert(level);
    assert(sz);

    _tcscpy(fmt, TEXT("%s: %s"));

    return cd->ExtraRoutines.LogError(cd->HelperRoutines.OcManagerContext,
                                      level,
                                      fmt,
                                      ComponentId,
                                      sz);
}

DWORD
CleanupNetShares(
    PPER_COMPONENT_DATA cd,
    LPCTSTR component,
    DWORD state)
{
    INFCONTEXT  ic;
    TCHAR       sname[S_SIZE];
    DWORD       section;
    TCHAR      *keyword;

    if (state) {
        return NO_ERROR;
    } else {
        keyword = KEYWORD_DELSHARE;
    }

    for (section = 1;
         EnumSections(cd->hinf, component, keyword, section, &ic, sname);
         section++)
    {
        INFCONTEXT  sic;
        NET_API_STATUS netStat;

        CHAR Temp[SBUF_SIZE];
        TCHAR ShareName[ SBUF_SIZE ];

        if (!SetupFindFirstLine(cd->hinf, sname, KEYWORD_SHARENAME, &sic))
        {
            log( TEXT("OCGEN: %s INF error - unable to find %s\r\n"), keyword, KEYWORD_SHARENAME );
            continue;
        }

        if (!SetupGetStringField(&sic, 1, ShareName, SBUF_SIZE, NULL))
        {
            log( TEXT("OCGEN: %s INF error - incorrect %s line\r\n"), keyword, KEYWORD_SHARENAME );
            continue;
        }

#ifdef UNICODE
        netStat = NetShareDel( NULL, ShareName, 0 );
#else // UNICODE
        WCHAR ShareNameW[ SBUF_SIZE ];
        mbstowcs( ShareNameW, ShareName, lstrlen(ShareName));
        netStat = NetShareDel( NULL, ShareNameW, 0 );
#endif // UNICODE
        if ( netStat != NERR_Success )
        {
            log( TEXT("OCGEN: Failed to remove %s share. Error 0x%08x\r\n"), ShareName, netStat );
            continue;
        }

        log( TEXT("OCGEN: %s share removed successfully.\r\n"), ShareName );
    }

    return TRUE;
}

DWORD
RunExternalProgram(
    PPER_COMPONENT_DATA cd,
    LPCTSTR component,
    DWORD state)
{
    INFCONTEXT  ic;
    TCHAR       sname[S_SIZE];
    DWORD       section;
    TCHAR      *keyword;

    keyword = KEYWORD_RUN;

    for (section = 1;
         EnumSections(cd->hinf, component, keyword, section, &ic, sname);
         section++)
    {
        INFCONTEXT  sic;
        TCHAR CommandLine[ SBUF_SIZE ];
        CHAR szTickCount[ SBUF_SIZE ];
        ULONG TickCount;
        BOOL b;
        STARTUPINFO startupinfo;
        PROCESS_INFORMATION process_information;
        DWORD dwErr;

        if (!SetupFindFirstLine(cd->hinf, sname, KEYWORD_COMMANDLINE , &sic))
        {
            log( TEXT("OCGEN: %s INF error - unable to find %s\r\n"), keyword, KEYWORD_COMMANDLINE );
            continue;
        }

        if (!SetupGetStringField(&sic, 1, CommandLine, SBUF_SIZE, NULL))
        {
            log( TEXT("OCGEN: %s INF error - incorrect %s line\r\n"), keyword, KEYWORD_COMMANDLINE );
            continue;
        }

        if (!SetupFindFirstLine(cd->hinf, sname, KEYWORD_TICKCOUNT, &sic))
        {
            log( TEXT("OCGEN: %s INF error - unable to find %s\r\n"), keyword, KEYWORD_TICKCOUNT );
            continue;
        }

        if (!SetupGetStringFieldA(&sic, 1, szTickCount, SBUF_SIZE, NULL))
        {
            log( TEXT("OCGEN: %s INF error - incorrect %s line\r\n"), keyword, KEYWORD_TICKCOUNT );
            continue;
        }

        TickCount = atoi( szTickCount );

        ZeroMemory( &startupinfo, sizeof(startupinfo) );
        startupinfo.cb = sizeof(startupinfo);
        startupinfo.dwFlags = STARTF_USESHOWWINDOW;
        startupinfo.wShowWindow = SW_HIDE | SW_SHOWMINNOACTIVE;

        b = CreateProcess( NULL,
                           CommandLine,
                           NULL,
                           NULL,
                           FALSE,
                           CREATE_DEFAULT_ERROR_MODE,
                           NULL,
                           NULL,
                           &startupinfo,
                           &process_information );
        if ( !b )
        {
            log( TEXT("OCGEN: failed to spawn %s process.\r\n"), CommandLine );
            continue;
        }

        dwErr = WaitForSingleObject( process_information.hProcess, TickCount * 1000 );
        if ( dwErr != NO_ERROR )
        {
            log( TEXT("OCGEN: WaitForSingleObject() failed. Error 0x%08x\r\n"), dwErr );
            TerminateProcess( process_information.hProcess, -1 );
            CloseHandle( process_information.hProcess );
            CloseHandle( process_information.hThread );
            continue;
        }

        CloseHandle( process_information.hProcess );
        CloseHandle( process_information.hThread );

        log( TEXT("OCGEN: %s successfully completed within %u seconds.\r\n"), CommandLine, TickCount );
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ocmanage\sysocmgr\rsrcutil.c ===
#include "precomp.h"
#pragma hdrstop


int
MessageBoxFromMessageV(
    IN HWND     Window,
    IN DWORD    MessageId,
    IN BOOL     SystemMessage,
    IN LPCTSTR  CaptionString,
    IN UINT     Style,
    IN va_list *Args
    )
{
    TCHAR Caption[512];
    TCHAR Buffer[5000];

    if((DWORD_PTR)CaptionString > 0xffff) {
        //
        // It's a string already.
        //
        lstrcpyn(Caption,CaptionString,sizeof(Caption)/sizeof(TCHAR));
    } else {
        //
        // It's a string id
        //
        if(!LoadString(hInst,PtrToUlong(CaptionString),Caption,sizeof(Caption)/sizeof(TCHAR))) {
            Caption[0] = 0;
        }
    }

    FormatMessage(
        SystemMessage ? FORMAT_MESSAGE_FROM_SYSTEM : FORMAT_MESSAGE_FROM_HMODULE,
        NULL,
        MessageId,
        0,
        Buffer,
        sizeof(Buffer) / sizeof(TCHAR),
        Args
        );

    return(MessageBox(Window,Buffer,Caption,Style|MB_SETFOREGROUND));
}


int
MessageBoxFromMessage(
    IN HWND    Window,
    IN DWORD   MessageId,
    IN BOOL    SystemMessage,
    IN LPCTSTR CaptionString,
    IN UINT    Style,
    ...
    )
{
    va_list arglist;
    int i;

    va_start(arglist,Style);

    i = MessageBoxFromMessageV(Window,MessageId,SystemMessage,CaptionString,Style,&arglist);

    va_end(arglist);

    return(i);
}


int
MessageBoxFromMessageAndSystemError(
    IN HWND    Window,
    IN DWORD   MessageId,
    IN DWORD   SystemMessageId,
    IN LPCTSTR CaptionString,
    IN UINT    Style,
    ...
    )
{
    va_list arglist;
    TCHAR Caption[512];
    TCHAR Buffer1[1024];
    TCHAR Buffer2[1024];
    int i;

    //
    // Fetch the non-system part. The arguments are for that part of the
    // message -- the system part has no inserts.
    //
    va_start(arglist,Style);

    FormatMessage(
        FORMAT_MESSAGE_FROM_HMODULE,
        NULL,
        MessageId,
        0,
        Buffer1,
        sizeof(Buffer1) / sizeof(TCHAR),
        &arglist
        );

    va_end(arglist);

    //
    // Now fetch the system part.
    //
    FormatMessage(
        FORMAT_MESSAGE_FROM_SYSTEM,
        NULL,
        MessageId,
        0,
        Buffer2,
        sizeof(Buffer2) / sizeof(TCHAR),
        &arglist
        );

    //
    // Now display the message, which is made up of two parts that get
    // inserted into MSG_ERROR_WITH_SYSTEM_ERROR.
    //
    i = MessageBoxFromMessage(
            Window,
            MSG_ERROR_WITH_SYSTEM_ERROR,
            FALSE,
            CaptionString,
            Style,
            Buffer1,
            Buffer2
            );

    return(i);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ocmanage\sysocmgr\res.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by res.rc
//
#define IDS_ERROR                       1
#define IDS_WINNT_SETUP                 2
#define IDS_WIN9X_SETUP                 3
#define IDS_OCPAGE_HEADER               4
#define IDS_OCPAGE_SUBHEAD              5
#define IDS_PROGPAGE_HEADER             6
#define IDS_PROGPAGE_SUBHEAD            7
#define IDS_FINAL_HEADER                8
#define IDS_FINAL_SUBHEAD               9
#define IDS_LOGSEVINFO                  10
#define IDS_LOGSEVWARN                  11
#define IDS_LOGSEVERR                   12
#define IDS_LOGSEVFATAL                 13
#define IDS_SETUP                       14
#define IDD_OC_WIZARD_PAGE              101
#define IDT_COMPONENTS                  102
#define IDI_SETUP                       103
#define IDT_INSTRUCTIONS                103
#define IDT_SELECT_COMPONENTS           104
#define IDD_OC_DETAILS_PAGE             104
#define IDT_SPACE_NEEDED_NUM            105
#define IDD_PROGRESS_PAGE               105
#define IDT_SPACE_AVAIL_NUM             106
#define IDD_FINAL                       106
#define IDT_TIP                         107
#define IDT_INSTALLED_COUNT             108
#define IDA_FILECOPY                    108
#define IDD_STARTING                    110
#define IDD_FINISHING                   111
#define IDB_WATERMARK1_16               112
#define IDB_WATERMARK1_256              113
#define IDB_WELCOME                     114
#define IDC_LISTVIEW                    1000
#define IDB_DETAILS                     1001
#define IDB_RESET                       1003
#define IDC_BUTTON1                     1005
#define IDC_LISTBOX                     1006
#define IDC_PROGRESS                    1009
#define IDA_EXTERNAL_PROGRAM            1010
#define IDT_SUBHEAD                     1013
#define IDT_COMP_TITLE                  1014
#define IDT_THERM_LABEL                 1015
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        114
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1016
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ocmanage\sysocmgr\sysocmgr.h ===
//
// NT Header Files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <prsht.h>
#include <commctrl.h>
#include <setupapi.h>
#include <spapip.h>
#include <ocmanage.h>

#include <setuplog.h>

#include "ocmgrlib.h"
#include "res.h"
#include "msg.h"


//
// App instance.
//
extern HINSTANCE hInst;

//
// Global version information structure and macro to tell whether
// the system is NT.
//
extern OSVERSIONINFO OsVersionInfo;
#define IS_NT() (OsVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)

//
// Source path for installation files, etc.
//
extern TCHAR SourcePath[MAX_PATH];
extern TCHAR UnattendPath[MAX_PATH];

extern BOOL bUnattendInstall;

//
// OC Manager context 'handle'
//
extern PVOID OcManagerContext;

//
// Generic app title string id.
//
extern UINT AppTitleStringId;

//
// Flag indicating whether a flag was passed on the cmd line
// indicating that the oc setup wizard page should use the
// external-type progress indicator at all times
//
extern BOOL ForceExternalProgressIndicator;

extern BOOL AllowCancel;

//
// Whether to run without UI
//
extern BOOL QuietMode;

//
// Wizard routines.
//
BOOL
DoWizard(
    IN PVOID OcManagerContext,
    IN HWND StartingMsgWindow,
    IN HCURSOR hOldCursor
    );

//
// Misc routines
//
VOID
OcFillInSetupDataA(
    OUT PSETUP_DATAA SetupData
    );

#ifdef UNICODE
VOID
OcFillInSetupDataW(
    OUT PSETUP_DATAW SetupData
    );
#endif

INT
OcLogError(
    IN OcErrorLevel Level,
    IN LPCTSTR      FormatString,
    ...
    );

//
// Resource-handling functions.
//
int
MessageBoxFromMessageV(
    IN HWND     Window,
    IN DWORD    MessageId,
    IN BOOL     SystemMessage,
    IN LPCTSTR  CaptionString,
    IN UINT     Style,
    IN va_list *Args
    );

int
MessageBoxFromMessage(
    IN HWND    Window,
    IN DWORD   MessageId,
    IN BOOL    SystemMessage,
    IN LPCTSTR CaptionString,
    IN UINT    Style,
    ...
    );

int
MessageBoxFromMessageAndSystemError(
    IN HWND    Window,
    IN DWORD   MessageId,
    IN DWORD   SystemMessageId,
    IN LPCTSTR CaptionString,
    IN UINT    Style,
    ...
    );


#ifdef UNICODE
#define pDbgPrintEx  DbgPrintEx
#else
#define pDbgPrintEx
#endif

#define MyMalloc(sz) ((PVOID)LocalAlloc(LMEM_FIXED,sz))
#define MyFree(ptr) (LocalFree(ptr))
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ocmanage\sysocmgr\log.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    log.c

Abstract:

    Routines for logging actions performed during setup.

Author:

    Ted Miller (tedm) 4-Apr-1995

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

      
#include <tchar.h>
#if 0
#include <wtypes.h>     // to define HRESULT for richedit.h
#include <richedit.h>
#endif
#include "setuplog.h"

//
// Severity descriptions. Initialized in InitializeSetupActionLog.
//
PCSTR SeverityDescriptions[LogSevMaximum];

//
// Constant strings used for logging in various places.
//
PCWSTR szWaitForSingleObject        = L"WaitForSingleObject";
PCWSTR szFALSE                      = L"FALSE";
PCWSTR szSetGroupOfValues           = L"SetGroupOfValues";
PCWSTR szSetArrayToMultiSzValue     = L"SetArrayToMultiSzValue";
PCWSTR szCreateProcess              = L"CreateProcess";
PCWSTR szRegOpenKeyEx               = L"RegOpenKeyEx";
PCWSTR szRegQueryValueEx            = L"RegQueryValueEx";
PCWSTR szRegSetValueEx              = L"RegSetValueEx";
PCWSTR szDeleteFile                 = L"DeleteFile";
PCWSTR szRemoveDirectory            = L"RemoveDirectory";

LPCTSTR szErrorFilename             = TEXT("ocmerr.log");
LPCTSTR szActionFilename            = TEXT("ocmact.log");

//
// This structure is passed as the parameter to DialogBoxParam to provide
// initialization data.
//

typedef struct _LOGVIEW_DIALOG_DATA {
    PCWSTR  LogFileName;                        // actual file used
    PCWSTR  WindowHeading;                      // actual title of main window
} LOGVIEW_DIALOG_DATA, *PLOGVIEW_DIALOG_DATA;


LPTSTR
RetrieveAndFormatMessageV(
    IN LPCTSTR   MessageString,
    IN UINT      MessageId,      OPTIONAL
    IN va_list  *ArgumentList
    )

/*++

Routine Description:

    Format a message string using a message string and caller-supplied
    arguments.

    The message id can be either a message in this dll's message table
    resources or a win32 error code, in which case a description of
    that error is retrieved from the system.

Arguments:

    MessageString - supplies the message text.  If this value is NULL,
        MessageId is used instead

    MessageId - supplies message-table identifier or win32 error code
        for the message.

    ArgumentList - supplies arguments to be inserted in the message text.

Return Value:

    Pointer to buffer containing formatted message. If the message was not found
    or some error occurred retrieving it, this buffer will bne empty.

    Caller can free the buffer with MyFree().

    If NULL is returned, out of memory.

--*/

{
    DWORD d;
    LPTSTR Buffer;
    LPTSTR Message;
    TCHAR ModuleName[MAX_PATH];
    TCHAR ErrorNumber[24];
    PTCHAR p;
    LPTSTR Args[2];

    if(MessageString > SETUPLOG_USE_MESSAGEID) {
        d = FormatMessage(
                FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                MessageString,
                0,
                0,
                (LPTSTR)&Buffer,
                0,
                ArgumentList
                );
    } else {
        d = FormatMessage(
                FORMAT_MESSAGE_ALLOCATE_BUFFER |
                    ((MessageId < MSG_FIRST) ? FORMAT_MESSAGE_FROM_SYSTEM : FORMAT_MESSAGE_FROM_HMODULE),
                (PVOID)hInst,
                MessageId,
                MAKELANGID(LANG_NEUTRAL,SUBLANG_NEUTRAL),
                (LPTSTR)&Buffer,
                0,
                ArgumentList
                );
    }


    if(!d) {
        if(GetLastError() == ERROR_NOT_ENOUGH_MEMORY) {
            return(NULL);
        }

        wsprintf(ErrorNumber, TEXT("%x"), MessageId);
        Args[0] = ErrorNumber;

        Args[1] = ModuleName;

        if(GetModuleFileName(hInst, ModuleName, MAX_PATH)) {
            if(p = _tcschr(ModuleName, TEXT('\\'))) {
                Args[1] = p+1;
            }
        } else {
            ModuleName[0] = 0;
        }

        d = FormatMessage(
                FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ARGUMENT_ARRAY,
                NULL,
                ERROR_MR_MID_NOT_FOUND,
                MAKELANGID(LANG_NEUTRAL,SUBLANG_NEUTRAL),
                (LPTSTR)&Buffer,
                0,
                (va_list *)Args
                );

        if(!d) {
            //
            // Give up.
            //
            return(NULL);
        }
    }

    //
    // Make duplicate using our memory system so user can free with MyFree().
    //
    Message = DuplicateString(Buffer);

    LocalFree((HLOCAL)Buffer);

    return(Message);
}

LPTSTR
RetrieveAndFormatMessage(
    IN LPCTSTR   MessageString,
    IN UINT      MessageId,      OPTIONAL
    ...
    )

/*++

Routine Description:

    Format a message string using a message string and caller-supplied
    arguments.

    The message id can be either a message in this dll's message table
    resources or a win32 error code, in which case a description of
    that error is retrieved from the system.

Arguments:

    MessageString - supplies the message text.  If this value is NULL,
        MessageId is used instead

    MessageId - supplies message-table identifier or win32 error code
        for the message.

    ... - supplies arguments to be inserted in the message text.

Return Value:

    Pointer to buffer containing formatted message. If the message was not found
    or some error occurred retrieving it, this buffer will bne empty.

    Caller can free the buffer with MyFree().

    If NULL is returned, out of memory.

--*/

{
    va_list arglist;
    LPTSTR p;

    va_start(arglist,MessageId);
    p = RetrieveAndFormatMessageV(MessageString,MessageId,&arglist);
    va_end(arglist);

    return(p);
}

static PVOID
pOpenFileCallback(
    IN  PCTSTR  Filename,
    IN  BOOL    WipeLogFile
    )
{
    TCHAR   CompleteFilename[MAX_PATH];
    HANDLE  hFile;

    //
    // Form the pathname of the logfile.
    //
    GetWindowsDirectory(CompleteFilename,MAX_PATH);
    ConcatenatePaths(CompleteFilename,Filename,MAX_PATH,NULL);

    //
    // If we're wiping the logfile clean, attempt to delete
    // what's there.
    //
    if(WipeLogFile) {
        SetFileAttributes(CompleteFilename,FILE_ATTRIBUTE_NORMAL);
        DeleteFile(CompleteFilename);
    }

    //
    // Open existing file or create a new one.
    //
    hFile = CreateFile(
        CompleteFilename,
        GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );

    return (PVOID)hFile;
}

static BOOL
pWriteFile (
    IN  PVOID   LogFile,
    IN  LPCTSTR Buffer
    )
{
    PCSTR   AnsiBuffer;
    BOOL    Status;
    DWORD   BytesWritten;

#ifdef UNICODE
    if(AnsiBuffer = UnicodeToAnsi (Buffer)) {
#else
    if (AnsiBuffer = Buffer) {
#endif
        SetFilePointer (LogFile, 0, NULL, FILE_END);

        Status = WriteFile (
            LogFile,
            AnsiBuffer,
            lstrlenA(AnsiBuffer),
            &BytesWritten,
            NULL
            );
        MyFree (AnsiBuffer);
    } else {
        Status = FALSE;
    }

    return Status;

}

static BOOL
pAcquireMutex (
    IN  PVOID   Mutex
    )

/*++

Routine Description:

    Waits on the log mutex for a max of 1 second, and returns TRUE if the mutex
    was claimed, or FALSE if the claim timed out.

Arguments:

    Mutex - specifies which mutex to acquire.

Return Value:

    TRUE if the mutex was claimed, or FALSE if the claim timed out.

--*/


{
    DWORD rc;

    if (!Mutex) {
        SetLastError (ERROR_INVALID_HANDLE);
        return FALSE;
    }

    // Wait a max of 1 second for the mutex
    rc = WaitForSingleObject (Mutex, 1000);
    if (rc != WAIT_OBJECT_0) {
        SetLastError (ERROR_EXCL_SEM_ALREADY_OWNED);
        return FALSE;
    }

    return TRUE;
}


LPCTSTR
MyLoadString(
    IN UINT StringId
    )

/*++

Routine Description:

    Retrieve a string from the string resources of this module.

Arguments:

    StringId - supplies string table identifier for the string.

Return Value:

    Pointer to buffer containing string. If the string was not found
    or some error occurred retrieving it, this buffer will bne empty.

    Caller can free the buffer with MyFree().

    If NULL is returned, out of memory.

--*/

{
    TCHAR Buffer[4096];
    UINT Length;

    Length = LoadString(hInst,StringId,Buffer,sizeof(Buffer)/sizeof(TCHAR));
    if(!Length) {
        Buffer[0] = 0;
    }

    return(DuplicateString(Buffer));
}


VOID
InitializeSetupLog(
    IN  PSETUPLOG_CONTEXT   Context
    )

/*++

Routine Description:

     Initialize the setup action log. This file is a textual description
     of actions performed during setup.

     The log file is called setuplog.txt and it exists in the windows dir.

Arguments:

    Context - context structrure used by Setuplog.

Return Value:

    Boolean value indicating whether initialization was sucessful.

--*/

{
    UINT    i;

    Context->OpenFile = pOpenFileCallback;
    Context->CloseFile = CloseHandle;
    Context->AllocMem = MyMalloc;
    Context->FreeMem = MyFree;
    Context->Format = RetrieveAndFormatMessageV;
    Context->Write = pWriteFile;
    Context->Lock = pAcquireMutex;
    Context->Unlock = ReleaseMutex;

    Context->Mutex = CreateMutex(NULL,FALSE,TEXT("SetuplogMutex"));

    //
    // Initialize the log severity descriptions.
    //
    for(i=0; i < LogSevMaximum; i++) {
        Context->SeverityDescriptions[i] = MyLoadString(IDS_LOGSEVINFO+i);
    }

    SetuplogInitializeEx(Context,
                         FALSE,
                         szActionFilename,
                         szErrorFilename,
                         0,
                         0);
    
    SetuplogError(
        LogSevInformation,
        SETUPLOG_USE_MESSAGEID,
        MSG_LOG_GUI_START,
        0,0);

}

VOID
TerminateSetupLog(
    IN  PSETUPLOG_CONTEXT   Context
    )

/*++

Routine Description:

    Close the Setup log and free resources.

Arguments:

    Context - context structrure used by Setuplog.

Return Value:

    None.

--*/

{
    UINT    i;

    if(Context->Mutex) {
        CloseHandle(Context->Mutex);
        Context->Mutex = NULL;
    }

    for (i=0; i<LogSevMaximum; i++) {
        if (Context->SeverityDescriptions[i]) {
            MyFree (Context->SeverityDescriptions[i]);
        }
    }

    SetuplogTerminate();
}



// all this stuff is from syssetup's setuplog code


#if 0

DWORD CALLBACK
EditStreamCallback (
    IN HANDLE   hLogFile,
    IN LPBYTE   Buffer,
    IN LONG     cb,
    IN PLONG    pcb
    )

/*++

Routine Description:

    Callback routine used by the rich edit control to read in the log file.

Arguments:

    hLogFile - handle of file to read.  This module provides the value through
        the EDITSTREAM structure.

    Buffer - address of buffer that receives the data

    cb - number of bytes to read

    pcb - address of number of bytes actually read

Return Value:

    0 to continue the stream operation, or nonzero to abort it.

--*/

{
    DWORD error;

    if (!ReadFile (hLogFile, Buffer, cb, pcb, NULL)) {
        error = GetLastError();
        return error;
    }

    return 0;
}

BOOL
FormatText (
    IN HWND hWndRichEdit
    )

/*++

Routine Description:

    Modify the contents of the rich edit control to make the log file look
    prettier.  The modifications are driven by the array FormatStrings.  It
    contains a list of strings to search for, and modifications to make when
    a target string is found.

Arguments:

    hWndRichEdit - handle to the Rich Edit control.

Return Value:

    Boolean indicating whether routine was successful.

--*/

{

    //
    // separate items in the log with a horizontal line
    //

    PCWSTR      NewTerm = L"----------------------------------------"
        L"----------------------------------------\r\n\r\n";

    FINDTEXT    FindText;       // target text to change
    INT         Position;       // start of where target was found
    INT         LineIndex;      // index of line containing target
    CHARRANGE   SelectRange;    // range where target was found
    CHARFORMAT  NewFormat;      // structure to hold our format changes
    INT         i;              // loop counter
    PWSTR       pw;             // temporary pointer
    BOOL        Status;         // return status

    //
    // An array of changes we're going to make
    //

    struct tagFormatStrings {
        PCWSTR      Find;       // target string
        PCWSTR      Replace;    // change the target to this
        COLORREF    Color;      // make target text this color
        DWORD       Effects;    // modifications to target's font
    }
    FormatStrings[] = {
        {NULL,  NULL,   RGB(0,150,0),   CFE_UNDERLINE},
        {NULL,  NULL,   RGB(150,150,0), CFE_UNDERLINE},
        {NULL,  NULL,   RGB(255,0,0),   CFE_UNDERLINE},
        {NULL,  NULL,   RGB(255,0,0),   CFE_UNDERLINE|CFE_ITALIC},
        {NULL,  NULL,   RGB(0,0,255),   0}
    };

    //
    // Number of elements in FormatStrings array
    //

    #define FORMATSTRINGSCOUNT  \
        (sizeof(FormatStrings) / sizeof(struct tagFormatStrings))
    sapiAssert(FORMATSTRINGSCOUNT == LogSevMaximum + 1);


    //
    // Initialize those parts of our data structures that won't change
    //

    Status = TRUE;

    NewFormat.cbSize = sizeof(NewFormat);
    FindText.chrg.cpMax = -1;   // search to the end
    for (i=0; i<LogSevMaximum; i++) {   // load severity strings
        if (!(pw = MyLoadString (IDS_LOGSEVINFO+i))) {
            Status = FALSE;
            goto cleanup;
        }
        FormatStrings[i].Find = MyMalloc((lstrlen(pw)+4)*sizeof(WCHAR));
        if(!FormatStrings[i].Find) {
            MyFree(pw);
            Status = FALSE;
            goto cleanup;
        }
        lstrcpy ((PWSTR)FormatStrings[i].Find, pw);
        lstrcat ((PWSTR)FormatStrings[i].Find, L":\r\n");
        MyFree(pw);

        if(pw = MyMalloc((lstrlen(FormatStrings[i].Find)+3)*sizeof(WCHAR))) {
            lstrcpy(pw,FormatStrings[i].Find);
            lstrcat(pw,L"\r\n");
            FormatStrings[i].Replace = pw;
        } else {
            Status = FALSE;
            goto cleanup;
        }
    }

    FormatStrings[LogSevMaximum].Find =
        DuplicateString(SETUPLOG_ITEM_TERMINATOR);
    if (!FormatStrings[LogSevMaximum].Find) {
        Status = FALSE;
        goto cleanup;
    }
    FormatStrings[LogSevMaximum].Replace = DuplicateString (NewTerm);
    if (!FormatStrings[LogSevMaximum].Replace) {
        Status = FALSE;
        goto cleanup;
    }

    //
    // Change 1 string at a time in the rich edit control
    //

    for (i=0; i<FORMATSTRINGSCOUNT; i++) {
        FindText.chrg.cpMin = 0;    // start search at beginning
        FindText.lpstrText = (PWSTR) FormatStrings[i].Find;

         //
        // Search for current target until we've found each instance
        //

        while ((Position = SendMessage
            (hWndRichEdit, EM_FINDTEXT, FR_MATCHCASE, (LPARAM) &FindText))
            != -1) {

            //
            // Verify that the target is at the beginning of the line
            //

            LineIndex = SendMessage (hWndRichEdit, EM_LINEFROMCHAR,
                Position, 0);

            if (SendMessage (hWndRichEdit, EM_LINEINDEX, LineIndex, 0) !=
                Position) {
                FindText.chrg.cpMin = Position + lstrlen (FindText.lpstrText);
                continue;
            }

            //
            // Select the target text and get its format
            //

            SelectRange.cpMin = Position;
            SelectRange.cpMax = Position + lstrlen (FindText.lpstrText);
            SendMessage (hWndRichEdit, EM_EXSETSEL, 0, (LPARAM) &SelectRange);
            SendMessage (hWndRichEdit, EM_GETCHARFORMAT, TRUE,
                (LPARAM) &NewFormat);

            //
            // Modify the target's format
            //

            NewFormat.dwMask = CFM_COLOR | CFM_UNDERLINE | CFM_ITALIC;
            NewFormat.dwEffects &= ~CFE_AUTOCOLOR;
            NewFormat.crTextColor = FormatStrings[i].Color;
            NewFormat.dwEffects |= FormatStrings[i].Effects;
            SendMessage (hWndRichEdit, EM_SETCHARFORMAT, SCF_SELECTION,
                (LPARAM) &NewFormat);

            //
            // Replace the target with new text.  Set the starting point for
            // the next search at the end of the current string
            //

            if (FormatStrings[i].Replace != NULL) {
                SendMessage (hWndRichEdit, EM_REPLACESEL, FALSE,
                    (LPARAM) FormatStrings[i].Replace);
                FindText.chrg.cpMin = Position +
                    lstrlen (FormatStrings[i].Replace);
            } else {
                FindText.chrg.cpMin = Position + lstrlen (FindText.lpstrText);
            }
        }
    }

cleanup:

    for (i=0; i<=LogSevMaximum; i++) {
        if (FormatStrings[i].Find) {
            MyFree (FormatStrings[i].Find);
        }
        if (FormatStrings[i].Replace) {
            MyFree (FormatStrings[i].Replace);
        }
    }
    return Status;
}

BOOL
ReadLogFile (
    PCWSTR  LogFileName,
    HWND    hWndRichEdit
    )

/*++

Routine Description:

    This routine reads the log file and initializes the contents of the Rich
    Edit control.

Arguments:

    LogFileName - path to the file we're going to read.

    hWndRichEdit - handle to the Rich Edit control.

Return Value:

    Boolean indicating whether routine was successful.

--*/

{
    HANDLE      hLogFile;       // handle to log file
    EDITSTREAM  eStream;        // structure used by EM_STREAMIN message

    hLogFile = CreateFile(
        LogFileName,
        GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );

    if (hLogFile == INVALID_HANDLE_VALUE) {
        hLogFile = NULL;
        return FALSE;
    }

    //
    // Read the file into the Rich Edit control.
    //

    eStream.dwCookie = (DWORD) hLogFile;
    eStream.pfnCallback = (EDITSTREAMCALLBACK) EditStreamCallback;
    eStream.dwError = 0;
    SendMessage (hWndRichEdit, EM_STREAMIN, SF_TEXT, (LPARAM) &eStream);
    CloseHandle (hLogFile);

    if (!FormatText (hWndRichEdit)) {
        return FALSE;
    }
    SendMessage (hWndRichEdit, EM_SETMODIFY, TRUE, 0);
    return TRUE;
}

BOOL
DialogProc (
    IN HWND     hDialog,
    IN UINT     message,
    IN WPARAM   wParam,
    IN LPARAM   lParam
    )

/*++

Routine Description:

    This is the window proc for the dialog box.

Arguments:

    Standard window proc arguments.

Return Value:

    Bool that indicates whether we handled the message.

--*/

{
    HWND    hWndRichEdit;       // handle to rich edit window

    switch (message) {

    case WM_INITDIALOG:
        SetWindowText (hDialog,
            ((LOGVIEW_DIALOG_DATA *)lParam)->WindowHeading);
        hWndRichEdit = GetDlgItem (hDialog, IDT_RICHEDIT1);
        if (!ReadLogFile (((LOGVIEW_DIALOG_DATA *)lParam)->LogFileName,
            hWndRichEdit)) {
            MessageBoxFromMessage (hDialog, MSG_UNABLE_TO_SHOW_LOG, NULL,
                IDS_ERROR, MB_OK|MB_ICONSTOP);
            EndDialog (hDialog, FALSE);
        }
        CenterWindowRelativeToParent(hDialog);
        PostMessage(hDialog,WM_APP,0,0);
        break;

    case WM_APP:

        hWndRichEdit = GetDlgItem (hDialog, IDT_RICHEDIT1);
        SendMessage(hWndRichEdit,EM_SETSEL,0,0);
        SendMessage(hWndRichEdit,EM_SCROLLCARET,0,0);
        break;

    case WM_COMMAND:
        switch (wParam) {
        case IDOK:
            EndDialog (hDialog, TRUE);
        default:
            return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

BOOL
ViewSetupActionLog (
    IN HWND     hOwnerWindow,
    IN PCWSTR   OptionalFileName    OPTIONAL,
    IN PCWSTR   OptionalHeading     OPTIONAL
    )

/*++

Routine Description:

    Formats the setup action log and displays it in a window.
    The log file is called setuplog.txt and it exists in the windows dir.

Arguments:

    hOwnerWindow - handle to window that owns the dialog box

    OptionalFileName - full path of the file to be displayed.

    OptionalHeading - text to be shown at the top of the window.

Return Value:

    Boolean value indicating whether the routine was sucessful.

--*/

{
    LOGVIEW_DIALOG_DATA  Global;        // initialization data for dialog box
    WCHAR       TmpFileName[MAX_PATH];  // used to create the log file name
    PCWSTR      TmpHeading;             // used to create the heading
    HANDLE      hRichedDLL;             // DLL used for rich edit
    INT         Status;                 // what we're going to return

    //
    // Form the pathname of the logfile.
    //

    if (!ARGUMENT_PRESENT(OptionalFileName)) {
        GetWindowsDirectory (TmpFileName,MAX_PATH);
        ConcatenatePaths (TmpFileName,SETUPLOG_ERROR_FILENAME,MAX_PATH,NULL);
        Global.LogFileName = DuplicateString (TmpFileName);
    } else {
        if (wcslen(OptionalFileName) > MAX_PATH) {
            Status = 0;
            goto err0;
        }
        Global.LogFileName = DuplicateString (OptionalFileName);
    }

    if (!Global.LogFileName) {
        Status = FALSE;
        goto err0;
    }

    //
    // Form the heading for the dialog box.
    //

    if (!ARGUMENT_PRESENT(OptionalHeading)) {
        TmpHeading = MyLoadString (IDS_LOG_DEFAULT_HEADING);
    } else {
        TmpHeading = DuplicateString (OptionalHeading);
    }
    if (!TmpHeading) {
        Status = FALSE;
        goto err1;
    }

    Global.WindowHeading = FormatStringMessage (IDS_LOG_WINDOW_HEADING,
        TmpHeading, Global.LogFileName);
    if (!Global.WindowHeading) {
        Status = FALSE;
        goto err2;
    }

    //
    // Create the dialog box.
    //

    if (!(hRichedDLL = LoadLibrary (L"RICHED20.DLL"))) {
        Status = FALSE;
        goto err3;
    }
    Status = DialogBoxParam (MyModuleHandle, MAKEINTRESOURCE(IDD_VIEWLOG),
        hOwnerWindow, DialogProc, (LPARAM) &Global);

    //
    // Clean up and return.
    //

    FreeLibrary (hRichedDLL);
err3:
    MyFree (Global.WindowHeading);
err2:
    MyFree (TmpHeading);
err1:
    MyFree (Global.LogFileName);
err0:
    return Status;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ocmanage\sysocmgr\sysocmgr.c ===
#include "precomp.h"
#pragma hdrstop
#include <tchar.h>
#include <stdlib.h>
#include <CRTDBG.H>
#include <winuserp.h>

#if DBG

VOID
AssertFail(
    IN PSTR FileName,
    IN UINT LineNumber,
    IN PSTR Condition
    )
{
    int i;
    CHAR Name[MAX_PATH];
    PCHAR p;
    CHAR Msg[4096];

    //
    // Use dll name as caption
    //
    GetModuleFileNameA(NULL,Name,MAX_PATH);
    if(p = strrchr(Name,'\\')) {
        p++;
    } else {
        p = Name;
    }

    wsprintfA(
        Msg,
        "Assertion failure at line %u in file %s: %s\n\nCall DebugBreak()?",
        LineNumber,
        FileName,
        Condition
        );

    OutputDebugStringA(Msg);

    i = MessageBoxA(
                NULL,
                Msg,
                p,
                MB_YESNO | MB_TASKMODAL | MB_ICONSTOP | MB_SETFOREGROUND
                );

    if(i == IDYES) {
        DebugBreak();
    }
}

#define MYASSERT(x)     if(!(x)) { AssertFail(__FILE__,__LINE__,#x); }

#else

#define MYASSERT( exp )

#endif // DBG

//
// App instance.
//
HINSTANCE hInst;

//
// Global version information structure.
//
OSVERSIONINFO OsVersionInfo;

//
// Specification of master inf, from command line.
//
TCHAR InfPath[MAX_PATH];
TCHAR InfDir[MAX_PATH];

//
// Source path for installation files, etc.
//
TCHAR SourcePath[MAX_PATH];
TCHAR UnattendPath[MAX_PATH];

// If Unattened

BOOL bUnattendInstall;

//
// Whether to force the specified master inf to be treated as new
// (from command line)
//
BOOL ForceNewInf;

//
// whether we need to pass language callback to components
//
BOOL LanguageAware;

//
// Whether to run without UI
//
BOOL QuietMode;

//
// Whether to delete all subcomponent entries listed in the master inf
// (from command line)
//
BOOL KillSubcomponentEntries;

// If set and /U then reboot is suppressed
BOOL bNoReboot;

// if this is set and we're running /unattend, then warn on reboot
BOOL bWarnOnReboot;

// if this is set then we want sysocmgr.exe to enforce the admin check.
BOOL bDoAdminCheck = FALSE;

// Flag for Derminineing Starting or Ending message

BOOL bStarting;
//
// OC Manager context 'handle'
//
PVOID OcManagerContext;

//
// Generic app title string id.
//
UINT AppTitleStringId;

BOOL NeedToReboot;
BOOL SkipBillboard;
BOOL ForceExternalProgressIndicator;
BOOL AllowCancel = TRUE;

VOID
OcSetReboot(
           VOID
           );

//
// Callback routines.
//
OCM_CLIENT_CALLBACKS CallbackRoutines = {
    OcFillInSetupDataA,
    OcLogError,
    OcSetReboot
#ifdef UNICODE
    ,OcFillInSetupDataW
#endif
    ,NULL,                     // No callback for show,hide wizard
    NULL,                      // No callback for progress feedback, they are only needed for setup
    NULL,                      // No callback to set the progress text
    NULL                       // No logging callback.
};

BOOL
DoIt(
    VOID
    );

BOOL
ParseArgs(
         IN int argc,
         IN TCHAR *argv[]
         );

DWORD
ExpandPath(
          IN  LPCTSTR lpFileName,
          OUT LPTSTR lpBuffer,
          OUT LPTSTR *lpFilePart
          );

void
ShutDown()
{


    extern void RestartDialogEx(VOID *, VOID *, DWORD, DWORD);
    if (!bNoReboot)  {
        if ( bUnattendInstall && !bWarnOnReboot ) {

            //
            // NT is always UNICODE and W9x is alwasy Ansii
            //
#ifdef UNICODE
            HANDLE hToken; TOKEN_PRIVILEGES tkp;  // Get a token for this process.

            if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES|TOKEN_QUERY, &hToken))
                sapiAssert("OpenProcessToken");  // Get the LUID for the shutdown privilege.

            LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME, &tkp.Privileges[0].Luid);
            tkp.PrivilegeCount = 1;  // one privilege to set
            tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

            // Get the shutdown privilege for this process.
            AdjustTokenPrivileges(hToken, FALSE, &tkp, 0, (PTOKEN_PRIVILEGES)NULL, 0);

            // Cannot test the return value of AdjustTokenPrivileges.
            if (GetLastError() == ERROR_SUCCESS) {
                sapiAssert("AdjustTokenPrivileges");
            }
#endif
            //
            // Shut down the system and force all applications to close.
            //
            if (! ExitWindowsEx(EWX_REBOOT|EWX_FORCE , 0) ) {
                _RPT0(_CRT_WARN,"Sysocmgr:Failed to ExitWindows");
                sapiAssert(FALSE);
            }

        } else {
            RestartDialogEx(NULL,NULL,EWX_REBOOT, SHTDN_REASON_MAJOR_OPERATINGSYSTEM | SHTDN_REASON_MINOR_RECONFIG \
                                                  | SHTDN_REASON_FLAG_PLANNED );
        }
    }
}


VOID
__cdecl
#ifdef UNICODE
wmain(
#else
main(
#endif
    IN int argc,
    IN TCHAR *argv[]
    )
{
    INITCOMMONCONTROLSEX ControlInit;

    //
    // Preliminaries
    //
    ControlInit.dwSize = sizeof(INITCOMMONCONTROLSEX);
    ControlInit.dwICC = ICC_LISTVIEW_CLASSES    |
                        ICC_TREEVIEW_CLASSES    |
                        ICC_BAR_CLASSES         |
                        ICC_TAB_CLASSES         |
                        ICC_UPDOWN_CLASS        |
                        ICC_PROGRESS_CLASS      |
                        ICC_HOTKEY_CLASS        |
                        ICC_ANIMATE_CLASS       |
                        ICC_WIN95_CLASSES       |
                        ICC_DATE_CLASSES        |
                        ICC_USEREX_CLASSES      |
                        ICC_COOL_CLASSES;

#if (_WIN32_IE >= 0x0400)

    ControlInit.dwICC = ControlInit.dwICC       |
                        ICC_INTERNET_CLASSES    |
                        ICC_PAGESCROLLER_CLASS;

#endif

    InitCommonControlsEx( &ControlInit );

    hInst = GetModuleHandle(NULL);

    OsVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&OsVersionInfo);

    AppTitleStringId = IS_NT() ? IDS_WINNT_SETUP : IDS_WIN9X_SETUP;

    //
    // Parse arguments and do it.
    //
    if (ParseArgs(argc,argv)) {
        DoIt();
    }

    //
    // If we need to reboot, do that now.
    //
    if (NeedToReboot) {
        ShutDown();
    }
}


BOOL
ParseArgs(
         IN int argc,
         IN TCHAR *argv[]
         )

/*++

Routine Description:

    Parse and syntactically validate arguments specified on the comment line.

    The following arguments are valid:

    /a                  forces the external progress indicator on the setup page

    /c                  disallow cancel during final installation phase

    /i:<master_oc_inf>  specifies the master OC inf (required).

    /n                  forces specified master_oc_inf to be treated as new.

    /s:<master_oc_inf>  specifies the source path (required).

    /u:<unattend_spec>  specifies unattended operation parameters.

    /x                  supresses the 'initializing' banner

    /q                  run wizard invisibly

    /r                  supress reboot if need on unattended operation

    /w                  warn on reboot on unattended operation

Arguments:

    Standard main argc/argv.

Return Value:

    Boolean value indicating whether the arguments specified are valid.

    If successful, various global variables will have been filled in.
    If not, the user will have been informed.

--*/

{
    BOOL Valid;
    LPCTSTR SourcePathSpec = NULL;
    LPCTSTR InfSpec = NULL;
    LPCTSTR UnattendSpec = NULL;
    LPTSTR FilePart;
    DWORD u;

    //
    // Skip program name.
    //
    if (argc) {
        argc--;
    }

    Valid = TRUE;
    ForceNewInf = FALSE;
    QuietMode = FALSE;
    KillSubcomponentEntries = FALSE;

    while (Valid && argc--) {

        argv++;

        if ((argv[0][0] == TEXT('-')) || (argv[0][0] == TEXT('/'))) {

            switch (argv[0][1]) {

                case TEXT('a'):
                case TEXT('A'):

                    if (!ForceExternalProgressIndicator && !argv[0][2]) {
                        ForceExternalProgressIndicator = TRUE;
                    } else {
                        Valid = FALSE;
                    }
                    break;

                case TEXT('c'):
                case TEXT('C'):

                    if (AllowCancel && !argv[0][2]) {
                        AllowCancel = FALSE;
                    } else {
                        Valid = FALSE;
                    }
                    break;

                case TEXT('f'):
                case TEXT('F'):

                    ForceNewInf = TRUE;
                    KillSubcomponentEntries = TRUE;
                    break;

                case TEXT('i'):
                case TEXT('I'):

                    if (!InfSpec && (argv[0][2] == TEXT(':')) && argv[0][3]) {

                        InfSpec = &(argv[0][3]);

                    } else {
                        Valid = FALSE;
                    }
                    break;

                case TEXT('l'):
                case TEXT('L'):

                    LanguageAware = TRUE;
                    break;

                case TEXT('n'):
                case TEXT('N'):

                    ForceNewInf = TRUE;
                    break;

                case TEXT('q'):
                case TEXT('Q'):

                    if (!QuietMode && !argv[0][2]) {
                        QuietMode = TRUE;
                        SkipBillboard = TRUE;
                    } else {
                        Valid = FALSE;
                    }
                    break;

                case TEXT('r'):
                case TEXT('R'):

                    bNoReboot = TRUE;
                    break;

                case TEXT('s'):
                case TEXT('S'):

                    if (!SourcePathSpec && (argv[0][2] == TEXT(':')) && argv[0][3]) {

                        SourcePathSpec = &argv[0][3];

                    } else {
                        Valid = FALSE;
                    }
                    break;

                case TEXT('u'):
                case TEXT('U'):
                    //
                    // accept unattend, unattended, u all as the same
                    //
                    if(!_tcsnicmp(&argv[0][1],TEXT("unattended"),10)) {
                        u = 11;
                    } else if(!_tcsnicmp(&argv[0][1],TEXT("unattend"),8)) {
                        u = 9;
                    } else if(!_tcsnicmp(&argv[0][1],TEXT("u"),1)) {
                        u = 2;
                    } else {
                        Valid = FALSE;
                        u = 0;
                    }

                    if (!UnattendSpec ) {

                        bUnattendInstall = TRUE;


                        // If you have the : then you must also have the arg
                        if (argv[0][u] == TEXT(':')) {

                            if ( argv[0][u+1]) {
                                UnattendSpec = &argv[0][u+1];
                            } else {
                                Valid = FALSE;
                            }
                        } else {
                            Valid = FALSE;
                        }
                    } else {
                        Valid = FALSE;
                    }
                    break;

                case TEXT('w'):
                case TEXT('W'):

                    bWarnOnReboot = TRUE;
                    break;

                case TEXT('x'):
                case TEXT('X'):

                    if (!SkipBillboard && !argv[0][2]) {
                        SkipBillboard = TRUE;
                    } else {
                        Valid = FALSE;
                    }
                    break;

                // For ISSUE NTBUG9:295052 (389583): We want to do a top level admin check so we get a more friendly message.
                // It is possible for people to have been using sysocmgr.exe with their own custom master oc.inf
                // (the one passed in with the /i: switch) and they may not need this admin check. So, we did
                // not want to do this admin check unconditionally. We will have the control panel applet that
                // is launching sysocmgr.exe to pass in this /y switch.
                //
                case TEXT('y'):
                case TEXT('Y'):

                    bDoAdminCheck = TRUE;
                    break;


                case TEXT('z'):
                case TEXT('Z'):
                    // Stop parsing Arguments All other args past this point are
                    // Component Arguments

                    argc = 0;
                    break;

                default:

                    Valid = FALSE;
                    break;
            }

        } else {
            Valid = FALSE;
        }
    }

    if (Valid && !InfSpec) {
        Valid = FALSE;
    }

    if (Valid) {
        //
        // Expand the inf spec to a full path.
        //
        ExpandPath(InfSpec,InfPath,&FilePart);
        _tcscpy(InfDir, InfSpec);
        if (_tcsrchr(InfDir, TEXT('\\')))
            *_tcsrchr(InfDir,TEXT('\\')) = 0;
        else
            GetCurrentDirectory(MAX_PATH, InfDir);

        // If the user specified /s then expand it too, otherwise
        // use the dir in the /i as the /s arg.

        if (SourcePathSpec) {

            ExpandPath(SourcePathSpec,SourcePath,&FilePart);

        } else {
            
            lstrcpy(SourcePath,InfPath);
            if (_tcsrchr(SourcePath,TEXT('\\'))) {
                *_tcsrchr(SourcePath,TEXT('\\')) = 0;
            }
            
        }

        SetCurrentDirectory(InfDir);

        if (UnattendSpec) {
            ExpandPath(UnattendSpec,UnattendPath,&FilePart);
        }else{
            // Allow /Q only if /U was specified

            QuietMode = FALSE;
            SkipBillboard = FALSE;
        }

        

    } else {
        MessageBoxFromMessage(
                             NULL,
                             MSG_ARGS,
                             FALSE,
                             MAKEINTRESOURCE(AppTitleStringId),
                             MB_OK | MB_ICONERROR | MB_SETFOREGROUND | MB_SYSTEMMODAL
                             );
    }

    return (Valid);
}


INT_PTR
BillboardDlgProc(
                IN HWND   hdlg,
                IN UINT   msg,
                IN WPARAM wParam,
                IN LPARAM lParam
                )
{
    BOOL b;
    RECT rect1,rect2;
    static HCURSOR hOldCursor;

    switch (msg) {

        case WM_INITDIALOG:

            //
            // Center on-screen.
            //
            GetWindowRect(hdlg,&rect1);
            SystemParametersInfo(SPI_GETWORKAREA,0,&rect2,0);

            MoveWindow(
                      hdlg,
                      rect2.left + (((rect2.right - rect2.left) - (rect1.right - rect1.left)) / 2),
                      rect2.top + (((rect2.bottom - rect2.top) - (rect1.bottom - rect1.top)) / 2),
                      rect1.right - rect1.left,
                      rect1.bottom - rect1.top,
                      FALSE
                      );

            *(HWND *)lParam = hdlg;
            b = TRUE;

            hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
            break;

        case WM_APP:

            EndDialog(hdlg,0);

            SetCursor( hOldCursor );

            b = TRUE;
            break;

        default:

            b = FALSE;
            break;
    }

    return (b);
}


DWORD
DisplayMessage(
              IN LPVOID ThreadParameter
              )
{
    int i;

    i = (int)DialogBoxParam(
                           hInst,
                           MAKEINTRESOURCE(bStarting?IDD_STARTING:IDD_FINISHING),
                           NULL,
                           BillboardDlgProc,
                           (LPARAM)ThreadParameter
                           );

    if (i == -1) {
        //
        // Force caller out of wait loop
        //
        *(HWND *)ThreadParameter = (HWND)(-1);
    }

    return (0);
}

/*---------------------------------------------------------------------------*\
  Function: RunningAsAdministrator()
|*---------------------------------------------------------------------------*|
  Description: Checks whether we are running as administrator on the machine
  or not.
  Code taken from ntoc.dll
\*---------------------------------------------------------------------------*/
BOOL 
RunningAsAdministrator(
        VOID
        )
{
    BOOL   fAdmin;
    HANDLE  hThread;
    TOKEN_GROUPS *ptg = NULL;
    DWORD  cbTokenGroups;
    DWORD  dwGroup;
    PSID   psidAdmin;
    
    SID_IDENTIFIER_AUTHORITY SystemSidAuthority= SECURITY_NT_AUTHORITY;
    
    
    // First we must open a handle to the access token for this thread.

    if ( !OpenThreadToken ( GetCurrentThread(), TOKEN_QUERY, FALSE, &hThread))
    {
        if ( GetLastError() == ERROR_NO_TOKEN)
        {
            // If the thread does not have an access token, we'll examine the
            // access token associated with the process.
            
            if (! OpenProcessToken ( GetCurrentProcess(), TOKEN_QUERY, 
                         &hThread))
                return ( FALSE);
        }
        else 
            return ( FALSE);
    }
    
    // Then we must query the size of the group information associated with
    // the token. Note that we expect a FALSE result from GetTokenInformation
    // because we've given it a NULL buffer. On exit cbTokenGroups will tell
    // the size of the group information.
    
    if ( GetTokenInformation ( hThread, TokenGroups, NULL, 0, &cbTokenGroups))
        return ( FALSE);
    
    // Here we verify that GetTokenInformation failed for lack of a large
    // enough buffer.
    
    if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER)
        return ( FALSE);
    
    // Now we allocate a buffer for the group information.
    // Since _alloca allocates on the stack, we don't have
    // to explicitly deallocate it. That happens automatically
    // when we exit this function.
    
    if ( ! ( ptg= (TOKEN_GROUPS *)malloc ( cbTokenGroups))) 
        return ( FALSE);
    
    // Now we ask for the group information again.
    // This may fail if an administrator has added this account
    // to an additional group between our first call to
    // GetTokenInformation and this one.
    
    if ( !GetTokenInformation ( hThread, TokenGroups, ptg, cbTokenGroups,
          &cbTokenGroups) )
    {
        free(ptg);
        return ( FALSE);
    }
    
    // Now we must create a System Identifier for the Admin group.
    
    if ( ! AllocateAndInitializeSid ( &SystemSidAuthority, 2, 
            SECURITY_BUILTIN_DOMAIN_RID, 
            DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0, &psidAdmin) )
    {
        free(ptg);
        return ( FALSE);
    }
    
    // Finally we'll iterate through the list of groups for this access
    // token looking for a match against the SID we created above.
    
    fAdmin= FALSE;
    
    for ( dwGroup= 0; dwGroup < ptg->GroupCount; dwGroup++)
    {
        if ( EqualSid ( ptg->Groups[dwGroup].Sid, psidAdmin))
        {
            fAdmin = TRUE;
            
            break;
        }
    }
    
    // Before we exit we must explicity deallocate the SID we created.
    
    FreeSid ( psidAdmin);
    free(ptg);
    
    return ( fAdmin);
}


BOOL
DoIt(
    VOID
    )
{
    BOOL ShowErr;
    HANDLE hThread;
    DWORD ThreadId;
    HANDLE hMutex;
    TCHAR Fname[MAX_PATH];
    TCHAR MutexName[MAX_PATH];
    DWORD Flags;
    HWND StartingMsgWindow = NULL;
    HCURSOR hOldCursor;

    if (bDoAdminCheck && !RunningAsAdministrator()) {
        MessageBoxFromMessage(
             StartingMsgWindow,
             MSG_NOT_ADMIN,
             FALSE,
             MAKEINTRESOURCE(AppTitleStringId),
             MB_OK | MB_ICONERROR | MB_SETFOREGROUND | MB_SYSTEMMODAL
             );
        return FALSE;
    }

    //
    // Create a Mutex from the Base Name of the Inf file
    // This will prevent OCM from running on the same inf file
    // in two or more instances
    //
    _tsplitpath( InfPath, NULL, NULL, Fname, NULL );

    lstrcpy( MutexName, TEXT("Global\\"));
    lstrcat( MutexName, Fname );

    hMutex = CreateMutex( NULL, TRUE, MutexName );

    if (!hMutex || ERROR_ALREADY_EXISTS == GetLastError()) {
        MessageBoxFromMessage(
                             NULL,
                             MSG_ONLY_ONE_INST,
                             FALSE,
                             MAKEINTRESOURCE(AppTitleStringId),
                             MB_OK | MB_ICONEXCLAMATION | MB_SETFOREGROUND | MB_SYSTEMMODAL
                             );

        ReleaseMutex(hMutex);
        return FALSE;

    }

    //
    // Initialize the OC Manager. Show the user an "initializing setup"
    // dialog while this is happening, as it can take a while.
    //
    if (!SkipBillboard) {
        bStarting = TRUE;
        StartingMsgWindow = NULL;
        hThread = CreateThread(
                              NULL,
                              0,
                              DisplayMessage,
                              &StartingMsgWindow,
                              0,
                              &ThreadId
                              );

        if (hThread) {
            CloseHandle(hThread);
            Sleep(50);
        } else {
            DisplayMessage(0);
        }
    }

    //
    // Make sure the window has actually been created,
    // or we could have a timing window where the PostMessage fails
    // and the billboard shows up on top of the wizard.
    //
    if (!SkipBillboard) {
        while (!StartingMsgWindow) {
            Sleep(50);
        }
    }

    Flags = ForceNewInf ? OCINIT_FORCENEWINF : 0;
    Flags |= KillSubcomponentEntries ? OCINIT_KILLSUBCOMPS : 0;
    Flags |= QuietMode ? OCINIT_RUNQUIET : 0;
    Flags |= LanguageAware ? OCINIT_LANGUAGEAWARE : 0 ;

    hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

    OcManagerContext = OcInitialize(
                                   &CallbackRoutines,
                                   InfPath,
                                   Flags,
                                   &ShowErr,
                                   NULL
                                   );

    if (!OcManagerContext) {

        SetCursor( hOldCursor );

        if (ShowErr) {
            MessageBoxFromMessage(
                                 StartingMsgWindow,
                                 MSG_CANT_INIT,
                                 FALSE,
                                 MAKEINTRESOURCE(AppTitleStringId),
                                 MB_OK | MB_ICONERROR | MB_SETFOREGROUND | MB_SYSTEMMODAL
                                 );
        }

        ReleaseMutex(hMutex);
        return (FALSE);
    }

    //
    // Do the wizard.
    //
    DoWizard(OcManagerContext,StartingMsgWindow, hOldCursor);

    SetCursor( hOldCursor );
    hOldCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

    // the Terminate can take a while too..
    if (!SkipBillboard) {

        bStarting = FALSE;
        StartingMsgWindow = NULL;
        hThread = CreateThread(
                              NULL,
                              0,
                              DisplayMessage,
                              &StartingMsgWindow,
                              0,
                              &ThreadId
                              );

        if (hThread) {
            CloseHandle(hThread);
            Sleep(50);
        } else {
            DisplayMessage(0);
        }
    }

    //
    // Clean up, we're done.
    //
    OcTerminate(&OcManagerContext);

    if (!SkipBillboard) {
        //
        // Make sure the window has actually been created,
        // or we could have a timing window where the PostMessage fails
        // and the billboard shows up on top of the wizard.
        //
        while (!StartingMsgWindow) {
            Sleep(50);
        }
        SendMessage(StartingMsgWindow,WM_APP,0,0);
    }

    ReleaseMutex(hMutex);

    SetCursor( hOldCursor );
    return (TRUE);
}


VOID
OcSetReboot(
           VOID
           )
{
    NeedToReboot = TRUE;
}

DWORD
ExpandPath(
          IN  LPCTSTR lpFileName,
          OUT LPTSTR lpBuffer,
          OUT LPTSTR *lpFilePart
          )
{
    TCHAR buf[MAX_PATH];

    ExpandEnvironmentStrings(lpFileName, buf, MAX_PATH);
    return GetFullPathName(buf, MAX_PATH, lpBuffer, lpFilePart);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ocmanage\sysocmgr\setupdat.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    setupdat.c

Abstract:

    Module containing implementation for OcFillInSetupData, which the
    common OC Manager library will call to fill in the environment-dependent
    SETUP_DATA structure.

Author:

    tedm 30-Sep-1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#include <lmcons.h>
#include <lmserver.h>
#include <lmapibuf.h>


UINT
pDetermineProductType(
    VOID
    );



#ifdef UNICODE
VOID
OcFillInSetupDataA(
    OUT PSETUP_DATAA SetupData
    )

/*++

Routine Description:

    Routine to fill in the ANSI SETUP_DATA structure in the Unicode build.

    This routine is merely a thunk to the Unicode implementation.

Arguments:

    SetupData - receives various environment-specific values relating
        to the OC Manager's operation.

Return Value:

    None.

--*/

{
    SETUP_DATAW data;

    OcFillInSetupDataW(&data);

    SetupData->SetupMode = data.SetupMode;
    SetupData->ProductType = data.ProductType;
    SetupData->OperationFlags = data.OperationFlags;

    WideCharToMultiByte(
        CP_ACP,
        0,
        data.SourcePath,
        -1,
        SetupData->SourcePath,
        sizeof(SetupData->SourcePath),
        NULL,
        NULL
        );

    WideCharToMultiByte(
        CP_ACP,
        0,
        data.UnattendFile,
        -1,
        SetupData->UnattendFile,
        sizeof(SetupData->UnattendFile),
        NULL,
        NULL
        );
}
#endif


#ifdef UNICODE
VOID
OcFillInSetupDataW(
    OUT PSETUP_DATAW SetupData
    )
#else
VOID
OcFillInSetupDataA(
    OUT PSETUP_DATAA SetupData
    )
#endif

/*++

Routine Description:

    Routine to fill in the SETUP_DATA structure in the "native"
    character width.

Arguments:

    SetupData - receives various environment-specific values relating
        to the OC Manager's operation.

Return Value:

    None.

--*/

{
    TCHAR str[4];
    
    SetupData->SetupMode = (ULONG)SETUPMODE_UNKNOWN;
    SetupData->ProductType = pDetermineProductType();

    //
    // Set up source path stuff, unattend file.
    //
    lstrcpy(SetupData->SourcePath,SourcePath);
    lstrcpy(SetupData->UnattendFile,UnattendPath);

    //
    // Set miscellaneous bit flags and fields.
    //
    SetupData->OperationFlags = SETUPOP_STANDALONE;
    if(bUnattendInstall) {
        SetupData->OperationFlags |= SETUPOP_BATCH;
    }

    //
    // Which files are available?
    //
#if defined(_AMD64_)
    SetupData->OperationFlags |= SETUPOP_X86_FILES_AVAIL | SETUPOP_AMD64_FILES_AVAIL;
#elif defined(_X86_)
    SetupData->OperationFlags |= SETUPOP_X86_FILES_AVAIL;
#elif defined(_IA64_)
    SetupData->OperationFlags |= SETUPOP_X86_FILES_AVAIL | SETUPOP_IA64_FILES_AVAIL;
#else
#error "No Target Architecture"
#endif


}


UINT
pDetermineProductType(
    VOID
    )

/*++

Routine Description:

    Determine the product type suitable for use in the SETUP_DATA structure.
    On Win95 this is always PRODUCT_WORKSTATION. On NT we check the registry
    and use other methods to distinguish among workstation and 3 flavors
    of server.

Arguments:

    None.

Return Value:

    Value suitable for use in the ProductType field of the SETUP_DATA structure.

--*/

{
    UINT ProductType;
    HKEY hKey;
    LONG l;
    DWORD Type;
    TCHAR Buffer[512];
    DWORD BufferSize;
    PSERVER_INFO_101 ServerInfo;

    HMODULE NetApiLib;

    NET_API_STATUS
    (NET_API_FUNCTION *xNetServerGetInfo)(
        IN  LPTSTR  servername,
        IN  DWORD   level,
        OUT LPBYTE  *bufptr
        );

    NET_API_STATUS
    (NET_API_FUNCTION *xNetApiBufferFree)(
        IN LPVOID Buffer
        );

    //
    // Assume workstation.
    //
    ProductType = PRODUCT_WORKSTATION;

    if(IS_NT()) {
        //
        // Look in registry to determine workstation, standalone server, or DC.
        //
        l = RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                TEXT("SYSTEM\\CurrentControlSet\\Control\\ProductOptions"),
                0,
                KEY_QUERY_VALUE,
                &hKey
                );

        if(l == NO_ERROR) {

            BufferSize = sizeof(Buffer);

            l = RegQueryValueEx(hKey,TEXT("ProductType"),NULL,&Type,(LPBYTE)Buffer,&BufferSize);
            if((l == NO_ERROR) && (Type == REG_SZ)) {
                //
                // Check for standalone server or DC server.
                //
                if(!lstrcmpi(Buffer,TEXT("SERVERNT"))) {
                    ProductType = PRODUCT_SERVER_STANDALONE;
                } else {
                    if(!lstrcmpi(Buffer,TEXT("LANMANNT"))) {
                        //
                        // PDC or BDC -- determine which. Assume PDC in case of failure.
                        //
                        ProductType = PRODUCT_SERVER_PRIMARY;

                        if(NetApiLib = LoadLibrary(TEXT("NETAPI32"))) {

                            if(((FARPROC)xNetServerGetInfo = GetProcAddress(NetApiLib,"NetServerGetInfo"))
                            && ((FARPROC)xNetApiBufferFree = GetProcAddress(NetApiLib,"NetApiBufferFree"))
                            && (xNetServerGetInfo(NULL,101,(LPBYTE *)&ServerInfo) == 0)) {

                                if(ServerInfo->sv101_type & SV_TYPE_DOMAIN_BAKCTRL) {
                                    ProductType = PRODUCT_SERVER_SECONDARY;
                                }

                                xNetApiBufferFree(ServerInfo);
                            }

                            FreeLibrary(NetApiLib);
                        }
                    }
                }
            }

            RegCloseKey(hKey);
        }
    }

    return(ProductType);
}


INT
OcLogError(
    IN OcErrorLevel Level,
    IN LPCTSTR      FormatString,
    ...
    )
{
    TCHAR str[4096];
    TCHAR tmp[64];
    TCHAR Title[256];
    va_list arglist;
    UINT Icon;

    va_start(arglist,FormatString);
    wvsprintf(str,FormatString,arglist);
    va_end(arglist);

    // In Batch mode don't display UI
    if ( Level & OcErrBatch ) {

        pDbgPrintEx( 
            DPFLTR_SETUP_ID, 
            DPFLTR_INFO_LEVEL,
            "sysocmgr: %S\n",
            str 
            );

        return IDOK;
    }
        //
        // Mask off lower byte to allow us to pass
        // Addtionall "icon" information 
        // 
        
    switch( Level & OcErrMask ) {
    case OcErrLevInfo:
        Icon = MB_ICONINFORMATION;
        break;
    case OcErrLevWarning:
    case OcErrLevError:
        Icon = MB_ICONWARNING;
        break;
    case OcErrTrace:
        pDbgPrintEx( 
            DPFLTR_SETUP_ID, 
            DPFLTR_INFO_LEVEL,
            "sysocmgr: %S\n",
            str 
            );
        return(IDOK);
        break;
    default:
        Icon = MB_ICONERROR;
        break;
    }

    pDbgPrintEx( 
        DPFLTR_SETUP_ID, 
        DPFLTR_ERROR_LEVEL,
        "sysocmgr: level 0x%08x error: %S\n",
        Level,
        str 
        );

        //
        // If no additional Icon information is specified that's ok since
        // MB_OK is default
        //
        Icon |= (Level & ~OcErrMask);

    if ((Level & OcErrMask) < OcErrLevError)
        return IDOK;


    LoadString(hInst,AppTitleStringId,Title,sizeof(Title)/sizeof(TCHAR));
    return MessageBox(NULL,str,Title,Icon | MB_TASKMODAL | MB_SETFOREGROUND);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ocmanage\sysocmgr\wizard.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    wizard.c

Abstract:

    Routines to run the wizard for the suite.

Author:

    Ted Miller (tedm) 1-Oct-1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

HPROPSHEETPAGE
CreateInstallationAndProgressPage(
    VOID
    );

INT_PTR
FinalPageDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

//
// Bogus global variable necessary because there's no way to get
// a value through to the PropSheetCallback.
//
PVOID _CBx;

int
CALLBACK
PropSheetCallback(
    IN HWND   DialogHandle,
    IN UINT   msg,
    IN LPARAM lparam
    )
{
    DWORD oldp;
    LPDLGTEMPLATE dtemplate;

    switch (msg) {

    case PSCB_PRECREATE:
        dtemplate = (LPDLGTEMPLATE)lparam;
        if (QuietMode) {
            VirtualProtect(dtemplate, sizeof(DLGTEMPLATE), PAGE_READWRITE, &oldp);
            dtemplate->style = dtemplate->style & ~WS_VISIBLE;
        }
        break;

    case PSCB_INITIALIZED:
        OcRememberWizardDialogHandle(_CBx,DialogHandle);
        break;
    }

    return 0;
}



BOOL
DoWizard(
    IN PVOID OcManagerContext,
    IN HWND StartingMsgWindow,
    IN HCURSOR hOldCursor
    )

/*++

Routine Description:

    This routine creates and displays the wizard.

Arguments:

    OcManagerContext - value returned from OcInitialize().

Return Value:

    Boolean value indicating whether the wizard was successfully displayed.

--*/

{
    PSETUP_REQUEST_PAGES PagesFromOcManager[WizPagesTypeMax];
    BOOL b;
    UINT u;
    UINT PageCount;
    UINT i;
    HPROPSHEETPAGE *PageHandles;
    HPROPSHEETPAGE OcPage = NULL;
    HPROPSHEETPAGE SetupPage;
    HPROPSHEETPAGE FinalPage;
    PROPSHEETPAGE PageDescrip;
    PROPSHEETHEADER PropSheet;
    OC_PAGE_CONTROLS WizardPageControlsInfo;
    OC_PAGE_CONTROLS DetailsPageControlsInfo;
    SETUP_PAGE_CONTROLS SetupPageControlsInfo;
    HDC hdc;
    HWND PsHwnd;

    b = FALSE;

    u = OcGetWizardPages(OcManagerContext,PagesFromOcManager);
    if(u != NO_ERROR) {
        MessageBoxFromMessageAndSystemError(
            NULL,
            MSG_CANT_INIT,
            u,
            MAKEINTRESOURCE(AppTitleStringId),
            MB_OK | MB_ICONERROR | MB_SYSTEMMODAL | MB_SETFOREGROUND
            );

        goto c0;
    }

    //
    // There must be a final page, because the final page comes right after the
    // setup page, and we don't want the setup page to have to know whether to
    // simulate pressing next or finish to advance.
    //
    if(!PagesFromOcManager[WizPagesFinal] || !PagesFromOcManager[WizPagesFinal]->MaxPages) {

        PageDescrip.dwSize = sizeof(PROPSHEETPAGE);
        PageDescrip.dwFlags = PSP_DEFAULT;
        PageDescrip.hInstance = hInst;
        PageDescrip.pszTemplate = MAKEINTRESOURCE(IDD_FINAL);
        PageDescrip.pfnDlgProc = FinalPageDlgProc;

        FinalPage = CreatePropertySheetPage(&PageDescrip);
        if(!FinalPage) {
            MessageBoxFromMessageAndSystemError(
                NULL,
                MSG_CANT_INIT,
                ERROR_NOT_ENOUGH_MEMORY,
                MAKEINTRESOURCE(AppTitleStringId),
                MB_OK | MB_ICONERROR | MB_SYSTEMMODAL | MB_SETFOREGROUND
                );

            goto c1;
        }

    } else {
        FinalPage = NULL;
    }

    //
    // Calculate the number of pages. There's two extra pages (the OC and setup pages).
    // Also leave room for a potential dummy final page.
    //
    PageCount = FinalPage ? 3 : 2;
    for(u=0; u<WizPagesTypeMax; u++) {
        if(PagesFromOcManager[u]) {
            PageCount += PagesFromOcManager[u]->MaxPages;
        }
    }

    //
    // Allocate space for the page structures.
    //
    PageHandles = MyMalloc(PageCount * sizeof(HPROPSHEETPAGE));
    if(!PageHandles) {
        MessageBoxFromMessageAndSystemError(
            NULL,
            MSG_CANT_INIT,
            ERROR_NOT_ENOUGH_MEMORY,
            MAKEINTRESOURCE(AppTitleStringId),
            MB_OK | MB_ICONERROR | MB_SYSTEMMODAL | MB_SETFOREGROUND
            );

        goto c1;
    }
    ZeroMemory(PageHandles,PageCount*sizeof(HPROPSHEETPAGE));

    //
    // Create the OC Page.
    //
    WizardPageControlsInfo.TemplateModule = hInst;
    WizardPageControlsInfo.TemplateResource = MAKEINTRESOURCE(IDD_OC_WIZARD_PAGE);
    WizardPageControlsInfo.ListBox = IDC_LISTBOX;
    WizardPageControlsInfo.TipText = IDT_TIP;
    WizardPageControlsInfo.DetailsButton = IDB_DETAILS;
    WizardPageControlsInfo.ResetButton = IDB_RESET;
    WizardPageControlsInfo.InstalledCountText = IDT_INSTALLED_COUNT;
    WizardPageControlsInfo.SpaceNeededText = IDT_SPACE_NEEDED_NUM;
    WizardPageControlsInfo.SpaceAvailableText = IDT_SPACE_AVAIL_NUM;
    WizardPageControlsInfo.InstructionsText = IDT_INSTRUCTIONS;
    WizardPageControlsInfo.HeaderText = IDS_OCPAGE_HEADER;
    WizardPageControlsInfo.SubheaderText = IDS_OCPAGE_SUBHEAD;
    WizardPageControlsInfo.ComponentHeaderText = IDT_COMP_TITLE;


    DetailsPageControlsInfo = WizardPageControlsInfo;
    DetailsPageControlsInfo.TemplateResource = MAKEINTRESOURCE(IDD_OC_DETAILS_PAGE);

    if (OcSubComponentsPresent(OcManagerContext)) {
        OcPage = OcCreateOcPage(OcManagerContext,&WizardPageControlsInfo,&DetailsPageControlsInfo);
        if(!OcPage) {
            MessageBoxFromMessageAndSystemError(
                NULL,
                MSG_CANT_INIT,
                ERROR_NOT_ENOUGH_MEMORY,
                MAKEINTRESOURCE(AppTitleStringId),
                MB_OK | MB_ICONERROR | MB_SYSTEMMODAL | MB_SETFOREGROUND
                );

            goto c2;
        }
    }

    SetupPageControlsInfo.TemplateModule = hInst;
    SetupPageControlsInfo.TemplateResource = MAKEINTRESOURCE(IDD_PROGRESS_PAGE);
    SetupPageControlsInfo.ProgressBar = IDC_PROGRESS;
    SetupPageControlsInfo.ProgressLabel = IDT_THERM_LABEL;
    SetupPageControlsInfo.ProgressText = IDT_TIP;
    SetupPageControlsInfo.AnimationControl = IDA_EXTERNAL_PROGRAM;
    SetupPageControlsInfo.AnimationResource = IDA_FILECOPY;
    SetupPageControlsInfo.ForceExternalProgressIndicator = ForceExternalProgressIndicator;
    SetupPageControlsInfo.AllowCancel = AllowCancel;
    SetupPageControlsInfo.HeaderText = IDS_PROGPAGE_HEADER;
    SetupPageControlsInfo.SubheaderText = IDS_PROGPAGE_SUBHEAD;

    SetupPage = OcCreateSetupPage(OcManagerContext,&SetupPageControlsInfo);
    if(!SetupPage) {
        MessageBoxFromMessageAndSystemError(
            NULL,
            MSG_CANT_INIT,
            ERROR_NOT_ENOUGH_MEMORY,
            MAKEINTRESOURCE(AppTitleStringId),
            MB_OK | MB_ICONERROR | MB_SYSTEMMODAL | MB_SETFOREGROUND
            );

        goto c2;
    }

    for(PageCount=0,u=0; u<WizPagesTypeMax; u++) {
        //
        // OC Page comes between mode and early pages.
        // Setup page comes right before final page.
        //
        if(u == WizPagesEarly && OcPage) {
            PageHandles[PageCount++] = OcPage;
        } else {
            if(u == WizPagesFinal) {
                PageHandles[PageCount++] = SetupPage;
                if(FinalPage) {
                    PageHandles[PageCount++] = FinalPage;
                }
            }
        }

        if(PagesFromOcManager[u]) {

            CopyMemory(
                PageHandles+PageCount,
                PagesFromOcManager[u]->Pages,
                PagesFromOcManager[u]->MaxPages * sizeof(HPROPSHEETPAGE)
                );

            PageCount += PagesFromOcManager[u]->MaxPages;
        }
    }

    //
    // OK, we're ready. Set up and go.
    //
    PropSheet.dwSize = sizeof(PROPSHEETHEADER);
    PropSheet.dwFlags = PSH_WIZARD | PSH_USECALLBACK | PSH_WIZARD97 | PSH_WATERMARK | PSH_HEADER;
    PropSheet.hwndParent = NULL;
    PropSheet.hInstance = hInst;
    PropSheet.nPages = PageCount;
    PropSheet.nStartPage = 0;
    PropSheet.phpage = PageHandles;
    PropSheet.pfnCallback = PropSheetCallback;
    PropSheet.pszbmHeader    = MAKEINTRESOURCE(IDB_WATERMARK1_16);
    PropSheet.pszbmWatermark = MAKEINTRESOURCE(IDB_WELCOME);
    if(hdc = GetDC(NULL)) {
        if(GetDeviceCaps(hdc,BITSPIXEL) >= 8) {
            PropSheet.pszbmHeader = MAKEINTRESOURCE(IDB_WATERMARK1_256);
        }
        ReleaseDC(NULL,hdc);
    }

    //
    // Bogus global var used because we need to get a value through to
    // the property sheet callback routine.
    //
    _CBx = OcManagerContext;

    // make sure our new window can hold the focus before killing the wait window

    if(StartingMsgWindow) {
        AllowSetForegroundWindow(GetCurrentProcessId());
        PostMessage(StartingMsgWindow,WM_APP,0,0);
    }

    SetCursor(hOldCursor);

    PsHwnd = (HWND) PropertySheet( &PropSheet );

    if((LONG_PTR)PsHwnd == -1) {

        MessageBoxFromMessageAndSystemError(
            NULL,
            MSG_CANT_INIT,
            ERROR_NOT_ENOUGH_MEMORY,
            MAKEINTRESOURCE(AppTitleStringId),
            MB_OK | MB_ICONERROR | MB_SYSTEMMODAL | MB_SETFOREGROUND
            );

   } else {

        b = TRUE;
    }

c2:
    MyFree(PageHandles);
c1:
    for(u=0; u<WizPagesTypeMax; u++)    {
        if (PagesFromOcManager[u]) {
            pSetupFree(PagesFromOcManager[u]);
        }
    }

c0:
    return(b);
}


INT_PTR
FinalPageDlgProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{

    BOOL b;
    NMHDR *NotifyParams;
    b = FALSE;

    switch(msg) {

    case WM_NOTIFY:

        NotifyParams = (NMHDR *)lParam;

        switch(NotifyParams->code) {

        case PSN_SETACTIVE:

			// We don't dispaly this page. Just use it to end the Wizard set
			PropSheet_SetWizButtons(GetParent(hdlg),PSWIZB_FINISH);
            PropSheet_PressButton(GetParent(hdlg),PSBTN_FINISH);
            // fall through

        case PSN_KILLACTIVE:
        case PSN_WIZBACK:
        case PSN_WIZNEXT:
        case PSN_WIZFINISH:
            //
            // Allow activation/motion.
            //
            SetWindowLongPtr(hdlg,DWLP_MSGRESULT,0);
            b = TRUE;
            break;
        }
    }

    return(b);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ocmanage\sysocmgr\unicode\precomp.h ===
#include "sysocmgr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ocmanage\sysocmgr\ansi\precomp.h ===
#include "sysocmgr.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ocmanage\testoc\msg.h ===
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: MSG_SURE_SELECT
//
// MessageText:
//
//  Are you sure you want to select subcomponent '%2' of component '%1'?%0
//
#define MSG_SURE_SELECT                  0x00000001L

//
// MessageId: MSG_SURE_DESELECT
//
// MessageText:
//
//  Are you sure you want to deselect subcomponent '%2' of component '%1'?%0
//
#define MSG_SURE_DESELECT                0x00000002L
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ocmanage\testoc\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by octest.rc
//
#define IDD_WIZPAGE                     101
#define IDD_WIZWELCOME                  102
#define IDD_WIZMODE                     103
#define IDD_DIALOG1                     104
#define IDD_DIALOG2                     105
#define IDD_DIALOG3                     106
#define IDD_CHOOSERETURNANDAV           107
#define IDD_DIALOG4                     108
#define IDC_COMPONENT                   1001
#define IDC_PAGE                        1002
#define IDC_COUNT                       1003
#define IDC_TEST                        1004
#define IDC_MINIMAL                     1005
#define IDC_TYPICAL                     1006
#define IDC_CUSTOM                      1007
#define IDC_LAPTOP                      1008
#define IDC_STATIC_COMPONENT            1009
#define IDC_CURRENT_MODE                1010
#define IDC_SKIP_PAGES                  1011
#define IDC_FUNCTION                    1013
#define IDC_ANSI                        2000
#define IDC_UNICODE                     2001
#define IDC_ANSI_AND_UNICODE            2002
#define IDC_COMPONENT1                  2010
#define IDC_LESS                        3000
#define IDC_EQUAL                       3001
#define IDC_GREATER                     3002
#define IDC_DEFAULT                     4000
#define IDC_ON                          4001
#define IDC_OFF                         4002
#define IDC_ZERO                        6000
#define IDC_NEGONE                      6001
#define IDC_SEVEN                       6002
#define IDC_CAUSEAV                     7006
#define IDC_USE_OLDVALUE                7007
#define IDC_USE_NEWVALUE                7008
#define IDC_STATIC_APICALL              7010
#define IDC_STATIC_SUBCOMPONENT         7011
#define IDC_NEWVALUE                    7012
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        109
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1014
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ocmanage\testoc\octest.c ===
/*++

Copyright (c) 1997	Microsoft Corporation

Module Name:

	octest.c

Abstract:

	The code for the component setup DLL. This includes ComponentSetupProc, 
	the DLL's entry point that is called by the OC Manager, as well as some 
	routines that test the private data calls and the private functions calls.

Author:

	Bogdan Andreiu (bogdana)  10-Feb-1997  Created.
	Jason Allor    (jasonall) 24-Feb-1998  Took over the project.
	Sean Edmison   (SEdmison) 21-Feb-2000  Took over the project.

Revision History:

	10-Feb-1997    bogdana
		First draft.
	
	20-Feb-1997    bogdana	
		Added multistring testing for the private data
	
	19-Mar-1997    bogdana
		Modified and added routines that test the private functions call
	 
	21-Feb-2000  SEdmison
		Initialized a bunch of variables.
		Added casts to avoid compiler warnings.
		Added a return TRUE to avoid compiler error.

--*/
#include "octest.h"

const static PTCHAR g_atszStringValues[MAX_STRINGS_FOR_PRIVATE_DATA] = 
{
	TEXT("First value to set"),
	TEXT("Second value to set"),
	TEXT("The third and longest value to set"),
	TEXT(""),
	TEXT("A"),
	TEXT("AB"),
	TEXT("ABC"),
	TEXT("The final value : \\//\\//\\//\\")
};

const static PTCHAR g_atszMultiStringValues[MAX_MULTI_STRINGS_FOR_PRIVATE_DATA] = 
{
	TEXT("A\0B\0C\0D\0E\0\0"),
	TEXT("\0\0"),
	TEXT("One\0Two\0Three\0\0"),
	TEXT("String1\0\0"),
	TEXT("0\01\02\03\0\0"),
	TEXT("Multi\0String\0\\0\0\0")
};

/*++

Routine Description: DllMain (1.24)

	main routine

Arguments:

	standard DllMain arguments

Return Value:

	BOOL

--*/
BOOL WINAPI DllMain(IN HINSTANCE hInstance, 
						  IN DWORD		fdwReason, 
						  IN PVOID		pvReserved)
{
	USHORT		  i = 0;
	TCHAR		  tszModulePath[MAX_PATH], szMsg[MAX_MSG_LEN];
	PTCHAR		  tszLogPath = NULL;
	PTCHAR		  tszAux = NULL;
	static UINT uiThreadCount = 0;

	switch (fdwReason)
	{
		case  DLL_PROCESS_ATTACH:
										
			InitializeMemoryManager();
			InitGlobals();
			
			ParseCommandLine();
			
			//
			// Randomize, save the module instance and in initialize the log
			//
			srand((unsigned) time(NULL));
			g_hDllInstance = hInstance;
			InitCommonControls();
			GetModuleFileName(g_hDllInstance, tszModulePath, MAX_PATH);
			break;
		
		case DLL_PROCESS_DETACH:

			CleanUpTest();
			ExitLog();
			CheckAllocs();
			
			break;
		
		case DLL_THREAD_DETACH:
			
			//
			// If we added a participant, we have to remoce it
			//
			break;
		
		case DLL_THREAD_ATTACH:
			
			//
			// Otherwise we won't be able to log on correctly
			//
			uiThreadCount++;
			break;
		
		default: 
		
			break;
	}
	return TRUE;
	
} // DllMain //



//==========================================================================
//
// Functions to set up UI
//
//==========================================================================



/*++

Routine Description: ChooseVersionDlgProc (1.26)

	Dialog procedure that allows the user to choose a component version
	less, equal or greater then the one of the OC Manager's.
	
Arguments:

	Standard dialog procedure parameters
	
Return Value:

	Standard dialog procedure return value

--*/
BOOL CALLBACK ChooseVersionDlgProc(IN HWND	  hwnd,
											  IN UINT	 uiMsg, 
											  IN WPARAM wParam,
											  IN LPARAM lParam) 
{
	PTSTR tszComponentId = NULL;
	INT    iVersion = 0;

	switch (uiMsg)
	{
		case WM_INITDIALOG:
			
			CheckRadioButton(hwnd, IDC_LESS, IDC_GREATER, IDC_EQUAL);
			tszComponentId = (PTSTR)lParam;
			SetDlgItemText(hwnd, IDC_COMPONENT1, tszComponentId);
			return TRUE;
		
		case WM_COMMAND:
			
			switch (LOWORD(wParam))
			{
				case IDOK:
					
					//
					// Retrieve the current selection
					//
					if (QueryButtonCheck(hwnd, IDC_LESS))
					{
						iVersion = -1;
					}
					
					if (QueryButtonCheck(hwnd, IDC_EQUAL))
					{
						iVersion = 0;
					}
					
					if (QueryButtonCheck(hwnd, IDC_GREATER))
					{
						iVersion = 1;
					}
					
					//
					// Send the version chosen back to ChooseVersionEx
					//
					EndDialog(hwnd, iVersion);
					return TRUE;
				
				case IDCANCEL:
					
					EndDialog(hwnd, 0);
					return TRUE;
				
				default:  
					break;
			}
		default:  
			break;
	}
	return	FALSE;

} // ChooseVersionDlgProc //




/*++

Routine Description: ChooseSubcomponentDlgProc (1.27)

	Dialog procedure that allows the user to select a different 
	initial state for a component than the one found by the OC Manager
	
Arguments:

	Standard dialog procedure parameters
	
Return Value:

	Standard dialog procedure return value

--*/
BOOL CALLBACK ChooseSubcomponentDlgProc(IN HWND    hwnd,
													 IN UINT	uiMsg, 
													 IN WPARAM wParam,
													 IN LPARAM lParam) 
{
	PTSTR					 tszComponentId = NULL;
	SubComponentState	 scsInitialState;

	switch (uiMsg)
	{
		case WM_INITDIALOG:
			
			CheckRadioButton(hwnd, IDC_DEFAULT, IDC_OFF, IDC_DEFAULT);
			tszComponentId = (PTSTR)lParam;
			SetDlgItemText(hwnd, IDC_COMPONENT1, tszComponentId);
			return TRUE;
		
		case WM_COMMAND:
			
			switch (LOWORD(wParam))
			{
				case IDOK:
					
					//
					// Retrieve the current selection
					//
					if (QueryButtonCheck(hwnd, IDC_DEFAULT))
					{
					  scsInitialState = SubcompUseOcManagerDefault;
					}
					
					if (QueryButtonCheck(hwnd, IDC_OFF))
					{
						scsInitialState = SubcompOff;
					}
					
					if (QueryButtonCheck(hwnd, IDC_ON))
					{
						scsInitialState = SubcompOn;
					}
					
					EndDialog(hwnd, 0);
					return TRUE;
				
				case IDCANCEL:
					
					EndDialog(hwnd, 0);
					return TRUE;
				
				default:  
					break;
			}
		default:  
			break;
	}
	return	FALSE;

} // ChooseSubcomponentDlgProc //




/*++

Routine Description: ChooseVersionEx (1.29)

	"Wrapper" routine for the dialog box procedure ChooseVersionDlgProc.
	Retrieves the value chosen by the user and sets the version field of
	pInitComponent accordingly.
	 
Arguments:

	lpcvComponentId: supplies the id for the component. 
	pInitComponent:  supplies the address of the initialization structure.
						  After return the "Version" field of that structure will 
						  reflect the user's selection 

Return Value:

	void

--*/
VOID ChooseVersionEx(IN 	 LPCVOID					lpcvComponentId, 
							IN OUT PSETUP_INIT_COMPONENT psicInitComponent)  
{
	INT iVersion = 0;
	
	//
	// We will display a dialog box so the user can choose the 
	// version he/she wants
	//
	iVersion = DialogBoxParam(g_hDllInstance, 
									  MAKEINTRESOURCE(IDD_DIALOG2), 
									  NULL, 
									  ChooseVersionDlgProc,
									  (LPARAM)lpcvComponentId);
	
	//
	// We set the version choosen in a structure that will be sent 
	// back to the Oc Manager
	//
	psicInitComponent->ComponentVersion = 
		psicInitComponent->OCManagerVersion + iVersion;

	return;

} // ChooseVersionEx //



//==========================================================================
//
// Test functions. The ocmanager will call these functions.
//
//==========================================================================



/*++

Routine Description: ComponentSetupProc (1.6)

	The DLL entry point. This function is called by the OC Manager whenever 
	it wants to send/recieve setup information to/from the component.
	Note that the ComponentId and SubcomponentId are LPCVOID because we 
	don't know in advance if they are ANSI or Unicode.
	 
Arguments:

	lpcvComponentId:	 supplies the id for the component. 
	lpcvSubcomponentId: supplies the id for the subcomponent. 
	uiFunction: 		   one of OC_XXX.
	uiParam1:			   its meaning depends on the function.
	pvParam2:			   its meaning depends on the function.
	
Return Value:

	Depends on the function (e.g. TRUE/FALSE for the language supported, 
	the number of pages supplied by the component, etc.).

--*/
EXPORT DWORD ComponentSetupProc(IN LPCVOID lpcvComponentId,
										  IN LPCVOID lpcvSubcomponentId,
										  IN UINT	  uiFunction,
										  IN UINT	  uiParam1,
										  IN PVOID	  pvParam2) 
{
	double fn = 1.6;
	
	DWORD			   dwRetval = NO_ERROR;
	PTCHAR			   tszComponentId	  = (PTCHAR)lpcvComponentId;
	PTCHAR			   tszSubcomponentId = (PTCHAR)lpcvSubcomponentId;
	TCHAR			   tsz[MAX_MSG_LEN];
	PCOMPONENT_DATA pcdComponentData = NULL; 
	TCHAR			   tszDlgMessage[256];

	PTCHAR			   tszDummy = NULL;
	
	ReturnOrAV		  raValue;
	
	static BOOL 	 bFirstTime = TRUE;
	
	//
	// Log the details about the call
	//
	LogOCFunction(lpcvComponentId, 
					  lpcvSubcomponentId, 
					  uiFunction, 
					  uiParam1, 
					  pvParam2);

	//if (uiFunction == g_uiFunctionToAV && uiFunction != OC_PREINITIALIZE && uiFunction != OC_INIT_COMPONENT) {
	//	  testAV(TRUE);
	//}

	causeAVPerComponent(uiFunction, lpcvComponentId);

	#ifndef UNICODE
	//if (g_bAccessViolation && !g_uiFunctionToAV) {
	//	  causeAV(uiFunction);
	//}
	#endif
	
	//		  
	// Check to see if valid component and subcomponent IDs were received
	//
	if (uiFunction > OC_INIT_COMPONENT && uiFunction < OCP_TEST_PRIVATE_BASE)
	{
		if (!FindSubcomponentInformationNode((PTCHAR)lpcvComponentId,
														 (PTCHAR)lpcvSubcomponentId))
		{
			 Log(fn, SEV2, TEXT("ComponentSetupProc function received %s.%s. ")
								TEXT("This is not a valid component.subcomponent."),
								lpcvComponentId, lpcvSubcomponentId);
		}
	}
	
	//
	// Whenever the user hits the next or back button, check all
	// the needs dependencies, exclude dependencies, 
	// and parent child dependencies
	//	  
	if (uiFunction == OC_QUERY_SKIP_PAGE		 || 
		 uiFunction == OC_QUEUE_FILE_OPS		  ||
		 uiFunction == OC_ABOUT_TO_COMMIT_QUEUE ||
		 uiFunction == OC_COMPLETE_INSTALLATION)
	{	 
		//
		// Check selection status of components to make sure all 
		// dependency relationships are being fulfilled.
		//
		CheckNeedsDependencies();
		CheckExcludeDependencies();
		CheckParentDependencies();
	}
	
	//
	// Enable the use of private functions
	//
	g_bUsePrivateFunctions = TRUE;	  

	if (g_bTestExtended || !bFirstTime){
	
		bFirstTime = FALSE;
		
		// Prepare to call TestReturnValueAndAV
		raValue.tszComponent = NULL;
		raValue.tszSubComponent = NULL;
		raValue.bOverride = FALSE;
		raValue.iReturnValue = 0;
		
		TestReturnValueAndAV(lpcvComponentId, 
									lpcvSubcomponentId, 
									uiFunction, 
									uiParam1, 
									pvParam2,
									&raValue);
	
	}
	
	
	switch (uiFunction)
	{
		case  OC_PREINITIALIZE:
			//testAV(g_bAccessViolation);
#ifdef UNICODE
			testAV(g_bCrashUnicode);
#endif
		
			dwRetval = RunOcPreinitialize(lpcvComponentId, 
													lpcvSubcomponentId, 
													uiParam1);
			break;
			
		case OC_INIT_COMPONENT:
			__ASSERT(pvParam2 != NULL);
			
			//
			// Init the log, now that OC Manager knows whether we 
			// are ANSI or Unicode 
			//
			_stprintf(tsz, TEXT("%s.log"), (PTCHAR)lpcvComponentId);
			InitLog(tsz, TEXT("OCManager Test Log"), TRUE);
						
			dwRetval = RunOcInitComponent(lpcvComponentId,
													lpcvSubcomponentId,
													pvParam2);
#ifdef UNICODE
			if (g_bCloseInf && hInfGlobal != NULL){
				SetupCloseInfFile(pcdComponentData->hinfMyInfHandle);
			}
#endif	  

			// Let's read the INF file and decide the values of some global variables

			if ((pcdComponentData = LocateComponent(lpcvComponentId)) &&
				 (pcdComponentData->hinfMyInfHandle != NULL) && 
				 !(pcdComponentData->dwlFlags & SETUPOP_BATCH))
			{
				SetGlobalsFromINF(pcdComponentData->hinfMyInfHandle);
			}

			//if (g_bNoWizPage) {
				// Check is there is a default mode specified in [OCTest] section
				SetDefaultMode(pcdComponentData);
			//}
			break;
			
		case OC_QUERY_STATE:			
			dwRetval = RunOcQueryState(lpcvComponentId, 
												lpcvSubcomponentId);
			if (dwRetval == SubcompOn) {
				//MessageBox(NULL, TEXT("Let's turn it on"), TEXT("OC_QUERY_STATE"), MB_OK);
			}
			break;
			
		case OC_SET_LANGUAGE:
			dwRetval = RunOcSetLanguage(lpcvComponentId, 
												 lpcvSubcomponentId, 
												 uiParam1);
			if (g_bNoLangSupport) {
				//MessageBox(NULL, TEXT("No Language Support"), TEXT("OC_SET_LANGUAGE"), MB_OK);
				dwRetval = FALSE;
			}
			break;
			
		case OC_QUERY_IMAGE:
			if (g_bInvalidBitmap){
				dwRetval = 1000;
			}
			else{
				dwRetval = RunOcQueryImage(lpcvComponentId, 
													lpcvSubcomponentId, 
													pvParam2);
			}
			break;
			
		case OC_REQUEST_PAGES:

			if (g_bNoWizPage){
				dwRetval = 0;
			}
			else{
				dwRetval = RunOcRequestPages(lpcvComponentId, 
													  uiParam1, 
													  pvParam2);
			}
			break;
			
		case OC_QUERY_CHANGE_SEL_STATE:
			dwRetval = RunOcQueryChangeSelState(lpcvComponentId, 
															lpcvSubcomponentId, 
															uiParam1);
			break;
			
		case OC_CALC_DISK_SPACE: 
			dwRetval = RunOcCalcDiskSpace(lpcvComponentId, 
													lpcvSubcomponentId, 
													uiParam1, 
													pvParam2);
			break;
			
		case OC_QUEUE_FILE_OPS:
			dwRetval = RunOcQueueFileOps(lpcvComponentId, 
												  lpcvSubcomponentId, 
												  pvParam2);
			break;
			
		case OC_NEED_MEDIA:
			//if (!g_bNoNeedMedia){
			//	  dwRetval = RunOcNeedMedia(lpcvComponentId, 
			//										uiParam1, 
			//										pvParam2);
			//}
			//else{
				dwRetval = NO_ERROR;
				Log(fn, SEV2, TEXT("OC_NEED_MEDIA is passed in for %s.%s. ")
								  TEXT("This should not happen according to the spec."),
								  lpcvComponentId, lpcvSubcomponentId);
				//MessageBox(NULL, TEXT("OC_NEED_MEDIA is passed to the DLL."), TEXT("OC_NEED_MEDIA"), MB_OK);
			//}
			break;
			
		case OC_QUERY_STEP_COUNT:
			dwRetval = RunOcQueryStepCount(lpcvComponentId);
			break;
			
		case OC_COMPLETE_INSTALLATION:
			dwRetval = RunOcCompleteInstallation(lpcvComponentId, 
															 lpcvSubcomponentId);

			if (g_bReboot) {
				if ((pcdComponentData = LocateComponent(lpcvComponentId)) &&
					 (pcdComponentData->hinfMyInfHandle != NULL) && 
					 !(pcdComponentData->dwlFlags & SETUPOP_BATCH))
				{
					//MessageBox(NULL, TEXT("A reboot is queued"), TEXT("Reboot"), MB_OK);
					//OcHelperSetReboot(pcdComponentData->ocrHelperRoutines.OcManagerContext, NULL);
					pcdComponentData->ocrHelperRoutines.SetReboot(pcdComponentData->ocrHelperRoutines.OcManagerContext,TRUE);
				}				 
			}
			break;
			
		case OC_CLEANUP:
			dwRetval = RunOcCleanup(lpcvComponentId);
			break;
				
		case OCP_TEST_PRIVATE_BASE:
			dwRetval = RunTestOcPrivateBase(lpcvSubcomponentId, 
													  uiParam1, 
													  pvParam2);
			break;

		case OCP_CHECK_NEEDS:
			
			if (pcdComponentData = LocateComponent(lpcvComponentId))
			{
				dwRetval = CheckLocalNeedsDependencies(
											 pcdComponentData->ocrHelperRoutines,
											 (PSUBCOMP)uiParam1,
											 ((PCHECK_NEEDS)pvParam2)->pclNeeds,
											 ((PCHECK_NEEDS)pvParam2)->tszNodesVisited);
			
				((PCHECK_NEEDS)pvParam2)->bResult = (BOOL)dwRetval;
				dwRetval = (DWORD)pvParam2;
			}
			else
			{
				Log(fn, SEV2, TEXT("Could not get component data of %s"),
								  lpcvComponentId);    
			}	 
			break;

		default: 
			dwRetval = (DWORD)FALSE;
	}

	if ((g_bTestExtended || !bFirstTime) && BeginTest() && raValue.bOverride){
		return raValue.iReturnValue;
	}
	else {
		return dwRetval;
	}

} // ComponentSetupProc //




/*++

Routine Description: RunOcPreinitialize (1.7)

	 Code to run if OC_PREINITIALIZE is called.
	 
Arguments:

	 lpcvComponentId:	  supplies the id for the component. 
	 lpcvSubcomponentId: supplies the id for the subcomponent. 
	 uiParam1:				its meaning depends on the function.
	
Return Value:

	 DWORD: returns error status

--*/
DWORD RunOcPreinitialize(IN LPCVOID lpcvComponentId, 
								 IN LPCVOID lpcvSubcomponentId, 
								 IN UINT	 uiParam1)
{								  
	DWORD dwComponentReturnValue = NO_ERROR;
	
	//
	// If the test is not extended, the return value
	// matches the native character width.
	//
	#ifdef UNICODE
	dwComponentReturnValue = OCFLAG_UNICODE;
	#else
	dwComponentReturnValue = OCFLAG_ANSI;
	#endif

	return dwComponentReturnValue;
	
} // RunOcPreinitialize //




/*++

Routine Description: RunOcInitComponent (1.8)

	 Code to run if OC_INIT_COMPONENT is called.
	 
Arguments:

	 lpcvComponentId:	  supplies the id for the component. 
	 lpcvSubcomponentId: supplies the id for the subcomponent. 
	 pvParam2:				its meaning depends on the function.
	
Return Value:

	 DWORD: returns error status

--*/
DWORD RunOcInitComponent(IN LPCVOID lpcvComponentId,
								 IN LPCVOID lpcvSubcomponentId,
								 IN PVOID	 pvParam2)
{								  
	double fn = 1.8;
	
	PSETUP_INIT_COMPONENT psicInitComponent;
	PCOMPONENT_DATA 		pcdComponentData; 

	DWORD dwComponentReturnValue = NO_ERROR;

	TCHAR tszFunctionName[256];
	BOOL bSuccess;

	INFCONTEXT infContext;

	int nRequiredBufferSize = 255;
	
	TCHAR tszMsg[256];
	
	psicInitComponent = (PSETUP_INIT_COMPONENT)pvParam2;
	
	hInfGlobal = psicInitComponent->OCInfHandle;


	if (pcdComponentData = AddNewComponent(lpcvComponentId))
	{
		//
		// Save the INF file handle
		//
		pcdComponentData->hinfMyInfHandle = 
			(psicInitComponent->ComponentInfHandle == INVALID_HANDLE_VALUE)
			? NULL : psicInitComponent->ComponentInfHandle;
				
		if (pcdComponentData->hinfMyInfHandle)
		{
			SetupOpenAppendInfFile(NULL, 
										  pcdComponentData->hinfMyInfHandle, 
										  NULL); 
		}
				
		CreateSubcomponentInformationList(pcdComponentData->hinfMyInfHandle);
		
		_tcscpy(pcdComponentData->tszSourcePath, 
				  psicInitComponent->SetupData.SourcePath);
				
		_tcscpy(pcdComponentData->tszUnattendFile, 
				  psicInitComponent->SetupData.UnattendFile);
				
		pcdComponentData->ocrHelperRoutines = 
			psicInitComponent->HelperRoutines;
		pcdComponentData->dwlFlags = 
			psicInitComponent->SetupData.OperationFlags;
		dwComponentReturnValue = NO_ERROR;

		//
		// Initialize the "witness" file queue
		// 
		if ((g_FileQueue = SetupOpenFileQueue()) == INVALID_HANDLE_VALUE)
		{
			Log(fn, SEV2, TEXT("Unable to create file queue"));
		}

		// Determine where to AV
		bSuccess = SetupFindFirstLine(pcdComponentData->hinfMyInfHandle, TEXT("OCTest"), TEXT("AccessViolation"), &infContext);

		if (bSuccess) {
			pcdComponentData->bAccessViolation = TRUE;
			bSuccess = SetupGetStringField(&infContext, 1, tszFunctionName, 255, &nRequiredBufferSize);
			if (bSuccess) {
				//_stprintf(tszMsg, TEXT("An access violation will be generated at %s of %s"), tszFunctionName, lpcvComponentId);
				//MessageBox(NULL, tszMsg, TEXT("Access Violation"), MB_OK);
				pcdComponentData->uiFunctionToAV = GetOCFunctionName(tszFunctionName);
			}
		}
		else{
			pcdComponentData->bAccessViolation = FALSE;
		}
		 

		//
		// Test the helper routines
		//
		TestHelperRoutines(lpcvComponentId,
								 pcdComponentData->ocrHelperRoutines);
	} 
	else
	{
		dwComponentReturnValue = ERROR_NOT_ENOUGH_MEMORY;
	}

	if (g_bTestExtended && (dwComponentReturnValue == NO_ERROR))
	{
		//
		// Let the user decide if the component is 
		// compatible with the OC Manager
		//
		ChooseVersionEx(lpcvComponentId, psicInitComponent);
		//ChooseAccessViolationEx();
	} 
	else
	{
		//
		// We put the same component version to be sure that can go on
		//
		psicInitComponent->ComponentVersion = 
			psicInitComponent->OCManagerVersion;
	}

	return dwComponentReturnValue;
	
} // RunOcInitComponent //




/*++

Routine Description: RunOcQueryState (1.9)

	 Code to run if OC_QUERY_STATE is called.
	 
Arguments:

	 lpcvComponentId:	  supplies the id for the component. 
	 lpcvSubcomponentId: supplies the id for the subcomponent. 
	
Return Value:

	 DWORD: returns error status

--*/
DWORD RunOcQueryState(IN LPCVOID lpcvComponentId,
							 IN LPCVOID lpcvSubcomponentId)
{							  
	PCOMPONENT_DATA pcdComponentData = NULL;
			
	DWORD dwComponentReturnValue = NO_ERROR;	

	BOOL bSuccess;

	TCHAR tszKeyName[256];
	
	INFCONTEXT infContext;

	int nRequiredSize;

	TCHAR tszState[256];
	
	if (pcdComponentData = LocateComponent(lpcvComponentId))
	{
		if (!g_bTestExtended)
		{
			dwComponentReturnValue = SubcompUseOcManagerDefault;
		} 
		else
		{
			dwComponentReturnValue = 
				ChooseSubcomponentInitialState(lpcvComponentId, 
														 lpcvSubcomponentId);
		}
		
		_stprintf(tszKeyName, TEXT("%s.initState"),lpcvSubcomponentId);

		//MessageBox(NULL, TEXT("Going to look for the key"), tszKeyName, MB_OK);

		bSuccess = SetupFindFirstLine(pcdComponentData->hinfMyInfHandle,
												TEXT("OCTest"),
												tszKeyName,
												&infContext);

		if (bSuccess) {
			//MessageBox(NULL, TEXT("Key Found"), tszKeyName, MB_OK);
			bSuccess = SetupGetStringField(&infContext,
													 1,
													 tszState,
													 255,
													 &nRequiredSize);
			if (bSuccess) {
				//MessageBox(NULL, TEXT("String field fetched"), tszState, MB_OK);
				if (_tcscmp(tszState, TEXT("On")) == 0) {
					dwComponentReturnValue = SubcompOn;
				}
				else if (_tcscmp(tszState, TEXT("Off")) == 0) {
					dwComponentReturnValue = SubcompOff;
				}
				else{
					dwComponentReturnValue = SubcompUseOcManagerDefault;
				}
			}
		}

		//
		// Test the helper routines
		//
		TestHelperRoutines(lpcvComponentId,
								 pcdComponentData->ocrHelperRoutines);
	} 
	else
	{
		dwComponentReturnValue = SubcompUseOcManagerDefault;
	}

	return dwComponentReturnValue;
	
} // RunOcQueryState //




/*++

Routine Description: RunOcSetLanguage (1.11)

	 Code to run if OC_SET_LANGUAGE is called.
	 
Arguments:

	 lpcvComponentId:	  supplies the id for the component. 
	 lpcvSubcomponentId: supplies the id for the subcomponent. 
	 uiParam1:				its meaning depends on the function.
	
Return Value:

	 DWORD: returns error status

--*/
DWORD RunOcSetLanguage(IN LPCVOID lpcvComponentId,
							  IN LPCVOID lpcvSubcomponentId,
							  IN UINT	  uiParam1)
{							   
	DWORD			   dwComponentReturnValue = NO_ERROR;
	PCOMPONENT_DATA pcdComponentData; 
	
	if (pcdComponentData = LocateComponent(lpcvComponentId))
	{
		//
		// If we won't support the language, the OC Manager won't 
		// continue, so we have to return TRUE
		//
		dwComponentReturnValue = (DWORD)TRUE;
		pcdComponentData->LanguageId = (LANGID)uiParam1;
				
		//
		// Test the helper routines
		//
		TestHelperRoutines(lpcvComponentId,
								 pcdComponentData->ocrHelperRoutines);
	} 
	else
	{
		dwComponentReturnValue = (DWORD)FALSE;
	}

	return dwComponentReturnValue;
	
} // RunOcSetLanguage //




/*++

Routine Description: RunOcQueryImage (1.12)

	 Code to run if OC_QUERY_IMAGE is called.
	 
Arguments:

	 lpcvComponentId:	  supplies the id for the component. 
	 lpcvSubcomponentId: supplies the id for the subcomponent. 
	 pvParam2:				its meaning depends on the function.
	
Return Value:

	 DWORD: returns error status

--*/
DWORD RunOcQueryImage(IN LPCVOID lpcvComponentId,
							 IN LPCVOID lpcvSubcomponentId,
							 IN PVOID	 pvParam2)
{							  
	double fn = 1.12;
	
	DWORD			   dwComponentReturnValue = NO_ERROR;
	BOOL				bAux;
	TCHAR			   tszMsg[MAX_MSG_LEN]; 
	TCHAR			   tszResourceName[MAX_PATH]; 
	INFCONTEXT		  infContext;
	PCOMPONENT_DATA pcdComponentData; 
			
	
	#ifdef DEBUG
	Log(fn, INFO, TEXT("Height = %d, Width = %d"), 
					  HIWORD(pvParam2), LOWORD(pvParam2)); 
	#endif
			
	if ((pcdComponentData = LocateComponent(lpcvComponentId)) && 
		 (pcdComponentData->hinfMyInfHandle))
	{
		__ASSERT(LOWORD(uiParam1) == SubCompInfoSmallIcon);
		
		_stprintf(tszMsg, TEXT("%s.%s"), lpcvComponentId, lpcvSubcomponentId);
				
		if (SetupFindFirstLine(pcdComponentData->hinfMyInfHandle, tszMsg, 
									  TEXT("Bitmap"), &infContext))
		{
			bAux = SetupGetStringField(&infContext, 1, tszResourceName, 
												sizeof(tszResourceName) / 
												sizeof(TCHAR), NULL);
					
			if (bAux)
			{
				//
				// Try to use Param1 and Param2 to resize the icon
				//
				dwComponentReturnValue = (DWORD)LoadBitmap(g_hDllInstance, 
																		 tszResourceName);
				  
				bAux = SetBitmapDimensionEx((HBITMAP)dwComponentReturnValue, 
													 LOWORD(pvParam2),	
													 HIWORD(pvParam2), 
													 NULL);
				#ifdef DEBUG
				if (bAux)
				{
					Log(fn, PASS, TEXT("Success"));
				} 
				else
				{
					_stprintf(tszMsg, TEXT("Can't resize %d"), 
											GetLastError());
					Log(fn, PASS, tszMsg);
				}
				#endif
			}
		}
				
		//
		// Test the helper routines
		//
		TestHelperRoutines(lpcvComponentId,
								 pcdComponentData->ocrHelperRoutines);
	}

	return dwComponentReturnValue;

} // RunOcQueryImage //




/*++

Routine Description: RunOcRequestPages (1.13)

	 Code to run if OC_REQUEST_PAGES is called.
	 
Arguments:

	 lpcvComponentId:  supplies the id for the component. 
	 uiParam1:			  its meaning depends on the function.
	 pvParam2:			  its meaning depends on the function.
	
Return Value:

	 DWORD: returns error status

--*/
DWORD RunOcRequestPages(IN LPCVOID lpcvComponentId,
								IN UINT 	uiParam1,
								IN PVOID	pvParam2)
{
	DWORD			   dwComponentReturnValue = NO_ERROR;
	PCOMPONENT_DATA pcdComponentData; 
	TCHAR			   tsz[256];
	
	if (pcdComponentData = LocateComponent(lpcvComponentId))
	{
		dwComponentReturnValue = DoPageRequest(
													 pcdComponentData->tszComponentId, 
													 uiParam1, 
													 (PSETUP_REQUEST_PAGES)pvParam2, 
													 pcdComponentData->ocrHelperRoutines);
				
		//
		// Test the helper routines
		//
		TestHelperRoutines(lpcvComponentId,
								 pcdComponentData->ocrHelperRoutines);
	} 
	else
	{
		//
		// Some kind of error, 0 pages 
		//
		dwComponentReturnValue = -1;
	}
	
	return dwComponentReturnValue;

} // RunOcRequestPages //




/*++

Routine Description: RunOcQueryChangeSelState (1.14)

	 Code to run if OC_QUERY_CHANGE_SEL_STATE is called.
	 
Arguments:

	 lpcvComponentId:	  supplies the id for the component. 
	 lpcvSubcomponentId: supplies the id for the subcomponent. 
	 uiParam1:				its meaning depends on the function.
	
Return Value:

	 DWORD: returns error status

--*/
DWORD RunOcQueryChangeSelState(IN LPCVOID lpcvComponentId, 
										 IN LPCVOID lpcvSubcomponentId, 
										 IN UINT	 uiParam1)
{										  
	DWORD			   dwComponentReturnValue = TRUE;
	TCHAR			   tszText[MAX_MSG_LEN];
	TCHAR			   tszSectionName[MAX_MSG_LEN];
	INFCONTEXT		  infContext;
	PCOMPONENT_DATA pcdComponentData; 
			
	if ((pcdComponentData = LocateComponent(lpcvComponentId)) &&
		 (pcdComponentData->hinfMyInfHandle != NULL) && 
		 !(pcdComponentData->dwlFlags & SETUPOP_BATCH))
	{
		//
		// Check to see if this component should refuse to enable or
		// disable. The component should refuse if there is a field
		// called "RefuseSelect" or "RefuseDeselect" in the INF file.
		//
		if (lpcvSubcomponentId == NULL || 
			 _tcscmp((PTCHAR)lpcvSubcomponentId, TEXT("(null)")) == 0 ||
			 ((PTCHAR)lpcvSubcomponentId)[0] == TEXT('\0'))
		{
			_stprintf(tszSectionName, (PTCHAR)lpcvComponentId);
		}
		else
		{
			_stprintf(tszSectionName, (PTCHAR)lpcvSubcomponentId);
		}
		
		if (SetupFindFirstLine(
						  pcdComponentData->hinfMyInfHandle, 
						  tszSectionName,
						  uiParam1 ? TEXT("RefuseSelect") : TEXT("RefuseDeselect"),
						  &infContext))
		{
			dwComponentReturnValue = FALSE;
		}
				
		//
		// Test the helper routines
		//
		TestHelperRoutines(lpcvComponentId,
								 pcdComponentData->ocrHelperRoutines);
	} 
	else
	{
		dwComponentReturnValue = FALSE;
	}

	return dwComponentReturnValue;

} // RunOcQueryChangerSelState //




/*++

Routine Description: RunOcCalcDiskSpace (1.15)

	 Code to run if OC_CALC_DISK_SPACE is called.
	 
Arguments:

	 lpcvComponentId:	  supplies the id for the component. 
	 lpcvSubcomponentId: supplies the id for the subcomponent. 
	 uiParam1:				its meaning depends on the function.
	 pvParam2:				its meaning depends on the function.
	
Return Value:

	 DWORD: returns error status

--*/
DWORD RunOcCalcDiskSpace(IN LPCVOID lpcvComponentId, 
								 IN LPCVOID lpcvSubcomponentId, 
								 IN UINT	 uiParam1,
								 IN PVOID	 pvParam2)
{								  
	DWORD			   dwComponentReturnValue = TRUE;
	BOOL				bAux, bRetval;
	TCHAR			   tszSectionName[MAX_PATH];
	TCHAR			   tszMsg[MAX_MSG_LEN];
	PCOMPONENT_DATA pcdComponentData; 
	INFCONTEXT		  infContext;
			
	if ((pcdComponentData = LocateComponent(lpcvComponentId)) &&
		 (pcdComponentData->hinfMyInfHandle))
	{
		//
		// Check to see if the file to be copied in this section is called
		// "hugefile.txt"  If it is, don't add the real size of this file.
		// Instead, add a gigantic file size so large that there won't
		// be enough disk space to complete the operation.
		//
		_stprintf(tszMsg, TEXT("%s.%s.copyfiles"),
								lpcvComponentId, lpcvSubcomponentId);
								
		bAux = SetupFindFirstLine(pcdComponentData->hinfMyInfHandle, 
										  tszSectionName, 
										  TEXT("hugefile.txt"),
										  &infContext);

		bAux = bAux && g_bHugeSize;
		 
		if (bAux)
		{
			//
			// hugefile.txt is present. 
			//
			if (uiParam1)
			{
				//
				// Add gigantic file size
				//
				bRetval = SetupAddToDiskSpaceList((HDSKSPC)pvParam2, 
															 TEXT("c:\\file.big"), 
															 ONE_HUNDRED_GIG, 
															 FILEOP_COPY,
															 0, 0);
			}
			else
			{
				//
				// Remove a gigantic file size
				//
				bRetval = SetupAddToDiskSpaceList((HDSKSPC)pvParam2, 
															 TEXT("c:\\file.big"), 
															 ONE_HUNDRED_GIG, 
															 FILEOP_COPY,
															 0, 0);
			}
		}
		else
		{
			//
			// Get the section name
			//
			_stprintf(tszMsg, TEXT("%s.%s"), lpcvComponentId, lpcvSubcomponentId);
				
			if (uiParam1)
			{
				//
				// Adding
				//
				bRetval = SetupAddInstallSectionToDiskSpaceList(
														 (HDSKSPC)pvParam2,
														 pcdComponentData->hinfMyInfHandle,
														 NULL, tszMsg, 0, 0);
			} 
			else
			{
				//
				// Removing
				//
				bRetval = SetupRemoveInstallSectionFromDiskSpaceList(
														 (HDSKSPC)pvParam2, 
														 pcdComponentData->hinfMyInfHandle,
														 NULL, tszMsg, 0, 0);
			}
		}
		
		dwComponentReturnValue = bRetval ? NO_ERROR : GetLastError();

				
		//
		// Test the helper routines
		//
		TestHelperRoutines(lpcvComponentId,
								 pcdComponentData->ocrHelperRoutines);
	} 
	else
	{
		dwComponentReturnValue = ERROR_NOT_ENOUGH_MEMORY;
	}
 
	return dwComponentReturnValue;
 
} // RunOcCalcDiskSpace //




/*++				  

Routine Description: RunOcQueueFileOps (1.16)

	 Code to run if OC_QUEUE_FILE_OPS is called.
	 
Arguments:

	 lpcvComponentId:	  supplies the id for the component. 
	 lpcvSubcomponentId: supplies the id for the subcomponent. 
	 pvParam2:				its meaning depends on the function.
	
Return Value:

	 DWORD: returns error status

--*/
DWORD RunOcQueueFileOps(IN LPCVOID lpcvComponentId, 
								IN LPCVOID lpcvSubcomponentId, 
								IN PVOID	pvParam2)
{								 
	double fn = 1.16;
	
	DWORD			   dwComponentReturnValue = NO_ERROR;
	BOOL				bAux;
	BOOL				bCurrentState, bOriginalState;
	TCHAR			   tszMsg[MAX_MSG_LEN];
	TCHAR			   tszSectionName[MAX_PATH];
	INFCONTEXT		  infContext;
	PCOMPONENT_DATA pcdComponentData; 
	PSUBCOMP		  pscTemp;
			
	//
	// Check to make sure this subcomponent is allowed to do work.
	// If the subcomponent is not a bottom leaf on the subcomponent
	// tree, it is not allowed to do any work. So we will check to 
	// see if it has any children.
	//
	for (pscTemp = g_pscHead; pscTemp != NULL; pscTemp = pscTemp->Next)
	{
		if (lpcvSubcomponentId && _tcscmp(pscTemp->tszSubcomponentId, 
													 (PTCHAR)lpcvSubcomponentId) == 0)
		{
			if (pscTemp->pclChildren)
			{
				//
				// This subcomponent has children. OcManager should not be
				// try to queue file ops for this subcomponent. This is
				// a failure.
				//
				Log(fn, SEV2, TEXT("OC Manager is trying to queue file ops ")
								  TEXT("for subcomponent %s of component %s. ")
								  TEXT("This subcomponent has children and ")
								  TEXT("should not be allowed to do any work."),
								  lpcvSubcomponentId, lpcvComponentId);
				
				return NO_ERROR;
			}
		}
	}
	
	if (lpcvSubcomponentId && 
		 (pcdComponentData = LocateComponent(lpcvComponentId)))
	{
		//
		// Get original and current state. If the state didn't change,
		// nothing to do.
		//
		bOriginalState = 
			pcdComponentData->ocrHelperRoutines.QuerySelectionState(
								pcdComponentData->ocrHelperRoutines.OcManagerContext,
								lpcvSubcomponentId,
								OCSELSTATETYPE_ORIGINAL);

		bCurrentState = 
			pcdComponentData->ocrHelperRoutines.QuerySelectionState(
								pcdComponentData->ocrHelperRoutines.OcManagerContext,
								lpcvSubcomponentId,
								OCSELSTATETYPE_CURRENT);

		_stprintf(tszSectionName, TEXT("%s.%s"), 
										  lpcvComponentId, lpcvSubcomponentId);

		bAux = TRUE;
																				
		if (!bCurrentState)
		{
			//
			// Being uninstalled. Fetch uninstall section name.
			//
			bAux = SetupFindFirstLine(pcdComponentData->hinfMyInfHandle, 
											  tszSectionName, 
											  TEXT("Uninstall"),
											  &infContext);

			if (bAux)
			{
				bAux = SetupGetStringField(&infContext, 1, tszSectionName, 
													sizeof(tszSectionName) / 
													sizeof(TCHAR), NULL);
			}
		}

		if (bAux)
		{
			bAux = SetupInstallFilesFromInfSection(
												 pcdComponentData->hinfMyInfHandle, 
												 NULL, 
												 pvParam2,
												 tszSectionName, 
												 pcdComponentData->tszSourcePath,
												 bCurrentState ? SP_COPY_NEWER : 0);
					
			SetupInstallFilesFromInfSection(
												 pcdComponentData->hinfMyInfHandle,
												 NULL, 
												 g_FileQueue, 
												 tszSectionName, 
												 pcdComponentData->tszSourcePath,
												 bCurrentState ? SP_COPY_NEWER : 0);
					
			dwComponentReturnValue = bAux ? NO_ERROR : GetLastError();
		}
				
		//
		// Test the helper routines
		//
		TestHelperRoutines(lpcvComponentId,
								 pcdComponentData->ocrHelperRoutines);
	}

	return dwComponentReturnValue;

} // RunOcQueueFileOps //




/*++

Routine Description: RunOcNeedMedia (1.17)

	 Code to run if OC_NEED_MEDIA is called.
	 
Arguments:

	 lpcvComponentId:  supplies the id for the component. 
	 uiParam1:			  its meaning depends on the function.
	 pvParam2:			  its meaning depends on the function.
	
Return Value:

	 DWORD: returns error status

--*/
DWORD RunOcNeedMedia(IN LPCVOID lpcvComponentId, 
							IN UINT 	uiParam1, 
							IN PVOID	pvParam2)
{			 
	PVOID pvQueueContext;
	DWORD dwComponentReturnValue;
	
	//
	// Nothing special to do if media is needed
	// Call the default queue routine
	//
	pvQueueContext = SetupInitDefaultQueueCallback(NULL);
	dwComponentReturnValue = SetupDefaultQueueCallback(pvQueueContext, 
																		SPFILENOTIFY_NEEDMEDIA, 
																		uiParam1, 
																		(UINT)pvParam2);
			
	 SetupTermDefaultQueueCallback(pvQueueContext);

	 return dwComponentReturnValue;
	 
} // RunOcNeedMedia //




/*++

Routine Description: RunOcQueryStepCount (1.18)

	 Code to run if OC_QUERY_STEP_COUNT is called.
	 
Arguments:

	 lpcvComponentId: supplies the id for the component. 
	
Return Value:

	 DWORD: returns error status

--*/
DWORD RunOcQueryStepCount(IN LPCVOID lpcvComponentId)
{
	PCOMPONENT_DATA pcdComponentData; 
			 
	if (pcdComponentData = LocateComponent(lpcvComponentId))
	{
		//
		// Test the helper routines
		//
		TestHelperRoutines(lpcvComponentId,
								 pcdComponentData->ocrHelperRoutines);
	} 

	return NO_STEPS_FINAL;

} // RunOcQueryStepCount //



			
/*++

Routine Description: RunOcCompleteInstallation (1.19)

	 Code to run if OC_COMPLETE_INSTALLATION is called.
	 
Arguments:

	 lpcvComponentId:	  supplies the id for the component. 
	 lpcvSubcomponentId: supplies the id for the subcomponent. 
	
Return Value:

	 DWORD: returns error status

--*/
DWORD RunOcCompleteInstallation(IN LPCVOID lpcvComponentId, 
										  IN LPCVOID lpcvSubcomponentId)
{										   
	double fn = 1.19;
	
	DWORD			   dwComponentReturnValue = NO_ERROR;
	DWORD			   dwResult;
	INT 				iCount;
	BOOL				bAux;
	TCHAR			   tszMsg[MAX_MSG_LEN];
	PVOID			   pvCallbackContext;
	PCOMPONENT_DATA pcdComponentData; 
	
	//
	// Output the name of the component that is currently working
	//
	_stprintf(tszMsg, TEXT("OC_COMPLETE_INSTALLATION: Copying files for %s\n"), lpcvSubcomponentId);
	OutputDebugString(tszMsg);
			
	if (pcdComponentData = LocateComponent(lpcvComponentId))
	{
		// 
		// We perform the check for the top-level component 
		// We will scan the witness queue
		//
		pvCallbackContext = SetupInitDefaultQueueCallback(NULL);
				
		bAux = SetupScanFileQueue(g_FileQueue, 
										  SPQ_SCAN_FILE_PRESENCE, 
										  NULL, 
										  SetupDefaultQueueCallback, 
										  pvCallbackContext, 
										  &dwResult);
				
		SetupTermDefaultQueueCallback(pvCallbackContext);
				
		if (!dwResult)
		{
			Log(fn, SEV2, TEXT("Not all the files are on the target!"));
		}

		//
		// Check the helper routines
		//
		for (iCount = 0; iCount < nStepsFinal; iCount++)
		{
			//
			// From time to time (every 3 "ticks") change the progress text 
			//
			pcdComponentData->ocrHelperRoutines.TickGauge(
							  pcdComponentData->ocrHelperRoutines.OcManagerContext);
					
			if (iCount % 3 == 1)
			{
				_stprintf(tszMsg, TEXT("%s Progress Text Changed Step %d "), 
										lpcvSubcomponentId, iCount); 
				
				pcdComponentData->ocrHelperRoutines.SetProgressText(
								pcdComponentData->ocrHelperRoutines.OcManagerContext,
								tszMsg);
			}
					
			Sleep(10 * TICK_TIME);
		} 

		//
		// Test the helper routines
		//
		TestHelperRoutines(lpcvComponentId,
								 pcdComponentData->ocrHelperRoutines);
	} 
	else
	{
		dwComponentReturnValue = ERROR_NOT_ENOUGH_MEMORY;
	}

	return dwComponentReturnValue;

} // RunOcCompleteInstallation //




/*++

Routine Description: RunOcCleanup (1.21)

	 Code to run if OC_CLEANUP is called.
	 
Arguments:

	 lpcvComponentId: supplies the id for the component. 
	
Return Value:

	 DWORD: returns error status

--*/
DWORD RunOcCleanup(IN LPCVOID lpcvComponentId)
{
	UINT uiCount;
	
	RemoveComponent(lpcvComponentId);	 
			
	g_bFirstTime = TRUE;
			
	//
	// Close the witness file queue
	//
	SetupCloseFileQueue(g_FileQueue);

	return NO_ERROR;
	
} // RunOcCleanup //




/*++

Routine Description: RunTestOcPrivateBase (1.22)

	 Code to run if OCP_TEST_PRIVATE_BASE is called.
	 
Arguments:

	 lpcvSubcomponentId: supplies the id for the subcomponent. 
	 uiParam1:				its meaning depends on the function.
	 pvParam2:				its meaning depends on the function.
	
Return Value:

	 DWORD: returns error status

--*/
DWORD RunTestOcPrivateBase(IN LPCVOID lpcvSubcomponentId, 
									IN UINT 	uiParam1, 
									IN PVOID	pvParam2)
{							   
	//
	// Will send back the value in Param1.
	// But first, assert that the subcomponent is NULL, 
	// as well as the Param2
	//
	__ASSERT((lpcvSubcomponentId == NULL) && (pvParam2 == NULL));

	return uiParam1;

} // RunTestOcPrivateBase //			




/*++

Routine Description: TestHelperRoutines (1.5)

	Tests the helper routines, using the functions above.
	
Arguments:

	OCManagerRoutines: the helper routines.
	
Return Value:

	DWORD: error return

--*/
DWORD TestHelperRoutines(IN LPCVOID lpcvComponentId,
								 IN OCMANAGER_ROUTINES OCManagerRoutines)
{
	double fn = 1.5;
	
	DWORD dwPreviousMode, dwSetPreviousMode, dwSetupMode, dwRandomSetupMode;
	DWORD dwComponentReturnValue;
	DWORD dwError;
	TCHAR tszMsg[MAX_MSG_LEN];
	BOOL  bQueryReturn;

	//
	// Test TickGauge - the call is ignored except when the component
	// is allowed to perform its own (final) setup and informs the OC Manager
	// about the number of steps this setup will require. 
	// For each such step, the OC Manager ticks the gauge once.
	//
	OCManagerRoutines.TickGauge(OCManagerRoutines.OcManagerContext);

	//
	// Test SetProgressText - the call is ignored except the final stage
	// (the text above the tick gauge is set this way)
	//
	OCManagerRoutines.SetProgressText(OCManagerRoutines.OcManagerContext, 
												 TEXT("Progress text"));
	
	//
	// Test Get/SetPrivateData
	//
	TestPrivateData(OCManagerRoutines);

	//
	// Test Get/SetSetupMode
	//
	
	//
	// Get the original mode first
	//
	dwPreviousMode = OCManagerRoutines.GetSetupMode(
													  OCManagerRoutines.OcManagerContext);
	
	dwRandomSetupMode = (DWORD)rand();
	
	//
	// The return value should be the previous mode
	//
	dwSetPreviousMode =  OCManagerRoutines.SetSetupMode(
														OCManagerRoutines.OcManagerContext, 
														dwRandomSetupMode);

	if (dwPreviousMode != dwSetPreviousMode)
	{
		Log(fn, SEV2, TEXT("SetSetupMode failed. Return value is not equal ")
						  TEXT("to previous mode: Previous = %lu Return = %lu ") 
						  TEXT("New Mode = %lu"), 
						  dwPreviousMode, dwSetPreviousMode, dwRandomSetupMode);
	}
	else
	{
		//
		// Set the mode again
		// The first 24 bits are private data, the last 8 are the mode
		//
		dwSetupMode = ((DWORD)rand()) << 8;
	
		//
		// So, get the last 8 bits from PreviousMode
		//
		dwSetupMode |= (dwPreviousMode & 0xFF);
		dwSetPreviousMode =  OCManagerRoutines.SetSetupMode(
														OCManagerRoutines.OcManagerContext, 
														dwSetupMode);
	
		if (dwRandomSetupMode != dwSetPreviousMode)
		{
			Log(fn, SEV2, TEXT("SetSetupMode failed. Return value is not ")
							  TEXT("equal to previous mode: Previous = %lu ")
							  TEXT("Return = %lu New Mode = %lu"), 
							  dwRandomSetupMode, dwSetPreviousMode, dwSetupMode);
		}
	}
	
	//
	// Leave the mode back at its original state
	//
	dwSetPreviousMode =  OCManagerRoutines.SetSetupMode(
														OCManagerRoutines.OcManagerContext, 
														dwPreviousMode);
	
	//
	// Test QuerySelectionState
	//
	
	//
	// Perform negative testing first : use an inexistent component name
	// Expect to get ERROR_INVALID_NAME
	//
	bQueryReturn = OCManagerRoutines.QuerySelectionState(
														OCManagerRoutines.OcManagerContext, 
														TEXT("Phony component"), 
														OCSELSTATETYPE_ORIGINAL);
	
	if ((bQueryReturn == FALSE) && 
		 ((dwError = GetLastError()) != ERROR_INVALID_NAME ))
	{
		Log(fn, SEV2, TEXT("QuerySelectionState returned error %lu ")
						  TEXT("when called with phony name"), dwError);
	}
	
	bQueryReturn = OCManagerRoutines.QuerySelectionState(
														OCManagerRoutines.OcManagerContext, 
														TEXT("Phony component"), 
														OCSELSTATETYPE_CURRENT);
	
	if ((bQueryReturn == FALSE) && 
		 ((dwError = GetLastError()) != ERROR_INVALID_NAME ))
	{
		Log(fn, SEV2, TEXT("QuerySelectionState returned error %lu ")
						  TEXT("when called with phony name"), dwError); 
	}

	SetLastError(NO_ERROR);
	
	//
	// Tests the private function calls
	// Save the return value first : this is done because another 
	// component is called and the return value is modified
	//
	dwComponentReturnValue = TestPrivateFunction(lpcvComponentId,
																OCManagerRoutines);

	return dwComponentReturnValue;

} // TestHelperRountines //




/*++

Routine Description: TestPrivateFunction (1.4)

	Tests the private function calls 
	(these are used for inter-component communication)
	
Arguments:

	OCManagerRoutines: the helper routines (CallPrivateFunction is a member 
														 of this structure)
	
Return Value:

	DWORD: error value

--*/
DWORD TestPrivateFunction(IN LPCVOID lpcvComponentId,
								  IN OCMANAGER_ROUTINES OCManagerRoutines)
{
	double fn = 1.4;
	
	DWORD	  dwComponentReturnValue = ERROR_SUCCESS;
	UINT	  uiRemoteResult = 0;
	UINT	  uiLocalResult = 0;
	UINT	  uiRandomValue = 0;
	BOOL	  bBlank = FALSE;
	BOOL	  bOtherComponent = FALSE;
	TCHAR	  tszComponent[MAX_PATH];
	TCHAR	  tszOtherComponent[MAX_PATH];
	TCHAR	  tszStandalone[MAX_PATH];
	TCHAR	  tszMsg[MAX_MSG_LEN];
	TCHAR	  tszSubComp[] = TEXT("");
	PSUBCOMP pscTemp;

	//
	// Copy the current component
	//
	_tcscpy(tszComponent, (PTCHAR)lpcvComponentId);
	
	//
	// Find another component, if one exists
	//
	for (pscTemp = g_pscHead; pscTemp != NULL; pscTemp = pscTemp->Next)
	{
		if (_tcscmp(tszComponent, pscTemp->tszComponentId) != 0)
		{
			bOtherComponent = TRUE;
			_tcscpy(tszOtherComponent, pscTemp->tszComponentId);
			break;
		}
	}

	//
	// 1. Call the same component
	//
	uiLocalResult = OCManagerRoutines.CallPrivateFunction(
														OCManagerRoutines.OcManagerContext, 
														tszComponent,
														tszSubComp, 
														OCP_TEST_PRIVATE_BASE, 
														0, 0, &uiRemoteResult);
	
	if (uiLocalResult != ERROR_BAD_ENVIRONMENT)
	{
		Log(fn, SEV2, TEXT("CallPrivateFunction: expected ")
						  TEXT("ERROR_BAD_ENVIRONMENT, received %lu"),
						  uiLocalResult);
		bBlank = TRUE;
	}

	//
	// 2. Call a non-existing component
	//
	uiLocalResult = OCManagerRoutines.CallPrivateFunction(
														OCManagerRoutines.OcManagerContext, 
														TEXT("No component"), 
														tszSubComp, 
														OCP_TEST_PRIVATE_BASE, 
														0, 0, &uiRemoteResult);
	
	if (uiLocalResult != ERROR_INVALID_FUNCTION)
	{
		Log(fn, SEV2, TEXT("CallPrivateFunction: expected ")
						  TEXT("ERROR_INVALID_FUNCTION, received %lu"),
						  uiLocalResult);
		bBlank = TRUE;
	}
	
	//
	// 3. Call the standalone component
	//
	uiLocalResult = OCManagerRoutines.CallPrivateFunction(
														OCManagerRoutines.OcManagerContext, 
														tszStandalone, 
														tszSubComp, 
														OCP_TEST_PRIVATE_BASE, 
														0, 0, &uiRemoteResult);
	
	if (uiLocalResult != ERROR_INVALID_FUNCTION)
	{
		Log(fn, SEV2, TEXT("CallPrivateFunction: expected ")
						  TEXT("ERROR_INVALID_FUNCTION, received %lu"),
						  uiLocalResult);
		bBlank = TRUE;
	}
	
	if (bOtherComponent)
	{
		//
		// 4. Call the other component with OC_PRIVATE_BASE - 1
		//
		uiLocalResult = OCManagerRoutines.CallPrivateFunction(
														OCManagerRoutines.OcManagerContext, 
														tszOtherComponent,
														tszSubComp, 
														OC_PRIVATE_BASE - 1, 
														0, 0, &uiRemoteResult);
	
		if (uiLocalResult != ERROR_INVALID_FUNCTION)
		{
			Log(fn, SEV2, TEXT("CallPrivateFunction: expected ")
							  TEXT("ERROR_INVALID_FUNCTION, received %lu"),
							  uiLocalResult);
			bBlank = TRUE;
		}

		//
		// 5. A normal call : we will supply a random number and will expect 
		//	   to receive as a result the same value. This is true if the 
		//	   private calls are allowed	  
		//
		uiRandomValue = (UINT)(rand() + 1);
	
		//
		// To be sure the two values are not equal
		//
		uiRemoteResult = 0;
		uiLocalResult = OCManagerRoutines.CallPrivateFunction(
														OCManagerRoutines.OcManagerContext, 
														tszOtherComponent, 
														tszSubComp, 
														OCP_TEST_PRIVATE_BASE, 
														uiRandomValue, 
														0, 
														&uiRemoteResult);
	
		if (uiLocalResult != ERROR_ACCESS_DENIED)
		{
			if (g_bUsePrivateFunctions && (uiLocalResult != NO_ERROR))
			{
				Log(fn, SEV2, TEXT("CallPrivateFunction called on %s for ")
								  TEXT("OCP_TEST_PRIVATE_BASE returned %lu"),
								  tszOtherComponent, uiLocalResult);
				bBlank = TRUE;
			}
	
			if (!g_bUsePrivateFunctions && 
				 (uiLocalResult != ERROR_BAD_ENVIRONMENT))
			{
				Log(fn, SEV2, TEXT("CallPrivateFunction: expected ")
								  TEXT("ERROR_BAD_ENVIRONMENT, received %lu"),
								  uiLocalResult);
				bBlank = TRUE;
			}
	
			if (g_bUsePrivateFunctions && (uiRemoteResult != uiRandomValue))
			{
				Log(fn, SEV2, TEXT("CallPrivateFunction: received invalid data ")
								  TEXT("from routine. Expected %lu, received %lu"),
								  uiRandomValue, uiRemoteResult);
				bBlank = TRUE;
			}
		}
	}
	
	if (bBlank) LogBlankLine();

	return dwComponentReturnValue;
	
} // TestPrivateFunction //




/*++

Routine Description: TestPrivateData (1.3)

	Checks all the OC Manager values against the local ones,
	then it randomly changes one value. 

Arguments:

	OCManagerRoutines: the helper routines (Get/SetPrivateData are members 
														 of this structure)
	
Return Value:

	void

--*/
VOID TestPrivateData(IN OCMANAGER_ROUTINES OCManagerRoutines)
{
	double fn = 1.3;
	
	PVOID		  pvBuffer;
	UINT		  uiCount, uiRandomValue;
	BOOL		  bResult;
	
	PRIVATE_DATA aPrivateDataTable[] = 
	{
		{TEXT("Binary value"),			  REG_BINARY,	 0, NULL, NULL},
		{TEXT("Binary value 2"),		 REG_BINARY,	0, NULL, NULL},
		{TEXT("String value"),			  REG_SZ,		  0, NULL, NULL},
		{TEXT("String value 2"),		 REG_SZ,		 0, NULL, NULL},
		{TEXT("Multi String value"),	REG_MULTI_SZ, 0, NULL, NULL},
		{TEXT("Multi String value 2"), REG_MULTI_SZ, 0, NULL, NULL},
		{TEXT("DWORD value"),			  REG_DWORD,	 0, NULL, NULL},
		{TEXT("DWORD value 2"), 		 REG_DWORD, 	0, NULL, NULL}
	};
	
	//
	// Set all the values
	//
	for (uiCount = 0; uiCount < MAX_PRIVATE_VALUES; uiCount++)
	{
		bResult = SetAValue(OCManagerRoutines, uiCount, aPrivateDataTable);
	}
		
	//
	// Check all the values against the local table
	//
	CheckPrivateValues(OCManagerRoutines, aPrivateDataTable);

	free(aPrivateDataTable[0].pvBuffer);
	free(aPrivateDataTable[1].pvBuffer);
	free(aPrivateDataTable[2].pvBuffer);
	free(aPrivateDataTable[3].pvBuffer);
	free(aPrivateDataTable[4].pbBuffer);
	free(aPrivateDataTable[5].pbBuffer);
	free(aPrivateDataTable[6].pvBuffer);
	free(aPrivateDataTable[7].pvBuffer);
	
	return;

} // TestPrivateData //




/*++

Routine Description: CheckPrivateValues (1.2)

	Checks the values of the private data stored by the OC Manager against
	those stored internally by the application.
	
Arguments:

	OCManagerRoutines: the helper routines (GetPrivateData is a member of 
														 this structure)
	
Return Value:

	void

--*/
VOID CheckPrivateValues(IN OCMANAGER_ROUTINES OCManagerRoutines,
								IN PRIVATE_DATA 		*aPrivateDataTable)
{
	double fn = 1.2;
	
	UINT	uiCount, uiSize, uiType;
	DWORD  dwErrorCode;
	PVOID  pvBuffer = NULL;
	PTCHAR tszBuffer;
	TCHAR  tszMsg[MAX_MSG_LEN];
	TCHAR  tszError[MAX_ERROR_LEN];

	for (uiCount = 0; uiCount < MAX_PRIVATE_VALUES; uiCount++)
	{
		//
		// First call is used only to get the size of the data
		// Only the second one will actually retrieve it
		//
		dwErrorCode = OCManagerRoutines.GetPrivateData(
													  OCManagerRoutines.OcManagerContext,
													  NULL,
													  aPrivateDataTable[uiCount].tszName,
													  NULL,
													  &uiSize,
													  &uiType);
		
		if (dwErrorCode != NO_ERROR)
		{
			Log(fn, SEV2, TEXT("GetPrivateData failed for %s: %s"), 
							  aPrivateDataTable[uiCount].tszName, 
							  ErrorMsg(dwErrorCode, tszError));
			continue;
		}
		
		
		if (pvBuffer) __Free(&pvBuffer);
		__Malloc(&pvBuffer, uiSize);
		
		dwErrorCode = OCManagerRoutines.GetPrivateData(
													 OCManagerRoutines.OcManagerContext,
													 NULL,
													 aPrivateDataTable[uiCount].tszName,
													 pvBuffer,
													 &uiSize,
													 &uiType);
		
		if (dwErrorCode != NO_ERROR)
		{
			Log(fn, SEV2, TEXT("GetPrivateData failed for %s: %s"),
							  aPrivateDataTable[uiCount].tszName, 
							  ErrorMsg(dwErrorCode, tszError));
			continue;
		}

		//
		// Now perform the actual checking
		// The type first
		//
		if (uiType != aPrivateDataTable[uiCount].uiType)
		{
			Log(fn, SEV2, TEXT("GetPrivateData: Retrieved type %d ")
							  TEXT("instead of %d"), 
							  uiType, aPrivateDataTable[uiCount].uiType);
		}
		
		//
		// Then the size 
		//
		if (uiSize != aPrivateDataTable[uiCount].uiSize)
		{
			if (uiType == REG_SZ)
			{
				tszBuffer = (PTCHAR)pvBuffer;
				_stprintf(tszMsg, TEXT("GetPrivateData: Size retrieved %d ")
										TEXT("expected %d, ")
										TEXT("pvBuffer = %s, known buffer = %s, ") 
										TEXT("Chars %u %u %u %u"), 
										uiSize, 
										aPrivateDataTable[uiCount].uiSize, 
										tszBuffer, 
										aPrivateDataTable[uiCount].pvBuffer, 
										tszBuffer[uiSize - 4], 
										tszBuffer[uiSize - 3], 
										tszBuffer[uiSize - 2], 
										tszBuffer[uiSize - 1]);
			} 
			else
			{
				if (uiType == REG_MULTI_SZ)
				{
					TCHAR tszAux[MAX_MSG_LEN];

					_stprintf(tszMsg, TEXT("MULTI_SZ Size retrieved %d, ")
											TEXT("expected %d, pvBuffer = "), 
											uiSize, aPrivateDataTable[uiCount].uiSize); 
					tszBuffer = (PTCHAR)pvBuffer;
					MultiStringToString(tszBuffer, tszAux);
					_tcscat(tszMsg, tszAux);

					_tcscat(tszMsg, TEXT(" and known buffer = "));

					tszBuffer = (PTCHAR)aPrivateDataTable[uiCount].pvBuffer;
					MultiStringToString(tszBuffer, tszAux);
					_tcscat(tszMsg, tszAux);
				} 
				else
				{
					_stprintf(tszMsg, TEXT("Size retrieved %d instead %d"), 
											uiSize, aPrivateDataTable[uiCount].uiSize);
				}				  
			}

			Log(fn, SEV2, tszMsg);
		}

		if (uiType == REG_BINARY)
		{
			if (memcmp(pvBuffer, 
						  aPrivateDataTable[uiCount].pbBuffer, 
						  aPrivateDataTable[uiCount].uiSize))
			{
				Log(fn, SEV2, TEXT("Private data %s, Received %s expected %s"), 
								  aPrivateDataTable[uiCount].tszName, 
								  (PTSTR)pvBuffer, 
								  (PTSTR)aPrivateDataTable[uiCount].pbBuffer);
			}
		}
		else
		{
			if (memcmp(pvBuffer, 
						  aPrivateDataTable[uiCount].pvBuffer, 
						  aPrivateDataTable[uiCount].uiSize))
			{
				Log(fn, SEV2, TEXT("Private data %s, Received %s expected %s"), 
								  aPrivateDataTable[uiCount].tszName, 
								  (PTSTR)pvBuffer, 
								  (PTSTR)aPrivateDataTable[uiCount].pvBuffer);
			}
		}
		
		//
		// Try to use a smaller buffer - should get an error code
		//
		uiSize--;
		dwErrorCode = OCManagerRoutines.GetPrivateData(
													  OCManagerRoutines.OcManagerContext,
													  NULL,
													  aPrivateDataTable[uiCount].tszName,
													  pvBuffer,
													  &uiSize,
													  &uiType);
		
		if (dwErrorCode != ERROR_INSUFFICIENT_BUFFER)
		{
			Log(fn, SEV2, TEXT("GetPrivateData returned %s when called ")
							  TEXT("with small buffer size for %s"),
							  ErrorMsg(dwErrorCode, tszError), 
							  aPrivateDataTable[uiCount].tszName);
			continue;
		}
		__Free(&pvBuffer);
	} 

	if (pvBuffer) __Free(&pvBuffer);
	
} // CheckPrivateValues //




/*++

Routine Description: SetAValue (1.1)

	 Sets the value of a variable from the private data. The variable 
	 that will be changed is randomly selected.
	
Arguments:

	OCManagerRoutines: the helper routines (SetPrivateData is a member 
							 of this structure)
	
	uiIndex:			  the index of the variable to change
	
Return Value:

	BOOL: TRUE if value is set, FALSE if not

--*/
BOOL SetAValue(IN	   OCMANAGER_ROUTINES OCManagerRoutines,
					IN		UINT					uiIndex,
					IN OUT PRIVATE_DATA 		*aPrivateDataTable)
{
	double fn = 1.1;
	
	UINT	uiAuxIndex;
	UINT	uiOffset;
	DWORD  dwRandomValue;
	PTCHAR tszBuffer;
	TCHAR  tszMsg[MAX_MSG_LEN];

	switch (aPrivateDataTable[uiIndex].uiType)
	{
		case REG_DWORD:
			
			aPrivateDataTable[uiIndex].uiSize = sizeof(DWORD);
	
			aPrivateDataTable[uiIndex].pvBuffer = 
				(PVOID)malloc(aPrivateDataTable[uiIndex].uiSize);
											 
			//
			// Fill in the buffer
			//
			dwRandomValue = (DWORD)rand();
			memcpy(aPrivateDataTable[uiIndex].pvBuffer, 
					 &dwRandomValue, 
					 aPrivateDataTable[uiIndex].uiSize);
			
			//
			// Set the private data "with" the OC Manager
			//
			OCManagerRoutines.SetPrivateData(
													OCManagerRoutines.OcManagerContext,
													aPrivateDataTable[uiIndex].tszName,
													aPrivateDataTable[uiIndex].pvBuffer,
													aPrivateDataTable[uiIndex].uiSize,
													aPrivateDataTable[uiIndex].uiType);
			break;

		case REG_BINARY:
			
			aPrivateDataTable[uiIndex].uiSize = 
				(UINT)(rand() % MAX_PRIVATE_DATA_SIZE) + 1;
			
			aPrivateDataTable[uiIndex].pbBuffer = 
				(PVOID)malloc(aPrivateDataTable[uiIndex].uiSize);
				
			//
			// Fill in the buffer
			//
			for (uiAuxIndex = 0; 
				  uiAuxIndex < aPrivateDataTable[uiIndex].uiSize; 
				  uiAuxIndex++)
			{
				aPrivateDataTable[uiIndex].pbBuffer[uiAuxIndex] = (BYTE)rand();
			} 
			
			//
			// Set the private data
			//
			OCManagerRoutines.SetPrivateData(
													OCManagerRoutines.OcManagerContext,
													aPrivateDataTable[uiIndex].tszName,
													aPrivateDataTable[uiIndex].pbBuffer,
													aPrivateDataTable[uiIndex].uiSize,
													aPrivateDataTable[uiIndex].uiType);
			break;
		
		case REG_SZ:
			
			uiAuxIndex = (UINT)(rand() % MAX_STRINGS_FOR_PRIVATE_DATA);
			
			aPrivateDataTable[uiIndex].uiSize = 
				(_tcslen(g_atszStringValues[uiAuxIndex]) + 1) * sizeof(TCHAR);
			
			aPrivateDataTable[uiIndex].pvBuffer = 
				(PVOID)malloc(aPrivateDataTable[uiIndex].uiSize);
			
			//
			// Fill in the buffer
			//
			_tcscpy((PTSTR)aPrivateDataTable[uiIndex].pvBuffer, 
					  g_atszStringValues[uiAuxIndex]);

			//
			// Set the private data
			//
			OCManagerRoutines.SetPrivateData(
													 OCManagerRoutines.OcManagerContext,
													 aPrivateDataTable[uiIndex].tszName,
													 aPrivateDataTable[uiIndex].pvBuffer,
													 aPrivateDataTable[uiIndex].uiSize,
													 aPrivateDataTable[uiIndex].uiType);
			break;

		case REG_MULTI_SZ:
			
			uiAuxIndex = (UINT)(rand() % MAX_MULTI_STRINGS_FOR_PRIVATE_DATA);
			
			aPrivateDataTable[uiIndex].uiSize = 
				MultiStringSize(g_atszMultiStringValues[uiAuxIndex]);
			
			aPrivateDataTable[uiIndex].pvBuffer = 
				(PVOID)malloc(aPrivateDataTable[uiIndex].uiSize);
				
			//
			// Fill in the buffer
			//
			CopyMultiString((PTSTR)aPrivateDataTable[uiIndex].pvBuffer, 
								 g_atszMultiStringValues[uiAuxIndex]);

			//
			// Set the private data
			//
			OCManagerRoutines.SetPrivateData(
													OCManagerRoutines.OcManagerContext,
													aPrivateDataTable[uiIndex].tszName,
													aPrivateDataTable[uiIndex].pvBuffer,
													aPrivateDataTable[uiIndex].uiSize,
													aPrivateDataTable[uiIndex].uiType);
			break;

		default: 
			break;
	}

	return TRUE;

} // SetAValue //




/*++

Routine Description: ChooseSubcomponentInitialState (1.31)

	"Wrapper" routine for the dialog box procedure ChooseSuncomponentDlgProc.
	 
Arguments:

	lpcvComponentId:	 supplies the id for the component. 
	lpcvSubcomponentId: supplies the id for the subcomponent.
	
Return Value:

	void

--*/
DWORD ChooseSubcomponentInitialState(IN LPCVOID lpcvComponentId,
												 IN LPCVOID lpcvSubcomponentId) 
{
	TCHAR  tszDlgBoxMessage[MAX_MSG_LEN];
	
	//							   
	// We will display a dialog box so the user can choose the 
	// initial state he/she wants
	//
	_stprintf(tszDlgBoxMessage, TEXT("%s, %s"), 
										 lpcvComponentId, lpcvSubcomponentId);
	
	return DialogBoxParam(g_hDllInstance, 
								 MAKEINTRESOURCE(IDD_DIALOG3), 
								 NULL, 
								 ChooseSubcomponentDlgProc,
								 (LPARAM)tszDlgBoxMessage);

} // ChooseSubcomponentInitialState //




/*++

Routine Description: AddNewComponent (1.32)

	Add a new component to the list
	
Arguments:

	tszComponentId: supplies id of component to be added to the list.

Return Value:

	Pointer to new per-component data structure or NULL if no memory.
	The structure will be zeroed out except for the ComponentId field.

--*/
PCOMPONENT_DATA AddNewComponent(IN LPCTSTR tszComponentId)
{
	PCOMPONENT_DATA pcdAux;

	if (__Malloc(&pcdAux, sizeof(COMPONENT_DATA)))
	{
		__Malloc(&(PTCHAR)(pcdAux->tszComponentId), 
					(_tcslen(tszComponentId) + 1) * sizeof(TCHAR));
		
		if (pcdAux->tszComponentId)
		{
			_tcscpy((PTSTR)pcdAux->tszComponentId, tszComponentId);
			
			//
			// Prepend at the begining
			//
			pcdAux->Next  = g_pcdComponents;
			g_pcdComponents = pcdAux;
		} 
	}

	return pcdAux;

} // AddNewComponent //




/*++

Routine Description: LocateComponent (1.33)

	Locate a component by name from the list of components
	that this dll has been assigned to handle via
	OC_INIT_COMPONENT.

Arguments:

	tszComponentId: supplies the id for the component to look up.

Return Value:

	Pointer to component data or NULL if not found.

--*/
PCOMPONENT_DATA LocateComponent(IN LPCTSTR tszComponentId)
{
	PCOMPONENT_DATA pcdAux;

	for (pcdAux = g_pcdComponents; pcdAux; pcdAux = pcdAux->Next)
	{
		if (!(_tcscmp(pcdAux->tszComponentId, tszComponentId)))
		{
			break;
		}
	}
	return pcdAux;

} // LocateComponent //




/*++

Routine Description: RemoveComponent (1.34)

	Locate a component by name from the list of components and
	then remove it from the list of components.

Arguments:

	tszComponentId: supplies the id for the component to remove.

Return Value:

	void

--*/
VOID RemoveComponent(IN LPCTSTR tszComponentId)
{
	PCOMPONENT_DATA pcdAux, pcdPrev;

	for (pcdPrev = NULL, pcdAux = g_pcdComponents; 
		  pcdAux; 
		  pcdPrev = pcdAux, pcdAux = pcdAux->Next)
	{
		if (!(_tcscmp(pcdAux->tszComponentId, tszComponentId)))
		{
			__Free(&(PTCHAR)(pcdAux->tszComponentId));
			if (pcdPrev)
			{
				pcdPrev->Next = pcdAux->Next;
			} 
			else
			{
				g_pcdComponents = pcdAux->Next;
			}
			__Free(&pcdAux);
			break;
		}
	}
	return;

} // RemoveComponent //




/*++

Routine Description: CleanUpTest (1.35)

	 Frees globally allocated memory before the test exits

Arguments:

	 none

Return Value:

	 void

--*/
VOID CleanUpTest()
{
	USHORT i;
	PCOMPONENT_DATA pcdAux = g_pcdComponents, pcdNext;
	
	while (pcdAux)
	{
		pcdNext = pcdAux->Next;
		
		__Free(&(PTCHAR)(pcdAux->tszComponentId));
		__Free(&pcdAux);
			
		pcdAux = pcdNext;
	}
	
	FreeSubcomponentInformationList();
	
	return;
	
} // CleanUpTest //




/*++

Routine Description: CreateSubcomponentInformationList (1.23)

	 Creates a linked list of every subcomponent. For each subcomponent,
	 tells the parent of the subcomponent and whether or not the 
	 subcomponent has any children.

Arguments:

	 hinf: handle to inf file

Return Value:

	 BOOL: TRUE if function succeeds, FALSE if it fails

--*/
BOOL CreateSubcomponentInformationList(IN HINF hinf)
{
	double fn = 1.23;
	
	int 				i, j;
	USHORT			   usIdLen;
	USHORT			   usParentIndex;
	LONG				lLine, lLineCount;
	DWORD			   dwSize;
	BOOL				bRetval;
	BOOL				bFound;
	TCHAR			   tszSubcomponent[MAX_PATH];
	TCHAR			   tszParent[MAX_PATH];
	TCHAR			   tszError[MAX_ERROR_LEN];
	TCHAR			   tszNeeds[MAX_PATH];
	TCHAR			   tszExclude[MAX_PATH];
	INFCONTEXT		  infContext;
	PSUBCOMP		  pscSubcomponent, pscTemp, pscParent, pscChild;
	PCOMPLIST		  pclNeeds, pclExclude, pclChild, pclTemp;
			
	lLineCount = SetupGetLineCount(hinf, TEXT("Optional Components"));
											 
	if (lLineCount < 0)
	{
		Log(fn, SEV2, TEXT("Could not get number of lines in Optional ")
						  TEXT("Components section of inf file: %s"),
						  ErrorMsg(GetLastError(), tszError));
		return FALSE;
	}											  
	
	for (lLine = 0; lLine < lLineCount; lLine++)
	{
		bRetval = SetupGetLineByIndex(hinf,
												TEXT("Optional Components"),
												lLine,
												&infContext);
												
		if (!bRetval)
		{
			Log(fn, SEV2, TEXT("Could not get line %d from Optional ")
							  TEXT("Components section of inf file: %s"),
							  lLine, ErrorMsg(GetLastError(), tszError));
			return FALSE;
		}	 
		
		bRetval = SetupGetLineText(&infContext,
											NULL,
											NULL,
											NULL,
											tszSubcomponent,
											MAX_PATH,
											&dwSize);
											
		if (!bRetval)
		{
			Log(fn, SEV2, TEXT("Could not get text of line %d from ")
							  TEXT("Optional Components section of inf file: %s"),
							  lLine, ErrorMsg(GetLastError(), tszError));
			return FALSE;
		}	 
											
		//
		// Allocate a new subcomponent structure
		//
		if (!__Malloc(&pscSubcomponent, sizeof(SUBCOMP)))
		{
			Log(fn, SEV2, TEXT("Could not allocate space for ")
							  TEXT("pscSubcomponent"));
			return FALSE;
		}
		
		pscSubcomponent->pclNeeds = NULL;
		pscSubcomponent->pclExclude = NULL;
		pscSubcomponent->pclChildren = NULL;
		pscSubcomponent->Next = NULL;
		
		//
		// Find out the subcomponent id's length
		//
		usIdLen = (USHORT) _tcslen(tszSubcomponent);
	
		//
		// Copy the ComponentId. All of the test inf's use a special
		// SubcomponentId naming format, so that the subcomponent is a 
		// superset of the ComponentId. For example, if the component
		// name is "component" the subcomponet names will be
		// "component_1", "component_2", "component_1_2", etc.
		//
		for (i = 0; i < usIdLen; i++)
		{
			if (tszSubcomponent[i] == TEXT('_'))
			{
				break;
			}
			else
			{
				pscSubcomponent->tszComponentId[i] = tszSubcomponent[i];
			}
		}
		pscSubcomponent->tszComponentId[i] = TEXT('\0');
			
		
		//
		// if the subcomponent has a parent, get the name of the parent, store
		// it, and then search for this parent amongst the subcomponents
		// we've already processed. If the parent is found, mark the parent
		// so we know that the parent has children.
		// 
		
		//
		// Record the name of the parent.
		//
		if (SetupFindFirstLine(hinf, 
									  tszSubcomponent, 
									  TEXT("Parent"), 
									  &infContext))
		{
			bRetval = SetupGetStringField(&infContext, 
													1, 
													tszParent, 
													MAX_PATH,
													NULL);
			if (!bRetval)
			{
				//
				// Parent name is empty. This is an invalid INF, but 
				// we'll go with it.
				//
				ZeroMemory(tszParent, MAX_PATH);
			}
			else
			{
				//
				// Search through the subcomponent list for this parent
				//
				for (pscParent = g_pscHead; 
					  pscParent != NULL; 
					  pscParent = pscParent->Next)
				{
					if (_tcscmp(tszParent, pscParent->tszSubcomponentId) == 0)
					{
						//
						// Found the parent subcomponent node. Add the current
						// subcomponent to the parent node's children list,
						// if it isn't there already
						//
						bFound = FALSE;
						for (pclTemp = pscParent->pclChildren;
							  pclTemp != NULL;
							  pclTemp = pclTemp->Next)
						{
							if (_tcscmp(pclTemp->tszSubcomponentId, 
											tszSubcomponent) == 0)
							{
								bFound = TRUE;				   
							}
						}
					  
						if (!bFound)
						{
							if (!__Malloc(&pclChild, sizeof(COMPLIST)))
							{
								Log(fn, SEV2, TEXT("Out of memory"));
								break;
							}

							_tcscpy(pclChild->tszSubcomponentId, tszSubcomponent);
							pclChild->Next = pscParent->pclChildren;
							pscParent->pclChildren = pclChild;
						}
					}
				}
			}
		}
		else
		{
			//
			// This component has no parent. Assume this is the top-level
			// component and assign it's parent's name as itself
			//
			_tcscpy(tszParent, tszSubcomponent);
		}	 
	
		_tcscpy(pscSubcomponent->tszParentId, tszParent);
		
		//
		// Now search through the list to see if any of the subcomponents
		// in the list are children of this new subcomponent
		//
		for (pscChild = g_pscHead; pscChild != NULL; pscChild = pscChild->Next)
		{
			if (_tcscmp(tszSubcomponent, pscChild->tszParentId) == 0)
			{
				//
				// Found a node that is the child of the current
				// node. Add this child to the current node's
				// child list, if it isn't there already
				//
				bFound = FALSE;
				for (pclTemp = pscSubcomponent->pclChildren;
					  pclTemp != NULL;
					  pclTemp = pclTemp->Next)
				{
					if (_tcscmp(pclTemp->tszSubcomponentId, 
									pscChild->tszSubcomponentId) == 0)
					{
						bFound = TRUE;				   
					}
				}
				
				if (!bFound)
				{	 
					if (!__Malloc(&pclChild, sizeof(COMPLIST)))
					{
						Log(fn, SEV2, TEXT("Out of memory"));
						break;
					}

					_tcscpy(pclChild->tszSubcomponentId, 
							  pscChild->tszSubcomponentId);
					pclChild->Next = pscSubcomponent->pclChildren;
					pscSubcomponent->pclChildren = pclChild;
				}	 
			}
		}
	
		//
		// Fill in the rest of the data for the new node
		//
		_tcscpy(pscSubcomponent->tszSubcomponentId, tszSubcomponent);
	
		//
		// See if this node has any needs relationships. If it does,
		// record them.
		//
		if (SetupFindFirstLine(hinf, 
									  tszSubcomponent, 
									  TEXT("Needs"), 
									  &infContext))
		{
			for (i = 1, bRetval = TRUE; bRetval; i++)
			{
				bRetval = SetupGetStringField(&infContext, 
														i, 
														tszNeeds, 
														MAX_PATH,
														NULL);
		
				if (bRetval)
				{
					if (!__Malloc(&pclNeeds, sizeof(COMPLIST)))
					{
						Log(fn, SEV2, TEXT("Out of memory"));
						break;
					}

					_tcscpy(pclNeeds->tszSubcomponentId, tszNeeds);
					pclNeeds->Next = pscSubcomponent->pclNeeds;
					pscSubcomponent->pclNeeds = pclNeeds;
				}
			}
		}
				
		//
		// See if this node has any exclude relationships. If it does,
		// record them.
		//
		if (SetupFindFirstLine(hinf, 
									  tszSubcomponent, 
									  TEXT("Exclude"), 
									  &infContext))
		{
			for (i = 1, bRetval = TRUE; bRetval; i++)
			{
				bRetval = SetupGetStringField(&infContext, 
														i, 
														tszExclude, 
														MAX_PATH,
														NULL);
		
				if (bRetval)
				{
					if (!__Malloc(&pclExclude, sizeof(COMPLIST)))
					{
						Log(fn, SEV2, TEXT("Out of memory"));
						break;
					}

					_tcscpy(pclExclude->tszSubcomponentId, tszExclude);
					pclExclude->Next = pscSubcomponent->pclExclude;
					pscSubcomponent->pclExclude = pclExclude;
				}
			}
		}
		
		//
		// Add the new component to the beginning of the linked list
		//
		pscSubcomponent->Next = g_pscHead;
		g_pscHead = pscSubcomponent;
	
	} // for (lLine...
	
	return TRUE;
	
} // CreateSubcomponentInformationList //




/*++

Routine Description: FreeSubcomponentInformationList (1.36)

	 Frees the global linked list of subcomponent information.

Arguments:

	 none

Return Value:

	 void

--*/
VOID FreeSubcomponentInformationList()
{
	PSUBCOMP  pscTemp = g_pscHead;
	PSUBCOMP  pscNext;
	PCOMPLIST pclTemp, pclNext;
	
	//
	// Delete all the SUBCOMP nodes
	//
	while (pscTemp)
	{
		pscNext = pscTemp->Next;
		
		//
		// Delete all the COMPLIST pclNeeds nodes
		//
		pclTemp = pscTemp->pclNeeds;
		while (pclTemp)
		{
			pclNext = pclTemp->Next;
			
			__Free(&pclTemp);
			
			pclTemp = pclNext;
		}
		
		//
		// Delete all the COMPLIST pcdExclude nodes
		//
		pclTemp = pscTemp->pclExclude;
		while (pclTemp) 
		{
			pclNext = pclTemp->Next;
			
			__Free(&pclTemp);
			
			pclTemp = pclNext;
		}

		//
		// Delete all the COMPLIST pclChildren nodes
		//
		pclTemp = pscTemp->pclChildren;
		while (pclTemp)
		{
			pclNext = pclTemp->Next;
			
			__Free(&pclTemp);
			
			pclTemp = pclNext;
		}
		
		__Free(&pscTemp);
		
		pscTemp = pscNext;
	}
	
	g_pscHead = NULL;
	
} // FreeSubcomponentInformationList //




/*++

Routine Description: ClearSubcomponentInformationMarks (1.37)

	 Clears the marks on each of the subcomponent information nodes

Arguments:

	 none

Return Value:

	 void

--*/
VOID ClearSubcomponentInformationMarks()
{
	PSUBCOMP pscTemp;

	for (pscTemp = g_pscHead; pscTemp != NULL; pscTemp = pscTemp->Next)
	{
		pscTemp->bMarked = FALSE;
	}
	
} // ClearSubcomponentInformationMarks //




/*++

Routine Description: CheckSubcomponentInformationMarks (1.38)

	 Clears the marks on each of the subcomponent information nodes

Arguments:

	 none

Return Value:

	 void

--*/
VOID CheckSubcomponentInformationMarks()
{
	double fn = 1.38;
	
	PSUBCOMP pscTemp;

	for (pscTemp = g_pscHead; pscTemp != NULL; pscTemp = pscTemp->Next)
	{
		if (!(pscTemp->pclChildren) && !(pscTemp->bMarked))
		{
			Log(fn, SEV2, TEXT("%s.%s was not processed"),
							  pscTemp->tszComponentId, 
							  pscTemp->tszSubcomponentId);
		}
	}
	
} // CheckSubcomponentInformationMarks //




/*++

Routine Description: FindSubcomponentInformationNode (1.39)

	 Tries to find a node with matching ComponentId and SubcomponentId

Arguments:

	 tszComponentId:	 name of the component
	 tszSubcomponentId: name of the subcomponent

Return Value:

	 PSUBCOMP: if node is found, returns pointer to node.
				  if node is not found, returns NULL
	 
--*/
PSUBCOMP FindSubcomponentInformationNode(IN PTCHAR tszComponentId,
													  IN PTCHAR tszSubcomponentId)
{
	PSUBCOMP pscTemp;
	TCHAR	  tszSubcomp[MAX_PATH];

	__ASSERT(tszComponentId != NULL);

	//
	// If subcomponent is null, this is probably the master component.
	// In this case, subcomponent name should be same as component name.
	//
	if (tszSubcomponentId == NULL || 
		 _tcscmp(tszSubcomponentId, TEXT("(null)")) == 0 ||
		 tszSubcomponentId[0] == TEXT('\0'))
	{
		_tcscpy(tszSubcomp, tszComponentId);
	}
	else
	{
		_tcscpy(tszSubcomp, tszSubcomponentId);
	}
	
	//
	// Look for the node
	//
	for (pscTemp = g_pscHead; pscTemp != NULL; pscTemp = pscTemp->Next)
	{
		if (_tcscmp(tszComponentId, pscTemp->tszComponentId) == 0 &&
			 _tcscmp(tszSubcomp, pscTemp->tszSubcomponentId) == 0)
		{
			return pscTemp;
		}
	}

	return NULL;
	
} // FindSubcomponentInformationNode //




/*++

Routine Description: CheckNeedsDependencies (1.41)

	 Checks the selection status of every component and subcomponent to
	 make sure all needs relationships are being upheld.
	
Arguments:

	 none
 
Return Value:

	 void
	 
--*/
VOID CheckNeedsDependencies()
{
	PSUBCOMP		  pscSubcomponent;
	PCOMPONENT_DATA pcdComponentData; 
	TCHAR			   tszNodesVisited[NODES_VISITED_LENGTH];
	
	ZeroMemory(tszNodesVisited, NODES_VISITED_LENGTH);
				
	//
	// Go through each subcomponent, check its selection state
	// and the selection state of any subcomponents that it needs
	//
	for (pscSubcomponent = g_pscHead; 
		  pscSubcomponent != NULL;
		  pscSubcomponent = pscSubcomponent->Next)
	{
		if (pcdComponentData = LocateComponent(pscSubcomponent->tszComponentId))
		{
			//
			// If this component is selected, check out its needs
			// dependencies
			//
			if (pcdComponentData->ocrHelperRoutines.QuerySelectionState(
							  pcdComponentData->ocrHelperRoutines.OcManagerContext,
							  pscSubcomponent->tszSubcomponentId,
							  OCSELSTATETYPE_CURRENT))
			{
				CheckNeedsDependenciesOfSubcomponent(
													 pcdComponentData->ocrHelperRoutines,
													 pscSubcomponent,
													 pscSubcomponent,
													 tszNodesVisited);
			}
		}
	}

} // CheckNeedsDependencies //
				
										


/*++

Routine Description: CheckNeedsDependenciesOfSubcomponent (1.42)

	 Receives a subcomponent ID. Checks to see if this subcomponent is
	 checked, and if it is, recurses to check all the subcomponents
	 that are needed by this subcomponent (if any)
	
Arguments:

	 ocrHelper: 		 helper routines 
	 pscSubcomponent:  contains data about subcomponent being checked
	 pscWhoNeedsMe: 	tells who needs this subcomponent

Return Value:

	 BOOL: TRUE if all needs dependencies check out, FALSE if not
	 
--*/
BOOL CheckNeedsDependenciesOfSubcomponent(IN	  OCMANAGER_ROUTINES ocrHelper,
														IN		PSUBCOMP			  pscSubcomponent,
														IN		PSUBCOMP			  pscWhoNeedsMe,
														IN OUT PTCHAR				  tszNodesVisited)
{
	double fn = 1.42;
	
	PCOMPLIST	 pclNeeds;
	PSUBCOMP	 pscNeeds;
	UINT		  uiRemoteResult;
	CHECK_NEEDS cnCheckNeeds;
	TCHAR		  tsz[MAX_PATH];
	ULONG		  ulError;
	
	if (ocrHelper.QuerySelectionState(ocrHelper.OcManagerContext,
												 pscSubcomponent->tszSubcomponentId,
												 OCSELSTATETYPE_CURRENT))
	{
		//
		// Check to see if we've already checked out this node
		//
		if (!AlreadyVisitedNode(pscSubcomponent->tszSubcomponentId,
										tszNodesVisited))
		{
			//
			// Add this node to the list of nodes we've already checked
			//
			_tcscat(tszNodesVisited, pscSubcomponent->tszSubcomponentId);
			_tcscat(tszNodesVisited, TEXT(" "));
			
			//
			// Go through each subcomponent that is needed by this subcomponent
			//
			for (pclNeeds = pscSubcomponent->pclNeeds;
				  pclNeeds != NULL;
				  pclNeeds = pclNeeds->Next)
			{
				//
				// Check to see if this needed subcomponent belongs to the
				// current component. If it does, just check here.
				// If it doesn't, call private function of the component
				// that it does belong to. This private function will
				// do the checking and return the result
				//
				if (_tcsncmp(pscSubcomponent->tszSubcomponentId, 
								 pclNeeds->tszSubcomponentId,
								 _tcslen(pscSubcomponent->tszComponentId)) == 0)
				{
					if (!CheckLocalNeedsDependencies(ocrHelper,
																pscSubcomponent,
																pclNeeds,
																tszNodesVisited))
					{
						return FALSE;
					}
				}
				else
				{
					cnCheckNeeds.pclNeeds = pclNeeds;
					cnCheckNeeds.tszNodesVisited = tszNodesVisited;
					
					ulError = ocrHelper.CallPrivateFunction(
										ocrHelper.OcManagerContext, 
										GetComponent(pclNeeds->tszSubcomponentId, tsz),
										pclNeeds->tszSubcomponentId,
										OCP_CHECK_NEEDS, 
										(UINT)pscSubcomponent, 
										&cnCheckNeeds, 
										(PUINT)&cnCheckNeeds);
					
					if (ulError != NO_ERROR)
					{
						Log(fn, SEV2, TEXT("CallPrivateFunction failed for ")
										  TEXT("%s called from %s: %lu"),
										  pclNeeds->tszSubcomponentId,
										  pscSubcomponent->tszComponentId,
										  ulError);
						return FALSE;
					}
				
					if (!cnCheckNeeds.bResult) return FALSE;
				}	 
			}
		}
	
		//
		// All the needs dependencies checked out
		//
		return TRUE;
	}
	
	//
	// This component is not selected, return FALSE
	//
	Log(fn, SEV2, TEXT("%s needs %s. %s is selected, ")
					  TEXT("but %s is not."),
					  pscWhoNeedsMe->tszSubcomponentId,
					  pscSubcomponent->tszComponentId,
					  pscWhoNeedsMe->tszSubcomponentId,
					  pscSubcomponent->tszComponentId);
	return FALSE;
	
} // CheckNeedsDependenciesOfSubcomponent //




/*++

Routine Description: CheckLocalNeedsDependencies (1.43)

	 Receives a subcomponent ID. Checks to see if this subcomponent is
	 checked, and if it is, recurses to check all the subcomponents
	 that are needed by this subcomponent (if any)
	
Arguments:

	 ocrHelper: 		 helper routines 
	 pscSubcomponent:  contains data about subcomponent being checked
	 pclNeeds:			  tells who this subcomponent needs

Return Value:

	 BOOL: TRUE if all needs dependencies check out, FALSE if not
	 
--*/
BOOL CheckLocalNeedsDependencies(IN 	 OCMANAGER_ROUTINES ocrHelper,
											IN		PSUBCOMP			  pscSubcomponent,
											IN		PCOMPLIST			  pclNeeds,
											IN OUT PTCHAR				  tszNodesVisited)
{
	PSUBCOMP pscNeeds;
	
	//
	// Find the PSUBCOMP node for this subcomponent
	//
	for (pscNeeds = g_pscHead;
		  pscNeeds != NULL;
		  pscNeeds = pscNeeds->Next)
	{
		if (_tcscmp(pscNeeds->tszSubcomponentId, 
						pclNeeds->tszSubcomponentId) == 0)
		{
			if (!CheckNeedsDependenciesOfSubcomponent(ocrHelper,
																	pscNeeds,
																	pscSubcomponent,
																	tszNodesVisited))	 
			{
				return FALSE;
			}
			break;
		}
	}

	return TRUE;
} // CheckLocalNeedsDependencies //




/*++

Routine Description: CheckExcludeDependencies (1.46)

	 Checks the selection status of every component and subcomponent to
	 make sure all exclude relationships are being upheld.
	
Arguments:

	 none
 
Return Value:

	 void
	 
--*/
VOID CheckExcludeDependencies()
{
	double fn = 1.46;
	
	PSUBCOMP		  pscSubcomponent;
	PCOMPLIST		  pclExclude;
	PCOMPONENT_DATA pcdComponentData; 
				
	//
	// Go through each subcomponent, check its selection state
	// and the selection state of any subcomponents that it excludes
	//
	for (pscSubcomponent = g_pscHead; 
		  pscSubcomponent != NULL;
		  pscSubcomponent = pscSubcomponent->Next)
	{
		if (pcdComponentData = LocateComponent(pscSubcomponent->tszComponentId))
		{
			//
			// If this component is selected, check out its exclude
			// dependencies
			//
			if (pcdComponentData->ocrHelperRoutines.QuerySelectionState(
							  pcdComponentData->ocrHelperRoutines.OcManagerContext,
							  pscSubcomponent->tszSubcomponentId,
							  OCSELSTATETYPE_CURRENT))
			{
				//
				// Go through each subcomponent that is
				// excluded by this subcomponent
				//
				for (pclExclude = pscSubcomponent->pclExclude;
					  pclExclude != NULL;
					  pclExclude = pclExclude->Next)
				{
					if (pcdComponentData->ocrHelperRoutines.QuerySelectionState(
							  pcdComponentData->ocrHelperRoutines.OcManagerContext,
							  pclExclude->tszSubcomponentId,
							  OCSELSTATETYPE_CURRENT))
					{
						Log(fn, SEV2, TEXT("%s excludes %s. Both are selected"),
										  pscSubcomponent->tszSubcomponentId,
										  pclExclude->tszSubcomponentId);
					}
				}
			}
		}
	}
					
} // CheckExcludeDependencies //




/*++

Routine Description: CheckParentDependencies (1.47)

	 Checks the selection status of every component and subcomponent to
	 make sure all parent relationships are being upheld.
	
Arguments:

	 none
 
Return Value:

	 void
	 
--*/
VOID CheckParentDependencies()
{
	double fn = 1.47;
	
	PSUBCOMP		  pscSubcomponent;
	PCOMPONENT_DATA pcdComponentData; 
	BOOL				bState;
	PCOMPLIST		  pclChildren;			  

	PCOMPONENT_DATA pcdSubComponentData;

	BOOL				bParentState;
	BOOL				bAllCleared;

	PSUBCOMP		  pscParent;

	TCHAR			   tszMsg[256];

	static BOOL 	 bInformed1 = FALSE;
	static BOOL 	 bInformed2 = FALSE;

	// QuerySelectionState returns TRUE when the component's state
	// does not equal SELSTATE_NO
	// This means it returns TRUE when the component is selected
	// or partially selected

	//
	// Go through each subcomponent, check its selection state
	// and the selection state of its parent
	//

	for (pscSubcomponent = g_pscHead; 
		  pscSubcomponent != NULL;
		  pscSubcomponent = pscSubcomponent->Next)
	{
		bState = TRUE;
		if (pcdComponentData = LocateComponent(pscSubcomponent->tszComponentId))
		{
			//
			// Check to see if this subcomponent is selected
			//
			bState = pcdComponentData->ocrHelperRoutines.QuerySelectionState(
							  pcdComponentData->ocrHelperRoutines.OcManagerContext,
							  pscSubcomponent->tszSubcomponentId,
							  OCSELSTATETYPE_CURRENT);

			// Let pass a NULL pointer to the helper routine
			//pcdComponentData->ocrHelperRoutines.QuerySelectionState(
			//	  NULL, NULL, OCSELSTATETYPE_CURRENT);

			if (bState == TRUE) {

				// The component is selected

				//if (GetLastError() == ERROR_INVALID_NAME) {				 
				//	  MessageBox(NULL, TEXT("There is an error when calling QuerySelectionState"), TEXT("CheckParentDependencies"), MB_OK);
				//	  break;
				//}

				//
				// Check to see if its parent is selected
				//	  
				bParentState = pcdComponentData->ocrHelperRoutines.QuerySelectionState(
									pcdComponentData->ocrHelperRoutines.OcManagerContext,
									pscSubcomponent->tszParentId,
									OCSELSTATETYPE_CURRENT);

				// If the component is selected, its parent should
				// be selected or partially selected, thus bParentState
				// should be TRUE

				if (!bParentState)				   
				{
					Log(fn, SEV2, TEXT("%s is selected but its parent, %s, ")
									  TEXT("is not"),
									  pscSubcomponent->tszSubcomponentId,
									  pscSubcomponent->tszParentId);
				}
			}

			else if (bState == FALSE) {
				//
				// The child is not selected, this means none of its children 
				// should be selected, and its parent should be greyed or
				// unselected
				//
				// This will check its siblings to determine whether they
				// are selected or not
				// if none of its siblings are selected, the parent should be 
				// cleared.
				
				// First find its parent in the list

				if (_tcscmp(pscSubcomponent->tszSubcomponentId, pscSubcomponent->tszParentId) == 0) {
					// This is a top level component
					// we will skip the following test
					continue;
				}
				for (pscParent = g_pscHead; pscParent != NULL; pscParent = pscParent->Next) {
					if (_tcscmp(pscParent->tszSubcomponentId, pscSubcomponent->tszParentId) == 0) {
						break;
					}
				}

				pclChildren = pscParent->pclChildren;

				bAllCleared = TRUE;

				for (pclChildren = pscParent->pclChildren; pclChildren != NULL; pclChildren = pclChildren->Next) {
					// Locate the child component
					//pcdSubComponentData = LocateComponent(pclChildren->tszSubcomponentId);
					//if (!pcdSubComponentData) {
					//	  MessageBox(NULL, TEXT("Error locating subcomponent that is in the list"), TEXT("CheckParentDependencies"), MB_OK);
					//	  break;
					//}
					// Now query the state of this subcomponent
					if (pcdComponentData->ocrHelperRoutines.QuerySelectionState(
							  pcdComponentData->ocrHelperRoutines.OcManagerContext,
							  pclChildren->tszSubcomponentId,
							  OCSELSTATETYPE_CURRENT)){
						bAllCleared = FALSE;
						break;
					}
				}

				//pcdSubComponentData = LocateComponent(pscParent->tszComponentId);
				//if (!pcdSubComponentData) {
				//	  MessageBox(NULL, TEXT("Error locating subcomponent that is in the list"), TEXT("CheckParentDependencies"), MB_OK);
				//	  break;
				//}

				bParentState = pcdComponentData->ocrHelperRoutines.QuerySelectionState(
									pcdComponentData->ocrHelperRoutines.OcManagerContext,
									pscParent->tszSubcomponentId,
									OCSELSTATETYPE_CURRENT);
								
				if (bAllCleared) {
					// None of the subcomponent is selected
					// Check the state of the parent component
					if (bParentState != FALSE) {
						Log(fn, SEV2, TEXT("%s.%s is (partially) selected, but none")
										  TEXT(" of its subcomponent is selected"),
										  pscParent->tszParentId,
										  pscParent->tszComponentId);
						if (!bInformed1) {
							_stprintf(tszMsg, TEXT("%s is (partially) selected, but none of child is selected"), pscParent->tszSubcomponentId);
							MessageBox(NULL,tszMsg, TEXT("CheckParentDependencies"), MB_OK); 
							bInformed1 = TRUE;
						}
					}
				}

				else{
					// At least one of the subcomponent is selected
					// Parent should be (partially) selected
					if (bParentState == FALSE) {
						Log(fn, SEV2, TEXT("%s.%s is not selected, but one")
										  TEXT(" of its subcomponent is selected"),
										  pscParent->tszParentId,
										  pscParent->tszComponentId);
						if (!bInformed2) {
							_stprintf(tszMsg, TEXT("%s is not selected, but at least one of child is selected"), pscParent->tszSubcomponentId);
							MessageBox(NULL,tszMsg, TEXT("CheckParentDependencies"), MB_OK);
							bInformed2 = TRUE;
						}
					}
				}

			}
		}
	}
					
} // CheckParentDependencies //




/*++

Routine Description: AlreadyVisitedNode (1.44)

	 Receives a subcomponent ID and a list of subcomponents that 
	 have already been checked. Looks in the list to see if this
	 subcomponent has already been checked. 
	
Arguments:

	 tszSubcomponentId: the new subcomponent
	 tszNodesVisited:	 list of what's already been checked

Return Value:

	 BOOL: TRUE if this subcomponent has already been checked, FALSE if not
	 
--*/
BOOL AlreadyVisitedNode(IN PTCHAR tszSubcomponentId,
								IN PTCHAR tszNodesVisited)
{
	PTCHAR tszMarker;
	TCHAR  tszName[MAX_PATH];
	USHORT usCount, i;
	
	tszMarker = tszNodesVisited;
	
	for (usCount = 0; usCount < _tcslen(tszNodesVisited);)
	{
		for (i = 0; i < _tcslen(tszMarker); i++)
		{
			if (tszMarker[i] == TEXT(' ')) break;
			tszName[i] = tszMarker[i];
		}
		tszName[i] = TEXT('\0');
		
		if (_tcscmp(tszName, tszSubcomponentId) == 0)
		{
			return TRUE;
		}
		
		usCount += _tcslen(tszName) + 1;
	
		tszMarker += _tcslen(tszName) + 1;
	}
	
	return FALSE;
	
} // AlreadyVisitedNode //




/*++

Routine Description: GetComponent (1.45)

	 Receives a subcomponent ID and returns the ID of the master component
	 that owns this subcomponent
	
Arguments:

	 tszSubcomponentId: the subcomponent
	 tszComponentId:	 returns component ID using this string.
							  must be a valid buffer

Return Value:

	 PTCHAR: returns component ID
	 
--*/
PTCHAR GetComponent(IN		PTCHAR tszSubcomponentId,
						  IN OUT PTCHAR tszComponentId)
{
	USHORT i;
	
	__ASSERT(tszComponentId != NULL);
	
	for (i = 0; i < _tcslen(tszSubcomponentId); i++)
	{
		if (tszSubcomponentId[i] == TEXT('_'))
		{
			break;
		}
			
		tszComponentId[i] = tszSubcomponentId[i];
	}
	
	tszComponentId[i] = TEXT('\0');
	
	return tszComponentId;
	
} // GetComponent //							  




/*++

Routine Description: ParseCommandLine (1.47)

	 Checks the command line to see if there are any arguments that
	 pertain to the component DLLs
	
Arguments:

	 none

Return Value:

	 VOID
	 
--*/
VOID ParseCommandLine()
{
	USHORT i;
	USHORT usMarker;
	//TCHAR  usMarker;
	BOOL	bCheckArgs = FALSE;
	PTCHAR tszCommandLine;
	PTCHAR tszMarker;
	TCHAR  tszArg[MAX_PATH];

	TCHAR tszDlgMessage[256];
		
	tszCommandLine = GetCommandLine();
	tszMarker = tszCommandLine;
	usMarker = (USHORT)tszMarker;

	while ((USHORT)((USHORT)tszMarker - usMarker) < (USHORT)_tcslen(tszCommandLine) * sizeof(TCHAR))
	{	 
		for (i = 0; i < _tcslen(tszMarker); i++)
		{
			if (tszMarker[i] == TEXT(' ') || 
				 tszMarker[i] == TEXT('\0'))
			{
				break;
			}
			tszArg[i] = tszMarker[i];
		}
		tszArg[i] = TEXT('\0');

		tszMarker += _tcslen(tszArg) + 1;
		
		while (tszMarker[0] == TEXT(' ')) tszMarker++;
		
		if (bCheckArgs)
		{
			//
			// Check the value of this argument 
			//
			if (_tcscmp(tszArg, TEXT("/av")) == 0 ||
				 _tcscmp(tszArg, TEXT("/AV")) == 0 ||
				 _tcscmp(tszArg, TEXT("-av")) == 0 ||
				 _tcscmp(tszArg, TEXT("-AV")) == 0)
			{
				g_bAccessViolation = TRUE;
			}

			//
			// Check the value of this argument 
			//
			if (_tcscmp(tszArg, TEXT("/e")) == 0 ||
				 _tcscmp(tszArg, TEXT("/E")) == 0 ||
				 _tcscmp(tszArg, TEXT("-e")) == 0 ||
				 _tcscmp(tszArg, TEXT("-E")) == 0)
			{ 
				g_bTestExtended = TRUE;
			}

			//
			// negstep make the return value of OC_QUERY_STEP_COUNT negative one
			//
			if (_tcscmp(tszArg, TEXT("/negstep")) == 0 ||
				 _tcscmp(tszArg, TEXT("/NEGSTEP")) == 0 ||
				 _tcscmp(tszArg, TEXT("-negstep")) == 0 ||
				 _tcscmp(tszArg, TEXT("-NEGSTEP")) == 0)
			{ 
				nStepsFinal = -1;
			}

			if (_tcscmp(tszArg, TEXT("/nowiz")) == 0 ||
				 _tcscmp(tszArg, TEXT("/NOWIZ")) == 0 ||
				 _tcscmp(tszArg, TEXT("-nowiz")) == 0 ||
				 _tcscmp(tszArg, TEXT("-NOWIZ")) == 0)
			{ 
				g_bNoWizPage = TRUE;
			}
			
			if (_tcscmp(tszArg, TEXT("/crashunicode")) == 0 ||
				 _tcscmp(tszArg, TEXT("/CRASHUNICODE")) == 0 ||
				 _tcscmp(tszArg, TEXT("-crashunicode")) == 0 ||
				 _tcscmp(tszArg, TEXT("-CRASHUNICODE")) == 0)
			{ 
				g_bCrashUnicode = TRUE;
			}

			if (_tcscmp(tszArg, TEXT("/invalidbitmap")) == 0 ||
				 _tcscmp(tszArg, TEXT("/INVALIDBITMAP")) == 0 ||
				 _tcscmp(tszArg, TEXT("-invalidbitmap")) == 0 ||
				 _tcscmp(tszArg, TEXT("-INVALIDBITMAP")) == 0)
			{ 
				g_bInvalidBitmap = TRUE;
			}

			if (_tcscmp(tszArg, TEXT("/closeinf")) == 0 ||
				 _tcscmp(tszArg, TEXT("/CLOSEINF")) == 0 ||
				 _tcscmp(tszArg, TEXT("-closeinf")) == 0 ||
				 _tcscmp(tszArg, TEXT("-CLOSEINF")) == 0)
			{ 
				g_bCloseInf = TRUE;
			}
						
			if (_tcscmp(tszArg, TEXT("/hugesize")) == 0 ||
				 _tcscmp(tszArg, TEXT("/HUGESIZE")) == 0 ||
				 _tcscmp(tszArg, TEXT("-hugesize")) == 0 ||
				 _tcscmp(tszArg, TEXT("-HUGESIZE")) == 0)
			{ 
				g_bHugeSize = TRUE;
			}	   

			if (_tcscmp(tszArg, TEXT("/noneedmedia")) == 0 ||
				 _tcscmp(tszArg, TEXT("/NONEEDMEDIA")) == 0 ||
				 _tcscmp(tszArg, TEXT("-noneedmedia")) == 0 ||
				 _tcscmp(tszArg, TEXT("-NONEEDMEDIA")) == 0)
			{ 
				g_bNoNeedMedia = TRUE;
			}				  
			
			if (_tcscmp(tszArg, TEXT("/reboot")) == 0 ||
				 _tcscmp(tszArg, TEXT("/reboot")) == 0 ||
				 _tcscmp(tszArg, TEXT("-reboot")) == 0 ||
				 _tcscmp(tszArg, TEXT("-reboot")) == 0)
			{ 
				g_bReboot = TRUE;
			}				  


			if (_tcscmp(tszArg, TEXT("/cleanreg")) == 0 ||
				 _tcscmp(tszArg, TEXT("/CLEANREG")) == 0 ||
				 _tcscmp(tszArg, TEXT("-cleanreg")) == 0 ||
				 _tcscmp(tszArg, TEXT("-CLEANREG")) == 0)
			{ 
				g_bCleanReg = TRUE;
			}

			if (_tcscmp(tszArg, TEXT("/nolang")) == 0 ||
				 _tcscmp(tszArg, TEXT("/NOLANG")) == 0 ||
				 _tcscmp(tszArg, TEXT("-nolang")) == 0 ||
				 _tcscmp(tszArg, TEXT("-NOLANG")) == 0)
				{ 
					g_bNoLangSupport = TRUE;
				}
			
		}			 
		
		if (_tcscmp(tszArg, TEXT("/z")) == 0 ||
			 _tcscmp(tszArg, TEXT("/Z")) == 0)
		{
			bCheckArgs = TRUE;
		}
	}
	
} // ParseCommandLine //  

/*++

Routine Description: testAV (1.0)

	Procedure to generate an access violation
	
Argument:
	
	If true, an access violation is generated
	
Return Value:

	None
	
--*/  
VOID testAV(BOOL bDoIt){

	/* The Following variables are used for access violation test */
	COMPONENT_DATA *g_pcdAccessViolation;
	
	if (bDoIt){
		g_pcdAccessViolation = NULL;
		g_pcdAccessViolation->hinfMyInfHandle = NULL;
	}
}


/*++

Routine Description: TestReturnValueAndAV (1.0)

	Procdefure to give the user control of what to return and when to cause an access violation
	
Argument:

	Arguments to ComponentSetupProc plus and bOverride
	
Return Value:

	The return value that user gives.
	
--*/
BOOL TestReturnValueAndAV(IN LPCVOID lpcvComponentId,
								  IN LPCVOID lpcvSubcomponentId,
								  IN UINT	  uiFunction,
								  IN UINT	  uiParam1,
								  IN PVOID	  pvParam2,
								  IN OUT PReturnOrAV	 praValue)
{
	int returnValue;

	if (!BeginTest()){
		praValue->bOverride = FALSE;
		return ((DWORD)0);
	}

	//ChooseAccessViolationEx();

	//Now fill in the fields of raValue
	praValue->tszComponent = (PTCHAR)lpcvComponentId;
	praValue->tszSubComponent = (PTCHAR)lpcvSubcomponentId;
		
	switch(uiFunction){
		case  OC_PREINITIALIZE:
		praValue->tszSubComponent[0]=TEXT('\0');
		_tcscpy(praValue->tszAPICall, TEXT("OC_PREINITIALIZE"));	 
		break;
			
		case OC_INIT_COMPONENT:
		_tcscpy(praValue->tszAPICall, TEXT("OC_INIT_COMPONENT"));
		break;
			
		case OC_QUERY_STATE:
		_tcscpy(praValue->tszAPICall, TEXT("OC_QUERY_STATE"));
		break;
			
		case OC_SET_LANGUAGE:
		_tcscpy(praValue->tszAPICall, TEXT("OC_SET_LANGUAGE"));
		break;
			
		case OC_QUERY_IMAGE:
		_tcscpy(praValue->tszAPICall, TEXT("OC_QUERY_IMAGE"));
		break;
			
		case OC_REQUEST_PAGES:
		_tcscpy(praValue->tszAPICall, TEXT("OC_REQUEST_PAGES"));
		break;
			
		case OC_QUERY_CHANGE_SEL_STATE:
		_tcscpy(praValue->tszAPICall, TEXT("OC_QUERY_CHANGE_SEL_STATE"));
		break;
			
		case OC_CALC_DISK_SPACE: 
		_tcscpy(praValue->tszAPICall, TEXT("OC_CALC_DISK_SPACE"));
		break;
			
		case OC_QUEUE_FILE_OPS:
		_tcscpy(praValue->tszAPICall, TEXT("OC_QUEUE_FILE_OPS"));
		break;
			
		case OC_NEED_MEDIA:
		_tcscpy(praValue->tszAPICall, TEXT("OC_NEED_MEDIA"));
		break;
			
		case OC_QUERY_STEP_COUNT:
		_tcscpy(praValue->tszAPICall, TEXT("OC_QUERY_STEP_COUNT"));
		break;
			
		case OC_COMPLETE_INSTALLATION:
		_tcscpy(praValue->tszAPICall, TEXT("OC_COMPLETE_INSTALLATION"));
		break;
			
		case OC_CLEANUP:
		_tcscpy(praValue->tszAPICall, TEXT("OC_CLEANUP"));
		break;
			
		case OCP_TEST_PRIVATE_BASE:
		_tcscpy(praValue->tszAPICall, TEXT("OC_TEST_PRIVATE_BASE"));
		break;
			
		case OCP_CHECK_NEEDS:
		_tcscpy(praValue->tszAPICall, TEXT("OC_CHECK_NEEDS"));
		break;
			
		default:
		_tcscpy(praValue->tszAPICall, TEXT("Unknown call"));
		break;
	}
	
	//Now everything is ready, let's make the call
	returnValue = DialogBoxParam(g_hDllInstance, 
								  MAKEINTRESOURCE(IDD_CHOOSERETURNANDAV), 
								  NULL, 
								  ChooseReturnOrAVDlgProc,
								  (LPARAM)praValue);

	praValue = (PReturnOrAV)returnValue;

	return TRUE;
}

/*++

Routine Description: BeginTest (1.0)

	Let the user decide whether to test the return values of each API 
	

Arguments:
	
	None
	
Return Value:

	Whether to do extended test
--*/
BOOL BeginTest(){ 
	static BOOL bStart = FALSE;
	static BOOL bFirstTime = TRUE;
	static int iMsgReturn;
		
	TCHAR tszDlgMessage[256];
	TCHAR tszDlgTitle[256];

	if (bFirstTime){
		bFirstTime = FALSE;
#ifdef UNICODE	   
		_stprintf(tszDlgMessage, TEXT("Do you want to test return values and/or access violations of each API call in the UNICODE DLL? It may take a long long time"));
		_stprintf(tszDlgTitle, TEXT("Begin Test For UNICODE?"));
#else
		_stprintf(tszDlgMessage, TEXT("Do you want to test return values and/or access violations of each API call in the ANSI DLL? It may take a long long time"));
		_stprintf(tszDlgTitle, TEXT("Begin Test For ANSI?"));
#endif		  
		iMsgReturn = MessageBox(NULL, tszDlgMessage, tszDlgTitle, MB_YESNO|MB_ICONQUESTION);
		
		if (iMsgReturn == IDNO){
			bStart = FALSE;
			return (FALSE);
		}
		else{
			bStart = TRUE;
			return (TRUE);
		}
	}
	else{
		return bStart;
	}
		
}  

/*++

Routine Description: ChooseReturnOrAVDlgProc (1.27)

	Dialog procedure that allows the user to select a different 
	return value of an API call, and/or to cause a access violation
	
Arguments:

	Standard dialog procedure parameters
	
Return Value:

	Standard dialog procedure return value

--*/
BOOL CALLBACK ChooseReturnOrAVDlgProc(IN HWND	 hwnd,
									  IN UINT	 uiMsg, 
									  IN WPARAM wParam,
									  IN LPARAM lParam) 
{
	
	BOOL					 bSuccess = FALSE;
	PReturnOrAV 		   praValue = NULL;
	static HWND 		   hOldWnd = NULL;
	
	switch (uiMsg)
	{
		case WM_INITDIALOG:
			
			hOldWnd = hwnd;
			CheckRadioButton(hwnd, IDC_USE_OLDVALUE, IDC_USE_NEWVALUE, IDC_USE_OLDVALUE);
			CheckDlgButton(hwnd, IDC_CAUSEAV, 0);
		
			praValue = (PReturnOrAV)lParam;
			if (praValue){
				if (praValue->tszComponent){
					SetDlgItemText(hwnd, IDC_STATIC_COMPONENT, praValue->tszComponent);
				}
				else{
					SetDlgItemText(hwnd, IDC_STATIC_COMPONENT, TEXT("null"));
				}
				if (praValue->tszSubComponent && praValue->tszSubComponent[0]!=TEXT('\0')){ 			 
					SetDlgItemText(hwnd, IDC_STATIC_SUBCOMPONENT, praValue->tszSubComponent);
				}
				else{
					SetDlgItemText(hwnd, IDC_STATIC_SUBCOMPONENT, TEXT("null"));
				}
				SetDlgItemText(hwnd, IDC_STATIC_APICALL, praValue->tszAPICall);
			}
			
			return TRUE;
			break;

		case WM_COMMAND:
		
			switch (LOWORD(wParam))
			{
				case IDOK:
				
					//
					// Retrieve the current selection
					//
					if (QueryButtonCheck(hwnd, IDC_USE_NEWVALUE))
					{
						praValue->iReturnValue = GetDlgItemInt(hwnd, IDC_NEWVALUE, &bSuccess, TRUE);
						if (bSuccess){
							praValue->bOverride = TRUE;
						}
						else{
							praValue->bOverride = FALSE;
							praValue->iReturnValue = 0;
						}
					}
					
					if (QueryButtonCheck(hwnd, IDC_USE_OLDVALUE))
					{
						praValue->bOverride = FALSE;
						praValue->iReturnValue = 0;
					}
					
					if (QueryButtonCheck(hwnd, IDC_CAUSEAV))
					{
						praValue->bOverride = FALSE;
						praValue->iReturnValue = 0;
						testAV(TRUE);
					}
					
					EndDialog(hOldWnd, (int)praValue);
					return TRUE;
					
				case IDCANCEL:
			
					praValue->bOverride = FALSE;
					EndDialog(hOldWnd, 0);
					return TRUE;
					
				default:  
					break;
			}
		default:  
			break;
	}
	return	FALSE;
	
} // ChooseReturnOrAVDlgProc //

/*++
	Routine: causeAV
	
	Description: pops up a dialog box and ask the user where to av
	
	Argument: Function that the DLL receives from ComponentSetupProc

--*/

void causeAV(IN UINT uiFunction){
	static BOOL bFirstTime = TRUE;
	static UINT uiFunctionToAV = 0;

	if (bFirstTime) {
		// Display dialog box, asks the user where to av
		bFirstTime = FALSE;

		uiFunctionToAV = DialogBoxParam(g_hDllInstance, 
										  MAKEINTRESOURCE(IDD_DIALOG4), 
										  NULL, 
										  CauseAVDlgProc,
										  (LPARAM)NULL);
	}
	if (uiFunction == uiFunctionToAV) {
		testAV(TRUE);
	}
}


/*++

Routine Description: CauseAVDlgProc (1.26)

	Dialog Procedure to allow the user to choose where to cause an access violation
		
Arguments:

	Standard dialog procedure parameters
	
Return Value:

	Standard dialog procedure return value

--*/
BOOL CALLBACK CauseAVDlgProc(IN HWND	hwnd,
											  IN UINT	 uiMsg, 
											  IN WPARAM wParam,
											  IN LPARAM lParam) 
{
	UINT uiFunction;
	TCHAR tszFunctionName[256];
	BOOL bSuccess;

	switch (uiMsg)
	{
		case WM_INITDIALOG:
			
			break;
		
		case WM_COMMAND:
			
			switch (LOWORD(wParam))
			{
				case IDOK:
					
					//
					// Retrieve the current text in the edit box
					//
					GetDlgItemText(hwnd, IDC_FUNCTION, tszFunctionName, 255);
					if (*tszFunctionName) {
						uiFunction = GetOCFunctionName(tszFunctionName);
					}

					//
					// Send the version chosen back to ChooseVersionEx
					//
					EndDialog(hwnd, uiFunction);
					return TRUE;
				
				case IDCANCEL:
					
					EndDialog(hwnd, -1);
					return TRUE;
				
				default:  
					break;
			}
		default:  
			break;
	}
	return	FALSE;

} // CauseAVDlgProc //

UINT GetOCFunctionName(IN PTCHAR tszFunctionName){

	// Now tszFunctionName should contains the function name that user wants to cause an AV
	if (!_tcsicmp(tszFunctionName, TEXT("OC_PREINITIALIZE"))) {
		return(OC_PREINITIALIZE); 
	}

	else if (!_tcsicmp(tszFunctionName, TEXT("OC_INIT_COMPONENT"))) {
		return(OC_INIT_COMPONENT);
			}
	else if (!_tcsicmp(tszFunctionName, TEXT("OC_QUERY_STATE"))) {
		return(OC_QUERY_STATE);
	}
	else if (!_tcsicmp(tszFunctionName, TEXT("OC_SET_LANGUAGE"))) {
		return(OC_SET_LANGUAGE);
	}
	else if (!_tcsicmp(tszFunctionName, TEXT("OC_QUERY_IMAGE"))) {
		return(OC_QUERY_IMAGE);
	}
	else if (!_tcsicmp(tszFunctionName, TEXT("OC_REQUEST_PAGES"))) {
		return(OC_REQUEST_PAGES);
	}
	else if (!_tcsicmp(tszFunctionName, TEXT("OC_QUERY_SKIP_PAGE"))) {
		return(OC_QUERY_SKIP_PAGE);
	}
	else if (!_tcsicmp(tszFunctionName, TEXT("OC_QUERY_CHANGE_SEL_STATE"))) {
		return(OC_QUERY_CHANGE_SEL_STATE);
	}
	else if (!_tcsicmp(tszFunctionName, TEXT("OC_CALC_DISK_SPACE"))) {
		return(OC_CALC_DISK_SPACE);
	}
	else if (!_tcsicmp(tszFunctionName, TEXT("OC_QUEUE_FILE_OPS"))) {
		return(OC_QUEUE_FILE_OPS);
	}
	else if (!_tcsicmp(tszFunctionName, TEXT("OC_NEED_MEDIA"))) {
		return(OC_NEED_MEDIA);
	}
	else if (!_tcsicmp(tszFunctionName, TEXT("OC_QUERY_STEP_COUNT"))) {
		return(OC_QUERY_STEP_COUNT);
	}

	else if (!_tcsicmp(tszFunctionName, TEXT("OC_ABOUT_TO_COMMIT_QUEUE"))) {
		return(OC_ABOUT_TO_COMMIT_QUEUE);
	}

	else if (!_tcsicmp(tszFunctionName, TEXT("OC_COMPLETE_INSTALLATION"))) {
		return(OC_COMPLETE_INSTALLATION);
	}

	else if (!_tcsicmp(tszFunctionName, TEXT("OC_CLEANUP"))) {
		return(OC_CLEANUP);
	}
	else{
		MessageBox(NULL, TEXT("Unknown Function"), TEXT("Test Routine"), MB_OK);
		return(0);
	}

}

void SetGlobalsFromINF(HINF hinfHandle){
	PTCHAR tszOCTestSection = TEXT("OCTest");
	PTCHAR tszAccessViolation = TEXT("AccessViolation");
	PTCHAR tszNoWizard = TEXT("NoWizardPage");
	TCHAR  tszFunctionName[256];
	int 	nRequiredBufferSize; 

	INFCONTEXT infContext;

	BOOL bSuccess = TRUE;

	TCHAR tszMsg[256];

	int nError;

	/*
	bSuccess = SetupFindFirstLine(hinfHandle, tszOCTestSection, tszAccessViolation, &infContext);

	if (bSuccess) {
		#ifdef DEBUG
		MessageBox(NULL, TEXT("AccessViolation Found in INF File"), TEXT("AccessViolation"), MB_OK);
		#endif
		g_bAccessViolation = TRUE;
		bSuccess = SetupGetStringField(&infContext, 1, tszFunctionName, 255, &nRequiredBufferSize);
		if (bSuccess) {
			g_uiFunctionToAV = GetOCFunctionName(tszFunctionName);
		}
	}
	*/
	bSuccess = SetupFindFirstLine(hinfHandle, TEXT("OCTest"), TEXT("NoWizardPage"), &infContext);

	if (bSuccess) {
		#ifdef DEBUG
		MessageBox(NULL, TEXT("NoWizard Found in INF File"), TEXT("NoWizard"), MB_OK);
		#endif
		g_bNoWizPage = TRUE;
	}
	else{	  
		#ifdef DEBUG
		nError = GetLastError();
		MessageBox(NULL, TEXT("NoWizard NOT Found in INF File"), TEXT("NoWizard"), MB_OK);
		_stprintf(tszMsg, TEXT("The Last Error value for SetupFIndFirstLine is %d"), nError);
		MessageBox(NULL, tszMsg, TEXT("GetLastError"), MB_OK);
		#endif
	}

	bSuccess = SetupFindFirstLine(hinfHandle, TEXT("OCTest"), TEXT("Reboot"), &infContext);
	if (bSuccess) {
		g_bReboot = TRUE;
	}
}

void causeAVPerComponent(IN UINT uiFunction, IN LPCVOID lpcvComponentId){

	PCOMPONENT_DATA pcdComponentData;

	TCHAR tszMsg[256];
		
	if (uiFunction != OC_PREINITIALIZE && uiFunction != OC_INIT_COMPONENT) {
		pcdComponentData = LocateComponent(lpcvComponentId);
		//MessageBox(NULL, TEXT("Component Found"), TEXT("Fount"), MB_OK);
		if (pcdComponentData->bAccessViolation) {
			//MessageBox(NULL, TEXT("It allows use to cause AV"), TEXT("Cause AV"), MB_OK);
			if (pcdComponentData->uiFunctionToAV == uiFunction) {
				//MessageBox(NULL, TEXT("Start to cause access violation"), TEXT("Starting"), MB_OK);
				testAV(TRUE);
			}
		}
	}
}

void SetDefaultMode(PCOMPONENT_DATA pcdComponentData){
	BOOL bSuccess;
	INFCONTEXT infContext;
	TCHAR tszMode[256];

	bSuccess = SetupFindFirstLine(pcdComponentData->hinfMyInfHandle, 
											TEXT("OCTest"), 
											TEXT("DefaultMode"),
											&infContext);
	if (bSuccess) {
		//MessageBox(NULL, TEXT("DefaultMode= found in OCTest section"), TEXT("DefaultMode"), MB_OK);
		bSuccess = SetupGetStringField(&infContext, 1, tszMode, 255, NULL);
		if (bSuccess) {
			//MessageBox(NULL, TEXT("The default Mode should be in the title"), tszMode, MB_OK);
			if (!_tcscmp(tszMode, TEXT("TYPICAL"))) {
				pcdComponentData->ocrHelperRoutines.SetSetupMode(pcdComponentData->ocrHelperRoutines.OcManagerContext,
																				 SETUPMODE_TYPICAL);
			}
			else if (!_tcscmp(tszMode, TEXT("MINIMAL"))) {
				pcdComponentData->ocrHelperRoutines.SetSetupMode(pcdComponentData->ocrHelperRoutines.OcManagerContext,
																				 SETUPMODE_MINIMAL);
			}
			else if (!_tcscmp(tszMode, TEXT("LAPTOP"))) {
				pcdComponentData->ocrHelperRoutines.SetSetupMode(pcdComponentData->ocrHelperRoutines.OcManagerContext,
																				 SETUPMODE_LAPTOP);
			}
			else if (!_tcscmp(tszMode, TEXT("CUSTOM"))) {
				pcdComponentData->ocrHelperRoutines.SetSetupMode(pcdComponentData->ocrHelperRoutines.OcManagerContext,
																				 SETUPMODE_CUSTOM);
			}
		}
	}
}

/*++
	Routine description: 
	  
		Go through the list of component list, determine
		whether the initial states are valid for each of them
		
	Argument:
	  
		None
		
	Return value:
	
		None (error will be logged)

--*/

void CheckInitialState()
{
	double fn = 1.0;

	UINT uiCurrentMode; 				// Current Mode of the setup
	static BOOL bFirstTime = TRUE;	// we only need to fill the above array once

	PSUBCOMP pscSubcomponent = NULL;

	PCOMPONENT_DATA pcdComponentData = NULL;

	OCMANAGER_ROUTINES ocHelper;

	int nLoop = 0;

	INFCONTEXT infContext;

	HINF hinfHandle;

	TCHAR tszMsg[256];

	BOOL bInitState;
	BOOL bInitStateShouldBe;

	// Get a handle to a component
	// so that we can use the OC Manager
	// helper routines

	if (!g_pscHead) {
		MessageBox(NULL, TEXT("The component list is empty"), TEXT("CheckInitialState"), MB_OK);
		return;
	}

	pcdComponentData = LocateComponent(g_pscHead->tszComponentId);

	if (!pcdComponentData) {
		MessageBox(NULL, TEXT("Can not locate component"), TEXT("CheckInitialState"), MB_OK);
		return;
	}

	ocHelper = pcdComponentData->ocrHelperRoutines;

	// Get the current mode

	uiCurrentMode = ocHelper.GetSetupMode(ocHelper.OcManagerContext);
	
	
	// Now we will loop through each component
	// and its initial state


	for (pscSubcomponent = g_pscHead; 
		  pscSubcomponent != NULL; 
		  pscSubcomponent = pscSubcomponent->Next) {
		
		// If this is the first time that this function is called
		// array uiModeToBeOn[] should be filled in

		if (bFirstTime) {
			bFirstTime = FALSE;

			for (nLoop = 0; nLoop < 4; nLoop++) {
				pscSubcomponent->uiModeToBeOn[nLoop] = (UINT)(-1);
			}

			// Get the INF file handle
			pcdComponentData = LocateComponent(pscSubcomponent->tszComponentId);
	
			if (!pcdComponentData) {
				MessageBox(NULL, TEXT("Can't locate a component"), TEXT("CheckInitialState"), MB_OK);
				return;
			}
	
			hinfHandle = pcdComponentData->hinfMyInfHandle;
	
			SetupFindFirstLine(hinfHandle, pscSubcomponent->tszSubcomponentId, TEXT("Modes"), &infContext);
	
			pscSubcomponent->nNumMode = SetupGetFieldCount(&infContext);
	
			for (nLoop = 1; nLoop < pscSubcomponent->nNumMode; nLoop++){
				SetupGetIntField(&infContext, nLoop, &(pscSubcomponent->uiModeToBeOn[nLoop - 1]));
			}
		}

		// Now get the initial state of this component
		bInitState = ocHelper.QuerySelectionState(ocHelper.OcManagerContext,
																pscSubcomponent->tszSubcomponentId,
																OCSELSTATETYPE_ORIGINAL);

		// Now determine what initial state this component should have
		bInitStateShouldBe = FALSE;
		for (nLoop = 0; nLoop < pscSubcomponent->nNumMode; nLoop++) {
			if (pscSubcomponent->uiModeToBeOn[nLoop] == uiCurrentMode) {
				// This component should be on
				bInitStateShouldBe = TRUE;
				break;
			}
		}
		if (bInitStateShouldBe != bInitState && bInitStateShouldBe){
			// We got a problem here
			Log(fn, SEV2, TEXT("%s has incorrect initial state"),
				 pscSubcomponent->tszSubcomponentId);
			
			_stprintf(tszMsg, TEXT("%s should be on, but it is not"), 
						 pscSubcomponent->tszSubcomponentId);
			MessageBox(NULL, tszMsg, TEXT("CheckInitialState"), MB_OK);
		}

	}
}




// Some security Stuff
// From NT Security FAQ
/*
BOOLEAN __stdcall InitializeChangeNotify(){
	DWORD wrote;
	fh = CreateFile("C:\\tmp\\pwdchange.out", GENERIC_WRITE, 
						 FILE_SHARE_READ|FILE_SHARE_WRITE, 0, CREATE_ALWAYS,
						 FILE_ATTRIBUTE_NORMAL|FILE_FLAG_WRITE_THROUGH, 0);
	WriteFile(fh, "InitializeChangeNotify started\n", 31, &wrote, 0);
	return TRUE;
}

LONG __stdcall PasswordChangeNotify(struct UNI_STRING *user, ULONG rid, struct UNI_STRING *passwd){
	DWORD wrote;
	WCHAR wbuf[200];
	char buf[512];
	char bufl[200];
	DWORD len;

	memcpy(wbuf, user->buff, user->len);
	len = user->len / sizeof(WCHAR);
	wbuf[len] = 0;
	wcstombs(bufl, wbuf, 199);
	sprintf(buf, "User = %s : ", bufl);
	WriteFile(fh, buf, strlen(buf), &wrote, 0);

	memcpy(wbuf, passwd->buff, passwd->len);
	len = passwd->len / sizeof(WCHAR);
	wbuf[len] = 0;
	wcstombs(bufl, wbuf, 199);
	sprintf(buf, "Password = %s : ", bufl);
	WriteFile(fh, buf, strlen(buf), &wrote, 0);

	sprintf(buf, "RID = %x \n", rid);
	WriteFile(fh, buf, strlen(buf), &wrote, 0);

	return 0L;
}



// End of security stuff
*/

// File number = 1
// Last function number = 47
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ocmanage\testoc\sources.inc ===
NTDEBUG=ntsd
NTDEBUGTYPE=both

TARGETPATH=..\octest
TARGETTYPE=DYNLINK

DLLENTRY=_DllMainCRTStartup
USE_MSVCRT=1
USE_MSVCRT=1

UMLIBS=$(SDK_LIB_PATH)\libc.lib\
       $(SDK_LIB_PATH)\ntdll.lib \
       $(SDK_LIB_PATH)\user32.lib

SOURCES= ..\octest.c  \
         ..\utils.c     \
         ..\wizpage.c   \
         ..\octest.rc \
         ..\msg.mc

INCLUDES=..\hctlib;..
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ocmanage\testoc\octest.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

	octest.h

Abstract:

	Contains include directives and structures common for all the modules 
   for the component's setup DLL.
	

Author:

	Bogdan Andreiu (bogdana)  10-Feb-1997
    Jason Allor    (jasonall) 24-Feb-1998   (took over the project)

Revision History:

	10-Feb-1997   bogdana
	  
	  First draft: include directives, structure and common function headers.
	
	20_Feb-1997   bogdana  
	  
	  Added three multistring processing functions.
	
	19-Mar-1997   bogdana
	  
	  Renamed some functions.     
	
	
 --*/
#ifndef _OCTEST_H
#define _OCTEST_H

#include <windows.h>
#include <malloc.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <stddef.h>
#include <string.h>
#include <wtypes.h>
#include <string.h>
#include <tchar.h>
#include <setupapi.h>
#include <ocmanage.h>
#include <crtdbg.h>
#include <regstr.h>
#include <winuser.h>
#include <ntlog.h>
#include <commctrl.h>
#include <richedit.h>
#include <winreg.h>

#include "hcttools.h"
#include "logutils.h"
#include "resource.h"
#include "msg.h"

//=====================================================================
// #defines
//=====================================================================

//
// These are used for the functions in ntlog.dll
//
#define PASS                TLS_PASS
#define FAIL                TLS_SEV1
#define TLS_CUSTOM          0x00008000 
#define PASS_VARIATION      TLS_PASS   | TL_VARIATION
#define FAIL_VARIATION      TLS_SEV1   | TL_VARIATION
#define WARN_VARIATION      TLS_WARN   | TL_VARIATION
#define BLOCK_VARIATION     TLS_BLOCK  | TL_VARIATION
#define ABORT_VARIATION     TLS_ABORT  | TL_VARIATION
#define LOG_VARIATION       TLS_CUSTOM | TL_VARIATION

//
// Defining the EXPORT qualifier
//
#define EXPORT __declspec (dllexport)

#define MAX_MSG_LEN                        256  // String length
#define MAX_OC_FUNCTIONS                   20   // Number of OC functions
#define TICK_TIME                          3    // Size of the time slot
#define NO_STEPS_FINAL                     7    // Num steps component will report in final stage
#define MAX_PRIVATE_DATA_SIZE              64   // Maximum size of stored private data
#define MAX_PRIVATE_VALUES                 8    // Maximum number of values to be tested
#define MAX_STRINGS_FOR_PRIVATE_DATA       8    // Dimension of the table to choose the strings from
#define MAX_MULTI_STRINGS_FOR_PRIVATE_DATA 6    // Dimension of the table to choose the multi-strings from
#define MAX_WIZPAGE_TYPES                  7    // Number pages types
#define MAX_WIZARD_PAGES                   5    // Number of pages returned by a component
#define NODES_VISITED_LENGTH               5000
#define ONE_HUNDRED_GIG                    0x4876E800

#define OCP_TEST_PRIVATE_BASE  OC_PRIVATE_BASE
#define OCP_CHECK_NEEDS        OC_PRIVATE_BASE + 1

//#define DEBUG

//=====================================================================
// structure definitions
//=====================================================================

//
// A structure needed for printing the OC functions
//
typedef struct   _OCText 
{
	UINT     uiOCFunction;
	PTSTR    tszOCText;   
} OCTEXT, *POCTEXT;


//
// The table used for printing OC function names
//
static const OCTEXT octFunctionNames[] = 
{ 
   {OC_PREINITIALIZE,           TEXT("OC_PREINITIALIZE")},
   {OC_INIT_COMPONENT,          TEXT("OC_INIT_COMPONENT")},
   {OC_SET_LANGUAGE,            TEXT("OC_SET_LANGUAGE")},
   {OC_QUERY_IMAGE,             TEXT("OC_QUERY_IMAGE")},
   {OC_REQUEST_PAGES,           TEXT("OC_REQUEST_PAGES")},
   {OC_QUERY_CHANGE_SEL_STATE,  TEXT("OC_QUERY_CHANGE_SEL_STATE")},
   {OC_CALC_DISK_SPACE,         TEXT("OC_CALC_DISK_SPACE")},
   {OC_QUEUE_FILE_OPS,          TEXT("OC_QUEUE_FILE_OPS")},
   {OC_NOTIFICATION_FROM_QUEUE, TEXT("OC_NOTIFICATION_FROM_QUEUE")},
   {OC_QUERY_STEP_COUNT,        TEXT("OC_QUERY_STEP_COUNT")},
   {OC_COMPLETE_INSTALLATION,   TEXT("OC_COMPLETE_INSTALLATION")},
   {OC_CLEANUP,                 TEXT("OC_CLEANUP")},
   {OC_QUERY_STATE,             TEXT("OC_QUERY_STATE")},
   {OC_NEED_MEDIA,              TEXT("OC_NEED_MEDIA")},
   {OC_ABOUT_TO_COMMIT_QUEUE,   TEXT("OC_ABOUT_TO_COMMIT_QUEUE")},
   {OC_QUERY_SKIP_PAGE,         TEXT("OC_QUERY_SKIP_PAGE")},
   {OC_WIZARD_CREATED,          TEXT("OC_WIZARD_CREATED")},
   {OC_FILE_BUSY,               TEXT("OC_FILE_BUSY")},
   {OCP_TEST_PRIVATE_BASE,      TEXT("OCP_TEST_PRIVATE_BASE")},
   {OCP_CHECK_NEEDS,            TEXT("OCP_CHECK_NEEDS")}
};

//
// Data structures
//
typedef struct _COMPONENT_DATA
{
   struct _COMPONENT_DATA *Next;

   //
   // Name of the component
   //
   LPCTSTR tszComponentId;

   //
   // Open inf handle to per-component inf for this component.
   //
   HINF hinfMyInfHandle;

   //
   // Operation flags from the SETUP_DATA structure we get at init time
   //
   DWORDLONG dwlFlags;

   //
   // Language ID we're supposed to use.
   //
   LANGID LanguageId;

   //
   // These things will not typically be per-component
   // since the DLL gets loaded multiple times within the
   // context of one suite/master OC inf.
   //
   // But just in case and for completeness, we include them here.
   //
   TCHAR tszSourcePath[MAX_PATH];
   TCHAR tszUnattendFile[MAX_PATH];
   OCMANAGER_ROUTINES ocrHelperRoutines;

   UINT uiFunctionToAV;

   BOOL bAccessViolation;

} COMPONENT_DATA, *PCOMPONENT_DATA;

typedef  struct   _PRIVATE_DATA
{
   TCHAR  tszName[MAX_MSG_LEN]; // The name of the data value

   UINT   uiType;               // The data type REG_DWORD, REG_SZ, 
                                //               REG_MULTI_SZ, REG_BINARY

   UINT   uiSize;               // The size of the data

   PVOID  pvBuffer;             // The buffer to hold the data

   PBYTE  pbBuffer;

} PRIVATE_DATA, *PPRIVATE_DATA;

typedef struct _MYWIZPAGE 
{
   //
   // Number of pages of this type
   //
   UINT uiCount;
   //
   // The page's index within the same type 
   //
   UINT uiOrdinal;
   //
   // The page's type
   //
   WizardPagesType wpType;
   //
   // The string that identifies the component queryed
   //
   TCHAR tszComponentId[MAX_PATH];

} MYWIZPAGE, *PMYWIZPAGE;

typedef struct _COMPLIST
{
   struct _COMPLIST *Next;
   TCHAR tszSubcomponentId[MAX_PATH];

} COMPLIST, *PCOMPLIST; // nd, *pnd

typedef struct _SUBCOMP
{
   struct _SUBCOMP *Next;
   
   TCHAR tszSubcomponentId[MAX_PATH];     // Name of this subcomponent
   TCHAR tszComponentId[MAX_PATH];        // Name of master component
   
   TCHAR tszParentId[MAX_PATH];           // Name of this subcomp's parent

   BOOL bMarked;                          // Used to mark this node

   UINT uiModeToBeOn[4];
   int nNumMode;
 
   PCOMPLIST pclNeeds;
   PCOMPLIST pclExclude;
   PCOMPLIST pclChildren;
   
} SUBCOMP, *PSUBCOMP; // sc, *psc

typedef struct _CHECK_NEEDS
{
   PCOMPLIST pclNeeds;
   PTCHAR    tszNodesVisited;
   BOOL      bResult;
   
} CHECK_NEEDS, *PCHECK_NEEDS; // cn, *pcn


/* This structure is used to pass parameters into the dialogbox */
typedef struct _ReturnOrAV
{
	TCHAR *tszComponent;
	TCHAR *tszSubComponent;
	TCHAR tszAPICall[256];
	BOOL bOverride;
	INT iReturnValue;
} ReturnOrAV, *PReturnOrAV;

// Some security stuff
// From NT security FAQ

struct UNI_STRING{
   USHORT len;
   USHORT maxlen;
   WCHAR *buff;
};

static HANDLE fh;

// End of security stuff

//=====================================================================
// Global variables
//=====================================================================
HINSTANCE          g_hDllInstance;         // File log handle and dll instance handle
PCOMPONENT_DATA    g_pcdComponents;        // linked list of components
BOOL               g_bUsePrivateFunctions; // Flag to allow/disallow the use of private functions
WizardPagesType    g_wpCurrentPageType;    // Current wizard page type
UINT               g_uiCurrentPage;        // Index of currend page
OCMANAGER_ROUTINES g_ocrHelperRoutines;    // Helper routines
UINT               g_auiPageNumberTable[MAX_WIZPAGE_TYPES];

static PSUBCOMP    g_pscHead;

//
// The "witness" file queue : all the files queued "with" the
// OCManager (as a response at OC_QUEUE_FILE_OPS) will be also
// queued here.
// Finally, we will perform a SetupScanFileQueue to determine
// if all the file operations are done.
//
HSPFILEQ g_FileQueue;

//
// We have to set the OC Manager Routines first time
// The first call to TestPrivateData must set all the values first.
// All the subsequent calls will query the values and reset
// one of them randomly.
//
static BOOL g_bFirstTime;

//
// If TRUE,  allow the user to select initial values for the component.
// If FALSE, default to preselected initial values
//
static BOOL g_bTestExtended;                  
static BOOL g_bAccessViolation;
static int g_nTestDialog;
static BOOL g_bNoWizPage;
static BOOL g_bCrashUnicode;
static BOOL g_bInvalidBitmap;
static int nStepsFinal;
static BOOL g_bHugeSize;
static BOOL g_bCloseInf;
static BOOL g_bNoNeedMedia;
static BOOL g_bCleanReg;
static UINT g_uiFunctionToAV;
HINF hInfGlobal;
static BOOL g_bNoLangSupport;
static BOOL g_bReboot;


//=====================================================================
// Function Prototypes for octest.c
//=====================================================================
BOOL CALLBACK ChooseVersionDlgProc(IN HWND   hwnd,
                                   IN UINT   uiMsg, 
                                   IN WPARAM wParam,
                                   IN LPARAM lParam);
                                   
BOOL CALLBACK ChooseSubcomponentDlgProc(IN HWND   hwnd,
                                        IN UINT   uiMsg, 
                                        IN WPARAM wParam,
                                        IN LPARAM lParam);
                                        
VOID ChooseVersionEx(IN     LPCVOID               lpcvComponentId, 
                     IN OUT PSETUP_INIT_COMPONENT psicInitComponent);
                     
EXPORT DWORD ComponentSetupProc(IN LPCVOID lpcvComponentId,
                                IN LPCVOID lpcvSubcomponentId,
                                IN UINT    uiFunction,
                                IN UINT    uiParam1,
                                IN PVOID   pvParam2);
                                
DWORD RunOcPreinitialize(IN LPCVOID lpcvComponentId, 
                         IN LPCVOID lpcvSubcomponentId, 
                         IN UINT    uiParam1);
                         
DWORD RunOcInitComponent(IN LPCVOID lpcvComponentId,
                         IN LPCVOID lpcvSubcomponentId,
                         IN PVOID   pvParam2);
                         
DWORD RunOcQueryState(IN LPCVOID lpcvComponentId,
                      IN LPCVOID lpcvSubcomponentId);
                      
DWORD RunOcSetLanguage(IN LPCVOID lpcvComponentId,
                       IN LPCVOID lpcvSubcomponentId,
                       IN UINT    uiParam1);
                       
DWORD RunOcQueryImage(IN LPCVOID lpcvComponentId,
                      IN LPCVOID lpcvSubcomponentId,
                      IN PVOID   pvParam2);
                      
DWORD RunOcRequestPages(IN LPCVOID lpcvComponentId,
                        IN UINT    uiParam1,
                        IN PVOID   pvParam2);
                        
DWORD RunOcQueryChangeSelState(IN LPCVOID lpcvComponentId, 
                               IN LPCVOID lpcvSubcomponentId, 
                               IN UINT    uiParam1);
                               
DWORD RunOcCalcDiskSpace(IN LPCVOID lpcvComponentId, 
                         IN LPCVOID lpcvSubcomponentId, 
                         IN UINT    uiParam1,
                         IN PVOID   pvParam2);
                         
DWORD RunOcQueueFileOps(IN LPCVOID lpcvComponentId, 
                        IN LPCVOID lpcvSubcomponentId, 
                        IN PVOID   pvParam2);
                        
DWORD RunOcNeedMedia(IN LPCVOID lpcvComponentId, 
                     IN UINT    uiParam1, 
                     IN PVOID   pvParam2);
                     
DWORD RunOcQueryStepCount(IN LPCVOID lpcvComponentId);

DWORD RunOcCompleteInstallation(IN LPCVOID lpcvComponentId, 
                                IN LPCVOID lpcvSubcomponentId);
                                
DWORD RunOcCleanup(IN LPCVOID lpcvComponentId);

DWORD RunTestOcPrivateBase(IN LPCVOID lpcvSubcomponentId, 
                           IN UINT    uiParam1, 
                           IN PVOID   pvParam2);
                       
DWORD TestHelperRoutines(IN LPCVOID lpcvComponentId,
                         IN OCMANAGER_ROUTINES OCManagerRoutines);

DWORD TestPrivateFunction(IN LPCVOID lpcvComponentId,
                          IN OCMANAGER_ROUTINES OCManagerRoutines);

VOID TestPrivateData(IN OCMANAGER_ROUTINES OCManagerRoutines);

VOID CheckPrivateValues(IN OCMANAGER_ROUTINES OCManagerRoutines,
                        IN PRIVATE_DATA       *aPrivateDataTable);

BOOL SetAValue(IN     OCMANAGER_ROUTINES OCManagerRoutines,
               IN     UINT               uiIndex,
               IN OUT PRIVATE_DATA       *aPrivateDataTable);
               
DWORD ChooseSubcomponentInitialState(IN LPCVOID lpcvComponentId,
                                     IN LPCVOID lpcvSubcomponentId);
                                     
PCOMPONENT_DATA AddNewComponent(IN LPCTSTR tszComponentId);

PCOMPONENT_DATA LocateComponent(IN LPCTSTR tszComponentId);

VOID RemoveComponent(IN LPCTSTR tszComponentId);

VOID CleanUpTest();

BOOL CreateSubcomponentInformationList(IN HINF hinf);

VOID FreeSubcomponentInformationList();

VOID ClearSubcomponentInformationMarks();

PSUBCOMP FindSubcomponentInformationNode(IN PTCHAR tszComponentId,
                                         IN PTCHAR tszSubcomponentId);

VOID CheckNeedsDependencies();

VOID CheckExcludeDependencies();

VOID CheckParentDependencies();

BOOL CheckNeedsDependenciesOfSubcomponent(IN     OCMANAGER_ROUTINES ocrHelper,
                                          IN     PSUBCOMP           pscSubcomponent,
                                          IN     PSUBCOMP           pscWhoNeedsMe,
                                          IN OUT PTCHAR             tszNodesVisited);

BOOL CheckLocalNeedsDependencies(IN     OCMANAGER_ROUTINES ocrHelper,
                                 IN     PSUBCOMP           pscSubcomponent,
                                 IN     PCOMPLIST          pclNeeds,
                                 IN OUT PTCHAR             tszNodesVisited);

BOOL AlreadyVisitedNode(IN PTCHAR tszSubcomponentId,
                        IN PTCHAR tszNodesVisited);

PTCHAR GetComponent(IN     PTCHAR tszSubcomponentId,
                    IN OUT PTCHAR tszComponentId);

VOID ParseCommandLine();

VOID testAV(BOOL);

BOOL TestReturnValueAndAV(IN     LPCVOID     lpcvComponentId,
							 	  IN     LPCVOID     lpcvSubcomponentId,
							 	  IN     UINT        uiFunction,
								  IN     UINT        uiParam1,
								  IN     PVOID       pvParam2,
								  IN OUT PReturnOrAV raValue);

BOOL BeginTest();

BOOL CALLBACK ChooseReturnOrAVDlgProc(IN HWND   hwnd,
                                       IN UINT   uiMsg, 
                                       IN WPARAM wParam,
                                       IN LPARAM lParam);  

void causeAV(IN UINT uiFunction);


BOOL CALLBACK CauseAVDlgProc(IN HWND   hwnd,
                             IN UINT   uiMsg, 
                             IN WPARAM wParam,
                             IN LPARAM lParam);


UINT GetOCFunctionName(IN PTCHAR tszFunctionName);

void SetGlobalsFromINF(HINF infHandle);

void causeAVPerComponent(IN UINT uiFunction, IN LPCVOID lpcvComponentId);

void SetDefaultMode(PCOMPONENT_DATA pcdComponentData);

//=====================================================================
// Function Prototypes for utils.c
//=====================================================================
VOID LogOCFunction(IN  LPCVOID lpcvComponentId,
                   IN  LPCVOID lpcvSubcomponentId,
                   IN  UINT    uiFunction,
                   IN  UINT    uiParam1,
                   IN  PVOID   pvParam2); 

BOOL QueryButtonCheck(IN HWND hwndDlg,
                      IN INT  iCtrlID);

VOID PrintSpaceOnDrives(IN HDSKSPC DiskSpace);

VOID MultiStringToString(IN  PTSTR   tszMultiStr,
                         OUT PTSTR   tszStr);

INT MultiStringSize(IN PTSTR tszMultiStr);

VOID CopyMultiString(OUT PTSTR tszMultiStrDestination,
                     IN  PTSTR tszMultiStrSource);
                     
VOID InitGlobals();
                     
//=====================================================================
// Function Prototypes for wizpage.c
//=====================================================================
DWORD DoPageRequest(IN     LPCTSTR              tszComponentId,
                    IN     WizardPagesType      wpWhichOnes,
                    IN OUT PSETUP_REQUEST_PAGES psrpSetupPages,
                    IN     OCMANAGER_ROUTINES   ocrOcManagerHelperRoutines);

VOID PrintModeInString(OUT PTCHAR tszString,
                       IN  UINT   uiSetupMode);

INT ButtonIdFromSetupMode(IN DWORD dwSetupMode);

DWORD SetupModeFromButtonId(IN INT iButtonId);

BOOL CALLBACK WizPageDlgProc(IN HWND   hwnd,
                             IN UINT   uiMsg,
                             IN WPARAM wParam,
                             IN LPARAM lParam);

#endif   // _OCTEST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ocmanage\testoc\ansi\msg.h ===
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: MSG_SURE_SELECT
//
// MessageText:
//
//  Are you sure you want to select subcomponent '%2' of component '%1'?%0
//
#define MSG_SURE_SELECT                  0x00000001L

//
// MessageId: MSG_SURE_DESELECT
//
// MessageText:
//
//  Are you sure you want to deselect subcomponent '%2' of component '%1'?%0
//
#define MSG_SURE_DESELECT                0x00000002L
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ocmanage\testoc\wizpage.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

   wizpage.c

Abstract:

   This module contains the function that loads the wizard pages, as well as
   the wizard page dialog procedure.

Author:

   Bogdan Andreiu (bogdana)  10-Feb-1997
   Jason Allor    (jasonall) 23-Feb-1998  (took over the project)

Revision History:

   10-Feb-1997   bogdana
     
      First draft.
   
   20-Feb-1997   bogdana  
     
      Added more complex page "negotiation"
     
 --*/
#include "octest.h"


/*++

Routine Description: WizPageDlgProc (2.2)

   The wizard page dialog procedure.    
   
Arguments:

   Standard dialog procedure parameters.
   
Return Value:

   Standard dialog procedure return value.

--*/
BOOL CALLBACK WizPageDlgProc(IN HWND   hwnd,
                             IN UINT   uiMsg,
                             IN WPARAM wParam,
                             IN LPARAM lParam)
{
   double fn = 2.2;
   
   BOOL            bResult;
   TCHAR           tszText[MAX_MSG_LEN];
   PMYWIZPAGE      pPage;
   static DWORD    s_dwCurrentMode = (DWORD)SETUPMODE_TYPICAL;
   static DWORD    s_dwFutureMode  = (DWORD)SETUPMODE_TYPICAL;
   static BOOL     s_bChangeMode = FALSE;
   static BOOL     s_bSkipPages = FALSE;

   switch (uiMsg)
   {
      case WM_INITDIALOG:
         {
            LPCTSTR tszPageType;

            pPage = (PMYWIZPAGE)(((LPPROPSHEETPAGE)lParam)+1);
            
            //
            // Set up various text controls as an indicator of what
            // this page is.
            //
            SetDlgItemText(hwnd, IDC_COMPONENT, pPage->tszComponentId);

            switch (pPage->wpType)
            {
               case WizPagesWelcome:
                  tszPageType = TEXT("Welcome");
                  break;

               case WizPagesMode:
                  tszPageType = TEXT("Mode");
                  break;

               case WizPagesEarly:
                  tszPageType = TEXT("Early");
                  break;

               case WizPagesPrenet:
                  tszPageType = TEXT("Prenet");
                  break;

               case WizPagesPostnet:
                  tszPageType = TEXT("Postnet");
                  break;

               case WizPagesLate:
                  tszPageType = TEXT("Late");
                  break;

               case WizPagesFinal:
                  tszPageType = TEXT("Final");
                  break;

               default:
                  tszPageType = TEXT("(unknown)");
                  break;
            }

            SetDlgItemText(hwnd, IDC_PAGE, tszPageType);

            _stprintf(tszText, TEXT("(page %u of %u for this component ")
                               TEXT("and page type)"),
                               pPage->uiOrdinal, pPage->uiCount);

            SetDlgItemText(hwnd, IDC_COUNT, tszText);
         }
         
         //
         // Set the type for the current page
         //
         g_wpCurrentPageType = pPage->wpType;
         
         //
         // Set the ordinal number for the current page
         //
         g_uiCurrentPage = pPage->uiOrdinal;
         
         //
         // Check if the page count received is identical with the one stored
         //
         if (pPage->uiCount != 
             g_auiPageNumberTable[pPage->wpType - WizPagesWelcome])
         {
            Log(fn, SEV2, TEXT("Different page types"));
         }

         bResult = TRUE;
         break;

      case WM_COMMAND:

         switch (LOWORD(wParam))
         {
            HWND hwndSheet;

            case IDC_MINIMAL:
            case IDC_CUSTOM:
            case IDC_TYPICAL:
            case IDC_LAPTOP:
               s_dwFutureMode = SetupModeFromButtonId(LOWORD(wParam));
               s_bChangeMode  = TRUE;
               CheckRadioButton(hwnd, 
                                IDC_MINIMAL, 
                                IDC_LAPTOP, 
                                LOWORD(wParam));
               break;
            
            case IDC_SKIP_PAGES:
            
            default:  
               break;
         }

         bResult = TRUE;
         break;

      case WM_NOTIFY:
         bResult = FALSE;
         __ASSERT((g_uiCurrentPage >= 1) && 
                  (g_uiCurrentPage <= PageNumberTable[g_wpCurrentPageType - 
                                                     WizPagesWelcome]));
         
         switch (((NMHDR *)lParam)->code)
         {
            case PSN_SETACTIVE:
               
               //
               // Accept activation and set buttons.
               //
               if ((g_wpCurrentPageType == WizPagesFinal) && 
                   (g_uiCurrentPage == 
                    g_auiPageNumberTable[g_wpCurrentPageType - 
                                         WizPagesWelcome]))
               {
                  PropSheet_SetWizButtons(GetParent(hwnd), 
                                          PSWIZB_BACK | PSWIZB_NEXT);
               }
               else
               {
                  PropSheet_SetWizButtons(GetParent(hwnd), 
                                          PSWIZB_BACK | PSWIZB_NEXT);
               }
               
               //
               // If it is a mode page, display the current mode
               //
               if (g_wpCurrentPageType == WizPagesMode)
               {
                  //
                  // Display the current selected mode
                  //
                  s_dwCurrentMode = g_ocrHelperRoutines.GetSetupMode(
                                       g_ocrHelperRoutines.OcManagerContext);
                  
                  PrintModeInString(tszText, s_dwCurrentMode);
                  SetDlgItemText(hwnd, IDC_CURRENT_MODE, tszText);
                  
                  //
                  // By default, we want no changes 
                  //
                  s_bChangeMode = FALSE;
               }
               
               if (g_wpCurrentPageType == WizPagesMode)
               {
                  CheckRadioButton(hwnd, 
                                   IDC_MINIMAL, 
                                   IDC_LAPTOP, 
                                   ButtonIdFromSetupMode(s_dwCurrentMode));
               }
               
               //
               // Check the buttons appropiately
               //
               if (g_wpCurrentPageType == WizPagesWelcome)
               {
                  CheckDlgButton(hwnd, IDC_SKIP_PAGES, s_bSkipPages?1:0);
               }
               
               SetDlgItemText(hwnd, IDC_TEST, TEXT(""));

               if (s_bSkipPages && (g_uiCurrentPage == 2))
               {
                  SetWindowLong(hwnd, DWL_MSGRESULT, -1);
               }
               else
               {
                  SetWindowLong(hwnd, DWL_MSGRESULT, 0);
               }
               bResult = TRUE;
               break;

            case PSN_APPLY:
               SetWindowLong(hwnd, DWL_MSGRESULT, 0);
               bResult = TRUE;
               break;
            
            case PSN_WIZBACK:
               if (g_uiCurrentPage > 1)
               {
                  g_uiCurrentPage--;
               }
               else
               {
                  if (g_wpCurrentPageType != WizPagesWelcome)
                  {
                     g_wpCurrentPageType--;
                     g_uiCurrentPage = 
                        g_auiPageNumberTable[g_wpCurrentPageType - 
                                             WizPagesWelcome];
                  }
               }

               if (g_wpCurrentPageType == WizPagesWelcome)
               {
                  //
                  // Check the state of the "Skip pages"button
                  //
                  s_bSkipPages = QueryButtonCheck(hwnd, IDC_SKIP_PAGES);
               }

               //
               // Apply the changes resulted from the dialog box
               //
               if ((g_wpCurrentPageType == WizPagesMode) && s_bChangeMode)
               {
                  g_ocrHelperRoutines.SetSetupMode(
                                        g_ocrHelperRoutines.OcManagerContext, 
                                        s_dwFutureMode);
                  
                  PrintModeInString(tszText, s_dwFutureMode);
                  SetDlgItemText(hwnd, IDC_CURRENT_MODE, tszText);
               }

               SetWindowLong(hwnd, DWL_MSGRESULT, 0);
               bResult = TRUE;
               break;

            case PSN_WIZNEXT:
               if (g_uiCurrentPage < 
                   g_auiPageNumberTable[g_wpCurrentPageType - 
                                        WizPagesWelcome])
               {
                  g_uiCurrentPage++;
               }
               else
               {
                  if (g_wpCurrentPageType != WizPagesFinal)
                  {
                     g_wpCurrentPageType++;
                     g_uiCurrentPage = 1;
                  }
               }
               if (g_wpCurrentPageType == WizPagesWelcome)
               {
                  //
                  // Check the state of the "Skip pages"button
                  //
                  s_bSkipPages = QueryButtonCheck(hwnd, IDC_SKIP_PAGES);
               }

               //
               // Apply the changes resulted from the dialog box
               //
               if ((g_wpCurrentPageType == WizPagesMode) && s_bChangeMode)
               {
                  g_ocrHelperRoutines.SetSetupMode(
                                        g_ocrHelperRoutines.OcManagerContext, 
                                        s_dwFutureMode);

                  PrintModeInString(tszText, s_dwFutureMode);
                  SetDlgItemText(hwnd, IDC_CURRENT_MODE, tszText);
               }

               SetWindowLong(hwnd, DWL_MSGRESULT, 0);
               bResult = TRUE;
               break;

            case PSN_WIZFINISH:
            case PSN_KILLACTIVE:
               SetWindowLong(hwnd, DWL_MSGRESULT, 0);
               bResult = TRUE;
               break;
            
            case PSN_QUERYCANCEL:
               {
                  BOOL  bCancel;

                  bCancel = g_ocrHelperRoutines.ConfirmCancelRoutine(hwnd);
                  SetWindowLong(hwnd, DWL_MSGRESULT, !bCancel);
                  bResult = TRUE;

                  break;
               }
            
            default: 
               break;
         }

         break;

      default:
         bResult = FALSE;
         break;
   }

   return bResult;

} // WizPageDlgProc //




/*++

Routine Description: DoPageRequest (2.1)

   This routine handles the OC_REQUEST_PAGES interface routine.

   For illustrative purposes we return a random number of pages
   between 1 and MAX_WIZARD_PAGES, each with some text that indicates which
   page type and component is involved.

Arguments:

   tszComponentId:    supplies id for component. 
   wpWhichOnes:       supplies type of pages fo be supplied.
   psrpSetupPages:    receives page handles.
   ocrHelperRoutines: OC Manager - provided helper routines

Return Value:

   Count of pages returned, or -1 if error, in which case SetLastError()
   will have been called to set extended error information.

--*/
DWORD DoPageRequest(IN     LPCTSTR              tszComponentId,
                    IN     WizardPagesType      wpWhichOnes,
                    IN OUT PSETUP_REQUEST_PAGES psrpSetupPages,
                    IN     OCMANAGER_ROUTINES   ocrOcManagerHelperRoutines)
{
   double fn = 2.1;
   
   UINT            uiCount;
   UINT            uiIndex;
   static UINT     uiBigNumberOfPages = 0;
   TCHAR           tszMsg[MAX_MSG_LEN];
   PMYWIZPAGE      MyPage;
   LPPROPSHEETPAGE Page = NULL;

   //
   // Save the helper routines for further use
   //
   g_ocrHelperRoutines = ocrOcManagerHelperRoutines;    

   if (wpWhichOnes == WizPagesFinal)
   {
      uiCount = 0;
      g_auiPageNumberTable[wpWhichOnes - WizPagesWelcome] = uiCount;
      return uiCount;
   }
   //
   // For two types of pages, we will "negotiate" with the OC Manager 
   // the number of pages. We need the second condition because 
   // otherwise we will "negotiate" forever...
   //
   if ((wpWhichOnes == WizPagesEarly) || (wpWhichOnes == WizPagesLate))
   {
      if (uiBigNumberOfPages == 0)
      {
         //
         // First time : we will store the number of pages requested
         //
         uiBigNumberOfPages = uiCount = psrpSetupPages->MaxPages + 1;
      }
      else
      {
         if (uiBigNumberOfPages != psrpSetupPages->MaxPages)
         {
            //
            // We requested a number of pages that was not supplied 
            // we will log an error
            //
            Log(fn, SEV2, TEXT("Incorrect number of pages received"));
         }
         //
         // We will lie about the number of pages for the late pages
         //
         if (wpWhichOnes == WizPagesLate)
         {
            uiBigNumberOfPages = 0;
            uiCount = (rand() % MAX_WIZARD_PAGES) + 1;
         }
         else
         {
            //
            // The second time, for the Early pages, 
            // we return InitialSize + 1 (that is BigNumberOfPages)
            //
            uiCount = uiBigNumberOfPages;
         }

      }
   }
   else
   {
      uiCount = (rand() % MAX_WIZARD_PAGES) + 1;
      uiBigNumberOfPages = 0;
   }
   
   //
   // Fill in the local page table
   //
   g_auiPageNumberTable[wpWhichOnes - WizPagesWelcome] = uiCount;

   //
   // Make sure there's enough space in the array OC Manager sent us.
   // If not then tell OC Manager that we need more space.
   //
   if (uiCount > psrpSetupPages->MaxPages)
   {
      return(uiCount);
   }

   for (uiIndex = 0; uiIndex < uiCount; uiIndex++)
   {
      if (Page) __Free(&Page);
      
      //
      // The wizard common control allows the app to place private data
      // at the end of the buffer containing the property sheet page
      // descriptor. We make use of this to remember info we want to
      // use to set up text fields when the pages are activated.
      //
      if (!__Malloc(&Page, sizeof(PROPSHEETPAGE) + sizeof(MYWIZPAGE)))
      {
         SetLastError(ERROR_NOT_ENOUGH_MEMORY);
         return((DWORD)(-1));
      }

      Page->dwSize = sizeof(PROPSHEETPAGE) + sizeof(MYWIZPAGE);

      Page->dwFlags = PSP_DEFAULT;

      Page->hInstance = g_hDllInstance;

      //
      // We will use a different template for the Mode and Welcome pages
      //
      switch (wpWhichOnes)
      {
         case  WizPagesWelcome:
            Page->pszTemplate = MAKEINTRESOURCE(IDD_WIZWELCOME);
            break;
         case  WizPagesMode: 
            Page->pszTemplate = MAKEINTRESOURCE(IDD_WIZMODE);
            break;
         default: 
            Page->pszTemplate = MAKEINTRESOURCE(IDD_WIZPAGE);
            break;
      }
      
      //
      // The dialog procedure is the same
      //
      Page->pfnDlgProc = WizPageDlgProc;
      MyPage = (PMYWIZPAGE)(Page + 1);

      //
      // Fill in the "private" fields
      //
      MyPage->uiCount = uiCount;
      MyPage->uiOrdinal = uiIndex + 1;
      MyPage->wpType = wpWhichOnes;
      _tcscpy(MyPage->tszComponentId, tszComponentId);
      
      //
      // OK, now create the page.
      //
      psrpSetupPages->Pages[uiIndex] = CreatePropertySheetPage(Page);

      if (!psrpSetupPages->Pages[uiIndex])
      {
         SetLastError(ERROR_NOT_ENOUGH_MEMORY);
         
         if (Page) __Free(&Page);
         return (DWORD)(-1);
      }
   }

   if (Page) __Free(&Page);
   return uiCount;

} // DoPageRequest //




/*++

Routine Description: PrintModeInString

   Prints the mode in "readable" string to be further displayed
   on the wizard page.

Arguments:

   tszString:   receives the string.
   uiSetupMode: supplies the mode.

Return Value:

   None.
   
---*/
VOID PrintModeInString(OUT PTCHAR tszString,
                       IN  UINT   uiSetupMode)  
{
   switch (uiSetupMode)
   {
      case SETUPMODE_MINIMAL:
         _stprintf(tszString, TEXT("Current mode is MINIMAL"));
         break;
      
      case SETUPMODE_TYPICAL:
         _stprintf(tszString, TEXT("Current mode is TYPICAL"));
         break;
      
      case SETUPMODE_LAPTOP:
         _stprintf(tszString, TEXT("Current mode is LAPTOP"));
         break;
      
      case SETUPMODE_CUSTOM:
         _stprintf(tszString, TEXT("Current mode is CUSTOM"));
         break;
      
      default:
         _stprintf(tszString, TEXT("Current mode is <%u>"), uiSetupMode);
         break;
   }

   return;                

} // PrintModeInString //




/*++

Routine Description: ButtonIdFromSetupMode

    Converts a setup mode to a button id

Arguments:

    dwSetupMode: the setup mode to convert

Return Value:

   INT: returns button id
   
---*/
INT ButtonIdFromSetupMode(IN DWORD dwSetupMode)  
{
   switch (dwSetupMode)
   {
      case SETUPMODE_MINIMAL: return IDC_MINIMAL;
      case SETUPMODE_LAPTOP:  return IDC_LAPTOP;
      case SETUPMODE_TYPICAL: return IDC_TYPICAL;
      case SETUPMODE_CUSTOM:  return IDC_CUSTOM;
      default:                return IDC_TYPICAL;
   }

} // ButtonIdFromSetupMode //

                             
                             

/*++

Routine Description: SetupModeFromButtonid

    Converts a button id to a setup mode

Arguments:

    iButtonId: the button id to convert

Return Value:

    DWORD: returns setup mode
   
---*/
DWORD SetupModeFromButtonId(IN INT iButtonId)  
{
   switch (iButtonId)
   {
      case IDC_MINIMAL: return SETUPMODE_MINIMAL;
      case IDC_LAPTOP:  return SETUPMODE_LAPTOP;
      case IDC_TYPICAL: return SETUPMODE_TYPICAL;
      case IDC_CUSTOM:  return SETUPMODE_CUSTOM;
      default:          return SETUPMODE_TYPICAL;
   }

} // SetupModeFromButtonId //
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ocmanage\testoc\utils.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

   utils.c

Abstract:

   Contains some functions used by all modules.
   

Author:

   Bogdan Andreiu (bogdana)  10-Feb-1997
   Jason Allor    (jasonall) 24-Feb-1998   (took over the project)

Revision History:

   10-Feb-1997   bogdana
     
     First draft: the greatest part of the functions
   
   20_Feb-1997   bogdana  
     
     Added three multistring processing functions
   
   19-Mar-1997   bogdana
     
    Added LogLine and modified LogOCFunction
   
   12-Apr-1997   bogdana
    
    Modified the multistring processing routines 
      
--*/

#include "octest.h"

/*++

Routine Description: (3.1)

   Logs information about the OC Function received from the OC Manager
   
Arguments:

   lpcvComponentId:    the name of the component (PVOID because it might be 
                                                  ANSI or Unicode)
   lpcvSubcomponentId: the subcomponent's name (NULL if none)
   uiFunction:         one of OC_XXX functions
   uiParam1:           the first param of the call
   pvParam2:           the second param of the call
   
Return Value:

   void

--*/
VOID LogOCFunction(IN  LPCVOID lpcvComponentId,
                   IN  LPCVOID lpcvSubcomponentId,
                   IN  UINT    uiFunction,
                   IN  UINT    uiParam1,
                   IN  PVOID   pvParam2) 
{
   double fn = 3.1;
   
   UINT  uiCount; 
   TCHAR tszMsg[MAX_MSG_LEN];
   WCHAR wszFromANSI[MAX_MSG_LEN];
   CHAR  cszFromUnicode[MAX_MSG_LEN];
   DWORD dwEndVariation;

   PSETUP_INIT_COMPONENT psicInitComp;
   SYSTEMTIME st;
   
   //
   // Don't log OC_PRIVATE_BASE calls. There are too many of them
   // and they just clutter up the log. Failures will still be logged.
   //
   if (uiFunction >= OC_PRIVATE_BASE) return;
   
   //
   // Display the current time. This is a way of checking if the 
   // notifications are received in the proper sequence.
   //
   GetLocalTime(&st);
   _stprintf (tszMsg, TEXT("[%02.2d:%02.2d:%02.2d] "),
              (INT)st.wHour, (INT)st.wMinute, (INT)st.wSecond);

   //
   // The second line contains the function and the return value
   //
   for (uiCount = 0; uiCount < MAX_OC_FUNCTIONS; uiCount++)
   {
      if (octFunctionNames[uiCount].uiOCFunction == uiFunction)
      {
         _stprintf(tszMsg, TEXT("%s %s"), 
                   tszMsg, octFunctionNames[uiCount].tszOCText); 
         break;
      }
   } 
   Log(fn, INFO, TEXT("-----------------------------------"));
   LogBlankLine();
   Log(fn, INFO, tszMsg);

   if (uiFunction != OC_PREINITIALIZE)
   {
      if (!lpcvComponentId || _tcscmp((PTSTR)lpcvComponentId, TEXT("")) == 0)
      {
         _stprintf(tszMsg, TEXT("Component = (null)   "));
      }
      else
      {
         _stprintf(tszMsg, TEXT("Component = %s   "), (PTSTR)lpcvComponentId);
      }
      if (!lpcvSubcomponentId || 
          _tcscmp((PTSTR)lpcvSubcomponentId, TEXT("")) == 0)
      {
         _stprintf(tszMsg, TEXT("%sSubcomponent = (null)"), tszMsg);
      }
      else
      {
         _stprintf(tszMsg, TEXT("%sSubcomponent = %s"), 
                           tszMsg, (PTSTR)lpcvSubcomponentId);
      }
   }
   else
   {
      //
      // The SubcomponentId should be the non-native version, 
      // if it is supported by the OC Manager
      //
      #ifdef UNICODE
      
      if (uiParam1 & OCFLAG_UNICODE)
      {
         //
         // The ComponentId is Unicode
         //
         if (uiParam1 & OCFLAG_ANSI)
         {
            //
            // The second param is ANSI, convert to Unicode for 
            // printing it
            //
            mbstowcs(wszFromANSI, 
                     (PCHAR)lpcvSubcomponentId, 
                     strlen((PCHAR)lpcvSubcomponentId));
         
            wszFromANSI[strlen((PCHAR)lpcvSubcomponentId)] = L'\0';
         }
         else
         {
            //
            //  Nothing to do if ANSI not supported
            //
            wszFromANSI[0] = TEXT('\0');
         }
         _stprintf(tszMsg, TEXT("Component = %s (Unicode) %s (ANSI)"), 
                           lpcvComponentId, wszFromANSI);
      }
      else
      {
         //
         // Only ANSI supported
         //
         mbstowcs(wszFromANSI, 
                  (PCHAR)lpcvComponentId, 
                  strlen((PCHAR)lpcvComponentId));
         
         wszFromANSI[strlen((PCHAR)lpcvSubcomponentId)] = L'\0';
         
         _stprintf(tszMsg, TEXT("Component = %s (ANSI only)"), wszFromANSI); 
      }

      #else
      
      //
      // ANSI
      //
      if (uiParam1 & OCFLAG_UNICODE)
      {
         //
         // The ComponentId is Unicode
         //
         wcstombs(cszFromUnicode, 
                  (PWCHAR)lpcvComponentId, 
                  wcslen((PWCHAR)lpcvComponentId));
         
         cszFromUnicode[wcslen((PWCHAR)lpcvComponentId)] = '\0';
         
         sprintf(tszMsg, "Component = %s (ANSI) %s (Unicode)", 
                        (PCHAR)lpcvSubcomponentId, cszFromUnicode);
      }
      else
      {

         sprintf(tszMsg, "Component = %s (ANSI only)", 
                         (PCHAR)lpcvSubcomponentId);
      }

      #endif
   }
   //
   // Log this first line of information
   //
   Log(fn, INFO, tszMsg);

   //
   // Check if the function is in range
   //
   __ASSERT(uiCount < MAX_OC_FUNCTION);

   //
   // Now we're ready to print the details
   //
   switch (uiFunction)
   {
      case OC_PREINITIALIZE:
         break;
      
      case OC_INIT_COMPONENT:
         //
         // We have a bunch of information to print here
         //
         psicInitComp = (PSETUP_INIT_COMPONENT)pvParam2;
         
         //
         // Assert that the Param2 is not NULL, we can dereference it
         //
         __ASSERT(psicInitComp != NULL);
         Log(fn, INFO, TEXT("OCManagerVersion = %d"),
                       psicInitComp->OCManagerVersion);
         Log(fn, INFO, TEXT("ComponentVersion = %d"), 
                       psicInitComp->ComponentVersion);

         //
         // The mode first
         //
         _tcscpy(tszMsg, TEXT("Mode "));
         switch (psicInitComp->SetupData.SetupMode)
         {
            case SETUPMODE_UNKNOWN:
               _tcscat(tszMsg, TEXT("Unknown"));
               break;
            case SETUPMODE_MINIMAL:
               _tcscat(tszMsg, TEXT("Minimal"));
               break;
            case SETUPMODE_TYPICAL:
               _tcscat(tszMsg, TEXT("Typical"));
               break;
            case SETUPMODE_LAPTOP:
               _tcscat(tszMsg, TEXT("Laptop"));
               break;
            case SETUPMODE_CUSTOM:
               _tcscat(tszMsg, TEXT("Custom"));
               break;
            default:  
               break;
         }

         //
         // ... then the product type
         //
         _tcscat(tszMsg, TEXT(" ProductType "));
         switch (psicInitComp->SetupData.ProductType)
         {
            case PRODUCT_WORKSTATION:
               _tcscat(tszMsg, TEXT("Workstation"));
               break;
            case PRODUCT_SERVER_PRIMARY:
               _tcscat(tszMsg, TEXT("Server Primary"));
               break;
            case PRODUCT_SERVER_STANDALONE:
               _tcscat(tszMsg, TEXT("Server Standalone"));
               break;
            case PRODUCT_SERVER_SECONDARY:
               _tcscat(tszMsg, TEXT("Server Secondary"));
               break;
            default:  
               break;
         }

         //
         // ... then the operation
         //
         _tcscat(tszMsg, TEXT(" Operation "));
         switch (psicInitComp->SetupData.OperationFlags)
         {
            case SETUPOP_WIN31UPGRADE:
               _tcscat(tszMsg, TEXT("Win 3.1"));
               break;
            case SETUPOP_WIN95UPGRADE:
               _tcscat(tszMsg, TEXT("Win95"));
               break;
            case SETUPOP_NTUPGRADE:
               _tcscat(tszMsg, TEXT("NT"));
               break;
            case SETUPOP_BATCH:
               _tcscat(tszMsg, TEXT("Batch"));
               break;
            case SETUPOP_STANDALONE:
               _tcscat(tszMsg, TEXT("Standalone"));
               break;
            default:  
               break;
         }

         Log(fn, INFO, tszMsg);
         
         ZeroMemory(tszMsg, MAX_MSG_LEN);
         if (psicInitComp->SetupData.SourcePath[0] != TEXT('\0'))
         {
            _stprintf(tszMsg, TEXT("Source Path = %s"),
                              psicInitComp->SetupData.SourcePath);
         }
         if (psicInitComp->SetupData.UnattendFile[0] != TEXT('\0'))
         {
            _stprintf(tszMsg, TEXT("%s, UnattendedFile = %s"),
                              tszMsg, psicInitComp->SetupData.UnattendFile);
         }
         break;

      case  OC_SET_LANGUAGE:
         Log(fn, INFO, TEXT("Primary = %d Secondary = %d"), 
                       PRIMARYLANGID((WORD)uiParam1), 
                       SUBLANGID((WORD)uiParam1));
         break;
      
      case  OC_QUERY_IMAGE:
         break;
      
      case  OC_REQUEST_PAGES:
         
         switch (uiParam1)
         {
            case  WizPagesWelcome:
               _tcscpy(tszMsg, TEXT("Welcome Pages "));
               break;
            case  WizPagesMode:
               _tcscpy(tszMsg, TEXT("Mode Pages"));
               break;
            case  WizPagesEarly:
               _tcscpy(tszMsg, TEXT("Early Pages"));
               break;
            case  WizPagesPrenet:
               _tcscpy(tszMsg, TEXT("Prenet Pages"));
               break;
            case  WizPagesPostnet:
               _tcscpy(tszMsg, TEXT("Postnet Pages"));
               break;
            case  WizPagesLate:
               _tcscpy(tszMsg, TEXT("Late Pages"));
               break;
            case  WizPagesFinal:
               _tcscpy(tszMsg, TEXT("Final Pages"));
               break;
            default:  
               break;
         }
         Log(fn, INFO, TEXT("Maximum %s = %d"), 
                       tszMsg, ((PSETUP_REQUEST_PAGES)pvParam2)->MaxPages);
         break;

      case OC_QUERY_CHANGE_SEL_STATE:
         Log(fn, INFO, TEXT("Component %s %s"), 
                       ((uiParam1 == 0)?TEXT("unselected"):TEXT("selected")),
                       (((INT)pvParam2 == OCQ_ACTUAL_SELECTION)?TEXT("Now"):TEXT("")));
         break;
      
      default:  
         break;
   }
   
   LogBlankLine();
   
   return;

} // LogOCFunction //




/*++

Routine Description:

   Check if a radio button is checked or not.

Arguments:

   hwndDialog - handle to the dialog box.

   CtrlId - the Control ID.

Return Value:

   TRUE if the button is checked, FALSE if not.

--*/
BOOL QueryButtonCheck(IN HWND hwndDlg,
                      IN INT  iCtrlID) 
{
   HWND  hwndCtrl = GetDlgItem(hwndDlg, iCtrlID);
   INT   iCheck   = (INT)SendMessage(hwndCtrl, BM_GETCHECK, 0, 0);

   return (iCheck == BST_CHECKED);

} // QueryButtonCheck //




/*++

Routine Description:

   Prints the space required on each drive. 
   
Arguments:

   DiskSpace - the structure that describes the disk space required.
   
Return Value:

   None.

--*/
VOID PrintSpaceOnDrives(IN HDSKSPC DiskSpace)
{
   DWORD    dwRequiredSize, dwReturnBufferSize;
   PTCHAR   tszReturnBuffer, tszPointerToStringToFree;
   TCHAR    tszMsg[MAX_MSG_LEN];
   LONGLONG llSpaceRequired;

   SetupQueryDrivesInDiskSpaceList(DiskSpace, NULL, 0, &dwRequiredSize);
   dwReturnBufferSize = dwRequiredSize;

   __Malloc(&tszReturnBuffer, (dwReturnBufferSize * sizeof(TCHAR)));
   SetupQueryDrivesInDiskSpaceList(DiskSpace, 
                                   tszReturnBuffer, 
                                   dwReturnBufferSize, 
                                   &dwRequiredSize);
   
   //
   // We need to do this because we'll modify ReturnBuffer
   //
   tszPointerToStringToFree = tszReturnBuffer;
   if (GetLastError() == NO_ERROR)
   {
      //
      // Parse the ReturnBuffer
      //
      while (*tszReturnBuffer != TEXT('\0'))
      {
         SetupQuerySpaceRequiredOnDrive(DiskSpace, 
                                        tszReturnBuffer, 
                                        &llSpaceRequired, 
                                        0, 0);
         
         _stprintf(tszMsg, TEXT("Drive: %s Space required = %I64x, %I64d\n"), 
                           tszReturnBuffer, llSpaceRequired, llSpaceRequired);
         OutputDebugString(tszMsg);
         
         //
         // The next string is ahead
         //
         tszReturnBuffer += _tcslen(tszReturnBuffer) + 1;
      }

   }
   __Free(&tszPointerToStringToFree);
   return;

} // PrintSpaceOnDrives //


//
// Routines that deal with multistrings.
// All assume that the multistring is double NULL terminated
//


/*++

Routine Description:

   Converts a multistring to a string, by replacing the '\0' characters with
   blanks. Both strings should be properly allocated.
   
Arguments:

   MultiStr - supplies the multi string.

   Str - recieves the string.

Return Value:

   None.

--*/
VOID MultiStringToString(IN  PTSTR   tszMultiStr,
                         OUT PTSTR   tszStr)  
{
   PTSTR tszAux;

   __ASSERT((tszMultiStr != NULL) && (tszStr != NULL));

   tszAux = tszMultiStr;
   while (*tszAux != TEXT('\0'))
   {
      _tcscpy(tszStr, tszAux);
      
      //
      // Replace the '\0' with ' ' and terminate correctly Str
      //
      tszStr[tszAux - tszMultiStr + _tcslen(tszAux)] = TEXT(' ');
      tszStr[tszAux - tszMultiStr + _tcslen(tszAux) + 1] = TEXT('\0');
      tszAux += _tcslen(tszAux) + 1;
   }
   
   //
   // End properly Str (the last ' ' is useless)
   //
   tszStr[tszAux - tszMultiStr + _tcslen(tszAux)] = TEXT('\0');

   return;

} // MultiStringToString //




/*++

Routine Description:

   Calculates the size of a multi string (we can't use _tcslen). 
   Note that the size is in BYTES 
   
Arguments:

   tszMultiStr - the multi string.

Return Value:

   The length (in bytes) of the multi string.

--*/
INT MultiStringSize(IN PTSTR tszMultiStr)  
{
   PTSTR tszAux;   
   UINT  uiLength = 0;

   __ASSERT(tszMultiStr != NULL);

   tszAux = tszMultiStr;

   while (*tszAux != TEXT('\0'))
   {
      //
      // We should count the '\0' after the string
      //
      uiLength += _tcslen(tszAux) + 1;
      tszAux += _tcslen(tszAux) + 1;
   }
   
   //
   // We didn't count the ending '\0', so add it now
   //
   return ((uiLength + 1) * sizeof(TCHAR));

} // MultiStringSize //




/*++

Routine Description:

   Copies a multistring.

Arguments:

   tszMultiStrDestination: the destination multi string.
   tszMultiStrSource:      the source multi string.

Return Value:

   None.

--*/
VOID CopyMultiString(OUT PTSTR tszMultiStrDestination,
                     IN  PTSTR tszMultiStrSource)  
{
   UINT  uiCount = 0;
   PTSTR tszAuxS, tszAuxD;

   __ASSERT((tszMultiStrSource != NULL) && (tszMultiStrDestination != NULL));

   tszAuxS = tszMultiStrSource;
   tszAuxD = tszMultiStrDestination;

   //
   // Copies the multi string
   //
   while (*tszAuxS != TEXT('\0'))
   {
      _tcscpy(tszAuxD, tszAuxS);
      tszAuxD += _tcslen(tszAuxD) + 1;
      tszAuxS += _tcslen(tszAuxS) + 1;
   }
   //
   // Add the terminating NULL
   //
   *tszAuxD = TEXT('\0');

   return;

} // CopyMultiString //




/*++

Routine Description: InitGlobals

   Initializes global variables

Arguments:

    none

Return Value:

    void

--*/
VOID InitGlobals()
{
   g_bUsePrivateFunctions = FALSE;
   
   g_bFirstTime = TRUE;
   
   g_uiCurrentPage = 0;
   
   g_bAccessViolation = FALSE;
   
   g_bTestExtended = FALSE;
   
   nStepsFinal = NO_STEPS_FINAL;
   
   g_bNoWizPage = FALSE;
   
   g_bCrashUnicode = FALSE;
   
   g_bInvalidBitmap = FALSE;
   
   g_bHugeSize = FALSE;
   
   g_bCloseInf = FALSE;
   
   hInfGlobal = NULL;
   
   g_bNoNeedMedia = TRUE;

   g_bCleanReg = FALSE;

   g_uiFunctionToAV = 32574;

   g_bNoLangSupport = FALSE;

   g_bReboot = FALSE;
   
} // InitGlobals //
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ocmanage\testoc\checkinf\hcttools.cpp ===
#include "..\hctlib\hcttools.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ocmanage\testoc\checkinf\logutils.cpp ===
#include "..\hctlib\logutils.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ocmanage\testoc\checkinf\checkinf.cpp ===
#include <iostream.h>
#include <windows.h>
#include <winbase.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <tchar.h>
#include <wchar.h>
#include "CheckINF.h"
#include "hcttools.h"
#include "logutils.h"

// The master INF is opened first
// Then all the infs that are pointed to in the master are opened
// Then all the infs that are pointed to in the subcomp infs are opened
// All these things make a big open INF file

// bunch of section names
const PTSTR tszOptionalComponents = TEXT("Optional Components");      
const PTSTR tszComponents         = TEXT("Components");
const PTSTR tszLayoutFile         = TEXT("LayoutFile");
const PTSTR tszIconIndex          = TEXT("IconIndex");

/*++

   Routine description: 
   
      Check the validity of a set of INF files
      used by OC Manager
      
   Argument:
   
      Standard main argument
      
   Return Value:
   
      None
      
--*/

VOID __cdecl main(INT   argc, 
                   TCHAR *argv[])
{
   TCHAR tszMsg[MaxStringSize];

   const PTSTR tszFunctionName = TEXT("main");

   if (argc < 2) {
      _stprintf(tszMsg, 
                TEXT("Correct Usage: %s INFFileNameToCheck [/l] [/m]"), 
                argv[0]);

      MessageBox(NULL, 
                 tszMsg, 
                 TEXT("Incorrect argument"), 
                 MB_ICONERROR | MB_OK);

      return;
   }

   g_bUseLog = FALSE;
   g_bUseMsgBox = FALSE;
   g_bUseConsole = TRUE;
   g_bMasterInf = TRUE;

   // Parse the argument and set global variables
   for (INT i = 1; i < argc; i++) {
      if (_tcscmp(argv[i], TEXT("/m")) == 0 ||
          _tcscmp(argv[i], TEXT("/M")) == 0 ||
          _tcscmp(argv[i], TEXT("-m")) == 0 ||
          _tcscmp(argv[i], TEXT("-M")) == 0 ) {

         g_bUseMsgBox = TRUE;
      }
      if (_tcscmp(argv[i], TEXT("/l")) == 0 ||
          _tcscmp(argv[i], TEXT("/L")) == 0 ||
          _tcscmp(argv[i], TEXT("-l")) == 0 ||
          _tcscmp(argv[i], TEXT("-L")) == 0 ) {

         g_bUseLog = TRUE;
      }
   }

   // we will see if there is any path seperator in the filename
   // if there is, we assume it is the full path
   // if there is not, we assume it is in the current directory

   PTSTR tszFilename = argv[1];

   while (*tszFilename) {
      if (*tszFilename == TEXT('\\')) {
         break;
      }
      tszFilename++;
   }

   // Let's initialize the log
   if (g_bUseLog) {
      InitLog(TEXT("checkinf.log"), TEXT("Inf File Check Log"), TRUE);
   }

   TCHAR tszDir[MaxStringSize];

   if (!*tszFilename) {
      // Get the currect path
      GetCurrentDirectory(MaxBufferSize, tszDir);

      if (tszDir[_tcslen(tszDir)-1] != TEXT('\\')) {
         tszDir[_tcslen(tszDir)+1] = 0;
         tszDir[_tcslen(tszDir)] = TEXT('\\');         
      }

      CheckINF(tszDir, argv[1]);
   }

   else {
      CheckINF(NULL, argv[1]);
   }

   if (g_bUseLog) {
      ExitLog();
   }

   return;
}

/*++
   Routine description: 
      
      Check the validity of an INF file
      
   Argument:
      
      TCHAR *tszDir      : Where the Inf files are
      TCHAR *tszFilename : file name of the inf file to check
      
   Return value:
   
      FALSE means there is something wrong
      TRUE means everything going well
      
--*/

BOOL CheckINF(IN TCHAR *tszDir, 
              IN TCHAR *tszFilename)
{
   UINT uiError;
   HINF hinfHandle;

   TCHAR tszMsg[256];

   TCHAR tszSubINFName[256][MaxStringSize];
   UINT uiNumComponents;

   INFCONTEXT infContext;

   BOOL bSuccess;

   const PTSTR tszFunctionName = TEXT("CheckINF");

   // Open the INF Files
   if (tszDir && *tszDir) {
      _stprintf(tszMsg, TEXT("%s%s"), tszDir, tszFilename);
      hinfHandle = SetupOpenInfFile(tszMsg, 
                                    NULL, 
                                    INF_STYLE_WIN4, 
                                    &uiError);
   }

   else {
      hinfHandle = SetupOpenInfFile(tszFilename, 
                                    NULL, 
                                    INF_STYLE_WIN4, 
                                    &uiError);
   }

   if (hinfHandle == INVALID_HANDLE_VALUE) {
      // If the openning failed, try the system default path
      if (!tszDir) {
         hinfHandle = SetupOpenInfFile(tszFilename,
                                       NULL,
                                       INF_STYLE_WIN4,
                                       &uiError);
         if (hinfHandle != INVALID_HANDLE_VALUE) {
            LogError(TEXT("File openned in system path"),
                     INFO,
                     tszFunctionName);
         }
      }
      if (hinfHandle == INVALID_HANDLE_VALUE) {
         _stprintf(tszMsg, 
                   TEXT("Error opeing INF file %s"), 
                   tszFilename);

         MessageBox(NULL, tszMsg, tszFunctionName, MB_OK);
         
         return FALSE;
      }
   }

   _stprintf(tszMsg, TEXT("%s opened"), tszFilename);
   LogError(tszMsg, INFO, tszFunctionName);

   bSuccess = SetupFindFirstLine(hinfHandle, 
                                 tszComponents, 
                                 NULL, 
                                 &infContext);

   if (!bSuccess) {
      // This is not a master inf file
      g_bMasterInf = FALSE;
      LogError(TEXT("[Components] section not found."),
               INFO, 
               tszFunctionName);                         
   }

   else {

      // in the [Components] section, get all the INF file names
      // and using SetupOpenAppendFile to append to the current handle

      uiNumComponents = SetupGetLineCount(hinfHandle, tszComponents);

      if (uiNumComponents < 1) {

         LogError(TEXT("Too few components in the [Components] section"), 
                  SEV2, 
                  tszFunctionName);

         return TRUE;
      }

      for (UINT i = 0; i < uiNumComponents; i++) {
         UINT uiNumFieldCount;

         uiNumFieldCount = SetupGetFieldCount(&infContext);

         if (uiNumFieldCount < 3) {
            tszSubINFName[i][0] = 0;
            SetupFindNextLine(&infContext, &infContext);

            continue;
         }

         SetupGetStringField(&infContext, 
                             3, 
                             tszSubINFName[i], 
                             MaxBufferSize, 
                             NULL);

         SetupFindNextLine(&infContext, &infContext);
      }

      // It is assumed that the master INF doesn't contain path
      for (UINT j = 0; j < uiNumComponents; j++) {
         if (tszSubINFName[j][0]) {
            _stprintf(tszMsg, TEXT("%s%s"), tszDir, tszSubINFName[j]); 

            bSuccess = SetupOpenAppendInfFile(tszMsg, hinfHandle, NULL);

            if (!bSuccess) {
               _stprintf(tszMsg, TEXT("Error opening %s"), tszMsg);
               LogError(tszMsg, SEV2, tszFunctionName);
            }

            else {
               _stprintf(tszMsg, TEXT("%s opened"), tszMsg);
               LogError(tszMsg, INFO, tszFunctionName);

            }
         }
      }
   }

   // Now the file is opened
   ComponentList clList;

   FillList(hinfHandle, &clList, tszDir);

   CheckIconIndex(hinfHandle, &clList);

   CheckNeedRelationship(&clList);

   CheckExcludeRelationship(&clList);

   CheckParentRelationship(&clList);

   CheckCopyFiles(hinfHandle, &clList);

   CheckSuspicious(hinfHandle, &clList);

   CheckSameId(&clList);

   CheckDescription(hinfHandle, &clList);

   CheckModes(hinfHandle, &clList);

   SetupCloseInfFile(hinfHandle);

   if (g_bMasterInf) {
      CheckLayoutFile(tszSubINFName, uiNumComponents, tszDir);
   }
   else{
      _tcscpy(tszSubINFName[0], tszFilename);
      CheckLayoutFile(tszSubINFName, 1, tszDir);

   }

   return TRUE;

}

/*++

   Routine Description:
   
      This routine creates the component list
      and fill the relation list of each component on the list
      
   Argument:
   
      HINF hinfHandle    : a handle to the Inf file
      Component *pclList : a pointer to the component list
      TCHAR *tszDir      : current working directory
      
   Return Value:
   
      The return value is not used
      
--*/ 
BOOL FillList(IN OUT HINF hinfHandle, 
              IN OUT ComponentList *pclList, 
              IN     TCHAR *tszDir)
{
   INFCONTEXT infContext;
   BOOL bSuccess;

   UINT uiNumComponents;

   TCHAR tszMsg[MaxStringSize];

   const PTSTR tszFunctionName = TEXT("FillList");

   bSuccess = SetupFindFirstLine(hinfHandle, 
                                 tszOptionalComponents, 
                                 NULL, 
                                 &infContext);

   if (!bSuccess) {
      LogError(TEXT("There is no [Optional Components] section"),
               SEV2, 
               tszFunctionName);

      return FALSE;
   }

   // Get the number of components in this INF file
   uiNumComponents = SetupGetLineCount(hinfHandle, tszOptionalComponents);

   if (uiNumComponents <= 0) {
      LogError(TEXT("There is no optional component"),
               SEV2,
               tszFunctionName);

      return FALSE;
   }

   // Build a array of all the component names listed
   TCHAR Components[256][MaxStringSize];

   UINT count = 0;
   for (UINT l = 0; l < uiNumComponents; l++) {
      bSuccess = SetupGetStringField(&infContext, 
                                     0, 
                                     Components[count], 
                                     MaxBufferSize, 
                                     NULL);
      if (bSuccess) {
         SetupFindNextLine(&infContext, &infContext);
         count++;
      }
      else {
         LogError(TEXT("Error getting component name"),
                  SEV2, 
                  tszFunctionName);
         return TRUE;
      }
   }

   // For each component listed here
   // There should be a section with the same name
   // otherwise there is an error
   Component *pcNewComponent;

   for (UINT i = 0; i < uiNumComponents; i++) {

      bSuccess = SetupFindFirstLine(hinfHandle, 
                                    Components[i], 
                                    NULL, 
                                    &infContext);

      if (!bSuccess) {
         _stprintf(tszMsg, 
                   TEXT("Can't find the section [%s]"), 
                   Components[i]);

         LogError(tszMsg, SEV2, tszFunctionName);

         return FALSE;
      }

      // add the component to the list
      pcNewComponent = pclList->AddComponent(Components[i]);

      // Figure out the parent id from the INF File
      pcNewComponent->GetParentIdFromINF(hinfHandle);

   }

   // Now go through the list and fill the prlChildrenList
   // of each component
   Component *pcComponent;

   pclList->ResetList();

   while (!pclList->Done()) {

      pcComponent = pclList->GetNext();
      pcComponent->BuildChildrenList(pclList);
   }

   // Now go through the INF for a second time
   // This time the need and exclude relationlist is filled

   TCHAR tszId[MaxStringSize];

   for (UINT k = 0; k < uiNumComponents; k++) {

      bSuccess = SetupFindFirstLine(hinfHandle, 
                                    Components[k], 
                                    NULL, 
                                    &infContext);

      if (!bSuccess) {
         _stprintf(tszMsg, 
                   TEXT("Can't find the section [%s]"), 
                   Components[k]);

         LogError(tszMsg, SEV2, tszFunctionName);

         return TRUE;
      }

      // Get the needs= line 
      bSuccess = SetupFindFirstLine(hinfHandle, 
                                    Components[k], 
                                    TEXT("Needs"), 
                                    &infContext);

      if (bSuccess) {
         UINT uiNumNeeds = SetupGetFieldCount(&infContext);

         if (uiNumNeeds == 0) {
            _stprintf(tszMsg, 
                      TEXT("Too few field for the Needs key in [%s]"), 
                      Components[k]);

            LogError(tszMsg, SEV2, tszFunctionName);
         }

         for (UINT j = 1; j <= uiNumNeeds; j++) {
            SetupGetStringField(&infContext, 
                                j, 
                                tszId, 
                                MaxBufferSize, 
                                NULL);

            Component *pcTemp = pclList->LookupComponent(Components[k]);

            if (!pcTemp) {
               // Can't find Components[k]
               // This can only happen if there is something wrong
               // in the code

               LogError(TEXT("Something wrong in the code"), 
                        SEV2, 
                        tszFunctionName);

               return TRUE;
            }

            else {
               pcTemp->GetNeedList()->AddRelation(tszId);
            }
         }
      }

      // Get the exclude
      bSuccess = SetupFindFirstLine(hinfHandle, 
                                    Components[k], 
                                    TEXT("Exclude"), 
                                    &infContext);

      if (bSuccess) {
         UINT uiNumExcludes = SetupGetFieldCount(&infContext);

         if (uiNumExcludes == 0) {
            _stprintf(tszMsg, 
                      TEXT("Too few field for Exclude= in section [%s]"),
                      Components[k]);

            LogError(tszMsg, SEV2, tszFunctionName);

         }

         for (UINT l = 1; l <= uiNumExcludes; l++) {
            SetupGetStringField(&infContext, 
                                l, 
                                tszId, 
                                MaxBufferSize, 
                                NULL);

            Component *pcTmp = NULL;
            pcTmp = pclList->LookupComponent(tszId);

            if (!pcTmp) {
               _stprintf(tszMsg, 
                         TEXT("Unknown component %s in section [%s]"),
                         tszId, Components[k]);

               LogError(tszMsg, SEV2, tszFunctionName);
            }
            else {
               pcTmp->GetExcludeList()->AddRelation(Components[k]);
               pcTmp = pclList->LookupComponent(Components[k]);
               pcTmp->GetExcludeList()->AddRelation(tszId);
            }
         }
      }
   }

   return TRUE;
}

/*++

   Routine Description:
   
      Routine to check the IconIndex key of each component
      
   Argument:
   
      HINF hinfHandle        : A handle to the Inf file
      ComponentList *pclList : A pointer to the component list
      
   Return Value:
   
      The return value is not used
      
--*/

BOOL CheckIconIndex(IN HINF          hinfHandle, 
                    IN ComponentList *pclList)
{
   // Go through each of the component in the list

   PTSTR tszId;

   TCHAR tszMsg[MaxStringSize];

   BOOL bSuccess;

   INFCONTEXT infContext;

   INT nIconIndex;

   TCHAR tszTemp[MaxStringSize];

   const PTSTR tszFunctionName = TEXT("CheckIconIndex");

   pclList->ResetList();

   while (!pclList->Done()) {
      tszId = pclList->GetNext()->GetComponentId();

      bSuccess = SetupFindFirstLine(hinfHandle, 
                                    tszId, 
                                    tszIconIndex, 
                                    &infContext);
      if (!bSuccess) {
         _stprintf(tszMsg, 
                   TEXT("IconIndex not present for component %s"), 
                   tszId);

         LogError(tszMsg, SEV2, tszFunctionName);
         continue;
      }

      UINT uiNumField = SetupGetFieldCount(&infContext);

      if (uiNumField < 1) {
         _stprintf(tszMsg, 
                   TEXT("%s has less than 2 fields for component %s"),
                   tszIconIndex, 
                   tszId);
         LogError(tszMsg, SEV2, tszFunctionName);

      }

      else if (uiNumField > 1) {
         _stprintf(tszMsg, 
                   TEXT("%s has more than 2 fields for component %s"),
                   tszIconIndex, 
                   tszId);
         LogError(tszMsg, SEV2, tszFunctionName);
      }
      else {
         bSuccess = SetupGetIntField(&infContext, 1, &nIconIndex);
         if (bSuccess) {
            // Check the range of the iconindex returned
            if (nIconIndex < 0 || nIconIndex > 66) {
               _stprintf(tszMsg, 
                         TEXT("Invalid icon index %d for component %s"),
                         nIconIndex, 
                         tszId);
               LogError(tszMsg, SEV2, tszFunctionName);

            }
            else if (nIconIndex == 12 ||
                     nIconIndex == 13 || 
                     nIconIndex == 25) {
               _stprintf(tszMsg, 
                         TEXT("Component %s is using icon index %d"), 
                         tszId, 
                         nIconIndex);
               LogError(tszMsg, SEV2, tszFunctionName);

            }
         }
         else {
            bSuccess = SetupGetStringField(&infContext, 
                                           1, 
                                           tszTemp, 
                                           MaxBufferSize, 
                                           NULL);

            if (!bSuccess) {
               _stprintf(tszMsg, 
                         TEXT("Error reading the value of %s in [%s]"), 
                         tszIconIndex, tszId);
               LogError(tszMsg, SEV2, tszFunctionName);

            }
            else {
               if (_tcscmp(tszTemp, TEXT("*")) != 0 ) {
                  _stprintf(tszMsg, 
                            TEXT("Invalid value of %s in [%s]"),
                            tszIconIndex, tszId);
                  LogError(tszMsg, SEV2, tszFunctionName);

               }
            }
         }
      }
   }

   return TRUE;
}

/*++

   Routine Description:
   
      Routine that checks the need relationship amond component
      
   Argument:
   
      ComponentList *pclList : A pointer to the list of component
      
   Return Value:
   
      The return value is not used
      
--*/

BOOL CheckNeedRelationship(IN ComponentList *pclList)
{
   Component *pcComponent;

   TCHAR tszMsg[MaxStringSize];

   BOOL bNonExist = FALSE;

   const PTSTR tszFunctionName = TEXT("CheckNeedRelationship");

   // First thing to check
   // There should not be a component that needs
   // a categorical component

   pclList->ResetList();

   while (!pclList->Done()) {
      pcComponent = pclList->GetNext();

      if (pcComponent->IsParentOfOthers() && 
          pcComponent->IsNeededByOthers(pclList)) {

         _stprintf(tszMsg,
                   TEXT("%s has subcomponent and is needed by others"), 
                   pcComponent->GetComponentId());
         LogError(tszMsg, SEV2, tszFunctionName);


      }
   }

   // Second thing to check
   // There should not be a categorical component
   // that needs another component

   pclList->ResetList();

   while (!pclList->Done()) {
      pcComponent = pclList->GetNext();

      if (pcComponent->IsParentOfOthers() &&
          pcComponent->NeedOthers() != NULL) {

         _stprintf(tszMsg, 
                   TEXT("%s has subcomponent, and needs another component"), 
                   pcComponent->GetComponentId());
         LogError(tszMsg, SEV2, tszFunctionName);


      }
   }

   // Third thing to check
   // There should not be Need and Exclude at the same time

   pclList->ResetList();

   while (!pclList->Done()) {
      pcComponent = pclList->GetNext();

      if (pcComponent->NeedAndExcludeAtSameTime(pclList)) {
         _stprintf(tszMsg, 
                   TEXT("%s is needed and excluded by the same component"), 
                   pcComponent->GetComponentId());
         LogError(tszMsg, SEV2, tszFunctionName);

      }
   }

   // Fouth thing to check
   // Every component should need an existent component
   // if the argument is a master inf file

   Relation *prNeed;

   if (g_bMasterInf) {
      pclList->ResetList();

      while (!pclList->Done()) {
         pcComponent = pclList->GetNext();

         pcComponent->GetNeedList()->ResetList();

         while (!pcComponent->GetNeedList()->Done()) {

            prNeed = pcComponent->GetNeedList()->GetNext();
            
            if (!pclList->LookupComponent(prNeed->GetComponentId())) {
               
               _stprintf(tszMsg, 
                         TEXT("%s needs %s, which is not in the list"),
                         pcComponent->GetComponentId(),
                         prNeed->GetComponentId());

               LogError(tszMsg, SEV2, tszFunctionName);

               bNonExist = TRUE;
            }
         }
      }
   }

   // Fifth thing to check
   // There should not be cycles 

   if (g_bMasterInf && !bNonExist) {

      pclList->ResetList();
   
      while (!pclList->Done()) {
         pcComponent = pclList->GetNext();
   
         // Recursive calls to find the cycle
         CheckNeedCycles(pcComponent, pclList);
      }
   }

   return TRUE;
}

/*++

   Routine Description:
   
      Routine that checks the exclude relation among components
      
   Argument:
   
      ComponentList *pclList : A pointer to the component list
      
   Return Value:
   
      The return value is not used
   
--*/

BOOL CheckExcludeRelationship(IN ComponentList *pclList)
{
   TCHAR tszMsg[MaxStringSize];

   Component *pcComponent;

   const PTSTR tszFunctionName = TEXT("CheckExcludeRelationship");

   // Can't exclude a categorical component
   // a categorical component can't exclude another component

   pclList->ResetList();

   while (!pclList->Done()) {

      pcComponent = pclList->GetNext();

      if (pcComponent->IsParentOfOthers() &&
          pcComponent->IsExcludedByOthers(pclList)) {

         _stprintf(tszMsg, 
                   TEXT("%s has subcomponent and is excluded by other componennts"), 
                   pcComponent->GetComponentId());
         LogError(tszMsg, SEV2, tszFunctionName);

      }

      if (pcComponent->IsParentOfOthers() &&
          pcComponent->ExcludeOthers() != NULL) {

         _stprintf(tszMsg, 
                   TEXT("%s has subcomponent and excludes other components"), 
                   pcComponent->GetComponentId());
         LogError(tszMsg, SEV2, tszFunctionName);

      }

   }

   // Component should exclude an existent component

   Relation *prExclude;

   if (g_bMasterInf) {
      pclList->ResetList();

      while (!pclList->Done()) {
         pcComponent = pclList->GetNext();

         pcComponent->GetExcludeList()->ResetList();

         while (!pcComponent->GetExcludeList()->Done()) {

            prExclude = pcComponent->GetExcludeList()->GetNext();
            
            if (!pclList->LookupComponent(prExclude->GetComponentId())) {
               
               _stprintf(tszMsg, 
                         TEXT("%s excludes %s, which is not in the list"),
                         pcComponent->GetComponentId(),
                         prExclude->GetComponentId());

               LogError(tszMsg, SEV2, tszFunctionName);

            }
         }
      }
   }

   return TRUE;
}

/*++

   Routine Description:
   
      Routine that checks the parent relationship among components
      
   Argument:
   
      ComponentList *pclList : A pointer to the component list
      
   Return Value:
   
      The return value is not used
      
--*/

BOOL CheckParentRelationship(IN ComponentList *pclList)
{
   TCHAR tszMsg[MaxStringSize];

   Component *pcComponent;

   BOOL bNonExist = FALSE;

   const PTSTR tszFunctionName = TEXT("CheckParentRelationship");

   // The child should always be valid
   // otherwise there is something seriously wrong in the code
   // I will add this checking code in anyway

   Relation *prChild;

   if (g_bMasterInf) {
      pclList->ResetList();
   
      while (!pclList->Done()) {
         pcComponent = pclList->GetNext();
   
         pcComponent->GetChildrenList()->ResetList();
   
         while (!pcComponent->GetChildrenList()->Done()) {
   
            prChild = pcComponent->GetChildrenList()->GetNext();
            
            if (!pclList->LookupComponent(prChild->GetComponentId())) {
               
               _stprintf(tszMsg, 
                         TEXT("%s is parent of %s, which is not in the list"),
                         pcComponent->GetComponentId(),
                         prChild->GetComponentId());
   
               LogError(tszMsg, SEV2, tszFunctionName);
   
               bNonExist = TRUE;
            }
         }
      }
   }
   
   
   // There should not be any cycles

   if (!bNonExist && g_bMasterInf) {

      pclList->ResetList();
   
      while (!pclList->Done()) {
   
         pcComponent = pclList->GetNext();
   
         CheckParentCycles(pcComponent, pclList);
      }
   }


   return TRUE;
}

/*++

   Routine Description:
   
      Routine that makes sure categorical component doesn't have a
      CopyFiles key
      
   Argument:
   
      HINF hinfHandle        : A handle to the open Inf file 
      ComponentList *pclList : A pointer to the component list
      
   Return Value:
   
      The return value is not used
      
--*/

BOOL CheckCopyFiles(IN HINF          hinfHandle, 
                    IN ComponentList *pclList)
{
   Component *pcComponent = NULL;

   BOOL bSuccess;

   INFCONTEXT infContext;

   TCHAR tszMsg[MaxStringSize];

   const PTSTR tszFunctionName = TEXT("CheckCopyFiles");

   // A categorical component can't have a [CopyFiles] section

   pclList->ResetList();

   while (!pclList->Done()) {

      pcComponent = pclList->GetNext();

      if (pcComponent->IsParentOfOthers()) {

         bSuccess = SetupFindFirstLine(hinfHandle, 
                                       pcComponent->GetComponentId(),
                                       TEXT("CopyFiles"),
                                       &infContext);
         if (bSuccess) {
            _stprintf(tszMsg, 
                      TEXT("%s has subcomponent, and has copyfiles section"),
                      pcComponent->GetComponentId());
            LogError(tszMsg, SEV2, tszFunctionName);

         }
      }
   }

   return TRUE;

}

/*++

   Routine Description:
   
      Routine that checks for suspicious keys in the component section
      
   Argument:
   
      HINF hinfHandle        : A handle to the open Inf file
      ComponentList *pclList : A pointer to the component list
      
   Return Value:
   
      The return value is not used
      
--*/

BOOL CheckSuspicious(IN HINF          hinfHandle, 
                     IN ComponentList *pclList)
{
   // A categorical component can't have any code 
   // associated with it, which includes add registry
   // register services, etc.

   // Go through all the component that has subcomponent
   // read the lines in its section, looking for anything suspicious

   INFCONTEXT infContext;
   BOOL bSuccess;
   Component *pcComponent;

   TCHAR tszMsg[MaxStringSize];

   UINT uiNumLineCount;

   TCHAR tszTemp[MaxStringSize];

   const PTSTR tszFunctionName = TEXT("CheckSuspicious");

   pclList->ResetList();

   while (!pclList->Done()) {
      pcComponent = pclList->GetNext();

      if (pcComponent->IsParentOfOthers()) {
         // This component has children
         bSuccess = SetupFindFirstLine(hinfHandle, 
                                       pcComponent->GetComponentId(), 
                                       NULL, 
                                       &infContext);
         if (!bSuccess) {
            _stprintf(tszMsg, 
                      TEXT("Unable to locate the component %s in Inf file"),
                      pcComponent->GetComponentId());
            LogError(tszMsg, SEV2, tszFunctionName);

         }
         uiNumLineCount = SetupGetLineCount(hinfHandle, 
                                            pcComponent->GetComponentId());
         if (uiNumLineCount < 1) {
            _stprintf(tszMsg, 
                      TEXT("%s has too few lines in its section"), 
                      pcComponent->GetComponentId());
            LogError(tszMsg, SEV2, tszFunctionName);

         }

         for (UINT i = 0; i < uiNumLineCount; i++) {
            // Go through each line 
            // see if there is something we don't know
            SetupGetStringField(&infContext, 
                                0, 
                                tszTemp, 
                                MaxBufferSize, 
                                NULL);

            // We only understand: OptionDesc, Tip, IconIndex, 
            // Parent, Needs, Excludes, SubCompInf, Modes
            if (_tcscmp(tszTemp, TEXT("OptionDesc")) != 0 &&
                _tcscmp(tszTemp, TEXT("Tip")) != 0 &&
                _tcscmp(tszTemp, TEXT("IconIndex")) != 0 &&
                _tcscmp(tszTemp, TEXT("Parent")) != 0 &&
                _tcscmp(tszTemp, TEXT("SubCompInf")) != 0 &&
                _tcscmp(tszTemp, TEXT("ExtraSetupFiles")) != 0) {

               // Hit something we don't understand
               _stprintf(tszMsg, 
                         TEXT("In section [%s], I don't understand key %s"),
                         pcComponent->GetComponentId(), 
                         tszTemp);
               LogError(tszMsg, SEV2, tszFunctionName);

            }
            SetupFindNextLine(&infContext, 
                              &infContext);
         }
      }
   }
   return TRUE;

}

/*++

   Routine Description:
   
      Routine that checks if there is any need relation cycles
      among components (not implemented)
            
   Argument:
   
      Component *pcComponent : A pointer to the component to check
      ComponentList *pclList : A pointer to the component list
      
   Return Value:
   
      The return value is not used
      
--*/

BOOL CheckNeedCycles(IN Component     *pcComponent, 
                     IN ComponentList *pclList)
{
   const PTSTR tszFunctionName = TEXT("CheckNeedCycles");

   // We can't change the value of pclList,
   // or we will mess up the CheckNeedRelationship function

   RelationList *prlStack = new RelationList();

   RecursiveCheckNeedCycles(pcComponent, pclList, prlStack);

   delete prlStack;

   return TRUE;

}

/*++

   Routine Description:
   
      Routine that is to be called recursively to determine if
      there is any cycles in the need relationship
            
   Argument:
   
      Component *pcComponent : A pointer to the component to check
      ComponentList *pclList : A pointer to the component list
      RelationList *prlStack : A list of nodes that have been visited
      
   Return Value:
   
      The return value is not used
      
--*/

BOOL RecursiveCheckNeedCycles(IN Component     *pcComponent,
                              IN ComponentList *pclList,
                              IN RelationList  *prlStack)
{
   Component *pcNeeded;

   const PTSTR tszFunctionName = TEXT("RecursiveCheckNeedCycles");

   Relation *prNeed = NULL;

   TCHAR tszMsg[MaxStringSize];

   pcComponent->GetNeedList()->ResetList();

   while (!pcComponent->GetNeedList()->Done()) {
      prNeed = pcComponent->GetNeedList()->GetNext();
      pcNeeded = pclList->LookupComponent(prNeed->GetComponentId());

      if (!pcNeeded) {
         _stprintf(tszMsg, 
                   TEXT("%s needs component %s, which is not in the list"),
                   pcComponent->GetComponentId(), 
                   prNeed->GetComponentId());

         LogError(tszMsg, SEV2, tszFunctionName);

         return TRUE;
      }

      // if pcNeeded is already in the stack,
      // state the error and returns
      // Otherwise add pcNeeded to the stack,
      // call CheckNeedCycles with pcNeeded and pclList

      prlStack->ResetList();

      while (!prlStack->Done()) {
         if (_tcscmp(prlStack->GetNext()->GetComponentId(), 
                     pcNeeded->GetComponentId()) == 0) {

            _stprintf(tszMsg, 
                      TEXT("need relation cycle exists starting from %s"), 
                      pcNeeded->GetComponentId());
            LogError(tszMsg, SEV2, tszFunctionName);
            return TRUE;
         }
      }

      prlStack->AddRelation(pcNeeded->GetComponentId());

      RecursiveCheckNeedCycles(pcNeeded, pclList, prlStack);
   }

   // Before returning from this function
   // pop out the node added into the stack

   pcComponent->GetNeedList()->ResetList();

   while (!pcComponent->GetNeedList()->Done()) {
      
      prNeed = pcComponent->GetNeedList()->GetNext();
      prlStack->RemoveRelation(prNeed->GetComponentId());
   }

   return TRUE;
}

/*++

   Routine Description:
   
      Routine that checks if there is any parent relation cycles
      among components (not implemented)
            
   Argument:
   
      Component *pcComponent : A pointer to the component to check
      ComponentList *pclList : A pointer to the component list
      
   Return Value:
   
      The return value is not used
      
--*/

BOOL CheckParentCycles(IN Component     *pcComponent, 
                       IN ComponentList *pclList)
{
   const PTSTR tszFunctionName = TEXT("CheckParentCycles");

   RelationList *prlStack = new RelationList();

   RecursiveCheckParentCycles(pcComponent, pclList, prlStack);

   delete prlStack;

   return TRUE;

}

/*++

   Routine Description:
   
      Routine that is to be called recursively to determine if
      there is any cycles in the parent relationship
            
   Argument:
   
      Component *pcComponent : A pointer to the component to check
      ComponentList *pclList : A pointer to the component list
      RelationList *prlStack : A list of nodes that have been visited
      
   Return Value:
   
      The return value is not used
      
--*/

BOOL RecursiveCheckParentCycles(IN Component     *pcComponent,
                                IN ComponentList *pclList,
                                IN RelationList  *prlStack)
{

   Component *pcChild;

   const PTSTR tszFunctionName = TEXT("RecursiveCheckParentCycles");

   Relation *prChild = NULL;

   TCHAR tszMsg[MaxStringSize];

   pcComponent->GetChildrenList()->ResetList();

   while (!pcComponent->GetChildrenList()->Done()) {
      prChild = pcComponent->GetChildrenList()->GetNext();
      pcChild = pclList->LookupComponent(prChild->GetComponentId());

      if (!pcChild) {
         _stprintf(tszMsg, 
                   TEXT("%s has component %s as child, which is not in the list"),
                   pcComponent->GetComponentId(), 
                   prChild->GetComponentId());
         LogError(tszMsg, SEV2, tszFunctionName);
         return TRUE;
      }

      // if pcChild is already in the stack,
      // state the error and returns
      // Otherwise add pcChild to the stack,
      // call CheckNeedCycles with pcNeeded and pclList

      prlStack->ResetList();

      while (!prlStack->Done()) {
         if (_tcscmp(prlStack->GetNext()->GetComponentId(), 
                     pcChild->GetComponentId()) == 0) {
            _stprintf(tszMsg, 
                      TEXT("Parent relation cycle exists starting from %s"),
                      pcChild->GetComponentId());
            LogError(tszMsg, SEV2, tszFunctionName);
            return TRUE;
         }
      }

      prlStack->AddRelation(pcChild->GetComponentId());

      RecursiveCheckParentCycles(pcChild, pclList, prlStack);
   }

   pcComponent->GetChildrenList()->ResetList();

   while (!pcComponent->GetChildrenList()->Done()) {
      
      prChild = pcComponent->GetChildrenList()->GetNext();
      prlStack->RemoveRelation(prChild->GetComponentId());

   }

   return TRUE;
}

/*++

   Routine Description:
   
      Routine that checks if there are components with the same ID
      
   Argument:
   
      ComponentList *pclList : A pointer to the component list
      
   Return Value:
   
      The return value is not used
      
--*/

BOOL CheckSameId(IN ComponentList *pclList)
{
   const PTSTR tszFunctionName = TEXT("CheckSameId");

   pclList->ResetList();

   Component *pcComponent;

   while (!pclList->Done()) {
      pcComponent = pclList->GetNext();

      pcComponent->IsThereSameId(pclList);
   }

   return TRUE;
}

/*++

   Routine Description:
   
      Routine that checks if the top level components are the ones
      that are listed in the master INF file
      
   Argument:
   
      HINF hinfHandle        : A handle to the open Inf file
      ComponentList *pclList : A pointer to the component list
      
   Return Value:
   
      The return value is not used
      
--*/

BOOL CheckTopLevelComponent(IN HINF          hinfHandle, 
                            IN ComponentList *pclList)
{
   const PTSTR tszFunctionName = TEXT("CheckTopLevelComponent");

   Component *pcComponent;

   BOOL bSuccess;

   INFCONTEXT infContext;

   TCHAR tszMsg[MaxStringSize];

   pclList->ResetList();

   while (!pclList->Done()) {
      pcComponent = pclList->GetNext();

      if (pcComponent->IsTopLevelComponent()) {
         // Check if this component exists in the [Components] section
         bSuccess = SetupFindFirstLine(hinfHandle, 
                                       tszComponents, 
                                       pcComponent->GetComponentId(),
                                       &infContext);
         if (!bSuccess) {
            _stprintf(tszMsg, 
                      TEXT("Component %s doesn't have a parent, but it is not listed in the [Components] section"), 
                      pcComponent->GetComponentId());
            LogError(tszMsg, SEV2, tszFunctionName);

         }
      }
   }

   return TRUE;
}

/*++

   Routine Description:
   
      Routine that checks if every component has a description
      and tip, and that no two components have the same 
      description if they share a common parent
      
   Argument:
   
      HINF hinfHandle        : A handle to the open Inf file
      ComponentList *pclList : A pointer to the component list
      
   Return Value:
   
      The return value is not used
      
--*/

BOOL CheckDescription(IN HINF          hinfHandle,
                      IN ComponentList *pclList)
{
   const PTSTR tszFunctionName = TEXT("CheckDescription");

   Component *pcComponent;

   BOOL bSuccess;

   TCHAR tszMsg[MaxStringSize];

   INFCONTEXT infContext;

   pclList->ResetList();

   while (!pclList->Done()) {
      pcComponent = pclList->GetNext();

      // We probably have to add two members to the class
      // but let's how this works out

      // Allocate a new structure for this node
      pcComponent->pDescAndTip = new DescAndTip;

      // Get the data from the inf file
      bSuccess = SetupFindFirstLine(hinfHandle, 
                                    pcComponent->GetComponentId(), 
                                    TEXT("OptionDesc"), 
                                    &infContext);
      if (!bSuccess) {
         _stprintf(tszMsg, 
                   TEXT("Unable to find OptionDesc for component %s"), 
                   pcComponent->GetComponentId());
         LogError(tszMsg, SEV2, tszFunctionName);

      }
      else {
         bSuccess = SetupGetStringField(&infContext, 1, 
                                        pcComponent->pDescAndTip->tszDesc,
                                        MaxBufferSize, 
                                        NULL);
         if (!bSuccess) {
            _stprintf(tszMsg, 
                      TEXT("Unable to read OptionDesc field of component %s"), 
                      pcComponent->GetComponentId());
            LogError(tszMsg, SEV2, tszFunctionName);

         }

         // Now see if it is a real description or a string
         if (pcComponent->pDescAndTip->tszDesc[0] == TEXT('%')) {
            bSuccess = SetupFindFirstLine(hinfHandle, 
                                          TEXT("Strings"),
                                          Strip(pcComponent->pDescAndTip->tszDesc),
                                          NULL);
            if (!bSuccess) {
               _stprintf(tszMsg, 
                         TEXT("Unable to find key %s in [Strings] section"),
                         pcComponent->pDescAndTip->tszDesc);
               LogError(tszMsg, SEV2, tszFunctionName);

            }
            else {
               bSuccess = SetupGetStringField(&infContext, 
                                              1, 
                                              pcComponent->pDescAndTip->tszDesc,
                                              MaxBufferSize, 
                                              NULL);
            }
         }
         else {
            // Do nothing
            
         }
      }

      // Now Get the tip stuff, it is basically the same as desc
      bSuccess = SetupFindFirstLine(hinfHandle, 
                                    pcComponent->GetComponentId(), 
                                    TEXT("Tip"), 
                                    &infContext);
      if (!bSuccess) {
         _stprintf(tszMsg, 
                   TEXT("Unable to find Tip key for component %s"), 
                   pcComponent->GetComponentId());
         LogError(tszMsg, SEV2, tszFunctionName);

      }
      else {
         bSuccess = SetupGetStringField(&infContext, 1, 
                                        pcComponent->pDescAndTip->tszTip,
                                        MaxBufferSize, 
                                        NULL);
         if (!bSuccess) {
            _stprintf(tszMsg, 
                      TEXT("Unable to read Tip field for component %s"), 
                      pcComponent->GetComponentId());
            LogError(tszMsg, SEV2, tszFunctionName);

         }

         // Now see if it is a real description or a string
         if (pcComponent->pDescAndTip->tszTip[0] == TEXT('%')) {
            bSuccess = SetupFindFirstLine(hinfHandle, 
                                          TEXT("Strings"),
                                          Strip(pcComponent->pDescAndTip->tszTip),
                                          NULL);
            if (!bSuccess) {
               _stprintf(tszMsg, 
                         TEXT("Unable to find key %s in [Strings] section"),
                         pcComponent->pDescAndTip->tszTip);
               LogError(tszMsg, SEV2, tszFunctionName);

            }
            else {
               bSuccess = SetupGetStringField(&infContext, 
                                              1, 
                                              pcComponent->pDescAndTip->tszTip,
                                              MaxBufferSize, 
                                              NULL);
            }
         }
         else {
            // Do nothing
            
         }
      }
   }

   // Now all the tip and desc thing is filled
   // Loop through the component, see if there are two components with 
   // the same description

   pclList->ResetList();

   while (!pclList->Done()) {
      pcComponent = pclList->GetNext();

      pcComponent->IsThereSameDesc(pclList);
   }

   // Now go through the list and delete the field
   pclList->ResetList();

   while (!pclList->Done()) {
      pcComponent = pclList->GetNext();
      delete (pcComponent->pDescAndTip);
   }

   return TRUE;

}

/*++

   Routine Description:
   
      Routine that checks if every component has the correct mode value
      Toplevel component should not have Modes= line, and the modes value 
      should only be 0 through 3
      
   Argument:
   
      HINF hinfHandle        : A handle to the open Inf file
      ComponentList *pclList : A pointer to the component list
      
   Return Value:
   
      The return value is not used
      
--*/

BOOL CheckModes(IN HINF          hinfHandle,
                IN ComponentList *pclList)
{
   // Go through each component, two things to check

   // a component with children should not have a mode line

   // the value of the fields should be between 0 and 3
   //SETUPMODE_MINIMAL = 0;
   //SETUPMODE_TYPICAL = 1;
   //SETUPMODE_LAPTOP  = 2;
   //SETUPMODE_CUSTOM  = 3;

   TCHAR tszMsg[MaxStringSize];
   INFCONTEXT infContext;
   BOOL bSuccess;

   UINT uiNumFields;

   const PTSTR tszFunctionName = TEXT("CheckModes");

   INT nMode;

   Component *pcComponent;

   pclList->ResetList();

   while (!pclList->Done()) {
      pcComponent = pclList->GetNext();

      bSuccess = SetupFindFirstLine(hinfHandle, 
                                    pcComponent->GetComponentId(),
                                    TEXT("Modes"), 
                                    &infContext);
      if (bSuccess) {
         // Found the mode line
         // first check if this a component with children
         if (pcComponent->IsParentOfOthers()) {
            _stprintf(tszMsg, 
                      TEXT("%s has subcomponent, and has Modes = line"),
                      pcComponent->GetComponentId());
            LogError(tszMsg, SEV2, tszFunctionName);

         }
         else {
            // Check the validity of the fields
            uiNumFields = SetupGetFieldCount(&infContext);
            if (uiNumFields < 1 || uiNumFields > 4) {
               _stprintf(tszMsg, 
                         TEXT("Invalid number of fields in section [%s]"),
                         pcComponent->GetComponentId());
               LogError(tszMsg, SEV2, tszFunctionName);

            }
            for (UINT i = 1; i <= uiNumFields; i++) {
               bSuccess = SetupGetIntField(&infContext, i, &nMode);
               if (!bSuccess) {
                  _stprintf(tszMsg, 
                            TEXT("Failed to get Mode value in section [%s]"),
                            pcComponent->GetComponentId());
                  LogError(tszMsg, SEV2, tszFunctionName);

               }
               if (nMode < 0 || nMode > 3) {
                  _stprintf(tszMsg, 
                            TEXT("Invalid mode value %d in section [%s]"), 
                            nMode, 
                            pcComponent->GetComponentId());
                  LogError(tszMsg, SEV2, tszFunctionName);

               }
            }
         }
      }
   }

   return TRUE;
}

/*++

   Routine Description:
   
      Routine that checks if the every INF file has a line
      LayoutFile = layout.inf  No file should ever use 
      [SourceDisksFiles] or [SourceDisksNames] section
      
   Argument:
   
      HINF hinfHandle        : A handle to the open Inf file
      ComponentList *pclList : A pointer to the component list
      
   Return Value:
   
      The return value is not used
      
--*/


BOOL CheckLayoutFile(IN TCHAR tszSubINFName[MaxStringSize][MaxStringSize],
                     IN UINT  uiNumComponents,
                     IN TCHAR *tszDir)
{
   TCHAR tszMsg[MaxStringSize];

   BOOL bSuccess;

   HINF hinfHandle;

   INFCONTEXT infContext;

   UINT uiError;

   TCHAR tszLine[MaxStringSize];

   const PTSTR tszFunctionName = TEXT("CheckLayoutFile");

   // Now check the LayoutFile in each INF file

   for (UINT m = 0; m < uiNumComponents; m++) {
      if (tszSubINFName[m][0]) {
         _stprintf(tszMsg, TEXT("%s%s"), tszDir, tszSubINFName[m]); 
         hinfHandle = SetupOpenInfFile(tszMsg, 
                                       NULL, 
                                       INF_STYLE_WIN4, 
                                       &uiError);

         // We assume the hinf handle is valid

         bSuccess = SetupFindFirstLine(hinfHandle, 
                                       TEXT("Version"), 
                                       tszLayoutFile, 
                                       &infContext);

         if (!bSuccess) {

            _stprintf(tszMsg, 
                      TEXT("LayoutFile not found in file %s"), 
                      tszSubINFName[m]);

            LogError(tszMsg, SEV2, tszFunctionName);

            SetupCloseInfFile(hinfHandle);

            continue;

         }

         // Check if the value of the key is Layout.inf

         TCHAR tszLayoutFileName[MaxStringSize];

         bSuccess = SetupGetStringField(&infContext, 
                                        1, 
                                        tszLayoutFileName, 
                                        MaxBufferSize, 
                                        NULL);

         if (!bSuccess) {
            _stprintf(tszMsg, 
                      TEXT("Error reading the value of the %s in %s"), 
                      tszLayoutFile, 
                      tszSubINFName[m]);
         }
         if ( _tcsicmp(tszLayoutFileName, TEXT("Layout.inf")) != 0 ) {
            _stprintf(tszMsg, 
                      TEXT("The value of LayoutFile= %s in %s is invalid"),
                      tszLayoutFileName, 
                      tszSubINFName[m]);
         }

         if (!bSuccess || 
             _tcsicmp(tszLayoutFileName, TEXT("Layout.inf")) != 0 ) {

            LogError(tszMsg, SEV2, tszFunctionName);
         }

         // Now check that we should not have SourceDisksNames
         // or SourceDisksFiles sections
         bSuccess = SetupFindFirstLine(hinfHandle, 
                                       TEXT("SourceDisksNames"), 
                                       NULL, 
                                       &infContext);

         if (bSuccess) {
            _stprintf(tszMsg, 
                      TEXT("[SourceDisksNames] section presents in %s"), 
                      tszSubINFName[m]);

            LogError(tszMsg, SEV2, tszFunctionName);

         }

         bSuccess = SetupFindFirstLine(hinfHandle, 
                                       TEXT("SourceDisksFiles"), 
                                       NULL, 
                                       &infContext);

         if (bSuccess) {
            _stprintf(tszMsg, 
                      TEXT("[SourceDisksFiles] section presents in %s"), 
                      tszSubINFName[m]);
            LogError(tszMsg, SEV2, tszFunctionName);
         }

         SetupCloseInfFile(hinfHandle);

      }
   }

   return TRUE;

}

/*++

   Routine Description:
   
      Routine that logs an error depending on the ways some
      global variables are set
      
   Argument:
   
      TCHAR *tszMsg:          Error Message to log
      DWORD dwErrorLevel:     How serious the error is      
      TCHAR *tszFunctionName: the function name this error is detected
      
   Return Value:
   
      The return value is not used
      
--*/

VOID LogError(IN TCHAR *tszMsg, 
              IN DWORD dwErrorLevel,
              IN TCHAR *tszFunctionName)
{
   double fn = 1.00;

   if (g_bUseLog) {
      Log(fn, dwErrorLevel, tszMsg);
   }
   if (g_bUseMsgBox) {
      if (dwErrorLevel == INFO) {
         // We will not put up anything            
         
      }

      else {
         MessageBox(NULL, tszMsg, tszFunctionName, MB_ICONERROR | MB_OK);
      }
   }
   if (g_bUseConsole) {

      TCHAR tszContent[MaxStringSize];

      _tcscpy(tszContent, tszMsg);
      _tcscat(tszContent, TEXT("\n"));
      _ftprintf(stdout, tszContent);

   }

}

/*++

   Routine Description:
   
      Routine that gets rid of the first and last char of a string
      
   Argument:
   
      TCHAR *tszString:  Error Message to log
   
   Return Value:
   
      The return value is not used
      
--*/

TCHAR *Strip(TCHAR *tszString)
{
   TCHAR tszTemp[MaxStringSize];

   _tcscpy(tszTemp, (tszString+1));

   tszTemp[_tcslen(tszTemp)-1] = 0;

   _tcscpy(tszString, tszTemp);

   return tszString;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ocmanage\testoc\checkinf\checkinf.h ===
#ifndef _CHECKINF_H_
#define _CHECKINF_H_

#include "Component.h"
#include <setupapi.h>

// Function prototype

BOOL CheckCopyFiles(IN HINF hinfHandle, 
                    IN ComponentList *pclList);

BOOL CheckExcludeRelationship(IN ComponentList *pclList);

BOOL CheckIconIndex(IN HINF hinfHandle, 
                    IN ComponentList *pclList);

BOOL CheckINF(IN TCHAR *tszDir, 
              IN TCHAR *tszFilename);

BOOL CheckNeedRelationship(IN ComponentList *pclList);

BOOL CheckParentRelationship(IN ComponentList *pclList);

BOOL CheckSuspicious(IN HINF hinfHandle, 
                     IN ComponentList *pclList);

BOOL FillList(IN OUT HINF hinfHandle, 
              IN OUT ComponentList *pclList, 
              IN     TCHAR *tszDir);

BOOL CheckNeedCycles(IN Component *pcComponent, 
                     IN ComponentList *pclList);

BOOL CheckParentCycles(IN Component *pcComponent, 
                       IN ComponentList *pclList);

BOOL CheckSameId(IN ComponentList *pclList);

BOOL CheckDescription(IN HINF hinfHandle,
                      IN ComponentList *pclList);

TCHAR *Strip(IN OUT TCHAR *tszString);

BOOL CheckModes(IN HINF hinfHandle,
                IN ComponentList *pclList);

BOOL CheckLayoutFile(IN TCHAR tszSubINFName[MaxStringSize][MaxStringSize],
                     IN UINT uiNumComponents,
                     IN TCHAR *tszDir);

BOOL RecursiveCheckNeedCycles(IN Component *pcComponent,
                              IN ComponentList *pclList,
                              IN RelationList *prlStack);


BOOL RecursiveCheckParentCycles(IN Component *pcComponent,
                                IN ComponentList *pclList,
                                IN RelationList *prlStack);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ocmanage\testoc\checkinf\component.h ===
#ifndef _COMPONENT_H_
#define _COMPONENT_H_

#include <iostream.h>
#include <windows.h>
#include <setupapi.h>
#include <stdio.h>
#include <tchar.h>
#include "logutils.h"
#include "hcttools.h"

const INT MaxStringSize = 256;
const INT MaxBufferSize = 255;      

// Global variables
static BOOL g_bUseLog;
static BOOL g_bUseMsgBox;
static BOOL g_bUseConsole;
static BOOL g_bMasterInf;

// Global function definitions

VOID LogError(IN TCHAR *tszMsg,
              IN DWORD dwErrorLevel,
              IN TCHAR *tszFunctionName);

// Some structures to hold temporary data

typedef struct _DescAndTip{
   TCHAR tszDesc[MaxStringSize];
   TCHAR tszTip[MaxStringSize];
}DescAndTip;
                        
class ComponentList;
class RelationList;

class Component{

private:
   // ComponentId is the real ID
   TCHAR tszComponentId[MaxStringSize];
   
   // ParentId is the ID of the its parent
   // It is the same as its own ID if it is a
   // top level component
   TCHAR tszParentId[MaxStringSize];

   RelationList *prlNeedList;
   RelationList *prlExcludeList;
   RelationList *prlChildrenList;

   Component *Next;

public:

   // Constructors and destructors
   Component();
   ~Component();
   Component(TCHAR *tszId);
   
   // Copy constructor
   Component(const Component& source);

   // Assignment operator
   const Component& operator=(const Component& source);

   // Get this component's ID
   TCHAR *GetComponentId(){
      return tszComponentId;
   }

   // Get this component's parent's ID
   TCHAR *GetParentId(){
      return tszParentId;
   }

   // Get a pointer to the parent component of this component
   // It returns NULL if this is a top-level component
   Component *GetParent(ComponentList *pclHead);
   
   RelationList *GetNeedList(){
      return prlNeedList;
   }

   RelationList *GetExcludeList(){
      return prlExcludeList;
   }

   RelationList *GetChildrenList(){
      return prlChildrenList;
   }

   // TRUE if this component is the parent of the parameter
   BOOL IsParent(Component *pcChild);

   // TRUE if this component is the child of the parameter
   BOOL IsChild(Component *pcParent);

   // TRUE if this component is needed by the parameter
   BOOL IsNeededBy(Component *pcComponent);

   // TRUE if this component is excluded by the parameter
   BOOL IsExcludeBy(Component *pcComponent);
   
   // The following function is to be called when only
   // the component ID is known
   BOOL BuildChildrenList(ComponentList *pclList);

   BOOL GetParentIdFromINF(HINF hinfHandle);

   BOOL IsTopLevelComponent();

   BOOL IsBottomComponent();

   BOOL IsNeededByOthers(ComponentList *pclList);

   BOOL IsExcludedByOthers(ComponentList *pclList);

   BOOL IsParentOfOthers();

   BOOL NeedAndExcludeAtSameTime(ComponentList *pclList);

   BOOL NeedOthers();
   BOOL ExcludeOthers();

   BOOL IsThereSameId(ComponentList *pclList);

   UINT GetDiskSpaceRequirement(HINF hinfHandle);

   // Doesn't matter if this is a public member
   // It will only be used once
   DescAndTip *pDescAndTip;

   BOOL IsThereSameDesc(ComponentList *pclList);

   BOOL HasSameParentWith(Component *pcComponent);

   friend class ComponentList;
};

class ComponentList{

private:

   Component *pcHead;   

   Component *pcCurrent;

public:

   // Constructor and destructor
   ComponentList();
   ~ComponentList();

   void ResetList();

   Component *GetNext();

   BOOL Done();

   Component* AddComponent(TCHAR *tszId);

   BOOL RemoveComponent(TCHAR *tszId);

   Component *LookupComponent(TCHAR *tszId);

   friend class Component;

};

class Relation{

   TCHAR tszComponentId[MaxStringSize];
   Relation *Next;

public:

   TCHAR *GetComponentId(){ 
      return tszComponentId;
   }
   friend class Component;
   friend class ComponentList;
   friend class RelationList;
};

class RelationList{

   Relation *prHead;
   Relation *prCurrent;

public:

   RelationList();
   ~RelationList();

   void ResetList();
   BOOL Done();
   Relation *GetNext();

   Relation* AddRelation(TCHAR *tszId);
   BOOL RemoveRelation(TCHAR *tszId);

   friend class Component;
   friend class ComponentList;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ocmanage\testoc\checkinf\component.cpp ===
#include "component.h"
#include <wchar.h>
#include <tchar.h>
#include <string.h>
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>

//////////////////////////////////////////////////////////////////
// Implementation of the Component Class
//////////////////////////////////////////////////////////////////     

// Constructor     
Component::Component(){
   
   tszComponentId[0] = 0;
   tszParentId[0] = 0;
   prlNeedList = new RelationList;
   prlExcludeList = new RelationList;
   prlChildrenList = new RelationList;

}

// Another constructor
Component::Component(TCHAR *tszId){
   _tcscpy(tszComponentId, tszId);
   tszParentId[0] = 0;
   prlNeedList = new RelationList;
   prlExcludeList = new RelationList;
   prlChildrenList = new RelationList;
}

// Destructor 
Component::~Component(){

   if (prlNeedList) {
      delete prlNeedList;
   }

   if (prlExcludeList) {
      delete prlExcludeList;
   }

   if (prlChildrenList) {
      delete prlChildrenList;
   }
}

// Copy constructor
Component::Component(const Component& source){

   _tcscpy(tszComponentId, source.tszComponentId);
   _tcscpy(tszParentId, source.tszParentId);

   prlNeedList = source.prlNeedList;
   prlExcludeList = source.prlExcludeList;
   prlChildrenList = source.prlChildrenList;

}

// Assignment operator
const Component& Component::operator=(const Component& source){

   _tcscpy(tszComponentId, source.tszComponentId);
   _tcscpy(tszComponentId, source.tszParentId);

   if (prlNeedList) {
      delete prlNeedList;
   }

   if (prlExcludeList) {
      delete prlExcludeList;
   }

   if (prlChildrenList) {
      delete prlChildrenList;
   }

   prlNeedList = source.prlNeedList;
   prlExcludeList = source.prlExcludeList;
   prlChildrenList = source.prlChildrenList;

   return *this;

}

// Find the parent of this component
// by searching a component list
Component* Component::GetParent(ComponentList *pclHead){

   Component *pcTemp = pclHead->pcCurrent;

   pclHead->ResetList();

   while (!pclHead->Done()) {

	  if (pclHead->GetNext()->IsParent(this)){
		  
		  pclHead->pcCurrent = pcTemp;
		  return (pclHead->GetNext());
	  }
   }

   pclHead->pcCurrent = pcTemp;

   return NULL;
}

// If this component is the parent of the parameter
BOOL Component::IsParent(Component* pcChild){

   if (_tcscmp(pcChild->tszParentId, this->tszComponentId) == 0) {
      if (_tcscmp(pcChild->tszComponentId, pcChild->tszParentId) == 0) {
         
         // the parameter is a top-level component
         
         return FALSE;
      }
      return TRUE;
   }

   return FALSE;
}


// If this component is the child of the parameter
BOOL Component::IsChild(Component* pcParent){

   if (_tcscmp(this->tszParentId, pcParent->tszComponentId) == 0) {
      if (_tcscmp(this->tszParentId, this->tszComponentId) == 0 ) {

         // This is a top-level component

         return FALSE;
      }
      return TRUE;
   }

   return FALSE;
}

// Check if this component is needed by the parameter
BOOL Component::IsNeededBy(Component *pcComponent){

   pcComponent->prlNeedList->ResetList();

   while (!pcComponent->prlNeedList->Done()) {

      if (_tcscmp(pcComponent->prlNeedList->GetNext()->tszComponentId, 
                  this->tszComponentId) == 0){
         return TRUE;
      }
   }

   return FALSE;
}

// Check if this component is excluded by the parameter
BOOL Component::IsExcludeBy(Component *pcComponent){

   pcComponent->prlExcludeList->ResetList();

   while (!pcComponent->prlExcludeList->Done()) {

      if (_tcscmp(pcComponent->prlNeedList->GetNext()->tszComponentId, 
                  this->tszComponentId) == 0) {
         return TRUE;
      }
   }

   return FALSE;
}

// Get this component's parent id from INF file
BOOL Component::GetParentIdFromINF(HINF hinfHandle){

   INFCONTEXT infContext;

   BOOL bSuccess;

   bSuccess = SetupFindFirstLine(hinfHandle, 
                                 tszComponentId, 
                                 TEXT("Parent"), 
                                 &infContext);

   if (bSuccess) {
      // Find the line
      bSuccess = SetupGetStringField(&infContext, 
                                     1, 
                                     tszParentId, 
                                     MaxBufferSize, 
                                     NULL);
      if (bSuccess) {
         return TRUE;
      }
      else{
         MessageBox(NULL, 
                    TEXT("Unexpected error happened"), 
                    TEXT("GetParentIdFromINF"), 
                    MB_ICONERROR | MB_OK);

         return FALSE;
      }
   }
   else{
      // This is a top-level component
      _tcscpy(tszParentId, tszComponentId);
      return TRUE;
   }
}

// Check if this component is a toplevel compoent
// Toplevel component means no parent
BOOL Component::IsTopLevelComponent(){
   if (_tcscmp(tszComponentId, tszParentId) == 0) {
      return TRUE;
   }
   return FALSE;
}

// Check if this component is a bottomlevel component
// bottom level component doesn't have any child
BOOL Component::IsBottomComponent(){
   if (prlChildrenList == NULL ||
       prlChildrenList->prHead == NULL) {
      return TRUE;
   }

   return FALSE;
}

// Check if this component is needed by others
BOOL Component::IsNeededByOthers(ComponentList *pclList){
   Component *pcTemp = pclList->pcCurrent;

   pclList->ResetList();
   while (!pclList->Done()) {
      if (IsNeededBy(pclList->GetNext())){
		  pclList->pcCurrent = pcTemp;	
		  return TRUE;
      }
   }

   pclList->pcCurrent = pcTemp;

   return FALSE;
}

// Check if this component is excluded by others
BOOL Component::IsExcludedByOthers(ComponentList *pclList){

   Component *pcTemp = pclList->pcCurrent;
   
   pclList->ResetList();
   while (!pclList->Done()) {
      if (IsExcludeBy(pclList->GetNext())){
          pclList->pcCurrent = pcTemp;
		  return TRUE;
      }
   }

   pclList->pcCurrent = pcTemp;

   return FALSE;
}

// Check if this component is parent of other components
BOOL Component::IsParentOfOthers(){
   if (prlChildrenList != NULL &&
       prlChildrenList->prHead != NULL) {
      return TRUE;
   }

   return FALSE;
}

// Build the children list for this component
BOOL Component::BuildChildrenList(ComponentList *pclList){
   // We can't use the enumerate facility of pclList here
   
   Component *pcComponent = pclList->pcHead;

   while (pcComponent) {
      if (IsParent(pcComponent)) {
         if (!prlChildrenList) {
            prlChildrenList = new RelationList;
         }
         prlChildrenList->AddRelation(pcComponent->tszComponentId);
      }
      pcComponent = pcComponent->Next;
   }

   return TRUE;

}

// Check if this component has a need and exclude relation with other
// component at the same time
BOOL Component::NeedAndExcludeAtSameTime(ComponentList *pclList){
	
	TCHAR tszMsg[MaxStringSize];

	Component *pcComponent;
                                 
   const PTSTR tszFunctionName = TEXT("Component::NeedAndExcludeAtSameTime");

	// Go through the list of component it excludes
	// check if any of them needs this one

	prlExcludeList->ResetList();

	while (!prlExcludeList->Done()){
		
		pcComponent = pclList->LookupComponent(prlExcludeList->GetNext()->GetComponentId());

		// Check if this needs pcComponent
		
		if (pcComponent->IsNeededBy(this)){
			_stprintf(tszMsg, 
                   TEXT("%s is needed and excluded by the same component"), 
                   this->tszComponentId);
         LogError(tszMsg, SEV2, tszFunctionName);

		   return TRUE;
      }

		// Check if pcComponent needs this

		if (this->IsNeededBy(pcComponent)){
			_stprintf(tszMsg, 
                   TEXT("%s is needed and excluded by the same component"), 
                   this->tszComponentId);
         LogError(tszMsg, SEV2, tszFunctionName);

		   return TRUE;
      }
	}

	return FALSE;
}

// Check if this component needs other components
BOOL Component::NeedOthers(){
   
   if (prlNeedList != NULL && prlNeedList->prHead != NULL) {
      
      return TRUE;
   }
   return FALSE;
}

// Check if this component excludes other components
BOOL Component::ExcludeOthers(){
   
   if (prlExcludeList != NULL && prlExcludeList->prHead != NULL) {
      
      return TRUE;
   
   }
   
   return FALSE;   
}

// Check if there is another component with the same
// id as this component
BOOL Component::IsThereSameId(ComponentList *pclList){

   Component *pcCur;
   TCHAR tszMsg[MaxStringSize];

   const PTSTR tszFunctionName = TEXT("Component::IsThereSameId");

   pcCur = pclList->pcHead;

   while (pcCur) {
      if (pcCur != this) {
         if (_tcscmp(pcCur->tszComponentId, this->tszComponentId) == 0) {
            _stprintf(tszMsg, 
                      TEXT("There are two component with the same ID %s"), 
                      this->tszComponentId);
            LogError(tszMsg, SEV2, tszFunctionName);

         }
      }
      pcCur = pcCur->Next;
   }

	return TRUE;
}

// Not implemented yet
UINT Component::GetDiskSpaceRequirement(HINF hinfHandle){

   // Not implemented yet.

   return 0;
}

// Check if this another component with the same description
BOOL Component::IsThereSameDesc(ComponentList *pclList){

   const PTSTR tszFunctionName = TEXT("Component::IsThereSameDesc");

   TCHAR tszMsg[MaxStringSize];

   Component *pcCur = pclList->pcHead;

   while (pcCur) {
      if (pcCur != this) {
         if (_tcscmp(pcCur->pDescAndTip->tszDesc, 
                     this->pDescAndTip->tszDesc) == 0) {
            if ((this->IsTopLevelComponent() && 
                 pcCur->IsTopLevelComponent()) ||
                this->HasSameParentWith(pcCur)) {

               // ahha, found one
               _stprintf(tszMsg, 
                         TEXT("Two components with the same description %s"),
                         pDescAndTip->tszDesc);
               LogError(tszMsg, SEV2, tszFunctionName);

            }
         }
      }
      pcCur = pcCur->Next;
   }

   return TRUE;
}

// Check if this component has the same parent as the parameter
BOOL Component::HasSameParentWith(Component *pcComponent){
   if (_tcscmp(tszParentId, pcComponent->tszParentId) == 0) {
      return TRUE;
   }
   else{
      return FALSE;
   }
}

/////////////////////////////////////////////////////////////////////
// Implementation of the ComponentList class
/////////////////////////////////////////////////////////////////////

// Constructor
ComponentList::ComponentList(){

   pcHead = NULL;

   pcCurrent = NULL;
}

// destructor
ComponentList::~ComponentList(){

   // Go through the list and delete each component

   Component *pcComponent;

   if (pcHead == NULL) {
      // Empty list
      return;
   }

   while(pcHead != NULL){
  
      pcComponent = pcHead->Next;

      delete pcHead;

      pcHead = pcComponent;

   }   
}

// List iteration facility
// reset the iterator
void ComponentList::ResetList(){

    pcCurrent = pcHead;
}

// Check if the iterator has reached the end
BOOL ComponentList::Done(){

   return (pcCurrent == NULL);
}

// Get the next node in the list
Component* ComponentList::GetNext(){

   Component *pcReturn;
   pcReturn = pcCurrent;
 
   if (pcCurrent != NULL) {
      pcCurrent = pcReturn->Next;
      return pcReturn;
   }

   else{
      MessageBox(NULL, 
                 TEXT("Something is seriously wrong"), 
                 TEXT("ComponentList.GetNext()"), 
                 MB_ICONERROR | MB_OK);

      return NULL;
   }
}
 
// Add a component into the list
Component* ComponentList::AddComponent(TCHAR *tszId){

   if (tszId == NULL) {
      return NULL;
   }

   Component *pcNewComponent = new Component(tszId);

   if (!pcHead) {
      pcHead = pcNewComponent;
      pcNewComponent->Next = NULL;
      return pcNewComponent;
   }

   pcNewComponent->Next = pcHead;
   pcHead = pcNewComponent;
   return pcNewComponent;
}

// Remove a component from the list according to the id given
BOOL ComponentList::RemoveComponent(TCHAR *tszId){
   if (tszId == NULL) {
      return NULL;
   }

   // Find the component in the list
   Component *pcPrev = pcHead;
   Component *pcCur = pcHead;

   while (pcCur) {
      if (_tcscmp(pcCur->tszComponentId, tszId) == 0) {
         // Found the node to delete
         pcPrev->Next = pcCur->Next;
         delete pcCur;
         return TRUE;
      }
      pcPrev = pcCur;
      pcCur = pcCur->Next;
   }
   return FALSE;
}

// Find a component from the list
Component* ComponentList::LookupComponent(TCHAR *tszId){
   if (tszId == NULL) {
      return NULL;
   }

   Component *pcCur = pcHead;

   while (pcCur) {
      if (_tcscmp(pcCur->tszComponentId, tszId) == 0) {
         return pcCur;
      }
      pcCur = pcCur->Next;
   }

   return NULL;
}

//////////////////////////////////////////////////////////////////////
// Implementation of RelationList
//////////////////////////////////////////////////////////////////////

// Constructor
RelationList::RelationList(){

   prHead = NULL;
   prCurrent = NULL;
}

// destructor
RelationList::~RelationList(){

   // deallocate all the memory

   Relation *prNext;

   if (prHead == NULL) {
      // The list is empty
      return;

   }

   while (prNext = prHead->Next) {
      delete prHead;
      prHead = prNext;
   }
}

// List iteration facility
// reset the iterator
void RelationList::ResetList(){
   prCurrent = prHead;
}

// Check if the iterator has reached the end of the list
BOOL RelationList::Done(){
   if (prCurrent == NULL) {
      return TRUE;
   }
   else{
      return FALSE;
   }
}

// Get the next node in the list
Relation* RelationList::GetNext(){
   Relation *prReturn = prCurrent;

   if (prCurrent != NULL) {
      prCurrent = prCurrent->Next;
      return prReturn;
   }
   else{
      MessageBox(NULL, 
                 TEXT("Something is seriously wrong"), 
                 TEXT("RelationList::GetNext()"), 
                 MB_ICONERROR | MB_OK);

      return NULL;
   }
   
}

// Add a node to the list
Relation* RelationList::AddRelation(TCHAR *tszId){
   Relation *newRelation = new Relation;

   _tcscpy(newRelation->tszComponentId, tszId);

   if (!prHead) {
      prHead = newRelation;
      newRelation->Next = NULL;
      return newRelation;
   }

   newRelation->Next = prHead;

   prHead = newRelation;

   return newRelation;
}

// Remove a node from the list
BOOL RelationList::RemoveRelation(TCHAR *tszId){
   // First find the node from the list
   Relation *prPrev = prHead;   
   prCurrent = prHead;

   while (prCurrent) {
      if (_tcscmp(prCurrent->tszComponentId, tszId) == 0) {
         prPrev->Next = prCurrent->Next;
         delete prCurrent;
         return TRUE;
      }
      prPrev = prCurrent;
      prCurrent = prCurrent->Next;
   }
   return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ocmanage\testoc\hctlib\logutils.h ===
#ifndef _LOGUTILS_H_
#define _LOGUTILS_H_

#include <windows.h>
#include <ntlog.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>

//
// Definitions
//
#define LOG_STRING_LEN    256
#define LOG_SPACE_LEN     6
#define NTLOG_LINE_LEN    42
#define NO_NTLOG_LINE_LEN 65
#define MAX_FUNC_NUM      100
#define INFO TLS_INFO
#define PASS TLS_PASS
#define SEV1 TLS_SEV1
#define SEV2 TLS_SEV2
#define SEV3 TLS_SEV3

#define GREY  0x7	
#define GREEN 0xa
#define RED   0xc

//
// Globals
//
static HANDLE gPnPTestLog;           // Handle to NTLog - "pnptest.log"
static FILE   *gPnPTestLogFile;      // Handle if ntlog.dll couldn't load
static BOOL   gNtLogLoaded;          // Tells whether ntlog.dll was loaded
static USHORT g_LogLineLen;
HANDLE g_hConsole;

//
// Function definitions
//
void LoadDLLs(IN PTCHAR DLLName);

HANDLE InitLog(IN PTCHAR tszLogName,
               IN PTCHAR tszTitle,
               IN BOOL   bConsole);

void ExitLog();

void WriteLog(IN DWORD  dwLogLevel,
              IN PTCHAR tszBuffer);

void Log(IN double dFunctionNumber,
         IN DWORD  dwLogLevel,
         IN PTCHAR tszLogString,
         IN  ...);

VOID LogBlankLine();

VOID CreateConsoleWindow(IN BOOL   bConsole,
                         IN PTCHAR tszTitle);

VOID AddLogParticipant(IN HANDLE hLog);

VOID RemoveLogParticipant(IN HANDLE hLog);

//
// NtLog definitions
//
typedef HANDLE (*Dll_tlCreateLog) (LPCWSTR, DWORD);
typedef BOOL   (*Dll_tlAddParticipant) (HANDLE, DWORD, int);
typedef BOOL   (*Dll_tlStartVariation) (HANDLE);
typedef BOOL   (*Dll_tlLog) (HANDLE, DWORD, PTCHAR, int, PTCHAR, ...);
typedef DWORD  (*Dll_tlEndVariation) (HANDLE);
typedef BOOL   (*Dll_tlRemoveParticipant) (HANDLE);
typedef BOOL   (*Dll_tlDestroyLog) (HANDLE);
typedef VOID   (*Dll_tlReportStats) (HANDLE);

Dll_tlCreateLog         _tlCreateLog;
Dll_tlAddParticipant    _tlAddParticipant;
Dll_tlDestroyLog        _tlDestroyLog;
Dll_tlEndVariation      _tlEndVariation;
Dll_tlLog               _tlLog;
Dll_tlRemoveParticipant _tlRemoveParticipant;
Dll_tlStartVariation    _tlStartVariation;
Dll_tlReportStats       _tlReportStats;

#define LOG_OPTIONS (TLS_REFRESH | TLS_SEV2 | TLS_WARN | TLS_PASS | \
                     TLS_MONITOR | TLS_VARIATION | \
                     TLS_SYSTEM  | TLS_INFO )


#endif // _LOGUTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ocmanage\testoc\hctlib\hcttools.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    hcttools.c

Abstract:

    This module contains helpful functions and wrappers for debugging and
    tools commonly used throughout hct programs.

Environment:

    User mode

Revision History:

    05-Sep-1997 : Jason Allor (jasonall)

--*/
#include "hcttools.h"

#ifdef DEBUG

static PBLOCKINFO g_pbiHead;

static USHORT g_usMalloc;
static USHORT g_usFree;

#endif

/*++

Routine Description: InitializeMemoryManager

    Initializes globals used by this module

Arguments:

    none

Return Value:

    VOID

--*/
VOID InitializeMemoryManager()
{
#ifdef DEBUG

   g_pbiHead  = NULL;
   g_usMalloc = 0;
   g_usFree   = 0;

#else

   return;
   
#endif

} // InitializeMemoryManager //



#ifdef DEBUG

/*++

Routine Description: GetBlockInfo

    Searches the memory log to find the block that pb points into and
    returns a pointer to the corresponding blockinfo structure of the
    memory log. Note: pb must point into an allocated block or you
    will get an assertion failure. The function either asserts or
    succeeds -- it never returns an error.

Arguments:

    pb: block to get info about

Return Value:

    BLOCKINFO: returns the information

--*/
static PBLOCKINFO GetBlockInfo(IN PBYTE pb)
{
   PBLOCKINFO pbi;

   for (pbi = g_pbiHead; pbi != NULL; pbi = pbi->pbiNext)
   {
      PBYTE pbStart = pbi->pb;
      PBYTE pbEnd   = pbi->pb + pbi->size - 1;

      if (PtrGrtrEq(pb, pbStart) && PtrLessEq(pb, pbEnd))
      {
         break;
      }
   }

   //
   // Couldn't find pointer? It is garbage, pointing to a block that was
   // freed, or pointing to a block that moved when it was resized?
   //
   __ASSERT(pbi != NULL);

   return (pbi);

} // GetBlockInfo //




/*++

Routine Description: CreateBlockInfo

    Creates a log entry for the memory block defined by pbNew:sizeNew.

Arguments:

    pbNew:   new block
    sizeNew: the size of the new block
    cszFile: the file name the code is located in \ these tell what code
    iLine:   the line number of the assertion     / called the malloc

Return Value:

    BOOL: TRUE if it successfully creates the log information,
          FALSE otherwise

--*/
BOOL CreateBlockInfo(OUT PBYTE  pbNew,
                     IN  size_t sizeNew,
                     IN  PCHAR  cszFile,
                     IN  UINT   iLine)
{
   PBLOCKINFO pbi;

   __ASSERT(pbNew != NULL && sizeNew != 0);

   pbi = (PBLOCKINFO)malloc(sizeof(BLOCKINFO));
   if (pbi != NULL)
   {
      pbi->pb = pbNew;
      pbi->size = sizeNew;
      pbi->pbiNext = g_pbiHead;
      pbi->iLine = iLine;
      strcpy(pbi->cszFile, cszFile);
      g_pbiHead = pbi;
   }

   return (pbi != NULL);

} // CreateBlockInfo //




/*++

Routine Description: FreeBlockInfo

    Destroys the log entry for the memory block that pbToFree
    points to. pbToFree must point to the start of an allocated
    block or you will get an assertion failure

Arguments:

    pbToFree: the block to free

Return Value:

    void

--*/
void FreeBlockInfo(IN PBYTE pbToFree)
{
   PBLOCKINFO pbi, pbiPrev;

   pbiPrev = NULL;
   for (pbi = g_pbiHead; pbi != NULL; pbi = pbi->pbiNext)
   {
      if (PtrEqual(pbi->pb, pbToFree))
      {
         if (pbiPrev == NULL)
         {
            g_pbiHead = pbi->pbiNext;
         }
         else
         {
            pbiPrev->pbiNext = pbi->pbiNext;
         }
         break;
      }
      pbiPrev = pbi;
   }

   //
   // If pbi is NULL, the pbToFree is invalid
   //
   __ASSERT(pbi != NULL);

   //
   // Destroy the contents of *pbi before freeing them
   //
   memset(pbi, GARBAGE, sizeof(BLOCKINFO));

   free(pbi);

} // FreeBlockInfo //




/*++

Routine Description: UpdateBlockInfo

    UpdateBlockInfo looks up the log information for the memory
    block that pbOld points to. The function then updates the log
    information to reflect the fact that the block new lives at pbNew
    and is "sizeNew" bytes long. pbOld must point to the start of an
    allocated block or you will get an assertion failure

Arguments:

    pbOld:   old location
    pbNew:   new location
    sizeNew: the new size

Return Value:

    void

--*/
void UpdateBlockInfo(IN PBYTE  pbOld,
                     IN PBYTE  pbNew,
                     IN size_t sizeNew)
{
   PBLOCKINFO pbi;

   __ASSERT(pbNew != NULL && sizeNew);

   pbi = GetBlockInfo(pbOld);
   __ASSERT(pbOld == pbi->pb);

   pbi->pb   = pbNew;
   pbi->size = sizeNew;

} // UpdateBlockInfo //




/*++

Routine Description: SizeOfBlock

    Returns the size of the block that pb points to. pb must point to
    the start of an allocated block or you will get an assertion failure

Arguments:

    pb: the block to find the size of

Return Value:

    size_t: returns the size

--*/
size_t SizeOfBlock(IN PBYTE pb)
{
   PBLOCKINFO pbi;

   pbi = GetBlockInfo(pb);
   __ASSERT(pb == pbi->pb);

   return (pbi->size);
   return 1;
   
} // SizeOfBlock //




/*++

Routine Description: ClearMemoryRefs

    ClearMemoryRefs marks all blocks in the memory log as
    being unreferenced

Arguments:

    void

Return Value:

    void

--*/
void ClearMemoryRefs()
{
   PBLOCKINFO pbi;

   for (pbi = g_pbiHead; pbi != NULL; pbi = pbi->pbiNext)
   {
      pbi->boolReferenced = FALSE;
   }

} // ClearMemoryRefs //




/*++

Routine Description: NoteMemoryRef

    Marks the block that pv points into as being referenced.
    Note: pv does not have to point to the start of a block; it may
    point anywhere withing an allocated block

Arguments:

    pv: the block to mark

Return Value:

    void

--*/
void NoteMemoryRef(IN PVOID pv)
{
   PBLOCKINFO pbi;

   pbi = GetBlockInfo((PBYTE)pv);
   pbi->boolReferenced = TRUE;

} // NoteMemoryRef //




/*++

Routine Description: CheckMemoryRefs

    Scans the memory log looking for blocks that have not been
    marked with a call to NoteMemoryRef. It this function finds an
    unmarked block, it asserts.

Arguments:

    void

Return Value:

    void

--*/
void CheckMemoryRefs()
{
   PBLOCKINFO pbi;

   for (pbi = g_pbiHead; pbi != NULL; pbi = pbi->pbiNext)
   {
      //
      // A simple check for block integrity. If this assert fires, it
      // means that something is wrong with the debug code that manages
      // blockinfo or, possibly, that a wild memory store has thrashed
      // the data structure. Either way, there's a bug
      //
      __ASSERT(pbi->pb != NULL && pbi->size);

      //
      // A check for lost or leaky memory. If this assert fires, it means
      // that the app has either lost track of this block or that not all
      // global pointers have been accounted for with NoteMemoryRef.
      //
      __ASSERT(pbi->boolReferenced);
   }

} // CheckMemoryRefs //




/*++

Routine Description: ValidPointer

    Verifies that pv points into an allocated memory block and that there
    are at least "size" allocated bytes from pv to the end of a block. If
    either condition is not met, ValidPointer will assert.

Arguments:

    pv:   the block to check out
    size: the size to match against

Return Value:

    BOOL: Always returns TRUE.

    The reason this always returns TRUE is to allow you to call the
    function within an __ASSERT macro. While this isn't the most efficient
    method to use, using the macro neatly handles the debug-vs-ship
    version control issue without your having to resort to #ifdef
    DEBUGS or to introducing other __ASSERT-like macros.

--*/
BOOL ValidPointer(IN PVOID  pv,
                  IN size_t size)
{
   PBLOCKINFO pbi;
   PBYTE      pb = (PBYTE)pv;

   __ASSERT(pv != NULL && size);

   pbi = GetBlockInfo(pb);

   //
   // size isn't valid if pb+size overflows the block
   //
   __ASSERT(PtrLessEq(pb + size, pbi->pb + pbi->size));

   return TRUE;

} // ValidPointer //




/*++

Routine Description: _Assert

    My assert function. Simply outputs the file name and line number
    to a MessageBox and then kills the program. Note: this should only
    be called by the __ASSERT macro above

Arguments:

    cszFile: the file name the code is located in
    iLine:   the line number of the assertion

Return Value:

     void

--*/
void MyAssert(IN PCHAR cszFile,
              IN UINT  iLine)
{
   WCHAR wszFile[100];
   TCHAR tszMessage[100];
   
   fflush(NULL);

   _stprintf(tszMessage, TEXT("Assertion failed: %s, line %u"),
                         ConvertAnsi(cszFile, wszFile, 100), iLine);
   MessageBox(NULL, tszMessage, NULL, MB_OK);
   
   abort();

} // MyAssert //

#endif  // DEBUG




/*++

Routine Description: __MALLOC

    Don't call this function. Instead, call the macro MyMalloc, 
    which calls this function. 
    
    Wrapper for malloc function. Provides better calling convention
    and debug syntax. Calling example:

    malloc:   pbBlock = (byte *)malloc(sizeof(pbBlock));
    MyMalloc: MyMalloc(&pbBlock, sizeof(pbBlock));

Arguments:

    ppv:    variable to be malloced
    size:   the memory size to use
    cszFile: the file name the code is located in  \ these tell what code
    iLine:   the line number of the assertion      / called the malloc

Return Value:

    BOOL: TRUE if malloc succeeds, FALSE if it does not

--*/
BOOL __MALLOC(IN OUT void   **ppv,
              IN     size_t size,
              IN     PCHAR  cszFile,
              IN     UINT   iLine)
{
   BYTE **ppb = (BYTE **)ppv;

   __ASSERT(ppv != NULL && size != 0);

   *ppb = (BYTE *)malloc(size);

   #ifdef DEBUG
   g_usMalloc++;
   
   if (*ppb != NULL)
   {
      //
      // Shred the memory
      //
      memset(*ppb, GARBAGE, size);

      //
      // Record information about this block in memory
      //
      if (!CreateBlockInfo(*ppb, size, cszFile, iLine))
      {                
         free(*ppb);
         *ppb = NULL;
      }
   }
   #endif

   return (*ppb != NULL);

} // __MALLOC //




/*++

Routine Description: __FREE

    Wrapper for free function. Provides debug syntax.
    Sets the pointer to NULL after it is done freeing it.
    This should always be called in a format such as:
    
    Old syntax: free(pVariable);
    New syntax: MyFree(&pVariable);

Arguments:

    ppv:  variable to be freed

Return Value:

    void

--*/
void __FREE(IN void **ppv)
{
   //
   // *ppv should never be NULL. This is technically legal
   // but it's not good behavior
   //
   __ASSERT (*ppv != NULL);

   #ifdef DEBUG
   g_usFree++;
   
   //
   // Shred the memory
   //
   memset(*ppv, GARBAGE, SizeOfBlock(*ppv));
   FreeBlockInfo(*ppv);
   #endif

   free(*ppv);
   *ppv = NULL;
   
} // __FREE //




/*++

Routine Description: CheckAllocs

    Checks to make sure that everything has been freed. This
    should be called right before the program ends.

Arguments:

    none
    
Return Value:

    VOID: If this function finds any allocated memory that
    has not been freed, it will __ASSERT.

--*/
VOID CheckAllocs()
{
   #ifndef DEBUG
   
   return;
   
   #else
   
   PBLOCKINFO pbi;
   TCHAR      tszInvalidMemoryLocations[10000];
   USHORT     usCounter = 0;
   BOOL       bBadMemFound = FALSE;
   WCHAR      wszUnicode[100];
   
   _stprintf(tszInvalidMemoryLocations, 
             TEXT("Unfreed Malloc Locations: \n\n"));
   
   _stprintf(tszInvalidMemoryLocations, 
             TEXT("%sMallocs = %d Frees = %d\n\n"),
             tszInvalidMemoryLocations, g_usMalloc, g_usFree);
   
   for (pbi = g_pbiHead; pbi != NULL; pbi = pbi->pbiNext)
   {
      bBadMemFound = TRUE;
      
      //
      // Only print out the first 20 unfreed blocks we
      // find, so the messagebox won't be too huge
      //
      if (usCounter++ < 20)
      {
         _stprintf(tszInvalidMemoryLocations,
                   TEXT("%sFile = %s \t Line = %d\n"),
                   tszInvalidMemoryLocations,
                   ConvertAnsi(pbi->cszFile, wszUnicode, 100),
                   pbi->iLine);
      }
   }
   
   if (bBadMemFound)
   {
      MessageBox(NULL, tszInvalidMemoryLocations, NULL, 
                 MB_OK | MB_ICONERROR);
                 
      __ASSERT(TRUE);
   }
   
   #endif
   
} // CheckAllocs //




/*++

Routine Description: StrNCmp

    Compares two TCHAR strings. Both strings length must be >= ulLength

Arguments:

    tszString1: the first string
    tszString2: the second string
    ulLength:  the length to compare

Return Value:

    BOOL: TRUE if strings are equal, FALSE if not

--*/
BOOL StrNCmp(IN PTCHAR tszString1,
             IN PTCHAR tszString2,
             IN ULONG  ulLength)
{
   ULONG ulIndex;

   //
   // Both strings must be valid and ulLength must be > 0
   //
   __ASSERT(tszString1 != NULL);
   __ASSERT(tszString2 != NULL);
   __ASSERT(ulLength > 0);
   
   if (_tcslen(tszString1) < ulLength ||
       _tcslen(tszString2) < ulLength)
   {
      goto RetFALSE;
   }
   
   for (ulIndex = 0; ulIndex < ulLength; ulIndex++)
   {
      if (tszString1[ulIndex] != tszString2[ulIndex])
      {
         goto RetFALSE;
      }
   }

   return TRUE;

   RetFALSE:
   return FALSE;

} // StrNCmp //




/*++

Routine Description: StrCmp

    Compares two TCHAR strings

Arguments:

    tszString1: the first string
    tszString2: the second string

Return Value:

    BOOL: TRUE if strings are equal, FALSE if not

--*/
BOOL StrCmp(IN PTCHAR tszString1,
            IN PTCHAR tszString2)
{
   ULONG ulIndex;
   ULONG ulLength;
   
   //
   // Both strings must be valid
   //
   __ASSERT(tszString1 != NULL);
   __ASSERT(tszString2 != NULL);
   
   ulLength = _tcslen(tszString1);
   
   if (ulLength != _tcslen(tszString2))
   {
      goto RetFALSE;
   }
   
   for (ulIndex = 0; ulIndex < ulLength; ulIndex++)
   {
      if (tszString1[ulIndex] != tszString2[ulIndex])
      {
         goto RetFALSE;
      }
   }

   return TRUE;

   RetFALSE:
   return FALSE;

} // StrCmp //


        

/*++

Routine Description: AnsiToUnicode

    Converts an Ansi string to a Unicode string.
    
Arguments:

    cszAnsi:    the Ansi string to convert
    wszUnicode: unicode buffer to store new string. Must not be NULL    
    ulSize:     must be set to the size of the wszUnicode buffer
    
Return Value:

    PWCHAR: returns the wszUnicode buffer

--*/
PWCHAR AnsiToUnicode(IN  PCHAR  cszAnsi,
                     OUT PWCHAR wszUnicode,
                     IN  ULONG  ulSize)
{                     
   USHORT i;
   USHORT usAnsiLength;
   CHAR   cszTemp[2000];
   CHAR   cszTemp2[2000];
   
   //
   // Clear out the new Unicode string
   //
   ZeroMemory(wszUnicode, ulSize);
   
   //
   // Record the length of the original Ansi string
   //
   usAnsiLength = strlen(cszAnsi);
   
   //
   // Copy the unicode string to a temporary buffer
   //
   strcpy(cszTemp, cszAnsi);
   
   for (i = 0; i < usAnsiLength && i < ulSize - 1; i++)
   {
      //
      // Copy the current character
      //
      wszUnicode[i] = (WCHAR)cszTemp[i];
   }
   
   wszUnicode[i] = '\0';
   return wszUnicode;
   
} // AnsiToUnicode //




/*++

Routine Description: UnicodeToAnsi

    Converts a Unicode string to an Ansi string.
    
Arguments:

    wszUnicode: the Unicode string to convert
    cszAnsi:    Ansi buffer to store new string. Must not be NULL    
    ulSize:     must be set to the size of the cszAnsi buffer
    
Return Value:

    PCHAR: returns the cszAnsi buffer

--*/
PCHAR UnicodeToAnsi(IN  PWCHAR wszUnicode,
                    OUT PCHAR  cszAnsi,
                    IN  ULONG  ulSize)  
{
   USHORT i;
   USHORT usUnicodeLength;
   WCHAR  wszTemp[2000];
   
   //
   // Record the length of the original Unicode string
   //
   usUnicodeLength = wcslen(wszUnicode);
   
   //
   // Copy the unicode string to a temporary buffer
   //
   wcscpy(wszTemp, wszUnicode);
   
   for (i = 0; i < usUnicodeLength && i < ulSize - 1; i++)
   {
      //
      // Copy the current character
      //
      cszAnsi[i] = (CHAR)wszTemp[0];
      
      //
      // Shift the unicode string up by one position
      //
      wcscpy(wszTemp, wszTemp + 1);
   }
   
   //
   // Add a null terminator to the end of the new ansi string
   //
   cszAnsi[i] = '\0';

   return cszAnsi;
   
} // UnicodeToAnsi //




/*++

Routine Description: ConvertAnsi

    Receives an Ansi string. Returns the equivalent string in Ansi or
    Unicode, depending on the current environment
    
Arguments:

    cszAnsi:    the Ansi string to convert
    wszUnicode: unicode buffer to store new string (if needed). 
                Must not be NULL    
    ulSize:     must be set to the size of the wszUnicode buffer
    
Return Value:

    TCHAR: returns the ANSI or Unicode string

--*/
PTCHAR ConvertAnsi(IN OUT PCHAR  cszAnsi,
                   IN OUT PWCHAR wszUnicode,
                   IN     ULONG  ulSize)
{                     
   //
   // If Unicode, we need to convert the string
   //
   #ifdef UNICODE
   
   return AnsiToUnicode(cszAnsi, wszUnicode, ulSize);
   
   //
   // If not Unicode, just return the original Ansi string
   //
   #else   
 
   return cszAnsi;
   
   #endif
   
} // ConvertAnsi //




/*++

Routine Description: ConvertUnicode

    Receives a Unicode string. Returns the equivalent string in Ansi or
    Unicode, depending on the current environment
    
Arguments:

    wszUnicode: the Unicode string to convert
    cszAnsi:    ANSI buffer to store new string (if needed). 
                Must not be NULL    
    ulSize:     must be set to the size of the cszAnsi buffer
    
Return Value:

    TCHAR: returns the ANSI or Unicode string

--*/
PTCHAR ConvertUnicode(IN OUT PWCHAR wszUnicode,
                      IN OUT PCHAR  cszAnsi,
                      IN     ULONG  ulSize)
{                     
   //
   // If Unicode, just return the original Unicode string
   //
   #ifdef UNICODE
 
   return wszUnicode;
   
   //
   // If not Unicode, need to convert to Ansi
   //
   #else   
   
   return UnicodeToAnsi(wszUnicode, cszAnsi, ulSize);
   
   #endif
   
} // ConvertUnicode //




/*++

Routine Description: ErrorMsg

    Converts a numerical winerror into it's string value

Arguments:

    ulError:   the error number
    tszBuffer: this buffer is used to return the string interpretation
               must be declared of size MAX_ERROR_LEN

Return Value:

    PTCHAR: returns the string value of the message stored in tszBuffer

--*/
PTCHAR ErrorMsg(IN     ULONG  ulError,
                IN OUT PTCHAR tszBuffer)  
{
   USHORT i, usLen;
   ULONG  ulSuccess;
   
   __ASSERT(tszBuffer != NULL);
   
   ZeroMemory(tszBuffer, MAX_ERROR_LEN);
   
   ulSuccess = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                             NULL,
                             ulError,
                             0,
                             tszBuffer,
                             MAX_ERROR_LEN,
                             NULL);
                             
   if (!ulSuccess)
   {
      // 
      // Couldn't get a description of this error. Just return the number
      //
      _itot(ulError, tszBuffer, MAX_ERROR_LEN);
   }
   else
   {
      //
      // Strip out returns from tszBuffer string
      //
      for (usLen = _tcslen(tszBuffer), i = 0; i < usLen; i++)
      {
         if (tszBuffer[i] == RETURN_CHAR1 || tszBuffer[i] == RETURN_CHAR2)
         {
            tszBuffer[i] = SPACE;
         }
      }
   }
   
   return tszBuffer;
   
} // ErrorMsg //
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ocmanage\testoc\cleanreg\cleanreg.c ===
#include <windows.h>
#include <winreg.h>
#include <winuser.h>

//#define DEBUG

VOID __cdecl main(){

   LONG        lDeleteRegResult;
   //LPCTSTR     tszKeyErrors = TEXT("HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\Errors");
   //LPCTSTR     tszKeyMasterInfs = TEXT("HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\MasterInfs");
   //LPCTSTR     tszKeySubcomponents = TEXT("HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\Subcomponents");
   //LPCTSTR     tszKeyTemporaryData = TEXT("HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\TemporaryData");
   //LPCTSTR     tszKeyOCManager = TEXT("HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager");

   #ifdef DEBUG
   HKEY        hkeyResult = 0;

   // Let's see if I can open the key
   lDeleteRegResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\Errors", 0, KEY_ALL_ACCESS, &hkeyResult);
   if (lDeleteRegResult != ERROR_SUCCESS) {
      MessageBox(NULL, TEXT("Can not open error key"), TEXT("Open"), MB_OK);
   }
   #endif
    
   // Do something to clean OC Manager's registry
   // the whole key will be deleted
   lDeleteRegResult = RegDeleteKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\Errors");
   #ifdef DEBUG
   if (lDeleteRegResult != ERROR_SUCCESS) {
      MessageBox(NULL, TEXT("Error Key not deleted"), TEXT("CleanReg"), MB_OK);
   }
   #endif
   
   lDeleteRegResult = RegDeleteKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\MasterInfs");
   #ifdef DEBUG
   if (lDeleteRegResult != ERROR_SUCCESS) {
      MessageBox(NULL, TEXT("MasterInfs Key not deleted"), TEXT("CleanReg"), MB_OK);
   }
   #endif
   
   lDeleteRegResult = RegDeleteKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\Subcomponents");
   #ifdef DEBUG
   if (lDeleteRegResult != ERROR_SUCCESS) {
      MessageBox(NULL, TEXT("Subcomponents Key not deleted"), TEXT("CleanReg"), MB_OK);
   }
   #endif
   
   lDeleteRegResult = RegDeleteKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\TemporaryData");
   #ifdef DEBUG
   if (lDeleteRegResult != ERROR_SUCCESS) {
      MessageBox(NULL, TEXT("TemporaryData Key not deleted"), TEXT("CleanReg"), MB_OK);
   }
   #endif
   
   lDeleteRegResult = RegDeleteKey(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager");
   #ifdef DEBUG
   if (lDeleteRegResult != ERROR_SUCCESS) {
      MessageBox(NULL, TEXT("OCManager Key not deleted"), TEXT("CleanReg"), MB_OK);
   }
   #endif
   
   lDeleteRegResult = RegFlushKey(HKEY_LOCAL_MACHINE);
   #ifdef DEBUG
   if (lDeleteRegResult != ERROR_SUCCESS) {
      MessageBox(NULL, TEXT("Registry not flushed sucessfully"), TEXT("CleanReg"), MB_OK);
   }
   #endif

         
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ocmanage\testoc\hctlib\hcttools.h ===
/*++

Copyright (c) 1997    Microsoft Corporation

Module Name:

    hctytools.h

Abstract:

    Contains the definitions used by hcttools.c

Environment:

    User mode

Revision History:

    05-Sep-1997 : Jason Allor (jasonall)

--*/
#include "windows.h"
#include "stdlib.h"
#include "stdio.h"
#include "tchar.h"

#ifndef _MYTOOLS_H
#define _MYTOOLS_H

   #define MAX_ERROR_LEN 256   
   #define RETURN_CHAR1  0x0d
   #define RETURN_CHAR2  0x0a
   #define SPACE         0x20
   
   BOOL __MALLOC(IN OUT void   **ppv,
                 IN     size_t size,
                 IN     PCHAR  cszFile,
                 IN     UINT   iLine);

   void __FREE(IN void **pv);

   VOID CheckAllocs();
   
   VOID InitializeMemoryManager();
   
   #ifdef DEBUG
      
      typedef struct _BLOCKINFO
      {
         struct _BLOCKINFO *pbiNext;
         BYTE   *pb;
         size_t size;   
         BOOL   boolReferenced;
         UINT   iLine;
         CHAR   cszFile[MAX_PATH];
      } BLOCKINFO, *PBLOCKINFO;

      #define Ptrless(pLeft, pRight)    ((pLeft  <  (pRight))
      #define PtrGrtr(pLeft, pRight)    ((pLeft) >  (pRight))
      #define PtrEqual(pLeft, pRight)   ((pLeft) == (pRight))
      #define PtrLessEq(pLeft, pRight)  ((pLeft) <= (pRight))
      #define PtrGrtrEq(pLeft, pRight)  ((pLeft) >= (pRight))

      void MyAssert(PCHAR, unsigned);
      BOOL CreateBlockInfo(OUT PBYTE  pbNew,
                           IN  size_t sizeNew,
                           IN  PCHAR  cszFile,
                           IN  UINT   iLine);
      void UpdateBlockInfo(PBYTE pbOld, PBYTE pbNew, size_t sizeNew);
      size_t SizeOfBlock(PBYTE pb);
      void ClearMemoryRegs();
      void NoteMemoryRef(PVOID pv);
      void CheckMemoryRefs();
      BOOL ValidPointer(PVOID pv, size_t size);
   
      #define GARBAGE 0xCC // used for shredding memory during Malloc and Free
   
   #endif

   //
   // Define __ASSERT macro
   //
   #ifdef DEBUG
      
      #define __ASSERT(f) \
         if (f)         \
            {}          \
         else           \
            MyAssert(__FILE__, __LINE__) 
   
   #else
      
      #define __ASSERT(f)
   
   #endif

   //
   // Define __Malloc macro. This gives the MALLOC function
   // the file name and line number of the line calling MyMalloc
   //
   #define __Malloc(one, two) __MALLOC(one, two, __FILE__, __LINE__) 
   
   //
   // Define the __Free macro. This is only here for consistency with __Malloc
   //
   #define __Free(one) __FREE(one)

   BOOL StrNCmp(IN PTCHAR tszString1,
                IN PTCHAR tszString2,
                IN ULONG  ulLength);

   BOOL StrCmp(IN PTCHAR tszString1,
               IN PTCHAR tszString2);

   PWCHAR AnsiToUnicode(IN  PCHAR  cszAnsi,
                        OUT PWCHAR wszUnicode,
                        IN  ULONG  ulSize);
                        
   PCHAR UnicodeToAnsi(IN  PWCHAR wszUnicode,
                       OUT PCHAR  cszAnsi,
                       IN  ULONG  ulSize);
                       
   PTCHAR ConvertAnsi(IN     PCHAR  cszAnsi,
                      IN OUT PWCHAR wszUnicode,
                      IN     ULONG  ulSize);
                     
   PTCHAR ConvertUnicode(IN     PWCHAR wszUnicode,
                         IN OUT PCHAR  cszAnsi,
                         IN     ULONG  ulSize);
                     
   PTCHAR ErrorMsg(IN ULONG  ulError,
                   IN PTCHAR tszBuffer);

#endif // _MYTOOLS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ocmanage\testoc\hctlib\sources.inc ===
C_DEFINES= -DDEBUG

NTDEBUG=ntsd
NTDEBUGTYPE=both

TARGETPATH=..\lib
TARGETTYPE=LIBRARY

TARGETLIBS=$(SDK_LIB_PATH)\advapi32.lib \
           $(SDK_LIB_PATH)\kernel32.lib \


UMLIBS=$(SDK_LIB_PATH)\libc.lib \
       $(SDK_LIB_PATH)\ntdll.lib \
       $(SDK_LIB_PATH)\user32.lib 

SOURCES= ..\logutils.c ..\hcttools.c

INCLUDES= ..;

UMTYPE=console
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ocmanage\testoc\hctlib\logutils.c ===
//3456789012345678901234567890123456789012345678901234567890123456789012345678
/*++

Copyright (c) 1997  Microsoft Corporation.

Module Name:

    logutils.c

Abstract:

    Contains functions that deal with ntlog.dll

Author:

    Jason Allor (JasonAll) 5/27/97

Revision History:


--*/
#include "logutils.h"

static HANDLE g_hSemaphore;
static ULONG  g_ulPass;
static ULONG  g_ulFail;
static ULONG  g_ulInfo;

/*++

Routine Description: LoadDLLs

    Tries to dynamically load ntlog.dll functions

Arguments:

    DLLName: the name of the DLL to load, ntlog.dll in this case

Return Value:

    void

--*/
void LoadDLLs(IN PTCHAR DLLName)
{
   HINSTANCE Library;

   //
   // Set global handle to logfile to NULL
   //
   gPnPTestLog = NULL;

   //
   // Load the engine DLL
   //
   Library = LoadLibrary(DLLName);

   if ((UINT) Library > 32)
   {
#ifdef UNICODE
      _tlLog               = (Dll_tlLog) \
                             GetProcAddress(Library, "tlLog_W");

      _tlCreateLog         = (Dll_tlCreateLog) \
                             GetProcAddress(Library, "tlCreateLog_W");
#else
      _tlLog               = (Dll_tlLog) \
                             GetProcAddress(Library, "tlLog_A");

      _tlCreateLog         = (Dll_tlCreateLog) \
                             GetProcAddress(Library, "tlCreateLog_A");
#endif
      
      _tlAddParticipant    = (Dll_tlAddParticipant) \
                             GetProcAddress(Library, "tlAddParticipant");

      _tlDestroyLog        = (Dll_tlDestroyLog) \
                             GetProcAddress(Library, "tlDestoryLog");

      _tlEndVariation      = (Dll_tlEndVariation) \
                             GetProcAddress(Library, "tlEndVariation");

      _tlRemoveParticipant = (Dll_tlRemoveParticipant) \
                             GetProcAddress(Library, "tlRemoveParticipant");

      _tlStartVariation    = (Dll_tlStartVariation) \
                             GetProcAddress(Library, "tlStartVariation");

      _tlReportStats       = (Dll_tlReportStats) \
                             GetProcAddress(Library, "tlReportStats");

      gNtLogLoaded = TRUE;
   }
   else
   {
      gNtLogLoaded = FALSE;
   }

   return;

} // LoadDLLs //




/*++

Routine Description: InitLog

    This routine will import the NtLog DLL functions and initialize them

Arguments:

    none

Return Value:

    HANDLE: handle to the log file

--*/
HANDLE InitLog(IN PTCHAR tszLogName,
               IN PTCHAR tszTitle,
               IN BOOL   bConsole)
{
   gPnPTestLog = NULL;
   gPnPTestLogFile = NULL;

   g_ulPass = 0;
   g_ulFail = 0;
   g_ulInfo = 0;

   //
   // Initialize Semaphore
   //
   g_hSemaphore = CreateSemaphore(NULL, 1, 9999, NULL);

   if (g_hSemaphore == NULL)
   {
      _ftprintf(stderr, TEXT("WARNING!  Could not create semaphore!\n"));
   }

   CreateConsoleWindow(bConsole, tszTitle);
   
   //
   // Set up console window for log output
   //
   g_hConsole = CreateConsoleScreenBuffer(GENERIC_WRITE,
                                          0,
                                          NULL,
                                          CONSOLE_TEXTMODE_BUFFER,
                                          NULL);

   if (g_hConsole == INVALID_HANDLE_VALUE) 
   {
      return INVALID_HANDLE_VALUE;
   }
     
   //
   // Load ntlog.dll
   //
   LoadDLLs(TEXT("ntlog.dll"));

   if (gNtLogLoaded)
   {
      g_LogLineLen = NTLOG_LINE_LEN;
      gPnPTestLog = _tlCreateLog((LPCWSTR)(tszLogName), LOG_OPTIONS);

      if (!gPnPTestLog)
      {
         _ftprintf(stderr, TEXT("WARNING!  Log file could not be created!\n"));
      }
      else
      {
         _tlStartVariation(gPnPTestLog);
         _tlAddParticipant(gPnPTestLog, 0, 0);
      }
   }
   else
   {
      SetConsoleActiveScreenBuffer(g_hConsole);
     
      g_LogLineLen =  NO_NTLOG_LINE_LEN;
      gPnPTestLogFile = _tfopen(tszLogName, TEXT("w"));

      if (!gPnPTestLogFile)
      {
         _ftprintf(stderr, TEXT("WARNING! Log file could not be created!\n"));
      }
   }

   return gPnPTestLog;

} // InitLog //




/*++

Routine Description: ExitLog

    Processes clean-up work before exiting the program

Arguments:

    none

Return Value:

    void

--*/
void ExitLog()
{
   double dTotal;
   double dPass;
   double dFail;
   USHORT usPassPerc;
   USHORT usFailPerc;
   
   CloseHandle(g_hConsole);
   CloseHandle(g_hSemaphore);
   
   if (gNtLogLoaded)
   {
      if (gPnPTestLog)
      {
         _tlReportStats(gPnPTestLog);
         _tlRemoveParticipant(gPnPTestLog);
         _tlEndVariation(gPnPTestLog);

         gPnPTestLog = NULL;
      }
   }
   else
   {
      //
      // Print out statistics
      //
      dTotal = g_ulPass + g_ulFail;

      dPass = (double)g_ulPass / dTotal;
      dFail = (double)g_ulFail / dTotal;
      
      usPassPerc = (USHORT)(dPass * 100);
      usFailPerc = (USHORT)(dFail * 100);

      LogBlankLine();
      LogBlankLine();
      Log(0, INFO, TEXT("Log Statistics:"));
      LogBlankLine();

      Log(0, INFO, TEXT("Pass:  %lu\t%lu%%%%%%%%%%%%%%%"), g_ulPass, usPassPerc);

      Log(0, INFO, TEXT("Fail:  %lu\t%lu%%%%%%%%%%%%%%%"), g_ulFail, usFailPerc);

      Log(0, INFO, TEXT("Total: %lu"), dTotal);
      
      if (gPnPTestLog)
      {
         fclose(gPnPTestLogFile);

         gPnPTestLogFile = NULL;
      }
   }

} // ExitLog //




/*++

Routine Description: WriteLog

    Wrapper function to write to the log

Arguments:

    dwLoglevel: specifies the log level such as TLS_INF, TLS_WARN, or TLS_SEV2
    tszBuffer:  the string to write to the log

Return Value:

    void

--*/
void WriteLog(IN DWORD  dwLogLevel,
              IN PTCHAR tszBuffer)
{
   USHORT i;
   HANDLE hConsole;
   DWORD  dwDummy;
   TCHAR  tszLogLine[2000];
   CHAR   cszAnsi[2000];
   CHAR   cszLogLine[2000];
   
   if (gNtLogLoaded)
   {
      if (gPnPTestLog)
      {
         _tlLog(gPnPTestLog, dwLogLevel | TL_VARIATION, tszBuffer);
      }
   }
   else
   {
      //
      // Convert tszBuffer to an ANSI string
      //
#ifdef UNICODE
   
      _tcscpy(tszLogLine, tszBuffer);
   
      for (i = 0; i < _tcslen(tszBuffer) && i < 1999; i++)
      {
         cszAnsi[i] = (CHAR)tszLogLine[0];
         _tcscpy(tszLogLine, _tcsinc(tszLogLine));
      }
      cszAnsi[i] = '\0';

#else

      strcpy(cszAnsi, tszBuffer);
   
#endif   
   
      switch (dwLogLevel)
      {
         case INFO:
            sprintf(cszLogLine, "INFO  ");
            g_ulInfo++;
            break;
         case SEV1:
            sprintf(cszLogLine, "SEV1  ");
            g_ulFail++;
            break;
         case SEV2:
            sprintf(cszLogLine, "SEV2  ");
            g_ulFail++;
            break;
         case SEV3:
            sprintf(cszLogLine, "SEV3  ");
            g_ulFail++;
             break;
         case PASS:
            sprintf(cszLogLine, "PASS  ");
            g_ulPass++;
            break;
         default:
            sprintf(cszLogLine, "      ");
      }
   
      if (gPnPTestLogFile)
      {
         sprintf (cszLogLine, "%s%s\n", cszLogLine, cszAnsi);
         
         WaitForSingleObject(g_hSemaphore, INFINITE);
         
         //
         // Print to log file
         //
         fprintf(gPnPTestLogFile, cszLogLine);
         fflush(gPnPTestLogFile);

         //
         // Print to screen
         //
         WriteFile(g_hConsole, 
                   cszLogLine, 
                   strlen(cszLogLine), 
                   &dwDummy, 
                   NULL);
         
         ReleaseSemaphore(g_hSemaphore, 1, NULL);
      }
   }

   return;

} // WriteLog //




/*++

Routine Description: Log

    Wrapper to the Log function. It divides a long string into
    shorter strings and puts each one on a separate line to avoid running
    over the end of a console window

Arguments:

    dFunctionNumber: shows which function this log output is coming from.
                     Used to track function progress
    dwLoglevel:      specifies the log level such as TLS_INF, TLS_WARN, 
                     or TLS_SEV2
    tszLogString:    printf() style format string

Return Value:

    void

--*/
void Log(IN double dFunctionNumber,
         IN DWORD  dwLogLevel,
         IN PTCHAR tszLogString,
         IN  ...)
{
   va_list va;
   TCHAR   tszBuffer[LOG_STRING_LEN];
   TCHAR   tszBufferToPrint[LOG_STRING_LEN];
   TCHAR   tszTmpString[LOG_STRING_LEN + LOG_SPACE_LEN];
   ULONG   ulIndex, i, j;
   BOOL    boolFirstTime = TRUE;
   int     iInteger, iFunctionNumber;      
   double  dDecimal;      

   //
   // Prints the list to a buffer
   //
   va_start(va, tszLogString);
   if (!_vsntprintf (tszBuffer, LOG_STRING_LEN, tszLogString, va))
   {
      _ftprintf(stderr, TEXT("Log: Failed\n"));
      ExitLog();
      exit(1);
   }
   va_end(va);

   switch (dwLogLevel)
   {
      case INFO:
         SetConsoleTextAttribute(g_hConsole, GREY);
         break;
      case SEV1:
         SetConsoleTextAttribute(g_hConsole, RED);
         break;
      case SEV2:
         SetConsoleTextAttribute(g_hConsole, RED);
         break;
      case SEV3:
         SetConsoleTextAttribute(g_hConsole, RED);
          break;
      case PASS:
         SetConsoleTextAttribute(g_hConsole, GREEN);
         break;
      default:
         SetConsoleTextAttribute(g_hConsole, GREY);
   }
   
   while (_tcslen(tszBuffer))
   {
      ZeroMemory(tszBufferToPrint, LOG_STRING_LEN);

      if (_tcslen(tszBuffer) > g_LogLineLen)
      {
         //
         // If the LogString is longer than the console length, start at the
         // maximum console length and work backwards until we hit a space
         // to find out where to cut off the string
         //
         for (ulIndex = g_LogLineLen; ulIndex > 0; ulIndex--)
         {
            if (tszBuffer[ulIndex] == ' ')
            {
               break;
            }
         }

         //
         // index now sits on the last char that we want to print. Create
         // two strings - one to print now and one with the leftovers.
         //
         for (i = 0; i < ulIndex; i++)
         {
            tszBufferToPrint[i] = tszBuffer[i];
         }

         ulIndex++;
         for (i = 0; i < LOG_STRING_LEN; i++)
         {
            //
            // Shift the remaining string up to the front
            //
            if (i < LOG_STRING_LEN - ulIndex)
            {
               tszBuffer[i] = tszBuffer[i + ulIndex];
            }
            else
            {
               tszBuffer[i] = '\0';
            }
         }
      }
      else
      {
         //
         // Just print out the entire string since it contains no spaces
         //
         _stprintf(tszBufferToPrint, tszBuffer);
         ZeroMemory(tszBuffer, LOG_STRING_LEN);
      }

      if (boolFirstTime)
      {
         {
            _stprintf(tszTmpString, TEXT("(%.2f) "), dFunctionNumber);
         }
         _tcscat(tszTmpString, tszBufferToPrint);
         _tcscpy(tszBufferToPrint, tszTmpString);
         WriteLog(dwLogLevel, tszBufferToPrint);
      }
      else
      {
         _stprintf(tszTmpString, TEXT("       "));
         _tcscat(tszTmpString, tszBufferToPrint);
         _tcscpy(tszBufferToPrint, tszTmpString);
         WriteLog(INFO, tszBufferToPrint);
      }

      boolFirstTime = FALSE;
   }

   return;

} // Log //




/*++

Routine Description: LogBlankLine

    Print a blank line to the log

Arguments:

    none

Return Value:

    void

--*/
VOID LogBlankLine()
{
   SetConsoleTextAttribute(g_hConsole, GREY);
   WriteLog(INFO, TEXT(" "));

} // LogBlankLine //




/*++

Routine Description: CreateConsoleWindow

    Creates a console window for this process to dump the log output into.
    Gives the console window a title and uses this title to get a handle
    to the console window. Then disables the cancel button on the window.

Arguments:

    bConsole: TRUE if a new console window needs to be created.
              FALSE if there is already a console that can be used
    tszTitle: title to give the console window

Return Value:

    none

--*/
VOID CreateConsoleWindow(IN BOOL   bConsole,
                         IN PTCHAR tszTitle)
{
   HWND gConsole;

   if (bConsole)
   {
      //
      // Create a console window to dump the log output in
      //
      if (!AllocConsole())
      {
         goto RETURN;
      }
   }
   
   if (!SetConsoleTitle(tszTitle))
   {
      goto RETURN;
   }

   RETURN:
   return;

} // CreateConsoleWindow //




VOID AddLogParticipant(IN HANDLE hLog)
{
   if (gNtLogLoaded)
   {
      _tlAddParticipant(hLog, 0, 0);                  
   }

} // AddLogParticipant //




VOID RemoveLogParticipant(IN HANDLE hLog)
{
   if (gNtLogLoaded)
   {
      _tlRemoveParticipant(hLog);
   }

} // RemoveLogParticipant //
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ocmanage\testoc\hctlib\ntlog.h ===
/*---------------------------------------------------------------------------*\
| NTLOG OBJECT
|   This module defines the NTLOG object.  This header must be include in all
|   modules which make NTLOG calls, or utilizes the definitions.
|
|
| Copyright (C) 1990-1994 Microsoft Corp.
|
| created: 01-Oct-90
| history: 01-Oct-90 <chriswil> created.
|          05-Feb-91 <chriswil> added NOPROLOG style.
|          23-Feb-91 <chriswil> expanded log-flags to DWORD.
|          28-May-91 <chriswil> added per-thread variation tracking.
|          19-Mar-92 <chriswil> redefined struct for shared memory.
|          10-Oct-92 <martys>   added thread macros
|          05-Oct-93 <chriswil> unicode enabled.
|
\*---------------------------------------------------------------------------*/


// NTLOG STYLES
//  The folowing are logging levels in which the Log Object can prejudice
//  itself.  These are used by the tlLogCreate() in initializing the
//  Log Object information.  A combination of characteristics is obtained
//  by bitwise OR'ing these identifiers together.
//
#define LOG_LEVELS    0x0000FFFFL       // These are used to mask out the
#define LOG_STYLES    0xFFFF0000L       // styles or levels from log object.

#define TLS_LOGALL    0x0000FFFFL       // Log output.  Logs all the time.
#define TLS_LOG       0x00000000L       // Log output.  Logs all the time.
#define TLS_INFO      0x00002000L       // Log information.
#define TLS_ABORT     0x00000001L       // Log Abort, then kill process.
#define TLS_SEV1      0x00000002L       // Log at Severity 1 level
#define TLS_SEV2      0x00000004L       // Log at Severity 2 level
#define TLS_SEV3      0x00000008L       // Log at Severity 3 level
#define TLS_WARN      0x00000010L       // Log at Warn level
#define TLS_PASS      0x00000020L       // Log at Pass level
#define TLS_BLOCK     0x00000400L       // Block the variation.
#define TLS_BREAK     0x00000800L       // Debugger break;
#define TLS_CALLTREE  0x00000040L       // Log call-tree (function tracking).
#define TLS_SYSTEM    0x00000080L       // Log System debug.
#define TLS_TESTDEBUG 0x00001000L       // Debug level.
#define TLS_TEST      0x00000100L       // Log Test information (user).
#define TLS_VARIATION 0x00000200L       // Log testcase level.

#define TLS_REFRESH   0x00010000L       // Create new file || trunc to zero.
#define TLS_SORT      0x00020000L       // Sort file output by instance.
#define TLS_DEBUG     0x00040000L       // Output to debug (com) monitor).
#define TLS_MONITOR   0x00080000L       // Output to 2nd screen.
#define TLS_PROLOG    0x00200000L       // Prolog line information.
#define TLS_WINDOW    0x00400000L       // Log to windows.
#define TLS_ACCESSON  0x00800000L       // Keep log-file open.


// NTLOG tlLogOut() PARAMETERS
//   The following defines are used in the tlLogOut() function to output the
//   filename and line numbers associated with the caller.  This uses the
//   preprocessors capabilities for obtaining the file/line.
//
#define TL_LOG       TLS_LOG      ,(LPTSTR)__FILE__,(int)__LINE__
#define TL_ABORT     TLS_ABORT    ,(LPTSTR)__FILE__,(int)__LINE__
#define TL_SEV1      TLS_SEV1     ,(LPTSTR)__FILE__,(int)__LINE__
#define TL_SEV2      TLS_SEV2     ,(LPTSTR)__FILE__,(int)__LINE__
#define TL_SEV3      TLS_SEV3     ,(LPTSTR)__FILE__,(int)__LINE__
#define TL_WARN      TLS_WARN     ,(LPTSTR)__FILE__,(int)__LINE__
#define TL_PASS      TLS_PASS     ,(LPTSTR)__FILE__,(int)__LINE__
#define TL_BLOCK     TLS_BLOCK    ,(LPTSTR)__FILE__,(int)__LINE__
#define TL_INFO      TLS_INFO     ,(LPTSTR)__FILE__,(int)__LINE__
#define TL_BREAK     TLS_BREAK    ,(LPTSTR)__FILE__,(int)__LINE__
#define TL_CALLTREE  TLS_CALLTREE ,(LPTSTR)__FILE__,(int)__LINE__
#define TL_SYSTEM    TLS_SYSTEM   ,(LPTSTR)__FILE__,(int)__LINE__
#define TL_TESTDEBUG TLS_TESTDEBUG,(LPTSTR)__FILE__,(int)__LINE__
#define TL_TEST      TLS_TEST     ,(LPTSTR)__FILE__,(int)__LINE__
#define TL_VARIATION TLS_VARIATION,(LPTSTR)__FILE__,(int)__LINE__


// NTLOG API (EXPORT METHODS)
//   These routines are exported from the library.  These should be the only
//   interface with the NTLOG object.
//
HANDLE APIENTRY  tlCreateLog_W(LPWSTR,DWORD);
HANDLE APIENTRY  tlCreateLog_A(LPSTR,DWORD);
BOOL   APIENTRY  tlDestroyLog(HANDLE);
BOOL   APIENTRY  tlAddParticipant(HANDLE,DWORD,int);
BOOL   APIENTRY  tlRemoveParticipant(HANDLE);
DWORD  APIENTRY  tlParseCmdLine_W(LPWSTR);
DWORD  APIENTRY  tlParseCmdLine_A(LPSTR);
int    APIENTRY  tlGetLogFileName_W(HANDLE,LPWSTR);
int    APIENTRY  tlGetLogFileName_A(HANDLE,LPSTR);
BOOL   APIENTRY  tlSetLogFileName_W(HANDLE,LPWSTR);
BOOL   APIENTRY  tlSetLogFileName_A(HANDLE,LPSTR);
DWORD  APIENTRY  tlGetLogInfo(HANDLE);
DWORD  APIENTRY  tlSetLogInfo(HANDLE,DWORD);
HANDLE APIENTRY  tlPromptLog(HWND,HANDLE);
int    APIENTRY  tlGetTestStat(HANDLE,DWORD);
int    APIENTRY  tlGetVariationStat(HANDLE,DWORD);
VOID   APIENTRY  tlClearTestStats(HANDLE);
VOID   APIENTRY  tlClearVariationStats(HANDLE);
BOOL   APIENTRY  tlStartVariation(HANDLE);
DWORD  APIENTRY  tlEndVariation(HANDLE);
VOID   APIENTRY  tlReportStats(HANDLE);
BOOL   APIENTRY  tlLogX_W(HANDLE,DWORD,LPWSTR,int,LPWSTR);
BOOL   APIENTRY  tlLogX_A(HANDLE,DWORD,LPSTR,int,LPSTR);
BOOL   FAR cdecl tlLog_W(HANDLE,DWORD,LPWSTR,int,LPWSTR,...);
BOOL   FAR cdecl tlLog_A(HANDLE,DWORD,LPSTR,int,LPSTR,...);


#ifdef UNICODE
#define tlCreateLog         tlCreateLog_W
#define tlParseCmdLine      tlParseCmdLine_W
#define tlGetLogFileName    tlGetLogFileName_W
#define tlSetLogFileName    tlSetLogFileName_W
#define tlLogX              tlLogX_W
#define tlLog               tlLog_W
#else
#define tlCreateLog         tlCreateLog_A
#define tlParseCmdLine      tlParseCmdLine_A
#define tlGetLogFileName    tlGetLogFileName_A
#define tlSetLogFileName    tlSetLogFileName_A
#define tlLogX              tlLogX_A
#define tlLog               tlLog_A
#endif



// RATS MACROS
//   These macros are provided as a common logging interface which is
//   compatible with the RATS logging-macros.
//
#define L_PASS                   hLog,TL_PASS
#define L_WARN                   hLog,TL_WARN
#define L_DEBUG                  hLog,TL_TESTDEBUG
#define L_TRACE                  hLog,TL_SYSTEM
#define L_FAIL                   hLog,TL_SEV1
#define L_FAIL2                  hLog,TL_SEV2
#define L_FAIL3                  hLog,TL_SEV3
#define L_BLOCK                  hLog,TL_BLOCK

#define TESTDATA                 HANDLE hLog;

#define TESTOTHERDATA            extern HANDLE hLog;
#define TESTBEGIN(cmd)           TCHAR  log[100];                                                        \
                                 DWORD  tlFlags;                                                         \
                                 tlFlags = tlParseCmdLine(cmd,log);                                      \
                                 hLog    = tlCreateLog(log,tlFlags);                                     \
                                 tlAddParticipant(hLog,0,0);

#define TESTEND                  tlRemoveParticipant(hLog);                                              \
                                 tlDestroyLog(hLog);

#define VARIATION(name,flags)    if(tlStartVariation(hLog))                                              \
                                 {                                                                       \
                                     DWORD  dwResult;                                                    \
                                     tlLog(hLog,TL_VARIATION,TEXT("%s"),(LPTSTR)name);


#define ENDVARIATION                 dwResult = tlEndVariation(hLog);                                    \
                                     tlLog(hLog,dwResult | TL_VARIATION,TEXT("End Variation reported")); \
                                 }


#define ENTERTHREAD(_hLG,_szNM)  {                                                                       \
                                    LPTSTR _lpFN = _szNM;                                                \
                                    tlAddParticipant(_hLG,0,0);                                          \
                                    tlLog(_hLG,TL_CALLTREE,TEXT("Entering %s()"),(LPTSTR)_lpFN);


#define LEAVETHREAD(_hLG,_ret)                                                                           \
                                    tlLog(_hLG,TL_CALLTREE,TEXT("Exiting  %s()"),(LPTSTR)_lpFN);         \
                                    tlRemoveParticipant(_hLG);                                           \
                                    return(_ret);                                                        \
                                 }

#define LEAVETHREADVOID(_hLG)                                                                            \
                                     tlLog(_hLG,TL_CALLTREE,TEXT("Exiting  %s()"),(LPTSTR)_lpFN);        \
                                     tlRemoveParticipant(_hLG);                                          \
                                     return;                                                             \
                                 }


// Macro to report variation PASS/FAIL statistic (based on an expression)
//
#define THPRINTF                tlLog
#define TESTRESULT(expr,msg)    tlLog((expr ? L_PASS : L_FAIL),TEXT("%s"),(LPTSTR)msg);
#define TESTFAIL(msg)           TESTSEV2(msg)
#define TESTSEV1(msg)           tlLog(L_FAIL ,TEXT("%s"),(LPTSTR)msg);
#define TESTSEV2(msg)           tlLog(L_FAIL2,TEXT("%s"),(LPTSTR)msg);
#define TESTSEV3(msg)           tlLog(L_FAIL3,TEXT("%s"),(LPTSTR)msg);
#define TESTPASS(msg)           tlLog(L_PASS ,TEXT("%s"),(LPTSTR)msg);
#define TESTWARN(expr,msg)      if(expr) tlLog(L_WARN,TEXT("%s"),(LPTSTR)msg);
#define TESTBLOCK(expr,msg)     if(expr) tlLog(L_BLOCK,TEXT("%s"),(LPTSTR)msg);


#define VAR_SI          0x01                                 // Ship Issue
#define VAR_NSI         0x02                                 // Non-ship Issue
#define VAR_LI          0x03                                 // Less Important
#define VAR_ISSUE_MASK  0x03                                 // To get ship-issue bits only
#define VAR_TIMEABLE    0x04                                 // Var. used in timing suites
#define CORE_API        0x08                                 // API is in most used list
#define CORE_SI         (CORE_API | VAR_TIMEABLE | VAR_SI )  //
#define CORE_NSI        (CORE_API | VAR_TIMEABLE | VAR_NSI)  //
#define NONCORE_SI      (VAR_TIMEABLE | VAR_SI )             //
#define NONCORE_NSI     (VAR_TIMEABLE | VAR_NSI)             //



// CALLTREE Macros
//   These macros are useful for bracketing function-calls.
//
#define ENTER(_hLG,_szNM) {                                                                 \
                              LPTSTR _lpFN = _szNM;                                         \
                              tlLog(_hLG,TL_CALLTREE,TEXT("Entering %s()"),(LPTSTR)_lpFN);


#define LEAVE(_hLG,_ret)                                                                    \
                              tlLog(_hLG,TL_CALLTREE,TEXT("Exiting  %s()"),(LPTSTR)_lpFN);  \
                              return(_ret);                                                 \
                          }

#define LEAVEVOID(_hLG)                                                                     \
                              tlLog(_hLG,TL_CALLTREE,TEXT("Exiting  %s()"),(LPTSTR)_lpFN);  \
                              return;                                                       \
                          }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ocmanage\testoc\unicode\msg.h ===
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//


//
// MessageId: MSG_SURE_SELECT
//
// MessageText:
//
//  Are you sure you want to select subcomponent '%2' of component '%1'?%0
//
#define MSG_SURE_SELECT                  0x00000001L

//
// MessageId: MSG_SURE_DESELECT
//
// MessageText:
//
//  Are you sure you want to deselect subcomponent '%2' of component '%1'?%0
//
#define MSG_SURE_DESELECT                0x00000002L
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oempre\eventclear\eventclear.c ===
#include <windows.h>
#include <stdio.h>


int WINAPI
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow
    )
{
    HANDLE hEventLog;


    hEventLog = OpenEventLog( NULL, "System" );
    if (hEventLog) {
        ClearEventLog( hEventLog, NULL );
        CloseEventLog( hEventLog );
    }

    hEventLog = OpenEventLog( NULL, "Application" );
    if (hEventLog) {
        ClearEventLog( hEventLog, NULL );
        CloseEventLog( hEventLog );
    }

    hEventLog = OpenEventLog( NULL, "Security" );
    if (hEventLog) {
        ClearEventLog( hEventLog, NULL );
        CloseEventLog( hEventLog );
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oemtools\oemapply\usermod\const.h ===
#ifndef CONST_H
#define CONST_H

#include "oemshare.h"

#define 	MAXPATH 	515
#define 	AND 		&&
#define 	OR			||

#ifndef EXDEV
#define 	EXDEV		0x12
#endif

static CONST WCHAR ACTION_C_NEW_DIRECTORY = L'A';
static CONST WCHAR ACTION_C_MOVE_FILE = L'M';
static CONST WCHAR ACTION_C_EXCEPT_FILE = L'E';
static CONST WCHAR ACTION_C_NEW_ZERO_FILE = L'Z';
static CONST WCHAR ACTION_C_RENAME_FILE = L'R';
static CONST WCHAR ACTION_C_COPY_FILE = L'C';
static CONST WCHAR ACTION_C_PATCH_FILE = L'P';
static CONST WCHAR ACTION_C_NOT_PATCH_FILE = L'N';
static CONST WCHAR ACTION_C_SAVED_FILE = L'S';
static CONST WCHAR ACTION_C_DELETE_DIRECTORY = L'X';

static CONST WCHAR DIR_C_READONLY = L'R';
static CONST WCHAR DIR_C_SYSTEM = L'S';
static CONST WCHAR DIR_C_HIDDEN = L'H';
static CONST WCHAR DIR_C_COMPRESSED = L'C';
static CONST WCHAR DIR_C_ENCRYPTED = L'E';

#endif // CONST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oeminf\oeminf.c ===
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <ctype.h>
#include <string.h>

typedef int BOOL;
#define TRUE  1
#define FALSE 0

typedef struct _linklist
{
    struct _linklist *Next;
    char data[1000];
}
LINKLIST;

void trim( char * s )
{
    int n;
    char *tmp;
    int i;
    for (n=strlen(s) -1;n>=0;n--)
    {
        if ( s[n]!=' '&&s[n]!='\t'&&s[n]!='\n') break;
    }
    s[n+1]='\0';
    tmp = s;

    for( ;isspace(*tmp); tmp++);
    i=0;
    do{
        s[i]=tmp[i];
        i++;
    }
    while (s[i]!='\0');

}

void AddItem( LINKLIST **ppLinkList, char * psz )
{
    if ( *ppLinkList == NULL )
    {
        *ppLinkList = (LINKLIST *)malloc(sizeof( LINKLIST));
        if( *ppLinkList ) {
            (*ppLinkList)->Next = NULL;
            trim( psz );
            strcpy( (*ppLinkList)->data,psz );
        }
    }
    else
        AddItem ( &((*ppLinkList)->Next), psz );
}

void PrintItem( LINKLIST *pLinkList )
{
    if ( pLinkList != NULL )
    {
        printf( "%s\n", pLinkList->data);
        PrintItem( pLinkList->Next );
    }
}

void DeleteList( LINKLIST **ppLinkList )
{

    while ( *ppLinkList != NULL )
    {
        DeleteList (&((*ppLinkList)->Next));
        free (*ppLinkList);
        *ppLinkList = NULL;
    }
}


int
__cdecl
main ( int argc, char * argv[], char * envp[] )
{
    LINKLIST *Options = NULL;
    LINKLIST *OptionsText = NULL;
    LINKLIST *LLfilename = NULL;
    LINKLIST *OpenFile = NULL;
    char buf[1000];
    char platbuf[1000];
    FILE *fp;
    char OptionBuf[100];
    sprintf(OptionBuf,"[%sOptions]",argv[2]);
    AddItem( &Options, OptionBuf);
    sprintf(OptionBuf,"[%sOptionsTextENG]",argv[2]);
    AddItem( &OptionsText, OptionBuf);
    sprintf(OptionBuf,"[%sFilename]",argv[2]);
    AddItem( &LLfilename, OptionBuf);

    if ( argc > 1 )
    {
        FILE *ffilename = fopen(argv[1],"r");
        LINKLIST *tmpFile;
        if ( ffilename != NULL)
        {
            char filename[1000];
            while (fgets(filename,1000,ffilename))
            {
                AddItem(&OpenFile, filename);
            }
            fclose(ffilename);
        }
        tmpFile=OpenFile;
        while(tmpFile!= NULL )
        {
            LINKLIST *LocOptions = NULL;
            LINKLIST *LocOptionsText = NULL;
            LINKLIST *LocPlatform = NULL;
            LINKLIST *tmp = NULL;
            BOOL ffind;
            trim(tmpFile->data);
            fp = fopen(tmpFile->data,"r");
            if ( fp != NULL )
            {
                BOOL fRecordPlatform = FALSE;
                BOOL fRecordOptions = FALSE;
                BOOL fRecordOptionsText = FALSE;
                while (fgets(buf,1000,fp))
                {
                    // get the platform
                        trim(buf);
                    if (strcmp(buf,"")==0)
                    {
                        continue;
                    }
                    if ( strchr( buf, ';') != NULL )
                    {
                        continue;
                    }
                    if ( strchr( buf, '[') != NULL )
                    {
                        fRecordPlatform = FALSE;
                        fRecordOptions = FALSE;
                        fRecordOptionsText = FALSE;
                    }
                    if ( strstr( buf, "[PlatformsSupported]" ) != NULL )
                    {
                        fRecordPlatform = TRUE;
                        continue;
                    }
                    if ( strstr( buf, "[Options]" ) != NULL )
                    {
                        fRecordOptions = TRUE;
                        continue;
                    }

                    if ( strstr( buf, "[OptionsText" ) != NULL )
                    {
                        fRecordOptionsText = TRUE;
                        continue;
                    }


                    if ( fRecordPlatform)
                    {
                        AddItem(&LocPlatform, buf );
                    }
                    if ( fRecordOptions)
                    {
                        AddItem(&LocOptions, buf );
                    }
                    if ( fRecordOptionsText)
                    {
                        AddItem(&LocOptionsText, buf );
                    }
                }
                fclose(fp);

                tmp = LocPlatform;
                ffind = FALSE;
                platbuf[0]='\0';
                while  (tmp != NULL )
                {
                    if (strstr( tmp->data,argv[2]))
                    {
                        if ((strcmp( argv[2],"ISA")==0) && (strcmp(tmp->data,"EISA")==0))
                        {
                            // not mathc
                        }
                        else
                        {
                            ffind = TRUE;
                        }
                    }
tmp=tmp->Next;
                }
                if (!ffind)
                    goto NextFile;
                tmp = LocOptions;
                while  (tmp != NULL )
                {
                    AddItem(&Options,tmp->data);
                    AddItem(&LLfilename,&(tmpFile->data[2]));
                    tmp=tmp->Next;
                }
                tmp = LocOptionsText;
                while  (tmp != NULL )
                {
                    AddItem(&OptionsText,tmp->data);
                    tmp=tmp->Next;
                }
            }
NextFile:
            DeleteList(&LocOptions);
            DeleteList(&LocOptionsText);
            DeleteList(&LocPlatform);
            tmpFile = tmpFile->Next;
        }
    }
    PrintItem(Options);
    PrintItem(LLfilename);
    PrintItem(OptionsText);

    DeleteList (&Options);
    DeleteList (&OptionsText);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oemtools\oemapply\usermod\main.cpp ===
#include <stdio.h>
#include <direct.h>
#include <windows.h>

#include "patchapi.h"
#include "const.h"

BOOL IsUnicodeFile(IN HANDLE hFile);
BOOL ReadLine(IN HANDLE hFile, IN WCHAR* strLine);
BOOL CopyThisFile(IN WCHAR* strFrom, IN WCHAR* strTo);
BOOL MoveThisFile(IN WCHAR* strFrom, IN WCHAR* strTo);
BOOL PatchFile(IN WCHAR* strOldFile, IN WCHAR* strPatchFile, IN WCHAR* strNewFile);
BOOL CreateZeroFile(IN WCHAR* strFile);
BOOL CreateThisDirectory(IN WCHAR* strDirectory, IN WCHAR* strAttrib);
BOOL DeleteThisDirectory(IN WCHAR* strDirectory);

extern "C" VOID __cdecl wmain(VOID)
{
	HANDLE hScriptFile = CreateFileW(APPLY_PATCH_SCRIPT,
									GENERIC_READ,
									0,
									NULL,
									OPEN_EXISTING,
									FILE_ATTRIBUTE_NORMAL,
									NULL);
	if(hScriptFile != INVALID_HANDLE_VALUE)
	{
		if(IsUnicodeFile(hScriptFile))
		{
			// local varibles
			BOOL blnReturn = TRUE;
			WCHAR strThisLine[SUPER_LENGTH / 2];
			WCHAR* strAction = NULL;
			WCHAR strParam1[STRING_LENGTH];
			WCHAR strParam2[STRING_LENGTH];
			WCHAR strParam3[STRING_LENGTH];
			DWORD iError = 0;

			// get drive letter
			INT iDrive = _getdrive() - 1;
			if(iDrive >= 0)
			{
				strParam1[0] = strParam2[0] = strParam3[0] = (WCHAR)(L'A' + iDrive);
				strParam1[1] = strParam2[1] = strParam3[1] = L':';
				while(ReadLine(hScriptFile, strThisLine))
				{
					blnReturn = TRUE;
					strParam1[2] = strParam2[2] = strParam3[2] = 0;
					strAction = wcstok(strThisLine, SEPARATOR);
					if(strAction)
					{
						switch(strAction[0])
						{
						case ACTION_C_NEW_DIRECTORY:
							wcscpy(strParam1 + 2, wcstok(NULL, SEPARATOR));
							blnReturn = CreateThisDirectory(strParam1, wcstok(NULL, SEPARATOR));
							break;
						case ACTION_C_PATCH_FILE:
							wcscpy(strParam1 + 2, wcstok(NULL, SEPARATOR));
							wcscpy(strParam2 + 2, wcstok(NULL, SEPARATOR));
							wcscpy(strParam3 + 2, wcstok(NULL, SEPARATOR));
							blnReturn = PatchFile(strParam1, strParam2, strParam3);
							break;
						case ACTION_C_MOVE_FILE:
						case ACTION_C_EXCEPT_FILE:
						case ACTION_C_RENAME_FILE:
						case ACTION_C_NOT_PATCH_FILE:
						case ACTION_C_SAVED_FILE:
							wcscpy(strParam1 + 2, wcstok(NULL, SEPARATOR));
							wcscpy(strParam2 + 2, wcstok(NULL, SEPARATOR));
							blnReturn = MoveThisFile(strParam1, strParam2);
							break;
						case ACTION_C_COPY_FILE:
							wcscpy(strParam1 + 2, wcstok(NULL, SEPARATOR));
							wcscpy(strParam2 + 2, wcstok(NULL, SEPARATOR));
							blnReturn = CopyThisFile(strParam1, strParam2);
							break;
						case ACTION_C_NEW_ZERO_FILE:
							wcscpy(strParam1 + 2, wcstok(NULL, SEPARATOR));
							blnReturn = CreateZeroFile(strParam1);
							break;
						case ACTION_C_DELETE_DIRECTORY:
							wcscpy(strParam1 + 2, wcstok(NULL, SEPARATOR));
							blnReturn = DeleteThisDirectory(strParam1);
							break;
						default:
							blnReturn = FALSE;
							break;
						}
					}
					if(!blnReturn)
					{
						iError = GetLastError();
						switch(iError)
						{
						case ERROR_PATCH_NOT_NECESSARY:
							CopyThisFile(strParam1, strParam3);
							break;
						default:
							// some thing went wrong
							printf("warning, A=%ls, 1=%ls, 2=%ls, 3=%ls, C=%d\n", strAction, strParam1, strParam2, strParam3, iError);
							break;
						}
					}
				}
			}
		}
		CloseHandle(hScriptFile);
	}
}

BOOL IsUnicodeFile(IN HANDLE hFile)
{
	WCHAR cFirstChar = 0;
	ULONG iRead = 0;

	if(hFile != INVALID_HANDLE_VALUE &&
		ReadFile(hFile, &cFirstChar, sizeof(WCHAR), &iRead, NULL) &&
		iRead != 0 &&
		cFirstChar == UNICODE_HEAD)
	{
		return(TRUE);
	}

	return(FALSE);
}

BOOL ReadLine(IN HANDLE hFile, IN WCHAR* strLine)
{
	static WCHAR strBuffer[SUPER_LENGTH + 1];
	static LONG iLength = 0;
	static LONG iReadChar = 0;
	static ULONG iRead = 0;
	static LONG iOffset = 0;
	static LONG iThisLineLength = 0;
	static WCHAR* strThisLine = NULL;

	if(iLength > 0)
	{
		// char 0xA is set to 0
		strThisLine = wcstok(strBuffer + iReadChar - iLength, CRETURN);
		iThisLineLength = wcslen(strThisLine);
		if(iThisLineLength + 1 <= iLength)
		{
			// char 0xD is set to 0
			strThisLine[iThisLineLength - 1] = 0;
			wcscpy(strLine, strThisLine);
			iLength = iLength - iThisLineLength - 1;
		}
		else
		{
			wcsncpy(strLine, strThisLine, iLength);
			// set the last char + 1 to 0 for cat
			strLine[iLength] = 0;
			if(iLength <= 0 || strLine[iLength - 1] != ENDOFLINE[0])
			{
				ReadFile(hFile, strBuffer, SUPER_LENGTH * sizeof(WCHAR), &iRead, NULL);
				iReadChar = iRead / sizeof(WCHAR);
				// char 0xA is set to 0
				strThisLine = wcstok(strBuffer, CRETURN);
				iThisLineLength = wcslen(strThisLine);
				iLength = iReadChar - iThisLineLength - 1;
				// char 0xD is set to 0
				strThisLine[iThisLineLength - 1] = 0;
				wcscat(strLine, strThisLine);
				if(strBuffer[0] == CRETURN[0])
				{
					iLength -= 1;
				}
			}
			else
			{
				strLine[iLength - 1] = 0;
				iLength = 0;
			}
		}
	}
	else
	{
		if(ReadFile(hFile, strBuffer, SUPER_LENGTH * sizeof(WCHAR), &iRead, NULL) && iRead != 0)
		{
			iReadChar = iRead / sizeof(WCHAR);
			// char 0xA is set to 0
			strThisLine = wcstok(strBuffer, CRETURN);
			iThisLineLength = wcslen(strThisLine);
			iLength = iReadChar - iThisLineLength - 1;
			// char 0xD is set to 0
			strThisLine[iThisLineLength - 1] = 0;
			wcscpy(strLine, strThisLine);
			if(strBuffer[0] == CRETURN[0])
			{
				iLength -= 1;
			}
		}
		else
		{
			return(FALSE);
		}
	}

	return(TRUE);
}

BOOL CopyThisFile(IN WCHAR* strFrom, IN WCHAR* strTo)
{
	BOOL blnReturn = TRUE;

	blnReturn = CopyFileW(strFrom, strTo, TRUE);

	return(blnReturn);
}

BOOL MoveThisFile(IN WCHAR* strFrom, IN WCHAR* strTo)
{
	BOOL blnReturn = FALSE;
	DWORD iAttrib = GetFileAttributesW(strFrom);

	if(iAttrib != 0xFFFFFFFF)
	{
		blnReturn = SetFileAttributesW(strFrom, FILE_ATTRIBUTE_ARCHIVE);
		blnReturn &= MoveFileW(strFrom, strTo);
		blnReturn &= SetFileAttributesW(strTo, iAttrib);
	}

	return(blnReturn);
}

BOOL CreateZeroFile(IN WCHAR* strFile)
{
	BOOL blnReturn = TRUE;

	HANDLE hFile = CreateFileW(strFile,
							GENERIC_READ | GENERIC_WRITE,
							0, NULL,
							CREATE_ALWAYS,
							FILE_ATTRIBUTE_NORMAL,
							NULL);
	if((blnReturn = (hFile != INVALID_HANDLE_VALUE)) == TRUE)
	{
		CloseHandle(hFile);
	}

	return(blnReturn);
}

BOOL PatchFile(IN WCHAR* strOldFile, IN WCHAR* strPatchFile, IN WCHAR* strNewFile)
{
	BOOL blnReturn = TRUE;

	blnReturn = ApplyPatchToFileW(strPatchFile,
								strOldFile,
								strNewFile,
								0);

	return(blnReturn);
}

BOOL CreateThisDirectory(IN WCHAR* strDirectory, IN WCHAR* strAttrib)
{
	BOOL blnReturn = TRUE;

	blnReturn = (_wmkdir(strDirectory) == 0 || errno == 17 /*EEXIST*/);
	if(blnReturn && strAttrib)
	{
		DWORD iAttrib = 0;
		for(UINT i = 0; i < wcslen(strAttrib); i++)
		{
			switch(strAttrib[i])
			{
			case DIR_C_READONLY:
				iAttrib |= FILE_ATTRIBUTE_READONLY;
				break;
			case DIR_C_SYSTEM:
				iAttrib |= FILE_ATTRIBUTE_SYSTEM;
				break;
			case DIR_C_HIDDEN:
				iAttrib |= FILE_ATTRIBUTE_HIDDEN;
				break;
			case DIR_C_COMPRESSED:
				iAttrib |= FILE_ATTRIBUTE_COMPRESSED;
				break;
			case DIR_C_ENCRYPTED:
				iAttrib |= FILE_ATTRIBUTE_ENCRYPTED;
				break;
			default:
				break;
			}
		}
		SetFileAttributesW(strDirectory, iAttrib);
	}

	return(blnReturn);
}

BOOL DeleteThisDirectory(IN WCHAR* strDirectory)
{
	INT length = 0;
	BOOL result = TRUE;
	HANDLE findHandle = INVALID_HANDLE_VALUE;
	WIN32_FIND_DATAW file;
	WCHAR path[MAXPATH + 7];

	if((length = wcslen(strDirectory)) > MAXPATH)
	{
		result = FALSE;
		goto done;
	}
	wcscpy(path, strDirectory);

	if(length)
	{
		if((path[length - 1] != '\\') AND (path[length - 1] != ':'))
		{
			wcscpy(path + length, L"\\");
			length++;
		}
	}

	wcscpy(path + length, L"*.*");
	findHandle = FindFirstFileW(path, &file);
	if(findHandle == INVALID_HANDLE_VALUE)
	{
		result = FALSE;
	}
	path[length] = L'\0';

	while(result)
	{
		if((file.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == FILE_ATTRIBUTE_DIRECTORY &&
			wcscmp(file.cFileName, L".") != 0 &&
			wcscmp(file.cFileName, L"..") != 0)
		{
			/* recursively going into this directory */
			wcscpy(path + length, file.cFileName);
			DeleteThisDirectory(path);
		}
		else
		{
			wcscpy(path + length, file.cFileName);
			if(!DeleteFileW(path))
			{
				SetFileAttributesW(path, FILE_ATTRIBUTE_ARCHIVE);
				DeleteFileW(path);
			}
		}
		path[length] = 0;
		if(!FindNextFileW(findHandle, &file))
		{
			result = FALSE;
		}
	}

	/* All files are examed, close the findhandle */
	if(findHandle != INVALID_HANDLE_VALUE)
	{
		FindClose(findHandle);
		findHandle = INVALID_HANDLE_VALUE;
	}

done:

	/* finally remove the directory */
	return(RemoveDirectoryW(path));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\ocmanage\testoc\octest\inf\auto.cpp ===
#include <iostream.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


#include <windows.h>
#include <winbase.h>

const DWORD MaxStrLength = 256;
const char ComponentSectionTitle[] = "[Components]";

/*++

Description:

  Program to do setup testing automatically

Argument:

  argv[1]: test case directory
  argv[2]: Windows NT installation directory, where server is to be installed
  argv[3]: generate the test case from a standalone test case

Return value:
  None

--*/

void main(int argc, char *argv[])
{
	bool bFromStandalone;
	char pchTestCaseDir[MaxStrLength];
	char pchNTDir[MaxStrLength];

	char pchOcFileName[MaxStrLength];
	char pchSysocFileName[MaxStrLength];

	LPSTR lpBuffer;

	if (argc != 3 && argc != 4){
		cout << "Usage: " << argv[0] << " TestCaseDir NTDir IfFromStandalone" << endl;
		exit(1);
	}

	if (argc == 4){
		bFromStandalone = true;
		cout << "Start test from a standalone test case is not supported yet" << endl;
	}
	else{
		bFromStandalone = false;
	}

	// Now we need to form an absolute path.
	// It is assumed that test case directory is relative to the current directory
	// and NT directory is an absolute path

	strcpy(pchNTDir, argv[2]);
	strcpy(pchTestCaseDir, argv[1]);

	if (pchNTDir[strlen(pchNTDir)-1] == '\\'){
		strcat(pchNTDir, "system32\\");
	}
	else{
		strcat(pchNTDir, "\\system32\\");
	}

	lpBuffer = (LPSTR)malloc(sizeof(char) * MaxStrLength);
	
	GetCurrentDirectory(MaxStrLength, lpBuffer);

	if (lpBuffer[strlen(lpBuffer) - 1] != '\\'){
		strcat(lpBuffer, "\\");
	}

	strcat(lpBuffer, pchTestCaseDir);
	
	strcpy(pchTestCaseDir, lpBuffer);

	free(lpBuffer);

	if (pchTestCaseDir[strlen(pchTestCaseDir) - 1] != '\\'){
		strcat(pchTestCaseDir, "\\");
	}

	// Now we will open oc.inf from test directory
	// and sysoc.inf from NT directory
	// and put something from oc.inf into sysoc.inf

	strcpy(pchOcFileName, pchTestCaseDir);
	strcat(pchOcFileName, "oc.inf");

	strcpy(pchSysocFileName, pchNTDir);
	strcat(pchSysocFileName, "sysoc.inf");
	
	FILE *pfSysoc, *pfOc, *pfTemp;

	if ((pfSysoc = fopen(pchSysocFileName, "r")) == NULL){
		cout << "Error opening sysoc.inf " << endl;
	 	exit(1);
	}

	if ((pfOc = fopen(pchOcFileName, "r")) == NULL){
		cout << "Error opening oc.inf " << endl;
		exit(1);
	}

	if ((pfTemp = fopen("temp.inf", "w")) == NULL){
		cout << "Error opening temp.inf " << endl;
		exit(1);
	}

	char pchOcLine[MaxStrLength];
	char pchSysocLine[MaxStrLength];	

	bool bNotFound = true;

	while (fgets(pchSysocLine, MaxStrLength, pfSysoc) != NULL){

		fputs(pchSysocLine, pfTemp);


		if (strstr(pchSysocLine, ComponentSectionTitle) != NULL){
			// Read from oc.inf and paste important information
			bNotFound = true;

			while (fgets(pchOcLine, MaxStrLength, pfOc) != NULL){
				if (bNotFound){
					if (strstr(pchOcLine, ComponentSectionTitle) == NULL){
						continue;
					}
					else{
						bNotFound = false;
					}
				}
				else{
					if (pchOcLine[0] != '['){
						fputs(pchOcLine, pfTemp);
					}
					else{
						bNotFound = true;
					}
				}
			}
			fclose(pfOc);
		}
	}

	fclose(pfSysoc);
	fclose(pfTemp);

	// Now copy the temporary file onto sysoc.inf

	char pchCmdLine[MaxStrLength];

	sprintf(pchCmdLine, "copy temp.inf %s /Y", pchSysocFileName);
	system(pchCmdLine);

	system("del temp.inf");

	// We are now done with the file stuff
	// We will begin copying files

	sprintf(pchCmdLine, "copy %s*.dll %s /Y", pchTestCaseDir, pchNTDir);
	system(pchCmdLine);

	// We will assume it is not from a standalone.
	//if (!bFromStandalone || true){
		sprintf(pchCmdLine, "copy %s*.inf %s /Y", pchTestCaseDir, pchNTDir);
		system(pchCmdLine);
	//}
	
	exit(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oemtools\oemapply\ntnative\const.h ===
#ifndef CONST_H
#define CONST_H

#include "oemshare.h"

#define 	MAXPATH 	515
#define 	AND 		&&
#define 	OR			||

#ifndef EXDEV
#define 	EXDEV		0x12
#endif

static CONST WCHAR ACTION_C_NEW_DIRECTORY = L'A';
static CONST WCHAR ACTION_C_MOVE_FILE = L'M';
static CONST WCHAR ACTION_C_EXCEPT_FILE = L'E';
static CONST WCHAR ACTION_C_NEW_ZERO_FILE = L'Z';
static CONST WCHAR ACTION_C_RENAME_FILE = L'R';
static CONST WCHAR ACTION_C_COPY_FILE = L'C';
static CONST WCHAR ACTION_C_PATCH_FILE = L'P';
static CONST WCHAR ACTION_C_NOT_PATCH_FILE = L'N';
static CONST WCHAR ACTION_C_SAVED_FILE = L'S';
static CONST WCHAR ACTION_C_DELETE_DIRECTORY = L'X';

static CONST WCHAR DIR_C_READONLY = L'R';
static CONST WCHAR DIR_C_SYSTEM = L'S';
static CONST WCHAR DIR_C_HIDDEN = L'H';
static CONST WCHAR DIR_C_COMPRESSED = L'C';
static CONST WCHAR DIR_C_ENCRYPTED = L'E';

#endif // CONST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oemtools\oemapply\ntnative\main.cpp ===
#include <ntos.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntosdef.h>
#include <ntioapi.h>
#include <ntstatus.h>

#include <stdlib.h>

#include <windef.h>

#include "patchapi.h"
#include "const.h"

VOID NtGetParameter(IN INT iTh, IN WCHAR* strLine,
					OUT WCHAR* strParam, IN WCHAR cLimit);
BOOL NtIsUnicodeFile(IN HANDLE hFile);
BOOL NtReadLine(IN HANDLE hFile, OUT WCHAR* strLine);
BOOL NtCopyThisFile(IN WCHAR* strFrom, IN WCHAR* strTo,
					IN BOOL blnDeleteFrom);
BOOL NtPatchFile(IN WCHAR* strOldFile, IN WCHAR* strPatchFile,
				 IN WCHAR* strNewFile);
BOOL NtCreateZeroFile(IN WCHAR* strFile);
BOOL NtCreateThisDirectory(IN WCHAR* strDirectory, IN WCHAR* strAttrib);
BOOL NtDeleteThisDirectory(IN WCHAR* strDirectory);

///////////////////////////////////////////////////////////////////////////////
//
// main, the entry point for the OEMApply tool, it opens up the script file and
//       read it line by line.  Each line tells the tool what to do.
// 
// Parameters:
//
//   none
//
// Return:
//
//   none
//
///////////////////////////////////////////////////////////////////////////////
extern "C" VOID __cdecl main(VOID)
{
	OBJECT_ATTRIBUTES myFileObject;
	HANDLE hScriptFile = NULL;
	IO_STATUS_BLOCK statusScriptFile;
	UNICODE_STRING strScriptFile;

	// initialize the filename and so on
	strScriptFile.Length = wcslen(APPLY_PATCH_SCRIPT) + 1;
    strScriptFile.MaximumLength = strScriptFile.Length;
	strScriptFile.Buffer = (USHORT*)APPLY_PATCH_SCRIPT;

	InitializeObjectAttributes(&myFileObject,
							&strScriptFile,
							OBJ_EXCLUSIVE,
							NULL,
							NULL);

	// open the script file, remove the file when we are done
	if(NtCreateFile(&hScriptFile,
					FILE_READ_DATA | DELETE | SYNCHRONIZE,
					&myFileObject,
					&statusScriptFile,
					NULL,
					FILE_ATTRIBUTE_NORMAL,
					FILE_SHARE_READ,
					FILE_OPEN,
					FILE_DELETE_ON_CLOSE | FILE_SYNCHRONOUS_IO_NONALERT,
					NULL,
					0) == STATUS_SUCCESS)
	{
		// script file should be to be unicoded
		if(NtIsUnicodeFile(hScriptFile))
		{
			// local varibles
			BOOL blnReturn = TRUE;
			WCHAR strThisLine[SUPER_LENGTH / 2];
			WCHAR strAction[LANGUAGE_LENGTH];
			WCHAR strParam1[STRING_LENGTH];
			WCHAR strParam2[STRING_LENGTH];
			WCHAR strParam3[STRING_LENGTH];

			// get a line from the script file in strThisLine, strThisLine is
			// NULL terminated with no end of line or carriage return
			while(NtReadLine(hScriptFile, strThisLine))
			{
				blnReturn = TRUE;
				// get the first token from strThisLine, strThisLine is
				// not changed by NtGetParameter, all filenames are of
				// full path
				NtGetParameter(1, strThisLine, strAction, SEPARATOR[0]);
				switch(strAction[0])
				{
				case ACTION_C_NEW_DIRECTORY:
					// get directory name
					NtGetParameter(2, strThisLine,
						strParam1, SEPARATOR[0]);
					// get directory attributes, can be NULL
					NtGetParameter(3, strThisLine,
						strParam2, SEPARATOR[0]);
					blnReturn = NtCreateThisDirectory(strParam1,
													strParam2);
					break;
				case ACTION_C_PATCH_FILE:
					// get the old filename
					NtGetParameter(2, strThisLine,
						strParam1, SEPARATOR[0]);
					// get the patch filename
					NtGetParameter(3, strThisLine,
						strParam2, SEPARATOR[0]);
					// get the new filename
					NtGetParameter(4, strThisLine,
						strParam3, SEPARATOR[0]);
					blnReturn = NtPatchFile(strParam1,
											strParam2,
											strParam3);
					break;
				case ACTION_C_MOVE_FILE:
				case ACTION_C_EXCEPT_FILE:
				case ACTION_C_RENAME_FILE:
				case ACTION_C_NOT_PATCH_FILE:
				case ACTION_C_SAVED_FILE:
					// get the old filename
					NtGetParameter(2, strThisLine,
						strParam1, SEPARATOR[0]);
					// get the new filename
					NtGetParameter(3, strThisLine,
						strParam2, SEPARATOR[0]);
					// delete the old file once we are done
					blnReturn = NtCopyThisFile(strParam1, strParam2,
						TRUE);
					break;
				case ACTION_C_COPY_FILE:
					// get the old filename
					NtGetParameter(2, strThisLine,
						strParam1, SEPARATOR[0]);
					// get the new filename
					NtGetParameter(3, strThisLine,
						strParam2, SEPARATOR[0]);
					// do not remove the old file
					blnReturn = NtCopyThisFile(strParam1, strParam2,
						FALSE);
					break;
				case ACTION_C_NEW_ZERO_FILE:
					// get the filename
					NtGetParameter(2, strThisLine,
						strParam1, SEPARATOR[0]);
					blnReturn = NtCreateZeroFile(strParam1);
					break;
				case ACTION_C_DELETE_DIRECTORY:
					// get the directory name
					NtGetParameter(2, strThisLine,
						strParam1, SEPARATOR[0]);
					blnReturn = NtDeleteThisDirectory(strParam1);
					break;
				default:
					break;
				}
				if(!blnReturn)
				{
					// some thing went wrong
					DbgPrint("warning, A=%ls, 1=%ls, 2=%ls, 3=%ls\n", strAction, strParam1, strParam2, strParam3);
				}
			}
		}
		NtClose(hScriptFile);
	}
}

///////////////////////////////////////////////////////////////////////////////
//
// NtGetParameter, essentially a wcstok function, returns the iTh token
//                 separated by cLimit in strParam, if the token is not found,
//                 strParam is of 0 length, strLine is unchanged
// 
// Parameters:
//
//   iTh, the nTh token
//   strLine, the line of characters that the token is taken from
//   strParam, the returned token
//   cLimit, the character the separates the tokens
//
// Return:
//
//   none
//
///////////////////////////////////////////////////////////////////////////////
VOID NtGetParameter(IN INT iTh, IN WCHAR* strLine,
					OUT WCHAR* strParam, IN WCHAR cLimit)
{
	INT iCount = 0;
	INT iPrevCount = 0;
	INT iEncounter = 0;
	INT iLength = 0;

	if(iTh > 0 && strLine && strParam)
	{
		while(strLine[iCount] != 0)
		{
			if(strLine[iCount] == cLimit)
			{
				// just like the real wcstok, ignores the first token separator
				if(iCount != 0)
				{
					iEncounter += 1;
				}
				if(iEncounter == iTh)
				{
					break;
				}
				iPrevCount = iCount + 1;
			}
			iCount += 1;
		}
		// two conditions for successful return
		// 1. the token is found
		// 2. reached the end of line, and this is the token we want
		if(iEncounter == iTh || iEncounter + 1 == iTh)
		{
			iLength = iCount - iPrevCount;
			wcsncpy(strParam, strLine + iPrevCount, iLength);
			strParam[iLength] = 0;
		}
		else
		{
			// zero out the return token if token is not found
			strParam[0] = 0;
		}
	}
}

///////////////////////////////////////////////////////////////////////////////
//
// NtIsUnicodeFile, test to see if the file is unicoded by reading the first 2
//                  bytes, should be FEFF, the file position is moved for next
//                  read
// 
// Parameters:
//
//   hFile, the file handle to read from
//
// Return:
//
//   TRUE if the first 2 bytes matches, FALSE otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL NtIsUnicodeFile(IN HANDLE hFile)
{
	WCHAR cFirstChar = 0;
	IO_STATUS_BLOCK ioBlock;

	// read the first 2 bytes
	if(NtReadFile(hFile, 
				NULL,
				NULL,
				NULL,
				&ioBlock,
				&cFirstChar,
				sizeof(WCHAR),
				NULL,
				NULL) &&
		cFirstChar == UNICODE_HEAD)
	{
		return(TRUE);
	}

	return(FALSE);
}

///////////////////////////////////////////////////////////////////////////////
//
// NtReadLine, reads a line from hFile, each line in hFile is expected to be
//             terminated by 0xD and 0xA, the line will be returned in strLine,
//             with 0xD and 0xA removed
// 
// Parameters:
//
//   hFile, the file handle to read from
//   strLine, the buffer to store the line
//
// Return:
//
//   TRUE if the strLine contains a valid line, FALSE for end of file
//
///////////////////////////////////////////////////////////////////////////////
BOOL NtReadLine(IN HANDLE hFile, OUT WCHAR* strLine)
{
	static WCHAR strBuffer[SUPER_LENGTH + 1];
	static LONG iLength = 0;
	static LONG iReadChar = 0;
	static LONG iOffset = 0;
	static LONG iThisLineLength = 0;
	static WCHAR strThisLine[SUPER_LENGTH / 2];
	static IO_STATUS_BLOCK ioBlock;

	if(iLength > 0)
	{
		NtGetParameter(1, strBuffer + iReadChar - iLength,
			strThisLine, CRETURN[0]);
		iThisLineLength = wcslen(strThisLine);
		if(iThisLineLength + 1 <= iLength)
		{
			// char 0xD is set to 0
			strThisLine[iThisLineLength - 1] = 0;
			wcscpy(strLine, strThisLine);
			iLength = iLength - iThisLineLength - 1;
		}
		else
		{
			wcsncpy(strLine, strThisLine, iLength);
			// set the last char + 1 to 0 for cat
			strLine[iLength] = 0;
			if(iLength <= 0 || strLine[iLength - 1] != ENDOFLINE[0])
			{
				NtReadFile(hFile, NULL,	NULL, NULL,	&ioBlock, strBuffer,
					SUPER_LENGTH * sizeof(WCHAR), NULL, NULL);
				iReadChar = ioBlock.Information / sizeof(WCHAR);
				NtGetParameter(1, strBuffer,
					strThisLine, CRETURN[0]);
				iThisLineLength = wcslen(strThisLine);
				iLength = iReadChar - iThisLineLength - 1;
				// char 0xD is set to 0
				strThisLine[iThisLineLength - 1] = 0;
				wcscat(strLine, strThisLine);
				if(strBuffer[0] == CRETURN[0])
				{
					iLength -= 1;
				}
			}
			else
			{
				strLine[iLength - 1] = 0;
				iLength = 0;
			}
		}
	}
	else
	{
		if(NtReadFile(hFile, NULL,	NULL, NULL,	&ioBlock, strBuffer,
				SUPER_LENGTH * sizeof(WCHAR), NULL, NULL) == STATUS_SUCCESS &&
				ioBlock.Information != 0)
		{
			iReadChar = ioBlock.Information / sizeof(WCHAR);
			NtGetParameter(1, strBuffer,
				strThisLine, CRETURN[0]);
			iThisLineLength = wcslen(strThisLine);
			iLength = iReadChar - iThisLineLength - 1;
			// char 0xD is set to 0
			strThisLine[iThisLineLength - 1] = 0;
			wcscpy(strLine, strThisLine);
			if(strBuffer[0] == CRETURN[0])
			{
				iLength -= 1;
			}
		}
		else
		{
			return(FALSE);
		}
	}

	return(TRUE);
}

///////////////////////////////////////////////////////////////////////////////
//
// NtCopyThisFile, copies a file to another location, depending on
//                 blnDeleteFrom, the old file can be deleted
// 
// Parameters:
//
//   strFrom, the old filename, full path
//   strTo, the new filename, full path
//   blnDeleteFrom, delete the old file?
//
// Return:
//
//   TRUE for file copied successfully, FALSE otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL NtCopyThisFile(IN WCHAR* strFrom, IN WCHAR* strTo, IN BOOL blnDeleteFrom)
{
	BOOL blnReturn = FALSE;
	BYTE byteBuffer[1024];
	ULONG iCreateOptions = 0;
	ULONG iDesireAccess = 0;

	// set the options to delete the old file
	if(blnDeleteFrom)
	{
		iCreateOptions = FILE_DELETE_ON_CLOSE;
		iDesireAccess = DELETE;
	}

	OBJECT_ATTRIBUTES myFileReadObject;
	OBJECT_ATTRIBUTES myFileWriteObject;

	HANDLE hReadFile = NULL;
	HANDLE hWriteFile = NULL;

	IO_STATUS_BLOCK statusReadFile;
	IO_STATUS_BLOCK statusWriteFile;

	UNICODE_STRING strReadFile;
	UNICODE_STRING strWriteFile;

	IO_STATUS_BLOCK statusReadInfoFile;
	FILE_BASIC_INFORMATION infoReadFile;
	IO_STATUS_BLOCK ioReadBlock;
	IO_STATUS_BLOCK ioWriteBlock;

	strReadFile.Length = wcslen(strFrom) + 1;
    strReadFile.MaximumLength = strReadFile.Length;
	strReadFile.Buffer = strFrom;

	strReadFile.Length = wcslen(strTo) + 1;
    strReadFile.MaximumLength = strReadFile.Length;
	strReadFile.Buffer = strTo;

	InitializeObjectAttributes(&myFileReadObject,
							&strReadFile,
							OBJ_EXCLUSIVE,
							NULL,
							NULL);

	InitializeObjectAttributes(&myFileWriteObject,
							&strWriteFile,
							OBJ_EXCLUSIVE,
							NULL,
							NULL);

	// open the old file to read
	if(NtCreateFile(&hReadFile,
					FILE_READ_DATA | SYNCHRONIZE | FILE_READ_ATTRIBUTES |
					iDesireAccess,
					&myFileReadObject,
					&statusReadFile,
					NULL,
					FILE_ATTRIBUTE_NORMAL,
					FILE_SHARE_READ,
					FILE_OPEN,
					FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT |
					iCreateOptions,
					NULL,
					0) == STATUS_SUCCESS)
	{
		// get the old file's attributes
		if(NtQueryInformationFile(hReadFile,
					&statusReadInfoFile,
					&infoReadFile,
					sizeof(FILE_BASIC_INFORMATION),
					FileBasicInformation) == STATUS_SUCCESS)
		{
			// create the new file with old file's attributes
			if(NtCreateFile(&hWriteFile,
						FILE_WRITE_DATA | SYNCHRONIZE | FILE_WRITE_ATTRIBUTES,
						&myFileWriteObject,
						&statusWriteFile,
						NULL,
						infoReadFile.FileAttributes,
						0,
						FILE_CREATE,
						FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
						NULL,
						0) == STATUS_SUCCESS)
			{
				blnReturn = TRUE;
				// read from the old file and write to the new file
				while(NtReadFile(hReadFile,
								NULL, NULL, NULL,
								&ioReadBlock,
								byteBuffer,
								1024, NULL, NULL) == STATUS_SUCCESS && 
								ioReadBlock.Information != 0 && blnReturn)
				{
					// make sure that write is successful
					blnReturn = (NtWriteFile(hWriteFile,
											NULL, NULL, NULL,
											&ioWriteBlock,
											byteBuffer,
											ioReadBlock.Information,
											NULL, NULL) == STATUS_SUCCESS &&
						ioWriteBlock.Information == ioReadBlock.Information);
				}
				NtClose(hWriteFile);
			}
		}
		NtClose(hReadFile);
	}

	return(blnReturn);
}

///////////////////////////////////////////////////////////////////////////////
//
// NtCreateZeroFile, creates a zero length file
// 
// Parameters:
//
//   strFile, the filename, full path
//
// Return:
//
//   TRUE for file created successfully, FALSE otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL NtCreateZeroFile(IN WCHAR* strFile)
{
	BOOL blnReturn = FALSE;
	HANDLE hFile = NULL;

	OBJECT_ATTRIBUTES myFileObject;
	IO_STATUS_BLOCK statusFile;
	UNICODE_STRING strUniFile;

	strUniFile.Length = wcslen(strFile) + 1;
    strUniFile.MaximumLength = strUniFile.Length;
	strUniFile.Buffer = strFile;

	InitializeObjectAttributes(&myFileObject,
							&strUniFile,
							OBJ_EXCLUSIVE,
							NULL,
							NULL);

	if(NtCreateFile(&hFile,
				FILE_WRITE_DATA | SYNCHRONIZE | FILE_WRITE_ATTRIBUTES,
				&myFileObject,
				&statusFile,
				NULL,
				FILE_ATTRIBUTE_NORMAL,
				0,
				FILE_CREATE,
				FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT,
				NULL,
				0) == STATUS_SUCCESS)
	{
		blnReturn = TRUE;
		NtClose(hFile);
	}

	return(blnReturn);
}

///////////////////////////////////////////////////////////////////////////////
//
// NtPatchFile, create the new file from the patch file
// 
// Parameters:
//
//   strOldFile, the old filename, full path
//   strPatchFile, the patch filename, full path
//   strNewFile, the new filename, full path
//
// Return:
//
//   TRUE for file created successfully, FALSE otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL NtPatchFile(IN WCHAR* strOldFile,
				 IN WCHAR* strPatchFile,
				 IN WCHAR* strNewFile)
{
	BOOL blnReturn = TRUE;

	blnReturn = ApplyPatchToFileW(strPatchFile,
								strOldFile,
								strNewFile,
								0);

	return(blnReturn);
}

///////////////////////////////////////////////////////////////////////////////
//
// NtCreateThisDirectory, create a directory
// 
// Parameters:
//
//   strDirectory, the name of the directory, full path
//   strAttrib, the attributes of the directory
//
// Return:
//
//   TRUE for directory created successfully, FALSE otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL NtCreateThisDirectory(IN WCHAR* strDirectory, IN WCHAR* strAttrib)
{
	BOOL blnReturn = FALSE;
	HANDLE hDirectory = NULL;

	OBJECT_ATTRIBUTES myDirectoryObject;
	IO_STATUS_BLOCK statusDirectory;
	UNICODE_STRING strUniDirectory;

	strUniDirectory.Length = wcslen(strDirectory) + 1;
    strUniDirectory.MaximumLength = strUniDirectory.Length;
	strUniDirectory.Buffer = strDirectory;

	InitializeObjectAttributes(&myDirectoryObject,
							&strUniDirectory,
							OBJ_EXCLUSIVE,
							NULL,
							NULL);

	// create the directory
	if(NtCreateFile(&hDirectory,
				FILE_WRITE_DATA | SYNCHRONIZE | FILE_WRITE_ATTRIBUTES,
				&myDirectoryObject,
				&statusDirectory,
				NULL,
				FILE_ATTRIBUTE_NORMAL,
				0,
				FILE_CREATE,
				FILE_DIRECTORY_FILE,
				NULL,
				0) == STATUS_SUCCESS)
	{
		blnReturn = TRUE;
	}

	if(blnReturn)
	{
		DWORD iAttrib = FILE_ATTRIBUTE_NORMAL;
		LARGE_INTEGER iLargeInt;
		FILE_BASIC_INFORMATION infoDirectory;

		// look through the attributes
		for(UINT i = 0; i < wcslen(strAttrib); i++)
		{
			switch(strAttrib[i])
			{
			case DIR_C_READONLY:
				iAttrib |= FILE_ATTRIBUTE_READONLY;
				break;
			case DIR_C_SYSTEM:
				iAttrib |= FILE_ATTRIBUTE_SYSTEM;
				break;
			case DIR_C_HIDDEN:
				iAttrib |= FILE_ATTRIBUTE_HIDDEN;
				break;
			case DIR_C_COMPRESSED:
				iAttrib |= FILE_ATTRIBUTE_COMPRESSED;
				break;
			case DIR_C_ENCRYPTED:
				iAttrib |= FILE_ATTRIBUTE_ENCRYPTED;
				break;
			default:
				break;
			}
		}
		NtQuerySystemTime(&iLargeInt);
		
		// set the information struct
		infoDirectory.CreationTime = iLargeInt;
		infoDirectory.LastAccessTime = iLargeInt;
		infoDirectory.LastWriteTime = iLargeInt;
		infoDirectory.ChangeTime = iLargeInt;
		infoDirectory.FileAttributes = iAttrib;

		// set the attributes
		blnReturn = (NtSetInformationFile(hDirectory, 
							&statusDirectory,
							&infoDirectory,
							sizeof(FILE_BASIC_INFORMATION),
							FileBasicInformation) == STATUS_SUCCESS);

		NtClose(hDirectory);
	}

	return(blnReturn);
}

///////////////////////////////////////////////////////////////////////////////
//
// NtDeleteThisDirectory, deletes the directory recursively
// 
// Parameters:
//
//   strDirectory, the name of the directory, full path
//   strAttrib, the attributes of the directory
//
// Return:
//
//   TRUE for directory removed, FALSE otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL NtDeleteThisDirectory(IN WCHAR* strDirectory)
{
	INT length = 0;
	NTSTATUS result;
	WCHAR path[MAXPATH + 7];

	HANDLE hVddHeap = NULL;

	HANDLE hFindFile = NULL;
	OBJECT_ATTRIBUTES myFileObject;
	IO_STATUS_BLOCK IoStatusBlock;
	UNICODE_STRING strUniFile;

	PFILE_BOTH_DIR_INFORMATION DirectoryInfo = NULL;

	// adding the trailing '\'
	if((length = wcslen(strDirectory)) > MAXPATH)
	{
		return FALSE;
	}
	wcscpy(path, strDirectory);

	if(length)
	{
		if((path[length - 1] != '\\') AND (path[length - 1] != ':'))
		{
			wcscpy(path + length, L"\\");
			length++;
		}
	}

	strUniFile.Length = length;
    strUniFile.MaximumLength = strUniFile.Length;
	strUniFile.Buffer = strDirectory;

	InitializeObjectAttributes(&myFileObject,
							&strUniFile,
							OBJ_EXCLUSIVE,
							NULL,
							NULL);

	// allocate memory for the directory info struct used to get files from
	// the directory
	DirectoryInfo = (PFILE_BOTH_DIR_INFORMATION)RtlAllocateHeap(
							RtlProcessHeap(),
							0,
							MAX_PATH * sizeof(WCHAR) + 
							sizeof(FILE_BOTH_DIR_INFORMATION));

	// open the directory
	if(DirectoryInfo != NULL &&
		NtCreateFile(&hFindFile,
				FILE_LIST_DIRECTORY | SYNCHRONIZE | DELETE,
				&myFileObject,
				&IoStatusBlock,
				NULL,
				FILE_ATTRIBUTE_NORMAL,
				FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
				FILE_OPEN,
				FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT |
				FILE_DELETE_ON_CLOSE,
				NULL,
				0) == STATUS_SUCCESS)
	{
		// get a file
		result = NtQueryDirectoryFile(hFindFile,
							NULL,
							NULL,
							NULL,
							&IoStatusBlock,
							DirectoryInfo,
							(MAX_PATH * sizeof(WCHAR) +
							sizeof(FILE_BOTH_DIR_INFORMATION)),
							FileBothDirectoryInformation,
							TRUE,
							NULL,
							TRUE);

		while(result == STATUS_SUCCESS)
		{
			ULONG iLengthFull = DirectoryInfo->FileNameLength / sizeof(WCHAR);
			DirectoryInfo->FileName[iLengthFull] = 0;
			if((DirectoryInfo->FileAttributes & FILE_ATTRIBUTE_DIRECTORY) ==
				FILE_ATTRIBUTE_DIRECTORY && 
				wcscmp(DirectoryInfo->ShortName, L"." ) != 0 &&
				wcscmp(DirectoryInfo->ShortName, L"..") != 0)
			{
				// the file is a directory
				NtDeleteThisDirectory(DirectoryInfo->FileName);
			}
			else
			{
				// the file is a file
				HANDLE hFindFileFile = NULL;
				OBJECT_ATTRIBUTES myFileFileObject;
				IO_STATUS_BLOCK FileIoStatusBlock;
				UNICODE_STRING strUniFileFile;

				strUniFileFile.Length = (USHORT)iLengthFull;
				strUniFileFile.MaximumLength = strUniFile.Length;
				strUniFileFile.Buffer = DirectoryInfo->FileName;

				InitializeObjectAttributes(&myFileFileObject,
										&strUniFileFile,
										OBJ_EXCLUSIVE,
										NULL,
										NULL);

				if(NtCreateFile(&hFindFileFile,
						SYNCHRONIZE | DELETE,
						&myFileFileObject,
						&FileIoStatusBlock,
						NULL,
						FILE_ATTRIBUTE_NORMAL,
						0,
						FILE_OPEN,
						FILE_SYNCHRONOUS_IO_NONALERT | FILE_DELETE_ON_CLOSE,
						NULL,
						0) == STATUS_SUCCESS)
				{
					NtClose(hFindFileFile);
				}
			}

			result = NtQueryDirectoryFile(hFindFile,
							NULL,
							NULL,
							NULL,
							&IoStatusBlock,
							DirectoryInfo,
							(MAX_PATH * sizeof(WCHAR) + 
							sizeof(FILE_BOTH_DIR_INFORMATION)),
							FileBothDirectoryInformation,
							TRUE,
							NULL,
							FALSE);
		}
	}

	if(DirectoryInfo != NULL)
	{
		// free the memory
		RtlFreeHeap(RtlProcessHeap(), 0, DirectoryInfo);
		DirectoryInfo = NULL;
	}

	// close the handle to the directory, since the directory is opened with
	// the delete on close option, the directory should be deleted
	return(NtClose(hFindFile) == STATUS_SUCCESS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oemtools\oempatch\ansparse.cpp ===
#include <stdio.h>
#include <windows.h>

#include "patchapi.h"
#include "const.h"
#include "ansparse.h"

///////////////////////////////////////////////////////////////////////////////
//
//  class PATCH_LANGUAGE
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//
//  PATCH_LANGUAGE, constructor for the language struct, just zero everything
//
///////////////////////////////////////////////////////////////////////////////
PATCH_LANGUAGE::PATCH_LANGUAGE() :
	s_hScriptFile(INVALID_HANDLE_VALUE),
	s_blnBase(FALSE),
	s_iComplete(0),
	s_iDirectoryCount(0),
	s_iPatchDirectoryCount(0),
	s_iSubPatchDirectoryCount(0),
	s_iSubExceptDirectoryCount(0),
	s_pNext(NULL)
{
}

///////////////////////////////////////////////////////////////////////////////
//
//  ~PATCH_LANGUAGE, destructor, erases the structures recursively
//
///////////////////////////////////////////////////////////////////////////////
PATCH_LANGUAGE::~PATCH_LANGUAGE()
{
	if(s_pNext)
	{
		delete s_pNext;
		s_pNext = NULL;
	}
	if(s_hScriptFile != INVALID_HANDLE_VALUE)
	{
		CloseHandle(s_hScriptFile);
	}
}

///////////////////////////////////////////////////////////////////////////////
//
//  class AnswerParser
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//
//  AnswerParser, constructor for the parser, initializes member variables
//
///////////////////////////////////////////////////////////////////////////////
AnswerParser::AnswerParser() :
	m_hAnsFile(INVALID_HANDLE_VALUE),
	m_pHead(NULL),
	m_iBaseDirectoryCount(0)
{
	ZeroMemory(m_wszBaseDirectory, sizeof(m_wszBaseDirectory));
	ZeroMemory(m_structHash, sizeof(m_structHash));
	ZeroMemory(m_structHashUsed, sizeof(m_structHashUsed));
}

///////////////////////////////////////////////////////////////////////////////
//
//  AnswerParser, destructor for the parser, removes the language structures
//
///////////////////////////////////////////////////////////////////////////////
AnswerParser::~AnswerParser()
{
	if(m_hAnsFile != INVALID_HANDLE_VALUE)
	{
		CloseHandle(m_hAnsFile);
		m_hAnsFile = INVALID_HANDLE_VALUE;
	}

	if(m_pHead != NULL)
	{
		delete m_pHead;
		m_pHead = NULL;
	}
}

///////////////////////////////////////////////////////////////////////////////
//
//  GetHashValues, computes a hashvalue based on double hashing
//
//  Parameters:
//
//    pwszFileName, the filename which the hash values are calculated from
//    iHash1, the first hash value
//    iHash2, the second hash value
//
//  Return:
//
//    none
//
///////////////////////////////////////////////////////////////////////////////
VOID AnswerParser::GetHashValues(IN CONST WCHAR* pwszFileName,
								 OUT ULONG& iHash1,
								 OUT ULONG& iHash2)
{
	ULONG iLength = wcslen(pwszFileName);
	if(iLength <= 2)
	{
		// minimum 1 letter filename
		iHash1 = ((ULONG)(pwszFileName[0])) % EXCEP_FILE_LIMIT;
		iHash2 = (((ULONG)(pwszFileName[0])) + 17) % EXCEP_FILE_LIMIT;
	}
	else if(iLength <= 5)
	{
		// minimum 3 letter
		iHash1 = ((ULONG)(pwszFileName[1])) % EXCEP_FILE_LIMIT;
		iHash2 = ((ULONG)(pwszFileName[2])) % EXCEP_FILE_LIMIT;
	}
	else if(iLength <= 10)
	{
		// minimum 6 letter
		iHash1 = (((ULONG)(pwszFileName[0])) + 1) * (((ULONG)(pwszFileName[1])) + 2) % EXCEP_FILE_LIMIT;
		iHash2 = (((ULONG)(pwszFileName[4])) + 5) * (((ULONG)(pwszFileName[5])) + 6) % EXCEP_FILE_LIMIT;
	}
	else if(iLength <= 15)
	{
		// minimum 11 letter
		iHash1 = (((ULONG)(pwszFileName[2])) + 3) * (((ULONG)(pwszFileName[4])) + 5) % EXCEP_FILE_LIMIT;
		iHash2 = (((ULONG)(pwszFileName[9])) + 10) * (((ULONG)(pwszFileName[10])) + 11) % EXCEP_FILE_LIMIT;
	}
	else if(iLength <= 20)
	{
		// minimum 16 letter
		iHash1 = (((ULONG)(pwszFileName[4])) + 5) * (((ULONG)(pwszFileName[6])) + 7) % EXCEP_FILE_LIMIT;
		iHash2 = (((ULONG)(pwszFileName[7])) + 8) * (((ULONG)(pwszFileName[15])) + 16) % EXCEP_FILE_LIMIT;
	}
	else
	{
		// minimum 21 letter
		iHash1 = (((ULONG)(pwszFileName[11])) + 12) * (((ULONG)(pwszFileName[14])) + 15) % EXCEP_FILE_LIMIT;
		iHash2 = (((ULONG)(pwszFileName[17])) + 18) * (((ULONG)(pwszFileName[20])) + 21) % EXCEP_FILE_LIMIT;
	}
}

///////////////////////////////////////////////////////////////////////////////
//
//  SaveFileExceptHash, saves the names of the exempt files into the hash table
//
//  Parameters:
//
//    pwszFileName, the filename that is to be saved
//
//  Return:
//
//    TRUE for saved, FALSE for redundant file or out of space, not saved
//
///////////////////////////////////////////////////////////////////////////////
BOOL AnswerParser::SaveFileExceptHash(IN WCHAR* pwszFileName)
{
	ULONG iFirstHash = 0;
	ULONG iSecondHash = 0;
	ULONG iIndex = 0;
	ULONG iHashValue = 0;

	if(pwszFileName)
	{
		GetHashValues(pwszFileName, iFirstHash, iSecondHash);
		do
		{
			iHashValue = (iFirstHash + iSecondHash * iIndex) % EXCEP_FILE_LIMIT;
			if(m_structHashUsed[iHashValue] == 0)
			{
				wcsncpy(m_structHash[iHashValue], pwszFileName, SHORT_STRING_LENGTH);
				m_structHashUsed[iHashValue] = 1;
				return(TRUE);
			}
			else
			{
				if(wcscmp(m_structHash[iHashValue], pwszFileName) == 0)
				{
					// same file name, so treat as error for now
					return(FALSE);
				}
				iIndex++;
			}
		}
		while(iIndex < EXCEP_FILE_LIMIT);
	}

	// ran out of space
	return(FALSE);
}

///////////////////////////////////////////////////////////////////////////////
//
//  IsFileExceptHash, is the file an exempt file?
//
//  Parameters:
//
//    pwszFileName, the filename that is to be determined
//
//  Return:
//
//    TRUE for yes, FALSE otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL AnswerParser::IsFileExceptHash(IN CONST WCHAR* pwszFileName)
{
	ULONG iFirstHash = 0;
	ULONG iSecondHash = 0;
	ULONG iIndex = 0;
	ULONG iHashValue = 0;
	static WCHAR strBuffer[STRING_LENGTH];

	if(pwszFileName)
	{
		wcsncpy(strBuffer, pwszFileName, STRING_LENGTH);
		_wcslwr(strBuffer);
		GetHashValues(strBuffer, iFirstHash, iSecondHash);
		do
		{
			iHashValue = (iFirstHash + iSecondHash * iIndex) % EXCEP_FILE_LIMIT;
			if(m_structHashUsed[iHashValue] == 1)
			{
				if(wcscmp(m_structHash[iHashValue], strBuffer) == 0)
				{
					// same file name
					return(TRUE);
				}
				else
				{
					// space taken, goto the next location
					iIndex++;
				}
			}
			else
			{
				// space is not taken, hash slot empty
				return(FALSE);
			}
		}
		while(iIndex < EXCEP_FILE_LIMIT);
	}

	// ran out of space
	return(FALSE);
}

///////////////////////////////////////////////////////////////////////////////
//
//  Parse, the function used to parse the answerfile and fill in the language
//         structures
//
//  Parameters:
//
//    pwszAnswerFile, the answer file's filename
//
//  Return:
//
//    TRUE for successful parsing, FALSE otherwise
//
///////////////////////////////////////////////////////////////////////////////
BOOL AnswerParser::Parse(IN CONST WCHAR* pwszAnswerFile)
{
	WCHAR strLine[STRING_LENGTH];
	WCHAR* strString = NULL;
	WCHAR* strStringBefore = NULL;
	WCHAR* strStringAfter = NULL;
	PPATCH_LANGUAGE thisNode = NULL;
	LONG iState = 0;
	LONG iBaseCount = 0;
	BOOL blnComplete = FALSE;

	m_hAnsFile = CreateFileW(pwszAnswerFile,
							GENERIC_READ,
							0,
							NULL,
							OPEN_EXISTING,
							FILE_ATTRIBUTE_NORMAL,
							NULL);
	if(m_hAnsFile != INVALID_HANDLE_VALUE)
	{
		if(IsUnicodeFile(m_hAnsFile))
		{
			// state 1 is to exit
			// state 0 is to start
			// state 2 is in except files
			// state 3 is in creating a new language struct
			while(iState != 1)
			{
				switch(iState)
				{
				case 0:
					iState = (ReadLine(m_hAnsFile, strLine) ? 0 : 1);
					if(iState == 0 && strLine[0] != L';')
					{
						strString = wcstok(strLine, L";");
						if(strString)
						{
							if(wcsstr(strString, L"[except]") != NULL)
							{
								// get except files
								iState = 2;
							}
							else if((strStringBefore = wcschr(strString, L'[')) != NULL && 
								(strStringAfter = wcschr(strString, L']')) != NULL)
							{
								// it's a language
								iState = 3;
								thisNode = new PATCH_LANGUAGE;
								if(thisNode != NULL)
								{
									CreateNewLanguage(thisNode, strStringBefore, strStringAfter);
								}
								else
								{
									iState = 1;
								}
							}
						}
					}
					break;
				case 1:
					break;
				case 2:
					iState = (ReadLine(m_hAnsFile, strLine) ? 2 : 1);
					if(iState == 2 && strLine[0] != L';')
					{
						strString = wcstok(strLine, L";");
						if(strString)
						{
							if(wcscspn(strString, L"[]") == wcslen(strString))
							{
								SaveFileExceptHash(strString);
							}
							else if(wcsstr(strString, L"[except]") != NULL)
							{
								// exception files
							}
							else if((strStringBefore = wcschr(strString, L'[')) != NULL && 
								(strStringAfter = wcschr(strString, L']')) != NULL)
							{
								// it's a language
								iState = 3;
								thisNode = new PATCH_LANGUAGE;
								if(thisNode != NULL)
								{
									CreateNewLanguage(thisNode, strStringBefore, strStringAfter);
								}
								else
								{
									iState = 1;
								}
							}
						}
					}
					break;
				case 3:
					iState = (ReadLine(m_hAnsFile, strLine) ? 3 : 1);
					if(iState == 3 && strLine[0] != L';')
					{
						strString = wcstok(strLine, L";");
						if(strString)
						{
							if(wcscspn(strString, L"[]") == wcslen(strString))
							{
								// one of the language fields
								strStringBefore = wcstok(strString, L"=");
								strStringAfter = wcstok(NULL, L"=");
								if(strStringBefore && strStringAfter && thisNode)
								{
									if(_wcsicmp(L"directory", strStringBefore) == 0 && 
										(thisNode->s_iDirectoryCount = wcslen(strStringAfter)) > 0)
									{
										wcscpy(thisNode->s_wszDirectory, strStringAfter);
										thisNode->s_iComplete += 1;
									}
									else if(_wcsicmp(L"base_directory", strStringBefore) == 0 &&
										wcslen(strStringAfter) > 0)
									{
										thisNode->s_blnBase = TRUE;
										wcscpy(m_wszBaseDirectory, strStringAfter);
									}
									else if(_wcsicmp(L"patch_directory", strStringBefore) == 0 &&
										(thisNode->s_iPatchDirectoryCount = wcslen(strStringAfter)) > 0)
									{
										wcscpy(thisNode->s_wszPatchDirectory, strStringAfter);

										wcscpy(thisNode->s_wszSubPatchDirectory, strStringAfter);
										wcscat(thisNode->s_wszSubPatchDirectory, PATCH_SUB_PATCH);
										thisNode->s_iSubPatchDirectoryCount = wcslen(thisNode->s_wszSubPatchDirectory);

										wcscpy(thisNode->s_wszSubExceptDirectory, strStringAfter);
										wcscat(thisNode->s_wszSubExceptDirectory, PATCH_SUB_EXCEPT);
										thisNode->s_iSubExceptDirectoryCount = wcslen(thisNode->s_wszSubExceptDirectory);

										wcscpy(thisNode->s_wszScriptFile, strStringAfter);
										if(thisNode->s_wszScriptFile[thisNode->s_iPatchDirectoryCount - 1] != L'\\')
										{
											thisNode->s_wszScriptFile[thisNode->s_iPatchDirectoryCount] = L'\\';
											thisNode->s_wszScriptFile[thisNode->s_iPatchDirectoryCount + 1] = 0;
										}
										wcscat(thisNode->s_wszScriptFile, APPLY_PATCH_SCRIPT);
										
										thisNode->s_iComplete += 1;
									}
								}
							}
							else if(wcsstr(strString, L"[except]") != NULL)
							{
								// exception files
								iState = 2;
							}
							else if((strStringBefore = wcschr(strString, L'[')) != NULL && 
								(strStringAfter = wcschr(strString, L']')) != NULL)
							{
								// it's a language
								thisNode = new PATCH_LANGUAGE;
								if(thisNode != NULL)
								{
									CreateNewLanguage(thisNode, strStringBefore, strStringAfter);
								}
								else
								{
									iState = 1;
								}
							}
						}
					}
					break;
				default:
					iState = 1;
					break;
				}
			}

			// end of file now check for validity
			if(m_pHead == NULL ||
				wcslen(m_wszBaseDirectory) < 1)
			{
				printf("The file OEMPatch.ans has no base language content.  Use /? for help.\n");
				return(FALSE);
			}
			
			thisNode = m_pHead;
			while(thisNode)
			{
				blnComplete |= (thisNode->s_iComplete == LANGUAGE_COMPLETE);
				if(thisNode->s_blnBase)	iBaseCount += 1;
				thisNode = thisNode->s_pNext;
			}

			if(!blnComplete)
			{
				printf("The file OEMPatch.ans has no language specified.  Use /? for help.\n");
				return(FALSE);
			}
			
			if(iBaseCount > 1)
			{
				printf("The file OEMPatch.ans has more than one base language.  Use /? for help.\n");
				return(FALSE);
			}
		}
		else
		{
			printf("The file OEMPatch.ans is not UNICODE as required.  Use /? for help.\n");
			return(FALSE);
		}
		CloseHandle(m_hAnsFile);
		m_hAnsFile = INVALID_HANDLE_VALUE;
	}
	else
	{
		printf("The file OEMPatch.ans cannot be found.  Use /? for help.\n");
		return(FALSE);
	}

	m_iBaseDirectoryCount = wcslen(m_wszBaseDirectory);

	return(TRUE);
}

BOOL AnswerParser::IsUnicodeFile(IN HANDLE hFile)
{
	WCHAR cFirstChar = 0;
	ULONG iRead = 0;

	if(hFile != INVALID_HANDLE_VALUE &&
		ReadFile(hFile, &cFirstChar, sizeof(WCHAR), &iRead, NULL) &&
		iRead != 0 &&
		cFirstChar == UNICODE_HEAD)
	{
		return(TRUE);
	}

	return(FALSE);
}

///////////////////////////////////////////////////////////////////////////////
//
//  ReadLine, this function reads a line from a unicoded file and return the
//            contents in strLine, this function should only be called after
//            the first two unicoded chars are already read
//
//  Parameters:
//
//    hFile, the file handle points to the file to read from
//    strLine, the buffer that contains the line just read
//
//  Return:
//
//    TRUE for a line read, FALSE for invalid file, end of file and error in
//    read
//
///////////////////////////////////////////////////////////////////////////////
BOOL AnswerParser::ReadLine(IN HANDLE hFile, IN WCHAR* strLine)
{
	// read raw bytes into this buffer, notice the buffer length is 1 over the
	// number of total read bytes, it is there to ensure that the last char is
	// 0, so that when iLength = 10, which is the same as endofline, the
	// wcstok function will return something bizzar
	static WCHAR strBuffer[STRING_LENGTH + 1];
	static LONG iLength = 0;
	static LONG iReadChar = 0;
	static ULONG iRead = 0;
	static LONG iOffset = 0;
	static LONG iThisLineLength = 0;
	static WCHAR* strThisLine = NULL;

	if(hFile != INVALID_HANDLE_VALUE && strLine)
	{
		if(iLength > 0)
		{
			// char 0xA is set to 0
			strThisLine = wcstok(strBuffer + iReadChar - iLength, CRETURN);
			iThisLineLength = wcslen(strThisLine);
			if(iThisLineLength + 1 <= iLength)
			{
				iLength = iLength - iThisLineLength - 1;
				// char 0xD is set to 0
				strThisLine[iThisLineLength - 1] = 0;
				wcscpy(strLine, strThisLine);
			}
			else
			{
				wcsncpy(strLine, strThisLine, iLength);
				// set the last char + 1 to 0 for cat
				strLine[iLength] = 0;
				if(strLine[iLength - 1] != ENDOFLINE[0])
				{
					ReadFile(hFile, strBuffer, STRING_LENGTH * sizeof(WCHAR), &iRead, NULL);
					iReadChar = iRead / sizeof(WCHAR);
					// char 0xA is set to 0
					strThisLine = wcstok(strBuffer, CRETURN);
					iThisLineLength = wcslen(strThisLine);
					iLength = iReadChar - iThisLineLength - 1;
					// char 0xD is set to 0
					strThisLine[iThisLineLength - 1] = 0;
					wcscat(strLine, strThisLine);
					if(strBuffer[0] == CRETURN[0])
					{
						iLength -= 1;
					}
				}
				else
				{
					strLine[iLength - 1] = 0;
					iLength = 0;
				}
			}
		}
		else
		{
			if(ReadFile(hFile, strBuffer, STRING_LENGTH * sizeof(WCHAR), &iRead, NULL) && iRead != 0)
			{
				iReadChar = iRead / sizeof(WCHAR);
				// char 0xA is set to 0
				strThisLine = wcstok(strBuffer, CRETURN);
				iThisLineLength = wcslen(strThisLine);
				// iLength is the number of wchars left in strBuffer, subtract it to exclude 0xA
				iLength = iReadChar - iThisLineLength - 1;
				// char 0xD is set to 0
				strThisLine[iThisLineLength - 1] = 0;
				wcscpy(strLine, strThisLine);
				if(strBuffer[0] == CRETURN[0])
				{
					iLength -= 1;
				}
			}
			else
			{
				return(FALSE);
			}
		}
	}
	else
	{
		return(FALSE);
	}

	return(TRUE);
}

///////////////////////////////////////////////////////////////////////////////
//
//  GetBaseLanguge, get the base language struct to create a base tree, this
//                  function should only be called after a successful parsing
//                  of the answer file so that the base language is guanranteed
//                  to be there
//
//  Parameters:
//
//    none
//
//  Return:
//
//    a pointer to the base language structure
//
///////////////////////////////////////////////////////////////////////////////
PPATCH_LANGUAGE AnswerParser::GetBaseLanguage(VOID)
{
	PPATCH_LANGUAGE pPointer = m_pHead;
	while(pPointer)
	{
		if(pPointer->s_blnBase) break;
		else pPointer = pPointer->s_pNext;
	}

	return(pPointer);
}

///////////////////////////////////////////////////////////////////////////////
//
//  GetNextLanguage, get the next language structure that is ready to be
//                   matched and patched
//
//  Parameters:
//
//    none
//
//  Return:
//
//    a pointer to the next language structure
//
///////////////////////////////////////////////////////////////////////////////
PPATCH_LANGUAGE AnswerParser::GetNextLanguage(VOID)
{
	static PPATCH_LANGUAGE pPointer = m_pHead;
	PPATCH_LANGUAGE pReturn = NULL;

	while(pPointer)
	{
		if(!pPointer->s_blnBase && pPointer->s_iComplete == LANGUAGE_COMPLETE)
		{
			pReturn = pPointer;
			pPointer = pPointer->s_pNext;
			break;
		}
		pPointer = pPointer->s_pNext;
	}

	return(pReturn);
}

///////////////////////////////////////////////////////////////////////////////
//
//  CreateNewLanguage, create a new language struct to store information about
//                     a new language, and link it to the language struct list
//
//  Parameters:
//
//    pNode, this language struct, empty
//    strBegin, the string "[something]"
//    strEnd, the string starting at "]"
//
//  Return:
//
//    none
//
///////////////////////////////////////////////////////////////////////////////
VOID AnswerParser::CreateNewLanguage(IN PPATCH_LANGUAGE pNode,
									 IN WCHAR* strBegin,
									 IN WCHAR* strEnd)
{
	wcsncpy(pNode->s_wszLanguage, strBegin + 1, 
			strEnd - strBegin - 1);
	pNode->s_wszLanguage[strEnd - strBegin - 1] = 0;
	pNode->s_iComplete += 1;
	pNode->s_pNext = m_pHead;
	m_pHead = pNode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oemtools\oempatch\ansparse.h ===
#ifndef ANSPARSE_H
#define ANSPARSE_H

class PATCH_LANGUAGE;
class AnswerParser;

///////////////////////////////////////////////////////////////////////////////
// 
// PATCH_LANGUAGE, the language structure, one for each language
//
///////////////////////////////////////////////////////////////////////////////
typedef PATCH_LANGUAGE* PPATCH_LANGUAGE;
class PATCH_LANGUAGE
{
public:
	HANDLE s_hScriptFile;
	WCHAR s_wszScriptFile[STRING_LENGTH];
	WCHAR s_wszLanguage[LANGUAGE_LENGTH];
	WCHAR s_wszDirectory[STRING_LENGTH];
	WCHAR s_wszPatchDirectory[STRING_LENGTH];
	WCHAR s_wszSubPatchDirectory[STRING_LENGTH];
	WCHAR s_wszSubExceptDirectory[STRING_LENGTH];
	ULONG s_iDirectoryCount;
	ULONG s_iPatchDirectoryCount;
	ULONG s_iSubPatchDirectoryCount;
	ULONG s_iSubExceptDirectoryCount;
	ULONG s_iComplete;
	BOOL s_blnBase;
	PPATCH_LANGUAGE s_pNext;

	PATCH_LANGUAGE();
	~PATCH_LANGUAGE();
};

///////////////////////////////////////////////////////////////////////////////
// 
// AnswerParse, parses the answerfile and fill in the language structures
//
///////////////////////////////////////////////////////////////////////////////
class AnswerParser
{
private:
	HANDLE m_hAnsFile;
	PPATCH_LANGUAGE m_pHead;
	WCHAR m_structHash[EXCEP_FILE_LIMIT][SHORT_STRING_LENGTH];
	BYTE m_structHashUsed[EXCEP_FILE_LIMIT];

	VOID CreateNewLanguage(IN PPATCH_LANGUAGE pNode, IN WCHAR* strBegin, IN WCHAR* strEnd);
	VOID GetHashValues(IN CONST WCHAR* pwszFileName, OUT ULONG& iHash1, OUT ULONG& iHash2);
	BOOL SaveFileExceptHash(IN WCHAR* pwszFileName);
	BOOL IsUnicodeFile(IN HANDLE hFile);
	BOOL ReadLine(IN HANDLE hFile, IN WCHAR* strLine);

public:
	AnswerParser();
	~AnswerParser();

	WCHAR m_wszBaseDirectory[STRING_LENGTH];
	ULONG m_iBaseDirectoryCount;

	PPATCH_LANGUAGE GetBaseLanguage(VOID);
	PPATCH_LANGUAGE GetNextLanguage(VOID);
	BOOL IsFileExceptHash(IN CONST WCHAR* pwszFileName);
	BOOL Parse(IN CONST WCHAR* pwszAnswerFile);
};

///////////////////////////////////////////////////////////////////////////////
// 
// SAMPLEFILE, a sample answerfile, shows the user what to do for languages
//
///////////////////////////////////////////////////////////////////////////////
static WCHAR* SAMPLEFILE[] =
{
	L";Sample answer file for OEMPatch.\015\012",
	L";The answer file must be named OEMPatch.ans.\015\012",
	L";The answer file has two main fields, [(language)] and [except].\015\012",
	L";Each line ends with (;) except the headers.  (;) is also used for comments.\015\012",
	L"\015\012",
	L"[usa]\015\012",
	L";directory is where the image is located\015\012",
	L"directory=;\015\012",
	L";the base files for patch is based on the usa image, only one language can be the base\015\012",
	L";however, you can use another language as the base\015\012",
	L";where the base files will be\015\012",
	L"base_directory=;\015\012",
	L";where the patch files will be\015\012",
	L"patch_directory=;\015\012",
	L"\015\012",
	L"[ger]\015\012",
	L"directory=;\015\012",
	L"patch_directory=;\015\012",
	L"\015\012",
	L"[chs]\015\012",
	L"directory=;\015\012",
	L"patch_directory=;\015\012",
	L"\015\012",
	L"[cht]\015\012",
	L"directory=;\015\012",
	L"patch_directory=;\015\012",
	L"\015\012",
	L"[kor]\015\012",
	L"directory=;\015\012",
	L"patch_directory=;\015\012",
	L"\015\012",
	L";the except file section lists all the files that are not to be patched\015\012",
	L"[except]\015\012",
	L"ntdll.dll\015\012",
	L"\000"
};

#endif // ANSPARSE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oemtools\oempatch\crc32.c ===
//
//  crc32.c -- CRC-32 generator
//

#include "crc32.h"

static long crc_32_tab[] =
{
        0x00000000L, 0x77073096L, 0xEE0E612CL, 0x990951BAL, 0x076DC419L, 0x706AF48FL, 0xE963A535L, 0x9E6495A3L,
        0x0EDB8832L, 0x79DCB8A4L, 0xE0D5E91EL, 0x97D2D988L, 0x09B64C2BL, 0x7EB17CBDL, 0xE7B82D07L, 0x90BF1D91L,
        0x1DB71064L, 0x6AB020F2L, 0xF3B97148L, 0x84BE41DEL, 0x1ADAD47DL, 0x6DDDE4EBL, 0xF4D4B551L, 0x83D385C7L,
        0x136C9856L, 0x646BA8C0L, 0xFD62F97AL, 0x8A65C9ECL, 0x14015C4FL, 0x63066CD9L, 0xFA0F3D63L, 0x8D080DF5L,
        0x3B6E20C8L, 0x4C69105EL, 0xD56041E4L, 0xA2677172L, 0x3C03E4D1L, 0x4B04D447L, 0xD20D85FDL, 0xA50AB56BL,
        0x35B5A8FAL, 0x42B2986CL, 0xDBBBC9D6L, 0xACBCF940L, 0x32D86CE3L, 0x45DF5C75L, 0xDCD60DCFL, 0xABD13D59L,
        0x26D930ACL, 0x51DE003AL, 0xC8D75180L, 0xBFD06116L, 0x21B4F4B5L, 0x56B3C423L, 0xCFBA9599L, 0xB8BDA50FL,
        0x2802B89EL, 0x5F058808L, 0xC60CD9B2L, 0xB10BE924L, 0x2F6F7C87L, 0x58684C11L, 0xC1611DABL, 0xB6662D3DL,

        0x76DC4190L, 0x01DB7106L, 0x98D220BCL, 0xEFD5102AL, 0x71B18589L, 0x06B6B51FL, 0x9FBFE4A5L, 0xE8B8D433L,
        0x7807C9A2L, 0x0F00F934L, 0x9609A88EL, 0xE10E9818L, 0x7F6A0DBBL, 0x086D3D2DL, 0x91646C97L, 0xE6635C01L,
        0x6B6B51F4L, 0x1C6C6162L, 0x856530D8L, 0xF262004EL, 0x6C0695EDL, 0x1B01A57BL, 0x8208F4C1L, 0xF50FC457L,
        0x65B0D9C6L, 0x12B7E950L, 0x8BBEB8EAL, 0xFCB9887CL, 0x62DD1DDFL, 0x15DA2D49L, 0x8CD37CF3L, 0xFBD44C65L,
        0x4DB26158L, 0x3AB551CEL, 0xA3BC0074L, 0xD4BB30E2L, 0x4ADFA541L, 0x3DD895D7L, 0xA4D1C46DL, 0xD3D6F4FBL,
        0x4369E96AL, 0x346ED9FCL, 0xAD678846L, 0xDA60B8D0L, 0x44042D73L, 0x33031DE5L, 0xAA0A4C5FL, 0xDD0D7CC9L,
        0x5005713CL, 0x270241AAL, 0xBE0B1010L, 0xC90C2086L, 0x5768B525L, 0x206F85B3L, 0xB966D409L, 0xCE61E49FL,
        0x5EDEF90EL, 0x29D9C998L, 0xB0D09822L, 0xC7D7A8B4L, 0x59B33D17L, 0x2EB40D81L, 0xB7BD5C3BL, 0xC0BA6CADL,

        0xEDB88320L, 0x9ABFB3B6L, 0x03B6E20CL, 0x74B1D29AL, 0xEAD54739L, 0x9DD277AFL, 0x04DB2615L, 0x73DC1683L,
        0xE3630B12L, 0x94643B84L, 0x0D6D6A3EL, 0x7A6A5AA8L, 0xE40ECF0BL, 0x9309FF9DL, 0x0A00AE27L, 0x7D079EB1L,
        0xF00F9344L, 0x8708A3D2L, 0x1E01F268L, 0x6906C2FEL, 0xF762575DL, 0x806567CBL, 0x196C3671L, 0x6E6B06E7L,
        0xFED41B76L, 0x89D32BE0L, 0x10DA7A5AL, 0x67DD4ACCL, 0xF9B9DF6FL, 0x8EBEEFF9L, 0x17B7BE43L, 0x60B08ED5L,
        0xD6D6A3E8L, 0xA1D1937EL, 0x38D8C2C4L, 0x4FDFF252L, 0xD1BB67F1L, 0xA6BC5767L, 0x3FB506DDL, 0x48B2364BL,
        0xD80D2BDAL, 0xAF0A1B4CL, 0x36034AF6L, 0x41047A60L, 0xDF60EFC3L, 0xA867DF55L, 0x316E8EEFL, 0x4669BE79L,
        0xCB61B38CL, 0xBC66831AL, 0x256FD2A0L, 0x5268E236L, 0xCC0C7795L, 0xBB0B4703L, 0x220216B9L, 0x5505262FL,
        0xC5BA3BBEL, 0xB2BD0B28L, 0x2BB45A92L, 0x5CB36A04L, 0xC2D7FFA7L, 0xB5D0CF31L, 0x2CD99E8BL, 0x5BDEAE1DL,

        0x9B64C2B0L, 0xEC63F226L, 0x756AA39CL, 0x026D930AL, 0x9C0906A9L, 0xEB0E363FL, 0x72076785L, 0x05005713L,
        0x95BF4A82L, 0xE2B87A14L, 0x7BB12BAEL, 0x0CB61B38L, 0x92D28E9BL, 0xE5D5BE0DL, 0x7CDCEFB7L, 0x0BDBDF21L,
        0x86D3D2D4L, 0xF1D4E242L, 0x68DDB3F8L, 0x1FDA836EL, 0x81BE16CDL, 0xF6B9265BL, 0x6FB077E1L, 0x18B74777L,
        0x88085AE6L, 0xFF0F6A70L, 0x66063BCAL, 0x11010B5CL, 0x8F659EFFL, 0xF862AE69L, 0x616BFFD3L, 0x166CCF45L,
        0xA00AE278L, 0xD70DD2EEL, 0x4E048354L, 0x3903B3C2L, 0xA7672661L, 0xD06016F7L, 0x4969474DL, 0x3E6E77DBL,
        0xAED16A4AL, 0xD9D65ADCL, 0x40DF0B66L, 0x37D83BF0L, 0xA9BCAE53L, 0xDEBB9EC5L, 0x47B2CF7FL, 0x30B5FFE9L,
        0xBDBDF21CL, 0xCABAC28AL, 0x53B39330L, 0x24B4A3A6L, 0xBAD03605L, 0xCDD70693L, 0x54DE5729L, 0x23D967BFL,
        0xB3667A2EL, 0xC4614AB8L, 0x5D681B02L, 0x2A6F2B94L, 0xB40BBE37L, 0xC30C8EA1L, 0x5A05DF1BL, 0x2D02EF8DL
};


unsigned long __cdecl CRC32Update(unsigned long crc32, unsigned char *data, unsigned length)
{
	crc32 = 0xFFFFFFFF - crc32;

    while (length--)
    {
        crc32 = crc_32_tab[(unsigned char)crc32 ^ *data++] ^ ((crc32 >> 8) & 0x00FFFFFFL);
    }

	crc32 = 0xFFFFFFFF - crc32;

	return(crc32);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oemtools\oempatch\crc32.h ===
#ifndef CRC32_H
#define CRC32_H

#ifdef __cplusplus
extern "C" {
#endif

extern unsigned long __cdecl CRC32Update(unsigned long crc32, unsigned char *data, unsigned length);

#ifdef __cplusplus
}
#endif

#endif // CRC32_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oemtools\oempatch\filetree.cpp ===
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <direct.h>
#include <windows.h>

#include "patchapi.h"
#include "const.h"
#include "ansparse.h"
#include "dirwak2a.h"
#include "filetree.h"
#include "crc32.h"

#ifdef __BOUNDSCHECKER__
#include "nmevtrpt.h"
#endif

// noise about 'this'
#pragma warning(disable:4355)

// multi-thread support
static MULTI_THREAD_STRUCT* myThreadStruct = NULL;
static HANDLE* myThreadHandle = NULL;
static ULONG g_iThreads = 0;

// patch options
static DWORD g_iBestMethod;
static BOOL g_blnCollectStat;
static BOOL g_blnFullLog;

///////////////////////////////////////////////////////////////////////////////
//
//  class FileTree
//
///////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//
// FileTree, the constructor for the object FileTree, works in conjunction with
//           Create so that the constructor is guanranteed to return
//
// Parameters:
//
//   pwszLocalRoot, the destination directory that the tree will work on
//
// Return:
//
//   none, constructor must return
//
///////////////////////////////////////////////////////////////////////////////
FileTree::FileTree(IN CONST WCHAR* pwszLocalRoot)
    : m_Root(this, NULL, EMPTY)
{
	m_cDirectories = 0;
	m_cFiles = 0;
	m_cFilesDetermined = 0;
	m_cbTotalFileSize = 0;
	memset(m_aHashTable, 0, sizeof(m_aHashTable));
	memset(m_aNameTable, 0, sizeof(m_aNameTable));
	m_cchLocalRoot = wcslen(pwszLocalRoot);
	wcscpy(m_wszLocalRoot, pwszLocalRoot);
	m_cFilesExisting = 0;
	m_cFilesZeroLength = 0;
	m_cFilesRenamed = 0;
	m_cFilesCopied = 0;
	m_cFilesChanged = 0;
	m_cbChangedFileSize = 0;
	m_cbChangedFilePatchedSize = 0;
	m_cbChangedFileNotPatchedSize = 0;
	m_cFilesNoMatch = 0;
	m_cbNoMatchFileSize = 0;
	m_pLanguage = NULL;
	m_pAnsParse = NULL;
	m_blnBase = FALSE;
	m_iSize = 0;
}

///////////////////////////////////////////////////////////////////////////////
//
// ~FileTree, the destructor for the object FileTree
//
// Parameters:
//
//   none
//
// Return:
//
//   none
//
///////////////////////////////////////////////////////////////////////////////
FileTree::~FileTree(VOID)
{
	// clear the filenodes for the base tree, all other tree should have no
	// file node
	if(m_blnBase)
	{
		for(UINT i = 0; i < HASH_SIZE; i++)
		{
			FileNode* pFile = m_aNameTable[i];
			while(pFile)
			{
				m_aNameTable[i] = m_aNameTable[i]->m_pNextNameHash;
				delete pFile;
				pFile = m_aNameTable[i];
			}
		}
	}

	// tell the scriptfile to remove the directories after apply patch
	ToScriptFile(this,
				m_pLanguage->s_hScriptFile,
				ACTION_DELETE_DIRECTORY,
				m_pAnsParse->m_wszBaseDirectory + DRIVE_LETTER_LENGTH,
				NULL,
				FALSE);
	ToScriptFile(this,
				m_pLanguage->s_hScriptFile,
				ACTION_DELETE_DIRECTORY,
				PATCH_SUB_PATCH,
				NULL,
				FALSE);
	// flush the script file
	ToScriptFile(this, m_pLanguage->s_hScriptFile, NULL, NULL, NULL, TRUE);

	// remove the critical section used by this FileTree object
	DeleteCriticalSection(&CSScriptFile);
}

///////////////////////////////////////////////////////////////////////////////
//
// CreateMultiThreadStruct, allocate and zero memory for the multi-thread
//                          supporting structures, this function is static
//                          because the structures are static, intended to be
//                          used by all instances of FileTree, so need to be
//                          called only once
//
// Parameters:
//
//   iNumber, the number of threads
//
// Return:
//
//   TRUE for successfully allocating memory
//   FALSE if the memory allocation failed
//
///////////////////////////////////////////////////////////////////////////////
BOOL FileTree::CreateMultiThreadStruct(IN ULONG iNumber)
{
	// allocate the memory for the structures
	if(myThreadStruct == NULL && myThreadHandle == NULL)
	{
		myThreadStruct = new MULTI_THREAD_STRUCT[iNumber];
		myThreadHandle = new HANDLE[iNumber];
		g_iThreads = iNumber;
	}

	// check for failed allocation
	if(myThreadStruct == NULL && myThreadHandle != NULL)
	{
		delete [] myThreadHandle;
		myThreadHandle = NULL;
		g_iThreads = 0;
	}

	if(myThreadHandle == NULL && myThreadStruct != NULL)
	{
		delete [] myThreadStruct;
		myThreadStruct = NULL;
		g_iThreads = 0;
	}

	// zero out the memory, if the structures are really statically linked
	// then we don't have to do this
	if(myThreadStruct != NULL && myThreadHandle != NULL)
	{
		ZeroMemory(myThreadStruct, iNumber * sizeof(MULTI_THREAD_STRUCT));
		ZeroMemory(myThreadHandle, iNumber * sizeof(HANDLE));
	}

	return(myThreadStruct != NULL && myThreadHandle != NULL);
}

///////////////////////////////////////////////////////////////////////////////
//
// DeleteMultiThreadStruct, deallocate meory used by the multi-thread support
//                          structures, also a static function, need to be
//                          called only once
//
// Parameters:
//
//   none
//
// Return:
//
//   none, the memory are guanrateed to be de-allocated, and set to NULL
//
///////////////////////////////////////////////////////////////////////////////
VOID FileTree::DeleteMultiThreadStruct(VOID)
{
	if(myThreadStruct != NULL)
	{
		delete [] myThreadStruct;
		myThreadStruct = NULL;
	}
	if(myThreadHandle != NULL)
	{
		delete [] myThreadHandle;
		myThreadHandle = NULL;
	}
}

///////////////////////////////////////////////////////////////////////////////
//
// Create, the true function for initializing a FileTree object
//
// Parameters:
//
//   pInLanguage, the language struct, contains information about directories
//                and others specified in the answer file
//   pInAnsParse, the parser for the answer file, contains information about
//                the base directory and so on
//   ppTree, pTree is the would be pointer to the FileTree
//   blnBase, whether or not this FileTree is a base tree
//
// Return:
//
//   PREP_BAD_PATH_ERROR, invalid directory encountered
//   PREP_NO_MEMORY, memory allocation failed
//   PREP_DIRECTORY_ERROR, cannot create some directory
//   PREP_SCRIPT_FILE_ERROR, cannot create or write to the scriptfile
//   PREP_INPUT_FILE_ERROR, pInLanguage is NULL, no input
//   PREP_NO_ERROR, no error
//
///////////////////////////////////////////////////////////////////////////////
INT FileTree::Create(IN PPATCH_LANGUAGE pInLanguage,
					IN AnswerParser* pInAnsParse,
					OUT FileTree** ppTree,
					IN BOOL blnBase,
					IN DWORD iInBestMethod,
					IN BOOL blnInCollectStat,
					IN BOOL blnInFullLog)
{
    DWORD cch;
    WCHAR wszBasePath[STRING_LENGTH];
    WCHAR* pwszJunk;
    FileTree* pTree;

    *ppTree = NULL;

	g_iBestMethod = iInBestMethod;
	g_blnCollectStat = blnInCollectStat;
	g_blnFullLog = blnInFullLog;

	if(pInLanguage)
	{
		cch = GetFullPathNameW(pInLanguage->s_wszDirectory,
			countof(wszBasePath), wszBasePath, &pwszJunk);
		if((cch == 0) || (cch >= countof(wszBasePath)))
		{
			return(PREP_BAD_PATH_ERROR);
		}

		if(wszBasePath[cch - 1] != L'\\')
		{
			wszBasePath[cch++] = L'\\';
			wszBasePath[cch] = L'\0';
		}

		DWORD dwAttributes = GetFileAttributesW(wszBasePath);
		if((dwAttributes == 0xFFFFFFFF) ||
			((dwAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0))
		{
			return(PREP_BAD_PATH_ERROR);
		}

		pTree = new FileTree(wszBasePath);
		if(pTree == NULL)
		{
			return(PREP_NO_MEMORY);
		}

		pTree->m_pLanguage = pInLanguage;
		pTree->m_pAnsParse = pInAnsParse;
		pTree->m_blnBase = blnBase;

		// create some directories
		if(!(pTree->CreateNewDirectory(pInLanguage->s_wszPatchDirectory,
										EMPTY) &&
			pTree->CreateNewDirectory(pInLanguage->s_wszSubPatchDirectory,
										EMPTY) &&
			pTree->CreateNewDirectory(pInLanguage->s_wszSubExceptDirectory,
										EMPTY)))
		{
			return(PREP_DIRECTORY_ERROR);
		}
		if(blnBase)
		{
			if(!pTree->CreateNewDirectory(pInAnsParse->m_wszBaseDirectory,
										EMPTY))
			{
				return(PREP_DIRECTORY_ERROR);
			}
		}
		DisplayDebugMessage(FALSE, FALSE, FALSE, FALSE,
							L"Directory created for patching.");

		// create the script file
		pTree->m_pLanguage->s_hScriptFile = CreateFileW(pTree->m_pLanguage->s_wszScriptFile,
														GENERIC_WRITE,
														0,
														NULL,
														CREATE_ALWAYS,
														FILE_ATTRIBUTE_NORMAL,
														NULL);
		if(pTree->m_pLanguage->s_hScriptFile == INVALID_HANDLE_VALUE)
		{
			return(PREP_SCRIPT_FILE_ERROR);
		}
		// write the unicode header to file
		WriteFile(pTree->m_pLanguage->s_hScriptFile, &UNICODE_HEAD,
			sizeof(WCHAR), &cch, NULL);
		ZeroMemory(pTree->m_strWriteBuffer, SUPER_LENGTH * sizeof(WCHAR));
		DisplayDebugMessage(FALSE, FALSE, FALSE, FALSE,
							L"Script file created for patching.");


		// initialized the critical section here
		InitializeCriticalSection(&(pTree->CSScriptFile));

		*ppTree = pTree;
	}
	else
	{
		return(PREP_INPUT_FILE_ERROR);
	}

    return(PREP_NO_ERROR);
}

///////////////////////////////////////////////////////////////////////////////
//
// Load, the entry point for processing files,
//       for a base tree, pTree should be NULL,
//       otherwise, use the pointer to base tree to process files
//
// Parameters:
//
//   pTree, a FileTree object, used to as a match target
//
// Return:
//
//   PREP_BAD_PATH_ERROR, invalid directory encountered
//   PREP_NO_MEMORY, memory allocation failed
//   PREP_DEPTH_ERROR, the directory tree is too deep
//   PREP_UNKNOWN_ERROR, the directory tree is too deep
//   PREP_NO_ERROR, no error
//
///////////////////////////////////////////////////////////////////////////////
INT FileTree::Load(IN FileTree* pTree)
{
    INT rc = PREP_NO_ERROR;
    
	// do the directory walk, this funtion will use the callback functions
	// to process files
    rc = DirectoryWalk(this, NULL, m_wszLocalRoot, NotifyDirectory,
						NotifyFile,
						NotifyDirectoryEnd, pTree);

	// at the end of matching, shutdown all threads and close the handles
	for(UINT i = 0; i < g_iThreads; i++)
	{
		if(WaitForSingleObject(myThreadHandle[i], INFINITE) != WAIT_FAILED)
		{
			CloseHandle(myThreadHandle[i]);
		}
		myThreadHandle[i] = NULL;
	}

	// determin error from the directory walk errors
    switch(rc)
    {
    case DW_NO_ERROR:
        rc = PREP_NO_ERROR;
        break;
    case DW_MEMORY:
        rc = PREP_NO_MEMORY;
        break;
    case DW_ERROR:
        rc = PREP_BAD_PATH_ERROR;
        break;
    case DW_DEPTH:
        rc = PREP_DEPTH_ERROR;
        break;
    case DW_OTHER_ERROR:
        rc = PREP_UNKNOWN_ERROR;
        break;
    default:
		break;
    }

	// print out the stats
	if(!m_pLanguage->s_blnBase)
	{
		DisplayDebugMessage(FALSE, FALSE, FALSE, TRUE,
							L"Patch results:");
		DisplayDebugMessage(FALSE, FALSE, FALSE, TRUE,
							L"%12I64u files total, %I64u bytes", m_cFiles,
							m_cbTotalFileSize);
		DisplayDebugMessage(FALSE, FALSE, FALSE, TRUE,
							L"%12I64u existing", m_cFilesExisting);
		DisplayDebugMessage(FALSE, FALSE, FALSE, TRUE,
							L"%12I64u zero-length", m_cFilesZeroLength);
		DisplayDebugMessage(FALSE, FALSE, FALSE, TRUE,
							L"%12I64u renamed", m_cFilesRenamed);
		DisplayDebugMessage(FALSE, FALSE, FALSE, TRUE,
							L"%12I64u copied (from another directory)",
							m_cFilesCopied);
		DisplayDebugMessage(FALSE, FALSE, FALSE, TRUE,
							L"%12I64u changed, %I64u bytes,	%I64u patched + %I64u raw",
							m_cFilesChanged, m_cbChangedFileSize,
							m_cbChangedFilePatchedSize,
							m_cbChangedFileNotPatchedSize);
		DisplayDebugMessage(FALSE, FALSE, FALSE, TRUE,
							L"%12I64u unique unmatched, %I64u bytes",
							m_cFilesNoMatch, m_cbNoMatchFileSize);
	}

    return(rc);
}

///////////////////////////////////////////////////////////////////////////////
//
// NotifyDirectory, the callback function used when a new directory is opened
//                  and ready to be processed for files, the directory can be
//                  any directory that the user has access to, also, directory
//                  processing is not multi-threaded, only the files
//
// Parameters:
//
//   context, a pointer to a FileTree object, this FileTree has called for a
//            directory walk
//   parentID, a pointer to the parent directory
//   directory, the name of the directory
//   path, the full path of the directory include then ending "\"
//   childID, a would be pointer to the this directory, so this directory is a
//            child of the parent directory
//   pTree, the matching tree
//
// Return:
//
//   PREP_NO_MEMORY, memory allocation failed
//   PREP_DIRECTORY_ERROR, unable to recreate the directory for base directory
//   PREP_NO_ERROR, no error
//
///////////////////////////////////////////////////////////////////////////////
INT FileTree::NotifyDirectory(
        IN VOID* context,
        IN VOID* parentID,
        IN CONST WCHAR* directory,
        IN CONST WCHAR* path,
        OUT VOID** childID,
		VOID* pTree
    )
{
	WCHAR wszDirectoryAttrib[LANGUAGE_LENGTH];
    FileTree* pThis = (FileTree*)context;
	DirectoryNode* pParent = (DirectoryNode*)parentID;

    if(parentID == NULL)
    {
        *childID = &pThis->m_Root;
    }
    else
    {
		// create the new directory node here
        DirectoryNode *pNew = new DirectoryNode(pThis,
								(DirectoryNode*)parentID, directory);
        if(pNew == NULL)
        {
            return(PREP_NO_MEMORY);
        }
		wcscpy(pNew->m_wszLongDirectoryName, path);
		pNew->m_wszDirectoryName = pNew->m_wszLongDirectoryName + 
								wcslen(path) - wcslen(directory);
        pThis->m_cDirectories++;

		// go match this directory if matchable
		if(pTree != NULL) pNew->Match((FileTree*)pTree);

        *childID = pNew;
    }

	if(pParent)
	{
		if(pThis->m_blnBase)
		{
			// create base directories
			if(!pThis->CreateNewDirectory(
				pThis->m_pAnsParse->m_wszBaseDirectory,
				path + pThis->m_pLanguage->s_iDirectoryCount))
			{
				return(PREP_DIRECTORY_ERROR);
			}
		}
		// save the directory creation to scriptfile
		// most localized trees do contain localized directory names, we need
		// to recreate them later with the same directory attributes
		DWORD iAttrib = GetFileAttributesW(path);
		ZeroMemory(wszDirectoryAttrib, LANGUAGE_LENGTH * sizeof(WCHAR));
		if((iAttrib & FILE_ATTRIBUTE_HIDDEN) == FILE_ATTRIBUTE_HIDDEN)
		{
			wcscat(wszDirectoryAttrib, DIR_HIDDEN);
		}
		if((iAttrib & FILE_ATTRIBUTE_READONLY) == FILE_ATTRIBUTE_READONLY)
		{
			wcscat(wszDirectoryAttrib, DIR_READONLY);
		}
		if((iAttrib & FILE_ATTRIBUTE_SYSTEM) == FILE_ATTRIBUTE_SYSTEM)
		{
			wcscat(wszDirectoryAttrib, DIR_SYSTEM);
		}
		if((iAttrib & FILE_ATTRIBUTE_COMPRESSED) == FILE_ATTRIBUTE_COMPRESSED)
		{
			wcscat(wszDirectoryAttrib, DIR_COMPRESSED);
		}
		if((iAttrib & FILE_ATTRIBUTE_ENCRYPTED) == FILE_ATTRIBUTE_ENCRYPTED)
		{
			wcscat(wszDirectoryAttrib, DIR_ENCRYPTED);
		}
		pThis->ToScriptFile(pThis,
							pThis->m_pLanguage->s_hScriptFile,
							ACTION_NEW_DIRECTORY,
							path + pThis->m_pLanguage->s_iDirectoryCount,
							wszDirectoryAttrib,
							FALSE);
	}

    return(DW_NO_ERROR);
}

///////////////////////////////////////////////////////////////////////////////
//
// NotifyFile, this is a callback function used when a new file is being
//             processed, also a static function to allow same entry point
//             for all files, supports multi-threaded file processing
//
// Parameters:
//
//   context, a pointer to a FileTree object, this FileTree has called for a
//            directory walk
//   parentID, a pointer to the parent directory
//   filename, the filename
//   path, the full path of the directory include then ending "\"
//   attributes, the file attribute
//   filetime, the last modified time, not used
//   creation, the creation time, not used
//   filesize, the size of the file in bytes
//   pTree, the matching tree
//
// Return:
//
//   DW_OTHER_ERROR, thread creation failed
//   DW_NO_ERROR, no error
//
///////////////////////////////////////////////////////////////////////////////
INT FileTree::NotifyFile(
        IN VOID* context,
        IN VOID* parentID,
        IN CONST WCHAR* filename,
        IN CONST WCHAR* path,
        IN DWORD attributes,
        IN FILETIME filetime,
        IN FILETIME creation,
        IN __int64 filesize,
		IN VOID* pTree
    )
{
	UINT i = 0;
	DWORD iThread = 0;

	// find an empty thread slot for file processing
	for(i = 0; i < g_iThreads; i++)
	{
		if(!myThreadStruct[i].blnInUse) break;
	}
	if(i < g_iThreads && !myThreadStruct[i].blnInUse)
	{
		// empty slot is found
		// make sure the thread is done and close the handle
		if(myThreadHandle[i] &&
			WaitForSingleObject(myThreadHandle[i], INFINITE) != WAIT_FAILED)
		{
			CloseHandle(myThreadHandle[i]);
		}
	}
	else
	{
		// empty slot is not found
		// wait for a thread to finish
		DWORD dwEvent = WaitForMultipleObjects(g_iThreads,
			myThreadHandle, FALSE, INFINITE);
		// there is a struct not in use, so find it and close the handle
		i = dwEvent - WAIT_OBJECT_0;
		CloseHandle(myThreadHandle[i]);
	}
	// reset the handle to null for insurance
	myThreadHandle[i] = NULL;

	// ready the multi-thread support struct to pass onto the actual processing
	// function, should try not to pass pointers here unless absolutely
	// necessary
	myThreadStruct[i].blnInUse = TRUE;
	myThreadStruct[i].pThis = (FileTree*)context;
	myThreadStruct[i].pParent = (DirectoryNode*)parentID;
	// the reason for copy the filenames is that once the thread is running,
	// the pointers are changed by the directory walk thread
	wcscpy(myThreadStruct[i].filename, filename);
	wcscpy(myThreadStruct[i].path, path);
	myThreadStruct[i].attributes = attributes;
	myThreadStruct[i].filetime = filetime;
	myThreadStruct[i].creation = creation;
	myThreadStruct[i].filesize = filesize;
	myThreadStruct[i].pTree = (FileTree*)pTree;
	// create the thread and give the struct
	myThreadHandle[i] = CreateThread(NULL,
									0,
									(LPTHREAD_START_ROUTINE)StartFileThread,
									(LPVOID)&myThreadStruct[i],
									0,
									&iThread);
	if(myThreadHandle[i] == NULL)
	{
		// thread creation failed
		return(DW_OTHER_ERROR);
	}

    return(DW_NO_ERROR);
}

///////////////////////////////////////////////////////////////////////////////
//
// StartFileThread, this is the original thread entry point, I did some debug
//                  work here before, but now it is just a wrapper to jump to
//                  the next function
//
// Parameters:
//
//   lpParam, the multi-thread struct, everything about this file ready to be
//            processed
//
// Return:
//
//   Whatever from ProcessFile
//
///////////////////////////////////////////////////////////////////////////////
DWORD WINAPI FileTree::StartFileThread(IN LPVOID lpParam)
{
	MULTI_THREAD_STRUCT* pStruct = (MULTI_THREAD_STRUCT*)lpParam;
	// translate the parameters and call the processing function
	return(ProcessFile(pStruct->pThis,
						pStruct->pParent,
						pStruct->filename,
						pStruct->path,
						pStruct->attributes,
						pStruct->filetime,
						pStruct->creation,
						pStruct->filesize,
						pStruct->pTree,
						pStruct));
}

///////////////////////////////////////////////////////////////////////////////
//
// ProcessFile, do actual file processing, determines what to do with the file,
//              computes filehash, try to match it, every file node is created
//              here, but deleted after usage to save memory
//
// Parameters:
//
//   same as in NotifyFile
//
// Return:
//
//   PREP_NO_MEMORY, allocation failed
//   DW_NO_ERROR, no error
//
///////////////////////////////////////////////////////////////////////////////
INT FileTree::ProcessFile(
		IN FileTree* pThis,
		IN DirectoryNode* pParent,
		IN CONST WCHAR* filename,
		IN CONST WCHAR* path,
		IN DWORD attributes,
		IN FILETIME filetime,
		IN FILETIME creation,
		IN __int64 filesize,
		IN FileTree* pTree,
		IN VOID* pStruct
    )
{
    WCHAR wszFullPathFileName[STRING_LENGTH];
	INT iLength = 0;

	// is the file an exception?
	if(!pThis->m_pAnsParse->IsFileExceptHash(filename))
	{
		// create the file node here
		FileNode* pNew = new FileNode(pParent, filename, filetime, filesize);    
		if(pNew == NULL)
		{
			return(PREP_NO_MEMORY);
		}
		pThis->m_cFiles++;
		pThis->m_cbTotalFileSize += filesize;

		// path includes the ending '\'
		// process filenames to get fullpath name
		iLength = wcslen(path);
		wcscpy(pNew->m_wszLongFileName, path);
		wcscat(pNew->m_wszLongFileName + iLength, filename);
		pNew->m_wszFileName = pNew->m_wszLongFileName + iLength;

		// computes the file content hash
		// file name hash is computed in (new FileNode)
		pNew->ComputeHash();

		if(!pThis->m_pLanguage->s_blnBase)
		{
			// match the file if the file is not in the base tree
			// the directory node should already be matched
			pNew->Match((FileTree*)pTree);
			// remove the filenode after use
			delete pNew;
			pNew = NULL;
		}
		else
		{
			// this language is the base language, need to copy files to base directory
			if(!pThis->CopyFileTo(pThis,
								ACTION_MOVE_FILE,
								pThis->m_pAnsParse->m_wszBaseDirectory,
								pNew->m_wszLongFileName + 
								pThis->m_pLanguage->s_iDirectoryCount,
								pNew->m_wszLongFileName,
								attributes))
			{
				// copy file failed, a warning
				DisplayDebugMessage(FALSE, FALSE, FALSE, FALSE,
									L"warning, file copy %ls failed, e=%d",
									filename, GetLastError());
			}
		}
	}
	else
	{
		// get full path, then move the file to patch\except directory
		wcscpy(wszFullPathFileName, path);
		wcscat(wszFullPathFileName, filename);
		if(!pThis->CopyFileTo(pThis,
							ACTION_EXCEPT_FILE,
							pThis->m_pLanguage->s_wszSubExceptDirectory,
							filename,
							wszFullPathFileName,
							attributes))
		{
			// copy file failed, a warning
			DisplayDebugMessage(FALSE, FALSE, FALSE, FALSE,
								L"warning, except file copy %ls failed, e=%d",
								filename, GetLastError());
		}
	}

	// reset the thread status so other threads can close the thread and
	// takes its place
	((MULTI_THREAD_STRUCT*)pStruct)->blnInUse = FALSE;

	return(DW_NO_ERROR);
}

///////////////////////////////////////////////////////////////////////////////
//
// NotifyDirectoryEnd, this callback function is used when the end of directory
//                     is encountered
//
// Parameters:
//
//   not used, just there for compiling
//
// Return:
//
//   DW_NO_ERROR, no error
//
///////////////////////////////////////////////////////////////////////////////
INT FileTree::NotifyDirectoryEnd(
		IN VOID*         pContext,
		IN VOID*         pParentID,
		IN CONST WCHAR*  pwszDirectory,
		IN CONST WCHAR*  pwszPath,
		IN VOID*         pChildID)
{
	// when the end of the directory is reached, all file processig thread
	// must be terminated, the reason is that each file rely on its parent,
	// a directory node, to know where it is at and how to match itself, but
	// the directory node pointer is changed when a new directory is
	// encountered, to avoid errors, all threads must exit.
	// the thread handles are not closed here, but they will be close either
	// through a new file thread creation or the end of Load.
	WaitForMultipleObjects(g_iThreads, myThreadHandle, TRUE, INFINITE);
	return(DW_NO_ERROR);
}

///////////////////////////////////////////////////////////////////////////////
//
// CreateNewDirectory, creates a directory with no attributes set, if the
//                     directory already exist, no new directory is created and
//                     attributes are not changed
//
// Parameters:
//
//   pwszLocal, the first part of the directory
//   pwszBuffer, the second part of the directory,
//               pwszLocal + pwszBuffer = full path of the new directory
//
// Return:
//
//   DW_NO_ERROR, no error
//
///////////////////////////////////////////////////////////////////////////////
BOOL FileTree::CreateNewDirectory(IN WCHAR* pwszLocal,
								  IN CONST WCHAR* pwszBuffer)
{
	BOOL blnReturn = FALSE;
	ULONG iLength = 0;
	ULONG iEntireLength = 0;

	iLength = wcslen(pwszLocal);
	wcscat(pwszLocal, pwszBuffer);
	// uses _wmdir instead of CreateDirectory so that error is easy to check,
	// errno is defined by CRT stdlib.h, and 17 is the EEXIST error code
	blnReturn = (_wmkdir(pwszLocal) == 0 || errno == 17 /*EEXIST*/);
	pwszLocal[iLength] = 0;

	return(blnReturn);
}

///////////////////////////////////////////////////////////////////////////////
//
// CopyFileTo, physically copy a file along with its attributes to another
//             location, used to save files that are not patched
//
// Parameters:
//
// pThis, pointer to this filetree
// pwszWhat, the action
// pwszLocal, the destination directory
// pwszFileName, the full path filename minus the directory specified in the
//               answerfile, pwszLocal + pwszFileName = new filename
// pwszOldFile, the full path oldfile
// attributes, this file's attributes
//
// Return:
//
// TRUE for file copied and logged into the scriptfile
// FALSE otherwise, should not stop processing files, but logs the entries
//
///////////////////////////////////////////////////////////////////////////////
BOOL FileTree::CopyFileTo(IN FileTree* pThis,
						  IN CONST WCHAR* pwszWhat,
						  IN WCHAR* pwszLocal,
						  IN CONST WCHAR* pwszFileName,
						  IN WCHAR* pwszOldFile,
						  IN DWORD attributes)
{
	BOOL blnReturn = FALSE;
	ULONG iLength = 0;
	ULONG iEntireLength = 0;
	WCHAR wszRandom[10];
	WCHAR wszTempString[STRING_LENGTH];

	iLength = wcslen(pwszLocal);
	iEntireLength = iLength + wcslen(pwszFileName);
	wcscpy(wszTempString, pwszLocal);
	wcscpy(wszTempString + iLength, pwszFileName);
	if(pwszWhat != ACTION_EXCEPT_FILE &&
		pwszWhat != ACTION_NOT_PATCH_FILE &&
		pwszWhat != ACTION_SAVED_FILE)
	{
		// error can be caused by file attributes
		blnReturn = CopyFileW(pwszOldFile, wszTempString, FALSE);
		if(!blnReturn)
		{
			SetFileAttributesW(wszTempString, FILE_ATTRIBUTE_ARCHIVE);
			blnReturn = CopyFileW(pwszOldFile, wszTempString, FALSE);
			SetFileAttributesW(wszTempString, attributes);
		}
	}
	else
	{
		// choose a different name if possible
		while((blnReturn = CopyFileW(pwszOldFile, wszTempString, TRUE)) ==
			FALSE)
		{
			ZeroMemory(wszRandom, 10 * sizeof(WCHAR));
			// randomly picks a number, total number of possible choice is 100,
			// there shouldn't be 100 same name file in a file tree
			_itow(rand() % FILE_LIMIT, wszRandom, 10);
			if(wcslen(wszRandom) + iEntireLength < STRING_LENGTH)
			{
				wcscpy(wszTempString + iEntireLength, wszRandom);
			}
			else
			{
				break;
			}
		}
	}
	if(blnReturn)
	{
		// remember what to do later
		if(pwszWhat != ACTION_MOVE_FILE)
		{
			pThis->ToScriptFile(pThis,
				pThis->m_pLanguage->s_hScriptFile,
				pwszWhat,
				wszTempString + pThis->m_pLanguage->s_iPatchDirectoryCount,
				pwszOldFile + pThis->m_pLanguage->s_iDirectoryCount,
				FALSE);
		}
		else
		{
			pThis->ToScriptFile(pThis,
				pThis->m_pLanguage->s_hScriptFile,
				pwszWhat,
				wszTempString + DRIVE_LETTER_LENGTH,
				pwszOldFile + pThis->m_pLanguage->s_iDirectoryCount,
				FALSE);
		}
	}

	return(blnReturn);
}

///////////////////////////////////////////////////////////////////////////////
//
// ToScriptFile, save actions into the scriptfile so that apply patch can be
//               done later on the client side
//
// Parameters:
//
//   pThis, pointer to this filetree
//   hFile, the handle of the script file
//   pwszWhat, the action to be saved
//   pwszFirst, first string to be saved
//   pwszSecond, the second string to be saved
//   blnFlush, TRUE to flush the saved buffer to write, FALSE = do not flush
//
// Note:
//
//    where blnFlush is set to TRUE, all other parameters are ignored
//
// Return:
//
//   none
//
///////////////////////////////////////////////////////////////////////////////
VOID FileTree::ToScriptFile(IN FileTree* pThis,
							IN HANDLE hFile,
							IN CONST WCHAR* pwszWhat,
							IN CONST WCHAR* pwszFirst,
							IN WCHAR* pwszSecond, 
							IN BOOL blnFlush)
{
	ULONG iFirstLength = 0;
	ULONG iLength = 0;
	ULONG iBegin = 0;
	ULONG iSecondLength = 0;
	ULONG iWriteBytes = 0;

    __try
    {
        // critical section lock on the scriptfile
        EnterCriticalSection(&(pThis->CSScriptFile));
		if(!blnFlush && pwszWhat && pwszFirst &&
			(iFirstLength = wcslen(pwszFirst)) > 0)
		{
			// 1: the action
			// 1: the * separator
			// 1: the end of line
			// 1: the carriage return
			iLength = 4 + iFirstLength;
			if(pwszSecond && (iSecondLength = wcslen(pwszSecond)) > 0)
			{
				// 1: the * separator
				iLength += 1 + iSecondLength;
			}
			iBegin = pThis->m_iSize;
			pThis->m_iSize += iLength;
			if(pThis->m_iSize + 1 < SUPER_LENGTH)
			{
				// buffer the message up
				wcscpy(pThis->m_strWriteBuffer + iBegin, pwszWhat);
				wcscpy(pThis->m_strWriteBuffer + iBegin + 1, SEPARATOR);
				wcscpy(pThis->m_strWriteBuffer + iBegin + 2, pwszFirst);
				if(pwszSecond && iSecondLength > 0)
				{
					wcscpy(pThis->m_strWriteBuffer + iBegin + 2 + iFirstLength,
						SEPARATOR);
					wcscpy(pThis->m_strWriteBuffer + iBegin + 3 + iFirstLength,
						pwszSecond);
				}
				wcscpy(pThis->m_strWriteBuffer + pThis->m_iSize - 2, ENDOFLINE);
				wcscpy(pThis->m_strWriteBuffer + pThis->m_iSize - 1, CRETURN);
			}
			else
			{
				// overflow, write the buffer out
				WriteFile(hFile, pThis->m_strWriteBuffer,
					iBegin * sizeof(WCHAR), &iWriteBytes, NULL);
				ZeroMemory(pThis->m_strWriteBuffer,
					SUPER_LENGTH * sizeof(WCHAR));
				wcscpy(pThis->m_strWriteBuffer, pwszWhat);
				wcscpy(pThis->m_strWriteBuffer + 1, SEPARATOR);
				wcscpy(pThis->m_strWriteBuffer + 2, pwszFirst);
				if(iSecondLength > 0)
				{
					wcscpy(pThis->m_strWriteBuffer + 2 + iFirstLength,
						SEPARATOR);
					wcscpy(pThis->m_strWriteBuffer + 3 + iFirstLength,
						pwszSecond);
				}
				wcscpy(pThis->m_strWriteBuffer + iLength - 2, ENDOFLINE);
				wcscpy(pThis->m_strWriteBuffer + iLength - 1, CRETURN);
				pThis->m_iSize = iLength;
			}
		}
		else if(blnFlush && pThis->m_iSize > 0)
		{
			// flush the buffer to file
			WriteFile(hFile, pThis->m_strWriteBuffer,
				pThis->m_iSize * sizeof(WCHAR), &iWriteBytes, NULL);
			pThis->m_iSize = 0;
		}
	}
    __finally
    {
        LeaveCriticalSection(&(pThis->CSScriptFile));
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  class DirectoryNode
//
////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//
// DirectoryNode, constructor for the DirectoryNode object, directory name hash
//                is created here
//
// Parameters:
//
//   pRoot, the filetree object that contains this directory
//   pParent, the parent directory node
//   pwszDirectoryName, the name of the directory
//
// Return:
//
//   none
//
///////////////////////////////////////////////////////////////////////////////
DirectoryNode::DirectoryNode(IN FileTree* pRoot,
							 IN DirectoryNode* pParent,
							 IN CONST WCHAR* pwszDirectoryName)
{
    m_pParent = pParent;
    m_pFirstChild = NULL;
    m_pNext = NULL;
    m_pRoot = pRoot;
    m_pMatchingDirectory = NULL;
    m_cchDirectoryName = wcslen(pwszDirectoryName);
	m_wszDirectoryName = NULL;
    if(pParent != NULL)
    {
        m_pNext = pParent->m_pFirstChild;
        pParent->m_pFirstChild = this;
    }
    m_DirectoryNameHash = CRC32Update(0, (UCHAR*)pwszDirectoryName,
		sizeof(WCHAR) * m_cchDirectoryName);
}

///////////////////////////////////////////////////////////////////////////////
//
// ~DirectoryNode, destructor, responsible for clean up its own child
//                 directories, file nodes are not removed here, but in the
//                 destructor of the filetree
//
// Parameters:
//
//   none
//
// Return:
//
//   none
//
///////////////////////////////////////////////////////////////////////////////
DirectoryNode::~DirectoryNode(VOID)
{
	// remove the directory nodes
	DirectoryNode* pDirectory = m_pFirstChild;
    while(pDirectory)
    {
        DirectoryNode* pNext = pDirectory->m_pNext;
        delete pDirectory;
		pDirectory = NULL;
        pDirectory = pNext;
    }
}

///////////////////////////////////////////////////////////////////////////////
//
// Match, this function is used to match a directory with another directory in
//        the BaseTree, must be called before processing a file, otherwise,
//        some matches do not make any sense
//
// Parameters:
//
//   pBaseTree, the pointer to the BaseTree
//
// Return:
//
//   PREP_NO_ERROR, no error
//
///////////////////////////////////////////////////////////////////////////////
INT DirectoryNode::Match(IN FileTree* pBaseTree)
{
    DirectoryNode* pChoice = NULL;

    // match this directory
    if(m_pParent == NULL)
    {
        // Rule: localized root's mate is base root
        m_pMatchingDirectory = &pBaseTree->m_Root;
    }
    else if(m_pParent->m_pMatchingDirectory != NULL)
    {
        // Rule: choose the cousin with an identical name
        // from this directory's parent's mate's children
        pChoice = m_pParent->m_pMatchingDirectory->m_pFirstChild;
        while(pChoice != NULL)
        {
            if((m_DirectoryNameHash == pChoice->m_DirectoryNameHash) &&
                (wcscmp(m_wszDirectoryName, pChoice->m_wszDirectoryName) == 0))
            {
				// update the matching directory member
                m_pMatchingDirectory = pChoice;
                break;
            }
            pChoice = pChoice->m_pNext;
        }
    }
    else
    {
        // Rule: I have no cousins if my parent has no mate.
    }

    return(PREP_NO_ERROR);
}

////////////////////////////////////////////////////////////////////////////////////////////////////
//
//  class FileNode
//
////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////
//
// FileNode, constructor for the FileNode object, compute for a name hash, file
//           content hash is computed by ComputeHash
//
// Parameters:
//
//   pParent, the parent directory
//   pwszFileName, the name of the file
//   ftLastModified, time the file was touched, not used
//   iFileSize, the size of the file in bytes
//
// Return:
//
//   none
//
///////////////////////////////////////////////////////////////////////////////
FileNode::FileNode(IN DirectoryNode* pParent,
				   IN CONST WCHAR* pwszFileName,
				   IN FILETIME ftLastModified,
				   IN __int64 iFileSize)
{
    m_pParent = pParent;
    m_ftLastModified = ftLastModified;
    m_iFileSize = iFileSize;
    m_cchFileName = wcslen(pwszFileName);
	m_wszFileName = NULL;    
    m_pNextHashHash = NULL;
    m_pNextNameHash = NULL;
    m_FileNameHash = CRC32Update(0, (UCHAR*)pwszFileName,
		sizeof(WCHAR) * m_cchFileName);
    unsigned iNameHash = m_FileNameHash % HASH_SIZE;
    m_pNextNameHash = pParent->m_pRoot->m_aNameTable[iNameHash];
    pParent->m_pRoot->m_aNameTable[iNameHash] = this;
    m_fPostCopySource = 0;
}

///////////////////////////////////////////////////////////////////////////////
//
// ~FileNode, the destructor for a file node, does not
//
// Parameters:
//
//   none
//
// Return:
//
//   none
//
///////////////////////////////////////////////////////////////////////////////
FileNode::~FileNode(VOID)
{
}

///////////////////////////////////////////////////////////////////////////////
//
// Nibble, an inline function used to calculate a value for file content hash
//
// Parameters:
//
//   wch, a single unicoded character
//
// Return:
//
//   a BYTE that is intended for hashing
//
///////////////////////////////////////////////////////////////////////////////
__inline BYTE Nibble(WCHAR wch)
{
    if((wch >= L'0') && (wch <= L'9'))
    {
        return((BYTE)(wch - L'0'));
    }
    else if((wch >= L'A') && (wch <= L'F'))
    {
        return((BYTE)(wch - L'A' + 10));
    }
    else if((wch >= L'a') && (wch <= L'f'))
    {
        return((BYTE)(wch - L'a' + 10));
    }
    else
    {
        return(99);
    }
}

///////////////////////////////////////////////////////////////////////////////
//
// ComputeHash, produces a hash value for the file content, almost unique for
//              all files, the hash value is of MD5, a 16 byte value
//
// Parameters:
//
//   none
//
// Return:
//
//   PREP_NO_ERROR, no error
//   PREP_HASH_ERROR, hash error, wrong hash value
//
///////////////////////////////////////////////////////////////////////////////
INT FileNode::ComputeHash(VOID)
{
    INT rc = PREP_NO_ERROR;

    if(m_iFileSize == 0)
    {
        memset(m_Hash, 0, sizeof(m_Hash));
    }
    else
    {
		WCHAR wszBuffer[STRING_LENGTH];
		// filename, then hash
        if(GetFilePatchSignatureW(m_wszLongFileName,
								(PATCH_OPTION_NO_REBASE |
								PATCH_OPTION_NO_BINDFIX |
								PATCH_OPTION_NO_LOCKFIX |
								PATCH_OPTION_NO_RESTIMEFIX |
								PATCH_OPTION_SIGNATURE_MD5),
								NULL,
								0, NULL,                // no ignore
								0, NULL,                // no retain
								sizeof(wszBuffer),      // buffer size in bytes
								wszBuffer))
        {
            WCHAR* pwch = wszBuffer;

            for(INT i = 0; i < sizeof(m_Hash); i++)
            {
                BYTE hiNibble = Nibble(*pwch++);
                BYTE loNibble = Nibble(*pwch++);

                m_Hash[i] = (BYTE)((hiNibble << 4) + loNibble);
                if((hiNibble > 0x0F) || (loNibble > 0x0F))
                {
                    rc = PREP_HASH_ERROR;
                    break;
                }
            }
            if(*pwch != L'\0')
            {
                rc = PREP_HASH_ERROR;
            }
        }
        else
        {
			DisplayDebugMessage(FALSE, FALSE, FALSE, TRUE,
								L"warning, GetFilePatchSignatureW() failed,	GLE=%08X\n, F=%ls", GetLastError(),
								m_wszLongFileName);
            rc = PREP_HASH_ERROR;
        }
    }

    if(rc == PREP_NO_ERROR)
    {
        // add this file to root's hash table
        unsigned iHashHash = (*(UINT*)(&m_Hash[0])) % HASH_SIZE;
        m_pNextHashHash = m_pParent->m_pRoot->m_aHashTable[iHashHash];
        m_pParent->m_pRoot->m_aHashTable[iHashHash] = this;
    }

    return(rc);
}

///////////////////////////////////////////////////////////////////////////////
//
// Match, the file node is attempting to match with another file in the base
//        trees interms of filename and filecontent through hashing, there are
//        a total of 6 rules, in practice, rule 0 and 2 can be ignored
//
// Parameters:
//
//   pBaseTree, the FileTree object that is intended to match with
//
// Return:
//
//   PREP_NO_ERROR, no error
//
///////////////////////////////////////////////////////////////////////////////
INT FileNode::Match(IN FileTree* pBaseTree)
{
	WCHAR wszTempName[STRING_LENGTH];
    DETERMINATION eDetermination;
    unsigned iHashHash = (*(UINT*)(&m_Hash[0])) % HASH_SIZE;
    unsigned iNameHash = m_FileNameHash % HASH_SIZE;
    FileTree *pLocalizedTree = m_pParent->m_pRoot;
    FileNode *pChoice = NULL;

    pLocalizedTree->m_cFilesDetermined++;
    fprintf(stderr, "%I64u of %I64u\r",
		pLocalizedTree->m_cFilesDetermined, pLocalizedTree->m_cFiles);

    // Rule 0
	// What: files that are of the same name, same content, same location in base and localized tree
	// What to do here: record the location and name of the files with a move tag in the script file
	// What to do later: the base file needs to be moved from the base to localized directory
    if(m_pParent->m_pMatchingDirectory != NULL)
    {
        pChoice = pBaseTree->m_aHashTable[iHashHash];
        while(pChoice != NULL)
        {
            if((m_FileNameHash == pChoice->m_FileNameHash) &&
                (m_pParent->m_pMatchingDirectory == pChoice->m_pParent) &&
                (memcmp(m_Hash, pChoice->m_Hash, sizeof(m_Hash)) == 0) &&
                (wcscmp(m_wszFileName, pChoice->m_wszFileName) == 0))
            {
                eDetermination = DETERMINATION_EXISTING;
                pLocalizedTree->m_cFilesExisting++;
				wcscpy(wszTempName,
					pLocalizedTree->m_pAnsParse->m_wszBaseDirectory +
					DRIVE_LETTER_LENGTH);
				wcscat(wszTempName,
					pChoice->m_wszLongFileName +
					pBaseTree->m_pLanguage->s_iDirectoryCount);
				pLocalizedTree->ToScriptFile(pLocalizedTree,
							pLocalizedTree->m_pLanguage->s_hScriptFile,
							ACTION_MOVE_FILE,
							wszTempName,
							m_wszLongFileName +
							pLocalizedTree->m_pLanguage->s_iDirectoryCount,
							FALSE);
                goto done;
            }
            pChoice = pChoice->m_pNextHashHash;
        }
    }

    // Rule 1
	// What: files that are of zero length in the localized tree
	// What to do here: record the location and name of the files with a zero tag in the script file
	// What to do later: re-create the zero length file
    if(m_iFileSize == 0)
    {
        eDetermination = DETERMINATION_ZERO_LENGTH;
		pLocalizedTree->ToScriptFile(pLocalizedTree,
			pLocalizedTree->m_pLanguage->s_hScriptFile,
			ACTION_NEW_ZERO_FILE,
			m_wszLongFileName +
			pLocalizedTree->m_pLanguage->s_iDirectoryCount,
			NULL,
			FALSE);		
        pLocalizedTree->m_cFilesZeroLength++;
        goto done;
    }

    // Rule 2
	// What: files that are of the different name, same content, same location in base and localized tree
	// What to do here: record the location of the files with a rename tag in the script file
	// What to do later: the base file needs to be renamed(actually moved) from the base to localized directory
    if(m_pParent->m_pMatchingDirectory != NULL)
    {
        pChoice = pBaseTree->m_aHashTable[iHashHash];
        while(pChoice != NULL)
        {
            if((m_pParent->m_pMatchingDirectory == pChoice->m_pParent) &&
                (memcmp(m_Hash, pChoice->m_Hash, sizeof(m_Hash)) == 0))
            {
                eDetermination = DETERMINATION_RENAMED;
                pLocalizedTree->m_cFilesRenamed++;
				wcscpy(wszTempName,
					pLocalizedTree->m_pAnsParse->m_wszBaseDirectory +
					DRIVE_LETTER_LENGTH);
				wcscat(wszTempName,
					pChoice->m_wszLongFileName +
					pBaseTree->m_pLanguage->s_iDirectoryCount);
				pLocalizedTree->ToScriptFile(pLocalizedTree,
								pLocalizedTree->m_pLanguage->s_hScriptFile,
								ACTION_RENAME_FILE,
								wszTempName,
								m_wszLongFileName +
								pLocalizedTree->m_pLanguage->s_iDirectoryCount,
								FALSE);
                goto done;
            }
            pChoice = pChoice->m_pNextHashHash;
        }
    }

    // Rule 3
	// What: files that are of the different name, same content, different location in base and localized tree,
	//       different location means that "same" directory but the directory name is localized
	// What to do here: record the location of the files with a copy tag in the script file
	// What to do later: the base file needs to be copied from the base to localized directory
    pChoice = pBaseTree->m_aHashTable[iHashHash];
    while(pChoice != NULL)
    {
        if(memcmp(m_Hash, pChoice->m_Hash, sizeof(m_Hash)) == 0)
        {
            eDetermination = DETERMINATION_COPIED;
            pLocalizedTree->m_cFilesCopied++;
			wcscpy(wszTempName,
				pLocalizedTree->m_pAnsParse->m_wszBaseDirectory +
				DRIVE_LETTER_LENGTH);
			wcscat(wszTempName,
				pChoice->m_wszLongFileName +
				pBaseTree->m_pLanguage->s_iDirectoryCount);
			pLocalizedTree->ToScriptFile(pLocalizedTree,
						pLocalizedTree->m_pLanguage->s_hScriptFile,
						ACTION_COPY_FILE,
						wszTempName,
						m_wszLongFileName +
						pLocalizedTree->m_pLanguage->s_iDirectoryCount,
						FALSE);
            goto done;
        }
        pChoice = pChoice->m_pNextHashHash;
    }

    // Rule 4
	// What: files with the same name, whatever location, different file content
	// What to do here: record the location of the base file, patch file, and destination file with a patch tag in the script file
	// What to do later: the localized file needs to be re-created from the base and patch file
    pChoice = pBaseTree->m_aNameTable[iNameHash];
    {
        while(pChoice != NULL)
        {
            if((m_FileNameHash == pChoice->m_FileNameHash) &&
                (wcscmp(m_wszFileName, pChoice->m_wszFileName) == 0))
            {
                eDetermination = DETERMINATION_PATCHED;
				wcscpy(wszTempName,
					pLocalizedTree->m_pLanguage->s_wszSubPatchDirectory);
				wcscat(wszTempName, m_wszFileName);
				wcscat(wszTempName, PATCH_EXT);
                pLocalizedTree->m_cFilesChanged++;
                pLocalizedTree->m_cbChangedFileSize += m_iFileSize;
                goto done;
            }
            pChoice = pChoice->m_pNextNameHash;
        }
    }

    // Rule 5
	// What: files that are not matched, considered as unique
	// What to do here: copy the file into the except directory for storage, 
	//                  record the location of the localized file with a saved file tag
	// What to do later: move the except file to the localized file location
    eDetermination = DETERMINATION_UNMATCHED;
	pLocalizedTree->CopyFileTo(pLocalizedTree,
					ACTION_SAVED_FILE,
					pLocalizedTree->m_pLanguage->s_wszSubExceptDirectory,
					m_wszFileName,
					m_wszLongFileName,
					0);
    pLocalizedTree->m_cFilesNoMatch++;
    pLocalizedTree->m_cbNoMatchFileSize += m_iFileSize;
	
done:

    // If it's a patching candidate, try it.  Might demote to unmatched.
    if(eDetermination == DETERMINATION_PATCHED)
    {
        // try to patch it
        __int64 cbPatchedSize = 0;
		WCHAR wszOldFile[STRING_LENGTH];
        if((m_iFileSize < MAX_PATCH_TARGET_SIZE) &&
            (BuildPatch(pChoice->m_wszLongFileName, m_wszLongFileName,
			wszTempName, &cbPatchedSize) == PREP_NO_ERROR) &&
            (cbPatchedSize < m_iFileSize))
        {
			// the oldfile is now in the base directory
			wcscpy(wszOldFile,
				pLocalizedTree->m_pAnsParse->m_wszBaseDirectory +
				DRIVE_LETTER_LENGTH);
			wcscat(wszOldFile, pChoice->m_wszLongFileName +
				pBaseTree->m_pLanguage->s_iDirectoryCount);
			// the patch file and the newfile
			wcscat(wszTempName, SEPARATOR);
			wcscat(wszTempName,
				m_wszLongFileName +
				pLocalizedTree->m_pLanguage->s_iDirectoryCount);
			// record the information for apply the patch later
			pLocalizedTree->ToScriptFile(pLocalizedTree,
						pLocalizedTree->m_pLanguage->s_hScriptFile,
						ACTION_PATCH_FILE,
						wszOldFile,
						wszTempName +
						pLocalizedTree->m_pLanguage->s_iPatchDirectoryCount,
						FALSE);
            pLocalizedTree->m_cbChangedFilePatchedSize += cbPatchedSize;
        }
        else
        {
			// if un-success, move the file into the except directory and record the information, so the file
			// can be moved to its original position later
            eDetermination = DETERMINATION_UNMATCHED;
			pLocalizedTree->CopyFileTo(pLocalizedTree,
						ACTION_NOT_PATCH_FILE,
						pLocalizedTree->m_pLanguage->s_wszSubExceptDirectory,
						m_wszFileName,
						m_wszLongFileName,
						0);
			DeleteFileW(wszTempName);
            pLocalizedTree->m_cbChangedFileNotPatchedSize += m_iFileSize;
        }
    }

	if(g_blnFullLog)
	{
		DisplayDebugMessage(TRUE, FALSE, FALSE, FALSE,
							L"N=%05I64u\tF=%ls\tS=%I64u",
							pLocalizedTree->m_cFilesDetermined, m_wszFileName,
							m_iFileSize);
	}
    
	return(PREP_NO_ERROR);
}

///////////////////////////////////////////////////////////////////////////////
//
// BuildPatch, a wrapper function that handles the actual patching
//
// Parameters:
//
//   pwszBaseFileName, the oldfile, the base file
//   pwszLocFileName, the localized file
//   pwszTempPatchFileName, the intended patch filename, can be changed
//
// Return:
//
//   PREP_UNKNOWN_ERROR, something went wrong with the patch file created
//   PREP_NOT_PATCHABLE, not patched
//   PREP_NO_ERROR, no error
//
///////////////////////////////////////////////////////////////////////////////
INT FileNode::BuildPatch(IN WCHAR* pwszBaseFileName, 
						 IN WCHAR* pwszLocFileName,
						 IN OUT WCHAR* pwszTempPatchFileName,
						 OUT __int64* pcbPatchSize)
{
    INT rc = PREP_NO_ERROR;
	HANDLE hFile = INVALID_HANDLE_VALUE;

	// choose a different name if possible
	hFile = CreateFileW(pwszTempPatchFileName,
						GENERIC_READ,
						0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);
	if(hFile == INVALID_HANDLE_VALUE)
	{
		ULONG iLength = wcslen(pwszTempPatchFileName);
		WCHAR wszRandom[10];
		do
		{
			ZeroMemory(wszRandom, 10 * sizeof(WCHAR));
			_itow(rand() % FILE_LIMIT, wszRandom, 10);
			wcscpy(pwszTempPatchFileName + iLength, wszRandom);
			hFile = CreateFileW(pwszTempPatchFileName,
								GENERIC_READ,
								0, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL,
								NULL);
		}
		while(hFile == INVALID_HANDLE_VALUE);
	}
	CloseHandle(hFile);

	// do patch
    if(CreatePatchFileW(pwszBaseFileName,
						pwszLocFileName,
						pwszTempPatchFileName,
						g_iBestMethod,
						NULL))
    {
		// collect the stats, don't do this unless it is necessary, open a file
		// and close a file can take a long time
		if(g_blnCollectStat)
		{
			HANDLE handle = CreateFileW(pwszTempPatchFileName,
									   GENERIC_READ,
									   0,
									   NULL,
									   OPEN_EXISTING,
									   0,
									   NULL);

			if(handle != INVALID_HANDLE_VALUE)
			{
				DWORD dwFileSizeLow = 0;
				DWORD dwFileSizeHigh = 0;
				DWORD dwError = 0;

				dwFileSizeLow = GetFileSize(handle, &dwFileSizeHigh);
				dwError = GetLastError();
				if((dwFileSizeLow == 0xFFFFFFFF) && (dwError != NO_ERROR))
				{
					DisplayDebugMessage(FALSE, FALSE, FALSE, FALSE,
					L"warning, Created a patch,	but can't get patch file size. GLE=%08X, F=%ls",
					dwError, pwszTempPatchFileName);
					rc = PREP_UNKNOWN_ERROR;
				}
				else
				{
					*pcbPatchSize = (((__int64) dwFileSizeHigh) << 32) + 
										dwFileSizeLow;
					rc = PREP_NO_ERROR;
				}
				CloseHandle(handle);
			}
			else
			{
				DisplayDebugMessage(FALSE, FALSE, FALSE, FALSE,
				L"warning, Created a patch, but can't open the patch file.  GLE=%08X, F=%ls",
				GetLastError(), pwszTempPatchFileName);
				rc = PREP_UNKNOWN_ERROR;
			}
		}
    }
    else
    {
        DWORD dwError = GetLastError();
		DisplayDebugMessage(FALSE, FALSE, FALSE, FALSE,
			L"warning, CreatePatchFileW(\"%ls\") failed, GLE=%08X",
			pwszLocFileName, dwError);
        rc = PREP_NOT_PATCHABLE;
    }

    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oemtools\oempatch\const.h ===
#ifndef CONST_H
#define CONST_H

#include "oemshare.h"

#define PREP_NO_ERROR           (0)     // nothing bad happened
#define PREP_NO_MEMORY          (1)     // allocation failed
#define PREP_BAD_PATH_ERROR     (2)     // problem scanning directory
#define PREP_UNKNOWN_ERROR      (3)     // problem
#define PREP_DEPTH_ERROR        (4)     // directory is too deep
#define PREP_BAD_COMMAND        (5)     // error in command line syntax
#define PREP_HASH_ERROR         (6)     // error computing file hash
#define PREP_BUFFER_OVERFLOW    (7)     // an internal buffer was overrun
#define PREP_NOT_PATCHABLE      (8)     // not worth patching (internal)
#define PREP_INPUT_FILE_ERROR   (9)     // answer file is incorrect
#define PREP_SCRIPT_FILE_ERROR  (10)    // cannot save to scriptfile
#define PREP_PATCH_FILE_ERROR   (11)    // cannot create patch file
#define PREP_DIRECTORY_ERROR    (12)    // cannot create the directories
#define PREP_COPY_FILE_ERROR    (13)    // cannot copy files

#define HASH_SIZE               (13)                // (10007) large, prime
#define MAX_PATCH_TARGET_SIZE   (10 * 1024 * 1024)  // 10Mb max patch file size
#define countof(a) (sizeof((a)) / sizeof((a)[0]))   // a simple char counter

typedef enum
{
    DETERMINATION_EXISTING,
    DETERMINATION_ZERO_LENGTH,
    DETERMINATION_RENAMED,
    DETERMINATION_COPIED,
    DETERMINATION_DUPLICATED,
    DETERMINATION_PATCHED,
    DETERMINATION_UNMATCHED
}
DETERMINATION;

static CONST ULONG g_iMajorVersion = 1;
static CONST ULONG g_iMinorVersion = 0;

static CONST WCHAR ANS_FILE_NAME[] = L"OEMPatch.ans";
static CONST WCHAR LOG_FILE_NAME[] = L"OEMPatch.log";
static CONST WCHAR PATCH_SUB_PATCH[] = L"\\Patch\\";
static CONST WCHAR PATCH_SUB_EXCEPT[] = L"\\";
static CONST WCHAR PATCH_EXT[] = L".jxw";

static CONST ULONG FILE_LIMIT = 100;
static CONST ULONG LANGUAGE_COMPLETE = 3;
// need to be a prime number for hashing
// this is the maximum allowed number of except file, typical to give a good hashing performance,
// this number is 2 * number of actual files
// check out http://www.utm.edu/research/primes/lists/small/10000.txt for prime numbers
static CONST ULONG EXCEP_FILE_LIMIT = 349;

// log file constants
static CONST WCHAR SPACE[] = L" ";
static CONST WCHAR BANNER[] = L"----------------------------------------\015\012";
static CONST ULONG BANNER_LENGTH = 42;
static CONST ULONG TIME_LENGTH = 12;

// log file function
VOID DisplayDebugMessage(IN BOOL blnTime,
						 IN BOOL blnBanner,
						 IN BOOL blnFlush,
						 IN BOOL blnPrint,
						 IN WCHAR* pwszWhat,
						 ...);

#endif // CONST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oemtools\oempatch\filetree.h ===
#ifndef FILETREE_H
#define FILETREE_H

class FileNode;
class DirectoryNode;
class FileTree;

///////////////////////////////////////////////////////////////////////////////
//
// MULTI_THREAD_STRUCT, a parameter container, used when passing parameters to
//                      a thread for file processing
//
///////////////////////////////////////////////////////////////////////////////
typedef struct _MULTI_THREAD_STRUCT
{
    FileTree* pThis;
    DirectoryNode* pParent;
    WCHAR filename[STRING_LENGTH];
    WCHAR path[STRING_LENGTH];
	DWORD attributes;
	FILETIME filetime;
	FILETIME creation;
	__int64 filesize;
	FileTree* pTree;
	BOOL blnInUse;
}
MULTI_THREAD_STRUCT;

///////////////////////////////////////////////////////////////////////////////
//
// FileNode, each file would have its own filenode object to store and
//           determine what to do about this file
//
///////////////////////////////////////////////////////////////////////////////
class FileNode
{
    friend class DirectoryNode;

public:
	FileNode(IN DirectoryNode* pParent,
			IN CONST WCHAR* pwszFileName,
			IN FILETIME ftLastModified,
			IN __int64 iFileSize);
	~FileNode(VOID);
    INT ComputeHash(VOID);
    INT Match(IN FileTree* pBaseTree);
    INT BuildPatch(IN WCHAR* pwszBaseFileName, 
					IN WCHAR* pwszLocFileName,
					IN OUT WCHAR* pwszTempPatchFileName,
					OUT __int64* pcbPatchSize);
public:
	WCHAR m_wszLongFileName[STRING_LENGTH];
	WCHAR* m_wszFileName;			// name of this file, ie, "kernel32.dll"

    FileNode* m_pNextNameHash;      // next file with same filename hash
private:
    FileNode* m_pNextHashHash;      // next file with same hash hash
    DirectoryNode* m_pParent;       // parent directory
	FILETIME m_ftLastModified;		// last-modified timestamp
	__int64 m_iFileSize;			// size of file in bytes
    INT m_fPostCopySource;          // another file plans to postcopy this one
    unsigned m_FileNameHash;        // hash of m_wszFileName
    BYTE m_Hash[16];                // file content's MD5 signature
    INT m_cchFileName;              // length of m_wszFileName in characters, excl. term.
};

///////////////////////////////////////////////////////////////////////////////
//
// DirectoryNode, each directory is associated with its own dirctorynode, which
//                contains all information about this directory
//
///////////////////////////////////////////////////////////////////////////////
class DirectoryNode
{
    friend class FileNode;

public:
	DirectoryNode(IN FileTree* pRoot,
					IN DirectoryNode* pParent,
					IN CONST WCHAR* pwszDirectoryName);
	~DirectoryNode(VOID);
    WCHAR* GetDirectoryName(VOID);

    INT Match(IN FileTree* pBaseTree);

public:
	WCHAR m_wszLongDirectoryName[STRING_LENGTH];
	WCHAR* m_wszDirectoryName;      // name of this directory, ie, "system32"

private:
    FileTree* m_pRoot;              // pointer to FileTree
	DirectoryNode* m_pParent;		// parent of this node
	DirectoryNode* m_pNext;			// next sibling of this node
	DirectoryNode* m_pFirstChild;	// first child directory
    DirectoryNode* m_pMatchingDirectory;    // ptr to mate in base tree
    unsigned m_DirectoryNameHash;   // hash of m_wszDirectoryName
    INT m_cchDirectoryName;         // length of m_wszDirectoryName in characters, excl. term.
};

///////////////////////////////////////////////////////////////////////////////
//
// FileTree, a tree of directory and file nodes, used to match with another
//           filetree using hashing techniques
//
///////////////////////////////////////////////////////////////////////////////
class FileTree
{
    friend class FileNode;
    friend class DirectoryNode;

public:
	static BOOL CreateMultiThreadStruct(IN ULONG iNumber);
	static VOID DeleteMultiThreadStruct(VOID);
    static INT Create(IN PPATCH_LANGUAGE pInLanguage,
					IN AnswerParser* pInAnsParse,
					OUT FileTree** ppTree,
					IN BOOL blnBase,
					IN DWORD iInBestMethod,
					IN BOOL blnInCollectStat,
					IN BOOL blnInFullLog);
	FileTree(IN CONST WCHAR* pwszPath);
	~FileTree(VOID);
    INT Load(IN FileTree* pTree);
	BOOL CreateNewDirectory(IN WCHAR* pwszLocal,
							IN CONST WCHAR* pwszBuffer);
	BOOL CopyFileTo(IN FileTree* pThis,
					IN CONST WCHAR* pwszWhat,
					IN WCHAR* pwszLocal,
					IN CONST WCHAR* pwszFileName,
					IN WCHAR* pwszOldFile,
					IN DWORD attributes);
	VOID ToScriptFile(IN FileTree* pThis,
					IN HANDLE hFile,
					IN CONST WCHAR* pwszWhat,
					IN CONST WCHAR* pwszFirst,
					IN WCHAR* pwszSecond,
					IN BOOL blnFlush);

public:
	WCHAR m_wszLocalRoot[STRING_LENGTH];        // local path to this tree's root, ie, "C:\SRC\"

private:
    static FN_DIRECTORY NotifyDirectory;
    static FN_FILE NotifyFile;
	static FN_DIRECTORY_END NotifyDirectoryEnd;

	static DWORD WINAPI StartFileThread(IN LPVOID lpParam);
	static INT ProcessFile(
        IN FileTree* pThis,
        IN DirectoryNode* pParent,
        IN CONST WCHAR* filename,
        IN CONST WCHAR* path,
		IN DWORD attributes,
		IN FILETIME filetime,
		IN FILETIME creation,
		IN __int64 filesize,
		IN FileTree* pTree,
		IN VOID* pStruct
    );

private:

	CRITICAL_SECTION CSScriptFile;
	PPATCH_LANGUAGE m_pLanguage;
	AnswerParser* m_pAnsParse;
	BOOL m_blnBase;
	WCHAR m_strWriteBuffer[SUPER_LENGTH];
	ULONG m_iSize;

	DirectoryNode m_Root;
    __int64 m_cDirectories;
    __int64 m_cFiles;
    __int64 m_cFilesDetermined;
    __int64 m_cbTotalFileSize;
    __int64 m_cFilesExisting;
    __int64 m_cFilesZeroLength;
    __int64 m_cFilesRenamed;
    __int64 m_cFilesCopied;
    __int64 m_cFilesChanged;
    __int64 m_cbChangedFileSize;
    __int64 m_cbChangedFilePatchedSize;
    __int64 m_cbChangedFileNotPatchedSize;
    __int64 m_cFilesNoMatch;
    __int64 m_cbNoMatchFileSize;
    FileNode* m_aHashTable[HASH_SIZE];
    FileNode* m_aNameTable[HASH_SIZE];
    INT m_cchLocalRoot;             // length of m_wszLocalRoot in characters, excl. term.
};

#endif // FILETREE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oemtools\oempatch\dirwak2a.c ===
/* ---------------------------------------------------------------------------------------------------------------------------- */
/*                                                                                                                              */
/*                                                           DIRWAK2AC                                                         */
/*                                                                                                                              */
/* ---------------------------------------------------------------------------------------------------------------------------- */

/* ---------------------------------------------------------------------------------------------------------------------------- */
/*                                                                                                                              */
/*  int DirectoryWalk(context,directory,ProcessDirectory,ProcessFile,ProcessDirectoryEnd,pTree) will search a directory and all */
/*  of its subdirectories looking for file entries.  The provided ProcessDirectory() will be called for each subdirectory found */
/*  just before searching that directory.  ProcessDirectory() is called for the original path; an empty name is reported.       */
/*  The provided ProcessDirectoryEnd() will be called after the last file has been reported in each directory.  The provided    */
/*  ProcessFile() is called for each file located.  pTree is passed as to those functions for OEMPATCH support                  */
/*                                                                                                                              */
/*  If NULL is provided for ProcessDirectory, subdirectories will not be included in the search.                                */
/*  If NULL is provided for ProcessFile, no notification of file entries will be made.                                          */
/*  If NULL is provided for ProcessDirectoryEnd, no notification of end of directories will be made.                            */
/*                                                                                                                              */
/*  Return codes are:                                                                                                           */
/*                                                                                                                              */
/*      0 => no error.                                                                                                          */
/*      DW_MEMORY => ran out of memory to track directories.                                                                    */
/*      DW_ERROR => DOS reported an error on a search (most likely the path doesn't exist.)                                     */
/*      DW_DEPTH => total path name was or became too long.                                                                     */
/*      any others => whatever ProcessDirectory(), ProcessFile(), or ProcessDirectoryEnd() returned.                            */
/*                                                                                                                              */
/* ---------------------------------------------------------------------------------------------------------------------------- */

/* ---------------------------------------------------------------------------------------------------------------------------- */
/*                                                                                                                              */
/* Revision 1.9a 10/04/99  JXW  DIRWAK2A: added support for OEMPATCH for a one pass patching process                            */
/*                                                                                                                              */
/* Revision 1.9  10/04/99  MVS  DIRWALK2: unicode, FILETIME, big FILESIZE                                                       */
/*                                                                                                                              */
/* Revision 1.8  05/06/99  MVS  Fixed to preserve case of directories.                                                          */
/*                                                                                                                              */
/* Revision 1.7  03/05/99  MVS  Fixed date/time handling for files with no info.  Make directory sorting case-insensitive.      */
/*                                                                                                                              */
/* Revision 1.6  09/28/97  MVS  Added global context pointer.  Fixed leaks in error conditions.  Abandoned 16-bit version.      */
/*                                                                                                                              */
/* Revision 1.5  12/16/96  MVS  Added 32-bit file date/time conversions.                                                        */
/*                                                                                                                              */
/* Revision 1.4  10/14/96  MVS  Fixed 32-bit case for ProcessDirectory==NULL.                                                   */
/*                                                                                                                              */
/* Revision 1.3  03/22/94  MVS  Made NT-capable version.  For non-NT, compile with -DBIT16.                                     */
/*                                                                                                                              */
/* Revision 1.2  03/07/94  MVS  Removed erroneous const qualifiers.  Changed to new-style declarators.                          */
/*                                                                                                                              */
/* Revision 1.1  04/03/93  MVS  Forced the minor list to stay sorted, so that all directories will be reported in sorted order. */
/*                              (filenames within each directory can still appear unsorted.)                                    */
/*                                                                                                                              */
/* Revision 1.0            MVS  Initial release.  A long, long time ago.                                                        */
/*                                                                                                                              */
/* ---------------------------------------------------------------------------------------------------------------------------- */

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include "dirwak2a.h"                                       /* prototype verification */

#define     MAXPATH     515                                 /* reasonable path length limit */

#define     AND         &&                                  /* standard definition */
#define     OR          ||                                  /* standard definition */

#ifndef EXDEV
#define     EXDEV       0x12                                /* MS-DOS "no more files" error code */
#endif

struct DIRECTORY                                            /* internal use only - a directory discovered but not explored */
{
    struct DIRECTORY *link;                                 /* link to next to be searched */
    int length;                                             /* length of path string before this name */
    void *parentID;                                         /* ID of this directory's parent */
    WCHAR directory[1];                                     /* name of the directory to search / MUST BE LAST STRUCT ENTRY */
};


int DirectoryWalk(
        void *context,
        void *parentID,
        const WCHAR *directory,
        FN_DIRECTORY *ProcessDirectory,
        FN_FILE *ProcessFile,
        FN_DIRECTORY_END *ProcessDirectoryEnd,
		void *pTree)
{
    int length = 0;                                         /* length of current path */
    HANDLE findHandle;                                      /* handle for searches */
    WIN32_FIND_DATAW file;                                  /* find data structure */
    WCHAR path[MAXPATH+7];                                  /* working buffer */
    struct DIRECTORY *majorList;                            /* list of subdirectories to explore */
    struct DIRECTORY *minorList;                            /* list of subdirectories just found */
    struct DIRECTORY *temp;                                 /* subdirectory list temporary */
    struct DIRECTORY **backLink;                            /* where to link next to end of the minor list */
    int result;

    majorList = NULL;
    minorList = NULL;
    findHandle = INVALID_HANDLE_VALUE;

    if((length = wcslen(directory)) > MAXPATH)              /* check path length */
    {
        result = DW_DEPTH;                                  /* provided path is too long */
        goto done;
    }
    wcscpy(path, directory);                                 /* copy into our buffer */

    if(length)
    {                                                       /* change paths like "DOS" to "DOS\" */
        if((path[length-1] != L'\\') AND (path[length-1] != L':'))   /* don't make "DOS\\", don't assume "C:" means "C:\" */
        {
            wcscpy(path + length, L"\\");                   /* so we can attach "*.*" or another name */
            length++;                                       /* that makes the length longer */
        }
    }

    majorList = (struct DIRECTORY*)GlobalAlloc(GMEM_FIXED, sizeof(struct DIRECTORY));   /* allocate initial request as a directory to explore */
    if(majorList == NULL)
    {
        result = DW_MEMORY;                                 /* if out of memory */
        goto done;
    }

    majorList->link = NULL;                                 /* fabricate initial request */
    majorList->directory[0] = L'\0';                        /* no discovery to report yet */
    majorList->length = length;                             /* length of base path name */
    majorList->parentID = parentID;                         /* parent ID of initial request */

    while(majorList != NULL)                                /* until we run out of places to look... */
    {
        path[majorList->length] = L'\0';                    /* truncate path as needed */
        wcscpy(path + majorList->length, majorList->directory);      /* append the name from the list */

        parentID = majorList->parentID;                     /* pre-set parent ID to parent's */

        if(ProcessDirectory != NULL)                        /* if we are supposed to do subdirectories, report this one */
        {
            result = ProcessDirectory(context,
                    majorList->parentID,                    /* pass ID of parent dir */
                    majorList->directory,                   /* name of this directory */
                    path,                                   /* full path incl. this dir */
                    &parentID,                              /* where to store new ID */
					pTree);

            if(result != DW_NO_ERROR)                       /* if ProcessDirectory reports an error, */
            {
                goto done;                                  /*   then pass it on */
            }
        }

        length = wcslen(path);                              /* compute length so we can clip later */
        if(length)
        {                                                   /* change paths like "DOS" to "DOS\" */
            if((path[length-1] != '\\') AND (path[length-1] != ':'))   /* don't make "DOS\\", don't assume "C:" means "C:\" */
            {
                wcscpy(path + length, L"\\");               /* so we can attach "*.*" or some other name */
                length++;                                   /* that increased the length by one */
            }
        }

        wcscat(path, L"*.*");                               /* append wild file name for findfirst */

        findHandle = FindFirstFileW(path, &file);
        if(findHandle == INVALID_HANDLE_VALUE)
        {
            result = EXDEV;
        }
        else
        {
            result = DW_NO_ERROR;
        }
        path[length] = L'\0';                               /* truncate name to path (clip the "*.*") */

        while(result == DW_NO_ERROR)                        /* while there are entries */
        {
            if(file.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)  /* if it's a subdirectory entry */
            {
                if(ProcessDirectory != NULL)
                {
                    if((file.cFileName[0] == L'.') &&
                        (file.cFileName[1] == L'\0'))
                    {
                        goto skip;  /* skip "." entry */
                    }

                    if((file.cFileName[0] == L'.') &&
                        (file.cFileName[1] == L'.') &&
                        (file.cFileName[2] == L'\0'))
                    {
                        goto skip;  /* skip ".." entry */
                    }

                    /* A subdirectory entry has been found.  Append a record to the */
                    /* minor list and we'll process each of those after we complete */
                    /* the current directory.  This approach means that only one    */
                    /* find_t structure is in use at a time (better for DOS), all   */
                    /* files in the same directory are reported together, and we    */
                    /* don't have to search each directory again looking for the    */
                    /* subdirectory entries.                                        */

                    if((length + wcslen(file.cFileName)) > MAXPATH)
                    {
                        result = DW_DEPTH;                  /* directory name is getting too long */
                        goto done;
                    }

                    temp = (struct DIRECTORY*)GlobalAlloc(GMEM_FIXED, sizeof(struct DIRECTORY) + sizeof(WCHAR) * wcslen(file.cFileName));
                    if(temp == NULL)                       /* if ran out of memory */
                    {
                        result = DW_MEMORY;                 /* post the result */
                        goto done;
                    }

                    wcscpy(temp->directory,file.cFileName); /* create new record */
                    temp->length = length;                  /* remember depth */
                    temp->parentID = parentID;              /* ID of this child's parent */

                    backLink = &minorList;                  /* start search at head of minor list */

                    while((*backLink != NULL) && (_wcsicmp(temp->directory,(*backLink)->directory) > 0))
                    {
                        backLink = &(*backLink)->link;      /* walk up the list past "smaller" names */
                    }

                    temp->link = *backLink;                 /* inherit link of previous */
                    *backLink = temp;                       /* become previous' successor */
skip:
                    ;
                }
            }
            else                                            /* if not a subdirectory */
            {
                                                            /* A file entry has been found.  Call the file processor and    */
                                                            /* let it do whatever it wants with it.                         */

                if(ProcessFile != NULL)                     /* call only if there is a file processor */
                {
                    __int64 FileSize = (((__int64) file.nFileSizeHigh) << 32) + file.nFileSizeLow;

                    result = ProcessFile(context,
                            parentID,                       /* pass ID of parent dir */
                            file.cFileName,                 /* name of file just found */
                            path,                           /* full path to the file */
                            file.dwFileAttributes,          /* the file's attribute bits */
                            file.ftLastWriteTime,           /* last-modified time */
                            file.ftCreationTime,            /* creation time */
                            FileSize,
							pTree);

                    if(result != DW_NO_ERROR)               /* if file processor fails, report it */
                    {
                        goto done;                          /* return whatever file processor returned to us */
                    }
                }
            }

            if(!FindNextFileW(findHandle,&file))            /* look for next entry */
            {
                result = EXDEV;                             /* NT's only error is "no more" */
            }
        }                                                   /* end while */

        if(findHandle != INVALID_HANDLE_VALUE)
        {
            FindClose(findHandle);
            findHandle = INVALID_HANDLE_VALUE;
        }

        if(ProcessDirectoryEnd != NULL)                     /* if we are supposed to report end of directories */
        {
            result = ProcessDirectoryEnd(context,
                    majorList->parentID,                    /* pass ID of parent dir */
                    majorList->directory,                   /* name of this directory */
                    path,                                   /* full path incl. this dir */
                    parentID);                              /* pass ID of this directory */

            if(result != DW_NO_ERROR)                       /* if ProcessDirectoryEnd reports an error, */
            {
                goto done;                                  /*    then pass it on */
            }
        }

        temp = majorList;                                   /* hold pointer to destroy */
        majorList = majorList->link;                        /* advance major list to the next entry */
        GlobalFree(temp);                                   /* destroy list entries as they are used */

        backLink = &minorList;                              /* locate end of the minor list */

        while(*backLink != NULL)                            /* (actually, find the element who's forward link is NULL) */
        {
            backLink = &(*backLink)->link;                  /* (then we'll set that element's link to the front of major list) */
        }

        *backLink = majorList;                              /* prepend the new minor list onto the major list */
        majorList = minorList;                              /* minor list becomes the major list, minor list is scrapped */
        minorList = NULL;                                   /* reset the minor list */
    }

    result = DW_NO_ERROR;

done:

    while(majorList != NULL)                                /* don't leak the list */
    {
        temp = majorList;
        majorList = majorList->link;

        GlobalFree(temp);
    }

    while(minorList != NULL)                                /* don't leak the list */
    {
        temp = minorList;
        minorList = minorList->link;

        GlobalFree(temp);
    }

    if(findHandle != INVALID_HANDLE_VALUE)
    {
        FindClose(findHandle);
    }

    return(result);                                         /* report result to caller */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oemtools\oempatch\dirwak2a.h ===
/* ---------------------------------------------------------------------------------------------------------------------------- */
/*                                                                                                                              */
/*                                                           DIRWAK2A.H                                                         */
/*  This a modified version of DIRWALK2.H by adding function parameters to support OEMPATCH.                          */
/*  Definitions for the DirectoryWalk function found in DIRWAK2A.C, and the related processing calls needed.                    */
/*                                                                                                                              */
/* ---------------------------------------------------------------------------------------------------------------------------- */

#ifndef DIRWAK2A_H
#define DIRWAK2A_H

#ifdef __cplusplus
extern "C" {
#endif

/*
 *  User function definitions:
 *
 *  The context is just a void * which gets passed to each callback.  It is not used internally.  The user may assign
 *  any meaning desired.  The same value will be passed to each callback.
 *
 *  The parentID and childID values are "void *"s to DirectoryWalk.  They are not used internally.  The user may assign
 *  any meaning desired to the value.  DirectoryWalk simply requests an assignment via the Directory(), and reports the
 *  corresponding assignment with each file reported to File(), then to DirectoryEnd().
 */

typedef int (__cdecl FN_DIRECTORY)(
        void *              pContext,       /* global context */
        void *              pParentID,      /* the handle for the directory where this directory was found */
        const WCHAR *       pwszDirectory,  /* the name of the directory found, ie, "DOS" */
        const WCHAR *       pwszPath,       /* the full name of the directory, ie, "C:\DOS" */
        void * *            ppChildID,      /* Directory() assigns this directory a handle, and passes it back here */
		void *              pTree);

/*
 *  If Directory() returns a non-zero value, DirectoryWalk will terminate and return that value.  If NULL is passed
 *  to DirectoryWalk() for a Directory() pointer, subdirectories will not be searched.  For subdirectory searching
 *  without specific per-directory processing, create a simple function which always returns DW_NO_ERROR (any other
 *  return will terminate the search.)
 */

typedef int (__cdecl FN_FILE)(
        void *              pContext,       /* global context */
        void *              pParentID,      /* the handle for the directory where this file was found */
        const WCHAR *       pwszFilename,   /* the name of the file found, ie, "ANSI.SYS" */
        const WCHAR *       pwszPath,       /* the full name of the directory where file was found, ie, "C:\DOS\" */
        DWORD               attributes,     /* the file's attribute bits */
        FILETIME            lastWriteTime,  /* the file's last modification time */
        FILETIME            creationTime,   /* the file's creation time */
        __int64             filesize,       /* the file's size in bytes */
		void *              pTree);

/*
 *  If File() returns a value other than DW_NO_ERROR, DirectoryWalk will terminate and return that value.  NULL can
 *  be passed to DirectoryWalk() for a File() pointer; file entries found will be ignored.
 */

typedef int (__cdecl FN_DIRECTORY_END)(
        void *              pContext,       /* global context */
        void *              pParentID,      /* the handle for the directory where this directory was found */
        const WCHAR *       pwszDirectory,  /* the name of the directory found, ie, "DOS" */
        const WCHAR *       pwszPath,       /* the full name of the directory, ie, "C:\DOS" */
        void *              pChildID);      /* the handle assigned this directory by Directory() */

/*
 *  If NULL is passed to DirectoryWalk for the DirectoryEnd() pointer, no report of end of directories will be made.
 *  If DirectoryEnd returns a value other than DW_NO_ERROR, DirectoryWalk will terminate and return that value.
 */


extern int DirectoryWalk(
        void *              pContext,       /* global context for callbacks */
        void *              pParentID,      /* top-level parentID */
        const WCHAR *       pwszPath,       /* path to search, ie, "C:\" */
        FN_DIRECTORY *      Directory,      /* pointer to Directory() or NULL */
        FN_FILE *           File,           /* pointer to File() or NULL */
        FN_DIRECTORY_END *  DirectoryEnd,   /* pointer to DirectoryEnd() or NULL */
		void *              pTree);


#define     DW_MEMORY       (-10)           /* unable to allocate for internal use */
#define     DW_ERROR        (-11)           /* find first/next reported an error */
#define     DW_DEPTH        (-12)           /* path name became too long */
#define     DW_NO_ERROR     (0)             /* no error detected */
#define     DW_OTHER_ERROR  (-1)            /* some error */

#ifdef __cplusplus
}
#endif

#endif // DIRWAK2A_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oemtools\oempatch\main.cpp ===
#include <windows.h>
#include <stdio.h>

#include "patchapi.h"
#include "const.h"
#include "ansparse.h"
#include "dirwak2a.h"
#include "filetree.h"

// the log file handle
HANDLE g_hDebugFile = INVALID_HANDLE_VALUE;
// is log required?
BOOL g_blnDebugFile = FALSE;
// is the logfile a new file?
BOOL g_blnDebugNewFile = FALSE;
// guard for the logfile access
CRITICAL_SECTION g_CSLogFile;
// multi thread support, default number of threads
ULONG g_iNumberOfThreads = 1;

// some patching options
DWORD g_iBestMethod = (PATCH_OPTION_USE_LZX_A | PATCH_OPTION_NO_TIMESTAMP);
BOOL g_blnCollectStat = FALSE;
BOOL g_blnFullLog = FALSE;

// some local function declarations
VOID DisplayHelpMessage(VOID);
VOID DisplayHelp(VOID);
VOID GenerateAnswerFile(VOID);
BOOL ParseCommandLine(IN INT argc, IN WCHAR* argv[]);

///////////////////////////////////////////////////////////////////////////////
//
// wmain, the unicode command line parameter entry point for this patching
//        tool, it parses the commandline first, then reads the answerfile for
//        what to do, and then creates the filetrees for languages that are to
//        to matched and patched
//
///////////////////////////////////////////////////////////////////////////////
extern "C" int __cdecl wmain(int argc, WCHAR *argv[])
{
    INT rc = PREP_NO_ERROR;
    FileTree* pBaseTree = NULL;
	FileTree* pLocTree = NULL;
	AnswerParser* pParse = NULL;
	PPATCH_LANGUAGE pBase = NULL;
	PPATCH_LANGUAGE pLanguage = NULL;

	InitializeCriticalSection(&g_CSLogFile);

	DisplayDebugMessage(TRUE, TRUE, FALSE, TRUE,
						L"Microsoft (R) OEMPatch Version %d.%.3d\nCopyright (C) Microsoft Corp 1999-2000. All rights reserved.",
						g_iMajorVersion, g_iMinorVersion);

	// parse command line
	if(!ParseCommandLine(argc, argv))
	{
		goto CLEANUP;
	}
	DisplayDebugMessage(FALSE, FALSE, FALSE, FALSE,
						L"OEMPatch has finished parsing command line parameters.");

	// create the parser for parsing the answer file
	pParse = new AnswerParser;
	if(pParse == NULL)
	{
		rc = PREP_NO_MEMORY;
		goto CLEANUP;
	}
	DisplayDebugMessage(FALSE, FALSE, FALSE, FALSE,
						L"Creating the parser for OEMPatch.ans.");

	// parsing the answer file
	if(!pParse->Parse(ANS_FILE_NAME))
	{
		delete pParse;
		pParse = NULL;
		rc = PREP_INPUT_FILE_ERROR;
		goto CLEANUP;
	}
	DisplayDebugMessage(FALSE, FALSE, FALSE, FALSE,
						L"Parsing answer file completed.");

	DisplayDebugMessage(TRUE, TRUE, FALSE, TRUE,
						L"Starting a new OEMPatch session.");

	// call for filetree objects
	// base language, any error causes the process to terminate, cannot go on without a base language
	pBase = pParse->GetBaseLanguage();
	if(pBase)
	{
		DisplayDebugMessage(FALSE, FALSE, FALSE, FALSE,
							L"Retrieved the base language.");
		DisplayDebugMessage(TRUE, TRUE, FALSE, TRUE,
							L"Creating base tree...");
		rc = FileTree::Create(pBase, pParse, &pBaseTree, TRUE,
							g_iBestMethod, g_blnCollectStat, g_blnFullLog);
		if(rc != PREP_NO_ERROR)
		{
			DisplayDebugMessage(FALSE, FALSE, FALSE, TRUE,
								L"error, CreateFileTree(\"%ls\") returned %d",
								pBase->s_wszLanguage, rc);
			goto CLEANUP;
		}
		DisplayDebugMessage(TRUE, FALSE, FALSE, TRUE,
							L"Done creating base tree.");

		// create the multi-thread structs, done only once by the base tree
		if(!pBaseTree->CreateMultiThreadStruct(g_iNumberOfThreads))
		{
			DisplayDebugMessage(FALSE, FALSE, FALSE, TRUE,
								L"error, cannot create the patch thread(s)");
			goto CLEANUP;
		}

		DisplayDebugMessage(TRUE, TRUE, FALSE, TRUE,
							L"Loading base tree...");
		rc = pBaseTree->Load(NULL);
		if(rc != PREP_NO_ERROR)
		{
			DisplayDebugMessage(FALSE, FALSE, FALSE, TRUE,
								L"error, LoadFileTree(\"%ls\") returned %d",
								pBase->s_wszLanguage, rc);
			goto CLEANUP;
		}
		DisplayDebugMessage(TRUE, FALSE, FALSE, TRUE,
							L"Done loading base tree.");
	}
	else
	{
		rc = PREP_INPUT_FILE_ERROR;
		DisplayDebugMessage(FALSE, FALSE, FALSE, TRUE,
							L"error, there is no base lanugage to load");
		goto CLEANUP;
	}

	// none-base languages, errors are just recorded, continue to the next language
	while((pLanguage = pParse->GetNextLanguage()) != NULL)
	{
		// none-base tree
		DisplayDebugMessage(TRUE, TRUE, FALSE, TRUE,
							L"Creating localized (\"%ls\") tree...",
							pLanguage->s_wszDirectory);
		rc = FileTree::Create(pLanguage, pParse, &pLocTree, FALSE,
							g_iBestMethod, g_blnCollectStat, g_blnFullLog);
		if(rc == PREP_NO_ERROR)
		{
			DisplayDebugMessage(TRUE, FALSE, FALSE, TRUE,
								L"Done creating localized (\"%ls\") tree.",
								pLanguage->s_wszDirectory);
			DisplayDebugMessage(TRUE, TRUE, FALSE, TRUE,
								L"Loading and patching localized (\"%ls\") tree...", pLanguage->s_wszDirectory);
			// load and match it
			rc = pLocTree->Load(pBaseTree);
			if(rc == PREP_NO_ERROR)
			{
				DisplayDebugMessage(TRUE, FALSE, FALSE, TRUE,
									L"Done loading and patching localized (\"%ls\") tree.", pLanguage->s_wszDirectory);
			}
			else
			{
				DisplayDebugMessage(TRUE, FALSE, FALSE, TRUE,
									L"warning, error in matching localized (\"%ls\") tree.", pLanguage->s_wszDirectory);
			}

			// remove for the next language
			delete pLocTree;
			pLocTree = NULL;

			DisplayDebugMessage(FALSE, FALSE, FALSE, FALSE,
								L"Localized tree is removed from memory.");
		}
		else
		{
			DisplayDebugMessage(FALSE, FALSE, FALSE, TRUE,
								L"error, creating localized (\"%ls\") tree.",
								pLanguage->s_wszDirectory);
		}
	}

CLEANUP:

	if(pBaseTree)
	{
		// remove the multi-thread struct here, done only once
		pBaseTree->DeleteMultiThreadStruct();
		delete pBaseTree;
		pBaseTree = NULL;
	}
    if(pLocTree)
	{
		delete pLocTree;
		pLocTree = NULL;
	}
	if(pParse)
	{
		delete pParse;
		pParse = NULL;
	}

	if(rc != PREP_NO_ERROR)
	{
		switch(rc)
		{
		case PREP_NO_MEMORY:
			DisplayDebugMessage(FALSE, FALSE, FALSE, TRUE,
								L"More memory is needed on this system to run.");
			break;
		case PREP_BAD_PATH_ERROR:
			DisplayDebugMessage(FALSE, FALSE, FALSE, TRUE,
								L"Directory for some files are invalid, please check for valid directories.");
			break;
		case PREP_UNKNOWN_ERROR:
			DisplayDebugMessage(FALSE, FALSE, FALSE, TRUE,
								L"Unknown error, contact support.");
			break;
		case PREP_DEPTH_ERROR:
			DisplayDebugMessage(FALSE, FALSE, FALSE, TRUE,
								L"File tree is too deep, contact support.");
			break;
		case PREP_BAD_COMMAND:
			DisplayDebugMessage(FALSE, FALSE, FALSE, TRUE,
								L"Bad command, try again.");
			break;
		case PREP_HASH_ERROR:
			DisplayDebugMessage(FALSE, FALSE, FALSE, TRUE,
								L"Internal hashing error, contact support.");
			break;
		case PREP_BUFFER_OVERFLOW:
			DisplayDebugMessage(FALSE, FALSE, FALSE, TRUE,
								L"Internal buffer overflow, contact support.");
			break;
		case PREP_NOT_PATCHABLE:
			DisplayDebugMessage(FALSE, FALSE, FALSE, TRUE,
								L"Patching error, try again or contact support");
			break;
		case PREP_INPUT_FILE_ERROR:
			DisplayDebugMessage(FALSE, FALSE, FALSE, TRUE,
								L"Input file error, please check for valid OEMPatch.ans.");
			break;
		case PREP_SCRIPT_FILE_ERROR:
			DisplayDebugMessage(FALSE, FALSE, FALSE, TRUE,
								L"Cannot save infomation to scipt file, try again or contact support.");
			break;
		case PREP_PATCH_FILE_ERROR:
			DisplayDebugMessage(FALSE, FALSE, FALSE, TRUE,
								L"Patch file error, try again or contact support.");
			break;
		case PREP_DIRECTORY_ERROR:
			DisplayDebugMessage(FALSE, FALSE, FALSE, TRUE,
								L"Directory error, try again or contact support.");
			break;
		case PREP_COPY_FILE_ERROR:
			DisplayDebugMessage(FALSE, FALSE, FALSE, TRUE,
								L"File cannot be copied, check for available space and file permission.");
			break;
		}
	}

	DisplayDebugMessage(TRUE, TRUE, FALSE, TRUE,
						L"OEMPatch has finished.");
	DisplayDebugMessage(FALSE, FALSE, TRUE, FALSE, NULL);

	if(g_hDebugFile != INVALID_HANDLE_VALUE)
	{
		CloseHandle(g_hDebugFile);
	}

	DeleteCriticalSection(&g_CSLogFile);

    return(rc);
}

///////////////////////////////////////////////////////////////////////////////
//
// ParseCommandLine, this function attempts to parse the commandline parameters
//                   and saves them into global variables for easy access
// 
// Parameters:
//
//   argc, the number of parameter in the command line
//   argv[], the command line buffer, holds all the command line parameters
//
// Return:
//
//   TRUE for correct command line parameters, FALSE for invalid parameters
//
///////////////////////////////////////////////////////////////////////////////
BOOL ParseCommandLine(IN INT argc, IN WCHAR* argv[])
{
	BOOL blnReturn = TRUE;

	// parse commandline parameters
	for(INT i = 1; i < argc && blnReturn; i++)
	{
		if(argv[i][0] == L'/')
		{
			switch(argv[i][1])
			{
			case L'm':
				// multi thread
				if(argv[i][2] >= L'1' && argv[i][2] <= '9')
				{
					g_iNumberOfThreads = argv[i][2] - L'0';
				}
				break;
			case L's':
				// collect all stats
				g_blnCollectStat = TRUE;
				break;
			case L'b':
				// best patch
				g_iBestMethod |= PATCH_OPTION_FAIL_IF_BIGGER;
				break;
			case L'L':
				// log a new file
				g_blnDebugNewFile = TRUE;
			case L'l':
				// log a old file
				g_blnDebugFile = TRUE;
				if(g_blnDebugNewFile)
				{
					// new logfile
					ULONG iWriteByte = 0;
					g_hDebugFile = CreateFileW(LOG_FILE_NAME,
											GENERIC_WRITE,
											FILE_SHARE_WRITE | FILE_SHARE_READ,
											(LPSECURITY_ATTRIBUTES)NULL,
											CREATE_ALWAYS,
											FILE_ATTRIBUTE_NORMAL,
											(HANDLE)NULL);
					if(g_hDebugFile != INVALID_HANDLE_VALUE)
					{
						WriteFile(g_hDebugFile, &UNICODE_HEAD, sizeof(WCHAR),
							&iWriteByte, NULL);
					}
				}
				else
				{
					// append to old logfile
					g_hDebugFile = CreateFileW(LOG_FILE_NAME,
											GENERIC_WRITE,
											FILE_SHARE_WRITE | FILE_SHARE_READ,
											(LPSECURITY_ATTRIBUTES)NULL,
											OPEN_EXISTING,
											FILE_ATTRIBUTE_NORMAL,
											(HANDLE)NULL);
					if(g_hDebugFile != INVALID_HANDLE_VALUE)
					{
						SetFilePointer(g_hDebugFile, 0, NULL, FILE_END);
					}
					else
					{
						ULONG iWriteByte = 0;
						g_hDebugFile = CreateFileW(LOG_FILE_NAME,
											GENERIC_WRITE,
											FILE_SHARE_WRITE | FILE_SHARE_READ,
											(LPSECURITY_ATTRIBUTES)NULL,
											CREATE_ALWAYS,
											FILE_ATTRIBUTE_NORMAL,
											(HANDLE)NULL);
						if(g_hDebugFile != INVALID_HANDLE_VALUE)
						{
							WriteFile(g_hDebugFile, &UNICODE_HEAD,
								sizeof(WCHAR), &iWriteByte, NULL);
						}
					}
				}
				if(g_hDebugFile == INVALID_HANDLE_VALUE)
				{
					printf("warning, Logfile error, failed to open OEMPatch.log.\n");
					printf("warning, there is no log file\n");
				}
				if(argv[i][2] == L'C')
				{
					g_blnFullLog = TRUE;
				}
				break;
			case L'g':
				// generate a sample answerfile
				GenerateAnswerFile();
				blnReturn = FALSE;
				break;
			case L'?':
				// show help
				DisplayHelp();
				blnReturn = FALSE;
				break;
			default:
				// show the message for help
				DisplayHelpMessage();
				blnReturn = FALSE;
			}
		}
		else
		{
			DisplayHelpMessage();
			blnReturn = FALSE;
		}
	}

	return(blnReturn);
}

///////////////////////////////////////////////////////////////////////////////
//
// DisplayDebugMessage, show the message to the logfile is possible, else if
//                      the message is intended as print, output to stdout.
//                      The function will buffer all the messages up until
//                      either flushed or the buffer overflows, the reason
//                      being is to reduce io to disk
//
// Note, all message in pwszWhat should not contain any endoflinec char,
//       when blnFlush is TRUE, all other parameter are ignored
//
// Parameters:
//
//   blnTime, time included in the message?
//   blnBanner, create a banner around the message?
//   blnFlush, write the buffer to file
//   blnPrint, show this message to stdout?
//   pwszWhat, the format string
//   ..., parameters for the format string
//
// Return:
//
//   none
//
///////////////////////////////////////////////////////////////////////////////
VOID DisplayDebugMessage(IN BOOL blnTime,
						 IN BOOL blnBanner,
						 IN BOOL blnFlush,
						 IN BOOL blnPrint,
						 IN WCHAR* pwszWhat,
						 ...)
{
	static WCHAR strWriteBuffer[SUPER_LENGTH];
	static ULONG iSize;

	WCHAR msg[STRING_LENGTH];
	ZeroMemory(msg, STRING_LENGTH * sizeof(WCHAR));
	ULONG iBegin = 0;
	ULONG iLength = 0;
	ULONG iWriteBytes = 0;
	va_list arglist;

	if(pwszWhat)
	{
		va_start(arglist, pwszWhat);
		vswprintf(msg, pwszWhat, arglist);
		va_end(arglist);
	}

    __try
    {
        EnterCriticalSection(&g_CSLogFile);
		if(g_hDebugFile != INVALID_HANDLE_VALUE)
		{
			if(!blnFlush && pwszWhat)
			{
				// 2 for endofline and carriage return
				iLength = wcslen(msg) + 2;
				if(blnTime)
				{
					// 1 for space
					iLength += 1 + TIME_LENGTH; 
				}
				if(blnBanner)
				{
					iLength += BANNER_LENGTH * 2;
				}
				iBegin = iSize;
				iSize += iLength;
				if(iSize + 1 < SUPER_LENGTH)
				{
					// buffer the message up
					if(blnBanner)
					{
						wcscat(strWriteBuffer, BANNER);
					}
					if(blnTime)
					{
						WCHAR strDate[LANGUAGE_LENGTH];
						WCHAR strTime[LANGUAGE_LENGTH];
						SYSTEMTIME SystemTime;
						GetLocalTime(&SystemTime);
						GetDateFormatW(LOCALE_USER_DEFAULT, 0, &SystemTime,
							L"MMddyy", strDate, LANGUAGE_LENGTH);
						GetTimeFormatW(LOCALE_USER_DEFAULT, 0, &SystemTime,
							L"HHmmss", strTime, LANGUAGE_LENGTH);
						wcscat(strWriteBuffer, strDate);
						wcscat(strWriteBuffer, strTime);
						wcscat(strWriteBuffer, SPACE);
					}
					wcscat(strWriteBuffer, msg);
					wcscat(strWriteBuffer, ENDOFLINE);
					wcscat(strWriteBuffer, CRETURN);
					if(blnBanner)
					{
						wcscat(strWriteBuffer, BANNER);
					}
					strWriteBuffer[iSize] = 0;
				}
				else
				{
					// overflow
					WriteFile(g_hDebugFile, strWriteBuffer,
						iBegin * sizeof(WCHAR), &iWriteBytes, NULL);
					ZeroMemory(strWriteBuffer, SUPER_LENGTH * sizeof(WCHAR));
					if(blnBanner)
					{
						wcscat(strWriteBuffer, BANNER);
					}
					if(blnTime)
					{
						WCHAR strDate[LANGUAGE_LENGTH];
						WCHAR strTime[LANGUAGE_LENGTH];
						SYSTEMTIME SystemTime;
						GetLocalTime(&SystemTime);
						GetDateFormatW(LOCALE_USER_DEFAULT, 0,
							&SystemTime, L"MMddyy", strDate, LANGUAGE_LENGTH);
						GetTimeFormatW(LOCALE_USER_DEFAULT,
							0, &SystemTime, L"HHmmss", strTime,
							LANGUAGE_LENGTH);
						wcscat(strWriteBuffer, strDate);
						wcscat(strWriteBuffer, strTime);
						wcscat(strWriteBuffer, SPACE);
					}
					wcscat(strWriteBuffer, msg);
					wcscat(strWriteBuffer, ENDOFLINE);
					wcscat(strWriteBuffer, CRETURN);
					if(blnBanner)
					{
						wcscat(strWriteBuffer, BANNER);
					}
					iSize = iLength;
				}
			}
			else if(blnFlush && iSize > 0)
			{
				// flush the buffer to file
				WriteFile(g_hDebugFile, strWriteBuffer, iSize * sizeof(WCHAR), &iWriteBytes, NULL);
				iSize = 0;
			}
			if(blnPrint)
			{
				wprintf(L"%ls\n", msg);
			}
		}
		else if(msg && blnPrint)
		{
			wprintf(L"%ls\n", msg);
		}
    }
    __finally
    {
        LeaveCriticalSection(&g_CSLogFile);
    }
}

///////////////////////////////////////////////////////////////////////////////
//
// DisplayHelpMessage, shows what to do if the user if confused
//
// Parameters:
//
//   none
//
// Return:
//
//   none
//
///////////////////////////////////////////////////////////////////////////////
VOID DisplayHelpMessage(VOID)
{
	printf("\nFor help try /?.\n");
}

///////////////////////////////////////////////////////////////////////////////
//
// DisplayHelp, shows what oempatch is cabable of
//
// Parameters:
//
//   none
//
// Return:
//
//   none
//
///////////////////////////////////////////////////////////////////////////////
VOID DisplayHelp(VOID)
{
	printf("\nOEMPatch %d.%.3d - Help\n", g_iMajorVersion, g_iMinorVersion);
	printf("Usage: oempatch [/m#] [/s] [/b] [/l | /L [C] ] [/g | /?]\n");
	printf("(no switch):\trun patch, single thread\n");
	printf("/m#:\t\trun multi-threaded patch, maximum # is 9, minimum is 1\n");
	printf("/s:\t\tcollect patching stats when running patch, slows down patching\n");
	printf("/b:\t\tchoose best patching methods, slows down patching\n");
	printf("/l:\t\trun patch with append to the log file OEMPatch.log\n");
	printf("/L:\t\trun patch with a new log file OEMPatch.log\n");
	printf("/lC, /LC:\tevery file status is logged\n");
	printf("/g:\t\tgenerate a new sample answer file if there is no such file\n");
	printf("/?:\t\tdisplay help\n");
}

///////////////////////////////////////////////////////////////////////////////
//
// DisplayHelp, creates a sample answer file, so that the user can modifie
//              according to needs
//
// Parameters:
//
//   none
//
// Return:
//
//   none
//
///////////////////////////////////////////////////////////////////////////////
VOID GenerateAnswerFile(VOID)
{
	HANDLE hAnsFile = INVALID_HANDLE_VALUE;
	ULONG iWriteByte = 0;
	ULONG i = 0;

	hAnsFile = CreateFileW(ANS_FILE_NAME,
						GENERIC_WRITE,
						0,
						(LPSECURITY_ATTRIBUTES)NULL,
						CREATE_NEW,
						FILE_ATTRIBUTE_NORMAL,
						(HANDLE)NULL);
	if(hAnsFile != INVALID_HANDLE_VALUE)
	{
		// construct the answer file
		WriteFile(hAnsFile, &UNICODE_HEAD, sizeof(WCHAR), &iWriteByte, NULL);
		// SAMPLEFILE is defined in ansparse.h
		while(SAMPLEFILE[i][0] &&
			WriteFile(hAnsFile, SAMPLEFILE[i],
			wcslen(SAMPLEFILE[i]) * sizeof(WCHAR), &iWriteByte, NULL))
		{
			i++;
		}
		CloseHandle(hAnsFile);
		if(SAMPLEFILE[i][0])
		{
			printf("Warning:OEMPatch.ans may contain errors, needs regeneration.\n");
		}
		else
		{
			printf("OEMPatch.ans generated, needs to be manually completed and saved as UNICODE.\n");
		}
	}
	else
	{
		printf("OEMPatch.ans already exists, no new file created.\n");
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oemtools\oemshare\oemshare.h ===
#ifndef SHARE_H
#define SHARE_H

#include <stdlib.h>

static CONST WCHAR EMPTY[] = L"";
static CONST WCHAR SEPARATOR[] = L"*";
static CONST WCHAR APPLY_PATCH_SCRIPT[] = L"OEMApply.scp";

static CONST ULONG LANGUAGE_LENGTH = 20;
static CONST ULONG DRIVE_LETTER_LENGTH = _MAX_DRIVE - 1;
static CONST ULONG STRING_LENGTH = _MAX_PATH + 1;
static CONST ULONG SUPER_LENGTH = STRING_LENGTH * 8;
static CONST ULONG SHORT_STRING_LENGTH = 128;

static CONST WCHAR UNICODE_HEAD = 0xFEFF;
static CONST WCHAR ENDOFLINE[] = L"\015";
static CONST WCHAR CRETURN[] = L"\012";
static CONST WCHAR ACTION_NEW_DIRECTORY[] = L"A";
static CONST WCHAR ACTION_MOVE_FILE[] = L"M";
static CONST WCHAR ACTION_EXCEPT_FILE[] = L"E";
static CONST WCHAR ACTION_NEW_ZERO_FILE[] = L"Z";
static CONST WCHAR ACTION_RENAME_FILE[] = L"R";
static CONST WCHAR ACTION_COPY_FILE[] = L"C";
static CONST WCHAR ACTION_PATCH_FILE[] = L"P";
static CONST WCHAR ACTION_NOT_PATCH_FILE[] = L"N";
static CONST WCHAR ACTION_SAVED_FILE[] = L"S";
static CONST WCHAR ACTION_DELETE_DIRECTORY[] = L"X";

static CONST WCHAR DIR_READONLY[] = L"R";
static CONST WCHAR DIR_SYSTEM[] = L"S";
static CONST WCHAR DIR_HIDDEN[] = L"H";
static CONST WCHAR DIR_COMPRESSED[] = L"C";
static CONST WCHAR DIR_ENCRYPTED[] = L"E";

#endif // SHARE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies project-wide macros for OOBE.

Author:

    Dan Elliott (dane)

!ENDIF

OOBELIB=$(PROJECT_ROOT)\ntsetup\oobe\lib
OOBEINC=$(PROJECT_ROOT)\ntsetup\oobe\inc;$(PROJECT_ROOT)\ntsetup\oobe\idl\$(O);

USE_MSVCRT=1
C_DEFINES = $(C_DEFINES) -DUNICODE -D_UNICODE

!include $(PROJECT_ROOT)\ntsetup\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\common\cfactory.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  CFACTORY.CPP - Implementation of IClassFactory
//
//  HISTORY:
//  
//  1/27/99 a-jaswed Created.
// 
//  Base class for reusing a single class factory for all
//  components in a DLL.

#include <objbase.h>
#include "cfactory.h"
#include "registry.h"

///////////////////////////////////////////////////////////
// Static variables
//
LONG    CFactory::s_cServerLocks = 0 ;      // Count of locks
HMODULE CFactory::s_hModule      = NULL;    // DLL Module Handle.

#ifdef _OUTPROC_SERVER_
DWORD CFactory::s_dwThreadID = 0;
#endif

///////////////////////////////////////////////////////////
// CFactory implementation
//
CFactory::CFactory(const CFactoryData* pFactoryData)
: m_cRef(1)
{
    m_pFactoryData = pFactoryData;
}

///////////////////////////////////////////////////////////
//              IUnknown implementation
///////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////
// QueryInterface
//
HRESULT __stdcall CFactory::QueryInterface(REFIID iid, void** ppv)
{   
    IUnknown* pI ;
    if ((iid == IID_IUnknown) || (iid == IID_IClassFactory))
    {
        pI = this; 
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    pI->AddRef();
    *ppv = pI;
    return S_OK;
}

///////////////////////////////////////////////////////////
// AddRef
//
ULONG __stdcall CFactory::AddRef() 
{
    return ::InterlockedIncrement(&m_cRef); 
}

///////////////////////////////////////////////////////////
// Release
//
ULONG __stdcall CFactory::Release() 
{
    if (::InterlockedDecrement(&m_cRef) == 0) 
    {
        delete this; 
        return 0;
    }
    return m_cRef;
}

///////////////////////////////////////////////////////////
//              IClassFactory Implementation
///////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////
// CreateInstance
//
HRESULT __stdcall CFactory::CreateInstance( IUnknown* pOuterUnknown,
                                            const IID& iid,
                                            void** ppv) 
{

    // Aggregate only if the requested iid is IID_IUnknown
    if ((pOuterUnknown != NULL) && (iid != IID_IUnknown))
    {
        return CLASS_E_NOAGGREGATION;
    }

    // Create the component.
    CUnknown* pNewComponent ;
    HRESULT hr = m_pFactoryData->CreateInstance(pOuterUnknown, 
                                                &pNewComponent);
    if (FAILED(hr))
    {
        return hr;
    }

    // Initialize the component.
    hr = pNewComponent->Init();
    if (FAILED(hr))
    {
        // Initialization failed. Release the component.
        pNewComponent->NondelegatingRelease();
        return hr ;
    }

    // Get the requested interface.
    hr = pNewComponent->NondelegatingQueryInterface(iid, ppv);

    // Release the reference held by the class factory.
    pNewComponent->NondelegatingRelease();
    return hr ;
}

///////////////////////////////////////////////////////////
// LockServer
//
HRESULT __stdcall CFactory::LockServer(BOOL bLock) 
{
    if (bLock) 
    {
        ::InterlockedIncrement(&s_cServerLocks); 
    }
    else
    {
        ::InterlockedDecrement(&s_cServerLocks);
    }
    // If this is an outproc server check to see if we should shut down.
    CloseExe() ;  //@local

    return S_OK;
}


//////////////////////////////////////////////////////////
// GetClassObject - Creates a class factory based on CLSID
//
HRESULT CFactory::GetClassObject(const CLSID& clsid, 
                                 const IID& iid, 
                                 void** ppv)
{
    if ((iid != IID_IUnknown) && (iid != IID_IClassFactory))
    {
            return E_NOINTERFACE;
    }

    // Traverse the array of data looking for this class ID.
    for (int i = 0; i < g_cFactoryDataEntries; i++)
    {
        const CFactoryData* pData = &g_FactoryDataArray[i];
        if (pData->IsClassID(clsid))
        {

            // Found the ClassID in the array of components we
            // can create. So create a class factory for this component.
            // Pass the CFactoryData structure to the class factory
            // so that it knows what kind of components to create.
            *ppv = (IUnknown*) new CFactory(pData);
            if (*ppv == NULL)
            {
                return E_OUTOFMEMORY;
            }
            return NOERROR;
        }
    }
    return CLASS_E_CLASSNOTAVAILABLE;
}

//////////////////////////////////////////////////////////
// CanUnloadNow - Determine if component can be unloaded.
//
HRESULT CFactory::CanUnloadNow()
{
    if (CUnknown::ActiveComponents() || IsLocked())
    {
        return S_FALSE;
    }
    else
    {
        return S_OK;
    }
}

//////////////////////////////////////////////////////////
//  CFactory Member Function
//////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////
// Register all components.
//
HRESULT CFactory::RegisterAll()
{
    for(int i = 0 ; i < g_cFactoryDataEntries ; i++)
    {
        RegisterServer( s_hModule,
                        *(g_FactoryDataArray[i].m_pCLSID),
                        g_FactoryDataArray[i].m_RegistryName,
                        g_FactoryDataArray[i].m_szVerIndProgID, 
                        g_FactoryDataArray[i].m_szProgID ); 

        // Perform any additional registration.
        if (g_FactoryDataArray[i].SpecialRegistration != NULL)
        {
            g_FactoryDataArray[i].SpecialRegistration(TRUE);
        }
    }

    return S_OK ;
}

//////////////////////////////////////////////////////////
// Unregister all components.
//
HRESULT CFactory::UnregisterAll()
{
    for(int i = 0 ; i < g_cFactoryDataEntries ; i++)   
    {
        // Undo any additional registration.
        if (g_FactoryDataArray[i].SpecialRegistration != NULL)
        {
            g_FactoryDataArray[i].SpecialRegistration(FALSE);
        }

        UnregisterServer(*(g_FactoryDataArray[i].m_pCLSID),
                                g_FactoryDataArray[i].m_szVerIndProgID, 
                                g_FactoryDataArray[i].m_szProgID );
    }
    return S_OK;
}

#ifndef _OUTPROC_SERVER_

//////////////////////////////////////////////////////////
// Exported functions
//////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////
// DllCanUnloadNow
//
STDAPI DllCanUnloadNow()
{
    return CFactory::CanUnloadNow(); 
}

//////////////////////////////////////////////////////////
// Get class factory
//
STDAPI DllGetClassObject(   const CLSID& clsid,
                            const IID& iid,
                            void** ppv) 
{
    return CFactory::GetClassObject(clsid, iid, ppv);
}

//////////////////////////////////////////////////////////
// Server Registration
//
STDAPI DllRegisterServer()
{
    return CFactory::RegisterAll();
}


//////////////////////////////////////////////////////////
// Unregistration
//
STDAPI DllUnregisterServer()
{
    return CFactory::UnregisterAll();
}

///////////////////////////////////////////////////////////
// DLL module information
//
BOOL APIENTRY DllMain(HANDLE hModule, 
                             DWORD dwReason, 
                             void* lpReserved )
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        CFactory::s_hModule = (HMODULE) hModule;
    }
    return TRUE;
}

#else

//////////////////////////////////////////////////////////
//          Out of process Server support
//////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////
// Start factories
//
BOOL CFactory::StartFactories()
{
    CFactoryData* pStart = &g_FactoryDataArray[0];
    const CFactoryData* pEnd = &g_FactoryDataArray[g_cFactoryDataEntries-1];

    for(CFactoryData* pData = pStart ; pData <= pEnd ; pData++)
    {
        // Initialize the class factory pointer and cookie.
        pData->m_pIClassFactory = NULL ;
        pData->m_dwRegister = NULL ;

        // Create the class factory for this component.
        IClassFactory* pIFactory = new CFactory(pData);

        // Register the class factory.
        DWORD dwRegister ;
        HRESULT hr = ::CoRegisterClassObject(   *pData->m_pCLSID,
                                            (IUnknown*)pIFactory,
                                            CLSCTX_LOCAL_SERVER,
                                            REGCLS_MULTIPLEUSE,
                                            //REGCLS_MULTI_SEPARATE, //@Multi
                                            &dwRegister) ;
        if (FAILED(hr))
        {
            pIFactory->Release() ;
            return FALSE ;
        }

        // Set the data.
        pData->m_pIClassFactory = pIFactory ;
        pData->m_dwRegister = dwRegister ;
    }
    return TRUE ;
}

//////////////////////////////////////////////////////////
// Stop factories
//
void CFactory::StopFactories()
{
    CFactoryData* pStart = &g_FactoryDataArray[0];
    const CFactoryData* pEnd = &g_FactoryDataArray[g_cFactoryDataEntries-1];

    for(CFactoryData* pData = pStart ; pData <= pEnd ; pData++)
    {
        // Get the magic cookie and stop the factory from running.
        DWORD dwRegister = pData->m_dwRegister ;
        if (dwRegister != 0) 
        {
            ::CoRevokeClassObject(dwRegister) ;
        }

        // Release the class factory.
        IClassFactory* pIFactory  = pData->m_pIClassFactory;
        if (pIFactory != NULL) 
        {
            pIFactory->Release() ;
        }
    }
}

#endif //_OUTPROC_SERVER_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\common\cunknown.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  CUNKNOWN.CPP - Implementation of IUnknown 
//
//  HISTORY:
//  
//  1/27/99 a-jaswed Created.
//
// IUnknown Base class

#include "cunknown.h"
#include "cfactory.h"
#include "util.h"

///////////////////////////////////////////////////////////
// Count of active objects. Use to determine if we can unload the DLL.
//
long CUnknown::s_cActiveComponents = 0;

///////////////////////////////////////////////////////////
// Constructor
//
CUnknown::CUnknown(IUnknown* pOuterUnknown)
:   m_cRef(1)
{ 
   // Set pOuterUnknown pointer.
   if (pOuterUnknown == NULL)
   {
      TRACE(L"CUnknown: Using nondelegating IUnknown.") ;
      m_pOuterUnknown = reinterpret_cast<IUnknown*>(static_cast<INondelegatingUnknown*>(this)) ; // notice cast
   }
   else
   {
        TRACE(L"CUnknown: Aggregating. Using delegating IUnknown.") ;
        m_pOuterUnknown = pOuterUnknown;
   }

   // Increment count of active components.
   ::InterlockedIncrement(&s_cActiveComponents) ;
} 

///////////////////////////////////////////////////////////
// Destructor
//
CUnknown::~CUnknown()
{
    ::InterlockedDecrement(&s_cActiveComponents) ;
    // If this is an exe server shut it down.
    CFactory::CloseExe(); //@local server
}

///////////////////////////////////////////////////////////
// FinalRelease -- called by Release before it deletes the component.
//
void CUnknown::FinalRelease()
{
    TRACE(L"FinalRelease\n") ;
    m_cRef = 1;
}

///////////////////////////////////////////////////////////
// NonDelegatingIUnknown - Override to handle custom interfaces.
//
HRESULT __stdcall 
CUnknown::NondelegatingQueryInterface(const IID& riid, void** ppv)
{
    // CUnknown only supports IUnknown.
    if (riid == IID_IUnknown)
    {
        return FinishQI(reinterpret_cast<IUnknown*>(static_cast<INondelegatingUnknown*>(this)), ppv) ;
    }   
    else
    {
        *ppv = NULL ;
        return E_NOINTERFACE ;
    }
}

///////////////////////////////////////////////////////////
//
// AddRef
//
ULONG __stdcall CUnknown::NondelegatingAddRef()
{
    return ::InterlockedIncrement(&m_cRef) ;
}

///////////////////////////////////////////////////////////
//
// Release
//
ULONG __stdcall CUnknown::NondelegatingRelease()
{
    ::InterlockedDecrement(&m_cRef) ;
    if (m_cRef == 0)
    {
        FinalRelease() ;
        delete this ;
        return 0 ;
    }
    return m_cRef;
}

///////////////////////////////////////////////////////////
// FinishQI - 
//
// Helper function to simplify overriding NondelegatingQueryInterface
//
HRESULT CUnknown::FinishQI(IUnknown* pI, void** ppv) 
{
    // Copy pointer into out parameter.
    *ppv = pI ;
    // Increment reference count for this interface.
    pI->AddRef() ;
    return S_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\common\util.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  UTIL.CPP - utilities
//
//  HISTORY:
//
//  1/27/99 a-jaswed Created.
//
//  Common utilities for printing out messages

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <objbase.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>

#include "util.h"
#include "appdefs.h"
#include <shlwapi.h>
#include <shlobj.h>
#include <shfolder.h>
#include <wchar.h>
#include <winsvcp.h>    // for SC_OOBE_MACHINE_NAME_DONE


///////////////////////////////////////////////////////////
// Print out the COM/OLE error string for an HRESULT.
//
void ErrorMessage(LPCWSTR message, HRESULT hr)
{
    const WCHAR* sz ;
    if (message == NULL)
    {
        sz = L"The following error occured." ;
    }
    else
    {
        sz = message ;
    }

    void* pMsgBuf;

    ::FormatMessage(
         FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
         NULL,
         hr,
         MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
         (LPWSTR) &pMsgBuf,
         0,
         NULL
    );

    WCHAR buf[256] ;
    wsprintf(buf, L"%s\r\nError: (%x) - %s", sz, hr, (LPWSTR)pMsgBuf) ;

    MessageBox(NULL, buf, L"Utility Error Message Box.", MB_OK) ;

    // Free the buffer.
    LocalFree( pMsgBuf );
}

////////////////////////////////////////////////////////////
//  Check to see if both interfaces are on the same component.
//
BOOL InterfacesAreOnSameComponent(IUnknown* p1, IUnknown* p2)
{
    HRESULT hr = S_OK ;

    // Get the real IUnknown for the first interface.
    IUnknown* pReal1 = NULL ;
    hr = p1->QueryInterface(IID_IUnknown, (void**)&pReal1) ;
    assert(SUCCEEDED(hr)) ;

    // Get the real IUnknown for the second interface.
    IUnknown* pReal2 = NULL ;
    hr = p2->QueryInterface(IID_IUnknown, (void**)&pReal2) ;
    assert(SUCCEEDED(hr)) ;

    // Compare the IUnknown pointers.
    BOOL bReturn = (pReal1 == pReal2) ;

    // Cleanup
    pReal1->Release() ;
    pReal2->Release() ;

    // Return the value.
    return bReturn;
}


///////////////////////////////////////////////////////////
//  IsValidAddress
//
BOOL IsValidAddress(const void* lp, UINT nBytes, BOOL bReadWrite)
{
    return (lp != NULL && !::IsBadReadPtr(lp, nBytes) &&
        (!bReadWrite || !::IsBadWritePtr((LPVOID)lp, nBytes)));
}


///////////////////////////////////////////////////////////
//  MyDebug
//
#if ASSERTS_ON
VOID
AssertFail(
    IN PSTR FileName,
    IN UINT LineNumber,
    IN PSTR Condition
    )
{
    int i;
    CHAR Name[MAX_PATH];
    PCHAR p;
    CHAR Msg[4096];

    //
    // Use dll name as caption
    //
    GetModuleFileNameA(NULL,Name,MAX_PATH);
    if(p = strrchr(Name,'\\')) {
        p++;
    } else {
        p = Name;
    }

    wsprintfA(
        Msg,
        "Assertion failure at line %u in file %s: %s%s",
        LineNumber,
        FileName,
        Condition,
        "\n\nCall DebugBreak()?"
        );

    i = MessageBoxA(
            NULL,
            Msg,
            p,
            MB_YESNO | MB_TASKMODAL | MB_ICONSTOP | MB_SETFOREGROUND
            );

    if(i == IDYES) {
        DebugBreak();
    }
}
#endif


///////////////////////////////////////////////////////////
//  Trace
//
void __cdecl MyTrace(LPCWSTR lpszFormat, ...)
{
    USES_CONVERSION;
    va_list args;
    va_start(args, lpszFormat);

    int nBuf;
    WCHAR szBuffer[512];

    nBuf = _vsnwprintf(szBuffer, MAX_CHARS_IN_BUFFER(szBuffer), lpszFormat, args);

    // was there an error? was the expanded string too long?
    assert(nBuf > 0);

#if DBG
    DbgPrintEx( DPFLTR_SETUP_ID, DPFLTR_INFO_LEVEL, W2A(szBuffer) );
#endif

    va_end(args);
}


//BUGBUG need bettter default
bool GetString(HINSTANCE hInstance, UINT uiID, LPWSTR szString, UINT uiStringLen)
{
    // BUGBUG: Should this assume current module if hInstance is NULL??
    MYASSERT(NULL != hInstance);
    if (NULL != hInstance)
            return (0 < LoadString(hInstance, uiID, szString, uiStringLen));
    else
            return (false);
}


// the goal of this function is to be able to able to get to
// c:\windows dir\system dir\oobe\oobeinfo.ini
// c:\windows dir\system dir\oeminfo.ini
// c:\windows dir\oemaudit.oem
// the canonicalize allows the specification for oemaudit.oem to be ..\oemaudit.oem

bool GetCanonicalizedPath(LPWSTR szCompletePath, LPCWSTR szFileName)
{
    if (0 < GetSystemDirectory(szCompletePath, MAX_PATH))
    {
                lstrcat(szCompletePath, szFileName);

        WCHAR szLocal[MAX_PATH];
                lstrcpy(szLocal, szCompletePath);
                return PathCanonicalize(szCompletePath, (LPCWSTR) szLocal) ? true : false;
    }

    return false;
}

bool GetOOBEPath(LPWSTR szOOBEPath)
{
    if (0 < GetSystemDirectory(szOOBEPath, MAX_PATH))
    {
                lstrcat(szOOBEPath, L"\\OOBE");

                return true;
    }

    return false;
}

// This returns the path for the localized OOBE files on a system with MUI.
//
bool GetOOBEMUIPath(LPWSTR szOOBEPath)
{
    LANGID  UILang;
    WCHAR   szMUIPath[MAX_PATH];

    if (GetOOBEPath(szOOBEPath))
    {
                UILang = GetUserDefaultUILanguage();
                if ( UILang != GetSystemDefaultUILanguage() ) {
                    wsprintf( szMUIPath, L"\\MUI\\%04x", UILang );
                    lstrcat(szOOBEPath, szMUIPath );
                }

                return true;
    }

    return false;
}

HRESULT GetINIKey(HINSTANCE hInstance, LPCWSTR szINIFileName, UINT uiSectionName, UINT uiKeyName, LPVARIANT pvResult)
{
    WCHAR szSectionName[MAX_PATH], szKeyName[MAX_PATH];
    WCHAR szItem[1024]; //bugbug bad constant

        if (GetString(hInstance, uiSectionName, szSectionName) && GetString(hInstance, uiKeyName, szKeyName))
        {
                WCHAR szINIPath[MAX_PATH];
                if (GetCanonicalizedPath(szINIPath, szINIFileName))
                {
                        if (VT_I4 == V_VT(pvResult))
                        {
                                V_I4(pvResult) = GetPrivateProfileInt(szSectionName, szKeyName, 0, szINIPath);
                                return S_OK;
                        }
                        else
                        {
                                if (GetPrivateProfileString(
                                                szSectionName,
                                                szKeyName,
                                                L"",
                                                szItem,
                                                MAX_CHARS_IN_BUFFER(szItem),
                                                szINIPath))
                                {
                                    V_BSTR(pvResult) = SysAllocString(szItem);
                                    return S_OK;
                                }
                        }
                }
        }

        if (VT_BSTR == V_VT(pvResult))
                V_BSTR(pvResult) = SysAllocString(L"\0");
    else
                V_I4(pvResult) = 0;

        return S_OK;
}


HRESULT GetINIKeyBSTR(HINSTANCE hInstance, LPCWSTR szINIFileName, UINT uiSectionName, UINT uiKeyName, LPVARIANT pvResult)
{
    VariantInit(pvResult);
    V_VT(pvResult) = VT_BSTR;

        return (GetINIKey(hInstance, szINIFileName, uiSectionName, uiKeyName, pvResult));
}


HRESULT GetINIKeyUINT(HINSTANCE hInstance, LPCWSTR szINIFileName, UINT uiSectionName, UINT uiKeyName, LPVARIANT pvResult)
{
    VariantInit(pvResult);
    V_VT(pvResult) = VT_I4;

        return (GetINIKey(hInstance, szINIFileName, uiSectionName, uiKeyName, pvResult));
}


HRESULT SetINIKey(HINSTANCE hInstance, LPCWSTR szINIFileName, UINT uiSectionName, UINT uiKeyName, LPVARIANT pvResult)
{
	WCHAR szSectionName[MAX_PATH], szKeyName[MAX_PATH];

    VariantInit(pvResult);
    V_VT(pvResult) = VT_BSTR;

        if (GetString(hInstance, uiSectionName, szSectionName) && GetString(hInstance, uiKeyName, szKeyName))
        {
            if (WritePrivateProfileString(V_BSTR(pvResult), szKeyName,
                                          V_BSTR(pvResult), szINIFileName))
            {
                    return S_OK;
            }
        }

        return E_FAIL;
}



void WINAPI URLEncode(WCHAR* pszUrl, size_t bsize)
{
    if (!pszUrl)
        return;
    WCHAR* pszEncode = NULL;
    WCHAR* pszEStart = NULL;
    WCHAR* pszEEnd   = (WCHAR*)wmemchr( pszUrl, L'\0', bsize );
    int   iUrlLen   = (int)(pszEEnd-pszUrl);
    pszEEnd = pszUrl;

    WCHAR  c;
    size_t cch = (iUrlLen+1) * sizeof(WCHAR) * 3;

    assert( cch <= bsize );
    if (cch <= bsize)
    {

        pszEncode = (WCHAR*)malloc(BYTES_REQUIRED_BY_CCH(cch));
        if(pszEncode)
        {
            pszEStart = pszEncode;
            ZeroMemory(pszEncode, BYTES_REQUIRED_BY_CCH(cch));

            for(; c = *(pszUrl); pszUrl++)
            {
                switch(c)
                {
                    case L' ': //SPACE
                        memcpy(pszEncode, L"+", 1*sizeof(WCHAR));
                        pszEncode+=1;
                        break;
                    case L'#':
                        memcpy(pszEncode, L"%23", 3*sizeof(WCHAR));
                        pszEncode+=3;
                        break;
                    case L'&':
                        memcpy(pszEncode, L"%26", 3*sizeof(WCHAR));
                        pszEncode+=3;
                        break;
                    case L'%':
                        memcpy(pszEncode, L"%25", 3*sizeof(WCHAR));
                        pszEncode+=3;
                        break;
                    case L'=':
                        memcpy(pszEncode, L"%3D", 3*sizeof(WCHAR));
                        pszEncode+=3;
                        break;
                    case L'<':
                        memcpy(pszEncode, L"%3C", 3*sizeof(WCHAR));
                        pszEncode+=3;
                        break;
                    case L'+':
                        memcpy(pszEncode, L"%2B", 3*sizeof(WCHAR));
                        pszEncode += 3;
                        break;

                    default:
                        *pszEncode++ = c;
                        break;
                }
            }
            *pszEncode++ = L'\0';
            memcpy(pszEEnd ,pszEStart, (size_t)(pszEncode - pszEStart));
            free(pszEStart);
        }
    }
}


//BUGBUG:  Need to turn spaces into "+"
void WINAPI URLAppendQueryPair
(
    LPWSTR   lpszQuery,
    LPWSTR   lpszName,
    LPWSTR   lpszValue  OPTIONAL
)
{
    // Append the Name
    lstrcat(lpszQuery, lpszName);
    lstrcat(lpszQuery, cszEquals);

    // Append the Value
    if ( lpszValue ) {
        lstrcat(lpszQuery, lpszValue);
    }

    // Append an Ampersand if this is NOT the last pair
    lstrcat(lpszQuery, cszAmpersand);
}


void GetCmdLineToken(LPWSTR *ppszCmd, LPWSTR pszOut)
{
    LPWSTR  c;
    int     i = 0;
    BOOL    fInQuote = FALSE;

    c = *ppszCmd;

    pszOut[0] = *c;
    if (!*c)
        return;
    if (*c == L' ')
    {
        pszOut[1] = L'\0';
        *ppszCmd = c+1;
        return;
    }
    else if( L'"' == *c )
    {
        fInQuote = TRUE;
    }

NextChar:
    i++;
    c++;
    if( !*c || (!fInQuote && (*c == L' ')) )
    {
        pszOut[i] = L'\0';
        *ppszCmd = c;
        return;
    }
    else if( fInQuote && (*c == L'"') )
    {
        fInQuote = FALSE;
        pszOut[i] = *c;

        i++;
        c++;
        pszOut[i] = L'\0';
        *ppszCmd = c;
        return;
    }
    else
    {
        pszOut[i] = *c;
        goto NextChar;
    }
}


BOOL IsOEMDebugMode()
{
    HKEY   hKey      = NULL;
    DWORD  dwIsDebug = 0;
    DWORD  dwSize    = sizeof(dwIsDebug);

    if(RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                    OOBE_MAIN_REG_KEY,
                    0,
                    KEY_QUERY_VALUE,
                    &hKey) == ERROR_SUCCESS)
    {
        RegQueryValueEx(hKey,
                        OOBE_OEMDEBUG_REG_VAL,
                        0,
                        NULL,
                        (LPBYTE)&dwIsDebug,
                        &dwSize);
        RegCloseKey(hKey);
    }
#ifdef DEBUG
    return (BOOL)1;
#else
    return (BOOL)dwIsDebug;
#endif
}

VOID
PumpMessageQueue(
    VOID
    )
{
    MSG msg;

    while(PeekMessage(&msg, NULL, 0,0,PM_REMOVE)) {
        DispatchMessage(&msg);
    }

}

BOOL
IsThreadActive(
    HANDLE              hThread
    )
{
    DWORD               dwExitCode = 0;

    return (NULL != hThread
            && GetExitCodeThread(hThread, &dwExitCode)
            && STILL_ACTIVE == dwExitCode
            );
}

void GetDesktopDirectory(WCHAR* pszPath)
{
    WCHAR pszFolder[MAX_PATH];
    *pszFolder = L'\0';
    HRESULT hRet = SHGetFolderPath(NULL, CSIDL_COMMON_DESKTOPDIRECTORY,
                                   NULL, 0, pszFolder
                                   );
    if (S_OK != hRet)
    {
        hRet = SHGetFolderPath(NULL, CSIDL_DESKTOPDIRECTORY,
                               NULL, 0, pszFolder
                               );
    }

    if (S_OK == hRet)
    {
        lstrcpy(pszPath , pszFolder);
    }


}

void RemoveDesktopShortCut
(
    LPWSTR lpszShortcutName
)
{
    WCHAR szShortcutPath[MAX_PATH] = L"\0";

    GetDesktopDirectory(szShortcutPath);

    if(szShortcutPath[0] != L'\0')
    {
        lstrcat(szShortcutPath, L"\\");
        lstrcat(szShortcutPath, lpszShortcutName);
        lstrcat(szShortcutPath, L".LNK");
        DeleteFile(szShortcutPath);
    }
}

BOOL
InvokeExternalApplication(
    IN     PCWSTR ApplicationName,  OPTIONAL
    IN     PCWSTR CommandLine,
    IN OUT PDWORD ExitCode          OPTIONAL
    )

/*++

Routine Description:

    Invokes an external program, which is optionally detached.

Arguments:

    ApplicationName - supplies app name. May be a partial or full path,
        or just a filename, in which case the standard win32 path search
        is performed. If not specified then the first element in
        CommandLine must specify the binary to execute.

    CommandLine - supplies the command line to be passed to the
        application.

    ExitCode - If specified, the execution is synchronous and this value
        receives the exit code of the application. If not specified,
        the execution is asynchronous.

Return Value:

    Boolean value indicating whether the process was started successfully.

--*/

{
    PWSTR FullCommandLine;
    BOOL b;
    PROCESS_INFORMATION ProcessInfo;
    STARTUPINFO StartupInfo;
    DWORD d;

    b = FALSE;
    //
    // Form the command line to be passed to CreateProcess.
    //
    if(ApplicationName) {
        FullCommandLine =
            (PWSTR) malloc(BYTES_REQUIRED_BY_SZ(ApplicationName)+BYTES_REQUIRED_BY_SZ(CommandLine)+BYTES_REQUIRED_BY_CCH(2));
        if(!FullCommandLine) {
            goto err0;
        }

        lstrcpy(FullCommandLine, ApplicationName);
        lstrcat(FullCommandLine, L" ");
        lstrcat(FullCommandLine, CommandLine);
    } else {
        FullCommandLine =
            (PWSTR) malloc(BYTES_REQUIRED_BY_SZ(CommandLine));
        if(!FullCommandLine) {
	    goto err0;
        }
        lstrcpy(FullCommandLine, CommandLine);
    }

    //
    // Initialize startup info.
    //
    ZeroMemory(&StartupInfo, sizeof(STARTUPINFO));
    StartupInfo.cb = sizeof(STARTUPINFO);

    //
    // Create the process.
    //
    b = CreateProcess(
            NULL,
            FullCommandLine,
            NULL,
            NULL,
            FALSE,
            ExitCode ? 0 : DETACHED_PROCESS,
            NULL,
            NULL,
            &StartupInfo,
            &ProcessInfo
            );

    if(!b) {
        goto err1;
    }

    //
    // If execution is asynchronus, we're done.
    //
    if(!ExitCode) {
        goto err2;
    }

err2:
    CloseHandle(ProcessInfo.hThread);
    CloseHandle(ProcessInfo.hProcess);
err1:
    free(FullCommandLine);
err0:
    return(b);
}



//////////////////////////////////////////////////////////////////////////////
//
//  InSafeMode
//
//  Determine whether the system is running in safe mode or clean mode.
//
//  parameters:
//      None.
//
//  returns:
//      TRUE        if the system was booted in safe mode
//      FALSE       if the system was booted in clean mode
//
//////////////////////////////////////////////////////////////////////////////
BOOL
InSafeMode()
{
    if (BOOT_CLEAN != GetSystemMetrics(SM_CLEANBOOT))
    {
        TRACE(L"Running in SAFEMODE...\n");
        return TRUE;
    }
    return FALSE;
}   //  InSafeMode

// Signal winlogon that the computer name has been changed.  WinLogon waits to
// start services that depend on the computer name until this event is
// signalled.
//
BOOL
SignalComputerNameChangeComplete()
{
    BOOL                fReturn = TRUE;

    // Open event with EVENT_ALL_ACCESS so that synchronization and state
    // change can be done.
    //
    HANDLE              hevent = OpenEvent(EVENT_ALL_ACCESS,
                                           FALSE,
                                           SC_OOBE_MACHINE_NAME_DONE
                                           );

    // It is not fatal for OpenEvent to fail: this synchronization is only
    // required when OOBE will be run in OEM mode.
    //
    if (NULL != hevent)
    {
        if (! SetEvent(hevent))
        {
            // It is fatal to open but not set the event: services.exe will not
            // continue until this event is signalled.
            //
            TRACE2(L"Failed to signal SC_OOBE_MACHINE_NAME_DONE(%s): 0x%08X\n",
                  SC_OOBE_MACHINE_NAME_DONE, GetLastError());
            fReturn = FALSE;
        }
        MYASSERT(fReturn);  // Why did we fail to set an open event??
    }

    return fReturn;
}


BOOL
IsUserAdmin(
    VOID
    )

/*++

Routine Description:

    This routine returns TRUE if the caller's process is a
    member of the Administrators local group.

    Caller is NOT expected to be impersonating anyone and IS
    expected to be able to open their own process and process
    token.

Arguments:

    None.

Return Value:

    TRUE - Caller has Administrators local group.

    FALSE - Caller does not have Administrators local group.

--*/

{
    HANDLE Token;
    DWORD BytesRequired;
    PTOKEN_GROUPS Groups;
    BOOL b;
    DWORD i;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID AdministratorsGroup;


    //
    // Open the process token.
    //
    if(!OpenProcessToken(GetCurrentProcess(),TOKEN_QUERY,&Token)) {
        return(FALSE);
    }

    b = FALSE;
    Groups = NULL;

    //
    // Get group information.
    //
    if(!GetTokenInformation(Token,TokenGroups,NULL,0,&BytesRequired)
    && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
    && (Groups = (PTOKEN_GROUPS)LocalAlloc(LPTR,BytesRequired))
    && GetTokenInformation(Token,TokenGroups,Groups,BytesRequired,&BytesRequired)) {

        b = AllocateAndInitializeSid(
                &NtAuthority,
                2,
                SECURITY_BUILTIN_DOMAIN_RID,
                DOMAIN_ALIAS_RID_ADMINS,
                0, 0, 0, 0, 0, 0,
                &AdministratorsGroup
                );

        if(b) {

            //
            // See if the user has the administrator group.
            //
            b = FALSE;
            for(i=0; i<Groups->GroupCount; i++) {
                if(EqualSid(Groups->Groups[i].Sid,AdministratorsGroup)) {
                    b = TRUE;
                    break;
                }
            }

            FreeSid(AdministratorsGroup);
        }
    }

    //
    // Clean up and return.
    //

    if(Groups) {
        LocalFree((HLOCAL)Groups);
    }

    CloseHandle(Token);

    return(b);
}

#define MyMalloc(s)                  GlobalAlloc(GPTR, s)
#define MyFree(p)                    GlobalFree(p)

static LPTSTR
pDuplicateString(
    LPCTSTR szText
    )
{
    int    cchText;
    LPTSTR szOutText;
    
    if (szText == NULL)
    {
        return NULL;
    }

    cchText = lstrlen(szText);
    szOutText = (LPTSTR) MyMalloc(sizeof(TCHAR) * (cchText + 1));
    if (szOutText)
    {
        lstrcpyn(szOutText, szText, cchText + 1);
    }

    return szOutText;
}


PSTRINGLIST
CreateStringCell (
    IN      PCTSTR String
    )
{
    PSTRINGLIST p = (PSTRINGLIST) MyMalloc (sizeof (STRINGLIST));
    if (p) {
        ZeroMemory (p, sizeof (STRINGLIST));
        if (String) {
            p->String = pDuplicateString (String);
            if (!p->String) {
                MyFree (p);
                p = NULL;
            }
        } else {
            p->String = NULL;
        }
    }
    return p;
}

VOID
DeleteStringCell (
    IN      PSTRINGLIST Cell
    )
{
    if (Cell) {
        MyFree (Cell->String);
        MyFree (Cell);
    }
}


BOOL
InsertList (
    IN OUT  PSTRINGLIST* List,
    IN      PSTRINGLIST NewList
    )
{
    PSTRINGLIST p;

    if (!NewList) {
        return FALSE;
    }
    if (*List) {
        for (p = *List; p->Next; p = p->Next) ;
        p->Next = NewList;
    } else {
        *List = NewList;
    }
    return TRUE;
}

VOID
DestroyList (
    IN      PSTRINGLIST List
    )
{
    PSTRINGLIST p, q;

    for (p = List; p; p = q) {
        q = p->Next;
        DeleteStringCell (p);
    }
}

BOOL
RemoveListI(
    IN OUT  PSTRINGLIST* List,
    IN      PCTSTR       String
    )
{
    PSTRINGLIST p = *List;
    BOOL        b = FALSE;

    if (p)
    {
        if (!lstrcmpi(p->String, String))
        {
            *List = p->Next;
            DeleteStringCell(p);
            b = TRUE;
        }
        else
        {
            PSTRINGLIST q;
            for (q = p->Next; q; p = q, q = q->Next)
            {
                if (!lstrcmpi(q->String, String))
                {
                    p->Next = q->Next;
                    DeleteStringCell(q);
                    b = TRUE;
                    break;
                }
            }
        }
    }

    return b;
}

BOOL
ExistInListI(
    IN PSTRINGLIST List,
    IN PCTSTR      String
    )
{
    PSTRINGLIST p;

    for (p = List; p; p = p->Next)
    {
        if (!lstrcmpi(p->String, String))
        {
            break;
        }
    }

    return (p != NULL);
}

BOOL IsDriveNTFS(IN TCHAR Drive)
{
    TCHAR       DriveName[4];
    TCHAR       Filesystem[256];
    TCHAR       VolumeName[MAX_PATH];
    DWORD       SerialNumber;
    DWORD       MaxComponent;
    DWORD       Flags;
    BOOL        bIsNTFS = FALSE;

    DriveName[0] = Drive;
    DriveName[1] = TEXT(':');
    DriveName[2] = TEXT('\\');
    DriveName[3] = 0;

    if (GetVolumeInformation(
            DriveName,
            VolumeName,MAX_PATH,
            &SerialNumber,
            &MaxComponent,
            &Flags,
            Filesystem,
            sizeof(Filesystem)/sizeof(TCHAR)
            ))
    {
        bIsNTFS = (lstrcmpi(Filesystem,TEXT("NTFS")) == 0);
    }

    return bIsNTFS;
}

BOOL
HasTablet()
{
    TCHAR szPath[MAX_PATH+1];

    ZeroMemory(szPath, sizeof(szPath));
    
    if (FAILED(SHGetFolderPath(
        NULL,
        CSIDL_PROGRAM_FILES_COMMON,
        NULL,
        SHGFP_TYPE_DEFAULT,
        szPath)))
    {
        return FALSE;
    }

    StrCatBuff(szPath, TEXT("\\Microsoft Shared\\Ink\\tabtip.exe"), MAX_PATH+1);

    return PathFileExists(szPath);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\common\registry.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  REGISTRY.CPP - Implementation of functions to register components.
//
//  HISTORY:
//  
//  1/27/99 a-jaswed Created.
//
// registry functions.

#include <objbase.h>
#include <assert.h>
#include <appdefs.h>
#include "registry.h"


////////////////////////////////////////////////////////
// Internal helper functions prototypes
//

// Set the given key and its value.
BOOL setKeyAndValue(const WCHAR* pszPath, 
                    const WCHAR* szSubkey, 
                    const WCHAR* szValue,
                    const WCHAR* szName = NULL);

// Convert a CLSID into a char string.
void CLSIDtochar(const CLSID& clsid, 
                 WCHAR* szCLSID,
                 int   length);

// Determine if a particular subkey exists.
BOOL SubkeyExists(const WCHAR* pszPath,
                  const WCHAR* szSubkey);

// Delete szKeyChild and all of its descendents.
LONG recursiveDeleteKey(HKEY hKeyParent, const WCHAR* szKeyChild);

/////////////////////////////////////////////////////////
// Public function implementation
/////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////
// Register the component in the registry.
//
HRESULT RegisterServer( HMODULE hModule,                // DLL module handle
                        const CLSID& clsid,             // Class ID
                        const WCHAR* szFriendlyName,     // Friendly Name
                        const WCHAR* szVerIndProgID,     // Programmatic
                        const WCHAR* szProgID)           //  IDs
{
    // Get server location.
    WCHAR szModule[512] ;
    DWORD dwResult = 
        ::GetModuleFileName(hModule, 
                            szModule, 
                            MAX_CHARS_IN_BUFFER(szModule)) ; 
    assert(dwResult != 0) ;

    // Convert a CLSID into a char string.
    WCHAR szCLSID[CLSID_STRING_SIZE] ;
    CLSIDtochar(clsid, szCLSID, CLSID_STRING_SIZE) ;

    // Build the key CLSID\\{...}
    WCHAR szKey[64] ;
    lstrcpy(szKey, L"CLSID\\");
    lstrcat(szKey, szCLSID) ;

    // Add the CLSID to the registry.
    setKeyAndValue(szKey, NULL, szFriendlyName) ;

    // Add server filename key
#ifdef _OUTPROC_SERVER_
    setKeyAndValue(szKey, L"LocalServer32", szModule) ;
#else
    setKeyAndValue(szKey, L"InprocServer32", szModule) ;
#endif

    // Add the ProgID subkey under the CLSID key.
    setKeyAndValue(szKey, L"ProgID", szProgID) ;

    // Add the version-independent ProgID subkey under CLSID key.
    setKeyAndValue( szKey, L"VersionIndependentProgID", 
                    szVerIndProgID) ;

    // Add the version-independent ProgID subkey under HKEY_CLASSES_ROOT.
    setKeyAndValue(szVerIndProgID, NULL, szFriendlyName); 
    setKeyAndValue(szVerIndProgID, L"CLSID", szCLSID) ;
    setKeyAndValue(szVerIndProgID, L"CurVer", szProgID) ;

    // Add the versioned ProgID subkey under HKEY_CLASSES_ROOT.
    setKeyAndValue(szProgID, NULL, szFriendlyName); 
    setKeyAndValue(szProgID, L"CLSID", szCLSID) ;

    return S_OK;
}

/////////////////////////////////////////////////////////
// Remove the component from the registry.
//
LONG UnregisterServer(  const CLSID& clsid,
                        const WCHAR* szVerIndProgID,
                        const WCHAR* szProgID)
{
    // Convert the CLSID into a char.
    WCHAR szCLSID[CLSID_STRING_SIZE] ;
    CLSIDtochar(clsid, szCLSID, CLSID_STRING_SIZE) ;

    // Build the key CLSID\\{...}
    WCHAR szKey[80] ;
    lstrcpy(szKey, L"CLSID\\");
    lstrcat(szKey, szCLSID) ;

    // Check for a another server for this component.
#ifdef _OUTPROC_SERVER_
    if (SubkeyExists(szKey, L"InprocServer32"))
#else
    if (SubkeyExists(szKey, L"LocalServer32"))
#endif
    {
        // Delete only the path for this server.
#ifdef _OUTPROC_SERVER_
        lstrcat(szKey, L"\\LocalServer32") ;
#else
        lstrcat(szKey, L"\\InprocServer32") ;
#endif
        LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
        assert(lResult == ERROR_SUCCESS) ;
    }
    else
    {
        // Delete all related keys.
        // Delete the CLSID Key - CLSID\{...}
        LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
        assert((lResult == ERROR_SUCCESS) ||
               (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

        // Delete the version-independent ProgID Key.
        lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szVerIndProgID) ;
        assert((lResult == ERROR_SUCCESS) ||
               (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

        // Delete the ProgID key.
        lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szProgID) ;
        assert((lResult == ERROR_SUCCESS) ||
               (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.
    }
    return S_OK;
}

///////////////////////////////////////////////////////////
// Internal helper functions
///////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////
// Convert a CLSID to a char string.
//
void CLSIDtochar(   const CLSID& clsid, 
                    WCHAR* szCLSID,
                    int length)
{
    assert(length >= CLSID_STRING_SIZE) ;
    // Get CLSID
    LPOLESTR sz = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &sz) ;
    assert(SUCCEEDED(hr)) ;
    assert(NULL != sz);

    // Convert from wide characters to non-wide characters.
    lstrcpyn(szCLSID, sz, length);

    // Free memory.
    CoTaskMemFree(sz) ;
}

/////////////////////////////////////////////////////////
// Delete a key and all of its descendents.
//
LONG recursiveDeleteKey(HKEY hKeyParent,            // Parent of key to delete.
                        const WCHAR* lpszKeyChild)   // Key to delete.
{
    // Open the child.
    HKEY hKeyChild;
    LONG lRes = RegOpenKeyEx(   hKeyParent, lpszKeyChild, 0, 
                                KEY_ALL_ACCESS, &hKeyChild);
    if (lRes != ERROR_SUCCESS)
    {
        return lRes;
    }

    // Enumerate all of the decendents of this child.
    FILETIME time;
    WCHAR szBuffer[256];
    DWORD dwSize = 256;
    while (RegEnumKeyEx(hKeyChild, 0, szBuffer, &dwSize, NULL, 
                        NULL, NULL, &time) == S_OK)
    {
        // Delete the decendents of this child.
        lRes = recursiveDeleteKey(hKeyChild, szBuffer);
        if (lRes != ERROR_SUCCESS)
        {
            // Cleanup before exiting.
            RegCloseKey(hKeyChild);
            return lRes;
        }
        dwSize = 256;
    }

    // Close the child.
    RegCloseKey(hKeyChild);

    // Delete this child.
    return RegDeleteKey(hKeyParent, lpszKeyChild);
}

/////////////////////////////////////////////////////////
// Determine if a particular subkey exists.
//
BOOL SubkeyExists(const WCHAR* pszPath,    // Path of key to check
                  const WCHAR* szSubkey)   // Key to check
{
    HKEY hKey ;
    WCHAR szKeyBuf[80] ;

    // Copy keyname into buffer.
    lstrcpy(szKeyBuf, pszPath) ;

    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        lstrcat(szKeyBuf, L"\\") ;
        lstrcat(szKeyBuf, szSubkey ) ;
    }

    // Determine if key exists by trying to open it.
    LONG lResult = ::RegOpenKeyEx(HKEY_CLASSES_ROOT, 
                                  szKeyBuf,
                                  0,
                                  KEY_ALL_ACCESS,
                                  &hKey) ;
    if (lResult == ERROR_SUCCESS)
    {
        RegCloseKey(hKey) ;
        return TRUE ;
    }
    return FALSE ;
}

/////////////////////////////////////////////////////////
// Create a key and set its value.
//
// This helper function was borrowed and modifed from Kraig Brockschmidt's
// book Inside OLE.
//
BOOL setKeyAndValue(const WCHAR* szKey, 
                    const WCHAR* szSubkey, 
                    const WCHAR* szValue,
                    const WCHAR* szName) 
{
    HKEY hKey;
    WCHAR szKeyBuf[1024] ;

    // Copy keyname into buffer.
    lstrcpy(szKeyBuf, szKey);

    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        lstrcat(szKeyBuf, L"\\");
        lstrcat(szKeyBuf, szSubkey );
    }

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(  HKEY_CLASSES_ROOT,
                                    szKeyBuf, 
                                    0, NULL, REG_OPTION_NON_VOLATILE, 
                                    KEY_ALL_ACCESS, NULL, 
                                    &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)         
    {
         RegSetValueEx(hKey, szName, 0, REG_SZ, 
                            (BYTE *)szValue, 
                            BYTES_REQUIRED_BY_SZ(szValue)
                            );
    }

    RegCloseKey(hKey);
    return TRUE;
}

// value must be at least 1024 in size;
BOOL getKeyAndValue(const WCHAR* szKey, 
                    const WCHAR* szSubkey, 
                    const WCHAR* szValue,
                    const WCHAR* szName) 
{
    HKEY hKey;
    WCHAR szKeyBuf[1024] ;

    // Copy keyname into buffer.
    lstrcpy(szKeyBuf, szKey);

    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        lstrcat(szKeyBuf, L"\\");
        lstrcat(szKeyBuf, szSubkey );
    }
                
        // open key and subkey.
    long lResult = RegOpenKeyEx(  HKEY_CLASSES_ROOT,
                                    szKeyBuf, 
                                    0,
                                    KEY_QUERY_VALUE, 
                                    &hKey) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE;
    }

    // Get the Value.
    if (szValue != NULL)         
    {
                DWORD   dwType, dwBufferSize = GETKEYANDVALUEBUFFSIZE;
                lResult = RegQueryValueEx(hKey, szName, NULL, &dwType, (LPBYTE) szValue, &dwBufferSize);
                if (lResult != ERROR_SUCCESS)
                {
                        return FALSE;
                }
    }

    RegCloseKey(hKey);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\html\makefile.inc ===
.SUFFIXES: .csx .htx .jsx

{}.htx{$O\}.htm:
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@
    $(BINPLACE_CMD)

{}.jsx{$O\}.js:
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@
    $(BINPLACE_CMD)

{error\}.htx{$O\}.htm:
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@
    $(BINPLACE_CMD)

{actsetup\}.htx{$O\}.htm:
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@
    $(BINPLACE_CMD)

{actsetup\}.csx{$O\}.css:
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@
    $(BINPLACE_CMD)

{html\dslmain\}.htx{$O\}.htm:
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@
    $(BINPLACE_CMD)

{html\iconnect\}.htx{$O\}.htm:
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@
    $(BINPLACE_CMD)

{html\ispsgnup\}.htx{$O\}.htm:
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@
    $(BINPLACE_CMD)

{html\isptype\}.htx{$O\}.htm:
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@
    $(BINPLACE_CMD)

{html\migwiz\}.htx{$O\}.htm:
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@
    $(BINPLACE_CMD)

{html\mouse\}.htx{$O\}.htm:
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@
    $(BINPLACE_CMD)

{html\oemcust\}.htx{$O\}.htm:
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@
    $(BINPLACE_CMD)

{html\oemhw\}.htx{$O\}.htm:
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@
    $(BINPLACE_CMD)

{html\oemreg\}.htx{$O\}.htm:
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@
    $(BINPLACE_CMD)

{html\sconnect\}.htx{$O\}.htm:
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@
    $(BINPLACE_CMD)

{icserror\}.htx{$O\}.htm:
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@
    $(BINPLACE_CMD)

{isperror\}.htx{$O\}.htm:
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@
    $(BINPLACE_CMD)

{msnerror\}.htx{$O\}.htm:
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@
    $(BINPLACE_CMD)

{msnsetup\}.htx{$O\}.htm:
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@
    $(BINPLACE_CMD)

{msnsetup\}.csx{$O\}.css:
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@
    $(BINPLACE_CMD)

{newoobe\}.htx{$O\}.htm:
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@
    $(BINPLACE_CMD)

{newoobe\}.csx{$O\}.css:
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@
    $(BINPLACE_CMD)

{regerror\}.htx{$O\}.htm:
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@
    $(BINPLACE_CMD)

{regsetup\}.htx{$O\}.htm:
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@
    $(BINPLACE_CMD)

{regsetup\}.csx{$O\}.css:
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@
    $(BINPLACE_CMD)

{sample\}.htx{$O\}.htm:
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@
    $(BINPLACE_CMD)

{setup\}.csx{$O\}.css:
    @echo Creating $@ from $**
    $(C_PREPROCESSOR) $** > $@
    $(BINPLACE_CMD)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\inc\commerr.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  COMMERR.H - Header for the communication manager error definitions
//
//  HISTORY:
//  
//  2/10/99 vyung Created.
// 
//  

#ifndef _COMMERR_H_
#define _COMMERR_H_

//window.external.CheckDialReady
#define ERR_COMM_NO_ERROR             0x00000000        // There is no error
#define ERR_COMM_OOBE_COMP_MISSING    0x00000001        // Some OOBE component is missing
#define ERR_COMM_UNKNOWN              0x00000002        // Unknow error, check input parameters
#define ERR_COMM_NOMODEM              0x00000003        // There is no modem installed
#define ERR_COMM_RAS_TCP_NOTINSTALL   0x00000004        // TCP/IP or RAS is not installed
#define ERR_COMM_ISDN                 0x00000005
#define ERR_COMM_PHONE_AND_ISDN       0x00000006

//window.external.Dial -- RAS events
#define ERR_COMM_RAS_PHONEBUSY        0x00000001
#define ERR_COMM_RAS_NODIALTONE       0x00000002
#define ERR_COMM_RAS_NOMODEM          ERR_COMM_NOMODEM
#define ERR_COMM_RAS_SERVERBUSY       0x00000004
#define ERR_COMM_RAS_UNKNOWN          0x00000005

//window.external.navigate/submit/processins -- server errors
#define ERR_COMM_SERVER_BINDFAILED    0x00000001

//Server errors
#define ERR_SERVER_DNS               0x00000002
#define ERR_SERVER_SYNTAX            0x00000003
#define ERR_SERVER_HTTP_400          0x00000190
#define ERR_SERVER_HTTP_403          0x00000193
#define ERR_SERVER_HTTP_404          0x00000194
#define ERR_SERVER_HTTP_405          0x00000195
#define ERR_SERVER_HTTP_406          0x00000196
#define ERR_SERVER_HTTP_408          0x00000198
#define ERR_SERVER_HTTP_410          0x0000019A
#define ERR_SERVER_HTTP_500          0x000001F4
#define ERR_SERVER_HTTP_501          0x000001F5

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\inc\cunknown.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  CUNKNOWN.H - Header file for IUnknown Implementation.
//
//  HISTORY:
//  
//  1/27/99 a-jaswed Created.
//
// IUnknown Implementation.

#ifndef __CUnknown_h__
#define __CUnknown_h__

#include <objbase.h>

///////////////////////////////////////////////////////////
// Nondelegating version of IUnknown.
//
struct INondelegatingUnknown
{
    virtual HRESULT  __stdcall 
        NondelegatingQueryInterface(const IID& iid, void** ppv) = 0;
    virtual ULONG    __stdcall NondelegatingAddRef() = 0;
    virtual ULONG    __stdcall NondelegatingRelease() = 0;
};

/////////////////////////////////////////////////////////////////////
// Declaration of CUnknown 
//
// Base class for implementing IUnknown.
//

class CUnknown : public INondelegatingUnknown
{
public:
    // Internal IUnknown Implementation...
    virtual HRESULT  __stdcall NondelegatingQueryInterface( const IID&, 
                                                            void**) ;
    virtual ULONG    __stdcall NondelegatingAddRef() ;
    virtual ULONG    __stdcall NondelegatingRelease();
    
    // Constructor
    CUnknown(IUnknown* pOuterUnknown) ;
    
    // Destructor
    virtual ~CUnknown() ;
    
    // Initialization (esp for aggregates)
    virtual HRESULT Init() 
        {return S_OK;}

    // Notify derived classes that we are releasing.
    virtual void FinalRelease() ;

    // Support for delegation
    IUnknown* GetOuterUnknown() const
    { return m_pOuterUnknown; }

    // Count of currently active components.
    static long ActiveComponents() 
    {return s_cActiveComponents;}
    
    // QueryInterface Helper Function
    HRESULT FinishQI(IUnknown* pI, void** ppv) ;
    
private:
    // Reference Count for this object.
    long m_cRef;

    // Outer IUnknown pointer.
    IUnknown* m_pOuterUnknown;

    // Count of all active instances.
    static long s_cActiveComponents ; 
} ;


///////////////////////////////////////////////////////////
// Delegating IUnknown - 
//
// Delegates to the nondelegating IUnknown interface if 
// not aggregated. If aggregated, delegates to the outer unknown.
//
#define DECLARE_IUNKNOWN                                    \
    virtual HRESULT __stdcall                               \
    QueryInterface(const IID& iid, void** ppv)              \
    {                                                       \
        return GetOuterUnknown()->QueryInterface(iid,ppv);  \
    };                                                      \
    virtual ULONG __stdcall AddRef()                        \
    {                                                       \
        return GetOuterUnknown()->AddRef();                 \
    };                                                      \
    virtual ULONG __stdcall Release()                       \
    {                                                       \
        return GetOuterUnknown()->Release();                \
    };

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\inc\msobstub.h ===
#ifndef     _MSOBSTUB_H_
#define _MSOBSTUB_H_

//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module: msobstub.h
//
//  Author: Dan Elliott
//
//  Abstract:
//
//  Environment:
//      Whistler
//
//  Revision History:
//      000210  dane    Created.
//
//////////////////////////////////////////////////////////////////////////////


#include <windows.h>

// Setup
//
BOOL
ValidateEula(
    LPWSTR              szEulaPath,
    int                 cchEulaPath
    );


#endif  //  _MSOBSTUB_H_

//
///// End of file: msobstub.h ////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\inc\msobdl.h ===
// ############################################################################
#ifndef _ICWDL_H
#define _ICWDL_H

// These are the types of info that are passed back through the callback
#define CALLBACK_TYPE_URL       100
#define CALLBACK_TYPE_PROGRESS  99

// ############################################################################
#define DOWNLOAD_LIBRARY     L"msobdl.dll"
#define DOWNLOADINIT         "DownLoadInit"
#define DOWNLOADEXECUTE      "DownLoadExecute"
#define DOWNLOADCLOSE        "DownLoadClose"
#define DOWNLOADSETSTATUS    "DownLoadSetStatusCallback"
#define DOWNLOADPROCESS      "DownLoadProcess"
#define DOWNLOADCANCEL       "DownLoadCancel"

// ############################################################################
typedef HRESULT (CALLBACK *PFNDOWNLOADINIT)(LPWSTR pszURL, DWORD FAR *lpCDialingDlg, DWORD_PTR FAR *pdwDownLoad, HWND hwndParent);
typedef HRESULT (CALLBACK *PFNDOWNLOADCANCEL)(DWORD_PTR dwDownLoad);
typedef HRESULT (CALLBACK *PFNDOWNLOADEXECUTE)(DWORD_PTR dwDownLoad);
typedef HRESULT (CALLBACK *PFNDOWNLOADCLOSE)(DWORD_PTR dwDownLoad);

// jmazner  10/2/96  Normandy #8493
// WRONG PROTOTYPE!! This should match icwdl/download.cpp:DownLoadSetStatusCallBack!!
//typedef HRESULT (CALLBACK *PFNDOWNLOADSETSTATUS)(DWORD dwDownLoad,INTERNET_STATUS_CALLBACK pfnCallback, DWORD dwContext);
typedef HRESULT (CALLBACK *PFNDOWNLOADSETSTATUS)(DWORD_PTR dwDownLoad,INTERNET_STATUS_CALLBACK pfnCallback);

typedef HRESULT (CALLBACK *PFNDOWNLOADPROCESS)(DWORD_PTR dwDownLoad);

#endif // _ICWDL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\inc\appdefs.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  APPDEFS.H - Header for application wide defines, typedefs, etc
//
//  HISTORY:
//
//  1/27/99 a-jaswed Created.
//
// Header for application wide defines, typedefs, etc

#ifndef _APPDEFS_H_
#define _APPDEFS_H_

#include <windows.h>
#include <wtypes.h>
#include <oleauto.h>
#include <malloc.h>

#define OOBE_DIR                        L"\\OOBE"
#define OOBE_SHELL_DLL                  L"MSOBSHEL.DLL"
#define OOBE_MAIN_DLL                   L"MSOBMAIN.DLL"
#define OOBE_WEB_DLL                    L"MSOBWEB.DLL"
#define OOBE_COMM_DLL                   L"MSOBCOMM.DLL"
#define OOBE_EXE                        L"MSOOBE.EXE"
#define OOBEBALN_EXE                    L"OOBEBALN.EXE"
#define ICW_APP_TITLE                   L"INETWIZ.EXE"

#define OOBE_MAIN_CLASSNAME             L"MSOBMAIN_AppWindow"
#define OOBE_MAIN_WINDOWNAME            L"Microsoft Out of Box Experience"
#define OBSHEL_MAINPANE_CLASSNAME       L"MSOBSHEL_MainPane"
#define OBSHEL_MAINPANE_WINDOWNAME      L"ObShellMainPane"
#define OBSHEL_STATUSPANE_CLASSNAME     L"MSOBSHEL_StatPane"
#define OBSHEL_STATUSPANE_WINDOWNAME    L"CObShellStatusPane"

#define OBSHEL_STATUSPANE_MINITEM       0
#define OBSHEL_STATUSPANE_MAXITEM       8

//Window size for standalone operation
#define MSN_WIDTH                       640
#define MSN_HEIGHT                      530

//These MUST be ANSI for GetProcAddress
#define MSOBMAIN_ENTRY                  "LaunchMSOOBE"
#define REG_SERVER                      "DllRegisterServer"
#define UNREG_SERVER                    "DllUnregisterServer"

#define DEFAULT_FRAME_NAME              L"msoobeMain"
#define DEFAULT_FRAME_PAGE              L"msobshel.htm"
#define MSN_FRAME_PAGE                  L"dtsgnup.htm"
#define REG_FRAME_PAGE                  L"regshell.htm"
#define ISP_FRAME_PAGE                  L"ispshell.htm"
#define ACT_FRAME_PAGE                  L"actshell.htm"
#define DEFAULT_START_PAGE              L"\\setup\\welcome.htm"
#define DEFAULT_STATUS_PAGE             L"/STATPANE_RESOURCE"
#define IFRMSTATUSPANE                  L"ifrmStatusPane"
#define WINNT_INF_FILENAME              L"\\$winnt$.inf"
#define OOBE_PATH                       L"\\oobe\\msoobe.exe"
#define OOBE_BALLOON_REMINDER           L"\\oobe\\oobebaln.exe"
#define DATA_SECTION                    L"data"
#define WINNT_UPGRADE                   L"winntupgrade"
#define WIN9X_UPGRADE                   L"win9xupgrade"
#define YES_ANSWER                      L"yes"
#define OOBE_PROXY_SECTION              L"OobeProxy"
#define OOBE_ENABLE_OOBY_PROXY          L"Enable"
#define OOBE_FLAGS                      L"Flags"
#define OOBE_PROXY_SERVER               L"Proxy_Server"
#define OOBE_PROXY_BYPASS               L"Proxy_Bypass"
#define OOBE_AUTOCONFIG_URL             L"Autoconfig_URL"
#define OOBE_AUTODISCOVERY_FLAGS        L"Autodiscovery_Flag"
#define OOBE_AUTOCONFIG_SECONDARY_URL   L"Autoconfig_Secondary_URL"


#define OOBE_MAIN_REG_KEY               L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OOBE"
#define REG_KEY_OOBE_TEMP               L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OOBE\\Temp"
#define REG_KEY_OOBE_CKPT               L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OOBE\\CKPT"
#define REG_KEY_OOBE_ICS                L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OOBE\\ics"
#define REG_KEY_OOBE_STATUS             L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OOBE\\status"
#define REG_KEY_WINDOWS                 L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion"
#define REG_KEY_WINDOWSNT               L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"
#define REG_KEY_SETUP                   L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup"
#define RUNONCE_REGKEY                  L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce"
#define IE_APP_PATH_REGKEY              L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEXPLORE.EXE"
#define NOEULA_REGKEY L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion"
#define REG_KEY_CONFIG_DISPLAY          L"Config\\0001\\Display\\Settings"
#define RUNONCE_IE_ENTRY                L"^BrowseNow"
#define OOBE_OEMDEBUG_REG_VAL           L"OEMDebug"
#define OOBE_MSDEBUG_REG_VAL            L"MsDebug"
#define REG_VAL_OOBE                    L"OOBE"
#define REG_VAL_REBOOT                  L"DontReboot"
#define REG_VAL_RES                     L"Resolution"
#define REG_VAL_ISPSIGNUP               L"ISPSignup"
#define REG_VAL_NOEULA                  L"WelcomeHelpString"
#define OOBE_SKIP_EULA_VAL              L"Welcome to Microsoft Windows."
#define REG_VAL_COMPUTERDESCRIPTION     L"ComputerDescription"
#define REG_VAL_PRODUCTID               L"ProductId"

#define OOBE_EVENT_NOEXITCODE           L"OOBE_Event_NoExitCode"

////////////////////////////////////////////////////////////////
//??????????????????????????????????????????????????????????????
//??? This is for OOBEINFO.INI

#define INI_SETTINGS_FILENAME           L"\\oobe\\OOBEINFO.INI"
#define OEMINFO_INI_FILENAME            INI_SETTINGS_FILENAME
#define DEFAULT_WINDOW_TEXT             L"Microsoft Out of Box Experience"
#define MSN_WINDOW_TEXT                 L"MSN Setup"

////////////////////////////////////
////////////////////////////////////
//SECTION :: StartupOptions
#define STARTUP_OPTIONS_SECTION         L"StartupOptions"
//KEYS:
#define OOBE_FULLSCREEN_MODE            L"FullScreenMode"
#define OOBE_FULLSCREEN_MODE_DEFAULT    1
#define OOBE_DESKTOP_URL               L"DesktopStartUrl"
#define OOBE_DESKTOP_URL_DEFAULT        MSN_FRAME_PAGE
#define OOBE_DESKTOP_TITLE             L"DesktopWindowTitle"
#define OOBE_DESKTOP_TITLE_DEFAULT     DEFAULT_WINDOW_TEXT
#define OOBE_DESKTOP_HEIGHT            L"DesktopWindowHeight"
#define OOBE_DESKTOP_HEIGHT_DEFAULT    MSN_HEIGHT
#define OOBE_DESKTOP_WIDTH             L"DesktopWindowWidth"
#define OOBE_DESKTOP_WIDTH_DEFAULT     MSN_WIDTH
#define OOBE_SCREEN_RES_CHECK          L"ScreenResolutionCheck"
#define OOBE_SCREEN_RES_CHECK_DEFAULT  1
#define OOBE_OEMAUDITBOOT              L"OEMAuditBoot"

////////////////////////////////////
////////////////////////////////////
//SECTION :: StartupOptions
#define STATUS_PANE_SECTION             L"StatusPane"
//KEYS:
#define STATUS_PANE_ITEM                L"Item_text_%d"
#define STATUS_PANE_LOGO                L"Logo"
#define STATUS_PANE_LOGO_BACKGROUND     L"LogoBackground"
#define REGISTRATION                    L"Registration"

////////////////////////////////////
////////////////////////////////////
//SECTION :: WindowsLogon
#define WINDOWS_LOGON_SECTION           L"WindowsLogon"
//KEYS:
#define AUTOLOGON                       L"AutoLogon"
#define DEFAULT_USER_NAME               L"DefaultUserName"

////////////////////////////////////
////////////////////////////////////
//SECTION :: HardwareOptions
#define OPTIONS_SECTION                L"Options"
//KEYS:
#define TONEPULSE                      L"TonePulse"
#define CHECK_KEYBOARD                 L"USBKeyboard"
#define CHECK_MOUSE                    L"USBMouse"
#define AREACODE                       L"Areacode"
#define OUTSIDELINE                    L"OutsideLine"
#define DISABLECALLWAITING             L"DisableCallWaiting"
#define DEFAULT_REGION                 L"DefaultRegion"
#define DEFAULT_LANGUAGE               L"DefaultLanguage"
#define DEFAULT_KEYBOARD               L"DefaultKeyboard"
#define CHECK_MODEMGCI                 L"CheckModemGCI"
#define OOBE_KEEPCURRENTTIME           L"KeepCurrentTime"
#define USE_1394_AS_LAN                L"Use1394AsLan"

#define NOUSBKBD_FILENAME              L"\\oobe\\setup\\nousbkbd.htm"
#define NOUSBMS_FILENAME               L"\\oobe\\setup\\nousbms.htm"
#define NOUSBKM_FILENAME               L"\\oobe\\setup\\nousbkm.htm"

////////////////////////////////////
////////////////////////////////////
//SECTION :: DesktopReminders
#define DESKTOPREMINDERS_SECTION       L"DesktopReminders"
//KEYS:
#define REGREMINDERX                   L"RegRemind%1d"
#define ISPREMINDERX                   L"ISPRemind%1d"



////////////////////////////////////
////////////////////////////////////
//SECTION :: UserInfo
#define USER_INFO_KEYNAME                L"UserInfo"


////////////////////////////////////////////////////////////////
//??????????????????????????????????????????????????????????????
//??? ISP file

////////////////////////////////////
////////////////////////////////////
//SECTION :: URL
#define ISP_FILE_URL_SECTION            L"URL"
//KEYS:
#define ISP_FILE_SIGNUP_URL             L"Signup"

////////////////////////////////////////////////////////////////
//??????????????????????????????????????????????????????????????
// These are the command line option used by MSoobe.exe

#define CMD_FULLSCREENMODE              L"/F"
#define CMD_MSNMODE                     L"/x"
#define CMD_ICWMODE                     L"/xicw"
#define CMD_PRECONFIG                   L"/preconfig"
#define CMD_OFFLINE                     L"/offline"
#define CMD_SHELLNEXT                   L"/shellnext"
#define CMD_SETPWD                      L"/setpwd"
#define CMD_OOBE                        L"/oobe"
#define CMD_REG                         L"/r"
#define CMD_ISP                         L"/i"
#define CMD_ACTIVATE                    L"/a"
#define CMD_1                           L"/1"
#define CMD_2                           L"/2"
#define CMD_3                           L"/3"
#define CMD_RETAIL                      L"/retail"
#define CMD_2NDINSTANCE                 L"/2ND"

const WCHAR cszEquals[]               = L"=";
const WCHAR cszAmpersand[]            = L"&";
const WCHAR cszPlus[]                 = L"+";
const WCHAR cszQuestion[]             = L"?";
const WCHAR cszFormNamePAGEID[]       = L"PAGEID";
const WCHAR cszFormNameBACK[]         = L"BACK";
const WCHAR cszFormNamePAGETYPE[]     = L"PAGETYPE";
const WCHAR cszFormNameNEXT[]         = L"NEXT";
const WCHAR cszFormNamePAGEFLAG[]     = L"PAGEFLAG";
const WCHAR cszPageTypeTERMS[]        = L"TERMS";
const WCHAR cszPageTypeCUSTOMFINISH[] = L"CUSTOMFINISH";
const WCHAR cszPageTypeFINISH[]       = L"FINISH";
const WCHAR cszPageTypeNORMAL[]       = L"";
const WCHAR cszOLSRegEntries[]        = L"regEntries";
const WCHAR cszKeyName[]              = L"KeyName";
const WCHAR cszEntry_Name[]           = L"Entry_Name";
const WCHAR cszEntryName[]            = L"EntryName";
const WCHAR cszEntryValue[]           = L"EntryValue";
const WCHAR cszOLSDesktopShortcut[]   = L"DesktopShortcut";
const WCHAR cszSourceName[]           = L"SourceName";
const WCHAR cszTargetName[]           = L"TargetName";

//Htm pagetype flags
#define PAGETYPE_UNDEFINED                     E_FAIL
#define PAGETYPE_NOOFFERS                      0x00000001
#define PAGETYPE_MARKETING                     0x00000002
#define PAGETYPE_BRANDED                       0x00000004
#define PAGETYPE_BILLING                       0x00000008
#define PAGETYPE_CUSTOMPAY                     0x00000010
#define PAGETYPE_ISP_NORMAL                    0x00000020
#define PAGETYPE_ISP_TOS                       0x00000040
#define PAGETYPE_ISP_FINISH                    0x00000080
#define PAGETYPE_ISP_CUSTOMFINISH              0x00000100
#define PAGETYPE_OLS_FINISH                    0x00000200

//Htm page flags
#define PAGEFLAG_SAVE_CHKBOX                   0x00000001  // Display ISP HTML with checkbox to save info at the bottom

//??????????????????????????????????????????????????????????????
////////////////////////////////////////////////////////////////

#define WM_OBCOMM_ONDIALERROR           WM_USER + 42
#define WM_OBCOMM_ONDIALING             WM_USER + 43
#define WM_OBCOMM_ONCONNECTING          WM_USER + 44
#define WM_OBCOMM_ONCONNECTED           WM_USER + 45
#define WM_OBCOMM_ONDISCONNECT          WM_USER + 46
#define WM_OBCOMM_ONSERVERERROR         WM_USER + 47
#define WM_OBCOMM_DOWNLOAD_PROGRESS     WM_USER + 50
#define WM_OBCOMM_DOWNLOAD_DONE         WM_USER + 51
#define WM_AGENT_HELP                   WM_USER + 52
#define WM_OBCOMM_ONICSCONN_STATUS      WM_USER + 53
#define WM_OBCOMM_DIAL_DONE             WM_USER + 54
#define WM_OBCOMM_NETCHECK_DONE         WM_USER + 56

#define WM_OBMAIN_QUIT                  WM_USER + 48
#define WM_OBMAIN_SERVICESSTART_DONE    WM_USER + 55
#define WM_OBMAIN_ASYNCINVOKE_DONE      WM_USER + 57
#define WM_OBMAIN_ASYNCINVOKE_FAILED    WM_USER + 58

#define WM_OBBACKGROUND_EXIT            WM_USER + 60
#define WM_OBMY_STATUS                  WM_USER + 61

#define WM_SKIP                         WM_USER + 0x3000


#define TIMER_DELAY                     100

#define IDT_OBMAIN_HANDSHAKE_TIMER      1001
#define IDT_OBMAIN_LICENSE_TIMER        1002


#define MAX_DISP_NAME                   50
#define MAX_RES_LEN                     256

// APP Mode enumeration.
typedef enum
{
    APMD_DEFAULT,
    APMD_OOBE,
    APMD_REG,
    APMD_ISP,
    APMD_MSN,
    APMD_ACT
} APMD;

// APP properties
#define PROP_FULLSCREEN     0x80000000
#define PROP_OOBE_OEM       0x00000001
#define PROP_SETCONNECTIOD  0x10000000
#define PROP_2NDINSTANCE    0x20000000
#define PROP_CALLFROM_MSN   0x40000000

// Registration post defines.
#define POST_TO_OEM                     0x0000001
#define POST_TO_MS                      0x0000002

// reminder types.
#define REMIND_REG          0
#define REMIND_ISP          1

// Activation errors
#define ERR_ACT_UNINITIALIZED          -1
#define ERR_ACT_SUCCESS                 0
#define ERR_ACT_INACCESSIBLE            1
#define ERR_ACT_INVALID_PID             2
#define ERR_ACT_USED_PID                3
#define ERR_ACT_INTERNAL_WINDOWS_ERR    4
#define ERR_ACT_BLOCKED_PID             5
#define ERR_ACT_CORRUPTED_PID           6
#define ERR_ACT_NETWORK_FAILURE         7

// Audit mode values
#define NO_AUDIT            0
#define NONE_RESTORE_AUDIT  1
#define RESTORE_AUDIT       2
#define SIMULATE_ENDUSER    3

#define ICW_OS_VER                             L"01"
#define ICW_ISPINFOPath                        L"download\\ispinfo.csv"

//various flags for the icw including branding stuff
#define ICW_CFGFLAG_OFFERS                     0x00000001  // 0 = No offer;        1 = offers
#define ICW_CFGFLAG_AUTOCONFIG                 0x00000002  // 0 = No;              1 = Yes
#define ICW_CFGFLAG_CNS                        0x00000004  // 0 = No star;         1 = Star
#define ICW_CFGFLAG_SIGNUP_PATH                0x00000008  // 0 = Jump to Finish;  1 = Continue down sign up path
#define ICW_CFGFLAG_USERINFO                   0x00000010  // 0 = Hide name/addr;  1 = Show name/addr page
#define ICW_CFGFLAG_BILL                       0x00000020  // 0 = Hide bill        1 = Show bill page
#define ICW_CFGFLAG_PAYMENT                    0x00000040  // 0 = Hide payment;    1 = Show payment page
#define ICW_CFGFLAG_SECURE                     0x00000080  // 0 = Not secure;      1 = Secure
#define ICW_CFGFLAG_IEAKMODE                   0x00000100  // 0 = No IEAK;         1 = IEAK
#define ICW_CFGFLAG_BRANDED                    0x00000200  // 0 = No branding;     1 = Branding
#define ICW_CFGFLAG_SBS                        0x00000400  // 0 = No SBS           1 = SBS
#define ICW_CFGFLAG_ALLOFFERS                  0x00000800  // 0 = Not all offers   1 = All offers
#define ICW_CFGFLAG_USE_COMPANYNAME            0x00001000  // 0 = Not use          1 = Use company name
#define ICW_CFGFLAG_ISDN_OFFER                 0x00002000  // 0 = Non-ISDN offer   1 = ISDN offer
#define ICW_CFGFLAG_OEM_SPECIAL                0x00004000  // 0 = non OEM special offer    1 = OEM special offer
#define ICW_CFGFLAG_OEM                        0x00008000  // 0 = non OEM offer    1 = OEM offer
#define ICW_CFGFLAG_MODEMOVERRIDE              0x00010000
#define ICW_CFGFLAG_ISPURLOVERRIDE             0x00020000
#define ICW_CFGFLAG_PRODCODE_FROM_CMDLINE      0x00040000
#define ICW_CFGFLAG_PROMOCODE_FROM_CMDLINE     0x00080000
#define ICW_CFGFLAG_OEMCODE_FROM_CMDLINE       0x00100000
#define ICW_CFGFLAG_SMARTREBOOT_NEWISP         0x00200000
#define ICW_CFGFLAG_SMARTREBOOT_AUTOCONFIG     0x00400000  // this is seperate from ICW_CFGFLAG_AUTOCONFIG so as not to confuse function of flag
#define ICW_CFGFLAG_SMARTREBOOT_MANUAL         0x00800000
#define ICW_CFGFLAG_DO_NOT_OVERRIDE_ALLOFFERS  0x01000000
#define ICW_CFGFLAG_SMARTREBOOT_LAN            0x02000000

#define CONNECTED_REFFERAL                     0x00000001
#define CONNECTED_ISP_SIGNUP                   0x00000002
#define CONNECTED_ISP_MIGRATE                  0x00000003
#define CONNECTED_REGISTRATION                 0x00000004
#define CONNECTED_TYPE_MAX                     5

// Default strings for oem, prod, and promo code
#define DEFAULT_OEMCODE                        L"Default"
#define DEFAULT_PRODUCTCODE                    L"Desktop"
#define DEFAULT_PROMOCODE                      L"Default"

#define UPGRADETYPE_NONE                       0
#define UPGRADETYPE_WIN9X                      1
#define UPGRADETYPE_WINNT                      2


const UINT MAXSTATUSITEMS = 10;

typedef struct  dispatchList_tag
{
    WCHAR szName [MAX_DISP_NAME];
    DWORD dwDispID;

}  DISPATCHLIST;

// These macros calculate the bytes required by a string.  The null-terminator
// is accounted for.
//
#define BYTES_REQUIRED_BY_CCH(cch) ((cch + 1) * sizeof(WCHAR))
#define BYTES_REQUIRED_BY_SZ(sz)   ((lstrlen(sz) + 1) * sizeof(WCHAR))

// These macros calculate the number of characters that will fit in a buffer.
// The null-terminator is accounted for.
//
#define MAX_CHARS_IN_BUFFER(buf)    ((sizeof(buf) / sizeof(WCHAR)) - 1)
#define MAX_CHARS_IN_CB(cb)         (((cb) / sizeof(WCHAR)) - 1)

#define ARRAYSIZE(a)                (sizeof(a) / sizeof(a[0]))

#define SZ_EMPTY L"\0"



///////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////
////////
//////// A2W -- AnsiToWide Helper
////////
////////

#define USES_CONVERSION int _convert = 0

inline LPWSTR WINAPI A2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars)
{
    lpw[0] = L'\0';
    MultiByteToWideChar(CP_ACP, 0, lpa, -1, lpw, nChars);
    return lpw;
}

inline LPSTR WINAPI W2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars)
{
    lpa[0] = '\0';
    WideCharToMultiByte(CP_ACP, 0, lpw, -1, lpa, nChars, NULL, NULL);
    return lpa;
}

#define A2WHELPER A2WHelper
#define W2AHELPER W2AHelper

#define W2A(lpw) (\
        ((LPCWSTR)lpw == NULL) ? NULL : (\
                _convert = (lstrlenW(lpw)+1)*2,\
                W2AHELPER((LPSTR) alloca(_convert), lpw, _convert)))
#define A2W(lpa) (\
        ((LPCSTR)lpa == NULL) ? NULL : (\
                _convert = (lstrlenA((LPSTR)lpa)+1),\
                A2WHELPER((LPWSTR) alloca(_convert*2), (LPSTR)lpa, _convert)))


#define A2CW(lpa) ((LPCWSTR)A2W(lpa))

#define A2COLE A2CW

#endif //_APPDEFS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\inc\dispids.h ===
#ifndef _DISPIDS_H
#define _DISPIDS_H

//MSOBCOMM
#define DISPID_DIALING                              0x420000
#define DISPID_CONNECTING                           0x420001
#define DISPID_DIALINGERROR                         0x420002
#define DISPIP_CONNECTIONCOMPLETE                   0x420003
#define DISPIP_DOWNLOADCOMPLETE                     0x420004

//MSOBSHEL
#define DISPID_MAINPANE_NAVCOMPLETE                 0x420100
#define DISPID_STATPANE_NAVCOMPLETE                 0x420101

//window.external
#define DISPID_EXTERNAL_POWERDOWN                   0x420200
#define DISPID_EXTERNAL_ENABLECANCEL                0x420201
#define DISPID_EXTERNAL_MOVENEXT                    0x420202
#define DISPID_EXTERNAL_MOVEPREVIOUS                0x420203
#define DISPID_EXTERNAL_DIAL                        0x420204
#define DISPID_EXTERNAL_HANGUP                      0x420205
#define DISPID_EXTERNAL_PROCESSINS                  0x420206
#define DISPID_EXTERNAL_USERINFO                    0x420208
// #define DISPID_EXTERNAL_UNUSED                      0x420209
#define DISPID_EXTERNAL_FINISH                      0x42020A
#define DISPID_EXTERNAL_CHECKDIALREADY              0x42020B
#define DISPID_EXTERNAL_BTN_CANCEL                  0x42020C
#define DISPID_EXTERNAL_BTN_EXISTING                0x42020D
// #define DISPID_EXTERNAL_UNUSED                      0x42020E
// #define DISPID_EXTERNAL_UNUSED                      0x42020F
#define DISPID_EXTERNAL_TAPILOC                     0x420210
#define DISPID_EXTERNAL_PRODUCTID                   0x420211
// #define DISPID_EXTERNAL_UNUSED                      0x420212
#define DISPID_EXTERNAL_PRECONFIGINS                0x420213
#define DISPID_EXTERNAL_LANGUAGE                    0x420214
#define DISPID_EXTERNAL_EULA                        0x420215
#define DISPID_EXTERNAL_SYSTEMCLOCK                 0x420216
#define DISPID_EXTERNAL_HIDECANCEL                  0x420217
#define DISPID_EXTERNAL_SIGNUP                      0x420218
#define DISPID_EXTERNAL_STATUS                      0x420219
#define DISPID_EXTERNAL_DIRECTIONS                  0x42021A
#define DISPID_EXTERNAL_API                         0x42021B
#define DISPID_EXTERNAL_BROWSENOW                   0x42021C
#define DISPID_EXTERNAL_LOADSTATUSITEMS             0x42021D
#define DISPID_EXTERNAL_EXECSCRIPTFN                0x42021E
#define DISPID_EXTERNAL_GET_STATUSINDEX             0x42021F
#define DISPID_EXTERNAL_REDIAL                      0x420220
#define DISPID_EXTERNAL_GETRECONNECTURL             0x420221
#define DISPID_EXTERNAL_GETFILE                     0x420222
#define DISPID_EXTERNAL_GETDIALNUMBER               0x420223
#define DISPID_EXTERNAL_CHECKPHONEBOOK              0x420224
#define DISPID_EXTERNAL_REGISTER                    0x420225
#define DISPID_EXTERNAL_SETDIALNUMBER               0x420226
#define DISPID_EXTERNAL_GETCONNECTIONTYPE           0x420227
#define DISPID_EXTERNAL_CONNECT                     0x420228
#define DISPID_EXTERNAL_RECONNECT                   0x420229
#define DISPID_EXTERNAL_SET_STATUSINDEX             0x42022A
// #define DISPID_EXTERNAL_UNUSED                      0x42022B
// #define DISPID_EXTERNAL_UNUSED                      0x42022c
// #define DISPID_EXTERNAL_UNUSED                      0x42022D
// #define DISPID_EXTERNAL_UNUSED                      0x42022E
// #define DISPID_EXTERNAL_UNUSED                      0x42022F
#define DISPID_EXTERNAL_RUNMANUALICW                0x420230
#define DISPID_EXTERNAL_CHECKKEYBOARD               0x420231
#define DISPID_EXTERNAL_CHECKMOUSE                  0x420232
#define DISPID_EXTERNAL_GETAPPLCID                  0x420233
#define DISPID_EXTERNAL_GETISPLIST                  0x420234
#define DISPID_EXTERNAL_SETSELECTISP                0x420235
#define DISPID_EXTERNAL_WALK                        0x420236
#define DISPID_EXTERNAL_GETPAGETYPE                 0x420237
#define DISPID_EXTERNAL_GETPAGEFLAG                 0x420238
#define DISPID_EXTERNAL_GETPAGEID                   0x420239
// #define DISPID_EXTERNAL_UNUSED                      0x42023A
// #define DISPID_EXTERNAL_UNUSED                      0x42023B
// #define DISPID_EXTERNAL_UNUSED                      0x42023c
// #define DISPID_EXTERNAL_UNUSED                      0x42023D
// #define DISPID_EXTERNAL_UNUSED                      0x42023E
// #define DISPID_EXTERNAL_UNUSED                      0x42023F
#define DISPID_EXTERNAL_GETURL                      0x420240
#define DISPID_EXTERNAL_MIGRATEGONEXT               0x420241
#define DISPID_EXTERNAL_MIGRATEGOBACK               0x420242
#define DISPID_EXTERNAL_GETISPNAME                  0x420243
#define DISPID_EXTERNAL_SAVEISPFILE                 0x420244
#define DISPID_EXTERNAL_CHECKONLINESTATUS           0x420245
#define DISPID_EXTERNAL_GETREGSTATUS                0x420246
#define DISPID_EXTERNAL_CHECKSTAYCONNECTED          0x420247
#define DISPID_EXTERNAL_DIALEX                      0x420248
#define DISPID_EXTERNAL_REDIALEX                    0x420249
// #define DISPID_EXTERNAL_UNUSED                      0x42024A
// #define DISPID_EXTERNAL_UNUSED                      0x42024B
// #define DISPID_EXTERNAL_UNUSED                      0x42024c
// #define DISPID_EXTERNAL_UNUSED                      0x42024D
// #define DISPID_EXTERNAL_UNUSED                      0x42024E
// #define DISPID_EXTERNAL_UNUSED                      0x42024F
#define DISPID_EXTERNAL_CONNECTEX                   0x420250
#define DISPID_EXTERNAL_RECONNECTEX                 0x420251
#define DISPID_EXTERNAL_POSTREGDATA                 0x420252
#define DISPID_EXTERNAL_STOP_REMIND                 0x420253
#define DISPID_EXTERNAL_DELETE_REMIND               0x420254
#define DISPID_EXTERNAL_GETOEMEULATEXT              0x420255
#define DISPID_EXTERNAL_GETOEMEULA                  0x420256
#define DISPID_EXTERNAL_ISICSAVAILABLE              0x420257
#define DISPID_EXTERNAL_ISICSUSED                   0x420258
#define DISPID_EXTERNAL_GETSUPPHONENUM              0x420259
#define DISPID_EXTERNAL_GETPHBKNUMBER               0x42025A
#define DISPID_EXTERNAL_TRIGGERICSCALLBACK          0x42025B
#define DISPID_EXTERNAL_ISICSHOSTREACHABLE          0x42025C
#define DISPID_EXTERNAL_NOWELCOMEFINISH             0x42025D
#define DISPID_EXTERNAL_NOISPPRECONFIG              0x42025E
#define DISPID_EXTERNAL_NOEULA                      0x42025F
#define DISPID_EXTERNAL_SHOWOOBEWIN                 0x420260
#define DISPID_EXTERNAL_PROCESSEVENTS               0x420261
#define DISPID_EXTERNAL_DEBUG                       0x420262
#define DISPID_EXTERNAL_GETLOCALUSERCOUNT           0x420263
#define DISPID_EXTERNAL_CREATEMODEMCONNECTOID       0x420264
#define DISPID_EXTERNAL_ISSETUPUPGRADE              0x420265
#define DISPID_EXTERNAL_COMPUTERNAMECHANGECOMPLETE  0x420266
#define DISPID_EXTERNAL_GET_RETAILOOBE              0x420267
#define DISPID_EXTERNAL_ISPROFESSIONALSKU           0x420268
#define DISPID_EXTERNAL_JOINDOMAIN                  0x420269
// #define DISPID_EXTERNAL_UNUSED                      0x42026A
// #define DISPID_EXTERNAL_UNUSED                      0x42026B
// #define DISPID_EXTERNAL_UNUSED                      0x42026C
// #define DISPID_EXTERNAL_UNUSED                      0x42026D
// #define DISPID_EXTERNAL_UNUSED                      0x42026E
// #define DISPID_EXTERNAL_UNUSED                      0x42026F
#define DISPID_EXTERNAL_ISSELECTVARIATION           0x420270
#define DISPID_EXTERNAL_SETADMINPASSWORD            0x420271
#define DISPID_EXTERNAL_GETCONNECTIONCAPABILITIES   0x420272
#define DISPID_EXTERNAL_GETPREFERREDCONNECTION      0x420273
#define DISPID_EXTERNAL_SETPREFERREDCONNECTION      0x420274
#define DISPID_EXTERNAL_CONNECTEDTOINTERNET         0x420275
#define DISPID_EXTERNAL_NEEDACTIVATION              0x420276
#define DISPID_EXTERNAL_ACTIVATE                    0x420277
#define DISPID_EXTERNAL_GETINSTALLATIONID           0x420278
#define DISPID_EXTERNAL_CREATEPPPOECONNECTOID       0x420279
#define DISPID_EXTERNAL_SETPREFERREDCONNECTIONTCPIPPROPERTIES 0x42027A
#define DISPID_EXTERNAL_SETCONFIRMATIONID           0x42027B
#define DISPID_EXTERNAL_INTERNETAUTODIAL            0x42027C
#define DISPID_EXTERNAL_GETACTIVATIONDAYSLEFT       0x42027D
#define DISPID_EXTERNAL_GETNETJOINSTATUS            0x42027E
#define DISPID_EXTERNAL_INHIGHCONTRASTMODE          0x42027F
#define DISPID_EXTERNAL_SETDIALALTERNATIVE          0x420280
#define DISPID_EXTERNAL_CONNECTEDTOINTERNETEX       0x420281
#define DISPID_EXTERNAL_ASYNCCONNECTEDTOINTERNETEX  0x420282
#define DISPID_EXTERNAL_ISUPGRADE                   0x420283
#define DISPID_EXTERNAL_FIREWALLPREFERREDCONNECTION 0x420284
#define DISPID_EXTERNAL_COMPUTERNAMEDIFFERENT       0x420285
#define DISPID_EXTERNAL_GETDEFAULTACCOUNT           0x420286
#define DISPID_EXTERNAL_GETOOBEMUIPATH              0x420287
#define DISPID_EXTERNAL_OEMPASSWORD                 0x420288
#define DISPID_EXTERNAL_INTERNETAUTODIALHANGUP      0x420289
#define DISPID_EXTERNAL_VERIFYCHECKDIGITS           0x42028A
#define DISPID_EXTERNAL_ISOEMSKU                    0x42028B
#define DISPID_EXTERNAL_GETPROXYSETTINGS            0x42028C
#define DISPID_EXTERNAL_SETPROXYSETTINGS            0x42028D
#define DISPID_EXTERNAL_PLAYBACKGROUNDMUSIC         0x42028E
#define DISPID_EXTERNAL_CALLED_FROM_MSN             0x42028F
#define DISPID_EXTERNAL_USEFADEEFFECT               0x420290
#define DISPID_EXTERNAL_SETICWCOMPLETED             0x420291
#define DISPID_EXTERNAL_HASTABLET                   0x420294
#define DISPID_EXTERNAL_GETPUBLICLANCOUNT           0x420295
#define DISPID_EXTERNAL_ASYNCGETPUBLICLANCOUNT      0x420296
#define DISPID_EXTERNAL_GNSAUTODIAL                 0x420297

//window.external.UserInfo
#define DISPID_USERINFO_GET_FIRSTNAME               0x420300
#define DISPID_USERINFO_SET_FIRSTNAME               0x420301
#define DISPID_USERINFO_GET_MIDDLEINITIAL           0x420302
#define DISPID_USERINFO_SET_MIDDLEINITIAL           0x420303
#define DISPID_USERINFO_GET_LASTNAME                0x420304
#define DISPID_USERINFO_SET_LASTNAME                0x420305
#define DISPID_USERINFO_GET_COMPANYNAME             0x420306
#define DISPID_USERINFO_SET_COMPANYNAME             0x420307
#define DISPID_USERINFO_GET_ADDRESS1                0x420308
#define DISPID_USERINFO_SET_ADDRESS1                0x420309
#define DISPID_USERINFO_GET_CITY                    0x42030A
#define DISPID_USERINFO_SET_CITY                    0x42030B
#define DISPID_USERINFO_GET_STATE                   0x42030C
#define DISPID_USERINFO_SET_STATE                   0x42030D
#define DISPID_USERINFO_GET_ZIP                     0x42030E
#define DISPID_USERINFO_SET_ZIP                     0x42030F
#define DISPID_USERINFO_GET_PRIMARYEMAIL            0x420310
#define DISPID_USERINFO_SET_PRIMARYEMAIL            0x420311
#define DISPID_USERINFO_GET_SECONDARYEMAIL          0x420312
#define DISPID_USERINFO_SET_SECONDARYEMAIL          0x420313
#define DISPID_USERINFO_GET_AREACODE                0x420314
#define DISPID_USERINFO_SET_AREACODE                0x420315
#define DISPID_USERINFO_GET_PHONENUMBER             0x420318
#define DISPID_USERINFO_SET_PHONENUMBER             0x420319
#define DISPID_USERINFO_GET_FURIGANANAME            0x42031A
#define DISPID_USERINFO_SET_FURIGANANAME            0x42031B
#define DISPID_USERINFO_GET_ADDRESS2                0x42031C
#define DISPID_USERINFO_SET_ADDRESS2                0x42031D
#define DISPID_USERINFO_GET_COUNTRY                 0x42031E
#define DISPID_USERINFO_SET_COUNTRY                 0x42031F
#define DISPID_USERINFO_GET_IDENTITY                0x420320
#define DISPID_USERINFO_SET_IDENTITY                0x420321
#define DISPID_USERINFO_GET_IDENTITIESMAX           0x420322
#define DISPID_USERINFO_CHECK_IDENTITY              0x420323
#define DISPID_USERINFO_SUGGESTIDENTITY0            0x420324
#define DISPID_USERINFO_GET_USEIDENTITIES           0x420325
#define DISPID_USERINFO_SET_USEIDENTITIES           0x420326
#define DISPID_USERINFO_GET_OEMIDENTITIES           0x420327
#define DISPID_USERINFO_SET_OWNERNAME               0x420328
#define DISPID_USERINFO_GET_OWNERNAME               0x420329
#define DISPID_USERINFO_GET_MSUPDATE                0x42032A
#define DISPID_USERINFO_SET_MSUPDATE                0x42032B
#define DISPID_USERINFO_GET_MSOFFER                 0x42032C
#define DISPID_USERINFO_SET_MSOFFER                 0x42032D
#define DISPID_USERINFO_GET_OTHEROFFER              0x42032E
#define DISPID_USERINFO_SET_OTHEROFFER              0x42032F
#define DISPID_USERINFO_GET_COUNTRYID               0x420330
#define DISPID_USERINFO_SET_COUNTRYID               0x420331
#define DISPID_USERINFO_GET_DEFAULTNEWUSER          0x420332

//window.external.Tapi
#define DISPID_TAPI_INITTAPI                        0x420401
#define DISPID_TAPI_GETCOUNTRYINDEX                 0x420402
#define DISPID_TAPI_SETCOUNTRYINDEX                 0x420403
#define DISPID_TAPI_GETNUMOFCOUNTRY                 0x420404
#define DISPID_TAPI_GETCOUNTRYNAME                  0x420405
#define DISPID_TAPI_GETAREACODE                     0x420406
#define DISPID_TAPI_SETAREACODE                     0x420407
#define DISPID_TAPI_GETDIALOUT                      0x420408
#define DISPID_TAPI_SETDIALOUT                      0x420409
#define DISPID_TAPI_GETPHONESYS                     0x42040A
#define DISPID_TAPI_SETPHONESYS                     0x42040B
#define DISPID_TAPI_GETCALLWAITING                  0x42040C
#define DISPID_TAPI_SETCALLWAITING                  0x42040D
#define DISPID_TAPI_GETALLCNTRYNAME                 0x42040E
#define DISPID_TAPI_ISACODEREQUIRED                 0x42040F
#define DISPID_TAPI_GETCOUNTRYID                    0x420410
#define DISPID_TAPI_TAPISERVICERUNNING              0x420411

//window.external.ProductID
#define DISPID_PRODUCTID_GET_PID                    0x420500
#define DISPID_PRODUCTID_SET_PID                    0x420501
#define DISPID_PRODUCTID_VALIDATEPID                0x420502
#define DISPID_PRODUCTID_GET_ACCEPTED               0x420503
#define DISPID_PRODUCTID_GET_CURRENT_PID2           0x420504

//window.external.Signup
#define DISPID_SIGNUP_GET_LOCALE                    0x420600
#define DISPID_SIGNUP_GET_IDLOCALE                  0x420601
#define DISPID_SIGNUP_GET_TEXT1                     0x420602
#define DISPID_SIGNUP_GET_TEXT2                     0x420603
#define DISPID_SIGNUP_GET_OEMNAME                   0x420604
#define DISPID_SIGNUP_GET_OEMCODE                   0x420605

//window.external.Language
#define DISPID_GETNUMOFREGIONS                      0x420700
#define DISPID_GETREGIONNAME                        0x420701
#define DISPID_GETREGIONINDEX                       0x420702
#define DISPID_SETREGIONINDEX                       0x420703
#define DISPID_GETNUMOFKEYLAYOUTS                   0x420704
#define DISPID_GETKEYNAME                           0x420705
#define DISPID_GETKEYLAYOUTINDEX                    0x420706
#define DISPID_SETKEYLAYOUTINDEX                    0x420707
#define DISPID_LANGUAGE_GETREBOOTSTATE              0x420708
#define DISPID_LANGUAGE_SAVESETTINGS                0x420709
#define DISPID_GETNUMOFLANGS                        0x42070A
#define DISPID_GETLANGNAME                          0x42070B
#define DISPID_GETLANGINDEX                         0x42070C
#define DISPID_SETLANGINDEX                         0x42070D
#define DISPID_GETPHONECOUNTRIES                    0x42070E

//window.external.Eula
#define DISPID_EULA_GET_ACCEPTED                    0x420800
#define DISPID_EULA_SET_ACCEPTED                    0x420801
#define DISPID_EULA_VALIDATEEULA                    0x420802

//window.external.SystemClock
#define DISPID_SYSTEMCLOCK_SETTIMEZONE              0x420900
#define DISPID_SYSTEMCLOCK_SETTIME                  0x420901
#define DISPID_SYSTEMCLOCK_SETDATE                  0x420902
#define DISPID_SYSTEMCLOCK_GETTIMEZONE              0x420903
#define DISPID_SYSTEMCLOCK_GETALLTIMEZONES          0x420904
#define DISPID_SYSTEMCLOCK_GETTIMEZONEIDX           0x420905
#define DISPID_SYSTEMCLOCK_SETTIMEZONEIDX           0x420906
#define DISPID_SYSTEMCLOCK_INIT                     0x420907
#define DISPID_SYSTEMCLOCK_SETAUTODAYLIGHT          0x420908
#define DISPID_SYSTEMCLOCK_GETAUTODAYLIGHT          0x420909
#define DISPID_SYSTEMCLOCK_GETTIMEZONEWASPRESET     0x42090A
#define DISPID_SYSTEMCLOCK_GETDAYLIGHT_ENABLED      0x42090B

//window.external.Status
#define DISPID_STATUS_GET_PID_COMPLETED             0x421000
#define DISPID_STATUS_SET_PID_COMPLETED             0x421001
#define DISPID_STATUS_GET_TAPI_COMPLETED            0x421002
#define DISPID_STATUS_SET_TAPI_COMPLETED            0x421003
#define DISPID_STATUS_GET_LANGUAGE_COMPLETED        0x421004
#define DISPID_STATUS_SET_LANGUAGE_COMPLETED        0x421005
#define DISPID_STATUS_GET_EULA_COMPLETED            0x421006
#define DISPID_STATUS_SET_EULA_COMPLETED            0x421007
#define DISPID_STATUS_GET_MOUSETUTOR_COMPLETED      0x421008
#define DISPID_STATUS_SET_MOUSETUTOR_COMPLETED      0x421009
#define DISPID_STATUS_GET_USERINFO_POSTED           0x42100A
#define DISPID_STATUS_SET_USERINFO_POSTED           0x42100B
#define DISPID_STATUS_GET_USERINFO_STAMPED          0x42100C
#define DISPID_STATUS_SET_USERINFO_STAMPED          0x42100D
#define DISPID_STATUS_GET_OEMINFO_COMPLETED         0x42100E
#define DISPID_STATUS_SET_OEMINFO_COMPLETED         0x42100F
#define DISPID_STATUS_GET_ISPSIGNUP_COMPLETED       0x421010
#define DISPID_STATUS_SET_ISPSIGNUP_COMPLETED       0x421011
#define DISPID_STATUS_GET_SIGNATURE_COMPLETED       0x421012
#define DISPID_STATUS_SET_SIGNATURE_COMPLETED       0x421013
#define DISPID_STATUS_GET_TIMEZONE_COMPLETED        0x421014
#define DISPID_STATUS_SET_TIMEZONE_COMPLETED        0x421015
#define DISPID_STATUS_GET_STATUS                    0x421016
#define DISPID_STATUS_SET_STATUS                    0x421017

//window.external.Directions
#define DISPID_DIRECTIONS_GET_DOMOUSETUTORIAL       0x421100
#define DISPID_DIRECTIONS_GET_DOOEMREGISTRATION     0x421101
#define DISPID_DIRECTIONS_GET_DOREGIONALKEYBOARD    0x421102
#define DISPID_DIRECTIONS_GET_DOOEMHARDWARECHECK    0x421103
#define DISPID_DIRECTIONS_GET_DOBROWSENOW           0x421104
#define DISPID_DIRECTIONS_GET_ISPSIGNUP             0x421105
#define DISPID_DIRECTIONS_GET_OFFLINE               0x421106
#define DISPID_DIRECTIONS_GET_OFFERCODE             0x421107
#define DISPID_DIRECTIONS_GET_APPMODE               0x421108
#define DISPID_DIRECTIONS_GET_OEMCUST               0x421109
#define DISPID_DIRECTIONS_GET_DOOEMADDREGISTRATION  0x42110A
#define DISPID_DIRECTIONS_GET_DOTIMEZONE            0x42110B
#define DISPID_DIRECTIONS_GET_TIMEZONEVALUE         0x42110C
#define DISPID_DIRECTIONS_GET_DOIMETUTORIAL         0x42110D
#define DISPID_DIRECTIONS_GET_DOSKIPANIMATION       0x42110E
#define DISPID_DIRECTIONS_GET_DOWELCOMEFADEIN       0x42110F
#define DISPID_DIRECTIONS_GET_INTROONLY             0x421111
#define DISPID_DIRECTIONS_GET_AGENTDISABLED         0x421112
#define DISPID_DIRECTIONS_GET_SHOWISPMIGRATION      0x421113
#define DISPID_DIRECTIONS_GET_DOJOINDOMAIN          0x421114
#define DISPID_DIRECTIONS_GET_DOADMINPASSWORD       0x421115

//window.external.API
#define DISPID_API_SAVEFILE                         0x421200
#define DISPID_API_SAVEFILEBYCSIDL                  0x421201
#define DISPID_API_GET_INIKEY                       0x421202
#define DISPID_API_GET_REGVALUE                     0x421203
#define DISPID_API_SET_REGVALUE                     0x421204
#define DISPID_API_DELETEREGVALUE                   0x421205
#define DISPID_API_DELETEREGKEY                     0x421206
#define DISPID_API_GET_SYSTEMDIRECTORY              0x421207
#define DISPID_API_GET_CSIDLDIRECTORY               0x421208
#define DISPID_API_LOADFILE                         0x421209
#define DISPID_API_GET_USERDEFAULTLCID              0x42120A
#define DISPID_API_GET_COMPUTERNAME                 0x42120B
#define DISPID_API_SET_COMPUTERNAME                 0x42120C
#define DISPID_API_FLUSHREGKEY                      0x42120D
#define DISPID_API_VALIDATECOMPUTERNAME             0x42120E
#define DISPID_API_FORMATMESSAGE                    0x42120F
#define DISPID_API_OEMCOMPUTERNAME                  0x421210
#define DISPID_API_SET_COMPUTERDESC                 0x421211
#define DISPID_API_GET_USERDEFAULTUILANGUAGE        0x421212

//window.external.Register
#define DISPID_REGISTER_POSTTOMSN                    0x421300
#define DISPID_REGISTER_POSTTOOEM                    0x421301
#define DISPID_REGISTER_REGPOSTURL                   0x421302
#define DISPID_REGISTER_OEMADDREGPAGE                0x421303

//window.external.Debug
#define DISPID_DEBUG_TRACE                           0x421400
#define DISPID_DEBUG_ISMSDEBUGMODE                   0x421401
#define DISPID_DEBUG_ISOEMDEBUGMODE                  0x421402

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\inc\cfactory.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  CFACTORY.H - Header file for the Implementation of IClassFactory
//
//  HISTORY:
//  
//  1/27/99 a-jaswed Created.
// 
//  Base class for reusing a single class factory for all
//  components in a DLL.

#ifndef __CFactory_h__
#define __CFactory_h__

#include "cunknown.h"

///////////////////////////////////////////////////////////
// Forward reference.
//
class CFactoryData;

// Global data used by CFactory.
extern CFactoryData g_FactoryDataArray[];
extern int g_cFactoryDataEntries;

//////////////////////////////////////////////////////////////////////////////////////
//  Component creation function pointer.
//
typedef HRESULT (*FPCREATEINSTANCE)(IUnknown*, CUnknown**);

//////////////////////////////////////////////////////////////////////////////////////
// typedefs
//
// The special registration function is used to add custom registration and
// unregistration code to the component. It takes a single parameter.
// TRUE = Reg and FALSE = UnReg.
typedef void (*FPSPECIALREGISTRATION)(BOOL);

//////////////////////////////////////////////////////////////////////////////////////
// CFactoryData -
//
// Information CFactory needs to create a component supported
// by the DLL.

class CFactoryData
{
public:
    // The class ID for the component
    const CLSID* m_pCLSID;

    // Pointer to the function that creates it
    FPCREATEINSTANCE CreateInstance;

    // Name of the component to register in the registry
    const WCHAR* m_RegistryName;

    // ProgID
    const WCHAR* m_szProgID;

    // Version independent ProgID
    const WCHAR* m_szVerIndProgID;

    // Helper function for finding the class id
    BOOL IsClassID(const CLSID& clsid) const
        {return (*m_pCLSID == clsid) ;}

    // Function for performing special registration
    FPSPECIALREGISTRATION SpecialRegistration ;

    //----- Out of process server support -----
    
    // Pointer running class factory associated with this component.
    IClassFactory* m_pIClassFactory ;

    // Magic cookie to identify running object
    DWORD m_dwRegister ;
} ;


///////////////////////////////////////////////////////////
//
// Class Factory
//
class CFactory : public IClassFactory
{
public:
    // IUnknown
    virtual HRESULT __stdcall QueryInterface(   const IID& iid,
                                                void** ppv) ;
    virtual ULONG   __stdcall AddRef() ;
    virtual ULONG   __stdcall Release() ;
    
    // IClassFactory
    virtual HRESULT __stdcall CreateInstance(   IUnknown* pUnkOuter,
                                                const IID& iid,
                                                void** ppv) ;
    virtual HRESULT __stdcall LockServer(BOOL bLock); 

    // Constructor - Pass pointer to data of component to create.
    CFactory(const CFactoryData* pFactoryData) ;

    // Destructor
    ~CFactory() {/*empty*/ }

    // ----- static FactoryData support functions. -----

    // DllGetClassObject Support
    static HRESULT GetClassObject(  const CLSID& clsid, 
                                    const IID& iid, 
                                    void** ppv);
    
    // Helper function for DllCanUnloadNow 
    static BOOL IsLocked()
        { return (s_cServerLocks > 0) ; }

    // Functions to [Un]Register all components.
    static HRESULT RegisterAll();
    static HRESULT UnregisterAll();

    // Functions to determine if component can be unloaded.
    static HRESULT CanUnloadNow();


#ifdef _OUTPROC_SERVER_
    // ----- Out of process server support -----

    static BOOL StartFactories() ;
    static void StopFactories() ;

    static DWORD s_dwThreadID;

    // Shut down the application.
    static void CloseExe()
    {
        if (CanUnloadNow() == S_OK)
        {
            ::PostThreadMessage(s_dwThreadID, WM_QUIT, 0, 0);
        }
    }
#else
    // CloseExe doesn't do anything if we are in process.
    static void CloseExe() {/*Empty*/} 
#endif

public:
    // Reference Count
    LONG m_cRef;

    // Pointer to information about class this factory creates.
    const CFactoryData* m_pFactoryData;

    // Count of locks
    static LONG s_cServerLocks ;   

    // Module handle
    static HMODULE s_hModule ;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\inc\setupx32.h ===
/****************************************************************************\

    SETUPX32.H

    Microsoft Confidential
    Copyright (c) Microsoft Corporation 1999
    All rights reserved

\****************************************************************************/


#ifndef _SETUPX32_H_
#define _SETUPX32_H_

// BUGBUG: IS THIS FILE NECESSARY??

//
// Exporting (this gets rid of the .def)
//

#ifdef SETUPX32_EXPORT
#define DLLExportImport         __declspec(dllexport)
#else
#define DLLExportImport         __declspec(dllimport)
#endif

//
// Audit mode flags.
//

#define SX_AUDIT_NONE           0x00000000
#define SX_AUDIT_NONRESTORE     0x00000001
#define SX_AUDIT_RESTORE        0x00000002
#define SX_AUDIT_ENDUSER        0x00000003
#define SX_AUDIT_AUTO           0x00000100
#define SX_AUDIT_RESTORATIVE    0x00000200
#define SX_AUDIT_ALLOWMANUAL    0x00000400
#define SX_AUDIT_ALLOWENDUSER   0x00000800
#define SX_AUDIT_MODES          0x000000FF
#define SX_AUDIT_FLAGS          0x0000FF00
#define SX_AUDIT_INVALID        0xFFFFFFFF

#endif // _SETUPX32_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobcomm\atmcfg.h ===
//****************************************************************************
//
//  File:       atmcfg.h
//  Content:    This file contains the ATM device specific configuration
//
//  Copyright (c) 1997-1998, Microsoft Corporation, all rights reserved
//
//  History:
//      Thurs 5-28-98   BJohnson        Created
//
//****************************************************************************

#ifndef _ATMCFG_H_
#define _ATMCFG_H_
//
// #ifndef HKEY
// #define HKEY PVOID
// #endif
//
//
// ATM Configuration info
//

typedef struct tagATMCONFIG {
    ULONG   cbSize;                 /* size of structure */
    ULONG   cbTotalSize;            /* Total mem used by struct & var data */
    ULONG   ulFlags;                /* flags for the device */
    ULONG   ulCircuitFlags;         /* flags for the circuit */

    HKEY    hkeyDriver;             /* handle to driver registry key */
    ULONG   ulVendorOffset;         /* offset of vendor specific data in
                                       bytes from the start */
    ULONG   cbVendorSize;           /* size of the vendor specific data
                                       field */
    ULONG   ulReservedOffset;       /* offset of reserved data in bytes 
                                       from the start */
    ULONG   cbReservedSize;         /* size of the reserved data field */

    WCHAR   wcData[1];              /* variable data */
    } ATMCONFIG, FAR * LPATMCONFIG;


//
//  ATM Phone book data.  This data is stored on a per connection basis
//  and is the structure returned for get and set dev config.
//

typedef struct tagATMPBCONFIG {
    ULONG   ulGeneralOpt;           /* General options */
    ULONG   ulCircuitOpt;           /* Circuit options */
    ULONG	ulCircuitSpeed;         /* Circuit Speed */
    USHORT  usPvcVpi;               /* PVC: VPI */
    USHORT  usPvcVci;               /* PVC: VCI */
} ATMPBCONFIG, FAR * LPATMPBCONFIG;


//
// Flags for ATM Phone Book entry
//

//
// ATM General Options
//
#define ATM_GENERAL_OPT_VENDOR_CONFIG   0x00000001L
#define ATM_GENERAL_OPT_SHOW_STATUS     0x00000002L
#define ATM_GENERAL_OPT_ENABLE_LOG      0x00000004L

#define ATM_GENERAL_OPT_MASK            0x0000000FL
#define ATM_GENERAL_OPT_DEFAULT         0x00000000L


//
// ATM Circuit Options
//
#define ATM_CIRCUIT_OPT_QOS_ADJUST      0x00000010L
#define ATM_CIRCUIT_OPT_SPEED_ADJUST    0x00000020L
#define ATM_CIRCUIT_OPT_SVC             0x00000040L
#define ATM_CIRCUIT_OPT_PVC             0x00000080L

#define ATM_CIRCUIT_OPT_MASK            0x000000F0L
#define ATM_CIRCUIT_OPT_DEFAULT         (ATM_CIRCUIT_OPT_SVC | ATM_CIRCUIT_OPT_QOS_ADJUST | ATM_CIRCUIT_OPT_SPEED_ADJUST)


//
// ATM QOS Flags
//
#define ATM_CIRCUIT_QOS_VBR             0x00000100L
#define ATM_CIRCUIT_QOS_CBR             0x00000200L
#define ATM_CIRCUIT_QOS_ABR             0x00000400L
#define ATM_CIRCUIT_QOS_UBR             0x00000800L

#define ATM_CIRCUIT_QOS_MASK            0x00000F00L
#define ATM_CIRCUIT_QOS_DEFAULT         (ATM_CIRCUIT_QOS_UBR)

//
// ATM Speed Flags
//
#define ATM_CIRCUIT_SPEED_LINE_RATE     0x00001000L
#define ATM_CIRCUIT_SPEED_USER_SPEC     0x00002000L
#define ATM_CIRCUIT_SPEED_512KB         0x00004000L
#define ATM_CIRCUIT_SPEED_1536KB        0x00008000L
#define ATM_CIRCUIT_SPEED_25MB          0x00010000L
#define ATM_CIRCUIT_SPEED_155MB         0x00020000L

#define ATM_CIRCUIT_SPEED_MASK          0x000FF000L
#define ATM_CIRCUIT_SPEED_DEFAULT       (ATM_CIRCUIT_SPEED_LINE_RATE)

//
// ATM Encapsulation Flags
//
#define ATM_CIRCUIT_ENCAP_NULL          0x00100000L
#define ATM_CIRCUIT_ENCAP_LLC           0x00200000L

#define ATM_CIRCUIT_ENCAP_MASK          0x00F00000L
#define ATM_CIRCUIT_ENCAP_DEFAULT       (ATM_CIRCUIT_ENCAP_NULL)

#endif  //_ATMCFG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobcomm\ccsv.h ===
#ifndef _CCSV
#define _CCSV

#define CCSVFILE_BUFFER_SIZE 2*512

// simple file i/o for comma seperated files
class CCSVFile 
{
    
    public: 
        void far * operator new( size_t cb ) { return GlobalAlloc(GPTR, cb); };
        void operator delete( void far * p ) {GlobalFree(p); };

        CCSVFile();
        ~CCSVFile();
        BOOLEAN Open(LPCWSTR pszFileName);
        BOOLEAN ReadToken(LPWSTR pszDest, DWORD cbMax);  // reads up to comma or newline, returns fFalse on EOF
        BOOLEAN SkipTillEOL(void);  // reads up to EOL
        void Close(void);
        inline int ILastRead(void)
            {
            return m_iLastRead;
            }

    private:
        BOOL    FReadInBuffer(void);
        inline int  ChNext(void);
        CHAR    m_rgchBuf[CCSVFILE_BUFFER_SIZE]; //buffer
        WCHAR   m_rgwchBuf[CCSVFILE_BUFFER_SIZE];
        LPWSTR  m_pchBuf;           //pointer to the next item in the buffer to read
        LPWSTR  m_pchLast;          //pointer to the last item in the buffer
        int     m_iLastRead;        //the character last read.
        DWORD   m_cchAvail;
        HANDLE  m_hFile;

}; // ccsv
#endif //_CCSV
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\inc\util.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  UTIL.H - utilities
//
//  HISTORY:
//
//  1/27/99 a-jaswed Created.
//
// Common utilities for printing out messages

#ifndef _UTIL_H_
#define _UTIL_H_

#include <assert.h>
#include <tchar.h>
#include <windows.h>
#include <ole2.h>
#include <setupapi.h>
#include <syssetup.h>

//////////////////////////////////////////////////////////////////////////////
//
// System boot mode
//

// Constants for values returned by GetSystemMetrics(SM_CLEANBOOT)
//
#define BOOT_CLEAN              0
#define BOOT_SAFEMODE           1
#define BOOT_SAFEMODEWITHNET    2

BOOL InSafeMode();

// Displays a message box with an error string in it.
void ErrorMessage(LPCWSTR str, HRESULT hr) ;

// Determine if two interfaces below to the same component.
BOOL InterfacesAreOnSameComponent(IUnknown* pI1, IUnknown* pI2) ;
bool GetOOBEPath(LPWSTR szOOBEPath);
bool GetOOBEMUIPath(LPWSTR szOOBEPath);

// Displays messages using OutputDebugString
void __cdecl MyTrace(LPCWSTR lpszFormat, ...);

// Determine if an address is accessable.
BOOL IsValidAddress(const void* lp, UINT nBytes = 1, BOOL bReadWrite = FALSE) ;

bool GetCanonicalizedPath(LPWSTR szCompletePath, LPCWSTR szFileName);

bool GetString(HINSTANCE hInstance, UINT uiID, LPWSTR szString, UINT uiStringLen = MAX_PATH);
HRESULT GetINIKey(HINSTANCE hInstance, LPCWSTR szINIFileName, UINT uiSectionName, UINT uiKeyName, LPVARIANT pvResult);
HRESULT GetINIKeyBSTR(HINSTANCE hInstance, LPCWSTR szINIFileName, UINT uiSectionName, UINT uiKeyName, LPVARIANT pvResult);
HRESULT GetINIKeyUINT(HINSTANCE hInstance, LPCWSTR szINIFileName, UINT uiSectionName, UINT uiKeyName, LPVARIANT pvResult);
HRESULT SetINIKey(HINSTANCE hInstance, LPCWSTR szINIFileName, UINT uiSectionName, UINT uiKeyName, LPVARIANT pvResult);
void WINAPI URLEncode(WCHAR* pszUrl, size_t bsize);

void WINAPI URLAppendQueryPair
(
    LPWSTR   lpszQuery,
    LPWSTR   lpszName,
    LPWSTR   lpszValue
);
void GetCmdLineToken(LPWSTR *ppszCmd, LPWSTR pszOut);
VOID PumpMessageQueue( );
BOOL IsOEMDebugMode();
BOOL IsThreadActive(HANDLE hThread);
void GetDesktopDirectory(WCHAR* pszPath);
void RemoveDesktopShortCut(LPWSTR lpszShortcutName);
BOOL InvokeExternalApplication(
    IN     PCWSTR ApplicationName,  OPTIONAL
    IN     PCWSTR CommandLine,
    IN OUT PDWORD ExitCode          OPTIONAL
    );
BOOL SignalComputerNameChangeComplete();
BOOL IsUserAdmin(VOID);

typedef struct tagSTRINGLIST {
    struct tagSTRINGLIST* Next;
    PTSTR String;
} STRINGLIST, *PSTRINGLIST;

PSTRINGLIST
CreateStringCell(
    IN PCTSTR String
    );

VOID
DeleteStringCell(
    IN PSTRINGLIST Cell
    );

BOOL
InsertList(
    IN OUT PSTRINGLIST* List,
    IN     PSTRINGLIST NewList
    );

VOID
DestroyList(
    IN PSTRINGLIST List
    );

BOOL
RemoveListI(
    IN OUT  PSTRINGLIST* List,
    IN      PCTSTR       String
    );

BOOL
ExistInListI(
    IN PSTRINGLIST List,
    IN PCTSTR      String
    );

BOOL IsDriveNTFS(IN TCHAR Drive);

BOOL
HasTablet();

// Determine if interface pointer is accessable.
inline BOOL IsValidInterface(IUnknown* p)
{
    return (p != NULL) && IsValidAddress(p, sizeof(IUnknown*), FALSE) ;
}

// Determine if the out parameter for an interface pointer is accessable.
template <class T>
inline BOOL IsValidInterfaceOutParam(T** p)
{
    return (p != NULL) && IsValidAddress(p, sizeof(IUnknown*), TRUE) ;
}

inline VARIANT_BOOL Bool2VarBool(BOOL b)
{
    return (b) ? -1 : 0;
}

inline BOOL VarBool2Bool(VARIANT_BOOL b)
{
    return (0 == b) ? 0 : 1;
}


///////////////////////////////////////////////////////////
// Diagnostic support
//
#if defined(DBG) && !defined(ASSERTS_ON)
#define ASSERTS_ON  1
#endif

#if ASSERTS_ON
VOID
AssertFail(
    IN PSTR FileName,
    IN UINT LineNumber,
    IN PSTR Condition
    );

#define MYASSERT(x)     if(!(x)) { AssertFail(__FILE__,__LINE__,#x); }
#define VERIFY(x)       MYASSERT(x)
#else
#define MYASSERT(x)
#define VERIFY(f)           ((void)(f))
#endif

// Helper function for checking HRESULTs.
#ifdef DBG
inline void CheckResult(HRESULT hr)
{
    if (FAILED(hr))
    {
        ErrorMessage(NULL, hr) ;
        assert(FAILED(hr)) ;
    }
}

#define ASSERT_HRESULT      CheckResult
#else
#define ASSERT_HRESULT
#endif

///////////////////////////////////////////////////////////
//
// More Diagnostic support which mimics MFC
//
#ifndef __AFX_H__   // Only define these if MFC has not already been included

#define TRACE(_fmt_)                                            \
    pSetupDebugPrint(TEXT(__FILE__),__LINE__,NULL,_fmt_)
#define TRACE1(_fmt_,_arg1_)                                    \
    pSetupDebugPrint(TEXT(__FILE__),__LINE__,NULL,_fmt_,_arg1_)
#define TRACE2(_fmt_,_arg1_,_arg2_)                             \
    pSetupDebugPrint(TEXT(__FILE__),__LINE__,NULL,_fmt_,_arg1_,_arg2_)
#define TRACE3(_fmt_,_arg1_,_arg2_,_arg3_)                      \
    pSetupDebugPrint(TEXT(__FILE__),__LINE__,NULL,_fmt_,_arg1_,_arg2_,_arg3_)
#define TRACE4(_fmt_,_arg1_,_arg2_,_arg3_,_arg4_)               \
    pSetupDebugPrint(TEXT(__FILE__),__LINE__,NULL,_fmt_,_arg1_,_arg2_,_arg3_,_arg4_)
#define TRACE5(_fmt_,_arg1_,_arg2_,_arg3_,_arg4_,_arg5_)        \
    pSetupDebugPrint(TEXT(__FILE__),__LINE__,NULL,_fmt_,_arg1_,_arg2_,_arg3_,_arg4_,_arg5_)
#define TRACE6(_fmt_,_arg1_,_arg2_,_arg3_,_arg4_,_arg5_,_arg6_) \
    pSetupDebugPrint(TEXT(__FILE__),__LINE__,NULL,_fmt_,_arg1_,_arg2_,_arg3_,_arg4_,_arg5_,_arg6_)

#define ASSERT_POINTER(p, type) \
    MYASSERT(((p) != NULL) && IsValidAddress((p), sizeof(type), FALSE))

#define ASSERT_NULL_OR_POINTER(p, type) \
    MYASSERT(((p) == NULL) || IsValidAddress((p), sizeof(type), FALSE))

#endif // TRACE

//////////////////////////////////////////////////////////////////////////////
//
//  macro for QueryInterface and related functions
//  that require a IID and a (void **)
//  this will insure that the cast is safe and appropriate on C++
//
//  IID_PPV_ARG(IType, ppType)
//      IType is the type of pType
//      ppType is the variable of type IType that will be filled
//
//      RESULTS in:  IID_IType, ppvType
//      will create a compiler error if wrong level of indirection is used.
//
//      Just like IID_PPV_ARG, except that it sticks a NULL between the
//      IID and PPV (for IShellFolder::GetUIObjectOf).
//
//  IID_PPV_ARG_NULL(IType, ppType)
//

#ifdef __cplusplus
#define IID_PPV_ARG(IType, ppType) IID_##IType, reinterpret_cast<void**>(static_cast<IType**>(ppType))
#define IID_X_PPV_ARG(IType, X, ppType) IID_##IType, X, reinterpret_cast<void**>(static_cast<IType**>(ppType))
#else
#define IID_PPV_ARG(IType, ppType) &IID_##IType, (void**)(ppType)
#define IID_X_PPV_ARG(IType, X, ppType) &IID_##IType, X, (void**)(ppType)
#endif
#define IID_PPV_ARG_NULL(IType, ppType) IID_X_PPV_ARG(IType, NULL, ppType)

//////////////////////////////////////////////////////////////////////////////
//
//  Types of actions OOBE requires after shutdown.  The type and amount of
//  cleanup done by OOBE on exit are dependent on these.  This includes
//  notifying WinLogon of the necessity of reboot, deleting persistent data,
//  and setting the keys in HKLM\System\Setup.
//
typedef enum _OOBE_SHUTDOWN_ACTION
{
    SHUTDOWN_NOACTION,
    SHUTDOWN_LOGON,
    SHUTDOWN_REBOOT,
    SHUTDOWN_POWERDOWN,
    SHUTDOWN_MAX        // this entry must always be last
} OOBE_SHUTDOWN_ACTION;


#endif // _UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\inc\registry.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1999                    **
//*********************************************************************
//
//  REGISTRY.H - Header for implementation of functions to register components.
//
//  HISTORY:
//  
//  1/27/99 a-jaswed Created.
//
// functions to register components.

#ifndef __Registry_H__
#define __Registry_H__

////////////////////////////////////////////////////////
// Constants
////////////////////////////////////////////////////////

// Size of a CLSID as a string
const int CLSID_STRING_SIZE = 39 ;

////////////////////////////////////////////////////////
// Function Prototypes
////////////////////////////////////////////////////////

// This function will register a component in the Registry.
// The component calls this function from its DllRegisterServer function.
HRESULT RegisterServer( HMODULE hModule, 
                        const CLSID& clsid, 
                        const WCHAR*  szFriendlyName,
                        const WCHAR*  szVerIndProgID,
                        const WCHAR*  szProgID);

// This function will unregister a component. Components
// call this function from their DllUnregisterServer function.
HRESULT UnregisterServer(   const CLSID& clsid,
                            const WCHAR* szVerIndProgID,
                            const WCHAR* szProgID);

// Converts a CLSID into a char string.
void CLSIDtochar(   const CLSID& clsid, 
                    WCHAR* szCLSID,
                    int length) ;

BOOL setKeyAndValue(const WCHAR* szKey, 
                    const WCHAR* szSubkey, 
                    const WCHAR* szValue,
                    const WCHAR* szName);

CONST UINT GETKEYANDVALUEBUFFSIZE = 1024;

// value must be at least 1024 in size;
BOOL getKeyAndValue(const WCHAR* szKey, 
                    const WCHAR* szSubkey, 
                    const WCHAR* szValue,
                    const WCHAR* szName);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobcomm\ccsv.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

// ############################################################################
// INCLUDES
#include "appdefs.h"
#include "ccsv.h"

// ############################################################################
// DEFINES
#define chComma L','
#define chNewline L'\n'
#define chReturn L'\r'

// ############################################################################
//
// CCSVFile - simple file i/o for CSV files
//
CCSVFile::CCSVFile()
{
    m_hFile = 0;
    m_iLastRead = 0;
    m_pchLast = m_pchBuf = NULL;
}

// ############################################################################
CCSVFile::~CCSVFile()
{
    if(m_hFile)
        CloseHandle(m_hFile);

    //AssertMsg(!m_hFile, L"CCSV file is still open");
}

// ############################################################################
BOOLEAN CCSVFile::Open(LPCWSTR pszFileName)
{
    //AssertMsg(!m_hFile, L"a file is already open.");
        
    m_hFile = CreateFile((LPCWSTR)pszFileName, 
                            GENERIC_READ, FILE_SHARE_READ, 
                            0, OPEN_EXISTING, 0, 0);
    if (INVALID_HANDLE_VALUE == m_hFile)
    {
        return FALSE;
    }
    m_pchLast = m_pchBuf = NULL;
    return TRUE;
}

// ############################################################################
BOOLEAN CCSVFile::ReadToken(LPWSTR psz, DWORD cchMax)
{
    LPWSTR    pszLast;
    int      ch;

    ch = ChNext();
    if (-1 == ch)
    {
        return FALSE;
    }

    pszLast = psz + (cchMax - 1);
    while ( psz < pszLast &&
            chComma != ch &&
            chNewline != ch &&
            chReturn != ch &&
            -1 != ch)
    {
        *psz++ = (WCHAR)ch;
        ch = ChNext(); //Read in the next WCHARacter
    }

    *psz++ = L'\0';

    return TRUE;
}

// ############################################################################
BOOLEAN CCSVFile::SkipTillEOL()
{
    int ch = ChNext();
    if (-1 == ch)
    {
        return FALSE;
    }

    while ( chNewline != ch &&
            -1 != ch)
    {
        ch = ChNext(); //Read in the next character
    }
    return TRUE;
}

// ############################################################################
void CCSVFile::Close(void)
{
    if (m_hFile)
        CloseHandle(m_hFile);

    m_hFile = 0;
}

// ############################################################################
BOOL CCSVFile::FReadInBuffer(void)
{
    //Read another buffer
    if (!ReadFile(m_hFile, m_rgchBuf, CCSVFILE_BUFFER_SIZE, &m_cchAvail, NULL) || !m_cchAvail)
        return FALSE;     //nothing more to read

    // Convert ANSI to UNICODE
    MultiByteToWideChar(CP_ACP, 0, m_rgchBuf, m_cchAvail, m_rgwchBuf, m_cchAvail);

    m_pchBuf = m_rgwchBuf;
    m_pchLast = m_pchBuf + m_cchAvail;
    
    return TRUE; //success
}

// ############################################################################
inline int CCSVFile::ChNext(void)
{
    if (m_pchBuf >= m_pchLast && !FReadInBuffer())  //implies that we finished reading the buffer. Read in some more.
        return -1;     //nothing more to read

    m_iLastRead = *m_pchBuf++;
    return m_iLastRead;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobcomm\cntpoint.cpp ===
///////////////////////////////////////////////////////////
//
// CConnectionPoint 
// 
// Defines the connection point object used by CTangramModel.
//
//
#include <windows.h>
#include <olectl.h>
#include <assert.h>

#include "CntPoint.h"
//#include "EnumCon.h"

///////////////////////////////////////////////////////////
//
// Construction
CConnectionPoint::CConnectionPoint(IConnectionPointContainer* pIConnectionPointContainer, const IID* piid)
:	m_dwNextCookie(0)
{
	assert(piid != NULL) ;
	assert(pIConnectionPointContainer != NULL) ;

	m_pIConnectionPointContainer = pIConnectionPointContainer ; // AddRef is not needed.
	m_piid = piid ;
}

///////////////////////////////////////////////////////////
//
// Destruction
CConnectionPoint::~CConnectionPoint()
{
	// The array should be empty before this is called.
}

///////////////////////////////////////////////////////////
//
//			Interface IUnknown Methods
//
///////////////////////////////////////////////////////////
//
// QueryInterface
//
HRESULT __stdcall 
CConnectionPoint::QueryInterface(const IID& iid, void** ppv)
{
	if ((iid == IID_IUnknown) ||(iid == IID_IConnectionPoint))
	{
		*ppv = static_cast<IConnectionPoint*>(this) ; 
	}
	else
	{
		*ppv = NULL;
		return E_NOINTERFACE;
	}
	(reinterpret_cast<IUnknown*>(*ppv))->AddRef() ;
	return S_OK ;
}

///////////////////////////////////////////////////////////
//
// AddRef
//
ULONG __stdcall CConnectionPoint::AddRef() 
{
	// Delegate AddRefss
	return m_pIConnectionPointContainer->AddRef() ;
}

///////////////////////////////////////////////////////////
//
// Release
//
ULONG __stdcall CConnectionPoint::Release() 
{
	// Delegate Releases
	return m_pIConnectionPointContainer->Release() ;
}

///////////////////////////////////////////////////////////
//
//			Interface IConnectionPoint Methods
//
///////////////////////////////////////////////////////////
//
// GetConnectionInterface
//
HRESULT __stdcall 
CConnectionPoint::GetConnectionInterface(IID* piid)
{
	assert( m_piid != NULL);

	if (piid == NULL)
	{
		return E_POINTER ;
	}

	// Cast away Cast away Cast away Const!
	*piid = *(const_cast<IID*>(m_piid)) ;
	return S_OK ;
}

///////////////////////////////////////////////////////////
//
// GetConnectionPointContainer
//
HRESULT __stdcall 
CConnectionPoint::GetConnectionPointContainer(IConnectionPointContainer** ppIConnectionPointContainer)
{
	assert( m_pIConnectionPointContainer != NULL);

	if (ppIConnectionPointContainer == NULL)
	{
		return E_POINTER ;
	}

	*ppIConnectionPointContainer = m_pIConnectionPointContainer ;
	m_pIConnectionPointContainer->AddRef() ;
	return S_OK ;
}
///////////////////////////////////////////////////////////
//
// Advise
//
HRESULT __stdcall 
CConnectionPoint::Advise(IUnknown* pIUnknownSink, DWORD* pdwCookie )
{
	if (pIUnknownSink == NULL || pdwCookie == NULL)
	{
		*pdwCookie = 0;
		return E_POINTER;
	}

	IUnknown* pI = NULL ;
	HRESULT hr = pIUnknownSink->QueryInterface(*m_piid, (void**)&pI) ;
	if (SUCCEEDED(hr))
	{		
		m_Cd.dwCookie = ++m_dwNextCookie ;
		m_Cd.pUnk = pI ;
        if (pI)
            pI->Release();

		// Return cookie
		*pdwCookie = m_Cd.dwCookie ;
		return S_OK ;
	}
	else
	{
		return CONNECT_E_CANNOTCONNECT ;
	}
}
///////////////////////////////////////////////////////////
//
// Unadvise
//
HRESULT __stdcall 
CConnectionPoint::Unadvise(DWORD dwCookie)
{
	if (m_Cd.dwCookie == dwCookie)
	{
		// Found sink point.
		IUnknown* pSink = m_Cd.pUnk;

        // Release the interface pointer.
		pSink->Release() ;

		return S_OK ;
	}
	return CONNECT_E_NOCONNECTION;;
}

///////////////////////////////////////////////////////////
//
// EnumConnections
//
HRESULT __stdcall 
CConnectionPoint::EnumConnections(IEnumConnections** ppIEnum)
{
	//if (ppIEnum == NULL)
	{
	//	return E_POINTER ;
	}

	// Construct the enumerator object.
	//IEnumConnections* pIEnum = new CEnumConnections(m_SinkList) ;
	// The contructor AddRefs for us.
	//*ppIEnum = pIEnum ;
	return S_OK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobcomm\cntpoint.h ===
#ifndef __CConnectionPoint_h__ 
#define __CConnectionPoint_h__ 
///////////////////////////////////////////////////////////
//
// CntPoint.h - CTangramModelConnectionPoint 
// 
// Defines the connection point object used by CTangramModel.
//
#include <ocidl.h> //For IConnectionPoint
//#include "ConData.h"

///////////////////////////////////////////////////////////
//
// CConnectionPoint
//
class CConnectionPoint : public IConnectionPoint 
{
public:
	// IUnknown
	virtual HRESULT __stdcall QueryInterface(const IID& iid, void** ppv) ;			
	virtual ULONG   __stdcall AddRef() ;
	virtual ULONG   __stdcall Release() ;
	
	// Interface IConnectionPoint methods.
	virtual HRESULT __stdcall GetConnectionInterface(IID*);
	virtual HRESULT __stdcall GetConnectionPointContainer(IConnectionPointContainer**);
	virtual HRESULT __stdcall Advise(IUnknown*, DWORD*);
	virtual HRESULT __stdcall Unadvise(DWORD);
	virtual HRESULT __stdcall EnumConnections(IEnumConnections**);

	// Construction
	CConnectionPoint(IConnectionPointContainer*, const IID*) ;

	// Destruction
	~CConnectionPoint() ;

// Member variables
public:
	
	// Interface ID of the outgoing interface supported by this connection point.
	const IID* m_piid ;

	// Point to the ConnectionPointerContainer
	IConnectionPointContainer* m_pIConnectionPointContainer ;

	// Cookie Incrementor
	DWORD m_dwNextCookie ;

	// Reference Count
	// Not required --- delegated to container long m_cRef;	   

	// STL List which holds points to the interfaces to call
	CONNECTDATA m_Cd;
};

#endif //__CConnectionPoint_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobcomm\connmgr.h ===
#ifndef     _CONNMGR_H_
#define _CONNMGR_H_

//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module: ConnMgr.h
//
//  Author: Dan Elliott
//
//  Abstract:
//
//  Environment:
//      Whistler
//
//  Revision History:
//
//////////////////////////////////////////////////////////////////////////////

#include <obcomm.h>
#include <util.h>
#include <netcon.h>
#include <netcfgp.h>

#define NUM_PROXY_OPTIONS 6


class CObCommunicationManager;

//////////////////////////////////////////////////////////////////////////////
//
// CConnectionManager
//
class CConnectionManager 
{
public:                 // operations
    CConnectionManager();
    ~CConnectionManager( );

    STDMETHOD(GetCapabilities)(
        DWORD*          pdwCapabilities
        );

    STDMETHOD(SetPreferredConnection)(
        const DWORD     dwType,
        BOOL*           pfSupportedType
        );

    STDMETHOD(GetPreferredConnection)(
        DWORD*          pdwPreferred
        )
    {
        if (NULL == pdwPreferred)  
        {
            MYASSERT(NULL != pdwPreferred);
            return E_POINTER;
        }
        *pdwPreferred = m_dwPreferredConnection;
        return S_OK;
    }

    HRESULT
    CConnectionManager::GetPreferredConnectionName(
        LPWSTR              szConnectionName,
        DWORD               cchConnectionName
        );

    STDMETHOD(ConnectedToInternet)(
        BOOL*               pfConnected
        );

    STDMETHOD(ConnectedToInternetEx)(
        BOOL*               pfConnected
        );
    
    STDMETHOD(AsyncConnectedToInternetEx)(
        const HWND          hwnd
        );
    
    STDMETHOD(GetConnectionCount)(
        DWORD*              pcConnections
        )
    {

        if (NULL == pcConnections) 
        {
            MYASSERT(NULL != pcConnections);
            return E_POINTER;
        }

        // Currently phone connections are supported via CEnumModems and RAS.
        // Until they are supported via this object only return count of LAN
        // connections.
        //
        *pcConnections = m_cLanConnections;
        return S_OK;
    }

    STDMETHOD(SetPreferredConnectionTcpipProperties)(
        BOOL fAutoIPAddress,
        DWORD StaticIp_A,
        DWORD StaticIp_B,
        DWORD StaticIp_C,
        DWORD StaticIp_D,
        DWORD SubnetMask_A,
        DWORD SubnetMask_B,
        DWORD SubnetMask_C,
        DWORD SubnetMask_D,
        DWORD DefGateway_A,
        DWORD DefGateway_B,
        DWORD DefGateway_C,
        DWORD DefGateway_D,
        BOOL fAutoDns,
        DWORD DnsPref_A,
        DWORD DnsPref_B,
        DWORD DnsPref_C,
        DWORD DnsPref_D,
        DWORD DnsAlt_A,
        DWORD DnsAlt_B,
        DWORD DnsAlt_C,
        DWORD DnsAlt_D
        );

    BOOL IsValid( ) const
    {
        return (CONNECTIONTYPE_INVALID != m_dwConnectionCapabilities);
    }   //  IsValid

    void UseWinntProxySettings();
    
    void DisableWinntProxySettings();

    STDMETHOD(GetProxySettings)(
        BOOL* pbUseAuto,
        BOOL* pbUseScript,
        BSTR* pszScriptUrl,
        BOOL* pbUseProxy,
        BSTR* pszProxy
        );
    
    STDMETHOD(SetProxySettings)(
        BOOL bUseAuto,
        BOOL bUseScript,
        BSTR szScriptUrl,
        BOOL bUseProxy,
        BSTR szProxy
        );
    
    STDMETHOD(GetPublicLanCount)(
        int* pcPublicLan
        );

    void SetExclude1394(
        BOOL bExclude
        )
    {
        m_bExclude1394 = bExclude;
    }

    HRESULT EnumPublicConnections(
        OUT PSTRINGLIST* pList
        );

protected:              // operations

protected:              // data

private:                // operations

    BOOL LanConnectionReady();

    HRESULT SetProxyBlanket(
        IUnknown*           pUnk
        );

    void DeterminePreferredConnection();

    void GetPreferredConnection();

    HRESULT SetTcpipProperties(
        GUID                guid,
        REMOTE_IPINFO*      pipInfo
        );

    HRESULT GetNetCfgInterface(
        BOOL                fNeedWriteLock,
        INetCfg**           ppNetCfg
        );

    void ReleaseNetCfgInterface(
        INetCfg*            pNetCfg,
        BOOL                fHasWriteLock
        );

    HRESULT GetTcpipPrivateInterface(
        INetCfg*            pNetCfg,
        ITcpipProperties**  ppTcpipProperties
        );

    BOOL IsEnabledConnection(
        NETCON_PROPERTIES* pprops
        );

    BOOL GetInternetHandleForPinging(
        HINTERNET* phInternet
        );

    BOOL ApplyWinntProxySettings();

    BOOL SaveProxySettings();

    void RestoreProxySettings();

    BOOL AllocProxyOptionList(
        INTERNET_PER_CONN_OPTION_LIST* pList
        );

    void FreeProxyOptionList(
        INTERNET_PER_CONN_OPTION_LIST* pList
        );

    void DisableRasAutodial();

    void RestoreRasAutoDial();

    HRESULT Enum1394Adapters(
        OUT PSTRINGLIST* pList
        );

    BOOL Is1394Adapter(
        IN GUID* pguid
        );

    HRESULT
    EnumPublicAdapters(
        OUT PSTRINGLIST* pList
        );
    inline BOOL HasModem() 
    {
        return (BOOL)(CONNECTIONTYPE_MODEM & m_dwConnectionCapabilities);
    }

    inline BOOL HasIcs() 
    {
        return (BOOL)(CONNECTIONTYPE_LAN_ICS & m_dwConnectionCapabilities);
    }

    inline BOOL HasBroadband() 
    {
        return (BOOL)(CONNECTIONTYPE_LAN_BROADBAND & m_dwConnectionCapabilities);
    }

    inline BOOL HasConnection(
        const DWORD     dwType
        )
                
    {
        return (BOOL)(dwType & m_dwConnectionCapabilities);    
    }

    inline void AddConnectionCapability(
        DWORD           dwType
        )
    {
        m_dwConnectionCapabilities |= dwType;
    }

    inline void ClearConnectionCapability(
        DWORD           dwType
        )
    {
        m_dwConnectionCapabilities &= ~dwType;
    }



    // Explicitly disallow copy constructor and assignment operator.
    //
    CConnectionManager(
        const CConnectionManager&      rhs
        );

    CConnectionManager&
    operator=(
        const CConnectionManager&      rhs
        );

private:                // data

    // Bitmask of connection types supported by the system
    //
    DWORD               m_dwConnectionCapabilities;

    // Preferred connection type to use.
    //
    DWORD               m_dwPreferredConnection;

    // Preferred connection
    //
    INetConnection*     m_pPreferredConnection;

    // Count of the LAN connections in the system (includes ICS)
    //
    DWORD               m_cLanConnections;

    // Count of the phone connections in the system
    //
    DWORD               m_cPhoneConnections;


    HINTERNET           m_hInternetPing;

    // Proxy settings
    //
    BOOL                          m_bUseProxy;
    BOOL                          m_bProxySaved;
    BOOL                          m_bProxyApplied;
    INTERNET_PER_CONN_OPTION_LIST m_CurrentProxySettings;

    DWORD               m_dwRasAutodialDisable;

    
    static const DWORD RAS_AUTODIAL_DISABLED;
    static const DWORD RAS_AUTODIAL_ENABLED;
    static const DWORD RAS_AUTODIAL_DONT_KNOW;
    
    BOOL                m_bForceOnline;

    BOOL                m_bExclude1394;

};  //  CConnectionManager



#endif  //  _CONNMGR_H_

//
///// End of file: ConnMgr.h ////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobcomm\connmgr.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module: ConnMgr.cpp  
//
//  Author: Dan Elliott
//
//  Abstract:
//
//  Environment:
//      Neptune
//
//  Revision History:
//
//////////////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////////////
//
//  Include files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <netcon.h>
#include <wininet.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <devguid.h>
#include <mswsock.h>
#include <util.h>
#include <commerr.h>
#include "connmgr.h"
#include "msobcomm.h"

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

const static int MAX_NUM_NET_COMPONENTS = 128;
const static int MAX_GUID_LEN = 40;

const DWORD CConnectionManager::RAS_AUTODIAL_ENABLED   = 0;
const DWORD CConnectionManager::RAS_AUTODIAL_DISABLED  = 1;
const DWORD CConnectionManager::RAS_AUTODIAL_DONT_KNOW = 2;

////////////////////////////////
//  Wininet/URL Helpers
////////////////////////////////

STDAPI InternetOpenWrap(
    LPCTSTR pszAgent,
    DWORD dwAccessType,
    LPCTSTR pszProxy,
    LPCTSTR pszProxyBypass,
    DWORD dwFlags,
    HINTERNET * phFileHandle
    );

STDAPI InternetOpenUrlWrap(
    HINTERNET hInternet,
    LPCTSTR   pszUrl,
    LPCTSTR   pszHeaders,
    DWORD     dwHeadersLength,
    DWORD     dwFlags,
    DWORD_PTR dwContext,
    HINTERNET * phFileHandle
    );

STDAPI HttpQueryInfoWrap(
    HINTERNET hRequest,
    DWORD dwInfoLevel,
    LPVOID lpvBuffer,
    LPDWORD lpdwBufferLength,
    LPDWORD lpdwIndex
    );

BOOL
IsGlobalOffline(
    VOID
    );

VOID
SetOffline(
    IN BOOL fOffline
    );

STDAPI PingWebServer(
    HINTERNET hInternet,
    LPCTSTR   pszUrl,
    BOOL*     pfConnected
    );

static NLA_BLOB* _NLABlobNext(
    IN NLA_BLOB* pnlaBlob
    );

static int _AllocWSALookupServiceNext(
    IN HANDLE hQuery,
    IN DWORD dwControlFlags,
    OUT LPWSAQUERYSET* ppResults
    );

static int StringCmpGUID(
    IN LPCWSTR szGuid,
    IN const GUID* pguid
    );

//////////////////////////////////////////////////////////////////////////////
//
//  CConnectionManager
//
//  Default constructor
//
//  parameters:
//      None.
//
//  returns:
//      Nothing.
//
//////////////////////////////////////////////////////////////////////////////

CConnectionManager::CConnectionManager()
:   m_dwConnectionCapabilities(CONNECTIONTYPE_INVALID),
    m_dwPreferredConnection(CONNECTIONTYPE_INVALID),
    m_pPreferredConnection(NULL),
    m_cLanConnections(0),
    m_cPhoneConnections(0),
    m_hInternetPing(NULL),
    m_bProxySaved(FALSE),
    m_bProxyApplied(FALSE),
    m_bUseProxy(FALSE),
    m_dwRasAutodialDisable(RAS_AUTODIAL_DONT_KNOW),
    m_bForceOnline(FALSE),
    m_bExclude1394(FALSE)
{
    ZeroMemory(&m_CurrentProxySettings, sizeof(m_CurrentProxySettings));
}   //  CConnectionManager::CConnectionManager



//////////////////////////////////////////////////////////////////////////////
//
//  ~CConnectionManager
//
//  Destructor.
//
//  parameters:
//      None.
//
//  returns:
//      Nothing.
//
//////////////////////////////////////////////////////////////////////////////

CConnectionManager::~CConnectionManager()
{
    if (m_hInternetPing)
    {
        InternetCloseHandle(m_hInternetPing);
    }

    if (m_bProxySaved)
    {
        RestoreProxySettings();
        FreeProxyOptionList(&m_CurrentProxySettings);
    }

    if (m_bForceOnline)
    {
        SetOffline(TRUE);
        TRACE(L"Set wininet back to offline");
    }
    
    if (m_pPreferredConnection)
    {
        m_pPreferredConnection->Release();
    }
}   //  CConnectionManager::~CConnectionManager



//////////////////////////////////////////////////////////////////////////////
//
//  GetCapabilities
//
//  Queries the system for network connection capabilities.  In addition, the
//  number of phone and LAN connections are counted and a preferred connection
//  type is determined.
//
//  parameters:
//      None.
//
//  returns:
//      A bitmask indicating the capabilities that are present.
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConnectionManager::GetCapabilities(
    DWORD*              pdwCapabilities
    )
{
    TRACE(L"CConnectionManager::GetCapabilities\n");
    HRESULT             hr = S_OK;

    if (NULL == pdwCapabilities)
    {
        MYASSERT(NULL != pdwCapabilities);
        return E_POINTER;
    }

#ifndef     CONNMGR_INITFROMREGISTRY
    // The #else part of this directive contains test code that retrieves
    // connection capabilities and preference settings from the registry
    //

    DWORD               m_cLanConnections = 0;
    DWORD               m_cPhoneConnections = 0;

    // Initialize the net connection enumeration.  For each interface
    // retrieved, SetProxyBlanket must be called to set the authentication for
    // the interface proxy handle because the Network Connection Manager lives
    // in a remote process with a different security context.
    //
    INetConnectionManager* pmgr = NULL;

    if (   SUCCEEDED(hr = CoCreateInstance(
                                CLSID_ConnectionManager, 
                                NULL, 
                                CLSCTX_SERVER | CLSCTX_NO_CODE_DOWNLOAD, 
                                IID_PPV_ARG(INetConnectionManager, &pmgr)
                                ) 
                     )
        && SUCCEEDED(hr = SetProxyBlanket(pmgr))
        )
    {
        TRACE(L"INetConnectionManager\n");
        IEnumNetConnection* penum = NULL;
        if (   SUCCEEDED(hr = pmgr->EnumConnections(NCME_DEFAULT, &penum))
            && SUCCEEDED(hr = SetProxyBlanket(penum))
            )
        {
            TRACE(L"IEnumNetConnection\n");

            hr = penum->Reset();
            while (S_OK == hr)
            {
                INetConnection* pnc = NULL;
                ULONG ulRetrieved;
                if (   S_OK == (hr = penum->Next(1, &pnc, &ulRetrieved))
                    && SUCCEEDED(hr = SetProxyBlanket(pnc))
                    )
                {
                    NETCON_PROPERTIES*  pprops = NULL;
                    hr = pnc->GetProperties(&pprops);
                    
                    if (SUCCEEDED(hr))
                    {
                        // Log the network connectivity detected
                        TRACE4(L"INetConnection: %s--%s--%d--%d\n",
                            pprops->pszwName,
                            pprops->pszwDeviceName,
                            pprops->MediaType,
                            pprops->Status);

                        if (IsEnabledConnection(pprops))
                        {
                            switch(pprops->MediaType)    
                            {
                            case NCM_LAN:
                                m_cLanConnections++;
                                if (! (HasConnection(
                                            CONNECTIONTYPE_LAN_INDETERMINATE
                                            )
                                        )
                                    )
                                {
                                    if (HasBroadband())
                                    {
                                        AddConnectionCapability(
                                            CONNECTIONTYPE_LAN_INDETERMINATE
                                            );
                                        ClearConnectionCapability(
                                            CONNECTIONTYPE_LAN_BROADBAND
                                            );
                                    }
                                    else
                                    {
                                        AddConnectionCapability(
                                            CONNECTIONTYPE_LAN_BROADBAND
                                            );
                                    }
                                }
                                break;
                            case NCM_SHAREDACCESSHOST_LAN:
                            case NCM_SHAREDACCESSHOST_RAS:
                                // Do not increment LAN connection count here.
                                // This media type is in addition to the NCM_LAN
                                // for the NIC.
                                //
                                AddConnectionCapability(CONNECTIONTYPE_LAN_ICS);
                                break;
                            case NCM_PHONE:
#ifdef      BLACKCOMB
    // For Whistler, determination of modem capability is done via
    // CObCommunicationManager::CheckDialReady.
                                m_cPhoneConnections++;
                                AddConnectionCapability(CONNECTIONTYPE_MODEM);
#endif  //  BLACKCOMB
                                break;
                            case NCM_ISDN:
                            case NCM_PPPOE:
                                AddConnectionCapability(CONNECTIONTYPE_OTHER);
                                break;
                            }   // switch
                        }
                        NcFreeNetconProperties(pprops);
                    }
                }
                
                if (NULL != pnc)
                {
                    pnc->Release();
                }
            }

            if (S_FALSE == hr)
            {
                // IEnumNetConnection::Next returned S_FALSE to indicate
                // that no more elements were available.
                hr = S_OK;
            }

        }

        if (NULL != penum)
        {
            penum->Release();
        }
    }

    if (NULL != pmgr)
    {
        pmgr->Release();
    }

    DeterminePreferredConnection();

#else
    HKEY                hKey = NULL;
    DWORD               dwSize;

    if(ERROR_SUCCESS == (lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                                OOBE_MAIN_REG_KEY,
                                                0,
                                                KEY_QUERY_VALUE,
                                                &hKey)
            )
        )
    {
        dwSize = sizeof(DWORD);
        if (ERROR_SUCCESS != (lResult = RegQueryValueEx(hKey,
                                            L"ConnectionCapabilities",
                                            0,
                                            NULL,
                                            (LPBYTE)&m_dwConnectionCapabilities,
                                            &dwSize)
                )
            )
        {
            m_dwConnectionCapabilities = CONNECTIONTYPE_INVALID;
        }
        if (ERROR_SUCCESS != (lResult = RegQueryValueEx(hKey,
                                            L"PreferredConnection",
                                            0,
                                            NULL,
                                            (LPBYTE)&m_dwPreferredConnection,
                                            &dwSize
                                            )
                )
            )
        {
            m_dwPreferredConnection = CONNECTIONTYPE_INVALID;
        }

        RegCloseKey(hKey);
    }
    else
    {
        m_dwConnectionCapabilities = CONNECTIONTYPE_INVALID;
        m_dwPreferredConnection = CONNECTIONTYPE_INVALID;
    }
#endif  //  CONNMGR_INITFROMREGISTRY
    TRACE(L"Exiting CConnectionManager::GetCapabilities\n");
    *pdwCapabilities = m_dwConnectionCapabilities;
    return hr;

}   //  CConnectionManager::GetCapabilities




//////////////////////////////////////////////////////////////////////////////
//
//  SetPreferredConnection
//
//  Set the preferred connection type.  This allows an override of the
//  internally determined preference.
//
//  parameters:
//      dwType          one of the CONNECTIONTYPE_* values from obcomm.h.
//
//  returns:
//      Boolean indicating whether the preferred connection was set.
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConnectionManager::SetPreferredConnection(
    const DWORD         dwType,
    BOOL*               pfSupportedType
    )
{
    BOOL            fSupportedType = FALSE;

    switch (dwType)
    {
    case CONNECTIONTYPE_NONE:
        fSupportedType = TRUE;
        break;
    case CONNECTIONTYPE_MODEM:
#ifdef      BLACKCOMB
// Modem capability for Whistler is handled via
// CObCommunicationManager::CheckDialReady.  However, CONNECTIONTYPE_MODEM is a
// valid enum value to pass to this function so we don't want to hit the
// default and assert.  Hence, the case and break aren't ifdef'd.
        if (HasModem())
        {
            fSupportedType = TRUE;
        }
#endif  //  BLACKCOMB
        break;
    case CONNECTIONTYPE_LAN_ICS:
        if (HasIcs())
        {
            fSupportedType = TRUE;
        }
        break;
    case CONNECTIONTYPE_LAN_BROADBAND:
        if (HasBroadband())
        {
            fSupportedType = TRUE;
        }
        break;
    default:
        // Unsupported connection type or multiple connection types
        MYASSERT(FALSE);
    }   //  switch

    if (fSupportedType)
    {
        TRACE1(L"SetPreferredConnection %d", dwType);
        
        m_dwPreferredConnection = dwType;
        GetPreferredConnection();
    }
    else
    {
        TRACE1(L"Unsupported Connection type %d", dwType);
    }
    
    if (NULL != pfSupportedType)
    {
        *pfSupportedType = fSupportedType;
    }

    return fSupportedType;

}   //  CConnectionManager::SetPreferredConnection


//////////////////////////////////////////////////////////////////////////////
//
//  ConnectedToInternet
//
//  Determines whether the system is currently connected to the Internet.
//
//  parameters:
//      pfConnected     pointer to a buffer that will receive the boolean
//                      indicating whether the connection exists.
//
//  returns:
//      TRUE            if system is connected to the internet via LAN or 
//                      dial-up or can be connected via dial-up
//      FALSE           otherwise
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConnectionManager::ConnectedToInternet(
    BOOL*               pfConnected
    )
{
    DWORD               dwFlags;

    if (NULL == pfConnected)
    {
        MYASSERT(NULL != pfConnected);
        return E_POINTER;
    }

    *pfConnected = InternetGetConnectedState(&dwFlags, 0);

    // Log the network connectivity detected
    TRACE2(L"InternetGetConnectedState %d, 0x%08lx", *pfConnected, dwFlags);
    
    return S_OK;
}   //  CConnectionManager::ConnectedToInternet


///////////////////////////////////////////////////////////
//
// SetPreferredConnectionTcpipProperties
//
STDMETHODIMP 
CConnectionManager::SetPreferredConnectionTcpipProperties(
    BOOL fAutoIpAddress,
    DWORD StaticIp_A,
    DWORD StaticIp_B,
    DWORD StaticIp_C,
    DWORD StaticIp_D,
    DWORD SubnetMask_A,
    DWORD SubnetMask_B,
    DWORD SubnetMask_C,
    DWORD SubnetMask_D,
    DWORD DefGateway_A,
    DWORD DefGateway_B,
    DWORD DefGateway_C,
    DWORD DefGateway_D,
    BOOL fAutoDns,
    DWORD DnsPref_A,
    DWORD DnsPref_B,
    DWORD DnsPref_C,
    DWORD DnsPref_D,
    DWORD DnsAlt_A,
    DWORD DnsAlt_B,
    DWORD DnsAlt_C,
    DWORD DnsAlt_D
    )
{
    HRESULT             hr;
    REMOTE_IPINFO       ipInfo;
    struct in_addr      inaddr;
    WCHAR               rgchStaticIp[INET_ADDRSTRLEN];
    WCHAR               rgchSubnetMask[INET_ADDRSTRLEN];
    WCHAR               rgchDefGateway[2 * INET_ADDRSTRLEN] = L"DefGw=";
    WCHAR               rgchGatewayMetric[2 * INET_ADDRSTRLEN] = L"GwMetric=";
    WCHAR               rgchDnsAddr[3 * INET_ADDRSTRLEN] = L"DNS=";
    WCHAR*              pch = NULL;
    NETCON_PROPERTIES*  pncProps = NULL;

    memset(&ipInfo, 0, sizeof(REMOTE_IPINFO));
    
    hr = m_pPreferredConnection->GetProperties(&pncProps);
    if (FAILED(hr))
    {
        TRACE1(L"Failed to retrieve preferred connection properties (0x%08X)\n", hr);
        goto SetPreferredConnectionTcpipPropertiesExit;
    }

    ipInfo.dwEnableDhcp = fAutoIpAddress;

    if (! fAutoIpAddress)
    {
        // if a static ip address was specified, convert it to a string and add
        // it to the REMOTE_IPINFO structure
        //
        memset(&inaddr, 0, sizeof(struct in_addr));
        inaddr.S_un.S_un_b.s_b1 = (BYTE)StaticIp_A;
        inaddr.S_un.S_un_b.s_b2 = (BYTE)StaticIp_B;
        inaddr.S_un.S_un_b.s_b3 = (BYTE)StaticIp_C;
        inaddr.S_un.S_un_b.s_b4 = (BYTE)StaticIp_D;
        if (! INetNToW(inaddr, rgchStaticIp))    
        {
            hr = E_FAIL;
            TRACE1(L"Failed to create ip address string (0x%08X)\n", hr);
            goto SetPreferredConnectionTcpipPropertiesExit;
        }

        ipInfo.pszwIpAddrList = rgchStaticIp;

        memset(&inaddr, 0, sizeof(struct in_addr));
        inaddr.S_un.S_un_b.s_b1 = (BYTE)SubnetMask_A;
        inaddr.S_un.S_un_b.s_b2 = (BYTE)SubnetMask_B;
        inaddr.S_un.S_un_b.s_b3 = (BYTE)SubnetMask_C;
        inaddr.S_un.S_un_b.s_b4 = (BYTE)SubnetMask_D;

        if (! INetNToW(inaddr, rgchSubnetMask))    
        {
            hr = E_FAIL;
            TRACE1(L"Failed to create ip address string (0x%08X)\n", hr);
            goto SetPreferredConnectionTcpipPropertiesExit;
        }

        ipInfo.pszwSubnetMaskList = rgchSubnetMask;

        pch = rgchDefGateway + lstrlen(rgchDefGateway);
        memset(&inaddr, 0, sizeof(struct in_addr));
        inaddr.S_un.S_un_b.s_b1 = (BYTE)DefGateway_A;
        inaddr.S_un.S_un_b.s_b2 = (BYTE)DefGateway_B;
        inaddr.S_un.S_un_b.s_b3 = (BYTE)DefGateway_C;
        inaddr.S_un.S_un_b.s_b4 = (BYTE)DefGateway_D;

        if (! INetNToW(inaddr, pch))    
        {
            hr = E_FAIL;
            TRACE1(L"Failed to create ip address string (0x%08X)\n", hr);
            goto SetPreferredConnectionTcpipPropertiesExit;
        }
        lstrcat(rgchGatewayMetric, L"1");


        TRACE4(L"Tcpip StaticIp %d.%d.%d.%d",
            StaticIp_A, StaticIp_B, StaticIp_C, StaticIp_D);

        TRACE4(L"Tcpip SubnetMask %d.%d.%d.%d",
            SubnetMask_A, SubnetMask_B, SubnetMask_C, SubnetMask_D);

        TRACE4(L"Tcpip DefGateway %d.%d.%d.%d",
            DefGateway_A, DefGateway_B, DefGateway_C, DefGateway_D);

        //ipInfo.pszwIpAddrList = rgchDefGateway;

    }

    if (! fAutoDns)
    {
        // if dns addresses were specified, convert them to strings and add
        // them to the REMOTE_IPINFO structure
        //
       
        pch = rgchDnsAddr + lstrlen(rgchDnsAddr);

        memset(&inaddr, 0, sizeof(struct in_addr));
        inaddr.S_un.S_un_b.s_b1 = (BYTE)DnsPref_A;
        inaddr.S_un.S_un_b.s_b2 = (BYTE)DnsPref_B;
        inaddr.S_un.S_un_b.s_b3 = (BYTE)DnsPref_C;
        inaddr.S_un.S_un_b.s_b4 = (BYTE)DnsPref_D;
        if (! INetNToW(inaddr, pch))
        {
            hr = E_FAIL;
            TRACE1(L"Failed to create dns address string (0x%08X)\n", hr);
            goto SetPreferredConnectionTcpipPropertiesExit;
        }
        pch += lstrlen(pch);
        *pch++ = L',';

        inaddr.S_un.S_un_b.s_b1 = (BYTE)DnsAlt_A;
        inaddr.S_un.S_un_b.s_b2 = (BYTE)DnsAlt_B;
        inaddr.S_un.S_un_b.s_b3 = (BYTE)DnsAlt_C;
        inaddr.S_un.S_un_b.s_b4 = (BYTE)DnsAlt_D;
        if (! INetNToW(inaddr, pch))
        {
            hr = E_FAIL;
            TRACE1(L"Failed to create alternate dns address string (0x%08X)\n", hr);
            goto SetPreferredConnectionTcpipPropertiesExit;
        }

        TRACE4(L"Tcpip DnsPref %d.%d.%d.%d",
            DnsPref_A, DnsPref_B, DnsPref_C, DnsPref_D);
        
        TRACE4(L"Tcpip DnsAlt %d.%d.%d.%d",
            DnsAlt_A, DnsAlt_B, DnsAlt_C, DnsAlt_D);
        
    }

    // plus 4 for 3 semi-colons and the null-terminator
    ipInfo.pszwOptionList = (WCHAR*) malloc((lstrlen(rgchDefGateway) 
                                             + lstrlen(rgchGatewayMetric) 
                                             + lstrlen(rgchDnsAddr) 
                                             + 4)
                                             * sizeof(WCHAR)
                                             );
    if (NULL == ipInfo.pszwOptionList)
    {
        TRACE(L"Failed to allocate memory for option list\n");
        goto SetPreferredConnectionTcpipPropertiesExit;
    }

    wsprintf(ipInfo.pszwOptionList, L"%s;%s;%s;", 
             rgchDefGateway, rgchGatewayMetric, rgchDnsAddr
             );

    hr = SetTcpipProperties(pncProps->guidId, &ipInfo);
    if (FAILED(hr))
    {
        TRACE1(L"Failed to set TCPIP info (0x%08X)\n", hr);
    }

SetPreferredConnectionTcpipPropertiesExit:

    if (NULL != ipInfo.pszwOptionList)
    {
        free(ipInfo.pszwOptionList);
        ipInfo.pszwOptionList = NULL;
    }

    if (NULL != pncProps)
    {
        NcFreeNetconProperties(pncProps);
        pncProps = NULL;
    }

    return hr;

}   //  CObCommunicationManager::SetPreferredConnectionTcpipProperties


///////////////////////////////////////////////////////////
//
// SetTcpipProperties
//
HRESULT 
CConnectionManager::SetTcpipProperties(
    GUID                guid,
    REMOTE_IPINFO*      pipInfo
    )
{
    HRESULT             hr;
    INetCfg*            pNetCfg = NULL;
    ITcpipProperties*   pTcpipProps = NULL;

    hr = GetNetCfgInterface(TRUE, &pNetCfg);
    if (SUCCEEDED(hr))
    {
        hr = GetTcpipPrivateInterface(pNetCfg, &pTcpipProps);
        if (SUCCEEDED(hr))
        {
            hr = pTcpipProps->SetIpInfoForAdapter(&guid, pipInfo);
            TRACE1(L"SetIpInfoForAdapter 0x%08lx", hr);
            if (SUCCEEDED(hr))
            {
                hr = pNetCfg->Apply();
                TRACE1(L"INetCfg::Apply 0x%08lx", hr);
            }
            pTcpipProps->Release();
        }
        ReleaseNetCfgInterface(pNetCfg, TRUE);
    }

    return hr;

}   //  CObCommunicationManager::SetTcpipProperties

//////////////////////////////////////////////////////////////////////////////
//
//  LanConnectionReady
//
//  Determines whether the system has a LAN connection that is connected to the
//  Internet.
//
//  parameters:
//      None.
//
//  returns:
//      Boolean indicating whether or not their is a ready connection.
//
//////////////////////////////////////////////////////////////////////////////
BOOL
CConnectionManager::LanConnectionReady()
{
    BOOL                fReady = FALSE;

#ifndef     CONNMGR_INITFROMREGISTRY
    if (HasBroadband() || HasIcs())
    {
        DWORD           dwFlags = 0;
        if (   InternetGetConnectedState(&dwFlags, 0)
            && (INTERNET_CONNECTION_LAN & dwFlags)
            )    
        {
            fReady = TRUE;
        }
    }
#else
    DWORD               dwLanConnectionReady;
    DWORD               dwSize = sizeof(DWORD);
    if(ERROR_SUCCESS == (lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                                OOBE_MAIN_REG_KEY,
                                                0,
                                                KEY_QUERY_VALUE,
                                                &hKey)
                         )
        )
    {
        lResult = RegQueryValueEx(hKey,
                                  L"LanConnectionReady",
                                  0,
                                  NULL,
                                  (LPBYTE)&dwLanConnectionReady,
                                  &dwSize
                                  );
        RegCloseKey(hKey);
    }

    fReady = (ERROR_SUCCESS == lResult) ? (BOOL)dwLanConnectionReady : FALSE;
#endif  //  CONNMGR_INITFROMREGISTRY

    return fReady;

}   //  CConnectionManager::LanConnectionReady


//////////////////////////////////////////////////////////////////////////////
//
//  SetProxyBlanket
//
//  Set the authentication settings for the binding handle for the
//  interface proxy.  This is necessary for setting up security for interface
//  pointers returned by a remote process, such as the Network Connections
//  Manager (netman.dll).
//
//  parameters:
//      pUnk            pointer to the interface for which the proxy will be
//                      bound.
//
//  returns:
//      HRESULT returned by CoSetProxyBlanket.
//
//////////////////////////////////////////////////////////////////////////////
HRESULT 
CConnectionManager::SetProxyBlanket(
    IUnknown*           pUnk
    )
{
    HRESULT hr;
    hr = CoSetProxyBlanket (
            pUnk,
            RPC_C_AUTHN_WINNT,      // use NT default security
            RPC_C_AUTHZ_NONE,       // use NT default authentication
            NULL,                   // must be null if default
            RPC_C_AUTHN_LEVEL_CALL, // call
            RPC_C_IMP_LEVEL_IMPERSONATE,
            NULL,                   // use process token
            EOAC_NONE);

    if(SUCCEEDED(hr)) 
    {
        IUnknown * pUnkSet = NULL;
        hr = pUnk->QueryInterface(IID_PPV_ARG(IUnknown, &pUnkSet));
        if(SUCCEEDED(hr)) 
        {
            hr = CoSetProxyBlanket (
                    pUnkSet,
                    RPC_C_AUTHN_WINNT,      // use NT default security
                    RPC_C_AUTHZ_NONE,       // use NT default authentication
                    NULL,                   // must be null if default
                    RPC_C_AUTHN_LEVEL_CALL, // call
                    RPC_C_IMP_LEVEL_IMPERSONATE,
                    NULL,                   // use process token
                    EOAC_NONE);
            pUnkSet->Release();
        }
    }
    return hr;
}   //  CConnectionManager::SetProxyBlanket




//////////////////////////////////////////////////////////////////////////////
//
//  DeterminePreferredConnection
//
//  Determine the preferred connection.  The order of preference is
//  * ICS
//  * Broadband (DSL, cable modem, etc.)
//  * Modem
//
//  parameters:
//      None.
//
//  returns:
//      Nothing.
//
//////////////////////////////////////////////////////////////////////////////
void
CConnectionManager::DeterminePreferredConnection()
{
    // REVIEW: Differences between full-screen and desktop in using default
    // connectoid.
    //
    if (HasIcs())
    {
        m_dwPreferredConnection = CONNECTIONTYPE_LAN_ICS;
    }
    else if (HasBroadband())
    {
        m_dwPreferredConnection = CONNECTIONTYPE_LAN_BROADBAND;
    }
#ifdef      BLACKCOMB
// Modem capability for Whistler is handled via
// CObCommunicationManager::CheckDialReady
    else if (HasModem())
    {
        m_dwPreferredConnection = CONNECTIONTYPE_MODEM;
    }
#endif  //  BLACKCOMB
    else    // CONNECTIONTYPE_NONE || CONNECTIONTYPE_LAN_INDETERMINATE
    {
        m_dwPreferredConnection = CONNECTIONTYPE_NONE;
    }

    GetPreferredConnection();

}   //  CConnectionManager::DeterminePreferredConnection


//////////////////////////////////////////////////////////////////////////////
//
//  GetPreferredConnection
//
//  Determine the name of the connectoid for the preferred connection.  
//
//  parameters:
//      None.
//
//  returns:
//      Nothing.
//
//////////////////////////////////////////////////////////////////////////////
void
CConnectionManager::GetPreferredConnection()
{
    HRESULT             hr;
    NETCON_MEDIATYPE    ncMediaType = NCM_NONE; // assume no connection

    switch (m_dwPreferredConnection)
    {
    case CONNECTIONTYPE_LAN_ICS:
        ncMediaType = NCM_SHAREDACCESSHOST_LAN;
        break;
    case CONNECTIONTYPE_LAN_BROADBAND:
        ncMediaType = NCM_LAN;
        break;
    }   //  switch(m_dwPreferredConnection)

    // Free up previous preferred connection properties
    //
    if (NULL != m_pPreferredConnection)
    {
        m_pPreferredConnection->Release();
        m_pPreferredConnection = NULL;
    }

    if (NCM_NONE != ncMediaType)
    {
        
        INetConnectionManager* pmgr = NULL;

        if (   SUCCEEDED(hr = CoCreateInstance(
                                    CLSID_ConnectionManager, 
                                    NULL, 
                                    CLSCTX_SERVER | CLSCTX_NO_CODE_DOWNLOAD, 
                                    IID_PPV_ARG(INetConnectionManager, &pmgr)
                                    ) 
                         )
            && SUCCEEDED(hr = SetProxyBlanket(pmgr))
            )
        {
            TRACE(L"INetConnectionManager\n");
            IEnumNetConnection* penum = NULL;
            if (   SUCCEEDED(hr = pmgr->EnumConnections(NCME_DEFAULT, &penum))
                && SUCCEEDED(hr = SetProxyBlanket(penum))
                )
            {
                TRACE(L"IEnumNetConnection\n");

                MYASSERT(NULL == m_pPreferredConnection);
                hr = penum->Reset();

                // Find the first connection matching the preferred type. This
                // works because the only types we are concerned with are
                // broadband and ICS.  By definition, we should not be here if
                // there are more than 1 of these connections.  If there are
                // more than 1 of these we should be deferring to the HomeNet
                // Wizard.  
                //
                // ONCE THIS OBJECT SUPPORTS MODEM CONNECTIONS OR MULTIPLE
                // BROADBAND CONNECTIONS we'll need a more sophisticated method
                // of determining that we've found the correct connection.
                //
                while (S_OK == hr && NULL == m_pPreferredConnection)
                {
                    INetConnection* pnc = NULL;
                    ULONG ulRetrieved;
                    if (   S_OK == (hr = penum->Next(1, &pnc, &ulRetrieved))
                        && SUCCEEDED(hr = SetProxyBlanket(pnc))
                        )
                    {
                        NETCON_PROPERTIES*  pprops = NULL;
                        hr = pnc->GetProperties(&pprops);
                        
                        // Log the network connectivity detected
                        TRACE4(L"INetConnection: %s--%s--%d--%d\n",
                            pprops->pszwName,
                            pprops->pszwDeviceName,
                            pprops->MediaType,
                            pprops->Status);
                        
                        if (SUCCEEDED(hr))
                        {
                            if (IsEnabledConnection(pprops))
                            {
                                if (ncMediaType == pprops->MediaType)
                                {
                                    m_pPreferredConnection = pnc;
                                    pnc = NULL;
                                }
                            }
                            NcFreeNetconProperties(pprops);
                        }
                    }
                    
                    if (NULL != pnc)
                    {
                        pnc->Release();
                    }
                }

                if (S_FALSE == hr)
                {
                    // IEnumNetConnection::Next returned S_FALSE to indicate
                    // that no more elements were available.
                    hr = S_OK;
                }

            }

            if (NULL != penum)
            {
                penum->Release();
            }
        }

        if (NULL != pmgr)
        {
            pmgr->Release();
        }
    }
}   //  CConnectionManager::GetPreferredConnection

//////////////////////////////////////////////////////////////////////////////
//
//  GetPreferredConnectionName
//
//  Fills in a user-allocated buffer with the name of the connectoid for the
//  preferred connection.
//
//  parameters:
//      szConnectionName    buffer that will recieve the name of the preferred
//                          connectoid
//      cchConnectionName   count of characters that the buffer can hold
//
//  returns:
//      S_OK                if the name is retrieved successfully
//      S_FALSE             if there is no default connectoid
//      E_INVALIDARG        if there is no buffer or if the buffer size is 0
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CConnectionManager::GetPreferredConnectionName(
    LPWSTR              szConnectionName,
    DWORD               cchConnectionName
    )
{

    HRESULT             hr = S_FALSE;

    if (NULL == szConnectionName || 0 == cchConnectionName)
    {
        MYASSERT(NULL != szConnectionName);
        MYASSERT(0 < cchConnectionName);
        return E_INVALIDARG;
    }

    if (NULL != m_pPreferredConnection)
    {
        NETCON_PROPERTIES* pprops = NULL;
        hr = m_pPreferredConnection->GetProperties(&pprops);
        if (SUCCEEDED(hr))
        {
            MYASSERT(NULL != pprops);
            if (NULL == pprops->pszwName)
            {
                hr = S_FALSE;
            }

            if (S_OK == hr)
            {
                lstrcpyn(szConnectionName, 
                         pprops->pszwName, 
                         cchConnectionName
                         );        
            }
            NcFreeNetconProperties(pprops);
        }
    }

    return hr;

}   //  CConnectionManager::GetPreferredConnectionName

HRESULT
CConnectionManager::GetNetCfgInterface(
    BOOL                fNeedWriteLock,
    INetCfg**           ppNetCfg
    )
{
    HRESULT             hr;
    INetCfg*            pNetCfg = NULL;

    if (NULL == ppNetCfg)
    {
        ASSERT(NULL != ppNetCfg);
        return E_INVALIDARG;
    }

    *ppNetCfg = NULL;

    hr = CoCreateInstance(CLSID_CNetCfg, 
                          NULL, 
                          CLSCTX_SERVER, 
                          IID_INetCfg, 
                          (LPVOID*)&pNetCfg
                          );
    if (SUCCEEDED(hr))
    {
        INetCfgLock*    pNetCfgLock = NULL;
        if (fNeedWriteLock)
        {
            hr = pNetCfg->QueryInterface(IID_INetCfgLock, (VOID**)&pNetCfgLock);
            if (SUCCEEDED(hr))
            {
                hr = pNetCfgLock->AcquireWriteLock(
                                        5,         // millisec timeout
                                        L"Out-of-Box Experience", 
                                        NULL       // name of previous holder
                                        );
                if (S_FALSE == hr)
                {
                    hr = NETCFG_E_NO_WRITE_LOCK;
                    TRACE(L"AcquireWriteLock failed");
                }
                pNetCfgLock->Release();
            }
            else
            {
                TRACE1(L"QueryInterface IID_INetCfgLock 0x%08lx", hr);
            }
        }

        if (SUCCEEDED(hr))
        {
            hr = pNetCfg->Initialize(NULL);
            if (SUCCEEDED(hr))
            {
                *ppNetCfg = pNetCfg;
            }
            else
            {
                TRACE1(L"INetCfg Initialize 0x%08lx", hr);
            }
        }
    }
    else
    {
        TRACE1(L"CoCreateInstance CLSID_CNetCfg IID_INetCfg 0x%08lx", hr);
    }

    if (FAILED(hr))
    {
        if (pNetCfg != NULL)
        {
            pNetCfg->Release();
        }
    }

    return hr;

}   //  CConnectionManager::GetNetCfgInterface

void
CConnectionManager::ReleaseNetCfgInterface(
    INetCfg*            pNetCfg,
    BOOL                fHasWriteLock
    )
{
    HRESULT             hr = S_OK;

    if (NULL != pNetCfg)
    {
        hr = pNetCfg->Uninitialize();

        INetCfgLock*    pNetCfgLock = NULL;
        if (fHasWriteLock)
        {
            hr = pNetCfg->QueryInterface(IID_INetCfgLock, (VOID**)&pNetCfgLock);
            if (SUCCEEDED(hr))
            {
                hr = pNetCfgLock->ReleaseWriteLock();
                pNetCfgLock->Release();
            }
        }
        pNetCfg->Release();
    }

    
}   //  CConnectionManager::ReleaseNetCfgInterface

HRESULT
CConnectionManager::GetTcpipPrivateInterface(
    INetCfg*            pNetCfg,
    ITcpipProperties**  ppTcpipProperties
    )
{
    HRESULT             hr;

    if (NULL == ppTcpipProperties)
    {
        return E_INVALIDARG;
    }

    INetCfgClass*   pncclass = NULL;

    hr = pNetCfg->QueryNetCfgClass(&GUID_DEVCLASS_NETTRANS, 
                                   IID_INetCfgClass,
                                   (void**)&pncclass
                                   );
    if (SUCCEEDED(hr))
    {
        INetCfgComponent*   pnccItem = NULL;

        hr = pncclass->FindComponent(NETCFG_TRANS_CID_MS_TCPIP, &pnccItem);
        if (SUCCEEDED(hr))
        {
            INetCfgComponentPrivate*    pinccp = NULL;
            hr = pnccItem->QueryInterface(IID_INetCfgComponentPrivate,
                                          (void**) &pinccp
                                          );
            if (SUCCEEDED(hr))
            {
                hr = pinccp->QueryNotifyObject(IID_ITcpipProperties,
                                               (void**) ppTcpipProperties
                                               );
                if (FAILED(hr))
                {
                    TRACE1(L"QueryNotifyObject IID_ITcpipProperties 0x%08lx", hr);
                }
                pinccp->Release();
                pinccp = NULL;
            }
            else
            {
                TRACE1(L"QueryInterface IID_INetCfgComponentPrivate 0x%08lx", hr);
            }

            pnccItem->Release();
            pnccItem = NULL;
        }
        else
        {
            TRACE1(L"FindComponent NETCFG_TRANS_CID_MS_TCPIP 0x%08lx", hr);
        }
        
        pncclass->Release();
        pncclass = NULL;
    }
    else
    {
        TRACE1(L"QueryNetCfgClass IID_INetCfgClass 0x%08lx", hr);
    }
    
    return hr;
}   //  CConnectionManager::GetTcpipPrivateInterface

STDAPI InternetOpenWrap(
    LPCTSTR pszAgent,
    DWORD dwAccessType,
    LPCTSTR pszProxy,
    LPCTSTR pszProxyBypass,
    DWORD dwFlags,
    HINTERNET * phFileHandle
    )
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    *phFileHandle = InternetOpen(pszAgent, dwAccessType, pszProxy, pszProxyBypass, dwFlags);
    if (!*phFileHandle)
    {
        dwError = GetLastError();
        TRACE1(L"InternetOpen failed (WININET Error %d)", dwError);
        hr = HRESULT_FROM_WIN32(dwError);
    }

    return hr;
}


STDAPI InternetOpenUrlWrap(
    HINTERNET hInternet,
    LPCTSTR   pszUrl,
    LPCTSTR   pszHeaders,
    DWORD     dwHeadersLength,
    DWORD     dwFlags,
    DWORD_PTR dwContext,
    HINTERNET * phFileHandle
    )
{
    HRESULT hr = S_OK;
    DWORD dwError = 0;

    *phFileHandle = InternetOpenUrl(hInternet, pszUrl, pszHeaders, dwHeadersLength, dwFlags, dwContext);
    if (!*phFileHandle)
    {
        dwError = GetLastError();
        TRACE1(L"InternetOpenUrl failed (WININET Error %d)", dwError);
        hr = HRESULT_FROM_WIN32(dwError);
    }

    return hr;
}

STDAPI HttpQueryInfoWrap(
    HINTERNET hRequest,
    DWORD dwInfoLevel,
    LPVOID lpvBuffer,
    LPDWORD lpdwBufferLength,
    LPDWORD lpdwIndex
    )
{
    HRESULT hr = S_OK;

    if (!HttpQueryInfo(hRequest, dwInfoLevel, lpvBuffer, lpdwBufferLength, lpdwIndex))
    {
        DWORD dwError;

        dwError = GetLastError();
        TRACE1(L"HttpQueryInfo failed (WININET Error %d)", dwError);
        hr = HRESULT_FROM_WIN32(dwError);
    }

    return hr;
}

BOOL
IsGlobalOffline(
    VOID
    )

/*++

Routine Description:

    Determines whether wininet is in global offline mode

Arguments:

    None

Return Value:

    BOOL
        TRUE    - offline
        FALSE   - online

--*/

{
    DWORD   dwState = 0;
    DWORD   dwSize = sizeof(DWORD);
    BOOL    fRet = FALSE;

    if(InternetQueryOption(
        NULL,
        INTERNET_OPTION_CONNECTED_STATE,
        &dwState,
        &dwSize
        ))
    {
        if (dwState & INTERNET_STATE_DISCONNECTED_BY_USER)
        {
            fRet = TRUE;
        }
    }

    return fRet;
}



VOID
SetOffline(
    IN BOOL fOffline
    )

/*++

Routine Description:

    Sets wininet's offline mode

Arguments:

    fOffline    - online or offline

Return Value:

    None.

--*/

{
    INTERNET_CONNECTED_INFO ci;

    memset(&ci, 0, sizeof(ci));
    
    if (fOffline)
    {
        ci.dwConnectedState = INTERNET_STATE_DISCONNECTED_BY_USER;
        ci.dwFlags = ISO_FORCE_DISCONNECTED;
    } else
    {
        ci.dwConnectedState = INTERNET_STATE_CONNECTED;
    }

    InternetSetOption(NULL, INTERNET_OPTION_CONNECTED_STATE, &ci, sizeof(ci));
}

STDAPI PingWebServer(
    HINTERNET hInternet,
    LPCTSTR   pszUrl,
    BOOL*     pfConnected
    )
{    
    HRESULT hr = E_FAIL;
    HINTERNET hOpenUrlSession;
 
    *pfConnected = FALSE;

    hr = InternetOpenUrlWrap(
        hInternet, 
        pszUrl,
        NULL,
        0,
        INTERNET_FLAG_NO_UI |
            INTERNET_FLAG_PRAGMA_NOCACHE |
            INTERNET_FLAG_NO_CACHE_WRITE |
            INTERNET_FLAG_RELOAD,
        NULL,
        &hOpenUrlSession);

    if (SUCCEEDED(hr))
    {
        DWORD dwSize = sizeof(DWORD);
        DWORD dwStatusCode;
        
        hr = HttpQueryInfoWrap(
            hOpenUrlSession,
            HTTP_QUERY_FLAG_NUMBER | HTTP_QUERY_STATUS_CODE,
            (LPVOID) &dwStatusCode,
            &dwSize,
            NULL);

        if (SUCCEEDED(hr))
        {
            // HTTP status code greater than or equal to 500 means server
            // or network problem occur
            *pfConnected = (dwStatusCode < 500);

            TRACE1(L"HTTP status code from WPA HTTP server %d", dwStatusCode);
        }

        InternetCloseHandle(hOpenUrlSession);
    }

    return hr;
}

BOOL
CConnectionManager::GetInternetHandleForPinging(
    HINTERNET* phInternet
    )
{
    static const WCHAR OOBE_HTTP_AGENT_NAME[] =  
        L"Mozilla/4.0 (compatible; MSIE 6.0b; Windows NT 5.1)";
    static const int   TIMEOUT_IN_MILLISEC = 30000;
        
    if (m_hInternetPing == NULL)
    {
        HINTERNET hInternet;
        
        if (SUCCEEDED(InternetOpenWrap(
            OOBE_HTTP_AGENT_NAME,
            PRE_CONFIG_INTERNET_ACCESS,
            NULL,
            NULL,
            0,
            &hInternet
            )))
        {
            DWORD     dwValue;

            dwValue = TIMEOUT_IN_MILLISEC;
            InternetSetOption(
                hInternet,
                INTERNET_OPTION_CONNECT_TIMEOUT,
                &dwValue,
                sizeof(DWORD));

            m_hInternetPing = hInternet;
        }

    }

    *phInternet = m_hInternetPing;

    return (m_hInternetPing != NULL);
    
}

//////////////////////////////////////////////////////////////////////////////
//
//  ConnectedToInternetEx
//
//  Determines whether the system is currently connected to the Internet.
//
//  parameters:
//      pfConnected     pointer to a buffer that will receive the boolean
//                      indicating whether the connection exists.
//
//  returns:
//      TRUE            if the system is connected to the internet. Note it may
//                      trigger autodial if it is enabled and no connection is
//                      available when this is called
//      FALSE           otherwise
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConnectionManager::ConnectedToInternetEx(
    BOOL*               pfConnected
    )
{
    const WCHAR MS_URL[] = L"http://WPA.one.microsoft.com";
    
    HINTERNET hInternet;
    HRESULT   hr = E_FAIL;
    
    *pfConnected = FALSE;

    TRACE(L"tries to connect to the WPA HTTP server");

    if (IsGlobalOffline())
    {
        SetOffline(FALSE);
        m_bForceOnline = TRUE;
        TRACE(L"Force wininet to go online");
    }
    
    DisableRasAutodial();
    
    //
    // Try to use the proxy settings from winnt32.exe first because it is
    // quite likely a proper configuration. If the settings
    // is not available or if we failed to connect to the web server 
    // using these settings, use the original settings and check the web
    // server connectivity once more.
    //

    if (GetInternetHandleForPinging(&hInternet))
    {
        DWORD     dwDisable = 0;
        DWORD     dwSize = sizeof(DWORD);
        DWORD     dwOrigDisable;

        if (!InternetQueryOption(
            hInternet,
            INTERNET_OPTION_DISABLE_AUTODIAL,
            (LPVOID) &dwOrigDisable,
            &dwSize))
        {
            // Assume the orginal state is autodial-enabled.
            dwOrigDisable = 0;
        }

        // InternetSetOption for INTERNET_OPTION_DISABLE_AUTODIAL affects the
        // behavior of an application, e.g. it cause InternetAutodial 
        // elsewhere to fail. It does not affect other applications, however.
        dwDisable = 1;
        InternetSetOption(
            hInternet,
            INTERNET_OPTION_DISABLE_AUTODIAL,
            &dwDisable,
            sizeof(DWORD));
        
        if (m_bUseProxy)
        {
            //
            // If we have already applied or we can successfully apply the
            // proxy settings
            //
            if (ApplyWinntProxySettings())
            {
                // User or we may have update the proxy and other settings in
                // registry
                InternetSetOption(
                    hInternet,
                    INTERNET_OPTION_REFRESH,
                    NULL,
                    0); 
                
                hr = PingWebServer(hInternet, MS_URL, pfConnected);         
            }
        }

        if (*pfConnected == FALSE)
        {
            //
            // Restore proxy setting if it is already applied
            //
            if (m_bUseProxy)
            {
                // Don't revert the change by SetProxySettings call.
                RestoreProxySettings();
            }

            // User or we may have update the proxy and other settings in
            // registry
            InternetSetOption(
                hInternet,
                INTERNET_OPTION_REFRESH,
                NULL,
                0); 

            hr = PingWebServer(hInternet, MS_URL, pfConnected);
        }
        
        InternetSetOption(
            hInternet,
            INTERNET_OPTION_DISABLE_AUTODIAL,
            &dwOrigDisable,
            sizeof(DWORD));        
    }

    RestoreRasAutoDial();

    TRACE1(L"%s connect to WPA HTTP server",
        (*pfConnected) ? L"could" : L"could not");

    return hr;
}   //  CConnectionManager::ConnectedToInternetEx

typedef struct tagConnmgrPARAM
{
    HWND                  hwnd;
    CConnectionManager    *pConnmgr;
} CONNMGRPARAM, *PCONNMGRPARAM;

DWORD WINAPI ConnectedToInternetExThread(LPVOID vpParam)
{
    BOOL          fConnected = FALSE;
    PCONNMGRPARAM pParam = (PCONNMGRPARAM) vpParam;
    HRESULT       hr = S_OK;
    
    hr = pParam->pConnmgr->ConnectedToInternetEx(&fConnected);

    PostMessage(pParam->hwnd, WM_OBCOMM_NETCHECK_DONE, fConnected, hr);
    
    GlobalFree(pParam);
    
    return 0;
}

//////////////////////////////////////////////////////////////////////////////
//
//  AsyncConnectedToInternetEx
//
//  Determines whether the system is currently connected to the Internet.
//
//  parameters:
//      pfConnected     pointer to a buffer that will receive the boolean
//                      indicating whether the connection exists.
//
//  returns:
//      TRUE            if the system is connected to the internet. Note it may
//                      trigger autodial if it is enabled and no connection is
//                      available when this is called
//      FALSE           otherwise
//
//  note:
//      Deprecated.
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP
CConnectionManager::AsyncConnectedToInternetEx(
    const HWND          hwnd
    )
{
    DWORD         threadId;
    HANDLE        hThread;
    PCONNMGRPARAM pParam = NULL;
    HRESULT       hr = S_OK;
    DWORD         dwError;

    pParam = (PCONNMGRPARAM) GlobalAlloc(GPTR, sizeof(CONNMGRPARAM));
    if (pParam)
    {
        pParam->hwnd = hwnd;
        pParam->pConnmgr = this;
        
        hThread = CreateThread(NULL, 0, ConnectedToInternetExThread, pParam, 0, &threadId);
        if (hThread == NULL)
        {
            dwError = GetLastError();
            hr = HRESULT_FROM_WIN32(dwError);        
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if (FAILED(hr))
    {
        // Notify the script so that it won't hang
        PostMessage(hwnd, WM_OBCOMM_NETCHECK_DONE, FALSE, hr);
    }
    
    return hr;
}   //  CConnectionManager::AsyncConnectedToInternetEx

//////////////////////////////////////////////////////////////////////////////
//
//  IsEnabledConnection
//
//  Determines whether a connection should be considered as having Internet
//  capability or not, based on its media type and current status.
//
//  parameters:
//      ncMedia         The media type of the connection
//      ncStatus        The current status of the connection
//
//  returns:
//      TRUE            We should not considered it as having Internet capability
//      FALSE           otherwise
//
//////////////////////////////////////////////////////////////////////////////
BOOL
CConnectionManager::IsEnabledConnection(
    NETCON_PROPERTIES* pprops
    )
{
    BOOL bRet;
    
    switch (pprops->MediaType)
    {
    case NCM_LAN:
        bRet = (pprops->Status != NCS_DISCONNECTED);
        if (bRet && m_bExclude1394 && Is1394Adapter(&(pprops->guidId)))
        {
            TRACE1(L"%s not considered as LAN", pprops->pszwName);
            bRet = FALSE;
        }
        break;

    case NCM_SHAREDACCESSHOST_LAN:
    case NCM_SHAREDACCESSHOST_RAS:
        bRet = (pprops->Status != NCS_DISCONNECTED);
        break;
    default:
        bRet = TRUE;
        
    }

    return bRet;
}

//////////////////////////////////////////////////////////////////////////////
//
//  SaveProxySettings
//
//  Save existing proxy settings for current user.  
//
//  returns:
//      TRUE            The value is successfully saved
//      FALSE           otherwise
//
//////////////////////////////////////////////////////////////////////////////
BOOL
CConnectionManager::SaveProxySettings()
{
    if (!m_bProxySaved)
    {
        TRACE(TEXT("try to save the existing proxy settings"));
        
        if (AllocProxyOptionList(&m_CurrentProxySettings))
        {
            DWORD dwBufferLength = sizeof(m_CurrentProxySettings);
            
            if (InternetQueryOption(
                NULL,
                INTERNET_OPTION_PER_CONNECTION_OPTION,
                &m_CurrentProxySettings,
                &dwBufferLength
                ))
            {
                m_bProxySaved = TRUE;
                TRACE(TEXT("successfully save the proxy settings"));
            }
            else
            {
                FreeProxyOptionList(&m_CurrentProxySettings);
            }
        }

        if (!m_bProxySaved)
        {
            TRACE1(
                TEXT("fail to save the proxy settings (Error %d)"),
                GetLastError()
                );
        }
    }

    return m_bProxySaved;
    
}

//////////////////////////////////////////////////////////////////////////////
//
//  RestoreProxySettings
//
//  Restore the setting captured by SaveProxySettings.
//
//////////////////////////////////////////////////////////////////////////////
void
CConnectionManager::RestoreProxySettings()
{   

    BOOL bRestored = FALSE;

    if (m_bProxyApplied)
    {
        TRACE(TEXT("try to restore the original proxy settings"));
        
        bRestored = InternetSetOption(
            NULL,
            INTERNET_OPTION_PER_CONNECTION_OPTION,
            &m_CurrentProxySettings,
            sizeof(m_CurrentProxySettings)
            );

        if (bRestored)
        {
            m_bProxyApplied = FALSE;
            TRACE(TEXT("successfully restored the proxy settings"));
        }
        else
        {
            TRACE1(
                TEXT("failed to restore the proxy settings (WININET Error %d)"),
                GetLastError()
                );
        }
    }

}

static LPTSTR
pDuplicateString(
    LPCTSTR szText
    )
{
    int    cchText;
    LPTSTR szOutText;
    
    if (szText == NULL)
    {
        return NULL;
    }

    cchText = lstrlen(szText);
    szOutText = (LPTSTR) GlobalAlloc(GPTR, sizeof(TCHAR) * (cchText + 1));
    if (szOutText)
    {
        lstrcpyn(szOutText, szText, cchText + 1);
    }

    return szOutText;
}


//////////////////////////////////////////////////////////////////////////////
//
//  ApplyWinntProxySettings
//
//  Apply the proxy settings for NIC saved during winnt32.exe to the current user.
//  Before the values is applied, it makes sure that existing settings is saved.
//
//  returns:
//      TRUE            the proxy settings was successfully applied
//      FALSE           otherwise
//
//////////////////////////////////////////////////////////////////////////////
BOOL
CConnectionManager::ApplyWinntProxySettings()
{
    #define MAX_URL_LENGTH 2048

    DWORD     dwProxyFlags = 0;
    LPTSTR    szProxyList = NULL;
    TCHAR     szWinntPath[MAX_PATH];

    //
    // Save proxy settings if it has not been saved.
    //
    SaveProxySettings();

    //
    // Apply proxy settings if it has not been applied.
    //
    if (m_bProxySaved && !m_bProxyApplied)
    {
        TRACE1(TEXT("tries to apply proxy settings, saved in %s"),
            WINNT_INF_FILENAME);

        if (GetCanonicalizedPath(szWinntPath, WINNT_INF_FILENAME))
        {
            DWORD dwEnableOobeProxy;
            
            dwEnableOobeProxy = GetPrivateProfileInt(
                OOBE_PROXY_SECTION,
                OOBE_ENABLE_OOBY_PROXY,
                0,
                szWinntPath
                );

            if (dwEnableOobeProxy)
            {
                INTERNET_PER_CONN_OPTION_LIST PrevProxySettings;
                
                if (AllocProxyOptionList(&PrevProxySettings))
                {
                    INTERNET_PER_CONN_OPTION* pOption = PrevProxySettings.pOptions;
                    DWORD                     dwBufferLength = sizeof(PrevProxySettings);
                    TCHAR                     szBuffer[MAX_URL_LENGTH];

                    pOption[0].Value.dwValue = GetPrivateProfileInt(
                        OOBE_PROXY_SECTION,
                        OOBE_FLAGS,
                        0,
                        szWinntPath
                        );
                    
                    if (GetPrivateProfileString(
                        OOBE_PROXY_SECTION,
                        OOBE_PROXY_SERVER,
                        TEXT(""),
                        szBuffer,
                        MAX_URL_LENGTH,
                        szWinntPath
                        ))
                    {
                        pOption[1].Value.pszValue = pDuplicateString(szBuffer);
                    }
                    
                    if (GetPrivateProfileString(
                        OOBE_PROXY_SECTION,
                        OOBE_PROXY_BYPASS,
                        TEXT(""),
                        szBuffer,
                        MAX_URL_LENGTH,
                        szWinntPath
                        ))
                    {
                        pOption[2].Value.pszValue = pDuplicateString(szBuffer);
                    }

                    if (GetPrivateProfileString(
                        OOBE_PROXY_SECTION,
                        OOBE_AUTOCONFIG_URL,
                        TEXT(""),
                        szBuffer,
                        MAX_URL_LENGTH,
                        szWinntPath
                        ))
                    {
                        pOption[3].Value.pszValue = pDuplicateString(szBuffer);
                    }

                    pOption[4].Value.dwValue = GetPrivateProfileInt(
                        OOBE_PROXY_SECTION,
                        OOBE_AUTODISCOVERY_FLAGS,
                        0,
                        szWinntPath
                        );
                    
                    if (GetPrivateProfileString(
                        OOBE_PROXY_SECTION,
                        OOBE_AUTOCONFIG_SECONDARY_URL,
                        TEXT(""),
                        szBuffer,
                        MAX_URL_LENGTH,
                        szWinntPath
                        ))
                    {
                        pOption[5].Value.pszValue = pDuplicateString(szBuffer);
                    }

                    m_bProxyApplied = InternetSetOption(
                        NULL,
                        INTERNET_OPTION_PER_CONNECTION_OPTION,
                        &PrevProxySettings,
                        sizeof(PrevProxySettings)
                        );

                    FreeProxyOptionList(&PrevProxySettings);
                    
                }
            }

        }

        if (m_bProxyApplied)
        {
            TRACE(TEXT("successfully load the proxy settings"));
        }
        else
        {
            TRACE1(TEXT("could not load the proxy settings (WIN32 Error %d)"),
                GetLastError());
        }
    }
    
    return m_bProxyApplied;
}

void
CConnectionManager::UseWinntProxySettings()
{
    m_bUseProxy = TRUE;
}

void
CConnectionManager::DisableWinntProxySettings()
{
    TCHAR szWinntPath[MAX_PATH];
    
    if (GetCanonicalizedPath(szWinntPath, WINNT_INF_FILENAME))
    {
        WritePrivateProfileString(
            OOBE_PROXY_SECTION,
            OOBE_ENABLE_OOBY_PROXY,
            TEXT("0"),
            szWinntPath
            );
        
        TRACE1(TEXT("disabled the proxy settings in %s"),
            WINNT_INF_FILENAME);
    }
}

BOOL
CConnectionManager::AllocProxyOptionList(
    INTERNET_PER_CONN_OPTION_LIST *pList
    )
{
    INTERNET_PER_CONN_OPTION*     pOption;        

    pOption = (INTERNET_PER_CONN_OPTION*) GlobalAlloc(
        GPTR,
        sizeof(INTERNET_PER_CONN_OPTION) * NUM_PROXY_OPTIONS);

    if (pOption)
    {
        pList->dwSize = sizeof(*pList);
        pList->pszConnection = NULL;
        pList->dwOptionCount = NUM_PROXY_OPTIONS;
        pList->pOptions = pOption;
    
        pOption[0].dwOption = INTERNET_PER_CONN_FLAGS;
        pOption[1].dwOption = INTERNET_PER_CONN_PROXY_SERVER;
        pOption[2].dwOption = INTERNET_PER_CONN_PROXY_BYPASS;
        pOption[3].dwOption = INTERNET_PER_CONN_AUTOCONFIG_URL;
        pOption[4].dwOption = INTERNET_PER_CONN_AUTODISCOVERY_FLAGS;
        pOption[5].dwOption = INTERNET_PER_CONN_AUTOCONFIG_SECONDARY_URL;
    }
    else
    {
        pList->pOptions = NULL;
    }

    return (pOption != NULL);
}

void
CConnectionManager::FreeProxyOptionList(
    INTERNET_PER_CONN_OPTION_LIST *pList
    )
{
    INTERNET_PER_CONN_OPTION* pOption = pList->pOptions;
    if (pOption)
    {
        if (pOption[1].Value.pszValue)
        {
            GlobalFree(pOption[1].Value.pszValue);
        }

        if (pOption[2].Value.pszValue)
        {
            GlobalFree(pOption[2].Value.pszValue);
        }

        if (pOption[3].Value.pszValue)
        {
            GlobalFree(pOption[3].Value.pszValue);
        }

        if (pOption[5].Value.pszValue)
        {
            GlobalFree(pOption[5].Value.pszValue);
        }

        GlobalFree(pOption);

        pList->pOptions = NULL;
    }
}

void CConnectionManager::DisableRasAutodial()
{
    DWORD dwValue = RAS_AUTODIAL_DISABLED;
    
    if (m_dwRasAutodialDisable == RAS_AUTODIAL_DONT_KNOW)
    {         
        DWORD dwSize = sizeof(m_dwRasAutodialDisable);
        
        if (RasGetAutodialParam(
            RASADP_LoginSessionDisable,
            &m_dwRasAutodialDisable,
            &dwSize
            ) != ERROR_SUCCESS)
        {
            m_dwRasAutodialDisable = RAS_AUTODIAL_ENABLED;
        }
        else
        {
            TRACE1(
                L"Save value of RASADP_LoginSessionDisable %d",
                m_dwRasAutodialDisable
                );
        }
    }

    if (RasSetAutodialParam(
        RASADP_LoginSessionDisable,
        &dwValue,
        sizeof(dwValue)
        ) == ERROR_SUCCESS)
    {
        TRACE(L"Disabled RAS Autodial for current logon session");
    }
}

void CConnectionManager::RestoreRasAutoDial()
{
    if (m_dwRasAutodialDisable != RAS_AUTODIAL_DONT_KNOW)
    {
        if (RasSetAutodialParam(
            RASADP_LoginSessionDisable,
            &m_dwRasAutodialDisable,
            sizeof(m_dwRasAutodialDisable)
            ) == ERROR_SUCCESS)
        {
            TRACE(L"Restore value of RAS Autodial for current logon session");
        }
    }
}

HRESULT CConnectionManager::GetProxySettings(
    BOOL* pbUseAuto,
    BOOL* pbUseScript,
    BSTR* pszScriptUrl,
    BOOL* pbUseProxy,
    BSTR* pszProxy
    )
{
    HRESULT hr = E_FAIL;

    //
    // Save proxy settings if it has not been saved.
    //
    SaveProxySettings();
    
    if (m_bProxySaved)
    {
        INTERNET_PER_CONN_OPTION* pOption = m_CurrentProxySettings.pOptions;
        
        *pbUseAuto = pOption[0].Value.dwValue & PROXY_TYPE_AUTO_DETECT;
        *pbUseScript = pOption[0].Value.dwValue & PROXY_TYPE_AUTO_PROXY_URL;
        *pbUseProxy = pOption[0].Value.dwValue & PROXY_TYPE_PROXY;

        if (pOption[1].Value.pszValue)
        {
            *pszProxy = SysAllocString(pOption[1].Value.pszValue);
        }
        else
        {
            *pszProxy = NULL;
        }

        if (pOption[3].Value.pszValue)
        {
            *pszScriptUrl = SysAllocString(pOption[3].Value.pszValue);
        }
        else
        {
            *pszScriptUrl = NULL;
        }
        
        hr = S_OK;
    }

    return hr;

}

HRESULT CConnectionManager::SetProxySettings(
    BOOL bUseAuto,
    BOOL bUseScript,
    BSTR szScriptUrl,
    BOOL bUseProxy,
    BSTR szProxy
    )
{
    HRESULT hr = E_FAIL;

    //
    // We don't behavior correctly in this->ConnectedToInternetEx if we
    // also use proxy settings saved in winnt32.
    //
    MYASSERT(!m_bUseProxy);
    
    //
    // Save proxy settings if it has not been saved.
    //
    SaveProxySettings();
        
    if (m_bProxySaved)
    {
        INTERNET_PER_CONN_OPTION_LIST ProxySettings;
        
        if (AllocProxyOptionList(&ProxySettings))
        {
            INTERNET_PER_CONN_OPTION* pOption = ProxySettings.pOptions;

            pOption[0].Value.dwValue = PROXY_TYPE_DIRECT;
            if (bUseAuto)
            {
                pOption[0].Value.dwValue |= PROXY_TYPE_AUTO_DETECT;
            }
            if (bUseScript)
            {
                pOption[0].Value.dwValue |= PROXY_TYPE_AUTO_PROXY_URL;
            }
            if (bUseProxy)
            {
                pOption[0].Value.dwValue |= PROXY_TYPE_PROXY;
            }

            pOption[1].Value.pszValue = szProxy;

            pOption[2].Value.pszValue = NULL;

            pOption[3].Value.pszValue = szScriptUrl;

            pOption[4].Value.dwValue = m_CurrentProxySettings.pOptions[4].Value.dwValue;
            if (bUseAuto)
            {
                pOption[4].Value.dwValue |= AUTO_PROXY_FLAG_USER_SET;
            }
            
            pOption[5].Value.pszValue = m_CurrentProxySettings.pOptions[5].Value.pszValue;

            TRACE5(TEXT("tries to set LAN proxy: %d, %s, %s, %d"),
                pOption[0].Value.dwValue,
                pOption[1].Value.pszValue,
                pOption[3].Value.pszValue,
                pOption[4].Value.dwValue,
                pOption[5].Value.pszValue
                );

            if (InternetSetOption(
                NULL,
                INTERNET_OPTION_PER_CONNECTION_OPTION,
                &ProxySettings,
                sizeof(ProxySettings)
                ))
            {
                m_bProxyApplied = TRUE;
                hr = S_OK;
            }

            // so that we don't free the memory from the caller in
            // FreeProxyOptionList
            pOption[1].Value.pszValue = NULL;
            pOption[3].Value.pszValue = NULL;
            pOption[5].Value.pszValue = NULL;
            
            FreeProxyOptionList(&ProxySettings);
        }
    }

    if (SUCCEEDED(hr))
    {
        TRACE(TEXT("successfully set the proxy settings"));
    }
    else
    {
        TRACE1(TEXT("could not set the proxy settings (WIN32 Error %d)"),
            GetLastError());
    }


    return hr;
}

STDMETHODIMP
CConnectionManager::GetPublicLanCount(int* pcPublicLan)
{
    PSTRINGLIST PubList = NULL;
    HRESULT hr = S_OK;
    
    EnumPublicAdapters(&PubList);

    int i = 0;

    for (PSTRINGLIST p = PubList; p; p = p->Next)
    {
        i++;
    }

    *pcPublicLan = i;        

    if (PubList)
    {
        DestroyList(PubList);
    }
    
    return hr;
}

HRESULT 
CConnectionManager::Enum1394Adapters(
    OUT PSTRINGLIST* pList
    )
{

    UINT i;
    INetCfgComponent* arrayComp[MAX_NUM_NET_COMPONENTS];
    IEnumNetCfgComponent* pEnum = NULL;
    INetCfgClass* pNetCfgClass = NULL;
    INetCfgComponent* pNetCfgComp = NULL;
    LPWSTR szPnpId = NULL;
    HRESULT hr = S_OK;
    DWORD dwCharacteristics = 0;
    ULONG iCount = 0;
    PSTRINGLIST List = NULL;
    PSTRINGLIST Cell = NULL;
    GUID guidInstance;
    WCHAR szInstanceGuid[MAX_GUID_LEN + 1] = L"";
    INetCfg* pNetCfg = NULL;
    
    ZeroMemory(arrayComp, sizeof(arrayComp));

    hr = GetNetCfgInterface(FALSE, &pNetCfg);
    if (FAILED(hr))
    {
        goto cleanup;
    }

    //
    // Obtain the INetCfgClass interface pointer
    //

    hr = pNetCfg->QueryNetCfgClass( &GUID_DEVCLASS_NET, 
                                    IID_INetCfgClass, 
                                    (void**)&pNetCfgClass );

    if( FAILED( hr ) )
    {
        goto cleanup;
    }

    //
    // Retrieve the enumerator interface
    //

    hr = pNetCfgClass->EnumComponents( &pEnum );
    if( FAILED( hr ) )
    {
        goto cleanup;
    }

    hr = pEnum->Next( MAX_NUM_NET_COMPONENTS, &arrayComp[0], &iCount );
    if( FAILED( hr ) )
    {
        goto cleanup;
    }

    MYASSERT( iCount <= MAX_NUM_NET_COMPONENTS );
    if ( iCount > MAX_NUM_NET_COMPONENTS )
    {
        hr = E_UNEXPECTED;
        goto cleanup;
    }

    for( i = 0; i < iCount; i++ )
    {
        pNetCfgComp = arrayComp[i];
        
        hr = pNetCfgComp->GetCharacteristics( &dwCharacteristics );
        if( FAILED( hr ) )
        {
            goto cleanup;
        }

        //
        //  If this is a physical adapter
        //
        
        if( dwCharacteristics & NCF_PHYSICAL )
        {
            hr = pNetCfgComp->GetId( &szPnpId );

            if (FAILED(hr))
            {
                goto cleanup;
            }
                
            //
            // If this is a 1394 network adapter
            //
            
            if (!lstrcmpi(szPnpId, L"v1394\\nic1394"))
            {
                hr = pNetCfgComp->GetInstanceGuid(&guidInstance);

                if (FAILED(hr))
                {
                    goto cleanup;
                }
                
                if (!StringFromGUID2(guidInstance, szInstanceGuid, MAX_GUID_LEN))
                {
                    goto cleanup;
                }
                
                Cell = CreateStringCell(szInstanceGuid);
                
                if (!Cell)
                {
                    goto cleanup;
                }
                
                InsertList(&List, Cell);

                Cell = NULL;

            }

            CoTaskMemFree( szPnpId );
            
            szPnpId = NULL;
        }
    }

    *pList = List;
    List = NULL;

cleanup:

    if (List)
    {
        DestroyList(List);
    }

    if (Cell)
    {
        DeleteStringCell(Cell);
    }

    if (szPnpId)
    {
        CoTaskMemFree(szPnpId);
    }

    for (i = 0; i < iCount; i++)
    {
        if (arrayComp[i])
        {
            arrayComp[i]->Release();
        }
    }

    if (pNetCfgClass)
    {
        pNetCfgClass->Release();
    }

    if (pEnum)
    {
        pEnum->Release();
    }

    if (pNetCfg)
    {
        ReleaseNetCfgInterface(pNetCfg, FALSE);
    }

    return hr;

}

BOOL
CConnectionManager::Is1394Adapter(
    GUID* pguid
    )
{
    PSTRINGLIST List = NULL;
    PSTRINGLIST p;
    BOOL bRet = FALSE;

    Enum1394Adapters(&List);

    if (List)
    {
        for (p = List; p; p = p->Next)
        {
            if (!StringCmpGUID(p->String, pguid))
            {
                bRet = TRUE;
                break;
            }
        }

        DestroyList(List);
    }

    return bRet;
}

HRESULT
CConnectionManager::EnumPublicConnections(
    OUT PSTRINGLIST* pList
    )
{
    HRESULT hr = S_OK;
    PSTRINGLIST PubList = NULL;

    TRACE(L"Begin EnumPublicConnections ...");
    
    EnumPublicAdapters(&PubList);

    if (!PubList)
    {
        *pList = NULL;
        return hr;
    }

    // Initialize the net connection enumeration.  For each interface
    // retrieved, SetProxyBlanket must be called to set the authentication for
    // the interface proxy handle because the Network Connection Manager lives
    // in a remote process with a different security context.
    //
    INetConnectionManager* pmgr = NULL;
    IEnumNetConnection* penum = NULL;
    NETCON_PROPERTIES* pprops = NULL;
    INetConnection* pnc = NULL;
    PSTRINGLIST List = NULL;
    PSTRINGLIST p = NULL;
    PSTRINGLIST Cell = NULL;
    ULONG ulRetrieved;

    hr = CoCreateInstance(
            CLSID_ConnectionManager, 
            NULL, 
            CLSCTX_SERVER | CLSCTX_NO_CODE_DOWNLOAD, 
            IID_INetConnectionManager,
            (VOID**) &pmgr
            );

    if (FAILED(hr))
    {
        goto cleanup;
    }

    hr = SetProxyBlanket(pmgr);

    if (FAILED(hr))
    {
        goto cleanup;
    }

    hr = pmgr->EnumConnections(NCME_DEFAULT, &penum);

    if (FAILED(hr))
    {
        goto cleanup;
    }

    hr = SetProxyBlanket(penum);

    if (FAILED(hr))
    {
        goto cleanup;
    }

    hr = penum->Reset();

    if (FAILED(hr))
    {
        goto cleanup;
    }

    hr = penum->Next(1, &pnc, &ulRetrieved);

    while (S_OK == hr)
    {
                
        hr = SetProxyBlanket(pnc);
        
        if (FAILED(hr))
        {
            goto cleanup;
        }

        hr = pnc->GetProperties(&pprops);

        if (FAILED(hr))
        {
            goto cleanup;
        }
           
        if (pprops->MediaType == NCM_LAN && pprops->Status != NCS_DISCONNECTED)    
        {
            for (p = PubList; p; p = p->Next)
            {
                if (!StringCmpGUID(p->String, &(pprops->guidId)))
                {
                    Cell = CreateStringCell(pprops->pszwName);
                    if (Cell)
                    {
                        TRACE1(L" + %s", pprops->pszwName);
                        InsertList(&List, Cell);
                    }
                }
            }
        }
        
        NcFreeNetconProperties(pprops);
        
        pprops = NULL;

        pnc->Release();

        pnc = NULL;

        hr = penum->Next(1, &pnc, &ulRetrieved);
        
    }

    if (hr != S_FALSE)
    {
        goto cleanup;
    }
    
    // IEnumNetConnection::Next returned S_FALSE to indicate
    // that no more elements were available.

    hr = S_OK;
        
    *pList = List;

    List = NULL;
    

cleanup:

    if (List)
    {
        DestroyList(List);
    }

    if (NULL != pprops)
    {
        NcFreeNetconProperties(pprops);
    }

    if (NULL != pnc)
    {
        pnc->Release();
    }

    if (NULL != penum)
    {
        penum->Release();
    }

    if (NULL != pmgr)
    {
        pmgr->Release();
    }

    TRACE1(L"End EnumPublicConnections (0x%08lx)", hr);

    return hr;
}

HRESULT
CConnectionManager::EnumPublicAdapters(
    OUT PSTRINGLIST* pList
    )
{
    static GUID g_guidNLAServiceClass = NLA_SERVICE_CLASS_GUID;
    static const int MAX_ADAPTER_NAME_LEN = 256;
    
    WSADATA wsaData;
    int error;
    PSTRINGLIST AdapterList = NULL;
    PSTRINGLIST ExcludeList = NULL;

    TRACE(L"Begin EnumPublicAdapters ...");
    
    if (m_bExclude1394)
    {       
        Enum1394Adapters(&ExcludeList);
    }
    
    if (0 == (error = WSAStartup(MAKEWORD(2, 2), &wsaData))) 
    {
        // Init query for network names
        WSAQUERYSET restrictions = {0};
        restrictions.dwSize = sizeof(restrictions);
        restrictions.lpServiceClassId = &g_guidNLAServiceClass;
        restrictions.dwNameSpace = NS_NLA;

        HANDLE hQuery;
        
        // Make sure we do not ask for the (chicken) blobs that take a long time to get
        if (0 == (error = WSALookupServiceBegin(&restrictions, LUP_NOCONTAINERS | LUP_DEEP, &hQuery)))
        {
            PWSAQUERYSET pqsResults = NULL;

            while (0 == _AllocWSALookupServiceNext(hQuery, 0, &pqsResults)) 
            {
                if (NULL != pqsResults->lpBlob)
                {
                    NLA_BLOB* pnlaBlob = (NLA_BLOB*) pqsResults->lpBlob->pBlobData;
                    WCHAR szAdapterWide[MAX_ADAPTER_NAME_LEN] = L"";
                    NLA_INTERNET nlaInternet = NLA_INTERNET_UNKNOWN;
                    
                    while (NULL != pnlaBlob)
                    {
                        switch (pnlaBlob->header.type)
                        {
                        case NLA_INTERFACE:
                            MultiByteToWideChar(
                                CP_ACP,
                                0,
                                pnlaBlob->data.interfaceData.adapterName, 
                                -1,
                                szAdapterWide,
                                ARRAYSIZE(szAdapterWide)
                                );
                            break;
                        case NLA_CONNECTIVITY:
                            nlaInternet = pnlaBlob->data.connectivity.internet;
                            break;
                        }
                        pnlaBlob = _NLABlobNext(pnlaBlob);
                    }

                    if (nlaInternet == NLA_INTERNET_YES && szAdapterWide[0])
                    {
                        PSTRINGLIST p = NULL;

                        for (p = ExcludeList; p; p = p->Next)
                        {
                            if (!lstrcmpi(p->String, szAdapterWide))
                            {
                                break;
                            }
                        }

                        //
                        // Check if the adapter is excluded.
                        //
                        
                        if (!p)
                        {
                            PSTRINGLIST Cell = CreateStringCell(szAdapterWide);
                            if (Cell)
                            {
                                TRACE1(L" + %s", szAdapterWide);
                                InsertList(&AdapterList, Cell);
                            }
                        }
                    }
                    
                }

                LocalFree(pqsResults);
            }

            
            WSALookupServiceEnd(pqsResults);
        }

        WSACleanup();

        if (error == 0)
        {
            *pList = AdapterList;
        }
        else
        {
            if (AdapterList)
            {
                DestroyList(AdapterList);
            }
        }
        
    }

    TRACE1(L"End EnumPublicAdapters (%d)", error);

    return HRESULT_FROM_WIN32(error);
}

NLA_BLOB* _NLABlobNext(
    IN NLA_BLOB* pnlaBlob
    )
{
    NLA_BLOB* pNext = NULL;

    if (pnlaBlob->header.nextOffset)
    {
        pNext = (NLA_BLOB*) (((BYTE*) pnlaBlob) + pnlaBlob->header.nextOffset);
    }
    
    return pNext;
}

int _AllocWSALookupServiceNext(
    IN HANDLE hQuery, 
    IN DWORD dwControlFlags, 
    OUT LPWSAQUERYSET* ppResults
    )
{
    *ppResults = NULL;

    DWORD cb = 0;
    int error = 0;
    if (SOCKET_ERROR == WSALookupServiceNext(hQuery, dwControlFlags, &cb, NULL))
    {
        error = WSAGetLastError();
        if (WSAEFAULT == error)
        {
            assert(cb);
            *ppResults = (LPWSAQUERYSET) LocalAlloc(LPTR, cb);

            if (NULL != *ppResults)
            {
                error = 0;
                if (SOCKET_ERROR == WSALookupServiceNext(hQuery, dwControlFlags, &cb, *ppResults))
                {
                    error = WSAGetLastError();
                }
            }
            else
            {
                error = WSA_NOT_ENOUGH_MEMORY;
            }
        }
    }

    // May as well map outdated error code while we're here.
    if (WSAENOMORE == error)
    {
        error = WSA_E_NO_MORE;
    }

    if (error && (*ppResults))
    {
        LocalFree(*ppResults);
        *ppResults = NULL;
    }

    return error;
}

static int StringCmpGUID(
    IN LPCWSTR szGuid,
    IN const GUID* pguid
    )
{
    WCHAR szGuid1[MAX_GUID_LEN + 1];
    
    if (!StringFromGUID2(*pguid, szGuid1, MAX_GUID_LEN))
    {
        // consider it as szGuid is greater than pguid
        return 1;
    }
    
    return lstrcmpi(szGuid, szGuid1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobcomm\enumodem.h ===
// jmazner  pinched from inetcfg\rnacall.h class ENUM_MODEM

#ifndef __ENUMODEM_H_
#define __ENUMODEM_H_
#include "obcomglb.h"


class CEnumModem
{
private:
  DWORD         m_dwError;
  DWORD         m_dwNumEntries;
  DWORD         m_dwIndex;
  LPRASDEVINFO  m_lpData;
public:
  CEnumModem();
  ~CEnumModem();
  DWORD ReInit();
  WCHAR * Next();
  WCHAR * GetDeviceTypeFromName(LPWSTR szDeviceName);
  WCHAR * GetDeviceNameFromType(LPWSTR szDeviceType);
  WCHAR * GetDeviceName(DWORD dwIndex);
  WCHAR * GetDeviceType(DWORD dwIndex);
  BOOL VerifyDeviceNameAndType(LPWSTR szDeviceName, LPWSTR szDeviceType);
  DWORD GetNumDevices() {  this->ReInit(); return m_dwNumEntries; }
  DWORD GetError()  { return m_dwError; }
  void  ResetIndex() { m_dwIndex = 0; }
};

// from inetcfg\export.cpp
// structure to pass data back from IDD_CHOOSEMODEMNAME handler
typedef struct tagCHOOSEMODEMDLGINFO
{
  LPWSTR szModemName[RAS_MaxDeviceName + 1];
  HRESULT hr;
} CHOOSEMODEMDLGINFO, * PCHOOSEMODEMDLGINFO;

BOOL CALLBACK ChooseModemDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
  LPARAM lParam);
BOOL ChooseModemDlgInit(HWND hDlg, PCHOOSEMODEMDLGINFO pChooseModemDlgInfo);
BOOL ChooseModemDlgOK(HWND hDlg, PCHOOSEMODEMDLGINFO pChooseModemDlgInfo);


//rnacall.cpp
HRESULT InitModemList(HWND hCB);

#endif      // ENUMODEM.H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobcomm\homenet.h ===
#ifndef     _HOMENET_H_
#define _HOMENET_H_

//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module: homenet.h
//
//  Author: Dan Elliott
//
//  Abstract:
//
//  Environment:
//      Neptune
//
//  Revision History:
//
//////////////////////////////////////////////////////////////////////////////

#include <shpriv.h>


//////////////////////////////////////////////////////////////////////////////
//
// CHomeNet
//
// Abstract:  This class manages configuration and connection of Home
// Networking components.
//
class CHomeNet 
{
public:                 // operations
    CHomeNet( );
    ~CHomeNet( );
    HRESULT Create();
    HRESULT ConfigureSilently(
        LPCWSTR         szConnectoidName,
        BOOL*           pfRebootRequired
        );

    BOOL
    IsValid( ) const
    {
        return (NULL != m_pHNWiz);
    }   //  IsValid
protected:              // operations

protected:              // data

private:                // operations



    // Explicitly disallow copy constructor and assignment operator.
    //
    CHomeNet(
        const CHomeNet&      rhs
        );

    CHomeNet&
    operator=(
        const CHomeNet&      rhs
        );

    void
    DeepCopy(
        const CHomeNet&      rhs
        )
    {
    }   //  DeepCopy

private:                // data

    // Pointer to the Home Networking Wizard for configuring HomeNet components.
    //
    IHomeNetworkWizard*     m_pHNWiz;

};  //  CHomeNet



#endif  //  _HOMENET_H_

//
///// End of file: homenet.h ////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobcomm\enumodem.cpp ===
/*-----------------------------------------------------------------------------
	enumodem.cpp

	Holds code that deals with the "Choose a modem" dialog needed when user has
	multiple modems installed

	Copyright (C) 1996-1998 Microsoft Corporation
	All rights reserved

	Authors:
		jmazner Jeremy Mazner

	History:
		10/19/96        jmazner Created, cloned almost verbatim from 
							INETCFG's rnacall.cpp and export.cpp    
        1-9-98          donaldm Adapted from ICWCONN1
-----------------------------------------------------------------------------*/

#include <windowsx.h>

#include "obcomglb.h"
#include "enumodem.h"
#include "rnaapi.h"
#include "util.h"


// from psheet.cpp
extern void ProcessDBCS(HWND hDlg, int ctlID);


/*******************************************************************

  NAME:    CEnumModem::CEnumModem

  SYNOPSIS:  Constructor for class to enumerate modems

  NOTES:    Useful to have a class rather than C functions for
	this, due to how the enumerators function

********************************************************************/
CEnumModem::CEnumModem() :
  m_dwError(ERROR_SUCCESS), m_lpData(NULL),m_dwIndex(0)
{
  DWORD cbSize = 0;
  m_lpData = NULL;
}


/*******************************************************************

  NAME:     CEnumModem::ReInit

  SYNOPSIS: Re-enumerate the modems, freeing the old memory.

********************************************************************/
DWORD CEnumModem::ReInit()
{
  DWORD cbSize = 0;
  RNAAPI cRnaapi;

  // Clean up the old list
  if (m_lpData)
  {
    delete m_lpData;
    m_lpData = NULL;             
  }
  m_dwNumEntries = 0;
  m_dwIndex = 0;

  // call RasEnumDevices with no buffer to find out required buffer size
  m_dwError = cRnaapi.RasEnumDevices(NULL, &cbSize, &m_dwNumEntries);

  // Special case check to work around RNA bug where ERROR_BUFFER_TOO_SMALL
  // is returned even if there are no devices.
  // If there are no devices, we are finished.
  if (0 == m_dwNumEntries)
  {
    m_dwError = ERROR_SUCCESS;
    return m_dwError;
  }

  // Since we were just checking how much mem we needed, we expect
  // a return value of ERROR_BUFFER_TOO_SMALL, or it may just return
  // ERROR_SUCCESS (ChrisK  7/9/96).
  if (ERROR_BUFFER_TOO_SMALL != m_dwError && ERROR_SUCCESS != m_dwError)
  {
    return m_dwError;
  }

  // Allocate the space for the data
  m_lpData = (LPRASDEVINFO) new BYTE[cbSize];
  if (NULL == m_lpData)
  {
	  //TraceMsg(TF_GENERAL, L"ICWCONN1: CEnumModem: Failed to allocate device list buffer\n");
	  m_dwError = ERROR_NOT_ENOUGH_MEMORY;
	  return m_dwError;
  }
  m_lpData->dwSize = sizeof(RASDEVINFO);
  m_dwNumEntries = 0;

  // enumerate the modems into buffer
  m_dwError = cRnaapi.RasEnumDevices(m_lpData, &cbSize,
    &m_dwNumEntries);

    if (ERROR_SUCCESS != m_dwError)
	return m_dwError;

    //
    // ChrisK Olympus 4560 do not include VPN's in the list
    //
    DWORD dwTempNumEntries;
    DWORD idx;
    LPRASDEVINFO lpNextValidDevice;

    dwTempNumEntries = m_dwNumEntries;
    lpNextValidDevice = m_lpData;


	//
	// Walk through the list of devices and copy non-VPN device to the first
	// available element of the array.
	//
	for (idx = 0;idx < dwTempNumEntries; idx++)
	{
	    TRACE2(L"Modem device %s %s",
	        m_lpData[idx].szDeviceType, m_lpData[idx].szDeviceName);
	    
		if ((0 == lstrcmpi(RASDT_Modem, m_lpData[idx].szDeviceType)) || 
            (0 == lstrcmpi(RASDT_Isdn,  m_lpData[idx].szDeviceType)) ||
            (0 == lstrcmpi(RASDT_PPPoE, m_lpData[idx].szDeviceType)) ||
			(0 == lstrcmpi(RASDT_Atm,   m_lpData[idx].szDeviceType)))
		{
			if (lpNextValidDevice != &m_lpData[idx])
			{
				MoveMemory(lpNextValidDevice , &m_lpData[idx],sizeof(RASDEVINFO));
			}
			lpNextValidDevice++;
		}
		else
		{
			m_dwNumEntries--;
		}
	}


  return m_dwError;
}


/*******************************************************************

  NAME:    CEnumModem::~CEnumModem

  SYNOPSIS:  Destructor for class

********************************************************************/
CEnumModem::~CEnumModem()
{
  if (m_lpData)
  {
    delete m_lpData;
    m_lpData = NULL;             
  }
}

/*******************************************************************

  NAME:     CEnumModem::Next

  SYNOPSIS: Enumerates next modem 

  EXIT:     Returns a pointer to device info structure.  Returns
	    NULL if no more modems or error occurred.  Call GetError
	    to determine if error occurred.

********************************************************************/
WCHAR * CEnumModem::Next()
{
  if (m_dwIndex < m_dwNumEntries)
  {
    return m_lpData[m_dwIndex++].szDeviceName;
  }

  return NULL;
}


/*******************************************************************

  NAME:     CEnumModem::GetDeviceTypeFromName

  SYNOPSIS: Returns type string for specified device.

  EXIT:     Returns a pointer to device type string for first
	    device name that matches.  Returns
	    NULL if no device with specified name is found

********************************************************************/

WCHAR * CEnumModem::GetDeviceTypeFromName(LPWSTR szDeviceName)
{
  DWORD dwIndex = 0;

  while (dwIndex < m_dwNumEntries)
  {
    if (!lstrcmpi(m_lpData[dwIndex].szDeviceName, szDeviceName))
    {
      return m_lpData[dwIndex].szDeviceType;
    }
    dwIndex++;
  }

  return NULL;
}


/*******************************************************************

  NAME:     CEnumModem::GetDeviceNameFromType

  SYNOPSIS: Returns type string for specified device.

  EXIT:     Returns a pointer to device name string for first
	    device type that matches.  Returns
	    NULL if no device with specified Type is found

********************************************************************/

WCHAR * CEnumModem::GetDeviceNameFromType(LPWSTR szDeviceType)
{
  DWORD dwIndex = 0;

  while (dwIndex < m_dwNumEntries)
  {
    if (!lstrcmpi(m_lpData[dwIndex].szDeviceType, szDeviceType))
    {
        return m_lpData[dwIndex].szDeviceName;
    }
    dwIndex++;
  }

  return NULL;
}


/*******************************************************************

  NAME:     CEnumModem::GetDeviceName
            CEnumModem::GetDeviceType

  SYNOPSIS: Returns the device name or type for the selected device.

  REMARKS:
            ONLY call this function after calling ReInit to initialize
            the device list. The device index is relative to the 
            current copy of the device list.

  EXIT:     Returns a pointer to the device name or type. 

  donsc - 3/11/98 
      Added this function because we need to be able to select a device
      from the list.
********************************************************************/

WCHAR * CEnumModem::GetDeviceName(DWORD dwIndex)
{
    if(dwIndex>=m_dwNumEntries)
        return NULL;

    return m_lpData[dwIndex].szDeviceName;
}

WCHAR * CEnumModem::GetDeviceType(DWORD dwIndex)
{
    if(dwIndex>=m_dwNumEntries)
        return NULL;

    return m_lpData[dwIndex].szDeviceType;
}


/*******************************************************************

  NAME:     CEnumModem::VerifyDeviceNameAndType

  SYNOPSIS: Determines whether there is a device with the name
	    and type given.

  EXIT:     Returns TRUE if the specified device was found, 
	    FALSE otherwise.

********************************************************************/

BOOL CEnumModem::VerifyDeviceNameAndType(LPWSTR szDeviceName, LPWSTR szDeviceType)
{
  DWORD dwIndex = 0;

  while (dwIndex < m_dwNumEntries)
  {
    if (!lstrcmpi(m_lpData[dwIndex].szDeviceType, szDeviceType) &&
      !lstrcmpi(m_lpData[dwIndex].szDeviceName, szDeviceName))
    {
      return TRUE;
    }
    dwIndex++;
  }

  return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobcomm\homenet.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module: homenet.cpp
//
//  Author: Dan Elliott
//
//  Abstract:
//
//  Environment:
//      Neptune
//
//  Revision History:
//      000828  dane    Created.
//
//////////////////////////////////////////////////////////////////////////////

#pragma comment(user, "Compiled on " __DATE__ " at " __TIME__)
#pragma comment(compiler)


//////////////////////////////////////////////////////////////////////////////
//
//  Include files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <util.h>
#include <homenet.h>

//////////////////////////////////////////////////////////////////////////////
//
//  Static initialization
//


//////////////////////////////////////////////////////////////////////////////
//
//  CHomeNet
//
//  Default constructor for CHomeNet.  All initialization that cannot fail
//  should be done here.
//
//  parameters:
//      None
//
//  returns:
//      Nothing.
//
//////////////////////////////////////////////////////////////////////////////

CHomeNet::CHomeNet()
:   m_pHNWiz(NULL)
{
}   //  CHomeNet::CHomeNet

//////////////////////////////////////////////////////////////////////////////
//
//  ~CHomeNet
//
//  Destructor for CHomeNet.
//
//  parameters:
//      None.
//
//  returns:
//      Nothing.
//
//////////////////////////////////////////////////////////////////////////////

CHomeNet::~CHomeNet()
{
    if (NULL != m_pHNWiz)
    {
        m_pHNWiz->Release();
        m_pHNWiz = NULL;
    }
}   //  CHomeNet::~CHomeNet

//////////////////////////////////////////////////////////////////////////////
//
//  Create
//
//  Initialization for CHomeNet that can fail.
//
//  parameters:
//      None.
//
//  returns:
//      HRESULT returned from CoCreateInstance.
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CHomeNet::Create()
{

    HRESULT             hr = CoCreateInstance(
                                    CLSID_HomeNetworkWizard,
                                    NULL,
                                    CLSCTX_INPROC_SERVER,
                                    IID_PPV_ARG(IHomeNetworkWizard, &m_pHNWiz)
                                    );
    if (FAILED(hr))
    {
        TRACE1(L"Failed to CoCreate CSLID_HomeNetworkWizard (0x%08X)", hr);
        ASSERT(SUCCEEDED(hr));
    }

    return hr;

}   //  CHomeNet::Create


//////////////////////////////////////////////////////////////////////////////
//
//  ConfigureSilently
//
//  Run the Home Networking Wizard sans UI.
//
//  parameters:
//      szConnectoidName Name of the RAS connectoid to be firewalled.
//                       NULL is valid if no connectoid is to be firewalled.
//      pfRebootRequired Return value indicating whether the changes made by
//                       the HNW required a reboot before taking affect.
//
//  returns:
//      E_UNEXPECTED if object has not be initialized
//      E_INVALIDARG if pfRebootRequired is NULL
//      HRESULT returned by IHomeNetWizard::ConfigureSilently
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CHomeNet::ConfigureSilently(
    LPCWSTR             szConnectoidName,
    BOOL*               pfRebootRequired
    )
{
    MYASSERT(IsValid());
    MYASSERT(NULL != pfRebootRequired);

    if (!IsValid())
    {
        return E_UNEXPECTED;
    }

    if (NULL == pfRebootRequired)
    {
        return E_INVALIDARG;
    }

    TRACE(L"Starting IHomeNetWizard::ConfigureSilently()...");

    HRESULT             hr = m_pHNWiz->ConfigureSilently(szConnectoidName,
                                                         HNET_FIREWALLCONNECTION,
                                                         pfRebootRequired
                                                         );
    TRACE(L"    IHomeNetWizard::ConfigureSilently() completed");

    if (FAILED(hr))
    {
        TRACE2(L"IHomeNetWizard::ConfigureSilently(%s) failed (0x%08X)",
               (NULL != szConnectoidName) ? szConnectoidName
                                          : L"No connectoid specified",
               hr
               );
    }

    return hr;

}   //  CHomeNet::ConfigureSilently


//
///// End of file: homenet.cpp   /////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobcomm\icsmgr.h ===
/********
 * Ics APIs
 */

#ifndef  _ICSMGR_H_
#define  _ICSMGR_H_

#include <windows.h>
#include "icsapi.h"

// for IsIcsAvailable()
#define ICSMGR_ICSBOT_CREATED			0x0L
#define ICSMGR_ICSBOT_ALREADY_CREATED	0x1L
#define ICSMGR_ICSBOT_CREATION_FAILED   0x2L

/*
 * ICSLAP_DIAL_STATE - copied from ICS API - error states for ICS connectivity
 */
typedef enum {
 ICSLAP_STARTING = 1,
 ICSLAP_CONNECTING = 2,
 ICSLAP_CONNECTED = 3,
 ICSLAP_DISCONNECTING = 4,
 ICSLAP_DISCONNECTED = 5,
 ICSLAP_STOPPED = 6,
 ICSLAP_PERMANENT = 7,
 ICSLAP_UNK_DIAL_STATE = 8,
 ICSLAP_CALLWAITING = 9, /* may want to pass back other caller's telno */
 ICS_HOMENET_UNAVAILABLE = 1000, /* added by thomasje */
 ICS_TIMEOUT             = 5000  /* added by thomasje */
} ICS_DIAL_STATE;


// callback function prototype used to report connections in ICS
typedef VOID    (CALLBACK*PFN_ICS_CONN_CALLBACK)(ICS_DIAL_STATE);

static BOOL        bIsDialThreadAlive = FALSE;
static BOOL        bReducedCallback   = TRUE;
static ICS_DIAL_STATE    eIcsDialState = ICS_HOMENET_UNAVAILABLE;
static BOOL        bIsBroadbandIcsAvailable    = FALSE;

// thread functions to look for ICS and monitor incoming
// connection broadcast packets.
DWORD	IcsEngine(LPVOID lpParam);
DWORD   WINAPI IcsDialStatusProc(LPVOID lpParam);

enum	ICSSTATUS {		ICS_IS_NOT_AVAILABLE		= 0, 
						ICS_IS_AVAILABLE			= 1, 
						ICS_ENGINE_NOT_COMPLETE		= 1000, 
						ICS_ENGINE_FAILED			= 1001
};

// callback routine used to notify MSOBMAIN about ICS connection changes
VOID    CALLBACK OnIcsConnectionStatus(ICS_DIAL_STATE  dwIcsConnectionStatus);


class CIcsMgr {

public:
	CIcsMgr();
	~CIcsMgr();

	DWORD		CreateIcsBot();
    DWORD       CreateIcsDialMgr();
	BOOL		IsIcsAvailable();
    BOOL        IsCallbackUsed();
    VOID        TriggerIcsCallback(BOOL bStatus);
    ICS_DIAL_STATE      GetIcsDialState () { return eIcsDialState; }
    VOID        NotifyIcsMgr(UINT msg, WPARAM wparam, LPARAM lparam);
    BOOL        IsIcsHostReachable();
    DWORD       RefreshIcsDialStatus();

private:

    // these variables are presently unused.
    // the handles are cleared in the class' destructor.

	HANDLE		m_hBotThread;
	DWORD		m_dwBotThreadId;

    HANDLE      m_hDialThread;
    DWORD       m_dwDialThreadId;



    PFN_ICS_CONN_CALLBACK   m_pfnIcsConn;

};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobcomm\ienews.cpp ===
//****************************************************************************
//
//  Module:     INETCFG.DLL
//  File:       ienews.c
//  Content:    This file contains all the functions that handle importing
//              connection information.
//  History:
//      Sat 10-Mar-1996 23:50:40  -by-  Mark MacLin [mmaclin]
//          this code started its life as ixport.c in RNAUI.DLL
//          my thanks to viroont
//
//  Copyright (c) Microsoft Corporation 1991-1996
//
//****************************************************************************
#include "inetreg.h"
#include "obcomglb.h"


#pragma data_seg(".rdata")


#define REGSTR_PATH_IE_SERVICES         REGSTR_PATH_IEXPLORER L"\\Services"

static const WCHAR cszRegPathIEServices[]       = REGSTR_PATH_IE_SERVICES;
static const WCHAR cszRegValNNTPEnabled[]       = L"NNTP_Enabled";
static const WCHAR cszRegValNNTPUseAuth[]       = L"NNTP_Use_Auth";
static const WCHAR cszRegValNNTPServer[]        = L"NNTP_Server";
static const WCHAR cszRegValNNTPMailName[]      = L"NNTP_MailName";
static const WCHAR cszRegValNNTPMailAddress[]   = L"NNTP_MailAddr";
static const WCHAR cszYes[]                     = L"yes";
static const WCHAR cszNo[]                      = L"no";

#pragma data_seg()

#define PCE_WWW_BASIC 0x13
WCHAR   szNNTP_Resource[] = L"NNTP";
typedef DWORD (APIENTRY *PFNWNETGETCACHEDPASSWORD)(LPSTR, WORD, LPSTR, LPWORD,BYTE);

DWORD MyWNetGetCachedPassword(LPWSTR pbResource, WORD cbResource, LPWSTR pbPassword,
    LPWORD pcchPassword, BYTE   nType)
{
    USES_CONVERSION;
	HINSTANCE hInst = NULL;
	FARPROC fp = NULL;
	DWORD dwRet = 0;
	
	hInst = LoadLibrary(L"MPR.DLL");
	if (hInst)
	{
		fp = GetProcAddress(hInst, "WNetGetCachedPassword");
		if (fp)
			dwRet = ((PFNWNETGETCACHEDPASSWORD)fp) (W2A(pbResource), cbResource, W2A(pbPassword), pcchPassword, nType);
		else
			dwRet = GetLastError();
		FreeLibrary(hInst);
		hInst = NULL;
	} else {
		dwRet = GetLastError();
	}
	return dwRet;
}


typedef DWORD (APIENTRY *PFNWNETCACHEPASSWORD)(LPSTR, WORD, LPSTR, WORD,BYTE,UINT);

DWORD MyWNetCachePassword
(
    LPWSTR szResource,
    WORD   cchResource,
    LPWSTR szPassword,
    WORD   cchPassword,
    BYTE   nType,
    UINT   fnFlags
    )
{
	HINSTANCE hInst = NULL;
	FARPROC fp = NULL;
	DWORD dwRet = 0;
	hInst = LoadLibrary(L"MPR.DLL");
	if (hInst)
	{
        USES_CONVERSION;
		fp = GetProcAddress(hInst, "WNetCachePassword");
		if (fp)
			dwRet = ((PFNWNETCACHEPASSWORD)fp)(W2A(szResource), cchResource, W2A(szPassword), cchPassword,nType,fnFlags);
		else
			dwRet = GetLastError();
		FreeLibrary(hInst);
		hInst = NULL;
		fp = NULL;
	} else {
		dwRet = GetLastError();
	}
	return dwRet;
}


BOOL
SetAuthInfo( WCHAR *szUsername,  WCHAR *szPassword)
{
    int wnet_status;
    WCHAR   szUserInfo[256];
    WORD    cchUserInfo = MAX_CHARS_IN_BUFFER(szUserInfo);

    if (wcschr(szUsername, L':'))  {
        return(FALSE);
    }

    lstrcpy( szUserInfo, szUsername );
    lstrcat( szUserInfo, L":" );
    lstrcat( szUserInfo, szUsername );

     wnet_status = MyWNetCachePassword (szNNTP_Resource, (USHORT   )lstrlen(szNNTP_Resource), szUserInfo, (USHORT)lstrlen( szUserInfo ), PCE_WWW_BASIC, 0);

    return( wnet_status == WN_SUCCESS );
}

DWORD SetIEClientInfo(LPINETCLIENTINFO lpClientInfo)
{
    HKEY hKey;
    DWORD dwRet;
    DWORD dwSize;
    DWORD dwType;

    dwRet = RegCreateKey(HKEY_CURRENT_USER, cszRegPathIEServices, &hKey);
    if (ERROR_SUCCESS != dwRet)
    {
        return dwRet;
    }

    dwSize = max(sizeof(cszYes), sizeof(cszNo));
    dwType = REG_SZ;
    RegSetValueEx(
            hKey,
            cszRegValNNTPEnabled,
            0L,
            dwType,
            (LPBYTE)(*lpClientInfo->szNNTPServer ? cszYes : cszNo),
            dwSize);

    dwSize = max(sizeof(cszYes), sizeof(cszNo));
    dwType = REG_SZ;
    RegSetValueEx(
            hKey,
            cszRegValNNTPUseAuth,
            0L,
            dwType,
            (LPBYTE)((lpClientInfo->dwFlags & INETC_LOGONNEWS) ? cszYes : cszNo),
            dwSize);


    dwSize = sizeof(lpClientInfo->szEMailName);
    dwType = REG_SZ;
    RegSetValueEx(
            hKey,
            cszRegValNNTPMailName,
            0L,
            dwType,
            (LPBYTE)lpClientInfo->szEMailName,
            dwSize);

    dwSize = sizeof(lpClientInfo->szEMailAddress);
    dwType = REG_SZ;
    RegSetValueEx(
            hKey,
            cszRegValNNTPMailAddress,
            0L,
            dwType,
            (LPBYTE)lpClientInfo->szEMailAddress,
            dwSize);


    dwSize = sizeof(lpClientInfo->szNNTPServer);
    dwType = REG_SZ;
    RegSetValueEx(
            hKey,
            cszRegValNNTPServer,
            0L,
            dwType,
            (LPBYTE)lpClientInfo->szNNTPServer,
            dwSize);

    RegCloseKey(hKey);

    SetAuthInfo(lpClientInfo->szNNTPLogonName,  lpClientInfo->szNNTPLogonPassword);
    
    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobcomm\icsapi.h ===
/******************************************************************************
 **
 **  Copyright (c) 1998-1999  Microsoft Corporation
 **
 **  Module Name:
 **
 **      icsapi.h
 **
 **  Abstract:
 **
 **      External header for Internet Connection Sharing API module
 **
 **  Author:
 **
 **      Bruce Johnson (bjohnson)
 **
 **
 **  Environment:
 **
 **      Win32.
 **
 **  Revision History:
 **
 **  Date     Author     Comments	
 **  -------- ---------- ----------------------------------------------------
 **  03/08/99 bjohnson   Created
 **
 ****************************************************************************/

//****************************************************************************
// Defines
//****************************************************************************

//
// ICSAPI32 parameters 
//


//****************************************************************************
// ICS Return Codes
//****************************************************************************

#define ICS_ERROR_SUCCESS               0x00000000
#define ICS_ERROR_FAILURE               0x80000001
#define ICS_ERROR_NOT_IMPLEMENTED       0x80000002
#define ICS_ERROR_NO_MEMORY             0x80000003
#define ICS_ERROR_INVALID_OPTION        0x80000004
#define ICS_ERROR_INVALID_PARAMETER     0x80000005

//****************************************************************************
// Options for IcsSetMapping
//****************************************************************************
#define ICS_PORTMAP_ENABLE                  1
#define ICS_PORTMAP_DISABLE                 2
#define ICS_PORTMAP_DISABLE_ALL             3
#define ICS_PORTMAP_ENABLE_NON_PERSISTENT   4

//****************************************************************************
// Options for IcsDisconnect
//****************************************************************************
#define ICS_DISCONNECT_IMMEDIATELY          0
#define ICS_DISCONNECT_IF_IDLE              1

//****************************************************************************
// Connect status
//****************************************************************************
#define ICS_CONN_STATUS_DISCONNECTED        0
#define ICS_CONN_STATUS_DIALING             1
#define ICS_CONN_STATUS_AUTHENTICATING      2
#define ICS_CONN_STATUS_CONNECTED           3
#define ICS_CONN_STATUS_LINE_IDLE           4

//****************************************************************************
// Autodial configuration
//****************************************************************************
#define ICS_AUTODIAL_OPT_NONE           0x00000000  // No options
#define ICS_AUTODIAL_OPT_NEVER          0x00000001  // Never Autodial
#define ICS_AUTODIAL_OPT_ALWAYS         0x00000002  // Autodial regardless
#define ICS_AUTODIAL_OPT_DEMAND         0x00000004  // Autodial on demand

//****************************************************************************
// Miscellaneous
//****************************************************************************
#define ICS_MAX_NAME          255
#define ICS_MAX_PORTKEY       255
#define ICS_MAX_INDEX         255
#define ICS_DISABLED          0
#define ICS_ENABLED           1

//****************************************************************************
// Typedefs
//****************************************************************************

//
// ICS Machine Information
//

typedef struct  _ICS_MACHINE_INFO {
    WCHAR   szName[ICS_MAX_NAME+1];
    BYTE   bMacAddress[6];
    DWORD  IpAddress;
    DWORD  dwLeaseTime;
    DWORD  dwOptions;
  
} ICS_MACHINE_INFO, *PICS_MACHINE_INFO, *LPICS_MACHINE_INFO;

//
// ICS Client Options
//

typedef struct  _ICS_CLIENT_OPTIONS {
     WCHAR   szName[ICS_MAX_NAME+1];
     DWORD  dwOptions;

} ICS_CLIENT_OPTIONS, *PICS_CLIENT_OPTIONS, *LPICS_CLIENT_OPTIONS;

//
// ICS Port Mapping
//

typedef struct  _ICS_PORT_MAPPING {
     WCHAR   szName[ICS_MAX_NAME+1];
     WCHAR   szPortMapping[ICS_MAX_PORTKEY+1];
     DWORD  dwOptions;

} ICS_PORT_MAPPING, *PICS_PORT_MAPPING, *LPICS_PORT_MAPPING;


//
// ICS Active Port Mapping
//

typedef struct _ICS_ACTIVE_PORT_MAPPING {
    ICS_PORT_MAPPING PortMap;
    ICS_MACHINE_INFO Client;

} ICS_ACTIVE_PORT_MAPPING, *PICS_ACTIVE_PORT_MAPPING, *LPICS_ACTIVE_PORT_MAPPING;


//
// ICS Adapter Information
//

typedef struct  _ICS_ADAPTER {
    WCHAR   szAdapterIndex[ICS_MAX_INDEX+1];

} ICS_ADAPTER, *PICS_ADAPTER, *LPICS_ADAPTER;


//
// ICS General Statistics
//

typedef struct  _ICS_GENERAL_STATISTICS {
    DWORD   dwBytesSent;
    DWORD   dwBytesReceived;
    DWORD   dwActiveClients;
    DWORD   dwActivePortMappings;
    DWORD   dwUpTime;
    DWORD   dwStatusFlags;
    WCHAR    szAutodialMachine [ICS_MAX_NAME+1];

} ICS_GENERAL_STATISTICS, *PICS_GENERAL_STATISTICS, *LPICS_GENERAL_STATISTICS;

//
// ICS General Configuration
//

typedef struct  _ICS_GENERAL_CONFIGURATION {
    DWORD  dwEnabled;
    DWORD  dwShowTrayIcon;
    DWORD  dwDHCPEnabled;
    DWORD  dwDNSEnabled;
    DWORD  dwLoggingEnabled;
    DWORD  dwDHCPSubnet;
    DWORD  dwDHCPServerAddress;
    DWORD  dwOptions;
    DWORD  dwAutodialEnabled;
    DWORD  dwAutodialTimeout;
    WCHAR   szAutodialConnection [ICS_MAX_NAME+1];
    WCHAR   szInternetAdapter [ICS_MAX_INDEX+1];
    WCHAR   szHomeNetworkAdapter [ICS_MAX_INDEX+1];

} ICS_GENERAL_CONFIGURATION, *PICS_GENERAL_CONFIGURATION, *LPICS_GENERAL_CONFIGURATION;

typedef struct _ICS_GENERAL_CONFIGURATION ICS_CONFIG, *PICS_CONFIG, *LPICS_CONFIG;


typedef enum {
    ICS_MSG_CONNECT_STATUS_CHANGE,
    ICS_MSG_ICS_STATUS_CHANGE,
} ICS_MESSAGE_TYPE;

typedef struct 
{
    DWORD       dwConnectStatus;
    DWORD       dwLastError;
} ICS_MSG_CONNECT_STATUS_CHANGE_INFO;

typedef struct
{
    DWORD       dwIcsStatus;
} ICS_MSG_ICS_STATUS_CHANGE_INFO;

typedef struct _ICS_MESSAGE {
    ICS_MESSAGE_TYPE    Type;
    union
    {
        ICS_MSG_CONNECT_STATUS_CHANGE_INFO  IcsConnectStatusChangeInfo;
        ICS_MSG_ICS_STATUS_CHANGE_INFO      IcsStatusChangeInfo;
    } MsgSpecific;
} ICS_MESSAGE, *LPICS_MESSAGE;

#define IM_dwConnectStatus  MsgSpecific.IcsConnectStatusChangeInfo.dwConnectStatus
#define IM_dwLastError      MsgSpecific.IcsConnectStatusChangeInfo.dwLastError
#define IM_dwIcsStatus      MsgSpecific.IcsStatusChangeInfo.dwIcsStatus

typedef VOID (WINAPI *ICS_MSG_NOTIFIER_FN)(LPICS_MESSAGE pIcsMsg);

//****************************************************************************
//
// Prototypes
//
//****************************************************************************


//****************************************************************************
// Configuration API's
//****************************************************************************


DWORD APIENTRY 
IcsGetConfiguration(
    LPICS_CONFIG lpIcsConfig
    );


DWORD APIENTRY 
IcsSetConfiguration(
    LPICS_CONFIG lpIcsConfig
    );


DWORD APIENTRY 
IcsGetAdapterList(
    LPICS_ADAPTER lpIcsAdapterList, 
    LPDWORD lpdwBufferSize
    );


DWORD APIENTRY 
IcsSetInternetConnection(
    LPICS_ADAPTER lpIcsAdapter
    );


DWORD APIENTRY 
IcsSetHomenetConnection(
    LPICS_ADAPTER lpIcsAdapter
    );


DWORD APIENTRY 
IcsEnumerateInstalledMappings(
    LPICS_PORT_MAPPING lpIcsPortMappings,
    LPDWORD lpdwBufferSize
    );

DWORD APIENTRY 
IcsGetAutodialEnable(LPDWORD lpdwOpt) ;

//****************************************************************************
// Management API's
//****************************************************************************


DWORD APIENTRY 
IcsConnect(
    LPWSTR                 lpszPhonebook,
    BOOL                  Synchronous
    );


DWORD APIENTRY
IcsDisconnect(
    DWORD                 dwOptions
    );


DWORD APIENTRY 
IcsEnable(
    DWORD                 dwOptions
    );


DWORD APIENTRY 
IcsDisable(
    DWORD                 dwOptions
    );


DWORD APIENTRY 
IcsGetStatistics(
    LPICS_GENERAL_STATISTICS  lpIcsGeneralStats
    );


DWORD APIENTRY 
IcsEnumerateClients(
    LPICS_MACHINE_INFO    lpIcsClients, 
    LPDWORD               lpdwBufferSize
    );


DWORD APIENTRY 
IcsEnumerateActiveMappings(
    LPICS_ACTIVE_PORT_MAPPING   lpIcsActiveMappings, 
    LPDWORD                     lpdwBufferSize
    );


DWORD APIENTRY 
IcsSetMapping(
    LPICS_MACHINE_INFO    lpIcsClient,  
    LPICS_PORT_MAPPING    lpIcsPortMap, 
    DWORD                 dwOptions
    );


DWORD APIENTRY 
IcsGetClientOptions(
    LPICS_MACHINE_INFO    lpIcsClient,
    LPICS_CLIENT_OPTIONS  lpIcsClientOptions
    );


DWORD APIENTRY 
IcsSetClientOptions(
    LPICS_MACHINE_INFO    lpIcsClient,
    LPICS_CLIENT_OPTIONS  lpIcsClientOptions
    );

DWORD APIENTRY 
IcsGetConnectStatus(
    LPDWORD                 lpdwConnectStatus,
    LPDWORD                 lpdwLastError
    );


DWORD APIENTRY    
IcsRegisterNotifierCallback(
    LPVOID  fnNotifier,
    DWORD   Options
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobcomm\iclient.cpp ===
//****************************************************************************
//
//  Module:     INETCFG.DLL
//  File:       iclient.c
//  Content:    This file contains all the functions that handle importing
//              client information.
//  History:
//      Sat 10-Mar-1996 23:50:40  -by-  Mark MacLin [mmaclin]
//  96/03/13  markdu  Assimilated with inetcfg.dll.
//  96/03/20  markdu  Combined export.h and iclient.h into inetcfg.h
//  96/04/18  markdu  NASH BUG 18443
//
//  Copyright (c) Microsoft Corporation 1991-1996
//
//****************************************************************************

//#include "wizard.h"
//#include "inetcfg.h"
#include "obcomglb.h"

#define REGSTR_PATH_INTERNET_CLIENT     L"Software\\Microsoft\\Internet ClientX"

#pragma data_seg(".rdata")

// registry constants
static const WCHAR cszRegPathInternetClient[] =  REGSTR_PATH_INTERNET_CLIENT;

static const WCHAR cszRegValEMailName[] =           L"EMail_Name";
static const WCHAR cszRegValEMailAddress[] =        L"EMail_Address";
static const WCHAR cszRegValPOPLogonRequired[] =    L"POP_Logon_Required";
static const WCHAR cszRegValPOPLogonName[] =        L"POP_Logon_Name";
static const WCHAR cszRegValPOPLogonPassword[] =    L"POP_Logon_Password";
static const WCHAR cszRegValPOPServer[] =           L"POP_Server";
static const WCHAR cszRegValSMTPServer[] =          L"SMTP_Server";
static const WCHAR cszRegValNNTPLogonRequired[] =   L"NNTP_Logon_Required";
static const WCHAR cszRegValNNTPLogonName[] =       L"NNTP_Logon_Name";
static const WCHAR cszRegValNNTPLogonPassword[] =   L"NNTP_Logon_Password";
static const WCHAR cszRegValNNTPServer[] =          L"NNTP_Server";
static const WCHAR cszNull[] = L"";
static const WCHAR cszYes[] = L"yes";
static const WCHAR cszNo[] = L"no";

#pragma data_seg()

//*******************************************************************
//
//  FUNCTION:   InetGetClientInfo
//
//  PURPOSE:    This function will get the internet client params
//              from the registry
//
//  PARAMETERS: lpClientInfo - on return, this structure will contain
//              the internet client params as set in the registry.
//              lpszProfileName - Name of client info profile to
//              retrieve.  If this is NULL, the default profile is used.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

extern HRESULT WINAPI InetGetClientInfo(
  LPCWSTR            lpszProfileName,
  LPINETCLIENTINFO  lpClientInfo)
{
    HKEY hKey;
    DWORD dwRet;
    DWORD dwSize;
    DWORD dwType;
    DWORD dwVal;

    if (sizeof(INETCLIENTINFO) > lpClientInfo->dwSize)
    {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    dwRet = RegOpenKey(HKEY_CURRENT_USER, cszRegPathInternetClient, &hKey);
    if (ERROR_SUCCESS != dwRet)
    {
        return dwRet;
    }

    lpClientInfo->dwFlags = 0;

    dwSize = sizeof(dwVal);
    dwType = REG_DWORD;
    RegQueryValueEx(
            hKey,
            cszRegValPOPLogonRequired,
            0L,
            &dwType,
            (LPBYTE)&dwVal,
            &dwSize);

    if (dwVal)
    {
        lpClientInfo->dwFlags |= INETC_LOGONMAIL;
    }

    dwSize = sizeof(dwVal);
    dwType = REG_DWORD;
    RegQueryValueEx(
            hKey,
            cszRegValNNTPLogonRequired,
            0L,
            &dwType,
            (LPBYTE)&dwVal,
            &dwSize);

    if (dwVal)
    {
        lpClientInfo->dwFlags |= INETC_LOGONNEWS;
    }

    dwSize = sizeof(lpClientInfo->szEMailName);
    dwType = REG_SZ;
    RegQueryValueEx(
            hKey,
            cszRegValEMailName,
            0L,
            &dwType,
            (LPBYTE)lpClientInfo->szEMailName,
            &dwSize);

    dwSize = sizeof(lpClientInfo->szEMailAddress);
    dwType = REG_SZ;
    RegQueryValueEx(
            hKey,
            cszRegValEMailAddress,
            0L,
            &dwType,
            (LPBYTE)lpClientInfo->szEMailAddress,
            &dwSize);

    dwSize = sizeof(lpClientInfo->szPOPServer);
    dwType = REG_SZ;
    RegQueryValueEx(
            hKey,
            cszRegValPOPServer,
            0L,
            &dwType,
            (LPBYTE)lpClientInfo->szPOPServer,
            &dwSize);

    dwSize = sizeof(lpClientInfo->szSMTPServer);
    dwType = REG_SZ;
    RegQueryValueEx(
            hKey,
            cszRegValSMTPServer,
            0L,
            &dwType,
            (LPBYTE)lpClientInfo->szSMTPServer,
            &dwSize);

    dwSize = sizeof(lpClientInfo->szNNTPServer);
    dwType = REG_SZ;
    RegQueryValueEx(
            hKey,
            cszRegValNNTPServer,
            0L,
            &dwType,
            (LPBYTE)lpClientInfo->szNNTPServer,
            &dwSize);

    RegCloseKey(hKey);

    return ERROR_SUCCESS;
}


//*******************************************************************
//
//  FUNCTION:   InetSetClientInfo
//
//  PURPOSE:    This function will set the internet client params
//
//  PARAMETERS: lpClientInfo - pointer to struct with info to set
//              in the registry.
//              lpszProfileName - Name of client info profile to
//              modify.  If this is NULL, the default profile is used.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//*******************************************************************

HRESULT WINAPI InetSetClientInfo(
  LPCWSTR            lpszProfileName,
  LPINETCLIENTINFO  lpClientInfo)
{
    HKEY hKey;
    DWORD dwRet;
    DWORD dwSize;
    DWORD dwType;
    DWORD dwVal;

    if (sizeof(INETCLIENTINFO) > lpClientInfo->dwSize)
    {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    dwRet = RegCreateKey(HKEY_CURRENT_USER, cszRegPathInternetClient, &hKey);
    if (ERROR_SUCCESS != dwRet)
    {
        return dwRet;
    }

    dwVal = lpClientInfo->dwFlags & INETC_LOGONMAIL ? 1 : 0;
    dwSize = sizeof(dwVal);
    dwType = REG_DWORD;
    RegSetValueEx(
            hKey,
            cszRegValPOPLogonRequired,
            0L,
            dwType,
            (LPBYTE)&dwVal,
            dwSize);

    dwVal = lpClientInfo->dwFlags & INETC_LOGONNEWS ? 1 : 0;
    dwSize = sizeof(dwVal);
    dwType = REG_DWORD;
    RegSetValueEx(
            hKey,
            cszRegValNNTPLogonRequired,
            0L,
            dwType,
            (LPBYTE)&dwVal,
            dwSize);

    dwSize = sizeof(lpClientInfo->szEMailName);
    dwType = REG_SZ;
    RegSetValueEx(
            hKey,
            cszRegValEMailName,
            0L,
            dwType,
            (LPBYTE)lpClientInfo->szEMailName,
            dwSize);

    dwSize = sizeof(lpClientInfo->szEMailAddress);
    dwType = REG_SZ;
    RegSetValueEx(
            hKey,
            cszRegValEMailAddress,
            0L,
            dwType,
            (LPBYTE)lpClientInfo->szEMailAddress,
            dwSize);

    dwSize = sizeof(lpClientInfo->szPOPServer);
    dwType = REG_SZ;
    RegSetValueEx(
            hKey,
            cszRegValPOPServer,
            0L,
            dwType,
            (LPBYTE)lpClientInfo->szPOPServer,
            dwSize);

    dwSize = sizeof(lpClientInfo->szSMTPServer);
    dwType = REG_SZ;
    RegSetValueEx(
            hKey,
            cszRegValSMTPServer,
            0L,
            dwType,
            (LPBYTE)lpClientInfo->szSMTPServer,
            dwSize);

    dwSize = sizeof(lpClientInfo->szNNTPServer);
    dwType = REG_SZ;
    RegSetValueEx(
            hKey,
            cszRegValNNTPServer,
            0L,
            dwType,
            (LPBYTE)lpClientInfo->szNNTPServer,
            dwSize);

    RegCloseKey(hKey);

    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobcomm\import.h ===
// Import.h: interface for the CISPImport class.
//
//////////////////////////////////////////////////////////////////////

#ifndef _IMPORT_
#define _IMPORT_

#include "obcomglb.h"

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define IDS_DEFAULT_SCP         0
#define IDS_INI_SCRIPT_DIR      1
#define IDS_INI_SCRIPT_SHORTDIR 2

#define MAXLONGLEN      80
#define MAXNAME         80

#define MAXIPADDRLEN    20
#define SIZE_ReadBuf    0x00008000    // 32K buffer size

#define AUTORUNSIGNUPWIZARDAPI "InetConfigClient"

// BUGBUG: Does PFNAUTORUNSIGNUPWIZARD get called anywhere?
typedef HRESULT (WINAPI *PFNAUTORUNSIGNUPWIZARD) (HWND hwndParent,
                                                  LPCSTR lpszPhoneBook,
                                                  LPCSTR lpszConnectoidName,
                                                  LPRASENTRY lpRasEntry,
                                                  LPCSTR lpszUsername,
                                                  LPCSTR lpszPassword,
                                                  LPCSTR lpszProfileName,
                                                  LPINETCLIENTINFO lpINetClientInfo,
                                                  DWORD dwfOptions,
                                                  LPBOOL lpfNeedsRestart);


#define DUN_NOPHONENUMBER L"000000000000"

class CISPImport  
{
public:
    CISPImport();
    virtual ~CISPImport();
    void    set_hWndMain(HWND   hWnd)
    {
        m_hWndMain = hWnd;
    };

    DWORD RnaValidateImportEntry (LPCWSTR szFileName);
    HRESULT ImportConnection (LPCWSTR szFileName, LPWSTR pszEntryName, LPWSTR pszSupportNumber, LPWSTR pszUserName, LPWSTR pszPassword, LPBOOL pfNeedsRestart);
    BOOL GetDeviceSelectedByUser (LPWSTR szKey, LPWSTR szBuf, DWORD dwSize);
    BOOL SetDeviceSelectedByUser (LPWSTR szKey, LPWSTR szBuf);
    BOOL DeleteUserDeviceSelection(LPWSTR szKey);
    DWORD ConfigRasEntryDevice( LPRASENTRY lpRasEntry );

    WCHAR m_szDeviceName[RAS_MaxDeviceName + 1]; //holds the user's modem choice when multiple
    WCHAR m_szDeviceType[RAS_MaxDeviceType + 1]; // modems are installed
    WCHAR m_szConnectoidName[RAS_MaxEntryName+1];

    HWND m_hWndMain;
    
    BOOL m_bIsISDNDevice;
};

#endif // !defined()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobcomm\import.cpp ===
// Import.cpp: implementation of the CISPImport class.
//
//////////////////////////////////////////////////////////////////////

//#include "stdafx.h"
//#include "appdefs.h"
//#include "icwhelp.h"
#include "import.h"
#include "rnaapi.h"

#ifdef DBG
#undef THIS_FILE
static CHAR THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

#pragma data_seg(".rdata")

WCHAR cszEntrySection[]     = L"Entry";
WCHAR cszAlias[]            = L"Import_Name";
WCHAR cszML[]               = L"Multilink";

WCHAR cszPhoneSection[]     = L"Phone";
WCHAR cszDialAsIs[]         = L"Dial_As_Is";
WCHAR cszPhone[]            = L"Phone_Number";
WCHAR cszISDN[]             = L"ISDN_Number";
WCHAR cszAreaCode[]         = L"Area_Code";
WCHAR cszCountryCode[]      = L"Country_Code";
WCHAR cszCountryID[]        = L"Country_ID";

WCHAR cszDeviceSection[]    = L"Device";
WCHAR cszDeviceType[]       = L"Type";
WCHAR cszDeviceName[]       = L"Name";
WCHAR cszDevCfgSize[]       = L"Settings_Size";
WCHAR cszDevCfg[]           = L"Settings";

WCHAR cszServerSection[]    = L"Server";
WCHAR cszServerType[]       = L"Type";
WCHAR cszSWCompress[]       = L"SW_Compress";
WCHAR cszPWEncrypt[]        = L"PW_Encrypt";
WCHAR cszNetLogon[]         = L"Network_Logon";
WCHAR cszSWEncrypt[]        = L"SW_Encrypt";
WCHAR cszNetBEUI[]          = L"Negotiate_NetBEUI";
WCHAR cszIPX[]              = L"Negotiate_IPX/SPX";
WCHAR cszIP[]               = L"Negotiate_TCP/IP";
WCHAR cszDisableLcp[]       = L"Disable_LCP";

WCHAR cszIPSection[]        = L"TCP/IP";
WCHAR cszIPSpec[]           = L"Specify_IP_Address";
WCHAR cszIPAddress[]        = L"IP_address";
WCHAR cszServerSpec[]       = L"Specify_Server_Address";
WCHAR cszDNSAddress[]       = L"DNS_address";
WCHAR cszDNSAltAddress[]    = L"DNS_Alt_address";
WCHAR cszWINSAddress[]      = L"WINS_address";
WCHAR cszWINSAltAddress[]   = L"WINS_Alt_address";
WCHAR cszIPCompress[]       = L"IP_Header_Compress";
WCHAR cszWanPri[]           = L"Gateway_On_Remote";

WCHAR cszMLSection[]        = L"Multilink";
WCHAR cszLinkIndex[]        = L"Line_%s";

WCHAR cszScriptingSection[] = L"Scripting";
WCHAR cszScriptName[]       = L"Name";

WCHAR cszScriptSection[]    = L"Script_File";

WCHAR cszYes[]              = L"yes";
WCHAR cszNo[]               = L"no";

WCHAR cszUserSection[]      = L"User";
WCHAR cszUserName[]         = L"Name";
WCHAR cszPassword[]         = L"Password";

WCHAR szNull[]              = L"";

WCHAR cszSupport[]          = L"Support";
WCHAR cszSupportNumber[]    = L"SupportPhoneNumber";

SERVER_TYPES aServerTypes[] =
{ 
    {L"PPP",     RASFP_Ppp,  0                          },
    {L"SLIP",    RASFP_Slip, 0                          },
    {L"CSLIP",   RASFP_Slip, RASEO_IpHeaderCompression  },
    {L"RAS",     RASFP_Ras,  0                          }
};


#pragma data_seg()


WCHAR g_szDeviceName[RAS_MaxDeviceName + 1] = L"\0"; //holds the user's modem choice when multiple
WCHAR g_szDeviceType[RAS_MaxDeviceType + 1] = L"\0"; // modems are installed
#define ISIGNUP_KEY L"Software\\Microsoft\\ISIGNUP"
#define DEVICENAMEKEY L"DeviceName"
#define DEVICETYPEKEY L"DeviceType"

static const WCHAR cszInetcfg[] = L"Inetcfg.dll";
static const CHAR cszSetAutoProxyConnectoid[] = "SetAutoProxyConnectoid";
typedef HRESULT (WINAPI * SETAUTOPROXYCONNECTOID) (IN BOOL bEnable);
extern int FIsDigit( int c );

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CISPImport::CISPImport()
{

    m_szDeviceName[0] = L'\0'; 
    m_szDeviceType[0] = L'\0';
    m_szConnectoidName[0] = L'\0';
    m_bIsISDNDevice = FALSE;
}

CISPImport::~CISPImport()
{
    // Clean up the registry
    DeleteUserDeviceSelection(DEVICENAMEKEY);
    DeleteUserDeviceSelection(DEVICETYPEKEY);
}

//+----------------------------------------------------------------------------
// DWORD NEAR PASCAL StrToip (LPWSTR szIPAddress, LPDWORD lpdwAddr)
//
// This function converts a IP address string to an IP address structure.
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Cloned from SMMSCRPT.
//  1/9/98  DONALDM     adapted from ICWCONN1
//+----------------------------------------------------------------------------
LPCWSTR NEAR PASCAL StrToSubip (LPCWSTR szIPAddress, LPBYTE pVal)
{
  LPCWSTR pszIP = szIPAddress;

  *pVal = (BYTE)Sz2W(pszIP);
  // skip over digits
  while (FIsDigit(*pszIP))
  {
    ++pszIP;
  }

  // skip over one or more separators
  while (*pszIP && !FIsDigit(*pszIP))
  {
    ++pszIP;
  }

  return pszIP;
}


DWORD NEAR PASCAL StrToip (LPCWSTR szIPAddress, RASIPADDR FAR *ipAddr)
{
  LPCWSTR pszIP = szIPAddress;

  pszIP = StrToSubip(pszIP, &ipAddr->a);
  pszIP = StrToSubip(pszIP, &ipAddr->b);
  pszIP = StrToSubip(pszIP, &ipAddr->c);
  pszIP = StrToSubip(pszIP, &ipAddr->d);

  return ERROR_SUCCESS;
}


//****************************************************************************
// DWORD NEAR PASCAL ImportPhoneInfo(PPHONENUM ppn, LPCWSTR szFileName)
//
// This function imports the phone number.
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************
DWORD NEAR PASCAL ImportPhoneInfo(LPRASENTRY lpRasEntry, LPCWSTR szFileName, BOOL bISDN)
{
  WCHAR   szYesNo[MAXNAME];

  if (!GetPrivateProfileString(cszPhoneSection,
                          (bISDN ? cszISDN : cszPhone),
                          szNull,
                          lpRasEntry->szLocalPhoneNumber,
                          MAX_CHARS_IN_BUFFER(lpRasEntry->szLocalPhoneNumber),
                          szFileName))
  {
      // If the ISDN_Number is empty, we read from the Phone_Number
      GetPrivateProfileString(cszPhoneSection,
                              cszPhone,
                              DUN_NOPHONENUMBER,
                              lpRasEntry->szLocalPhoneNumber,
                              MAX_CHARS_IN_BUFFER(lpRasEntry->szLocalPhoneNumber),
                              szFileName);
  }

  lpRasEntry->dwfOptions &= ~RASEO_UseCountryAndAreaCodes;

  GetPrivateProfileString(cszPhoneSection,
                          cszDialAsIs,
                          cszYes,
                          szYesNo,
                          MAX_CHARS_IN_BUFFER(szYesNo),
                          szFileName);

  // Do we have to get country code and area code?
  //
  if (!lstrcmpi(szYesNo, cszNo))
  {

    // If we cannot get the country ID or it is zero, default to dial as is
    //
    if ((lpRasEntry->dwCountryID = GetPrivateProfileInt(cszPhoneSection,
                                                 cszCountryID,
                                                 0,
                                                 szFileName)) != 0)
    {
      lpRasEntry->dwCountryCode = GetPrivateProfileInt(cszPhoneSection,
                                                cszCountryCode,
                                                1,
                                                szFileName);

      if (GetPrivateProfileString(cszPhoneSection,
                              cszAreaCode,
                              szNull,
                              lpRasEntry->szAreaCode,
                              MAX_CHARS_IN_BUFFER(lpRasEntry->szAreaCode),
                              szFileName) != 0)
      {
        lpRasEntry->dwfOptions |= RASEO_UseCountryAndAreaCodes;
      }
    }
  }
  return ERROR_SUCCESS;
}

//****************************************************************************
// DWORD NEAR PASCAL ImportServerInfo(PSMMINFO psmmi, LPWSTR szFileName)
//
// This function imports the server type name and settings.
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************
DWORD NEAR PASCAL ImportServerInfo(LPRASENTRY lpRasEntry, LPCWSTR szFileName)
{
  WCHAR   szYesNo[MAXNAME];
  WCHAR   szType[MAXNAME];
  DWORD  i;

  // Get the server type name
  //
  GetPrivateProfileString(cszServerSection,
                          cszServerType,
                          szNull,
                          szType,
                          MAX_CHARS_IN_BUFFER(szType),
                          szFileName);

  // need to convert the string into
  // one of the following values
  //   RASFP_Ppp
  //   RASFP_Slip  Note CSLIP is SLIP with IP compression on
  //   RASFP_Ras

  for (i = 0; i < NUM_SERVER_TYPES; ++i)
  {
    if (!lstrcmpi(aServerTypes[i].szType, szType))
    {
       lpRasEntry->dwFramingProtocol = aServerTypes[i].dwType;
       lpRasEntry->dwfOptions |= aServerTypes[i].dwfOptions;
       break;
    }
  }

  // Get the server type settings
  //
  if (GetPrivateProfileString(cszServerSection,
                              cszSWCompress,
                              szNull,
                              szYesNo,
                              MAX_CHARS_IN_BUFFER(szYesNo),
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
      lpRasEntry->dwfOptions &= ~RASEO_SwCompression;
    }
    else
    {
      lpRasEntry->dwfOptions |= RASEO_SwCompression;
    };
  };

  if (GetPrivateProfileString(cszServerSection,
                              cszPWEncrypt,
                              szNull,
                              szYesNo,
                              MAX_CHARS_IN_BUFFER(szYesNo),
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
      lpRasEntry->dwfOptions &= ~RASEO_RequireEncryptedPw;
    }
    else
    {
      lpRasEntry->dwfOptions |= RASEO_RequireEncryptedPw;
    };
  };

  if (GetPrivateProfileString(cszServerSection,
                              cszNetLogon,
                              szNull,
                              szYesNo,
                              MAX_CHARS_IN_BUFFER(szYesNo),
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
      lpRasEntry->dwfOptions &= ~RASEO_NetworkLogon;
    }
    else
    {
      lpRasEntry->dwfOptions |= RASEO_NetworkLogon;
    };
  };

  if (GetPrivateProfileString(cszServerSection,
                              cszSWEncrypt,
                              szNull,
                              szYesNo,
                              MAX_CHARS_IN_BUFFER(szYesNo),
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
      lpRasEntry->dwfOptions &= ~RASEO_RequireDataEncryption;
    }
    else
    {
      lpRasEntry->dwfOptions |= RASEO_RequireDataEncryption;
    };
  };

  // Get the protocol settings
  //
  if (GetPrivateProfileString(cszServerSection,
                              cszNetBEUI,
                              szNull,
                              szYesNo,
                              MAX_CHARS_IN_BUFFER(szYesNo),
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
        lpRasEntry->dwfNetProtocols &= ~RASNP_NetBEUI;
    }
    else
    {
        lpRasEntry->dwfNetProtocols |= RASNP_NetBEUI;
    };
  };

  if (GetPrivateProfileString(cszServerSection,
                              cszIPX,
                              szNull,
                              szYesNo,
                              MAX_CHARS_IN_BUFFER(szYesNo),
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
        lpRasEntry->dwfNetProtocols &= ~RASNP_Ipx;
    }
    else
    {
        lpRasEntry->dwfNetProtocols |= RASNP_Ipx;
    };
  };

  if (GetPrivateProfileString(cszServerSection,
                              cszIP,
                              szNull,
                              szYesNo,
                              MAX_CHARS_IN_BUFFER(szYesNo),
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
        lpRasEntry->dwfNetProtocols &= ~RASNP_Ip;
    }
    else
    {
        lpRasEntry->dwfNetProtocols |= RASNP_Ip;
    };
  };

  if (GetPrivateProfileString(cszServerSection,
                              cszDisableLcp,
                              szNull,
                              szYesNo,
                              MAX_CHARS_IN_BUFFER(szYesNo),
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszYes))
    {
        lpRasEntry->dwfOptions |= RASEO_DisableLcpExtensions;
    }
    else
    {
        lpRasEntry->dwfOptions &= ~RASEO_DisableLcpExtensions;
    }
  };
  return ERROR_SUCCESS;
}

//****************************************************************************
// DWORD NEAR PASCAL ImportIPInfo(LPWSTR szEntryName, LPWSTR szFileName)
//
// This function imports the TCP/IP information
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************
DWORD NEAR PASCAL ImportIPInfo(LPRASENTRY lpRasEntry, LPCWSTR szFileName)
{
  WCHAR   szIPAddr[MAXIPADDRLEN];
  WCHAR   szYesNo[MAXNAME];

  // Import IP address information
  //
  if (GetPrivateProfileString(cszIPSection,
                              cszIPSpec,
                              szNull,
                              szYesNo,
                              MAX_CHARS_IN_BUFFER(szYesNo),
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszYes))
    {
      // The import file has IP address specified, get the IP address
      //
      lpRasEntry->dwfOptions |= RASEO_SpecificIpAddr;
      if (GetPrivateProfileString(cszIPSection,
                                  cszIPAddress,
                                  szNull,
                                  szIPAddr,
                                  MAX_CHARS_IN_BUFFER(szIPAddr),
                                  szFileName))
      {
        StrToip (szIPAddr, &lpRasEntry->ipaddr);
      };
    }
    else
    {
      lpRasEntry->dwfOptions &= ~RASEO_SpecificIpAddr;
    };
  };

  // Import Server address information
  //
  if (GetPrivateProfileString(cszIPSection,
                              cszServerSpec,
                              szNull,
                              szYesNo,
                              MAX_CHARS_IN_BUFFER(szYesNo),
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszYes))
    {
      // The import file has server address specified, get the server address
      //
      lpRasEntry->dwfOptions |= RASEO_SpecificNameServers;
      if (GetPrivateProfileString(cszIPSection,
                                  cszDNSAddress,
                                  szNull,
                                  szIPAddr,
                                  MAX_CHARS_IN_BUFFER(szIPAddr),
                                  szFileName))
      {
        StrToip (szIPAddr, &lpRasEntry->ipaddrDns);
      };

      if (GetPrivateProfileString(cszIPSection,
                                  cszDNSAltAddress,
                                  szNull,
                                  szIPAddr,
                                  MAX_CHARS_IN_BUFFER(szIPAddr),
                                  szFileName))
      {
        StrToip (szIPAddr, &lpRasEntry->ipaddrDnsAlt);
      };

      if (GetPrivateProfileString(cszIPSection,
                                  cszWINSAddress,
                                  szNull,
                                  szIPAddr,
                                  MAX_CHARS_IN_BUFFER(szIPAddr),
                                  szFileName))
      {
        StrToip (szIPAddr, &lpRasEntry->ipaddrWins);
      };

      if (GetPrivateProfileString(cszIPSection,
                                  cszWINSAltAddress,
                                  szNull,
                                  szIPAddr,
                                  MAX_CHARS_IN_BUFFER(szIPAddr),
                                  szFileName))
      {
        StrToip (szIPAddr, &lpRasEntry->ipaddrWinsAlt);
      };
    }
    else
    {
      lpRasEntry->dwfOptions &= ~RASEO_SpecificNameServers;
    };
  };

  // Header compression and the gateway settings
  //
  if (GetPrivateProfileString(cszIPSection,
                              cszIPCompress,
                              szNull,
                              szYesNo,
                              MAX_CHARS_IN_BUFFER(szYesNo),
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
      lpRasEntry->dwfOptions &= ~RASEO_IpHeaderCompression;
    }
    else
    {
      lpRasEntry->dwfOptions |= RASEO_IpHeaderCompression;
    };
  };

  if (GetPrivateProfileString(cszIPSection,
                              cszWanPri,
                              szNull,
                              szYesNo,
                              MAX_CHARS_IN_BUFFER(szYesNo),
                              szFileName))
  {
    if (!lstrcmpi(szYesNo, cszNo))
    {
      lpRasEntry->dwfOptions &= ~RASEO_RemoteDefaultGateway;
    }
    else
    {
      lpRasEntry->dwfOptions |= RASEO_RemoteDefaultGateway;
    };
  };

  return ERROR_SUCCESS;
}

//****************************************************************************
// HANDLE NEAR PASCAL CreateUniqueFile(LPWSTR szPath, LPWSTR szFile)
//
// This function creates a unique file. If the file already exists, it will
// try to create a file with similar name and return the name.
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HANDLE NEAR PASCAL CreateUniqueFile(LPWSTR szPath, LPWSTR szScript)
{
  HANDLE hFile; 

  LPWSTR  pszSuffix, lpsz;
  UINT   uSuffix;

  pszSuffix = szPath + lstrlen(szPath); 
  
  lpsz = CharPrev(szPath, pszSuffix);
  
  if (*lpsz != L'\\')
  {
    *pszSuffix = L'\\';
    pszSuffix++;
  };
  lstrcpy(pszSuffix, szScript);

  // Try the specified filename
  //
  hFile = CreateFile(szPath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS,
                         FILE_ATTRIBUTE_NORMAL, NULL);
                     

  // If the file exists
  //
    if ((hFile == INVALID_HANDLE_VALUE) && (GetLastError() == ERROR_FILE_EXISTS))
  {
    WCHAR szNewName[MAX_PATH];

    // Need to copy it to another name in the same directory
    //
    if (LoadString(NULL, IDS_DEFAULT_SCP, szNewName, MAX_CHARS_IN_BUFFER(szNewName)))
    {
      // Increment the file index until a non-duplicated file can be created
      //
      uSuffix = 0;
      do
      {
        wsprintf(pszSuffix, szNewName, uSuffix);
        uSuffix++;
        hFile = CreateFile(szPath, GENERIC_WRITE, 0, NULL, CREATE_NEW,
                               FILE_ATTRIBUTE_NORMAL, NULL);

      } 
      while ((hFile == INVALID_HANDLE_VALUE) &&
             (GetLastError() == ERROR_FILE_EXISTS) &&
             (uSuffix < 0x0000FFFF)); 
    };
  };

  // If we do not have the file, reserve the pathname
  //
  if (hFile == INVALID_HANDLE_VALUE)
  {
    *pszSuffix = L'\0';
  };
  return hFile;
}

//****************************************************************************
// HANDLE NEAR PASCAL CreateScriptFile(LPWSTR szScript, LPWSTR szImportFile)
//
// This function creates the script file
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

HANDLE NEAR PASCAL CreateScriptFile(LPWSTR szScript, LPCWSTR szImportFile)
{
  LPWSTR pszPath, pszShortName;
  LPWSTR pszDir;
  DWORD cb;
  HANDLE hFile;

  // Assume failure
  //
  hFile = INVALID_HANDLE_VALUE;

  // Allocate a buffer for pathname
  //
  if ((pszPath = (LPWSTR)GlobalAlloc(GPTR, (2*MAX_PATH)*sizeof(WCHAR))) == NULL)
  {
      ////TraceMsg(TF_GENERAL, L"CONNECT:CreateScriptFile(): Local Alloc failed\n");
      return hFile;
  }
  pszShortName = pszPath+MAX_PATH;

  // Get the default directory
  //
  if (GetWindowsDirectory(pszPath, MAX_PATH) != 0)
  {
    // Get the Windows drive
    //
    pszDir = pszPath;
    while((*pszDir != L'\\') && (*pszDir != L'\0'))
    {
      pszDir = CharNext(pszDir);
    };

    // Did we find Windows drive?
    //
    if (*pszDir != L'\0')
    {
      // Prepare the drive
      //
      cb = (DWORD)(pszDir - pszPath);
      MyMemCpy((LPBYTE) szScript, (const LPBYTE) pszPath, (size_t) cb);
      pszDir = szScript + cb;

      // Get the script filename
      //
      if (GetPrivateProfileString(cszScriptingSection,
                                  cszScriptName,
                                  szNull,
                                  pszShortName,
                                  MAX_PATH,
                                  szImportFile) != 0)
      {
        // Try the favorite script directory
        //
        if (LoadString(NULL, IDS_INI_SCRIPT_DIR, pszDir,
                       (MAX_PATH - cb)) != 0)
        {
          // Try creating the file
          //
          hFile = CreateUniqueFile(szScript, pszShortName);
        };

        // If we do not have the file yet, try the second favorite
        //
        if (hFile == INVALID_HANDLE_VALUE)
        {
          if (LoadString(NULL/*_Module.GetModuleInstance()*/, IDS_INI_SCRIPT_SHORTDIR, pszDir,
                       (MAX_PATH - cb)))
          {
            // Try creating the file
            //
            hFile = CreateUniqueFile(szScript, pszShortName);
          };
        };

        // If we do not have the file yet, try Windows directory
        //
        if (hFile == INVALID_HANDLE_VALUE)
        {
          // Get original Windows directory
          //
          lstrcpy(szScript, pszPath);

          // Try one more time
          //
          hFile = CreateUniqueFile(szScript, pszShortName);
        };
      };
    };
  };

  GlobalFree(pszPath);
  return hFile;
}

//****************************************************************************
// DWORD NEAR PASCAL ImportScriptFile(LPWSTR szEntryName, LPWSTR szImportFile)
//
// This function imports the script file
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

DWORD NEAR PASCAL ImportScriptFile(LPRASENTRY lpRasEntry, LPCWSTR szImportFile)
{
  HANDLE hfScript;
  LPWSTR  pszLine;
  LPWSTR  pszFile;
  int    i, iMaxLine = 0;
  UINT   cbSize, cbRet;
  WCHAR   szTmp[4];
  DWORD  dwRet;

  dwRet=ERROR_SUCCESS;

  // If a script section does not exist, do nothing
  //
  if (GetPrivateProfileString(cszScriptingSection,
                              cszScriptName,
                              szNull,
                              szTmp,
                              MAX_CHARS_IN_BUFFER(szTmp),
                              szImportFile) == 0)
  {
    return ERROR_SUCCESS;
  };

  // Allocate a buffer for the script lines
  //
  if ((pszLine = (LPWSTR)GlobalAlloc(LMEM_FIXED, (SIZE_ReadBuf+MAX_PATH)*sizeof(WCHAR)))
       == NULL)
    {
        //TraceMsg(TF_GENERAL, L"CONNECT:ImportScriptFile(): Local Alloc failed\n");
    return ERROR_OUTOFMEMORY;
    }

  // Look for script
  //
  if (GetPrivateProfileString(cszScriptSection,
                              NULL,
                              szNull,
                              pszLine,
                              SIZE_ReadBuf,
                              szImportFile) != 0)
  {
    // Get the maximum line number
    //
    pszFile = pszLine;
    iMaxLine = -1;
    while (*pszFile)
    {
      i = Sz2W(pszFile);
      iMaxLine = max(iMaxLine, i);
      pszFile += lstrlen(pszFile)+1;
    };

    // If we have at least one line, we will import the script file
    //
    if (iMaxLine >= 0)
    {
      pszFile = pszLine+SIZE_ReadBuf;

      // Create the script file
      //
      //DebugBreak();
      hfScript = CreateScriptFile(pszFile, szImportFile);
        //TraceMsg(TF_GENERAL, "CONNECT:ImportScriptFile(): CreateScriptFile hfScript %d, %s, %s\n", hfScript, pszFile,szImportFile);

      if (hfScript != INVALID_HANDLE_VALUE)
      {
        WCHAR   szLineNum[MAXLONGLEN+1];

        // From The first line to the last line
        //
        for (i = 0; i <= iMaxLine; i++)
        {
          // Read the script line
          //
          wsprintf(szLineNum, L"%d", i);
          if ((cbSize = GetPrivateProfileString(cszScriptSection,
                                                szLineNum,
                                                szNull,
                                                pszLine,
                                                SIZE_ReadBuf,
                                                szImportFile)) != 0)
          {
            // Write to the script file
            //
            lstrcat(pszLine, L"\x0d\x0a");
            WriteFile(hfScript, pszLine, cbSize+2, (LPDWORD)&cbRet, NULL);
          };
        };

        CloseHandle(hfScript);

        // Associate it with the phonebook entry
        //
        lstrcpyn(lpRasEntry->szScript, pszFile, RAS_MaxEntryName);
      }
      else
      {
        dwRet = GetLastError();
      };
    }
    else
    {
      dwRet = ERROR_PATH_NOT_FOUND;
    };
  }
  else
  {
    dwRet = ERROR_PATH_NOT_FOUND;
  };
  GlobalFree(pszLine);

  return dwRet;
}

//****************************************************************************
// DWORD WINAPI RnaValidateImportEntry (LPWSTR)
//
// This function is called to validate an importable file
//
// History:
//  Wed 03-Jan-1996 09:45:01  -by-  Viroon  Touranachun [viroont]
// Created.
//****************************************************************************

DWORD CISPImport::RnaValidateImportEntry (LPCWSTR szFileName)
{
  WCHAR  szTmp[4];

  // Get the alias entry name
  //
  return (GetPrivateProfileString(cszEntrySection,
                                  cszEntry_Name,
                                  szNull,
                                  szTmp,
                                  MAX_CHARS_IN_BUFFER(szTmp),
                                  szFileName) > 0 ?
          ERROR_SUCCESS : ERROR_CORRUPT_PHONEBOOK);
}

//****************************************************************************
// HRESULT ImportConnection (LPCWSTR szFileName, LPWSTR pszEntryName, LPWSTR pszUserName, LPWSTR pszPassword)
//
// This function is called to import an entry from a specified file
//
// History:
//  Mon 18-Dec-1995 10:07:02  -by-  Viroon  Touranachun [viroont]
// Created.
//  Sat 16-Mar-1996 10:01:00  -by-  Chris Kauffman [chrisk]
// Modified to return HRESULT and load DLL dynamically
//****************************************************************************

HRESULT CISPImport::ImportConnection (LPCWSTR szFileName, LPWSTR pszSupportNumber, LPWSTR pszEntryName, LPWSTR pszUserName, LPWSTR pszPassword, LPBOOL pfNeedsRestart)
{
    LPRASENTRY      lpRasEntry;
    DWORD           dwRet;
    DWORD           dwOptions;
    //HINSTANCE       hinetcfg;
    //FARPROC         fp, fpSetAutoProxy;
    RNAAPI          Rnaapi;
  
    // Get the size of device configuration
    // This also validates an exported file
    //
    if ((dwRet = RnaValidateImportEntry(szFileName)) != ERROR_SUCCESS)
    {
        return dwRet;
    };

    // Allocate a buffer for entry and device config
    //
    if ((lpRasEntry = (LPRASENTRY)GlobalAlloc(GPTR, sizeof(RASENTRY))) == NULL)
    {
        return ERROR_OUTOFMEMORY;
    };
    
    // Get the entry name
    // Need to find a good name for it and remember it as an alias
    //
    GetPrivateProfileString(cszEntrySection,
                          cszEntry_Name,
                          szNull,
                          pszEntryName,
                          RAS_MaxEntryName+1,
                          szFileName);

    GetPrivateProfileString(cszUserSection,
                          cszUserName,
                          szNull,
                          pszUserName,
                          UNLEN+1,
                          szFileName);
  
    GetPrivateProfileString(cszUserSection,
                          cszPassword,
                          szNull,
                          pszPassword,
                          PWLEN+1,
                          szFileName);
  
    // Get ISP support number
    //
    GetPrivateProfileString(cszSupport,
                          cszSupportNumber,
                          szNull,
                          pszSupportNumber,
                          RAS_MaxAreaCode + RAS_MaxPhoneNumber +1,
                          szFileName);

    // Get device name, type and config
    //
    GetPrivateProfileString(cszDeviceSection,
                          cszDeviceType,
                          szNull,
                          lpRasEntry->szDeviceType,
                          MAX_CHARS_IN_BUFFER(lpRasEntry->szDeviceType),
                          szFileName);

    // Get Server Type settings
    //
    ImportServerInfo(lpRasEntry, szFileName);

    // Get IP address
    //
    ImportIPInfo(lpRasEntry, szFileName);

    // Import the script file
    //
    if ((dwRet = ImportScriptFile(lpRasEntry, szFileName)) != ERROR_SUCCESS)
    {
        //TraceMsg(TF_GENERAL, L"CONNECT:ImportScriptFile Failed with the error %d, %s,%s",dwRet,szFileName,lpRasEntry->szScript);
    }

    lpRasEntry->dwSize = sizeof(RASENTRY);

    // Load and Locate AutoRunSignUpWizard entry point
    //

    //hinetcfg = LoadLibrary(L"INETCFG.DLL");
    /*
    //AssertMsg(hinetcfg != NULL, L"Cannot find INETCFG.DLL");
    if (!hinetcfg) 
    {
        dwRet = GetLastError();
        goto ImportConnectionExit;
    }

    fpSetAutoProxy = GetProcAddress(hinetcfg, cszSetAutoProxyConnectoid);
    if (fpSetAutoProxy)
    {
        ((SETAUTOPROXYCONNECTOID)fpSetAutoProxy) (FALSE);
    }

    fp = GetProcAddress(hinetcfg, AUTORUNSIGNUPWIZARDAPI);
    //AssertMsg(fp != NULL, L"Cannot find AutoRunSignupWizard entry point");
    if (!fp)
    {
        dwRet = GetLastError();
        goto ImportConnectionExit;
    }*/

    // 10/19/96    jmazner    Normandy #8462 -- multiple modems
    dwRet = ConfigRasEntryDevice(lpRasEntry);
    switch( dwRet )
    {
        case ERROR_SUCCESS:
            break;
        case ERROR_CANCELLED:
            /*
            if( IDYES != MessageBox(GetActiveWindow(), GetSz(IDS_WANTTOEXIT), GetSz(IDS_TITLE),
                            MB_APPLMODAL | MB_ICONQUESTION |
                            MB_YESNO | MB_DEFBUTTON2) )
            {
                dwRet = ERROR_RETRY;
            }*/
            goto ImportConnectionExit;

        default:
            goto ImportConnectionExit;
    }

    if (lpRasEntry->szDeviceType[0] == TEXT('\0') &&
        lpRasEntry->szDeviceName[0] == TEXT('\0'))
    {
        lstrcpyn(lpRasEntry->szDeviceType, m_szDeviceType, RAS_MaxDeviceType);
        lstrcpyn(lpRasEntry->szDeviceName, m_szDeviceName, RAS_MaxDeviceName);
    }
    
    // See if this is a ISDN type device, and if so, then set the CFGFLAG_ISDN_OFFER
    if (lstrcmpi(g_szDeviceType, RASDT_Isdn) == 0)
        m_bIsISDNDevice = TRUE;
    
    ImportPhoneInfo(lpRasEntry, szFileName, m_bIsISDNDevice);

    //
    // ChrisK Olympus 4756 5/25/97
    // Do not display busy animation on Win95
    //
    dwOptions = INETCFG_INSTALLRNA |
                      INETCFG_INSTALLTCP |
                      INETCFG_OVERWRITEENTRY;

    dwRet =  Rnaapi.InetConfigClientEx(
                NULL,
                NULL,
                pszEntryName,
                lpRasEntry,
                pszUserName,
                pszPassword,
                NULL,
                NULL,
                dwOptions,
                pfNeedsRestart, 
                m_szConnectoidName,
                RAS_MaxEntryName+1); 

    //if (fpSetAutoProxy)
    //{
    //    ((SETAUTOPROXYCONNECTOID)fpSetAutoProxy) (TRUE);
    //}
    
    LclSetEntryScriptPatch(lpRasEntry->szScript, m_szConnectoidName);

    // now that we've made the connectoid in InetConfigClient (PFNAUTORUNSIGNUPWIZARD),
    // store its name in psheet's global so that we can delete it if user cancels
    //lstrcpyn( m_szConnectoidName, pszEntryName, lstrlen(pszEntryName) + 1);
    lstrcpyn( pszEntryName, m_szConnectoidName, lstrlen(pszEntryName) + 1);

    //TraceMsg(TF_GENERAL, "CONNECT:EntryName %s, User %s, Password (not shown), Number %s\n", pszEntryName,pszUserName,lpRasEntry->szLocalPhoneNumber);
    //AssertMsg(!fNeedsRestart, L"We have to reboot AGAIN!!");

    // Exit and cleanup
    //

ImportConnectionExit:
    //if (hinetcfg)
      //  FreeLibrary(hinetcfg);
    GlobalFree(lpRasEntry);
    return dwRet;
}

//+----------------------------------------------------------------------------
//
//    Function    GetDeviceSelectedByUser
//
//    Synopsis    Get the name of the RAS device that the user had already picked
//
//    Arguements    szKey - name of sub key
//                szBuf - pointer to buffer
//                dwSize - size of buffer
//
//    Return        TRUE - success
//
//    History        10/24/96    ChrisK    Created
//-----------------------------------------------------------------------------
BOOL CISPImport::GetDeviceSelectedByUser (LPWSTR szKey, LPWSTR szBuf, DWORD dwSize)
{
    BOOL bRC = FALSE;
    HKEY hkey = NULL;
    DWORD dwType = 0;

    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, ISIGNUP_KEY, &hkey))
    {
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, szKey, 0,&dwType,
            (LPBYTE)szBuf, &dwSize))
            bRC = TRUE;
    }

    if (hkey)
        RegCloseKey(hkey);
    return bRC;
}

//+----------------------------------------------------------------------------
//    Function    SetDeviceSelectedByUser
//
//    Synopsis    Write user's device selection to registry
//
//    Arguments    szKey - name of key
//                szBuf - data to write to key
//
//    Returns        TRUE - success
//
//    History        10/24/96    ChrisK    Created
//-----------------------------------------------------------------------------
BOOL CISPImport::SetDeviceSelectedByUser (LPWSTR szKey, LPWSTR szBuf)
{
    BOOL bRC = FALSE;
    HKEY hkey = 0;

    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE,
        ISIGNUP_KEY, &hkey))
    {
        if (ERROR_SUCCESS == RegSetValueEx(hkey, szKey, 0,REG_SZ,
            (LPBYTE)szBuf, BYTES_REQUIRED_BY_SZ(szBuf)))
            bRC = TRUE;
    }

    if (hkey)
        RegCloseKey(hkey);
    return bRC;
}

//+----------------------------------------------------------------------------
//    Funciton    DeleteUserDeviceSelection
//
//    Synopsis    Remove registry keys with device selection
//
//    Arguments    szKey - name of value to remove
//
//    Returns        TRUE - success
//
//    History        10/24/96    ChrisK    Created
//-----------------------------------------------------------------------------
BOOL CISPImport::DeleteUserDeviceSelection(LPWSTR szKey)
{
    BOOL bRC = FALSE;
    HKEY hkey = NULL;
    if (ERROR_SUCCESS == RegOpenKey(HKEY_LOCAL_MACHINE, ISIGNUP_KEY, &hkey))
    {
        bRC = (ERROR_SUCCESS == RegDeleteValue(hkey, szKey));
        RegCloseKey(hkey);
    }
    return bRC;
}

//+---------------------------------------------------------------------------
//
//  Function:   ConfigRasEntryDevice()
//
//  Synopsis:   Checks whether user has already specified a modem to use;
//                If so, verifies that modem is valid.
//                If not, or if modem is invalid, presents user a dialog
//                to choose which modem to use (if only one modem is installed,
//                it automaticaly selects that device and bypasses the dialog)
//
//  Arguments:  lpRasEntry - Pointer to the RasEntry whose szDeviceName and
//                             szDeviceType members you wish to verify/configure
//
//    Returns:    ERROR_CANCELLED - Had to bring up "Choose Modem" dialog, and
//                                  and user hit its "Cancel" button
//                Otherwise returns any error code encountered.
//                ERROR_SUCCESS indicates success.
//
//  History:    5/18/96     VetriV    Created
//              3/7/98      DonSc     Added the process-wide tracking of the previously
//                                    selected device.
//
//----------------------------------------------------------------------------
DWORD CISPImport::ConfigRasEntryDevice( LPRASENTRY lpRasEntry )
{
    DWORD        dwRet = ERROR_SUCCESS;
#if 0
    
    CEnumModem  EnumModem;

    GetDeviceSelectedByUser(DEVICENAMEKEY, g_szDeviceName, sizeof(g_szDeviceName));
    GetDeviceSelectedByUser(DEVICETYPEKEY, g_szDeviceType, sizeof(g_szDeviceType));

    ASSERT(lpRasEntry);

    dwRet = EnumModem.GetError();
    if (ERROR_SUCCESS != dwRet)
    {
        return dwRet;
    }

    // If there are no modems, we're horked
    if (0 == EnumModem.GetNumDevices())
    {
        //TraceMsg(TF_GENERAL, L"ICWHELP: import.cpp: ConfigRasEntryDevice: ERROR: No modems installed!\n");
        return ERROR_CANCELLED;
    }


    // Validate the device if possible
    if ( lpRasEntry->szDeviceName[0] && lpRasEntry->szDeviceType[0] )
    {
        // Verify that there is a device with the given name and type
        if (!EnumModem.VerifyDeviceNameAndType(lpRasEntry->szDeviceName, 
                                                lpRasEntry->szDeviceType))
        {
            // There was no device that matched both name and type,
            // so reset the strings and bring up the choose modem UI.
            lpRasEntry->szDeviceName[0] = L'\0';
            lpRasEntry->szDeviceType[0] = L'\0';
        }
    }
    else if ( lpRasEntry->szDeviceName[0] )
    {
        // Only the name was given.  Try to find a matching type.
        // If this fails, fall through to recovery case below.
        LPWSTR szDeviceType =
            EnumModem.GetDeviceTypeFromName(lpRasEntry->szDeviceName);
        if (szDeviceType)
        {
            lstrcpy (lpRasEntry->szDeviceType, szDeviceType);
        }
    }
    else if ( lpRasEntry->szDeviceType[0] )
    {
        // Only the type was given.  Try to find a matching name.
        // If this fails, fall through to recovery case below.
        LPWSTR szDeviceName = 
            EnumModem.GetDeviceNameFromType(lpRasEntry->szDeviceType);
        if (szDeviceName)
        {
            lstrcpy (lpRasEntry->szDeviceName, szDeviceName);
        }
    }
    

    // If either name or type is missing, check whether the user has already made a choice.
    // if not, bring up choose modem UI if there
    // are multiple devices, else just get first device.
    // Since we already verified that there was at least one device,
    // we can assume that this will succeed.
    
    if( !(lpRasEntry->szDeviceName[0]) ||
        !(lpRasEntry->szDeviceType[0]) )
    {
        //TraceMsg(TF_GENERAL, L"ICWHELP: ConfigRasEntryDevice: no valid device passed in\n");

        if( g_szDeviceName[0] )
        {
            // it looks like we have already stored the user's choice.
            // store the DeviceName in lpRasEntry, then call GetDeviceTypeFromName
            // to confirm that the deviceName we saved actually exists on the system
            lstrcpy(lpRasEntry->szDeviceName, g_szDeviceName);
            
            if( 0 == lstrcmp(EnumModem.GetDeviceTypeFromName(lpRasEntry->szDeviceName),
                              g_szDeviceType) )
            {
                lstrcpy(lpRasEntry->szDeviceType, g_szDeviceType);
                return ERROR_SUCCESS;
            }
        }


        if (1 == EnumModem.GetNumDevices())
        {
            // There is just one device installed, so copy the name
            //TraceMsg(TF_GENERAL, L"ICWHELP: import.cpp: ConfigRasEntryDevice: only one modem installed, using it\n");
            lstrcpy (lpRasEntry->szDeviceName, EnumModem.Next());
        }
        else
        {
            //TraceMsg(TF_GENERAL, L"ICWHELP: import.cpp: ConfigRasEntryDevice: multiple modems detected\n");

            if (IsNT4SP3Lower())
            {
                lstrcpy (lpRasEntry->szDeviceName, EnumModem.Next() );
            }
            else
            {
                // structure to pass to dialog to fill out
                CHOOSEMODEMDLGINFO ChooseModemDlgInfo;
    
                // Display a dialog and allow the user to select modem
                // TODO:  is g_hWndMain the right thing to use for parent?
                BOOL fRet=DialogBoxParam(GetModuleHandle(L"ICWHELP.DLL"), MAKEINTRESOURCE(IDD_CHOOSEMODEMNAME), GetActiveWindow(),
                    ChooseModemDlgProc, (LPARAM) &ChooseModemDlgInfo);
                if (TRUE != fRet)
                {
                    // user cancelled or an error occurred.
                    dwRet = ChooseModemDlgInfo.hr;
                    /*
                    dwRet = GetLastError(); //This will NEVER be ERROR_SUCCESS
                
                    //BUBGUG -- If the user hits OK -> then ChooseModemDlgInfo.hr == ERROR_SUCCESS,
                    BUT if OK was hit then the function returns true and this can never be hit!
                    if (ERROR_SUCCESS == dwRet)
                    {
                        // Error occurred, but the error code was not set.
                        dwRet = ERROR_INETCFG_UNKNOWN;
                    }*/
                    return dwRet;
                }
    
                // Copy the modem name string
                lstrcpy (lpRasEntry->szDeviceName, ChooseModemDlgInfo.szModemName);
            }
        }

        // Now get the type string for this modem
        lstrcpy (lpRasEntry->szDeviceType, EnumModem.GetDeviceTypeFromName(lpRasEntry->szDeviceName));
    }

    lstrcpy(g_szDeviceName, lpRasEntry->szDeviceName);
    lstrcpy(g_szDeviceType, lpRasEntry->szDeviceType);

    // Save device name and type
    lstrcpy( m_szDeviceName, lpRasEntry->szDeviceName);
    lstrcpy( m_szDeviceType, lpRasEntry->szDeviceType);

    // Save data in registry
    SetDeviceSelectedByUser(DEVICENAMEKEY, g_szDeviceName);
    SetDeviceSelectedByUser (DEVICETYPEKEY, g_szDeviceType);
#endif

    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobcomm\icsmgr.cpp ===
#include <winsock2.h>
#include "IcsMgr.h"
#include <winbase.h>
#include <winreg.h>
#include <tchar.h>
#include <sensapi.h>
#include "msobcomm.h"
// #include "appdefs.h"

typedef BOOL  (WINAPI * LPFNDLL_ISICSAVAILABLE) ();


static const DWORD ICSLAP_DIAL_STATE     = 15; // As per ICS Specification
static const DWORD ICSLAP_GENERAL_STATUS = 21;
static CIcsMgr *ptrIcsMgr                = NULL;
static BOOL bIsWinsockInitialized        = FALSE;

static const WCHAR  cszIcsHostIpAddress[] = L"192.168.0.1";

extern CObCommunicationManager* gpCommMgr;

// based on ICS beacon protocol
typedef struct _ICS_DIAL_STATE_CB
{
	ICS_DIAL_STATE state;
	DWORD options;
} ICS_DIAL_STATE_CB;

// used for IsIcsAvailable()
const static WCHAR		cszIcsKey[]             = L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OOBE\\Ics";
const static WCHAR		cszIcsStatusValueName[] = L"IsIcsAvailable";

// used for winsock operations
static WORD			    wVersionRequested	    = MAKEWORD ( 2, 2 );
static WSADATA	        SocketData;

CIcsMgr::CIcsMgr() : m_hBotThread(0), m_dwBotThreadId(0), m_hDialThread(0), m_dwDialThreadId(0), m_pfnIcsConn(OnIcsConnectionStatus)
{
    ptrIcsMgr = this;
    if ( !bIsWinsockInitialized )
    {
       	if ( !WSAStartup ( wVersionRequested, &SocketData ) )
	    {
		    bIsWinsockInitialized = TRUE;
	    }
    }
	return;
}

CIcsMgr::~CIcsMgr() 
{
    if ( m_hDialThread ) CloseHandle (m_hDialThread);
    if ( bIsWinsockInitialized )
    {
        //WSACleanup ();
        bIsWinsockInitialized = FALSE;
    }
    ptrIcsMgr = NULL;
    TriggerIcsCallback ( FALSE );
    return;
    
}

BOOL    CIcsMgr::IsCallbackUsed ()
{
    return !bReducedCallback;
}

// A server error during ICS is trapped by the ICS manager, instead
// of the OOBE MSOBMAIN body. This gives the manager a larger sphere
// of control.
VOID    CIcsMgr::NotifyIcsMgr(UINT msg, WPARAM wparam, LPARAM lparam)
{
	switch (msg)
	{
	case WM_OBCOMM_ONSERVERERROR:
		{
			// on server error! is the host still available ?
			if ( ! IsDestinationReachable ( cszIcsHostIpAddress, NULL ) )
			{
				// fire event that Home Network is unavailable.
				OnIcsConnectionStatus ( ICS_HOMENET_UNAVAILABLE );
			}
            else
            {   // this will be considered a timeout error.
                OnIcsConnectionStatus ( ICS_TIMEOUT );
            }
		}
		break;
		
	default:
		break;
	}
	return;
}

// PACKET READER ------------------
// Note: Please refer to the ICS Specifications for the packet format. You can
// consult RLamb@microsoft.com for the documentation.
//
// Description: This function listens for UDP packets arriving at the ICS
// broadcast port. The ICS host sends notifications to the Home Network
// whenever the Connection status changes at the Shared Connection. The func
// reads the packet and notifies OOBE by firing a callback function (*lpParam)
// which notifies OOBE via PostMessage(). A script routine can eventually be
// executed to handle the notification.              
//
// An ICS broadcast packet has the following format:
// |resp:0,bcast:1,id:2-31|cbData:0-31|data(cbData - 8 bytes)|
// |<---------32 bits---->|<-32 bits->|<---total_length - 8 ------>|
//                                    |<IE-1>|<IE-2>|..|<IE-N>|
//
// Each information element (IE) has the following format:
// | opcode 0-31   |  cbIE 0=64    |data(cbIE - 12 bytes)|
// |<-- 32 bits -->|<-- 64 bits -->|<-- cbIE - 12 bytes  |
//
DWORD   WINAPI IcsDialStatusProc(LPVOID lpParam)
{
	INT						n					= 0;

	u_short					usPort				= 2869;
	struct sockaddr_in		saddr, caddr;
	INT						caddr_len			= sizeof ( caddr );
	BYTE 					rgbBuf[300];
	DWORD					dwBufSize			= sizeof ( rgbBuf );
	LPDWORD					pdw					= 0;
	BYTE 					*lpbie				= 0;
	BYTE 					*lpbBound			= 0;
	ICS_DIAL_STATE_CB		*ptrDial			= 0;
	SOCKET					s					= INVALID_SOCKET;
    PFN_ICS_CONN_CALLBACK   pfn_IcsCallback     = NULL;
    DWORD                   dwError             = NULL;

    bIsDialThreadAlive = TRUE;

    if ( !lpParam )
    {
        bIsDialThreadAlive = FALSE;
        return ERROR_INVALID_PARAMETER;
    }

	if ( !bIsWinsockInitialized )
	{
        bIsDialThreadAlive = FALSE;

		return 0;
	}

	if ( (s	= socket ( AF_INET, SOCK_DGRAM, 0 )) == INVALID_SOCKET )
	{
        bIsDialThreadAlive = FALSE;
        return E_FAIL; // for want of a better return value *BUGBUG*
//		TRACE ( L"SOCKET Error.\t:%d:\n", WSAGetLastError() );
	}
	else
	{
        __try 
        {
            memset ( &saddr, 0, sizeof (saddr) );
            saddr.sin_family		   = AF_INET;
            saddr.sin_addr.S_un.S_addr = htonl ( INADDR_ANY );
            saddr.sin_port			   = htons ( usPort );
            
            if ( bind( s, (struct sockaddr *) &saddr, sizeof(saddr) ) == SOCKET_ERROR )
            {
                //			TRACE ( L"Bind error.\n" );
                dwError = WSAGetLastError();
            }
            else
            {
                if (ptrIcsMgr) ptrIcsMgr->RefreshIcsDialStatus();
                for ( ; ; )
                {
                    if ( (n = recvfrom ( s, (CHAR*)rgbBuf, dwBufSize, 0, (struct sockaddr *) &caddr, &caddr_len )) == SOCKET_ERROR )
                    {
                        //					TRACE ( L"Socket Error.\n" );
                        break;
                    }
                    lpbBound = rgbBuf+n; // this protects us from illegal packet configurations.
                    //				TRACE ( L" Something received! Size = %d\n" , n );
                    
                    // checking for BROADCAST packets //
                    if ( *(pdw = (LPDWORD) rgbBuf) & 0xC0000000 )
                    {
                        // This is a broadcast packet! We can parse the packet.
                    }
                    else
                    {
                        // non-broadcast packets are ignored.
                        continue; 
                    }
                    lpbie = rgbBuf+8;
                    
                    while ( lpbie && ( (lpbie+8) <= lpbBound) )
                    {
                        if ( *(pdw = ((PDWORD)lpbie)) == ICSLAP_DIAL_STATE )
                        {
                            //						TRACE (L"Dial State Engine. The Datasize is %d\n", pdw[2]-12);
                            if ( (lpbie+12+sizeof(ICS_DIAL_STATE_CB)) <= lpbBound )
                            {
                                ptrDial = (ICS_DIAL_STATE_CB*)(lpbie+12);
                                
                                pfn_IcsCallback = *((PFN_ICS_CONN_CALLBACK*)lpParam);
                                
                                if ( pfn_IcsCallback )
                                {
                                    pfn_IcsCallback ( ptrDial->state );
                                }
                                //							TRACE (L"Dial State = %d\n", ptrDial->state);
                                lpbie = 0;
                            }
                            else
                            {
                                // packet has illegal data.
                                break;
                            }
                        }
                        else
                        {
                            // not the correct ie.
                            if ( (lpbie += pdw[2]) >= lpbBound )
                            {
                                // we traversed the packet without finding the correct ie.
                                //							TRACE (L"Done.\n");
                                lpbie = 0;
                            }
                            // else we continue the loop.
                        }
                        
                    }
                }
            }
        }
        __finally
        {
            
            // graceful shutdown of the socket.
            shutdown    ( s, SD_BOTH );
            closesocket ( s );
        }
	}
    bIsDialThreadAlive = FALSE;

	return	    ERROR_SUCCESS;
}



// this is the callback routine that reports ICS connection state information.
// it relies on both the Beacon protocol and Internet Explorer's error handling
// (see ONSERVERERROR for details.)
VOID    CALLBACK OnIcsConnectionStatus(ICS_DIAL_STATE  dwIcsConnectionStatus)
{

    eIcsDialState = dwIcsConnectionStatus;

    if ( !gpCommMgr ) return;

    TRACE1(L"ICS Connection Status %d", dwIcsConnectionStatus);

    // we are not interested in the modem scenario. only ics-broadband is supported.
    if ( (dwIcsConnectionStatus == ICSLAP_CONNECTING) ||
         (dwIcsConnectionStatus == ICSLAP_CONNECTED)  ||
         (dwIcsConnectionStatus == ICSLAP_DISCONNECTING) ||
         (dwIcsConnectionStatus == ICSLAP_DISCONNECTED) )
    {
        bIsBroadbandIcsAvailable = FALSE;
   	    return;
   	}
    // indication of ics-broadband
    if (dwIcsConnectionStatus == ICSLAP_PERMANENT)
        bIsBroadbandIcsAvailable = TRUE;

    // none of the other states will change the bIsBroadbandIcsAvailable value.
   	
   	// if the callback mechanism has been turned off, we will not report
   	// connection status to the upper application layer(s).
    if ( bReducedCallback )
    {
        return;
    }
    PostMessage ( gpCommMgr->m_hwndCallBack, WM_OBCOMM_ONICSCONN_STATUS, (WPARAM)0, (LPARAM)dwIcsConnectionStatus);
}

// by turning this ON or OFF ( TRUE / FALSE respectively ), we can control
// whether or not to inform OOBE of ICS-connection status changes.
VOID   CIcsMgr::TriggerIcsCallback(BOOL bStatus)
{
    bReducedCallback = !bStatus; // if we want to un-trigger the callback, we go to "sleep" state.
    if ( bStatus )
    {
        RefreshIcsDialStatus();
    }
}

// Obsolete, but retained in case the beacon protocol becomes
// functional. This function used to call an ICS API to check if ICS was available.
// this is no longer useful for 2 reasons:
//  1. We ONLY want one type of ICS (broadband, as opposed to Dial-up)
//  2. The function does not report ICS availability if the machine it is called in
//     is the ICS HOST itself.
DWORD	IcsEngine(LPVOID lpParam) {

	// lpParam is ignored.


	HINSTANCE	hIcsDll								= NULL;
	LPFNDLL_ISICSAVAILABLE lpfndll_IsIcsAvailable	= NULL;
	BOOL bIsIcsAvailable							= FALSE;


	HKEY		hIcsRegKey	= 0;
	LONG		lRetVal		= 0;
	ICSSTATUS	dwIcsStatus	= ICS_ENGINE_NOT_COMPLETE;
	DWORD		nRet		= 0;
	DWORD		dwStatus	= 0;
	nRet = RegCreateKeyEx (	HKEY_LOCAL_MACHINE,
								cszIcsKey,
								0,
								L"",
								REG_OPTION_NON_VOLATILE,
								KEY_WRITE,
								NULL,
								&hIcsRegKey,
								&dwStatus
							);

	if (nRet != ERROR_SUCCESS) 
	{
		// Registry APIs refuse to create key. No point continuing farther.
		return (nRet        = GetLastError());
	}
    __try {
        if ( !(hIcsDll = LoadLibrary(L"ICSAPI32.DLL")) ) 
        {
            nRet                = GetLastError();
            dwIcsStatus         = ICS_ENGINE_FAILED;
            __leave;
        }
        if ( !(lpfndll_IsIcsAvailable = (LPFNDLL_ISICSAVAILABLE) GetProcAddress (hIcsDll, "IsIcsAvailable"))) 
        {
            // We record in the registry that the engine was not initializable.
            nRet				= GetLastError();
            dwIcsStatus			= ICS_ENGINE_FAILED;
            FreeLibrary ( hIcsDll );
            __leave;
        }
        
        dwIcsStatus				= ICS_ENGINE_NOT_COMPLETE;
        if ((nRet = RegSetValueEx(hIcsRegKey, cszIcsStatusValueName, 0, REG_DWORD, (BYTE*)&dwIcsStatus, sizeof(DWORD))) != ERROR_SUCCESS) 
        {	
            nRet                = GetLastError();
            dwIcsStatus         = ICS_ENGINE_FAILED;        
            __leave;
        }
        else 
        {
            __try 
            {
                if (bIsIcsAvailable = lpfndll_IsIcsAvailable()) {
                    // ICS is available
                    dwIcsStatus			= ICS_IS_AVAILABLE;
                    nRet				= ERROR_SUCCESS;
                } else {
                    dwIcsStatus			= ICS_IS_NOT_AVAILABLE;
                    nRet				= ERROR_SUCCESS;
                }
            }
            // exception-handlign is used to prevent IsIcsAvailable from
            // killing OOBE by generating an Invalid Page Fault.
            __except (EXCEPTION_EXECUTE_HANDLER) 
            {
                dwIcsStatus = ICS_IS_NOT_AVAILABLE;
                nRet = ERROR_SUCCESS;
            }
        }
    }
    __finally 
    {
        // perform registry update of the status.
        if ((nRet = RegSetValueEx (hIcsRegKey, cszIcsStatusValueName, 0, REG_DWORD, (BYTE*)&dwIcsStatus, sizeof(DWORD))) != ERROR_SUCCESS) 
        {
            nRet                = GetLastError();
        }
        
        RegCloseKey (hIcsRegKey);
        
        // unload library
        if (hIcsDll) FreeLibrary (hIcsDll);    
    }
	return nRet;
}

// not used. see remarks for IcsEngine() above.
DWORD	CIcsMgr::CreateIcsBot() 
{
	LPTHREAD_START_ROUTINE lpfn_ThreadProc		= (LPTHREAD_START_ROUTINE) IcsEngine;
	m_hBotThread = CreateThread (NULL, NULL, lpfn_ThreadProc, 0, 0, &m_dwBotThreadId);
	if (!m_hBotThread) 
	{
		// Thread was not created
        m_dwBotThreadId = 0;
        m_hBotThread = 0;
		return ICSMGR_ICSBOT_CREATION_FAILED;
	} else 
	{
		return ICSMGR_ICSBOT_CREATED;
	}
}

// this function spawns a thread that listens for ICS connectivity changes on the Host machine.
// the function will ALSO work on the Host machine itself.
// this uses UDP sockets. See the Ics beacon protocol [bjohnson] for details.
DWORD   CIcsMgr::CreateIcsDialMgr() 
{
	LPTHREAD_START_ROUTINE lpfn_ThreadProc		= (LPTHREAD_START_ROUTINE) IcsDialStatusProc;

    if ( bIsDialThreadAlive || m_hDialThread || m_dwDialThreadId) 
    {
        return ERROR_SERVICE_ALREADY_RUNNING;
    }
    m_hDialThread = CreateThread (NULL, NULL, lpfn_ThreadProc, (LPVOID)(&m_pfnIcsConn), 0, &m_dwDialThreadId);
	if (!m_hDialThread) 
	{
		// Thread was not created
        m_hDialThread    = 0;
        m_dwDialThreadId = 0;
		return GetLastError();
	} 
	else 
	{
		return ERROR_SUCCESS;
	}
}

// this now relies
BOOL	CIcsMgr::IsIcsAvailable() {
    return bIsBroadbandIcsAvailable;
}


BOOL    CIcsMgr::IsIcsHostReachable() 
{
    return IsDestinationReachable ( cszIcsHostIpAddress, 0 );
}

DWORD   CIcsMgr::RefreshIcsDialStatus()
{
	INT						n					= 0;

	u_short					usServerPort		= 2869;
	struct sockaddr_in		saddr;
	INT						saddr_len			= sizeof ( saddr );
    BYTE                    lpbRequestBuf[100];
    DWORD                   dwRequestBufSize    = sizeof ( lpbRequestBuf );
	LPDWORD					pdw					= 0;
	WCHAR					*lpbie				= 0;
	WCHAR					*lpbBound			= 0;
	SOCKET					s					= INVALID_SOCKET;
    DWORD                   nRet                = ERROR_SUCCESS;

	if ( !bIsWinsockInitialized )
	{
		return WSANOTINITIALISED;
	}

	if ( (s	= socket ( AF_INET, SOCK_DGRAM, 0 )) == INVALID_SOCKET )
	{
        return E_FAIL; // for want of a better return value *BUGBUG*
//		TRACE ( L"SOCKET Error.\t:%d:\n", WSAGetLastError() );
	}
	else
    {
        __try 
        {
            USES_CONVERSION;
                memset ( &saddr, 0, sizeof (saddr) );
                saddr.sin_family		   = AF_INET;
                saddr.sin_addr.S_un.S_addr = inet_addr (W2A(cszIcsHostIpAddress));
                saddr.sin_port			   = htons ( usServerPort );
                
                // set up request packet:
                memset ( lpbRequestBuf, 0, sizeof( lpbRequestBuf ) );
                
                
                // setting up the request buffer.
                pdw       = (PDWORD) lpbRequestBuf;
                pdw[0]    = 125152 & ~(0xC0000000); // random ID
                pdw[1]    = 20;
                pdw[2]    = ICSLAP_GENERAL_STATUS & ~(0x80000000);
                pdw[3]    = 0;
                pdw[4]    = 12;
                
                
                if ( (n = sendto   ( s, (CHAR*)lpbRequestBuf, 20, 0, (struct sockaddr *) &saddr, saddr_len )) == SOCKET_ERROR )
                {
                    nRet = WSAGetLastError();
                    __leave;
                }
                else
                {
                    nRet = ERROR_SUCCESS;
                    __leave;
                }
        }
        __finally 
        {
            // graceful shutdown of the socket.
            shutdown    ( s, SD_BOTH );
            closesocket ( s );
        }
    }
	return	    nRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobcomm\inets.cpp ===
// inets.cpp: implementation of the CInetSetup class.
//
//////////////////////////////////////////////////////////////////////

#include "inets.h"
#include <ras.h>
#include <tapi.h>
#include <stdio.h>
#include <string.h>
#include <appdefs.h>

#define MAXNAME 200



typedef DWORD (WINAPI *LPFNDLL_RASGETENTRYPROPERTIES)(LPCWSTR, LPCWSTR, LPRASENTRY, LPDWORD, LPBYTE, LPDWORD);
typedef DWORD (WINAPI *LPFNDLL_RASSETENTRYPROPERTIES)(LPCWSTR, LPCWSTR, LPRASENTRY, DWORD  , LPBYTE, DWORD  );

/////////////////////////////////////////////////////////////////////////
//                          Registry Values                            //
/////////////////////////////////////////////////////////////////////////

// For CInetSetup::InetSSetLanConnection
//static const    WCHAR    cszRegEnumPciKey[]         = L"Enum\\PCI";
//static const    WCHAR    cszRegEnumNetworkTcpKey[]  = L"Enum\\Network\\MSTCP";
//static const    WCHAR    cszRegClassKey[]           = L"System\\CurrentControlSet\\Services\\Class";

static const    WCHAR    cszRegBindings[]           = L"Bindings";
//static const    WCHAR    cszRegEnumDriverKey[]      = L"Driver";
static const    WCHAR    cszRegTcpIp[]              = L"MSTCP";

// Global TcpIp Reg Location
static const    WCHAR    cszRegFixedTcpInfoKey[] = L"System\\CurrentControlSet\\Services\\VxD\\MSTCP";

//
// IP Address
//
static const    WCHAR    cszRegIPAddress[]       = L"IPAddress";
static const    WCHAR    cszRegIPMask[]          = L"IPMask";
//
// WINS
//
static const    WCHAR    cszRegWINS[]            = L"NameServer";
//
// Gateway
//
static const    WCHAR    cszRegDefaultGateway[]  = L"DefaultGateway";
//
// DNS
//
static const    WCHAR    cszRegDomainName[]      = L"Domain";
static const    WCHAR    cszRegNameServer[]      = L"NameServer";
static const    WCHAR    cszRegHostName[]        = L"HostName";
static const    WCHAR    cszRegEnableDNS[]       = L"EnableDNS";
static const    WCHAR    cszRegSuffixSearchList[] = L"SearchList";

static const    WCHAR    cszNullIP[]             = L"0.0.0.0";

static const    WCHAR   cszAdapterClass[]       = L"Net";
static const    WCHAR   cszProtocolClass[]      = L"NetTrans";

static const    WCHAR   cszNodeType[]           = L"NodeType";

static const    WCHAR   cszScopeID[]            = L"ScopeID";

// Not in use by OOBE, but included in case this becomes
// a seperate module. API does *NOT* work with PPPOA.
DWORD WINAPI InetSSetRasConnection ( RASINFO& RasEntry )
{
    DWORD   nRetVal                     = ERROR_SUCCESS;
    LPFNDLL_RASSETENTRYPROPERTIES rsep  = NULL;
    LPFNDLL_RASGETENTRYPROPERTIES rgep  = NULL;
    LPBYTE  lpDeviceBuf                 = NULL;
    DWORD   dwDeviceBufSize             = 0;

    HMODULE hRasApi                     = LoadLibrary (L"RasApi32.dll");
    if (!hRasApi) return GetLastError();

    if (!(rsep = (LPFNDLL_RASSETENTRYPROPERTIES) GetProcAddress (hRasApi, "RasSetEntryProperties"))) {
        nRetVal = GetLastError();
        goto end;
    }
    if (!(rgep = (LPFNDLL_RASGETENTRYPROPERTIES) GetProcAddress (hRasApi, "RasGetEntryProperties"))) {
        nRetVal = GetLastError();
        goto end;
    }
    if ( (nRetVal = RasValidateEntryName (  ((!lstrlen(RasEntry.szPhoneBook)) ? NULL : RasEntry.szPhoneBook), RasEntry.szEntryName )) != ERROR_SUCCESS &&
          nRetVal != ERROR_ALREADY_EXISTS ) {
        nRetVal = ERROR_INVALID_NAME;
        goto end;
    }
    // we place the RASENTRY structure first. the lpDeviceInfo information is only considered for
    // ATM.
    if ( (nRetVal = rsep (((!lstrlen(RasEntry.szPhoneBook)) ? NULL : RasEntry.szPhoneBook), RasEntry.szEntryName, &RasEntry.RasEntry, sizeof (RasEntry.RasEntry), NULL, 0)) != ERROR_SUCCESS ) {
        goto end;
    }
    // unless the device is ATM, no further action is necessary.
    //if ( lstrcmpi (RasEntry.RasEntry.szDeviceType, RASDT_Atm) )
    {
        nRetVal = ERROR_SUCCESS;
        goto end;
    }
    if ( RasEntry.dwDeviceInfoSize != sizeof (ATMPBCONFIG) ) {
        nRetVal = ERROR_INVALID_PARAMETER;
        goto end;
    }
    if ( (nRetVal = rgep (((!lstrlen(RasEntry.szPhoneBook)) ? NULL : RasEntry.szPhoneBook), RasEntry.szEntryName, &(RasEntry.RasEntry), &(RasEntry.RasEntry.dwSize), NULL, &dwDeviceBufSize)) != ERROR_SUCCESS )  {
        goto end;
    }

    if ( !(lpDeviceBuf = (LPBYTE) malloc (dwDeviceBufSize)) ) {
        nRetVal = ERROR_NOT_ENOUGH_MEMORY;
        goto end;
    }
    if ( (nRetVal = rgep (((!lstrlen(RasEntry.szPhoneBook)) ? NULL : RasEntry.szPhoneBook), RasEntry.szEntryName, &(RasEntry.RasEntry), &(RasEntry.RasEntry.dwSize), lpDeviceBuf, &dwDeviceBufSize)) != ERROR_SUCCESS )  {
        goto end;
    }
    // ** BUGBUG: WARNING: THIS IS NOT STABLE CODE: THERE IS NO DOCUMENTATION ON THE CORRECT
    // ** -------- USE OF THE RASSETENTRYPROPERTIES FOR THE LPDEVICEINFO BUFFER.
    memcpy (lpDeviceBuf+66, &RasEntry.lpDeviceInfo, RasEntry.dwDeviceInfoSize); // HACK!
    if ( (nRetVal = rsep (NULL,                 RasEntry.szEntryName,
                          &RasEntry.RasEntry,   sizeof (RasEntry.RasEntry),
                          lpDeviceBuf,          dwDeviceBufSize)) != ERROR_SUCCESS) {
        goto end;
    }
end:
    free (lpDeviceBuf);
    FreeLibrary(hRasApi);
    return nRetVal;
}

// this function sets a PPPOE connection. Presently, it merely updates
// the device's registry location with the parameters in the INS file.
// in the future, InetSSetPppoeConnection () will have native support.
DWORD WINAPI InetSSetPppoeConnection ( PPPOEINFO& PppoeInfo )
{
    // settings:
    // ---------------------------------------------------
    //     Format:  "RegKey=RegVal" e.g. "Pvc1=10"

//    LPBYTE  lpbNdiBuf = PppoeInfo.PppoeModule.lpbRegNdiParamBuf;
    LPWSTR  pwchSetBuf  = (LPWSTR)PppoeInfo.PppoeModule.lpbRegSettingsBuf;
    LPWSTR  eq          = 0;
    DWORD   cwchValue   = 0;
    HKEY    hkeyAdapterClass = NULL;

    // BUGBUG: error checking is ignored. BUG-BUG
    DWORD   nRetVal  = 0;
    if ( (nRetVal = InetSGetAdapterKey ( cszAdapterClass, PppoeInfo.TcpIpInfo.szPnPId, INETS_ADAPTER_HARDWAREID, DIREG_DRV, hkeyAdapterClass )) != ERROR_SUCCESS )
    {
        return nRetVal;
    }

    while ( *pwchSetBuf )
    {
        if ( !(eq = wcschr ( pwchSetBuf, L'=' )) )
        {
            return ERROR_INVALID_PARAMETER;
        }
        // we also disallow the following: "Vci="
        if ( !(*(eq+1)) )
        {
            return ERROR_INVALID_PARAMETER;
        }

        // flush out the '=' so that we have two token strings.
        // we simply move each string directly into the registry.
        *eq = L'\0';
        cwchValue = lstrlen(eq + 1) + 1;	// account for trailing 0

        if ( RegSetValueEx ( hkeyAdapterClass, pwchSetBuf, 0, REG_SZ, (LPBYTE)(eq + 1), cwchValue * sizeof(WCHAR)) != ERROR_SUCCESS )
        {
            *eq = L'=';
            return E_FAIL;
        }

        // restore the '=' and move to the next pair "name=value"
        *eq = L'=';
        pwchSetBuf = eq + 1 + cwchValue; // include '='
    }

    if ( InetSSetLanConnection ( PppoeInfo.TcpIpInfo ) != ERROR_SUCCESS )
    {
        return E_FAIL;
    }

    return ERROR_SUCCESS;
}


DWORD WINAPI InetSSetRfc1483Connection ( RFC1483INFO &Rfc1483Info )
{
    // settings:
    // ---------------------------------------------------
    //     Format:  "RegKey=RegVal" e.g. "Pvc1=10"

//    LPBYTE  lpbNdiBuf = Rfc1483Info.Rfc1483Module.lpbRegNdiParamBuf;
    // BUGBUG: What does lpbSetBuf contain??
    LPBYTE  lpbSetBuf = Rfc1483Info.Rfc1483Module.lpbRegSettingsBuf;
    WCHAR   *eq         = 0;
    DWORD_PTR dwNameSize  = 0;
    DWORD   dwValueSize = 0;
    HKEY    hkeyAdapterClass = NULL;

    // BUGBUG: error checking is ignored. BUG-BUG
    DWORD   nRetVal  = 0;
    if ( (nRetVal = InetSGetAdapterKey ( cszAdapterClass, Rfc1483Info.TcpIpInfo.szPnPId, INETS_ADAPTER_HARDWAREID, DIREG_DRV, hkeyAdapterClass )) != ERROR_SUCCESS )
    {
        return nRetVal;
    }

    while ( *lpbSetBuf )
    {
        if ( !(eq = wcschr ( (WCHAR*)lpbSetBuf, L'=' )) )
        {
            return ERROR_INVALID_PARAMETER;
        }
        // we also disallow the following: "Vci="
        if ( !(*(eq+1)) )
        {
            return ERROR_INVALID_PARAMETER;
        }

        // flush out the '=' so that we have two token strings.
        // we simply move each string directly into the registry.
        *eq = L'\0';
        dwNameSize = eq-(WCHAR*)lpbSetBuf;
        dwValueSize = BYTES_REQUIRED_BY_SZ(eq+1);

        if ( RegSetValueEx ( hkeyAdapterClass, (WCHAR*)lpbSetBuf, 0, REG_SZ, (LPBYTE)eq+1, dwValueSize+1) != ERROR_SUCCESS )
        {
            *eq = L'=';
            return E_FAIL;
        }

        // restore the '=' and move to the next pair "name=value"
        *eq = L'=';
        lpbSetBuf += dwNameSize+dwValueSize+2; // for '=' and '\0'
    }

    if ( InetSSetLanConnection ( Rfc1483Info.TcpIpInfo ) != ERROR_SUCCESS )
    {
        return E_FAIL;
    }

    return ERROR_SUCCESS;
}

// -*-*-*-*-*-*-*-*-*-*-*-*-*-*-* InetSGetAdapterKey -*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-* //
//
// Description:
//              This function returns a Driver Registry Key for a Device.
//
// Arguments:
//              cszDeviceClass  - Any Device Class, e.g. "Net", "NetTrans", etc.
//              cszDeviceParam  - Value that we're using to identify the Device.
//              dwEnumType      - Can be either INETS_ADAPTER_HARDWAREID or
//                                INETS_ADAPTER_INSTANCEID.
//              dwRequiredKeyType - This corresponds to KeyType in SetupDiOpenDevRegKey
//                                  in SetupAPI.
//
//              hkeyDevKey      - Registry Key Handle provided by the caller.
//
// Return Values:
//              ERROR_SUCCESS   - Function returns successfully.
//              Other           - use GetLastError(). Note: hkeyDevKey = INVALID_HANDLE_VALUE in this case.
//
// Remarks:
//              Use this function to browse the Device Manager for Network Devices and Protocol Drivers.
//
DWORD WINAPI InetSGetAdapterKey ( LPCWSTR cszDeviceClass, LPCWSTR cszDeviceParam, DWORD dwEnumType, DWORD dwRequiredKeyType, HKEY &hkeyDevKey ) {

    // initialization of parameter
    hkeyDevKey      = (HKEY) INVALID_HANDLE_VALUE;
    DWORD nRetVal   = ERROR_SUCCESS;

    // We find out the network adapter's TCP/IP Binding first.

    HINSTANCE   hSetupLib = LoadLibrary (L"SetupApi.Dll");
    if (!hSetupLib)
    {
        return GetLastError();
    }

    // Get procedures we need from the DLL.
    LPFNDLL_SETUPDICLASSGUIDSFROMNAME   lpfndll_SetupDiClassGuidsFromName = NULL;
    LPFNDLL_SETUPDIGETCLASSDEVS         lpfndll_SetupDiGetClassDevs       = NULL;
    LPFNDLL_SETUPDIENUMDEVICEINFO       lpfndll_SetupDiEnumDeviceInfo     = NULL;
    LPFNDLL_SETUPDIGETDEVICEREGISTRYPROPERTY    lpfndll_SetupDiGetDeviceRegistryProperty = NULL;
    LPFNDLL_SETUPDIOPENDEVREGKEY        lpfndll_SetupDiOpenDevRegKey      = NULL;
    LPFNDLL_SETUPDIGETDEVICEINSTANCEID  lpfndll_SetupDiGetDeviceInstanceId = NULL;

    if ( !(lpfndll_SetupDiClassGuidsFromName = (LPFNDLL_SETUPDICLASSGUIDSFROMNAME) GetProcAddress ( hSetupLib, cszSetupDiClassGuidsFromName )) )
    {
        nRetVal = GetLastError();
        FreeLibrary ( hSetupLib );
        return nRetVal;
    }
    if ( !(lpfndll_SetupDiGetClassDevs = (LPFNDLL_SETUPDIGETCLASSDEVS) GetProcAddress ( hSetupLib, cszSetupDiGetClassDevs )) )
    {
        nRetVal = GetLastError();
        FreeLibrary ( hSetupLib );
        return nRetVal;
    }
    if ( !(lpfndll_SetupDiEnumDeviceInfo = (LPFNDLL_SETUPDIENUMDEVICEINFO) GetProcAddress ( hSetupLib, "SetupDiEnumDeviceInfo" )) )
    {
        nRetVal = GetLastError();
        FreeLibrary ( hSetupLib );
        return nRetVal;
    }
    if ( !(lpfndll_SetupDiGetDeviceRegistryProperty = (LPFNDLL_SETUPDIGETDEVICEREGISTRYPROPERTY) GetProcAddress ( hSetupLib, cszSetupDiGetDeviceRegistryProperty )) )
    {
        nRetVal = GetLastError();
        FreeLibrary ( hSetupLib );
        return nRetVal;
    }
    if ( !(lpfndll_SetupDiOpenDevRegKey = (LPFNDLL_SETUPDIOPENDEVREGKEY) GetProcAddress ( hSetupLib, "SetupDiOpenDevRegKey" )) )
    {
        nRetVal = GetLastError();
        FreeLibrary ( hSetupLib );
        return nRetVal;
    }
    if ( !(lpfndll_SetupDiGetDeviceInstanceId = (LPFNDLL_SETUPDIGETDEVICEINSTANCEID) GetProcAddress ( hSetupLib, cszSetupDiGetDeviceInstanceId ) ) )
    {
        nRetVal = GetLastError();
        FreeLibrary ( hSetupLib );
        return nRetVal;
    }
    // fantastic. we have the functions. now, on to business.
    // Get Class Guid.
    BOOLEAN     bRet = FALSE;
    DWORD       dwArraySize = 0;
    LPGUID      lpguidArray   = NULL;

    bRet = lpfndll_SetupDiClassGuidsFromName ( cszDeviceClass, NULL, NULL, &dwArraySize );

    // We depend on SetupDiClassGuidsFromName() to provide us with the Guid, and we need to
    // allocate space to accomodate the Guid. If this cannot be done, we are crippled!
    if ( !dwArraySize )
    {
        FreeLibrary ( hSetupLib );
        return ERROR_INVALID_DATA;
    }

    if ( !(lpguidArray      = (LPGUID) malloc (dwArraySize*sizeof(GUID))) )
    {
        FreeLibrary ( hSetupLib );
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    if ( !(bRet = (lpfndll_SetupDiClassGuidsFromName ( cszDeviceClass, lpguidArray, dwArraySize, &dwArraySize )) ) )
    {
        FreeLibrary ( hSetupLib );
        free ( lpguidArray );
        return ERROR_INVALID_FUNCTION;

    }

    // we retrieve the list of devices.
    HDEVINFO    hdevNetDeviceList = lpfndll_SetupDiGetClassDevs ( lpguidArray, NULL, NULL, DIGCF_PRESENT );
    if ( !hdevNetDeviceList )
    {
        FreeLibrary ( hSetupLib );
        free ( lpguidArray );
        return ERROR_INVALID_FUNCTION;
    }

    free ( lpguidArray ); // where shall we do this garbage collection ?

    // we will now enumerate through the list of Net devices.
    SP_DEVINFO_DATA     DevInfoStruct;
    memset ( &DevInfoStruct, 0, sizeof (DevInfoStruct) );
    DevInfoStruct.cbSize = sizeof (DevInfoStruct);
    int i = 0;

    LPBYTE  lpbHardwareIdBuf    = NULL;
    DWORD   dwHardwareIdBufSize = 0;
    DWORD   dwRequiredSize      = 0;
    BOOL    bFound              = FALSE;
    const   DWORD cdwIncrement  = 500;  // BUGBUG: What's magic about 500??

    if ( !(lpbHardwareIdBuf = (LPBYTE) malloc (500)) )
    {
        FreeLibrary ( hSetupLib );
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    dwHardwareIdBufSize = 500;

    while ( bRet = ( lpfndll_SetupDiEnumDeviceInfo (hdevNetDeviceList, i, &DevInfoStruct )) )
    {

        // for each Net device, we will compare its hardware ID to the one
        // provided in the parameter.
        switch ( dwEnumType )
        {
        case INETS_ADAPTER_HARDWAREID:
            while ( !(bRet = lpfndll_SetupDiGetDeviceRegistryProperty ( hdevNetDeviceList, &DevInfoStruct, SPDRP_HARDWAREID, NULL, lpbHardwareIdBuf, dwHardwareIdBufSize, &dwRequiredSize )) && ((nRetVal = GetLastError()) == ERROR_INSUFFICIENT_BUFFER ))
            {       // we need to reallocate the buffer size.
                if ( !dwRequiredSize ) dwHardwareIdBufSize += cdwIncrement;
                else dwHardwareIdBufSize += dwRequiredSize;
                if ( !(lpbHardwareIdBuf = (LPBYTE) realloc ( (void*) lpbHardwareIdBuf, dwHardwareIdBufSize )) )
                {
                    // not enough memory!
                    free (lpbHardwareIdBuf);
                    FreeLibrary ( hSetupLib );
                    return ERROR_NOT_ENOUGH_MEMORY;
                }
            }
            break;
        case INETS_ADAPTER_INSTANCEID:
            while ( !(bRet = lpfndll_SetupDiGetDeviceInstanceId ( hdevNetDeviceList, &DevInfoStruct, (PCWSTR) lpbHardwareIdBuf, dwHardwareIdBufSize, &dwRequiredSize )) && ((nRetVal = GetLastError()) == ERROR_INSUFFICIENT_BUFFER ))
            {
                // we need to reallocate the buffer size.
                if ( !dwRequiredSize ) dwHardwareIdBufSize += cdwIncrement;
                else dwHardwareIdBufSize += dwRequiredSize;
                if ( !(lpbHardwareIdBuf = (LPBYTE) realloc ( (void*) lpbHardwareIdBuf, dwHardwareIdBufSize )) )
                {
                    // not enough memory!
                    free (lpbHardwareIdBuf);
                    FreeLibrary ( hSetupLib );
                    return ERROR_NOT_ENOUGH_MEMORY;
                }
            }
            break;
        default:
            free (lpbHardwareIdBuf);
            FreeLibrary ( hSetupLib );
            return ERROR_INVALID_PARAMETER;
        }
        if ( bRet )
        {
                // we should have the hardware ID, at this stage. we compare it with
                // the device's plug-and-play ID.
            // BUGBUG: Is lpbHardwareIdBuf ANSI or Unicode?
                if ( wcsstr( (const WCHAR *)lpbHardwareIdBuf, cszDeviceParam) )
                {
                    // found!
                    bFound = TRUE;
                    // we get the device's registry key.
                    if ( (hkeyDevKey = lpfndll_SetupDiOpenDevRegKey ( hdevNetDeviceList, &DevInfoStruct, DICS_FLAG_GLOBAL, 0, dwRequiredKeyType, KEY_ALL_ACCESS )) == INVALID_HANDLE_VALUE )
                    {
                        free (lpbHardwareIdBuf);
                        FreeLibrary ( hSetupLib );
                        return ERROR_BADKEY;
                    }
                    free (lpbHardwareIdBuf);
                    FreeLibrary ( hSetupLib );
                    return ERROR_SUCCESS;
                }
        }
        i++;
    }
    // the while loop enumerated unsuccessfully.
    free (lpbHardwareIdBuf);
    FreeLibrary ( hSetupLib );
    return ERROR_NOT_FOUND;
}


DWORD WINAPI InetSSetLanConnection ( LANINFO& LANINFO )
{
    HKEY    hkeyAdapter = NULL;
    DWORD   nRetVal     = 0;
    HKEY    hkeyGlobalTcp = NULL;
    LPBYTE  lpbBufPtr   = NULL;
    DWORD   dwValueBufSize  = 0;
    WCHAR   *Token = NULL, *PlaceHolder = NULL;
    WCHAR   *WINSListPtr = NULL;
    // TCP/IP InstanceID ==> Class Key
    HKEY    hkeyClassTcp = NULL;
    HKEY    hkeyAdapterBinding = NULL;

    __try
    {
        // PnPId ==> Device Configuration Key
        if ( (nRetVal = InetSGetAdapterKey ( cszAdapterClass, LANINFO.szPnPId, INETS_ADAPTER_HARDWAREID, DIREG_DEV, hkeyAdapter)) != ERROR_SUCCESS )
        {
            __leave;
        }


        // Open the Bindings subkey to look for TCP/IP Binding.
        if ( RegOpenKeyEx ( hkeyAdapter, cszRegBindings, 0, KEY_ALL_ACCESS, &hkeyAdapterBinding ) != ERROR_SUCCESS )
        {
            nRetVal = GetLastError();
            __leave;
        }

        // Find the TCP/IP binding.
        WCHAR        szBindingValueName [GEN_MAX_STRING_LENGTH];
        DWORD       dwBindingValueNameSize = sizeof (szBindingValueName) / sizeof(WCHAR);
        int index = 0;
        while ( RegEnumValue ( hkeyAdapterBinding, index, szBindingValueName, &dwBindingValueNameSize, 0, 0, 0, 0 ) == ERROR_SUCCESS )
        {
            if ( !wcsncmp ( szBindingValueName, cszRegTcpIp, sizeof (cszRegTcpIp)-1 ) )
            {
                // we found a binding!
                break;
            }
            index++;
        }


        if ( (nRetVal = InetSGetAdapterKey ( cszProtocolClass, szBindingValueName, INETS_ADAPTER_INSTANCEID, DIREG_DRV, hkeyClassTcp )) != ERROR_SUCCESS )
        {
            nRetVal = GetLastError();
            __leave;
        }


        // Got it. we will now start the update.
        //
        // IP Address
        //
        lpbBufPtr      = 0;
        dwValueBufSize = 0;
        if ( LANINFO.TcpIpInfo.EnableIP )
        {
            lpbBufPtr   = (LPBYTE) LANINFO.TcpIpInfo.szIPAddress;
            dwValueBufSize = BYTES_REQUIRED_BY_SZ(LANINFO.TcpIpInfo.szIPAddress);
            if (RegSetValueEx ( hkeyClassTcp, cszRegIPAddress, 0, REG_SZ, lpbBufPtr, dwValueBufSize) != ERROR_SUCCESS)
            {
                // close handles also!
                nRetVal = E_FAIL;
                __leave;
            }
            lpbBufPtr   = (LPBYTE) LANINFO.TcpIpInfo.szIPMask;
            dwValueBufSize = BYTES_REQUIRED_BY_SZ(LANINFO.TcpIpInfo.szIPMask);
            if (RegSetValueEx ( hkeyClassTcp, cszRegIPMask, 0, REG_SZ, lpbBufPtr, dwValueBufSize) != ERROR_SUCCESS)
            {
                // close handles also!
                nRetVal = E_FAIL;
                __leave;
            }
        }
        else
        {
            lpbBufPtr   = (LPBYTE) cszNullIP;
            dwValueBufSize = BYTES_REQUIRED_BY_SZ(cszNullIP);
            if (RegSetValueEx ( hkeyClassTcp, cszRegIPAddress, 0, REG_SZ, lpbBufPtr, dwValueBufSize) != ERROR_SUCCESS)
            {
                // close handles also!
                nRetVal = E_FAIL;
                __leave;
            }
            if (RegSetValueEx ( hkeyClassTcp, cszRegIPMask, 0, REG_SZ, lpbBufPtr, dwValueBufSize) != ERROR_SUCCESS)
            {
                // close handles also!
                nRetVal = E_FAIL;
                __leave;
            }
        }

        //
        // WINS
        //
        lpbBufPtr =  0;
        dwValueBufSize = 0;
        index = 1;
        WCHAR        szWINSEntry [GEN_MAX_STRING_LENGTH];
        WCHAR        szWINSListCopy [GEN_MAX_STRING_LENGTH];
        WINSListPtr = szWINSListCopy;
        // BUGBUG: Is LANINFO.TcpIpInfo.szWINSList ANSI or Unicode?
        lstrcpy (WINSListPtr, LANINFO.TcpIpInfo.szWINSList);


        wsprintf (szWINSEntry, L"%s%d", cszRegWINS, index);
        PlaceHolder = szWINSEntry+lstrlen(cszRegWINS);


        if ( LANINFO.TcpIpInfo.EnableWINS )
        {
            while ( Token = wcstok ((index > 1) ? NULL : WINSListPtr, L", " )) { // WARNING. wcstok uses static data! Also the whitespace in ", " is necessary!
                if (!Token)
                {
                    nRetVal = E_FAIL;
                    __leave;
                }
                lpbBufPtr   = (LPBYTE) Token;
                dwValueBufSize = BYTES_REQUIRED_BY_SZ(Token);
                if (RegSetValueEx ( hkeyClassTcp, szWINSEntry, 0, REG_SZ, lpbBufPtr, dwValueBufSize) != ERROR_SUCCESS)
                {
                    // close handles also!
                    nRetVal = E_FAIL;
                    __leave;
                }
                wsprintf (PlaceHolder, L"%d", ++index);
            }
            if (RegSetValueEx ( hkeyClassTcp, cszNodeType, 0, REG_SZ, (LPBYTE) L"8", sizeof (L"8") ) != ERROR_SUCCESS)
            {
                nRetVal = E_FAIL;
                __leave;
            }
        }
        else
        {
            // TODO: Remove all instances of NameServerX <== IMPORTANT
            index = 0;
            WCHAR    szEnumValueBuffer[GEN_MAX_STRING_LENGTH];
            DWORD   dwEnumValueBufferSize;
            while ( RegEnumValue ( hkeyClassTcp, index, szEnumValueBuffer, &(dwEnumValueBufferSize=sizeof(szEnumValueBuffer)/sizeof(WCHAR)), 0, 0, 0, 0 ) != ERROR_NO_MORE_ITEMS )
            {
                if ( !wcsncmp (szEnumValueBuffer, cszRegWINS, sizeof (cszRegWINS)-1) )
                {
                    if ( RegDeleteValue ( hkeyClassTcp, szEnumValueBuffer ) != ERROR_SUCCESS )
                    {
                        nRetVal = E_FAIL;
                        __leave;
                    }
                    continue;
                }
                index++;
            }
            if (RegSetValueEx ( hkeyClassTcp, cszNodeType, 0, REG_SZ, (LPBYTE) L"1", sizeof (L"1") ) != ERROR_SUCCESS)
            {
                nRetVal = E_FAIL;
                __leave;
            }

        }

        //
        // Default Gateway
        //
        lpbBufPtr   = (LPBYTE) LANINFO.TcpIpInfo.szDefaultGatewayList;
        dwValueBufSize = BYTES_REQUIRED_BY_SZ (LANINFO.TcpIpInfo.szDefaultGatewayList);
        if (RegSetValueEx ( hkeyClassTcp, cszRegDefaultGateway, 0, REG_SZ, lpbBufPtr, dwValueBufSize) != ERROR_SUCCESS)
        {
            // close handles also!
            nRetVal = E_FAIL;
            __leave;
        }



        // Step 4:  Update global TCPIP entries (DNS)
        if ( RegOpenKeyEx ( HKEY_LOCAL_MACHINE, cszRegFixedTcpInfoKey, 0, KEY_ALL_ACCESS, &hkeyGlobalTcp) != ERROR_SUCCESS )
        {
            // close keys
            nRetVal = E_FAIL;
            __leave;
        }

        if ( LANINFO.TcpIpInfo.EnableDNS )
        {
            lpbBufPtr   = (LPBYTE) LANINFO.TcpIpInfo.szHostName;
            dwValueBufSize = BYTES_REQUIRED_BY_SZ (LANINFO.TcpIpInfo.szHostName);
            if (RegSetValueEx ( hkeyGlobalTcp, cszRegHostName, 0, REG_SZ, lpbBufPtr, dwValueBufSize) != ERROR_SUCCESS)
            {
                // close handles also!
                nRetVal = E_FAIL;
                __leave;
            }
            lpbBufPtr   = (LPBYTE) LANINFO.TcpIpInfo.szDomainName;
            dwValueBufSize = BYTES_REQUIRED_BY_SZ (LANINFO.TcpIpInfo.szDomainName);
            if (RegSetValueEx ( hkeyGlobalTcp, cszRegDomainName, 0, REG_SZ, lpbBufPtr, dwValueBufSize) != ERROR_SUCCESS)
            {
                // close handles also!
                nRetVal = E_FAIL;
                __leave;
            }
            lpbBufPtr   = (LPBYTE) LANINFO.TcpIpInfo.szDNSList;
            dwValueBufSize = BYTES_REQUIRED_BY_SZ (LANINFO.TcpIpInfo.szDNSList);
            if (RegSetValueEx ( hkeyGlobalTcp, cszRegNameServer, 0, REG_SZ, lpbBufPtr, dwValueBufSize) != ERROR_SUCCESS)
            {
                // close handles also!
                nRetVal = E_FAIL;
                __leave;
            }
            lpbBufPtr   = (LPBYTE) LANINFO.TcpIpInfo.szSuffixSearchList;
            dwValueBufSize = BYTES_REQUIRED_BY_SZ (LANINFO.TcpIpInfo.szSuffixSearchList);
            if (RegSetValueEx ( hkeyGlobalTcp, cszRegSuffixSearchList, 0, REG_SZ, lpbBufPtr, dwValueBufSize) != ERROR_SUCCESS)
            {
                // close handles also!
                nRetVal = E_FAIL;
                __leave;
            }
            if (RegSetValueEx ( hkeyGlobalTcp, cszRegEnableDNS, 0, REG_SZ, (LPBYTE)L"1", sizeof(L"1")) != ERROR_SUCCESS)
            {
                // close handles also!
                nRetVal = E_FAIL;
                __leave;
            }

        }
        else
        {
            if (RegSetValueEx ( hkeyGlobalTcp, cszRegEnableDNS, 0, REG_SZ, (LPBYTE)L"0", sizeof(L"0")) != ERROR_SUCCESS)
            {
                // close handles also!
                nRetVal = E_FAIL;
                __leave;
            }

        }
        WCHAR   szScopeID[GEN_MAX_STRING_LENGTH];
        if ( LANINFO.TcpIpInfo.EnableWINS )
        {
            if (LANINFO.TcpIpInfo.uiScopeID == (UINT)~0x0) // this line implies that no ScopeID is given.
            {
                if ( RegSetValueEx ( hkeyGlobalTcp, cszScopeID, 0, REG_SZ, (LPBYTE)L"", sizeof(L"") ) )
                {
                    nRetVal = E_FAIL;
                    __leave;
                }
            }
            else if (RegSetValueEx(hkeyGlobalTcp,
                                   cszScopeID,
                                   0,
                                   REG_SZ,
                                   (LPBYTE)_itow( LANINFO.TcpIpInfo.uiScopeID, szScopeID, 10 ),
                                   BYTES_REQUIRED_BY_SZ(szScopeID)
                                   ) != ERROR_SUCCESS )
            {
                nRetVal = E_FAIL;
                __leave;
            }
        }
        else
        {
            if ( RegDeleteValue ( hkeyGlobalTcp, cszScopeID ) != ERROR_SUCCESS )
            {
                nRetVal = E_FAIL;
                __leave;
            }
        }
        }

        // end.
        __finally
        {
            if ( hkeyAdapter )
            {
                RegCloseKey ( hkeyAdapter );
            }
            if ( hkeyGlobalTcp )
            {
                RegCloseKey ( hkeyGlobalTcp );
            }
            if ( hkeyAdapterBinding )
            {
                RegCloseKey ( hkeyAdapterBinding );
            }
            if ( hkeyClassTcp )
            {
                RegCloseKey ( hkeyClassTcp );
            }
        }

        return nRetVal;
}
/*
int main() {

    CInetSetup inetSetup;
    const   WCHAR    cszINS[] = L"C:\\test.ins";
    LANINFO LanInfo;
    RASINFO RasInfo;
    memset ( &RasInfo, 0, sizeof(RASINFO) );
    memset ( &LanInfo, 0, sizeof(LANINFO) );

    RasInfo.dwDeviceInfoSize = sizeof(ATMPBCONFIG);
    RasInfo.lpDeviceInfo     = (LPBYTE) malloc (sizeof (ATMPBCONFIG));
    RasInfo.RasEntry.dwSize = sizeof (RASENTRY);
    RasInfo.RasEntry.dwfNetProtocols = RASNP_Ip;
    RasInfo.RasEntry.dwFramingProtocol = RASFP_Ppp;
    lstrcpy ( RasInfo.RasEntry.szDeviceType, RASDT_Modem );
    lstrcpy ( RasInfo.RasEntry.szDeviceName, L"Standard 56000 bps V90 Modem"  );
    lstrcpy ( RasInfo.RasEntry.szLocalPhoneNumber, L"5551212"    );
    lstrcpy ( RasInfo.szEntryName, L"Test1" );
    lstrcpy ( RasInfo.szPhoneBook, L""      );



    inetSetup.InetSImportLanConnection ( LanInfo, cszINS );
    inetSetup.InetSSetLanConnection ( LanInfo );

    inetSetup.InetSSetRasConnection ( RasInfo );
    free ( RasInfo.lpDeviceInfo );
    return 0;
}

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobcomm\inetprop.h ===
#ifndef _INETPROP_H
#define _INETPROP_H

//---[ INETPROP.H ]--------------------------------------------------------
//
//  Definitions used by the the Inet transports, address books
//  and other Inet providers for service entry calls.
//
//  $$REVIEW This was stolen from Blade's MSFS.H (stolen from somewhere else)
//
//  The following INET-defined properties are settable in service entry
//  calls.  They are grouped by function. I've tried to maintain as much compatibility
//  with the Blade proptags, just to keep things easy.
//
//-------------------------------------------------------------------------

// $$REVIEW: What is this RAS_MaxEntryName doing in here?

#ifdef WIN32
#include <ras.h>
#else
#define RAS_MaxEntryName    20
#endif

#define MAIL_PROP_COUNT     42   // Not including the sess one.
#define NEWS_PROP_COUNT     19   // Not including the sess one.

//---[ Generic Connection Properties ]-------------------------------------
#define PR_CFG_SERVER_PATH              PROP_TAG (PT_TSTRING,   0x6600)
#define PR_CFG_CONN_TYPE                PROP_TAG (PT_LONG,      0x6601)
#define PR_CFG_SESSION_LOG              PROP_TAG (PT_LONG, 		0x6602)
#define PR_CFG_SESSION_LOG_FILE         PROP_TAG (PT_TSTRING,   0x6603)
#define PR_CFG_SESSION_LOG_FILTER_INDEX	PROP_TAG (PT_LONG,		0x6604)

//---[ IMail Connection Properties ]---------------------------------------
#define PR_CFG_EMAIL_ADDRESS            PROP_TAG (PT_TSTRING,   0x6605)
#define PR_CFG_EMAIL_ACCOUNT            PROP_TAG (PT_TSTRING,   0x6606)
#define PR_CFG_EMAIL_DISPLAY_NAME       PROP_TAG (PT_TSTRING,   0x6607)
//#define PR_CFG_PASSWORD                 PROP_TAG (PT_TSTRING,   0x6608)
#define PR_CFG_PASSWORD                 PROP_TAG (PT_TSTRING,   PROP_ID_SECURE_MIN)
#define PR_CFG_REMEMBER                 PROP_TAG (PT_BOOLEAN,   0x6610)
#define PR_CFG_OUTBOUND_MAIL_HOST       PROP_TAG (PT_TSTRING,   0x6611)

//---[ INews Connection Properties ]---------------------------------------
#define PR_CFG_NEWS_EMAIL_ADDRESS		PROP_TAG (PT_TSTRING,	0x6600)
#define PR_CFG_NEWS_DISPLAY_NAME		PROP_TAG (PT_TSTRING,	0x6601)
#define PR_CFG_NEWS_SERVER_NAME			PROP_TAG (PT_TSTRING,	0x6610)
#define PR_CFG_CONNECTION_TYPE			PROP_TAG (PT_LONG,		0x6603)
#define PR_CFG_CONNECTION_PROFILE		PROP_TAG (PT_TSTRING,	0x6604)

//---[ Advanced Properties ]-----------------------------------------------
 
#define PR_CFG_BODY_FORMAT              PROP_TAG (PT_LONG,      0x6620)
#define PR_CFG_TEXT_CHAR_SET            PROP_TAG (PT_TSTRING,   0x6621)
#define PR_CFG_MIME_CHAR_SET            PROP_TAG (PT_TSTRING,   0x6622)
#define PR_CFG_ENCODING_MINIMUM         PROP_TAG (PT_LONG,      0x6623)
#define PR_CFG_ENCODE_LINES             PROP_TAG (PT_BOOLEAN,   0x6624)
 
//---[ Remote Config Properties ]------------------------------------------

#define PR_CFG_SESSION_START_TYPE       PROP_TAG (PT_LONG,      0x6630)
#define PR_CFG_RNA_PROFILE              PROP_TAG (PT_TSTRING,   0x6631)
#define PR_CFG_RNA_PROFILE_ALWAYS       PROP_TAG (PT_BOOLEAN,   0x6632)
#define PR_CFG_RNA_CONFIRM              PROP_TAG (PT_LONG,      0x6633)
#define PR_CFG_REMOTE_CONNECT_TIMEOUT	PROP_TAG (PT_LONG,		0x6634)
#define PR_CFG_REMOTE_USERNAME			PROP_TAG (PT_TSTRING,	0x6635)
//#define PR_CFG_REMOTE_PASSWORD			PROP_TAG (PT_TSTRING,	0x6636)
#define PR_CFG_REMOTE_PASSWORD		PROP_TAG (PT_TSTRING,	PROP_ID_SECURE_MIN+1)

#define PR_CFG_NEWS_REMOTE_USERNAME		PROP_TAG (PT_TSTRING,	0x6620)
#define PR_CFG_NEWS_REMOTE_PASSWORD		PROP_TAG (PT_TSTRING, 	0x6621)   

//---[ Generic Delivery Options ]------------------------------------------

#define PR_CFG_DELIVERY_OPTIONS         PROP_TAG (PT_LONG,      0x6640)
#define PR_CFG_MSG_CHECK_WAIT           PROP_TAG (PT_LONG,      0x6641)

//---[ News Delivery Options ]---------------------------------------------

#define PR_CFG_NEW_GROUP_NOTIFY         PROP_TAG (PT_BOOLEAN,   0x6642)
#define PR_CFG_DEAD_GROUP_NOTIFY        PROP_TAG (PT_BOOLEAN,   0x6643)
#define PR_CFG_NEW_MESSAGE_NOTIFY       PROP_TAG (PT_BOOLEAN,   0x6644)
 
//---[ Other data ]--------------------------------------------------------

#define PR_CFG_SMTP_PORT                PROP_TAG (PT_LONG,   	0x6650)
#define PR_CFG_POP3_PORT                PROP_TAG (PT_LONG,   	0x6651)

#define PR_CFG_SMTP_TIMEOUT_CONNECT     PROP_TAG (PT_LONG,   	0x6660)
#define PR_CFG_SMTP_TIMEOUT_HELO        PROP_TAG (PT_LONG,   	0x6661)
#define PR_CFG_SMTP_TIMEOUT_MAILFROM    PROP_TAG (PT_LONG,   	0x6662)
#define PR_CFG_SMTP_TIMEOUT_RCPT        PROP_TAG (PT_LONG,   	0x6663)
#define PR_CFG_SMTP_TIMEOUT_DATAINIT    PROP_TAG (PT_LONG,   	0x6664)
#define PR_CFG_SMTP_TIMEOUT_DATABLOK    PROP_TAG (PT_LONG,   	0x6665)
#define PR_CFG_SMTP_TIMEOUT_RSET        PROP_TAG (PT_LONG,   	0x6666)
#define PR_CFG_SMTP_TIMEOUT_QUIT        PROP_TAG (PT_LONG,   	0x6667)
#define PR_CFG_SMTP_TIMEOUT_CLOSE       PROP_TAG (PT_LONG,   	0x6668)
#define PR_CFG_POP3_TIMEOUT_CONNECT     PROP_TAG (PT_LONG,   	0x6669)
#define PR_CFG_POP3_TIMEOUT_SEND        PROP_TAG (PT_LONG,   	0x6670)
#define PR_CFG_POP3_TIMEOUT_RECEIVE     PROP_TAG (PT_LONG,   	0x6671)
#define PR_CFG_SMTP_TIMEOUT_DATAACPT    PROP_TAG (PT_LONG,   	0x6672)

//---[ Remote Header Cache Props ]-----------------------------------------

#define PR_CFG_REMOTE_CACHE_TIMEOUT		PROP_TAG (PT_LONG,		0x6673)
#define PR_CFG_REMOTE_CACHE_NAME		PROP_TAG (PT_TSTRING,	0x6674)

//---[ INews PST Properties ]----------------------------------------------
#define PR_CFG_PST_PATH                 PROP_TAG (PT_TSTRING,   0x6680)

//---[ IMail Message Class String ]----------------------------------------

// The strings themselves are defined in mapiopt.h

extern WCHAR lpstrMsgClassRFC822[];
extern WCHAR lpstrMsgClassRFCMIME[];

#endif // _INETPROP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobcomm\inets.h ===
// inets.h: interface for the CInetSetup class.
//
//
//              Thomas A. Jeyaseelan [thomasje]
//              Capability:  RAS: (modem, isdn, atm)
//                           LAN: (cable,  ethernet) - As of  8 Dec 99
//                          1483:                    - As of 14 Dec 99
//
//////////////////////////////////////////////////////////////////////

// Note. These APIs are do not have OOBE dependencies and are fully self-
// sufficient. However, they can *ONLY* be run on Windows 9x machines.

#if !defined(AFX_INETSETUP_H__E5B39864_835C_41EE_A773_A5010699D1DE__INCLUDED_)
#define AFX_INETSETUP_H__E5B39864_835C_41EE_A773_A5010699D1DE__INCLUDED_

#pragma pack (push, inets, 4)

#include <windows.h>
#include "wancfg.h"
#include <ras.h>
#include <stdlib.h>
#include <malloc.h>
#include <tchar.h>
#include <string.h>
#include <setupapi.h>



#define PNP_MAX_STRING_LENGTH 260
#define GEN_MAX_STRING_LENGTH 260
#define NET_MAX_STRING_LENGTH 260
#define VXD_MAX_STRING_LENGTH 260


#define	INETS_ADAPTER_HARDWAREID		0x00000001
#define INETS_ADAPTER_INSTANCEID		0x00000002


// -*-*-*-*-*-*-*-*-*-*-* InetSGetDeviceRegistryKey -*-*-*-*-*-*-*-*-*-*-*-* //
typedef WINSETUPAPI BOOLEAN     (WINAPI *LPFNDLL_SETUPDICLASSGUIDSFROMNAME)
 (PCWSTR,    LPGUID, DWORD,  PDWORD);
typedef WINSETUPAPI HDEVINFO    (WINAPI *LPFNDLL_SETUPDIGETCLASSDEVS)
 (LPGUID,   PCWSTR, HWND,   DWORD);
typedef WINSETUPAPI BOOLEAN		(WINAPI *LPFNDLL_SETUPDIGETDEVICEINSTANCEID)
 (HDEVINFO,	PSP_DEVINFO_DATA,	PCWSTR,	DWORD,	PDWORD);

static const CHAR  cszSetupDiClassGuidsFromName[]  = "SetupDiClassGuidsFromNameW";
static const CHAR  cszSetupDiGetClassDevs[]        = "SetupDiGetClassDevsW";
static const CHAR	cszSetupDiGetDeviceRegistryProperty[] = "SetupDiGetDeviceRegistryPropertyW";
static const CHAR	cszSetupDiGetDeviceInstanceId[]	= "SetupDiGetDeviceInstanceIdW";

typedef WINSETUPAPI BOOLEAN     (WINAPI *LPFNDLL_SETUPDIENUMDEVICEINFO)
 (HDEVINFO, DWORD,  PSP_DEVINFO_DATA);
typedef WINSETUPAPI BOOLEAN     (WINAPI *LPFNDLL_SETUPDIGETDEVICEREGISTRYPROPERTY)
 (HDEVINFO, PSP_DEVINFO_DATA,   DWORD,  PDWORD, PBYTE,  DWORD,  PDWORD);
typedef WINSETUPAPI HKEY		(WINAPI *LPFNDLL_SETUPDIOPENDEVREGKEY)
 (HDEVINFO,	PSP_DEVINFO_DATA,	DWORD,	DWORD,	DWORD,	REGSAM);

// -*-*-*-*-*-*-*-*-*-*-* end InetSGetDeviceRegistryKey -*-*-*-*-*-*-*-*-*-*-*-* //



// The following structure is the generic TCP INFO structure. It will
// be used by all services to extract and use TCP Information.

typedef struct _TCPIP_INFO_EXT {
    DWORD           dwSize;             // versioning information
    //
    // IP Address - AutoIP is considered to be TRUE for Dial-up Adapters
    //
    DWORD           EnableIP;
    WCHAR            szIPAddress[NET_MAX_STRING_LENGTH];
    WCHAR            szIPMask[NET_MAX_STRING_LENGTH];
    //
    // Default Gateway 
    //
    WCHAR            szDefaultGatewayList[NET_MAX_STRING_LENGTH]; // n.n.n.n, n.n.n.n, ... 
    //
    // DHCP Info - where is this placed?
    //
    DWORD           EnableDHCP;
    WCHAR            szDHCPServer[NET_MAX_STRING_LENGTH];
    //
    // DNS - This is global and will overwrite existing settings.
    //
    DWORD           EnableDNS;
    WCHAR            szHostName[NET_MAX_STRING_LENGTH];
    WCHAR            szDomainName[NET_MAX_STRING_LENGTH];
    WCHAR            szDNSList[NET_MAX_STRING_LENGTH]; // n.n.n.n, n.n.n.n, ...
	WCHAR            szSuffixSearchList[NET_MAX_STRING_LENGTH];
    //
    // WINS
    //
    DWORD           EnableWINS;
    WCHAR            szWINSList[NET_MAX_STRING_LENGTH]; // n.n.n.n, n.n.n.n, ...
    UINT            uiScopeID;
    //
    //
    //
} TCPIP_INFO_EXT, *PTCPIP_INFO_EXT, FAR * LPTCPIP_INFO_EXT;

typedef struct      _RFC1483_INFO_EXT {
    DWORD           dwSize;
    DWORD           dwRegSettingsBufSize;
    // DWORD           dwRegNdiParamBufSize;
    LPBYTE          lpbRegSettingsBuf;
    // LPBYTE          lpbRegNdiParamBuf;
} RFC1483_INFO_EXT, * PRFC1483_INFO_EXT, FAR * LPRFC1483_INFO_EXT;

typedef struct      _PPPOE_INFO_EXT {
    DWORD           dwSize;
    DWORD           dwRegSettingsBufSize;
    // DWORD           dwRegNdiParamBufSize;
    LPBYTE          lpbRegSettingsBuf;
    // LPBYTE          lpbRegNdiParamBuf;
} PPPOE_INFO_EXT, * PPPPOE_INFO_EXT, FAR * LPPPPOE_INFO_EXT;


typedef struct      _LANINFO {
    DWORD               dwSize;
    TCPIP_INFO_EXT      TcpIpInfo;
    WCHAR                szPnPId[PNP_MAX_STRING_LENGTH];
} LANINFO, * PLANINFO, FAR * LPLANINFO;


typedef struct      _RASINFO {
    DWORD           dwSize;
    WCHAR            szPhoneBook[GEN_MAX_STRING_LENGTH];
    WCHAR            szEntryName[GEN_MAX_STRING_LENGTH];
    LPBYTE          lpDeviceInfo;
    DWORD           dwDeviceInfoSize;
    RASENTRY        RasEntry;
} RASINFO, *LPRASINFO, FAR * LPRASINFO;

typedef struct      _RFC1483INFO {
    DWORD               dwSize;
    RFC1483_INFO_EXT    Rfc1483Module;
    LANINFO          TcpIpInfo;
} RFC1483INFO, * PRFC1483INFO, FAR * LPRFC1483INFO;

typedef struct      _PPPOEINFO {
    DWORD             dwSize;
    PPPOE_INFO_EXT    PppoeModule;
    LANINFO           TcpIpInfo;
} PPPOEINFO, * PPPPOEINFO, FAR * LPPPPOEINFO;

DWORD WINAPI InetSSetRasConnection ( RASINFO& RasEntry );
DWORD WINAPI InetSSetLanConnection ( LANINFO& LanInfo  );
DWORD WINAPI InetSSetRfc1483Connection ( RFC1483INFO &Rfc1483Info );
DWORD WINAPI InetSSetPppoeConnection ( PPPOEINFO& PppoeInfo );

// helper routines //
DWORD WINAPI InetSGetAdapterKey ( LPCWSTR cszDeviceClass, LPCWSTR cszDeviceParam, DWORD dwEnumType, DWORD dwRequiredKeyType, HKEY &hkeyDevKey );

#endif // !defined(AFX_INETSETUP_H__E5B39864_835C_41EE_A773_A5010699D1DE__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\oobe\msobcomm\inshdlr.cpp ===
/*-----------------------------------------------------------------------------
    INSHandler.cpp

    Implementation of CINSHandler - INS file processing

    Copyright (C) 1999 Microsoft Corporation
    All rights reserved.

    Authors:
        vyung
        thomasje

    History:
        2/7/99      Vyung created - code borrowed from ICW, icwhelp.dll
        10/30/99    Thomasje modified - Broadband support (1483, PPPOA)

-----------------------------------------------------------------------------*/

#include "msobcomm.h"
#include <shellapi.h>

#include "inshdlr.h"
#include "webgate.h"
#include "import.h"
#include "rnaapi.h"

#include "inetreg.h"


#include "wininet.h"
#include "appdefs.h"
#include "util.h"
#include "wancfg.h"
#include "inets.h"

#define MAXNAME                     80
#define MAXIPADDRLEN                20
#define MAXLONGLEN                  80
#define MAX_ISP_MSG                 560
#define MAX_ISP_PHONENUMBER         80


#define CCH_ReadBuf                 (SIZE_ReadBuf / sizeof(WCHAR))    // 32K buffer size
#define myisdigit(ch)               (((ch) >= L'0') && ((ch) <= L'9'))
#define IS_PROXY                    L"Proxy"
#define IK_PROXYENABLE              L"Proxy_Enable"
#define IK_HTTPPROXY                L"HTTP_Proxy_Server"

// ICW INS PROCESSING FAIL
#define OEM_CONFIG_INS_FILENAME      L"icw\\OEMCNFG.INS"
#define OEM_CONFIG_REGKEY            L"SOFTWARE\\Microsoft\\Internet Connection Wizard\\INS processing"
#define OEM_CONFIG_REGVAL_FAILED     L"Process failed"
#define OEM_CONFIG_REGVAL_ISPNAME    L"ISP name"
#define OEM_CONFIG_REGVAL_SUPPORTNUM L"Support number"
#define OEM_CONFIG_INS_SECTION       L"Entry"
#define OEM_CONFIG_INS_ISPNAME       L"Entry_Name"
#define OEM_CONFIG_INS_SUPPORTNUM    L"Support_Number"

typedef HRESULT (WINAPI * INTERNETSETOPTION) (IN HINTERNET hInternet OPTIONAL, IN DWORD dwOption, IN LPVOID lpBuffer, IN DWORD dwBufferLength);
typedef HRESULT (WINAPI * INTERNETQUERYOPTION) (IN HINTERNET hInternet OPTIONAL, IN DWORD dwOption, IN LPVOID lpBuffer, IN LPDWORD dwBufferLength);

extern CObCommunicationManager* gpCommMgr;

// The following values are global read only strings used to
// process the INS file
#pragma data_seg(".rdata")

static const WCHAR cszAlias[]        = L"Import_Name";
static const WCHAR cszML[]           = L"Multilink";

static const WCHAR cszPhoneSection[] = L"Phone";
static const WCHAR cszDialAsIs[]     = L"Dial_As_Is";
static const WCHAR cszPhone[]        = L"Phone_Number";
static const WCHAR cszAreaCode[]     = L"Area_Code";
static const WCHAR cszCountryCode[]  = L"Country_Code";
static const WCHAR cszCountryID[]    = L"Country_ID";

static const WCHAR cszDeviceSection[] = L"Device";
static const WCHAR cszDeviceType[]    = L"Type";
static const WCHAR cszDeviceName[]    = L"Name";
static const WCHAR cszDevCfgSize[]    = L"Settings_Size";
static const WCHAR cszDevCfg[]        = L"Settings";

static const WCHAR cszPnpId[]         = L"Plug_and_Play_Id";

static const WCHAR cszServerSection[] = L"Server";
static const WCHAR cszServerType[]    = L"Type";
static const WCHAR cszSWCompress[]    = L"SW_Compress";
static const WCHAR cszPWEncrypt[]     = L"PW_Encrypt";
static const WCHAR cszNetLogon[]      = L"Network_Logon";
static const WCHAR cszSWEncrypt[]     = L"SW_Encrypt";
static const WCHAR cszNetBEUI[]       = L"Negotiate_NetBEUI";
static const WCHAR cszIPX[]           = L"Negotiate_IPX/SPX";
static const WCHAR cszIP[]            = L"Negotiate_TCP/IP";
static WCHAR cszDisableLcp[]          = L"Disable_LCP";

static const WCHAR cszIPSection[]     = L"TCP/IP";
static const WCHAR cszIPSpec[]        = L"Specify_IP_Address";
static const WCHAR cszIPAddress[]     = L"IP_address";
static const WCHAR cszIPMask[]        = L"Subnet_Mask";
static const WCHAR cszServerSpec[]    = L"Specify_Server_Address";

static const WCHAR cszGatewayList[]   = L"Default_Gateway_List";

static const WCHAR cszDNSSpec[]       = L"Specify_DNS_Address";
static const WCHAR cszDNSList[]       = L"DNS_List";

static const WCHAR cszDNSAddress[]    = L"DNS_address";
static const WCHAR cszDNSAltAddress[] = L"DNS_Alt_address";

static const WCHAR cszWINSSpec[]      = L"Specify_WINS_Address";
static const WCHAR cszWINSList[]      = L"WINS_List";
static const WCHAR cszScopeID[]      = L"ScopeID";

static const WCHAR cszDHCPSpec[]      = L"Specify_DHCP_Address";
static const WCHAR cszDHCPServer[]    = L"DHCP_Server";

static const WCHAR cszWINSAddress[]   = L"WINS_address";
static const WCHAR cszWINSAltAddress[]= L"WINS_Alt_address";
static const WCHAR cszIPCompress[]    = L"IP_Header_Compress";
static const WCHAR cszWanPri[]        = L"Gateway_On_Remote";
static const WCHAR cszDefaultGateway[]      = L"Default_Gateway";
static const WCHAR cszDomainName[]          = L"Domain_Name";
static const WCHAR cszHostName[]            = L"Host_Name";
static const WCHAR cszDomainSuffixSearchList[]  = L"Domain_Suffix_Search_List";

static const WCHAR cszATMSection[]    = L"ATM";
static const WCHAR cszCircuitSpeed[]  = L"Circuit_Speed";
static const WCHAR cszCircuitQOS[]    = L"Circuit_QOS";
static const WCHAR cszCircuitType[]   = L"Circuit_Type";
static const WCHAR cszSpeedAdjust[]   = L"Speed_Adjust";
static const WCHAR cszQOSAdjust[]     = L"QOS_Adjust";
static const WCHAR cszEncapsulation[] = L"Encapsulation";
static const WCHAR cszVPI[]           = L"VPI";
static const WCHAR cszVCI[]           = L"VCI";
static const WCHAR cszVendorConfig[]  = L"Vendor_Config";
static const WCHAR cszShowStatus[]    = L"Show_Status";
static const WCHAR cszEnableLog[]     = L"Enable_Log";

static const WCHAR cszRfc1483Section[] = L"RFC1483";
static const WCHAR cszPppoeSection[]   = L"PPPOE";

static const WCHAR cszMLSection[]     = L"Multilink";
static const WCHAR cszLinkIndex[]     = L"Line_%s";

static const WCHAR cszScriptingSection[]                = L"Scripting";
static const WCHAR cszScriptName[]                      = L"Name";

static const WCHAR cszScriptSection[]                   = L"Script_File";

static const WCHAR cszCustomDialerSection[]             = L"Custom_Dialer";
static const WCHAR cszAutoDialDLL[]                     = L"Auto_Dial_DLL";
static const WCHAR cszAutoDialFunc[]                    = L"Auto_Dial_Function";

// These strings will be use to populate the registry, with the data above
static const WCHAR cszKeyIcwRmind[]                     = L"Software\\Microsoft\\Internet Connection Wizard\\IcwRmind";

static const WCHAR cszTrialRemindSection[]              = L"TrialRemind";
static const WCHAR cszEntryISPName[]                    = L"ISP_Name";
static const WCHAR cszEntryISPPhone[]                   = L"ISP_Phone";
static const WCHAR cszEntryISPMsg[]                     = L"ISP_Message";
static const WCHAR cszEntryTrialDays[]                  = L"Trial_Days";
static const WCHAR cszEntrySignupURL[]                  = L"Signup_URL";
// ICWRMIND expects this value in the registry
static const WCHAR cszEntrySignupURLTrialOver[]         = L"Expired_URL";

// We get these two from the INS file
static const WCHAR cszEntryExpiredISPFileName[]         = L"Expired_ISP_File";
static const WCHAR cszSignupExpiredISPURL[]             = L"Expired_ISP_URL";

static const WCHAR cszEntryConnectoidName[]             = L"Entry_Name";
static const WCHAR cszSignupSuccessfuly[]               = L"TrialConverted";

static const WCHAR cszReminderApp[]                     = L"ICWRMIND.EXE";
static const WCHAR cszReminderParams[]                  = L"-t";

static const WCHAR cszPassword[]                        = L"Password";

extern SERVER_TYPES aServerTypes[];

// These are the field names from an INS file that will
// determine the mail and news settings
static const WCHAR cszMailSection[]                     = L"Internet_Mail";
static const WCHAR cszPOPServer[]                       = L"POP_Server";
static const WCHAR cszPOPServerPortNumber[]             = L"POP_Server_Port_Number";
static const WCHAR cszPOPLogonName[]                    = L"POP_Logon_Name";
static const WCHAR cszPOPLogonPassword[]                = L"POP_Logon_Password";
static const WCHAR cszSMTPServer[]                      = L"SMTP_Server";
static const WCHAR cszSMTPServerPortNumber[]            = L"SMTP_Server_Port_Number";
static const WCHAR cszNewsSection[]                     = L"Internet_News";
static const WCHAR cszNNTPServer[]                      = L"NNTP_Server";
static const WCHAR cszNNTPServerPortNumber[]            = L"NNTP_Server_Port_Number";
static const WCHAR cszNNTPLogonName[]                   = L"NNTP_Logon_Name";
static const WCHAR cszNNTPLogonPassword[]               = L"NNTP_Logon_Password";
static const WCHAR cszUseMSInternetMail[]               = L"Install_Mail";
static const WCHAR cszUseMSInternetNews[]               = L"Install_News";


static const WCHAR cszEMailSection[]                    = L"Internet_Mail";
static const WCHAR cszEMailName[]                       = L"EMail_Name";
static const WCHAR cszEMailAddress[]                    = L"EMail_Address";
static const WCHAR cszUseExchange[]                     = L"Use_MS_Exchange";
static const WCHAR cszUserSection[]                     = L"User";
static const WCHAR cszUserName[]                        = L"Name";
static const WCHAR cszDisplayPassword[]                 = L"Display_Password";
static const WCHAR cszYes[]                             = L"yes";
static const WCHAR cszNo[]                              = L"no";

// "Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"
static const WCHAR szRegPathInternetSettings[]           = REGSTR_PATH_INTERNET_SETTINGS;
static const WCHAR szRegPathDefInternetSettings[]        = L".DEFAULT\\" REGSTR_PATH_INTERNET_SETTINGS;
static const WCHAR cszCMHeader[]                        = L"Connection Manager CMS 0";


// "InternetProfile"
static const WCHAR szRegValInternetProfile[]            =  REGSTR_VAL_INTERNETPROFILE;

// "EnableAutodial"
static const WCHAR szRegValEnableAutodial[]             =  REGSTR_VAL_ENABLEAUTODIAL;

// "NoNetAutodial"
#ifndef REGSTR_VAL_NONETAUTODIAL
#define REGSTR_VAL_NONETAUTODIAL                        L"NoNetAutodial"
#endif
static const WCHAR szRegValNoNetAutodial[]              =  REGSTR_VAL_NONETAUTODIAL;

// "RemoteAccess"
static const WCHAR szRegPathRNAWizard[]                  =  REGSTR_PATH_REMOTEACCESS;

#define CLIENT_ELEM(elem)      (((LPINETCLIENTINFO)(NULL))->elem)
#define CLIENT_OFFSET(elem)    ((DWORD_PTR)&CLIENT_ELEM(elem))
#define CLIENT_SIZE(elem)      (sizeof(CLIENT_ELEM(elem)) / sizeof(CLIENT_ELEM(elem)[0]))
#define CLIENT_ENTRY(section, value, elem) \
    {section, value, CLIENT_OFFSET(elem), CLIENT_SIZE(elem)}

CLIENT_TABLE iniTable[] =
{
    CLIENT_ENTRY(cszEMailSection, cszEMailName,         szEMailName),
    CLIENT_ENTRY(cszEMailSection, cszEMailAddress,      szEMailAddress),
    CLIENT_ENTRY(cszEMailSection, cszPOPLogonName,      szPOPLogonName),
    CLIENT_ENTRY(cszEMailSection, cszPOPLogonPassword,  szPOPLogonPassword),
    CLIENT_ENTRY(cszEMailSection, cszPOPServer,         szPOPServer),
    CLIENT_ENTRY(cszEMailSection, cszSMTPServer,        szSMTPServer),
    CLIENT_ENTRY(cszNewsSection,  cszNNTPLogonName,     szNNTPLogonName),
    CLIENT_ENTRY(cszNewsSection,  cszNNTPLogonPassword, szNNTPLogonPassword),
    CLIENT_ENTRY(cszNewsSection,  cszNNTPServer,        szNNTPServer),
    {NULL, NULL, 0, 0}
};

static const WCHAR cszFileName[]                        = L"Custom_File";
static const WCHAR cszCustomFileSection[]               = L"Custom_File";
static const WCHAR cszNull[]                            = L"";

static const WCHAR cszURLSection[]                      = L"URL";
static const WCHAR cszSignupURL[]                       =  L"Signup";
static const WCHAR cszAutoConfigURL[]                   =  L"Autoconfig";

static const WCHAR cszExtINS[]                          = L".ins";
static const WCHAR cszExtISP[]                          = L".isp";
static const WCHAR cszExtHTM[]                          = L".htm";
static const WCHAR cszExtHTML[]                         = L".html";

static const WCHAR cszEntrySection[]                    = L"Entry";
static const WCHAR cszCancel[]                          = L"Cancel";
static const WCHAR cszRun[]                             = L"Run";
static const WCHAR cszArgument[]                        = L"Argument";

static const WCHAR cszConnect2[]                        = L"icwconn2.exe";
static const WCHAR cszClientSetupSection[]              = L"ClientSetup";

static const WCHAR cszRequiresLogon[]                   = L"Requires_Logon";

static const WCHAR cszCustomSection[]                   = L"Custom";
static const WCHAR cszKeepConnection[]                  = L"Keep_Connection";
static const WCHAR cszKeepBrowser[]                     = L"Keep_Browser";

static const WCHAR cszKioskMode[]                       = L"-k ";
static const WCHAR cszOpen[]                            = L"open";
static const WCHAR cszBrowser[]                         = L"iexplore.exe";
static const WCHAR szNull[]                             = L"";
static const WCHAR cszNullIP[]                          = L"0.0.0.0";
static const WCHAR cszWininet[]                         = L"WININET.DLL";
static const CHAR cszInternetSetOption[]               = "InternetSetOptionA";
static const CHAR cszInternetQueryOption[]             = "InternetQueryOptionA";

static const WCHAR cszDEFAULT_BROWSER_KEY[]             = L"Software\\Microsoft\\Internet Explorer\\Main";
static const WCHAR cszDEFAULT_BROWSER_VALUE[]           = L"check_associations";

// Registry keys which will contain News and Mail settings
#define MAIL_KEY        L"SOFTWARE\\Microsoft\\Internet Mail and News\\Mail"
#define MAIL_POP3_KEY   L"SOFTWARE\\Microsoft\\Internet Mail and News\\Mail\\POP3\\"
#define MAIL_SMTP_KEY   L"SOFTWARE\\Microsoft\\Internet Mail and News\\Mail\\SMTP\\"
#define NEWS_KEY        L"SOFTWARE\\Microsoft\\Internet Mail and News\\News"
#define MAIL_NEWS_INPROC_SERVER32 L"CLSID\\{89292102-4755-11cf-9DC2-00AA006C2B84}\\InProcServer32"
typedef HRESULT (WINAPI *PFNSETDEFAULTNEWSHANDLER)(void);

// These are the value names where the INS settings will be saved
// into the registry
static const WCHAR cszMailSenderName[]              = L"Sender Name";
static const WCHAR cszMailSenderEMail[]             = L"Sender EMail";
static const WCHAR cszMailRASPhonebookEntry[]       = L"RAS Phonebook Entry";
static const WCHAR cszMailConnectionType[]          = L"Connection Type";
static const WCHAR cszDefaultPOP3Server[]           = L"Default POP3 Server";
static const WCHAR cszDefaultSMTPServer[]           = L"Default SMTP Server";
static const WCHAR cszPOP3Account[]                 = L"Account";
static const WCHAR cszPOP3Password[]                = L"Password";
static const WCHAR cszPOP3Port[]                    = L"Port";
static const WCHAR cszSMTPPort[]                    = L"Port";
static const WCHAR cszNNTPSenderName[]              = L"Sender Name";
static const WCHAR cszNNTPSenderEMail[]             = L"Sender EMail";
static const WCHAR cszNNTPDefaultServer[]           = L"DefaultServer"; // NOTE: NO space between "Default" and "Server".
static const WCHAR cszNNTPAccountName[]             = L"Account Name";
static const WCHAR cszNNTPPassword[]                = L"Password";
static const WCHAR cszNNTPPort[]                    = L"Port";
static const WCHAR cszNNTPRasPhonebookEntry[]       = L"RAS Phonebook Entry";
static const WCHAR cszNNTPConnectionType[]          = L"Connection Type";


static const WCHAR arBase64[] =
{
    L'A',L'B',L'C',L'D',L'E',L'F',L'G',L'H',L'I',L'J',L'K',L'L',L'M',
    L'N',L'O',L'P',L'Q',L'R',L'S',L'T',L'U',L'V',L'W',L'X',L'Y',L'Z',
    L'a',L'b',L'c',L'd',L'e',L'f',L'g',L'h',L'i',L'j',L'k',L'l',L'm',
    L'n',L'o',L'p',L'q',L'r',L's',L't',L'u',L'v',L'w',L'x',L'y',L'z',
    L'0',L'1',L'2',L'3',L'4',L'5',L'6',L'7',L'8',L'9',L'+',L'/',L'='
};


#define ICWCOMPLETEDKEY L"Completed"

// 2/19/97 jmazner Olympus #1106 -- SAM/SBS integration
WCHAR FAR cszSBSCFG_DLL[]                           = L"SBSCFG.DLL\0";
CHAR FAR cszSBSCFG_CONFIGURE[]                      = "Configure\0";
typedef DWORD (WINAPI * SBSCONFIGURE) (HWND hwnd, LPWSTR lpszINSFile, LPWSTR szConnectoidName);
SBSCONFIGURE  lpfnConfigure;

// 09/02/98 Donaldm: Integrate with Connection Manager
WCHAR FAR cszCMCFG_DLL[]                            = L"CMCFG32.DLL\0";
CHAR FAR cszCMCFG_CONFIGURE[]                       = "CMConfig\0";
CHAR FAR cszCMCFG_CONFIGUREEX[]                     = "CMConfigEx\0";

typedef BOOL (WINAPI * CMCONFIGUREEX)(LPCWSTR lpszINSFile);
typedef BOOL (WINAPI * CMCONFIGURE)(LPCWSTR lpszINSFile, LPCWSTR lpszConnectoidNams);
CMCONFIGURE   lpfnCMConfigure;
CMCONFIGUREEX lpfnCMConfigureEx;
            
#pragma data_seg()

HRESULT InetGetAutodial(LPBOOL lpfEnable, LPWSTR lpszEntryName,
  DWORD cchEntryName)
{
    HRESULT dwRet;
    HKEY    hKey = NULL;

    MYASSERT(lpfEnable);
    MYASSERT(lpszEntryName);
    MYASSERT(cchEntryName);

    // Get the name of the connectoid set for autodial.
    // HKCU\RemoteAccess\InternetProfile
    dwRet = RegCreateKey(HKEY_CURRENT_USER, szRegPathRNAWizard, &hKey);
    if (ERROR_SUCCESS == dwRet)
    {
        DWORD   dwType = REG_SZ;
        DWORD   cbEntryName = BYTES_REQUIRED_BY_CCH(cchEntryName);
        dwRet = RegQueryValueEx(hKey, (LPWSTR) szRegValInternetProfile, 0, &dwType, (LPBYTE)lpszEntryName,
                &cbEntryName);
        RegCloseKey(hKey);
    }

    if (ERROR_SUCCESS != dwRet)
    {
        return dwRet;
    }

    // Get setting from registry that indicates whether autodialing is enabled.
    // HKCU\Software\Microsoft\Windows\CurrentVersion\InternetSettings\EnableAutodial
    dwRet = RegCreateKey(HKEY_CURRENT_USER, szRegPathInternetSettings, &hKey);
    if (ERROR_SUCCESS == dwRet)
    {

        DWORD   dwType = REG_BINARY;
        DWORD   dwNumber = 0L;
        DWORD   dwSize = sizeof(dwNumber);
        dwRet = RegQueryValueEx(hKey, (LPWSTR) szRegValEnableAutodial, 0, &dwType, (LPBYTE)&dwNumber,
                &dwSize);

        if (ERROR_SUCCESS == dwRet)
        {
            *lpfEnable = dwNumber;
        }
        RegCloseKey(hKey);
    }

    return dwRet;
}

//*******************************************************************
//
//  FUNCTION:   InetSetAutodial
//
//  PURPOSE:    This function will set the autodial settings in the registry.
//
//  PARAMETERS: fEnable - If set to TRUE, autodial will be enabled.
//                        If set to FALSE, autodial will be disabled.
//              lpszEntryName - name of the phone book entry to set
//                              for autodial.  If this is "", the
//                              entry is cleared.  If NULL, it is not changed.
//
//  RETURNS:    HRESULT code, ERROR_SUCCESS if no errors occurred
//
//  HISTORY:
//  96/03/11  markdu  Created.
//
//*******************************************************************

HRESULT InetSetAutodial(BOOL fEnable, LPCWSTR lpszEntryName)
{

    HRESULT dwRet = ERROR_SUCCESS;
    BOOL    bRet = FALSE;


    // 2 seperate calls:
    HINSTANCE hInst = NULL;
    FARPROC fp = NULL;

    dwRet = ERROR_SUCCESS;

    hInst = LoadLibrary(cszWininet);
    if (hInst && lpszEntryName)
    {
        fp = GetProcAddress(hInst, cszInternetSetOption);
        if (fp)
        {
            WCHAR szNewDefaultConnection[RAS_MaxEntryName+1];
            lstrcpyn(szNewDefaultConnection, lpszEntryName, lstrlen(lpszEntryName)+1);

            bRet = ((INTERNETSETOPTION)fp) (NULL,
                                            INTERNET_OPTION_AUTODIAL_CONNECTION,
                                            szNewDefaultConnection,
                                            lstrlen(szNewDefaultConnection));

            if (bRet)
            {
                DWORD dwMode = AUTODIAL_MODE_ALWAYS;
                bRet = ((INTERNETSETOPTION)fp) (NULL, INTERNET_OPTION_AUTODIAL_MODE, &dwMode, sizeof(DWORD));
            }
            if( !bRet )
            {
                dwRet = GetLastError();
            }
        }
        else
        {
            dwRet = GetLastError();
        }
    }

    // From DarrnMi, INTERNETSETOPTION for autodial is new for 5.5. 
    // We should try it this way and if the InternetSetOption fails (you'll get invalid option),
    // set the registry the old way.  That'll work everywhere.

    if (!bRet)
    {
        HKEY    hKey = NULL;

        // Set the name if given, else do not change the entry.
        if (lpszEntryName)
        {
            // Set the name of the connectoid for autodial.
            // HKCU\RemoteAccess\InternetProfile
            if (ERROR_SUCCESS == RegCreateKey(HKEY_CURRENT_USER, szRegPathRNAWizard, &hKey))
            {
                dwRet = RegSetValueEx(hKey, szRegValInternetProfile, 0, REG_SZ,
                        (BYTE*)lpszEntryName, BYTES_REQUIRED_BY_SZ(lpszEntryName));
                RegCloseKey(hKey);
            }
        }


        hKey = NULL;
        if (ERROR_SUCCESS == dwRet)
        {
            // Set setting in the registry that indicates whether autodialing is enabled.
            // HKCC\Software\Microsoft\Windows\CurrentVersion\InternetSettings\EnableAutodial
            if (ERROR_SUCCESS == RegCreateKey(HKEY_CURRENT_CONFIG, szRegPathInternetSettings, &hKey))
            {
                dwRet = RegSetValueEx(hKey, szRegValEnableAutodial, 0, REG_DWORD,
                        (BYTE*)&fEnable, sizeof(DWORD));
                RegCloseKey(hKey);
            }

            if (ERROR_SUCCESS == RegCreateKey(HKEY_LOCAL_MACHINE, szRegPathInternetSettings, &hKey))
            {
                dwRet = RegSetValueEx(hKey, szRegValEnableAutodial, 0, REG_DWORD,
                        (BYTE*)&fEnable, sizeof(DWORD));
                RegCloseKey(hKey);
            }

            // Set setting in the registry that indicates whether autodialing is enabled.
            // HKCU\Software\Microsoft\Windows\CurrentVersion\InternetSettings\EnableAutodial
            if (ERROR_SUCCESS == RegCreateKey(HKEY_CURRENT_USER, szRegPathInternetSettings, &hKey))
            {

                BOOL bVal = FALSE;
                dwRet = RegSetValueEx(hKey, szRegValEnableAutodial, 0, REG_DWORD,
                        (BYTE*)&fEnable, sizeof(DWORD));

                dwRet = RegSetValueEx(hKey, szRegValNoNetAutodial, 0, REG_DWORD,
                        (BYTE*)&bVal, sizeof(DWORD));
                RegCloseKey(hKey);
            }
        }

        // 2/10/97        jmazner        Normandy #9705, 13233 Notify wininet
        //                               when we change proxy or autodial
        if (fp)
        {
            if( !((INTERNETSETOPTION)fp) (NULL, INTERNET_OPTION_SETTINGS_CHANGED, NULL, 0) )
            {
                dwRet = GetLastError();
            }
        }
        else
        {
            dwRet = GetLastError();
        }

    }

    if (hInst)
    {
        FreeLibrary(hInst);
        hInst = NULL;
    }

    return dwRet;
}

//+----------------------------------------------------------------------------
//
//    Function:    CallCMConfig
//
//    Synopsis:    Call into the Connection Manager dll's Configure function to allow CM to
//                process the .ins file as needed.
//
//    Arguements: lpszINSFile -- full path to the .ins file
//
//    Returns:    TRUE if a CM profile is created, FALSE otherwise
//
//    History:    09/02/98    DONALDM
//
//-----------------------------------------------------------------------------
BOOL CINSHandler::CallCMConfig(LPCWSTR lpszINSFile)
{
    HINSTANCE   hCMDLL = NULL;
    BOOL        bRet = FALSE;

    //// TraceMsg(TF_INSHANDLER, L"ICWCONN1: Calling LoadLibrary on %s\n", cszCMCFG_DLL);
    // Load DLL and entry point
    hCMDLL = LoadLibrary(cszCMCFG_DLL);
    if (NULL != hCMDLL)
    {
        // To determine whether we should call CMConfig or CMConfigEx
        ULONG ulBufferSize = 1024*10;

        // Parse the ISP section in the INI file to find query pair to append
        WCHAR *pszKeys = NULL;
        PWSTR pszKey = NULL;
        ULONG ulRetVal     = 0;
        BOOL  bEnumerate = TRUE;
        BOOL  bUseEx = FALSE;
 
        PWSTR pszBuff = NULL;

        do
        {
            if (NULL != pszKeys)
            {
                delete [] pszKeys;
                ulBufferSize += ulBufferSize;
            }
            pszKeys = new WCHAR [ulBufferSize];
            if (NULL == pszKeys)
            {
                bEnumerate = FALSE;
                break;
            }

            ulRetVal = ::GetPrivateProfileString(NULL, NULL, L"", pszKeys, ulBufferSize, lpszINSFile);
            if (0 == ulRetVal)
            {
               bEnumerate = FALSE;
               break;
            }
        } while (ulRetVal == (ulBufferSize - 2));


        if (bEnumerate)
        {
            pszKey = pszKeys;
            while (*pszKey)
            {
                if (!lstrcmpi(pszKey, cszCMHeader)) 
                {
                    bUseEx = TRUE;
                    break;
                }
                pszKey += lstrlen(pszKey) + 1;
            }
        }


        if (pszKeys)
            delete [] pszKeys;
        
        WCHAR   szConnectoidName[RAS_MaxEntryName];
        // Get the connectoid name from the [Entry] Section
        GetPrivateProfileString(cszEntrySection,
                                    cszEntryName,
                                    cszNull,
                                    szConnectoidName,
                                    RAS_MaxEntryName,
                                    lpszINSFile);

        if (bUseEx)
        {
            // Call CMConfigEx
            lpfnCMConfigureEx = (CMCONFIGUREEX)GetProcAddress(hCMDLL, cszCMCFG_CONFIGUREEX);
            if( lpfnCMConfigureEx )
            {
                bRet = lpfnCMConfigureEx(lpszINSFile);    
            }
        }
        else
        {
            // Call CMConfig
            lpfnCMConfigure = (CMCONFIGURE)GetProcAddress(hCMDLL, cszCMCFG_CONFIGURE);
            // Call function
            if( lpfnCMConfigure )
            {
                bRet = lpfnCMConfigure(lpszINSFile, szConnectoidName);  
            }
        }

        if (bRet)
        {
            // restore original autodial settings
            SetDefaultConnectoid(AutodialTypeAlways, szConnectoidName);
        }
    }

    // Cleanup
    if( hCMDLL )
        FreeLibrary(hCMDLL);
    if( lpfnCMConfigure )
        lpfnCMConfigure = NULL;

    // TraceMsg(TF_INSHANDLER, L"ICWCONN1: CallSBSConfig exiting with error code %d \n", bRet);
    return bRet;
}


//+----------------------------------------------------------------------------
//
//    Function:    CallSBSConfig
//
//    Synopsis:    Call into the SBSCFG dll's Configure function to allow SBS to
//                process the .ins file as needed
//
//    Arguements: hwnd -- hwnd of parent, in case sbs wants to put up messages
//                lpszINSFile -- full path to the .ins file
//
//    Returns:    windows error code that sbscfg returns.
//
//    History:    2/19/97    jmazner    Created for Olympus #1106
//
//-----------------------------------------------------------------------------
DWORD CINSHandler::CallSBSConfig(HWND hwnd, LPCWSTR lpszINSFile)
{
    HINSTANCE   hSBSDLL = NULL;
    DWORD       dwRet = ERROR_SUCCESS;
    WCHAR        lpszConnectoidName[RAS_MaxEntryName] = L"nogood\0";

    //
    // Get name of connectoid we created by looking in autodial
    // We need to pass this name into SBSCFG
    // 5/14/97    jmazner    Windosw NT Bugs #87209
    //
    BOOL fEnabled = FALSE;

    dwRet = InetGetAutodial(&fEnabled, lpszConnectoidName, RAS_MaxEntryName);

    // TraceMsg(TF_INSHANDLER, L"ICWCONN1: Calling LoadLibrary on %s\n", cszSBSCFG_DLL);
    hSBSDLL = LoadLibrary(cszSBSCFG_DLL);

    // Load DLL and entry point
    if (NULL != hSBSDLL)
    {
        // TraceMsg(TF_INSHANDLER, L"ICWCONN1: Calling GetProcAddress on %s\n", cszSBSCFG_CONFIGURE);
        lpfnConfigure = (SBSCONFIGURE)GetProcAddress(hSBSDLL, cszSBSCFG_CONFIGURE);
    }
    else
    {
        // 4/2/97    ChrisK    Olympus 2759
        // If the DLL can't be loaded, pick a specific error message to return.
        dwRet = ERROR_DLL_NOT_FOUND;
        goto CallSBSConfigExit;
    }

    // Call function
    if( hSBSDLL && lpfnConfigure )
    {
        // TraceMsg(TF_INSHANDLER, L"ICWCONN1: Calling the Configure entry point: %s, %s\n", lpszINSFile, lpszConnectoidName);
        dwRet = lpfnConfigure(hwnd, (WCHAR *)lpszINSFile, lpszConnectoidName);
    }
    else
    {
        // TraceMsg(TF_INSHANDLER, L"ICWCONN1: Unable to call the Configure entry point\n");
        dwRet = GetLastError();
    }

CallSBSConfigExit:
    if( hSBSDLL )
        FreeLibrary(hSBSDLL);
    if( lpfnConfigure )
        lpfnConfigure = NULL;

    // TraceMsg(TF_INSHANDLER, L"ICWCONN1: CallSBSConfig exiting with error code %d \n", dwRet);
    return dwRet;
}

BOOL CINSHandler::SetICWCompleted( DWORD dwCompleted )
{
    HKEY hKey = NULL;

    HRESULT hr = RegCreateKey(HKEY_CURRENT_USER, ICWSETTINGSPATH, &hKey);
    if (ERROR_SUCCESS == hr)
    {
        hr = RegSetValueEx(hKey, ICWCOMPLETEDKEY, 0, REG_DWORD,
                    (CONST BYTE*)&dwCompleted, sizeof(dwCompleted));
        RegCloseKey(hKey);
    }

    if( ERROR_SUCCESS == hr )
        return TRUE;
    else
        return FALSE;

}

/////////////////////////////////////////////////////////////////////////////

#define FILE_BUFFER_SIZE 65534
#ifndef FILE_BEGIN
#define FILE_BEGIN  0
#endif

//+---------------------------------------------------------------------------
//
//  Function:   MassageFile
//
//  Synopsis:   Convert lone carriage returns to CR/LF pairs.
//
//  Note:       The file is ANSI because these need to be shared with Win9X.
//
//+---------------------------------------------------------------------------
HRESULT CINSHandler::MassageFile(LPCWSTR lpszFile)
{
    LPBYTE  lpBufferIn;
    LPBYTE  lpBufferOut;
    HANDLE  hfile;
    HRESULT hr = ERROR_SUCCESS;

    if (!SetFileAttributes(lpszFile, FILE_ATTRIBUTE_NORMAL))
    {
        return GetLastError();
    }

    lpBufferIn = (LPBYTE) GlobalAlloc(GPTR, 2 * FILE_BUFFER_SIZE);
    if (NULL == lpBufferIn)
    {
        return ERROR_OUTOFMEMORY;
    }
    lpBufferOut = lpBufferIn + FILE_BUFFER_SIZE;

    hfile = CreateFile(lpszFile,
                       GENERIC_READ | GENERIC_WRITE,
                       FILE_SHARE_READ,
                       NULL,    // security attributes
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);
    if (INVALID_HANDLE_VALUE != hfile)
    {
        BOOL    fChanged = FALSE;
        DWORD   cbOut = 0;
        DWORD   cbIn = 0;

        if (ReadFile(hfile,
        