ESULT
CW3SecurityPage::SaveInfo()
/*++

Routine Description:

    Save the information on this property page

Arguments:

    None

Return Value:

    Error return code

--*/
{
    ASSERT(IsDirty());

    TRACEEOLID("Saving W3 security page now...");

    CError err;

    //
    // Check to see if the ip access list needs saving.
    //
    BOOL fIplDirty = m_fIpDirty || (m_fOldDefaultGranted != m_fDefaultGranted);

    //
    // Use m_ notation because the message crackers require it
    //
    CBlob m_ipl;

    if (fIplDirty)
    {
        BuildIplBlob(m_oblAccessList, m_fDefaultGranted, m_ipl);
    }

    BeginWaitCursor();

    BEGIN_META_DIR_WRITE(CW3Sheet)
        STORE_DIR_DATA_ON_SHEET(m_dwSSLAccessPermissions)
        STORE_DIR_DATA_ON_SHEET(m_dwAuthFlags)
        STORE_DIR_DATA_ON_SHEET(m_strBasicDomain)

        if (fIplDirty)
        {
            STORE_DIR_DATA_ON_SHEET(m_ipl)
        }
        STORE_DIR_DATA_ON_SHEET(m_strAnonUserName)
        STORE_DIR_DATA_ON_SHEET(m_fPasswordSync)
        STORE_DIR_DATA_ON_SHEET(m_fUseNTMapper)
        if (m_fPasswordSync)
        {
            //
            // Delete password
            //
            // CODEWORK: Shouldn't need to know ID number.
            // Implement m_fDelete flag in CMP template maybe?
            //
            FLAG_DIR_DATA_FOR_DELETION(MD_ANONYMOUS_PWD);
        }
        else
        {
            STORE_DIR_DATA_ON_SHEET(m_strAnonPassword);
        }
    END_META_DIR_WRITE(err)

    if (err.Succeeded())
    {
        BEGIN_META_INST_WRITE(CW3Sheet)
            if ( m_strCTLIdentifier.IsEmpty() )
            {
                FLAG_INST_DATA_FOR_DELETION( MD_SSL_CTL_IDENTIFIER )
            }
            else
            {
                STORE_INST_DATA_ON_SHEET(m_strCTLIdentifier)
            }

            if ( m_strCTLStoreName.IsEmpty() )
            {
                FLAG_INST_DATA_FOR_DELETION( MD_SSL_CTL_STORE_NAME )
            }
            else
            {
                STORE_INST_DATA_ON_SHEET(m_strCTLStoreName)
            }
        END_META_INST_WRITE(err)
    }

    EndWaitCursor();

    if (err.Succeeded())
    {
        m_fIpDirty = FALSE;
        m_fOldDefaultGranted = m_fDefaultGranted;
    }

    return err;
}



BOOL
CW3SecurityPage::FetchSSLState()
/*++

Routine Description:

    Obtain the state of the dialog depending on whether certificates
    are installed or not.

Arguments:

    None

Return Value:

    TRUE if certificates are installed, FALSE otherwise

--*/
{
    BeginWaitCursor();
    m_fCertInstalled = ::IsCertInstalledOnServer(
        GetServerName(), 
        QueryInstance()
        );
    EndWaitCursor();

    return m_fCertInstalled;
}



void
CW3SecurityPage::SetSSLControlState()
/*++

Routine Description:

    Enable/disable supported controls depending on what's installed.
    Only available on non-master instance nodes.

Arguments:

    None

Return Value:

    None

--*/
{
    m_static_SSLPrompt.EnableWindow(!IsMasterInstance());
    m_button_GetCertificates.EnableWindow(
        !IsMasterInstance() 
     && m_fHome 
     && IsLocal() 
        );
    m_button_Communications.EnableWindow(
        !IsMasterInstance() 
     && IsSSLSupported() 
     && FetchSSLState()
        );
    m_button_ViewCertificates.EnableWindow(m_fCertInstalled);
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

BOOL 
CW3SecurityPage::OnSetActive() 
/*++

Routine Description:

    Page got activated -- set the SSL state depending on whether a
    certificate is installed or not.

Arguments:

    None

Return Value:

    TRUE to activate the page, FALSE otherwise.

--*/
{
    //
    // Enable/disable ssl controls
    //
    SetSSLControlState();
    
    return CInetPropertyPage::OnSetActive();
}



BOOL 
CW3SecurityPage::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CInetPropertyPage::OnInitDialog();

    //
    // Initialize certificate authorities ocx
    //
    CRect rc(0, 0, 0, 0);
    m_ocx_CertificateAuthorities.Create(
        _T("CertWiz"),
        WS_BORDER,
        rc,
        this,
        IDC_APPSCTRL
        );

    GetDlgItem(IDC_GROUP_IP)->EnableWindow(HasIPAccessCheck());
    GetDlgItem(IDC_ICON_IP)->EnableWindow(HasIPAccessCheck());
    GetDlgItem(IDC_STATIC_IP)->EnableWindow(HasIPAccessCheck());
    GetDlgItem(IDC_BUTTON_IP_SECURITY)->EnableWindow(HasIPAccessCheck());
    GetDlgItem(IDC_BUTTON_AUTHENTICATION)->EnableWindow(!m_fU2Installed);

    //
    // Configure for either master or non-master display.
    //
    m_check_EnableDS.ShowWindow(IsMasterInstance() ? SW_SHOW : SW_HIDE);
    m_check_EnableDS.EnableWindow(
        HasAdminAccess() 
     && IsMasterInstance() 
     && HasNTCertMapper()
        );

#define SHOW_NON_MASTER(x)\
   (x).ShowWindow(IsMasterInstance() ? SW_HIDE : SW_SHOW)
    
    SHOW_NON_MASTER(m_static_SSLPrompt);
    SHOW_NON_MASTER(m_icon_Secure);
    SHOW_NON_MASTER(m_button_GetCertificates);
    SHOW_NON_MASTER(m_button_Communications);
    SHOW_NON_MASTER(m_button_ViewCertificates);

#undef SHOW_NON_MASTER

    return TRUE;  
}



void 
CW3SecurityPage::OnButtonAuthentication() 
/*++

Routine Description:

    'Authentication' button hander

Arguments:

    None

Return Value:

    None

--*/
{
    CAuthenticationDlg dlg(
        GetServerName(), 
        QueryInstance(), 
        m_strBasicDomain,
        m_dwAuthFlags, 
        m_dwSSLAccessPermissions, 
        m_strAnonUserName,
        m_strAnonPassword,
        m_fPasswordSync,
        HasAdminAccess(),
        HasDigest(),
        this
        );

    DWORD dwOldAccess = m_dwSSLAccessPermissions;
    DWORD dwOldAuth = m_dwAuthFlags;
    CString strOldDomain = m_strBasicDomain;
    CString strOldUserName = m_strAnonUserName;
    CString strOldPassword = m_strAnonPassword;
    BOOL fOldPasswordSync = m_fPasswordSync;

    if (dlg.DoModal() == IDOK)
    {
        //
        // See if anything has changed
        //
        if (dwOldAccess != m_dwSSLAccessPermissions 
            || dwOldAuth != m_dwAuthFlags
            || m_strBasicDomain != strOldDomain
            || m_strAnonUserName != strOldUserName 
            || m_strAnonPassword != strOldPassword
            || m_fPasswordSync != fOldPasswordSync
            )
        {
            //
            // Mark as dirty
            //
            OnItemChanged();
        }
    }
}



void 
CW3SecurityPage::OnButtonCommunications() 
/*++

Routine Description:

    'Communications' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Prep the flag for if we can edit CTLs or not
    //
    BOOL fEditCTLs = IsMasterInstance() || m_fHome;

    //
    // Prep the communications dialog
    //
    CSecCommDlg dlg(
        GetServerName(), 
        QueryInstanceMetaPath(), 
        m_strBasicDomain,
        m_dwAuthFlags, 
        m_dwSSLAccessPermissions, 
        IsMasterInstance(),
        IsSSLSupported(), 
        IsSSL128Supported(),
        m_fU2Installed,
        m_strCTLIdentifier,
        m_strCTLStoreName,
        fEditCTLs,
        IsLocal(),
        this
        );

    DWORD dwOldAccess = m_dwSSLAccessPermissions;
    DWORD dwOldAuth = m_dwAuthFlags;

    if (dlg.DoModal() == IDOK)
    {
        //
        // See if anything has changed
        //
        if (dwOldAccess != m_dwSSLAccessPermissions 
            || dwOldAuth != m_dwAuthFlags
            )
        {
            //
            // Mark as dirty
            //
            OnItemChanged();
        }

        //
        // See if the CTL information has changed
        //
        if (dlg.m_bCTLDirty)
        {
            m_strCTLIdentifier = dlg.m_strCTLIdentifier;
            m_strCTLStoreName = dlg.m_strCTLStoreName;
            OnItemChanged();
        }
    }
}



void 
CW3SecurityPage::OnButtonIpSecurity() 
/*++

Routine Description:

    'tcpip' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    CIPDomainDlg dlg(
        m_fIpDirty,
        m_fDefaultGranted,
        m_fOldDefaultGranted,
        m_oblAccessList, 
        this
        );

    if (dlg.DoModal() == IDOK)
    {
        //
        // Rebuild the list.  Temporarily reset ownership, otherwise
        // RemoveAll() will destroy the pointers which are shared with the
        // new list.
        //
        BOOL fOwn = m_oblAccessList.SetOwnership(FALSE);
        m_oblAccessList.RemoveAll();
        m_oblAccessList.AddTail(&dlg.GetAccessList());
        m_oblAccessList.SetOwnership(fOwn);

        if (m_fIpDirty || m_fOldDefaultGranted != m_fDefaultGranted)
        {
            OnItemChanged();
        }
    }
}



void 
CW3SecurityPage::OnButtonGetCertificates() 
/*++

Routine Description:

    "get certicate" button handler

Arguments:

    None

Return Value:

    None

--*/
{
    m_ocx_CertificateAuthorities.SetMachineName(GetServerName());
    m_ocx_CertificateAuthorities.SetServerInstance(QueryInstanceMetaPath());
    m_ocx_CertificateAuthorities.DoClick();

    //
    // There may now be a certificate. See if we should enable the edit button.
    //
    SetSSLControlState();
}


void 
CW3SecurityPage::OnButtonViewCertificates() 
/*++

Routine Description:

    "view certicate" button handler

Arguments:

    None

Return Value:

    None

--*/
{
    HCERTSTORE hStore = NULL;
    PCCERT_CONTEXT pCert = NULL;
	CMetaKey key(GetServerName(),
				METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
				METADATA_MASTER_ROOT_HANDLE,
				QueryInstanceMetaPath());
	if (key.Succeeded())
	{
		CString store_name;
		CBlob hash;
		if (	SUCCEEDED(key.QueryValue(MD_SSL_CERT_STORE_NAME, store_name))
			&&	SUCCEEDED(key.QueryValue(MD_SSL_CERT_HASH, hash))
			)
		{
			hStore = CertOpenStore(
                    CERT_STORE_PROV_SYSTEM,
                    PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
           		    NULL,
                    CERT_SYSTEM_STORE_LOCAL_MACHINE,
                    store_name
                    );
            if (hStore != NULL)
            {
				// Now we need to find cert by hash
				CRYPT_HASH_BLOB crypt_hash;
				crypt_hash.cbData = hash.GetSize();
				crypt_hash.pbData = hash.GetData();
				pCert = CertFindCertificateInStore(
                    hStore, 
					X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 
					0, CERT_FIND_HASH, (LPVOID)&crypt_hash, NULL);
            }
        }
    }
	if (pCert)
	{
		BOOL fPropertiesChanged;
		CRYPTUI_VIEWCERTIFICATE_STRUCT vcs;
		HCERTSTORE hCertStore = ::CertDuplicateStore(hStore);
		::ZeroMemory (&vcs, sizeof (vcs));
		vcs.dwSize = sizeof (vcs);
		vcs.hwndParent = GetParent()->GetSafeHwnd();
		vcs.dwFlags = 0;
		vcs.cStores = 1;
		vcs.rghStores = &hCertStore;
		vcs.pCertContext = pCert;
		::CryptUIDlgViewCertificate(&vcs, &fPropertiesChanged);
		::CertCloseStore (hCertStore, 0);
	}
    else
    {
    }
    if (pCert != NULL)
        ::CertFreeCertificateContext(pCert);
    if (hStore != NULL)
        ::CertCloseStore(hStore, 0);
}

void
CW3SecurityPage::OnItemChanged()
/*++

Routine Description:

    All EN_CHANGE messages map to this function

Arguments:

    None

Return Value:

    None

--*/
{
    SetModified(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\seldate.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        seldate.h

   Abstract:

        Date selector dialog definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//{{AFX_INCLUDES()
#include "msacal70.h"
//}}AFX_INCLUDES


class CSelDate : public CDialog
/*++

Class Description:

    Date selector dialog

Public Interface:

    CSelDate        : Constructor
    GetTime         : Get time structure

--*/    
{
//
// Construction
//
public:
    CSelDate(
        IN CTime tm,
        IN CWnd * pParent = NULL
        );   

//
// Get the time and date
//
public:
    CTime & GetTime()
    {
        return m_tm;
    }

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CSelDate)
    enum { IDD = IDD_DIALOG_PICK_DATE };
    CMsacal70   m_cal;
    //}}AFX_DATA

    CTime m_tm;

//
// Overrides
//
protected:
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CSelDate)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:

    // Generated message map functions
    //{{AFX_MSG(CSelDate)
    virtual BOOL OnInitDialog();
    virtual void OnOK();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\sources.inc ===
!include ..\..\..\..\place.inc

MAJORCOMP=internet
MINORCOMP=w3scfg

TARGETNAME=w3scfg
TARGETPATH=obj
TARGETTYPE=DYNLINK

UMTYPE=windows
SUBSYSTEM_VERSION=4.00
DLLDEF=..\w3scfg.def
USE_MFCUNICODE=1
USE_MSVCRT=1
MFC_USRDLL=1
USE_ATL=1

PRECOMPILED_INCLUDE=stdafx.h
PRECOMPILED_CXX=1

C_DEFINES=$(C_DEFINES) -D_COMIMPORT

INCLUDES=\
	   $(DS_INC_PATH);\
       ..\..\inc;\
       ..\..\..\inc;\
       $(IISBASEDIR)\inc;\
       $(IISBASEDIR)\inc\$(O);\
       ..\..\comprop;\
       ..

SOURCES=\
       ..\w3scfg.cpp    \
       ..\w3servic.cpp  \
       ..\w3accts.cpp   \
       ..\perform.cpp   \
       ..\basdom.cpp    \
       ..\mmmdlg.cpp    \
       ..\docum.cpp     \
       ..\font.cpp      \
       ..\rat.cpp       \
       ..\logui.cpp     \
       ..\errors.cpp    \
       ..\errordlg.cpp  \
       ..\filters.cpp   \
       ..\HTTPPage.cpp  \
       ..\security.cpp  \
       ..\vdir.cpp      \
       ..\fltdlg.cpp    \
       ..\authent.cpp   \
       ..\anondlg.cpp   \
       ..\ipdomdlg.cpp  \
       ..\seccom.cpp    \
       ..\defws.cpp     \
       ..\hdrdlg.cpp    \
       ..\apps.cpp      \
       ..\font.cpp      \
       ..\certmap.cpp   \
       ..\certauth.cpp  \
       ..\certwiz.cpp   \
       ..\wizard.cpp    \
       ..\w3scfg.rc

TARGETLIBS=\
       $(IISBASEDIR)\svcs\infocomm\info\client\$(O)\infoadmn.lib \
       $(IISBASEDIR)\svcs\w3\client\$(O)\w3svapi.lib \
       $(SDK_LIB_PATH)\netapi32.lib   \
       $(SDK_LIB_PATH)\ws2_32.lib     \
       $(SDK_LIB_PATH)\kernel32.lib   \
       $(SDK_LIB_PATH)\advapi32.lib   \
       $(SDK_LIB_PATH)\comdlg32.lib   \
       $(SDK_LIB_PATH)\comctl32.lib   \
       $(SDK_LIB_PATH)\mmc.lib        \
       $(SDK_LIB_PATH)\winspool.lib   \
       $(SDK_LIB_PATH)\shell32.lib    \
       $(SDK_LIB_PATH)\user32.lib     \
       $(SDK_LIB_PATH)\ole32.lib      \
       $(SDK_LIB_PATH)\gdi32.lib      \
       $(SDK_LIB_PATH)\crypt32.lib    \
       $(SDK_LIB_PATH)\cryptui.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\ssldlg.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        ssldlg.cpp

   Abstract:

        SSL Dialog

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "w3scfg.h"
#include "SSLDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CSSLDlg::CSSLDlg(
    IN DWORD & dwAccessPermissions,
    IN BOOL fSSL128Supported,
    IN CWnd * pParent  OPTIONAL
    )
/*++

Routine Description:

    SSL Dialog constructor

Arguments:

    LPCTSTR lpstrServerName         : Server name, For API name only
    DWORD & dwAccessPermissions     : Access permissions
    BOOL fSSLSupported              : SSL Supported
    CWnd * pParent                  : Optional parent window

Return Value:

    N/A

--*/
    : CDialog(CSSLDlg::IDD, pParent),
      m_fSSL128Supported(fSSL128Supported),
      m_dwAccessPermissions(dwAccessPermissions)
{
#if 0 // Keep Class wizard happy

    //{{AFX_DATA_INIT(CSSLDlg)
    m_fRequire128BitSSL = FALSE;
    //}}AFX_DATA_INIT

#endif // 0

    m_fRequire128BitSSL = IS_FLAG_SET(m_dwAccessPermissions, MD_ACCESS_SSL128);
}



void 
CSSLDlg::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store Control Data

Arguments:

    CDataExchange * pDX : Data exchange object

Return Value:

    None

--*/
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CSSLDlg)
    DDX_Check(pDX, IDC_CHECK_REQUIRE_128BIT, m_fRequire128BitSSL);
    //}}AFX_DATA_MAP
}


//
// Message Map
//
BEGIN_MESSAGE_MAP(CSSLDlg, CDialog)
    //{{AFX_MSG_MAP(CSSLDlg)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/*
void
CSSLDlg::SetSSLText()
/*++

Routine Description:

    Set control texts depending on availability of
    SSL

Arguments:

    None

Return Value:

    None

--/
{
    CString str;
    if (!m_fSSLEnabledOnServer)
    {
        VERIFY(str.LoadString(IDS_CHECK_REQUIRE_SSL_NOT_ENABLED));
    }
    else 
    {
        VERIFY(str.LoadString(m_fSSLInstalledOnServer
            ? IDS_CHECK_REQUIRE_SSL_INSTALLED
            : IDS_CHECK_REQUIRE_SSL_NOT_INSTALLED));
    }

    m_check_RequireSSL.SetWindowText(str);
}
*/


//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


void 
CSSLDlg::OnOK()
/*++

Routine Description:

    'ok' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    if (UpdateData(TRUE))
    {
        SET_FLAG_IF(m_fRequire128BitSSL, m_dwAccessPermissions, MD_ACCESS_SSL128);

        CDialog::OnOK();
    }

    //
    // Don't dismiss the dialog
    //
}

BOOL 
CSSLDlg::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CDialog::OnInitDialog();

    GetDlgItem(IDC_CHECK_REQUIRE_128BIT)->EnableWindow(m_fSSL128Supported);
    
    return TRUE;  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\vdir.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        vdir.cpp

   Abstract:

        WWW Directory Properties Page

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"

#include "w3scfg.h"
#include "vdir.h"
#include "dirbrows.h"

#include <lmcons.h>
#include <atlbase.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/****************************************************************************
**                                                                         **
** WARNING:  What a hairy mess this dialog and this code have become.      **
**           The tale grew in the telling as it were, but at some point    **
**           it ought to be rewritten.  Currently, I would be very         **
**           wary of touching anything in here if I were you, because this **
**           dialog exists in many configurations: file, directory,        **
**           virtual directory, home directory, master properties, local   **
**           path, redirected path, UNC path, downlevel, plus combinations **
**           of the aforementioned.  Whatever you touch will likely affect **
**           all these configurations.                                     **
**                                                                         **
**           2/1/1998 - RonaldM                                            **
**                                                                         **
****************************************************************************/

//
// Directory Properties Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

LPCTSTR 
CvtPathToDosStyle(
    IN OUT CString & strPath
    )
{
    //
    // Get a pointer to the string data without increasing the buffer
    //
    for (LPTSTR lp = strPath.GetBuffer(1); *lp; ++lp)
    {
        if (*lp == _T('/'))
        {
            *lp = _T('\\');
        }
    }
    strPath.ReleaseBuffer();

    return strPath;
}



IMPLEMENT_DYNCREATE(CW3DirectoryPage, CInetPropertyPage)



CW3DirectoryPage::CW3DirectoryPage(
    IN CInetPropertySheet * pSheet,
    IN BOOL fHome,
    IN DWORD dwAttributes
    ) 
/*++

Routine Description:

    Constructor for directory property page

Arguments:

    CInetPropertySheet * pSheet : Sheet pointer
    BOOL fHome                  : TRUE if this is a home directory
    DWORD dwAttributes          : Attributes of the  directory/file/vroot

Return Value:

    N/A

--*/
    : CInetPropertyPage(CW3DirectoryPage::IDD, pSheet, 
        fHome ? IDS_TAB_HOME_DIRECTORY 
              : IS_VROOT(dwAttributes)
                ? IDS_TAB_VIRTUAL_DIRECTORY
                : IS_DIR(dwAttributes)
                    ? IDS_TAB_DIR
                    : IDS_TAB_FILE),
      //
      // Assign the range of bits in m_dwAccessPermissions that
      // we manage.  This is important, because another page
      // manages other bits, and we don't want to mess up
      // the master value bits when our changes collide (it
      // will mark the original bits as dirty, because we're not
      // notified when the change is made...
      //
      m_dwBitRangePermissions(MD_ACCESS_EXECUTE | 
            MD_ACCESS_SCRIPT | 
            MD_ACCESS_WRITE  | 
            MD_ACCESS_SOURCE |
            MD_ACCESS_READ),
      m_dwBitRangeDirBrowsing(MD_DIRBROW_ENABLED),
      m_fHome(fHome),
      m_fRecordChanges(FALSE),
      m_strMetaRoot(),
      m_dwAttributes(dwAttributes),
      m_pApplication(NULL),
      m_fOriginallyUNC(FALSE)
{
#if 0 // Keep Class-wizard happy

    //{{AFX_DATA_INIT(CW3DirectoryPage)
    m_nPathType = RADIO_DIRECTORY;
    m_nPermissions = -1;
    m_fBrowsingAllowed = FALSE;
    m_fRead = FALSE;
    m_fWrite = FALSE;
    m_fAuthor = FALSE;
    m_fLogAccess = FALSE;
    m_strPath = _T("");
    m_strRedirectPath = _T("");
    m_strAppFriendlyName = _T("");
    m_fIndex = FALSE;
    m_strDefaultDocument = _T("");
    //}}AFX_DATA_INIT

#endif // 0

    VERIFY(m_strPrompt[RADIO_DIRECTORY].LoadString(IDS_PROMPT_DIR));
    VERIFY(m_strPrompt[RADIO_NETDIRECTORY].LoadString(IDS_PROMPT_UNC));
    VERIFY(m_strPrompt[RADIO_REDIRECT].LoadString(IDS_PROMPT_REDIRECT));
    VERIFY(m_strRemove.LoadString(IDS_BUTTON_REMOVE));
    VERIFY(m_strCreate.LoadString(IDS_BUTTON_CREATE));
    VERIFY(m_strEnable.LoadString(IDS_BUTTON_ENABLE));
    VERIFY(m_strDisable.LoadString(IDS_BUTTON_DISABLE));
    VERIFY(m_strWebFmt.LoadString(IDS_APPROOT_FMT));
    VERIFY(m_strWebMaster.LoadString(IDS_WEB_MASTER));
}



CW3DirectoryPage::~CW3DirectoryPage()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    SAFE_DELETE(m_pApplication);
}



void
CW3DirectoryPage::MakeDisplayAlias()
/*++

Routine Description:

    Build display version of the metabase alias;

Arguments:

    None

Return Value:

    None

--*/
{
    CString strPath(((CW3Sheet *)GetSheet())->QueryParent());
    strPath += _T("/");
    strPath += m_strAlias;
    m_strDisplayAlias = strPath.Mid(::lstrlen(g_cszRoot));

    CvtPathToDosStyle(m_strDisplayAlias);
}



void 
CW3DirectoryPage::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control Data

Arguments:

    CDataExchange * pDX : DDX/DDV struct

Return Value:

    None.

--*/
{
    CInetPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CW3DirectoryPage)
    DDX_Radio(pDX, IDC_RADIO_DIR, m_nPathType);
    DDX_CBIndex(pDX, IDC_COMBO_PERMISSIONS, m_nPermissions);
    DDX_Check(pDX, IDC_CHECK_DIRECTORY_BROWSING_ALLOWED, m_fBrowsingAllowed);
    DDX_Check(pDX, IDC_CHECK_READ, m_fRead);
    DDX_Check(pDX, IDC_CHECK_WRITE, m_fWrite);
    DDX_Check(pDX, IDC_CHECK_AUTHOR, m_fAuthor);
    DDX_Check(pDX, IDC_CHECK_LOG_ACCESS, m_fLogAccess);
    DDX_Check(pDX, IDC_CHECK_INDEX, m_fIndexed);
    DDX_Text(pDX, IDC_EDIT_ALIAS, m_strDisplayAlias);
    DDX_Text(pDX, IDC_EDIT_APPLICATION, m_strAppFriendlyName);
    DDV_MinMaxChars(pDX, m_strAppFriendlyName, 0, MAX_PATH); /// ?
    DDX_Control(pDX, IDC_EDIT_PATH, m_edit_Path);
    DDX_Control(pDX, IDC_EDIT_ALIAS, m_edit_DisplayAlias);
    DDX_Control(pDX, IDC_EDIT_REDIRECT, m_edit_Redirect);
    DDX_Control(pDX, IDC_EDIT_APPLICATION, m_edit_AppFriendlyName);
    DDX_Control(pDX, IDC_STATIC_APP_PROMPT, m_static_AppPrompt);
    DDX_Control(pDX, IDC_STATIC_PATH_PROMPT, m_static_PathPrompt);
    DDX_Control(pDX, IDC_STATIC_STARTING_POINT, m_static_StartingPoint);
    DDX_Control(pDX, IDC_STATIC_PROTECTIOn, m_static_ProtectionPrompt);
    DDX_Control(pDX, IDC_STATIC_PERMISSIONS, m_static_PermissionsPrompt);
    DDX_Control(pDX, IDC_BUTTON_UNLOAD_APP, m_button_Unload);
    DDX_Control(pDX, IDC_BUTTON_CREATE_REMOVE_APP, m_button_CreateRemove);
    DDX_Control(pDX, IDC_BUTTON_BROWSE, m_button_Browse);
    DDX_Control(pDX, IDC_BUTTON_CONNECT_AS, m_button_ConnectAs);
    DDX_Control(pDX, IDC_DUMMY_CONFIGURATION, m_button_Configuration);
    DDX_Control(pDX, IDC_RADIO_DIR, m_radio_Dir);
    DDX_Control(pDX, IDC_CHECK_AUTHOR, m_check_Author);
    DDX_Control(pDX, IDC_CHECK_CHILD, m_check_Child);
    DDX_Control(pDX, IDC_CHECK_DIRECTORY_BROWSING_ALLOWED, m_check_DirBrowse);
    DDX_Control(pDX, IDC_CHECK_INDEX, m_check_Index);
    DDX_Control(pDX, IDC_CHECK_WRITE, m_check_Write);
    DDX_Control(pDX, IDC_CHECK_READ, m_check_Read);    
    DDX_Control(pDX, IDC_COMBO_PERMISSIONS, m_combo_Permissions);
    DDX_Control(pDX, IDC_COMBO_PROCESS, m_combo_Process);
    //}}AFX_DATA_MAP

    DDX_Control(pDX, IDC_RADIO_UNC, m_radio_Unc);
    DDX_Control(pDX, IDC_RADIO_REDIRECT, m_radio_Redirect);

    DDX_Check(pDX, IDC_CHECK_CHILD, m_fChild);
    DDX_Check(pDX, IDC_CHECK_EXACT, m_fExact);
    DDX_Check(pDX, IDC_CHECK_PERMANENT, m_fPermanent);

    if (pDX->m_bSaveAndValidate)
    {
        //
        // Make sure all field names are correct
        //
        if (m_nPathType == RADIO_NETDIRECTORY)
        {   
            DDX_Text(pDX, IDC_EDIT_PATH, m_strPath);
            m_strPath.TrimLeft();
            DDV_MinMaxChars(pDX, m_strPath, 0, MAX_PATH);

            if (!IsUNCName(m_strPath))
            {
                ::AfxMessageBox(IDS_BAD_UNC_PATH);
                pDX->Fail();
            }

            m_strRedirectPath.Empty();

        /*

            ISSUE: Don't need username/password?

            if (m_strUserName.IsEmpty())
            {
                ::AfxMessageBox(IDS_ERR_NO_USERNAME);

                if (!BrowseUser())
                {
                    pDX->Fail();
                }
            }
        */
        }
        else if (m_nPathType == RADIO_REDIRECT)
        {
            DDX_Text(pDX, IDC_EDIT_REDIRECT, m_strRedirectPath);
            m_strRedirectPath.TrimLeft();
            DDV_MinMaxChars(pDX, m_strRedirectPath, 0, 2 * MAX_PATH);

            if (!IsRelURLPath(m_strRedirectPath) 
             && !IsWildcardedRedirectPath(m_strRedirectPath)
             && !IsURLName(m_strRedirectPath))
            {
                ::AfxMessageBox(IDS_BAD_URL_PATH);
                pDX->Fail();
            }
        }
        else // Local directory
        {
            ASSERT(m_nPathType == RADIO_DIRECTORY);
            m_strRedirectPath.Empty();

            if (IsVroot())
            {
                DDX_Text(pDX, IDC_EDIT_PATH, m_strPath);
                m_strPath.TrimLeft();

                if (!IsMasterInstance())
                {
                    DDV_MinMaxChars(pDX, m_strPath, 1, MAX_PATH);
                }
                else
                {
                    if (m_strPath.IsEmpty())
                    {
                        //
                        // No additional validation necc. on master
                        // instance.
                        //
                        return;
                    }
                }

                if (!IsFullyQualifiedPath(m_strPath) && !IsDevicePath(m_strPath))
                {
                    ::AfxMessageBox(IDS_ERR_INVALID_PATH);
                    pDX->Fail();
                }

                if (IsLocal())
                {
                    DWORD dwAttr = GetFileAttributes(m_strPath);

                    if (dwAttr == 0xffffffff || 
                        (dwAttr & FILE_ATTRIBUTE_DIRECTORY) == 0)
                    {
                        ::AfxMessageBox(IDS_ERR_PATH_NOT_FOUND);
                        pDX->Fail();
                    }
                }
            }
        }
    }
    else
    {
        DDX_Text(pDX, IDC_EDIT_REDIRECT, m_strRedirectPath);
        DDX_Text(pDX, IDC_EDIT_PATH, m_strPath);
        DDV_MinMaxChars(pDX, m_strPath, 0, MAX_PATH);

        if (!IsMasterInstance() && IS_VROOT(m_dwAttributes))
        {
            DDV_MinMaxChars(pDX, m_strPath, 1, MAX_PATH);
        }
    }
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CW3DirectoryPage, CInetPropertyPage)
    //{{AFX_MSG_MAP(CW3DirectoryPage)
    ON_BN_CLICKED(IDC_BUTTON_BROWSE, OnButtonBrowse)
    ON_BN_CLICKED(IDC_BUTTON_CONNECT_AS, OnButtonConnectAs)
    ON_BN_CLICKED(IDC_BUTTON_CREATE_REMOVE_APP, OnButtonCreateRemoveApp)
    ON_BN_CLICKED(IDC_BUTTON_UNLOAD_APP, OnButtonUnloadApp)
    ON_BN_CLICKED(IDC_DUMMY_CONFIGURATION, OnButtonConfiguration)
    ON_BN_CLICKED(IDC_CHECK_READ, OnCheckRead)
    ON_BN_CLICKED(IDC_CHECK_WRITE, OnCheckWrite)
    ON_BN_CLICKED(IDC_CHECK_AUTHOR, OnCheckAuthor)
    ON_BN_CLICKED(IDC_RADIO_DIR, OnRadioDir)
    ON_BN_CLICKED(IDC_RADIO_REDIRECT, OnRadioRedirect)
    ON_BN_CLICKED(IDC_RADIO_UNC, OnRadioUnc)
    ON_CBN_SELCHANGE(IDC_COMBO_PERMISSIONS, OnSelchangeComboPermissions)
    ON_CBN_SELCHANGE(IDC_COMBO_PROCESS, OnSelchangeComboProcess)
    //}}AFX_MSG_MAP

    ON_EN_CHANGE(IDC_EDIT_PATH, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_REDIRECT, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_APPLICATION, OnItemChanged)
    ON_BN_CLICKED(IDC_CHECK_DIRECTORY_BROWSING_ALLOWED, OnItemChanged)
    ON_BN_CLICKED(IDC_CHECK_LOG_ACCESS, OnItemChanged)
    ON_BN_CLICKED(IDC_CHECK_SCRIPT, OnItemChanged)
    ON_BN_CLICKED(IDC_CHECK_CHILD, OnItemChanged)
    ON_BN_CLICKED(IDC_CHECK_EXACT, OnItemChanged)
    ON_BN_CLICKED(IDC_CHECK_PERMANENT, OnItemChanged)
    ON_BN_CLICKED(IDC_CHECK_INDEX, OnItemChanged)

END_MESSAGE_MAP()



void
CW3DirectoryPage::RefreshAppState()
/*++

Routine Description:

    Refresh app state parameters

Arguments:

    None

Return Value:

    None

--*/
{
    ASSERT(m_pApplication != NULL);

    CError err(m_pApplication->RefreshAppState());

    if (err.Failed())
    {
        m_dwAppState = APPSTATUS_NOTDEFINED;    

        if (err.Win32Error() == ERROR_PATH_NOT_FOUND)
        {
            //
            // Ignore this error, it really just means the path 
            // doesn't exist in the metabase, which is true for most
            // file and directory properties, and not an error
            // condition.
            //
            err.Reset();
        }
    }
    else
    {
        m_dwAppState = m_pApplication->QueryAppState();
    }

    if (err.Succeeded())
    {
        //
        // Get metabase information
        //
        m_strAppRoot = m_pApplication->m_strAppRoot;
        m_dwAppProtection = m_pApplication->m_dwProcessProtection;
        m_strAppFriendlyName = m_pApplication->m_strFriendlyName;
        m_fIsAppRoot = m_strMetaRoot.CompareNoCase(
            CMetaKey::CleanMetaPath(m_strAppRoot)) == 0;
    }
    else
    {
        //
        // Display error information
        //
        err.MessageBoxFormat(IDS_ERR_APP, MB_OK, NO_HELP_CONTEXT);
    }
}



CString &
CW3DirectoryPage::FriendlyAppRoot(
    IN  LPCTSTR lpAppRoot, 
    OUT CString & strFriendly
    )
/*++

Routine Description:

    Convert the metabase app root path to a friendly display name
    format.

Arguments:

    LPCTSTR lpAppRoot           : App root
    CString & strFriendly       : Output friendly app root format

Return Value:

    Reference to the output string

Notes:

    App root must have been cleaned from WAM format priort
    to calling this function (see first ASSERT below

--*/
{
    //
    // Make sure we cleaned up WAM format
    //
    ASSERT(*lpAppRoot != _T('/'));

    CString strAppRoot(lpAppRoot);

    TRACEEOLID("Unfriendly app root: " << strAppRoot);

    //
    // Break into fields
    //
    strFriendly.Empty();
    LPCTSTR lp = _tcschr(lpAppRoot, _T('/')); // lm   

    if (lp != NULL)
    {
        lp = _tcschr(++lp, _T('/'));         // w3svc

        if (lp == NULL)
        {
            //
            // Master Instance
            //
            strFriendly = m_strWebMaster;

            return strFriendly;
        }
        
        DWORD dwInstance = _ttol(++lp);
        lp = _tcschr(lp, _T('/'));         // Instance #    

        if (lp != NULL)
        {
            lp = _tcschr(++lp, _T('/'));   // Skip "ROOT"
        }

        CInstanceProps prop(QueryServerName(), g_cszSvc, dwInstance);
        HRESULT hr = prop.LoadData();

        if (SUCCEEDED(hr))
        {
            CString strName;
            strFriendly.Format(
                m_strWebFmt, 
                prop.GetDisplayText(strName, SERVICE_SHORT_NAME)
                );

            if (lp != NULL)
            {
                //
                // Add rest of dir path
                //
                strFriendly += lp;
            }

            //
            // Now change forward slashes in the path to backward slashes
            //
            CvtPathToDosStyle(strFriendly);

            return strFriendly;
        }
    };
    
    //
    // Bogus
    //    
    VERIFY(strFriendly.LoadString(IDS_APPROOT_UNKNOWN));

    return strFriendly;
}



int   
CW3DirectoryPage::SetComboSelectionFromAppState(
    IN DWORD dwAppState
    )
/*++

Routine Description:

    Set the protection combo box current selection from the 
    app state DWORD

Arguments:

    DWORD  dwAppState       : Application State

Return Value:

    Combo selection ID

--*/
{
    int nSel = -1;

    switch(dwAppState)
    {
    case CWamInterface::APP_INPROC:
        nSel = m_nSelInProc;
        break;

    case CWamInterface::APP_POOLEDPROC:
        ASSERT(m_pApplication->SupportsPooledProc());
        nSel = m_nSelPooledProc;
        break;

    case CWamInterface::APP_OUTOFPROC:
        nSel = m_nSelOutOfProc;
        break;

    default:
        ASSERT("Bogus app protection level");
    }

    ASSERT(nSel >= 0);
    m_combo_Process.SetCurSel(nSel);

    return nSel;
}



DWORD 
CW3DirectoryPage::GetAppStateFromComboSelection() const
/*++

Routine Description:

    Get the app state DWORD that coresponds to the current combo
    box list selection

Arguments:

    None

Return Value:

    App state DWORD or 0xffffffff;

--*/
{
    int nSel = m_combo_Process.GetCurSel();

    if (nSel == m_nSelOutOfProc)
    {
        return CWamInterface::APP_OUTOFPROC;
    }

    if (nSel == m_nSelPooledProc)
    {
        ASSERT(m_pApplication->SupportsPooledProc());
        return CWamInterface::APP_POOLEDPROC;
    }

    if (nSel == m_nSelInProc)
    {
        return CWamInterface::APP_INPROC;
    }

    ASSERT(FALSE && "Invalid application state");

    return 0xffffffff;
}
 


void
CW3DirectoryPage::SetApplicationState()
/*++

Routine Description:

    Set application control state

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // SetWindowText causes a dirty marker
    //
    BOOL fOld = m_fRecordChanges;
    m_fRecordChanges = FALSE;

    m_fParentEnabled = !m_strAppRoot.IsEmpty();

    m_fAppEnabled = FALSE;

    if (m_pApplication != NULL)
    {
        m_pApplication->RefreshAppState();
        m_fAppEnabled = m_fIsAppRoot && m_pApplication->IsEnabledApplication();
    }

    m_button_CreateRemove.EnableWindow(
        !IsMasterInstance() 
     && HasAdminAccess()
        );
        
    m_button_CreateRemove.SetWindowText(m_fAppEnabled 
        ? m_strRemove 
        : m_strCreate
        );
    
    m_static_ProtectionPrompt.EnableWindow(
        m_fAppEnabled 
     && !IsMasterInstance() 
     && HasAdminAccess()
        );

    //
    // Set selection in combo box to match current app state
    //
    SetComboSelectionFromAppState(m_dwAppProtection);

    m_combo_Process.EnableWindow(
        m_fAppEnabled 
     && !IsMasterInstance() 
     && HasAdminAccess()
        );

    m_static_PermissionsPrompt.EnableWindow(HasAdminAccess());
    m_combo_Permissions.EnableWindow(HasAdminAccess());

    m_static_AppPrompt.EnableWindow(m_fIsAppRoot && HasAdminAccess());
    m_edit_AppFriendlyName.EnableWindow(m_fIsAppRoot && HasAdminAccess());
    m_button_Configuration.EnableWindow(m_fAppEnabled);

    //
    // Write out the verbose starting point.  
    //
    CString str;

    FitPathToControl(
        m_static_StartingPoint,
        FriendlyAppRoot(m_strAppRoot, str)
        );

    m_edit_AppFriendlyName.SetWindowText(m_strAppFriendlyName);
    m_button_Unload.EnableWindow(m_dwAppState == APPSTATUS_RUNNING);

    //
    // Restore (see note on top)
    //
    m_fRecordChanges = fOld;
}



void
CW3DirectoryPage::ChangeTypeTo(
    IN int nNewType
    )
/*++

Routine Description

    Change the directory type

Arguments:

    int nNewType    : New radio value

Return Value:

    None

--*/
{
    int nOldType = m_nPathType;
    m_nPathType = nNewType;

    if (nOldType == m_nPathType)
    {
        //
        // No change
        //
        return;
    }

    OnItemChanged();
    SetStateByType();

    int nID = -1;
    CEdit * pPath = NULL;
    LPCTSTR lpKeepPath = NULL;

    switch(m_nPathType)
    {
    case RADIO_DIRECTORY:
        if (IsVroot())
        {
            if (IsFullyQualifiedPath(m_strPath) || IsDevicePath(m_strPath))
            {
                //
                // The old path info is acceptable, propose it
                // as a default
                //
                lpKeepPath = m_strPath;
            }

            nID = IDS_DIRECTORY_MASK;
            pPath = &m_edit_Path;
        }
        break;

    case RADIO_NETDIRECTORY:
        if (IsVroot())
        {
            if (IsUNCName(m_strPath))
            {
                //
                // The old path info is acceptable, propose it
                // as a default
                //
                lpKeepPath = m_strPath;
            }

            nID = IDS_UNC_MASK;
            pPath = &m_edit_Path;
        }
        break;

    case RADIO_REDIRECT:
        if (!m_strRedirectPath.IsEmpty())
        {
            //
            // The old path info is acceptable, propose it
            // as a default
            //
            lpKeepPath =  m_strRedirectPath;
        }

        nID = IDS_REDIRECT_MASK;
        pPath = &m_edit_Redirect;
        break;

    default:
        ASSERT(FALSE);
        return;
    }

    //
    // Load mask resource, and display
    // this in the directory
    //
    if (pPath != NULL)
    {
        if (lpKeepPath != NULL)
        {
            pPath->SetWindowText(lpKeepPath);
        }
        else
        {
            CString str;
            VERIFY(str.LoadString(nID));
            pPath->SetWindowText(str);
        }
        pPath->SetSel(0,-1);
        pPath->SetFocus();
    }
}



void 
CW3DirectoryPage::ShowControl(
    IN CWnd * pWnd,
    IN BOOL fShow
    )
/*++

Routine Description:

    Show/hide the given control

Arguments:

    CWnd * pWnd     : Window control
    BOOL fShow      : TRUE to show, FALSE to hide

Return Value:

    None

--*/
{
    ASSERT(pWnd != NULL);

    /*
    if (pWnd)
    {
        pWnd->ShowWindow(fShow ? SW_SHOW : SW_HIDE);
    }
    */

    ActivateControl(*pWnd, fShow);
}



int
CW3DirectoryPage::AddStringToComboBox(
    IN CComboBox & combo,
    IN UINT nID
    )
/*++

Routine Description:

    Add a string referred to by resource ID to the combobox

Arguments:

    CComboBox & combo       : Combo box
    UINT nID                : Resource ID

Return Value:

    Index of the string added

--*/
{
    CString str;

    VERIFY(str.LoadString(nID));
    return combo.AddString(str);
}



void
CW3DirectoryPage::SetStateByType()
/*++

Routine Description:

    Set the state of the dialog by the path type currently selected

Arguments:

    None

Return Value:

    None

--*/
{
    BOOL fShowDirFlags;
    BOOL fShowLargeDirGroup;
    BOOL fShowRedirectFlags;
    BOOL fShowApp;
    BOOL fShowIndex;
    BOOL fShowDirBrowse;
    BOOL fShowDAV;
    BOOL fEnableChild;
    BOOL fEnableBrowse;

    switch(m_nPathType)
    {
    case RADIO_DIRECTORY:
        ShowControl(&m_button_ConnectAs, FALSE);
        ShowControl(&m_button_Browse, IsVroot());
        ShowControl(&m_edit_Path, IsVroot());
        ShowControl(&m_edit_DisplayAlias, !IsVroot());
        ShowControl(&m_edit_Redirect, FALSE);
        fShowDirFlags = TRUE;
        fShowLargeDirGroup = !IsFile();
        fShowRedirectFlags = FALSE;
        fShowApp = !IsFile();
        fShowIndex = !IsFile();
        fShowDirBrowse = !IsFile();
        fShowDAV = TRUE;
        fEnableChild = FALSE;
        fEnableBrowse = IsLocal() && !IsMasterInstance() && HasAdminAccess();
        break;

    case RADIO_NETDIRECTORY:
        ShowControl(&m_button_ConnectAs, TRUE);
        ShowControl(&m_button_Browse, FALSE);
        ShowControl(&m_edit_Path, TRUE);
        ShowControl(&m_edit_DisplayAlias, FALSE);
        ShowControl(&m_edit_Redirect, FALSE);
        fShowDirFlags = TRUE;
        fShowLargeDirGroup = TRUE;
        fShowRedirectFlags = FALSE;
        fShowApp = TRUE;
        fShowIndex = TRUE;
        fShowDirBrowse = TRUE;
        fShowDAV = TRUE;
        fEnableChild = FALSE;
        fEnableBrowse = FALSE;
        break;

    case RADIO_REDIRECT:
        ShowControl(&m_button_ConnectAs, FALSE);
        ShowControl(&m_button_Browse, FALSE);
        ShowControl(&m_edit_Path, FALSE);
        ShowControl(&m_edit_DisplayAlias, FALSE);
        ShowControl(&m_edit_Redirect, TRUE);
        fShowDirFlags = FALSE;
        fShowRedirectFlags = TRUE;
        fShowApp = FALSE;
        fShowDAV = FALSE;
        fShowIndex = FALSE;
        fShowDirBrowse = FALSE;
        fEnableChild = !IsFile();
        fEnableBrowse = FALSE;
        break;

    default:
        ASSERT(FALSE && "Invalid Selection");
        return;
    }

    UINT nID;                                            
    for (nID = IDC_DIR_FLAGS_FIRST; nID <= IDC_DIR_FLAGS_LAST; ++nID)
    {
        ShowControl(GetDlgItem(nID), fShowDirFlags);
    }

    ShowControl(GetDlgItem(IDC_STATIC_DIRFLAGS_LARGE),
        fShowDirFlags && fShowLargeDirGroup);
    ShowControl(GetDlgItem(IDC_STATIC_DIRFLAGS_SMALL),
        fShowDirFlags && !fShowLargeDirGroup);

    for (nID = IDC_REDIRECT_FLAGS_FIRST; nID <= IDC_REDIRECT_FLAGS_LAST; ++nID)
    {
        ShowControl(nID, fShowRedirectFlags);
    }

    for (nID = IDC_APPLICATIONS_FIRST; nID <= IDC_APPLICATIONS_LAST; ++nID)
    {
        ShowControl(nID, fShowApp);
    }

    ShowControl(&m_check_Author, fShowDAV);
    ShowControl(&m_check_DirBrowse, fShowDirBrowse);
    ShowControl(&m_check_Index, fShowIndex);

    //
    // Enable/Disable must come after the showcontrols
    //
    m_button_Browse.EnableWindow(fEnableBrowse);
    m_check_Child.EnableWindow(fEnableChild);
    m_static_PathPrompt.SetWindowText(m_strPrompt[m_nPathType]);

    SetApplicationState();
}



void
CW3DirectoryPage::SaveAuthoringState()
/*++

Routine Description:

    Save authoring state

Arguments:

    None

Return Value:

    None

--*/
{
/*
    if (m_check_Write.m_hWnd)
    {
        //
        // Controls initialized -- store live data
        //
        m_fOriginalWrite = m_check_Write.GetCheck() > 0;
        m_fOriginalRead = m_check_Read.GetCheck() > 0;
    }
    else
    {
        //
        // Controls not yet initialized, store original data
        //
        m_fOriginalWrite = m_fWrite;
        m_fOriginalRead = m_fRead;
    }
*/
}



void
CW3DirectoryPage::RestoreAuthoringState()
/*++

Routine Description:

    Restore the authoring state

Arguments:

    None

Return Value:

    None

--*/
{
/*
    m_fWrite = m_fOriginalWrite;
    m_fRead = m_fOriginalRead;
*/
}



void 
CW3DirectoryPage::SetAuthoringState(
    BOOL fAlterReadAndWrite
    )
/*++

Routine Description:

    Set authoring state

Arguments:

    None

Return Value:

    None

--*/
{
    /*
    if (fAlterReadAndWrite)
    {
        if (m_fAuthor)
        {
            //
            // Remember previous setting to undo
            // this thing.
            //
            SaveAuthoringState();
            m_fRead = m_fWrite = TRUE;
        }
        else
        {
            //
            // Restore previous defaults
            //
            RestoreAuthoringState();
        }

        m_check_Read.SetCheck(m_fRead);
        m_check_Write.SetCheck(m_fWrite);
    }
    */

    m_check_Author.EnableWindow(
        (m_fRead || m_fWrite) && 
        HasAdminAccess() &&
        HasDAV()
        );

    //m_check_Read.EnableWindow(!m_fAuthor && HasAdminAccess());
    //m_check_Write.EnableWindow(!m_fAuthor && HasAdminAccess());

    m_check_Read.EnableWindow(HasAdminAccess());
    m_check_Write.EnableWindow(HasAdminAccess());
}



void 
CW3DirectoryPage::SetPathType()
/*++

Routine Description:

    Set path type from given path

Arguments:

    None

Return Value:

    None

--*/
{
    if (!m_strRedirectPath.IsEmpty())
    {
        m_nPathType = RADIO_REDIRECT;
        m_radio_Dir.SetCheck(0);
        m_radio_Unc.SetCheck(0);
        m_radio_Redirect.SetCheck(1);
    }
    else if (!IsVroot())
    {
        m_nPathType = RADIO_DIRECTORY;
        m_radio_Redirect.SetCheck(0);
        m_radio_Unc.SetCheck(0);
        m_radio_Dir.SetCheck(1);
    }
    else
    {
        m_radio_Redirect.SetCheck(0);
        SetPathType(m_strPath);
    }

    m_static_PathPrompt.SetWindowText(m_strPrompt[m_nPathType]);
}


void 
CW3DirectoryPage::SetPathType(
    IN LPCTSTR lpstrPath
    )
/*++

Routine Description:

    Set path type from given path

Arguments:

    LPCTSTR lpstrPath       : Path string

Return Value:

    None

--*/
{
    if (::IsUNCName(lpstrPath))
    {
        m_nPathType = RADIO_NETDIRECTORY;
        m_radio_Dir.SetCheck(0);
        m_radio_Unc.SetCheck(1);
    }
    else
    {
        m_nPathType = RADIO_DIRECTORY;
        m_radio_Unc.SetCheck(0);
        m_radio_Dir.SetCheck(1);
    }
}



BOOL
CW3DirectoryPage::BrowseUser()
/*++

Routine Description:

    Browse for username/password

Arguments:

    None

Return Value:

    TRUE if one was selected, FALSE otherwise.

--*/
{
    CUserAccountDlg dlg(
        QueryServerName(), 
        m_strUserName, 
        m_strPassword, 
        this
        );

    if (dlg.DoModal() == IDOK)
    {
        m_strUserName = dlg.m_strUserName;
        m_strPassword = dlg.m_strPassword;
        OnItemChanged();

        return TRUE;
    }

    return FALSE;
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



void
CW3DirectoryPage::OnItemChanged()
/*++

Routine Description:

    Handle change in data on the item

Arguments:

    None

Return Value:

    None

--*/
{
    if (m_fRecordChanges)
    {
        SetModified(TRUE);
    }
}



void 
CW3DirectoryPage::OnButtonBrowse() 
/*++

Routine Description:

    "Browse" button handler

Arguments:

    None

Return Value:

    None

--*/
{
    ASSERT(IsLocal());
    CString str;
    m_edit_Path.GetWindowText(str);

    CDirBrowseDlg dlgBrowse(this, str);
    if (dlgBrowse.DoModal() == IDOK)
    {
        m_edit_Path.SetWindowText(dlgBrowse.GetFullPath(m_strPath));
        SetPathType();

        OnItemChanged();
    }
}



BOOL 
CW3DirectoryPage::OnSetActive() 
/*++

Routine Description:

    Page has become active.  Dismiss if we're in an inconsistent state

Arguments:

    None

Return Value:

    TRUE to proceed, FALSE to dismiss.

--*/
{
    if (m_pApplication == NULL)
    {
        return FALSE;
    }

    return CInetPropertyPage::OnSetActive();
}



BOOL 
CW3DirectoryPage::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CInetPropertyPage::OnInitDialog();

    //
    // Dynamically create a hidden app config OCX. 
    //
    CRect rc(0, 0, 0, 0);
    CString str;
    VERIFY(str.LoadString(
        IsVroot() ? IDS_RADIO_VDIR : 
        IsDir() ? IDS_RADIO_DIR : IDS_RADIO_FILE));

    m_radio_Dir.SetWindowText(str);

    //
    // Fill permissions combo box.
    //
    for (UINT n = IDS_PERMISSIONS_NONE; n <= IDS_PERMISSIONS_EXECUTE; ++n)
    {
        AddStringToComboBox(m_combo_Permissions, n);
    }
    m_combo_Permissions.SetCurSel(m_nPermissions);

    //
    // And process combo box (low, medium and high)
    //
    m_nSelInProc = AddStringToComboBox(m_combo_Process, IDS_COMBO_INPROC);

    if (m_pApplication->SupportsPooledProc())
    {
        m_nSelPooledProc = AddStringToComboBox(
            m_combo_Process, 
            IDS_COMBO_POOLEDPROC
            ); 
    }
    else
    {
        m_nSelPooledProc = -1; // N/A
    }

    m_nSelOutOfProc = AddStringToComboBox(m_combo_Process, IDS_COMBO_OUTPROC);

    //
    // Selection will be set later...
    //

    SetPathType();
    SetStateByType();
    SetAuthoringState(FALSE);

    TRACEEOLID(m_strMetaRoot);

    //
    // Some items not available on master instance, or if no admin
    // access exists
    //
    BOOL fOkToDIR = TRUE;
    BOOL fOkToUNC = TRUE;

    if (!HasAdminAccess() && IsVroot())
    {
        //
        // If not an admin, operator cannot change
        // the path, he can only cancel a redirect 
        // by going back to the path it had before.
        // 
        fOkToDIR = IsFullyQualifiedPath(m_strPath) || IsDevicePath(m_strPath);
        fOkToUNC = IsUNCName(m_strPath);
    }

    GetDlgItem(IDC_STATIC_PATH_TYPE)->EnableWindow(!IsMasterInstance());
    GetDlgItem(IDC_RADIO_DIR)->EnableWindow(!IsMasterInstance() && fOkToDIR);
    GetDlgItem(IDC_RADIO_UNC)->EnableWindow(
        IsVroot() 
        && !IsMasterInstance() 
        && fOkToUNC
        );
    GetDlgItem(IDC_RADIO_REDIRECT)->EnableWindow(!IsMasterInstance());
    GetDlgItem(IDC_STATIC_PATH_PROMPT)->EnableWindow(!IsMasterInstance());
    GetDlgItem(IDC_EDIT_PATH)->EnableWindow(
        !IsMasterInstance() 
     && HasAdminAccess()
        );
    GetDlgItem(IDC_BUTTON_EDIT_PATH_TYPE)->EnableWindow(!IsMasterInstance());

    //SetApplicationState();

    //
    // Store the original value of fUNC of reference later 
    // when saving out --BoydM
    //
    m_fOriginallyUNC = (m_nPathType == RADIO_NETDIRECTORY);

    //
    // All changes from here on out need to be reflected.
    //
    m_fRecordChanges = TRUE;

    return TRUE;  
}



/* virtual */
HRESULT
CW3DirectoryPage::FetchLoadedValues()
/*++

Routine Description:
    
    Move configuration data from sheet to dialog controls

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;
    m_strMetaRoot = QueryMetaPath();

    BEGIN_META_DIR_READ(CW3Sheet)
        //
        // Use m_ notation because the message crackers require it
        //
        BOOL  m_fDontLog;

        FETCH_DIR_DATA_FROM_SHEET(m_strAlias);
        FETCH_DIR_DATA_FROM_SHEET(m_strUserName);
        FETCH_DIR_DATA_FROM_SHEET(m_strPassword);
        FETCH_DIR_DATA_FROM_SHEET(m_strPath);
        FETCH_DIR_DATA_FROM_SHEET(m_strRedirectPath);
        FETCH_DIR_DATA_FROM_SHEET(m_dwAccessPerms);
        FETCH_DIR_DATA_FROM_SHEET(m_dwDirBrowsing);
        FETCH_DIR_DATA_FROM_SHEET(m_fDontLog);
        FETCH_DIR_DATA_FROM_SHEET(m_fIndexed);
        FETCH_DIR_DATA_FROM_SHEET(m_fExact);
        FETCH_DIR_DATA_FROM_SHEET(m_fChild);
        FETCH_DIR_DATA_FROM_SHEET(m_fPermanent);

        m_fBrowsingAllowed = IS_FLAG_SET(m_dwDirBrowsing, MD_DIRBROW_ENABLED);
        m_fRead = IS_FLAG_SET(m_dwAccessPerms, MD_ACCESS_READ);
        m_fWrite = IS_FLAG_SET(m_dwAccessPerms, MD_ACCESS_WRITE);
        m_fAuthor = IS_FLAG_SET(m_dwAccessPerms, MD_ACCESS_SOURCE);
        m_fLogAccess = !m_fDontLog;

        SaveAuthoringState();

        if (!m_fIsAppRoot)
        {
            m_dwAppState = APPSTATUS_NOTDEFINED;
        }

        MakeDisplayAlias();
    END_META_DIR_READ(err)

    m_nPermissions = IS_FLAG_SET(m_dwAccessPerms, MD_ACCESS_EXECUTE)
        ? COMBO_EXECUTE
        : IS_FLAG_SET(m_dwAccessPerms, MD_ACCESS_SCRIPT)
            ? COMBO_SCRIPT
            : COMBO_NONE;

    //
    // Make sure we were passed the right home directory
    // flag
    //
    ASSERT((m_fHome && !::lstrcmp(m_strAlias, g_cszRoot))
        || (!m_fHome && ::lstrcmp(m_strAlias, g_cszRoot)));

    TRACEEOLID(QueryMetaPath());

    BeginWaitCursor();
    m_pApplication = new CIISApplication(QueryServerName(), QueryMetaPath());
    err = m_pApplication != NULL
        ? m_pApplication->QueryResult()
        : ERROR_NOT_ENOUGH_MEMORY;

    if (err.Win32Error() == ERROR_PATH_NOT_FOUND)
    {
        //
        // No app information; that's ok in cases of file system directories
        // that don't exist in the metabase yet.
        //
        err.Reset();
    }
    EndWaitCursor();

    if (err.Succeeded())
    {
        //
        // CODEWORK: RefreshAppState should be split up into two
        // different methods: one that fetches the data, and one
        // that moves the data to the UI controls on this page.
        //
        RefreshAppState();
    }
    
    return err;
}



/* virtual */
HRESULT
CW3DirectoryPage::SaveInfo()
/*++

Routine Description:

    Save the information on this property page

Arguments:

    None

Return Value:

    Error return code

--*/
{
    ASSERT(IsDirty());

    TRACEEOLID("Saving W3 virtual directory page now...");

    CError err;

    SET_FLAG_IF(m_fBrowsingAllowed, m_dwDirBrowsing, MD_DIRBROW_ENABLED);
    SET_FLAG_IF(m_fRead, m_dwAccessPerms,   MD_ACCESS_READ);
    SET_FLAG_IF(m_fWrite, m_dwAccessPerms,  MD_ACCESS_WRITE);
    SET_FLAG_IF(m_fAuthor, m_dwAccessPerms, MD_ACCESS_SOURCE);
    SET_FLAG_IF(
        (m_nPermissions == COMBO_EXECUTE), 
        m_dwAccessPerms, 
        MD_ACCESS_EXECUTE
        );

    //
    // script is set on EXECUTE as well "Execute (including script)"
    //
    SET_FLAG_IF(((m_nPermissions == COMBO_SCRIPT) || (m_nPermissions == COMBO_EXECUTE)), 
        m_dwAccessPerms, MD_ACCESS_SCRIPT);
    BOOL m_fDontLog = !m_fLogAccess;

    BOOL fUNC = (m_nPathType == RADIO_NETDIRECTORY);
    ASSERT(!fUNC || IsVroot());

    DWORD dwAppProtection = GetAppStateFromComboSelection();

    if (dwAppProtection != m_dwAppProtection && m_fAppEnabled)
    {
        //
        // Isolation state has changed; recreate the application
        //
        CError err2(m_pApplication->RefreshAppState());

        if (err2.Succeeded())
        {
            err2 = m_pApplication->Create(
                m_strAppFriendlyName, 
                dwAppProtection
                );

            //
            // Remember the new state, so we don't do this again
            // the next time the guy hits "apply"
            //
            if (err2.Succeeded())
            {
                m_dwAppProtection = dwAppProtection;
            }
        }

        err2.MessageBoxOnFailure();
    }

    BOOL fUserNameWritten = FALSE;

    BeginWaitCursor();

    BEGIN_META_DIR_WRITE(CW3Sheet)
        INIT_DIR_DATA_MASK(m_dwAccessPerms, m_dwBitRangePermissions)
        INIT_DIR_DATA_MASK(m_dwDirBrowsing, m_dwBitRangeDirBrowsing)

        if (fUNC)      
        {
              // Fix for 380353 -- sergeia
              // When user want to change password only the above construction doesn't work
              // because flag will be false -- user name is the same and not written!
//            STORE_DIR_DATA_ON_SHEET_REMEMBER(m_strUserName, fUserNameWritten)
//            if (fUserNameWritten)
//            {
                STORE_DIR_DATA_ON_SHEET(m_strUserName);
                STORE_DIR_DATA_ON_SHEET(m_strPassword);
//            }
			  // endoffix
        }
        else
        {
            if (m_fOriginallyUNC)
            {
                FLAG_DIR_DATA_FOR_DELETION(MD_VR_USERNAME)
                FLAG_DIR_DATA_FOR_DELETION(MD_VR_PASSWORD)
            }
        }
        STORE_DIR_DATA_ON_SHEET(m_strPath)
        STORE_DIR_DATA_ON_SHEET(m_fDontLog)
        STORE_DIR_DATA_ON_SHEET(m_fIndexed)
        STORE_DIR_DATA_ON_SHEET(m_fChild);
        STORE_DIR_DATA_ON_SHEET(m_fExact);
        STORE_DIR_DATA_ON_SHEET(m_fPermanent);
        //
        // CODEWORK: Not an elegant solution
        //
        pSheet->GetDirectoryProperties().MarkRedirAsInherit(!m_fChild);
        STORE_DIR_DATA_ON_SHEET(m_strRedirectPath)
        STORE_DIR_DATA_ON_SHEET(m_dwAccessPerms)
        STORE_DIR_DATA_ON_SHEET(m_dwDirBrowsing)
    END_META_DIR_WRITE(err)

    if (err.Succeeded() && m_pApplication->IsEnabledApplication())
    {
        err = m_pApplication->WriteFriendlyName(m_strAppFriendlyName);
    }

    if (err.Succeeded())
    {
        //
        // Save Defaults
        //
        SaveAuthoringState();
    }

    EndWaitCursor();

    return err;
}



BOOL
CW3DirectoryPage::CheckWriteAndExecWarning()
/*++

Routine Description:

    Warn if both 'exec' and 'write' permissions are set.
    
Arguments:

    None

Return Value:

    TRUE to proceed anyway.

-*/
{
    if (m_nPermissions == COMBO_EXECUTE && m_fWrite)
    {
        if (::AfxMessageBox(
            IDS_WRN_WRITE_EXEC,
            MB_YESNO | MB_DEFBUTTON2
            ) != IDYES)
        {
            return FALSE;
        }
    }

    OnItemChanged();

    return TRUE;
}



void
CW3DirectoryPage::OnCheckRead() 
/*++

Routine Description:

    handle 'read' checkbox

Arguments:

    None

Return Value:

    None

--*/
{
    m_fRead = !m_fRead;
    SetAuthoringState(FALSE);
    OnItemChanged();
}



void
CW3DirectoryPage::OnCheckWrite() 
/*++

Routine Description:

    handle 'write' checkbox

Arguments:

    None

Return Value:

    None

--*/
{
    m_fWrite = !m_fWrite;

    if (!CheckWriteAndExecWarning())
    {
        //
        // Undo
        //
        m_fWrite = FALSE;
        m_check_Write.SetCheck(m_fWrite);
    }
    else
    {
        SetAuthoringState(FALSE);
        OnItemChanged();
    }
}



void 
CW3DirectoryPage::OnCheckAuthor() 
/*++

Routine Description:

    'Author' checkbox handler

Arguments:

    None

Return Value:

    None

--*/
{
    m_fAuthor = !m_fAuthor;
    SetAuthoringState(TRUE);

    if (!CheckWriteAndExecWarning())
    {
        //
        // Undo -- set script instead
        //
        m_combo_Permissions.SetCurSel(m_nPermissions = COMBO_SCRIPT);
    }

    OnItemChanged();
}



void 
CW3DirectoryPage::OnSelchangeComboPermissions() 
/*++

Routine Description:

    Permissions combo box selection change handler

Arguments:

    None

Return Value:

    None

--*/
{
    m_nPermissions = m_combo_Permissions.GetCurSel();
    ASSERT(m_nPermissions >= COMBO_NONE && m_nPermissions <= COMBO_EXECUTE);

    if (!CheckWriteAndExecWarning())
    {
        //
        // Undo -- set script instead
        //
        m_combo_Permissions.SetCurSel(m_nPermissions = COMBO_SCRIPT);
    }

    OnItemChanged();
}



void 
CW3DirectoryPage::OnButtonConnectAs() 
/*++

Routine Description:

    Handle 'connect as' button.

Arguments:

    None

Return Value:

    None

--*/
{
    BrowseUser();
}



void 
CW3DirectoryPage::OnRadioDir() 
/*++

Routine Description:
    
    'Directory' radio button handler

Arguments:

    None

Return Value:

    None

--*/
{
    ChangeTypeTo(RADIO_DIRECTORY);
}



void 
CW3DirectoryPage::OnRadioUnc() 
/*++

Routine Description:
    
    'Network path' radio button handler

Arguments:

    None

Return Value:

    None

--*/
{
    ChangeTypeTo(RADIO_NETDIRECTORY);
}



void 
CW3DirectoryPage::OnRadioRedirect() 
/*++

Routine Description:
    
    'Redirect' radio button handler

Arguments:

    None

Return Value:

    None

--*/
{
    ChangeTypeTo(RADIO_REDIRECT);
}



void 
CW3DirectoryPage::OnButtonCreateRemoveApp() 
/*++

Routine Description:

    Create/Remove button handler

Arguments:

    None

Return Value:

    None

--*/
{
    BeginWaitCursor();

    CError err(m_pApplication->RefreshAppState());

    if (m_fAppEnabled)
    {
        //
        // App currently exists -- delete it
        //
        err = m_pApplication->Delete();
    }    
    else
    {
        //
        // Create new app in-proc
        //
        CString strAppName;

        if (m_fHome)
        {
            //
            // Use default name for application name
            //
            VERIFY(strAppName.LoadString(IDS_DEF_APP));
        }
        else
        {
            //
            // Use name of the virtual directory for the
            // application name
            //
            strAppName = m_strAlias;
        }

        //
        // Attempt to create a pooled-proc by default;  failing
        // that if it's not supported, create it in proc
        //
        DWORD dwAppProtState = m_pApplication->SupportsPooledProc()
            ? CWamInterface::APP_POOLEDPROC
            : CWamInterface::APP_INPROC;
        err = m_pApplication->Create(strAppName, dwAppProtState);
    }

    if (err.Succeeded())
    {
        RefreshAppState();
        NotifyMMC();  
    }

    //
    // Move app data to the controls
    //
    UpdateData(FALSE);

    EndWaitCursor();    

    err.MessageBoxOnFailure();    
    SetApplicationState();
}



void 
CW3DirectoryPage::OnButtonUnloadApp() 
/*++

Routine Description:

    'Unload' button handler

Arguments:

    None

Return Value:

    None

--*/
{
    ASSERT(m_dwAppState == APPSTATUS_RUNNING);

    BeginWaitCursor();
    CError err(m_pApplication->RefreshAppState());

    if (err.Succeeded())
    {
        if (m_dwAppProtection == CWamInterface::APP_POOLEDPROC)
        {
            //
            // Warn that everything in its process will get unloaded
            //
            if (!NoYesMessageBox(IDS_WRN_UNLOAD_POOP))
            {
                //
                // Chickened out
                //
                return;
            }
        }

        err = m_pApplication->Unload();
    }

    err.MessageBoxOnFailure();
    RefreshAppState();
    EndWaitCursor();    

    //
    // Ensure that an enabled button will have focus.
    //
    m_button_CreateRemove.SetFocus();

    SetApplicationState();
}


#include "..\AppConfig\AppConfig.h"

void 
CW3DirectoryPage::OnButtonConfiguration() 
/*++

Routine Description:

    Pass on "configuration" button click to the ocx.

Arguments:

    None

Return Value:

    None

--*/
{
   IIISAppConfig * pAppConfig = NULL;
   CLSID clsID;
   HRESULT hr;

   if (  SUCCEEDED(hr = CLSIDFromProgID(OLESTR("AppConfig.IISAppConfig"), &clsID))
      && SUCCEEDED(hr = ::CoCreateInstance(clsID, 
            NULL, 
            CLSCTX_ALL, 
            __uuidof(IIISAppConfig), 
            (void **)&pAppConfig)))
   {
      pAppConfig->put_ComputerName((LPTSTR)(LPCTSTR)GetServerName());
      pAppConfig->put_MetaPath((LPTSTR)QueryMetaPath());
      pAppConfig->put_UserName((LPTSTR)(LPCTSTR)m_strUserName);
      pAppConfig->put_UserPassword((LPTSTR)(LPCTSTR)m_strPassword);
      pAppConfig->Run();
   }
}



void 
CW3DirectoryPage::OnSelchangeComboProcess() 
/*++

Routine Description:

    Handle change in process protection UI

Arguments:

    None

Return Value:

    None

--*/
{
    OnItemChanged();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\w3accts.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        w3accts.cpp

   Abstract:

        WWW Accounts Property Page

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "w3scfg.h"
#include "w3accts.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif



IMPLEMENT_DYNCREATE(CW3AccountsPage, CInetPropertyPage)



CW3AccountsPage::CW3AccountsPage(
    IN CInetPropertySheet * pSheet
    )
/*++

Routine Description:

    Accounts page constructor

Arguments:

    CInetPropertySheet * pSheet : Sheet data

Return Value:

    N/A

--*/
    : CInetPropertyPage(CW3AccountsPage::IDD, pSheet),
      m_ListBoxRes(
        IDB_ACLUSERS,
        CAccessEntryListBox::nBitmaps
        ),
      m_oblSID()
{

#ifdef _DEBUG

    afxMemDF |= checkAlwaysMemDF;

#endif // _DEBUG

    m_list_Administrators.AttachResources(&m_ListBoxRes);

#if 0 // Keep class wizard happy

    //{{AFX_DATA_INIT(CW3AccountsPage)
    //}}AFX_DATA_INIT

#endif // 0

}



CW3AccountsPage::~CW3AccountsPage()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



void
CW3AccountsPage::DoDataExchange(
    IN CDataExchange * pDX
    )
/*

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CInetPropertyPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CW3AccountsPage)
    DDX_Control(pDX, IDC_BUTTON_DELETE, m_button_RemoveAdministrator);
    DDX_Control(pDX, IDC_BUTTON_ADD, m_button_Add);
    //}}AFX_DATA_MAP

    //
    // Private DDX/DDV Routines
    //
    DDX_Control(pDX, IDC_LIST_ADMINISTRATORS, m_list_Administrators);

}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CW3AccountsPage, CInetPropertyPage)
    //{{AFX_MSG_MAP(CW3AccountsPage)
    ON_BN_CLICKED(IDC_BUTTON_ADD, OnButtonAdd)
    ON_BN_CLICKED(IDC_BUTTON_DELETE, OnButtonDelete)
    ON_CBN_SELCHANGE(IDC_LIST_ADMINISTRATORS, OnSelchangeListAdministrators)
    //}}AFX_MSG_MAP

END_MESSAGE_MAP()




BOOL
CW3AccountsPage::SetAdminRemoveState()
/*++

Routine Description:

    Set the state of the remove button depending on the selection in the
    administrators listbox.  Remove is only enabled if ALL selected
    items are removable.

Arguments:

    None

Return Value:

    TRUE if the remove button is enabled

--*/
{
    int nSel = 0;
    int cSelectedItems = 0;
    BOOL fAllDeletable = TRUE;
    CAccessEntry * pAccess;
    while ((pAccess  = m_list_Administrators.GetNextSelectedItem(&nSel)) != NULL)
    {
        ++cSelectedItems;

        if (!pAccess->IsDeletable())
        {
            fAllDeletable = FALSE;
            break;
        }

        ++nSel;
    }

    fAllDeletable = fAllDeletable && (cSelectedItems > 0);

    m_button_RemoveAdministrator.EnableWindow(
        fAllDeletable 
     && HasOperatorList()
     && HasAdminAccess()
        );

    return fAllDeletable;
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL
CW3AccountsPage::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CInetPropertyPage::OnInitDialog();

    m_list_Administrators.Initialize();

    CWaitCursor wait;


    //
    // Build the ACL list
    //
    CError err(BuildAclOblistFromBlob(
        ((CW3Sheet *)GetSheet())->GetInstanceProperties().m_acl, 
        m_oblSID
        ));

    err.MessageBoxOnFailure();
    m_list_Administrators.FillAccessListBox(m_oblSID);

    //
    // check if the operators controls are accessible
    //
    m_button_Add.EnableWindow(HasOperatorList());

    SetAdminRemoveState();

    return TRUE;
}



/* virtual */
HRESULT
CW3AccountsPage::FetchLoadedValues()
/*++

Routine Description:
    
    Move configuration data from sheet to dialog controls

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    //
    // Nothing to do..
    //
    return S_OK;
}



/* virtual */
HRESULT
CW3AccountsPage::SaveInfo()
/*++

Routine Description:

    Save the information on this property page

Arguments:

    BOOL fUpdateData : If TRUE, control data has not yet been stored.  This
                       is the case when "apply" is pressed.

Return Value:

    Error return code

--*/
{
    ASSERT(IsDirty());

    TRACEEOLID("Saving W3 accounts page now...");

    //
    // Message crackers require m_ notation
    //
    CBlob m_acl;
    BOOL fAclDirty = BuildAclBlob(m_oblSID, m_acl);

    CError err;

    BeginWaitCursor();

    BEGIN_META_INST_WRITE(CW3Sheet)
        if (fAclDirty)
        {
            STORE_INST_DATA_ON_SHEET(m_acl)
        }
    END_META_INST_WRITE(err)

    EndWaitCursor();

    return err;
}



void
CW3AccountsPage::OnItemChanged()
/*++

Routine Description:

    All EN_CHANGE and BN_CLICKED messages map to this function

Arguments:

    None

Return Value:

    None

--*/
{
    SetModified(TRUE);
}


void 
CW3AccountsPage::OnButtonAdd()
/*++

Routine Description:

    'Add' button has been pressed

Arguments:

    None

Return Value:

    None

--*/
{
    if (m_list_Administrators.AddToAccessList(
        this,
        QueryServerName(),
        m_oblSID
        ))
    {
        OnItemChanged();
    }

    SetAdminRemoveState();
}


void 
CW3AccountsPage::OnSelchangeListAdministrators()
/*++

Routine Description:

    Selection Change in admin list box handler

Arguments:

    None.

Return Value:

    None

--*/
{
    SetAdminRemoveState();
}



void 
CW3AccountsPage::OnButtonDelete()
/*

Routine Description:

    Delete all selected items in the list box

Arguments:

    None.

Return Value:

    None

--*/
{
    int nSel = 0;
    int cChanges = 0;
    CAccessEntry * pAccess;
    while ((pAccess  = m_list_Administrators.GetNextSelectedItem(&nSel)) != NULL)
    {
        //
        // Remove button should be disabled unless all selected
        // items are deletable
        //
        ASSERT(pAccess->IsDeletable());
        if (pAccess->IsDeletable())
        {
            ++cChanges;
            pAccess->FlagForDeletion();
            m_list_Administrators.DeleteString(nSel);

            //
            // Don't advance counter to account for shift
            //
            continue;
        }

        ++nSel;
    }

    if (cChanges)
    {
        OnItemChanged();
    }

    if (!SetAdminRemoveState())
    {
        m_button_Add.SetFocus();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\vdir.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        vdir.h

   Abstract:

        WWW Directory Properties Page Definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#ifndef __VDIR_H__
#define __VDIR__H_ 



//{{AFX_INCLUDES()
#include "apps.h"
//}}AFX_INCLUDES



class CW3DirectoryPage : public CInetPropertyPage
/*++

Class Description:

    WWW Virtual Directory Page.

Public Interface:

    CW3DirectoryPage    : Constructor
    ~CW3DirectoryPage   : Destructor

--*/
{
    DECLARE_DYNCREATE(CW3DirectoryPage)

//
// Constructor/Destructor
//
public:
    CW3DirectoryPage(
        IN CInetPropertySheet * pSheet = NULL, 
        IN BOOL fHome                  = FALSE,
        IN DWORD dwAttributes          = FILE_ATTRIBUTE_VIRTUAL_DIRECTORY
        );

    ~CW3DirectoryPage();

//
// Dialog Data
//
protected:
    enum
    {
        RADIO_DIRECTORY,
        RADIO_NETDIRECTORY,
        RADIO_REDIRECT,
    };

    enum
    {
        COMBO_NONE,
        COMBO_SCRIPT,
        COMBO_EXECUTE,
    };

    //{{AFX_DATA(CW3DirectoryPage)
    enum { IDD = IDD_DIRECTORY_PROPERTIES };
    CStatic m_static_ProtectionPrompt;
    CStatic m_static_PermissionsPrompt;
    int     m_nPathType;
    int     m_nPermissions;
    BOOL    m_fBrowsingAllowed;
    BOOL    m_fRead;
    BOOL    m_fWrite;
    BOOL    m_fAuthor;
    BOOL    m_fLogAccess;
    BOOL    m_fIndexed;
    BOOL    m_fChild;
    BOOL    m_fExact;
    BOOL    m_fPermanent;
    CString m_strDisplayAlias;
    CString m_strPath;
    CString m_strRedirectPath;
    CString m_strAppFriendlyName;
    CEdit   m_edit_Footer;
    CEdit   m_edit_Path;
    CEdit   m_edit_DisplayAlias;
    CEdit   m_edit_Redirect;
    CEdit   m_edit_AppFriendlyName;
    CStatic m_static_AppPrompt;
    CStatic m_static_Path;
    CStatic m_static_PathPrompt;
    CStatic m_static_AliasPrompt;
    CStatic m_static_Alias;
    CStatic m_static_StartingPoint;
    CButton m_button_Unload;
    CButton m_button_CreateRemove;
    CButton m_button_Browse;
    CButton m_button_ConnectAs;
    CButton m_button_Configuration;
    CButton m_radio_Dir;
    CButton m_check_Author;
    CButton m_check_Child;
    CButton m_check_DirBrowse;
    CButton m_check_Index;
    CButton m_check_Write;
    CButton m_check_Read;
    CComboBox m_combo_Permissions;
    CComboBox m_combo_Process;
    //}}AFX_DATA

    
    BOOL  m_fOriginallyUNC;
    BOOL  m_fLoaded;
    DWORD m_dwAppState;
    DWORD m_dwAppProtection;
    DWORD m_dwAccessPermissions;
    DWORD m_dwDirBrowsing;
    DWORD m_dwBitRangePermissions;
    DWORD m_dwAccessPerms;
    DWORD m_dwBitRangeDirBrowsing;
    CString m_strAlias;
    CString m_strAppRoot;
    CButton m_radio_Unc;
    CButton m_radio_Redirect;

//
// Overrides
//
protected:
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

    //{{AFX_VIRTUAL(CW3DirectoryPage)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CW3DirectoryPage)
    afx_msg void OnButtonBrowse();
    afx_msg void OnButtonConnectAs();
    afx_msg void OnButtonCreateRemoveApp();
    afx_msg void OnButtonUnloadApp();
    afx_msg void OnButtonConfiguration();
    afx_msg void OnChangeEditPath();
    afx_msg void OnCheckRead();
    afx_msg void OnCheckWrite();
    afx_msg void OnCheckAuthor();
    afx_msg void OnRadioDir();
    afx_msg void OnRadioRedirect();
    afx_msg void OnRadioUnc();
    afx_msg void OnSelchangeComboPermissions();
    afx_msg void OnSelchangeComboProcess();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG

    afx_msg void OnItemChanged();

    DECLARE_MESSAGE_MAP()

    void ShowControl(
        IN CWnd * pWnd,
        IN BOOL fShow
        );

    void ShowControl(
        IN UINT nID,
        IN BOOL fShow
        );

    int AddStringToComboBox(
        IN CComboBox & combo,
        IN UINT nID
        );

    int   SetComboSelectionFromAppState(DWORD dwAppState);
    DWORD GetAppStateFromComboSelection()  const;
    BOOL  ShowProcOptionsForThisAppState(
        IN DWORD dwAppProtection
        ) const;
    
    void SetStateByType();
    void SetPathType();
    void SetPathType(LPCTSTR lpstrPath);
    void SetApplicationState();
    void SetState();
    void SetAuthoringState(BOOL fAlterReadAndWrite = TRUE);
    void RefreshAppState();
    void MakeDisplayAlias();
    void ChangeTypeTo(int nNewType);
    BOOL BrowseUser();
    BOOL CheckWriteAndExecWarning();
    LPCTSTR QueryMetaPath();

    CString & FriendlyAppRoot(
        IN LPCTSTR lpAppRoot,
        OUT CString & strStartingPoint
        );

    BOOL IsHome() const { return m_fHome; }

//
// Sheet Data Access
//
protected:
    BOOL IsVroot() const { return IS_VROOT(m_dwAttributes); }
    BOOL IsDir() const { return IS_DIR(m_dwAttributes); }
    BOOL IsFile() const { return IS_FILE(m_dwAttributes); }

protected:
    //
    // Remember/restore settings.
    //
    void SaveAuthoringState();
    void RestoreAuthoringState();

private:
    int   m_nSelInProc;
    int   m_nSelPooledProc;
    int   m_nSelOutOfProc;
    BOOL  m_fHome;
    BOOL  m_fRecordChanges;  
    BOOL  m_fAppEnabled;
    BOOL  m_fIsAppRoot;
    BOOL  m_fParentEnabled;
    BOOL  m_fOriginalBrowsingAllowed;
    BOOL  m_fOriginalRead;
    BOOL  m_fOriginalWrite;
    DWORD m_dwAttributes;
    CString m_strMetaRoot;
    CString m_strOldPath;
    CString m_strUserName;
    CString m_strPassword;
    CString m_strRemove;
    CString m_strCreate;
    CString m_strEnable;
    CString m_strDisable;
    CString m_strWebFmt;
    CString m_strWebMaster;
    CString m_strPrompt[3];
    CIISApplication * m_pApplication;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline void CW3DirectoryPage::ShowControl(
    IN UINT nID,
    IN BOOL fShow
    )
{
    ASSERT(nID > 0);
    ShowControl(GetDlgItem(nID), fShow);
}

inline LPCTSTR CW3DirectoryPage::QueryMetaPath()
{
    return ((CW3Sheet *)GetSheet())->GetDirectoryProperties().QueryMetaRoot();
}

inline BOOL CW3DirectoryPage::ShowProcOptionsForThisAppState(
    IN DWORD dwAppProtection
    ) const
{
    return dwAppProtection == CWamInterface::APP_OUTOFPROC 
        || IsMasterInstance();
}

#endif // __VDIR__H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\ssldlg.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        ssldlg.h

   Abstract:

        SSL Dialog definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/



class CSSLDlg : public CDialog
{
//
// Construction
//
public:
    CSSLDlg(
        IN DWORD & dwAccessPermissions,
        IN BOOL fSSL128Supported,
        IN CWnd * pParent = NULL
        );

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CSSLDlg)
    enum { IDD = IDD_DIALOG_SSL };
    BOOL    m_fRequire128BitSSL;
    //}}AFX_DATA

//
// Overrides
//
protected:
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CSSLDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CSSLDlg)
    virtual void OnOK();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    DWORD & m_dwAccessPermissions;
    BOOL m_fSSL128Supported;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\w3scfg.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        w3scfg.h

   Abstract:

        WWW Configuration Module

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include <lmcons.h>
#include <lmapibuf.h>
#include <svcloc.h>

//
// Required by VC5
//
#ifndef MIDL_INTERFACE
#define MIDL_INTERFACE(x) struct
#endif // MIDL_INTERFACE
#ifndef __RPCNDR_H_VERSION__
#define __RPCNDR_H_VERSION__ 440
#endif // __RPCNDR_H_VERSION__
#include "iwamreg.h"

#include <w3svc.h>

//
// Include Files
//
#include "resource.h"
#include "mmc.h"
#include "svrinfo.h"
#include "comprop.h"

extern const LPCTSTR g_cszSvc;
extern const LPCTSTR g_cszFilters;
extern HINSTANCE hInstance;

//
// Short descriptive name of the service.  This
// is what will show up as the name of the service
// in the internet manager tool.
//
// Issue: I'm assuming here that this name does NOT
//        require localisation.
//
#define SERVICE_SHORT_NAME      _T("Web")


class CConfigDll : public CWinApp
/*++

Class Description:

    Base class for the configuration DLL

--*/
{
public:
    virtual BOOL InitInstance();
    virtual int ExitInstance();

    CConfigDll(
        IN LPCTSTR pszAppName = NULL
        );

protected:
    //{{AFX_MSG(CConfigDll)
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    CString m_strHelpPath;
    LPCTSTR m_lpOldHelpPath;
};

//
// Helper function to determine if SSL is installed
// and enabled on the given server
//
DWORD
IsSSLEnabledOnServer(
    IN  LPCTSTR lpszServer,
    OUT BOOL & fInstalled,
    OUT BOOL & fEnabled
    );

//
// Helper function to see if a certificate is installed
//
BOOL
IsCertInstalledOnServer(
    IN LPCTSTR lpszServerName,
    IN DWORD   dwInstance
    );

//
// Run key manager app
//
void RunKeyManager(
    IN LPCTSTR lpszServer = NULL
    );


inline BOOL LoggingEnabled(
    IN DWORD dwLogType
    )
{
    return (dwLogType == MD_LOG_TYPE_ENABLED);
}

inline void EnableLogging(
    OUT DWORD & dwLogType, 
    IN  BOOL fEnabled = TRUE
    )
{
    dwLogType = fEnabled ? MD_LOG_TYPE_ENABLED : MD_LOG_TYPE_DISABLED;
}



//
// Bandwidth definitions
//
#define INFINITE_BANDWIDTH      (0xffffffff)
#define INFINITE_CPU_RAW        (0xffffffff)
#define KILOBYTE                (1024L)
#define MEGABYTE                (1024L * KILOBYTE)
#define DEF_BANDWIDTH           (1 * MEGABYTE)
#define CPU_THROTTLING_FACTOR   (1000)
#define DEFAULT_CPU_PERCENTAGE  (10L)

//
// Some sanity values on max connections
//
#define INITIAL_MAX_CONNECTIONS  (      1000L)
#define UNLIMITED_CONNECTIONS    (2000000000L)
#define MAX_MAX_CONNECTIONS      (UNLIMITED_CONNECTIONS - 1L)

#define MAX_TIMEOUT              (0x7FFFFFFF)



class CW3InstanceProps : public CInstanceProps
/*++

Class Description:
    
    WWW Instance properties class

Public Interface:

    CW3InstanceProps        : Constructor

--*/
{
public:
    CW3InstanceProps(
        IN LPCTSTR lpszServerName,
        IN DWORD   dwInstance = MASTER_INSTANCE
        );

public:
    //
    // Write Data if dirty
    //
    virtual HRESULT WriteDirtyProps();

protected:    
    //
    // Break out GetAllData() data to data fields
    //
    virtual void ParseFields();

public:
    //
    // Service Page
    //
    MP_DWORD         m_dwLogType;
    MP_CILong        m_nMaxConnections;
    MP_CILong        m_nConnectionTimeOut;
    MP_CStringListEx m_strlSecureBindings;

    //
    // Performance Page
    //
    MP_int           m_nServerSize;
    MP_BOOL          m_fUseKeepAlives;
    MP_BOOL          m_fEnableCPUAccounting;
    MP_DWORD         m_dwCPULimitLogEventRaw;
    MP_DWORD         m_dwCPULimitPriorityRaw;
    MP_DWORD         m_dwCPULimitPauseRaw;
    MP_DWORD         m_dwCPULimitProcStopRaw;
    MP_CILong        m_nMaxNetworkUse;

    //
    // Operators Page
    //
    MP_CBlob         m_acl;

    //
    // Root dir page
    //
    //MP_BOOL          m_fFrontPage;

    //
    // Default Site page
    //
    MP_DWORD         m_dwDownlevelInstance;

    //
    // Certificate and CTL information
    //
    MP_CBlob         m_CertHash;
    MP_CString       m_strCertStoreName;
    MP_CString       m_strCTLIdentifier;
    MP_CString       m_strCTLStoreName;
};



class CW3DirProps : public CChildNodeProps
/*++

Class Description:

    WWW Directory Properties

Public Interface:

    CW3DirProps     : Constructor

--*/
{
public:
    //
    // Constructor
    //
    CW3DirProps(
        IN LPCTSTR lpszServerName,
        IN DWORD   dwInstance  = MASTER_INSTANCE,
        IN LPCTSTR lpszParent  = NULL,
        IN LPCTSTR lpszAlias   = NULL
        );

public:
    //
    // Write Data if dirty
    //
    virtual HRESULT WriteDirtyProps();

protected:    
    //
    // Break out GetAllData() data to data fields
    //
    virtual void ParseFields();

public:
    //
    // Directory properties page
    //
    MP_CString       m_strUserName;
    MP_CString       m_strPassword;
    MP_CString       m_strDefaultDocument;
    MP_CString       m_strFooter;
    MP_CMaskedDWORD  m_dwDirBrowsing;
    MP_BOOL          m_fDontLog;
    MP_BOOL          m_fEnableFooter;
    MP_BOOL          m_fIndexed;

    //
    // HTTP Page
    //
    MP_CString       m_strExpiration;
    MP_CStringListEx m_strlCustomHeaders;

    //
    // Custom Errors
    //
    MP_CStringListEx m_strlCustomErrors;

    //
    // Security page
    //
    MP_DWORD         m_dwAuthFlags;
    MP_DWORD         m_dwSSLAccessPermissions;
    MP_CString       m_strBasicDomain;
    MP_CString       m_strAnonUserName;
    MP_CString       m_strAnonPassword;
    MP_BOOL          m_fPasswordSync;
    MP_BOOL          m_fU2Installed;
    MP_BOOL          m_fUseNTMapper;
    MP_CBlob         m_ipl;
};



class CIISFilter : public CObjectPlus
/*++

Class Description:

    A single filter description

Public Interface:

    CIISFilter      : Constructors
    IsInitialized   : Check to see if the name is set.
    Write           : Write to the metabase.
    QueryResult     : Query result from metabase read
    QueryError      : Returns error as stored in metabase
    QueryName       : Returns filter name
    IsLoaded        : TRUE if filter is loaded
    IsUnloaded      : TRUE if filter is unloaded
    IsEnabled       : TRUE if filter is enabled
    Enable          : Enable filter
    IsDirty         : TRUE if filter values have changed
    IsFlaggedForDeletion : TRUE if filter should be deleted
  
--*/
{
//
// Constructors/Destructors
//
public:
    //
    // Null Constructor
    //
    CIISFilter();

    //
    // Read filter values using provided key
    //
    CIISFilter(
        IN CMetaKey * pKey,
        IN LPCTSTR lpszName
        );

    //
    // Copy constructor
    //
    CIISFilter(
        IN const CIISFilter & flt
        );

public:
    //
    // Sorting helper
    //
    int OrderByPriority(
        IN const CObjectPlus * pobAccess
        ) const;

    BOOL IsInitialized() const { return !m_strName.IsEmpty(); }

    //
    // Write using provided key
    //
    HRESULT Write(CMetaKey * pKey);

public:
    BOOL IsLoaded() const;
    BOOL IsUnloaded() const;
    BOOL IsEnabled() const { return m_fEnabled; }
    void Enable(BOOL fEnabled = TRUE);
    DWORD QueryError() const { return m_dwWin32Error; }
    HRESULT QueryResult() const { return m_hrResult; }

    //
    // Check to see if this item is marked as dirty
    //
    BOOL IsDirty() const { return m_fDirty; }

    //
    // Check to see if this item is flagged for deletion
    //
    BOOL IsFlaggedForDeletion() const { return m_fFlaggedForDeletion; }

    //
    // Set/reset the dirty flag
    //
    void Dirty(BOOL fDirty = TRUE);

    //
    // Flag this item for deletion
    //
    void FlagForDeletion();

    //
    // Get the name of this filter
    //
    LPCTSTR QueryName() const { return m_strName; }

//
// Meta Values
//
public:
    int         m_nPriority;
    int         m_nOrder;
    BOOL        m_fEnabled;
    DWORD       m_dwState;
    DWORD       m_dwWin32Error;
    HRESULT     m_hrResult;
    CString     m_strName;
    CString     m_strExecutable;

//
// State Values
//
private:
    BOOL        m_fDirty;
    BOOL        m_fFlaggedForDeletion;
    DWORD       m_dwFlags;
};



class CIISFilterList : public CMetaKey
/*++

Class Description:

    A list of filters

Public Interface:

    CIISFilterList      : Constructor

    BeginSearch         : Reset the iterator
    MoreFilters         : More items available in the list?
    GetNextFilter       : Get the next item in the list

--*/
{
public:
    CIISFilterList(
        IN LPCTSTR lpszServerName,
        IN LPCTSTR lpszService,
        IN DWORD   dwInstance       = MASTER_INSTANCE
        );

public:
    //
    // Write out the filter list
    //
    HRESULT WriteIfDirty();

//
// Acccess Functions
//
public:
    DWORD QueryInstance() const { return m_dwInstance; }
    BOOL FiltersLoaded()  const { return m_fFiltersLoaded; }

    //
    // Load each filter in turn
    //
    HRESULT LoadAllFilters();

//
// Filter Access Functions
//
public:
    //
    // Reset the filter list iterator
    //
    void ResetEnumerator();

    int GetCount() const { return (int)m_oblFilters.GetCount(); }

    //
    // More filters available in the list? 
    //
    BOOL MoreFilters() const { return m_pos != NULL; }

    //
    // Return position of filter by index
    //
    POSITION GetFilterPositionByIndex(int nSel);

    //
    // Iterate to the next filter in the list
    //
    CIISFilter * GetNextFilter();

    //
    // Remove filter
    //
    void RemoveFilter(int nItem);

    //
    // Add new filter
    //
    void AddFilter(CIISFilter * pFilter);

    //
    // Exchange two filters in the list
    //
    BOOL ExchangePositions(
        IN  int nSel1, 
        IN  int nSel2, 
        OUT CIISFilter *& p1,
        OUT CIISFilter *& p2
        );

    //
    // See if at least one filter is dirty
    //
    BOOL HasDirtyFilter() const;

//
// Virtual Interface:
//
public:
    virtual BOOL Succeeded() const { return SUCCEEDED(m_hrResult); }
    virtual HRESULT QueryResult() const { return m_hrResult; }

protected:
    //
    // Build up order string from component list
    //
    LPCTSTR BuildFilterOrderString(
        OUT CString & strFilterOrder
        );

protected:
    //
    // Seperator string (one character)
    //
    static const LPCTSTR s_lpszSep;

private:
    BOOL     m_fFiltersLoaded;
    DWORD    m_dwInstance;
    POSITION m_pos;
    HRESULT  m_hrResult;
    CString  m_strFilterOrder;
    CObListPlus m_oblFilters;
};


//
// W3 Property sheet
//
class CW3Sheet : public CInetPropertySheet
{
public:
    CW3Sheet(
        LPCTSTR pszCaption,
        DWORD   dwAttributes,
        LPCTSTR lpszServer,
        DWORD   dwInstance,
        LPCTSTR lpszParent,
        LPCTSTR lpszAlias,
        CWnd *  pParentWnd  = NULL,
        LPARAM  lParam      = 0L,
        LONG_PTR handle      = 0L,
        UINT    iSelectPage = 0
        );

    ~CW3Sheet();

public:
    HRESULT QueryInstanceResult() const;
    HRESULT QueryDirectoryResult() const;
    CW3InstanceProps & GetInstanceProperties() { return *m_ppropInst; }
    CW3DirProps & GetDirectoryProperties() { return *m_ppropDir; }

    virtual HRESULT LoadConfigurationParameters();
    virtual void FreeConfigurationParameters();

protected:
    virtual void WinHelp(DWORD dwData, UINT nCmd = HELP_CONTEXT);

    // Generated message map functions
    //{{AFX_MSG(CW3Sheet)
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    DWORD            m_fNew;
    DWORD            m_dwAttributes;
    CW3InstanceProps * m_ppropInst;
    CW3DirProps      * m_ppropDir;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline BOOL CIISFilter::IsLoaded() const
{
    return m_dwState == MD_FILTER_STATE_LOADED;
}

inline BOOL CIISFilter::IsUnloaded() const
{
    return m_dwState == MD_FILTER_STATE_UNLOADED;
}

inline void CIISFilter::Enable(
    IN BOOL fEnabled
    )
{
    m_fEnabled = fEnabled;
}

inline void CIISFilter::Dirty(
    IN BOOL fDirty
    )
{
    m_fDirty = fDirty;
}

inline void CIISFilter::FlagForDeletion()
{
    m_fFlaggedForDeletion = TRUE;
}

inline void CIISFilterList::ResetEnumerator()
{
    m_pos = m_oblFilters.GetHeadPosition();
}

inline CIISFilter * CIISFilterList::GetNextFilter()
{
    return (CIISFilter *)m_oblFilters.GetNext(m_pos);
}

inline void CIISFilterList::RemoveFilter(int nItem)
{
    m_oblFilters.RemoveIndex(nItem);
}

inline void CIISFilterList::AddFilter(CIISFilter * pFilter)
{
    m_oblFilters.AddTail(pFilter);
}

inline HRESULT CW3Sheet::QueryInstanceResult() const 
{ 
    return m_ppropInst ? m_ppropInst->QueryResult() : S_OK;
}

inline HRESULT CW3Sheet::QueryDirectoryResult() const 
{ 
    return m_ppropDir ? m_ppropDir->QueryResult() : S_OK;
}

#define W3SCFG_DLL_NAME _T("W3SCFG.DLL")
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\w3scfg.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        w3scfg.h

   Abstract:

        WWW Configuration Module

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "wincrypt.h"

#include <process.h>
#include <afxtempl.h>


#include "w3scfg.h"
#include "w3servic.h"
#include "w3accts.h"
#include "vdir.h"
#include "perform.h"
#include "docum.h"
#include "security.h"
#include "httppage.h"
#include "defws.h"
#include "fltdlg.h"
#include "filters.h"
#include "errors.h"
#include "wizard.h"
#include "iisfilt.h"
#include "..\mmc\constr.h"

#define CDELETE(x) {if (x != NULL) delete x;}

//
// Standard configuration Information
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

#define SVC_ID                     INET_HTTP_SVC_ID
//
// Is this server discoverable by INETSLOC?
//
#define INETSLOC_DISCOVERY          TRUE

#if (INETSLOC_DISCOVERY) && !defined(_SVCLOC_)
    #error You must include svcloc.h.
#endif

//
// If INETSLOC_DISCOVERY == TRUE, define the discovery MASK here.
//
#if (INETSLOC_DISCOVERY)
    #define INETSLOC_MASK           INET_W3_SVCLOC_ID
#else  // (!INETSLOC_DISCOVERY)
    #define INETSLOC_MASK           (ULONGLONG)(0x00000000)
#endif // (INETSLOC_DISCOVERY)

#ifdef NO_SERVICE_CONTROLLER
#define CAN_CHANGE_SERVICE_STATE    FALSE
#define CAN_PAUSE_SERVICE           FALSE
#else
//
// Can we change the service state (start/pause/continue)?
//
#define CAN_CHANGE_SERVICE_STATE    TRUE

//
// Can we pause this service?
//
#define CAN_PAUSE_SERVICE           TRUE
#endif // NO_SERVICE_CONTROLLER

//
// Name used for this service by the service controller manager.
//
#define SERVICE_SC_NAME         _T("W3Svc")

//
// Longer name.  This is the text that shows up in
// the tooltips text on the internet manager
// tool.  This probably should be localised.
//
#define SERVICE_LONG_NAME      _T("Web Service")

//
// Web browser protocol name.  e.g. xxxxx://address
// A blank string if this is not supported.
//
#define SERVICE_PROTOCOL        _T("http")

//
// Use normal colour mapping.
//
#define NORMAL_TB_MAPPING          TRUE

//
// Toolbar button background mask. This is
// the colour that gets masked out in
// the bitmap file and replaced with the
// actual button background.  This setting
// is automatically assumed to be lt. gray
// if NORMAL_TB_MAPPING (above) is TRUE
//
#define BUTTON_BMP_BACKGROUND       RGB(192, 192, 192)      // Lt. Gray

//
// Resource ID of the toolbar button bitmap.
//
// The bitmap must be 16x16
//
#define BUTTON_BMP_ID               IDB_WWW

//
// Similar to BUTTON_BMP_BACKGROUND, this is the
// background mask for the service ID
//
#define SERVICE_BMP_BACKGROUND      RGB(255, 0, 255)      // Magenta

//
// Bitmap id which is used in the service view
// of the service manager.  It may be the same
// bitmap as the BUTTON_BMP_ID bitmap.
//
// The bitmap must be 16x16.
//
#define SERVICE_BMP_ID              IDB_WWW

//
// /* K2 */
//
// Similar to BUTTON_BMP_BACKGROUND, this is the
// background mask for the child bitmap
//
#define CHILD_BMP_BACKGROUND         RGB(255, 0, 255)      // Magenta

//
// /* K2 */
//
// Bitmap id which is used for the child
//
// The bitmap must be 16x16
//
#define CHILD_BMP_ID                 IDB_WWWVDIR

//
// Large child bitmap ID
//
#define CHILD_BMP32_ID               IDB_WWWVDIR32

//
// /* K2 */
//
// Large bitmap (32x32) id
//
#define SERVICE_BMP32_ID             IDB_WWW32


//
// Help IDs
//
#define HIDD_DIRECTORY_PROPERTIES       (0x207DB)
#define HIDD_HOME_DIRECTORY_PROPERTIES  (HIDD_DIRECTORY_PROPERTIES + 0x20000)
#define HIDD_FS_DIRECTORY_PROPERTIES    (HIDD_DIRECTORY_PROPERTIES + 0x20001)
#define HIDD_FS_FILE_PROPERTIES         (HIDD_DIRECTORY_PROPERTIES + 0x20002)


//
// Metabase node ID
//
const LPCTSTR g_cszSvc =            _T("W3SVC");
const LPCTSTR g_cszFilters =        _T("Filters");
const LPCTSTR g_cszSSLKeys =        _T("SSLKeys");



//
// End Of Standard configuration Information
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


CW3InstanceProps::CW3InstanceProps(
    IN LPCTSTR lpszServerName,
    IN DWORD   dwInstance   OPTIONAL
    )
/*++

Routine Description:

    Constructor for WWW instance properties

Arguments:

    LPCTSTR lpszServerName      : Server name
    DWORD   dwInstance          : Instance number (could be MASTER_INSTANCE)

Return Value:

    None.

--*/
    : CInstanceProps(lpszServerName, g_cszSvc, dwInstance, 80U),
      /**/
      m_nMaxConnections(INITIAL_MAX_CONNECTIONS),
      m_nConnectionTimeOut((LONG)900L),
      m_strlSecureBindings(),
      m_dwLogType(MD_LOG_TYPE_DISABLED),
      /**/
      m_fUseKeepAlives(TRUE),
      m_fEnableCPUAccounting(FALSE),
      m_nServerSize(MD_SERVER_SIZE_MEDIUM),
      m_nMaxNetworkUse(INFINITE_BANDWIDTH),
      /**/
      m_dwCPULimitLogEventRaw(INFINITE_CPU_RAW),
      m_dwCPULimitPriorityRaw(0),
      m_dwCPULimitPauseRaw(0),
      m_dwCPULimitProcStopRaw(0),
      /**/
      m_acl(),
      /**/
      m_dwDownlevelInstance(1),
      m_CertHash()
{
    //
    // Fetch everything
    //
    m_dwMDUserType = ALL_METADATA;
    m_dwMDDataType = ALL_METADATA;
}



/* virtual */
void
CW3InstanceProps::ParseFields()
/*++

Routine Description:

    Break into fields.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // Fetch base properties
    //
    CInstanceProps::ParseFields();

    BEGIN_PARSE_META_RECORDS(m_dwNumEntries, m_pbMDData)
      //
      // Service Page
      //
      HANDLE_META_RECORD(MD_MAX_CONNECTIONS,     m_nMaxConnections)
      HANDLE_META_RECORD(MD_CONNECTION_TIMEOUT,  m_nConnectionTimeOut)
      HANDLE_META_RECORD(MD_SECURE_BINDINGS,     m_strlSecureBindings)
      HANDLE_META_RECORD(MD_LOG_TYPE,            m_dwLogType)
      //
      // Performance Page
      //
      HANDLE_META_RECORD(MD_SERVER_SIZE,         m_nServerSize)
      HANDLE_META_RECORD(MD_ALLOW_KEEPALIVES,    m_fUseKeepAlives)
      HANDLE_META_RECORD(MD_MAX_BANDWIDTH,       m_nMaxNetworkUse)
      HANDLE_META_RECORD(MD_CPU_LIMITS_ENABLED,  m_fEnableCPUAccounting)
      HANDLE_META_RECORD(MD_CPU_LIMIT_LOGEVENT,  m_dwCPULimitLogEventRaw)
      HANDLE_META_RECORD(MD_CPU_LIMIT_PRIORITY,  m_dwCPULimitPriorityRaw)
      HANDLE_META_RECORD(MD_CPU_LIMIT_PAUSE,     m_dwCPULimitPauseRaw)
      HANDLE_META_RECORD(MD_CPU_LIMIT_PROCSTOP,  m_dwCPULimitProcStopRaw)
      //
      // Operators Page
      //
      HANDLE_META_RECORD(MD_ADMIN_ACL,           m_acl)

      //
      // Certificate and CTL information
      //
      HANDLE_META_RECORD(MD_SSL_CERT_HASH,       m_CertHash)
      HANDLE_META_RECORD(MD_SSL_CERT_STORE_NAME, m_strCertStoreName)
      HANDLE_META_RECORD(MD_SSL_CTL_IDENTIFIER,  m_strCTLIdentifier)
      HANDLE_META_RECORD(MD_SSL_CTL_STORE_NAME,  m_strCTLStoreName)
    END_PARSE_META_RECORDS
}



/* virtual */
HRESULT
CW3InstanceProps::WriteDirtyProps()
/*++

Routine Description:

    Write the dirty properties to the metabase

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err(CInstanceProps::WriteDirtyProps());

    if (err.Failed())
    {
        return err;
    }

    BEGIN_META_WRITE()
      //
      // Service Page
      //
      META_WRITE(MD_MAX_CONNECTIONS,     m_nMaxConnections)
      META_WRITE(MD_CONNECTION_TIMEOUT,  m_nConnectionTimeOut)
      META_WRITE(MD_SECURE_BINDINGS,     m_strlSecureBindings)
      META_WRITE(MD_LOG_TYPE,            m_dwLogType)
      //
      // Performance Page
      //
      META_WRITE(MD_SERVER_SIZE,         m_nServerSize)
      META_WRITE(MD_ALLOW_KEEPALIVES,    m_fUseKeepAlives)
      META_WRITE(MD_MAX_BANDWIDTH,       m_nMaxNetworkUse)
      META_WRITE(MD_CPU_LIMITS_ENABLED,  m_fEnableCPUAccounting)
      META_WRITE(MD_CPU_LIMIT_LOGEVENT,  m_dwCPULimitLogEventRaw)
      META_WRITE(MD_CPU_LIMIT_PRIORITY,  m_dwCPULimitPriorityRaw)
      META_WRITE(MD_CPU_LIMIT_PAUSE,     m_dwCPULimitPauseRaw)
      META_WRITE(MD_CPU_LIMIT_PROCSTOP,  m_dwCPULimitProcStopRaw)
      //
      // Operators Page
      //
      META_WRITE(MD_ADMIN_ACL,           m_acl)

      //
      // Certificate and CTL information
      //
      //META_WRITE(MD_SSL_CERT_HASH,       m_CertHash)
      //META_WRITE(MD_SSL_CERT_STORE_NAME, m_strCertStoreName)
      META_WRITE(MD_SSL_CTL_IDENTIFIER,  m_strCTLIdentifier)
      META_WRITE(MD_SSL_CTL_STORE_NAME,  m_strCTLStoreName)
    END_META_WRITE(err);

    return err;
}



CW3DirProps::CW3DirProps(
    IN LPCTSTR lpszServerName,
    IN DWORD   dwInstance,      OPTIONAL
    IN LPCTSTR lpszParent,      OPTIONAL
    IN LPCTSTR lpszAlias        OPTIONAL
    )
/*++

Routine Description:

    WWW Directory Properties Constructor

Arguments:

    LPCTSTR lpszServerName     : Server Name
    DWORD   dwInstance         : Instance number (could be MASTER_INSTANCE)
    LPCTSTR lpszParent         : Parent path (could be NULL or "")
    LPCTSTR lpszAlias          : Alias name (could be NULL or "")

--*/
    : CChildNodeProps(
        lpszServerName, 
        g_cszSvc, 
        dwInstance,
        lpszParent, 
        lpszAlias,
        WITH_INHERITANCE,
        FALSE               // Full information
        ),
      /**/
      m_strUserName(),
      m_strPassword(),
      m_strDefaultDocument(),
      m_strFooter(),
      m_dwDirBrowsing(0L),
      m_fEnableFooter(FALSE),
      m_fDontLog(FALSE),
      m_fIndexed(FALSE),
      /**/
      m_strExpiration(),
      m_strlCustomHeaders(),
      /**/
      m_strlCustomErrors(),
      /**/
      m_strAnonUserName(),
      m_strAnonPassword(),
      m_fPasswordSync(TRUE),
      m_fU2Installed(FALSE),
      m_fUseNTMapper(FALSE),
      m_dwAuthFlags(MD_AUTH_ANONYMOUS),
      m_dwSSLAccessPermissions(0L),
      m_strBasicDomain(),
      m_ipl()
{
    //
    // Fetch everything
    //
    m_dwMDUserType = ALL_METADATA;
    m_dwMDDataType = ALL_METADATA;
}



/* virtual */
void
CW3DirProps::ParseFields()
/*++

Routine Description:

    Break into fields.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // Fetch base properties
    //
    CChildNodeProps::ParseFields();

    BEGIN_PARSE_META_RECORDS(m_dwNumEntries,  m_pbMDData)
      //
      // VDir Page
      //
      HANDLE_META_RECORD(MD_VR_USERNAME,        m_strUserName)
      HANDLE_META_RECORD(MD_VR_PASSWORD,        m_strPassword)
      HANDLE_META_RECORD(MD_DEFAULT_LOAD_FILE,  m_strDefaultDocument);
      HANDLE_META_RECORD(MD_FOOTER_ENABLED,     m_fEnableFooter);
      HANDLE_META_RECORD(MD_FOOTER_DOCUMENT,    m_strFooter);
      HANDLE_META_RECORD(MD_DIRECTORY_BROWSING, m_dwDirBrowsing);
      HANDLE_META_RECORD(MD_DONT_LOG,           m_fDontLog);
      HANDLE_META_RECORD(MD_IS_CONTENT_INDEXED, m_fIndexed);
      //
      // HTTP Page
      //
      HANDLE_META_RECORD(MD_HTTP_EXPIRES,       m_strExpiration);
      HANDLE_META_RECORD(MD_HTTP_CUSTOM,        m_strlCustomHeaders);
      //
      // Custom Errors
      //
      HANDLE_META_RECORD(MD_CUSTOM_ERROR,       m_strlCustomErrors);
      //
      // Security page
      //
      HANDLE_META_RECORD(MD_AUTHORIZATION,        m_dwAuthFlags);
      HANDLE_META_RECORD(MD_SSL_ACCESS_PERM,      m_dwSSLAccessPermissions);
      HANDLE_META_RECORD(MD_DEFAULT_LOGON_DOMAIN, m_strBasicDomain);
      HANDLE_META_RECORD(MD_ANONYMOUS_USER_NAME,  m_strAnonUserName)
      HANDLE_META_RECORD(MD_ANONYMOUS_PWD,        m_strAnonPassword)
      HANDLE_META_RECORD(MD_ANONYMOUS_USE_SUBAUTH, m_fPasswordSync)
      HANDLE_META_RECORD(MD_U2_AUTH,              m_fU2Installed)
      HANDLE_META_RECORD(MD_SSL_USE_DS_MAPPER,    m_fUseNTMapper);
      HANDLE_META_RECORD(MD_IP_SEC,               m_ipl);
    END_PARSE_META_RECORDS
}



/* virtual */
HRESULT
CW3DirProps::WriteDirtyProps()
/*++

Routine Description:

    Write the dirty properties to the metabase

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err(CChildNodeProps::WriteDirtyProps());

    if (err.Failed())
    {
        return err;
    }

    //
    // CODEWORK: Consider DDX/DDV like methods which do both
    // ParseFields and WriteDirtyProps in a single method.  Must
    // take care not to write data which should only be read, not
    // written
    //
    BEGIN_META_WRITE()
      //
      // VDir Page
      //
      META_WRITE(MD_VR_USERNAME,           m_strUserName)
      META_WRITE(MD_VR_PASSWORD,           m_strPassword)
      META_WRITE(MD_DEFAULT_LOAD_FILE,     m_strDefaultDocument)
      META_WRITE(MD_FOOTER_ENABLED,        m_fEnableFooter)
      META_WRITE(MD_FOOTER_DOCUMENT,       m_strFooter)
      META_WRITE(MD_DIRECTORY_BROWSING,    m_dwDirBrowsing)
      META_WRITE(MD_DONT_LOG,              m_fDontLog)
      META_WRITE(MD_IS_CONTENT_INDEXED,    m_fIndexed)
      //
      // HTTP Page
      //
      META_WRITE(MD_HTTP_EXPIRES,          m_strExpiration)
      META_WRITE(MD_HTTP_CUSTOM,           m_strlCustomHeaders)
      //
      // Custom Errors
      //
      META_WRITE(MD_CUSTOM_ERROR,          m_strlCustomErrors)
      //
      // Security page
      //
      META_WRITE(MD_AUTHORIZATION,         m_dwAuthFlags)
      META_WRITE(MD_SSL_ACCESS_PERM,       m_dwSSLAccessPermissions)
      META_WRITE(MD_DEFAULT_LOGON_DOMAIN,  m_strBasicDomain)
      META_WRITE(MD_ANONYMOUS_USER_NAME,   m_strAnonUserName)
      META_WRITE(MD_ANONYMOUS_PWD,         m_strAnonPassword)
      META_WRITE(MD_ANONYMOUS_USE_SUBAUTH, m_fPasswordSync)
      META_WRITE(MD_SSL_USE_DS_MAPPER,     m_fUseNTMapper)
      META_WRITE(MD_IP_SEC,                m_ipl)
    END_META_WRITE(err);

    return err;
}



CIISFilter::CIISFilter()
/*++

Routine Description:

    Filter contructor for a new filter

Arguments:

    None

Return Value:

    N/A

--*/
    : CObjectPlus(),
      m_strName(),

      //
      // Default Values
      //
      m_strExecutable(),
      m_nPriority(FLTR_PR_INVALID),
      m_nOrder(-1),
      m_dwState(MD_FILTER_STATE_UNLOADED),
      m_dwFlags(0L),
      m_hrResult(S_OK),
      m_dwWin32Error(ERROR_SUCCESS),
      m_fEnabled(TRUE),
      m_fDirty(FALSE),
      m_fFlaggedForDeletion(FALSE)
{
}



CIISFilter::CIISFilter(
    IN CMetaKey * pKey,
    IN LPCTSTR lpszName
    )
/*++

Routine Description:

    Fully defined constructor

Arguments:

    CMetaKey * pKey         : Open key to read from
    LPCTSTR lpszName        : Name of the filter

Return Value:

    N/A

--*/
    : m_strName(lpszName),
      //
      // Default Values
      //
      m_strExecutable(),
      m_nPriority(FLTR_PR_INVALID),
      m_nOrder(-1),
      m_dwState(MD_FILTER_STATE_UNLOADED),
      m_dwFlags(0L),
      m_hrResult(S_OK),
      m_dwWin32Error(ERROR_SUCCESS),
      m_fEnabled(TRUE),
      m_fDirty(FALSE),
      m_fFlaggedForDeletion(FALSE)
{
    ASSERT(pKey != NULL);

    m_hrResult = pKey->QueryValue(
        MD_FILTER_IMAGE_PATH, 
        m_strExecutable,
        NULL,
        m_strName
        );

    pKey->QueryValue(MD_FILTER_ENABLED, m_fEnabled, NULL, m_strName);
    pKey->QueryValue(MD_FILTER_STATE,   m_dwState,  NULL, m_strName);
    pKey->QueryValue(MD_FILTER_FLAGS,   m_dwFlags,  NULL, m_strName);
    
    if (m_dwFlags & SF_NOTIFY_ORDER_HIGH)
    {
        m_nPriority = FLTR_PR_HIGH;
    }
    else if (m_dwFlags & SF_NOTIFY_ORDER_MEDIUM)
    {
        m_nPriority = FLTR_PR_MEDIUM;
    }
    else if (m_dwFlags & SF_NOTIFY_ORDER_LOW)
    {
        m_nPriority = FLTR_PR_LOW;
    }
    else
    {
        m_nPriority = FLTR_PR_INVALID;
    }
}



CIISFilter::CIISFilter(
    IN const CIISFilter & flt
    )
/*++

Routine Description:

    Copy Constructor

Arguments:

    const CIISFilter & flt : Source filter object

Return Value:

    N/A

--*/
    : m_strName(flt.m_strName),
      m_strExecutable(flt.m_strExecutable),
      m_nPriority(flt.m_nPriority),
      m_nOrder(flt.m_nOrder),
      m_hrResult(flt.m_hrResult),
      m_dwState(flt.m_dwState),
      m_dwFlags(flt.m_dwFlags),
      m_dwWin32Error(flt.m_dwWin32Error),
      m_fEnabled(flt.m_fEnabled),
      m_fDirty(FALSE),
      m_fFlaggedForDeletion(FALSE)
{
}



HRESULT
CIISFilter::Write(
    IN CMetaKey * pKey
    )
/*++

Routine Description:

    Write the current value to the metabase

Arguments:

    CMetaKey * pKey      : Open key

Return Value:

    HRESULT

--*/
{
    ASSERT(pKey != NULL);

    CError err;

    CString strKey(_T("IIsFilter"));
    err = pKey->SetValue(MD_KEY_TYPE, strKey, NULL, QueryName());

    if (err.Succeeded())
    {
        err = pKey->SetValue(
            MD_FILTER_IMAGE_PATH, 
            m_strExecutable, 
            NULL, 
            QueryName()
            );
    }

    return err;    
}



int
CIISFilter::OrderByPriority(
    IN const CObjectPlus * pobAccess
    ) const
/*++

Routine Description:

    Compare two filters against each other, and sort on priority first, and
    order secondarily.

Arguments:

    const CObjectPlus * pobAccess : This really refers to another
                                    CIISFilter to be compared to.

Return Value:

    Sort (+1, 0, -1) return value

--*/
{
    const CIISFilter * pob = (CIISFilter *)pobAccess;

    if (pob->m_nPriority != m_nPriority)
    {
        return pob->m_nPriority - m_nPriority;
    }

    //
    // Sort by order in reverse order
    //
    return m_nOrder - pob->m_nOrder;
}



//
// Static initialization
//
const LPCTSTR CIISFilterList::s_lpszSep = _T(",");



CIISFilterList::CIISFilterList(
    IN LPCTSTR lpszServerName,
    IN LPCTSTR lpszService,
    IN DWORD   dwInstance       OPTIONAL
    )
/*++

Routine Description:

    Constructor for filter list

Arguments:

    LPCTSTR lpszServerName     : Server name
    DWORD   dwInstance         : Instance number (could be MASTER_INSTANCE)

Return Value:

    N/A

--*/
    : CMetaKey(
        lpszServerName, 
        METADATA_PERMISSION_READ, 
        lpszService, 
        dwInstance,
        g_cszFilters
        ),
      m_dwInstance(dwInstance),
      m_hrResult(S_OK),
      //
      // Default properties
      //
      m_strFilterOrder(),
      m_fFiltersLoaded(FALSE)
{
    m_hrResult = CMetaKey::QueryResult();

    if (SUCCEEDED(m_hrResult))
    {
        m_hrResult = QueryValue(MD_FILTER_LOAD_ORDER, m_strFilterOrder);
    }
    
    if (m_hrResult == CError::HResult(ERROR_PATH_NOT_FOUND))
    {
        //
        // Harmless
        //
        m_hrResult = S_OK;
    }    

    if (IsOpen())
    {
        Close();
    }
}



HRESULT
CIISFilterList::LoadAllFilters()
/*++

Routine Description:

    Loop through the filter order string, and load information
    about each filter in turn.

Arguments:

    None.

Return Value:

    HRESULT.  The first error stops filter loading.

--*/
{
    ASSERT(SUCCEEDED(m_hrResult));

    if (m_fFiltersLoaded)
    {
        //
        // Already done
        //
        return S_OK;
    }

    int cItems = 0;
    CError err(ReOpen(METADATA_PERMISSION_READ));

    if (err.Failed())
    {
        return err;
    }

    try
    {
        CString strSrc(m_strFilterOrder);
        LPTSTR lp = strSrc.GetBuffer(0);
        lp = StringTok(lp, s_lpszSep);

        int nOrder = 0;

        while (lp)
        {
            CString str(lp);
            str.TrimLeft();
            str.TrimRight();

            TRACEEOLID("Adding filter: " << str);

            CIISFilter * pFilter = new CIISFilter(this, str);
            err = pFilter->QueryResult();

            if (err.Failed())
            {
                break;
            }

            pFilter->m_nOrder = nOrder++;
            m_oblFilters.AddTail(pFilter);

            lp = StringTok(NULL, s_lpszSep);
            ++cItems;
        }

        //
        // Sort filters list
        //
        m_oblFilters.Sort(
            (CObjectPlus::PCOBJPLUS_ORDER_FUNC)
            &CIISFilter::OrderByPriority
            );
    }
    catch(CMemoryException * e)
    {
        e->Delete();
        err = ERROR_NOT_ENOUGH_MEMORY;
    }

    m_fFiltersLoaded = err.Succeeded();

    if (IsOpen())
    {
        Close();
    }

    return err;    
}



HRESULT
CIISFilterList::WriteIfDirty()
/*++

Routine Description:

    Write all the changes in the filters list to the metabase

Arguments:

    None.

Return Value:

    HRESULT

--*/
{
    CError err;

    CString strNewOrder;
    VERIFY(BuildFilterOrderString(strNewOrder));

    //
    // Check to see if this new list is different
    //
    if (!strNewOrder.CompareNoCase(m_strFilterOrder) && !HasDirtyFilter())
    {
        //
        // The priority list hasn't changed, and no filter is marked
        // as dirty, so all done.
        //
        return err;
    }

    //
    // It's dirty -- save it
    //
    do
    {
        err = ReOpen(METADATA_PERMISSION_WRITE);

        if (err.Failed())
        {
            if (err.Win32Error() == ERROR_PATH_NOT_FOUND)
            {
                //
                // Path didn't exist yet, create it and reopen
                // it.
                //
                err = CreatePathFromFailedOpen();

                if (err.Succeeded())
                {
                    err = ReOpen(METADATA_PERMISSION_WRITE);
                }
            }

            if (err.Failed())
            {
                break;
            }
        }

        //
        // Delete deleted filters
        //
        POSITION pos1, pos2;

        for (pos1 = m_oblFilters.GetHeadPosition(); (pos2 = pos1) != NULL; )
        {
            CIISFilter * pFilter = (CIISFilter *)m_oblFilters.GetNext(pos1);
            ASSERT(pFilter != NULL);

            if (pFilter->IsFlaggedForDeletion())
            {
                TRACEEOLID("Deleting filter " << pFilter->QueryName());
                err = DeleteKey(pFilter->QueryName());

                if (err.Failed())
                {
                    break;
                }

                m_oblFilters.RemoveAt(pos2);
            }
        }

        if (err.Failed())
        {
            break;
        }

        //
        // Two passes are necessary, because the filter may
        // have been re-added after it was deleted from the
        // list as new entry.  This could be somewhat improved
        //
        ResetEnumerator();

        while(MoreFilters())
        {
            CIISFilter * pFilter = GetNextFilter();
            ASSERT(pFilter != NULL);

            if (pFilter->IsDirty())
            {
                TRACEEOLID("Writing filter " << pFilter->QueryName());
                err = pFilter->Write(this);

                if (err.Failed())
                {
                    break;
                }

                pFilter->Dirty(FALSE);
            }
        }

        if (err.Failed())
        {
            break;
        }

        //
        // Write the new filter load order
        //
        err = SetValue(MD_FILTER_LOAD_ORDER, strNewOrder);

        if (err.Failed())
        {
            break;
        }

        CString strKey(_T("IIsFilters"));
        err = SetValue(MD_KEY_TYPE, strKey);
        err = SetValue(MD_FILTER_LOAD_ORDER, strNewOrder);

        m_strFilterOrder = strNewOrder;
    }
    while(FALSE);

    if (IsOpen())
    {
        Close();
    }

    return err;
}



POSITION
CIISFilterList::GetFilterPositionByIndex(
    IN  int nSel
    )
/*++

Routine Description:

    Return the position of a filter object by index, skipping filters
    marked for deletion.

Arguments:

    int nSel        - 0 based index into the list

Return Value:

    The POSITION into the filters ObList of the filter at the index
    specified, or NULL if the filter is not found.

--*/
{
    int nIndex = -1;
    CIISFilter * pFilter;
    POSITION pos, 
             posReturn = NULL;

    pos = m_oblFilters.GetHeadPosition();

    while(pos && nIndex < nSel)
    {
        posReturn = pos;
        pFilter = (CIISFilter *)m_oblFilters.GetNext(pos);

        //
        // Skipping deleted filters
        //
        if (!pFilter->IsFlaggedForDeletion())
        {
            ++nIndex;
        }
    }
    
    return posReturn;
}



BOOL
CIISFilterList::ExchangePositions(
    IN  int nSel1,
    IN  int nSel2,
    OUT CIISFilter *& p1,
    OUT CIISFilter *& p2
    )
/*++

Routine Description:

    Exchange the positions of two filters in the list

Arguments:

    int nSel1           : Item 1
    int nSel2           : Item 2
    CIISFilter *& p1    : Returns the item moved to position 1
    CIISFilter *& p2    : Returns the item moved to position 2

Return Value:

    TRUE for success, FALSE for failure.

--*/
{
    ASSERT(SUCCEEDED(m_hrResult));

    //
    // Fetch filters at the two positions (deleted filters are
    // skipped in the index count)
    //
    POSITION pos1 = GetFilterPositionByIndex(nSel1);
    POSITION pos2 = GetFilterPositionByIndex(nSel2);
    p1 = pos2 ? (CIISFilter *)m_oblFilters.GetAt(pos2) : NULL;
    p2 = pos1 ? (CIISFilter *)m_oblFilters.GetAt(pos1) : NULL;

    if (!p1 || !p2)
    {
        TRACEEOLID("Invalid internal state -- filter exchange impossible");        
        ASSERT(FALSE);

        return FALSE;
    }

    TRACEEOLID("Filter (1) name is " << p1->m_strName);
    TRACEEOLID("Filter (2) name is " << p2->m_strName);

    //
    // Exchange
    //
    m_oblFilters.SetAt(pos1, p1);
    m_oblFilters.SetAt(pos2, p2);

    //
    // Success
    //
    return TRUE;
}



LPCTSTR
CIISFilterList::BuildFilterOrderString(
    OUT CString & strFilterOrder
    )
/*++

Routine Description:

    Convert the oblist of filters to a single filter order string
    fit to be stuffed into the metabase

Arguments:

    CString & strFilterOrder        : Output to receive the order string

Return Value:

    A pointer to the new filter order string.

--*/
{
    BOOL fFirst = TRUE;
    POSITION pos = m_oblFilters.GetHeadPosition();

    strFilterOrder.Empty();

    while(pos)
    {
        CIISFilter * pFlt = (CIISFilter *)m_oblFilters.GetNext(pos);

        if (!pFlt->IsFlaggedForDeletion())
        {
            if (!fFirst)
            {
                strFilterOrder += s_lpszSep;
            }
            else
            {
                fFirst = FALSE;
            }

            strFilterOrder += pFlt->m_strName;
        }
    }

    return (LPCTSTR)strFilterOrder;
}



BOOL
CIISFilterList::HasDirtyFilter() const
/*++

Routine Description:

    Go through the list of filters, and return TRUE if any filter
    in the list is dirty or flagged for deletion

Arguments:

    None

Return Value:

    TRUE if any filter is dirty or flagged for deletion.

--*/
{
    ASSERT(SUCCEEDED(m_hrResult));

    POSITION pos = m_oblFilters.GetHeadPosition();

    while(pos)
    {
        CIISFilter * pFilter = (CIISFilter *)m_oblFilters.GetNext(pos);

        if (pFilter->IsFlaggedForDeletion() || pFilter->IsDirty())
        {
            return TRUE;
        }
    }

    return FALSE;
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CW3Sheet, CInetPropertySheet)
    //{{AFX_MSG_MAP(CInetPropertySheet)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



CW3Sheet::CW3Sheet(
    LPCTSTR pszCaption,
    DWORD   dwAttributes,
    LPCTSTR lpszServer,
    DWORD   dwInstance,
    LPCTSTR lpszParent,
    LPCTSTR lpszAlias,
    CWnd *  pParentWnd,
    LPARAM  lParam,
    LONG_PTR handle,
    UINT    iSelectPage
    )
/*++

Routine Description:

    WWW Property sheet constructor

Arguments:

    LPCTSTR pszCaption      : Sheet caption
    LPCTSTR lpszServer      : Server name
    DWORD   dwInstance      : Instance number
    LPCTSTR lpszParent      : Parent path
    LPCTSTR lpszAlias       : Alias name
    CWnd *  pParentWnd      : Parent window
    LPARAM  lParam          : Parameter for MMC console
    LONG_PTR handle          : MMC console handle
    UINT    iSelectPage     : Initial page selected or -1

Return Value:

    N/A

--*/
    : CInetPropertySheet(
        pszCaption,
        lpszServer,
        g_cszSvc,
        dwInstance,
        lpszParent,
        lpszAlias,
        pParentWnd,
        lParam,
        handle,
        iSelectPage
        ),
      m_fNew(FALSE),
      m_dwAttributes(dwAttributes),
      m_ppropInst(NULL),
      m_ppropDir(NULL)
{
}



CW3Sheet::~CW3Sheet()
/*++

Routine Description:

    Sheet destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    FreeConfigurationParameters();

    //
    // Must be deleted by now
    //
    ASSERT(m_ppropInst == NULL);
    ASSERT(m_ppropDir  == NULL);
}



void
CW3Sheet::WinHelp(
    IN DWORD dwData,
    IN UINT nCmd
    )
/*++

Routine Description:

    WWW Property sheet help handler

Arguments:

    DWORD dwData            : WinHelp data (dialog ID)
    UINT nCmd               : WinHelp command

Return Value:

    None

Notes:

    Replace the dialog ID if this is the directory tab.  We have
    different help depending on virtual directory, home, file, directory.

--*/
{
    if (dwData == HIDD_DIRECTORY_PROPERTIES)
    {
        if (IS_FILE(m_dwAttributes))
        {
            dwData = HIDD_FS_FILE_PROPERTIES;
        }
        else if (IS_DIR(m_dwAttributes))
        {
            dwData = HIDD_FS_DIRECTORY_PROPERTIES;
        }
        else
        {
            ASSERT(IS_VROOT(m_dwAttributes));
            ASSERT(m_ppropDir != NULL);

            if (!::lstrcmpi(m_ppropDir->m_strAlias, g_cszRoot))
            {
                //
                // It's a home virtual directory -- change the ID
                //
                dwData = HIDD_HOME_DIRECTORY_PROPERTIES;
            }
        }
    }

    CInetPropertySheet::WinHelp(dwData, nCmd);
}



/* virtual */ 
HRESULT 
CW3Sheet::LoadConfigurationParameters()
/*++

Routine Description:

    Load configuration parameters information

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;

    if (m_ppropInst == NULL)
    {
        ASSERT(m_ppropDir == NULL);

        m_ppropInst = new CW3InstanceProps(m_strServer, m_dwInstance);
        m_ppropDir  = new CW3DirProps(
            m_strServer, 
            m_dwInstance, 
            m_strParent, 
            m_strAlias
            );

        if (!m_ppropInst || !m_ppropDir)
        {
            err = ERROR_NOT_ENOUGH_MEMORY;
            return err;
        }

        err = m_ppropInst->LoadData();

        if (err.Succeeded())
        {
            err = m_ppropDir->LoadData();
        }
    }

    return err;
}



/* virtual */ 
void 
CW3Sheet::FreeConfigurationParameters()
/*++

Routine Description:

    Clean up configuration data

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Must be deleted by now
    //
    ASSERT(m_ppropInst != NULL);
    ASSERT(m_ppropDir  != NULL);

    SAFE_DELETE(m_ppropInst);
    SAFE_DELETE(m_ppropDir);
}



//
// Global DLL instance
//
HINSTANCE hInstance;



//
// ISM API Functions
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



extern "C" DWORD APIENTRY
ISMQueryServiceInfo(
    OUT ISMSERVICEINFO * psi
    )
/*++

Routine Description:

    Return service-specific information back to to the application.  This
    function is called by the service manager immediately after
    LoadLibary();  The size element must be set prior to calling this API.

Arguments:

    ISMSERVICEINFO * psi    : Service information returned.

Return Value:

    Error return value

--*/
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState() );

    ASSERT(psi != NULL);
    ASSERT(psi->dwSize == ISMSERVICEINFO_SIZE);

    psi->dwSize = ISMSERVICEINFO_SIZE;
    psi->dwVersion = ISM_VERSION;

    psi->flServiceInfoFlags = 0
        | ISMI_INETSLOCDISCOVER
        | ISMI_CANCONTROLSERVICE
        | ISMI_CANPAUSESERVICE
        | ISMI_UNDERSTANDINSTANCE
        | ISMI_NORMALTBMAPPING
        | ISMI_INSTANCES
        | ISMI_CHILDREN
        | ISMI_FILESYSTEM
        | ISMI_TASKPADS
        | ISMI_SECURITYWIZARD     
        | ISMI_HASWEBPROTOCOL
        | ISMI_SUPPORTSMETABASE
        | ISMI_SUPPORTSMASTER
        ; /**/

    ASSERT(::lstrlen(SERVICE_LONG_NAME) <= MAX_LNLEN);
    ASSERT(::lstrlen(SERVICE_SHORT_NAME) <= MAX_SNLEN);

    psi->ullDiscoveryMask = INETSLOC_MASK;
    psi->rgbButtonBkMask = BUTTON_BMP_BACKGROUND;
    psi->nButtonBitmapID = BUTTON_BMP_ID;
    psi->rgbServiceBkMask = SERVICE_BMP_BACKGROUND;
    psi->nServiceBitmapID = SERVICE_BMP_ID;
    psi->rgbLargeServiceBkMask = SERVICE_BMP_BACKGROUND;
    psi->nLargeServiceBitmapID = SERVICE_BMP32_ID;
    ::lstrcpy(psi->atchShortName, SERVICE_SHORT_NAME);
    ::lstrcpy(psi->atchLongName, SERVICE_LONG_NAME);

    //
    // /* K2 */
    //
    psi->rgbChildBkMask = CHILD_BMP_BACKGROUND;
    psi->nChildBitmapID = CHILD_BMP_ID ;
    psi->rgbLargeChildBkMask = CHILD_BMP_BACKGROUND;
    psi->nLargeChildBitmapID = CHILD_BMP32_ID;

    //
    // IIS 5
    //
    ASSERT(::lstrlen(SERVICE_PROTOCOL) <= MAX_SNLEN);
    ASSERT(::lstrlen(g_cszSvc) <= MAX_SNLEN);
    ::lstrcpy(psi->atchProtocol, SERVICE_PROTOCOL);
    ::lstrcpy(psi->atchMetaBaseName, g_cszSvc);

    return ERROR_SUCCESS;
}



extern "C" DWORD APIENTRY
ISMDiscoverServers(
    OUT ISMSERVERINFO * psi,        
    IN  DWORD * pdwBufferSize,      
    IN  OUT int * cServers          
    )
/*++

Routine Description:

    Discover machines running this service.  This is only necessary for
    services not discovered with inetscloc (which don't give a mask)

Arguments:

    ISMSERVERINFO * psi         : Server info buffer.
    DWORD * pdwBufferSize       : Size required/available.
    OUT int * cServers          : Number of servers in buffer.

Return Value:

    Error return code

--*/
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());

    *cServers = 0;
    *pdwBufferSize = 0L;

    //
    // We're an inetsloc service
    //
    TRACEEOLID("Warning: service manager called bogus ISMDiscoverServers");
    ASSERT(FALSE);

    return ERROR_SUCCESS;
}



extern "C" DWORD APIENTRY
ISMQueryServerInfo(
    IN  LPCTSTR lpszServerName,
    OUT ISMSERVERINFO * psi
    )
/*++

Routine Description:

    Get information about a specific server with regards to this service.

Arguments:

    LPCTSTR lpszServerName : Name of server.
    ISMSERVERINFO * psi     : Server information returned.

Return Value:

    Error return code

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState() );

    ASSERT(psi != NULL);
    ASSERT(psi->dwSize == ISMSERVERINFO_SIZE);
    ASSERT(::lstrlen(lpszServerName) <= MAX_SERVERNAME_LEN);

    psi->dwSize = ISMSERVERINFO_SIZE;
    ::lstrcpy(psi->atchServerName, lpszServerName);

    //
    // Start with NULL comment
    //
    *psi->atchComment = _T('\0');

    //
    // First look at the SC
    //
    CError err(::QueryInetServiceStatus(
        psi->atchServerName,
        SERVICE_SC_NAME,
        &(psi->nState)
        ));

    if (err.Failed())
    {
        psi->nState = INetServiceUnknown;

        return err.Win32Error();
    }

    //
    // Check the metabase to see if the service is installed
    //
    CMetaKey mk(lpszServerName, METADATA_PERMISSION_READ, g_cszSvc);
    err = mk.QueryResult();

    if (err.Failed())
    {
        if (err == REGDB_E_CLASSNOTREG)
        {
            //
            // Ok, the service is there, but the metabase is not.
            // This must be the old IIS 1-3 version of this service,
            // which doesn't count as having the service installed.
            //
            return ERROR_SERVICE_DOES_NOT_EXIST;
        }

        return err;
    }

    //
    // If not exist, return bogus acceptable error
    //
    return (err.Win32Error() == ERROR_PATH_NOT_FOUND)
        ? ERROR_SERVICE_DOES_NOT_EXIST
        : err;
}



extern "C" DWORD APIENTRY
ISMChangeServiceState(
    IN  int nNewState,
    OUT int * pnCurrentState,
    IN  DWORD dwInstance,
    IN  LPCTSTR lpszServers
    )
/*++

Routine Description:

    Change the service state of the servers (to paused/continue, started,
    stopped, etc)

Arguments:

    int nNewState        : INetService definition.
    int * pnCurrentState : Ptr to current state (will be changed
    DWORD dwInstance     : Instance or 0 for the service itself
    LPCTSTR lpszServers : Double NULL terminated list of servers.

Return Value:

    Error return code

--*/

{
    AFX_MANAGE_STATE(AfxGetStaticModuleState() );

    ASSERT(nNewState >= INetServiceStopped
        && nNewState <= INetServicePaused);

    if (IS_MASTER_INSTANCE(dwInstance))
    {
        return ChangeInetServiceState(
            lpszServers,
            SERVICE_SC_NAME,
            nNewState,
            pnCurrentState
            );
    }

    //
    // Change the state of the instance
    //
    CInstanceProps inst(lpszServers, g_cszSvc, dwInstance);
    inst.LoadData();

    CError err(inst.ChangeState(nNewState));
    *pnCurrentState = inst.m_nISMState;

    return err.Win32Error();
}



extern "C" DWORD APIENTRY
ISMConfigureServers(
    IN HWND hWnd,
    IN DWORD dwInstance,
    IN LPCTSTR lpszServers
    )
/*++

Routine Description:

    Display configuration property sheet.

Arguments:

    HWND hWnd            : Main app window handle
    DWORD dwInstance     : Instance number
    LPCTSTR lpszServers : Double NULL terminated list of servers

Return Value:

    Error return code

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState() );

    DWORD err = ERROR_SUCCESS;

    //
    // Convert the list of servers to a
    // more manageable CStringList.
    //
    CStringList strlServers;
    err = ConvertDoubleNullListToStringList(lpszServers, strlServers);

    if (err != ERROR_SUCCESS)
    {
        TRACEEOLID("Error building server string list");
        return err;
    }

    CString strCaption;

    if (strlServers.GetCount() == 1)
    {
        CString str;
        LPCTSTR lpComputer = PURE_COMPUTER_NAME(lpszServers);

        if (IS_MASTER_INSTANCE(dwInstance))
        {
            VERIFY(str.LoadString(IDS_CAPTION_DEFAULT));
            strCaption.Format(str, lpComputer);
        }
        else
        {
            VERIFY(str.LoadString(IDS_CAPTION));
            strCaption.Format(str, dwInstance, lpComputer);
        }
    }
    else // Multiple server caption
    {
        VERIFY(strCaption.LoadString(IDS_CAPTION_MULTIPLE));
    }

    ASSERT(strlServers.GetCount() == 1);

    //
    // Get the server name
    //
    LPCTSTR lpszServer = strlServers.GetHead();
    DWORD dwAttributes = FILE_ATTRIBUTE_VIRTUAL_DIRECTORY;

    CW3Sheet * pSheet = NULL;

    try
    {

        //
        // Call the APIs and build the property pages
        //
        pSheet = new CW3Sheet(
            strCaption,
            dwAttributes,
            lpszServer,
            dwInstance,
            NULL,
            g_cszRoot,
            CWnd::FromHandlePermanent(hWnd)
            );
        pSheet->AddRef();

        if (SUCCEEDED(pSheet->QueryInstanceResult()))
        {
            //
            // Add instance pages
            //
            pSheet->AddPage(new CW3ServicePage(pSheet));

            if (pSheet->cap().HasOperatorList() && pSheet->HasAdminAccess())
            {
                pSheet->AddPage(new CW3AccountsPage(pSheet));
            }

            pSheet->AddPage(new CW3PerfPage(pSheet));
            pSheet->AddPage(new CW3FiltersPage(pSheet));
        }

        if (SUCCEEDED(pSheet->QueryDirectoryResult()))
        {
            //
            // Add directory pages
            //
            pSheet->AddPage(new CW3DirectoryPage(pSheet, TRUE));
            pSheet->AddPage(new CW3DocumentsPage(pSheet));
            pSheet->AddPage(new CW3SecurityPage(pSheet, TRUE, dwAttributes));
            pSheet->AddPage(new CW3HTTPPage(pSheet));
            pSheet->AddPage(new CW3ErrorsPage(pSheet));
        }

        if(dwInstance == MASTER_INSTANCE)
        {
            pSheet->AddPage(new CDefWebSitePage(pSheet));
        }
    }
    catch(CMemoryException * e)
    {
        TRACEEOLID("Aborting due to exception");
        err = ERROR_NOT_ENOUGH_MEMORY;
        e->Delete();
    }

    if (err == ERROR_SUCCESS)
    {
        ASSERT(pSheet != NULL);
        pSheet->DoModal();
        pSheet->Release();
    }

    //
    // Sheet and pages clean themselves up
    //
    return err;
}



//
// K2 Functions
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



HRESULT
AddMMCPage(
    IN LPPROPERTYSHEETCALLBACK lpProvider,
    IN CPropertyPage * pg
    )
/*++

Routine Description:

    Helper function to add MFC property page using callback provider
    to MMC.

Arguments:

    LPPROPERTYSHEETCALLBACK lpProvider  : Property sheet provider
    CPropertyPage * pg                  : MFC property page object

Return Value:

    HRESULT

--*/
{
    ASSERT(pg != NULL);

    //
    // Patch MFC property page class.
    //
    MMCPropPageCallback(&pg->m_psp);

    HPROPSHEETPAGE hPage = CreatePropertySheetPage(
        (LPCPROPSHEETPAGE)&pg->m_psp
        );

    if (hPage == NULL)
    {
        return E_UNEXPECTED;
    }


    lpProvider->AddPage(hPage);

    return S_OK;
}



extern "C" HRESULT APIENTRY
ISMBind(
    IN  LPCTSTR lpszServer,
    OUT HANDLE * phServer
    )
/*++

Routine Description:

    Generate a handle for the server name.

Arguments:

    LPCTSTR lpszServer      : Server name
    HANDLE * phServer       : Returns a handle

Return Value:
    
    HRESULT

--*/
{
    return COMDLL_ISMBind(lpszServer, phServer);
}



extern "C" HRESULT APIENTRY
ISMUnbind(
    IN HANDLE hServer
    )
/*++

Routine Description:

    Free up the server handle

Arguments:

    HANDLE hServer      : Server handle

Return Value:

    HRESULT

--*/
{
    return COMDLL_ISMUnbind(hServer);
}



extern "C" HRESULT APIENTRY
ISMMMCConfigureServers(
    IN HANDLE  hServer,
    IN PVOID   lpfnMMCCallbackProvider,
    IN LPARAM  param,
    IN LONG_PTR handle,
    IN DWORD   dwInstance
    )
/*++

Routine Description:

    Display configuration property sheet.

Arguments:

    HANDLE  hServer                 : Server handle
    PVOID   lpfnMMCCallbackProvider : MMC Callback provider
    LPARAM  param                   : MMC LPARAM
    LONG_PTR handle                  : MMC Console handle
    DWORD   dwInstance              : Instance number

Return Value:

    HRESULT

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    CError err;
    LPPROPERTYSHEETCALLBACK lpProvider =
        (LPPROPERTYSHEETCALLBACK)lpfnMMCCallbackProvider;

    LPCTSTR lpszServer = GetServerNameFromHandle(hServer);
    ASSERT(lpszServer != NULL);

    CString str, strCaption;
    LPCTSTR lpszComputer = PURE_COMPUTER_NAME(lpszServer);

    if(IS_MASTER_INSTANCE(dwInstance))
    {
        VERIFY(str.LoadString(IDS_CAPTION_DEFAULT));
        strCaption.Format(str, lpszComputer);
    }
    else
    {
        VERIFY(str.LoadString(IDS_CAPTION));
        strCaption.Format(str, dwInstance, lpszComputer);
    }

    DWORD dwAttributes = FILE_ATTRIBUTE_VIRTUAL_DIRECTORY;

    CW3Sheet * pSheet = NULL;

    try
    {
        //
        // Call the APIs and build the property pages
        //
        pSheet = new CW3Sheet(
            strCaption,
            dwAttributes,
            lpszServer,
            dwInstance,
            NULL,
            g_cszRoot,
            NULL,
            param,
            handle
            );

        pSheet->SetModeless();

        if (SUCCEEDED(pSheet->QueryInstanceResult()))
        {
            //
            // Add instance pages
            //
            AddMMCPage(lpProvider, new CW3ServicePage(pSheet));

            if (pSheet->cap().HasOperatorList() && pSheet->HasAdminAccess())
            {
                AddMMCPage(lpProvider, new CW3AccountsPage(pSheet));
            }

            AddMMCPage(lpProvider, new CW3PerfPage(pSheet));
            AddMMCPage(lpProvider, new CW3FiltersPage(pSheet));
        }

        if (SUCCEEDED(pSheet->QueryDirectoryResult()))
        {
            //
            // Add directory pages
            //
            AddMMCPage(lpProvider, new CW3DirectoryPage(pSheet, TRUE));
            AddMMCPage(lpProvider, new CW3DocumentsPage(pSheet));
            AddMMCPage(lpProvider, new CW3SecurityPage(pSheet,TRUE, dwAttributes));
            AddMMCPage(lpProvider, new CW3HTTPPage(pSheet));
            AddMMCPage(lpProvider, new CW3ErrorsPage(pSheet));
        }

        if(dwInstance == MASTER_INSTANCE)
        {
            AddMMCPage(lpProvider, new CDefWebSitePage(pSheet));
        }

    }
    catch(CMemoryException * e)
    {
        TRACEEOLID("Aborting due to exception");
        err = ERROR_NOT_ENOUGH_MEMORY;
        e->Delete();
    }

    //
    // Sheet and pages clean themselves up
    //
    return err;
}



extern "C" HRESULT APIENTRY
ISMMMCConfigureChild(
    IN HANDLE  hServer,
    IN PVOID   lpfnMMCCallbackProvider,
    IN LPARAM  param,
    IN LONG_PTR handle,
    IN DWORD   dwAttributes,
    IN DWORD   dwInstance,
    IN LPCTSTR lpszParent,
    IN LPCTSTR lpszAlias
    )
/*++

Routine Description:

    Display configuration property sheet for child object.

Arguments:

    HANDLE  hServer                 : Server handle
    PVOID lpfnMMCCallbackProvider   : MMC Callback provider
    LPARAM param                    : MMC parameter passed to sheet
    LONG_PTR handle                  : MMC console handle
    DWORD dwAttributes              : Must be FILE_ATTRIBUTE_VIRTUAL_DIRECTORY
    DWORD dwInstance                : Parent instance number
    LPCTSTR lpszParent             : Parent path
    LPCTSTR lpszAlias              : Child to configure

Return Value:

    Error return code

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    LPCTSTR lpszServer = GetServerNameFromHandle(hServer);

    CError err;
    LPPROPERTYSHEETCALLBACK lpProvider =
        (LPPROPERTYSHEETCALLBACK)lpfnMMCCallbackProvider;

    CString strCaption;
    {
        CString str;
        VERIFY(str.LoadString(IDS_DIR_TITLE));

        strCaption.Format(str, lpszAlias);
    }

    CW3Sheet * pSheet = NULL;

    try
    {
        pSheet = new CW3Sheet(
            strCaption,
            dwAttributes,
            lpszServer,
            dwInstance,
            lpszParent,
            lpszAlias,
            NULL,
            param,
            handle
            );

        pSheet->SetModeless();

        //
        // Do not allow editing of a file/dir which is overridden
        // by an alias.
        //
        #pragma message("Warning: file/vroot check stubbed out")

/*
        if (!IS_VROOT(dwAttributes)
            && !pSheet->GetDirectoryProperties().IsPathInherited())
        {
            ::AfxMessageBox(IDS_ERR_VROOT_OVERRIDE);
            pSheet->Release();

            return S_OK;
        }
    */

        //
        // Call the APIs and build the property pages
        //
        if (SUCCEEDED(pSheet->QueryDirectoryResult()))
        {
            AddMMCPage(lpProvider, new CW3DirectoryPage(pSheet, FALSE, dwAttributes));

            if (!IS_FILE(dwAttributes))
            {
                AddMMCPage(lpProvider, new CW3DocumentsPage(pSheet));
            }

            AddMMCPage(lpProvider, new CW3SecurityPage(pSheet, FALSE, dwAttributes));
            AddMMCPage(lpProvider, new CW3HTTPPage(pSheet));
            AddMMCPage(lpProvider, new CW3ErrorsPage(pSheet));
        }
    }
    catch(CMemoryException * e)
    {
        TRACEEOLID("Aborting due to exception");
        err = ERROR_NOT_ENOUGH_MEMORY;
        e->Delete();
    }

    //
    // Sheet and pages will delete themselves
    //
    return err;
}



extern "C" HRESULT APIENTRY
ISMEnumerateInstances(
    IN HANDLE  hServer,
    OUT ISMINSTANCEINFO * pii,
    OUT IN HANDLE * phEnum
    )
/*++

Routine Description:

    Enumerate Instances.  First call with *phEnum == NULL.

Arguments:

    HANDLE  hServer         : Server handle
    ISMINSTANCEINFO * pii   : Instance info buffer
    HANDLE * phEnum         : Enumeration handle.

Return Value:

    Error return code

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    CError err;
    CMetaInterface * pInterface = GetMetaKeyFromHandle(hServer);
    ASSERT(pInterface != NULL);

    BEGIN_ASSURE_BINDING_SECTION
        err = COMDLL_ISMEnumerateInstances(
            pInterface, 
            pii, 
            phEnum, 
            g_cszSvc
            );
    END_ASSURE_BINDING_SECTION(err, pInterface, ERROR_NO_MORE_ITEMS)

    return err;
}



extern "C" HRESULT APIENTRY
ISMAddInstance(
    IN  HANDLE  hServer,         
    IN  DWORD   dwSourceInstance,
    OUT ISMINSTANCEINFO * pii,      OPTIONAL
    IN  DWORD   dwBufferSize
    )
/*++

Routine Description:

    Add an instance.

Arguments:

    HANDLE  hServer             : Server handle
    DWORD dwSourceInstance      : Source instance ID to clone
    ISMINSTANCEINFO * pii       : Instance info buffer.  May be NULL
    DWORD   dwBufferSize        : Size of buffer

Return Value:

    Error return code.

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    CIISWizardSheet sheet(IDB_WIZ_LEFT, IDB_WIZ_HEAD);

    CIISWebWizSettings ws(hServer, g_cszSvc);

    CIISWizardBookEnd pgWelcome(
        IDS_SITE_WELCOME, 
        IDS_NEW_SITE_WIZARD, 
        IDS_SITE_BODY
        );

    CVDWPDescription  pgDescr(&ws);
    CVDWPBindings     pgBindings(&ws);
    CVDWPPath         pgHome(&ws, FALSE);
    CVDWPUserName     pgUserName(&ws, FALSE);
    CVDWPPermissions  pgPerms(&ws, FALSE);

    CIISWizardBookEnd pgCompletion(
        &ws.m_hrResult,
        IDS_SITE_SUCCESS,
        IDS_SITE_FAILURE,
        IDS_NEW_SITE_WIZARD
        );

    sheet.AddPage(&pgWelcome);
    sheet.AddPage(&pgDescr);
    sheet.AddPage(&pgBindings);
    sheet.AddPage(&pgHome);
    sheet.AddPage(&pgUserName);
    sheet.AddPage(&pgPerms);
    sheet.AddPage(&pgCompletion);

    if (sheet.DoModal() == IDCANCEL)
    {
        return CError::HResult(ERROR_CANCELLED);
    }

    CError err(ws.m_hrResult);

    if (err.Succeeded())
    {
        //
        // Get info on it to be returned.
        //
        ISMQueryInstanceInfo(
            hServer, 
            WITHOUT_INHERITANCE,
            pii, 
            ws.m_dwInstance
            );
    }

    return err;
}



extern "C" HRESULT APIENTRY
ISMDeleteInstance(
    IN HANDLE  hServer,         
    IN DWORD   dwInstance
    )
/*++

Routine Description:

   Delete an instance

Arguments:

    HANDLE  hServer         : Server handle
    DWORD   dwInstance      : Instance to be deleted

Return Value:

    Error return code.

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState() );

    CMetaKey * pKey = GetMetaKeyFromHandle(hServer);
    LPCTSTR lpszServer = GetServerNameFromHandle(hServer);

    //
    // First, attempt to delete the applications that might live
    // here
    //
    CIISApplication app(lpszServer, g_cszSvc, dwInstance, g_cszRoot);
    CError err(app.QueryResult());

    if(err.Succeeded())
    {
        //
        // Recursively delete all app info
        //
        err = app.DeleteRecoverable(TRUE);
    }

    if (err.Succeeded())
    {
        BEGIN_ASSURE_BINDING_SECTION
            err = CInstanceProps::Delete(
                pKey,
                g_cszSvc,
                dwInstance
                );
        END_ASSURE_BINDING_SECTION(err, pKey, ERROR_CANCELLED);

        if (err.Failed())
        {
            //
            // Failed to delete the instance -- recover application
            // information recursively
            //
            app.Recover(TRUE);
        }
    }

    return err;
}



extern "C" HRESULT APIENTRY
ISMEnumerateChildren(
    IN  HANDLE  hServer,        
    OUT ISMCHILDINFO * pii,
    OUT IN HANDLE * phEnum,
    IN  DWORD   dwInstance,
    IN  LPCTSTR lpszParent
    )
/*++

Routine Description:

    Enumerate children.  First call with *phEnum == NULL;

Arguments:

    HANDLE hServer              : Server handle
    ISMCHILDINFO * pii          : Child info buffer
    HANDLE * phEnum             : Enumeration handle.
    DWORD   dwInstance          : Parent instance
    LPCTSTR lpszParent          : Parent path

Return Value:

    Error return code.

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    CError err;
    CMetaInterface * pInterface = GetMetaKeyFromHandle(hServer);
    ASSERT(pInterface != NULL);

    BEGIN_ASSURE_BINDING_SECTION
        err = COMDLL_ISMEnumerateChildren(
            pInterface,
            pii,
            phEnum,
            g_cszSvc,
            dwInstance,
            lpszParent
            );
    END_ASSURE_BINDING_SECTION(err, pInterface, ERROR_NO_MORE_ITEMS);

    return err;
}



extern "C" HRESULT APIENTRY
ISMAddChild(
    IN  HANDLE  hServer,
    OUT ISMCHILDINFO * pii,
    IN  DWORD   dwBufferSize,
    IN  DWORD   dwInstance,
    IN  LPCTSTR lpszParent
    )
/*++

Routine Description:

    Add a child.

Arguments:

    HANDLE  hServer             : Server handle
    ISMCHILDINFO * pii          : Child info buffer. May be NULL
    DWORD   dwBufferSize        : Size of info buffer
    DWORD   dwInstance          : Parent instance
    LPCTSTR lpszParent          : Parent path

Return Value:

    Error return code.

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    CIISWizardSheet sheet(IDB_WIZ_LEFT_DIR, IDB_WIZ_HEAD_DIR);

    CIISWebWizSettings ws(hServer, g_cszSvc, dwInstance, lpszParent);

    CIISWizardBookEnd pgWelcome(
        IDS_VDIR_WELCOME, 
        IDS_NEW_VDIR_WIZARD, 
        IDS_VDIR_BODY
        );

    CVDWPAlias        pgAlias(&ws);
    CVDWPPath         pgPath(&ws, TRUE);
    CVDWPUserName     pgUserName(&ws, TRUE);
    CVDWPPermissions  pgPerms(&ws, TRUE);

    CIISWizardBookEnd pgCompletion(
        &ws.m_hrResult,
        IDS_VDIR_SUCCESS,
        IDS_VDIR_FAILURE,
        IDS_NEW_VDIR_WIZARD
        );

    sheet.AddPage(&pgWelcome);
    sheet.AddPage(&pgAlias);
    sheet.AddPage(&pgPath);
    sheet.AddPage(&pgUserName);
    sheet.AddPage(&pgPerms);
    sheet.AddPage(&pgCompletion);

    if (sheet.DoModal() == IDCANCEL)
    {
        return ERROR_CANCELLED;
    }

    CError err(ws.m_hrResult);

    if (err.Succeeded())
    {
        err = ISMQueryChildInfo(
            ws.m_pKey,
            WITH_INHERITANCE,
            pii, 
            ws.m_dwInstance, 
            ws.m_strParent, 
            ws.m_strAlias
            );
    }

    return err;
}



extern "C" HRESULT APIENTRY
ISMDeleteChild(
    IN HANDLE  hServer,
    IN DWORD   dwInstance,
    IN LPCTSTR lpszParent,
    IN LPCTSTR lpszAlias
    )
/*++

Routine Description:

    Delete a child.

Arguments:

    HANDLE  hServer            : Server handle
    DWORD   dwInstance         : Parent instance
    LPCTSTR lpszParent         : Parent path
    LPCTSTR lpszAlias          : Alias of child to be deleted

Return Value:

    Error return code.

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    CMetaKey * pKey = GetMetaKeyFromHandle(hServer);
    LPCTSTR lpszServer = GetServerNameFromHandle(hServer);
    ASSERT(lpszServer != NULL);

    //
    // First, attempt to delete the applications that might live
    // here.
    //
    CIISApplication app(
        lpszServer, 
        g_cszSvc, 
        dwInstance, 
        lpszParent, 
        lpszAlias
        );

    CError err(app.QueryResult());

    if (err.Succeeded())
    {
        err = app.DeleteRecoverable(TRUE);
    }

    if (err.Succeeded())
    {
        BEGIN_ASSURE_BINDING_SECTION
            err = CChildNodeProps::Delete(
                pKey,
                g_cszSvc,
                dwInstance,
                lpszParent,
                lpszAlias
                );
        END_ASSURE_BINDING_SECTION(err, pKey, ERROR_CANCELLED);

        if (err.Failed())
        {
            //
            // Failed to delete the child node -- recover application
            // information
            //
            app.Recover(TRUE);
        }
    }

    return err;
}



extern "C" HRESULT APIENTRY
ISMRenameChild(
    IN HANDLE  hServer,
    IN DWORD   dwInstance,
    IN LPCTSTR lpszParent,
    IN LPCTSTR lpszAlias,
    IN LPCTSTR lpszNewName
    )
/*++

Routine Description:

    Rename a child.

Arguments:

    HANDLE  hServer            : Server handle
    DWORD   dwInstance         : Parent instance
    LPCTSTR lpszParent         : Parent path
    LPCTSTR lpszAlias          : Alias of child to be renamed
    LPCTSTR lpszNewName        : New alias name

Return Value:

    Error return code.

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState() );

    CMetaKey * pKey = GetMetaKeyFromHandle(hServer);
    LPCTSTR lpszServer = GetServerNameFromHandle(hServer);
    ASSERT(lpszServer != NULL);

    //
    // First, attempt to delete the applications that might live
    // here.
    //
    CIISApplication app(
        lpszServer, 
        g_cszSvc,
        dwInstance,
        lpszParent,
        lpszAlias
        );

    CError err(app.QueryResult());

    if (err.Succeeded())
    {
        //
        // Delete recursively
        //
        err = app.DeleteRecoverable(TRUE);
    }

    if (err.Succeeded())
    {
        BEGIN_ASSURE_BINDING_SECTION
            err = CChildNodeProps::Rename(
                pKey,
                g_cszSvc,
                dwInstance,
                lpszParent,
                lpszAlias,
                lpszNewName
                );
        END_ASSURE_BINDING_SECTION(err, pKey, ERROR_CANCELLED);

        if (err.Succeeded())
        {
            //
            // Rename succeeded -- recover application information
            // on the _new_ metabase path.
            //
            CIISApplication appNew(
                lpszServer, 
                g_cszSvc,
                dwInstance,
                lpszParent,
                lpszNewName
                );

            err = appNew.QueryResult();

            if (err.Succeeded())
            {
                err = appNew.Recover(TRUE);
            }
        }
        else
        {
            //
            // Failed to delete the child node -- recover application
            // information on the _old_ metabase path (don't disturb the
            // error code).
            //
            app.Recover(TRUE);
        }
    }

    return err;
}



extern "C" HRESULT APIENTRY
ISMQueryInstanceInfo(
    IN  HANDLE  hServer,
    IN  BOOL    fInherit,
    OUT ISMINSTANCEINFO * pii,
    IN  DWORD   dwInstance
    )
/*++

Routine Description:

    Get instance specific information.

Arguments:

    HANDLE  hServer         : Server handle
    BOOL    fInherit        : TRUE to inherit, FALSE otherwise
    ISMINSTANCEINFO * pii   : Instance info buffer
    LPCTSTR lpszServer      : A single server
    DWORD   dwInstance      : Instance number

Return Value:

    Error return code.

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    ASSERT(pii != NULL);

	CError err;
    CMetaKey * pKey = GetMetaKeyFromHandle(hServer);
    BEGIN_ASSURE_BINDING_SECTION
	CInstanceProps inst(pKey, g_cszSvc, dwInstance);
	err = inst.LoadData();
	if (err.Succeeded())
	{
		//
		// Set the output structure
		//
		pii->dwSize = ISMINSTANCEINFO_SIZE;
		inst.FillInstanceInfo(pii);
		//
		// Get properties on the home directory
		//
		CChildNodeProps home(
			&inst, 
			g_cszSvc, 
			dwInstance, 
			NULL, 
			g_cszRoot, 
			fInherit,
			TRUE                // Path only
			);

		err = home.LoadData();
		home.FillInstanceInfo(pii);
	}
    END_ASSURE_BINDING_SECTION(err, pKey, err);

    return err.Failed() ? err : S_OK;
}



extern "C" HRESULT APIENTRY
ISMQueryChildInfo(
    IN  HANDLE  hServer,
    IN  BOOL    fInherit,
    OUT ISMCHILDINFO * pii,
    IN  DWORD   dwInstance,
    IN  LPCTSTR lpszParent,
    IN  LPCTSTR lpszAlias
    )
/*++

Routine Description:

   Get child-specific info.

Arguments:

    HANDLE  hServer         : Server handle
    BOOL    fInherit        : TRUE to inherit, FALSE otherwise
    ISMCHILDINFO * pii      : Child info buffer
    DWORD   dwInstance      : Parent instance
    LPCTSTR lpszParent      : Parent Path ("" for root)
    LPCTSTR lpszAlias       : Alias of child to be deleted

Return Value:

    Error return code.

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    //
    // Get all the inherited properties
    //
    CChildNodeProps node(
        GetMetaKeyFromHandle(hServer),
        g_cszSvc,
        dwInstance,
        lpszParent,
        lpszAlias,
        fInherit,
        FALSE               // Everything
        );
    CError err(node.LoadData());

    //
    // Set the output structure
    //
    pii->dwSize = ISMCHILDINFO_SIZE;
    node.FillChildInfo(pii);

    return err;
}



extern "C" HRESULT APIENTRY
ISMConfigureChild(
    IN HANDLE  hServer,
    IN HWND    hWnd,
    IN DWORD   dwAttributes,
    IN DWORD   dwInstance,
    IN LPCTSTR lpszParent,
    IN LPCTSTR lpszAlias
    )
/*++

Routine Description:

    Configure child.

Arguments:

    HANDLE  hServer         : Server handle
    HWND    hWnd            : Main app window handle
    DWORD   dwAttributes    : File attributes
    DWORD   dwInstance      : Parent instance
    LPCTSTR lpszParent      : Parent path
    LPCTSTR lpszAlias       : Child to configure or NULL

Return Value:

    Error return code.

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    CMetaKey * pKey = GetMetaKeyFromHandle(hServer);
    LPCTSTR lpszServer = GetServerNameFromHandle(hServer);
    ASSERT(lpszServer != NULL);

    CError err;

    CString strCaption;
    {
        CString str;
        VERIFY(str.LoadString(IDS_DIR_TITLE));

        strCaption.Format(str, lpszAlias);
    }

    CW3Sheet * pSheet = NULL;

    try
    {
        pSheet = new CW3Sheet(
            strCaption,
            dwAttributes,
            lpszServer,
            dwInstance,
            lpszParent,
            lpszAlias,
            CWnd::FromHandlePermanent(hWnd)
            );

        pSheet->AddRef();

        //
        // Do not allow editing of a file/dir which is overridden
        // by an alias.
        //
        if (!IS_VROOT(dwAttributes)
            && !pSheet->GetDirectoryProperties().IsPathInherited())
        {
            ::AfxMessageBox(IDS_ERR_VROOT_OVERRIDE);
            pSheet->Release();

            return S_OK;
        }

        //
        // Call the APIs and build the property pages
        //
        if (SUCCEEDED(pSheet->QueryDirectoryResult()))
        {
            pSheet->AddPage(new CW3DirectoryPage(pSheet, FALSE, dwAttributes));

            if (!IS_FILE(dwAttributes))
            {
                pSheet->AddPage(new CW3DocumentsPage(pSheet));
            }

            pSheet->AddPage(new CW3SecurityPage(pSheet, FALSE, dwAttributes));
            pSheet->AddPage(new CW3HTTPPage(pSheet));
            pSheet->AddPage(new CW3ErrorsPage(pSheet));
        }
    }
    catch(CMemoryException * e)
    {
        TRACEEOLID("Aborting due to exception");
        err = ERROR_NOT_ENOUGH_MEMORY;
        e->Delete();
    }

    if (err.Succeeded())
    {
        ASSERT(pSheet != NULL);
        pSheet->DoModal();
        pSheet->Release();
    }

    //
    // Sheet and pages will delete themselves
    //
    return err;
}



//
// Authentication bit strings
//
FLAGTOSTRING fsAuthentications[] = 
{
    { MD_AUTH_ANONYMOUS, IDS_AUTHENTICATION_ANONYMOUS,     TRUE  },
    { MD_AUTH_ANONYMOUS, IDS_AUTHENTICATION_NO_ANONYMOUS,  FALSE },
    { MD_AUTH_BASIC,     IDS_AUTHENTICATION_BASIC,         TRUE  },
    { MD_AUTH_MD5,       IDS_AUTHENTICATION_DIGEST,        TRUE  },
    { MD_AUTH_NT,        IDS_AUTHENTICATION_NT,            TRUE  },
};



class CWebSecurityTemplate : public CIISSecurityTemplate
/*++

Class Description:

    Web Security template class

Public Interface:

    CWebSecurityTemplate        : Constructor

    ApplySettings               : Apply template to destination path
    GenerateSummary             : Generate text summary

--*/
{
//
// Constructor
//
public:
    CWebSecurityTemplate(
        IN const CMetaKey * pKey,
        IN LPCTSTR lpszMDPath,
        IN BOOL    fInherit     
        );

public:
    //
    // Apply settings to destination path
    //
    virtual HRESULT ApplySettings(
        IN BOOL    fUseTemplates,
        IN LPCTSTR lpszServerName,
        IN LPCTSTR lpszService,
        IN DWORD   dwInstance         = MASTER_INSTANCE,
        IN LPCTSTR lpszParent         = NULL,
        IN LPCTSTR lpszAlias          = NULL
        );

    virtual void GenerateSummary(
        IN BOOL    fUseTemplates,
        IN LPCTSTR lpszServerName,
        IN LPCTSTR lpszService,
        IN DWORD   dwInstance         = MASTER_INSTANCE,
        IN LPCTSTR lpszParent         = NULL,
        IN LPCTSTR lpszAlias          = NULL
        );

protected:
    //
    // Break out GetAllData() data to data fields
    //
    virtual void ParseFields();

public:
    MP_DWORD    m_dwAuthentication;
    MP_DWORD    m_dwDirBrowsing;
};



CWebSecurityTemplate::CWebSecurityTemplate(
    IN const CMetaKey * pKey,
    IN LPCTSTR lpszMDPath,
    IN BOOL    fInherit     
    )
/*++

Routine Description:

    Construct from open key

Arguments:

    const CMetaKey * pKey   : Open key
    LPCTSTR lpszMDPath      : Path
    BOOL    fInherit        : TRUE to inherit values, FALSE if not

Return Value:

    N/A

--*/
    : CIISSecurityTemplate(pKey, lpszMDPath, fInherit),
      m_dwAuthentication(MD_AUTH_ANONYMOUS),
      m_dwDirBrowsing(
        MD_DIRBROW_SHOW_DATE      |
        MD_DIRBROW_SHOW_TIME      |
        MD_DIRBROW_SHOW_SIZE      |
        MD_DIRBROW_SHOW_EXTENSION
        )
{
    //
    // Managed Properties
    //
    m_dlProperties.AddTail(MD_AUTHORIZATION);
    // m_dlProperties.AddTail(MD_DIRECTORY_BROWSING);  // out of IIS 5
}



/* virtual */
void
CWebSecurityTemplate::ParseFields()
/*++

Routine Description:

    Break into fields.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    // Fetch base class values
    //
    CIISSecurityTemplate::ParseFields();

    BEGIN_PARSE_META_RECORDS(m_dwNumEntries,    m_pbMDData)
      HANDLE_META_RECORD(MD_AUTHORIZATION,      m_dwAuthentication)
      //HANDLE_META_RECORD(MD_DIRECTORY_BROWSING, m_dwDirBrowsing) // Out of IIS 5
    END_PARSE_META_RECORDS
}



/* virtual */
HRESULT 
CWebSecurityTemplate::ApplySettings(
    IN BOOL    fUseTemplate,
    IN LPCTSTR lpszServerName,
    IN LPCTSTR lpszService,
    IN DWORD   dwInstance,
    IN LPCTSTR lpszParent,
    IN LPCTSTR lpszAlias
    )
/*++

Routine Description:

    Apply the settings to the specified destination path

Arguments:
    
    BOOL fUseTemplates         : TRUE if the source is from a template,
                                 FALSE if using inheritance.
    LPCTSTR lpszServerName     : Server name
    LPCTSTR lpszService        : Service name 
    DWORD   dwInstance         : Instance        
    LPCTSTR lpszParent         : Parent path (or NULL)
    LPCTSTR lpszAlias          : Alias name  (or NULL)

Return Value:

    HRESULT

--*/
{
    //
    // Write base class properties
    //
    CError err(CIISSecurityTemplate::ApplySettings(
        fUseTemplate,
        lpszServerName,
        lpszService,
        dwInstance,
        lpszParent,
        lpszAlias
        ));

    if (err.Failed())
    {
        return err;
    }

    BOOL fWriteProperties = TRUE;

    CMetaKey mk(
        lpszServerName, 
        METADATA_PERMISSION_WRITE,
        lpszService,
        dwInstance,
        lpszParent,
        lpszAlias
        );

    err = mk.QueryResult();

    if (err.Win32Error() == ERROR_PATH_NOT_FOUND)
    {
        if (!fUseTemplate)
        {
            //
            // No need to delete properties; everything's already
            // inherited.  Note that this is the only legit failure
            // case.  If using a template, the base class must have
            // created the path by now.
            //
            fWriteProperties = FALSE;
            err.Reset();
        }
    }

    if (fWriteProperties)
    {
        do
        {
            BREAK_ON_ERR_FAILURE(err);
            
            if (fUseTemplate)
            {
                //
                // Write values from template
                //
                err = mk.SetValue(
                    MD_AUTHORIZATION, 
                    m_dwAuthentication
                    );

                BREAK_ON_ERR_FAILURE(err);

                //
                // dir browsing out of iis 5
                //
                /*
                err = mk.SetValue(
                    MD_DIRECTORY_BROWSING,
                    m_dwDirBrowsing
                    );
                BREAK_ON_ERR_FAILURE(err);
                */
            }

            //
            // Nothing to do in the inheritance case, because the 
            // base class knows which properties should be deleted
            //
        }
        while(FALSE);
    }

    return err;
}



/* virtual */
void 
CWebSecurityTemplate::GenerateSummary(
    IN BOOL    fUseTemplate,
    IN LPCTSTR lpszServerName,
    IN LPCTSTR lpszService,
    IN DWORD   dwInstance,
    IN LPCTSTR lpszParent,
    IN LPCTSTR lpszAlias
    )
/*++

Routine Description:

    Generate text summary of what's in the security template.  Arguments are
    the same as ApplySettings(), so that the summary can reflect what will
    actually be set.

Arguments:

    BOOL fUseTemplates         : TRUE if the source is from a template,
                                 FALSE if using inheritance.
    LPCTSTR lpszServerName     : Server name
    LPCTSTR lpszService        : Service name 
    DWORD   dwInstance         : Instance        
    LPCTSTR lpszParent         : Parent path (or NULL)
    LPCTSTR lpszAlias          : Alias name  (or NULL)

Return Value:

    None
--*/
{
    AddSummaryString(IDS_AUTHENTICATION_METHODS);

    int i;

    //
    // Summarize Authentication Methods:
    //
    if (m_dwAuthentication == 0L)
    {
        AddSummaryString(IDS_SUMMARY_NONE, 1);
    }
    else
    {
        for (i = 0; i < ARRAY_SIZE(fsAuthentications); ++i)
        {
            if (IS_FLAG_SET(
                m_dwAuthentication, 
                fsAuthentications[i].dwFlag
                ) == fsAuthentications[i].fSet)
            {
                AddSummaryString(fsAuthentications[i].nID, 1);
            }
        }
    }

//
// CODEWORK: Dir browsing settings in the security wizards are postponed
//           to post IIS 5
//
/*
    if (IS_FLAG_SET(m_dwDirBrowsing, MD_DIRBROW_ENABLED))
    {
        AddSummaryString(IDS_DIR_BROWSE_ON, 1);
    }
    else
    {
        AddSummaryString(IDS_DIR_BROWSE_OFF, 1);
    }

    if (IS_FLAG_SET(m_dwDirBrowsing, MD_DIRBROW_LOADDEFAULT))
    {
        AddSummaryString(IDS_LOAD_DEFAULT_ON, 1);
    }
    else
    {
        AddSummaryString(IDS_LOAD_DEFAULT_OFF, 1);
    }
*/

    //
    // Add base class summary
    //
    CIISSecurityTemplate::GenerateSummary(
        fUseTemplate,
        lpszServerName,
        lpszService,
        dwInstance,
        lpszParent,
        lpszAlias
        );
}



CIISSecurityTemplate * 
AllocateSecurityTemplate(
    IN const CMetaKey * pKey,
    IN LPCTSTR lpszMDPath,
    IN BOOL    fInherit     
    )
/*++

Routine Description:

    Security template allocator function

Arguments:

    IN const CMetaKey * pKey    : Open key
    IN LPCTSTR lpszMDPath       : Path
    IN BOOL fInherit            : TRUE to inherit properties

Return Value:

    Pointer to newly allocated security object    

--*/
{
    return new CWebSecurityTemplate(pKey, lpszMDPath, fInherit);
}



extern "C" HRESULT APIENTRY 
ISMSecurityWizard(
    IN HANDLE  hServer,           
    IN DWORD   dwInstance,        
    IN LPCTSTR lpszParent,        
    IN LPCTSTR lpszAlias          
    )
/*++

Routine Description:

    Launch the security wizard

Arguments:

    HANDLE  hServer         : Server handle
    DWORD   dwInstance      : Parent instance
    LPCTSTR lpszParent      : Parent path
    LPCTSTR lpszAlias       : Child to configure or NULL

Return Value:

    HRESULT

--*/
{
    AFX_MANAGE_STATE(::AfxGetStaticModuleState());

    return COMDLL_ISMSecurityWizard(
        &AllocateSecurityTemplate,
        GetMetaKeyFromHandle(hServer),
        IDB_WIZ_LEFT_SEC, 
        IDB_WIZ_HEAD_SEC,
        g_cszSvc,
        dwInstance,
        lpszParent,
        lpszAlias
        );
}



//
// End of ISM API Functions
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



DWORD
IsSSLEnabledOnServer(
    IN  LPCTSTR lpszServer,
    OUT BOOL & fInstalled,
    OUT BOOL & fEnabled
    )
/*++

Routine Description:

   Determine if SSL is installed on the server.

Arguments:

    LPCTSTR lpszServer      : Server name
    BOOL & fInstalled       : Returns TRUE if SSL is installed
    BOOL & fEnabled         : Returns TRUE if SSL is enabled

Return Value:

    Error return code.


--*/
{
/*
    LPW3_CONFIG_INFO lp = NULL;
    CString str;
    DWORD err = ::W3GetAdminInformation((LPTSTR)lpszServer, &lp);
    if (err != ERROR_SUCCESS)
    {
        TRACEEOLID("Failed to determine if SSL is installed");

        return err;
    }

    fInstalled = (lp->dwEncCaps & ENC_CAPS_NOT_INSTALLED) == 0;
    fEnabled = (lp->dwEncCaps & ENC_CAPS_DISABLED) == 0;

    NETAPIBUFFERFREE(lp);

*/

    //
    // Above doesn't work for Beta I -- hack to assume true.
    //
    fInstalled = fEnabled = TRUE;

    return ERROR_SUCCESS;
}



BOOL
IsCertInstalledOnServer(
    IN LPCTSTR lpszServerName,
    IN DWORD   dwInstance
    )
/*++

Routine Description:

    Check to see if a certificate is installed on this virtual server.
    This routine only checks that the cert metabase key was read in.

    by boydm

Arguments:

    None

Return Value:

    TRUE if a certificate are installed, FALSE otherwise

--*/
{
    CError err;
    BOOL fCertInstalled = FALSE;
    CW3InstanceProps * ppropInst;

    //
    // Get the instance properties
    //
    ppropInst = new CW3InstanceProps(lpszServerName, dwInstance);

    //
    // If it succeeded, load the data, then check the answer
    //
    if (ppropInst)
    {
        err = ppropInst->LoadData();

        if (err.Succeeded())
        {
            //
            // Get the specific data to a local holder
            // weird. You have to declare and assign the blob 
            // on different lines. Otherwise it gets constructed 
            // wrong and it tries to free an invalid
            // memory block and bad things happen.
            //
            CBlob blobHash;
            blobHash = ppropInst->m_CertHash;

//           CString strStore = ppropInst->m_strCertStoreName;

            //
            // If the certificate hash is there,
            // then we have a certificate
            //
            if (!blobHash.IsEmpty())
            {
                fCertInstalled = TRUE;
            }
        }
    }

    //
    // Clean up since we don't really need the ppropInst after this.
    //
    if (ppropInst)
    {
        delete ppropInst;
        ppropInst = NULL;
    }

    //
    // If that test failed, we may be admining a downlevel IIS4 machine.
    // Unfortunately  we can't tell by examining the capability bits, 
    // so look to see if the old certs are there.
    // 
    if (!fCertInstalled)
    {
        CString         strKey;
        CMetaEnumerator me(lpszServerName, g_cszSvc);
        HRESULT err = me.Next(strKey, g_cszSSLKeys);
        fCertInstalled = SUCCEEDED(err);
    }

    return fCertInstalled;
}



void
RunKeyManager(
    IN LPCTSTR lpszServer OPTIONAL
    )
/*++

Routine Description:

    Helper function to run the key manager application.

Arguments:

    None

Return Value:

    None

Notes:

    Key manager is run synchronously.

--*/
{
    //
    // Want to start key manager.  I'm assuming
    // here that the keyring app will be in the
    // same directory as w3scfg.dll (safe assumption
    // for the near future at least)
    //
    // CODEWORK: Move this to a registry key, so
    // it can be changed later.
    //
    CString strPath;
    CError err;

    if (::GetModuleFileName(hInstance, strPath.GetBuffer(MAX_PATH), MAX_PATH))
    {
        int nLen = strPath.ReverseFind(_T('\\'));

        if (nLen == -1)
        {
            TRACEEOLID("Bad module path");
            err = ERROR_PATH_NOT_FOUND;
        }
        else
        {
            strPath.ReleaseBuffer(nLen);
            strPath += _T("\\keyring.exe");

            TRACEEOLID("Spawning " << strPath);

            CString strParm;

            if (lpszServer != NULL)
            {
                strParm.Format(_T("/remote:%s"), lpszServer);
            }

            TRACEEOLID(strParm);
            TRACEEOLID(strPath);

            if (_tspawnl(_P_WAIT, strPath, strPath, strParm, NULL) != 0)
            {
                err.GetLastWinError();
            }
        }
    }
    else
    {
        err.GetLastWinError();
    }

    err.MessageBoxOnFailure();
}



void
InitializeDLL()
/*++

Routine Description:

    Perform additional initialisation as necessary

Arguments:

    None

Return Value:

    None

*/
{
#ifdef _DEBUG

    afxMemDF |= checkAlwaysMemDF;

#endif // _DEBUG

#ifdef UNICODE

    TRACEEOLID("Loading UNICODE w3scfg.dll");

#else

    TRACEEOLID("Loading ANSI w3scfg.dll");

#endif UNICODE

    ::AfxEnableControlContainer();

#ifndef _COMSTATIC
    //
    // Initialize IISUI extension DLL
    //
    InitIISUIDll();

#endif // _COMSTATIC

}



CConfigDll NEAR theApp;


//
// Message Map
//
BEGIN_MESSAGE_MAP(CConfigDll, CWinApp)
    //{{AFX_MSG_MAP(CConfigDll)
    //}}AFX_MSG_MAP
    //
    // Global Help Commands
    //
    ON_COMMAND(ID_HELP, CWinApp::OnHelp)
    ON_COMMAND(ID_CONTEXT_HELP, CWinApp::OnContextHelp)
END_MESSAGE_MAP()



BOOL
CConfigDll::InitInstance()
/*++

Routine Description:

    Initialize the instance

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    BOOL bInit = CWinApp::InitInstance();

    hInstance = ::AfxGetInstanceHandle();
    ASSERT(hInstance);

    InitializeDLL();

    try
    {
        //
        // Get the help path
        //
        ASSERT(m_pszHelpFilePath != NULL);
        m_lpOldHelpPath = m_pszHelpFilePath;
        CString strFile(_tcsrchr(m_pszHelpFilePath, _T('\\')));
        CRMCRegKey rk(REG_KEY, SZ_PARAMETERS, KEY_READ);
        rk.QueryValue(SZ_HELPPATH, m_strHelpPath, EXPANSION_ON);
        m_strHelpPath += strFile;
    }
    catch(CException * e)
    {
        e->ReportError();
        e->Delete();
    }

    if (!m_strHelpPath.IsEmpty())
    {
        m_pszHelpFilePath = m_strHelpPath;
    }

    return bInit;
}



int
CConfigDll::ExitInstance()
/*++

Routine Description:

    Exit instance handler

Arguments:

    None

Return Value:

    0 for success, or an error return code

--*/
{
    m_pszHelpFilePath = m_lpOldHelpPath;

    return CWinApp::ExitInstance();
}



CConfigDll::CConfigDll(
    IN LPCTSTR pszAppName OPTIONAL
    )
/*++

Routine Description:

    DLL CWinApp constructor

Arguments:

    None

Return Value:

    N/A

--*/
    : CWinApp(pszAppName)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\w3accts.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        w3accts.h

   Abstract:

        WWW Accounts Property Page

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/


#ifndef __W3ACCTS_H__
#define __W3ACCTS_H__



class CW3AccountsPage : public CInetPropertyPage
/*++

Class Description:

    WWW Accounts property page

Public Interface:

    CW3AccountsPage     : Constructor
    ~CW3AccountsPage    : Destructor

--*/
{
    DECLARE_DYNCREATE(CW3AccountsPage)

//
// Construction
//
public:
    CW3AccountsPage(CInetPropertySheet * pSheet = NULL);
    ~CW3AccountsPage();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CW3AccountsPage)
    enum { IDD = IDD_ACCOUNTS };
    CButton m_button_RemoveAdministrator;
    CButton m_button_Add;
    //}}AFX_DATA

    CAccessEntryListBox m_list_Administrators;

//
// Overrides
//
protected:
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CW3AccountsPage)
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CW3AccountsPage)
    virtual BOOL OnInitDialog();
    afx_msg void OnButtonAdd();
    afx_msg void OnButtonDelete();
    afx_msg void OnSelchangeListAdministrators();
    //}}AFX_MSG

    afx_msg void OnItemChanged();

    DECLARE_MESSAGE_MAP()

    BOOL SetAdminRemoveState();

private:
    CRMCListBoxResources m_ListBoxRes;
    CObListPlus          m_oblSID;
};

#endif // __W3ACCTS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\nt\stdafx.h ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        stdafx.h

   Abstract:

        Precompiled header file

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers
#include <stdio.h>
#include <afxwin.h>
#include <afxdlgs.h>
#include <afxext.h>         // MFC extensions
#include <afxcoll.h>        // collection class
#include <afxdisp.h>        // CG: added by OLE Control Containment component
#include <afxtempl.h>
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>
#endif // _AFX_NO_AFXCMN_SUPPORT
#include <tchar.h>

#include <aclapi.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\w3servic.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        w3servic.h

   Abstract:

        WWW Service Property Page

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//{{AFX_INCLUDES()
#include "logui.h"
//}}AFX_INCLUDES



class CW3ServicePage : public CInetPropertyPage
/*++

Class Description:

    WWW Service Page 

Public Interface:

    CW3ServicePage      : Constructor
    ~CW3ServicePage     : Destructor

--*/
{
    DECLARE_DYNCREATE(CW3ServicePage)

//
// Construction
//
public:
    CW3ServicePage(IN CInetPropertySheet * pSheet = NULL);
    ~CW3ServicePage();

//
// Dialog Data
//
protected:
    //
    //  Radio button IDs for unlimited radio control
    //
    enum
    {
        RADIO_UNLIMITED,
        RADIO_LIMITED,
    };

    //{{AFX_DATA(CW3ServicePage)
    enum { IDD = IDD_SERVICE };
    int         m_nUnlimited;
    int         m_nIpAddressSel;
    UINT        m_nTCPPort;
    BOOL        m_fUseKeepAlives;
    BOOL        m_fEnableLogging;
    CString     m_strComment;
    CString     m_strDomainName;
    CEdit       m_edit_SSLPort;
    CEdit       m_edit_TCPPort;
    CEdit       m_edit_MaxConnections;
    CButton     m_radio_Unlimited;
    CButton     m_button_LogProperties;
    CStatic     m_static_SSLPort;
    CStatic     m_static_Connections;
    CStatic     m_static_LogPrompt;
    CComboBox   m_combo_LogFormats;
    CComboBox   m_combo_IpAddresses;
    //}}AFX_DATA

    int         m_iSSL;
    BOOL        m_fUnlimitedConnections;
    UINT        m_nOldTCPPort;
    UINT        m_nSSLPort;
    CILong      m_nConnectionTimeOut;
    CILong      m_nMaxConnections;
    CILong      m_nVisibleMaxConnections;
    CLogUI      m_ocx_LogProperties;
    CIPAddress  m_iaIpAddress;
    DWORD       m_dwLogType;

//
// Overrides
//
protected:
    virtual HRESULT FetchLoadedValues();
    virtual HRESULT SaveInfo();

    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CW3ServicePage)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    // Generated message map functions
    //{{AFX_MSG(CW3ServicePage)
    virtual BOOL OnInitDialog();
    afx_msg void OnRadioLimited();
    afx_msg void OnRadioUnlimited();
    afx_msg void OnCheckEnableLogging();
    afx_msg void OnButtonAdvanced();
    afx_msg void OnButtonProperties();
    afx_msg void OnDestroy();
    //}}AFX_MSG

    afx_msg void OnItemChanged();
    DECLARE_MESSAGE_MAP()

    void SetControlStates();
    void SetLogState();
    void GetTopBinding();
    void ShowTopBinding();
    BOOL StoreTopBinding();
    LPCTSTR QueryMetaPath();

//
// Access to the sheet data
//
protected:
    BOOL          m_fCertInstalled;
    CObListPlus   m_oblIpAddresses;
    CStringListEx m_strlBindings;
    CStringListEx m_strlSecureBindings;
};



//
// Inline Expansion
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

inline LPCTSTR CW3ServicePage::QueryMetaPath()
{
    return ((CW3Sheet *)GetSheet())->GetInstanceProperties().QueryMetaRoot();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\wizard.h ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        wizard.h

   Abstract:

        WWW Wizards pages definitions

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/



#ifndef __WWW_WIZ_H__
#define __WWW_WIZ_H__



class CIISWebWizSettings : public CObjectPlus
/*++

Class Description:

    Web Wizard settings intended to pass along from page
    to page

--*/
{
//
// Constructor/Destructor
//
public:
    CIISWebWizSettings(
        IN HANDLE  hServer,
        IN LPCTSTR lpszService,
        IN DWORD   dwInstance   = MASTER_INSTANCE,
        IN LPCTSTR lpszParent   = NULL
        );

//
// Public Properties
//
public:
    BOOL    m_fLocal;
    BOOL    m_fUNC;
    BOOL    m_fRead;
    BOOL    m_fWrite;
    BOOL    m_fAllowAnonymous;
    BOOL    m_fDirBrowsing;
    BOOL    m_fScript;
    BOOL    m_fExecute;
    DWORD   m_dwInstance;
    CString m_strService;
    CString m_strParent;
    CString m_strServerName;
    CString m_strDescription;
    CString m_strBinding;
    CString m_strSecureBinding;
    CString m_strAlias;
    CString m_strPath;
    CString m_strUserName;
    CString m_strPassword;
    HRESULT m_hrResult;
    CMetaKey * m_pKey;
};



//
// New Virtual Server Wizard Description Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



class CVDWPDescription : public CIISWizardPage
{
    DECLARE_DYNCREATE(CVDWPDescription)

//
// Construction
//
public:
    CVDWPDescription(CIISWebWizSettings * pwsSettings = NULL);
    ~CVDWPDescription();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CVDWPDescription)
    enum { IDD = IDD_NEW_INST_DESCRIPTION };
    CEdit   m_edit_Description;
    //}}AFX_DATA

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CVDWPDescription)
    public:
    virtual BOOL OnSetActive();
    virtual LRESULT OnWizardNext();
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CVDWPDescription)
    afx_msg void OnChangeEditDescription();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void SetControlStates();

private:
    CIISWebWizSettings * m_pwsSettings;
};


//
// New Virtual Server Wizard Bindings Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

class CVDWPBindings : public CIISWizardPage
{
    DECLARE_DYNCREATE(CVDWPBindings)

//
// Construction
//
public:
    CVDWPBindings(
        IN CIISWebWizSettings * pwsSettings = NULL,
        IN DWORD dwInstance = MASTER_INSTANCE
        );

    ~CVDWPBindings();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CVDWPBindings)
    enum { IDD = IDD_NEW_INST_BINDINGS };
    int         m_nIpAddressSel;
    UINT        m_nTCPPort;
    UINT        m_nSSLPort;
    CString     m_strDomainName;
    CComboBox   m_combo_IpAddresses;
    //}}AFX_DATA

    BOOL        m_fCertInstalled;
    CIPAddress  m_iaIpAddress;
    CObListPlus m_oblIpAddresses;

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CVDWPBindings)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CVDWPBindings)
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void SetControlStates();

private:
    DWORD m_dwInstance;
    CIISWebWizSettings * m_pwsSettings;
};



//
// New Virtual Directory Wizard Alias Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

class CVDWPAlias : public CIISWizardPage
{
    DECLARE_DYNCREATE(CVDWPAlias)

//
// Construction
//
public:
    CVDWPAlias(CIISWebWizSettings * pwsSettings = NULL);
    ~CVDWPAlias();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CVDWPAlias)
    enum { IDD = IDD_NEW_DIR_ALIAS };
    CEdit   m_edit_Alias;
    //}}AFX_DATA

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CVDWPAlias)
    public:
    virtual BOOL OnSetActive();
    virtual LRESULT OnWizardNext();
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CVDWPAlias)
    afx_msg void OnChangeEditAlias();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void SetControlStates();

private:
    CIISWebWizSettings * m_pwsSettings;
};



//
// Wizard Path Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

class CVDWPPath : public CIISWizardPage
{
    DECLARE_DYNCREATE(CVDWPPath)

//
// Construction
//
public:
    CVDWPPath(
        IN CIISWebWizSettings * pwsSettings = NULL,
        IN BOOL bVDir = TRUE
        );

    ~CVDWPPath();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CVDWPPath)
    enum { IDD = -1 };
    CButton m_button_Browse;
    CEdit   m_edit_Path;
    //}}AFX_DATA


//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CVDWPPath)
    public:
    virtual BOOL OnSetActive();
    virtual LRESULT OnWizardNext();
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CVDWPPath)
    afx_msg void OnChangeEditPath();
    afx_msg void OnButtonBrowse();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void SetControlStates();

private:
    CIISWebWizSettings * m_pwsSettings;
};



//
// Wizard User/Password Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



class CVDWPUserName : public CIISWizardPage
{
    DECLARE_DYNCREATE(CVDWPUserName)

//
// Construction
//
public:
    CVDWPUserName(
        IN CIISWebWizSettings * pwsSettings = NULL,
        IN BOOL bVDir = TRUE
        );

    ~CVDWPUserName();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CVDWPUserName)
    enum { IDD = IDD_NEW_USER_PASSWORD };
    CEdit   m_edit_Password;
    CEdit   m_edit_UserName;
    //}}AFX_DATA

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CVDWPUserName)
    public:
    virtual BOOL OnSetActive();
    virtual LRESULT OnWizardNext();
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CVDWPUserName)
    afx_msg void OnButtonBrowseUsers();
    afx_msg void OnChangeEditUsername();
    afx_msg void OnButtonCheckPassword();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void SetControlStates();

private:
    CIISWebWizSettings * m_pwsSettings;
};



//
// Wizard Permissions Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

class CVDWPPermissions : public CIISWizardPage
{
    DECLARE_DYNCREATE(CVDWPPermissions)

//
// Construction
//
public:
    CVDWPPermissions(
        IN CIISWebWizSettings * pwsSettings = NULL,
        IN BOOL bVDir           = TRUE
        );

    ~CVDWPPermissions();

//
// Dialog Data
//
protected:
    //{{AFX_DATA(CVDWPPermissions)
    enum { IDD = IDD_NEW_PERMS };
    //}}AFX_DATA

//
// Overrides
//
protected:
    //{{AFX_VIRTUAL(CVDWPPermissions)
    public:
    virtual BOOL OnSetActive();
    virtual LRESULT OnWizardNext();
    protected:
    virtual void DoDataExchange(CDataExchange * pDX);
    //}}AFX_VIRTUAL

//
// Implementation
//
protected:
    //{{AFX_MSG(CVDWPPermissions)
    //}}AFX_MSG

    DECLARE_MESSAGE_MAP()

    void SetControlStates();

private:
    BOOL                 m_bVDir;
    CIISWebWizSettings * m_pwsSettings;
};



#endif // __WWW_WIZ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\w3servic.cpp ===
/*++

   Copyright    (c)    1994-1998    Microsoft Corporation

   Module  Name :

        w3servic.cpp

   Abstract:

        WWW Service Property Page

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "w3scfg.h"
#include "mmmdlg.h"
#include "w3servic.h"



#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif



//
// Values for PWS
//
#define LIMITED_CONNECTIONS_MIN    (10)
#define LIMITED_CONNECTIONS_MAX    (40)



//
// Default SSL port
//
#define DEFAULT_SSL_PORT            (441)



IMPLEMENT_DYNCREATE(CW3ServicePage, CInetPropertyPage)




CW3ServicePage::CW3ServicePage(
    IN CInetPropertySheet * pSheet
    )
/*++

Routine Description:

    Constructor for WWW service page

Arguments:

    CInetPropertySheet * pSheet : Property sheet object

Return Value:

    N/A

--*/
    : CInetPropertyPage(CW3ServicePage::IDD, pSheet),
      m_nSSLPort(DEFAULT_SSL_PORT),
      m_nTCPPort(80),
      m_iSSL(-1),
      m_iaIpAddress(NULL_IP_ADDRESS),
      m_strDomainName()
{
#ifdef _DEBUG

    afxMemDF |= checkAlwaysMemDF;

#endif // _DEBUG

#if 0 // Keep Class Wizard Happy

    //{{AFX_DATA_INIT(CW3ServicePage)
    m_nUnlimited = RADIO_LIMITED;
    m_nIpAddressSel = -1;
    m_nTCPPort = 80;
    m_fEnableLogging = FALSE;
    m_fUseKeepAlives = FALSE;
    m_strComment = _T("");
    m_strDomainName = _T("");
    m_nSSLPort = DEFAULT_SSL_PORT;
    //}}AFX_DATA_INIT

    m_iaIpAddress = (LONG)0L;
    m_nMaxConnections = 50;
    m_nVisibleMaxConnections = 50;
    m_nConnectionTimeOut = 600;
    m_nSSLPort = DEFAULT_SSL_PORT;
    m_fUnlimitedConnections = FALSE;

#endif // 0

}



CW3ServicePage::~CW3ServicePage()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}




void
CW3ServicePage::GetTopBinding()
/*++

Routine Description:

    Get the first binding information in the list

Arguments:

    None

Return Value:

    None

--*/
{
    //
    // Show primary values;
    //
    ASSERT(m_strlBindings.GetCount() > 0
       || IS_MASTER_INSTANCE(QueryInstance()));

    if (m_strlBindings.GetCount() > 0)
    {
        CString & strBinding = m_strlBindings.GetHead();
        CInstanceProps::CrackBinding(
            strBinding,
            m_iaIpAddress,
            m_nTCPPort,
            m_strDomainName
            );

        //
        // Find SSL port that is bound to this IP address
        //
        m_iSSL = CInstanceProps::FindMatchingSecurePort(
            m_strlSecureBindings,
            m_iaIpAddress,
            m_nSSLPort
            );
    }
}



BOOL
CW3ServicePage::StoreTopBinding()
/*++

Routine Description:

    Take values from the dialog, and put them into the top level
    binding string.

Arguments:

    None

Return Value:

    TRUE if the values are correct, FALSE otherwise.

--*/
{
    if (!FetchIpAddressFromCombo(
        m_combo_IpAddresses,
        m_oblIpAddresses,
        m_iaIpAddress
        ))
    {
        //
        // Because UpdateData() is called before this, this should NEVER fail
        //
        ASSERT(FALSE);
        return FALSE;
    }

    CString strBinding;
    ASSERT(m_nTCPPort > 0);

    if (m_nTCPPort == m_nSSLPort)
    {
        //
        // TCP port and SSL port cannot be the same
        //
        ::AfxMessageBox(IDS_TCP_SSL_PART);
        return FALSE;
    }

    CInstanceProps::BuildBinding(
        strBinding,
        m_iaIpAddress,
        m_nTCPPort,
        m_strDomainName
        );

    //
    // Check binding ok
    //
    if (m_strlBindings.GetCount() > 0)
    {
        if (!IsBindingUnique(strBinding, m_strlBindings, 0))
        {
            ::AfxMessageBox(IDS_ERR_BINDING);
            return FALSE;
        }

        m_strlBindings.SetAt(m_strlBindings.GetHeadPosition(), strBinding);
    }
    else
    {
        m_strlBindings.AddTail(strBinding);
    }

    //
    // Now do the same for the SSL binding
    //
    if (m_fCertInstalled)
    {
        if (m_nSSLPort > 0)
        {
            CInstanceProps::BuildSecureBinding(
                strBinding,
                m_iaIpAddress,
                m_nSSLPort
                );

            if (m_strlSecureBindings.GetCount() > 0)
            {
                if (IsBindingUnique(strBinding, m_strlSecureBindings, m_iSSL))
                {
                    //
                    // Find its place
                    //
                    if (m_iSSL != -1)
                    {
                        //
                        // Replace selected entry
                        //
                        m_strlSecureBindings.SetAt(
                            m_strlSecureBindings.FindIndex(m_iSSL),
                            strBinding
                            );
                    }
                    else
                    {
                        //
                        // Add to end of list
                        //
                        ASSERT(!m_strlSecureBindings.IsEmpty());
                        m_strlSecureBindings.AddTail(strBinding);
                        m_iSSL = (int)m_strlSecureBindings.GetCount() - 1;
                    }
                }
                else
                {
                    //
                    // Entry already existed in the list.  This is OK, just
                    // delete the current entry rather than bothering
                    // to change it.
                    //
                    ASSERT(m_iSSL != -1);
                    if (m_iSSL != -1)
                    {
                        m_strlSecureBindings.RemoveAt(
                            m_strlSecureBindings.FindIndex(m_iSSL)
                            );
                        m_iSSL = CInstanceProps::FindMatchingSecurePort(
                            m_strlSecureBindings,
                            m_iaIpAddress,
                            m_nSSLPort
                            );
                        ASSERT(m_iSSL != -1);
                    }
                }
            }
            else
            {
                //
                // List of secure bindings was empty, add new entry
                //
                m_strlSecureBindings.AddTail(strBinding);
                m_iSSL = 0;
            }
        }
        else
        {
            //
            // Delete the secure binding if it did exist
            //
            if (m_iSSL != -1)
            {
                m_strlSecureBindings.RemoveAt(
                    m_strlSecureBindings.FindIndex(m_iSSL)
                    );
                m_iSSL = -1;
            }
        }
    }

    return TRUE;
}



void
CW3ServicePage::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store Control Data

Arguments:

    CDataExchange * pDX : Data exchange object

Return Value:

    None

--*/
{
    CInetPropertyPage::DoDataExchange(pDX);

    if (!pDX->m_bSaveAndValidate)
    {
        m_fEnableLogging = LoggingEnabled(m_dwLogType);
    }

    //{{AFX_DATA_MAP(CW3ServicePage)
    DDX_Control(pDX, IDC_RADIO_UNLIMITED, m_radio_Unlimited);
    DDX_Control(pDX, IDC_BUTTON_PROPERTIES, m_button_LogProperties);
    DDX_Control(pDX, IDC_STATIC_CONNECTIONS, m_static_Connections);
    DDX_Control(pDX, IDC_STATIC_LOG_PROMPT, m_static_LogPrompt);
    DDX_Control(pDX, IDC_EDIT_SSL_PORT, m_edit_SSLPort);
    DDX_Control(pDX, IDC_EDIT_TCP_PORT, m_edit_TCPPort);
    DDX_Control(pDX, IDC_EDIT_MAX_CONNECTIONS, m_edit_MaxConnections);
    DDX_Control(pDX, IDC_COMBO_LOG_FORMATS, m_combo_LogFormats);
    DDX_Control(pDX, IDC_COMBO_IP_ADDRESS, m_combo_IpAddresses);
    DDX_Radio(pDX, IDC_RADIO_UNLIMITED, m_nUnlimited);
    DDX_Check(pDX, IDC_CHECK_USE_KEEPALIVE, m_fUseKeepAlives);
    DDX_Check(pDX, IDC_CHECK_ENABLE_LOGGING, m_fEnableLogging);
    DDX_Text(pDX, IDC_EDIT_COMMENT, m_strComment);
    DDV_MinMaxChars(pDX, m_strComment, 0, MAX_PATH);
    //}}AFX_DATA_MAP

    if (pDX->m_bSaveAndValidate && !FetchIpAddressFromCombo(
        m_combo_IpAddresses,
        m_oblIpAddresses,
        m_iaIpAddress
        ))
    {
        pDX->Fail();
    }

    if (!pDX->m_bSaveAndValidate || !m_fUnlimitedConnections )
    {
        DDX_Text(pDX, IDC_EDIT_MAX_CONNECTIONS, m_nVisibleMaxConnections);
    }

    if (Has10ConnectionLimit())
    {
        //
        // Special validation for unlimited connections.  We use a bogus
        // numeric check for data validation.  Number adjustment happens
        // later.
        //
        if (pDX->m_bSaveAndValidate &&
            (m_nVisibleMaxConnections < 0
                || m_nVisibleMaxConnections > UNLIMITED_CONNECTIONS))
        {
            TCHAR szMin[32];
            TCHAR szMax[32];
            wsprintf(szMin, _T("%ld"), 0);
            wsprintf(szMax, _T("%ld"), 40);
            CString prompt;
            ::AfxFormatString2(prompt, AFX_IDP_PARSE_INT_RANGE, szMin, szMax);
            ::AfxMessageBox(prompt, MB_ICONEXCLAMATION);
            prompt.Empty();
            pDX->Fail();
        }
    }
    else
    {
        DDV_MinMaxLong(pDX, m_nVisibleMaxConnections, 0, UNLIMITED_CONNECTIONS);
    }

    DDX_Text(pDX, IDC_EDIT_CONNECTION_TIMEOUT, m_nConnectionTimeOut);
    DDV_MinMaxLong(pDX, m_nConnectionTimeOut, 0, MAX_TIMEOUT);

    //
    // Port DDXV must be done just prior to storetopbinding,
    // so as to activate the right control in case of
    // failure
    //
    if (m_fCertInstalled && !IS_MASTER_INSTANCE(QueryInstance()))
    {
        DDXV_UINT(pDX, IDC_EDIT_SSL_PORT, m_nSSLPort, 0, 65535);
    }

    DDX_Text(pDX, IDC_EDIT_TCP_PORT, m_nTCPPort);
    if (!IS_MASTER_INSTANCE(QueryInstance()))
    {
        DDV_MinMaxUInt(pDX, m_nTCPPort, 1, 65535);
    }

    if (pDX->m_bSaveAndValidate)
    {
        if (!IS_MASTER_INSTANCE(QueryInstance()))
        {
            if (!StoreTopBinding())
            {
                pDX->Fail();
            }
        }

        EnableLogging(m_dwLogType, m_fEnableLogging);
    }
}



//
// Message Map
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BEGIN_MESSAGE_MAP(CW3ServicePage, CInetPropertyPage)
    //{{AFX_MSG_MAP(CW3ServicePage)
    ON_BN_CLICKED(IDC_RADIO_LIMITED, OnRadioLimited)
    ON_BN_CLICKED(IDC_RADIO_UNLIMITED, OnRadioUnlimited)
    ON_BN_CLICKED(IDC_CHECK_ENABLE_LOGGING, OnCheckEnableLogging)
    ON_BN_CLICKED(IDC_BUTTON_ADVANCED, OnButtonAdvanced)
    ON_BN_CLICKED(IDC_BUTTON_PROPERTIES, OnButtonProperties)
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP

    ON_BN_CLICKED(IDC_CHECK_USE_KEEPALIVE, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_TCP_PORT, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_COMMENT, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_CONNECTION_TIMEOUT, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_MAX_CONNECTIONS, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_IP_ADDRESS, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_SSL_PORT, OnItemChanged)
    ON_EN_CHANGE(IDC_EDIT_DOMAIN_NAME, OnItemChanged)
    ON_CBN_EDITCHANGE(IDC_COMBO_IP_ADDRESS, OnItemChanged)
    ON_CBN_SELCHANGE(IDC_COMBO_IP_ADDRESS, OnItemChanged)
    ON_CBN_SELCHANGE(IDC_COMBO_LOG_FORMATS, OnItemChanged)

END_MESSAGE_MAP()



void
CW3ServicePage::SetControlStates()
/*++

Routine Description:

    Set control states depending on the currently selected items

Arguments:

    None

Return Value:

    None.

--*/
{
    if (m_edit_MaxConnections.m_hWnd)
    {
        m_edit_MaxConnections.EnableWindow(!m_fUnlimitedConnections);
        m_static_Connections.EnableWindow(!m_fUnlimitedConnections);
    }
}



void
CW3ServicePage::SetLogState()
/*++

Routine Description:

    Enable/disable logging controls depending on whether logging
    is enabled or not.

Arguments:

    None

Return Value:

    None

--*/
{
    m_static_LogPrompt.EnableWindow(m_fEnableLogging);
    m_combo_LogFormats.EnableWindow(m_fEnableLogging);
    m_button_LogProperties.EnableWindow(m_fEnableLogging);
}



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL
CW3ServicePage::OnSetActive()
/*++

Routine Description:

    Property page is getting activation notification

Arguments:

    None

Return Value:

    TRUE to activate the page, FALSE otherwise.

--*/
{
    //
    // No certificates, no SSL
    //
    BeginWaitCursor();
    m_fCertInstalled = IsCertInstalledOnServer(GetServerName(), QueryInstance());
    EndWaitCursor();

    GetDlgItem(IDC_STATIC_SSL_PORT)->EnableWindow(
        m_fCertInstalled
     && !IS_MASTER_INSTANCE(QueryInstance())
     && HasAdminAccess()
        );

    GetDlgItem(IDC_EDIT_SSL_PORT)->EnableWindow(
        m_fCertInstalled
     && !IS_MASTER_INSTANCE(QueryInstance())
     && HasAdminAccess()
        );

    return CInetPropertyPage::OnSetActive();
}



BOOL
CW3ServicePage::OnInitDialog()
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CInetPropertyPage::OnInitDialog();

    //
    // Take our direction from a phony button
    //
    CRect rc(0, 0, 0, 0);

    m_ocx_LogProperties.Create(
        _T("LogUI"),
        WS_BORDER,
        rc,
        this,
        IDC_LOGUICTRL
        );

    m_radio_Unlimited.EnableWindow(!Has10ConnectionLimit());

    //
    // Initialize the logging ocx
    //
    m_ocx_LogProperties.SetAdminTarget(GetServerName(), QueryMetaPath());
    m_ocx_LogProperties.SetComboBox(m_combo_LogFormats.m_hWnd);

    //
    // Disable non heritable properties for master instance
    // or operator
    //
    if (IS_MASTER_INSTANCE(QueryInstance()) || !HasAdminAccess())
    {
        GetDlgItem(IDC_STATIC_IP_ADDRESS)->EnableWindow(FALSE);
        GetDlgItem(IDC_COMBO_IP_ADDRESS)->EnableWindow(FALSE);
        GetDlgItem(IDC_STATIC_TCP_PORT)->EnableWindow(FALSE);
        GetDlgItem(IDC_EDIT_TCP_PORT)->EnableWindow(FALSE);
        GetDlgItem(IDC_STATIC_SSL_PORT)->EnableWindow(FALSE);
        GetDlgItem(IDC_EDIT_SSL_PORT)->EnableWindow(FALSE);
        GetDlgItem(IDC_BUTTON_ADVANCED)->EnableWindow(FALSE);
    }

    {
        CWaitCursor wait;

        PopulateComboWithKnownIpAddresses(
            QueryServerName(),
            m_combo_IpAddresses,
            m_iaIpAddress,
            m_oblIpAddresses,
            m_nIpAddressSel
            );
    }

    SetControlStates();
    SetLogState();

    return TRUE;
}



/* virtual */
HRESULT
CW3ServicePage::FetchLoadedValues()
/*++

Routine Description:

    Move configuration data from sheet to dialog controls

Arguments:

    None

Return Value:

    HRESULT

--*/
{
    CError err;
    m_fCertInstalled = IsCertInstalledOnServer(GetServerName(), QueryInstance());

    BEGIN_META_INST_READ(CW3Sheet)
        FETCH_INST_DATA_FROM_SHEET(m_fUseKeepAlives);
        FETCH_INST_DATA_FROM_SHEET(m_nMaxConnections);
        FETCH_INST_DATA_FROM_SHEET(m_nConnectionTimeOut);
        FETCH_INST_DATA_FROM_SHEET(m_strComment);
        FETCH_INST_DATA_FROM_SHEET(m_dwLogType);
        FETCH_INST_DATA_FROM_SHEET(m_strlBindings);
        FETCH_INST_DATA_FROM_SHEET(m_strlSecureBindings);

        GetTopBinding();

        m_fUnlimitedConnections =
            ((ULONG)(LONG)m_nMaxConnections >= UNLIMITED_CONNECTIONS);

        if (Has10ConnectionLimit())
        {
            m_fUnlimitedConnections = FALSE;
            if ((LONG)m_nMaxConnections > LIMITED_CONNECTIONS_MAX)
            {
                m_nMaxConnections = LIMITED_CONNECTIONS_MAX;
            }
        }

        //
        // Set the visible max connections edit field, which
        // may start out with a default value
        //
        m_nVisibleMaxConnections = m_fUnlimitedConnections
            ? INITIAL_MAX_CONNECTIONS
            : m_nMaxConnections;

        //
        // Set radio value
        //
        m_nUnlimited = m_fUnlimitedConnections ? RADIO_UNLIMITED : RADIO_LIMITED;
        m_nOldTCPPort = m_nTCPPort;
    END_META_INST_READ(err)

    return err;
}



/* virtual */
HRESULT
CW3ServicePage::SaveInfo()
/*++

Routine Description:

    Save the information on this property page

Arguments:

    BOOL fUpdateData : If TRUE, control data has not yet been stored.  This
                       is the case when "apply" is pressed.

Return Value:

    Error return code

--*/
{
    ASSERT(IsDirty());

    TRACEEOLID("Saving W3 service page now...");

    CError err;

    m_nMaxConnections = m_fUnlimitedConnections
        ? UNLIMITED_CONNECTIONS
        : m_nVisibleMaxConnections;

    //
    // Check to make sure we're not violating the license
    // agreement
    //
    if (Has10ConnectionLimit())
    {
        if (m_nMaxConnections > LIMITED_CONNECTIONS_MAX)
        {
            ::AfxMessageBox(IDS_CONNECTION_LIMIT);
            m_nMaxConnections = LIMITED_CONNECTIONS_MIN;
        }
        else if (m_nMaxConnections >  LIMITED_CONNECTIONS_MIN
              && m_nMaxConnections <= LIMITED_CONNECTIONS_MAX)
        {
            ::AfxMessageBox(IDS_WRN_CONNECTION_LIMIT);
        }
    }

    m_ocx_LogProperties.ApplyLogSelection();

    BeginWaitCursor();

    BEGIN_META_INST_WRITE(CW3Sheet)
        STORE_INST_DATA_ON_SHEET(m_fUseKeepAlives);
        STORE_INST_DATA_ON_SHEET(m_nMaxConnections);
        STORE_INST_DATA_ON_SHEET(m_nConnectionTimeOut);
        STORE_INST_DATA_ON_SHEET(m_strComment);
        STORE_INST_DATA_ON_SHEET(m_dwLogType);
        STORE_INST_DATA_ON_SHEET(m_strlBindings);
        STORE_INST_DATA_ON_SHEET(m_strlSecureBindings);
    END_META_INST_WRITE(err)

    EndWaitCursor();

    return err;
}



void
CW3ServicePage::OnItemChanged()
/*++

Routine Description

    All EN_CHANGE and BN_CLICKED messages map to this function

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
    SetModified(TRUE);
}



void
CW3ServicePage::OnRadioLimited()
/*++

Routine Description:

    'limited' radio button handler

Arguments:

    None

Return Value:

    None

--*/
{
    m_fUnlimitedConnections = FALSE;
    SetControlStates();
    m_edit_MaxConnections.SetSel(0,-1);
    m_edit_MaxConnections.SetFocus();
    OnItemChanged();
}



void
CW3ServicePage::OnRadioUnlimited()
/*++

Routine Description:

    'unlimited' radio button handler

Arguments:

    None

Return Value:

    None

--*/
{
    m_fUnlimitedConnections = TRUE;
    OnItemChanged();
}



void
CW3ServicePage::ShowTopBinding()
/*++

Routine Description:

    Put information about the top level binding in the dialog controls

Arguments:

    None

Return Value:

    None

--*/
{
    BeginWaitCursor();
    GetTopBinding();
    PopulateComboWithKnownIpAddresses(
        QueryServerName(),
        m_combo_IpAddresses,
        m_iaIpAddress,
        m_oblIpAddresses,
        m_nIpAddressSel
        );
    EndWaitCursor();

    CString strTCPPort, strSSLPort;
    if (m_nTCPPort)
    {
        strTCPPort.Format(_T("%ld"), m_nTCPPort);
    }
    if (m_nSSLPort)
    {
        strSSLPort.Format(_T("%ld"), m_nSSLPort);
    }

    m_edit_TCPPort.SetWindowText(strTCPPort);
    m_edit_SSLPort.SetWindowText(strSSLPort);
}



void
CW3ServicePage::OnButtonAdvanced()
/*++

Routine Description:

    'advanced' button handler -- bring up the bindings dialog

Arguments:

    None

Return Value:

    None

--*/
{
    if (!UpdateData(TRUE))
    {
        return;
    }

    CMMMDlg dlg(
        QueryServerName(),
        QueryInstance(),
        m_strlBindings,
        m_strlSecureBindings,
        this
        );

    if (dlg.DoModal() == IDOK)
    {
        //
        // Get information about the top level binding
        //
        m_strlBindings.RemoveAll();
        m_strlSecureBindings.RemoveAll();
        m_strlBindings.AddTail(&(dlg.GetBindings()));
        m_strlSecureBindings.AddTail(&(dlg.GetSecureBindings()));
        ShowTopBinding();
        OnItemChanged();
    }
}



void
CW3ServicePage::OnCheckEnableLogging()
/*++

Routine Description:

    'enable logging' checkbox handler

Arguments:

    None

Return Value:

    None

--*/
{
    m_fEnableLogging = !m_fEnableLogging;
    SetLogState();
    OnItemChanged();
}



void
CW3ServicePage::OnButtonProperties()
/*++

Routine Description:

    Pass on "log properties" button click to the ocx.

Arguments:

    None

Return Value:

    None

--*/
{
    m_ocx_LogProperties.DoClick();
}



void
CW3ServicePage::OnDestroy()
/*++

Routine Description:

    WM_DESTROY handler.  Clean up internal data

Arguments:

    None

Return Value:

    None

--*/
{
    CInetPropertyPage::OnDestroy();

    if (m_ocx_LogProperties.m_hWnd)
    {
        m_ocx_LogProperties.Terminate();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\wizard.cpp ===
/*++

   Copyright    (c)    1998    Microsoft Corporation

   Module  Name :

        wizard.cpp

   Abstract:

        WWW Wizards pages 

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

//
// Include Files
//
#include "stdafx.h"
#include "w3scfg.h"
#include "dirbrows.h"
#include "wizard.h"



#define DEF_PORT        (80)
#define DEF_SSL_PORT   (443)
#define MAX_ALIAS_NAME (240)        // Ref Bug 241148



CIISWebWizSettings::CIISWebWizSettings(
    IN HANDLE  hServer,
    IN LPCTSTR lpszService,
    IN DWORD   dwInstance,      OPTIONAL
    IN LPCTSTR lpszParent       OPTIONAL
    )
/*++

Routine Description:

    Web Wizard Constructor

Arguments:

    HANDLE  hServer      : Server handle
    LPCTSTR lpszService  : Service name
    DWORD   dwInstance   : Instance number
    LPCTSTR lpszParent   : Parent path

Return Value:

    N/A

--*/
    : m_hrResult(S_OK),
      m_pKey(NULL),
      m_fLocal(FALSE),
      m_fUNC(FALSE),
      m_fRead(FALSE),
      m_fWrite(FALSE),
      m_fAllowAnonymous(TRUE),
      m_fDirBrowsing(FALSE),
      m_fScript(FALSE),
      m_fExecute(FALSE),
      m_strServerName(),
      m_strService(),
      m_strParent(),
      m_dwInstance(dwInstance)
{
    m_pKey = GetMetaKeyFromHandle(hServer);
    LPCTSTR lpszServer = GetServerNameFromHandle(hServer);
    ASSERT(lpszServer != NULL);

    m_strServerName = lpszServer;
    m_fLocal = IsServerLocal(m_strServerName);

    if (lpszService)
    {
        m_strService = lpszService;
    }

    if (lpszParent)
    {
        m_strParent = lpszParent;
    }
}




//
// New Virtual Server Wizard Description Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



IMPLEMENT_DYNCREATE(CVDWPDescription, CIISWizardPage)



CVDWPDescription::CVDWPDescription(
    IN OUT CIISWebWizSettings * pwsSettings
    ) 
/*++

Routine Description:

    Constructor

Arguments:

    CString & strServerName     : Server name

Return Value:

    None

--*/
    : CIISWizardPage(
        CVDWPDescription::IDD,  // Template
        IDS_NEW_SITE_WIZARD,    // Caption
        HEADER_PAGE
        ),
    m_pwsSettings(pwsSettings)
{

#if 0 // Keep Class Wizard Happy

    //{{AFX_DATA_INIT(CVDWPDescription)
    m_strDescription = _T("");
    //}}AFX_DATA_INIT

#endif // 0

}



CVDWPDescription::~CVDWPDescription()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



void 
CVDWPDescription::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CIISWizardPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CVDWPDescription)
    DDX_Control(pDX, IDC_EDIT_DESCRIPTION, m_edit_Description);
    //}}AFX_DATA_MAP
}



void
CVDWPDescription::SetControlStates()
/*++

Routine Description:

    Set the state of the control data

Arguments:

    None

Return Value:

    None

--*/
{
    DWORD dwFlags = PSWIZB_BACK;

    if (m_edit_Description.GetWindowTextLength() > 0)
    {
        dwFlags |= PSWIZB_NEXT;
    }
    
    SetWizardButtons(dwFlags); 
}



LRESULT
CVDWPDescription::OnWizardNext() 
/*++

Routine Description:

    'next' handler.  This is where validation is done,
    because DoDataExchange() gets called every time 
    the dialog is exited,  and this is not valid for
    wizards

Arguments:

    None

Return Value:

    0 to proceed, -1 to fail

--*/
{
    if (!ValidateString(
        m_edit_Description, 
        m_pwsSettings->m_strDescription, 
        1, 
        MAX_PATH
        ))
    {
        return -1;
    }

    return CIISWizardPage::OnWizardNext();
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CVDWPDescription, CIISWizardPage)
    //{{AFX_MSG_MAP(CVDWPDescription)
    ON_EN_CHANGE(IDC_EDIT_DESCRIPTION, OnChangeEditDescription)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

BOOL 
CVDWPDescription::OnSetActive() 
/*++

Routine Description:

    Activation handler

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    SetControlStates();
    
    return CIISWizardPage::OnSetActive();
}



void 
CVDWPDescription::OnChangeEditDescription() 
/*++

Routine Description:

    'edit change' handler

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
}



//
// New Virtual Server Wizard Bindings Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



IMPLEMENT_DYNCREATE(CVDWPBindings, CIISWizardPage)



CVDWPBindings::CVDWPBindings(
    IN OUT CIISWebWizSettings * pwsSettings,
    IN DWORD   dwInstance
    ) 
/*++

Routine Description:

    Constructor

Arguments:

    CString & strServerName     : Server name

Return Value:

    None

--*/
    : CIISWizardPage(
        CVDWPBindings::IDD,     // Template
        IDS_NEW_SITE_WIZARD,    // Caption
        HEADER_PAGE             // Header
        ),
      m_pwsSettings(pwsSettings),
      m_fCertInstalled(IsCertInstalledOnServer(
        pwsSettings->m_strServerName, 
        dwInstance)
        ),
      m_iaIpAddress(),
      m_oblIpAddresses(),
      m_dwInstance(dwInstance)
{
    //{{AFX_DATA_INIT(CVDWPBindings)
    m_nIpAddressSel = -1;
    m_nTCPPort = DEF_PORT;
    m_nSSLPort = DEF_SSL_PORT;
    m_strDomainName = _T("");
    //}}AFX_DATA_INIT
}



CVDWPBindings::~CVDWPBindings()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



void 
CVDWPBindings::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CIISWizardPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CVDWPBindings)
    DDX_Text(pDX, IDC_EDIT_TCP_PORT, m_nTCPPort);
    DDV_MinMaxUInt(pDX, m_nTCPPort, 1, 65535);
    DDX_Control(pDX, IDC_COMBO_IP_ADDRESSES, m_combo_IpAddresses);
    DDX_Text(pDX, IDC_EDIT_DOMAIN_NAME, m_strDomainName);
    DDV_MaxChars(pDX, m_strDomainName, MAX_PATH);
    //}}AFX_DATA_MAP

    if (m_fCertInstalled)
    {
        DDX_Text(pDX, IDC_EDIT_SSL_PORT, m_nSSLPort);
        DDV_MinMaxUInt(pDX, m_nSSLPort, 1, 65535);
    }

    //
    // Check for dup port right after DDXV of SSL port -- because focus will
    // be set appropriately.  Don't change!
    //
    if (pDX->m_bSaveAndValidate && m_nTCPPort == m_nSSLPort)
    {
        ::AfxMessageBox(IDS_TCP_SSL_PART);
        pDX->Fail();    
    }

    DDX_CBIndex(pDX, IDC_COMBO_IP_ADDRESSES, m_nIpAddressSel);

    if (pDX->m_bSaveAndValidate)
    {
        if (!FetchIpAddressFromCombo(
            m_combo_IpAddresses,
            m_oblIpAddresses,
            m_iaIpAddress
            ))
        {
            pDX->Fail();
        }

        //
        // Build with empty host header
        //
        CInstanceProps::BuildBinding(
            m_pwsSettings->m_strBinding, 
            m_iaIpAddress, 
            m_nTCPPort, 
            m_strDomainName
            );

        if (m_fCertInstalled)
        {
            CInstanceProps::BuildSecureBinding(
                m_pwsSettings->m_strSecureBinding, 
                m_iaIpAddress, 
                m_nSSLPort
                );
        }
        else
        {
            m_pwsSettings->m_strSecureBinding.Empty();
        }
    }
}




void
CVDWPBindings::SetControlStates()
/*++

Routine Description:

    Set the state of the control data

Arguments:

    None

Return Value:

    None

--*/
{
    SetWizardButtons(PSWIZB_NEXT | PSWIZB_BACK);
    
    m_fCertInstalled = IsCertInstalledOnServer(
        m_pwsSettings->m_strServerName, 
        m_dwInstance
        );

    GetDlgItem(IDC_STATIC_SSL_PORT)->EnableWindow(m_fCertInstalled);
    GetDlgItem(IDC_EDIT_SSL_PORT)->EnableWindow(m_fCertInstalled);
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CVDWPBindings, CIISWizardPage)
    //{{AFX_MSG_MAP(CVDWPBindings)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL 
CVDWPBindings::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CIISWizardPage::OnInitDialog();

    BeginWaitCursor();
    PopulateComboWithKnownIpAddresses(
        m_pwsSettings->m_strServerName,
        m_combo_IpAddresses,
        m_iaIpAddress,
        m_oblIpAddresses,
        m_nIpAddressSel
        );
    EndWaitCursor();
    
    return TRUE;
}



BOOL 
CVDWPBindings::OnSetActive() 
/*++

Routine Description:

    Activation handler

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    SetControlStates();
    
    return CIISWizardPage::OnSetActive();
}



//
// New Virtual Directory Wizard Alias Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



IMPLEMENT_DYNCREATE(CVDWPAlias, CIISWizardPage)



CVDWPAlias::CVDWPAlias(
    IN OUT CIISWebWizSettings * pwsSettings
    ) 
/*++

Routine Description:

    Constructor

Arguments:

    CString & strServerName     : Server name

Return Value:

    None

--*/
    : CIISWizardPage(
        CVDWPAlias::IDD,        // Template
        IDS_NEW_VDIR_WIZARD,    // Caption
        HEADER_PAGE
        ),
      m_pwsSettings(pwsSettings)
{
#if 0 // Keep Class Wizard Happy

    //{{AFX_DATA_INIT(CVDWPAlias)
    //}}AFX_DATA_INIT

#endif // 0
}



CVDWPAlias::~CVDWPAlias()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



void 
CVDWPAlias::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CIISWizardPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CVDWPAlias)
    DDX_Control(pDX, IDC_EDIT_ALIAS, m_edit_Alias);
    //}}AFX_DATA_MAP
}



LRESULT
CVDWPAlias::OnWizardNext() 
/*++

Routine Description:

    prevent the / and \ characters from being in the alias name

Arguments:

    None

Return Value:

    None

--*/
{
    if (!ValidateString(
        m_edit_Alias, 
        m_pwsSettings->m_strAlias, 
        1, 
        MAX_ALIAS_NAME
        ))
    {
        return -1;
    }

    //
    // Find the illegal characters. If they exist tell 
    // the user and don't go on.
    //
    if (m_pwsSettings->m_strAlias.FindOneOf(_T("/\\?*")) >= 0)
    {
        AfxMessageBox(IDS_ILLEGAL_ALIAS_CHARS);
        m_edit_Alias.SetFocus();
        m_edit_Alias.SetSel(0, -1);

        //
        // prevent the wizard page from changing
        //
        return -1;
    }

    //
    // Allow the wizard to continue
    //
    return CIISWizardPage::OnWizardNext();
}



void
CVDWPAlias::SetControlStates()
/*++

Routine Description:

    Set the state of the control data

Arguments:

    None

Return Value:

    None

--*/
{
    DWORD dwFlags = PSWIZB_BACK;

    if (m_edit_Alias.GetWindowTextLength() > 0)
    {
        dwFlags |= PSWIZB_NEXT;
    }
    
    SetWizardButtons(dwFlags); 
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CVDWPAlias, CIISWizardPage)
    //{{AFX_MSG_MAP(CVDWPAlias)
    ON_EN_CHANGE(IDC_EDIT_ALIAS, OnChangeEditAlias)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL 
CVDWPAlias::OnSetActive() 
/*++

Routine Description:

    Activation handler

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    SetControlStates();
    
    return CIISWizardPage::OnSetActive();
}



void 
CVDWPAlias::OnChangeEditAlias() 
/*++

Routine Description:

    'edit change' handler

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
}



//
// New Virtual Directory Wizard Path Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



IMPLEMENT_DYNCREATE(CVDWPPath, CIISWizardPage)



CVDWPPath::CVDWPPath(
    IN OUT CIISWebWizSettings * pwsSettings,
    IN BOOL bVDir
    ) 
/*++

Routine Description:

    Constructor

Arguments:

    CString & strServerName     : Server name
    BOOL bVDir                  : TRUE for a VDIR, FALSE for an instance

Return Value:

    None

--*/
    : CIISWizardPage(
        (bVDir ? IDD_NEW_DIR_PATH : IDD_NEW_INST_HOME),         // Template
        (bVDir ? IDS_NEW_VDIR_WIZARD : IDS_NEW_SITE_WIZARD),    // Caption
        HEADER_PAGE                                             // Header page
        ),
      m_pwsSettings(pwsSettings)
{
#if 0 // Keep ClassWizard happy

    //{{AFX_DATA_INIT(CVDWPPath)
    //}}AFX_DATA_INIT

#endif // 0
}



CVDWPPath::~CVDWPPath()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



void 
CVDWPPath::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CIISWizardPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CVDWPPath)
    DDX_Control(pDX, IDC_BUTTON_BROWSE, m_button_Browse);
    DDX_Control(pDX, IDC_EDIT_PATH, m_edit_Path);
    DDX_Check(pDX, IDC_CHECK_ALLOW_ANONYMOUS, m_pwsSettings->m_fAllowAnonymous);
    //}}AFX_DATA_MAP

    DDX_Text(pDX, IDC_EDIT_PATH, m_pwsSettings->m_strPath);
    DDV_MaxChars(pDX, m_pwsSettings->m_strPath, MAX_PATH);
}



void 
CVDWPPath::SetControlStates()
/*++

Routine Description:

    Set the state of the control data

Arguments:

    None

Return Value:

    None

--*/
{
    DWORD dwFlags = PSWIZB_BACK;

    if (m_edit_Path.GetWindowTextLength() > 0)
    {
        dwFlags |= PSWIZB_NEXT;
    }
    
    SetWizardButtons(dwFlags); 
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CVDWPPath, CIISWizardPage)
    //{{AFX_MSG_MAP(CVDWPPath)
    ON_EN_CHANGE(IDC_EDIT_PATH, OnChangeEditPath)
    ON_BN_CLICKED(IDC_BUTTON_BROWSE, OnButtonBrowse)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL 
CVDWPPath::OnSetActive() 
/*++

Routine Description:

    Activation handler

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    SetControlStates();
    
    return CIISWizardPage::OnSetActive();
}



LRESULT 
CVDWPPath::OnWizardNext() 
/*++

Routine Description:

    'next' handler.  This is where validation is done,
    because DoDataExchange() gets called every time 
    the dialog is exited,  and this is not valid for
    wizards

Arguments:

    None

Return Value:

    0 to proceed, -1 to fail

--*/
{
    if (!ValidateString(m_edit_Path, m_pwsSettings->m_strPath, 1, MAX_PATH))
    {
        return -1;
    }

    m_pwsSettings->m_fUNC = IsUNCName(m_pwsSettings->m_strPath);

    if (!m_pwsSettings->m_fUNC)
    {
        if (!IsFullyQualifiedPath(m_pwsSettings->m_strPath)
         && !IsDevicePath(m_pwsSettings->m_strPath)
           )
        {
            m_edit_Path.SetSel(0,-1);
            m_edit_Path.SetFocus();
            ::AfxMessageBox(IDS_ERR_BAD_PATH);

            return -1;
        }

        if (m_pwsSettings->m_fLocal)
        {
            DWORD dwAttr = GetFileAttributes(m_pwsSettings->m_strPath);

            if (dwAttr == 0xffffffff || 
               (dwAttr & FILE_ATTRIBUTE_DIRECTORY) == 0)
            {
                m_edit_Path.SetSel(0,-1);
                m_edit_Path.SetFocus();
                ::AfxMessageBox(IDS_ERR_PATH_NOT_FOUND);

                return -1;
            }
        }
    }

    return CIISWizardPage::OnWizardNext();
}



void 
CVDWPPath::OnChangeEditPath() 
/*++

Routine Description:

    'edit change' handler

Arguments:

    None

Return Value:

    None

--*/
{
    SetControlStates();
}



void 
CVDWPPath::OnButtonBrowse() 
/*++

Routine Description:

    Handle 'browsing' for directory path -- local system only

Arguments:

    None

Return Value:

    None

--*/
{
    ASSERT(m_pwsSettings->m_fLocal);

    CString str;
    m_edit_Path.GetWindowText(str);

    CDirBrowseDlg dlgBrowse(this, str);
    if (dlgBrowse.DoModal() == IDOK)
    {
        m_edit_Path.SetWindowText(dlgBrowse.GetFullPath(
            m_pwsSettings->m_strPath
            ));
        SetControlStates();
    }
}



BOOL 
CVDWPPath::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CIISWizardPage::OnInitDialog();

    m_button_Browse.EnableWindow(m_pwsSettings->m_fLocal);
    
    return TRUE;  
}



//
// Wizard User/Password Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



IMPLEMENT_DYNCREATE(CVDWPUserName, CIISWizardPage)



CVDWPUserName::CVDWPUserName(
    IN OUT CIISWebWizSettings * pwsSettings,    
    IN BOOL bVDir
    ) 
/*++

Routine Description:

    Constructor

Arguments:

    CString & strServerName     : Server name
    BOOL bVDir                  : TRUE if this is for a vdir,
                                  FALSE if this is an instance

Return Value:

    None

--*/
    : CIISWizardPage(
        CVDWPUserName::IDD,                                         // Templ.
        (bVDir ? IDS_NEW_VDIR_WIZARD : IDS_NEW_SITE_WIZARD),        // Caption
        HEADER_PAGE,                                                // Header
        (bVDir ? USE_DEFAULT_CAPTION : IDS_SITE_SECURITY_TITLE),    // Title
        (bVDir ? USE_DEFAULT_CAPTION : IDS_SITE_SECURITY_SUBTITLE)  // Subtitle
        ),
      m_pwsSettings(pwsSettings)
{

#if 0 // Keep Class Wizard Happy

    //{{AFX_DATA_INIT(CVDWPUserName)
    //}}AFX_DATA_INIT

#endif // 0
}



CVDWPUserName::~CVDWPUserName()
/*++

Routine Description:

    Destructor

Arguments:

    N/A

Return Value:

    N/A

--*/
{
}



void
CVDWPUserName::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CIISWizardPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CVDWPUserName)
    DDX_Control(pDX, IDC_EDIT_USERNAME, m_edit_UserName);
    DDX_Control(pDX, IDC_EDIT_PASSWORD, m_edit_Password);
    //}}AFX_DATA_MAP

    //
    // Private DDX/DDV Routines
    //
    DDX_Text(pDX, IDC_EDIT_USERNAME, m_pwsSettings->m_strUserName);
    DDV_MaxChars(pDX, m_pwsSettings->m_strUserName, UNLEN);

    //
    // Some people have a tendency to add "\\" before
    // the computer name in user accounts.  Fix this here.
    //
    m_pwsSettings->m_strUserName.TrimLeft();
    while (*m_pwsSettings->m_strUserName == '\\')
    {
        m_pwsSettings->m_strUserName = m_pwsSettings->m_strUserName.Mid(2);
    }

    DDX_Password(pDX, IDC_EDIT_PASSWORD, m_pwsSettings->m_strPassword, g_lpszDummyPassword);
    DDV_MaxChars(pDX, m_pwsSettings->m_strPassword, PWLEN);
}



void 
CVDWPUserName::SetControlStates()
/*++

Routine Description:

    Set the state of the control data

Arguments:

    None

Return Value:

    None

--*/
{
    DWORD dwFlags = PSWIZB_BACK;

    if (m_edit_UserName.GetWindowTextLength() > 0)
    {
        dwFlags |= PSWIZB_NEXT;
    }
    
    SetWizardButtons(dwFlags); 
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CVDWPUserName, CIISWizardPage)
    //{{AFX_MSG_MAP(CVDWPUserName)
    ON_BN_CLICKED(IDC_BUTTON_BROWSE_USERS, OnButtonBrowseUsers)
    ON_EN_CHANGE(IDC_EDIT_USERNAME, OnChangeEditUsername)
    ON_BN_CLICKED(IDC_BUTTON_CHECK_PASSWORD, OnButtonCheckPassword)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL 
CVDWPUserName::OnSetActive() 
/*++

Routine Description:

    Activation handler

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    if (!m_pwsSettings->m_fUNC)
    {
        return 0;
    }

    SetControlStates();
    
    return CIISWizardPage::OnSetActive();
}



BOOL
CVDWPUserName::OnInitDialog() 
/*++

Routine Description:

    WM_INITDIALOG handler.  Initialize the dialog.

Arguments:

    None.

Return Value:

    TRUE if no focus is to be set automatically, FALSE if the focus
    is already set.

--*/
{
    CIISWizardPage::OnInitDialog();

    return TRUE;  
}



LRESULT
CVDWPUserName::OnWizardNext() 
/*++

Routine Description:

    'next' handler.  This is where validation is done,
    because DoDataExchange() gets called every time 
    the dialog is exited,  and this is not valid for
    wizards

Arguments:

    None

Return Value:

    0 to proceed, -1 to fail

--*/
{
    if (!ValidateString(
        m_edit_UserName, 
        m_pwsSettings->m_strUserName, 
        1, 
        UNLEN
        ))
    {
        return -1;
    }
    
    return CIISWizardPage::OnWizardNext();
}



void
CVDWPUserName::OnButtonBrowseUsers() 
/*++

Routine Description:

    'browse' for users handler

Arguments:

    None

Return Value:

    None

--*/
{
    CString str;

    if (GetIUsrAccount(m_pwsSettings->m_strServerName, this, str))
    {
        //
        // If a name was selected, blank
        // out the password
        //
        m_edit_UserName.SetWindowText(str);
        m_edit_Password.SetFocus();
    }
}



void
CVDWPUserName::OnChangeEditUsername() 
/*++

Routine Description:

    'edit change' in user name notification handler

Arguments:

    None

Return Value:

    None

--*/
{
    m_edit_Password.SetWindowText(_T(""));
    SetControlStates();
}



void 
CVDWPUserName::OnButtonCheckPassword() 
/*++

Routine Description:

    'Check Password' has been pressed.  Try to validate
    the password that has been entered

Arguments:

    None

Return Value:

    None

--*/
{
    if (!UpdateData(TRUE))
    {
        return;
    }

    CError err(VerifyUserPassword(
        m_pwsSettings->m_strUserName, 
        m_pwsSettings->m_strPassword
        ));

    if (!err.MessageBoxOnFailure())
    {
        ::AfxMessageBox(IDS_PASSWORD_OK);
    }
}




//
// Wizard Permissions Page
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



IMPLEMENT_DYNCREATE(CVDWPPermissions, CIISWizardPage)



CVDWPPermissions::CVDWPPermissions(
    IN OUT CIISWebWizSettings * pwsSettings,
    IN BOOL bVDir
    ) 
/*++

Routine Description:

    Constructor

Arguments:

    CString & strServerName     : Server name
    BOOL bVDir                  : TRUE if this is a vdir page, 
                                  FALSE for instance

Return Value:

    None

--*/
    : CIISWizardPage(
        CVDWPPermissions::IDD,                                   // Template
        (bVDir ? IDS_NEW_VDIR_WIZARD : IDS_NEW_SITE_WIZARD),     // Caption
        HEADER_PAGE,                                             // Header
        (bVDir ? USE_DEFAULT_CAPTION : IDS_SITE_PERMS_TITLE),    // Title
        (bVDir ? USE_DEFAULT_CAPTION : IDS_SITE_PERMS_SUBTITLE)  // Subtitle
        ),
      m_bVDir(bVDir),
      m_pwsSettings(pwsSettings)
{
    //{{AFX_DATA_INIT(CVDWPPermissions)
    //}}AFX_DATA_INIT

    m_pwsSettings->m_fDirBrowsing = FALSE;
    m_pwsSettings->m_fRead = TRUE;
    m_pwsSettings->m_fScript = TRUE;
    m_pwsSettings->m_fWrite = FALSE;
    m_pwsSettings->m_fExecute = FALSE;
}



CVDWPPermissions::~CVDWPPermissions()
/*++

Routine Description:

    Destructor

Arguments:

    None

Return Value:

    None

--*/
{
}



void 
CVDWPPermissions::DoDataExchange(
    IN CDataExchange * pDX
    )
/*++

Routine Description:

    Initialise/Store control data

Arguments:

    CDataExchange * pDX - DDX/DDV control structure

Return Value:

    None

--*/
{
    CIISWizardPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CVDWPPermissions)
    //}}AFX_DATA_MAP

    DDX_Check(pDX, IDC_CHECK_DIRBROWS, m_pwsSettings->m_fDirBrowsing);
    DDX_Check(pDX, IDC_CHECK_READ, m_pwsSettings->m_fRead);
    DDX_Check(pDX, IDC_CHECK_SCRIPT, m_pwsSettings->m_fScript);
    DDX_Check(pDX, IDC_CHECK_WRITE, m_pwsSettings->m_fWrite);
    DDX_Check(pDX, IDC_CHECK_EXECUTE, m_pwsSettings->m_fExecute);
}



void
CVDWPPermissions::SetControlStates()
/*++

Routine Description:

    Set the state of the control data

Arguments:

    None

Return Value:

    None

--*/
{
    SetWizardButtons(PSWIZB_BACK | PSWIZB_NEXT);
}



//
// Message Map
//
BEGIN_MESSAGE_MAP(CVDWPPermissions, CIISWizardPage)
    //{{AFX_MSG_MAP(CVDWPPermissions)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()



//
// Message Handlers
//
// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



BOOL 
CVDWPPermissions::OnSetActive() 
/*++

Routine Description:

    Activation handler

Arguments:

    None

Return Value:

    TRUE for success, FALSE for failure

--*/
{
    SetControlStates();

    return CIISWizardPage::OnSetActive();
}



LRESULT
CVDWPPermissions::OnWizardNext() 
/*++

Routine Description:

    'next' handler.  Complete the wizard

Arguments:

    None

Return Value:

    0 to proceed, -1 to fail

--*/
{
    if (!UpdateData(TRUE))
    {
        return -1;
    }

    ASSERT(m_pwsSettings != NULL);

    CWaitCursor wait;

    //
    // Build permissions DWORD
    //
    DWORD dwPermissions = 0L;
    DWORD dwAuthFlags = MD_AUTH_NT;
    DWORD dwDirBrowsing =
        MD_DIRBROW_SHOW_DATE |
        MD_DIRBROW_SHOW_TIME |
        MD_DIRBROW_SHOW_SIZE |
        MD_DIRBROW_SHOW_EXTENSION |
        MD_DIRBROW_LONG_DATE |
        MD_DIRBROW_LOADDEFAULT;

	if (m_pwsSettings->m_fWrite && m_pwsSettings->m_fExecute)
	{
		if (IDNO == ::AfxMessageBox(IDS_EXECUTE_AND_WRITE_WARNING, MB_YESNO))
			return -1;
	}
    SET_FLAG_IF(m_pwsSettings->m_fRead, dwPermissions, MD_ACCESS_READ);
    SET_FLAG_IF(m_pwsSettings->m_fWrite, dwPermissions, MD_ACCESS_WRITE);
    SET_FLAG_IF(m_pwsSettings->m_fScript || m_pwsSettings->m_fExecute,
        dwPermissions, MD_ACCESS_SCRIPT);
    SET_FLAG_IF(m_pwsSettings->m_fExecute, dwPermissions, MD_ACCESS_EXECUTE);
    SET_FLAG_IF(m_pwsSettings->m_fDirBrowsing, dwDirBrowsing, MD_DIRBROW_ENABLED);
    SET_FLAG_IF(m_pwsSettings->m_fAllowAnonymous, dwAuthFlags, MD_AUTH_ANONYMOUS);

    if (m_bVDir)
    {
        //
        // First see if by any chance this name already exists
        //
        ISMCHILDINFO ii;
        ii.dwSize = sizeof(ii);

        CError err;

        BEGIN_ASSURE_BINDING_SECTION
            err = ::ISMQueryChildInfo(
                m_pwsSettings->m_pKey,
                WITHOUT_INHERITANCE,
                &ii,
                m_pwsSettings->m_dwInstance,    
                m_pwsSettings->m_strParent,     
                m_pwsSettings->m_strAlias
                );
        END_ASSURE_BINDING_SECTION(err, m_pwsSettings->m_pKey, ERROR_CANCELLED);

        if (err.Succeeded())
        {
            BOOL fNotUnique = TRUE;

            //
            // If the item existed without a VrPath, we'll just blow it
            // away, as a vdir takes presedence over a directory/file.
            //
            if (!*ii.szPath)
            {
                err = ::ISMDeleteChild(
                    m_pwsSettings->m_pKey,
                    m_pwsSettings->m_dwInstance,    
                    m_pwsSettings->m_strParent,     
                    m_pwsSettings->m_strAlias
                    );

                if (err.Succeeded())
                {
                    //
                    // Successfully deleted -- continue as normal.
                    //
                    fNotUnique = FALSE;
                }
            }

            //
            // This one already exists and exists as a virtual
            // directory, so away with it.
            //
            if (fNotUnique)
            {
                ::AfxMessageBox(IDS_ERR_ALIAS_NOT_UNIQUE);
                return IDD_NEW_DIR_ALIAS;
            }
        }

        //
        // Create new vdir
        //
        BEGIN_ASSURE_BINDING_SECTION
            err = CChildNodeProps::Add(
                m_pwsSettings->m_pKey,
                m_pwsSettings->m_strService,    // Service name
                m_pwsSettings->m_dwInstance,    // Instance
                m_pwsSettings->m_strParent,     // Parent path
                m_pwsSettings->m_strAlias,      // Desired alias name
                m_pwsSettings->m_strAlias,      // Name returned here (may differ)
                &dwPermissions,                 // Permissions
                &dwDirBrowsing,                 // dir browsing
                m_pwsSettings->m_strPath,       // Physical path of this directory
                (m_pwsSettings->m_fUNC ? (LPCTSTR)m_pwsSettings->m_strUserName : NULL),
                (m_pwsSettings->m_fUNC ? (LPCTSTR)m_pwsSettings->m_strPassword : NULL),
                TRUE                            // Name must be unique
                );
        END_ASSURE_BINDING_SECTION(err, m_pwsSettings->m_pKey, ERROR_CANCELLED);

        m_pwsSettings->m_hrResult = err;

        //
        // Create an (in-proc) application on the new directory if
        // script or execute was requested.
        //
        if (SUCCEEDED(m_pwsSettings->m_hrResult))
        {
            if (m_pwsSettings->m_fExecute || m_pwsSettings->m_fScript)
            {
                CIISApplication app(
                    m_pwsSettings->m_strServerName, 
                    m_pwsSettings->m_strService, 
                    m_pwsSettings->m_dwInstance, 
                    m_pwsSettings->m_strParent,
                    m_pwsSettings->m_strAlias
                    );
                m_pwsSettings->m_hrResult = app.QueryResult();

                //
                // This would make no sense...
                //
                ASSERT(!app.IsEnabledApplication());
        
                if (SUCCEEDED(m_pwsSettings->m_hrResult))
                {
                    //
                    // Attempt to create a pooled-proc by default;  failing
                    // that if it's not supported, create it in proc
                    //
                    DWORD dwAppProtState = app.SupportsPooledProc()
                        ? CWamInterface::APP_POOLEDPROC
                        : CWamInterface::APP_INPROC;

                    m_pwsSettings->m_hrResult = app.Create(
                        m_pwsSettings->m_strAlias, 
                        dwAppProtState
                        );
                }
            }
        }
    }
    else
    {
        //
        // Create new instance
        //
        CError err;

        BEGIN_ASSURE_BINDING_SECTION
            err = CInstanceProps::Add(
                m_pwsSettings->m_pKey,
                m_pwsSettings->m_strService,    // Service name
                m_pwsSettings->m_strPath,       // Physical path of this directory
                (m_pwsSettings->m_fUNC ? (LPCTSTR)m_pwsSettings->m_strUserName : NULL),
                (m_pwsSettings->m_fUNC ? (LPCTSTR)m_pwsSettings->m_strPassword : NULL),
                m_pwsSettings->m_strDescription,
                m_pwsSettings->m_strBinding,
                m_pwsSettings->m_strSecureBinding,
                &dwPermissions,
                &dwDirBrowsing,                 // dir browsing
                &dwAuthFlags,                   // Auth flags
                &m_pwsSettings->m_dwInstance
                );
        END_ASSURE_BINDING_SECTION(err, m_pwsSettings->m_pKey, ERROR_CANCELLED);

        m_pwsSettings->m_hrResult = err;

        if (SUCCEEDED(m_pwsSettings->m_hrResult))
        {
            //
            // Create an (in-proc) application on the new instance's home root
            //
            CIISApplication app(
                m_pwsSettings->m_strServerName, 
                m_pwsSettings->m_strService, 
                m_pwsSettings->m_dwInstance, 
                g_cszRoot
                );

            m_pwsSettings->m_hrResult = app.QueryResult();

            //
            // This would make no sense...
            //
            ASSERT(!app.IsEnabledApplication());
        
            if (SUCCEEDED(m_pwsSettings->m_hrResult))
            {
                //
                // Create in-proc
                //
                CString strAppName;
                VERIFY(strAppName.LoadString(IDS_DEF_APP));

                //
                // Attempt to create a pooled-proc by default;  failing
                // that if it's not supported, create it in proc
                //
                DWORD dwAppProtState = app.SupportsPooledProc()
                    ? CWamInterface::APP_POOLEDPROC
                    : CWamInterface::APP_INPROC;

                m_pwsSettings->m_hrResult = app.Create(
                    strAppName, 
                    dwAppProtState
                    );
            }
        }
    }
    
    return CIISWizardPage::OnWizardNext();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\common\ssltools\backup.cpp ===
#include "stdafx.h"

#ifndef _CHICAGO_

// this file is always compile UNICODE in the library - so the conversions work out right

//
//Local includes
//
#include "certupgr.h"

#define		BACKUP_ID	'KRBK'

//------------------------------------------------------------------------------
void ReadWriteDWORD( HANDLE hFile, DWORD *pDword, BOOL fRead );
void ReadWriteString( HANDLE hFile, LPTSTR* ppsz, BOOL fRead );
void ReadWriteBlob( HANDLE hFile, PVOID pBlob, DWORD cbBlob, BOOL fRead );

//-------------------------------------------------------------------------
PCCERT_CONTEXT ImportKRBackupToCAPIStore_A(
                        PCHAR pszFileName,          // path of the file
                        PCHAR pszPassword,          // ANSI password
                        PCHAR pszCAPIStore )        // name of the capi store
    {
    PCCERT_CONTEXT  pCert = NULL;

    // prep the wide strings
    PWCHAR  pszwFileName = NULL;
    PWCHAR  pszwCAPIStore = NULL;
    DWORD   lenFile = (strlen(pszFileName)+1) * sizeof(TCHAR);
    DWORD   lenStore = (strlen(pszCAPIStore)+1) * sizeof(TCHAR);
    pszwFileName = (PWCHAR)GlobalAlloc( GPTR, lenFile );
    pszwCAPIStore = (PWCHAR)GlobalAlloc( GPTR, lenStore );
    if ( !pszwFileName || !pszwCAPIStore )
        goto cleanup;

    // convert the strings
    MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, pszFileName, -1, pszwFileName, lenFile );
    MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, pszCAPIStore, -1, pszwCAPIStore, lenStore );

    // do the real call
    pCert = ImportKRBackupToCAPIStore_W( pszwFileName, pszPassword, pszwCAPIStore );
    
cleanup:
    // preserve the last error state
    DWORD   err = GetLastError();

    // clean up the strings
    if ( pszwFileName )
        GlobalFree( pszwFileName );
    if ( pszwCAPIStore )
        GlobalFree( pszwCAPIStore );

    // reset the last error state
    SetLastError( err );

    // return the cert
    return pCert;
    }

//-------------------------------------------------------------------------
// Import old-style keyring backup file
PCCERT_CONTEXT ImportKRBackupToCAPIStore_W(
                            PWCHAR ptszFileName,        // path of the file
                            PCHAR pszPassword,          // ANSI password
                            PWCHAR pszCAPIStore )       // name of the capi store
    {
    PCCERT_CONTEXT  pCertContext = NULL;
	DWORD	        dword;
    LPTSTR          psz = NULL;

    // prep the file name
    HANDLE          hFile = NULL;

    // This code is originally from KeyRing. The fImport controlled whether it was reading
    // or writing the file. In this case, we are always and only reading it. so....
    const BOOL    fImport = TRUE;

    // also, this was a method on a class. The appropriate member variables are now here
    PVOID   pPrivateKey = NULL;
    DWORD   cbPrivateKey;
    PVOID   pCertificate = NULL;
    DWORD   cbCertificate;
    PVOID   pRequest = NULL;
    DWORD   cbRequest = 0;
	CString	szName;

    // open the file
    hFile = CreateFile(
            ptszFileName,               // pointer to name of the file  
            GENERIC_READ,               // access (read-write) mode  
            FILE_SHARE_READ,            // share mode  
            NULL,                       // pointer to security attributes  
            OPEN_EXISTING,              // how to create  
            FILE_ATTRIBUTE_NORMAL,      // file attributes  
            NULL                        // handle to file with attributes to copy  
            );
    if ( hFile == INVALID_HANDLE_VALUE )
        return NULL;

	// do the backup id
	dword = BACKUP_ID;
	ReadWriteDWORD( hFile, &dword, fImport );

	// check the backup id
	if ( dword != BACKUP_ID )
		{
        goto cleanup;
		}

	// start with the name of the key
	ReadWriteString( hFile, &psz, fImport );

    // we aren't using the name for now, so throw it away.....
    if ( psz )
        GlobalFree( psz );
    psz = NULL;

	// now the private key data size
	ReadWriteDWORD( hFile, &cbPrivateKey, fImport );

	// make a private key data pointer if necessary
	if ( fImport && cbPrivateKey )
		{
		pPrivateKey = GlobalAlloc( GPTR, cbPrivateKey );
		if ( !pPrivateKey )
            {
            goto cleanup;
            }
		}
	
	// use the private key pointer
	if ( cbPrivateKey )
		ReadWriteBlob( hFile, pPrivateKey, cbPrivateKey, fImport );


	// now the certificate
	ReadWriteDWORD( hFile, &cbCertificate, fImport );

	// make a data pointer if necessary
	if ( fImport && cbCertificate )
		{
		pCertificate = GlobalAlloc( GPTR, cbCertificate );
		if ( !pCertificate )
            {
            goto cleanup;
            }
		}
	
	// use the public key pointer
	if ( cbCertificate )
		ReadWriteBlob( hFile, pCertificate, cbCertificate, fImport );


	// now the request - if there is one
	ReadWriteDWORD( hFile, &cbRequest, fImport );

	// make a data pointer if necessary
	if ( fImport && cbRequest )
		{
		pRequest = GlobalAlloc( GPTR, cbRequest );
		if ( !pRequest )
            {
            goto cleanup;
            }
		}
	
	// use the request pointer
	if ( cbRequest )
		ReadWriteBlob( hFile, pRequest, cbRequest, fImport );


    // finally, do the CAPI conversion here
    pCertContext = CopyKRCertToCAPIStore(
                        pPrivateKey, cbPrivateKey,
                        pCertificate, cbCertificate,
                        pRequest, cbRequest,
                        pszPassword,
                        pszCAPIStore);

    // clean up
cleanup:
    if ( hFile )
        CloseHandle( hFile );
    if ( pPrivateKey )
        GlobalFree( pPrivateKey );
    if ( pCertificate )
        GlobalFree( pCertificate );
    if ( pRequest )
        GlobalFree( pRequest );

    // return the context
    return pCertContext;
    }




// file utilities
//---------------------------------------------------------------------------
void ReadWriteDWORD( HANDLE hFile, DWORD *pDword, BOOL fRead )
	{
	// read it or write it
    ReadWriteBlob( hFile, pDword, sizeof(DWORD), fRead );
	}

//---------------------------------------------------------------------------
// remember - we are only and always reading - never writing.......
void ReadWriteString( HANDLE hFile, LPTSTR* ppsz, BOOL fRead )
	{
	// get the length of the string
	DWORD	cbLength = 0;
	ReadWriteDWORD(hFile,&cbLength,fRead );

    // allocate the buffer for the new string - it is the responsibility
    // of the caller to ensure that ppsz is not pointing to something that
    // needs to be freed.
    if ( fRead )
        {
        *ppsz = (LPTSTR)GlobalAlloc( GPTR, cbLength+1 );
        ASSERT( *ppsz );
        if ( !*ppsz )
            AfxThrowMemoryException();
        }

	// read or write the string
	ReadWriteBlob(hFile, *ppsz, cbLength+1, fRead);
	}

/* #pragma INTRINSA suppress=all */

//---------------------------------------------------------------------------
void ReadWriteBlob( HANDLE hFile, PVOID pBlob, DWORD cbBlob, BOOL fRead )
	{
	// read it or write it 
    // - always read it here this isn't keyring anymore
    ReadFile(
            hFile,              // handle of file to read
            pBlob,              // address of buffer that receives data
            cbBlob,             // number of bytes to read
            &cbBlob,            // address of number of bytes read
            NULL                // address of structure for data
            ); 
	}





#endif //_CHICAGO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\wrapmb\sources.inc ===
MAJORCOMP=CertMap
MINORCOMP=CertMap

TARGETNAME=wrapmb
TARGETPATH=obj
TARGETTYPE=LIBRARY

UMTYPE=windows
IDL_TYPE=OLE


#DLLDEF=CertMap.def
#DLLENTRY=_DllMainCRTStartup
#DLLENTRY=DllEntryPoint

MSC_WARNING_LEVEL=/W3 /WX

C_DEFINES=      /D_IISVERSION

#MFC_USRDLL=0
#PRECOMPILED_CXX=0

SUBSYSTEM_VERSION=4.00


INCLUDES=..;..\..\..\..\inc;\
    $O



SOURCES=\
    wrapmb.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\wrapmb\wrapmb.h ===
#ifndef _WRAPMB_
#define _WRAPMB_

/*++

Notes:  I made some changes to this library to build both a UNICODE and ANSI version

        RonaldM

--*/

#include "iadmw.h"

//--------------------------------------------------------
// startup & closeing utilities

BOOL     FInitMetabaseWrapper( OLECHAR* pocMachineName );
BOOL     FCloseMetabaseWrapper();

//
// As above, privately maintaining the interface
//
BOOL     FInitMetabaseWrapperEx( OLECHAR* pocMachineName, IMSAdminBase ** ppiab );
BOOL     FCloseMetabaseWrapperEx(IMSAdminBase ** ppiab);


//--------------------------------------------------------
class CWrapMetaBase
    {
    public:
    WORD m_count;
    // construct - destruct
    CWrapMetaBase();
    ~CWrapMetaBase();

    // second stage initialization
    BOOL FInit( PVOID pMBCom = NULL);

    // open, close and save the object and such
    BOOL Open( LPCTSTR pszPath, DWORD dwFlags = METADATA_PERMISSION_READ );
    BOOL Open( METADATA_HANDLE hOpenRoot, LPCTSTR pszPath,
               DWORD dwFlags = METADATA_PERMISSION_READ );

    BOOL Close( void );
    BOOL Save( void );

    // enumerate the objects
    BOOL EnumObjects( LPCTSTR pszPath, LPTSTR Name, DWORD cbNameBuf, DWORD Index );

    // Add and delete objects
    BOOL AddObject( LPCTSTR pszPath );
    BOOL DeleteObject( LPCTSTR pszPath );

    // rename an object
    BOOL RenameObject( LPCTSTR pszPathOld, LPCTSTR pszNewName );

    // access the metahandle
    METADATA_HANDLE QueryHandle();

    // setting values
    BOOL SetDword( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType, DWORD dwValue, DWORD dwFlags = METADATA_INHERIT );
    BOOL SetString( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType, LPCTSTR dwValue, DWORD dwFlags = METADATA_INHERIT );
    BOOL SetData( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType, DWORD dwDataType,
                            PVOID pData, DWORD cbData, DWORD dwFlags = METADATA_INHERIT );

    // getting values
    BOOL GetDword( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType, DWORD* dwValue, DWORD dwFlags = METADATA_INHERIT );
    BOOL GetString( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType, LPTSTR pszValue, DWORD cchValue,
                            DWORD dwFlags = METADATA_INHERIT );
    BOOL GetData( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType, DWORD dwDataType,
                            PVOID pData, DWORD* pcbData, DWORD dwFlags = METADATA_INHERIT );
    PVOID GetData( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType, DWORD dwDataType,
                            DWORD* pcbData, DWORD dwFlags = METADATA_INHERIT );

    // deleting values
    BOOL DeleteData( LPCTSTR pszPath, DWORD dwPropID, DWORD dwDataType );

    // free memory returned by GetData
    void FreeWrapData( PVOID pData );

    protected:
    // pointer to the real metabase object as defined in mb.hxx
    // by casting it PVOID, those files including this will not have to include mb.hxx, which
    // is the whole point of wrapping it like this.
    // PVOID   m_pvMB;

    // pointer to the dcom interface it should use
    IMSAdminBase *       m_pMetabase;

    // the open metabase handle
    METADATA_HANDLE     m_hMeta;

    // size of the local buffer
    #define BUFFER_SIZE     2000

    // local buffer - allocated once, used many times
    PVOID   m_pBuffer;
    DWORD   m_cbBuffer;


    // path conversion utilities
    WCHAR * PrepPath( LPCTSTR psz );
    void UnprepPath();

    WCHAR * m_pPathBuffer;
    DWORD   m_cchPathBuffer;
    };

#endif //_WRAPMB_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\w3scfg\w95\stdafx.h ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        stdafx.h

   Abstract:

        Precompiled header file

   Author:

        Ronald Meijer (ronaldm)

   Project:

        Internet Services Manager

   Revision History:

--*/

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers
#include <stdio.h>
#include <afxwin.h>
#include <afxdlgs.h>
#include <afxext.h>         // MFC extensions
#include <afxcoll.h>        // collection class
#include <afxdisp.h>        // CG: added by OLE Control Containment component
#include <afxtempl.h>
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>
#endif // _AFX_NO_AFXCMN_SUPPORT
#include <tchar.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\wrapmb\ansi\wrapmb.cpp ===
/*++

Module Name:

    wrapmb.cpp

Abstract:

    wrapper classes for the metabase class. Yes, I am wrapping a wrapper. Why?
        because including mb.hxx totally screws up the headers in my stdafx based
        MFC files. This way they can just include wrapmb.h and not have to worry
        about including all the other stuff. Also, I can set INITGUID here. That
        way I can use precompiled headers in the main project to Greatly increase
        compile times. If that isn't reason enough, then I can also manage the pointer
        to the interface object itself here.

Author:

   Boyd Multerer bmulterer@accessone.com

--*/

#define INITGUID


#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <lm.h>

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

#define _UNICODE
#define UNICODE
#include <objbase.h>
#include <initguid.h>
#include <iadmw.h>
#undef UNICODE
#undef _UNICODE

#include "iiscnfg.h"
#include "wrapmb.h"


#ifdef _NO_TRACING_
DECLARE_DEBUG_PRINTS_OBJECT();
#endif

#define     MB_TIMEOUT          5000


// a macro to automatically cast the pointer to the mb object
//#define _pmb    ((MB*)m_pvMB)


// globals
IMSAdminBase*                g_pMBCom = NULL;


//----------------------------------------------------------------
BOOL    FInitMetabaseWrapperEx( OLECHAR * pocMachineName, IMSAdminBase ** ppiab )
    {
    IClassFactory *  pcsfFactory = NULL;
    COSERVERINFO     csiMachineName;
    COSERVERINFO *   pcsiParam = NULL;

    HRESULT          hresError;

    if( !ppiab )
    {
        return FALSE;
    }

    //fill the structure for CoGetClassObject
    ZeroMemory( &csiMachineName, sizeof(csiMachineName) );
    // csiMachineName.pAuthInfo = NULL;
    // csiMachineName.dwFlags = 0;
    // csiMachineName.pServerInfoExt = NULL;
    csiMachineName.pwszName = pocMachineName;
    pcsiParam = &csiMachineName;

    hresError = CoGetClassObject(
        GETAdminBaseCLSID(TRUE),
        CLSCTX_SERVER,
        pcsiParam,
        IID_IClassFactory,
        (void**) &pcsfFactory
        );

    if (FAILED(hresError))
    {
        return FALSE;
    }

    // create the instance of the interface
    hresError = pcsfFactory->CreateInstance(NULL, IID_IMSAdminBase, (void **)ppiab);
    if (FAILED(hresError))
    {
        *ppiab = NULL;
        return FALSE;
    }

    // release the factory
    pcsfFactory->Release();

    // success
    return TRUE;
    }

//----------------------------------------------------------------
BOOL    FCloseMetabaseWrapperEx(IMSAdminBase ** ppiab)
    {
    if ( ppiab && *ppiab)
        {
        (*ppiab)->Release();
        *ppiab = NULL;
        }

    return TRUE;
    }

//----------------------------------------------------------------
BOOL    FInitMetabaseWrapper( OLECHAR * pocMachineName )
    {
    //release previous interface if needed
    if( g_pMBCom != NULL )
        {
        g_pMBCom->Release();
        g_pMBCom = NULL;
        }

    return FInitMetabaseWrapperEx(pocMachineName, &g_pMBCom);
    }

//----------------------------------------------------------------
BOOL    FCloseMetabaseWrapper()
    {
    return FCloseMetabaseWrapperEx(&g_pMBCom);
    }


//=================================================================== The wrapper class

//----------------------------------------------------------------
CWrapMetaBase::CWrapMetaBase():
    m_pMetabase( NULL ),
    m_hMeta( NULL ),
    m_count(0),
    m_pBuffer( NULL ),
    m_cbBuffer(0),
    m_pPathBuffer( NULL ),
    m_cchPathBuffer( 0 )
    {
    // attempt to allocate the general buffer
    m_pBuffer = GlobalAlloc( GPTR, BUFFER_SIZE );
    if ( m_pBuffer )
        m_cbBuffer = BUFFER_SIZE;
    }

//----------------------------------------------------------------
CWrapMetaBase::~CWrapMetaBase()
    {
    // make sure the metabase handle is closed
    Close();

    // clean up any prepped paths
    UnprepPath();

    // free the buffer
    if ( m_pBuffer )
        GlobalFree( m_pBuffer );
    m_pBuffer = NULL;
    }

//----------------------------------------------------------------
BOOL CWrapMetaBase::FInit( PVOID pMBCom )
    {
    BOOL            fAnswer = FALSE;

    // NULL was passed in, use the global reference - most cases will do this
    if ( pMBCom )
        m_pMetabase = (IMSAdminBase*)pMBCom;
    else
        m_pMetabase = g_pMBCom;

    // if the interface is not there, fail
    if ( !m_pMetabase )
        return FALSE;

    // return success
    return TRUE;
    }


//==========================================================================================
// open, close and save the object and such

//----------------------------------------------------------------
BOOL CWrapMetaBase::Open( LPCSTR pszPath, DWORD dwFlags )
        {
        return Open( METADATA_MASTER_ROOT_HANDLE, pszPath, dwFlags );
        }

//----------------------------------------------------------------
BOOL CWrapMetaBase::Open( METADATA_HANDLE hOpenRoot, LPCSTR pszPath, DWORD dwFlags )
    {
    m_count++;
    HRESULT hRes;

    // if a metabase handle is already open, close it
    if ( m_hMeta )
        Close();

    hRes = m_pMetabase->OpenKey( hOpenRoot, PrepPath(pszPath), dwFlags, MB_TIMEOUT, &m_hMeta );

    if ( SUCCEEDED( hRes ))
        return TRUE;
    SetLastError( HRESULTTOWIN32( hRes ) );
    return FALSE;
    }

//----------------------------------------------------------------
BOOL CWrapMetaBase::Close( void )
    {
    if ( m_hMeta )
        {
        m_count--;
        m_pMetabase->CloseKey( m_hMeta );
        }
    m_hMeta = NULL;
    return TRUE;
    }

//----------------------------------------------------------------
BOOL CWrapMetaBase::Save( void )
    {
    HRESULT hRes = m_pMetabase->SaveData();

    if ( SUCCEEDED( hRes ))
        return TRUE;
    SetLastError( HRESULTTOWIN32( hRes ));
    return FALSE;
    }

// enumerate the objects
//----------------------------------------------------------------
// fortunately, we know that there is a max length to the name of any individual
// key in the metabase of 256 characters
BOOL CWrapMetaBase::EnumObjects( LPCSTR pszPath, LPSTR pName, DWORD cbNameBuf, DWORD Index )
    {
    static WCHAR   wchBuff[258];

    // blank it out
    ZeroMemory( wchBuff, sizeof(wchBuff) );
    ZeroMemory( pName, cbNameBuf );

    // enumerate into the wide character buffer
    HRESULT hRes = m_pMetabase->EnumKeys( m_hMeta, PrepPath(pszPath), wchBuff, Index );

    // Check for success
    if ( SUCCEEDED( hRes ))
        {
        // convert the unicode name down to mbcs and put into pName
        int i = WideCharToMultiByte(
            CP_ACP,            // code page
            0,                  // performance and mapping flags
            wchBuff,            // address of wide-character string
            -1,                 // number of characters in string
            pName,              // address of buffer for new string
            cbNameBuf,          // size of buffer
            NULL,               // address of default for unmappable characters
            NULL                // address of flag set when default char. used
            );
        return TRUE;
        }

    SetLastError( HRESULTTOWIN32( hRes ));
    return FALSE;
    }


//==========================================================================================
// Add and delete objects
//----------------------------------------------------------------
BOOL CWrapMetaBase::AddObject( LPCSTR pszPath )
    {
    HRESULT hRes = m_pMetabase->AddKey( m_hMeta, PrepPath(pszPath) );

    if ( SUCCEEDED( hRes ))
        return TRUE;

    SetLastError( HRESULTTOWIN32( hRes ));
    return FALSE;
    }

//----------------------------------------------------------------
BOOL CWrapMetaBase::DeleteObject( LPCSTR pszPath )
    {
    HRESULT hRes = m_pMetabase->DeleteKey( m_hMeta, PrepPath(pszPath) );

    if ( SUCCEEDED( hRes ))
        return TRUE;

    SetLastError( HRESULTTOWIN32( hRes ));
    return FALSE;
    }


//==========================================================================================
// access the metahandle
//----------------------------------------------------------------
METADATA_HANDLE CWrapMetaBase::QueryHandle()
    {
    return m_hMeta;
    }


//==========================================================================================
// setting values
//----------------------------------------------------------------
BOOL CWrapMetaBase::SetDword( LPCSTR pszPath, DWORD dwPropID, DWORD dwUserType,
                                DWORD dwValue, DWORD dwFlags )
    {
    return SetData( pszPath,
            dwPropID,
            dwUserType,
            DWORD_METADATA,
            (PVOID) &dwValue,
            sizeof( DWORD ),
            dwFlags );
    }

//----------------------------------------------------------------
BOOL CWrapMetaBase::SetString( LPCSTR pszPath, DWORD dwPropID, DWORD dwUserType,
                              LPCSTR pszValue, DWORD dwFlags )
    {
    int len = strlen( pszValue )+1;

    // allocate a wide buffer able to take as many characters as the mbcs buffer
    WCHAR* pw = new WCHAR[len];
    DWORD cbWide = len * sizeof(WCHAR);

    // we have a buffer, so translate our string into it
    MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, pszValue, -1, pw, len );

    BOOL fAnswer = SetData( pszPath,
            dwPropID,
            dwUserType,
            STRING_METADATA,
            pw,
            cbWide,            // string length ignored for inprocess clients
            dwFlags );

    // clean up
    delete pw;

    // return the answer
    return fAnswer;
    }

//==========================================================================================
// getting values
//----------------------------------------------------------------
BOOL CWrapMetaBase::GetDword( LPCSTR pszPath, DWORD dwPropID, DWORD dwUserType,
                             DWORD* pdwValue, DWORD dwFlags )
    {
    DWORD cb = sizeof(DWORD);
    return GetData( pszPath,
            dwPropID,
            dwUserType,
            DWORD_METADATA,
            pdwValue,
            &cb,
            dwFlags );
    }

//----------------------------------------------------------------
BOOL CWrapMetaBase::GetString( LPCSTR pszPath, DWORD dwPropID, DWORD dwUserType,
                              LPSTR pszValue, DWORD cbszValue, DWORD dwFlags )
    {
    BOOL    fAnswer = FALSE;

    // allocate a wide buffer able to take as many characters as the mbcs buffer
    WCHAR* pw = new WCHAR[cbszValue];
    DWORD dw = cbszValue * sizeof(WCHAR);

    if ( GetData( pszPath,
            dwPropID,
            dwUserType,
            STRING_METADATA,
            pw,
            &dw,
            dwFlags ) )
        {
        ZeroMemory( pszValue, cbszValue );
        // we successfully got the string. now convert it down to ansi
        int i = WideCharToMultiByte(
            CP_ACP,             // code page
            0,                  // performance and mapping flags
            pw,                 // address of wide-character string
            -1,                 // number of characters in string
            pszValue,           // address of buffer for new string
            cbszValue,          // size of buffer
            NULL,               // address of default for unmappable characters
            NULL                // address of flag set when default char. used
            );
        fAnswer = TRUE;
        }

    // cleanup
    delete pw;

    // return the answer
    return fAnswer;
    }

//==========================================================================================
// deleting values
//----------------------------------------------------------------
BOOL CWrapMetaBase::DeleteData( LPCSTR pszPath, DWORD dwPropID, DWORD dwDataType )
    {
    // go right ahead and delete it
    HRESULT hRes = m_pMetabase->DeleteData( m_hMeta, PrepPath(pszPath), dwPropID, dwDataType );

    // test for success
    if ( SUCCEEDED( hRes ))
        return TRUE;

    // clean up after a failure
    SetLastError( HRESULTTOWIN32( hRes ));
    return(FALSE);
    }

//----------------------------------------------------------------
BOOL CWrapMetaBase::RenameObject( LPCSTR pszPathOld, LPCSTR pszNewName )
    {
    // first, get the length of the new name being presented
    DWORD    cchsz = strlen( pszNewName );

    // create a wide-character buffer to hold it
    WCHAR* pwNew = new WCHAR[cchsz+1];
    if ( !pwNew ) return FALSE;

    // we have a buffer, so translate our string into it
    MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, pszNewName, -1, pwNew, cchsz+1 );

    // rename the key
    HRESULT hRes = m_pMetabase->RenameKey( m_hMeta, PrepPath(pszPathOld), pwNew );

    // clean up
    delete pwNew;

    // test for success
    if ( SUCCEEDED( hRes ))
        return TRUE;

    // clean up after a failure
    SetLastError( HRESULTTOWIN32( hRes ));
    return FALSE;
    }

//=====================================================================================

//----------------------------------------------------------------
BOOL CWrapMetaBase::SetData( LPCSTR pszPath, DWORD dwPropID, DWORD dwUserType, DWORD dwDataType,
                                        PVOID pData, DWORD cbData, DWORD dwFlags )
    {
    METADATA_RECORD mdRecord;
    HRESULT         hRes;

    // prepare the set data record
    mdRecord.dwMDIdentifier  = dwPropID;
    mdRecord.dwMDAttributes  = dwFlags;
    mdRecord.dwMDUserType    = dwUserType;
    mdRecord.dwMDDataType    = dwDataType;
    mdRecord.dwMDDataLen     = cbData;
    mdRecord.pbMDData        = (PBYTE)pData;

    // set the data
    hRes = m_pMetabase->SetData( m_hMeta, PrepPath(pszPath), &mdRecord );

    // test for success
    if ( SUCCEEDED( hRes ))
        return TRUE;

    // there was an error, clean up
    SetLastError( HRESULTTOWIN32( hRes ) );
    return FALSE;
    }

//----------------------------------------------------------------
BOOL CWrapMetaBase::GetData( LPCSTR pszPath, DWORD dwPropID, DWORD dwUserType, DWORD dwDataType,
                                        PVOID pData, DWORD* pcbData, DWORD dwFlags )
    {
    METADATA_RECORD mdRecord;
    HRESULT         hRes;
    DWORD           dwRequiredLen;

    // prepare the get data record
    mdRecord.dwMDIdentifier  = dwPropID;
    mdRecord.dwMDAttributes  = dwFlags;
    mdRecord.dwMDUserType    = dwUserType;
    mdRecord.dwMDDataType    = dwDataType;
    mdRecord.dwMDDataLen     = *pcbData;
    mdRecord.pbMDData        = (PBYTE)pData;

    // get the data
    hRes = m_pMetabase->GetData( m_hMeta, PrepPath(pszPath), &mdRecord, &dwRequiredLen );

    // test for success
    if ( SUCCEEDED( hRes ))
        {
        *pcbData = mdRecord.dwMDDataLen;
        return TRUE;
        }

    // there was a failure - clean up
    *pcbData = dwRequiredLen;
    SetLastError( HRESULTTOWIN32( hRes ) );
    return FALSE;
    }

//----------------------------------------------------------------
// another form of GetData that automatically allocates the buffer. It should then be
// freed using GlobalFree(p);
PVOID CWrapMetaBase::GetData( LPCSTR pszPath, DWORD dwPropID, DWORD dwUserType, DWORD dwDataType,
                                        DWORD* pcbData, DWORD dwFlags )
    {
    PVOID           pData = m_pBuffer;
    DWORD           cbData = m_cbBuffer;
    DWORD           err = 0;
    BOOL            f;

    // first - attempt to get the data in the buffer that has already been allocated;
    f = GetData( pszPath, dwPropID, dwUserType, dwDataType, pData, &cbData, dwFlags );

    // if the get data function worked, we can pretty much leave
    if ( f )
        {
        // set the data size
        *pcbData = cbData;
        // return the allocated buffer
        return pData;
        }

    // check the error - it could be some sort of memory error
    err = GetLastError();

    // it is ok that the GetData failed, but the reason had better be ERROR_INSUFFICIENT_BUFFER
    // otherwise, it is something we can't handle
    if ( err != ERROR_INSUFFICIENT_BUFFER )
        return NULL;

    // allocate the buffer
    pData = GlobalAlloc( GPTR, cbData );
    if ( !pData )
        return NULL;

    // first, get the size of the data that we are looking for
    f = GetData( pszPath, dwPropID, dwUserType, dwDataType, pData, &cbData, dwFlags );

    // if that getting failed, we need to cleanup
    if ( !f )
        {
        GlobalFree( pData );
        pData = NULL;
        }

    // set the data size
    *pcbData = cbData;

    // return the allocated buffer
    return pData;
    }

//----------------------------------------------------------------
// free memory returned by GetData
void CWrapMetaBase::FreeWrapData( PVOID pData )
    {
    // if it is trying to free the local buffer, do nothing
    if ( pData == m_pBuffer )
        return;

    // ah - but it was not the local buffer - we should dispose of it
    if ( pData )
        GlobalFree( pData );
    }




//----------------------------------------------------------------
WCHAR* CWrapMetaBase::PrepPath( LPCSTR psz )
    {
    // first, get the length of the path being presented
    DWORD    cchsz = strlen( psz );

    // if a buffer already exists, see if it is big enough. If it isn't, kill it.
    if ( m_pPathBuffer && (m_cchPathBuffer < cchsz + 1) )
        UnprepPath();

    // if there is no buffer, create it
    if ( !m_pPathBuffer )
        {
        m_cchPathBuffer = cchsz + 1;
        m_pPathBuffer = new WCHAR[m_cchPathBuffer];
        // if that doesn't work, barf
        if ( !m_pPathBuffer )
            {
            m_cchPathBuffer = 0;
            return NULL;
            }
        }
    else
        // blank it out
        ZeroMemory( m_pPathBuffer, m_cchPathBuffer * 2 );


    // we have a buffer, so translate our string into it
    MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, psz, -1, m_pPathBuffer, m_cchPathBuffer );

    // return with a pointer to the buffer
    return m_pPathBuffer;
    }

//----------------------------------------------------------------
void CWrapMetaBase::UnprepPath()
    {
    // if the buffer is there, kill it
    if ( m_pPathBuffer )
        delete m_pPathBuffer;
    m_pPathBuffer = NULL;
    m_cchPathBuffer = 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\wrapmb\beta2\wrapmb.cpp ===
/*++

Module Name:

    wrapmb.cpp

Abstract:

    wrapper classes for the metabase class. Yes, I am wrapping a wrapper. Why?
        because including mb.hxx totally screws up the headers in my stdafx based
        MFC files. This way they can just include wrapmb.h and not have to worry
        about including all the other stuff. Also, I can set INITGUID here. That
        way I can use precompiled headers in the main project to Greatly increase
        compile times. If that isn't reason enough, then I can also manage the pointer
        to the interface object itself here.

Author:

   Boyd Multerer bmulterer@accessone.com

--*/

//C:\nt\public\sdk\lib\i386

#define INITGUID


#ifdef __cplusplus
extern "C" {
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <winsock2.h>
#include <lm.h>

#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <tchar.h>

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

#include "iiscnfg.h"
#include <ole2.h>
#include <iadm.h>
#include <dbgutil.h>
//#include <buffer.hxx>
#include <string.hxx>
#include "wrap.h"

#include <coguid.h>


#include "wrapmb.h"

DECLARE_DEBUG_PRINTS_OBJECT();


// a macro to automatically cast the pointer to the mb object
#define _pmb    ((MB*)m_pvMB)


// globals
IMSAdminBase*                g_pMBCom = NULL;


//              $(BASEDIR)\private\iis\svcs\lib\*\isdebug.lib \
//              $(BASEDIR)\private\iis\svcs\lib\*\tsstr.lib \
//              $(BASEDIR)\private\iis\svcs\lib\*\tsres.lib
//TARGETLIBS=\
//         ..\..\..\svcs\lib\*\isdebug.lib \
//         ..\..\..\svcs\lib\*\tsstr.lib


//----------------------------------------------------------------
BOOL    FInitMetabaseWrapper( OLECHAR* pocMachineName )
        {
        IClassFactory*  pcsfFactory = NULL;
    COSERVERINFO        csiMachineName;
    COSERVERINFO*       pcsiParam = NULL;

        HRESULT                 hresError;

        //release previous interface if needed
        if( g_pMBCom != NULL )
                {
                g_pMBCom->Release();
                g_pMBCom = NULL;
                }

        //fill the structure for CoGetClassObject
        csiMachineName.pAuthInfo = NULL;
    csiMachineName.dwReserved1 = 0;
    csiMachineName.dwReserved2 = 0;
        csiMachineName.pwszName = pocMachineName;
    pcsiParam = &csiMachineName;

    hresError = CoGetClassObject(GETAdminBaseCLSID(TRUE), CLSCTX_SERVER, pcsiParam,
                            IID_IClassFactory, (void**) &pcsfFactory);
    if (FAILED(hresError))
                return FALSE;

        // create the instance of the interface
        hresError = pcsfFactory->CreateInstance(NULL, IID_IMSAdminBase, (void **)&g_pMBCom);
        if (FAILED(hresError))
                {
                g_pMBCom = FALSE;
                return FALSE;
                }

        // release the factory
        pcsfFactory->Release();

        // success
        return TRUE;
        }

//----------------------------------------------------------------
BOOL    FCloseMetabaseWrapper()
        {
        if ( g_pMBCom )
                {
                g_pMBCom->Release();
                g_pMBCom = NULL;
                }
        return TRUE;
        }


//=================================================================== The wrapper class

//----------------------------------------------------------------
CWrapMetaBase::CWrapMetaBase():
                m_pvMB( NULL ),
                m_count(0),
                                m_pBuffer(NULL),
                                m_cbBuffer(0)
        {
                // attempt to allocate the general buffer
        m_pBuffer = GlobalAlloc( GPTR, BUFFER_SIZE );
        if ( m_pBuffer )
                        m_cbBuffer = BUFFER_SIZE;
        }

//----------------------------------------------------------------
CWrapMetaBase::~CWrapMetaBase()
        {
        if ( m_pvMB )
                delete m_pvMB;
        m_pvMB = NULL;
        }

//----------------------------------------------------------------
BOOL CWrapMetaBase::FInit( PVOID pMBCom )
        {
        BOOL            fAnswer = FALSE;
        IMSAdminBase*        pCom = (IMSAdminBase*)pMBCom;

        // NULL was passed in, use the global reference - most cases will do this
        if ( !pCom )
                pCom = g_pMBCom;

        // if the interface is not there, fail
        if ( !pCom )
                return FALSE;

        // create the MB object
        try {
                m_pvMB = (PVOID) new MB ( pCom );

                // success!
                fAnswer = TRUE;
                }
        catch (...)
                {
                // failure
                fAnswer = FALSE;
                }

        // return the answer
        return fAnswer;
        }


//==========================================================================================
// open, close and save the object and such
//----------------------------------------------------------------
BOOL CWrapMetaBase::Open( const CHAR * pszPath, DWORD dwFlags )
        {
        m_count++;
        return _pmb->Open( pszPath, dwFlags );
        }

//----------------------------------------------------------------
BOOL CWrapMetaBase::Open( METADATA_HANDLE hOpenRoot, const CHAR * pszPath,
                                                                        DWORD dwFlags )
        {
        m_count++;
        return _pmb->Open( hOpenRoot, pszPath, dwFlags );
        }

//----------------------------------------------------------------
BOOL CWrapMetaBase::Close( void )
        {
        m_count--;
        return _pmb->Close();
        }

//----------------------------------------------------------------
BOOL CWrapMetaBase::Save( void )
        {
        return _pmb->Save();
        }


// enumerate the objects
//----------------------------------------------------------------
BOOL CWrapMetaBase::EnumObjects( const CHAR* pszPath, CHAR* Name, DWORD Index )
        {
        return _pmb->EnumObjects( pszPath, Name, Index );
        }


//==========================================================================================
// Add and delete objects
//----------------------------------------------------------------
BOOL CWrapMetaBase::AddObject( const CHAR* pszPath )
        {
        return _pmb->AddObject( pszPath );
        }

//----------------------------------------------------------------
BOOL CWrapMetaBase::DeleteObject( const CHAR* pszPath )
        {
        return _pmb->DeleteObject( pszPath );
        }


//==========================================================================================
// access the metahandle
//----------------------------------------------------------------
METADATA_HANDLE CWrapMetaBase::QueryHandle()
        {
        return _pmb->QueryHandle();
        }


//==========================================================================================
// setting values
//----------------------------------------------------------------
BOOL CWrapMetaBase::SetDword( const CHAR* pszPath, DWORD dwPropID, DWORD dwUserType, DWORD dwValue, DWORD dwFlags )
        {
        return _pmb->SetDword( pszPath, dwPropID, dwUserType, dwValue, dwFlags);
        }

//----------------------------------------------------------------
BOOL CWrapMetaBase::SetString( const CHAR* pszPath, DWORD dwPropID, DWORD dwUserType, LPCSTR pszValue, DWORD dwFlags )
        {
        return _pmb->SetString( pszPath, dwPropID, dwUserType, (PCHAR)pszValue, dwFlags);
        }

//----------------------------------------------------------------
BOOL CWrapMetaBase::SetData( const CHAR* pszPath, DWORD dwPropID, DWORD dwUserType, DWORD dwDataType,
                                                                        PVOID pData, DWORD cbData, DWORD dwFlags )
        {
        return _pmb->SetData( pszPath, dwPropID, dwUserType, dwDataType, pData, cbData, dwFlags);
        }

//==========================================================================================
// getting values
//----------------------------------------------------------------
BOOL CWrapMetaBase::GetDword( const CHAR* pszPath, DWORD dwPropID, DWORD dwUserType, DWORD* dwValue, DWORD dwFlags )
        {
        return _pmb->GetDword( pszPath, dwPropID, dwUserType, dwValue, dwFlags);
        }

//----------------------------------------------------------------
BOOL CWrapMetaBase::GetString( const CHAR* pszPath, DWORD dwPropID, DWORD dwUserType, char* dwValue, DWORD* pcbValue, DWORD dwFlags )
        {
        return _pmb->GetString( pszPath, dwPropID, dwUserType, dwValue, pcbValue, dwFlags);
        }

//----------------------------------------------------------------
BOOL CWrapMetaBase::GetData( const CHAR* pszPath, DWORD dwPropID, DWORD dwUserType, DWORD dwDataType,
                                                                        PVOID pData, DWORD* cbData, DWORD dwFlags )
        {
        return _pmb->GetData( pszPath, dwPropID, dwUserType, dwDataType, pData, cbData, dwFlags);
        }

//----------------------------------------------------------------
// another form of GetData that automatically allocates the buffer. It should then be
// freed using GlobalFree(p);
PVOID CWrapMetaBase::GetData( const CHAR* pszPath, DWORD dwPropID, DWORD dwUserType, DWORD dwDataType,
                                                                        DWORD* pcbData, DWORD dwFlags )
        {
        PVOID           pData = m_pBuffer;
        DWORD           cbData = m_cbBuffer;
        DWORD           err = 0;
        BOOL            f;

        // first - attempt to get the data in the buffer that has already been allocated;
        f = GetData( pszPath, dwPropID, dwUserType, dwDataType, pData, &cbData );

                // if the get data function worked, we can pretty much leave
                if ( f )
                        {
                        // set the data size
                        *pcbData = cbData;
                        // return the allocated buffer
                        return pData;
                        }

        // check the error - it could be some sort of memory error
        err = GetLastError();

        // it is ok that the GetData failed, but the reason had better be ERROR_INSUFFICIENT_BUFFER
        // otherwise, it is something we can't handle
        if ( err != ERROR_INSUFFICIENT_BUFFER )
                return NULL;

        // allocate the buffer
        pData = GlobalAlloc( GPTR, cbData );
        if ( !pData ) return NULL;

        // first, get the size of the data that we are looking for
        f = GetData( pszPath, dwPropID, dwUserType, dwDataType, pData, &cbData );

        // if that getting failed, we need to cleanup
        if ( !f )
                {
                GlobalFree( pData );
                pData = NULL;
                }

        // set the data size
        *pcbData = cbData;

        // return the allocated buffer
        return pData;
        }

//----------------------------------------------------------------
// free memory returned by GetData
void CWrapMetaBase::FreeWrapData( PVOID pData )
        {
        // if it is trying to free the local buffer, do nothing
        if ( pData == m_pBuffer )
                return;

        // ah - but it was not the local buffer - we should dispose of it
        if ( pData )
                GlobalFree( pData );
        }


//==========================================================================================
// deleting values
//----------------------------------------------------------------
BOOL CWrapMetaBase::DeleteData( const CHAR* pszPath, DWORD dwPropID, DWORD dwUserType, DWORD dwDataType )
        {
        return _pmb->DeleteData( pszPath, dwPropID, dwUserType, dwDataType );
        }



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\wrapmb\unicode\wrapmb.cpp ===
/*++

Module Name:

    wrapmb.cpp

Abstract:

    wrapper classes for the metabase class. Yes, I am wrapping a wrapper. Why?
        because including mb.hxx totally screws up the headers in my stdafx based
        MFC files. This way they can just include wrapmb.h and not have to worry
        about including all the other stuff. Also, I can set INITGUID here. That
        way I can use precompiled headers in the main project to Greatly increase
        compile times. If that isn't reason enough, then I can also manage the pointer
        to the interface object itself here.

Author:

   Boyd Multerer boydm

--*/

#include <objbase.h>
#include <initguid.h>
#include <iadmw.h>

#include "iiscnfg.h"
#include "wrapmb.h"

#ifdef _NO_TRACING_
DECLARE_DEBUG_PRINTS_OBJECT();
#endif

#define     MB_TIMEOUT          5000


// a macro to automatically cast the pointer to the mb object
//#define _pmb    ((MB*)m_pvMB)


// globals
IMSAdminBase*                g_pMBCom = NULL;



//----------------------------------------------------------------
BOOL    FInitMetabaseWrapperEx( OLECHAR* pocMachineName, IMSAdminBase ** ppiab )
    {
    IClassFactory *  pcsfFactory = NULL;
    COSERVERINFO     csiMachineName;
    COSERVERINFO *   pcsiParam = NULL;

    HRESULT          hresError;

    if(!ppiab)
    {
        return FALSE;
    }

    //fill the structure for CoGetClassObject
    ZeroMemory( &csiMachineName, sizeof(csiMachineName) );
    // csiMachineName.pAuthInfo = NULL;
    // csiMachineName.dwFlags = 0;
    // csiMachineName.pServerInfoExt = NULL;
    csiMachineName.pwszName = pocMachineName;
    pcsiParam = &csiMachineName;

    hresError = CoGetClassObject(
        GETAdminBaseCLSID(TRUE),
        CLSCTX_SERVER,
        pcsiParam,
        IID_IClassFactory,
        (void**) &pcsfFactory
        );

    if (FAILED(hresError))
    {
        return FALSE;
    }

    // create the instance of the interface
    hresError = pcsfFactory->CreateInstance(NULL, IID_IMSAdminBase, (void **)ppiab);
    if (FAILED(hresError))
    {
        *ppiab = NULL;
        return FALSE;
    }

    // release the factory
    pcsfFactory->Release();

    // success
    return TRUE;
    }

//----------------------------------------------------------------
BOOL    FCloseMetabaseWrapperEx(IMSAdminBase ** ppiab)
    {
    if ( ppiab && *ppiab)
        {
        (*ppiab)->Release();
        *ppiab = NULL;
        }

    return TRUE;
    }

//----------------------------------------------------------------
BOOL    FInitMetabaseWrapper( OLECHAR * pocMachineName )
    {
    //release previous interface if needed
    if( g_pMBCom != NULL )
        {
        g_pMBCom->Release();
        g_pMBCom = NULL;
        }

    return FInitMetabaseWrapperEx(pocMachineName, &g_pMBCom);
    }

//----------------------------------------------------------------
BOOL    FCloseMetabaseWrapper()
    {
    return FCloseMetabaseWrapperEx(&g_pMBCom);
    }


//=================================================================== The wrapper class

//----------------------------------------------------------------
CWrapMetaBase::CWrapMetaBase():
    m_pMetabase( NULL ),
    m_hMeta( NULL ),
    m_count(0),
    m_pBuffer( NULL ),
    m_cbBuffer(0),
    m_pPathBuffer( NULL ),
    m_cchPathBuffer( 0 )
    {
    // attempt to allocate the general buffer
    m_pBuffer = GlobalAlloc( GPTR, BUFFER_SIZE );
    if ( m_pBuffer )
        m_cbBuffer = BUFFER_SIZE;
    }

//----------------------------------------------------------------
CWrapMetaBase::~CWrapMetaBase()
    {
    // make sure the metabase handle is closed
    Close();

    // free the buffer
    if ( m_pBuffer )
        GlobalFree( m_pBuffer );
    m_pBuffer = NULL;
    }

//----------------------------------------------------------------
BOOL CWrapMetaBase::FInit( PVOID pMBCom )
    {
    BOOL            fAnswer = FALSE;

    // NULL was passed in, use the global reference - most cases will do this
    if ( pMBCom )
    {
        m_pMetabase = (IMSAdminBase *)pMBCom;
    }
    else
    {
        m_pMetabase = g_pMBCom;
    }

    // if the interface is not there, fail
    if ( !m_pMetabase )
    {
        return FALSE;
    }

    // return success
    return TRUE;
    }


//==========================================================================================
// open, close and save the object and such

//----------------------------------------------------------------
BOOL CWrapMetaBase::Open( LPCTSTR pszPath, DWORD dwFlags )
    {
    return Open( METADATA_MASTER_ROOT_HANDLE, pszPath, dwFlags );
    }

//----------------------------------------------------------------
BOOL CWrapMetaBase::Open( METADATA_HANDLE hOpenRoot, LPCTSTR pszPath, DWORD dwFlags )
    {
    m_count++;
    HRESULT hRes;

    // if a metabase handle is already open, close it
    if ( m_hMeta )
        Close();

    hRes = m_pMetabase->OpenKey( hOpenRoot, pszPath, dwFlags, MB_TIMEOUT, &m_hMeta );

    if ( SUCCEEDED( hRes ))
        return TRUE;
    SetLastError( HRESULTTOWIN32( hRes ) );
    return FALSE;
    }

//----------------------------------------------------------------
BOOL CWrapMetaBase::Close( void )
    {
    if ( m_hMeta )
        {
        m_count--;
        m_pMetabase->CloseKey( m_hMeta );
        }
    m_hMeta = NULL;
    return TRUE;
    }

//----------------------------------------------------------------
BOOL CWrapMetaBase::Save( void )
        {
        HRESULT hRes = m_pMetabase->SaveData();

        if ( SUCCEEDED( hRes ))
            return TRUE;
        SetLastError( HRESULTTOWIN32( hRes ));
        return FALSE;
        }

// enumerate the objects
//----------------------------------------------------------------
// fortunately, we know that there is a max length to the name of any individual
// key in the metabase of 256 characters
BOOL CWrapMetaBase::EnumObjects(
    LPCTSTR pszPath,
    LPTSTR pName,
    DWORD cbNameBuf,
    DWORD Index
    )
    {
    // enumerate into the wide character buffer
    HRESULT hRes = m_pMetabase->EnumKeys( m_hMeta, pszPath, pName, Index );

    // Check for success
    if ( SUCCEEDED( hRes ))
        {
        return TRUE;
        }

    SetLastError( HRESULTTOWIN32( hRes ));
    return FALSE;
    }


//==========================================================================================
// Add and delete objects
//----------------------------------------------------------------
BOOL CWrapMetaBase::AddObject( LPCTSTR pszPath )
    {
    HRESULT hRes = m_pMetabase->AddKey( m_hMeta, pszPath );

    if ( SUCCEEDED( hRes ))
        return TRUE;
    SetLastError( HRESULTTOWIN32( hRes ));
    return FALSE;
    }

//----------------------------------------------------------------
BOOL CWrapMetaBase::DeleteObject( LPCTSTR pszPath )
    {
    HRESULT hRes = m_pMetabase->DeleteKey( m_hMeta, pszPath );

    if ( SUCCEEDED( hRes ))
        return TRUE;
    SetLastError( HRESULTTOWIN32( hRes ));
    return FALSE;
    }


//==========================================================================================
// access the metahandle
//----------------------------------------------------------------
METADATA_HANDLE CWrapMetaBase::QueryHandle()
        {
        return m_hMeta;
        }


//==========================================================================================
// setting values
//----------------------------------------------------------------
BOOL CWrapMetaBase::SetDword( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType,
                                DWORD dwValue, DWORD dwFlags )
    {
    return SetData( pszPath,
            dwPropID,
            dwUserType,
            DWORD_METADATA,
            (PVOID) &dwValue,
            sizeof( DWORD ),
            dwFlags );
    }

//----------------------------------------------------------------
BOOL CWrapMetaBase::SetString( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType,
                              LPCTSTR pszValue, DWORD dwFlags )
    {
    int len = wcslen( pszValue )+1;
    DWORD cbWide = len * sizeof(WCHAR);

    // set the string into place
    BOOL fAnswer = SetData( pszPath,
            dwPropID,
            dwUserType,
            STRING_METADATA,
            (PVOID)pszValue,
            cbWide,            // string length ignored for inprocess clients
            dwFlags );

    // return the answer
    return fAnswer;
    }

//==========================================================================================
// getting values
//----------------------------------------------------------------
BOOL CWrapMetaBase::GetDword( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType,
                             DWORD* pdwValue, DWORD dwFlags )
    {
    DWORD cb = sizeof(DWORD);
    return GetData( pszPath,
            dwPropID,
            dwUserType,
            DWORD_METADATA,
            pdwValue,
            &cb,
            dwFlags );
    }

//----------------------------------------------------------------
BOOL CWrapMetaBase::GetString( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType,
                              LPTSTR pszValue, DWORD cchValue, DWORD dwFlags )
    {
    BOOL    fAnswer = FALSE;

    // get the data and put it right into the buffer - this is the wide version
    if ( GetData( pszPath,
            dwPropID,
            dwUserType,
            STRING_METADATA,
            pszValue,
            &cchValue,
            dwFlags ) )
        {
        fAnswer = TRUE;
        }

    // return the answer
    return fAnswer;
    }

//==========================================================================================
// deleting values
//----------------------------------------------------------------
BOOL CWrapMetaBase::DeleteData( LPCTSTR pszPath, DWORD dwPropID, DWORD dwDataType )
    {
    // go right ahead and delete it
    HRESULT hRes = m_pMetabase->DeleteData( m_hMeta, pszPath, dwPropID, dwDataType );

    // test for success
    if ( SUCCEEDED( hRes ))
        return TRUE;

    // clean up after a failure
    SetLastError( HRESULTTOWIN32( hRes ));
    return(FALSE);
    }

//----------------------------------------------------------------
BOOL CWrapMetaBase::RenameObject( LPCTSTR pszPathOld, LPCTSTR pszNewName )
    {
    // rename the key
    HRESULT hRes = m_pMetabase->RenameKey( m_hMeta, pszPathOld, pszNewName );

    // test for success
    if ( SUCCEEDED( hRes ))
        return TRUE;

    // clean up after a failure
    SetLastError( HRESULTTOWIN32( hRes ));
    return FALSE;
    }

//=====================================================================================

//----------------------------------------------------------------
BOOL CWrapMetaBase::SetData( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType, DWORD dwDataType,
                                        PVOID pData, DWORD cbData, DWORD dwFlags )
    {
    METADATA_RECORD mdRecord;
    HRESULT         hRes;

    // prepare the set data record
    mdRecord.dwMDIdentifier  = dwPropID;
    mdRecord.dwMDAttributes  = dwFlags;
    mdRecord.dwMDUserType    = dwUserType;
    mdRecord.dwMDDataType    = dwDataType;
    mdRecord.dwMDDataLen     = cbData;
    mdRecord.pbMDData        = (PBYTE)pData;

    // set the data
    hRes = m_pMetabase->SetData( m_hMeta, pszPath, &mdRecord );

    // test for success
    if ( SUCCEEDED( hRes ))
        return TRUE;

    // there was an error, clean up
    SetLastError( HRESULTTOWIN32( hRes ) );
    return FALSE;
    }

//----------------------------------------------------------------
BOOL CWrapMetaBase::GetData( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType, DWORD dwDataType,
                                        PVOID pData, DWORD* pcbData, DWORD dwFlags )
    {
    METADATA_RECORD mdRecord;
    HRESULT         hRes;
    DWORD           dwRequiredLen;

    // prepare the get data record
    mdRecord.dwMDIdentifier  = dwPropID;
    mdRecord.dwMDAttributes  = dwFlags;
    mdRecord.dwMDUserType    = dwUserType;
    mdRecord.dwMDDataType    = dwDataType;
    mdRecord.dwMDDataLen     = *pcbData;
    mdRecord.pbMDData        = (PBYTE)pData;

    // get the data
    hRes = m_pMetabase->GetData( m_hMeta, pszPath, &mdRecord, &dwRequiredLen );

    // test for success
    if ( SUCCEEDED( hRes ))
        {
        *pcbData = mdRecord.dwMDDataLen;
        return TRUE;
        }

    // there was a failure - clean up
    *pcbData = dwRequiredLen;
    SetLastError( HRESULTTOWIN32( hRes ) );
    return FALSE;
    }

//----------------------------------------------------------------
// another form of GetData that automatically allocates the buffer. It should then be
// freed using GlobalFree(p);
PVOID CWrapMetaBase::GetData( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType, DWORD dwDataType,
                                        DWORD* pcbData, DWORD dwFlags )
    {
    PVOID           pData = m_pBuffer;
    DWORD           cbData = m_cbBuffer;
    DWORD           err = 0;
    BOOL            f;

    // first - attempt to get the data in the buffer that has already been allocated;
    f = GetData( pszPath, dwPropID, dwUserType, dwDataType, pData, &cbData, dwFlags );

    // if the get data function worked, we can pretty much leave
    if ( f )
        {
        // set the data size
        *pcbData = cbData;
        // return the allocated buffer
        return pData;
        }

    // check the error - it could be some sort of memory error
    err = GetLastError();

    // it is ok that the GetData failed, but the reason had better be ERROR_INSUFFICIENT_BUFFER
    // otherwise, it is something we can't handle
    if ( err != ERROR_INSUFFICIENT_BUFFER )
        return NULL;

    // allocate the buffer
    pData = GlobalAlloc( GPTR, cbData );
    if ( !pData )
        return NULL;

    // first, get the size of the data that we are looking for
    f = GetData( pszPath, dwPropID, dwUserType, dwDataType, pData, &cbData, dwFlags );

    // if that getting failed, we need to cleanup
    if ( !f )
        {
        GlobalFree( pData );
        pData = NULL;
        }

    // set the data size
    *pcbData = cbData;

    // return the allocated buffer
    return pData;
    }

//----------------------------------------------------------------
// free memory returned by GetData
void CWrapMetaBase::FreeWrapData( PVOID pData )
{
    // if it is trying to free the local buffer, do nothing
    if ( pData == m_pBuffer )
    {
        return;
    }

    // ah - but it was not the local buffer - we should dispose of it
    if ( pData )
    {
        GlobalFree( pData );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\common\ssltools\stdafx.h ===
#ifndef _STDAFX_H_
#define _STDAFX_H_

#include <tchar.h>
extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#undef ASSERT
}
#include <afxwin.h>
#include <afxext.h>
#include <afxcoll.h>
#include <afxcmn.h>

extern "C"
{
#include <ntsam.h>
#include <lm.h>
#include <lmerr.h>
}

//#include <dbgutil.h>
//#include <assert.h>

extern "C"
    {
    #include <md5.h>
    #include <rc4.h>
    #include <wincrypt.h>

    #define SECURITY_WIN32
    #include <sspi.h>
    #include <ntsecapi.h>
    #include <spseal.h>
    #include <schnlsp.h>
    }

#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\common\ssltools\certupgr.cpp ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    certupgr.cxx

Abstract:

    Functions used in upgrading server certs from K2 [server cert in metabase] to
    Avalanche [server cert in CAPI store].

Author:

    Alex Mallet (amallet)    07-Dec-1997
    Boyd Multerer (boydm)    20-Jan-1998        Converted to be useful in setup

--*/

#include "stdafx.h"
#include <objbase.h>

#ifndef _CHICAGO_


#include "oidenc.h"


// keyring include
#include "intrlkey.h"

//
//Local includes
//
#include "certupgr.h"
//#include "certtools.h"


// The below define is in some interal schannel header file. John Banes
// told me to just redefine it below as such........ - Boyd
LPCSTR SGC_KEY_SALT  =  "SGCKEYSALT";


// prototypes
BOOL DecodeAndImportPrivateKey( PBYTE pbEncodedPrivateKey IN,
                                DWORD cbEncodedPrivateKey IN,
                                PCHAR pszPassword IN,
                                PWCHAR pszKeyContainerIN,
                                CRYPT_KEY_PROV_INFO *pCryptKeyProvInfo );
BOOL UpdateCSPInfo( PCCERT_CONTEXT pcCertContext );


BOOL FImportAndStoreRequest( PCCERT_CONTEXT pCert, PVOID pbPKCS10req, DWORD cbPKCS10req );

//-------------------------------------------------------------------------
PCCERT_CONTEXT CopyKRCertToCAPIStore_A( PVOID pbPrivateKey, DWORD cbPrivateKey,
                            PVOID pbPublicKey, DWORD cbPublicKey,
                            PVOID pbPKCS10req, DWORD cbPKCS10req,
                            PCHAR pszPassword,
                            PCHAR pszCAPIStore)
    {
    PCCERT_CONTEXT  pCert = NULL;

    // prep the wide strings
    PWCHAR  pszwCAPIStore = NULL;
    DWORD   lenStore = (strlen(pszCAPIStore)+1) * sizeof(WCHAR);
    pszwCAPIStore = (PWCHAR)GlobalAlloc( GPTR, lenStore );
    if ( !pszwCAPIStore )
        goto cleanup;

    // convert the strings
    MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, pszCAPIStore, -1, pszwCAPIStore, lenStore );

    // do the real call
    pCert = CopyKRCertToCAPIStore_W(
                            pbPrivateKey, cbPrivateKey,
                            pbPublicKey, cbPublicKey,
                            pbPKCS10req, cbPKCS10req,
                            pszPassword,
                            pszwCAPIStore );

cleanup:
    // preserve the last error state
    DWORD   err = GetLastError();

    // clean up the strings
    if ( pszwCAPIStore )
        GlobalFree( pszwCAPIStore );

    // reset the last error state
    SetLastError( err );

    // return the cert
    return pCert;
    }

//--------------------------------------------------------------------------------------------
// Copies an old Key-Ring style cert to the CAPI store. This cert comes in as two binaries and a password.
PCCERT_CONTEXT CopyKRCertToCAPIStore_W( PVOID pbPrivateKey, DWORD cbPrivateKey,
                            PVOID pbPublicKey, DWORD cbPublicKey,
                            PVOID pbPKCS10req, DWORD cbPKCS10req,
                            PCHAR pszPassword,
                            PWCHAR pszCAPIStore)
/*++

Routine Description:

    Upgrades K2 server certs to Avalanche server certs - reads server cert out of K2
    metabase, creates cert context and stores it in CAPI2 "MY" store and writes
    relevant information back to metabase.

Arguments:

    pMDObject - pointer to Metabase object 
    pszOldMBPath - path to where server cert is stored in old MB, relative to SSL_W3_KEYS_MD_PATH
    pszNewMBPath - fully qualified path to where server cert info should be stored in new MB

Returns:

    BOOL indicating success/failure

--*/
    {
    BOOL        fSuccess = FALSE;

    HCERTSTORE hStore = NULL;
    PCCERT_CONTEXT pcCertContext = NULL;
    LPOLESTR    polestr = NULL;


    // start by opening the CAPI store that we will be saving the certificate into
    hStore = CertOpenStore( CERT_STORE_PROV_SYSTEM,
                                0,
                                NULL,
                                CERT_SYSTEM_STORE_LOCAL_MACHINE,
                                pszCAPIStore );
    if ( !hStore )
        {
//        iisDebugOut((_T("Error 0x%x calling CertOpenStore \n"), GetLastError());
        goto EndUpgradeServerCert;
        }


    // at this point we check to see if a certificate was passed in. If none was, then we need
    // to create a dummy-temporary certificate that markes the private key as incomplete. That
    // way, then the real certificate comes back from verisign the regular tools can be used
    // to complete the key.
    //CertCreateSelfSignCertificate()


    //
    //Create cert context to be stored in CAPI store
    //
    pbPublicKey = (PVOID)((PBYTE)pbPublicKey + CERT_DER_PREFIX);
    cbPublicKey -= CERT_DER_PREFIX;
    pcCertContext = CertCreateCertificateContext( X509_ASN_ENCODING, (PUCHAR)pbPublicKey, cbPublicKey);
    if ( pcCertContext )
        {

        // the private key gets stored in a seperate location from the certificate and gets referred to
        // by the certificate. We should try to pick a unique name so that some other cert won't step
        // on it by accident. There is no formal format for this name whatsoever. Some groups use a
        // human-readable string, some use a hash of the cert, and some use a GUID string. All are valid
        // although for generated certs the hash or the GUID are probably better.

        // get the 128 big md5 hash of the cert for the name
        DWORD dwHashSize;
        BOOL    fHash;

        BYTE MD5Hash[16];                // give it some extra size
        dwHashSize = sizeof(MD5Hash);
        fHash = CertGetCertificateContextProperty( pcCertContext,
                            CERT_MD5_HASH_PROP_ID,
                            (VOID *) MD5Hash,
                            &dwHashSize );

        // Since the MD5 hash is the same size as a guid, we can use the guid utilities to make a
        // nice string out of it.
        HRESULT     hresult;
        hresult = StringFromCLSID( (REFCLSID)MD5Hash, &polestr );

        //
        // Now decode private key blob and import it into CAPI1 private key
        //
        CRYPT_KEY_PROV_INFO CryptKeyProvInfo;

        if ( DecodeAndImportPrivateKey( (PUCHAR)pbPrivateKey, cbPrivateKey, pszPassword,
                                        polestr, &CryptKeyProvInfo ) )
            {
            //
            // Add the private key to the cert context
            //
            BOOL    f;
            f = CertSetCertificateContextProperty( pcCertContext, CERT_KEY_PROV_INFO_PROP_ID, 
                                                    0, &CryptKeyProvInfo );
            f = UpdateCSPInfo( pcCertContext );
            if ( f )
                {
                //
                // Store it in the provided store
                //
                if ( CertAddCertificateContextToStore( hStore, pcCertContext,
                                                       CERT_STORE_ADD_REPLACE_EXISTING, NULL ) )
                    {
                    fSuccess = TRUE;

                    // Write out the original request as a property on the cert
                    FImportAndStoreRequest( pcCertContext, pbPKCS10req, cbPKCS10req );
                    }
                else
                    {
//                    iisDebugOut((_T("Error 0x%x calling CertAddCertificateContextToStore"), GetLastError());
                    }
                }
            else
                {
//                iisDebugOut((_T("Error 0x%x calling CertSetCertificateContextProperty"), GetLastError());
                }
            }
        }
    else
        {
//        iisDebugOut((_T("Error 0x%x calling CertCreateCertificateContext"), GetLastError());
        }

    //
    //Cleanup that's done only on failure
    //
    if ( !fSuccess )
        {
        if ( pcCertContext )
            {
            CertFreeCertificateContext( pcCertContext );
            }
        pcCertContext = NULL;
        }

EndUpgradeServerCert:
    // cleanup
    if ( hStore )
        CertCloseStore ( hStore, 0 );

    if ( polestr )
        CoTaskMemFree( polestr );


    // return the answer
    return pcCertContext;
    }


//--------------------------------------------------------------------------------------------
BOOL UpdateCSPInfo( PCCERT_CONTEXT pcCertContext )
    {
    BYTE                    cbData[1000];
    CRYPT_KEY_PROV_INFO*    pProvInfo = (CRYPT_KEY_PROV_INFO *) cbData;
    DWORD                   dwFoo = 1000;
    BOOL                    fSuccess = TRUE;

    if ( ! CertGetCertificateContextProperty( pcCertContext,
                                              CERT_KEY_PROV_INFO_PROP_ID,
                                              pProvInfo,
                                              &dwFoo ) )
        {
        fSuccess = FALSE;
//        iisDebugOut((_T("Fudge. failed to get property : 0x%x"), GetLastError());
        }
    else
        {
        pProvInfo->dwProvType = PROV_RSA_SCHANNEL;
        pProvInfo->pwszProvName = NULL;
        if ( !CertSetCertificateContextProperty( pcCertContext,
                                                 CERT_KEY_PROV_INFO_PROP_ID,
                                                 0,
                                                 pProvInfo ) )
            {
            fSuccess = FALSE;
//            iisDebugOut((_T("Fudge. failed to set property : 0x%x"), GetLastError());
            }
        }

    // return success
    return fSuccess;
    }

//--------------------------------------------------------------------------------------------
BOOL DecodeAndImportPrivateKey( PBYTE pbEncodedPrivateKey IN,
                                DWORD cbEncodedPrivateKey IN,
                                PCHAR pszPassword IN,
                                PWCHAR pszKeyContainer IN,
                                CRYPT_KEY_PROV_INFO *pCryptKeyProvInfo )
    
/*++

Routine Description:

    Converts the private key stored in the metabase, in Schannel-internal format,
    into a key that can be imported via CryptImportKey() to create a CAP1 key blob.

Arguments:

    pbEncodedPrivateKey - pointer to [encoded] private key
    cbEncodedPrivateKey - size of encoded private key blob
    pszPassword - password used to encode private key
    pszKeyContainer - container name for private key
    pCryptKeyProvInfo - pointer to CRYPT_KEY_PROV_INFO structure filled in on success

Returns:

   BOOL indicating success/failure

--*/
    {
    BOOL fSuccess = FALSE;
    DWORD cbPassword = strlen(pszPassword);
    PPRIVATE_KEY_FILE_ENCODE pPrivateFile = NULL;
    DWORD                    cbPrivateFile = 0;
    MD5_CTX md5Ctx;
    struct RC4_KEYSTRUCT rc4Key;
    DWORD i;
    HCRYPTPROV hProv = NULL;
    HCRYPTKEY hPrivateKey = NULL;
    DWORD cbDecodedPrivateKey = 0;
    PBYTE pbDecodedPrivateKey = NULL;

	DWORD err;
    //
    //HACK HACK HACK - need to make sure Schannel is initialized, so it registers
    //its custom decoders, which we make use of in the following code. So, make a 
    //bogus call to an Schannel function

    // Note: on NT5, the AcquireCredentialsHandle operates in the lsass process and
    // thus will not properly initialize the stuff we need in our process. Thus we
    // call SslGenerateRandomBits instead.
    //
    DWORD   dw;
    SslGenerateRandomBits( (PUCHAR)&dw, sizeof(dw) );

    // We have to do a little fixup here.  Old versions of
    // schannel wrote the wrong header data into the ASN
    // for private key files, so we must fix the size data.
    pbEncodedPrivateKey[2] = (BYTE) (((cbEncodedPrivateKey - 4) & 0xFF00) >> 8); //Get MSB
    pbEncodedPrivateKey[3] = (BYTE) ((cbEncodedPrivateKey - 4) & 0xFF); //Get LSB

    //
    // ASN.1 decode the private key.
    //

    //
    // Figure out the size of the buffer needed
    //
    if( !CryptDecodeObject(X509_ASN_ENCODING,
                           szPrivateKeyFileEncode,
                           pbEncodedPrivateKey,
                           cbEncodedPrivateKey,
                           0,
                           NULL,
                           &cbPrivateFile) )
        {
		err = GetLastError();
//        iisDebugOut((_T("Error 0x%x decoding the private key"), err);
        goto EndDecodeKey;
        }

    pPrivateFile = (PPRIVATE_KEY_FILE_ENCODE) LocalAlloc( LPTR, cbPrivateFile );

    if(pPrivateFile == NULL)
        {
        SetLastError( ERROR_OUTOFMEMORY );
        goto EndDecodeKey;
        }

    //
    // Actually fill in the buffer
    //
    if( !CryptDecodeObject( X509_ASN_ENCODING,
                            szPrivateKeyFileEncode,
                            pbEncodedPrivateKey,
                            cbEncodedPrivateKey,
                            0,
                            pPrivateFile,
                            &cbPrivateFile ) )
        {
		err = GetLastError();
//        iisDebugOut((_T("Error 0x%x decoding the private key"), err);
        goto EndDecodeKey;
        }

    //
    // Decrypt the decoded private key using the password.
    //
    MD5Init(&md5Ctx);
    MD5Update(&md5Ctx, (PBYTE) pszPassword, cbPassword);
    MD5Final(&md5Ctx);

    rc4_key( &rc4Key, 16, md5Ctx.digest );
//    memset( &md5Ctx, 0, sizeof(md5Ctx) );

    rc4( &rc4Key, 
         pPrivateFile->EncryptedBlob.cbData,
         pPrivateFile->EncryptedBlob.pbData );



    //
    // Build a PRIVATEKEYBLOB from the decrypted private key.
    //

    //
    // Figure out size of buffer needed
    //
    if( !CryptDecodeObject( X509_ASN_ENCODING,
                            szPrivateKeyInfoEncode,
                            pPrivateFile->EncryptedBlob.pbData,
                            pPrivateFile->EncryptedBlob.cbData,
                            0,
                            NULL,
                            &cbDecodedPrivateKey ) )
        {
            // NOTE: This stuff is complicated!!! The following code came
            // from John Banes. Heck this whole routine pretty much came
            // from John Banes. -- Boyd

            // Maybe this was a SGC style key.
            // Re-encrypt it, and build the SGC decrypting
            // key, and re-decrypt it.
            BYTE md5Digest[MD5DIGESTLEN];

            rc4_key(&rc4Key, 16, md5Ctx.digest);
            rc4(&rc4Key,
                pPrivateFile->EncryptedBlob.cbData,
                pPrivateFile->EncryptedBlob.pbData);
            CopyMemory(md5Digest, md5Ctx.digest, MD5DIGESTLEN);

            MD5Init(&md5Ctx);
            MD5Update(&md5Ctx, md5Digest, MD5DIGESTLEN);
            MD5Update(&md5Ctx, (PUCHAR)SGC_KEY_SALT, strlen(SGC_KEY_SALT));
            MD5Final(&md5Ctx);
            rc4_key(&rc4Key, 16, md5Ctx.digest);
            rc4(&rc4Key,
                pPrivateFile->EncryptedBlob.cbData,
                pPrivateFile->EncryptedBlob.pbData);

            // Try again...
            if(!CryptDecodeObject(X509_ASN_ENCODING,
                          szPrivateKeyInfoEncode,
                          pPrivateFile->EncryptedBlob.pbData,
                          pPrivateFile->EncryptedBlob.cbData,
                          0,
                          NULL,
                          &cbDecodedPrivateKey))
            {
                ZeroMemory(&md5Ctx, sizeof(md5Ctx));
                err = GetLastError();
		        goto EndDecodeKey;
            }
        
        
        }

    pbDecodedPrivateKey = (PBYTE) LocalAlloc( LPTR, cbDecodedPrivateKey );

    if( pbDecodedPrivateKey == NULL )
        {
        SetLastError( ERROR_OUTOFMEMORY );
        goto EndDecodeKey;
        }

    //
    // Actually fill in the buffer
    //
    if( !CryptDecodeObject( X509_ASN_ENCODING,
                            szPrivateKeyInfoEncode,
                            pPrivateFile->EncryptedBlob.pbData,
                            pPrivateFile->EncryptedBlob.cbData,
                            0,
                            pbDecodedPrivateKey,
                            &cbDecodedPrivateKey ) )
        {
		err = GetLastError();
//        iisDebugOut((_T("Error 0x%x decoding the private key"), err);
        goto EndDecodeKey;
        }


    // On NT 4 the ff holds true : <- from Alex Mallet
    // Although key is going to be used for key exchange, mark it as being
    // used for signing, because only 512-bit key exchange keys are supported 
    // in the non-domestic rsabase.dll, whereas signing keys can be up to
    // 2048 bits.
    //
    // On NT 5, PROV_RSA_FULL should be changed to PROV_RSA_SCHANNEL, and 
    // aiKeyAlg to CALG_RSA_KEYX, because PROV_RSA_SCHANNEL, which is only
    // installed on NT 5, supports 1024-bit private keys for key exchange
    //
    // On NT4, Schannel doesn't care whether a key is marked for signing or exchange,
    // but on NT5 it does, so aiKeyAlg must be set appropriately
    //
    ((BLOBHEADER *) pbDecodedPrivateKey)->aiKeyAlg = CALG_RSA_KEYX;

    //
    // Clean out the key container, pszKeyContainer
    //

    CryptAcquireContext(&hProv,
                        pszKeyContainer,
                        NULL,
                        PROV_RSA_SCHANNEL,
                        CRYPT_DELETEKEYSET | CRYPT_MACHINE_KEYSET);
    //
    // Create a CryptoAPI key container in which to store the key.
    //
    if( !CryptAcquireContext( &hProv,
                              pszKeyContainer,
                              NULL,
                              PROV_RSA_SCHANNEL,
                              CRYPT_NEWKEYSET | CRYPT_MACHINE_KEYSET))
        {
		err = GetLastError();
//        iisDebugOut((_T("Error 0x%x calling CryptAcquireContext"), err);
        goto EndDecodeKey;
        }

    //
    // Import the private key blob into the key container.
    //
    if( !CryptImportKey( hProv,
                         pbDecodedPrivateKey,
                         cbDecodedPrivateKey,
                         0, 
                         CRYPT_EXPORTABLE, //so we can export it later
                         &hPrivateKey ) )
        {
		err = GetLastError();
//        iisDebugOut((_T("Error 0x%x importing PRIVATEKEYBLOB"), err);
        goto EndDecodeKey;
        }

    
    //
    // Fill in the CRYPT_KEY_PROV_INFO structure, with the same parameters we 
    // used in the call to CryptAcquireContext() above
    //

    //
    // container name in the structure is a unicode string, so we need to convert
    //

    if ( pszKeyContainer != NULL )
        {
        // point the key container name to the passed in string
        // WARNING: this does not actually copy the string, just the pointer
        // to it. So the strings needs to remain valid until the ProvInfo is commited.
        pCryptKeyProvInfo->pwszContainerName = pszKeyContainer;
        }
    else
        {
        pCryptKeyProvInfo->pwszContainerName = NULL;
        }

    pCryptKeyProvInfo->pwszProvName = NULL;
    pCryptKeyProvInfo->dwProvType = PROV_RSA_FULL;
    pCryptKeyProvInfo->dwFlags = 0x20;              // allow the cert to be exchanged
    pCryptKeyProvInfo->cProvParam = 0;
    pCryptKeyProvInfo->rgProvParam = NULL;
    pCryptKeyProvInfo->dwKeySpec = AT_KEYEXCHANGE;  // allow the cert to be exchanged

    fSuccess = TRUE;

EndDecodeKey:

    //
    // Clean-up that happens regardless of success/failure
    //
    if ( pPrivateFile )
        {
        LocalFree( pPrivateFile );
        }

    if ( pbDecodedPrivateKey )
        {
        LocalFree( pbDecodedPrivateKey );
        }

    if ( hPrivateKey )
        {
        CryptDestroyKey( hPrivateKey );
        }

    if ( hProv )
        {
        CryptReleaseContext( hProv, 0 ); 
        }

    return fSuccess;


    } //DecodeAndImportPrivateKey


//--------------------------------------------------------------------------------------------
/*++

Routine Description:

    Takes an incoming PKCS10 request and saves it as a property attached to the key. It also
    checks if the request is in the old internal Keyring format or not......

Arguments:

    pCert - CAPI certificate context pointer for the cert to save the request on
    pbPKCS10req - pointer to the request
    cbPKCS10req - size of the request

Returns:

   BOOL indicating success/failure

--*/
BOOL FImportAndStoreRequest( PCCERT_CONTEXT pCert, PVOID pbPKCS10req, DWORD cbPKCS10req )
{
    BOOL    f;
    DWORD   err;

    // if any NULLS are passed in, fail gracefully
    if ( !pCert || !pbPKCS10req || !cbPKCS10req )
        return FALSE;

    // first, check if the incoming request is actually pointing to an old KeyRing internal
    // request format. That just means that the real request is actuall slightly into
    // the block. The way you tell is by testing the first DWORD to see it
    // is REQUEST_HEADER_IDENTIFIER
    // start by seeing if this is a new style key request
    LPREQUEST_HEADER pHeader = (LPREQUEST_HEADER)pbPKCS10req;
    if ( pHeader->Identifier == REQUEST_HEADER_IDENTIFIER )
        {
        // update the request pointer and data count
            pbPKCS10req = (PBYTE)pbPKCS10req + pHeader->cbSizeOfHeader;
            cbPKCS10req = pHeader->cbRequestSize;
        }

    // now save the request onto the key
	CRYPT_DATA_BLOB dataBlob;
    ZeroMemory( &dataBlob, sizeof(dataBlob) );
    dataBlob.pbData = (PBYTE)pbPKCS10req;           // pointer to blob data
    dataBlob.cbData = cbPKCS10req;                  // blob length info
	f = CertSetCertificateContextProperty(
        pCert, 
        CERTWIZ_REQUEST_PROP_ID,
        0,
        &dataBlob
        );
    err = GetLastError();

/*
    HRESULT hRes = CertTool_SetBinaryBlobProp(
                    pCert,                  // cert context to set the prop on
                    pbPKCS10req,            // pointer to blob data
                    cbPKCS10req,            // blob length info
                    CERTWIZ_REQUEST_PROP_ID,// property ID for context
                    TRUE                   // the request is already encoded
                    );
*/

    return f;
}



#endif //_CHICAGO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\admin\wrapmb\ansi\wrap.h ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :
      mb.hxx

   Abstract:
      This module defines the USER-level wrapper class for access to the
      metabase

   Author:

       JohnL  09-Oct-1996

   Environment:
       Win32 - User Mode

   Project:

       Internet Server DLL

   Revision History:

--*/

#ifndef _MB_HXX_
#define _MB_HXX_

#if !defined( dllexp)
#define dllexp               __declspec( dllexport)
#endif // !defined( dllexp)

//
//  Default timeout
//

#define MB_TIMEOUT           5000

//
//  IIS Service pointer
//

#define PINETSVC             g_pInetSvc

/************************************************************
 *   Type Definitions
 ************************************************************/


//
//  Simple wrapper class around the metabase APIs
//
//  The Metabase Interface pointer is assumed to remain valid for the lifetime
//  of this object.
//
//  The character counts for paths should include the terminating '\0'.
//
//

class MB
{
public:

    MB( IMSAdminBase * pMBCom )
        : _pMBCom( pMBCom ),
          _hMB   ( NULL )
    {
    }

    ~MB( VOID )
    {
        Close();
        _pMBCom = NULL;
    }


    inline
    BOOL Open( const CHAR * pszPath,
               DWORD        dwFlags = METADATA_PERMISSION_READ )
    {
        return Open( METADATA_MASTER_ROOT_HANDLE,
                     pszPath,
                     dwFlags );
    }

    inline
    BOOL Open( METADATA_HANDLE hOpenRoot,
               const CHAR *    pszPath,
               DWORD           dwFlags = METADATA_PERMISSION_READ );

    inline
    BOOL EnumObjects( const CHAR * pszPath,
                      CHAR *       Name,
                      DWORD        Index )
    {
        HRESULT hRes = _pMBCom->EnumKeys( _hMB, pszPath, Name, Index );

        if ( SUCCEEDED( hRes ))
        {
            return TRUE;
        }

        SetLastError( HRESULTTOWIN32( hRes ));
        return FALSE;
    }

    inline
    BOOL AddObject( const CHAR * pszPath )
    {
        HRESULT hRes = _pMBCom->AddKey( _hMB, pszPath );
        if ( SUCCEEDED( hRes ))
        {
            return TRUE;
        }

        SetLastError( HRESULTTOWIN32( hRes ));
        return FALSE;
    }


    //----------------------------------------------------------------- boydm
    inline
    BOOL RenameKey( const CHAR* pszPath, const CHAR* pszNewName )
    {
    HRESULT hRes = _pMBCom->RenameKey( _hMB, pszPath, pszNewName );
    if ( SUCCEEDED( hRes ))
        {
        return TRUE;
        }
    SetLastError( HRESULTTOWIN32( hRes ));
    return FALSE;
    }

    inline
    BOOL DeleteObject( const CHAR * pszPath )
    {
        HRESULT hRes = _pMBCom->DeleteKey( _hMB, pszPath );

        if ( SUCCEEDED( hRes ))
        {
            return TRUE;
        }

        SetLastError( HRESULTTOWIN32( hRes ));
        return FALSE;
    }

    inline
    BOOL Save( VOID )
    {
        HRESULT hRes = _pMBCom->SaveData();

        if ( SUCCEEDED( hRes ))
        {
            return TRUE;
        }

        SetLastError( HRESULTTOWIN32( hRes ));
        return FALSE;
    }

    BOOL SetDword( const CHAR * pszPath,
                   DWORD        dwPropID,
                   DWORD        dwUserType,
                   DWORD        dwValue,
                   DWORD        dwFlags = METADATA_INHERIT )
    {
        return SetData( pszPath,
                        dwPropID,
                        dwUserType,
                        DWORD_METADATA,
                        (PVOID) &dwValue,
                        sizeof( DWORD ),
                        dwFlags );
    }

    BOOL SetString( const CHAR * pszPath,
                    DWORD        dwPropID,
                    DWORD        dwUserType,
                    CHAR *       pszValue,
                    DWORD        dwFlags = METADATA_INHERIT )
    {
        return SetData( pszPath,
                        dwPropID,
                        dwUserType,
                        STRING_METADATA,
                        pszValue,
                        strlen(pszValue)+1,          // string length ignored for inprocess clients
                        dwFlags );
    }

    BOOL GetDword( const CHAR *  pszPath,
                   DWORD         dwPropID,
                   DWORD         dwUserType,
                   DWORD *       pdwValue,
                   DWORD         dwFlags = METADATA_INHERIT )
    {
        DWORD cb = sizeof(DWORD);

        return GetData( pszPath,
                        dwPropID,
                        dwUserType,
                        DWORD_METADATA,
                        pdwValue,
                        &cb,
                        dwFlags );
    }

    BOOL GetString( const CHAR *  pszPath,
                    DWORD         dwPropID,
                    DWORD         dwUserType,
                    CHAR *        pszValue,
                    DWORD *       pcbValue,
                    DWORD         dwFlags = METADATA_INHERIT )
    {
        return GetData( pszPath,
                        dwPropID,
                        dwUserType,
                        STRING_METADATA,
                        pszValue,
                        pcbValue,
                        dwFlags );
    }

    inline
    BOOL SetData( const CHAR * pszPath,
                  DWORD        dwPropID,
                  DWORD        dwUserType,
                  DWORD        dwDataType,
                  VOID *       pvData,
                  DWORD        cbData,
                  DWORD        dwFlags = METADATA_INHERIT );

    inline
    BOOL GetData( const CHAR *  pszPath,
                  DWORD         dwPropID,
                  DWORD         dwUserType,
                  DWORD         dwDataType,
                  VOID *        pvData,
                  DWORD *       cbData,
                  DWORD         dwFlags = METADATA_INHERIT );

    inline
    BOOL DeleteData(const CHAR *  pszPath,
                    DWORD         dwPropID,
                    DWORD         dwUserType,
                    DWORD         dwDataType )
    {
        HRESULT hRes = _pMBCom->DeleteData( _hMB, pszPath, dwPropID, dwDataType );

        if ( SUCCEEDED( hRes ))
        {
            return TRUE;
        }
        SetLastError( HRESULTTOWIN32( hRes ));
        return(FALSE);
    }

    BOOL Close( VOID )
    {
        if ( _hMB )
        {
            _pMBCom->CloseKey( _hMB );
            _hMB = NULL;
        }

        return TRUE;
    }

    METADATA_HANDLE QueryHandle( VOID ) const
        { return _hMB; }

private:

    IMSAdminBase *       _pMBCom;
    METADATA_HANDLE _hMB;

};


inline
BOOL
MB::Open(
    METADATA_HANDLE hOpenRoot,
    const CHAR *    pszPath,
    DWORD           dwFlags
    )
/*++

Routine Description:

    Opens the metabase

Arguments:

    hOpenRoot - Relative root or METADATA_MASTER_ROOT_HANDLE
    pszPath - Path to open
    dwFlags - Open flags

Return:

    TRUE if success, FALSE on error, (call GetLastError())

--*/
{
    HRESULT hRes;

    hRes = _pMBCom->OpenKey( hOpenRoot, pszPath, dwFlags, MB_TIMEOUT, &_hMB );

    if ( SUCCEEDED( hRes ))
    {
        return TRUE;
    }

    SetLastError( HRESULTTOWIN32( hRes ) );

    return FALSE;
}

inline
BOOL
MB::SetData(
    const CHAR * pszPath,
    DWORD        dwPropID,
    DWORD        dwUserType,
    DWORD        dwDataType,
    VOID *       pvData,
    DWORD        cbData,
    DWORD        dwFlags
    )
/*++

Routine Description:

    Sets a metadata property on an openned metabase

Arguments:

    pszPath - Path to set data on
    dwPropID - Metabase property ID
    dwUserType - User type for this property
    dwDataType - Type of data being set (dword, string etc)
    pvData - Pointer to data
    cbData - Size of data
    dwFlags - Inheritance flags

Return:

    TRUE if success, FALSE on error, (call GetLastError())

--*/
{
    METADATA_RECORD mdRecord;
    HRESULT         hRes;


    mdRecord.dwMDIdentifier  = dwPropID;
    mdRecord.dwMDAttributes  = dwFlags;
    mdRecord.dwMDUserType    = dwUserType;
    mdRecord.dwMDDataType    = dwDataType;
    mdRecord.dwMDDataLen     = cbData;
    mdRecord.pbMDData        = (PBYTE) pvData;

    hRes = _pMBCom->SetData( _hMB, pszPath, &mdRecord );

    if ( SUCCEEDED( hRes ))
    {
        return TRUE;
    }

    SetLastError( HRESULTTOWIN32( hRes ) );

    return FALSE;
}

inline
BOOL
MB::GetData(
    const CHAR *  pszPath,
    DWORD         dwPropID,
    DWORD         dwUserType,
    DWORD         dwDataType,
    VOID *        pvData,
    DWORD *       pcbData,
    DWORD         dwFlags
    )
/*++

Routine Description:

    Retrieves a metadata property on an openned metabase

Arguments:

    pszPath - Path to set data on
    dwPropID - Metabase property ID
    dwUserType - User type for this property
    dwDataType - Type of data being set (dword, string etc)
    pvData - Pointer to data
    pcbData - Size of pvData, receives size of object
    dwFlags - Inheritance flags

Return:

    TRUE if success, FALSE on error, (call GetLastError())

--*/
{
    METADATA_RECORD mdRecord;
    HRESULT         hRes;
    DWORD           dwRequiredLen;

    mdRecord.dwMDIdentifier  = dwPropID;
    mdRecord.dwMDAttributes  = dwFlags;
    mdRecord.dwMDUserType    = dwUserType;
    mdRecord.dwMDDataType    = dwDataType;
    mdRecord.dwMDDataLen     = *pcbData;
    mdRecord.pbMDData        = (PBYTE) pvData;

    hRes = _pMBCom->GetData( _hMB, pszPath, &mdRecord, &dwRequiredLen );

    if ( SUCCEEDED( hRes ))
    {
        *pcbData = mdRecord.dwMDDataLen;
        return TRUE;
    }

    *pcbData = dwRequiredLen;

    SetLastError( HRESULTTOWIN32( hRes ) );

    return FALSE;
}

#ifdef O
inline
BOOL MB::GetAll(
    const CHAR *   pszPath,
    DWORD          dwFlags,
    DWORD          dwUserType,
    BUFFER *       pBuff,
    DWORD *        pcRecords,
    DWORD *        pdwDataSetNumber
    )
/*++

Routine Description:

    Retrieves all the metabase properties on this path of the request type

Arguments:

    pszPath - Path to set data on
    dwFlags - Inerhitance flags
    dwPropID - Metabase property ID
    dwUserType - User type for this property
    dwDataType - Type of data being set (dword, string etc)
    pvData - Pointer to data
    pcbData - Size of pvData, receives size of object
    dwFlags - Inheritance flags

Return:

    TRUE if success, FALSE on error, (call GetLastError())

--*/
{
    DWORD   RequiredSize;
    HRESULT hRes;

TryAgain:

    hRes = _pMBCom->GetAllData( _hMB,
                            pszPath,
                            dwFlags,
                            dwUserType,
                            ALL_METADATA,
                            pcRecords,
                            pdwDataSetNumber,
                            pBuff->QuerySize(),
                            (PBYTE)pBuff->QueryPtr(),
                            &RequiredSize
                            );

    // See if we got it, and if we failed because of lack of buffer space
    // try again.

    if ( SUCCEEDED(hRes) )
    {
        return TRUE;
    }

    // Some sort of error, most likely not enough buffer space. Keep
    // trying until we get a non-fatal error.

    if (HRESULT_FACILITY(hRes) == FACILITY_WIN32 &&
        HRESULT_CODE(hRes) == ERROR_INSUFFICIENT_BUFFER) {

        // Not enough buffer space. RequiredSize contains the amount
        // the metabase thinks we need.

        if ( !pBuff->Resize(RequiredSize) ) {

            // Not enough memory to resize.
            return FALSE;
        }

        goto TryAgain;

    }

    return FALSE;
}
#endif


#ifdef O
inline
BOOL
MB::GetStr(
    const CHAR *  pszPath,
    DWORD         dwPropID,
    DWORD         dwUserType,
    STR *         pstrValue,
    DWORD         dwFlags,
    const CHAR *  pszDefault
    )
/*++

Routine Description:

    Retrieves the string from the metabase.  If the value wasn't found and
    a default is supplied, then the default value is copied to the string.

Arguments:

    pszPath - Path to get data on
    dwPropID - property id to retrieve
    dwUserType - User type for this property
    pstrValue - string that receives the value
    dwFlags - Metabase flags
    pszDefault - Default value to use if the string isn't found, NULL
        for no default value (i.e., will return an error).

Return:

    TRUE if success, FALSE on error, (call GetLastError())

--*/
{
    DWORD cbSize = pstrValue->QuerySize();

TryAgain:

    if ( !GetData( pszPath,
                   dwPropID,
                   dwUserType,
                   STRING_METADATA,
                   pstrValue->QueryStr(),
                   &cbSize,
                   dwFlags ))
    {
        if ( GetLastError() == MD_ERROR_DATA_NOT_FOUND )
        {
            if ( pszDefault != NULL )
            {
                return pstrValue->Copy( pszDefault );
            }

            return FALSE;
        }
        else if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
                  pstrValue->Resize( cbSize ) )
        {
            goto TryAgain;
        }

        return FALSE;
    }

    pstrValue->SetLen( cbSize );

    return TRUE;
}
#endif

#endif // _MB_HXX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\common\ssltools\certupgr.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

   certupgr.hxx

Abstract:

    Declarations for functions used to upgrade K2 server certs to Avalanche server certs

Author:

    Alex Mallet (amallet)    02-Dec-1997
    Boyd Multerer (boydm)    20-Jan-1998

--*/

#ifndef _CERTUPGR_H_
#define _CERTUPGR_H_

#define CERT_DER_PREFIX		17

#define CERTWIZ_REQUEST_PROP_ID   (CERT_FIRST_USER_PROP_ID + 0x1001)


#ifdef UNICODE
    #define ImportKRBackupToCAPIStore   ImportKRBackupToCAPIStore_W
    #define CopyKRCertToCAPIStore       CopyKRCertToCAPIStore_W
#else
    #define ImportKRBackupToCAPIStore   ImportKRBackupToCAPIStore_A
    #define CopyKRCertToCAPIStore       CopyKRCertToCAPIStore_A
#endif

// NOTE: In both the below routines the password must always be ANSI.

// NOTE: The PCCERT_CONTEXT that is returned from the below routines MUST be freed
// via the CAPI call CertFreeCertificateContext(). Otherwise you will be leaking.

//----------------------------------------------------------------
// given a path to an old keyring style backup file, this reads in the public and private
// key information and, using the passed-in password, imports it into the specified
// CAPI store.
PCCERT_CONTEXT ImportKRBackupToCAPIStore_A(
                            PCHAR ptszFileName,         // path of the file
                            PCHAR pszPassword,          // ANSI password
                            PCHAR pszCAPIStore );       // name of the capi store

PCCERT_CONTEXT ImportKRBackupToCAPIStore_W(
                            PWCHAR ptszFileName,        // path of the file
                            PCHAR pszPassword,          // ANSI password
                            PWCHAR pszCAPIStore );      // name of the capi store

//----------------------------------------------------------------
// given a path to an old keyring style backup file, this reads in the public and private
// key information and, using the passed-in password, imports it into the specified
// CAPI store.
// ptszFilePath:    Pointer to the path of the file to be imported
// pszPassword:     Pointer to the password.        MUST BE ANSI 
// ptszPassword:     Pointer to the CAPI store name.
PCCERT_CONTEXT CopyKRCertToCAPIStore_A(
                            PVOID pbPrivateKey, DWORD cbPrivateKey,     // private key info
                            PVOID pbPublicKey, DWORD cbPublicKey,       // public key info
                            PVOID pbPKCS10req, DWORD cbPKCS10req,       // the pkcs10 request
                            PCHAR pszPassword,                          // ANSI password
                            PCHAR pszCAPIStore );                       // name of the capi store

PCCERT_CONTEXT CopyKRCertToCAPIStore_W(
                            PVOID pbPrivateKey, DWORD cbPrivateKey,     // private key info
                            PVOID pbPublicKey, DWORD cbPublicKey,       // public key info
                            PVOID pbPKCS10req, DWORD cbPKCS10req,       // the pkcs10 request
                            PCHAR pszPassword,                          // ANSI password
                            PWCHAR pszCAPIStore );                      // name of the capi store

#endif // _CERTUPGR_HXX_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\applyinf\makefile.inc ===
#
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\common\ssltools\oidenc.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       context.h
//
//  Contents:   Schannel context declarations.
//
//  Classes:
//
//  Functions:
//
//  History:    09-23-97   jbanes   Ported over SGC stuff from NT 4 tree.
//
//----------------------------------------------------------------------------

#ifndef __OIDENC_H__
#define __OIDENC_H__

#define szPublicTag   ".public"
#define szParamTag    ".params"
#define szPrivateTag  ".private"

#define MAX_OID_SIZE  64

#define szOID_DH  szOID_PKCS_3 ".1"


#define szOID_DH_Public szOID_DH szPublicTag
#define szOID_DH_Params szOID_DH szParamTag

#define szOID_RSA_RSA_Public szOID_RSA_RSA szPublicTag


#define szOID_INFOSEC_mosaicUpdatedSig_Public  szOID_INFOSEC_mosaicUpdatedSig  szPublicTag
#define szOID_INFOSEC_mosaicUpdatedSig_Params  szOID_INFOSEC_mosaicUpdatedSig  szParamTag
#define szOID_INFOSEC_mosaicKMandUpdSig_Public szOID_INFOSEC_mosaicKMandUpdSig szPublicTag
#define szOID_INFOSEC_mosaicKMandUpdSig_Params szOID_INFOSEC_mosaicKMandUpdSig szParamTag

#define szOID_DSA_Public szOID_OIWSEC_dsa szPublicTag
#define szOID_DSA_Params szOID_OIWSEC_dsa szParamTag

#define szOID_RSA_ENCRYPT_RC4_MD5  szOID_RSA_ENCRYPT ".4"


#define szPrivateKeyFileEncode "PrivateKeyFileEncode"
#define szPrivateKeyInfoEncode "PrivateKeyInfoEncode"

#ifndef X509_ENHANCED_KEY_USAGE
#define X509_ENHANCED_KEY_USAGE             ((LPCSTR) 36)

typedef struct _CTL_USAGE {
    DWORD               cUsageIdentifier;
    LPSTR               *rgpszUsageIdentifier;      // array of pszObjId
} CTL_USAGE, *PCTL_USAGE,
  CERT_ENHKEY_USAGE, *PCERT_ENHKEY_USAGE;


#endif

#ifndef szOID_ENHANCED_KEY_USAGE
#define szOID_ENHANCED_KEY_USAGE        "2.5.29.37"
#endif

#ifndef szOID_SERVER_GATED_CRYPTO
#define szOID_SERVER_GATED_CRYPTO       "1.3.6.1.4.1.311.10.3.3"
#endif

#define szOID_NETSCAPE_SGC              "2.16.840.1.113730.4.1"


BOOL
WINAPI
InitSchannelOSS(
        HMODULE hModule);

typedef struct _PRIVATE_KEY_FILE_ENCODE
{
    CRYPT_BIT_BLOB              EncryptedBlob;
    CRYPT_ALGORITHM_IDENTIFIER  Alg; 
} PRIVATE_KEY_FILE_ENCODE, *PPRIVATE_KEY_FILE_ENCODE;


#endif // __OIDENC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\applyinf\applyinf.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    applyinf.cxx

Abstract:

    Merge HTML documents & localizable string .inf file

Author:

    Philippe Choquier ( Phillich ) 15-may-1996

--*/

#include    <windows.h>
#include    <stdio.h>
#include    <stdlib.h>
#include    <string.h>

#include    <iis64.h>

typedef struct _SUBST_NODE {
    LPSTR pszName;
    LPSTR pszValue;
} SUBST_NODE;

#define MAX_NODES       8192
#define MAX_SIZE_NAME   256
#define MAX_SIZE_VALUE  8192

#define INF_SEEK_FIRST_CHAR_NAME    0
#define INF_SEEK_NAME               1
#define INF_SEEK_END_NAME           2
#define INF_SEEK_STR                3
#define INF_SEEK_END_STR            4
#define INF_SEEK_EOL                5

#define HT_SEEK_NAME                0
#define HT_SEEK_END_NAME            1

SUBST_NODE aNodes[MAX_NODES];
int cNodes = 0;

char achName[MAX_SIZE_NAME];
char achValue[MAX_SIZE_VALUE];


extern "C" int __cdecl
QsortStrCmp(
    const void *pA,
    const void *pB )
/*++

Routine Description:

    Compare two SUBST_NODE structures base on their pszName field

Arguments:

    pA - ptr to 1st struct
    pB - ptr to 2nd struct

Returns:

    -1 if *pA < *pB, 0 if *pA == *pB, 1 if *pA > *pB
    based on strcmp of their pszName field

--*/
{
    return strcmp( ((SUBST_NODE*)pA)->pszName, ((SUBST_NODE*)pB)->pszName );
}



BOOL
ParseINF(
    LPSTR pszInf
    )
/*++

Routine Description:

    Parse the .inf file for localizable string substitutions

Arguments:

    pszInf - name of .inf file

Returns:

    TRUE if success, FALSE if error

--*/
{
    BOOL fSt = TRUE;
    int ch;
    FILE *inf;

    if ( ( inf = fopen(pszInf, "r") ) == NULL )
    {
        return FALSE;
    }

    int iName = 0;
    int iValue = 0;
    BOOL fEsc;

    int iState = INF_SEEK_FIRST_CHAR_NAME;

    for ( ; (ch = fgetc( inf )) != EOF ; )
    {
        if ( ch == '\\' )
        {
            if ( (ch = fgetc( inf )) == EOF )
            {
                break;
            }
            if ( ch == '\n' )
            {
                continue;
            }
            if ( ch == 'n' )
            {
                ch = '\n';
            }
            fEsc = TRUE;
        }
        else
        {
            fEsc = FALSE;
        }

        switch ( iState )
        {
            case INF_SEEK_FIRST_CHAR_NAME:
                if ( !fEsc && ch == '#' )
                {
                    iState = INF_SEEK_EOL;
                    break;
                }
                iState = INF_SEEK_NAME;
                // fall-through

            case INF_SEEK_NAME:
                if ( !fEsc && ch == '^' )
                {
                    iState = INF_SEEK_END_NAME;
                }
                break;

            case INF_SEEK_END_NAME:
                if ( !fEsc && ch == '^' )
                {
                    iState = INF_SEEK_STR;
                }
                else
                {
                    achName[ iName++ ] = (char)ch;
                }
                break;

            case INF_SEEK_STR:
                if ( !fEsc && ch == '"' )
                {
                    iState = INF_SEEK_END_STR;
                }
                break;

            case INF_SEEK_END_STR:

                // handle "" as a single quote

                if ( !fEsc && ch == '"' )
                {
                    if ( (ch = fgetc( inf )) == EOF )
                    {
                        break;
                    }
                    if ( ch == '"' )
                    {
                        fEsc = TRUE;
                    }
                    else
                    {
                        ungetc( ch, inf );
                        ch = '"';
                    }
                }

                // skip new lines char in stream

                if ( !fEsc && ch == '\n' )
                {
                    break;
                }

                if ( !fEsc && ch == '"' )
                {
                    achName[ iName ] = '\0';
                    achValue[ iValue ] = '\0';
                    aNodes[ cNodes ].pszName = _strdup( achName );
                    aNodes[ cNodes ].pszValue = _strdup( achValue );
                    ++cNodes;
                    iState = INF_SEEK_FIRST_CHAR_NAME;
                    iName = 0;
                    iValue = 0;
                }
                else
                {
                    achValue[ iValue++ ] = (char)ch;
                }
                break;

            case INF_SEEK_EOL:
                if ( !fEsc && ch == '\n' )
                {
                    iState = INF_SEEK_FIRST_CHAR_NAME;
                }
                break;
        }
    }

    qsort( aNodes, cNodes, sizeof(SUBST_NODE), QsortStrCmp );

    fclose( inf );

    return fSt;
}


BOOL
ParseHTML(
    LPSTR pszIn,
    LPSTR pszOut
    )
/*++

Routine Description:

    Parse a HTML document and generate an output document
    based on a previously parsed .inf susbtitution file

Arguments:

    pszIn - name of input HTML document
    pszOut - name of created localized HTML document

Returns:

    TRUE if success, FALSE if error

--*/
{
    BOOL fSt = TRUE;
    int ch;
    FILE *in;
    FILE *out;

    if ( ( in = fopen(pszIn, "r") ) == NULL )
    {
        return FALSE;
    }
    if ( ( out = fopen(pszOut, "w") ) == NULL )
    {
        fclose( in );
        return FALSE;
    }

    int iName = 0;
    BOOL fEsc;

    int iState = HT_SEEK_NAME;

    for ( ; (ch = fgetc( in )) != EOF ; )
    {
        if ( ch == '\\' )
        {
            if ( (ch = fgetc( in )) == EOF )
            {
                break;
            }
            if ( ch == '\n' )
            {
                continue;
            }
            fEsc = TRUE;
        }
        else
        {
            fEsc = FALSE;
        }

        switch ( iState )
        {
            case HT_SEEK_NAME:
                if ( !fEsc && ch == '^' )
                {
                    iState = HT_SEEK_END_NAME;
                }
                else
                {
                    fputc( ch, out );
                }
                break;

            case HT_SEEK_END_NAME:
                if ( !fEsc && ch == '^' )
                {
                    SUBST_NODE snSeek;
                    SUBST_NODE *pN;
                    snSeek.pszName = achName;
                    achName[ iName ] = '\0';

                    if ( (pN = (SUBST_NODE*)bsearch( &snSeek,
                            aNodes,
                            cNodes,
                            sizeof(SUBST_NODE),
                            QsortStrCmp ))
                            != NULL )
                    {
                        fputs( pN->pszValue, out );
                    }
                    else
                    {
                        fprintf( stdout, "Can't find reference to %s in %s\n",
                            achName,
                            pszIn );
                        fflush( stdout );
                    }
                    iState = HT_SEEK_NAME;
                    iName = 0;
                }
                else
                {
                    achName[ iName++ ] = (char)ch;
                }
                break;
        }
    }

    fclose( in );
    fclose( out );

    return fSt;
}


BOOL
BreakPath(
    LPSTR pOut,
    LPSTR pExt,
    BOOL *pfIsExt
    )
/*++

Routine Description:

    Move a file extension from a file path to an extension buffer

Arguments:

    pOut - file path updated to remove file extension
    pExt - buffer for file extension
    pfIsExt - set to TRUE if file extension present

Returns:

    TRUE if success, FALSE if error

--*/
{
    // if ends with '\\' is directory
    // else extract extension

    LPSTR pL = pOut + strlen(pOut);
    LPSTR pE = NULL;

    if ( pL[-1] == '\\' )
    {
        *pfIsExt = FALSE;
        return TRUE;
    }

    while ( pL > pOut && pL[-1] != '\\' )
    {
        if ( pL[-1] == '.' && pE == NULL )
        {
            pE = pL;
        }
        --pL;
    }

    if ( pL == pOut )
    {
        return FALSE;
    }

    *pL = '\0';
    strcpy( pExt, pE );
    *pfIsExt = TRUE;

    return TRUE;
}


void
Usage(
    )
/*++

Routine Description:

    Display usage for this utility

Arguments:

    None

Returns:

    Nothing

--*/
{
    fprintf( stdout,
"\n"
"Usage: applyinf [source_file] [target_directory] [inf_file]\n"
"       source_file : can contains wild card characters\n"
"       target_directory : can contains a new extension to be\n"
"                          used, e.g. *.out\n"
"       inf_file : name of the .inf files containing replacement strings\n"
"\n" );
}


BOOL
Combine(
    LPSTR pOut,
    LPSTR pExt,
    BOOL fIsExt,
    LPSTR pFileName
    )
/*++

Routine Description:

    Combine file name & extension to a new file name

Arguments:

    pOut - output filename
    pExt - contains file extension if fIsExt is TRUE
    fIsExt - TRUE if pExt contains file extension
    pFileName - filename to be combined with extension to generare pOut

Returns:

    TRUE if success, FALSE if error

--*/
{
    LPSTR pL = pFileName + strlen(pFileName);


    if ( fIsExt )
    {
        while ( pL > pFileName && pL[-1] != '.' )
            --pL;

        if ( pL == pFileName )
        {
            // no ext in filename
            memcpy( pOut, pFileName, strlen(pFileName) );
            pOut += strlen(pFileName );
        }
        else
        {
            memcpy( pOut, pFileName, DIFF(pL - pFileName) - 1 );
            pOut += pL - pFileName - 1;
        }
        *pOut ++ = '.';
        strcpy( pOut, pExt );
    }
    else
    {
        strcpy( pOut, pFileName );
    }

    return TRUE;
}


int __cdecl
main(
    int argc,
    char *argv[]
    )
/*++

Routine Description:

    Entry point of this utility, parse command line

Arguments:

    argc - nbr of command line parameters
    argv - ptr to command line parameters

Returns:

    0 if success, else error code

--*/
{
    char achIn[MAX_PATH]="";
    char achOut[MAX_PATH]="";
    char achInf[MAX_PATH]="";
    char achExt[MAX_PATH];
    BOOL fIsExt;
    WIN32_FIND_DATA fdIn;
    HANDLE hF;
    int arg;
    int iN = 0;
    LPSTR pLastS;
    LPSTR pOut;

    for ( arg = 1 ; arg < argc ; ++arg )
    {
        if ( argv[arg][0] == '-' )
        {
            switch( argv[arg][1] )
            {
                case 'z':
                default:
                    ;
            }
        }
        else
        {
            switch ( iN )
            {
                case 0:
                    strcpy( achIn, argv[arg] );
                    break;

                case 1:
                    strcpy( achOut, argv[arg] );
                    break;

                case 2:
                    strcpy( achInf, argv[arg] );
                    break;
            }
            ++iN;
        }
    }

    if ( achIn[0] == '\0' )
    {
        fprintf( stdout, "No source directory specified\n" );
        fflush( stdout );
        Usage();
        return 3;
    }

    if ( achOut[0] == '\0' )
    {
        fprintf( stdout, "No target directory specified\n" );
        fflush( stdout );
        Usage();
        return 3;
    }

    if ( achInf[0] == '\0' )
    {
        fprintf( stdout, "No INF file specified\n" );
        fflush( stdout );
        Usage();
        return 3;
    }

    for ( pLastS = achIn + strlen(achIn) ; pLastS > achIn ; --pLastS )
    {
        if ( pLastS[-1] == '\\' )
        {
            break;
        }
    }

    if ( pLastS == achIn )
    {
        fprintf( stdout, "Invalid source directory : %s\n", achIn );
        fflush( stdout );
        return 5;
    }

    if ( !BreakPath( achOut, achExt, &fIsExt ) )
    {
        fprintf( stdout, "Invalid target directory : %s\n", achOut );
        fflush( stdout );
        return 6;
    }
    pOut = achOut + strlen( achOut );

    if ( !ParseINF( achInf ) )
    {
        fprintf( stdout, "Can't parse INF file %s\n", achInf );
        fflush( stdout );
        return 1;
    }

    // applyinf srcdir trgdirandext inffile
    // e.g. applyinf c:\nt\*.htr c:\drop\*.htm html.inf

    if ( (hF = FindFirstFile( achIn, &fdIn )) != INVALID_HANDLE_VALUE )
    {
        do {
            strcpy( pLastS, fdIn.cFileName );
            Combine( pOut, achExt, fIsExt, fdIn.cFileName );

            if ( !ParseHTML( achIn, achOut) )
            {
                fprintf( stdout, "Can't generate %s from %s\n", achOut, achIn );
                fflush( stdout );
                return 2;
            }
            else
            {
                fprintf( stdout, "Parsed %s to %s\n", achIn, achOut );
                fflush( stdout );
            }
        } while ( FindNextFile( hF, &fdIn ) );

        FindClose( hF );
    }
    else
    {
        fprintf( stdout, "No file found in %s", achIn );
        fflush( stdout );
        return 4;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\convlog\nocnvlin.c ===
#include "convlog.h"

// Process a line with no Format Conversion.

VOID
ProcessNoConvertLine(
    IN LPINLOGLINE lpLogLine,
    IN LPCSTR szInFileName,
    IN LPTSTR pszBuf,
    IN LPOUTFILESTATUS lpOutFile,
    BOOL *lpbNCFileOpen
    )
{

    if (!(*lpbNCFileOpen)) {
       lpOutFile->fpOutFile = StartNewOutputDumpLog (
                                lpOutFile,
                                szInFileName,
                                NoFormatConversion ? ".dns" : ".dmp"
                                );

       *lpbNCFileOpen=TRUE;
    }

    //
    // Print all fields of line
    //

    if ( NoFormatConversion ) {

        fprintf(lpOutFile->fpOutFile,"%s",pszBuf);
        nWebLineCount++;

    } else {

        fprintf(lpOutFile->fpOutFile,"%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s,\n",
            lpLogLine->szClientIP, lpLogLine->szUserName, lpLogLine->szDate, lpLogLine->szTime,
            lpLogLine->szService, lpLogLine->szServerName, lpLogLine->szServerIP, lpLogLine->szProcTime,
            lpLogLine->szBytesRec, lpLogLine->szBytesSent, lpLogLine->szServiceStatus, lpLogLine->szWin32Status,
            lpLogLine->szOperation, lpLogLine->szTargetURL, lpLogLine->szParameters);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\convlog\convlog.h ===
#if !defined CONVLOG_H
#define CONVLOG_H

#include <windows.h>
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <io.h>
#include <winsock2.h>
#include <strings.h>
#include <mbstring.h>           // Bug # 101690
#include <locale.h>

#define CONVLOG_BASE            (120)
#define NUM_SERVICES            (4)

#define DAILY                   (CONVLOG_BASE + 0)
#define MONTHLY                 (CONVLOG_BASE + 1)
#define ONE_BIG_FILE            (CONVLOG_BASE + 2)

#define NCSA                    (CONVLOG_BASE + 3)
#define NOFORMAT                (CONVLOG_BASE + 4)

#define ILLEGAL_COMMAND_LINE    (CONVLOG_BASE + 5)
#define COMMAND_LINE_OK         (CONVLOG_BASE + 6)
#define OUT_DIR_NOT_OK          (CONVLOG_BASE + 7)
#define ERROR_BAD_NONE          (CONVLOG_BASE + 8)


#define MAXWINSOCKVERSION       2

#define MAXASCIIIPLEN           16

#define ISWHITE( ch )       ((ch) == ' ' || (ch) == '\t' || (ch) == '\r' || (ch) == '\n')

#define MAXMACHINELEN   260

#define GREATEROF(p1,p2)      ((p1)>(p2)) ? (p1) : (p2)


typedef enum _DATEFORMATS {
    DateFormatUsa = 0,          // MM/DD/YY
    DateFormatJapan = 1,        // YY/MM/DD
    DateFormatGermany = 2,      // MM.DD.YY
    DateFormatMax

} DATEFORMAT;

typedef struct _HASHENTRY {
   ULONG uIPAddr;
   ULONG NextPtr;
   char     szMachineName[MAXMACHINELEN];
}  HASHENTRY, *PHASHENTRY;


typedef struct  _INLOGLINE
{
        DWORD   dwFieldMask;
        LPSTR   szClientIP;            //client ip address
        LPSTR   szUserName;            //client user name (not put in https log)
        LPSTR   szDate;                //date string in format DD/MM/YY
        LPSTR   szTime;                //time string in format HH:MM:SS 24 hour format
        LPSTR   szService;             //Service name (not put in https log)
        LPSTR   szServerName;          //netbios name of Server
        LPSTR   szServerIP;            //Server ip address
        LPSTR   szProcTime;            //time taken to process request (not put in https log)
        LPSTR   szBytesRec;            //number of bytes received (not put in https log)
        LPSTR   szBytesSent;           //number of bytes sent (not put in https log)
        LPSTR   szServiceStatus;       //HTTP status code (not put in https log)
        LPSTR   szWin32Status;         //win32 status code (not put in https log)
        LPSTR   szOperation;           //one of GET, POST, or HEAD
        LPSTR   szTargetURL;           //URL as requested by the client
        LPSTR   szUserAgent;           //only logged (by W3SVC) if NewLog.dll installed
        LPSTR   szReferer;             //only logged (by W3SVC) if NewLog.dll installed
        LPSTR   szParameters;          //any parameters passed with the URL
        LPSTR   szVersion;             //protocol version
} *LPINLOGLINE, INLOGLINE;


typedef struct  _DOSDATE
{
        WORD    wDOSDate;                       //holds the DOS Date packed word
        WORD    wDOSTime;                       //holds teh DOS Time packed word
} *LPDOSDATE, DOSDATE;

typedef struct _OUTFILESTATUS {
        FILE            *fpOutFile;
        CHAR            szLastDate[10];
        CHAR            szLastTime[10];
        CHAR            szOutFileName[MAX_PATH];
        CHAR            szTmpFileName[MAX_PATH];
        SYSTEMTIME      SystemTime;
        FILETIME        FileTime;
        DOSDATE         DosDate;
        CHAR            szAscTime[25];

} OUTFILESTATUS, *LPOUTFILESTATUS;

enum {
  GETLOG_SUCCESS = 0,
  GETLOG_ERROR,
  GETLOG_ERROR_PARSE_NCSA,
  GETLOG_ERROR_PARSE_MSINET,
  GETLOG_ERROR_PARSE_EXTENDED
};

char    * FindComma (char *);
char    * SkipWhite (char *);

DWORD
GetLogLine (
    FILE *,
    PCHAR szBuf,
    DWORD cbBuf,
    LPINLOGLINE
    );

WORD    DateStringToDOSDate(char *);
WORD    TimeStringToDOSTime(char *, LPWORD);
char    * SystemTimeToAscTime(LPSYSTEMTIME, char *);
char    * AscDay (WORD, char *);
char    * AscMonth (WORD, char *);

void    CombineFiles(LPTSTR, LPTSTR);
void    Usage (char*);
int     ParseArgs (int, char **);
char * FindChar (char *, char);

VOID
ProcessNoConvertLine(
    IN LPINLOGLINE lpLogLine,
    IN LPCSTR szInFileName,
    IN LPTSTR pszBuf,
    IN LPOUTFILESTATUS lpOutFile,
    BOOL *lpbNCFileOpen
    );

BOOL
ProcessWebLine(
        LPINLOGLINE,
        LPCSTR,
        LPOUTFILESTATUS
        );

VOID
printfids(
    DWORD ids,
    ...
    );

VOID InitHashTable (ULONG);
ULONG GetHashEntry();
ULONG GetElementFromCache(ULONG uIPAddr);
VOID AddEntryToCache(ULONG uIPAddr, char *szMachineName);
char *GetMachineName(char *szClientIP);
VOID PrintCacheTotals();

BOOL
InitDateStrings(
    VOID
    );

VOID
AddLocalMachineToCache(
    VOID
    );

FILE *
StartNewOutputDumpLog (
        IN LPOUTFILESTATUS  pOutFile,
        IN LPCSTR   pszInputFileName,
        IN LPCSTR   pszExt
        );

FILE *
StartNewOutputLog (
        IN LPOUTFILESTATUS  pOutFile,
        IN LPCSTR           pszInputFileName,
        IN PCHAR szDate
        );

//
// defines
//

#define LOGFILE_INVALID      0
#define LOGFILE_NCSA         2
#define LOGFILE_MSINET       3
#define LOGFILE_CUSTOM       4

#define NEW_DATETIME        "New"

//
// Globals
//

extern BOOL                 DoDNSConversion;
extern BOOL                 SaveFTPEntries;
extern CHAR                 FTPSaveFile[];
extern CHAR                 NCSAGMTOffset[];
extern DWORD                LogFileFormat;
extern CHAR                 InputFileName[];
extern CHAR                 OutputDir[];
extern CHAR                 TempDir[];
extern DWORD                nWebLineCount;
extern BOOL                 NoFormatConversion;
extern BOOL                ExtendedFieldsDefined;
extern CHAR                 szGlobalDate[];
extern DATEFORMAT           dwDateFormat;
extern BOOL                 bOnErrorContinue;

#endif //CONVLOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\convlog\caching.c ===
#include "convlog.h"

/*
This File implements caching of the mappings between ip addresses and machine names.


pHashTable:   An array of linked list headers which map directly to hash values, eg. the mapping for
an ipaddr is stored in the list with header pHashTable[GetHashVal(ipaddr)]

pHashEntries:   An array of HashEntry strucures. Each structure contains a mapping of ip address to machine name.

Algorithm:  A HashEntry structure is allocated each time an
entry is added to the cache. These are reused in circular fashion, eg. pHashEntries[0] is used first,
then pHashEntries[1], etc. When the ulNumHashEntries+1 entry is added to the cache, the entry currently
in pHashEntries[0] is discarded and pHashEntries[0] is reused. Hence the discard mechanism is
Least Recently Allocated. This is probably not as efficient  as Least Recently Used in terms of keeping
the most relevant entries in the cache. But it is more effiecient in terms of code speed, as there is no overhead
for keeping usage statistics or finding the least recently used entry.

All linked lists are kept in the reverse order of their allocation, that is, the most recently allocated is at the start
of the list. This allows for the most efficient allocation. It "should" also be efficient for lookup, but that could vary
on a per logfile basis.

All addressing of the pHashEntries array is currently done via array indices. At some point this should probably be
converted to use structure pointers, as that generates slightly more efficient code.
*/

#define HASHTABLELEN        2048

#define NOCACHEENTRY        0xFFFFFFFF

#define GetHashVal(p)       ((p) % HASHTABLELEN)

//This gets rid of the byte ordering dependency
#define BINARYIPTONUMERICIP(p1)   (ULONG) (((ULONG)p1[0] << 24) + ((ULONG)p1[1] << 16) + ((ULONG)p1[2] << 8) + ((ULONG)p1[3]))

ULONG   HashTable[HASHTABLELEN] = {0};

PHASHENTRY pHashEntries;

ULONG ulFreeListIndex = 0;

BOOL   bFreeElements = TRUE;

BOOL bCachingEnabled = FALSE;

ULONG ulCacheHits = 0;
ULONG ulCacheMisses = 0;

ULONG ulNumHashEntries;


VOID
InitHashTable(
    DWORD ulCacheSize
    )
{
    DWORD i;

    for (i = 0; i < HASHTABLELEN; i++) {
       HashTable[i] = NOCACHEENTRY;
    }

    ulNumHashEntries = ulCacheSize;
    while ((!bCachingEnabled) && (ulNumHashEntries >= 1000)) {

        pHashEntries = (PHASHENTRY)
            GlobalAlloc(GPTR, (sizeof(HASHENTRY) * ulNumHashEntries));

        if (NULL != pHashEntries) {
            bCachingEnabled = TRUE;
        } else {
            ulNumHashEntries /= 2;
        }
    }

    if (!bCachingEnabled) {
        printfids(IDS_CACHE_ERR);
    }

} // InitHashTable


ULONG
AllocHashEntry(
        VOID
        )
{
   ULONG i, ulCurHashVal;
   if (ulFreeListIndex == ulNumHashEntries) {
      ulFreeListIndex = 0;
      bFreeElements = FALSE;
   }
   if (!bFreeElements) {  // Use  this entry anyway, but free it first
      ulCurHashVal = GetHashVal(pHashEntries[ulFreeListIndex].uIPAddr);    //find hashtable entry
      if (HashTable[ulCurHashVal] == ulFreeListIndex) {
         HashTable[ulCurHashVal] = pHashEntries[ulFreeListIndex].NextPtr;       //Remove the entry from the table
      }
      else {
         for (i = HashTable[ulCurHashVal]; pHashEntries[i].NextPtr != ulFreeListIndex; i = pHashEntries[i].NextPtr)
            ;
         pHashEntries[i].NextPtr = pHashEntries[ulFreeListIndex].NextPtr;    //Remove the entry from the table
      }
   }

   return(ulFreeListIndex++);
}

ULONG GetElementFromCache(ULONG uIPAddr) {
   ULONG i = GetHashVal(uIPAddr);

   for (i =HashTable[i];(i != NOCACHEENTRY)&&(pHashEntries[i].uIPAddr != uIPAddr);i = pHashEntries[i].NextPtr)
      ;
   return(i);
}

VOID
AddEntryToCache(
        IN ULONG uIPAddr,
        IN PCHAR szMachineName
        )
{
   ULONG uHashEntry;
   ULONG uHashVal;
   char  *szTemp;

   uHashEntry=AllocHashEntry();
   uHashVal=GetHashVal(uIPAddr);

   pHashEntries[uHashEntry].uIPAddr = uIPAddr;
   if (strlen(szMachineName) < MAXMACHINELEN)
     szTemp = strcpy(pHashEntries[uHashEntry].szMachineName,szMachineName);
   else {
      szTemp = strncpy(pHashEntries[uHashEntry].szMachineName,szMachineName, (size_t)MAXMACHINELEN);
      pHashEntries[uHashEntry].szMachineName[MAXMACHINELEN - 1] = '\0';
   }
   pHashEntries[uHashEntry].NextPtr=HashTable[uHashVal];
   HashTable[uHashVal] = uHashEntry;
}

VOID
AddLocalMachineToCache(
    VOID
    )
{

    INT err;
    CHAR nameBuf[MAX_PATH+1];
    PHOSTENT    hostent;

    err = gethostname( nameBuf, sizeof(nameBuf));

    if ( err != 0 ) {
        return;
    }

    hostent = gethostbyname( nameBuf );
    if ( hostent == NULL ) {
        return;
    }

    AddEntryToCache(
            ((PIN_ADDR)hostent->h_addr_list[0])->s_addr,
            hostent->h_name
            );
    return;

} // AddLocalMachineToCache


PCHAR
GetMachineName(
    IN PCHAR szClientIP
    )
{
    IN_ADDR inaddr;
    PHOSTENT lpHostEnt;
    ULONG ulNumericIP;
    ULONG ulCurHashIndex;
    CHAR  tmpIP[64];
    PCHAR szReturnString = szClientIP;

    strcpy(tmpIP,szClientIP);
    FindChar(tmpIP,',');

    inaddr.s_addr = inet_addr(tmpIP);

    //
    // invalid IP
    //

    if ( inaddr.s_addr == INADDR_NONE ) {
        goto exit;
    }

    if (bCachingEnabled) {

        ulNumericIP = inaddr.s_addr;
        if ((ulCurHashIndex=GetElementFromCache(ulNumericIP)) == NOCACHEENTRY) {

            lpHostEnt = gethostbyaddr(
                                (char *)&inaddr, (int)4, (int)PF_INET);

            if (lpHostEnt != NULL) {
                szReturnString = lpHostEnt->h_name;
            }

            AddEntryToCache(ulNumericIP,szReturnString);
            ulCacheMisses++;
        } else {        //Entry is in cache
            szReturnString=pHashEntries[ulCurHashIndex].szMachineName;
            ulCacheHits++;
        }

    } else {     //Caching not enabled

        lpHostEnt = gethostbyaddr((char *)&inaddr, (int) 4, (int) PF_INET);
        if (lpHostEnt != NULL) {
            szReturnString = lpHostEnt->h_name;
        }
    }
exit:
    return(szReturnString);
}


#if DBG
VOID
PrintCacheTotals()
{
   if (bCachingEnabled) {

      DWORD dwTotal = ulCacheHits + ulCacheMisses;
      double dRatio;

      if ( ulCacheHits != 0 ) {
          dRatio = (double)ulCacheHits/(double)dwTotal;
      } else {
          dRatio = 0;
      }

      printfids(IDS_CACHE_HITS, ulCacheHits);
      printfids(IDS_CACHE_MISS, ulCacheMisses);
      printfids(IDS_CACHE_TOT, dRatio);
   }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\convlog\convlog.c ===
#include "convlog.h"
#include "inetcom.h"
#include "logtype.h"


//
// Current output file
//

OUTFILESTATUS       WebOutFile = {0};
OUTFILESTATUS       NoConvertOutFile = {0};

//
// Used for find first
//

WIN32_FIND_DATA     FindData = {0};

//
// struct for holding command line args
//

BOOL                DoDNSConversion = FALSE;
BOOL                SaveFTPEntries = FALSE;
BOOL                NoFormatConversion = FALSE;
CHAR                FTPSaveFile[MAX_PATH+1] = {0};
CHAR                NCSAGMTOffset[MAX_PATH+1] = {0};
DWORD               LogFileFormat = LOGFILE_INVALID;
CHAR                InputFileName[MAX_PATH+1] = {0};
CHAR                OutputDir[MAX_PATH+1] = {0};
CHAR                TempDir[MAX_PATH+1] = {0};
DWORD               nWebLineCount = 0;
DATEFORMAT          dwDateFormat = DateFormatUsa;
BOOL                bOnErrorContinue = FALSE;

//
// struct that holds log line items
//

INLOGLINE           InLogLine = {0};

int
__cdecl
main(
    int argc,
    char *argv[]
    )
{

    FILE                *fpInFile;                  //log File to open

    HANDLE              hFile;                      //Handle for FindFirstFile

    //
    // Buffer to hold log line
    //

    CHAR                szInBuf[MAX_LOG_RECORD_LEN+1];

    //
    // File mask to search for
    //

    CHAR                szFileMask[MAX_PATH+1];
    CHAR                szInfileName[MAX_PATH+1];
    CHAR                szWorkingDir[MAX_PATH+1];

    int                 nTotalWebCount = 0;

    BOOL                bWebFound = FALSE;          //did we find a web line?
    BOOL                bNoConvertFound = FALSE;    //did we find any NoConvert lines?
    BOOL                bRet;                       //used for testing returns
    DWORD               dwErr;                      //used to hold error codes
    int                 nLineCount = 0;             //number of lines read from input file
    int                 nTotalCount = 0;

    //int               nCount = 0;                 Bug # 101690
    CHAR                *pCh;

    DWORD               dwFieldMask;
    BOOL                fGetHeader;
    DWORD               nLinesDumped = 0;
    DWORD               dwGetLogLineResult;
    BOOL                bContinue;
    DWORD               dwCurrentLine;

    //
    // initialize data structure
    //

    setlocale(LC_ALL, ".ACP" );

    WebOutFile.fpOutFile = NULL;
    NoConvertOutFile.fpOutFile = NULL;

    ZeroMemory(szInBuf, sizeof(szInBuf));
    strcpy(OutputDir, ".\\");

    switch ( ParseArgs(argc, argv) ) {
        case ILLEGAL_COMMAND_LINE:
            Usage(argv[0]);
            return 0;

        case OUT_DIR_NOT_OK:
            printfids(IDS_BAD_DIR, OutputDir);
            return 0;

        case ERROR_BAD_NONE:
            printfids(IDS_BAD_NONE_ERR);
            return 0;

        case COMMAND_LINE_OK:
        break;
    }

    if ( DoDNSConversion ) {

        INT serr;
        WSADATA wsaData;

        if (serr = WSAStartup(MAKEWORD(2,0), &wsaData) != 0) {
            printfids(IDS_WINSOCK_ERR, serr);
            DoDNSConversion = FALSE;
        }
    }

    if ( (LogFileFormat == LOGFILE_NCSA) && !DoDNSConversion ) {
        printfids(IDS_NO_CONVERSION_NEEDED);
        return(0);
    }

    if ( !InitDateStrings() ) {
        printfids(IDS_BAD_DATESTRINGS);
    }

    if (DoDNSConversion) {

        InitHashTable(2000);
        AddLocalMachineToCache( );
    }

    strcpy (szWorkingDir, InputFileName);


    //  Bug # 101690
    //
    //  for (nCount = strlen(szWorkingDir) -1; nCount >= 0; nCount--) {
    //
    //      if ('\\' == szWorkingDir[nCount]) {
    //         szWorkingDir[nCount+1] = '\0';
    //            break;
    //      }
    //
    //  }

    //  if (nCount < 0) {
    //      strcpy (szWorkingDir, ".\\");
    //  }
    //

    pCh = _mbsrchr(szWorkingDir, '\\');

    if (pCh != NULL) {
        *(pCh+1) = '\0';
    } else {
        strcpy (szWorkingDir, ".\\");
    }


    strcpy(szFileMask, InputFileName);
    hFile = FindFirstFile (szFileMask, &FindData);

    if (INVALID_HANDLE_VALUE == hFile) {
        printfids(IDS_FILE_NONE, szFileMask);
        return(0);
    }

    do {

        if (!(FILE_ATTRIBUTE_DIRECTORY & FindData.dwFileAttributes)) {

            strcpy(szInfileName, szWorkingDir);
            strcat(szInfileName, FindData.cFileName);

            fpInFile = fopen(szInfileName, "r");
            printfids(IDS_FILE_OPEN, FindData.cFileName);

            nLineCount = 0;
            dwCurrentLine = 0;

            {
                //
                // Do file conversion
                //

                strcpy (WebOutFile.szLastDate, NEW_DATETIME);
                strcpy (WebOutFile.szLastTime, NEW_DATETIME);

                bWebFound = FALSE;
                nWebLineCount = 0;
                nLinesDumped = 0;

                ExtendedFieldsDefined = FALSE;
                szGlobalDate[0] = '\0';
            }

            fGetHeader = TRUE;
            bContinue = TRUE;

            while ((bContinue) && (!feof(fpInFile))) 
            {

                dwCurrentLine++;
                dwGetLogLineResult = GetLogLine( fpInFile, szInBuf, sizeof(szInBuf), &InLogLine);

                if (dwGetLogLineResult == GETLOG_SUCCESS) 
                {

                    nLineCount++;
                    if (DoDNSConversion) {

                        //
                        //Getting machine names could take days, so put out status messages
                        //

                        switch (nLineCount) {
                            case 25:
                            case 50:
                            case 100:
                            case 250:
                            case 500:
                                printfids(IDS_LINES_PROC, FindData.cFileName, nLineCount);
                                break;
                            default:
                                if ((nLineCount % 1000) == 0)
                                    printfids(IDS_LINES_PROC, FindData.cFileName, nLineCount);
                        }                               //end switch
                    }

                    //
                    // if NCSA and just DoDNS, do no convert
                    //

                    if ( NoFormatConversion ||

                          (_strnicmp(
                            InLogLine.szService,
                            "W3SVC",
                            strlen("W3SVC")) != 0) ) {

                        if ( NoFormatConversion || SaveFTPEntries ) {

                            ProcessNoConvertLine(
                                &InLogLine,
                                FindData.cFileName,
                                szInBuf,
                                &NoConvertOutFile,
                                &bNoConvertFound);
                        } else {
                            nLinesDumped++;
                        }

                    } else {
                        bWebFound = TRUE;
                        if (ProcessWebLine(
                                        &InLogLine,
                                        FindData.cFileName,
                                        &WebOutFile)) {

                            nWebLineCount++;
                        }
                    }
                }                                       //end if LogLineProcessed
                else
                {
                    if (dwGetLogLineResult != GETLOG_ERROR)
                    {
                        nLineCount++;
                    }

                    switch (dwGetLogLineResult) {
                        case GETLOG_ERROR_PARSE_NCSA:
                            printfids(IDS_FILE_NOT_NCSA,dwCurrentLine);
                            break;
                        case GETLOG_ERROR_PARSE_MSINET:
                            printfids(IDS_FILE_NOT_MSINET,dwCurrentLine);
                            break;
                        case GETLOG_ERROR_PARSE_EXTENDED:
                            printfids(IDS_BAD_EXTENDED_FORMAT,dwCurrentLine);
                            break;
                        default:
                            break;
                    }

                    if (!bOnErrorContinue)
                    {
                        bContinue = FALSE;
                    }
                }
            }                                           //end while !eof

            nTotalCount += nLineCount;

            if (fpInFile) {
                fclose(fpInFile);
            }

            if (bWebFound) {

                if (WebOutFile.fpOutFile != NULL ) {
                    fclose(WebOutFile.fpOutFile);
                    WebOutFile.fpOutFile = NULL;
                }

                bRet = MoveFileEx(
                            WebOutFile.szTmpFileName,
                            WebOutFile.szOutFileName,
                            MOVEFILE_COPY_ALLOWED);


                if (!bRet) {
                    dwErr = GetLastError();
                    switch (dwErr) {
                        case ERROR_FILE_EXISTS:
                        case ERROR_ALREADY_EXISTS:
                            CombineFiles(WebOutFile.szTmpFileName, WebOutFile.szOutFileName);
                            break;
                        case ERROR_PATH_NOT_FOUND:
                            break;
                        default:
                            printfids(IDS_FILE_ERR, dwErr);
                            return 1;
                    }
                }
            }

            if (bNoConvertFound) {

                bNoConvertFound = FALSE;

                if (NoConvertOutFile.fpOutFile != NULL) {
                    fclose(NoConvertOutFile.fpOutFile);
                    NoConvertOutFile.fpOutFile = NULL;
                }

                bRet = MoveFileEx(
                            NoConvertOutFile.szTmpFileName,
                            NoConvertOutFile.szOutFileName,
                            MOVEFILE_COPY_ALLOWED);

                if (!bRet) {
                    dwErr = GetLastError();
                    switch (dwErr) {

                        case ERROR_FILE_EXISTS:
                        case ERROR_ALREADY_EXISTS:
                            CombineFiles(NoConvertOutFile.szTmpFileName, NoConvertOutFile.szOutFileName);
                            break;
                        case ERROR_PATH_NOT_FOUND:
                            break;
                        default:
                            printfids(IDS_FILE_ERR, dwErr);
                            exit (1);
                            break;
                    }
                }
            }

            nTotalWebCount += nWebLineCount;
            printfids( IDS_LINES, FindData.cFileName, nLineCount);
            printfids (IDS_WEB_LINES, nWebLineCount);
            if ( nLinesDumped > 0 ) {
                printfids( IDS_DUMP_LINES, nLinesDumped );
                nLinesDumped = 0;
            }
        }

    } while (FindNextFile (hFile, &FindData));

    FindClose(hFile);

    printfids (IDS_TOTALS);
    printfids (IDS_TOT_LINES, nTotalCount);

    printfids (IDS_TOT_WEB_LINES, nTotalWebCount);

#if DBG
    PrintCacheTotals();
#endif

    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\convlog\parsearg.c ===
#include "convlog.h"

INT
ParseArgs (
    IN INT argc,
    IN PCHAR argv[]
    )
{

    INT     nCount;
    UINT    nIndex;
    CHAR    szTemp[MAX_PATH];

    //
    // Parse the command line and set flags for requested information
    // elements.  If parameters are incorrect or nonexistant, show usage.
    //

    if (argc > 1) {

        //
        // Get command line switches
        //

        for (nCount = 1; nCount < argc; nCount++) {

            PCHAR p;
            CHAR c;

            p=argv[nCount];
            if ((*p == '-') || (*p == '/')) {

                p++;
                c = *p;
                if (c == '\0') {
                    continue;
                }

                p++;
                switch (tolower(c)) { // Process switches

                    //  They specified the -s switch, cancel default
                    //  services to be processed.
                    //

                case 'i':

                    //
                    // Get input logfile type
                    //

                    if ( *p != '\0' ) {

                        switch (tolower(*p)) {
                        case 'i':
                            LogFileFormat = LOGFILE_MSINET;
                            break;

                        case 'n':
                            LogFileFormat = LOGFILE_NCSA;
                            NoFormatConversion = TRUE;
                            break;

                        case 'e':
                            LogFileFormat = LOGFILE_CUSTOM;
                            break;

                        default:
                            LogFileFormat = LOGFILE_INVALID;
                        }

                    } else {
                        return (ILLEGAL_COMMAND_LINE);
                    }
                    break;

                case 'l':

                    //
                    // Get date format/valid for MS INET Log only
                    //

                    if ( *p != '\0' ) {

                        switch (*p) {
                        case '0':
                            dwDateFormat = DateFormatUsa;
                            break;

                        case '1':
                            dwDateFormat = DateFormatJapan;
                            break;

                        case '2':
                            dwDateFormat = DateFormatGermany;
                            break;

                        default:
                            return (ILLEGAL_COMMAND_LINE);
                        }

                    } else {
                        return (ILLEGAL_COMMAND_LINE);
                    }
                    break;

                case 't':

                    if ((nCount+1) < argc) {

                        if ((*argv[nCount+1] != '-') &&
                            (*argv[nCount+1] != '/')) {

                            PCHAR pTmp;

                            strcpy(szTemp, argv[++nCount]);
                            pTmp = strstr(_strlwr(szTemp), "ncsa");

                            if (pTmp != NULL ) {

                                pTmp = strstr(szTemp, ":" );
                                if (NULL != pTmp ) {

                                    strncpy(NCSAGMTOffset,pTmp+1,6);

                                    if (strlen(NCSAGMTOffset) != 5) {
                                        return (ILLEGAL_COMMAND_LINE);
                                    }

                                    if (('+' != NCSAGMTOffset[0]) &&
                                        ('-' != NCSAGMTOffset[0])) {
                                        return (ILLEGAL_COMMAND_LINE);
                                    }
                                }
                            } else if (0 == _stricmp(szTemp, "none")) {
                                NoFormatConversion = TRUE;
                                DoDNSConversion = TRUE;
                            } else {
                                return (ILLEGAL_COMMAND_LINE);

                            }

                        } else {
                            return (ILLEGAL_COMMAND_LINE);
                        }
                    }

                    break;

                case 's':
                case 'f':

                    //
                    // Do nothing. For compatibility with old convlog versions.
                    //
                    break;

                case 'n':
                case 'd':

                    //
                    // doing NCSA dns convertion
                    //

                    DoDNSConversion = TRUE;
                    break;

                case 'x':

                    //
                    // doing NCSA dns convertion
                    //

                    SaveFTPEntries = TRUE;
                    break;

                case 'o':

                    //
                    // output directory
                    //

                    if ((nCount+1) < argc) {
                        if ((*argv[nCount+1] != '-') &&
                            (*argv[nCount+1] != '/')) {

                            strcpy(OutputDir, argv[++nCount]);

                            if (-1 == _access(OutputDir, 6)) {
                                return (OUT_DIR_NOT_OK);
                            }

                            if ('\\' != *CharPrev(OutputDir, &OutputDir[strlen(OutputDir)])) {
                                strcat(OutputDir, "\\");
                            }
                        }
                    } else {
                        return (ILLEGAL_COMMAND_LINE);
                    }
                    break;

                case 'c':

                    //
                    // on error, continue processing file  // WinSE 9148
                    //

                    bOnErrorContinue = TRUE;
                    break;

                default:
                    return(ILLEGAL_COMMAND_LINE);
                } //end switch
            } else {
                strcpy(InputFileName, argv[nCount]);
            }
        } //end for

        if ('\0' == InputFileName[0]) {
            return (ILLEGAL_COMMAND_LINE);
        }
    } else {
        return (ILLEGAL_COMMAND_LINE);
    }

    if ( LogFileFormat == LOGFILE_INVALID ) {
        return (ILLEGAL_COMMAND_LINE);
    }

    if ( NoFormatConversion &&
         ((LogFileFormat != LOGFILE_MSINET) &&
          (LogFileFormat != LOGFILE_NCSA)) ) {
        return (ERROR_BAD_NONE);
    }

    if (('\0' == NCSAGMTOffset[0])) {

        DWORD                   dwRet;
        INT                     nMinOffset;
        TIME_ZONE_INFORMATION   tzTimeZone;
        DWORD                   minutes;
        DWORD                   hours;
        LONG                    bias;

        dwRet = GetTimeZoneInformation (&tzTimeZone);

        if ( dwRet == 0xffffffff ) {

            bias = 0;
        } else {

            bias = tzTimeZone.Bias;

            //
            //!!! The old convlog always returns Bias
            // Let's comment out this one for now so that
            // we are compatible.
            //
#if 0
            switch (dwRet) {

            case TIME_ZONE_ID_STANDARD:
                if ( tzTimeZone.StandardDate.wMonth != 0 ) {
                    bias += tzTimeZone.StandardBias;
                }
                break;

            case TIME_ZONE_ID_DAYLIGHT:
                if ( tzTimeZone.DaylightDate.wMonth != 0 ) {
                    bias += tzTimeZone.DaylightBias;
                }
                break;

            case TIME_ZONE_ID_UNKNOWN:
            default:
                break;
            }
#endif
        }

        if ( bias > 0 ) {
            strcat(NCSAGMTOffset, "-");
        } else {
            strcat(NCSAGMTOffset, "+");
            bias *= -1;
        }

        hours = bias/60;
        minutes = bias % 60;

        sprintf (szTemp, "%02lu", hours);
        strcat (NCSAGMTOffset, szTemp);

        sprintf (szTemp, "%02lu", minutes);
        strcat (NCSAGMTOffset, szTemp);

        if ( LogFileFormat == LOGFILE_CUSTOM ) {
            strcpy(NCSAGMTOffset,"+0000");
        }
    }
    return COMMAND_LINE_OK;

} //end of ParseArgs
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\convlog\strings.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       strings.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    12-06-95  michth    Created
//
//----------------------------------------------------------------------------







#define IDS_BASE                        4000

#define IDS_HEADER1                     (IDS_BASE+1)
#define IDS_HEADER2                     (IDS_BASE+2)
#define IDS_HEADER3                     (IDS_BASE+3)
#define IDS_HEADER4                     (IDS_BASE+4)

#define IDS_USAGE1                      (IDS_BASE+11)
#define IDS_USAGE2                      (IDS_BASE+12)
#define IDS_USAGE3                      (IDS_BASE+13)
#define IDS_USAGE4                      (IDS_BASE+14)
#define IDS_USAGE5                      (IDS_BASE+15)
#define IDS_USAGE7                      (IDS_BASE+17)
#define IDS_USAGE8                      (IDS_BASE+18)
#define IDS_USAGE9                      (IDS_BASE+19)
#define IDS_USAGE10                     (IDS_BASE+20)
#define IDS_USAGE11                     (IDS_BASE+21)
#define IDS_USAGE12                     (IDS_BASE+22)
#define IDS_USAGE13                     (IDS_BASE+23)
#define IDS_USAGE14                     (IDS_BASE+24)
#define IDS_USAGE15                     (IDS_BASE+25)
#define IDS_USAGE16                     (IDS_BASE+26)

#define IDS_SAMPLE0                     (IDS_BASE+30)
#define IDS_SAMPLE1                     (IDS_BASE+31)
#define IDS_SAMPLE2                     (IDS_BASE+32)
#define IDS_SAMPLE3                     (IDS_BASE+33)
#define IDS_SAMPLE4                     (IDS_BASE+34)
#define IDS_SAMPLE5                     (IDS_BASE+35)
#define IDS_SAMPLE6                     (IDS_BASE+36)

#define IDS_TIME_ZONE1                  (IDS_BASE+50)
#define IDS_TIME_ZONE2                  (IDS_BASE+51)
#define IDS_LINES                       (IDS_BASE+52)
#define IDS_DUMP_LINES                  (IDS_BASE+53)
#define IDS_WEB_LINES                   (IDS_BASE+54)

#define IDS_TOTALS                      (IDS_BASE+55)
#define IDS_TOT_LINES                   (IDS_BASE+56)
#define IDS_TOT_FTP_LINES               (IDS_BASE+57)
#define IDS_TOT_WEB_LINES               (IDS_BASE+58)

#define IDS_CACHE_ERR                   (IDS_BASE+60)
#define IDS_CACHE_HITS                  (IDS_BASE+61)
#define IDS_CACHE_MISS                  (IDS_BASE+62)
#define IDS_CACHE_TOT                   (IDS_BASE+63)
#define IDS_LINES_PROC                  (IDS_BASE+64)
#define IDS_PREPROC                     (IDS_BASE+65)

#define IDS_LASTDATE                    (IDS_BASE+70)
#define IDS_LASTTIME                    (IDS_BASE+71)
#define IDS_NO_CONVERSION_NEEDED        (IDS_BASE+72)

#define IDS_ERROR                       4100
#define IDS_BAD_DIR                     (IDS_ERROR)
#define IDS_FILE_ERR                    (IDS_ERROR+1)
#define IDS_FILE_CLOSE                  (IDS_ERROR+2)
#define IDS_FILE_OPEN                   (IDS_ERROR+3)
#define IDS_FILE_WRITE                  (IDS_ERROR+4)
#define IDS_FILE_EXIST                  (IDS_ERROR+5)
#define IDS_FILE_NONE                   (IDS_ERROR+6)
#define IDS_FILE_NOT_MSINET             (IDS_ERROR+7)
#define IDS_FILE_NOT_NCSA               (IDS_ERROR+8)
#define IDS_BAD_NONE_ERR                (IDS_ERROR+9)
#define IDS_BAD_DATESTRINGS             (IDS_ERROR+10)
#define IDS_BAD_EXTENDED_FORMAT         (IDS_ERROR+11)

#define IDS_STRING_ERR                  (IDS_ERROR+20)
#define IDS_WINSOCK_ERR                 (IDS_ERROR+21)

#define IDS_MONTHS                      4200
#define IDS_JAN                         (IDS_MONTHS)
#define IDS_FEB                         (IDS_MONTHS+1)
#define IDS_MAR                         (IDS_MONTHS+2)
#define IDS_APR                         (IDS_MONTHS+3)
#define IDS_MAY                         (IDS_MONTHS+4)
#define IDS_JUN                         (IDS_MONTHS+5)
#define IDS_JUL                         (IDS_MONTHS+6)
#define IDS_AUG                         (IDS_MONTHS+7)
#define IDS_SEP                         (IDS_MONTHS+8)
#define IDS_OCT                         (IDS_MONTHS+9)
#define IDS_NOV                         (IDS_MONTHS+10)
#define IDS_DEC                         (IDS_MONTHS+11)
#define IDS_MON                         (IDS_MONTHS+12)
#define IDS_TUE                         (IDS_MONTHS+13)
#define IDS_WED                         (IDS_MONTHS+14)
#define IDS_THU                         (IDS_MONTHS+15)
#define IDS_FRI                         (IDS_MONTHS+16)
#define IDS_SAT                         (IDS_MONTHS+17)
#define IDS_SUN                         (IDS_MONTHS+18)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\convlog\tools.c ===
#include "convlog.h"
#include <logconst.h>

#define MAX_MONTH_SIZE  16

char szJan[MAX_MONTH_SIZE];
char szFeb[MAX_MONTH_SIZE];
char szMar[MAX_MONTH_SIZE];
char szApr[MAX_MONTH_SIZE];
char szMay[MAX_MONTH_SIZE];
char szJun[MAX_MONTH_SIZE];
char szJul[MAX_MONTH_SIZE];
char szAug[MAX_MONTH_SIZE];
char szSep[MAX_MONTH_SIZE];
char szOct[MAX_MONTH_SIZE];
char szNov[MAX_MONTH_SIZE];
char szDec[MAX_MONTH_SIZE];

//
// extended logging
//

DWORD   dwHostNamePos = 0;
DWORD   dwUserNamePos = 0;
DWORD   dwDatePos = 0;
DWORD   dwTimePos = 0;
DWORD   dwMethodPos = 0;
DWORD   dwURIStemPos = 0;
DWORD   dwURIQueryPos = 0;
DWORD   dwHTTPStatusPos = 0;
DWORD   dwBytesSentPos = 0;
DWORD   dwBytesRecvPos = 0;
DWORD   dwServicePos = 0;
DWORD   dwVersionPos = 0;
CHAR    szGlobalDate[32] = {0};
CHAR    szGlobalTime[32] = {0};
BOOL    ExtendedFieldsDefined = FALSE;

BOOL
InitDateStrings(
    VOID
    )
{
    HINSTANCE hInst = GetModuleHandle(NULL);

    if ( hInst == NULL ) {
        return(FALSE);
    }

    LoadString(hInst, IDS_JAN, szJan, sizeof(szJan));
    LoadString(hInst, IDS_FEB, szFeb, sizeof(szFeb));
    LoadString(hInst, IDS_MAR, szMar, sizeof(szMar));
    LoadString(hInst, IDS_APR, szApr, sizeof(szApr));
    LoadString(hInst, IDS_MAY, szMay, sizeof(szMay));
    LoadString(hInst, IDS_JUN, szJun, sizeof(szJun));
    LoadString(hInst, IDS_JUL, szJul, sizeof(szJul));
    LoadString(hInst, IDS_AUG, szAug, sizeof(szAug));
    LoadString(hInst, IDS_SEP, szSep, sizeof(szSep));
    LoadString(hInst, IDS_OCT, szOct, sizeof(szOct));
    LoadString(hInst, IDS_NOV, szNov, sizeof(szNov));
    LoadString(hInst, IDS_DEC, szDec, sizeof(szDec));

    return(TRUE);
}

PCHAR
FindChar(
    IN PCHAR    cp,
    IN CHAR     cTarget
    )

/*++
This procedure increments a character pointer until it finds a comma or the
NULL character.  if it finds a comma, it replaces it with a NULL and increments
the pointer.  if it finds a NULL, it merely returns without changing the character.
--*/
{
    while ((*cp != cTarget) && (*cp != '\0'))
        cp++;

    if (*cp == cTarget)
    {
        *cp = '\0';
        cp++;
        cp = SkipWhite(cp);
    }
    return (cp);
}


PCHAR
FindMSINETLogDelimChar( IN PCHAR cp )

/*++ 
This procedure increments a character pointer until it finds a comma+space or the
NULL character.  if it finds a comma+space, it replaces the comma with a NULL and increments
the pointer past the space.  if it finds a NULL, it merely returns without changing
the character.
--*/
    {
    while ( !(*cp == ',' && ISWHITE ( *(cp+1) ))  && (*cp != '\0') && (*cp != '\r') && (*cp != '\n'))
        {
        cp++;
        }
        
    if (*cp == ',')
        {
        *cp = '\0';
        cp++;
        cp = SkipWhite(cp);
        }
    else
        if ((*cp=='\r') || (*cp=='\n'))\
        {
            *cp = '\0';
        }
    
    return (cp);
    }

char * SkipWhite (char *cp)
{

    while (ISWHITE (*cp))
    {
        cp++;
    }
    return (cp);
}



#if 0
PCHAR
ConvertDate(
    IN LPTSTR pszDate
    )

/*++
Convert the date from "15/May/1995" to "5/15/95" format
--*/
{
    static char pszRetDate[100];
    char *cpCurrent = pszDate;

    int nMonth=1;
    int nDay=1;
    int nYear=90;

    nDay = atoi( cpCurrent );
    cpCurrent=FindChar(cpCurrent,'/');
    if ( strncmp(cpCurrent,szJan,3) == 0 )
    {
        nMonth = 1;
    } else if ( strncmp(cpCurrent,szFeb,3) == 0 )
    {
        nMonth = 2;
    } else if ( strncmp(cpCurrent,szMar,3) == 0 )
    {
        nMonth = 3;
    } else if ( strncmp(cpCurrent,szApr,3) == 0 )
    {
        nMonth = 4;
    } else if ( strncmp(cpCurrent,szMay,3) == 0 )
    {
        nMonth = 5;
    } else if ( strncmp(cpCurrent,szJun,3) == 0 )
    {
        nMonth = 6;
    } else if ( strncmp(cpCurrent,szJul,3) == 0 )
    {
        nMonth = 7;
    } else if ( strncmp(cpCurrent,szAug,3) == 0 )
    {
        nMonth = 8;
    } else if ( strncmp(cpCurrent,szSep,3) == 0 )
    {
        nMonth = 9;
    } else if ( strncmp(cpCurrent,szOct,3) == 0 )
    {
        nMonth = 10;
    } else if ( strncmp(cpCurrent,szNov,3) == 0 )
    {
        nMonth = 11;
    } else if ( strncmp(cpCurrent,szDec,3) == 0 )
    {
        nMonth = 12;
    }
    cpCurrent=FindChar(cpCurrent,'/');
    nYear = atoi( cpCurrent )%100;
    sprintf(pszRetDate,"%d/%d/%d",nMonth,nDay,nYear);
    return pszRetDate;
}
#endif

/* #pragma INTRINSA suppress=all */
DWORD
GetLogLine (
    IN FILE *fpInFile,
    IN PCHAR    szBuf,
    IN DWORD    cbBuf,
    IN LPINLOGLINE lpLogLine
    )
{
    BOOL    bRetCode = GETLOG_ERROR;
    CHAR    *cpCurrent;
    CHAR    buf[8*1024];

    static char szNULL[]="";
    static char szEmpty[]="-";
    static char szUnknownIP[] = "<UnknownIP>";
    static char szW3Svc[] = "W3Svc";
    static char szDefaultHTTPVersion[]="HTTP/1.0";

    lpLogLine->szClientIP = szNULL;
    lpLogLine->szUserName = szNULL;
    lpLogLine->szDate = szNULL;
    lpLogLine->szTime = szNULL;
    lpLogLine->szService = szNULL;
    lpLogLine->szServerName = szNULL;
    lpLogLine->szServerIP = szNULL;
    lpLogLine->szProcTime = szNULL;
    lpLogLine->szBytesRec = szNULL;
    lpLogLine->szBytesSent = szNULL;
    lpLogLine->szServiceStatus = szNULL;
    lpLogLine->szWin32Status = szNULL;
    lpLogLine->szOperation = szNULL;
    lpLogLine->szTargetURL = szNULL;
    lpLogLine->szUserAgent = szNULL;
    lpLogLine->szReferer = szNULL;
    lpLogLine->szParameters = szNULL;
    lpLogLine->szVersion = szDefaultHTTPVersion;

    if (NULL != fgets(szBuf, cbBuf, fpInFile)) {

        szBuf = SkipWhite(szBuf);
        
        if ((szBuf[0] != '\n') && ( szBuf[0] != '\0'))                             //is this an empty line? 
        {
            bRetCode = GETLOG_SUCCESS;

            //
            // set current char pointer to start of string
            //

            cpCurrent = szBuf;

            if ( LogFileFormat == LOGFILE_NCSA ) {
				              
                lpLogLine->szClientIP = szBuf;

                cpCurrent = FindChar(cpCurrent, ' ');
                
                lpLogLine->szClientIP = GetMachineName(lpLogLine->szClientIP);

                sprintf( buf,"%s %s",lpLogLine->szClientIP,cpCurrent);
                strcpy( szBuf, buf);

                // 
                // After the strcpy the pointers cpCurrent and lpLogLine->szClientIP have
                // the potential to be miss alligned if the dns name is shorter or longer than the IP 
                // address that it replaced. Simple fix reset the pointers to the beginning of the
                // string.
                //

               	lpLogLine->szClientIP = szBuf;
                cpCurrent = szBuf;
                             
        
                while ((*cpCurrent != '\0') && (*cpCurrent != '[') ) {
                    cpCurrent++;
                }

                if ( *cpCurrent == '\0' ) {
                    return(GETLOG_ERROR_PARSE_NCSA);
                }

            } else if (LogFileFormat == LOGFILE_MSINET ) {

                lpLogLine->szClientIP = szBuf;
                cpCurrent = FindMSINETLogDelimChar (cpCurrent);

                
                if (DoDNSConversion) {
                    lpLogLine->szClientIP = GetMachineName(
                                            lpLogLine->szClientIP
                                            );

                    if ( NoFormatConversion ) {
                        sprintf( buf,"%s, %s",lpLogLine->szClientIP,cpCurrent);
                        strcpy( szBuf, buf);
                        return(GETLOG_SUCCESS);
                    }
                }

                lpLogLine->szUserName = cpCurrent;
                cpCurrent = FindMSINETLogDelimChar (cpCurrent);

                lpLogLine->szDate = cpCurrent;
                cpCurrent = FindMSINETLogDelimChar (cpCurrent);

                lpLogLine->szTime = cpCurrent;
                cpCurrent = FindMSINETLogDelimChar (cpCurrent);

                lpLogLine->szService = cpCurrent;
                cpCurrent = FindMSINETLogDelimChar (cpCurrent);

                lpLogLine->szServerName = cpCurrent;
                cpCurrent = FindMSINETLogDelimChar (cpCurrent);

                lpLogLine->szServerIP = cpCurrent;
                cpCurrent = FindMSINETLogDelimChar (cpCurrent);

                lpLogLine->szProcTime = cpCurrent;
                cpCurrent = FindMSINETLogDelimChar (cpCurrent);

                lpLogLine->szBytesRec = cpCurrent;
                cpCurrent = FindMSINETLogDelimChar (cpCurrent);

                lpLogLine->szBytesSent = cpCurrent;
                cpCurrent = FindMSINETLogDelimChar (cpCurrent);

                lpLogLine->szServiceStatus = cpCurrent;
                cpCurrent = FindMSINETLogDelimChar (cpCurrent);

                lpLogLine->szWin32Status = cpCurrent;
                cpCurrent = FindMSINETLogDelimChar (cpCurrent);

                lpLogLine->szOperation = cpCurrent;
                cpCurrent = FindMSINETLogDelimChar (cpCurrent);

                lpLogLine->szTargetURL = cpCurrent;
                cpCurrent = FindMSINETLogDelimChar (cpCurrent);

                lpLogLine->szParameters = cpCurrent;
                cpCurrent = FindMSINETLogDelimChar (cpCurrent);

                if (lpLogLine->szClientIP[0] != '\0' &&
                   lpLogLine->szUserName[0] != '\0' &&
                   lpLogLine->szDate[0] != '\0' &&
                   lpLogLine->szTime[0] != '\0' &&
                   lpLogLine->szService[0] != '\0' &&
                   lpLogLine->szServerName[0] != '\0' &&
                   lpLogLine->szServerIP[0] != '\0' &&
                   lpLogLine->szProcTime[0] != '\0' &&
                   lpLogLine->szBytesRec[0] != '\0' &&
                   lpLogLine->szBytesSent[0] != '\0' &&
                   lpLogLine->szServiceStatus[0] != '\0' &&
                   lpLogLine->szWin32Status[0] != '\0' &&
                   lpLogLine->szOperation[0] != '\0' &&
                   lpLogLine->szTargetURL[0] != '\0' &&
                   lpLogLine->szParameters[0] != '\0'
                   ) {

                    bRetCode = GETLOG_SUCCESS;
                } else {
                    return(GETLOG_ERROR_PARSE_MSINET);
                }

            } else if ( LogFileFormat == LOGFILE_CUSTOM ) {

                //
                // W3C Extended Logging
                //

                if ( szBuf[0] == '#' ) {

                    PCHAR pszFields;
                    cpCurrent = FindChar(cpCurrent, '#');
                    bRetCode = GETLOG_SUCCESS;

                    if ( strncmp(cpCurrent, "Fields:", 7) == 0 ) {

                        DWORD pos;

                        //
                        // init positions
                        //

                        ExtendedFieldsDefined = TRUE;
                        dwHostNamePos = 0;
                        dwUserNamePos = 0;
                        dwDatePos = 0;
                        dwTimePos = 0;
                        dwMethodPos = 0;
                        dwURIStemPos = 0;
                        dwURIQueryPos = 0;
                        dwHTTPStatusPos = 0;
                        dwBytesSentPos = 0;
                        dwBytesRecvPos = 0;
                        dwServicePos = 0;
                        dwVersionPos = 0;

                        cpCurrent = FindChar(cpCurrent, ':');
                        (VOID)FindChar( cpCurrent, '\n' );

                        for (pos = 1; *cpCurrent != '\0'; pos++) {

                            PCHAR pszField = cpCurrent;
                            cpCurrent=FindChar(cpCurrent,' ');

                            if ( _stricmp( pszField, EXTLOG_CLIENT_IP_ID ) == 0 ) {
                                dwHostNamePos = pos;
                            } else if ( _stricmp( pszField, EXTLOG_USERNAME_ID ) == 0 ) {
                                dwUserNamePos = pos;
                            } else if ( _stricmp( pszField, EXTLOG_DATE_ID ) == 0 ) {
                                dwDatePos = pos;
                            } else if ( _stricmp( pszField, EXTLOG_TIME_ID ) == 0 ) {
                                dwTimePos = pos;
                            } else if ( _stricmp( pszField, EXTLOG_METHOD_ID ) == 0 ) {
                                dwMethodPos = pos;
                            } else if ( _stricmp( pszField, EXTLOG_URI_STEM_ID ) == 0 ) {
                                dwURIStemPos = pos;
                            } else if ( _stricmp( pszField, EXTLOG_URI_QUERY_ID ) == 0 ) {
                                dwURIQueryPos = pos;
                            } else if ( _stricmp( pszField, EXTLOG_HTTP_STATUS_ID ) == 0 ) {
                                dwHTTPStatusPos = pos;
                            } else if ( _stricmp( pszField, EXTLOG_BYTES_SENT_ID ) == 0 ) {
                                dwBytesSentPos = pos;
                            } else if ( _stricmp( pszField, EXTLOG_BYTES_RECV_ID ) == 0 ) {
                                dwBytesRecvPos = pos;
                            } else if ( _stricmp( pszField, EXTLOG_SITE_NAME_ID ) == 0 ) {
                                dwServicePos = pos;
                            } else if ( _stricmp( pszField, EXTLOG_PROTOCOL_VERSION_ID ) == 0 ) {
                                dwVersionPos = pos;
                            }
                        }
                    }

                    if ( strncmp(cpCurrent, "Date:", 5) == 0 ) {

                        //
                        // Grab the global date
                        //

                        cpCurrent = FindChar(cpCurrent, ':');

                        CopyMemory(szGlobalDate,cpCurrent, sizeof("2000-01-01") - 1);
                        szGlobalDate[10] = '\0';

                        //
                        // And the global time
                        //

                        cpCurrent = FindChar(cpCurrent, ' ');

                        CopyMemory(szGlobalTime,cpCurrent, sizeof("00:00:00") - 1);
                        szGlobalTime[8] = '\0';
                    }

                } else {

                    DWORD pos;
                    PCHAR pszValue;

                    if ( !ExtendedFieldsDefined ) {
                        return(GETLOG_ERROR_PARSE_EXTENDED);
                    }

                    //
                    // Need at least 1 valid entry in the log line other than date & time

                    if (    (dwHostNamePos  == 0)   &&
                            (dwUserNamePos  == 0)   &&
                            (dwMethodPos    == 0)   &&
                            (dwURIStemPos   == 0)   &&
                            (dwURIQueryPos  == 0)   &&
                            (dwHTTPStatusPos == 0)  &&
                            (dwBytesSentPos == 0)   && 
                            (dwBytesRecvPos == 0)   &&
                            (dwServicePos   == 0)   &&
                            (dwVersionPos   == 0)
                      )
                    {
                        return GETLOG_ERROR;
                    }

                    //
                    // loop through entries
                    //

                    lpLogLine->szClientIP = szEmpty;
                    lpLogLine->szUserName = szEmpty;
                    lpLogLine->szDate = szEmpty;
                    lpLogLine->szTime = szEmpty;
                    lpLogLine->szOperation = szEmpty;
                    lpLogLine->szTargetURL = szEmpty;
                    lpLogLine->szParameters = szEmpty;
                    lpLogLine->szServiceStatus = szEmpty;
                    lpLogLine->szBytesSent = szEmpty;
                    lpLogLine->szBytesRec = szEmpty;
                    lpLogLine->szService = szW3Svc;
                    lpLogLine->szVersion = szDefaultHTTPVersion;

                    (VOID)FindChar( cpCurrent, '\n' );
                    for (pos = 1;
                         *cpCurrent != '\0';
                         pos++) {

                        pszValue = cpCurrent;
                        cpCurrent = FindChar(cpCurrent,' ');

                        if ( pos == dwHostNamePos ) {
                            lpLogLine->szClientIP = pszValue;
                            if (DoDNSConversion) {
                                lpLogLine->szClientIP = GetMachineName(
                                                            lpLogLine->szClientIP
                                                            );
                            }
                        } else if (pos == dwUserNamePos) {

                            lpLogLine->szUserName = pszValue;
                        } else if (pos == dwDatePos) {

                            lpLogLine->szDate = pszValue;
                        } else if (pos == dwTimePos) {

                            lpLogLine->szTime = pszValue;
                        } else if (pos == dwMethodPos) {

                            lpLogLine->szOperation = pszValue;
                        } else if (pos == dwURIStemPos) {

                            lpLogLine->szTargetURL = pszValue;
                        } else if (pos == dwURIQueryPos) {

                            lpLogLine->szParameters = pszValue;
                        } else if (pos == dwHTTPStatusPos) {

                            lpLogLine->szServiceStatus = pszValue;
                        } else if (pos == dwBytesSentPos) {

                            lpLogLine->szBytesSent = pszValue;
                        } else if (pos == dwBytesRecvPos) {

                            lpLogLine->szBytesRec = pszValue;
                        } else if (pos == dwServicePos) {

                            lpLogLine->szService = pszValue;
                        } else if (pos == dwVersionPos) {

                            lpLogLine->szVersion = pszValue;
                        }
                    }

                    if ( lpLogLine->szDate == szEmpty ) {
                        lpLogLine->szDate = szGlobalDate;
                    }

                    if ( lpLogLine->szTime == szEmpty ) {
                        lpLogLine->szTime = szGlobalTime;
                    }

                    bRetCode = GETLOG_SUCCESS;
                }
            }
        }                                                   // end if first char = NewLine
    }                                                       // end if fgets != NULL

    return (bRetCode);
}


WORD
DateStringToDOSDate(
    IN PCHAR szDate
    )
{
    char    *szDay;
    char    *szMonth;
    char    *szYear;
    char    *cpCurrent;
    char    szTmpStr[20];
    int     iYear;

    if ( LogFileFormat == LOGFILE_CUSTOM ) {

        strcpy (szTmpStr, szDate);
        cpCurrent = szTmpStr;

        szYear = cpCurrent;
        cpCurrent = FindChar(cpCurrent,'-');

        szMonth = cpCurrent;
        cpCurrent = FindChar(cpCurrent,'-');

        szDay = cpCurrent;

        iYear=atoi(szYear);
        if ( iYear > 1980 ) {
            iYear -= 1980;
        }

    } else {

        strcpy (szTmpStr, szDate);
        cpCurrent = szTmpStr;

        if ( dwDateFormat == DateFormatJapan ) {
            // YY/MM/DD
            szYear = cpCurrent;
            cpCurrent = FindChar (cpCurrent, '/');

            szMonth = cpCurrent;
            cpCurrent = FindChar (cpCurrent, '/');

            szDay = cpCurrent;
        } else if (dwDateFormat == DateFormatGermany ) {

            // DD.MM.YY

            szDay = cpCurrent;
            cpCurrent = FindChar (cpCurrent, '.');

            szMonth = cpCurrent;
            cpCurrent = FindChar (cpCurrent, '.');

            szYear = cpCurrent;

        } else {
            // MM/DD/YY

            szMonth = cpCurrent;
            cpCurrent = FindChar (cpCurrent, '/');

            szDay = cpCurrent;
            cpCurrent = FindChar (cpCurrent, '/');

            szYear = cpCurrent;
        }

        iYear=atoi(szYear);

        if ( iYear < 80 ) {
            iYear += 2000;
        }

        if (iYear > 1980 ) {
            iYear = iYear - 1980;
        } else if (iYear >= 80 ) {
            iYear = iYear - 80;
        }
    }

    return ((iYear << 9) | (atoi(szMonth) << 5) | atoi(szDay));

} // DateStringToDOSDate



WORD
TimeStringToDOSTime(
    IN PCHAR szTime,
    IN LPWORD lpwSec
    )
{
    char    *cpCurrent;
    char    *szHour;
    char    *szMinute;
    char    *szSecond;
    char    szTmpStr[20];

    strcpy (szTmpStr, szTime);
    cpCurrent = szTmpStr;

    szHour = cpCurrent;
    cpCurrent = FindChar (cpCurrent, ':');

    szMinute = cpCurrent;
    cpCurrent = FindChar (cpCurrent, ':');

    szSecond = cpCurrent;
    *lpwSec = (WORD)atoi(szSecond);

    return ( (atoi(szHour) << 11) | (atoi(szMinute) << 5) | (atoi(szSecond) / 2));
}


char *
AscMonth (
    IN WORD wMonth,
    IN char *szMonth
    )
{
    switch (wMonth)
    {
        case 1:
            strncpy (szMonth, szJan, 3);
            break;
        case 2:
            strncpy (szMonth, szFeb, 3);
            break;
        case 3:
            strncpy (szMonth, szMar, 3);
            break;
        case 4:
            strncpy (szMonth, szApr, 3);
            break;
        case 5:
            strncpy (szMonth, szMay, 3);
            break;
        case 6:
            strncpy (szMonth, szJun, 3);
            break;
        case 7:
            strncpy (szMonth, szJul, 3);
            break;
        case 8:
            strncpy (szMonth, szAug, 3);
            break;
        case 9:
            strncpy (szMonth, szSep, 3);
            break;
        case 10:
            strncpy (szMonth, szOct, 3);
            break;
        case 11:
            strncpy (szMonth, szNov, 3);
            break;
        case 12:
            strncpy (szMonth, szDec, 3);
            break;
    }                                                       //end switch
    szMonth[3] = '\0';
    return (szMonth);
}                                                           //end AscMonth



FILE *
StartNewOutputLog (
        IN LPOUTFILESTATUS  pOutFile,
        IN LPCSTR   pszInFileName,
        IN PCHAR szDate
        )
{
    BOOL    bRet;
    DWORD   dwErr;

    if (pOutFile->fpOutFile != NULL ) {

        fclose(pOutFile->fpOutFile);
        pOutFile->fpOutFile = NULL;

        bRet = MoveFileEx(
                    pOutFile->szTmpFileName,
                    pOutFile->szOutFileName,
                    MOVEFILE_COPY_ALLOWED);

        if (!bRet) {

            dwErr = GetLastError();
            switch (dwErr)
            {
                case ERROR_FILE_EXISTS:
                case ERROR_ALREADY_EXISTS:
                    CombineFiles(
                            pOutFile->szTmpFileName,
                            pOutFile->szOutFileName);
                    break;
                case ERROR_PATH_NOT_FOUND:
                    break;
                default:
                    printfids(IDS_FILE_ERR, dwErr);
                    exit (1);
                    break;
            }
        }
        printfids(IDS_FILE_CLOSE, pOutFile->szOutFileName);
    }

    dwErr = GetTempPath(MAX_PATH, TempDir);

    if (0 != dwErr) {
        GetTempFileName(TempDir, "mhi", 0, pOutFile->szTmpFileName);
    } else {
        GetTempFileName(".", "mhi", 0, pOutFile->szTmpFileName);
    }

    pOutFile->fpOutFile = fopen(pOutFile->szTmpFileName, "w");

    sprintf(pOutFile->szOutFileName,
        "%s%s%s",
        OutputDir,
        pszInFileName,
        DoDNSConversion? ".ncsa.dns" : ".ncsa"
        );

    printfids (IDS_FILE_WRITE, pOutFile->szOutFileName);

    return (pOutFile->fpOutFile);

} // StartNewOutputLog



FILE *
StartNewOutputDumpLog (
        IN LPOUTFILESTATUS  pOutFile,
        IN LPCSTR   pszInputFileName,
        IN LPCSTR   pszExt
        )
{
    BOOL    bRet;
    DWORD   dwErr;

    dwErr = GetTempPath(MAX_PATH, TempDir);

    if (0 != dwErr) {
        GetTempFileName(TempDir, "mhi", 0, pOutFile->szTmpFileName);
    } else {
        GetTempFileName(".", "mhi", 0, pOutFile->szTmpFileName);
    }

    pOutFile->fpOutFile = fopen(pOutFile->szTmpFileName, "w");

    sprintf(pOutFile->szOutFileName,"%s%s%s",
                OutputDir, pszInputFileName,
                pszExt
                );

    printfids (IDS_FILE_WRITE, pOutFile->szOutFileName);
    return (pOutFile->fpOutFile);

} // StartNewOutputDumpLog


/* #pragma INTRINSA suppress=all */
VOID
CombineFiles(
    IN LPTSTR lpszNew,
    IN LPTSTR lpszExisting
    )
{
    FILE    *fpExisting;
    FILE    *fpNew;
    char    szLine[4096];

    printfids(IDS_FILE_EXIST, lpszExisting);
    fpNew = fopen(lpszNew, "r");
    fpExisting = fopen(lpszExisting, "a");

    fgets(szLine, sizeof(szLine), fpNew);
    // last line contains only EOF, but does not overwrite szLine.
    // It should not be written.
    while (!feof(fpNew))
    {
        fputs(szLine, fpExisting);
        fgets(szLine, sizeof(szLine), fpNew);
    }

    if (fpNew) {
        fclose(fpNew);
    }

    if (fpExisting) {
        fclose(fpExisting);
    }

    DeleteFile(lpszNew);
}


void
Usage(
    IN PCHAR szProg
    )
{
    CHAR    szTemp[MAX_PATH];

    GetTempPath(MAX_PATH, szTemp);

    printfids(IDS_HEADER1);
    printfids(IDS_HEADER2);
    printfids(IDS_HEADER3);
    printfids(IDS_HEADER4);

    printfids(IDS_USAGE1, szProg);
    printfids(IDS_USAGE2);
    printfids(IDS_USAGE3);
    printfids(IDS_USAGE4);
    printfids(IDS_USAGE5);
    printfids(IDS_USAGE7);
    printfids(IDS_USAGE8);
    printfids(IDS_USAGE9);
    printfids(IDS_USAGE10);
    printfids(IDS_USAGE11);
    printfids(IDS_USAGE12);
    printfids(IDS_USAGE13);
    printfids(IDS_USAGE14);
    printfids(IDS_USAGE15);
    printfids(IDS_USAGE16);

    printfids(IDS_SAMPLE0, szProg);
    printfids(IDS_SAMPLE1, szProg);
    printfids(IDS_SAMPLE2, szProg);
    printfids(IDS_SAMPLE3, szProg);
    return;
}


VOID
printfids(
    IN DWORD ids,
    ...
    )
{
    CHAR szBuff[2048];
    CHAR szString[2048];
    WCHAR szOutput[2048];
    va_list  argList;

    //
    //  Try and load the string
    //

    if ( !LoadString( GetModuleHandle( NULL ),
       ids,
       szString,
       sizeof( szString ) ))
    {
        printf( "Error loading string ID %d\n",
        ids );

        return;
    }

    va_start( argList, ids );
    vsprintf( szBuff, szString, argList );
    va_end( argList );

    MultiByteToWideChar( CP_ACP, 0, szBuff, -1, szOutput, sizeof(szOutput)/sizeof(WCHAR));
    
    WideCharToMultiByte( GetConsoleOutputCP(), 0, szOutput, wcslen(szOutput)+1,
        szBuff, sizeof(szBuff), NULL, NULL);

    printf(szBuff );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\addmime.cpp ===
// addmime.cpp : implementation file
//

#include "stdafx.h"
#include "ISAdmin.h"
#include "addmime.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAddMime dialog


CAddMime::CAddMime(CWnd* pParent /*=NULL*/)
	: CDialog(CAddMime::IDD, pParent)
{
	//{{AFX_DATA_INIT(CAddMime)
	m_strFileExtension = _T("");
	m_strGopherType = _T("");
	m_strImageFile = _T("");
	m_strMimeType = _T("");
	//}}AFX_DATA_INIT
}

void CAddMime::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAddMime)
	DDX_Text(pDX, IDC_ADDMIMEFILEEXTENSIONDATA1, m_strFileExtension);
	DDX_Text(pDX, IDC_ADDMIMEGOPHERTYPEDATA1, m_strGopherType);
	DDX_Text(pDX, IDC_ADDMIMEIMAGEFILEDATA1, m_strImageFile);
	DDX_Text(pDX, IDC_ADDMIMEMIMETYPEDATA1, m_strMimeType);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAddMime, CDialog)
	//{{AFX_MSG_MAP(CAddMime)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CAddMime message handlers

void CAddMime::OnOK() 
{
	// TODO: Add extra validation here
	
	CDialog::OnOK();
}
///////////////////////////////////////////////////////////////////////////
// Other Public Functions

	LPCTSTR CAddMime::GetFileExtension()
	{
	return (m_strFileExtension);
	}

	LPCTSTR CAddMime::GetGopherType()
	{
	return (m_strGopherType);
	}

	LPCTSTR CAddMime::GetImageFile()
	{
	return (m_strImageFile);
	}

	LPCTSTR CAddMime::GetMimeType()
	{
	return (m_strMimeType);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\htmla\htmlarc.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    htmlarc.h

Abstract:

    HTML administrator string resource IDs

Author:

    Philippe Choquier (phillich)    10-january-1996

--*/


#define IDS_HTRESP_OKANS            100
#define IDS_HTRESP_BAD_REQUEST      101
#define IDS_HTRESP_DENIED           102
#define IDS_HTRESP_FORBIDDEN        103
#define IDS_HTRESP_NOT_FOUND        104
#define IDS_HTRESP_SERVER_ERROR     105
#define IDS_HTRESP_NOT_SUPPORTED    106
#define IDS_HTRESP_REDIRECT         107
#define IDS_HTRESP_BAD_GATEWAY      108

#define IDS_HTRESPX_DENIED          200
#define IDS_HTRESPX_SERVER_ERROR    201
#define IDS_HTRESPX_DENIED_BODY     202
#define IDS_HTRESPX_NOT_FOUND       203
#define IDS_HTRESPX_NOT_FOUND_BODY  204
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\convlog\webline.c ===
#include "convlog.h"

BOOL
ProcessWebLine(
    IN LPINLOGLINE lpLogLine,
    IN LPCSTR      pszInFileName,
    IN LPOUTFILESTATUS lpOutFile
    )
{

    BOOL                    bLineOK = FALSE;                //function return code
    BOOL                    bDateChanged = FALSE;
    BOOL                    bTimeChanged = FALSE;
    char                    szMonth[4];
    char                    szDate[MAX_PATH];
    char                    szTime[MAX_PATH];
    static WORD             wSecond;						// Bug # 110921

    PCHAR   szBytes;

    //
    // NCSA Only
    //

    {
        bDateChanged = FALSE;
        bTimeChanged = FALSE;
        bLineOK = TRUE;

        if ( 0 != strcmp(lpOutFile->szLastDate, lpLogLine->szDate) ) {

            if (0 == strcmp(lpOutFile->szLastDate, NEW_DATETIME)) {

                lpOutFile->fpOutFile = StartNewOutputLog (
                                                lpOutFile,
                                                pszInFileName,
                                                lpLogLine->szDate
                                                );
            }

            strcpy(lpOutFile->szLastDate, lpLogLine->szDate);
            lpOutFile->DosDate.wDOSDate = DateStringToDOSDate(lpLogLine->szDate);
            bDateChanged = TRUE;
        }

        if (0 != strcmp(lpOutFile->szLastTime, lpLogLine->szTime))
        {
            strcpy(lpOutFile->szLastTime, lpLogLine->szTime);
            lpOutFile->DosDate.wDOSTime = TimeStringToDOSTime(lpLogLine->szTime, &wSecond);
            bTimeChanged = TRUE;
        }

        if (bDateChanged || bTimeChanged)
        {
            DosDateTimeToFileTime(lpOutFile->DosDate.wDOSDate, lpOutFile->DosDate.wDOSTime, &(lpOutFile->FileTime));
            FileTimeToSystemTime(&(lpOutFile->FileTime), &(lpOutFile->SystemTime));
            lpOutFile->SystemTime.wSecond = wSecond;
        }

        AscMonth (lpOutFile->SystemTime.wMonth, szMonth);

        //
        // Get bytes
        //

        if ( (_stricmp(lpLogLine->szOperation,"PUT") == 0) ||
             (_stricmp(lpLogLine->szOperation,"POST") == 0) ) {

            szBytes = lpLogLine->szBytesRec;
        } else {
            szBytes = lpLogLine->szBytesSent;
        }

        if ((0 != strcmp(lpLogLine->szParameters, " - ")) &&
           (0 != strcmp(lpLogLine->szParameters, "-,")) &&
           (0 != strcmp(lpLogLine->szParameters, "-")) &&
           (0 != strcmp(lpLogLine->szParameters, "")))
        {

            fprintf(lpOutFile->fpOutFile,"%s - %s [%02d/%s/%d:%02d:%02d:%02d %s] \"%s %s?%s %s\" %s %s\n",
            lpLogLine->szClientIP, lpLogLine->szUserName, lpOutFile->SystemTime.wDay,
            szMonth, lpOutFile->SystemTime.wYear, lpOutFile->SystemTime.wHour,
            lpOutFile->SystemTime.wMinute, lpOutFile->SystemTime.wSecond,
            NCSAGMTOffset, lpLogLine->szOperation,
            lpLogLine->szTargetURL, lpLogLine->szParameters, lpLogLine->szVersion,
            lpLogLine->szServiceStatus, szBytes);

        } else {

            fprintf(lpOutFile->fpOutFile, "%s - %s [%02d/%s/%d:%02d:%02d:%02d %s] \"%s %s %s\" %s %s\n",
            lpLogLine->szClientIP, lpLogLine->szUserName, lpOutFile->SystemTime.wDay,
            szMonth, lpOutFile->SystemTime.wYear, lpOutFile->SystemTime.wHour,
            lpOutFile->SystemTime.wMinute, lpOutFile->SystemTime.wSecond,
            NCSAGMTOffset, lpLogLine->szOperation,
            lpLogLine->szTargetURL, lpLogLine->szVersion, lpLogLine->szServiceStatus, szBytes);
        }
        //} //only process 200s
    }


    return (bLineOK);
}                                                           //end ProcessWebLine
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\addmime.h ===
// addmime.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CAddMime dialog

class CAddMime : public CDialog
{
// Construction
public:
	CAddMime(CWnd* pParent = NULL);   // standard constructor
// Dialog Data
	//{{AFX_DATA(CAddMime)
	enum { IDD = IDD_ADDMIMEMAPDIALOG };
	CString	m_strFileExtension;
	CString	m_strGopherType;
	CString	m_strImageFile;
	CString	m_strMimeType;
	//}}AFX_DATA

	LPCTSTR GetFileExtension();
	LPCTSTR GetGopherType();
	LPCTSTR GetImageFile();
	LPCTSTR GetMimeType();


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAddMime)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAddMime)
	virtual void OnOK();
	//}}AFX_MSG

	

	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\htmla\makefile.inc ===
iCPU=$(PROCESSOR_ARCHITECTURE)
APPLYINF=.\$(iCPU)\applyinf
htmll: scriptsl6\aexp.asp
    @-mkdir root\$(O)
    @-mkdir scripts\$(O)
    @-mkdir scripts6\$(O)
    $(APPLYINF) rootl\*.htm root\$(O)\*.htm scriptsl\htmla.inf
    $(APPLYINF) scriptsl\*.htr scripts\$(O)\*.htr scriptsl\htmla.inf
    $(APPLYINF) scriptsl6\*.asp scripts6\$(O)\*.asp scriptsl6\htmla.inf
!if "$(_NTTREE)" != ""
    copy scripts6\$(O)\aexp.asp $(_NTTREE)\inetsrv\aexp.asp
    copy scripts6\$(O)\aexp2.asp $(_NTTREE)\inetsrv\aexp2.asp
    copy scripts6\$(O)\aexp2b.asp $(_NTTREE)\inetsrv\aexp2b.asp
    copy scripts6\$(O)\achg.asp $(_NTTREE)\inetsrv\achg.asp
    copy scripts6\$(O)\anot.asp $(_NTTREE)\inetsrv\anot.asp
    copy scripts6\$(O)\anot3.asp $(_NTTREE)\inetsrv\anot3.asp
    copy scripts6\$(O)\aexp3.asp $(_NTTREE)\inetsrv\aexp3.asp
    copy scripts6\$(O)\aexp4.asp $(_NTTREE)\inetsrv\aexp4.asp
    copy scripts6\$(O)\aexp4b.asp $(_NTTREE)\inetsrv\aexp4b.asp
!endif

#    copy scripts\$(O)\aexp.htr $(_NTTREE)\inetsrv\aexp.htr
#    copy scripts\$(O)\aexp2.htr $(_NTTREE)\inetsrv\aexp2.htr
#    copy scripts\$(O)\aexp2b.htr $(_NTTREE)\inetsrv\aexp2b.htr
#    copy scripts\$(O)\achg.htr $(_NTTREE)\inetsrv\achg.htr
#    copy scripts\$(O)\anot.htr $(_NTTREE)\inetsrv\anot.htr
#    copy scripts\$(O)\anot3.htr $(_NTTREE)\inetsrv\anot3.htr
#    copy scripts\$(O)\aexp3.htr $(_NTTREE)\inetsrv\aexp3.htr
#    copy scripts\$(O)\aexp4.htr $(_NTTREE)\inetsrv\aexp4.htr
#    copy scripts\$(O)\aexp4b.htr $(_NTTREE)\inetsrv\aexp4b.htr

!ifdef LINKONLY
htmll:
!else
htmll:

!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\addscrip.cpp ===
// addscrip.cpp : implementation file
//

#include "stdafx.h"
#include "ISAdmin.h"
#include "addscrip.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAddScript dialog


CAddScript::CAddScript(CWnd* pParent /*=NULL*/)
	: CDialog(CAddScript::IDD, pParent)
{
	//{{AFX_DATA_INIT(CAddScript)
	m_strFileExtension = _T("");
	m_strScriptMap = _T("");
	//}}AFX_DATA_INIT
}


void CAddScript::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAddScript)
	DDX_Text(pDX, IDC_ADDSCRIPTFILEEXTENSIONDATA1, m_strFileExtension);
	DDX_Text(pDX, IDC_ADDSCRIPTMAPPINGDATA1, m_strScriptMap);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAddScript, CDialog)
	//{{AFX_MSG_MAP(CAddScript)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CAddScript message handlers

	LPCTSTR CAddScript::GetFileExtension()
	{
	return (m_strFileExtension);
	}

	LPCTSTR CAddScript::GetScriptMap()
	{
	return (m_strScriptMap);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\advcom1.h ===
// advcom1.h : header file
//

// Advanced Common Page

#define MAXPOOLTHREADSNAME	"MaxPoolThreads"
#define MINMAXPOOLTHREADS	0
#define	MAXMAXPOOLTHREADS	1000
#define DEFAULTMAXPOOLTHREADS	10

#define MAXCONCURRENCYNAME	"MaxConcurrency"
#define MINMAXCONCURRENCY	0
#define MAXMAXCONCURRENCY	32
#define DEFAULTMAXCONCURRENCY	0

#define THREADTIMEOUTNAME	"ThreadTimeout"
#define MINTHREADTIMEOUT	0
#define MAXTHREADTIMEOUT	0x7FFF						// Specify in minutes
#define DEFAULTTHREADTIMEOUT	(24 * 60 * 60)			// 24 hours

#define USEACCEPTEXNAME		"UseAcceptEX"
#define DEFAULTUSEACCEPTEX	TRUEVALUE

#define OBJECTCACHETTLNAME	"ObjectCacheTTL"
#define MINOBJECTCACHETTL	0
#define MAXOBJECTCACHETTL	0x7FFF 						//Specify in Minutes
#define DEFAULTOBJECTCACHETTL	(10 * 60)

#define USERTOKENTTLNAME	"UserTokenTTL"
#define MINUSERTOKENTTL	0
#define MAXUSERTOKENTTL	0x7FFF 						//Specify in Minutes
#define DEFAULTUSERTOKENTTL	(15 * 60)

#define ACCEPTEXOUTSTANDINGNAME	"AcceptExOutstanding"
#define MINACCEPTEXOUTSTANDING	0
#define MAXACCEPTEXOUTSTANDING	1000
#define	DEFAULTACCEPTEXOUTSTANDING	40

#define ACCEPTEXTIMEOUTNAME		"AcceptExTimeout"
#define MINACCEPTEXTIMEOUT	0
#define MAXACCEPTEXTIMEOUT	(60 * 60)					// 1 hour
#define DEFAULTACCEPTEXTIMEOUT	120

#define LOGFILEFLUSHINTERVALNAME	"LogFileFlushInterval"
#define MINLOGFILEFLUSHINTERVAL	1
#define MAXLOGFILEFLUSHINTERVAL	0x7FFF 						//Specify in Minutes
#define DEFAULTLOGFILEFLUSHINTERVAL	(5 * 60)

enum ADV_COMMON_NUM_REG_ENTRIES {
	 AdvComPage_MaxPoolThreads,
	 AdvComPage_MaxConcurrency,
	 AdvComPage_ThreadTimeout,
	 AdvComPage_UseAcceptEx,
	 AdvComPage_ObjectCacheTTL,
	 AdvComPage_UserTokenTTL,
	 AdvComPage_AcceptExOutstanding,
	 AdvComPage_AcceptExTimeout,
	 AdvComPage_LogFileFlushInterval,
	 AdvComPage_DebugFlags,
	 AdvComPage_TotalNumRegEntries
	 };

/////////////////////////////////////////////////////////////////////////////
// CADVCOM1 dialog

class CADVCOM1 : public CGenPage
{
	DECLARE_DYNCREATE(CADVCOM1)

// Construction
public:
	CADVCOM1();
	~CADVCOM1();

// Dialog Data
	//{{AFX_DATA(CADVCOM1)
	enum { IDD = IDD_ADVCOMSET1 };
	CSpinButtonCtrl	m_spinLogFileFlushInterval;
	CEdit	m_editLogFileFlushInterval;
	CButton	m_cboxUseLogFileFlushInterval;
	CSpinButtonCtrl	m_spinUserTokenTTL;
	CButton	m_cboxUseObjCacheTTL;
	CEdit	m_editObjCacheTTL;
	CEdit	m_editAcceptExTO;
	CEdit	m_editAcceptExOut;
	CEdit	m_editComDbgFlags;
	CButton	m_cboxUseAcceptEx;
	CSpinButtonCtrl	m_spinThreadTO;
	CSpinButtonCtrl	m_spinObjCache;
	CSpinButtonCtrl	m_spinMaxPool;
	CSpinButtonCtrl	m_spinMaxConcur;
	CSpinButtonCtrl	m_spinAcceptExTO;
	CSpinButtonCtrl	m_spinAcceptExOut;
	DWORD	m_ulComDbgFlags;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CADVCOM1)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual	void SaveInfo(void);
//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CADVCOM1)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeAcceptexoutdata1();
	afx_msg void OnChangeAcceptextodata1();
	afx_msg void OnChangeMaxconcurdata1();
	afx_msg void OnChangeMaxpooldata1();
	afx_msg void OnChangeObjcachedata1();
	afx_msg void OnChangeThreadtodata1();
	afx_msg void OnUseacceptexdata1();
	afx_msg void OnChangeComdbgflagsdata1();
	afx_msg void OnUseobjectcachettldata1();
	afx_msg void OnChangeUsertokenttldata1();
	afx_msg void OnUselogfileflushinternvaldata1();
	afx_msg void OnChangeLogfileflushintervaldata1();
	//}}AFX_MSG

	void  SetAcceptExEnabledState(void);
	void SetObjCacheTTLEnabledState(BOOL bEnabled);
	void SetLogFileFlushIntervalEnabledState(BOOL bEnabled);


	NUM_REG_ENTRY m_binNumericRegistryEntries[AdvComPage_TotalNumRegEntries];

	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\advcom1.cpp ===
// advcom1.cpp : implementation file
//

#include "stdafx.h"
#include "afxcmn.h"
#include "ISAdmin.h"
#include "advcom1.h"


#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CADVCOM1 dialog

IMPLEMENT_DYNCREATE(CADVCOM1, CGenPage)

CADVCOM1::CADVCOM1(): CGenPage(CADVCOM1::IDD)
{
	//{{AFX_DATA_INIT(CADVCOM1)
	//}}AFX_DATA_INIT
}

CADVCOM1::~CADVCOM1()
{
}

void CADVCOM1::DoDataExchange(CDataExchange* pDX)
{
	CGenPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CADVCOM1)
	DDX_Control(pDX, IDC_LOGFILEFLUSHINTERVALSPIN1, m_spinLogFileFlushInterval);
	DDX_Control(pDX, IDC_LOGFILEFLUSHINTERVALDATA1, m_editLogFileFlushInterval);
	DDX_Control(pDX, IDC_USELOGFILEFLUSHINTERNVALDATA1, m_cboxUseLogFileFlushInterval);
	DDX_Control(pDX, IDC_USERTOKENTTLSPIN1, m_spinUserTokenTTL);
	DDX_Control(pDX, IDC_USEOBJECTCACHETTLDATA1, m_cboxUseObjCacheTTL);
	DDX_Control(pDX, IDC_OBJCACHEDATA1, m_editObjCacheTTL);
	DDX_Control(pDX, IDC_ACCEPTEXTODATA1, m_editAcceptExTO);
	DDX_Control(pDX, IDC_ACCEPTEXOUTDATA1, m_editAcceptExOut);
	DDX_Control(pDX, IDC_COMDBGFLAGSDATA1, m_editComDbgFlags);
	DDX_Control(pDX, IDC_USEACCEPTEXDATA1, m_cboxUseAcceptEx);
	DDX_Control(pDX, IDC_THREADTOSPIN1, m_spinThreadTO);
	DDX_Control(pDX, IDC_OBJCACHESPIN1, m_spinObjCache);
	DDX_Control(pDX, IDC_MAXPOOLSPIN1, m_spinMaxPool);
	DDX_Control(pDX, IDC_MAXCONCURSPIN1, m_spinMaxConcur);
	DDX_Control(pDX, IDC_ACCEPTEXTOSPIN1, m_spinAcceptExTO);
	DDX_Control(pDX, IDC_ACCEPTEXOUTSPIN1, m_spinAcceptExOut);
	DDX_TexttoHex(pDX, IDC_COMDBGFLAGSDATA1, m_ulComDbgFlags);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CADVCOM1, CGenPage)
	//{{AFX_MSG_MAP(CADVCOM1)
	ON_EN_CHANGE(IDC_ACCEPTEXOUTDATA1, OnChangeAcceptexoutdata1)
	ON_EN_CHANGE(IDC_ACCEPTEXTODATA1, OnChangeAcceptextodata1)
	ON_EN_CHANGE(IDC_MAXCONCURDATA1, OnChangeMaxconcurdata1)
	ON_EN_CHANGE(IDC_MAXPOOLDATA1, OnChangeMaxpooldata1)
	ON_EN_CHANGE(IDC_OBJCACHEDATA1, OnChangeObjcachedata1)
	ON_EN_CHANGE(IDC_THREADTODATA1, OnChangeThreadtodata1)
	ON_BN_CLICKED(IDC_USEACCEPTEXDATA1, OnUseacceptexdata1)
	ON_EN_CHANGE(IDC_COMDBGFLAGSDATA1, OnChangeComdbgflagsdata1)
	ON_BN_CLICKED(IDC_USEOBJECTCACHETTLDATA1, OnUseobjectcachettldata1)
	ON_EN_CHANGE(IDC_USERTOKENTTLDATA1, OnChangeUsertokenttldata1)
	ON_BN_CLICKED(IDC_USELOGFILEFLUSHINTERNVALDATA1, OnUselogfileflushinternvaldata1)
	ON_EN_CHANGE(IDC_LOGFILEFLUSHINTERVALDATA1, OnChangeLogfileflushintervaldata1)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CADVCOM1 message handlers

BOOL CADVCOM1::OnInitDialog() 
{
	int i;
	CGenPage::OnInitDialog();

	for (i = 0; i < AdvComPage_TotalNumRegEntries; i++) {
	   m_binNumericRegistryEntries[i].bIsChanged = FALSE;
	   m_binNumericRegistryEntries[i].ulMultipleFactor = 1;
	   }
	
	m_binNumericRegistryEntries[AdvComPage_MaxPoolThreads].strFieldName = _T(MAXPOOLTHREADSNAME);	
	m_binNumericRegistryEntries[AdvComPage_MaxPoolThreads].ulDefaultValue = DEFAULTMAXPOOLTHREADS;

	m_binNumericRegistryEntries[AdvComPage_MaxConcurrency].strFieldName = _T(MAXCONCURRENCYNAME);	
	m_binNumericRegistryEntries[AdvComPage_MaxConcurrency].ulDefaultValue = DEFAULTMAXCONCURRENCY;

	m_binNumericRegistryEntries[AdvComPage_ThreadTimeout].strFieldName = _T(THREADTIMEOUTNAME);	
	m_binNumericRegistryEntries[AdvComPage_ThreadTimeout].ulDefaultValue = DEFAULTTHREADTIMEOUT;
	m_binNumericRegistryEntries[AdvComPage_ThreadTimeout].ulMultipleFactor = 60;

	m_binNumericRegistryEntries[AdvComPage_UseAcceptEx].strFieldName = _T(USEACCEPTEXNAME);	
	m_binNumericRegistryEntries[AdvComPage_UseAcceptEx].ulDefaultValue = DEFAULTUSEACCEPTEX;

	m_binNumericRegistryEntries[AdvComPage_ObjectCacheTTL].strFieldName = _T(OBJECTCACHETTLNAME);	
	m_binNumericRegistryEntries[AdvComPage_ObjectCacheTTL].ulDefaultValue = DEFAULTOBJECTCACHETTL;
	m_binNumericRegistryEntries[AdvComPage_ObjectCacheTTL].ulMultipleFactor = 60;

	m_binNumericRegistryEntries[AdvComPage_UserTokenTTL].strFieldName = _T(USERTOKENTTLNAME);	
	m_binNumericRegistryEntries[AdvComPage_UserTokenTTL].ulDefaultValue = DEFAULTUSERTOKENTTL;
	m_binNumericRegistryEntries[AdvComPage_UserTokenTTL].ulMultipleFactor = 60;


	m_binNumericRegistryEntries[AdvComPage_AcceptExOutstanding].strFieldName = _T(ACCEPTEXOUTSTANDINGNAME);	
	m_binNumericRegistryEntries[AdvComPage_AcceptExOutstanding].ulDefaultValue = DEFAULTACCEPTEXOUTSTANDING;

	m_binNumericRegistryEntries[AdvComPage_AcceptExTimeout].strFieldName = _T(ACCEPTEXTIMEOUTNAME);	
	m_binNumericRegistryEntries[AdvComPage_AcceptExTimeout].ulDefaultValue = DEFAULTACCEPTEXTIMEOUT;

	m_binNumericRegistryEntries[AdvComPage_LogFileFlushInterval].strFieldName = _T(LOGFILEFLUSHINTERVALNAME);	
	m_binNumericRegistryEntries[AdvComPage_LogFileFlushInterval].ulDefaultValue = DEFAULTLOGFILEFLUSHINTERVAL;
	m_binNumericRegistryEntries[AdvComPage_LogFileFlushInterval].ulMultipleFactor = 60;

	m_binNumericRegistryEntries[AdvComPage_DebugFlags].strFieldName = _T(DEBUGFLAGSNAME);	
	m_binNumericRegistryEntries[AdvComPage_DebugFlags].ulDefaultValue = DEFAULTDEBUGFLAGS;


	for (i = 0; i < AdvComPage_TotalNumRegEntries; i++) {
	   if (m_rkMainKey->QueryValue(m_binNumericRegistryEntries[i].strFieldName, 
	      m_binNumericRegistryEntries[i].ulFieldValue) != ERROR_SUCCESS) {
		  m_binNumericRegistryEntries[i].ulFieldValue = m_binNumericRegistryEntries[i].ulDefaultValue;
	   }
	}
   
	m_spinThreadTO.SetRange(MINTHREADTIMEOUT, MAXTHREADTIMEOUT);
	m_spinThreadTO.SetPos(LESSOROF ((m_binNumericRegistryEntries[AdvComPage_ThreadTimeout].ulFieldValue / 
	   m_binNumericRegistryEntries[AdvComPage_ThreadTimeout].ulMultipleFactor),MAXTHREADTIMEOUT));
	
	m_spinObjCache.SetRange(MINOBJECTCACHETTL, MAXOBJECTCACHETTL);
	if (m_binNumericRegistryEntries[AdvComPage_ObjectCacheTTL].ulFieldValue != 0xffffffff) {
	   m_spinObjCache.SetPos(LESSOROF ((m_binNumericRegistryEntries[AdvComPage_ObjectCacheTTL].ulFieldValue / 
	      m_binNumericRegistryEntries[AdvComPage_ObjectCacheTTL].ulMultipleFactor),MAXOBJECTCACHETTL));
	   SetObjCacheTTLEnabledState(TRUE);
	}
	else {
	   m_spinObjCache.SetPos(LESSOROF ((m_binNumericRegistryEntries[AdvComPage_ObjectCacheTTL].ulDefaultValue /
  	      m_binNumericRegistryEntries[AdvComPage_ObjectCacheTTL].ulMultipleFactor),MAXOBJECTCACHETTL));
	   SetObjCacheTTLEnabledState(FALSE);
	}

	m_spinUserTokenTTL.SetRange(MINUSERTOKENTTL, MAXUSERTOKENTTL);
	m_spinUserTokenTTL.SetPos(LESSOROF ((m_binNumericRegistryEntries[AdvComPage_UserTokenTTL].ulFieldValue / 
	   m_binNumericRegistryEntries[AdvComPage_UserTokenTTL].ulMultipleFactor),MAXUSERTOKENTTL));

	m_spinMaxPool.SetRange(MINMAXPOOLTHREADS,MAXMAXPOOLTHREADS);
	m_spinMaxPool.SetPos(LESSOROF ((m_binNumericRegistryEntries[AdvComPage_MaxPoolThreads].ulFieldValue / 
	   m_binNumericRegistryEntries[AdvComPage_MaxPoolThreads].ulMultipleFactor),MAXMAXPOOLTHREADS));
	
	m_spinMaxConcur.SetRange(MINMAXCONCURRENCY, MAXMAXCONCURRENCY);
	m_spinMaxConcur.SetPos(LESSOROF ((m_binNumericRegistryEntries[AdvComPage_MaxConcurrency].ulFieldValue / 
	   m_binNumericRegistryEntries[AdvComPage_MaxConcurrency].ulMultipleFactor), MAXMAXCONCURRENCY));
	
	m_spinAcceptExTO.SetRange(MINACCEPTEXTIMEOUT,MAXACCEPTEXTIMEOUT);
	m_spinAcceptExTO.SetPos(LESSOROF ((m_binNumericRegistryEntries[AdvComPage_AcceptExTimeout].ulFieldValue / 
	   m_binNumericRegistryEntries[AdvComPage_AcceptExTimeout].ulMultipleFactor),MAXACCEPTEXTIMEOUT));
	
	m_spinAcceptExOut.SetRange(MINACCEPTEXOUTSTANDING,MAXACCEPTEXOUTSTANDING);
	m_spinAcceptExOut.SetPos(LESSOROF ((m_binNumericRegistryEntries[AdvComPage_AcceptExOutstanding].ulFieldValue / 
	   m_binNumericRegistryEntries[AdvComPage_AcceptExOutstanding].ulMultipleFactor),MAXACCEPTEXOUTSTANDING));

	m_cboxUseAcceptEx.SetCheck(GETCHECKBOXVALUEFROMREG(m_binNumericRegistryEntries[AdvComPage_UseAcceptEx].ulFieldValue));
	SetAcceptExEnabledState();

	m_spinLogFileFlushInterval.SetRange(MINLOGFILEFLUSHINTERVAL, MAXLOGFILEFLUSHINTERVAL);
	if (m_binNumericRegistryEntries[AdvComPage_LogFileFlushInterval].ulFieldValue != 0xffffffff) {
	   m_spinLogFileFlushInterval.SetPos(LESSOROF ((m_binNumericRegistryEntries[AdvComPage_LogFileFlushInterval].ulFieldValue / 
	      m_binNumericRegistryEntries[AdvComPage_LogFileFlushInterval].ulMultipleFactor),MAXLOGFILEFLUSHINTERVAL));
	   SetLogFileFlushIntervalEnabledState(TRUE);
	}
	else {
	   m_spinObjCache.SetPos(LESSOROF ((m_binNumericRegistryEntries[AdvComPage_ObjectCacheTTL].ulDefaultValue /
  	      m_binNumericRegistryEntries[AdvComPage_ObjectCacheTTL].ulMultipleFactor),MAXOBJECTCACHETTL));
	   SetObjCacheTTLEnabledState(FALSE);
	}



	m_editComDbgFlags.LimitText(8);
	m_ulComDbgFlags = m_binNumericRegistryEntries[AdvComPage_DebugFlags].ulFieldValue;
	UpdateData(FALSE);		// Force Edit box(es) to pick up value(s)

	m_bSetChanged = TRUE;	// Any more changes come from the user

	// TODO: Add extra initialization here
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CADVCOM1::OnChangeAcceptexoutdata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[AdvComPage_AcceptExOutstanding].bIsChanged = TRUE;	
	   m_binNumericRegistryEntries[AdvComPage_AcceptExOutstanding].ulFieldValue = m_spinAcceptExOut.GetPos() 
	      * m_binNumericRegistryEntries[AdvComPage_AcceptExOutstanding].ulMultipleFactor;		

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
}

void CADVCOM1::OnChangeAcceptextodata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[AdvComPage_AcceptExTimeout].bIsChanged = TRUE;	
	   m_binNumericRegistryEntries[AdvComPage_AcceptExTimeout].ulFieldValue = m_spinAcceptExTO.GetPos() 
	      * m_binNumericRegistryEntries[AdvComPage_AcceptExTimeout].ulMultipleFactor;		

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
}

void CADVCOM1::OnChangeMaxconcurdata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[AdvComPage_MaxConcurrency].bIsChanged = TRUE;	
	   m_binNumericRegistryEntries[AdvComPage_MaxConcurrency].ulFieldValue = m_spinMaxConcur.GetPos() 
	      * m_binNumericRegistryEntries[AdvComPage_MaxConcurrency].ulMultipleFactor;		

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
}

void CADVCOM1::OnChangeMaxpooldata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[AdvComPage_MaxPoolThreads].bIsChanged = TRUE;	
	   m_binNumericRegistryEntries[AdvComPage_MaxPoolThreads].ulFieldValue = m_spinMaxPool.GetPos() 
	      * m_binNumericRegistryEntries[AdvComPage_MaxPoolThreads].ulMultipleFactor;		

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
	
}

void CADVCOM1::OnChangeObjcachedata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[AdvComPage_ObjectCacheTTL].bIsChanged = TRUE;	
	   m_binNumericRegistryEntries[AdvComPage_ObjectCacheTTL].ulFieldValue = m_spinObjCache.GetPos() 
	      * m_binNumericRegistryEntries[AdvComPage_ObjectCacheTTL].ulMultipleFactor;		

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
}

void CADVCOM1::OnUseobjectcachettldata1() 
{
	// TODO: Add your control notification handler code here
SetObjCacheTTLEnabledState(m_cboxUseObjCacheTTL.GetCheck());
if (m_bSetChanged) {
   m_binNumericRegistryEntries[AdvComPage_ObjectCacheTTL].bIsChanged = TRUE;	

   m_bIsDirty = TRUE;
   SetModified(TRUE);
   }

}


void CADVCOM1::OnChangeThreadtodata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[AdvComPage_ThreadTimeout].bIsChanged = TRUE;	
	   m_binNumericRegistryEntries[AdvComPage_ThreadTimeout].ulFieldValue = m_spinThreadTO.GetPos() 
	      * m_binNumericRegistryEntries[AdvComPage_ThreadTimeout].ulMultipleFactor;		

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
}

void CADVCOM1::OnUseacceptexdata1() 
{
	// TODO: Add your control notification handler code here
	SetAcceptExEnabledState();

	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[AdvComPage_UseAcceptEx].bIsChanged = TRUE;
	   
	   m_binNumericRegistryEntries[AdvComPage_UseAcceptEx].ulFieldValue = 
	      GETREGVALUEFROMCHECKBOX(m_cboxUseAcceptEx.GetCheck());

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
	
}

void CADVCOM1::OnChangeComdbgflagsdata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[AdvComPage_DebugFlags].bIsChanged = TRUE;
	   	   
	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
	
	
}

void CADVCOM1::OnChangeUsertokenttldata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[AdvComPage_UserTokenTTL].bIsChanged = TRUE;	
	   m_binNumericRegistryEntries[AdvComPage_UserTokenTTL].ulFieldValue = m_spinUserTokenTTL.GetPos() 
	      * m_binNumericRegistryEntries[AdvComPage_UserTokenTTL].ulMultipleFactor;		

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
}


void CADVCOM1::OnUselogfileflushinternvaldata1() 
{
	// TODO: Add your control notification handler code here
SetLogFileFlushIntervalEnabledState(m_cboxUseLogFileFlushInterval.GetCheck());
if (m_bSetChanged) {
   m_binNumericRegistryEntries[AdvComPage_LogFileFlushInterval].bIsChanged = TRUE;	

   m_bIsDirty = TRUE;
   SetModified(TRUE);
   }

}

void CADVCOM1::OnChangeLogfileflushintervaldata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[AdvComPage_LogFileFlushInterval].bIsChanged = TRUE;	
	   m_binNumericRegistryEntries[AdvComPage_LogFileFlushInterval].ulFieldValue = m_spinLogFileFlushInterval.GetPos() 
	      * m_binNumericRegistryEntries[AdvComPage_LogFileFlushInterval].ulMultipleFactor;		

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
}




//////////////////////////////////////////////////////////////////
// Other routines

void CADVCOM1::SaveInfo()
{

if (m_bIsDirty) {
   m_binNumericRegistryEntries[AdvComPage_DebugFlags].ulFieldValue = m_ulComDbgFlags;

   SaveNumericInfo(m_binNumericRegistryEntries, AdvComPage_TotalNumRegEntries);
}

CGenPage::SaveInfo();

}



void CADVCOM1::SetAcceptExEnabledState()
{
if (m_cboxUseAcceptEx.GetCheck() != 0) {
   m_spinAcceptExTO.EnableWindow(TRUE);
   m_editAcceptExTO.EnableWindow(TRUE);
   m_spinAcceptExOut.EnableWindow(TRUE);
   m_editAcceptExOut.EnableWindow(TRUE);
   if (m_bSetChanged) {		//if user enabled this, make sure there's a value there
	  m_binNumericRegistryEntries[AdvComPage_AcceptExTimeout].bIsChanged = TRUE;	
	  m_binNumericRegistryEntries[AdvComPage_AcceptExOutstanding].bIsChanged = TRUE;	
   }

}
else {
   m_spinAcceptExTO.EnableWindow(FALSE);
   m_editAcceptExTO.EnableWindow(FALSE);
   m_spinAcceptExOut.EnableWindow(FALSE);
   m_editAcceptExOut.EnableWindow(FALSE);
}
}

void CADVCOM1::SetObjCacheTTLEnabledState(BOOL bEnabled)
{
	if (bEnabled) {
	   m_binNumericRegistryEntries[AdvComPage_ObjectCacheTTL].ulFieldValue = 
	      m_spinObjCache.GetPos() * 
	      m_binNumericRegistryEntries[AdvComPage_ObjectCacheTTL].ulMultipleFactor;
	   m_cboxUseObjCacheTTL.SetCheck(CHECKEDVALUE);
	   m_spinObjCache.EnableWindow(TRUE);
	   m_editObjCacheTTL.EnableWindow(TRUE);
	}
	else {
	   m_binNumericRegistryEntries[AdvComPage_ObjectCacheTTL].ulFieldValue = 0xffffffff;
	   m_cboxUseObjCacheTTL.SetCheck(UNCHECKEDVALUE);
	   m_spinObjCache.EnableWindow(FALSE);
	   m_editObjCacheTTL.EnableWindow(FALSE);
	}
}	

void CADVCOM1::SetLogFileFlushIntervalEnabledState(BOOL bEnabled)
{
	if (bEnabled) {
	   m_binNumericRegistryEntries[AdvComPage_LogFileFlushInterval].ulFieldValue = 
	      m_spinLogFileFlushInterval.GetPos() * 
	      m_binNumericRegistryEntries[AdvComPage_LogFileFlushInterval].ulMultipleFactor;
	   m_cboxUseLogFileFlushInterval.SetCheck(CHECKEDVALUE);
	   m_spinLogFileFlushInterval.EnableWindow(TRUE);
	   m_editLogFileFlushInterval.EnableWindow(TRUE);
	}
	else {
	   m_binNumericRegistryEntries[AdvComPage_LogFileFlushInterval].ulFieldValue = 0xffffffff;
	   m_cboxUseLogFileFlushInterval.SetCheck(UNCHECKEDVALUE);
	   m_spinLogFileFlushInterval.EnableWindow(FALSE);
	   m_editLogFileFlushInterval.EnableWindow(FALSE);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\combut1.cpp ===
// combut1.cpp : implementation file
//

#include "stdafx.h"
#include "ISAdmin.h"
#include "combut1.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCOMBUT1

CCOMBUT1::CCOMBUT1()
{
}

CCOMBUT1::~CCOMBUT1()
{
}


BEGIN_MESSAGE_MAP(CCOMBUT1, CButton)
	//{{AFX_MSG_MAP(CCOMBUT1)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CCOMBUT1 message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\combut1.h ===
// combut1.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CCOMBUT1 window

class CCOMBUT1 : public CButton
{
// Construction
public:
	CCOMBUT1();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCOMBUT1)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CCOMBUT1();

	// Generated message map functions
protected:
	//{{AFX_MSG(CCOMBUT1)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\afximpl.h ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#undef AFX_DATA
#define AFX_DATA AFX_CORE_DATA

/////////////////////////////////////////////////////////////////////////////
// Auxiliary System/Screen metrics

struct AUX_DATA
{
	// system metrics
	int cxVScroll, cyHScroll;
	int cxIcon, cyIcon;

	int cxBorder2, cyBorder2;

	// device metrics for screen
	int cxPixelsPerInch, cyPixelsPerInch;
	int cySysFont;

	// solid brushes with convenient gray colors and system colors
	HBRUSH hbrLtGray, hbrDkGray;
	HBRUSH hbrBtnHilite, hbrBtnFace, hbrBtnShadow;
	HBRUSH hbrWindowFrame;
	HPEN hpenBtnHilite, hpenBtnShadow, hpenBtnText;

	// color values of system colors used for CToolBar
	COLORREF clrBtnFace, clrBtnShadow, clrBtnHilite;
	COLORREF clrBtnText, clrWindowFrame;

	// standard cursors
	HCURSOR hcurWait;
	HCURSOR hcurArrow;
	HCURSOR hcurHelp;       // cursor used in Shift+F1 help

	// special GDI objects allocated on demand
	HFONT   hStatusFont;
	HFONT   hToolTipsFont;
	HBITMAP hbmMenuDot;

	// other system information
	UINT    nWinVer;        // Major.Minor version numbers
	BOOL	bWin32s;		// TRUE if Win32s (or Windows 95)
	BOOL    bWin4;          // TRUE if Windows 4.0
	BOOL    bNotWin4;       // TRUE if not Windows 4.0
	BOOL    bSmCaption;     // TRUE if WS_EX_SMCAPTION is supported
	BOOL	bWin31; 		// TRUE if actually Win32s on Windows 3.1
	BOOL	bMarked4;		// TRUE if marked as 4.0

	// special Windows API entry points
	int (WINAPI* pfnSetScrollInfo)(HWND, int, LPCSCROLLINFO, BOOL);
	BOOL (WINAPI* pfnGetScrollInfo)(HWND, int, LPSCROLLINFO);

// Implementation
	AUX_DATA();
	~AUX_DATA();
	void UpdateSysColors();
	void UpdateSysMetrics();
};

extern AFX_DATA AUX_DATA afxData;

////////////////////////////////////////////////////////////////////////////
// other global state

#ifdef _WINDLL
	extern DWORD _afxAppTlsIndex;
	extern AFX_APP_STATE* _afxAppState;
#endif
extern DWORD _afxThreadTlsIndex;

// Note: afxData.cxBorder and afxData.cyBorder aren't used anymore
#define CX_BORDER   1
#define CY_BORDER   1

// states for Shift+F1 hep mode
#define HELP_INACTIVE   0   // not in Shift+F1 help mode (must be 0)
#define HELP_ACTIVE     1   // in Shift+F1 help mode (non-zero)
#define HELP_ENTERING   2   // entering Shift+F1 help mode (non-zero)

/////////////////////////////////////////////////////////////////////////////
// Window class names and other window creation support

// from wincore.cpp
extern const TCHAR _afxWnd[];           // simple child windows/controls
extern const TCHAR _afxWndControlBar[]; // controls with grey backgrounds
extern const TCHAR _afxWndMDIFrame[];
extern const TCHAR _afxWndFrameOrView[];

INT_PTR CALLBACK AfxDlgProc(HWND, UINT, WPARAM, LPARAM);
UINT_PTR CALLBACK _AfxCommDlgProc(HWND hWnd, UINT, WPARAM, LPARAM);

// Support for standard dialogs
extern const UINT _afxNMsgSETRGB;
typedef UINT_PTR (CALLBACK* COMMDLGPROC)(HWND, UINT, WPARAM, LPARAM);

/////////////////////////////////////////////////////////////////////////////
// Special helpers

HWND AFXAPI AfxGetSafeOwner(CWnd* pParent, HWND* phTopLevel = NULL);
void AFXAPI AfxCancelModes(HWND hWndRcvr);
HWND AFXAPI AfxGetParentOwner(HWND hWnd);
BOOL AFXAPI AfxIsDescendant(HWND hWndParent, HWND hWndChild);
BOOL AFXAPI AfxHelpEnabled();  // determine if ID_HELP handler exists
void AFXAPI AfxDeleteObject(HGDIOBJ* pObject);
BOOL AFXAPI AfxCustomLogFont(UINT nIDS, LOGFONT* pLogFont);

BOOL AFXAPI _AfxIsComboBoxControl(HWND hWnd, UINT nStyle);
BOOL AFXAPI _AfxCheckCenterDialog(LPCTSTR lpszResource);

#ifdef _MAC
BOOL AFXAPI _AfxIdenticalRect(LPCRECT lpRectOne, LPCRECT lpRectTwo);
#else
#define _AfxIdenticalRect EqualRect
#endif

// UNICODE/MBCS abstractions
#ifdef _MBCS
	extern const BOOL _afxDBCS;
#else
	#define _afxDBCS FALSE
#endif

// determine number of elements in an array (not bytes)
#define _countof(array) (sizeof(array)/sizeof(array[0]))

//#define UNUSED  // usage: UNUSED formal_arg

/////////////////////////////////////////////////////////////////////////////
// useful message ranges

#define WM_SYSKEYFIRST  WM_SYSKEYDOWN
#define WM_SYSKEYLAST   WM_SYSDEADCHAR

#define WM_NCMOUSEFIRST WM_NCMOUSEMOVE
#define WM_NCMOUSELAST  WM_NCMBUTTONDBLCLK

/////////////////////////////////////////////////////////////////////////////
// AFX_CRITICAL_SECTION

#pragma warning(disable: 4097)

class AFX_CRITICAL_SECTION : public CRITICAL_SECTION
{
// Constructors & Operations
public:
	AFX_CRITICAL_SECTION();

// Attributes
	operator CRITICAL_SECTION*();

// Implementation
public:
	~AFX_CRITICAL_SECTION();

private:
	// no implementation (CRITICAL_SECTION objects cannot be copied)
	AFX_CRITICAL_SECTION(const AFX_CRITICAL_SECTION&);
	void operator=(const AFX_CRITICAL_SECTION&);
};

inline AFX_CRITICAL_SECTION::AFX_CRITICAL_SECTION()
	{ ::InitializeCriticalSection(this); }
inline AFX_CRITICAL_SECTION::operator CRITICAL_SECTION*()
	{ return (CRITICAL_SECTION*)this; }
inline AFX_CRITICAL_SECTION::~AFX_CRITICAL_SECTION()
	{ ::DeleteCriticalSection(this); }

#pragma warning(default: 4097)

// global critical section for general thread safe access
extern AFX_DATA AFX_CRITICAL_SECTION _afxCriticalSection;

/////////////////////////////////////////////////////////////////////////////
// Portability abstractions

#define _AfxSetDlgCtrlID(hWnd, nID)     SetWindowLong(hWnd, GWL_ID, nID)
#define _AfxGetDlgCtrlID(hWnd)          ((UINT)(WORD)::GetDlgCtrlID(hWnd))

// misc helpers
BOOL AFXAPI AfxFullPath(LPTSTR lpszPathOut, LPCTSTR lpszFileIn);
BOOL AFXAPI AfxComparePath(LPCTSTR lpszPath1, LPCTSTR lpszPath2);
UINT AFXAPI AfxGetFileTitle(LPCTSTR lpszPathName, LPTSTR lpszTitle, UINT nMax);
UINT AFXAPI AfxGetFileName(LPCTSTR lpszPathName, LPTSTR lpszTitle, UINT nMax);
#ifdef _MAC
#define AfxGetFileName AfxGetFileTitle
#endif

const AFX_MSGMAP_ENTRY* AFXAPI
AfxFindMessageEntry(const AFX_MSGMAP_ENTRY* lpEntry,
	UINT nMsg, UINT nCode, UINT nID);

#define NULL_TLS ((DWORD)-1)

/////////////////////////////////////////////////////////////////////////////
// Debugging/Tracing helpers

#ifdef _DEBUG
	void AFXAPI _AfxTraceMsg(LPCTSTR lpszPrefix, const MSG* pMsg);
	BOOL AFXAPI _AfxCheckDialogTemplate(LPCTSTR lpszResource,
		BOOL bInvisibleChild);
#endif

/////////////////////////////////////////////////////////////////////////////
// Win4 specific defines

#if (WINVER < 0x400)

// new window styles
#define WS_EX_SMCAPTION         0x00000080L
#define WS_EX_WINDOWEDGE        0x00000100L
#define WS_EX_CLIENTEDGE        0x00000200L

// new dialog styles
#define DS_3DLOOK               0x00000004L

// new scroll bar styles
#define SBS_SIZEGRIP            0x00000010L

// new common dialog flags
#define OFN_EXPLORER            0x00080000L

// new color metrics
#define COLOR_INFOTEXT			23
#define COLOR_INFOBK			24

#endif //(WINVER < 0x400)

#ifndef WS_EX_SMCAPTION
#define WS_EX_SMCAPTION WS_EX_TOOLWINDOW
#endif

#ifndef WM_DISPLAYCHANGE
#define WM_DISPLAYCHANGE		0x007E
#endif

/////////////////////////////////////////////////////////////////////////////
// Macintosh-specific declarations

#ifdef _MAC
#include <macname1.h>
#include <Types.h>
#include <QuickDraw.h>
#include <AppleEvents.h>
#include <macname2.h>

extern AEEventHandlerUPP _afxPfnOpenApp;
extern AEEventHandlerUPP _afxPfnOpenDoc;
extern AEEventHandlerUPP _afxPfnPrintDoc;
extern AEEventHandlerUPP _afxPfnQuit;

OSErr PASCAL _AfxOpenAppHandler(AppleEvent* pae, AppleEvent* paeReply, long lRefcon);
OSErr PASCAL _AfxOpenDocHandler(AppleEvent* pae, AppleEvent* paeReply, long lRefcon);
OSErr PASCAL _AfxPrintDocHandler(AppleEvent* pae, AppleEvent* paeReply, long lRefcon);
OSErr PASCAL _AfxQuitHandler(AppleEvent* pae, AppleEvent* paeReply, long lRefcon);

void AFXAPI _AfxStripDialogCaption(HINSTANCE hInst, LPCTSTR lpszResource);

GDHandle AFXAPI _AfxFindDevice(int x, int y);
BOOL AFXAPI AfxCheckMonochrome(const RECT* pRect);
HFONT AFXAPI _AfxGetHelpFont();

#endif //_MAC

#undef AFX_DATA
#define AFX_DATA

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\htmla\ism.cxx ===
/*++


Copyright (c) 1996  Microsoft Corporation

Module Name:

    ism.cxx

Abstract:

    HTML administrator for Internet services as a BGI DLL

Author:

    Philippe Choquier (phillich)    10-january-1996

--*/

#include <windows.h>
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>
#include <limits.h>
#include <time.h>
#include <lmaccess.h>

#include <winsock2.h>

#include "iis64.h"
#include "iisext.h"
#include "inetinfo.h"
#include "apiutil.h"

#include <mbstring.h>
#include <pudebug.h>

typedef
BOOL
(*GET_DEFAULT_DOMAIN_NAME_FN)(PCHAR,DWORD);

#if defined(IISv1)
#define GENERATE_AUTH_HEADERS
#endif

//#define _CHECK_NEW_BALANCED
#if defined(_CHECK_NEW_BALANCED)
unsigned int g_cA = 0;

void* __cdecl operator new( unsigned int nb )
{
    LPVOID p;

    ++g_cA;

    if ( p = VirtualAlloc( NULL, 4096 + nb, MEM_RESERVE, PAGE_READWRITE) )
    {
        if ( VirtualAlloc( p, nb, MEM_COMMIT, PAGE_READWRITE ) )
        {
            return p;
        }
    }
    else
    {
    }

    return NULL;
}


void __cdecl operator delete( void* p )
{
    --g_cA;

    VirtualFree( p, 0, MEM_RELEASE );
}
#endif

#define _ENABLE_KEEP_ALIVE
#include "ism.hxx"
#include "htmlarc.h"

// This BGI DLL presents HTTP requests to an extended syntax HTML
// file. Extensions includes variables ( mostly used to interface
// use the structures defined by the admin RPC layer ), flow control
// ( if, goto, onerror ), HTTP redirection control, calls to C++ functions,
// iterated construct access ( begin/end iteration ).
// These files are stored with an .htr extension
//
// The HTTP request is composed of 2 parts :
// - the query string, of the form <service_name>/<script_path>+<param>
//   where <service_name> is the name of the service to access
//     ( http, ftp, gopher )
//   <script_path> defines the name of the .htr file to use. The .htr
//     extension is appended automatically.
//   <param> is made available to the .htr script through the <%urlparam%>
//     variable, and is typically used to pass back a reference to an
//     element to the script ( i.e. some unique ID referencing an element
//     to update / delete, such as an IP security entry ).
// - the request body ( optional ), which must contains the result of
//   an HTML FORM to be processed by the !Update function.
//   This is to be present only for information update ( see below )
//
// Settings are accessed using variables ( via the '<%' varname '%>'
//   construct ). Most variables map directly to a member variable of
//   one the structures defined by the admin RPC layer, but some are
//   defined onl to easily map with UI objects ( i.e. settings stored in
//   a DWORD bitmask are exposed as multiple independant variables ).
//
// Variables are defined in the g_InetInfoConfigInfoMap array. A variable is
//   defined by its name ( referenced using '<%' varname '%>' in a .htr file ),
//   its type ( cf INET_ELEM_TYPE, this is also used to define the input and
//   and output format ), a GET function ( update a pointer allowing get/set access
//   to the variable, i.e. a LP(W)STR* for strings, DWORD* for numeric, LPBYTE* for IP
//   addresses, LPWSTR for array of WCHAR. This function returns FALSE is the access
//   is invalid ( e.g. RPC call to retrieve settings failed )
//   and an UPDATE function ( a place to validate the new value ) to be called
//   after updating the variable. This will returns FALSE if validation fails,
//   or if the variable is inaccessible ( same as for GET : RPC failed, ... )
//
// A transaction ( seeing and modifying an internet server setting )
//   is typically composed of 2 parts :
//   - information display
//     Using variables.
//   - information update
//     Some settings resides in iterated constructs ( e.g. IP security entries )
//       accessing these settings is a 2 part process :
//     - positionning
//       To set the position on an existing instance of an iterated
//         settings the HTTP request must includes a setting specific
//         unique ID in the <param> part of the URL ( see above ).
//         This ID is used by a positionning function ( such as PosVirtDir )
//         to access the correct element. Deletion uses the same basic mechanism
//         but requires a specific delete function to position and delete the
//         element. This ID is available as a variable ( e.g. ipdenyref ) and is
//         typically used to build the <param> field of an URL.
//       To add an instance of an iterated settings, add functions are defined
//         on a per iterated construct basis.
//     - updating : same as a non iterated field.
//
//   The settings are updated from the request body by the !Update
//     function. The names in the HTML FORM construct must be the same
//     as the one defined in the g_InetInfoConfigInfoMap array.
//
//   As RPC structures are updated, so are the relevant FieldControl variables
//     so that only the minimal amount of updating is done by the RPC server.
//
//   In addition to functions to position, add, delete, set default, update
//     variables there is a !Clear function to set to 0 a DWORD variable.
//     This is necessary because a web browser doesn't send back information
//     for a checkbox item if not checked, so te update script has to clear
//     the relevant variable before calling the !Update function.
//
//   As an error occurs, the error code is stored in reqstatus. If the error
//     involves an RPC call the rpcstatus variable is also updated.
//     This is typically used with the onerror statement to branch on error.
//
//   Special note for IP security lists : there are 2 of them, the deny list
//     and the grat list. If the grant list is empty, the default is assumed
//     to be grant access. If the grant list is not empty, the default is deny access.
//     To signal a default set to deny access when the grant list is empty, as is
//     the case initially when a user modify the default to deny, a dummy entry
//     is created by the windows based admin tool ( cf. g_achIPNullAddr ).
//     This tool uses instead the IP HOST address for the current request,
//     to allow the administrator access to the web server after switching the
//     default to deny.
//
// The implementation of the current admin tools uses 2 types of .htr :
// - display .htr, which includes HTML FORMs and do not call update functions
// - update .htr, which calls update functions and typically only display
//   something in case of error. If no error, they use a redirect construct
//   to branch to a display .htr
// This distinction is a UI design conveniance : nothing in the design
//   of this DLL enforce this.
// The .htr are typically common to all services ( http, ftp, gopher ).
//   Service specific behaviour is possible by testing the servid variable.

// Hierarchy of the current implementation ( update .htr between parenthesis ) :
//
//  HTMLA.HTM                       Top level menu to select service
//      SERV.HTR                    "Service"
//          ( SERVU.HTR )
//          CONN.HTR                Current connections ( FTP Only )
//              ( DISC.HTR )        Disconnect a user
//              ( DISCA.HTR )       Disconnect all users
//      DIR.HTR                     "Diretories"
//          ( DIRU.HTR )
//          ( DIRDEL.HTR )          Delete a directory
//          DIRADD.HTR              Add a directory
//              ( DIRADDU.HTR )
//          DIREDT.HTR              Edit a directory
//              ( DIREDTU.HTR )
//      LOG.HTR                     "Logging"
//          ( LOGU.HTR )
//      ADV.HTR                     "Advanced"
//          ( ADVU.HTR )
//          ADVDENY.HTR             Ask is set default to deny
//              ( ADVDENY2.HTR )    Set default to deny
//          ( ADVGRANT.HTR )        Set default to grant
//          ( ADVDED.HTR )          Delete a denied access entry
//          ADVADDD.HTR             Add a denied access entry
//              ( ADVADDDU.HTR )
//          ADVEDD.HTR              Edit a denied access entry
//              ( ADVEDDU.HTR )
//          ( ADVDEG.HTR )          Delete a granted access entry
//          ADVADDG.HTR             Add a granted access entry
//              ( ADVADDGU.HTR )
//          ADVEDG.HTR              Edit a granted access entry
//              ( ADVEDGU.HTR )
//      MSG.HTR                     "Messages" ( FTP Only )
//          ( MSGU.HTR )

// If defined, enable DEBUG_TR() function. DEBUG_LEVEL value enables
// calls to DEBUG_TR up to this level ( as specified in the 1st param of
// DEBUG_TR(), the rest being equivalent to printf() )

#define DEBUG_LEVEL 0

// Separator used in a reference ( i.e. IP addr ref and virtdir ref )

#define REF_SEP     '|'
#define REF_SEP_STR "|"

// Expire header insuring that the returned document will always be considered
// expired, so that it will not be cached.

#define ALWAYS_EXPIRE "Expires: Tue, 01 Jan 1980 00:00:00 GMT\r\n\r\n"

#if defined(GENERATE_AUTH_HEADERS)
char WWW_AUTHENTICATE_HEADER[] = "WWW-Authenticate: ";
#define W3SVC_REGISTRY_NTAUTHENTICATIONPROVIDERS "NtAuthenticationProviders"
#define W3SVC_REGISTRY_AUTHENTICATION "Authorization"
#endif
#define W3SVC_REGISTRY_PATH "SYSTEM\\CurrentControlSet\\Services\\W3SVC\\Parameters"
#define W3SVC_REGISTRY_HTMLAPATH "HtmlaPath"


// tokens used to extend the HTML syntax. Extended tokens are inclosed
// in a '<%' '%>' construct.

BYTE TOKEN_BEGIN_ITERATION[]="beginiteration";
BYTE TOKEN_END_ITERATION[]="enditeration";
BYTE TOKEN_IF[]="if ";
BYTE TOKEN_ELSE[]="else";
BYTE TOKEN_ENDIF[]="endif";
BYTE TOKEN_ELIF[]="elif ";
BYTE TOKEN_REDIRECT[]="redirect";
BYTE TOKEN_END_REDIRECT[]="/redirect";
BYTE TOKEN_REDIRECTH[]="redirecthttp";
BYTE TOKEN_END_REDIRECTH[]="/redirecthttp";
BYTE TOKEN_GOTO[]="goto ";
BYTE TOKEN_LABEL[]="label ";
BYTE TOKEN_ONERROR[]="onerror ";
BYTE TOKEN_POST[]="post";
BYTE TOKEN_END_POST[]="/post";

// null IP address used by the RPC admin layer to indicates a non-empty
// IP security list

char g_achIPNullAddr[]="0.0.0.0" REF_SEP_STR "255.255.255.255";
LPSTR g_pszIPNullAddr = g_achIPNullAddr;

// Instance handle of this DLL

HINSTANCE g_hModule = (HINSTANCE)INVALID_HANDLE_VALUE;

// Used to return a zero or one value when accessing an invalid DWORD variable

DWORD g_dwZero = 0;
DWORD g_dwOne = 1;

// TRUE if invoked from a test shell ( i.e. not from the web server )

BOOL g_fFakeServer = FALSE;

#if defined(GENERATE_AUTH_HEADERS)
CAuthenticationReqs g_AuthReqs;
#endif

BOOL g_InitDone = FALSE;
PSTR g_pszDefaultHostName = NULL;
CHAR g_achHtmlaPath[MAX_PATH + 1];
CHAR g_achW3Version[128];

CHAR g_achAccessDenied[128];
CHAR g_achAccessDeniedBody[256];
CHAR g_achInternalError[128];
CHAR g_achNotFound[128];
CHAR g_achNotFoundBody[256];

#if defined(IISv1)
OSVERSIONINFO g_OSVersion;
DWORD g_dwCap1Flag = 0x0000003f;
DWORD g_dwCap1Mask = 0x0000003f;
#endif

HINSTANCE                       g_hLonsi = NULL;
GET_DEFAULT_DOMAIN_NAME_FN      g_pfnGetDefaultDomainName = NULL;

////////// Directory lists management

char g_achSysDir[MAX_PATH] = "";


CDriveView::CDriveView(
    VOID )
{
}


CDriveView::~CDriveView(
    VOID )
{
}


BOOL
CDriveView::Init(
    CInetInfoConfigInfoMapper* pM )
{
    m_pMapper = pM;

    m_dsDriveName.Reset();
    m_dsDriveLabel.Reset();
    m_dsDriveType.Reset();
    m_dwCachedDrive = 0;
    m_tmCacheExpire = 0;
    m_cDrives = 0;

    if ( g_achSysDir[0] == '\0' )
    {
        if ( !GetSystemDirectory( g_achSysDir, sizeof(g_achSysDir) ) )
        {
            strcpy( g_achSysDir, "c:\\*.*" );
        }
        else
        {
            strcpy( g_achSysDir + 2, "\\*.*" );
        }
    }

    return TRUE;
}


BOOL
CDriveView::Reset(
    VOID )
{
    m_dsDirs.Reset();
    m_dsComp.Reset();
    m_dsFComp.Reset();

    m_cDirs = 0;
    m_cComp = 0;

    return TRUE;
}


BOOL
CDriveView::Entry(
    UINT i,
    UINT cMax,
    CDStr &dsList,
    PVOID pRes )
/*++

Routine Description:

    Returns the ith entry ( base 0 ) in a CDStr considered
    as a collection of sz strings.

Arguments:

    i - index of entry to return
    cMax - # of entries in the list
    dsList - CDStr as collection of sz string entries
    pRes - points to a LPSTR update with address of entry

Returns:

    TRUE on success, FALSE on failure

--*/
{
    LPSTR pList = dsList.GetString();

    if ( i < cMax )
    {
        while ( i-- )
        {
            pList += strlen( pList ) + 1;
        }
        *(LPSTR*)pRes = pList;

        return TRUE;
    }

    return FALSE;
}


BOOL
CDriveView::ValidateDir(
    LPSTR pDir )
/*++

Routine Description:

    Validate a directory path, set reqstatus HTR_VALIDATION_FAILED
    if path invalid.

Arguments:

    pDir - directory path to validate

Returns:

    TRUE on success, FALSE on failure
    updates reqstatus

--*/
{
    DWORD dwS;

    if ( (dwS = GetFileAttributes( pDir )) == 0xffffffff
            || !(dwS & FILE_ATTRIBUTE_DIRECTORY) )
    {
        m_pMapper->SetRequestStatus( HTR_VALIDATION_FAILED );
    }

    return TRUE;
}


BOOL
CDriveView::CreateDir(
    LPSTR pPath,
    LPSTR pNewDir )
/*++

Routine Description:

    Create a new directory path from an existing path and
    a directory name to be created.
    set reqstatus HTR_VALIDATION_FAILED if creation fails

Arguments:

    pPath - directory path inn which to create the new directory
    pNewDir - directory to create

Returns:

    TRUE on success, FALSE on failure
    updates reqstatus

--*/
{
    BOOL fSt = FALSE;

    // Create path : insert '\\'\ between path and NewDir if
    // necessary

    int cP = strlen( pPath );
    LPSTR pDir = new char[cP + 1 + strlen(pNewDir) + 1];
    if ( pDir == NULL )
    {
        return FALSE;
    }

    memcpy( pDir, pPath, cP );
    if ( cP > 0
            && &pPath[cP-1] != (LPSTR)_mbsrchr((LPBYTE)pPath,'\\')
            && pPath[cP-1] != '/'
            && *pNewDir != '\\'
            && *pNewDir != '/' )
    {
        pDir[cP++] = '\\';
    }
    strcpy( pDir + cP, pNewDir );

    if ( !CreateDirectory( pDir, NULL ) )
    {
        m_pMapper->SetRequestStatus( HTR_VALIDATION_FAILED );
    }

    delete [] pDir;

    return TRUE;
}


extern "C" int __cdecl
QsortStrCmp(
    const void *pA,
    const void *pB )
{
    return _stricmp( *(LPSTR*)pA, *(LPSTR*)pB );
}

/* #pragma INTRINSA suppress=null_pointers */

BOOL
CDriveView::GenerateDirList(
    LPSTR pDrive )
/*++

Routine Description:

    Generate all directory lists and related values :
        m_achRootDir   - path actually used in the search
                         always contains a drive designation,
                         ends with a '\'
        m_achBaseDir   - as m_achRootDir but without trailing '\'
        m_dsComp       - list of all the directory components of the path
        m_dsFComp      - list of all the directory components of the path
                         as an absolute path
        m_dsDirs       - list of all sub-directory of the path
        m_dsDriveName  - list of all drive names ( i.e "c:" )
        m_dsDriveLabel - list of all drive labels
        m_dsDriveType  - list of all drive types ( as DRIVE_* )

Arguments:

    pDrive - path where directory browsing is to take place.

Returns:

    TRUE on success, FALSE on failure
    updates reqstatus

--*/
{
    WIN32_FIND_DATA fdF;
    NETRESOURCE *pNetResource;
    LPSTR pAdd;
    LPSTR pPath;
    BOOL fSt = TRUE;
    DWORD dwSize;
    DWORD cbBuffer;
    DWORD dwResult;
    HANDLE hEnum;
    DWORD cEntries;
    DWORD dwD;
    UINT i;
    int x;

    Reset();

    // replace all '/' with '\\'
    for ( pPath = pDrive ; pPath = strchr( pPath, '/' ) ; ++pPath )
        *pPath = '\\';

    // Normalize pPath from pDrive : must end with '\*.*'

    int cP = strlen( pDrive );
    if ( cP > 0 && &pDrive[cP-1] == (LPSTR)_mbsrchr((LPBYTE)pDrive,'\\') )
    {
        pAdd = "*.*";
    }
    else
    {
        if ( cP == 0 )
        {
            pAdd = g_achSysDir;
        }
        else
        {
            pAdd = "\\*.*";
        }
    }

    pPath = m_achRootDir;
    memcpy( pPath, pDrive, cP );
    strcpy( pPath + cP, pAdd );

    // check directory path valid, if not use default value

    HANDLE hF = FindFirstFile( pPath, &fdF) ;
    if ( hF == INVALID_HANDLE_VALUE )
    {
        strcpy( pPath, g_achSysDir );
        hF = FindFirstFile( pPath, &fdF) ;
    }

    if ( hF != INVALID_HANDLE_VALUE )
    {
        // build path component list
        m_cComp = 0;
        LPSTR pND, pCD = pPath;
        for ( ; pND = (LPSTR)_mbschr( (LPBYTE)pCD, '\\' ) ; pCD = pND + 1 )
        {
            // copy subdir, or drive letter + ':' + '\\' for root
            m_dsComp.AddRange( pCD, DIFF(pND - pCD) + (m_cComp == 0 ? 1 : 0) );
            m_dsComp.AddRange( "", sizeof("") );
            m_dsFComp.AddRange( pPath, DIFF(pND - pPath) + (m_cComp == 0 ? 1 : 0) );
            m_dsFComp.AddRange( "", sizeof("") );
            ++m_cComp;
        }

        CDStr dsTempDir;
        CDStr dsTempPtr;
        DWORD dwI;

        // build sub-directory list
        do {
            if ( fdF.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
            {
                if ( strcmp( fdF.cFileName, "." ) && strcmp( fdF.cFileName, ".." ) )
                {
                    dwI = dsTempDir.GetLen();
                    dsTempDir.Add( fdF.cFileName );
                    dsTempDir.AddRange( "", sizeof("") );
                    dsTempPtr.AddRange( (LPSTR)&dwI, sizeof(DWORD) );
                    ++m_cDirs;
                }
            }
        } while ( FindNextFile( hF, &fdF ) );

        if ( m_cDirs )
        {
            // adjust TempPtr from offset to ptr
            LPSTR *pA = (LPSTR*)dsTempPtr.GetString();
            for ( i = 0 ; i < m_cDirs ; ++i )
            {
                pA[i] = dsTempDir.GetString() + (ULONG_PTR)pA[i];
            }

            // sort
            qsort( pA, m_cDirs, sizeof(LPSTR), QsortStrCmp );

            // build sorted list
            for ( i = 0 ; i < m_cDirs ; ++ i )
            {
                m_dsDirs.AddRange( pA[i], strlen(pA[i]) + 1 );
            }
        }

        FindClose( hF );
    }
    else
    {
        if ( GetLastError() == ERROR_ACCESS_DENIED )
        {
           m_pMapper->SetRequestStatus( HTR_ACCESS_DENIED );
        }
        else
        {
           m_pMapper->SetRequestStatus( HTR_VALIDATION_FAILED );
        }
    }

    // build drive list

    dwD = GetLogicalDrives();
    if ( dwD == m_dwCachedDrive
            && time(NULL) < m_tmCacheExpire )
    {
        // use cache
    }
    else
    {
        // build list of name for network drives

        pNetResource = NULL;
        dwResult = WNetOpenEnum( RESOURCE_REMEMBERED, RESOURCETYPE_DISK,
                                      0, NULL, &hEnum );

        if ( dwResult == NO_ERROR )
        {
            // start with a reasonable buffer size
            cbBuffer     = 100 * sizeof( NETRESOURCE );
            pNetResource = (NETRESOURCE*) new BYTE[cbBuffer];

            while ( TRUE )
            {
                dwSize   = cbBuffer,
                cEntries = 0xffffffff;

                dwResult = WNetEnumResource( hEnum, &cEntries, pNetResource,
                        &dwSize );

                if ( dwResult == ERROR_MORE_DATA )
                {
                     // the buffer was too small, enlarge
                     cbBuffer = dwSize;
                     delete [] pNetResource;
                     pNetResource = (NETRESOURCE*) new BYTE[cbBuffer];
                     continue;
                }

                if ( dwResult != NO_ERROR )
                {
                    delete [] pNetResource;
                    pNetResource = NULL;
                    cEntries = 0;
                    break;
                }

                break;
           }
           WNetCloseEnum( hEnum );
        }
        else
        {
            cEntries = 0;
        }

        // because of x86 compiler bug
        if ( pNetResource == NULL )
        {
            cEntries = 0;
        }

        m_dsDriveName.Reset();
        m_dsDriveLabel.Reset();
        m_dsDriveType.Reset();
        m_cDrives = 0;

        // iterate for all possible drive names

        for ( x = 0 ; x < 'Z'-'A'+1 ; ++x )
        {
            char achD[4];

            // check drive present and visible by this process

            if ( dwD & (1<<x) )
            {
                strcpy( achD + 1, ":\\" );
                achD[0] = 'A' + x;
                UINT iT = GetDriveType( achD );
                if ( iT > 1 )
                {
                    DWORD dwI = iT;
                    char achVolName[80];
                    DWORD dwSerNum;
                    DWORD dwCompLen;
                    DWORD dwSysFlg;
                    BOOL fInf = FALSE;

                    // get volume information for non-removable
                    // & non cd-rom ( too slow to get info )
                    if ( iT == DRIVE_FIXED )
                    {
                        if ( GetVolumeInformation( achD,
                                        achVolName,
                                        sizeof(achVolName),
                                        &dwSerNum,
                                        &dwCompLen,
                                        &dwSysFlg,
                                        NULL,
                                        0 ) )
                            {
                                m_dsDriveLabel.Add( achVolName );
                                fInf = TRUE;
                            }
                    }
                    else if ( iT == DRIVE_REMOTE )
                    {
                        if ( cEntries != 0 )
                        {
                            // search for the specified drive letter
                            for ( i = 0; i < (int) cEntries; i++ )
                            {
                                if ( pNetResource[i].lpLocalName &&
                                    achD[0] == toupper(pNetResource[i]
                                            .lpLocalName[0]) )
                                {
                                     m_dsDriveLabel.Add( pNetResource[i]
                                            .lpRemoteName );
                                     fInf = TRUE;
                                }
                            }
                        }
                        else
                        {
                            dwCompLen = sizeof( achVolName );
                            achD[2] = '\0';

                            if ( WNetGetConnection( achD, achVolName,
                                    &dwCompLen ) == NO_ERROR )
                            {
                                 m_dsDriveLabel.Add( achVolName );
                                 fInf = TRUE;
                            }
                        }
                    }

                    if ( fInf )
                    {
                        m_dsDriveType.AddRange( (LPSTR)&dwI, sizeof(DWORD) );
                        m_dsDriveName.AddRange( achD, 2 );
                        m_dsDriveName.AddRange( "", sizeof("") );
                        m_dsDriveLabel.AddRange( "", sizeof("") );
                    }

                    ++m_cDrives;
                }
            }
        }
        m_dwCachedDrive = dwD;
        if ( pNetResource != NULL )
        {
            delete [] pNetResource ;
        }
    }
    m_tmCacheExpire = time(NULL) + DRIVE_CACHE_EXPIRE;

    // delimit RootDir after last '\\'
    LPSTR pL = pPath + strlen(pPath);
    BOOL fAddedSep;
    pL = (LPSTR)_mbsrchr((LPBYTE)pPath, '\\');
    if (pL == NULL) pL = pPath;
    if ( pL == (LPSTR)_mbschr( (LPBYTE)pPath, '\\' ) )
    {
        fAddedSep = TRUE;
        ++pL;
    }
    else
    {
        fAddedSep = FALSE;
    }
    if ( pL != pPath )
    {
        *pL = '\0';
    }

    strcpy( m_achBaseDir, pPath );
    if ( fAddedSep )
    {
        *_mbschr( (LPBYTE)m_achBaseDir, '\\' ) = '\0';
    }

    return fSt;
}


// DEBUG handling

#if defined(DEBUG_LEVEL)
CInetInfoRequest *g_pReq;
#endif

void
TR_DEBUG(
    int iLev,
    LPSTR pFormat,
    ... )
{
#if defined(DEBUG_LEVEL)
    if ( iLev <= DEBUG_LEVEL )
    {
        char achBuf[1024];
        va_list arglist;
        va_start( arglist, pFormat );
        UINT cL = (UINT)wvsprintf( achBuf, pFormat, arglist );
        g_pReq->GetBuffer()->CopyBuff( (LPBYTE)achBuf, cL );
    }
#endif
}


// Global helper functions


void
DelimStrcpyN(
    LPSTR pDest,
    LPSTR pSrc,
    int cLen )
{
    memcpy( pDest, pSrc, cLen );
    pDest[ cLen ] = '\0';
}


// Convert a Multi-byte string to a DWORD

DWORD
MultiByteToDWORD(
    LPSTR pSet )
{
    DWORD dwV = 0;
    int c;

    while ( (c=*pSet) != '\0' && c==' ' )
    {
        ++pSet;
    }

    while ( (c=*pSet++) != '\0' && ((c>='0' && c<='9') || c==',') )
    {
        if ( c != ',' )
        {
            dwV = dwV*10 + c-'0';
        }
    }

    return dwV;
}


// Convert a DWORD to a Multi-byte string

void
DWORDToMultiByte(
    DWORD dwV,
    LPSTR pS )
{
    LPSTR pF = pS;

    if ( dwV == 0 )
    {
        *pS++ = '0';
    }
    else for ( ; dwV ; dwV/=10 )
    {
        *pS++ = '0' + (int)(dwV%10);
    }
    *pS-- = '\0';

    while ( pF < pS )
    {
        int c = *pF;
        *pF++ = *pS;
        *pS-- = (CHAR)c;
    }
}


// convert ASCII Hex digit to UINT

UINT
HexCharToUINT(
    UINT cH )
{
    if ( cH>='0' && cH<='9' )
    {
        return cH-'0';
    }
    else if ( cH>='a' && cH<='f' )
    {
        return cH-'a'+10;
    }
    else if ( cH>='A' && cH<='F' )
    {
        return cH-'A'+10;
    }
    return 0;
}


///////////// Variable list

// to be accessed by the '<%' varname '%>'construct, and by various tokens
//
// Most of these variables map directly to a member variable of one of the
// structures defined bu the RPC admin layer ( cf. inetcom.h & inetinfo.h )
//
// Variables in iterated costructs ( e.g. virtual roots ) are to be used
// in a beginiteration ... enditeration construct. The element being accessed
// will be designated by the value of the CInetInfoConfigInfoMapper::m_iIter
// variable.
//
// Some of these variables are "virtual" : they do not map to a RPC struct,
// either because they are linked to the current BGI request ( e.g. reqstatus )
// or because the UI need to access info in a different way that what the RPC
// struct define ( e.g. we need to expose different variables to set/reset
// authentication method even if they are stored in one DWORD bitmask in the
// RPC struct ).

CInetInfoMap g_InetInfoConfigInfoMap[] = {

    // request variables ( linked to the current BGI request )

    { "reqstatus", ITYPE_DWORD, &CInetInfoConfigInfoMapper::RequestStatus,
        &CInetInfoConfigInfoMapper::DenyUpdate, 0
    },
    { "rpcstatus", ITYPE_DWORD, &CInetInfoConfigInfoMapper::RPCStatus,
        &CInetInfoConfigInfoMapper::DenyUpdate, 0
    },
    { "rpcstatusstring", ITYPE_LPSTR, &CInetInfoConfigInfoMapper::RPCStatusString,
      &CInetInfoConfigInfoMapper::DenyUpdate, 0
    },
    { "iter", ITYPE_DWORD, &CInetInfoConfigInfoMapper::Iter,
        &CInetInfoConfigInfoMapper::DenyUpdate, 0
    },
    { "httpstatus", ITYPE_DWORD, &CInetInfoConfigInfoMapper::HttpStatus,
        &CInetInfoConfigInfoMapper::DenyUpdate, 0
    },
    { "ftpstatus", ITYPE_DWORD, &CInetInfoConfigInfoMapper::FtpStatus,
        &CInetInfoConfigInfoMapper::DenyUpdate, 0
    },
    { "gopherstatus", ITYPE_DWORD, &CInetInfoConfigInfoMapper::GopherStatus,
        &CInetInfoConfigInfoMapper::DenyUpdate, 0
    },


    // version information

    { "osmajorversion", ITYPE_DWORD, &CInetInfoConfigInfoMapper::OSMajorVersion,
        &CInetInfoConfigInfoMapper::DenyUpdate, 0
    },
    { "osminorversion", ITYPE_DWORD, &CInetInfoConfigInfoMapper::OSMinorVersion,
        &CInetInfoConfigInfoMapper::DenyUpdate, 0
    },
    { "osbuildnumber", ITYPE_DWORD, &CInetInfoConfigInfoMapper::OSBuildNumber,
        &CInetInfoConfigInfoMapper::DenyUpdate, 0
    },
    { "majorversion", ITYPE_DWORD, &CInetInfoConfigInfoMapper::MajorVersion,
        &CInetInfoConfigInfoMapper::DenyUpdate, 0
    },
    { "minorversion", ITYPE_DWORD, &CInetInfoConfigInfoMapper::MinorVersion,
        &CInetInfoConfigInfoMapper::DenyUpdate, 0
    },
    { "w3version", ITYPE_LPSTR, &CInetInfoConfigInfoMapper::W3Version,
        &CInetInfoConfigInfoMapper::DenyUpdate, 0
    },
    { "platformtype", ITYPE_DWORD, &CInetInfoConfigInfoMapper::PlatformType,
        &CInetInfoConfigInfoMapper::DenyUpdate, 0
    },
    { "cap1flag", ITYPE_DWORD, &CInetInfoConfigInfoMapper::Cap1Flag,
        &CInetInfoConfigInfoMapper::DenyUpdate, 0
    },
    { "cap1mask", ITYPE_DWORD, &CInetInfoConfigInfoMapper::Cap1Mask,
        &CInetInfoConfigInfoMapper::DenyUpdate, 0
    },
    { "userflags", ITYPE_DWORD, &CInetInfoConfigInfoMapper::UserFlags,
        &CInetInfoConfigInfoMapper::DenyUpdate, 0
    },

    { "urlparam", ITYPE_LPSTR, &CInetInfoConfigInfoMapper::URLParam,
            &CInetInfoConfigInfoMapper::DenyUpdate , 0
    },
    { "servname", ITYPE_LPSTR, &CInetInfoConfigInfoMapper::ServName,
            &CInetInfoConfigInfoMapper::DenyUpdate , 0
    },
    { "servid", ITYPE_DWORD, &CInetInfoConfigInfoMapper::ServIdx,
            &CInetInfoConfigInfoMapper::DenyUpdate , 0
    },
    { "reqparam", ITYPE_LPSTR, &CInetInfoConfigInfoMapper::ReqParam,
            &CInetInfoConfigInfoMapper::DenyUpdate , 0
    },
    { "remoteaddr", ITYPE_LPSTR, &CInetInfoConfigInfoMapper::RemoteAddr,
            &CInetInfoConfigInfoMapper::DenyUpdate , 0
    },
    { "ipnulladdr", ITYPE_LPSTR, &CInetInfoConfigInfoMapper::IPNullAddr,
            &CInetInfoConfigInfoMapper::DenyUpdate , 0
    },
    { "hostname", ITYPE_LPSTR, &CInetInfoConfigInfoMapper::HostName,
            &CInetInfoConfigInfoMapper::DenyUpdate , 0
    },
    { "htmlapath", ITYPE_LPSTR, &CInetInfoConfigInfoMapper::HtmlaPath,
            &CInetInfoConfigInfoMapper::DenyUpdate , 0
    },
    { "iter", ITYPE_DWORD, &CInetInfoConfigInfoMapper::Iter,
            &CInetInfoConfigInfoMapper::DenyUpdate , 0
    },


        // INET_COM_CONFIG_INFO ( same name, different values for each service )

    { "comconntimeout", ITYPE_SHORTDW, &CInetInfoConfigInfoMapper::CommTimeout,
            &CInetInfoConfigInfoMapper::UpdateCommTimeout, 0
    },
    { "commaxconn", ITYPE_DWORD, &CInetInfoConfigInfoMapper::MaxConn,
            &CInetInfoConfigInfoMapper::UpdateMaxConn, 0
    },
    { "comadminname", ITYPE_LPWSTR, &CInetInfoConfigInfoMapper::AdminName,
            &CInetInfoConfigInfoMapper::UpdateAdminName, 0
    },
    { "comadminemail", ITYPE_LPWSTR, &CInetInfoConfigInfoMapper::AdminEmail,
            &CInetInfoConfigInfoMapper::UpdateAdminEmail, 0
    },
    { "comservercomment", ITYPE_LPWSTR, &CInetInfoConfigInfoMapper::ServerComment,
            &CInetInfoConfigInfoMapper::UpdateServerComment, 0
    },

        // INET_LOG_CONFIGURATION

    { "enablelog", ITYPE_BOOL, &CInetInfoConfigInfoMapper::EnableLog,
            &CInetInfoConfigInfoMapper::UpdateLog, 0
    } ,     // log type
    { "logtype", ITYPE_DWORD, &CInetInfoConfigInfoMapper::LogType,
            &CInetInfoConfigInfoMapper::UpdateLogType, 0
    },
    { "enablenewlog", ITYPE_BOOL, &CInetInfoConfigInfoMapper::EnableNewLog,
            &CInetInfoConfigInfoMapper::UpdateNewLog, 0
    } ,
    { "logperiod", ITYPE_DWORD, &CInetInfoConfigInfoMapper::LogPeriod,
            &CInetInfoConfigInfoMapper::UpdateLogPeriod, 0
    },      // log period
    { "logformat", ITYPE_DWORD, &CInetInfoConfigInfoMapper::LogFormat,
            &CInetInfoConfigInfoMapper::UpdateLogFormat, 0
    },
    { "logdir", ITYPE_AWCHAR, &CInetInfoConfigInfoMapper::LogDir,
            &CInetInfoConfigInfoMapper::UpdateLogFileInfo, MAX_PATH
    },
    { "logsize", ITYPE_1M, &CInetInfoConfigInfoMapper::LogSize,
            &CInetInfoConfigInfoMapper::UpdateLogSize, 0
    },
    { "logsrc", ITYPE_AWCHAR, &CInetInfoConfigInfoMapper::LogSrc,
            &CInetInfoConfigInfoMapper::UpdateLogODBCInfo, MAX_PATH             // sizeof(INET_LOG_CONFIGURATION.rgchDataSource)
    },
    { "logname", ITYPE_AWCHAR, &CInetInfoConfigInfoMapper::LogName,
            &CInetInfoConfigInfoMapper::UpdateLogODBCInfo, MAX_TABLE_NAME_LEN   // sizeof(INET_LOG_CONFIGURATION.rgchTableName)
    },
    { "loguser", ITYPE_AWCHAR, &CInetInfoConfigInfoMapper::LogUser,
            &CInetInfoConfigInfoMapper::UpdateLogODBCInfo, MAX_USER_NAME_LEN    // sizeof(INET_LOG_CONFIGURATION.rgchUserName)
    },
    { "logpw", ITYPE_AWCHAR, &CInetInfoConfigInfoMapper::LogPw,
            &CInetInfoConfigInfoMapper::UpdateLogODBCInfo, MAX_PASSWORD_LEN     // sizeof(INET_LOG_CONFIGURATION.rgchPassword)
    },
    { "invalidlogupdate", ITYPE_BOOL, &CInetInfoConfigInfoMapper::InvalidLogUpdate,
            &CInetInfoConfigInfoMapper::DenyUpdate, 0
    },

    // INET_INFO_CONFIG_INFO
    { "loganon", ITYPE_BOOL, &CInetInfoConfigInfoMapper::LogAnonymous,
            &CInetInfoConfigInfoMapper::UpdateLogAnonymous, 0
    },
    { "lognona", ITYPE_BOOL, &CInetInfoConfigInfoMapper::LogNonAnonymous,
            &CInetInfoConfigInfoMapper::UpdateLogNonAnonymous, 0
    },
    { "anonun", ITYPE_LPWSTR, &CInetInfoConfigInfoMapper::AnonUserName,
            &CInetInfoConfigInfoMapper::UpdateAnonUserName, 0
    },
    { "anonpw", ITYPE_AWCHAR, &CInetInfoConfigInfoMapper::AnonUserPw,
            &CInetInfoConfigInfoMapper::UpdateAnonUserPw, PWLEN+1,      // sizeof(INET_INFO_CONFIG_INFO.szAnonPassword)
    },
    { "authanon", ITYPE_BOOL, &CInetInfoConfigInfoMapper::AuthAnon,
            &CInetInfoConfigInfoMapper::UpdateAuth, 0
    },
    { "authbasic", ITYPE_BOOL, &CInetInfoConfigInfoMapper::AuthBasic,
            &CInetInfoConfigInfoMapper::UpdateAuth, 0
    },
    { "authnt", ITYPE_BOOL, &CInetInfoConfigInfoMapper::AuthNT,
            &CInetInfoConfigInfoMapper::UpdateAuth, 0
    },
    { "sport", ITYPE_SHORT, &CInetInfoConfigInfoMapper::SPort,
            &CInetInfoConfigInfoMapper::UpdateSPort, 0
    },
        // Deny IP list
    { "denyipcount", ITYPE_DWORD, &CInetInfoConfigInfoMapper::DenyIPCount,
            &CInetInfoConfigInfoMapper::DenyUpdate, 0
    },
    { "denyisipsingle", ITYPE_BOOL, &CInetInfoConfigInfoMapper::DenyIsIPSingle,
            &CInetInfoConfigInfoMapper::UpdateDenyIsIPSingle, 0
    },
    { "denyipaddr", ITYPE_IP_ADDR, &CInetInfoConfigInfoMapper::DenyIPAddr,
            &CInetInfoConfigInfoMapper::UpdateIP, 0
    },
    { "denyipmask", ITYPE_IP_MASK, &CInetInfoConfigInfoMapper::DenyIPMask,
            &CInetInfoConfigInfoMapper::UpdateDenyIsIPSingle, 0
    },
        // Grant IP list
    { "grantipcount", ITYPE_DWORD, &CInetInfoConfigInfoMapper::GrantIPCount,
            &CInetInfoConfigInfoMapper::DenyUpdate, 0
    },
    { "grantisipsingle", ITYPE_BOOL, &CInetInfoConfigInfoMapper::GrantIsIPSingle,
            &CInetInfoConfigInfoMapper::UpdateGrantIsIPSingle, 0
    },
    { "grantipaddr", ITYPE_IP_ADDR, &CInetInfoConfigInfoMapper::GrantIPAddr,
            &CInetInfoConfigInfoMapper::UpdateIP, 0
    },
    { "grantipmask", ITYPE_IP_MASK, &CInetInfoConfigInfoMapper::GrantIPMask,
            &CInetInfoConfigInfoMapper::UpdateGrantIsIPSingle, 0
    },
        // IP reference
    { "ipdenyref", ITYPE_LPSTR, &CInetInfoConfigInfoMapper::IPDenyRef,
            &CInetInfoConfigInfoMapper::DenyUpdate, 0
    },
    { "ipgrantref", ITYPE_LPSTR, &CInetInfoConfigInfoMapper::IPGrantRef,
            &CInetInfoConfigInfoMapper::DenyUpdate, 0
    },
        // Virtual root
    { "rootcount", ITYPE_DWORD, &CInetInfoConfigInfoMapper::RootCount,
            &CInetInfoConfigInfoMapper::DenyUpdate, 0
    },
    { "rootname", ITYPE_VIRT_DIR_LPWSTR, &CInetInfoConfigInfoMapper::RootName,
            &CInetInfoConfigInfoMapper::UpdateRootName, 0
    },
    { "rootaddr", ITYPE_LPWSTR, &CInetInfoConfigInfoMapper::RootAddr,
            &CInetInfoConfigInfoMapper::UpdateRoot, 0
    },
    { "rootdir", ITYPE_PATH_LPWSTR, &CInetInfoConfigInfoMapper::RootDir,
            &CInetInfoConfigInfoMapper::UpdateRoot, 0
    },
    { "rootishome", ITYPE_BOOL, &CInetInfoConfigInfoMapper::RootIsHome,
            &CInetInfoConfigInfoMapper::UpdateRoot, 0
    },
    { "rootisread", ITYPE_BOOL, &CInetInfoConfigInfoMapper::RootIsRead,
            &CInetInfoConfigInfoMapper::UpdateRootMask, 0
    },
    { "rootiswrite", ITYPE_BOOL, &CInetInfoConfigInfoMapper::RootIsWrite,
            &CInetInfoConfigInfoMapper::UpdateRootMask, 0
    },
    { "rootisexec", ITYPE_BOOL, &CInetInfoConfigInfoMapper::RootIsExec,
            &CInetInfoConfigInfoMapper::UpdateRootMask, 0
    },
    { "rootisssl", ITYPE_BOOL, &CInetInfoConfigInfoMapper::RootIsSSL,
            &CInetInfoConfigInfoMapper::UpdateRootMask, 0
    },
    { "rootacctname", ITYPE_LPWSTR, &CInetInfoConfigInfoMapper::RootAcctName,
            &CInetInfoConfigInfoMapper::UpdateRoot, 0
    },
    { "rootacctpw", ITYPE_AWCHAR, &CInetInfoConfigInfoMapper::RootAcctPw,
            &CInetInfoConfigInfoMapper::UpdateRoot, PWLEN +1        // sizeof(INET_INFO_VIRTUAL_ROOT_ENTRY.AccountPassword)
    },
    { "rooterror", ITYPE_DWORD, &CInetInfoConfigInfoMapper::RootError,
            &CInetInfoConfigInfoMapper::UpdateRoot, 0
    },
        // Virtual Root reference
    { "rootref", ITYPE_LPSTR, &CInetInfoConfigInfoMapper::RootRef,
            &CInetInfoConfigInfoMapper::DenyUpdate, 0
    },

    // W3
    { "w3dirbrowseenabled", ITYPE_BOOL, &CInetInfoConfigInfoMapper::DirBrowseEnab,
            &CInetInfoConfigInfoMapper::UpdateDirControl, 0
    },
    { "w3defaultfileenabled", ITYPE_BOOL, &CInetInfoConfigInfoMapper::DefFileEnab,
            &CInetInfoConfigInfoMapper::UpdateDirControl, 0
    },
    { "w3defaultfile", ITYPE_LPWSTR, &CInetInfoConfigInfoMapper::DefFile,
            &CInetInfoConfigInfoMapper::UpdateDefFile, 0
    },
    { "w3ssienabled", ITYPE_BOOL, &CInetInfoConfigInfoMapper::SSIEnabled,
            &CInetInfoConfigInfoMapper::UpdateSSIEnabled, 0
    },
    { "w3ssiext", ITYPE_LPWSTR, &CInetInfoConfigInfoMapper::SSIExt,
            &CInetInfoConfigInfoMapper::UpdateSSIExt, 0
    },
    { "w3cryptcapable", ITYPE_DWORD, &CInetInfoConfigInfoMapper::CryptCapable,
            &CInetInfoConfigInfoMapper::DenyUpdate, 0
    },

    // Gopher
    { "gophersite", ITYPE_LPWSTR, &CInetInfoConfigInfoMapper::GopherSite,
            &CInetInfoConfigInfoMapper::UpdateGopherSite, 0
    },
    { "gopherorg", ITYPE_LPWSTR, &CInetInfoConfigInfoMapper::GopherOrg,
            &CInetInfoConfigInfoMapper::UpdateGopherOrg, 0
    },
    { "gopherloc", ITYPE_LPWSTR, &CInetInfoConfigInfoMapper::GopherLoc,
            &CInetInfoConfigInfoMapper::UpdateGopherLoc, 0
    },
    { "gophergeo", ITYPE_LPWSTR, &CInetInfoConfigInfoMapper::GopherGeo,
            &CInetInfoConfigInfoMapper::UpdateGopherGeo, 0
    },
    { "gopherlang", ITYPE_LPWSTR, &CInetInfoConfigInfoMapper::GopherLang,
            &CInetInfoConfigInfoMapper::UpdateGopherLang, 0
    },

    // FTP
    { "ftpallowanon", ITYPE_BOOL, &CInetInfoConfigInfoMapper::FTPIsAnon,
            &CInetInfoConfigInfoMapper::UpdateFTPIsAnon, 0
    },
    { "ftpallowguest", ITYPE_BOOL, &CInetInfoConfigInfoMapper::FTPIsGuest,
            &CInetInfoConfigInfoMapper::UpdateFTPIsGuest, 0
    },
    { "ftpannotdir", ITYPE_BOOL, &CInetInfoConfigInfoMapper::FTPIsAnotDir,
            &CInetInfoConfigInfoMapper::UpdateFTPIsAnotDir, 0
    },
    { "ftpanononly", ITYPE_BOOL, &CInetInfoConfigInfoMapper::FTPIsAnonOnly,
            &CInetInfoConfigInfoMapper::UpdateFTPIsAnonOnly, 0
    },
    { "ftpexitmsg", ITYPE_LPWSTR, &CInetInfoConfigInfoMapper::FTPExitMsg,
            &CInetInfoConfigInfoMapper::UpdateFTPExitMsg, 0
    },
    { "ftpgreetmsg", ITYPE_LPWSTR, &CInetInfoConfigInfoMapper::FTPGreetMsg,
            &CInetInfoConfigInfoMapper::UpdateFTPGreetMsg, 0
    },
    { "ftphomedir", ITYPE_LPWSTR, &CInetInfoConfigInfoMapper::FTPHomeDir,
            &CInetInfoConfigInfoMapper::UpdateFTPHomeDir, 0
    },
    { "ftmaxclmsg", ITYPE_LPWSTR, &CInetInfoConfigInfoMapper::FTPMaxClMsg,
            &CInetInfoConfigInfoMapper::UpdateFTPMaxClMsg, 0
    },
    { "ftpmsdosdirout", ITYPE_BOOL, &CInetInfoConfigInfoMapper::FTPIsMsdos,
            &CInetInfoConfigInfoMapper::UpdateFTPIsMsdos, 0
    },

    // User enumeration
    { "enumusercount", ITYPE_DWORD, &CInetInfoConfigInfoMapper::UCount,
            &CInetInfoConfigInfoMapper::DenyUpdate, 0
    },
    { "enumusername", ITYPE_LPWSTR, &CInetInfoConfigInfoMapper::UName,
            &CInetInfoConfigInfoMapper::DenyUpdate, 0
    },
    { "enumuseranon", ITYPE_BOOL, &CInetInfoConfigInfoMapper::UAnonymous,
            &CInetInfoConfigInfoMapper::DenyUpdate, 0
    },
    { "enumuseraddr", ITYPE_IP_ADDR, &CInetInfoConfigInfoMapper::UAddr,
            &CInetInfoConfigInfoMapper::DenyUpdate, 0
    },
    { "enumusertime", ITYPE_TIME, &CInetInfoConfigInfoMapper::UTime,
            &CInetInfoConfigInfoMapper::DenyUpdate, 0
    },
    { "enumuserid", ITYPE_DWORD, &CInetInfoConfigInfoMapper::UID,
            &CInetInfoConfigInfoMapper::DenyUpdate, 0
    },


    // Global
    { "globalisbandwidthlimited", ITYPE_DWORD, &CInetInfoConfigInfoMapper::GlobalIsBandwidthLimited,
            &CInetInfoConfigInfoMapper::UpdateGlobalIsBandwidthLimited, 0
    },
    { "globalbandwidth", ITYPE_1K, &CInetInfoConfigInfoMapper::GlobalBandwidth,
            &CInetInfoConfigInfoMapper::UpdateGlobalBandwidth, 0
    },
    { "globalcache", ITYPE_DWORD, &CInetInfoConfigInfoMapper::GlobalCache,
            &CInetInfoConfigInfoMapper::UpdateGlobal, 0
    },
} ;


CInetInfoMap g_InetInfoDirInfoMap[] = {

    // request variables ( linked to the current BGI request )

    { "reqstatus", ITYPE_DWORD, &CInetInfoConfigInfoMapper::RequestStatus,
        &CInetInfoConfigInfoMapper::DenyUpdate, 0
    },
    { "rpcstatus", ITYPE_DWORD, &CInetInfoConfigInfoMapper::RPCStatus,
        &CInetInfoConfigInfoMapper::DenyUpdate, 0
    },
    { "rpcstatusstring", ITYPE_LPSTR, &CInetInfoConfigInfoMapper::RPCStatusString,
      &CInetInfoConfigInfoMapper::DenyUpdate, 0
    },
    { "iter", ITYPE_DWORD, &CInetInfoConfigInfoMapper::Iter,
            &CInetInfoConfigInfoMapper::DenyUpdate , 0
    },
    { "userflags", ITYPE_DWORD, &CInetInfoConfigInfoMapper::UserFlags,
        &CInetInfoConfigInfoMapper::DenyUpdate, 0
    },
    { "urlparam", ITYPE_LPSTR, &CInetInfoConfigInfoMapper::URLParam,
            &CInetInfoConfigInfoMapper::DenyUpdate , 0
    },
    { "reqparam", ITYPE_LPSTR, &CInetInfoConfigInfoMapper::ReqParam,
            &CInetInfoConfigInfoMapper::DenyUpdate , 0
    },
    { "remoteaddr", ITYPE_LPSTR, &CInetInfoConfigInfoMapper::RemoteAddr,
            &CInetInfoConfigInfoMapper::DenyUpdate , 0
    },
    { "hostname", ITYPE_LPSTR, &CInetInfoConfigInfoMapper::HostName,
            &CInetInfoConfigInfoMapper::DenyUpdate , 0
    },
    { "htmlapath", ITYPE_LPSTR, &CInetInfoConfigInfoMapper::HtmlaPath,
            &CInetInfoConfigInfoMapper::DenyUpdate , 0
    },
    { "arg1", ITYPE_LPSTR, &CInetInfoConfigInfoMapper::Arg1,
            &CInetInfoConfigInfoMapper::DenyUpdate , 0
    },
    { "arg2", ITYPE_LPSTR, &CInetInfoConfigInfoMapper::Arg2,
            &CInetInfoConfigInfoMapper::DenyUpdate , 0
    },
    { "arg3", ITYPE_LPSTR, &CInetInfoConfigInfoMapper::Arg3,
            &CInetInfoConfigInfoMapper::DenyUpdate , 0
    },

    // version information

    { "w3version", ITYPE_LPSTR, &CInetInfoConfigInfoMapper::W3Version,
        &CInetInfoConfigInfoMapper::DenyUpdate, 0
    },
    { "platformtype", ITYPE_DWORD, &CInetInfoConfigInfoMapper::PlatformType,
        &CInetInfoConfigInfoMapper::DenyUpdate, 0
    },

    { "w3cryptcapable", ITYPE_DWORD, &CInetInfoConfigInfoMapper::CryptCapable,
            &CInetInfoConfigInfoMapper::DenyUpdate, 0
    },

    { "rootdir", ITYPE_LPSTR, &CInetInfoConfigInfoMapper::DirRootDir,
            &CInetInfoConfigInfoMapper::IgnoreUpdate , 0
    },
    { "basedir", ITYPE_LPSTR, &CInetInfoConfigInfoMapper::DirBaseDir,
            &CInetInfoConfigInfoMapper::IgnoreUpdate, 0
    },
    { "dircount", ITYPE_DWORD, &CInetInfoConfigInfoMapper::DirCount,
            &CInetInfoConfigInfoMapper::IgnoreUpdate , 0
    },
    { "direntry", ITYPE_LPSTR, &CInetInfoConfigInfoMapper::DirEntry,
            &CInetInfoConfigInfoMapper::IgnoreUpdate , 0
    },
    { "dircompcount", ITYPE_DWORD, &CInetInfoConfigInfoMapper::DirCompCount,
            &CInetInfoConfigInfoMapper::IgnoreUpdate , 0
    },
    { "dircompentry", ITYPE_LPSTR, &CInetInfoConfigInfoMapper::DirCompEntry,
            &CInetInfoConfigInfoMapper::IgnoreUpdate , 0
    },
    { "dirfcompentry", ITYPE_LPSTR, &CInetInfoConfigInfoMapper::DirFCompEntry,
            &CInetInfoConfigInfoMapper::IgnoreUpdate , 0
    },
    { "drivecount", ITYPE_DWORD, &CInetInfoConfigInfoMapper::DriveCount,
            &CInetInfoConfigInfoMapper::IgnoreUpdate , 0
    },
    { "drivenameentry", ITYPE_LPSTR, &CInetInfoConfigInfoMapper::DriveNameEntry,
            &CInetInfoConfigInfoMapper::IgnoreUpdate , 0
    },
    { "drivelabelentry", ITYPE_LPSTR, &CInetInfoConfigInfoMapper::DriveLabelEntry,
            &CInetInfoConfigInfoMapper::IgnoreUpdate , 0
    },
    { "drivetypeentry", ITYPE_DWORD, &CInetInfoConfigInfoMapper::DriveTypeEntry,
            &CInetInfoConfigInfoMapper::IgnoreUpdate , 0
    },

} ;


///////////// User enumeration

// Generic for all services. This structure is bound to
// a CInetInfoConfigInfoMapper object, which will provide service type.
// Gives access to the list of currently connected users for this service.


CUserEnum::CUserEnum(
    VOID )
{
}


CUserEnum::~CUserEnum(
    VOID )
{
}


BOOL
CUserEnum::Init(
    CInetInfoConfigInfoMapper* pM )
{
    m_pMapper = pM;
    m_pUsers = NULL;
    Reset();

    return TRUE;
}


// Unbind object with user list

void
CUserEnum::Reset(
    VOID )
{
    if ( m_pUsers != NULL )
    {
        MIDL_user_free( m_pUsers );
        m_pUsers = NULL;
    }
    m_dwCount = 0;
}


// Insure list loaded. This allow usage on a "load on demand" basis

BOOL
CUserEnum::InsureLoaded(
    VOID )
{
    NET_API_STATUS is = 0;

    if ( m_pUsers == NULL )
    {
        // get list relevant to current service

        __try {

            switch ( m_pMapper->GetType() )
            {
                case INET_HTTP_SVC_ID:
                    is = W3EnumerateUsers( m_pMapper->GetComputerName(),
                            &m_dwCount, &m_pUsers );
                    break;

                case INET_FTP_SVC_ID:
                    is = I_FtpEnumerateUsers( m_pMapper->GetComputerName(),
                            &m_dwCount, (LPFTP_USER_INFO*)&m_pUsers );
                    break;

                default:
                    // no list : error
                    is = (NET_API_STATUS)~0;
                    break;
            }

        }
        __except( EXCEPTION_EXECUTE_HANDLER )
        {
            if ( m_pUsers != NULL )
            {
                MIDL_user_free( m_pUsers );
            }
            is = (NET_API_STATUS)~0;
        }

        if ( is != 0 )
        {
            m_pMapper->SetRequestStatus( HTR_USER_ENUM_ACCESS_ERROR );
        }
    }

    return is == 0 ? TRUE : FALSE;
}


// User count

BOOL
CUserEnum::GetCount(
    LPVOID* pV )
{
    if ( InsureLoaded() )
    {
        *pV = (LPVOID)&m_dwCount;
        return TRUE;
    }
    return FALSE;
}


// User Name

BOOL
CUserEnum::GetName(
    LPVOID* pV )
{
    DWORD dwI = m_pMapper->GetIter();

    if ( InsureLoaded() && dwI < m_dwCount )
    {
        *pV = (LPVOID)&m_pUsers[dwI].pszUser;
        return TRUE;
    }
    return FALSE;
}


// Is user logged-in as anonymous ?

BOOL
CUserEnum::GetAnonymous(
    LPVOID* pV )
{
    DWORD dwI = m_pMapper->GetIter();

    if ( InsureLoaded() && dwI < m_dwCount )
    {
        *pV = (LPVOID)&m_pUsers[dwI].fAnonymous;
        return TRUE;
    }
    return FALSE;
}


// User IP address

BOOL
CUserEnum::GetAddr(
    LPVOID* pV )
{
    DWORD dwI = m_pMapper->GetIter();

    if ( InsureLoaded() && dwI < m_dwCount )
    {
        *pV = (LPVOID)&m_pUsers[dwI].inetHost;
        return TRUE;
    }
    return FALSE;
}


BOOL
CUserEnum::GetCountAsDWORD(
    LPDWORD pDW )
{
    if ( InsureLoaded() )
    {
        *pDW = m_dwCount;
        return TRUE;
    }
    return FALSE;
}


BOOL
CUserEnum::GetIDAsDWORD(
    LPDWORD pDW )
{
    DWORD dwI = m_pMapper->GetIter();

    if ( InsureLoaded() && dwI < m_dwCount )
    {
        *pDW = m_pUsers[dwI].idUser;
        return TRUE;
    }
    return FALSE;
}


// User connection time

BOOL
CUserEnum::GetTime(
    LPVOID* pV )
{
    DWORD dwI = m_pMapper->GetIter();

    if ( InsureLoaded() && dwI < m_dwCount )
    {
        *pV = (LPVOID)&m_pUsers[dwI].tConnect;
        return TRUE;
    }
    return FALSE;
}


// User ID

BOOL
CUserEnum::GetID(
    LPVOID* pV )
{
    DWORD dwI = m_pMapper->GetIter();

    if ( InsureLoaded() && dwI < m_dwCount )
    {
        *pV = (LPVOID)&m_pUsers[dwI].idUser;
        return TRUE;
    }
    return FALSE;
}


///////////// Dynamic string class

CDStr::CDStr(
    VOID )
{
    Init();
}


CDStr::~CDStr(
    VOID )
{
    if ( m_pStr != NULL )
    {
        delete [] m_pStr;
    }
}


void
CDStr::Reset(
    VOID )
{
    if ( m_pStr != NULL )
    {
        delete [] m_pStr;
    }
    Init();
}


BOOL
CDStr::Init(
    VOID )
{
    m_pStr = NULL;
    m_dwAlloc = m_dwLen = 0;
    return TRUE;
}


LPSTR
CDStr::GetString(
    VOID )
{
    return m_pStr;
}


BOOL
CDStr::Add(
    LPSTR pS )
/*++

Routine Description:

    Add a sz string to a dynamic string

Arguments:

    pS - string to add at the end of the dynamic string

Returns:

    TRUE on success, FALSE on failure

--*/
{
    return AddRange( pS, lstrlen( pS ) );
}


BOOL
CDStr::AddRange(
    LPSTR pS,
    DWORD dwL )
/*++

Routine Description:

    Add a character range to a dynamic string

Arguments:

    pS - character range to add at the end of the dynamic string
    dwL - # of characters to add

Returns:

    TRUE on success, FALSE on failure

--*/
{
    if ( m_dwLen + dwL + 1 > m_dwAlloc )
    {
        DWORD dwN = ( ( m_dwLen + dwL + 1 + 128 ) / 128 ) * 128;
        LPSTR pN = new char[dwN];
        if ( pN == NULL )
        {
            return FALSE;
        }
        if ( m_pStr != NULL )
        {
            memcpy( pN, m_pStr, m_dwLen );
            delete [] m_pStr;
        }
        m_pStr = pN;
        m_dwAlloc = dwN;
    }

    memcpy( m_pStr + m_dwLen, pS, dwL );
    m_dwLen += dwL;
    m_pStr[ m_dwLen ] = '\0';

    return TRUE;
}


#if defined(GENERATE_AUTH_HEADERS)

//
// This class handles the generation of the authentication sequence
// as a list of supported WWW-Authenticate scheme.
// This is necessary for IIS/1.0, not for IIS/1.1+
//


CAuthenticationReqs::CAuthenticationReqs(
    VOID )
{
}


CAuthenticationReqs::~CAuthenticationReqs(
    VOID )
{
}


DWORD
WINAPI AuthUpdateIndication(
    LPVOID pV )
{
    return ((CAuthenticationReqs*)pV)->UpdateIndication();
}


BOOL
CAuthenticationReqs::Init(
    VOID )
/*++

Routine Description:

    Initialize the authentication package, which provides a way
    for an ISAPI app to retrieve the list of supported authentication
    methods as a list of HTTP WWW-Authenticate headers.
    build the initial authentication list, create a registry update
    monitor thread to check for changes in supported authentication
    methods.

Arguments:

    None

Returns:

    TRUE on success, FALSE on failure

--*/
{
    m_dsH.Init();
    m_pszProviders = NULL;
    INITIALIZE_CRITICAL_SECTION( &m_csR );

    m_hNotifyEvent = CreateEvent( NULL, FALSE, FALSE, NULL );
    m_fRequestTerminate = FALSE;

    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
            W3SVC_REGISTRY_PATH,
            0,
            KEY_READ,
            &m_hKey ) == ERROR_SUCCESS )
    {
        // retrieve methods
        UpdateMethodsIndication();

        // retrieve NT list
        UpdateNTAuthenticationProvidersIndication();

        // create registry monitoring thread
        DWORD dwID;
        if ( (m_hThread = CreateThread( NULL,
                0,
                (LPTHREAD_START_ROUTINE)::AuthUpdateIndication,
                (LPVOID)this,
                0,
                &dwID )) == NULL )
        {
            return FALSE;
        }

        return BuildListHeader();
    }
    else
    {
        m_hKey = NULL;
    }

    return FALSE;
}


//
// wait for an update notification from the registry
//

DWORD
CAuthenticationReqs::UpdateIndication(
    VOID )
/*++

Routine Description:

    Thread monitoring authentication methods update in registry

Arguments:

    None

Returns:

    NT error

--*/
{
    for ( ;; )
    {
        if ( RegNotifyChangeKeyValue( m_hKey,
                FALSE,
                REG_NOTIFY_CHANGE_LAST_SET,
                m_hNotifyEvent,
                TRUE ) != ERROR_SUCCESS )
        {
            break;
        }
        if ( WaitForSingleObject( m_hNotifyEvent, INFINITE)
                != WAIT_OBJECT_0 )
        {
            break;
        }
        if ( m_fRequestTerminate )
        {
            break;
        }
        UpdateMethodsIndication();
        UpdateNTAuthenticationProvidersIndication();
        BuildListHeader();
    }

    return 0;
}


BOOL
CAuthenticationReqs::Terminate(
    VOID )
/*++

Routine Description:

    Request the monitoring thread to terminate

Arguments:

    None

Returns:

    TRUE if thread successfully terminated, else FALSE

--*/
{
    // request thread kill
    m_fRequestTerminate = TRUE;
    SetEvent( m_hNotifyEvent );

    if ( m_hThread != NULL && WaitForSingleObject( m_hThread, 1000 * 3 )
            == WAIT_OBJECT_0 )
    {
        CloseHandle( m_hThread );
        m_hThread = NULL;

        DeleteCriticalSection( &m_csR );
        if ( m_pszProviders != NULL )
        {
            delete [] m_pszProviders;
        }
        if ( m_hKey != NULL )
        {
            RegCloseKey( m_hKey );
        }
        if ( m_hNotifyEvent != NULL )
        {
            CloseHandle( m_hNotifyEvent );
        }
        if ( m_hThread != NULL )
        {
            CloseHandle( m_hThread );
        }

        return TRUE;
    }

    return FALSE;
}


BOOL
CAuthenticationReqs::UpdateMethodsIndication(
    VOID )
/*++

Routine Description:

    Update bitmap of supported authentication methods

Arguments:

    None

Returns:

    TRUE on success, else FALSE

--*/
{
    BOOL fSt = FALSE;

    Lock();

    // access registry
    DWORD dwType;
    DWORD dwM;
    DWORD cData = sizeof( dwM );
    if ( RegQueryValueEx( m_hKey, W3SVC_REGISTRY_AUTHENTICATION,
            NULL, &dwType, (PBYTE)&dwM, &cData ) == ERROR_SUCCESS
            && dwType == REG_DWORD  )
    {
        fSt = TRUE;
        m_dwMethods = dwM;
    }

    UnLock();

    return fSt;
}


BOOL
CAuthenticationReqs::BuildListHeader(
    VOID )
/*++

Routine Description:

    Build a list of HTTP headers specifying all authentication methods
    supported by the local HTTP server in m_dsH

Arguments:

    None

Returns:

    TRUE on success, FALSE on failure

--*/
{
    BOOL fAdded = FALSE;

    Lock();

    m_dsH.Reset();

    if ( m_dwMethods & INET_INFO_AUTH_CLEARTEXT )
    {
        m_dsH.Add( WWW_AUTHENTICATE_HEADER );
        m_dsH.Add( "Basic realm=\"NTSRV\"\r\n" );
        fAdded = TRUE;
    }

    if ( (m_dwMethods & INET_INFO_AUTH_NT_AUTH)
            && m_pszProviders != NULL )
    {
        LPSTR pS, pT;
        // iterate through comma-separated list
        for ( pS = m_pszProviders ; *pS ; )
        {
            if ( (pT = strchr( pS, ',' )) == NULL )
            {
                pT = pS + lstrlen( pS );
            }
            m_dsH.Add( WWW_AUTHENTICATE_HEADER );
            m_dsH.AddRange( pS, pT - pS );
            m_dsH.Add( "\r\n" );
            pS = *pT ? pT + 1 : pT;
            fAdded = TRUE;
        }
    }

    if ( fAdded )
    {
        m_dsH.Add( "\r\n" );
    }

    UnLock();

    return TRUE;
}


BOOL
CAuthenticationReqs::UpdateNTAuthenticationProvidersIndication(
    VOID )
/*++

Routine Description:

    Update list of supported SSPI authentication methods

Arguments:

    None

Returns:

    TRUE on success, FALSE on failure

--*/
{
    BOOL fSt = FALSE;

    Lock();

    if ( m_pszProviders != NULL )
    {
        delete [] m_pszProviders;
        m_pszProviders = NULL;
    }

    // access registry
    DWORD cData = 256;
    DWORD dwType;
    if ( (m_pszProviders = new char[cData]) != NULL )
    {
        if ( RegQueryValueEx( m_hKey,
                W3SVC_REGISTRY_NTAUTHENTICATIONPROVIDERS,
                NULL,
                &dwType,
                (PBYTE)m_pszProviders,
                &cData ) == ERROR_SUCCESS
                && dwType == REG_SZ  )
        {
            fSt = TRUE;
        }
        else
        {
            delete [] m_pszProviders;
            m_pszProviders = NULL;
        }
    }

    UnLock();

    return fSt;
}


LPSTR
CAuthenticationReqs::GetAuthenticationListHeader(
    VOID )
/*++

Routine Description:

    Return the list of supported authentication
    methods as a list of HTTP WWW-Authenticate headers.
    The returned string is either empty or terminated by
    a blank line.

Arguments:

    None

Returns:

    TRUE on success, FALSE on failure

--*/
{
    return m_dsH.GetString();
}

#endif


///////////// Mapper

CInetInfoConfigInfoMapper::CInetInfoConfigInfoMapper(
    VOID )
{
}


CInetInfoConfigInfoMapper::~CInetInfoConfigInfoMapper(
    VOID )
{
#if !defined(IISv1)
    if ( m_pServerCaps != NULL )
    {
        MIDL_user_free( m_pServerCaps );
    }
#endif
    DeleteCriticalSection( &m_csLock );
}


BOOL
CInetInfoConfigInfoMapper::Init(
    CInetInfoMap* pMap,
    int cNbMap,
    DWORD dwS )
{
    INITIALIZE_CRITICAL_SECTION( &m_csLock );
    m_pMap = pMap;
    m_cNbMap = cNbMap;
    m_dwCurrentServerType = dwS;

    m_pGlobalConfig = NULL;
    m_pConfig = NULL;
    m_pServerCaps = NULL;
    m_pW3Config = NULL;
    m_pFtpConfig = NULL;
    m_pGdConfig = NULL;

    m_pFirstAlloc = m_pLastAlloc = NULL;

    m_fGotServerCapsAndVersion = FALSE;

    m_pszHtmlaPath = g_achHtmlaPath;
    m_pszHostName = m_achHostName;
    m_pszW3Version = g_achW3Version;
    m_pszRPCStatusString = NULL;
    m_fAllocatedRPCStatusString = FALSE;

    m_Users.Init( this );
    m_Drive.Init( this );

    return TRUE;
}


// variables access

BOOL
CInetInfoConfigInfoMapper::GlobalIsBandwidthLimited(
    LPVOID* pV )
/*++

Routine Description:

    Update a pointer to the virtual variable exposing the
    "global bandwidth is limited" setting.
    HTMLA var: "globalisbandwidthlimited"

Arguments:

    None

Returns:

    TRUE on success, FALSE on failure

--*/
{
    if ( m_pGlobalConfig != NULL )
    {
        m_dwIsBandwidthLimited = m_pGlobalConfig->BandwidthLevel
                != DWORD(-1) ? TRUE : FALSE;
        *pV = (LPVOID)&m_dwIsBandwidthLimited;
        return TRUE;
    }
    return FALSE;
}


void
CInetInfoConfigInfoMapper::AdjustFromIPSingle(
    LPBYTE pMsk )
/*++

Routine Description:

    Adjust network mask to be consistent
    with the virtual var controlling if this entry is for
    a single address or not.
    If single address the mask if set to all 1 ( i.e. the whole
    network address is significant ).

Arguments:

    None

Returns:

    None

--*/
{
    if ( m_dwIsIPSingle == 1 )
    {
        memset( pMsk, 0xff, IP_ADDR_BYTE_SIZE );
    }
}


void
CInetInfoConfigInfoMapper::AdjustIPSingle(
    LPBYTE pMsk )
/*++

Routine Description:

    Determine if the mask describes a single IP address ( i.e. is all 1 )
    and updates the virtual var controlling 'singleness' accordingly

Arguments:

    None

Returns:

    None

--*/
{
    m_dwIsIPSingle =  0;
    for ( int x = 0 ; x < IP_ADDR_BYTE_SIZE ; ++x )
    {
        if ( pMsk[x] != 0xff )
        {
            return;
        }
    }
    m_dwIsIPSingle =  1;
}


BOOL
CInetInfoConfigInfoMapper::DenyIsIPSingle(
    LPVOID* pV )
/*++

Routine Description:

    Adjust the virtual variable to be TRUE if the current entry
    in the IP deny access list is a single address, otherwise FALSE.
    Update a pointer to this virtual variable on exit.
    HTMLA var: "denyisipsingle"

Arguments:

    None

Returns:

    TRUE on success, FALSE on failure

--*/
{
    if ( m_pConfig!=NULL && m_pConfig->DenyIPList
            && m_iIter < m_pConfig->DenyIPList->cEntries )
    {
        AdjustIPSingle( (LPBYTE)&m_pConfig->DenyIPList
                ->aIPSecEntry[m_iIter].dwMask );
        *pV = (LPVOID)&m_dwIsIPSingle;
        return TRUE;
    }
    return FALSE;
}


BOOL
CInetInfoConfigInfoMapper::GrantIsIPSingle(
    LPVOID* pV )
/*++

Routine Description:

    Adjust the virtual variable to be TRUE if the current entry
    in the IP grant access list is a single address, otherwise FALSE.
    Update a pointer to this virtual variable on exit.
    HTMLA var: "grantisipsingle"

Arguments:

    None

Returns:

    TRUE on success, FALSE on failure

--*/
{
    if ( m_pConfig!=NULL && m_pConfig->GrantIPList
            && m_iIter < m_pConfig->GrantIPList->cEntries )
    {
        AdjustIPSingle( (LPBYTE)&m_pConfig->GrantIPList
                ->aIPSecEntry[m_iIter].dwMask );
        *pV = (LPVOID)&m_dwIsIPSingle;
        return TRUE;
    }
    return FALSE;
}


BOOL
CInetInfoConfigInfoMapper::DirBrowseEnab(
    LPVOID *pV )
/*++

Routine Description:

    Update a pointer to the virtual variable exposing the
    "directory browsing enabled" setting.
    HTMLA var: "w3dirbrowseenabled"

Arguments:

    None

Returns:

    TRUE on success, FALSE on failure

--*/
{
    if ( m_pW3Config != NULL )
    {
        m_DirBrowseEnab = (m_pW3Config->dwDirBrowseControl&DIRBROW_ENABLED)
                ? TRUE : FALSE;
        *pV = &m_DirBrowseEnab;
        return TRUE;
    }
    return FALSE;
}


BOOL
CInetInfoConfigInfoMapper::DefFileEnab(
    LPVOID *pV )
/*++

Routine Description:

    Update a pointer to the virtual variable exposing the
    "default file enabled" setting.
    HTMLA var: "w3defaultfileenabled"

Arguments:

    None

Returns:

    TRUE on success, FALSE on failure

--*/
{
    if ( m_pW3Config != NULL )
    {
        m_DefFileEnab = (m_pW3Config->dwDirBrowseControl&DIRBROW_LOADDEFAULT)
                ? TRUE : FALSE;
        *pV = &m_DefFileEnab;
        return TRUE;
    }
    return FALSE;
}


BOOL
CInetInfoConfigInfoMapper::SetRootEntryVars(
    VOID )
/*++

Routine Description:

    Set virtual vars exposing various properties of the current
    virtual root entry :
    Home status, read, write, exec, SSL required

Arguments:

    None

Returns:

    TRUE on success, FALSE on failure

--*/
{
    if ( m_fInvEntry )
    {
        if ( m_pConfig->VirtualRoots->aVirtRootEntry[m_iIter].pszRoot
                != NULL )
        {
            m_fRootIsHome = !wcscmp(
                    m_pConfig->VirtualRoots->aVirtRootEntry[m_iIter].pszRoot,
                    HOME_DIR_PATH ) ? TRUE : FALSE;
        }
        else
        {
            m_fRootIsHome = FALSE;
        }

        m_fRootIsRead =
                (m_pConfig->VirtualRoots->aVirtRootEntry[m_iIter].dwMask
                & VROOT_MASK_READ) ? TRUE : FALSE;

        m_fRootIsWrite =
                (m_pConfig->VirtualRoots->aVirtRootEntry[m_iIter].dwMask
                & VROOT_MASK_WRITE) ? TRUE : FALSE;

        m_fRootIsExec =
                (m_pConfig->VirtualRoots->aVirtRootEntry[m_iIter].dwMask
                & VROOT_MASK_EXECUTE) ? TRUE : FALSE;

        m_fRootIsSSL =
                (m_pConfig->VirtualRoots->aVirtRootEntry[m_iIter].dwMask
                & VROOT_MASK_SSL) ? TRUE : FALSE;

        m_fInvEntry = TRUE;
    }

    return TRUE;
}


BOOL
CInetInfoConfigInfoMapper::RootIsHome(
    LPVOID *pV )
/*++

Routine Description:

    Update a pointer to the virtual variable exposing the
    "current virtual root is home" setting.
    HTMLA var: rootishome

Arguments:

    None

Returns:

    TRUE on success, FALSE on failure

--*/
{
    if ( m_pConfig != NULL && m_pConfig->VirtualRoots
            && m_iIter < m_pConfig->VirtualRoots->cEntries )
    {
        // must call set vars, cannot make any assumptions about
        // current virtual root entry

        SetRootEntryVars();
        *pV = &m_fRootIsHome;
        return TRUE;
    }
    return FALSE;
}


BOOL
CInetInfoConfigInfoMapper::RootName(
    LPVOID *pV )
/*++

Routine Description:

    Update a pointer to the name of the current virtual root entry
    HTMLA var: "rootname"

Arguments:

    None

Returns:

    TRUE on success, FALSE on failure

--*/
{
    if ( m_pConfig!=NULL && m_pConfig->VirtualRoots
            && m_iIter < m_pConfig->VirtualRoots->cEntries )
    {
        *pV = (LPVOID)&m_pConfig->VirtualRoots
                ->aVirtRootEntry[m_iIter].pszRoot;
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}


BOOL
CInetInfoConfigInfoMapper::RootIsRead(
    LPVOID *pV )
/*++

Routine Description:

    Update a pointer to the virtual variable exposing the
    "current virtual root has read access" setting.
    HTMLA var: "rootisread"

Arguments:

    None

Returns:

    TRUE on success, FALSE on failure

--*/
{
    if ( m_pConfig != NULL
            && m_pConfig->VirtualRoots
            && m_iIter < m_pConfig->VirtualRoots->cEntries )
    {
        // must call set vars, cannot make any assumptions about
        // current virtual root entry

        SetRootEntryVars();
        *pV = &m_fRootIsRead;
        return TRUE;
    }
    return FALSE;
}


BOOL
CInetInfoConfigInfoMapper::RootIsWrite(
    LPVOID *pV )
/*++

Routine Description:

    Update a pointer to the virtual variable exposing the
    "current virtual root has write access" setting.
    HTMLA var: "rootiswrite"

Arguments:

    None

Returns:

    TRUE on success, FALSE on failure

--*/
{
    if ( m_pConfig != NULL
            && m_pConfig->VirtualRoots
            && m_iIter < m_pConfig->VirtualRoots->cEntries )
    {
        // must call set vars, cannot make any assumptions about
        // current virtual root entry

        SetRootEntryVars();
        *pV = &m_fRootIsWrite;
        return TRUE;
    }
    return FALSE;
}


BOOL
CInetInfoConfigInfoMapper::RootIsExec(
    LPVOID *pV )
/*++

Routine Description:

    Update a pointer to the virtual variable exposing the
    "current virtual root has execute access" setting.
    HTMLA var: "rootisexec"

Arguments:

    None

Returns:

    TRUE on success, FALSE on failure

--*/
{
    if ( m_pConfig != NULL
            && m_pConfig->VirtualRoots
            && m_iIter < m_pConfig->VirtualRoots->cEntries )
    {
        // must call set vars, cannot make any assumptions about
        // current virtual root entry

        SetRootEntryVars();
        *pV = &m_fRootIsExec;
        return TRUE;
    }
    return FALSE;
}


BOOL
CInetInfoConfigInfoMapper::RootIsSSL(
    LPVOID *pV )
/*++

Routine Description:

    Update a pointer to the virtual variable exposing the
    "current virtual root requires SSL access" setting.
    HTMLA var: "rootisssl"

Arguments:

    None

Returns:

    TRUE on success, FALSE on failure

--*/
{
    if ( m_pConfig != NULL
            && m_pConfig->VirtualRoots
            && m_iIter < m_pConfig->VirtualRoots->cEntries )
    {
        // must call set vars, cannot make any assumptions about
        // current virtual root entry

        SetRootEntryVars();
        *pV = &m_fRootIsSSL;
        return TRUE;
    }
    return FALSE;
}


BOOL
CInetInfoConfigInfoMapper::AuthAnon(
    LPVOID *pV )
/*++

Routine Description:

    Update a pointer to the virtual variable exposing the
    enable anonymous access setting.
    HTMLA var: "authanon"

Arguments:

    None

Returns:

    TRUE on success, FALSE on failure

--*/
{
    if ( m_pConfig != NULL )
    {
        m_fAuthAnon = m_pConfig->dwAuthentication&INET_INFO_AUTH_ANONYMOUS
                ? TRUE : FALSE;
        *pV = &m_fAuthAnon;
        return TRUE;
    }
    return FALSE;
}


BOOL
CInetInfoConfigInfoMapper::AuthBasic(
    LPVOID *pV )
/*++

Routine Description:

    Update a pointer to the virtual variable exposing the
    enable basic ( clear text password ) access setting.
    HTMLA var: "authbasic"

Arguments:

    None

Returns:

    TRUE on success, FALSE on failure

--*/
{
    if ( m_pConfig != NULL )
    {
        m_fAuthBasic = m_pConfig->dwAuthentication&INET_INFO_AUTH_CLEARTEXT
                ? TRUE : FALSE;
        *pV = &m_fAuthBasic;
        return TRUE;
    }
    return FALSE;
}


BOOL
CInetInfoConfigInfoMapper::AuthNT(
    LPVOID *pV )
/*++

Routine Description:

    Update a pointer to the virtual variable exposing the
    enable NTLM based authentication access setting.
    HTMLA var: "authnt"

Arguments:

    None

Returns:

    TRUE on success, FALSE on failure

--*/
{
    if ( m_pConfig != NULL )
    {
        m_fAuthNT = m_pConfig->dwAuthentication&INET_INFO_AUTH_NT_AUTH
                ? TRUE : FALSE;
        *pV = &m_fAuthNT;
        return TRUE;
    }
    return FALSE;
}


BOOL
CInetInfoConfigInfoMapper::EnableLog(
    LPVOID *pV )
/*++

Routine Description:

    Update a pointer to the virtual variable exposing the
    enable log setting.
    HTMLA var: "enablelog"

Arguments:

    None

Returns:

    TRUE on success, FALSE on failure

--*/
{
    if ( m_pConfig != NULL )
    {
        m_fEnableLog = m_pConfig->lpLogConfig->inetLogType
                ? TRUE : FALSE;
        *pV = &m_fEnableLog;
        return TRUE;
    }
    return FALSE;
}


BOOL
CInetInfoConfigInfoMapper::EnableNewLog(
    LPVOID *pV )
/*++

Routine Description:

    Update a pointer to the virtual variable exposing the
    enable new log file creation setting.
    HTMLA var: "enablenewlog"

Arguments:

    None

Returns:

    TRUE on success, FALSE on failure

--*/
{
    if ( m_pConfig != NULL )
    {
        m_fEnableNewLog = m_dwLogPeriod ? TRUE : FALSE;
        *pV = &m_fEnableNewLog;
        return TRUE;
    }
    return FALSE;
}


//
// Update indication for variables
// These functions are called AFTER the script updated the
// corresponding variable.
//


BOOL
CInetInfoConfigInfoMapper::UpdateGlobalIsBandwidthLimited(
    VOID )
/*++

Routine Description:

    Adjust bandwidth limit to be consistent
    with setting controlling whether bandwidth is limited.
    HTMLA var: "globalisbandwidthlimited"

Arguments:

    None

Returns:

    TRUE on success, FALSE on failure

--*/
{
    if ( m_pGlobalConfig != NULL )
    {
        if ( m_dwIsBandwidthLimited == 0 )
            m_pGlobalConfig->BandwidthLevel = DWORD(-1);
        SetField( m_pGlobalConfig->FieldControl, FC_GINET_INFO_ALL );
        return TRUE;
    }
    return FALSE;
}


BOOL
CInetInfoConfigInfoMapper::UpdateGlobalBandwidth(
    VOID )
/*++

Routine Description:

    Adjust bandwidth limit to be consistent
    with the virtual var controlling whether bandwidth is limited.
    This assumes that the virtual var "globalisbandwidthlimited" appears
    BEFORE the "globalbandwidth" variable.
    HTMLA var: "globalbandwidth"

Arguments:

    None

Returns:

    TRUE on success, FALSE on failure

--*/
{
    if ( m_pGlobalConfig != NULL )
    {
        if ( m_dwIsBandwidthLimited == 0 )
        {
            m_pGlobalConfig->BandwidthLevel = DWORD(-1);
        }
        SetField( m_pGlobalConfig->FieldControl, FC_GINET_INFO_ALL );
        return TRUE;
    }
    return FALSE;
}


BOOL
CInetInfoConfigInfoMapper::UpdateDenyIsIPSingle(
    VOID )
/*++

Routine Description:

    Adjust network mask for Deny IP access list to be consistent
    with the virtual var controlling if this entry is for
    a single address or not.
    This assumes that the virtual var "denyisipsingle" appears
    BEFORE the "denyipmask" variable.
    HTMLA var: "denyisipsingle"

Arguments:

    None

Returns:

    TRUE on success, FALSE on failure

--*/
{
    if ( m_pConfig!=NULL
            && m_pConfig->DenyIPList
            && m_iIter < m_pConfig->DenyIPList->cEntries )
    {
        AdjustFromIPSingle( (LPBYTE)&m_pConfig->DenyIPList
                ->aIPSecEntry[m_iIter].dwMask );
        UpdateIP();
        return TRUE;
    }
    return FALSE;
}


BOOL
CInetInfoConfigInfoMapper::UpdateGrantIsIPSingle(
    VOID )
/*++

Routine Description:

    Adjust network mask for Grant IP access list to be consistent
    with the virtual var controlling if this entry is for
    a single address or not.
    This assumes that the virtual var "grantisipsingle" appears
    BEFORE the "grantipmask" variable.
    HTMLA var: "grantisipsingle"

Arguments:

    None

Returns:

    TRUE on success, FALSE on failure

--*/
{
    if ( m_pConfig!=NULL
        && m_pConfig->GrantIPList
        && m_iIter < m_pConfig->GrantIPList->cEntries )
    {
        AdjustFromIPSingle( (LPBYTE)&m_pConfig->GrantIPList
                ->aIPSecEntry[m_iIter].dwMask );
        UpdateIP();
        return TRUE;
    }
    return FALSE;
}


BOOL
CInetInfoConfigInfoMapper::UpdateDirControl(
    VOID )
/*++

Routine Description:

    Synchronize virtual vars updated by the user request
    for directory attributes ( browsing, use default file )
    and RPC structures.

Arguments:

    None

Returns:

    TRUE on success, FALSE on failure

--*/
{
    if ( m_DirBrowseEnab )
    {
        m_pW3Config->dwDirBrowseControl |= DIRBROW_ENABLED;
    }
    else
    {
        m_pW3Config->dwDirBrowseControl &= ~DIRBROW_ENABLED;
    }

    if ( m_DefFileEnab )
    {
        m_pW3Config->dwDirBrowseControl |= DIRBROW_LOADDEFAULT;
    }
    else
    {
        m_pW3Config->dwDirBrowseControl &= ~DIRBROW_LOADDEFAULT;
    }

    SetField( m_pW3Config->FieldControl, FC_W3_DIR_BROWSE_CONTROL );

    return TRUE;
}


BOOL
CInetInfoConfigInfoMapper::UpdateRootName(
    VOID )
/*++

Routine Description:

    Synchronize virtual vars updated by the user request
    for virtual root name ( name, home directory or not )
    and RPC structures.
    It assumes that the 'homeness' status of this virtual root
    is determined BEFORE the name, i.e. that the 'home' setting
    appears before the virtual root name in the HTMLA form

    The user setting will be overidden if the virtual root is home
    In this case, the virtual root name will be set to HOME_DIR_PATH

    HTMLA var: "rootname"

Arguments:

    None

Returns:

    TRUE on success, FALSE on failure

--*/
{
    BOOL fSt = TRUE;

    if ( UpdateRoot() )
    {
        if ( m_fRootIsHome )
        {
            LPWSTR pszRoot = (LPWSTR)Alloc( (wcslen( HOME_DIR_PATH ) + 1)
                    * sizeof(WCHAR) );
            if ( pszRoot == NULL )
            {
                fSt = FALSE;
            }
            else
            {
                wcscpy( pszRoot, HOME_DIR_PATH );
                m_pConfig->VirtualRoots->aVirtRootEntry[m_iIter]
                        .pszRoot = pszRoot;
            }
        }
        else
        {
            LPWSTR pszR = m_pConfig->VirtualRoots->aVirtRootEntry[m_iIter].pszRoot;
            if ( pszR[0] == L'\0' || !wcscmp( L"/", pszR ) )
            {
                // no name was specified, auto-alias
                fSt = AliasVirtDir( m_pConfig->VirtualRoots
                        ->aVirtRootEntry + m_iIter );
            }
        }
    }
    else
    {
        fSt = FALSE;
    }

    return fSt;
}


BOOL
CInetInfoConfigInfoMapper::UpdateRootMask(
    VOID )
/*++

Routine Description:

    Synchronize virtual vars updated by the user request
    for directory attributes ( read, execute, SSL required )
    and RPC structures.

Arguments:

    None

Returns:

    TRUE on success, FALSE on failure

--*/
{
    if ( m_pConfig != NULL && m_iIter < m_pConfig->VirtualRoots->cEntries )
    {
        DWORD dwMsk = m_pConfig->VirtualRoots->aVirtRootEntry[m_iIter].dwMask;

        if ( m_fRootIsRead )
        {
            dwMsk |= VROOT_MASK_READ;
        }
        else
        {
            dwMsk &= ~VROOT_MASK_READ;
        }

        if ( m_fRootIsWrite )
        {
            dwMsk |= VROOT_MASK_WRITE;
        }
        else
        {
            dwMsk &= ~VROOT_MASK_WRITE;
        }

        if ( m_fRootIsExec )
        {
            dwMsk |= VROOT_MASK_EXECUTE;
        }
        else
        {
            dwMsk &= ~VROOT_MASK_EXECUTE;
        }

        if ( m_fRootIsSSL )
        {
            dwMsk |= VROOT_MASK_SSL;
        }
        else
        {
            dwMsk &= ~VROOT_MASK_SSL;
        }

        m_pConfig->VirtualRoots->aVirtRootEntry[m_iIter].dwMask = dwMsk;

        SetField( m_pConfig->FieldControl, FC_INET_INFO_VIRTUAL_ROOTS );

        return TRUE;
    }

    return FALSE;
}


BOOL
CInetInfoConfigInfoMapper::UpdateAuth(
    VOID )
/*++

Routine Description:

    Synchronize virtual vars updated by the user request
    for supported authetication methods ( anon, clear text, NTLMSSP )
    and RPC structures.

Arguments:

    None

Returns:

    TRUE on success, FALSE on failure

--*/
{
    if ( m_pConfig != NULL )
    {
        DWORD dwMsk = m_pConfig->dwAuthentication;

        if ( m_fAuthAnon )
        {
            dwMsk |= INET_INFO_AUTH_ANONYMOUS;
        }
        else
        {
            dwMsk &= ~INET_INFO_AUTH_ANONYMOUS;
        }

        if ( m_fAuthBasic )
        {
            dwMsk |= INET_INFO_AUTH_CLEARTEXT;
        }
        else
        {
            dwMsk &= ~INET_INFO_AUTH_CLEARTEXT;
        }

        if ( m_fAuthNT )
        {
            dwMsk |= INET_INFO_AUTH_NT_AUTH;
        }
        else
        {
            dwMsk &= ~INET_INFO_AUTH_NT_AUTH;
        }

        m_pConfig->dwAuthentication = dwMsk;

        SetField( m_pConfig->FieldControl, FC_INET_INFO_AUTHENTICATION );

        return TRUE;
    }

    return FALSE;
}


BOOL
CInetInfoConfigInfoMapper::UpdateLog(
    VOID )
/*++

Routine Description:

    Acknowledge update to log settings
    ( dummy entry, no action for now )
    HTMLA var: "enablelog"

Arguments:

    None

Returns:

    TRUE

--*/
{
    return TRUE;
}


BOOL
CInetInfoConfigInfoMapper::UpdateNewLog(
    VOID )
/*++

Routine Description:

    Insure consistency between user request ( new log enabled,
    log period ) and RPC structures.
    This assumes that enable new Log type is updated BEFORE the log period
    setting, i.e. it appears before this setting in the
    HTMLA form.
    HTMLA var: "enablenewlog"

Arguments:

    None

Returns:

    TRUE on success, FALSE on failure

--*/
{
    if ( m_pConfig != NULL )
    {
        if ( !m_fEnableNewLog )
        {
            if ( INET_LOG_PERIOD_NONE
                    != m_pConfig->lpLogConfig->ilPeriod )
            {
                m_dwLogPeriod
                        = m_pConfig->lpLogConfig->ilPeriod
                        = INET_LOG_PERIOD_NONE;
            }
        }
        return TRUE;
    }
    return FALSE;
}


BOOL
CInetInfoConfigInfoMapper::UpdateLogType(
    VOID )
/*++

Routine Description:

    Insure consistency between user request ( log enabled,
    log type ) and RPC structures.
    This assumes that Log type is updated AFTER the log enabled
    setting, i.e. it appears after this setting in the
    HTMLA form.
    HTMLA var : "logtype"

Arguments:

    None

Returns:

    TRUE on success, FALSE on failure

--*/
{
    if ( m_pConfig != NULL )
    {
        if ( !m_fEnableLog )
        {
            m_pConfig->lpLogConfig->inetLogType
                    = INET_LOG_DISABLED;
        }
        if ( m_dwWasLogType != m_pConfig->lpLogConfig->inetLogType )
        {
            SetField( m_pConfig->FieldControl, FC_INET_INFO_LOG_CONFIG );
        }
        return TRUE;
    }

    return FALSE;
}


BOOL
CInetInfoConfigInfoMapper::SetLogEntryVars(
    VOID )
/*++

Routine Description:

    Update virtual vars needed by the log settings, such as
    the log period. Virtual vars are needed to expose the log type
    as a single value, in contrast with the RPC struct definition
    where multiple variables are used to encode this information

Arguments:

    None

Returns:

    TRUE on success, FALSE on failure

--*/
{
    m_dwLogPeriod = m_pConfig->lpLogConfig->ilPeriod;
    m_dwLogFormat = *((DWORD UNALIGNED *)&(m_pConfig->lpLogConfig->rgchDataSource[MAX_PATH-sizeof(DWORD)]));

    if ( m_pConfig->lpLogConfig->inetLogType
            && m_dwLogPeriod == INET_LOG_PERIOD_NONE
            && m_pConfig->lpLogConfig->cbSizeForTruncation
            != (DWORD)-1 )
    {
        m_dwLogPeriod = INET_LOG_PERIOD_ON_SIZE;
    }

    m_dwInvalidLogUpdate = 0;

    return TRUE;
}


BOOL
CInetInfoConfigInfoMapper::LogPeriod(
    LPVOID *pV )
/*++

Routine Description:

    Update a pointer to the virtual variable exposing the
    log period. In addition to the RPC definition for log period
    we support a new log period defined as "create new log when size
    reaches xxx"
    HTMLA var: "logperiod"

Arguments:

    None

Returns:

    TRUE on success, FALSE on failure

--*/
{
    if ( m_pConfig!= NULL )
    {
        *pV = &m_dwLogPeriod;
        return TRUE;
    }

    return FALSE;
}


BOOL
CInetInfoConfigInfoMapper::LogFormat(
    LPVOID *pV )
/*++

Routine Description:

    Update a pointer to the virtual variable exposing the
    log format.
    HTMLA var: "logformat"

Arguments:

    None

Returns:

    TRUE on success, FALSE on failure

--*/
{
    if ( m_pConfig!= NULL )
    {
        *pV = &m_dwLogFormat;
        return TRUE;
    }

    return FALSE;
}


BOOL
CInetInfoConfigInfoMapper::UpdateLogPeriod(
    VOID )
/*++

Routine Description:

    Insure consistency between user request ( log enabled, new log
    enabled, create new log based on size, log period ) and
    RPC structures.
    This assumes that Log period is updated AFTER the log enabled & new
    log enabled settings, i.e. it appears after these settings in the
    HTMLA form.
    HTMLA var: "logperiod"

Arguments:

    None

Returns:

    TRUE on success, FALSE on failure

--*/
{
    BOOL fUp = FALSE;

    if ( m_pConfig != NULL )
    {
        DWORD dwN;

        // check disabled or set to open on file size
        if ( !m_fEnableLog
                || !m_fEnableNewLog
                || m_dwLogPeriod == INET_LOG_PERIOD_ON_SIZE )
        {
            dwN = INET_LOG_PERIOD_NONE;
        }
        else
        {
            if ( 0 == (dwN = m_dwLogPeriod) )
            {
                if ( m_fEnableLog && m_fEnableNewLog )
                {
                    return FALSE;
                }
            }
            m_pConfig->lpLogConfig->cbSizeForTruncation
                    = 0;
        }

        if ( dwN != m_pConfig->lpLogConfig->ilPeriod )
        {
            m_pConfig->lpLogConfig->ilPeriod = dwN;
        }

        return TRUE;
    }

    return FALSE;
}


BOOL
CInetInfoConfigInfoMapper::UpdateLogFormat(
    VOID )
/*++

Routine Description:

    Insure consistency between user request ( log enabled, new log
    enabled, create new log based on size, log period ) and
    RPC structures.
    HTMLA var: "logformat"

Arguments:

    None

Returns:

    TRUE on success, FALSE on failure

--*/
{
    BOOL fUp = FALSE;

    if ( m_pConfig != NULL )
    {
        if ((*(DWORD UNALIGNED*)&(m_pConfig->lpLogConfig->rgchDataSource[MAX_PATH-sizeof(DWORD)])) != m_dwLogFormat )
        {
            (*(DWORD UNALIGNED*)&(m_pConfig->lpLogConfig->rgchDataSource[MAX_PATH-sizeof(DWORD)])) = m_dwLogFormat;
            UpdateLogFileInfo();
        }
        return TRUE;
    }

    return FALSE;
}


BOOL
CInetInfoConfigInfoMapper::UpdateLogSize(
    VOID )
/*++

Routine Description:

    Insure consistency between user request ( log enabled, new log
    enabled, create new log based on size, log size ) and
    RPC structures.
    This assumes that Log size is updated AFTER the log enabled, new
    log enabled & log period settings, i.e. it appears after these
    settings in the HTMLA form.
    HTMLA var: "logsize"

Arguments:

    None

Returns:

    TRUE on success, FALSE on failure

--*/
{
    if ( m_pConfig != NULL )
    {
        if ( !m_fEnableNewLog )
        {
            m_pConfig->lpLogConfig->cbSizeForTruncation
                    = (DWORD)-1;
            return TRUE;
        }
        else if ( m_dwLogPeriod != INET_LOG_PERIOD_ON_SIZE )
        {
            // restore original log size if not currently creating
            // new file on size

            if ( m_pConfig->lpLogConfig->cbSizeForTruncation
                    != m_dwWasSizeForTruncation
                    && m_pConfig->lpLogConfig->cbSizeForTruncation
                    != 0 )
            {
                m_pConfig->lpLogConfig->cbSizeForTruncation
                        = m_dwWasSizeForTruncation;
                m_dwInvalidLogUpdate = INET_LOG_INVALID_TO_FILE;
            }
            else
            {
                m_pConfig->lpLogConfig->cbSizeForTruncation
                    = m_dwWasSizeForTruncation;
            }
        }
        else if ( (int)m_pConfig->lpLogConfig->cbSizeForTruncation
                < 1
                && m_pConfig->lpLogConfig->inetLogType
                == INET_LOG_TO_FILE )
        {
            return FALSE;
        }
        else
        {
            UpdateLogInfo();
        }

        return TRUE;
    }

    return FALSE;
}


BOOL
CInetInfoConfigInfoMapper::InvalidLogUpdate(
    LPVOID *pV )
/*++

Routine Description:

    Check for invalid changes requested by user to the log settings
    and returns a numeric value indicating what invalid change was made

Arguments:

    pV - pointer to DWORD where to put invalid change status
         can be updated with INET_LOG_TO_FILE if invalid change made
         to the file log settings, INET_LOG_TO_SQL if invalid changes
         to the ODBC log settings, or 0 if no invalid change.

Returns:

    TRUE on success, FALSE on failure

--*/
{
    if ( m_pConfig->lpLogConfig->ilPeriod != m_dwWasLogPeriod
            || (m_pConfig->lpLogConfig->cbSizeForTruncation
            != m_dwWasSizeForTruncation
            && (m_pConfig->lpLogConfig->ilPeriod
            != INET_LOG_PERIOD_NONE || m_pConfig->lpLogConfig->cbSizeForTruncation==(DWORD)-1)) )
    {
        if ( m_pConfig->lpLogConfig->cbSizeForTruncation
                == (DWORD)-1 && m_dwWasSizeForTruncation == 0)
        {
            // does not consider it as invalid log to file
            // if in ODBC mode
            UpdateLogInfo();
        }
        else
        {
            UpdateLogFileInfo();
        }
    }

    if ( !m_fEnableLog
        && !m_dwWasLogType
        && (m_fLogFileUpdate || m_fLogODBCUpdate ) )
    {
        m_dwInvalidLogUpdate = INET_LOG_INVALID_TO_FILE;
    }

    if ( m_pConfig->lpLogConfig->inetLogType
            == INET_LOG_TO_SQL
            && m_fLogFileUpdate )
    {
        m_dwInvalidLogUpdate = INET_LOG_TO_FILE;
    }
    else if ( m_pConfig->lpLogConfig->inetLogType
            == INET_LOG_TO_FILE
            && m_fLogODBCUpdate )
    {
        m_dwInvalidLogUpdate = INET_LOG_TO_SQL;
    }

    *pV = (LPVOID)&m_dwInvalidLogUpdate;

    return TRUE;
}


BOOL
CInetInfoConfigInfoMapper::UpdateLogFileInfo(
    VOID )
/*++

Routine Description:

    Mark the log to file settings as updated by the user
    This will be used to check for invalid log updates

Arguments:

    None

Returns:

    TRUE on success, FALSE on failure

--*/
{
    m_fLogFileUpdate = TRUE;

    return UpdateLogInfo();
}


BOOL
CInetInfoConfigInfoMapper::UpdateLogODBCInfo(
    VOID )
/*++

Routine Description:

    Mark the log to ODBC settings as updated by the user
    This will be used to check for invalid log updates

Arguments:

    None

Returns:

    TRUE on success, FALSE on failure

--*/
{
    m_fLogODBCUpdate = TRUE;

    return UpdateLogInfo();
}


BOOL
CInetInfoConfigInfoMapper::IPDenyRef(
    LPVOID *pV )
/*++

Routine Description:

    Builds a reference to the current IP element in the deny access list

Arguments:

    pV - LPSTR** to be updated with the address of the LPSTR that will
         contains the reference as a sz string
    HTMLA var: "ipdenyref"

Returns:

    TRUE on success, FALSE on failure

--*/
{
    return IPRef( pV, m_pConfig->DenyIPList, &m_pDenyRef );
}


BOOL
CInetInfoConfigInfoMapper::IPGrantRef(
    LPVOID *pV )
/*++

Routine Description:

    Builds a reference to the current IP element in the grant access list

Arguments:

    pV - LPSTR** to be updated with the address of the LPSTR that will
         contains the reference as a sz string
    HTMLA var: "ipgrantref"

Returns:

    TRUE on success, FALSE on failure

--*/
{
    return IPRef( pV, m_pConfig->GrantIPList, &m_pGrantRef );
}


BOOL
CInetInfoConfigInfoMapper::IPRef(
    LPVOID *pV,
    INET_INFO_IP_SEC_LIST* pL,
    LPSTR* pS )
/*++

Routine Description:

    build a reference to the current IP element in the specified list

Arguments:

    pV - LPSTR** to be updated with the address of the LPSTR that will
         contains the reference as a sz string
    pL - pointer to the a IP access list, to be indexed with the current
         value of the <%beginiteration%> construct : m_iIter
    pS - LPSTR* updated with the address of the generated
         reference

WARNING:

    Must be in sync with BuildIPUniqueID()

Returns:

    TRUE on success, FALSE on failure

--*/
{
    if ( m_pConfig != NULL && pL && m_iIter < pL->cEntries )
    {
        // get ASCII format of IP address & mask
        LPSTR pN = IPToMultiByte(
                (LPBYTE)&pL->aIPSecEntry[m_iIter].dwNetwork );
        LPSTR pM = IPToMultiByte(
                (LPBYTE)&pL->aIPSecEntry[m_iIter].dwMask );
        if ( pN == NULL || pM == NULL )
        {
            SetRequestStatus( HTR_OUT_OF_RESOURCE );
            return FALSE;
        }

        // build IP ref string
        LPSTR pR = (LPSTR)Alloc( lstrlen(pN)
                + sizeof(REF_SEP_STR)-1
                + lstrlen(pM)
                + 1 );
        if ( pR == NULL )
        {
            return FALSE;
        }
        lstrcpy( pR, pN );
        lstrcat( pR, REF_SEP_STR );
        lstrcat( pR, pM );

        *pS = pR;
        *pV = (LPVOID*)pS;

        return TRUE;
    }

    return FALSE;
}


BOOL
CInetInfoConfigInfoMapper::RootRef(
    LPVOID *pV )
/*++

Routine Description:

    build a reference to the current virtual root element
    HTMLA var: "rootref"

Arguments:

    pV - LPSTR** to be updated with the address of the LPSTR that will
         contains the reference as a sz string

WARNING:

    must be in sync with BuildVirtDirUniqueID()

Returns:

    TRUE on success, FALSE on failure

--*/
{
    if ( m_pConfig != NULL && m_pConfig->VirtualRoots && m_iIter < m_pConfig->VirtualRoots->cEntries )
    {
        INET_INFO_VIRTUAL_ROOT_ENTRY* pE
                = &m_pConfig->VirtualRoots->aVirtRootEntry[m_iIter];
        size_t lR = wcslen( pE->pszRoot );
        size_t lD = wcslen( pE->pszDirectory );
        size_t lA = wcslen( pE->pszAddress );
        LPSTR pR = (LPSTR)Alloc( lR*2 + 1 + lD*2 +1 + lA*2 + 1);
        if ( pR == NULL )
        {
            return FALSE;
        }
        DWORD dwLr, dwLd, dwLa;
        // contains Root SEP Directory SEP Address
        if ( (dwLr=lR)==0 || (dwLr = WideCharToMultiByte( CP_ACP,
                0,
                pE->pszRoot,
                lR,
                pR,
                lR*2,
                NULL,
                NULL )) != 0 )
        {
            pR[dwLr] = REF_SEP;
            if ( (dwLd=lD)==0 || (dwLd = WideCharToMultiByte( CP_ACP,
                    0,
                    pE->pszDirectory,
                    lD,
                    pR+dwLr+1,
                    lD*2,
                    NULL,
                    NULL )) != 0 )
            {
                pR[dwLr+1+dwLd] = REF_SEP;
                if ( (dwLa=lA)==0 || (dwLa = WideCharToMultiByte( CP_ACP,
                        0,
                        pE->pszAddress,
                        lA,
                        pR+dwLr+1+dwLd+1,
                        lA*2,
                        NULL,
                        NULL )) != 0 )
                {
                    pR[dwLr+1+dwLd+1+dwLa] = '\0';
                    m_pRootRef = pR;
                    *pV = (LPVOID*)&m_pRootRef;
                    return TRUE;
                }
            }
        }
    }

    return FALSE;
}


BOOL
CInetInfoConfigInfoMapper::CryptCapable(
    LPVOID *pV
    )
/*++

Routine Description:

    Return status on availability of encryption capability for
    the W3 service only.
    HTMLA var: "w3cryptcapable"

Arguments:

    pV - DWORD** to be updated with the address of a DWORD that
         will be non zero if encryption capability available

Returns:

    TRUE on success, FALSE on failure

--*/
{
    if ( m_pW3Config != NULL )
    {
        m_dwCryptCapable = (m_pW3Config->dwEncCaps
                & (ENC_CAPS_NOT_INSTALLED|ENC_CAPS_DISABLED))
                ? 0 : (m_pW3Config->dwEncCaps & ENC_CAPS_TYPE_MASK);
    }
    else
    {
        char achEncCaps[32];
        DWORD dwEncCaps = sizeof( achEncCaps );
        EXTENSION_CONTROL_BLOCK* pECB = m_piiR->GetECB();
        if ( pECB->GetServerVariable( (HCONN)pECB->ConnID,
                "HTTP_CFG_ENC_CAPS", achEncCaps, &dwEncCaps ) )
        {
            m_dwCryptCapable = (DWORD)atol( achEncCaps );
            m_dwCryptCapable = (m_dwCryptCapable
                    & (ENC_CAPS_NOT_INSTALLED|ENC_CAPS_DISABLED))
                    ? 0 : (m_dwCryptCapable & ENC_CAPS_TYPE_MASK);
        }
        else
        {
            m_dwCryptCapable = 0;
        }
    }

    *pV = &m_dwCryptCapable;

    return TRUE;
}


//
// array of services descriptor mapping name to service type
//

CServType g_aServTypes[] = {
    { "http", INET_HTTP_SVC_ID },
    { "ftp", INET_FTP_SVC_ID },
    { "gopher", INET_GOPHER_SVC_ID },
    { "dns", INET_DNS_SVC_ID },
    { "dir", INET_DIR },
} ;


CServTypeEnum g_ServTypeEnum;


CServType*
CServTypeEnum::GetServByName(
    LPSTR pName )
/*++

Routine Description:

    Map a service name to a service descriptor entry

Arguments:

    pName - Service name, i.e. http, ftp, ...

Returns:

    pointer to service descriptor or NULL if service name not found

--*/
{
    for ( int x =  0 ; x < sizeof(g_aServTypes)/sizeof(CServType) ; ++x )
    {
        if ( !strcmp( g_aServTypes[x].GetName(), pName ) )
        {
            return g_aServTypes+x;
        }
    }

    return NULL;
}


CServType*
CServTypeEnum::GetServByType(
    DWORD dwT )
/*++

Routine Description:

    Map a service type to a service descriptor entry

Arguments:

    dwT - Service type, i.e. INET_HTTP, ...

Returns:

    pointer to service descriptor or NULL if service type not found

--*/
{
    for ( int x =  0 ; x < sizeof(g_aServTypes)/sizeof(CServType) ; ++x )
    {
        if ( g_aServTypes[x].GetType() == dwT )
        {
            return g_aServTypes+x;
        }
    }

    return NULL;
}


//////


BOOL
CInetInfoConfigInfoMapper::ServName(
    LPVOID *pV )
/*++

Routine Description:

    Map the service type associated with this object to a string
    representation ( i.e http, ftp, ... )

Arguments:

    pV - LPSTR** updated with address of string representation of
         service name

Returns:

    TRUE if success, else FALSE

--*/
{
    CServType *pS = g_ServTypeEnum.GetServByType( m_dwCurrentServerType );
    if ( pS != NULL )
    {
        m_pszVarServName = pS->GetName();
        *pV = (LPVOID)&m_pszVarServName;
        return TRUE;
    }

    return FALSE;
}


void
CInetInfoConfigInfoMapper::Lock(
    VOID )
/*++

Routine Description:

    Lock access to this mapper object

Arguments:

    None

Returns:

    None

--*/
{
    EnterCriticalSection( &m_csLock );
}


void
CInetInfoConfigInfoMapper::UnLock(
    VOID )
/*++

Routine Description:

    Unlock access to this mapper object

Arguments:

    None

Returns:

    None

--*/
{
    LeaveCriticalSection( &m_csLock );
}


LPVOID
CInetInfoConfigInfoMapper::Alloc(
    DWORD dwL )
/*++

Routine Description:

    Allocate a block of memory which will automatically de-allocated
    by calling FreeInfo()

Arguments:

    dwL - size of memory block to allocate

Returns:

    pointer to allocated block or NULL if failure
    updates reqstatus if failure

--*/
{
    CAllocNode *pA = new CAllocNode( dwL );

    if ( pA == NULL )
    {
        SetRequestStatus( HTR_OUT_OF_RESOURCE );
        return NULL;
    }

    if ( m_pFirstAlloc == NULL )
    {
        m_pFirstAlloc = pA;
    }
    else
    {
        m_pLastAlloc->SetNext( pA );
    }
    m_pLastAlloc = pA;

    return pA->GetBuff();
}


LPSTR
CInetInfoConfigInfoMapper::IPToMultiByte(
    LPBYTE pB )
/*++

Routine Description:

    Returns a created string buffer containing the ASCII
    representation of an IP address

Arguments:

    pB - pointer to IP address as a byte sequence
         length is given by IP_ADDR_BYTE_SIZE

Returns:

    pointer to allocated string or NULL if failure
    string is of auto-deallocate type

--*/
{
    LPSTR pF,pS;
    pF = pS = (char*)Alloc( IP_ADDR_BYTE_SIZE*4+1 );
    if ( pS == NULL )
    {
        return NULL;
    }
    for ( int y = 0 ; y < IP_ADDR_BYTE_SIZE ; ++y )
    {
        DWORDToMultiByte( (DWORD)*pB++, pS );
        pS += lstrlen( pS );
        if ( y != IP_ADDR_BYTE_SIZE-1 )
        {
            *pS ++ = '.';
        }
    }
    *pS = '\0';

    return pF;
}


BOOL
CInetInfoConfigInfoMapper::MultiByteToIP(
    LPSTR *ppS,
    LPBYTE pB )
/*++

Routine Description:

    Convert the ASCII representation of an IP address
    to a sequence of byte

Arguments:

    ppS - pointer to string containing ASCII representation
          of IP address. Does not have to be zero delimited.
    pB - pointer to IP address as a byte sequence
         length will be IP_ADDR_BYTE_SIZE

Returns:

    TRUE if success, FALSE if failure

--*/
{
    LPSTR pS = *ppS;

    for ( int y = 0 ; y < IP_ADDR_BYTE_SIZE ; ++y )
    {
        int c;
        UINT v;
        for ( v = 0 ; (c=*pS)>='0' && c<='9' ; ++pS )
        {
            v = v * 10 + *pS-'0';
        }
        if ( v > 255 )
        {
            return FALSE;
        }
        *pB++ = (BYTE)v;
        if ( y != IP_ADDR_BYTE_SIZE-1 && *pS++ != '.' )
        {
            return FALSE;
        }
    }

    *ppS = pS;

    return TRUE;
}


extern "C" int __cdecl
QsortVirtDirCmp(
    const void *pA,
    const void *pB )
/*++

Routine Description:

    Compare two Virtual root entries for sorting order
    1st key is the address field, then the name

Arguments:

    pA - pointer to the 1st virtual root entry
    pB - pointer to the 2nd virtual root entry

Returns:

    -1 if 1st entry to be placed 1st as defined by the
    sort order, 0 if same rank, 1 if 2nd entry is to
    be placed first

--*/
{
    LPWSTR pNameA = ((INET_INFO_VIRTUAL_ROOT_ENTRY*)pA)->pszRoot;
    LPWSTR pNameB = ((INET_INFO_VIRTUAL_ROOT_ENTRY*)pB)->pszRoot;
    LPWSTR pAddrA = ((INET_INFO_VIRTUAL_ROOT_ENTRY*)pA)->pszAddress;
    LPWSTR pAddrB = ((INET_INFO_VIRTUAL_ROOT_ENTRY*)pB)->pszAddress;
    int iCmp;

    //
    // sort on Addr, then Name
    //

    if ( pAddrA && pAddrB )
    {
        iCmp = _wcsicmp( pAddrA, pAddrB );
    }
    else
    {
        iCmp = 0;
    }

    if ( iCmp == 0 && pNameA && pNameB )
    {
        iCmp = _wcsicmp( pNameA, pNameB );
    }

    return iCmp;
}


extern "C" int __cdecl
QsortIpSecCmp(
    const void *pA,
    const void *pB )
/*++

Routine Description:

    Compare two IP access entries for sorting order
    Uses the network address as the compare field

Arguments:

    pA - pointer to the 1st IP access entry
    pB - pointer to the 2nd IP access entry

Returns:

    -1 if 1st entry to be placed 1st as defined by the
    sort order, 0 if same rank, 1 if 2nd entry is to
    be placed first

--*/
{
    //
    // sort on network address
    //

    return memcmp( &((INET_INFO_IP_SEC_ENTRY*)pA)->dwNetwork,
        &((INET_INFO_IP_SEC_ENTRY*)pB)->dwNetwork,
        IP_ADDR_BYTE_SIZE );
}


BOOL SortVirtualRoots(
    LPINET_INFO_VIRTUAL_ROOT_LIST pL )
/*++

Routine Description:

    Sort a virtual root list for display

Arguments:

    pL - pointer to a virtual root list

Returns:

    TRUE

--*/
{
    if ( pL != NULL && pL->cEntries )
    {
        qsort( pL->aVirtRootEntry,
            pL->cEntries,
            sizeof(INET_INFO_VIRTUAL_ROOT_ENTRY),
            QsortVirtDirCmp );
    }

    return TRUE;
}


BOOL SortIpSecList(
    LPINET_INFO_IP_SEC_LIST pL )
/*++

Routine Description:

    Sort a IP access list for display

Arguments:

    pL - pointer to an IP access list

Returns:

    TRUE

--*/
{
    if ( pL != NULL && pL->cEntries )
    {
        qsort( pL->aIPSecEntry,
            pL->cEntries,
            sizeof(INET_INFO_IP_SEC_ENTRY),
            QsortIpSecCmp );
    }

    return TRUE;
}


BOOL
CInetInfoConfigInfoMapper::GetCurrentConfig(
    VOID )
/*++

Routine Description:

    Get the current configuration for the service linked
    to this object by calling the IIS RPC layer

Arguments:

    None

Returns:

    TRUE on success, FALSE on failure
    updates reqstatus

--*/
{
    BOOL fSt = TRUE;
    NET_API_STATUS iStat;
    DWORD dwSize = sizeof(m_achComputerName)-2;

    m_pConfig = NULL;
    m_pW3Config = NULL;
    m_pFtpConfig = NULL;
    m_pGdConfig = NULL;
    m_pGlobalConfig = NULL;

    // free user enumeration
    m_Users.Reset();
    m_Drive.Reset();
    ResetIter();
    m_dwRPCStatus = 0;
    m_dwInvalidLogUpdate = 0;
    m_fLogFileUpdate = FALSE;
    m_fLogODBCUpdate = FALSE;

    if ( !GetComputerNameW( m_achComputerName+2, &dwSize ) )
    {
        m_achComputerName[0] = 0;
    }
    else
    {
        // adjust computer name for reference through Named Pipes
        m_achComputerName[0] = L'\\';
        m_achComputerName[1] = L'\\';
#if 0
        m_achComputerName[2] = L'.';
        m_achComputerName[3] = L'\0';
#endif
    }


    if ( m_dwCurrentServerType == INET_DIR )
    {
        // udpate arg1...3 from m_pszURLParam

        m_pszArg1 = (LPSTR)Alloc( strlen( m_pszURLParam ) + 1 );
        m_pszArg2 = m_pszArg3 = NULL;
        if ( m_pszArg1 == NULL )
        {
            return FALSE;
        }
        strcpy( m_pszArg1, m_pszURLParam );
        LPSTR pD = strchr( m_pszArg1, '?' );
        if ( pD != NULL )
        {
            *pD = '\0';
            m_pszArg2 = pD + 1;
            pD = strchr( m_pszArg2, '?' );
            if ( pD != NULL )
            {
                *pD = '\0';
                m_pszArg3 = pD + 1;

                // insure does not end with '\'
                pD = m_pszArg3 + strlen(m_pszArg3);
                if ( pD > m_pszArg3 && &pD[-1] == (LPSTR)_mbsrchr((LPBYTE)m_pszArg3,'\\') )
                {
                    pD[-1] = '\0';
                }
            }
        }

        if ( !m_fGotServerCapsAndVersion )
        {
#if defined(IISv1)
            m_pServerCaps = NULL;

            g_OSVersion.dwOSVersionInfoSize = sizeof(g_OSVersion);
            GetVersionEx( &g_OSVersion );

            m_dwMinorVersion = 0;
            m_dwMajorVersion = 1;
#else
            if ( InetInfoGetServerCapabilities( m_achComputerName,
                    0,
                    &m_pServerCaps ) != NO_ERROR )
            {
                m_pServerCaps = NULL;
            }

            DWORD dwVer;
            if ( InetInfoGetVersion( m_achComputerName,
                    0,
                    &dwVer ) != NO_ERROR )
            {
                dwVer = 0;
            }
            m_dwMinorVersion = dwVer >> 16;
            m_dwMajorVersion = (DWORD)(WORD)dwVer;
#endif
            m_fGotServerCapsAndVersion = TRUE;
        }

        return TRUE;
    }

    __try {
        if ( (iStat = InetInfoGetAdminInformation( m_achComputerName,
                m_dwCurrentServerType,
                &m_pConfig ))
                == NO_ERROR || iStat == 2 )
        {
            m_pConfig->FieldControl = 0;
            SetLogEntryVars();
            m_dwWasLogPeriod = m_pConfig->lpLogConfig->ilPeriod;
            m_dwWasLogType = m_pConfig->lpLogConfig->inetLogType;
            m_dwWasSizeForTruncation = m_pConfig->lpLogConfig->cbSizeForTruncation ;
        }
        else
        {
            SetRequestStatus( HTR_CONFIG_ACCESS_ERROR );
            m_dwRPCStatus = (DWORD)iStat;
            fSt = FALSE;
            m_pConfig = NULL;
        }

        if ( fSt )
        {
            SortVirtualRoots( m_pConfig->VirtualRoots );
            SortIpSecList( m_pConfig->DenyIPList );
            SortIpSecList( m_pConfig->GrantIPList );

            if ( (iStat = InetInfoGetGlobalAdminInformation( m_achComputerName,
                    0,
                    &m_pGlobalConfig ))
                    == NO_ERROR || iStat == 2 )
            {
                m_pGlobalConfig->FieldControl = 0;
                m_dwIsBandwidthLimited = 2; // undefined
            }
            else
            {
                SetRequestStatus( HTR_COM_CONFIG_ACCESS_ERROR );
                m_dwRPCStatus = (DWORD)iStat;
                fSt = FALSE;
                m_pGlobalConfig = NULL;
            }
        }

        if ( fSt )
        {
            if ( !m_fGotServerCapsAndVersion )
            {
#if defined(IISv1)
                m_pServerCaps = NULL;

                g_OSVersion.dwOSVersionInfoSize = sizeof(g_OSVersion);
                GetVersionEx( &g_OSVersion );

                m_dwMinorVersion = 0;
                m_dwMajorVersion = 1;
#else
                if ( InetInfoGetServerCapabilities( m_achComputerName,
                        0,
                        &m_pServerCaps ) != NO_ERROR )
                {
                    m_pServerCaps = NULL;
                }

                DWORD dwVer;
                if ( InetInfoGetVersion( m_achComputerName,
                        0,
                        &dwVer ) != NO_ERROR )
                {
                    dwVer = 0;
                }
                m_dwMinorVersion = dwVer >> 16;
                m_dwMajorVersion = (DWORD)(WORD)dwVer;
#endif
                m_fGotServerCapsAndVersion = TRUE;
            }
            switch ( m_dwCurrentServerType )
            {
                case INET_HTTP_SVC_ID:
                    if ( (iStat = W3GetAdminInformation( m_achComputerName, &m_pW3Config )) == NO_ERROR )
                    {
                        m_pW3Config->FieldControl = 0;
                    }
                    else
                    {
                        SetRequestStatus( HTR_W3_CONFIG_ACCESS_ERROR );
                        m_dwRPCStatus = (DWORD)iStat;
                        fSt = FALSE;
                        m_pW3Config = NULL;
                    }

                    break;

                case INET_FTP_SVC_ID:
                    if ( (iStat = FtpGetAdminInformation( m_achComputerName,
                            &m_pFtpConfig )) == NO_ERROR )
                    {
                        m_pFtpConfig->FieldControl = 0;
                    }
                    else
                    {
                        SetRequestStatus( HTR_FTP_CONFIG_ACCESS_ERROR );
                        m_dwRPCStatus = (DWORD)iStat;
                        fSt = FALSE;
                        m_pFtpConfig = NULL;
                    }
                    break;
#if 0
                case INET_GOPHER_SVC_ID:
                    if ( (iStat = GdGetAdminInformation( m_achComputerName,
                            &m_pGdConfig )) == NO_ERROR )
                    {
                        m_pGdConfig->FieldControl = 0;
                    }
                    else
                    {
                        SetRequestStatus( HTR_GD_CONFIG_ACCESS_ERROR );
                        m_dwRPCStatus = (DWORD)iStat;
                        fSt = FALSE;
                        m_pGdConfig = NULL;
                    }
                    break;
#endif
            }
        }
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        SetRequestStatus( HTR_CONFIG_ACCESS_ERROR );
        FreeInfo();
        fSt = FALSE;
    }

    switch ( m_dwCurrentServerType )
    {
        case INET_HTTP_SVC_ID:
            m_dwHttpStatus = m_dwRPCStatus; break;

        case INET_FTP_SVC_ID:
            m_dwFtpStatus = m_dwRPCStatus; break;

        case INET_GOPHER_SVC_ID:
            m_dwGopherStatus = m_dwRPCStatus; break;
    }

    return fSt;
}


BOOL
CInetInfoConfigInfoMapper::Update(
    VOID )
/*++

Routine Description:

    Update the current configuration for the service linked
    to this object by calling the IIS RPC layer

Arguments:

    None

Returns:

    TRUE on success, FALSE on failure
    updates reqstatus

--*/
{
    BOOL fSt = TRUE;
    NET_API_STATUS iStat;

    if ( m_dwRequestStatus != HTR_OK )
    {
        return FALSE;
    }

    if ( m_dwCurrentServerType == INET_DIR )
    {
        return TRUE;
    }

    __try {

        if ( m_pConfig != NULL && m_pConfig->FieldControl &&
                (iStat = InetInfoSetAdminInformation( m_achComputerName,
                m_dwCurrentServerType, m_pConfig )) != NO_ERROR )
        {
            SetRequestStatus( HTR_CONFIG_WRITE_ERROR );
            m_dwRPCStatus = (DWORD)iStat;
            fSt = FALSE;
        }

        if ( fSt )
        {
#if 0
            // update Authentication header if Authentication methods field updated
            // not necessary : done via registry notification thread
            if ( m_pConfig != NULL && (m_pConfig->FieldControl
                    & FC_INET_INFO_AUTHENTICATION) )
                g_AuthReqs.UpdateMethodsIndication();
#endif
            if ( m_pGlobalConfig != NULL && m_pGlobalConfig->FieldControl &&
                    (iStat = InetInfoSetGlobalAdminInformation( m_achComputerName,
                    0, m_pGlobalConfig )) != NO_ERROR && iStat != 2 )
            {
                SetRequestStatus( HTR_COM_CONFIG_WRITE_ERROR );
                m_dwRPCStatus = (DWORD)iStat;
                fSt = FALSE;
            }
        }

        if ( fSt )
        {
            switch ( m_dwCurrentServerType )
            {
                case INET_HTTP_SVC_ID:
                    if ( m_pW3Config != NULL && m_pW3Config->FieldControl &&
                            (iStat = W3SetAdminInformation( m_achComputerName,
                            m_pW3Config )) != NO_ERROR )
                    {
                        SetRequestStatus( HTR_W3_CONFIG_WRITE_ERROR );
                        m_dwRPCStatus = (DWORD)iStat;
                        fSt = FALSE;
                    }
                    break;

                case INET_FTP_SVC_ID:
                    if ( m_pFtpConfig != NULL && m_pFtpConfig->FieldControl &&
                            (iStat = FtpSetAdminInformation( m_achComputerName,
                            m_pFtpConfig )) != NO_ERROR )
                    {
                        SetRequestStatus( HTR_FTP_CONFIG_WRITE_ERROR );
                        m_dwRPCStatus = (DWORD)iStat;
                        fSt = FALSE;
                    }
                    break;
#if 0
                case INET_GOPHER_SVC_ID:
                    if ( m_pGdConfig != NULL && m_pGdConfig->FieldControl &&
                            (iStat = GdSetAdminInformation( m_achComputerName,
                            m_pGdConfig )) != NO_ERROR )
                    {
                        SetRequestStatus( HTR_GD_CONFIG_WRITE_ERROR );
                        m_dwRPCStatus = (DWORD)iStat;
                        fSt = FALSE;
                    }
                    break;
#endif
            }
        }
    }
    __except( EXCEPTION_EXECUTE_HANDLER )
    {
        SetRequestStatus( HTR_CONFIG_WRITE_ERROR );
        fSt = FALSE;
    }

    return fSt;
}


BOOL
CInetInfoConfigInfoMapper::FreeInfo(
    VOID )
/*++

Routine Description:

    Free memory associated with the current map object
    including memory used by the structure used in the IIS RPC calls
    and memory allocated using Alloc()

Arguments:

    None

Returns:

    TRUE on success, FALSE on failure
    updates reqstatus

--*/
{
    BOOL fSt = TRUE;
    CAllocNode *pAllocNode;

    // free all memory alloced to update RPC structures
    for ( pAllocNode = m_pFirstAlloc ; pAllocNode != NULL ; )
    {
        CAllocNode *pN = pAllocNode->GetNext();
        delete pAllocNode;
        pAllocNode = pN;
    }
    m_pFirstAlloc = m_pLastAlloc = NULL;

    if ( m_pConfig != NULL )
    {
        MIDL_user_free( m_pConfig );
        m_pConfig = NULL;
    }

    if ( m_pGlobalConfig != NULL )
    {
        MIDL_user_free( m_pGlobalConfig );
        m_pGlobalConfig = NULL;
    }

    // free user enumeration
    m_Users.Reset();

    m_Drive.Reset();

    switch ( m_dwCurrentServerType )
    {
        case INET_HTTP_SVC_ID:
            if ( m_pW3Config != NULL )
            {
                MIDL_user_free( m_pW3Config );
                m_pW3Config = NULL;
            }
            break;

        case INET_FTP_SVC_ID:
            if ( m_pFtpConfig != NULL )
            {
                MIDL_user_free( m_pFtpConfig );
                m_pFtpConfig = NULL;
            }
            break;

        case INET_GOPHER_SVC_ID:
            if ( m_pGdConfig != NULL )
            {
                MIDL_user_free( m_pGdConfig );
                m_pGdConfig = NULL;
            }
            break;
    }

    return fSt;
}


BOOL
CInetInfoConfigInfoMapper::Map(
    LPBYTE pName,
    DWORD dwNameLen,
    CInetInfoMap** ppMap )
/*++

Routine Description:

    Map a variable name to a variable descriptor structure

Arguments:

    pName - variable name
    dwNameLen - variable name length
    ppMap - updated with pointer to variable descriptor

Returns:

    TRUE on success, FALSE if failure ( variable not found )

--*/
{
    int x;
    LPBYTE pLN = new BYTE[dwNameLen];
    if ( pLN == NULL )
    {
        SetRequestStatus( HTR_OUT_OF_RESOURCE );
        return FALSE;
    }
    memcpy( pLN, pName, dwNameLen );

    // case insensitive lookup : normalize name to lower case
    for ( x = 0 ; x < (int)dwNameLen ; ++x )
    {
        if ( IsDBCSLeadByte( pLN[x] ) )
        {
            ++x;
        }
        else if ( isupper( (UCHAR)pLN[x] ) )
        {
            pLN[x] = (UINT)_tolower( (int)pLN[x] );
        }
    }

    for ( x = 0 ; x < m_cNbMap ; ++x )
    {
        DWORD l = (DWORD)lstrlen(m_pMap[x].pName);
        if ( l == dwNameLen && !memcmp( m_pMap[x].pName, pLN, l) )
        {
            *ppMap = m_pMap+x;
            delete [] pLN;
            return TRUE;
        }
    }

    delete [] pLN;

    return FALSE;
}


BOOL
CInetInfoConfigInfoMapper::GetFromMsgBody(
    LPSTR pName,
    DWORD dwNameLen,
    LPSTR *pResult,
    DWORD *pdwResLen )
/*++

Routine Description:

    Returns the value of the specified variable in the message
    body of the current request

Arguments:

    pName - variable name
    dwNameLen - variable name length
    pResult - updated with address of string value
    pdwResLen - updated with length of value

Returns:

    TRUE on success, FALSE if failure ( variable not found )

--*/
{
    // Use the raw request body to avoid parsing errors caused
    // by escaped data values.
    LPSTR pV = m_pszReqParamRaw;

    // assume variable name begins with "msgbody."

    pName += sizeof("msgbody.") - 1;
    dwNameLen -= sizeof("msgbody.") - 1;

    for ( ; *pV ; )
    {
        while ( isspace((UCHAR)(*pV)) )
        {
            ++pV;
        }

        // scan for end of variable name

        LPSTR pE = strchr( pV, '=' );
        BOOL fIsLast = FALSE;

        if ( pE != NULL )
        {
            ++pE;

            // scan for end of value

            LPSTR pN = strchr( pE, '&' );
            if ( pN == NULL )
            {
                if ( (pN = strchr( pE, '\r' )) == NULL )
                {
                    if ( (pN = strchr( pE, '\n' )) == NULL )
                    {
                        pN = pE + strlen( pE );
                    }
                }

                fIsLast = TRUE;
            }

            // check for matching variable name

            if ( pE - pV - 1 == (int)dwNameLen
                    && !memcmp( pV, pName, dwNameLen ) )
            {
                *pdwResLen = DIFF(pN - pE);
                if ( (*pResult = (LPSTR)Alloc( *pdwResLen + 1 )) == NULL )
                {
                    return FALSE;
                }
                DelimStrcpyN( *pResult, pE, *pdwResLen );

                // Escape the data
                InlineFromTransparent( (LPBYTE)*pResult, pdwResLen, FALSE );
                (*pResult)[*pdwResLen] = '\0';

                return TRUE;
            }

            if ( fIsLast )
            {
                break;
            }

            pV = pN + 1;
        }
    }

    return FALSE;
}


BOOL
CInetInfoConfigInfoMapper::GetFromServer(
    LPSTR pName,
    DWORD dwNameLen,
    LPSTR *pResult,
    DWORD *pdwResLen )
/*++

Routine Description:

    Returns the value of the specified variable from IIS

Arguments:

    pName - variable name
    dwNameLen - variable name length
    pResult - updated with address of string value
    pdwResLen - updated with length of value

Returns:

    TRUE on success, FALSE if failure ( variable not found )

--*/
{
    LPSTR pN;

    // assume variable name begins with "iis."

    pName += sizeof("iis.") - 1;
    dwNameLen -= sizeof("iis.") - 1;

    DWORD dwLen = 256;

    if ( (*pResult = (LPSTR)Alloc( dwLen )) == NULL ||
         (pN = (LPSTR)Alloc( dwNameLen+1 )) == NULL )
    {
        return FALSE;
    }

    if ( dwNameLen == sizeof("DEFAULT_DOMAIN")-1 &&
         !_memicmp( pName, "DEFAULT_DOMAIN", dwNameLen ) )
    {
        if ( g_pfnGetDefaultDomainName == NULL ||
             !g_pfnGetDefaultDomainName( *pResult, dwLen))
        {
            *pdwResLen = 0;
        }
        else
        {
            *pdwResLen = strlen( *pResult );
        }

        return TRUE;
    }

    memcpy( pN, pName, dwNameLen );
    pN[dwNameLen] = '\0';

    if ( m_piiR->GetECB()->GetServerVariable( (HCONN)m_piiR->GetECB()->ConnID,
                pN,
                *pResult,
                &dwLen ) )
    {
        *pdwResLen = dwLen ? dwLen-1 : 0;

        return TRUE;
    }

    return FALSE;
}


BOOL
CInetInfoConfigInfoMapper::EscapeString(
    LPSTR *pResult,
    LPDWORD pdwResLen,
    BOOL fFreeAfterUse )
/*++

Routine Description:

    Escape the specified string in a form suitable for inclusion
    in a URL

Arguments:

    pResult - updated with address of string value
    pdwResLen - updated with length of value
    fFreeAfterUse - TRUE if input content of pResult needs to be freed
             after usage ( using delete[] )

Returns:

    TRUE on success, FALSE if failure

--*/
{
    LPSTR pIn = *pResult;
    LPSTR pOut;
    LPSTR pEsc;
    LPSTR pScan;
    DWORD dwIn = *pdwResLen;
    DWORD dwOut = 0;

    //
    // allocate output string base on its max length
    //

    if ( (pOut = (LPSTR)Alloc( dwIn * 3 + 1 )) == NULL )
    {
        return FALSE;
    }

    for ( pEsc = pOut, pScan = pIn ; dwIn-- ; )
    {
        int ch = *pScan++;

        if ( (((ch >= 0)   && (ch <= 32)) ||
              (ch&0x80)||
              ( ch == '\\') || ( ch == ':' ) ||
              (ch == '%') || (ch == '?') || (ch == '+') || (ch == '&')) &&
             !(ch == TEXT('\n') || ch == TEXT('\r'))  )
        {
            *pEsc++ = TEXT('%');

            //
            //  Convert the high then the low character to hex
            //

            UINT nDigit = (UINT)(ch >> 4);

            *pEsc++ = HEXDIGIT( nDigit );

            nDigit = (UINT)(ch & 0x0f);

            *pEsc++ = HEXDIGIT( nDigit );

            dwOut += 3;
        }
        else
        {
            *pEsc++ = (char)ch;
            ++dwOut;
        }
    }

    *pResult = pOut;
    *pdwResLen = dwOut;

    if ( fFreeAfterUse )
    {
        delete [] pIn;
    }

    return TRUE;
}


BOOL
CInetInfoConfigInfoMapper::GetString(
    LPBYTE pName,
    DWORD dwNameLen,
    LPSTR *pResult,
    DWORD *pdwResLen,
    BOOL *pfFree )
/*++

Routine Description:

    Returns the value of the specified variable as specified
    by its name as a string

Arguments:

    pName - variable name
    dwNameLen - variable name length
    pResult - updated with address of string value
    pdwResLen - updated with length of value
    pfFree - updated with TRUE if pResult needs to be freed
             after usage ( using delete[] )

Returns:

    TRUE on success, FALSE if failure ( variable not found )

--*/
{
    CInetInfoMap *pMap;
    BOOL fMustEscape;
    BOOL fSt;

    if ( !memcmp( "\"&z\",", pName, sizeof("\"&z\",")-1 ) )
    {
        pName += sizeof("\"&z\",")-1;
        dwNameLen -= sizeof("\"&z\",")-1;
        fMustEscape = TRUE;
    }
    else
    {
        fMustEscape = FALSE;
    }

    if ( !memcmp( "msgbody.", pName, sizeof("msgbody.")-1 ) )
    {
        *pfFree = FALSE;
        fSt = GetFromMsgBody( (LPSTR)pName, dwNameLen, pResult, pdwResLen );
    }
    else if ( !memcmp( "iis.", pName, sizeof("iis.")-1 ) )
    {
        *pfFree = FALSE;
        fSt = GetFromServer( (LPSTR)pName, dwNameLen, pResult, pdwResLen );
    }
    else if ( Map( pName, dwNameLen, &pMap ) )
    {
        fSt = GetString( pMap, pResult, pdwResLen, pfFree );
    }
    else
    {
        fSt = FALSE;
    }

    if ( fSt == FALSE )
    {
        *pfFree = FALSE;
    }
    else if ( fMustEscape )
    {
        if ( fSt = EscapeString( pResult, pdwResLen, *pfFree ) )
        {
            *pfFree = FALSE;
        }
    }

    return fSt;
}


BOOL
CInetInfoConfigInfoMapper::GetString(
    CInetInfoMap *pMap,
    LPSTR *pResult,
    DWORD *pdwResLen,
    BOOL *pfFree )
/*++

Routine Description:

    Returns the value of the specified variable as specified
    by its descriptor as a string

Arguments:

    pMap - variable descriptor
    pResult - updated with address of string value
    pdwResLen - updated with length of value
    pfFree - updated with TRUE if pResult needs to be freed
             after usage ( using delete[] )

Returns:

    TRUE on success, FALSE if failure
    updates reqstatus

--*/
{
    BOOL fSt = FALSE;
    LPVOID *pV;

    *pResult = NULL;
    *pdwResLen = 0;
    *pfFree = FALSE;

    if ( (this->*pMap->GetAddr)( (LPVOID*)&pV ) == FALSE )
    {
        return FALSE;
    }

    LPSTR pR;

    switch ( pMap->iType )
    {
        case ITYPE_LPWSTR:
        case ITYPE_VIRT_DIR_LPWSTR:
        case ITYPE_PATH_LPWSTR:
            if ( pV != NULL )
            {
                pV = (LPVOID*)*(LPWSTR*)pV;
            }
            // fall-through

        // convert from Unicode to ASCII

        case ITYPE_AWCHAR:
            if ( pV != NULL )
            {
                DWORD dwResLen = wcslen((LPWSTR)pV);
                pR = new char[ dwResLen*2 + 1 + 1];
                if ( pR == NULL )
                {
                    SetRequestStatus( HTR_OUT_OF_RESOURCE );
                    fSt = FALSE;
                }
                else
                {
                    if ( dwResLen == 0 ||
                            ( dwResLen = WideCharToMultiByte(
                                CP_ACP,
                                0,
                                (LPWSTR)pV,
                                wcslen((LPWSTR)pV),
                                pR,
                                wcslen( (LPWSTR)pV)*2,
                                NULL,
                                NULL ) )
                            != 0 )
                    {
                        // if type is path, normalize path
                        // so that root directory ends with '\'

                        if ( pMap->iType == ITYPE_PATH_LPWSTR
                            && dwResLen == 2 && pR[1] == ':' )
                        {
                            pR[ dwResLen++ ] = L'\\';
                        }

                        pR[ dwResLen ] = '\0';
                        *pdwResLen = dwResLen;
                        *pResult = (LPSTR)pR;
                        *pfFree = TRUE;
                        fSt = TRUE;
                    }
                    else
                    {
                        delete [] pR;
                    }
                }
            }
            else
            {
                *pdwResLen = 0;
                *pResult = "";
                *pfFree = FALSE;
                fSt = TRUE;
            }
            break;

        case ITYPE_LPSTR:
            if ( pV != NULL )
            {
                pV = (LPVOID*)*(LPSTR*)pV;
            }
            if ( pV != NULL )
            {
                *pdwResLen = lstrlen( (LPSTR)pV );
                *pResult = (LPSTR)pV;
                *pfFree = FALSE;
                fSt = TRUE;
            }
            else
            {
                *pdwResLen = 0;
                *pResult = "";
                *pfFree = FALSE;
                fSt = TRUE;
            }
            break;

        // convert from numeric to string after possible scaling

        case ITYPE_DWORD:
        case ITYPE_BOOL:
        case ITYPE_SHORT:
        case ITYPE_SHORTDW:
        case ITYPE_1K:
        case ITYPE_1M:
        case ITYPE_TIME:
            pR = new char[MAX_SIZE_OF_DWORD_AS_STRING];
            if ( pR == NULL )
            {
                SetRequestStatus( HTR_OUT_OF_RESOURCE );
                fSt = FALSE;
            }
            else
            {
                DWORD dwV = pMap->iType==ITYPE_SHORT
                        ? (DWORD)*(unsigned short*)pV : *(DWORD*)pV;

                if ( pMap->iType==ITYPE_1K )
                {
                    dwV /= 1024;
                }
                else if ( pMap->iType==ITYPE_1M )
                {
                    dwV /= 1024*1024;
                }

                if ( pMap->iType==ITYPE_TIME )
                {
                    wsprintf( pR,
                            "%d:%02d:%02d",
                            dwV/3600,
                            (dwV/60)%60,
                            dwV%60 );
                }
                else
                {
                    DWORDToMultiByte( dwV, pR );
                }

                *pResult = pR;
                *pdwResLen = lstrlen( pR );
                *pfFree = TRUE;
                fSt = TRUE;
            }
            break;

        case ITYPE_IP_ADDR:
        case ITYPE_IP_MASK:
            *pResult = IPToMultiByte( (LPBYTE)pV );
            *pdwResLen = lstrlen( *pResult );
            *pfFree = FALSE;
            fSt = TRUE;
            break;

        default:
            SetRequestStatus( HTR_INVALID_VAR_TYPE );
            break;
    }

    return fSt;
}


BOOL
CInetInfoConfigInfoMapper::PutString(
    CInetInfoMap *pMap,
    LPSTR pSet )
/*++

Routine Description:

    update the value of the specified variable as specified
    by its descriptor from a string

Arguments:

    pMap - variable descriptor
    pSet - string representation of the new value

Returns:

    TRUE on success, FALSE if failure
    updates reqstatus

--*/
{
    BOOL fSt = FALSE;
    BOOL fUp = FALSE;
    LPVOID pV;
    LPWSTR pW;
    LPSTR pS;
    LPSTR pSM = NULL;
    DWORD dwResLen;
    DWORD dwRes;
    int cL = strlen( pSet );
    DWORD dwN;
    DWORD dwC;
    WCHAR *pT;

    // assume variable accessible, as was checked when
    // retrieving the variable descriptor

    (this->*pMap->GetAddr)( (LPVOID*)&pV );

    if ( pV != NULL )
    {
        switch ( pMap->iType )
        {
            case ITYPE_VIRT_DIR_LPWSTR:
                pSM = (LPSTR)Alloc( (cL+2) );
                if ( pSM == NULL )
                {
                    break;
                }
                if ( *pSet == '\\' )
                {
                    *pSet = '/';
                }
                if ( *pSet != '/' )
                {
                    pSM[0] = '/';
                    strcpy( pSM + 1, pSet );
                    ++cL;
                }
                else
                {
                    strcpy( pSM, pSet );
                }
                // fall-through

            case ITYPE_LPWSTR:
            case ITYPE_PATH_LPWSTR:
                pW = (WCHAR*)Alloc( (cL+1)*sizeof(WCHAR) );
                if ( pW == NULL )
                {
                    break;
                }
                if ( (dwResLen=cL)==0 || (pW != NULL && (dwResLen
                        = MultiByteToWideChar( CP_ACP,
                            0,
                            pSM ? pSM : pSet,
                            cL,
                            pW,
                            cL )) != 0) )
                {
                    pW[ dwResLen ] = 0;
                    *(LPWSTR*)pV = pW;
                    fUp = (this->*pMap->UpdateIndication)();
                    fSt = TRUE;
                }
                break;

            case ITYPE_AWCHAR:
                pT = new WCHAR[pMap->dwParam];
                if ( pT == NULL )
                {
                    SetRequestStatus( HTR_OUT_OF_RESOURCE );
                    break;
                }
                dwC = MultiByteToWideChar(
                        CP_ACP,
                        0,
                        (LPSTR)pSet,
                        cL,
                        (LPWSTR)pT,
                        pMap->dwParam-1 );
                if ( (dwResLen = cL) == 0 || (dwResLen = dwC) != 0 )
                {
                    pT[dwResLen++] = 0;
                    if ( lstrcmpW( (PWSTR)pV, pT ) )
                    {
                        memcpy( pV, pT, dwResLen * sizeof(WCHAR) );
                        fUp = (this->*pMap->UpdateIndication)();
                    }
                    else
                    {
                        fUp = TRUE;
                    }
                    fSt = TRUE;
                }
                delete [] pT;
                break;

            case ITYPE_LPSTR:
                pS = (char*)Alloc( cL+1 );
                if ( pS != NULL )
                {
                    memcpy( pS, pSet, cL+1 );
                    fUp = (this->*pMap->UpdateIndication)();
                    fSt = TRUE;
                }
                else
                {
                    fSt = FALSE;
                }
                break;

            case ITYPE_TIME:
                    fSt = FALSE;
                    break;

            case ITYPE_1K:
                    *(DWORD*)pV = MultiByteToDWORD( pSet ) * 1024;
                    goto to_upd;

            case ITYPE_1M:
                    *(DWORD*)pV = MultiByteToDWORD( pSet ) * 1024*1024;
                    goto to_upd;

            case ITYPE_SHORT:
            case ITYPE_SHORTDW:
                    dwRes = MultiByteToDWORD( pSet );
                    if  ( dwRes > (pMap->iType == ITYPE_SHORT
                            ? USHRT_MAX : (DWORD)SHRT_MAX) )
                    {
                        fUp = FALSE;
                        fSt = TRUE;
                        break;
                    }
                    if ( pMap->iType == ITYPE_SHORT )
                    {
                        *(unsigned short*)pV = (unsigned short)dwRes;
                    }
                    else
                    {
                        *(DWORD*)pV = dwRes;
                    }
                    goto to_upd;

            case ITYPE_DWORD:
                    dwN = MultiByteToDWORD( pSet );
                    //if ( dwN != *(DWORD*)pV )
                    {
                        *(DWORD*)pV = dwN;
                        goto to_upd;
                    }
                    fSt = TRUE;
                    fUp = TRUE;
                    break;

            case ITYPE_BOOL:
                *(BOOL*)pV = MultiByteToDWORD( pSet ) ? TRUE : FALSE;
to_upd:
                fUp = (this->*pMap->UpdateIndication)();
                fSt = TRUE;
                break;

            case ITYPE_IP_ADDR:
            case ITYPE_IP_MASK:
                if ( isalpha( (UCHAR)(*pSet) ) )
                {
                    hostent *pH;
                    if( (pH = gethostbyname( pSet )) != NULL
                            && pH->h_addr != NULL )
                    {
                        memcpy( pV, pH->h_addr, IP_ADDR_BYTE_SIZE );
                        fUp = (this->*pMap->UpdateIndication)();
                        fSt = TRUE;
                    }
                }
                else if ( MultiByteToIP( &pSet, (LPBYTE)pV ) )
                {
                    fUp = (this->*pMap->UpdateIndication)();
                    fSt = TRUE;
                }
                else if ( pMap->iType == ITYPE_IP_MASK && *pSet == '\0' )
                {
                    memset( pV, 0xff, IP_ADDR_BYTE_SIZE );
                    fUp = (this->*pMap->UpdateIndication)();
                    fSt = TRUE;
                }
                else
                {
                    SetRequestStatus( HTR_BAD_PARAM );
                    fSt = FALSE;
                }
                break;

            default:
                SetRequestStatus( HTR_INVALID_VAR_TYPE );
                fSt = FALSE;
                break;
        }
        if ( fSt == TRUE && fUp == FALSE )
        {
            SetRequestStatus( HTR_VALIDATION_FAILED );
            fSt = FALSE;
        }
    }
    else
    {
        fSt = FALSE;
    }

    return fSt;
}


//
// Disconnect user management
//

BOOL
CInetInfoConfigInfoMapper::DisconnectUser(
    LPSTR pU )
/*++

Routine Description:

    Disconnect user from the specified service based on numeric ID as string
    The ID is opaque to HTMLA, only meaningfull to the FTP service
    It is retrieved using user enumeration

Arguments:

    pU - ASCII representation of the numeric ID

Returns:

    TRUE on success, FALSE on failure
    updates reqstatus

--*/
{
    BOOL fSt = FALSE;

    DWORD dwID = MultiByteToDWORD( pU );
    fSt = I_FtpDisconnectUser( m_achComputerName, dwID ) == NO_ERROR;
    if ( !fSt )
    {
        SetRequestStatus( HTR_USER_DISCONNECT_ERROR );
    }

    return fSt;
}


BOOL
CInetInfoConfigInfoMapper::DisconnectAll(
    VOID )
/*++

Routine Description:

    Disconnect all users from the specified service

Arguments:

    None

Returns:

    TRUE on success, FALSE on failure

--*/
{
    BOOL fSt = FALSE;

    DWORD dwC, dwI, dwCurID;
    if ( m_Users.GetCountAsDWORD( &dwC ) )
    {
        ResetIter();
        for ( dwI = 0 ; dwI < dwC ; ++dwI )
        {
            if ( !m_Users.GetIDAsDWORD( &dwCurID ) )
            {
                break;
            }
            // can't do anything with status at this point,
            // so ignore error
            I_FtpDisconnectUser( m_achComputerName, dwCurID );
            IncIter();
        }
        fSt = TRUE;
    }
    // if error accessing user enum, RequestStatus already set by CUserEnum

    return fSt;
}


BOOL
CInetInfoConfigInfoMapper::AliasVirtDir(
    INET_INFO_VIRTUAL_ROOT_ENTRY *pU )
/*++

Routine Description:

    create an alias for the matching virtual root
    by coalescing all alpha-numeric characters
    from the virtual root physical path

Arguments:

    pU - ptr to virtual root entry

Returns:

    TRUE on success, FALSE on failure

--*/
{
    int lD = wcslen( pU->pszDirectory );
    int lR = 0;
    if ( !(pU->pszRoot = (LPWSTR)Alloc( (lD + 1 + 1)*sizeof(WCHAR) )) )
    {
        return FALSE;
    }
    pU->pszRoot[lR++] = L'/';
    for ( int x = 0 ; x < lD ; ++x )
    {
        if ( iswalpha( pU->pszDirectory[x] )
                || iswdigit( pU->pszDirectory[x] ) )
        {
            pU->pszRoot[lR++] = pU->pszDirectory[x];
        }
    }
    pU->pszRoot[lR] = 0;

    return TRUE;
}


BOOL
CInetInfoConfigInfoMapper::HandleVirtDirRequest(
    LPSTR pszVirt,
    LPSTR pszAddr,
    int iReq )
/*++

Routine Description:

    Handle a virtual root command. can be one of :

    _VIRT_DIR_REQ_ALIAS : create an alias for the matching virtual root
                          by coalescing all alpha-numeric characters
                          from the virtual root physical path

    _VIRT_DIR_REQ_CHECK : check for the existence of the specified
                          virtual root, set reqstatus to HTR_DIR_SAME_NAME
                          if present

Arguments:

    pszVirt - name of virtual root
    pszAddr - network address virtual root
    iReq : a _VIRT_DIR_REQ_ command

Returns:

    TRUE on success, FALSE on failure
    updates reqstatus

--*/
{
    LPINET_INFO_VIRTUAL_ROOT_LIST pL = m_pConfig->VirtualRoots;
    INET_INFO_VIRTUAL_ROOT_ENTRY isE;
    BOOL fSt = FALSE;
    CHAR achID[MAX_PATH + 80];

    if ( pL == NULL )
    {
        goto no_match;
    }

    // drive dir part is empty
    strcpy( achID, pszVirt );
    strcat( achID, REF_SEP_STR REF_SEP_STR);
    strcat( achID, pszAddr );

    // parse ID
    if ( BuildVirtDirUniqueID( achID, &isE ) )
    {
        ResetIter();
        // iterate through list
        DWORD dwI;
        for ( dwI = 0 ; dwI < pL->cEntries ; ++dwI )
        {
            if ( VirtDirCmp( pL->aVirtRootEntry + dwI, &isE, FALSE ) )
            {
                break;
            }
            IncIter();
        }
        if ( dwI == pL->cEntries )
        {
            goto no_match;
        }
        else if ( iReq == _VIRT_DIR_REQ_ALIAS )
        {
            // update pszRoot with alphanum chars from pszDirectory
            fSt = AliasVirtDir( pL->aVirtRootEntry + dwI );
        }
        else    // check root
        {
            SetRequestStatus( HTR_DIR_SAME_NAME );
        }
        goto ret;
    }
    else
    {
        SetRequestStatus( HTR_BAD_PARAM );
    }

    goto ret;

no_match:
    if ( iReq != _VIRT_DIR_REQ_CHECK )
    {
        SetRequestStatus( HTR_REF_NOT_FOUND );
        fSt = FALSE;
    }
    else
    {
        fSt = TRUE;
    }
ret:

    return fSt;
}


BOOL
CInetInfoConfigInfoMapper::GetStatus(
    VOID )
/*++

Routine Description:

    Update the status of the IIS services : HTTP, FTP, Gopher
    stored in m_dw*Status
    status is the return code from the RPC InetInfoGetAdminInformation()

Arguments:

    None

Returns:

    TRUE on success, FALSE on failure

--*/
{
    BOOL fSt = TRUE;
    INET_INFO_CONFIG_INFO *pConfig;
    DWORD dwNeed;

    // check which status are missing :
    // all services except the one linked to this object

    switch ( m_dwCurrentServerType )
    {
        case INET_HTTP_SVC_ID:
            dwNeed = INET_FTP_SVC_ID | INET_GOPHER_SVC_ID; break;

        case INET_FTP_SVC_ID:
            dwNeed = INET_HTTP_SVC_ID | INET_GOPHER_SVC_ID; break;

        case INET_GOPHER_SVC_ID:
            dwNeed = INET_HTTP_SVC_ID | INET_FTP_SVC_ID; break;

        default:
            dwNeed = INET_HTTP_SVC_ID | INET_FTP_SVC_ID | INET_GOPHER_SVC_ID;
    }

    if ( dwNeed & INET_HTTP_SVC_ID )
    {
        pConfig = NULL;

        if ( (m_dwHttpStatus = InetInfoGetAdminInformation(
                m_achComputerName, INET_HTTP_SVC_ID, &pConfig ))
                == NO_ERROR || m_dwHttpStatus == 2 )
        {
            if ( pConfig != NULL )
            {
                MIDL_user_free( pConfig );
            }
        }
    }

    if ( dwNeed & INET_FTP_SVC_ID )
    {
        pConfig = NULL;

        if ( (m_dwFtpStatus = InetInfoGetAdminInformation( m_achComputerName,
                INET_FTP_SVC_ID, &pConfig ))
                == NO_ERROR || m_dwFtpStatus == 2 )
        {
            if ( pConfig != NULL )
            {
                MIDL_user_free( pConfig );
            }
        }
    }

    if ( dwNeed & INET_GOPHER_SVC_ID )
    {
        pConfig = NULL;

        if ( (m_dwGopherStatus = InetInfoGetAdminInformation( m_achComputerName,
                INET_GOPHER_SVC_ID, &pConfig ))
                == NO_ERROR || m_dwGopherStatus == 2 )
        {
            if ( pConfig != NULL )
            {
                MIDL_user_free( pConfig );
            }
        }
    }

    return fSt;
}


// IP list management

BOOL
CInetInfoConfigInfoMapper::AddIPAccess(
    BOOL fDenyList )
{
    return CloneIPAccesses( fDenyList, TRUE, FALSE, 0 );
}


BOOL
CInetInfoConfigInfoMapper::DeleteIPAccess(
    BOOL fDenyList,
    LPSTR pID )
{
    if ( PositionIPAccess( fDenyList, pID ) )
    {
        BOOL fSt = CloneIPAccesses( fDenyList, FALSE, TRUE, m_iIter );
        if ( fSt )
        {
            UpdateIP();
        }
        return TRUE;
    }
    return FALSE;
}


BOOL
CInetInfoConfigInfoMapper::BuildIPUniqueID(
    LPSTR pI,
    INET_INFO_IP_SEC_ENTRY* pE )
/*++

Routine Description:

    Decode the ASCII representation of an IP entry reference

Arguments:

    pI - contains the IP reference
    pE - pointer to a IP entry where dwMask & dwNetwork will be filled

WARNING:

    Must be in sync with IPRef()

Returns:

    TRUE on success, FALSE on failure

--*/
{
    for ( int x = 0 ; x < 2 ; ++x )
    {
        LPBYTE pB = x ? (LPBYTE)&pE->dwMask : (LPBYTE)&pE->dwNetwork;
        if ( !MultiByteToIP( &pI, pB ) )
        {
            return FALSE;
        }
        if ( x != 1 && *pI++ != REF_SEP )
        {
            return FALSE;
        }
    }

    return TRUE;
}


BOOL
CInetInfoConfigInfoMapper::PositionIPAccess(
    BOOL fDenyList,
    LPSTR pID )
/*++

Routine Description:

    Position the iteration counter ( m_iIter ) on the IP entry
    matching the specified IP reference in the specified list

Arguments:

    fDenyList - TRUE if the list is the deny list, else FALSE
                for the grant list
    pID - pointer to an IP entry reference

Returns:

    TRUE on success, FALSE on failure
    updates reqstatus, m_iIter

--*/
{
    LPINET_INFO_IP_SEC_LIST pL = fDenyList
            ? m_pConfig->DenyIPList : m_pConfig->GrantIPList;
    INET_INFO_IP_SEC_ENTRY isE;
    BOOL fSt = FALSE;

    InvalidateIPSingle();

    if ( pL == NULL )
    {
        SetRequestStatus( HTR_REF_NOT_FOUND );
        return FALSE;
    }

    // parse ID
    if ( BuildIPUniqueID( pID, &isE ) )
    {
        ResetIter();
        // iterate through list
        DWORD dwI;
        for ( dwI = 0 ; dwI < pL->cEntries ; ++dwI )
        {
            if ( !memcmp( pL->aIPSecEntry + dwI, &isE, sizeof(isE) ) )
            {
                fSt = TRUE;
                break;
            }
            IncIter();
        }
        if ( dwI == pL->cEntries )
        {
            SetRequestStatus( HTR_REF_NOT_FOUND );
        }
    }
    else
    {
        SetRequestStatus( HTR_BAD_PARAM );
    }

    return fSt;
}


BOOL
CInetInfoConfigInfoMapper::CloneIPAccesses(
    BOOL fDenyList,
    BOOL fExtend,
    BOOL fDel,
    DWORD dwToDel )
/*++

Routine Description:

    Clone the specified IP list with optional extension and/or
    deletion of an entry

Arguments:

    fDenyList - TRUE if the list is the deny list, else FALSE
                for the grant list
    fExtend   - TRUE if list is to be extended by one entry ( added
                at the end of the list, m_iIter will be positioned
                on this new entry )
    fDel      - TRUE if the entry specified in dwToDel is to be deleted
                from the list
    dwToDel   - specify the entry index ( 0-based ) to delete if fDel
                is TRUE

Returns:

    TRUE on success, FALSE on failure
    updates reqstatus, m_iIter

--*/
{
    LPINET_INFO_IP_SEC_LIST pL;
    DWORD dwNewCount, dwOldCount;
    LPINET_INFO_IP_SEC_LIST pN;

    pL = fDenyList ? m_pConfig->DenyIPList : m_pConfig->GrantIPList;
    dwOldCount = pL ? pL->cEntries : 0;
    dwNewCount = dwOldCount + (fExtend ? 1 : 0) - (fDel ? 1 : 0);
    pN = (LPINET_INFO_IP_SEC_LIST)Alloc(
            sizeof(INET_INFO_IP_SEC_LIST) + dwNewCount
            * sizeof(INET_INFO_IP_SEC_ENTRY));
    if ( pN == NULL )
    {
        // insure m_iIter is invalid ( so update attempts will fail )
        if ( fExtend )
        {
            SetIter( dwOldCount );
        }
        return FALSE;
    }
    pN->cEntries = dwNewCount;

    DWORD dwF;
    DWORD dwT;
    for ( dwF = dwT = 0 ; dwF < dwOldCount ; ++dwF )
    {
        if ( fDel && dwF == dwToDel )
        {
            continue;
        }
        memcpy( pN->aIPSecEntry + dwT,
                pL->aIPSecEntry + dwF,
                sizeof(INET_INFO_IP_SEC_ENTRY) );
        ++dwT;
    }

    if ( fDenyList )
    {
        m_pConfig->DenyIPList = pN;
    }
    else
    {
        m_pConfig->GrantIPList = pN;
    }

    if ( fExtend )
    {
        SetIter( dwNewCount - 1 );
        memset( &pN->aIPSecEntry[dwNewCount-1].dwMask,
                0xff,
                IP_ADDR_BYTE_SIZE );
        memset( &pN->aIPSecEntry[dwNewCount-1].dwNetwork,
                0x00,
                IP_ADDR_BYTE_SIZE );
    }

    return TRUE;
}


BOOL
CInetInfoConfigInfoMapper::SetRemoteAddr(
    LPSTR pR )
/*++

Routine Description:

    Store the client IP address in binary and ASCII format
    for later use

Arguments:

    pR - ASCII representation of the client IP address.

Returns:

    TRUE on success, FALSE on failure

--*/
{
    BOOL fSt = FALSE;

    m_pRemoteAddr = (LPBYTE)Alloc( IP_ADDR_BYTE_SIZE );
    m_pszRemoteAddr = (LPSTR)Alloc( lstrlen( pR ) + 1 );
    if ( m_pRemoteAddr != NULL && m_pszRemoteAddr != NULL )
    {
        LPSTR pC = pR;
        if ( MultiByteToIP( &pC, m_pRemoteAddr ) )
        {
            lstrcpy( m_pszRemoteAddr, pR );
            fSt = TRUE;
        }
        else
        {
            SetRequestStatus( HTR_BAD_PARAM );
        }
    }

    return fSt;
}


BOOL
CInetInfoConfigInfoMapper::SetIPAccessDefault(
    BOOL fIsDeny )
/*++

Routine Description:

    Set the default action for the IP access check made by the server
    Can be either deny or grant access.
    To signal a 'deny' default condition we set the deny list to be
    empty, and to signal 'grant' we set the grant list to be empty
    If both lists are empty the default is 'grant'
    To set the default to deny with an empty 'grant' list the regular
    admin tool create a dummy entry 0.0.0.0
    As we must provide access to the distant admin after switching the
    default to 'deny', we use the address of the client as the entry
    to store in the 'grant' list in this case.

Arguments:

    dIsDeny - TRUE if default is to be deny, FALSE for grant

Returns:

    TRUE on success, FALSE on failure

--*/
{
    LPINET_INFO_IP_SEC_LIST *pL;
    BOOL fSt = TRUE;

    if ( fIsDeny )
    {
        m_pConfig->DenyIPList = (LPINET_INFO_IP_SEC_LIST)NULL;
        pL = &m_pConfig->GrantIPList;
        // insert null entry if none exist in exception list
        if ( *pL == NULL || (*pL)->cEntries == 0 )
        {
            fSt = CloneIPAccesses( !fIsDeny, TRUE, FALSE, 0 );
            if ( fSt )
            {
                // set addr to REMOTE_ADDR
                INET_INFO_IP_SEC_ENTRY *pE = &(*pL)->aIPSecEntry[m_iIter];
                memcpy( &pE->dwNetwork, m_pRemoteAddr, IP_ADDR_BYTE_SIZE );
                memset( &pE->dwMask, 0xff, IP_ADDR_BYTE_SIZE );
            }
        }
    }
    else
    {
        m_pConfig->GrantIPList = (LPINET_INFO_IP_SEC_LIST)NULL;
    }
    if ( fSt )
    {
        UpdateIP();
    }
    return fSt;
}


// Virtual Directories list management

BOOL
CInetInfoConfigInfoMapper::AddVirtDir(
    VOID )
/*++

Routine Description:

    Add a virtual root entry in the current list, position
    the iteration counter to point to this new entry.

Arguments:

    None

Returns:

    TRUE on success, FALSE on failure
    Updates m_iIter ( iteration counter )

--*/
{
    return CloneVirtDirs( TRUE, FALSE, 0 );
}


BOOL
CInetInfoConfigInfoMapper::DeleteVirtDir(
    LPSTR pID )
/*++

Routine Description:

    Delete the virtual root entry specified by the reference

Arguments:

    pID - virtual root reference

Returns:

    TRUE on success, FALSE on failure ( e.g. inexistant reference )

--*/
{
    if ( PositionVirtDir( pID ) )
    {
        BOOL fSt = CloneVirtDirs( FALSE, TRUE, m_iIter );
        if ( fSt )
        {
            UpdateRoot();
        }
        return TRUE;
    }
    return FALSE;
}


BOOL
CInetInfoConfigInfoMapper::BuildVirtDirUniqueID(
    LPSTR pI,
    INET_INFO_VIRTUAL_ROOT_ENTRY* pE )
/*++

Routine Description:

    Decode the ASCII representation of a virtual root reference

Arguments:

    pI - contains the virtual root reference
    pE - pointer to a virtual root entry pszRoot,
         pszDirectory & pszAddress will be filled

WARNING:

    Must be in sync with RootRef()

Returns:

    TRUE on success, FALSE on failure

--*/
{
    LPSTR p;
    LPSTR pA;

    if ( (p = strchr( pI, REF_SEP )) != NULL )
    {
        if ( (pA = strchr( p+1, REF_SEP )) != NULL )
        {
            int l1, l2, l3;
            DWORD dwL1, dwL2, dwL3;

            pE->pszRoot = (LPWSTR)Alloc( (ULONG)(((l1=DIFF(p-pI))+1)*sizeof(WCHAR)) );
            pE->pszDirectory = (LPWSTR)Alloc( (ULONG)(((l2=DIFF(pA-p)-1)+1)*sizeof(WCHAR)) );
            pE->pszAddress = (LPWSTR)Alloc( ((l3=lstrlen(pI)-l1-l2-2)+1)
                    *sizeof(WCHAR) );

            if ( pE->pszRoot == NULL
                    || pE->pszDirectory == NULL
                    || pE->pszAddress == NULL )
            {
                return FALSE;
            }

            // convert to UNICODE if string non empty

            if ( dwL1 = l1 )
            {
                dwL1 = MultiByteToWideChar( CP_ACP,
                        0,
                        pI,
                        l1,
                        pE->pszRoot,
                        l1 );
            }

            if ( dwL2 = l2 )
            {
                dwL2 = MultiByteToWideChar( CP_ACP,
                        0,
                        p+1,
                        l2,
                        pE->pszDirectory,
                        l2 );
            }

            if ( dwL3 = l3 )
            {
                dwL3 = MultiByteToWideChar( CP_ACP,
                        0,
                        pA+1,
                        l3,
                        pE->pszAddress,
                        l3 );
            }

            pE->pszRoot[ dwL1 ] = '\0';
            pE->pszDirectory[ dwL2 ] = '\0';
            pE->pszAddress[ dwL3 ] = '\0';

            // return OK if empty string or convertion successfull
            // for both components

            return (!l1 || dwL1) && (!l2 || dwL2 ) && (!l3 || dwL3 )
                    ? TRUE : FALSE;
        }
    }

    return FALSE;
}


BOOL
CInetInfoConfigInfoMapper::VirtDirCmp(
    INET_INFO_VIRTUAL_ROOT_ENTRY* p1,
    INET_INFO_VIRTUAL_ROOT_ENTRY* p2,
    BOOL fCompareDrive )
/*++

Routine Description:

    Test two virtual root entries for identity
    if fCompareDrive is TRUE, pszRoot, pszDirectory & pszAddress
    will be used in the compare operation
    if FALSE, only pszRoot & pszAddress will be used

Arguments:

    p1 - 1st virtual root entry
    p2 - 2nd virtual root entry
    fCompareDrive - TRUE to enable compare of pszDirectory

Returns:

    TRUE if identical.

--*/
{
    return ( !wcscmp(p1->pszRoot ? p1->pszRoot : L"", p2->pszRoot)
            && (!fCompareDrive || !wcscmp( p1->pszDirectory
                ? p1->pszDirectory : L"", p2->pszDirectory))
            && !wcscmp( p1->pszAddress ? p1->pszAddress : L"",
                p2->pszAddress) )
            ? TRUE : FALSE;
}


BOOL
CInetInfoConfigInfoMapper::PositionVirtDir(
    LPSTR pID )
/*++

Routine Description:

    Position the iteration counter ( m_iIter ) on the virtual
    root entry matching the specified virtual root reference

Arguments:

    pID - pointer to a virutal root reference

Returns:

    TRUE on success, FALSE on failure
    updates reqstatus, m_iIter

--*/
{
    LPINET_INFO_VIRTUAL_ROOT_LIST pL = m_pConfig->VirtualRoots;
    INET_INFO_VIRTUAL_ROOT_ENTRY isE;
    BOOL fSt = FALSE;

    if ( pL == NULL )
    {
        SetRequestStatus( HTR_REF_NOT_FOUND );
        return FALSE;
    }

    // parse ID
    if ( BuildVirtDirUniqueID( pID, &isE ) )
    {
        ResetIter();
        // iterate through list
        DWORD dwI;
        for ( dwI = 0 ; dwI < pL->cEntries ; ++dwI )
        {
            if ( VirtDirCmp( pL->aVirtRootEntry + dwI, &isE, TRUE ) )
            {
                fSt = TRUE;
                break;
            }
            IncIter();
        }
        if ( dwI == pL->cEntries )
        {
            SetRequestStatus( HTR_REF_NOT_FOUND );
        }
        else
        {
            SetRootEntryVars();
        }
    }
    else
    {
        SetRequestStatus( HTR_BAD_PARAM );
    }

    return fSt;
}


BOOL
CInetInfoConfigInfoMapper::CloneVirtDirs(
    BOOL fExtend,
    BOOL fDel,
    DWORD dwToDel )
/*++

Routine Description:

    Clone the virtual root list with optional extension and/or
    deletion of an entry

Arguments:

    fExtend   - TRUE if list is to be extended by one entry ( added
                at the end of the list, m_iIter will be positioned
                on this new entry )
    fDel      - TRUE if the entry specified in dwToDel is to be deleted
                from the list
    dwToDel   - specify the entry index ( 0-based ) to delete if fDel
                is TRUE

Returns:

    TRUE on success, FALSE on failure
    updates reqstatus, m_iIter

--*/
{
    LPINET_INFO_VIRTUAL_ROOT_LIST pL;
    DWORD dwNewCount;
    LPINET_INFO_VIRTUAL_ROOT_LIST pN;

    pL = m_pConfig->VirtualRoots;
    dwNewCount = pL->cEntries + (fExtend ? 1 : 0) - (fDel ? 1 : 0);
    pN = (LPINET_INFO_VIRTUAL_ROOT_LIST)Alloc(
            sizeof(INET_INFO_VIRTUAL_ROOT_LIST) + dwNewCount
            * sizeof(INET_INFO_VIRTUAL_ROOT_ENTRY));
    if ( pN == NULL )
    {
        // insure m_iIter is invalid ( so update attempts will fail )
        if ( fExtend )
        {
            SetIter( pL->cEntries );
        }
        return FALSE;
    }
    pN->cEntries = dwNewCount;

    DWORD dwF;
    DWORD dwT;
    for ( dwF = dwT = 0 ; dwF < pL->cEntries ; ++dwF )
    {
        if ( fDel && dwF == dwToDel )
        {
            continue;
        }
        memcpy( pN->aVirtRootEntry + dwT,
                pL->aVirtRootEntry + dwF,
                sizeof(INET_INFO_VIRTUAL_ROOT_ENTRY) );
        ++dwT;
    }

    m_pConfig->VirtualRoots = pN;

    if ( fExtend )
    {
        SetIter( dwNewCount - 1 );
        LPWSTR pA = (LPWSTR)Alloc( sizeof(WCHAR) );
        if ( pA != NULL )
        {
            pA[0] = L'\0';
            pN->aVirtRootEntry[dwNewCount-1].pszAddress = pA;
        }
        else
        {
            return FALSE;
        }
    }

    return TRUE;
}


VOID
CInetInfoConfigInfoMapper::SetRPCStatusString( DWORD dwS )
/*++

Routine Description:

    Set the RPC status string to the system message with code dwS. If no matching
    code is found, set status string to empty string

Arguments:

    dwS       - System message code

Returns:

     VOID

--*/
{
    LPVOID pszMsgBuffer;
    BOOL fFoundMessage = FALSE;
    DWORD result = 0;
    HANDLE hdll;

    DWORD flags = FORMAT_MESSAGE_ALLOCATE_BUFFER |
    FORMAT_MESSAGE_FROM_SYSTEM |
    FORMAT_MESSAGE_IGNORE_INSERTS;
    //
    //Check whether we can find the error message in the current
    //image
    //

    if ( ! FormatMessage( flags,
              NULL,
              dwS,
              MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
              (LPTSTR) &pszMsgBuffer,
              0,
              NULL ))
    {

    //
    //Couldn't find it in current image, check a list of DLLs
    //
    flags = FORMAT_MESSAGE_ALLOCATE_BUFFER
        | FORMAT_MESSAGE_IGNORE_INSERTS
        | FORMAT_MESSAGE_MAX_WIDTH_MASK
        | FORMAT_MESSAGE_FROM_HMODULE;

    for (int i = 0; i < NUM_ERROR_CODE_DLLS;  i++)
    {
        hdll = LoadLibraryA(g_apszErrorCodeDlls[i]);

        //
        //Check for error msg in this dll
        //
        if (hdll != NULL)
        {
        result = FormatMessage( flags,
                    (LPVOID) hdll,
                    (DWORD) dwS,
                    0,
                    (LPTSTR)&pszMsgBuffer,
                    0,
                    NULL );

        //Done with the lib, unload
        FreeLibrary((HMODULE)hdll);

        //
        //Found an error string
        //

        if (result)
        {
            fFoundMessage = TRUE;
            break;
        }

        } //if (hdll != NULL)

    } //for (int i = 0; ...)

    } //if ( ! FormatMessage...)

    //
    //Found error message in current image
    //
    else
    {
    fFoundMessage = TRUE;
    }


    if (fFoundMessage)
    {
    //deallocate the string if it's been allocated by FormatMessage
    if (m_fAllocatedRPCStatusString)
    {
        LocalFree((HLOCAL) m_pszRPCStatusString);
    }
    m_pszRPCStatusString = (LPTSTR) pszMsgBuffer;
    m_fAllocatedRPCStatusString = TRUE;
    }
    else
    {
    //Couldn't get an error message string, set status string to be the numeric
    //error code

    //free the string if it's been allocated by FormatMessage
    if (m_fAllocatedRPCStatusString)
    {
        LocalFree((HLOCAL) m_pszRPCStatusString);
    }

    m_pszRPCStatusString = (LPTSTR) m_achRPCErrorCodeBuffer;
    wsprintf(m_pszRPCStatusString,"%ld", dwS);
    m_fAllocatedRPCStatusString = FALSE;
    }
}



/////////////////// Verb Context

CVerbContext::CVerbContext(
    VOID )
{
    m_pszVerbName = NULL;
    m_cNbInfoMap = m_cAllocedInfoMap = 0;
    m_pMaps = NULL;
}


CVerbContext::~CVerbContext(
    VOID )
{
    if ( m_pszVerbName != NULL )
    {
        delete [] m_pszVerbName;
    }

    if ( m_pMaps != NULL )
    {
        delete [] m_pMaps;
    }
}


CInetInfoMap*
CVerbContext::GetInfoMap(
    DWORD dwI )
/*++

Routine Description:

    Access the specified entry ( 0-based ) in the parameter list
    of a verb context

Arguments:

    dwI - index in the array of parameters

Returns:

    pointer to variable descriptor or NULL if error

--*/
{
    if ( dwI < m_cNbInfoMap )
    {
        return m_pMaps[dwI];
    }
    return NULL;
}


BOOL
CVerbContext::AddInfoMap(
    CInetInfoMap* pI )
/*++

Routine Description:

    Add a parameter entry in the list of parameters for a verb context

Arguments:

    pI - pointer to a parameter descriptor

Returns:

    TRUE on success, FALSE on failure

--*/
{
    if ( m_cNbInfoMap == m_cAllocedInfoMap )
    {
        m_cAllocedInfoMap += 4;
        CInetInfoMap **pN = new CInetInfoMap*[m_cAllocedInfoMap];
        if ( pN == NULL )
        {
            return FALSE;
        }
        if ( m_pMaps )
        {
            memcpy( pN, m_pMaps, m_cNbInfoMap * sizeof(CInetInfoMap*) );
            delete [] m_pMaps;
        }
        m_pMaps = pN;
    }

    m_pMaps[m_cNbInfoMap++] = pI;

    return TRUE;
}


DWORD
CVerbContext::Parse(
    CInetInfoConfigInfoMapper *pMapper,
    LPBYTE pS,
    DWORD dwL )
/*++

Routine Description:

    Parse a verb command for parameters ( separated with space )
    remember the verb name &
    create an internal array of parameters as variable descriptors

Arguments:

    pMapper - pointer to object used to map variable names to variable
              descriptors
    pS      - verb command to parse
    dwL     - maximum # of characters available for parsing

Returns:

    length of characters used for parsing the verb excluding the "%>"
    delimitor or 0 if error

--*/
{
    DWORD dwW = dwL;
    BOOL fIsVerb;
    CInetInfoMap* pM;
    LPSTR pResult;
    DWORD dwResLen;

    for ( fIsVerb = TRUE ; dwL ; fIsVerb = FALSE )
    {
        // skip white space
        while ( dwL && *pS == ' ' )
        {
            ++pS;
            --dwL;
        }

        LPBYTE pW = pS;
        DWORD dwLenTok = 0;

        // get until '%', ' '
        int c = '%';
        while ( dwL && (c=*pS)!='%' && c!=' ' )
        {
            ++dwLenTok;
            ++pS;
            --dwL;
        }

        if ( fIsVerb )
        {
            m_pszVerbName = new char[dwLenTok+1];
            if ( m_pszVerbName == NULL )
            {
                pMapper->SetRequestStatus( HTR_OUT_OF_RESOURCE );
                return 0;
            }
            memcpy( m_pszVerbName, pW, dwLenTok );
            m_pszVerbName[dwLenTok] = '\0';
        }
        else if ( !memcmp( "iis.", pW, sizeof("iis.")-1 ) )
        {
            if ( pMapper->GetFromServer( (LPSTR)pW, dwLenTok, &pResult,
                    &dwResLen ) )
            {
                goto alloc_map;
            }
            return 0;   // error
        }
        else if ( !memcmp( "msgbody.", pW, sizeof("msgbody.")-1 ) )
        {
            if ( pMapper->GetFromMsgBody( (LPSTR)pW, dwLenTok, &pResult,
                    &dwResLen ) )
            {
alloc_map:
                pM = (CInetInfoMap*)pMapper->Alloc( sizeof(CInetInfoMap) );
                if ( !pM )
                {
                    return 0;
                }
                pM->iType = ITYPE_PARAM_LIT_STRING;
                pM->pName = pResult;

                goto add_map;
            }
            return 0;   // error
        }
        else if ( *pW == '"' )
        {
            pM = (CInetInfoMap*)pMapper->Alloc( sizeof(CInetInfoMap) );
            if ( !pM )
            {
                return 0;
            }
            pM->iType = ITYPE_PARAM_LIT_STRING;
            if ( !(pM->pName = (LPSTR)pMapper->Alloc( dwLenTok - 1 )) )
            {
                return 0;
            }
            memcpy( pM->pName, pW + 1, dwLenTok - 2 );
            pM->pName[ dwLenTok -2 ] ='\0';
add_map:
            if ( !AddInfoMap( pM ) )
            {
                pMapper->SetRequestStatus( HTR_OUT_OF_RESOURCE );
                return 0;
            }
        }
        else
        {
            CInetInfoMap *pM;
            if ( pMapper->Map( pW, dwLenTok, &pM ) )
            {
                if ( !AddInfoMap( pM ) )
                {
                    pMapper->SetRequestStatus( HTR_OUT_OF_RESOURCE );
                    return 0;
                }
            }
            else
            {
                return 0;       // error
            }
        }

        if ( c=='%' )
        {
            break;
        }
    }

    return dwW - dwL;
}


/////////////////// Request

// adjust the IF status at the nested IF level

void
Adjust(
    int *piIsSkip,
    int iIf )
{
    if ( iIf )
    {
        *piIsSkip |= HSS_SKIP_IF;
    }
    else
    {
        *piIsSkip &= ~HSS_SKIP_IF;
    }
}


//
// Extensible buffer class
//

CExtBuff::CExtBuff(
    VOID )
{
    m_pB = NULL;
    m_cCurrent = m_cAlloc = 0;
}


CExtBuff::~CExtBuff(
    VOID )
{
    if ( m_pB )
    {
        delete [] m_pB;
    }
}


void
CExtBuff::Reset(
    VOID )
/*++

Routine Description:

    Reset a buffer to an empty state

Arguments:

    None

Returns:

    VOID

--*/
{
    if ( m_pB != NULL )
    {
        delete [] m_pB;
    }
    m_pB = NULL;
    m_cCurrent = m_cAlloc = 0;
}


BOOL
CExtBuff::Extend(
    UINT cReq )
/*++

Routine Description:

    Insure buffer at least wide enough for additional
    specified # of bytes

Arguments:

    cReq - # of characters to add to current buffer length

Returns:

    TRUE if success, FALSE if failure

--*/
{
    BOOL fSt = TRUE;

    if ( m_cAlloc - m_cCurrent < cReq )
    {
        UINT cAlloc = m_cAlloc + EXTBUFF_INCALLOC;
        if ( cAlloc < m_cCurrent + cReq )
        {
            cAlloc = ((cAlloc + cReq + EXTBUFF_INCALLOC)/EXTBUFF_INCALLOC)
                    * EXTBUFF_INCALLOC;
        }
        LPBYTE pN = new BYTE[cAlloc];
        if ( pN != NULL )
        {
            if ( m_pB != NULL )
            {
                memcpy( pN, m_pB, m_cCurrent );
                delete [] m_pB;
            }
            m_pB = pN;
            m_cAlloc = cAlloc;
        }
        else
        {
            fSt = FALSE;
        }
    }

    return fSt;
}


BOOL
CExtBuff::CopyBuff(
    LPBYTE pB,
    UINT cB )
/*++

Routine Description:

    append bytes at end of buffer

Arguments:

     pB - pointer to origine bytes
     cB - count of bytes to copy

Returns:

    TRUE if success, FALSE if failure

--*/
{
    if ( !cB )
    {
        return TRUE;
    }

    if ( Extend( cB ) )
    {
        memcpy( m_pB + m_cCurrent, pB, cB );
        m_cCurrent += cB;
        return TRUE;
    }

    return FALSE;
}


//
// Map HTTP status numeric code to ASCII status
//

CStatusStringAndCode g_aStatus[] = {
    { HT_OK, IDS_HTRESP_OKANS },
    { HT_REDIRECT, IDS_HTRESP_REDIRECT },
    { HT_SERVER_ERROR, IDS_HTRESP_SERVER_ERROR },
    { HT_BAD_GATEWAY, IDS_HTRESP_BAD_GATEWAY },
} ;


//
// list of recognized verbs
//

CInetInfoVerbMap g_aIVerbMap[] = {

    { "AddDenyIpAccess", &CInetInfoRequest::AddDenyIPAccess },
    { "DelDenyIpAccess", &CInetInfoRequest::DeleteDenyIPAccess },
    { "PosDenyIpAccess", &CInetInfoRequest::PositionDenyIPAccess },
    { "SetDefaultIpAccessToDeny", &CInetInfoRequest::DefaultIsDenyIPAccess },

    { "AddGrantIpAccess", &CInetInfoRequest::AddGrantIPAccess },
    { "DelGrantIpAccess", &CInetInfoRequest::DeleteGrantIPAccess },
    { "PosGrantIpAccess", &CInetInfoRequest::PositionGrantIPAccess },
    { "SetDefaultIpAccessToGrant", &CInetInfoRequest::DefaultIsGrantIPAccess },

    { "AddVirtDir", &CInetInfoRequest::AddVirtDir },
    { "DelVirtDir", &CInetInfoRequest::DeleteVirtDir },
    { "PosVirtDir", &CInetInfoRequest::PositionVirtDir },

    { "ChangePassword", &CInetInfoRequest::ChangePassword },
    { "GetUserFlags", &CInetInfoRequest::GetUserFlags },
    { "SetHttpStatus", &CInetInfoRequest::SetHttpStatus },

    { "Update", &CInetInfoRequest::Update },
    { "Clear", &CInetInfoRequest::Clear },

    { "DisconnectUser", &CInetInfoRequest::DisconnectUser },
    { "DisconnectAll", &CInetInfoRequest::DisconnectAll },

    { "GetStatus", &CInetInfoRequest::GetStatus },

    { "ValidateDir", &CInetInfoRequest::ValidateDir },
    { "CreateDir", &CInetInfoRequest::CreateDir },
    { "GenerateDirList", &CInetInfoRequest::GenerateDirList },

    { "CheckForVirtDir", &CInetInfoRequest::CheckForVirtDir },
    { "AliasVirtDir", &CInetInfoRequest::AliasVirtDir },
} ;


CInetInfoRequest::CInetInfoRequest(
    EXTENSION_CONTROL_BLOCK*p_ECB,
    CInetInfoConfigInfoMapper* pMapper,
    LPSTR pScr,
    LPSTR pParam )
{
    m_pECB = p_ECB;
    m_pMapper = pMapper;
    m_pScr = pScr;
    m_pParam = pParam;
    m_pData = NULL;
    m_dwDataLen = 0;

    m_pDataRaw = NULL;
    m_dwDataRawLen = 0;

    m_dwHTTPStatus = HT_OK;
}


CInetInfoRequest::~CInetInfoRequest(
    VOID )
{
    if ( m_pData != NULL )
    {
        delete [] m_pData;
    }

    if( m_pDataRaw != NULL )
    {
        delete [] m_pDataRaw;
    }
}


BOOL
CInetInfoRequest::DoVerb(
    CVerbContext *pC )
/*++

Routine Description:

    Invoke an already parsed verb

Arguments:

    pC - pointer to parsed verb

Returns:

    TRUE if success, FALSE if failure

--*/
{
    m_pVerbContext = pC;

    // find verb, call it
    UINT iH;
    for ( iH = 0 ; iH < sizeof(g_aIVerbMap)/sizeof(CInetInfoVerbMap) ; ++iH )
    {
        if ( !strcmp( g_aIVerbMap[iH].pszName, pC->GetVerbName() ) )
        {
            break;
        }
    }

    if ( iH == sizeof(g_aIVerbMap)/sizeof(CInetInfoVerbMap) )
    {
        return FALSE;
    }

    return (this->*g_aIVerbMap[iH].pHandler)();
}


BOOL
InlineFromTransparent(
    LPBYTE pData,
    DWORD *pdwDataLen,
    BOOL fFilterEscPlus
    )
/*++

Routine Description:

    Decode inline a buffer from HTTP character transparency

Arguments:

    pData          - array of characters to decode
    pdwDataLen     - # of characters in buffer, updated on output
    fFilterEscPlus - TRUE if "%+" is to be decoded to "+"

Returns:

    TRUE if success, FALSE if failure

--*/
{
    DWORD dwDataLen, dwWas;
    LPBYTE pT, pScan, pWas ;
    int ch;


    dwWas = *pdwDataLen;
    pWas = pData;

    for ( dwDataLen = dwWas, pScan = pWas ;
            dwDataLen-- ; )
    {
        switch ( ch = *pScan++ )
        {
            case '%':
                if ( dwDataLen )
                {
                    if ( !fFilterEscPlus && pScan[0] == '%' )
                    {
                        --dwWas;
                        ++pScan;
                        --dwDataLen;
                        *pData++ = '%';
                    }
                    else if ( pScan[0] == '+' )
                    {
                        if ( fFilterEscPlus )
                        {
                            --dwWas;
                        }
                        else
                        {
                            *pData++ = '%';
                        }
                        *pData++ = '+';
                        ++pScan;
                        --dwDataLen;
                    }
                    else if ( !fFilterEscPlus && dwDataLen >= 2 )
                    {
                        *pData++ = (HexCharToUINT( pScan[0] )<<4)
                                + HexCharToUINT( pScan[1] );
                        dwWas -= 2;
                        pScan += 2;
                        dwDataLen -= 2;
                    }
                    else
                    {
                        *pData++ = '%';
                    }
                }
                else
                {
                    *pData++ = '%';
                }
                break;

            case '+':
                if ( !fFilterEscPlus )
                {
                    *pData++ = ' ';
                    break;
                }
                // fall-through

            default:
                *pData ++ = (char)ch;
        }
    }

    *pdwDataLen = dwWas;

    return TRUE;
}


BOOL
CInetInfoRequest::Init(
    LPSTR pMsg,
    int cMsg )
/*++

Routine Description:

    Initialize a HTMLA request from the associated ISAPI object

Arguments:

    pMsg - message body. If NULL, uses the associated ISAPI
           structure to retrieve message body
    cMsg - message body length if pMsg is non NULL

Returns:

    TRUE if success, FALSE if failure

--*/
{
    BOOL fSt = TRUE;
    BOOL fDoTrp = TRUE;
    int cTotal;

    if ( pMsg == NULL )
    {
        cMsg = m_pECB->cbAvailable;
        cTotal = m_pECB->cbTotalBytes;
        // work-around bug in IIS
        if ( cMsg > cTotal )
        {
            cMsg = cTotal;
        }
        pMsg = (LPSTR)m_pECB->lpbData;
    }
    else
    {
        cTotal = cMsg;
        fDoTrp = FALSE;
    }

    // get request body
    m_pData = new char[cTotal +  1];
    if ( m_pData == NULL )
    {
        return FALSE;
    }
    if ( (m_dwDataLen = cMsg) )
    {
        memcpy( m_pData, pMsg, cMsg );
    }
    if ( cMsg < cTotal )
    {
        DWORD dwRead = cTotal - cMsg;
        if ( m_pECB->ReadClient( (HCONN)m_pECB->ConnID, m_pData + cMsg,
                &dwRead ) )
        {
            m_dwDataLen += dwRead;
        }
        else
        {
            fSt = FALSE;
        }
    }

    // Get the raw version of the entity data
    // Bug NT-3643652
    m_dwDataRawLen = m_dwDataLen;
    m_pDataRaw = new char[m_dwDataRawLen + 1];
    if( m_pDataRaw == NULL )
    {
        return FALSE;
    }
    memcpy( m_pDataRaw, m_pData, m_dwDataRawLen );
    m_pDataRaw[m_dwDataRawLen] = '\0';


    // Generate "Expires" header

    m_pHeader = ALWAYS_EXPIRE;

    // retrieve remote addr

    char achAddr[64];
    DWORD dwAddr = sizeof( achAddr );
    if ( g_fFakeServer
            || !m_pECB->GetServerVariable( (HCONN)m_pECB->ConnID,
                "REMOTE_ADDR",
                achAddr,
                &dwAddr ) )
    {
        achAddr[0] = '\0';
    }
    GetMapper()->SetRemoteAddr( achAddr );

    // set host name

    LPVOID *ppV;
    LPSTR pS;
    if ( GetMapper()->HostName( (LPVOID*)&ppV ) )
    {
        pS = *(LPSTR*)ppV;
        if ( g_pszDefaultHostName != NULL )
        {
            strcpy( pS, g_pszDefaultHostName );
        }
        else
        {
            DWORD dwL = MAX_DOMAIN_LENGTH;
            if ( m_pECB->GetServerVariable( (HCONN)m_pECB->ConnID,
                    "SERVER_NAME", pS, &dwL ) == FALSE )
            {
                *pS = '\0';
            }
        }
    }

    // retrieve HTTP server version

    if ( g_achW3Version[0] == '\0' )
    {
        DWORD dwL = sizeof(g_achW3Version);
        if ( m_pECB->GetServerVariable( (HCONN)m_pECB->ConnID,
                "SERVER_SOFTWARE", g_achW3Version, &dwL ) == FALSE )
        {
            g_achW3Version[0] = '\0';
        }
    }

    if ( fDoTrp )
    {
        // Handle request body for transparency

        InlineFromTransparent( (LPBYTE)m_pData, &m_dwDataLen, FALSE );
        m_pData[m_dwDataLen] = '\0';
    }

    // Handle query string for transparency

    DWORD dwLQ = lstrlen( m_pParam );
    InlineFromTransparent( (LPBYTE)m_pParam, &dwLQ, !fDoTrp );
    if ( m_pParam[dwLQ] != '\0' )
    {
        m_pParam[dwLQ] = '\0';
    }

    return fSt;
}


LPSTR
CInetInfoRequest::HTTPStatusStringFromCode(
    VOID )
{
    for ( int x = 0 ; x < sizeof(g_aStatus)/sizeof(CStatusStringAndCode) ;
            ++x )
    {
        if ( g_aStatus[x].dwStatus == m_dwHTTPStatus )
        {
            return g_aStatus[x].achStatus;
        }
    }

    return "";
}


DWORD
CInetInfoRequest::Done(
    VOID )
/*++

Routine Description:

    Send result from HTMLA request to the associated ISAPI object

Arguments:

    None, uses internal m_dwHTTPStatus & message buffer

Returns:

    ISAPI status, to be returned by the ExtensionProc

--*/
{
    DWORD dwLen = 0;
    DWORD dwS = HSE_STATUS_SUCCESS;
    char achStatus[80];

    if ( g_fFakeServer )
    {
        return FALSE;
    }

    switch ( m_dwHTTPStatus )
    {
    case HT_REPROCESS:
        dwS = HSE_REPROCESS;
        break;

    case HT_REDIRECT:
        //dwLen = m_eb.GetLen();
        if ( !m_pECB->ServerSupportFunction( m_pECB->ConnID,
                                             HSE_REQ_SEND_URL_REDIRECT_RESP,
                                             m_eb.GetPtr(),
                                             0,
                                             NULL ) )
        {
            dwS = HSE_STATUS_ERROR;
        }
        break;


    case HT_REDIRECTH:
        if ( !m_pECB->ServerSupportFunction( m_pECB->ConnID,
                                             HSE_REQ_SEND_URL_REDIRECT_RESP,
                                             m_eb.GetPtr(),
                                             0,
                                             NULL ) )
        {
            dwS = HSE_STATUS_ERROR;
        }
        break;

    case HT_DENIED:
#if defined(GENERATE_AUTH_HEADERS)
        g_AuthReqs.Lock();
         LPSTR pszAuthReqs = g_AuthReqs.GetAuthenticationListHeader();

        if ( pszAuthReqs == NULL )
        {
            dwLen = 0;
        }
        else
        {
            dwLen = lstrlen( pszAuthReqs );
        }

        if ( !m_pECB->ServerSupportFunction( m_pECB->ConnID,
                                             HSE_REQ_SEND_RESPONSE_HEADER,
                                             g_achAccessDenied,
                                             &dwLen,
                                             (LPDWORD)pszAuthReqs ) )
        {
            dwS = HSE_STATUS_ERROR;
        }
        g_AuthReqs.UnLock();
        break;
#else
        dwLen = strlen(g_achAccessDeniedBody);
        if ( !m_pECB->ServerSupportFunction( m_pECB->ConnID,
                                             HSE_REQ_SEND_RESPONSE_HEADER,
                                             g_achAccessDenied,
                                             &dwLen,
                                             (LPDWORD)g_achAccessDeniedBody ) )
        {
            dwS = HSE_STATUS_ERROR;
        }
        break;
#endif

    case HT_NOT_FOUND:
        dwLen = lstrlen( g_achNotFoundBody );

        if ( !m_pECB->ServerSupportFunction( m_pECB->ConnID,
                                             HSE_REQ_SEND_RESPONSE_HEADER,
                                             g_achNotFound,
                                             &dwLen,
                                             (LPDWORD) g_achNotFoundBody ) )
        {
            dwS = HSE_STATUS_ERROR;
        }
        break;

    default:
        HSE_SEND_HEADER_EX_INFO HSHEI;
        memset( &HSHEI, 0, sizeof( HSHEI ) );

        wsprintf( achStatus, "%d %s", m_dwHTTPStatus,
                  HTTPStatusStringFromCode() );

        HSHEI.pszStatus = achStatus;
        HSHEI.cchStatus = 0;

        if ( m_dwHTTPStatus != HT_OK )
        {
            m_eb.Reset();
        }

#if defined( _ENABLE_KEEP_ALIVE )
        LPSTR pNewH = new char[ lstrlen( m_pHeader ) + 128 ];
        if ( pNewH != NULL )
        {
            BOOL fKeep = FALSE;
            m_pECB->ServerSupportFunction( m_pECB->ConnID,
                                           HSE_REQ_IS_KEEP_CONN,
                                           &fKeep,
                                           0,
                                           NULL );

            strcpy( pNewH, m_pHeader );
            wsprintf( pNewH + lstrlen(pNewH) - 2,
                      "%sContent-Length: %lu\r\n\r\n",
                      fKeep ? "Connection: keep-alive\r\n" : "",
                      m_eb.GetLen() );

            dwLen = lstrlen( pNewH );

            HSHEI.pszHeader = pNewH;
            HSHEI.cchHeader = 0;
            HSHEI.fKeepConn = fKeep;

            if ( m_pECB->ServerSupportFunction( m_pECB->ConnID,
                                                HSE_REQ_SEND_RESPONSE_HEADER_EX,
                                                (LPVOID) &HSHEI,
                                                NULL,
                                                NULL ) )
            {
                dwS = fKeep
                      ? HSE_STATUS_SUCCESS_AND_KEEP_CONN
                      : HSE_STATUS_SUCCESS ;
            }
            else
            {
                dwS = HSE_STATUS_ERROR;
            }

            delete [] pNewH;
        }
        else
#endif
        {
            dwLen = lstrlen( m_pHeader );

            HSHEI.pszHeader = m_pHeader;
            HSHEI.cchHeader = 0;

            if ( !m_pECB->ServerSupportFunction( m_pECB->ConnID,
                                                 HSE_REQ_SEND_RESPONSE_HEADER_EX,
                                                 (LPVOID) &HSHEI,
                                                 NULL,
                                                 NULL ) )

            {
                dwS = HSE_STATUS_ERROR;
            }
        }

        if ( dwS != HSE_STATUS_ERROR )
        {
            dwLen = m_eb.GetLen();

            //
            // If WriteClient fails, nothing useful to do at this point,
            // so ignore return value
            //

            m_pECB->WriteClient( m_pECB->ConnID,
                                     m_eb.GetPtr(),
                                 &dwLen,
                                 0 );
        }

    }

    return dwS;
}


LPSTR
CInetInfoRequest::GetVarAsString(
    DWORD dwI,
    BOOL *pfF )
/*++

Routine Description:

    Access the specified entry ( 0-based ) in the parameter list
    of the associated verb context and returns the result as a string

Arguments:

    dwI - index in the array of parameters ( 0-based )
    pfF - updated with TRUE if buffer to be freed after usage
          ( using delete[] )

Returns:

    pointer to string representation of parameter or NULL if error

--*/
{
    LPSTR pResult;
    DWORD dwResLen;

    if ( m_pVerbContext->GetNbInfoMap() > dwI )
    {
        CInetInfoMap* pM = m_pVerbContext->GetInfoMap( dwI );
        if ( pM->iType == ITYPE_PARAM_LIT_STRING )
        {
            *pfF = FALSE;
            return pM->pName;
        }
        else if ( GetMapper()->GetString( pM, &pResult, &dwResLen, pfF ) )
        {
            return pResult;
        }
    }

    return NULL;
}


//
// HTMLA Verbs handling. verb is already parsed
//
// These functions are basically wrappers around functions in
// CInetInfoConfigInfoMapper
//
// The "HTMLA Arguments:" will indicates arguments for this function
// in a HTMLA script.
//


BOOL
CInetInfoRequest::AddDenyIPAccess(
    VOID )
/*++

Routine Description:

    Add an empty entry in the deny access IP list
    This entry is to be set later by the HTMLA script
    ( the relevant variables will point to the newly created entry )

Arguments:

    None

HTMLA Arguments:

    None

Returns:

    TRUE if success, otherwise FALSE
    updates reqstatus

--*/
{
    return GetMapper()->AddIPAccess( TRUE );
}


BOOL
CInetInfoRequest::DeleteDenyIPAccess(
    )
/*++

Routine Description:

    Delete an entry in the deny access IP list

Arguments:

    None

HTMLA Arguments:

    access list entry reference

Returns:

    TRUE if success, otherwise FALSE
    updates reqstatus

--*/
{
    LPSTR pV;
    BOOL fF;
    BOOL fSt = FALSE;

    if ( (pV = GetVarAsString( 0, &fF )) != NULL )
    {
        fSt = GetMapper()->DeleteIPAccess( TRUE, pV );
        if ( fF )
        {
            delete [] pV;
        }
    }

    return fSt;
}


BOOL
CInetInfoRequest::PositionDenyIPAccess(
    VOID )
/*++

Routine Description:

    Set the iteration counter ( m_iIter ) to point to the entry
    matching the specified reference in the deny access list.

Arguments:

    None

HTMLA Arguments:

    access list entry reference

Returns:

    TRUE if success, otherwise FALSE
    updates reqstatus

--*/
{
    LPSTR pV;
    BOOL fF;
    BOOL fSt = FALSE;

    if ( (pV = GetVarAsString( 0, &fF )) != NULL )
    {
        if ( GetMapper()->PositionIPAccess( TRUE, pV ) )
        {
            fSt = Update();
        }
        if ( fF )
        {
            delete [] pV;
        }
    }

    return fSt;
}


BOOL
CInetInfoRequest::DefaultIsDenyIPAccess(
    VOID )
/*++

Routine Description:

    Set the default condition to be denied access to the service
    if the client address is not in the grant list

Arguments:

    None

HTMLA Arguments:

    None

Returns:

    TRUE if success, otherwise FALSE
    updates reqstatus

--*/
{
    return GetMapper()->SetIPAccessDefault( TRUE );
}


BOOL
CInetInfoRequest::AddGrantIPAccess(
    VOID )
/*++

Routine Description:

    Add an empty entry in the grant access IP list
    This entry is to be set later by the HTMLA script
    ( the relevant variables will point to the newly created entry )

Arguments:

    None

HTMLA Arguments:

    None

Returns:

    TRUE if success, otherwise FALSE
    updates reqstatus

--*/
{
    return GetMapper()->AddIPAccess( FALSE );
}


BOOL
CInetInfoRequest::DeleteGrantIPAccess(
    VOID )
/*++

Routine Description:

    Delete an entry in the grant access IP list

Arguments:

    None

HTMLA Arguments:

    access list entry reference

Returns:

    TRUE if success, otherwise FALSE
    updates reqstatus

--*/
{
    LPSTR pV;
    BOOL fF;
    BOOL fSt = FALSE;

    if ( (pV = GetVarAsString( 0, &fF )) != NULL )
    {
        fSt = GetMapper()->DeleteIPAccess( FALSE, pV );
        if ( fF )
        {
            delete [] pV;
        }
    }

    return fSt;
}


BOOL
CInetInfoRequest::PositionGrantIPAccess(
    VOID )
/*++

Routine Description:

    Set the iteration counter ( m_iIter ) to point to the entry
    matching the specified reference in the grant access list.

Arguments:

    None

HTMLA Arguments:

    access list entry reference

Returns:

    TRUE if success, otherwise FALSE
    updates reqstatus

--*/
{
    LPSTR pV;
    BOOL fF;
    BOOL fSt = FALSE;

    if ( (pV = GetVarAsString( 0, &fF )) != NULL )
    {
        if ( GetMapper()->PositionIPAccess( FALSE, pV ) )
        {
            fSt = Update();
        }
        if ( fF )
        {
            delete [] pV;
        }
    }

    return fSt;
}


BOOL
CInetInfoRequest::DefaultIsGrantIPAccess(
    VOID )
/*++

Routine Description:

    Set the default condition to be granted access to the service
    if the client address is not in the deny list

Arguments:

    None

HTMLA Arguments:

    None

Returns:

    TRUE if success, otherwise FALSE
    updates reqstatus

--*/
{
    return GetMapper()->SetIPAccessDefault( FALSE );
}


BOOL
CInetInfoRequest::AddVirtDir(
    VOID )
/*++

Routine Description:

    Add an empty entry in the virtual root list
    This entry is to be set later by the HTMLA script
    ( the relevant variables will point to the newly created entry )

Arguments:

    None

HTMLA Arguments:

    None

Returns:

    TRUE if success, otherwise FALSE
    updates reqstatus

--*/
{
    return GetMapper()->AddVirtDir();
}

/* INTRINSA suppress=null_pointers, uninitialized */
BOOL
CInetInfoRequest::DeleteVirtDir(
    VOID )
/*++

Routine Description:

    Delete an entry in the grant access IP list

Arguments:

    None

HTMLA Arguments:

    virtual root list entry reference

Returns:

    TRUE if success, otherwise FALSE
    updates reqstatus

--*/
{
    LPSTR pV;
    BOOL fF;
    BOOL fSt = FALSE;

    if ( (pV = GetVarAsString( 0, &fF )) != NULL )
    {
        fSt = GetMapper()->DeleteVirtDir( pV );
        if ( fF )
        {
            delete [] pV;
        }
    }

    return fSt;
}


BOOL
CInetInfoRequest::PositionVirtDir(
    VOID )
/*++

Routine Description:

    Set the iteration counter ( m_iIter ) to point to the entry
    matching the specified reference in the virtual root list.

Arguments:

    None

HTMLA Arguments:

    virtual root list entry reference

Returns:

    TRUE if success, otherwise FALSE
    updates reqstatus

--*/
{
    LPSTR pV;
    BOOL fF;
    BOOL fSt = FALSE;

    if ( (pV = GetVarAsString( 0, &fF )) != NULL )
    {
        fSt = GetMapper()->PositionVirtDir( pV );
        if ( fF )
        {
            delete [] pV;
        }
    }

    return fSt;
}


LPWSTR
CInetInfoRequest::AnsiToUnicode(
    LPSTR psz
    )
/*++

Routine Description:

    Convert ANSI string to UNICODE
    Storage will be automatically released at end of HTMLA request

Arguments:

    psz - ANSI string

Returns:

    pointer to UNICODE string or NULL if failure
    updates reqstatus on failure.

--*/
{
    UINT cL = strlen( psz );
    LPWSTR pwsz = (LPWSTR)GetMapper()->Alloc( (cL+1)*sizeof(WCHAR) );

    if ( pwsz && cL )
    {
        if ( !(cL = MultiByteToWideChar( CP_ACP, 0, psz, cL, pwsz, cL )) )
        {
            pwsz = NULL;
            GetMapper()->SetRequestStatus( HTR_BAD_PARAM );
        }
        else
        {
            pwsz[cL] = L'\0';
        }
    }

    return pwsz;
}



BOOL
CInetInfoRequest::GetUserFlags(
    VOID
    )
/*++

Routine Description:

    Set the userflag variable with up to date info from GetUserInfo

Arguments:

    None

HTMLA arguments:

    UserAccout

Returns:

    TRUE if success, otherwise FALSE
    updates reqstatus, rpcstatus with return from NetUserChangePassword

--*/
{
    LPSTR pUser;
    BOOL fUser = FALSE;
    PUSER_INFO_1 pUI1;
    NET_API_STATUS s;

    if ( (pUser = GetVarAsString( 0, &fUser )) )
    {
        //(pU = strchr( pUser, '\\' )) != NULL
        LPWSTR pwszUser = AnsiToUnicode( pUser );

        if ( pwszUser )
        {
            if ( (s = NetUserGetInfo( NULL, pwszUser, 1, (LPBYTE*)&pUI1)) == 0 )
            {
               GetMapper()->SetUserFlags( pUI1->usri1_flags );
            }
            else
            {
                GetMapper()->SetRequestStatus( HTR_VALIDATION_FAILED );
            }
            GetMapper()->SetRPCStatus( s );
        }
    }
    else
    {
        return FALSE;
    }

    if ( fUser )
    {
        delete [] pUser;
    }

    return TRUE;
}



BOOL
CInetInfoRequest::SetHttpStatus(
    VOID
    )
/*++

Routine Description:

    Set the HTTP status for the current request

Arguments:

    None

HTMLA arguments:

    Numeric status

Returns:

    TRUE if success, otherwise FALSE

--*/
{
    LPSTR pUser;
    BOOL fUser = FALSE;
    PUSER_INFO_1 pUI1;
    NET_API_STATUS s;

    if ( (pUser = GetVarAsString( 0, &fUser )) )
    {
        SetHTTPStatus( atol(pUser) );
    }
    else
    {
        GetMapper()->SetRequestStatus( HTR_BAD_PARAM );
        return FALSE;
    }

    if ( fUser )
    {
        delete [] pUser;
    }

    return TRUE;
}


BOOL
CInetInfoRequest::ChangePassword(
    VOID
    )
/*++

Routine Description:

    Change NT account pwd using user name, old pwd, new pwd

Arguments:

    None

HTMLA arguments:

    UserAccout OldPwd NewPwd

Returns:

    TRUE if success, otherwise FALSE
    updates reqstatus, rpcstatus with return from NetUserChangePassword

--*/
{
    LPSTR           pDomain;
    LPSTR           pUser;
    LPSTR           pOld;
    LPSTR           pNew;
    LPSTR           pTmp;
    LPSTR           pSep = NULL;
    LPSTR           pU = NULL;
    BOOL            fDomain = FALSE;
    BOOL            fUser = FALSE;
    BOOL            fOld = FALSE;
    BOOL            fNew = FALSE;
    BOOL            fSt = FALSE;
    BOOL            fGotAllParams = FALSE;
    CHAR            achDefaultDomain[DNLEN + 1];

    NET_API_STATUS  s;

    GetMapper()->SetRPCStatus( 0 );

    pDomain = GetVarAsString( 0, &fDomain );
    pUser = GetVarAsString( 1, &fUser );
    pOld = GetVarAsString( 2, &fOld );
    pNew = GetVarAsString( 3, &fNew );

    //
    // We may have the user and domain in the pUser and pDomain fields or
    // we may get both user and domain in the pUser field, in the form
    // DOMAIN\USERNAME. In either case, try to split the information into
    // two variables, pU and pUser, for domain and user name respectively.
    //

    if ( pUser )
    {
    //
    // Got the domain as separate field
    //
        if ( pDomain && *pDomain )
        {
            pU = pDomain;
        }
    //
    // Got domain\user as single field
    //
        else if ( (pU = (LPSTR)_mbschr( (LPBYTE)pUser, '\\' )) != NULL )
        {
            pSep = pU;
            pU[0] = '\0';
            pTmp = pU + 1;
            pU = pUser;
            pUser = pTmp;
        }
    }

    //
    // If we still don't have a logon domain, try to retrieve the default
    //
    if (pU == NULL)
    {
    if ( g_pfnGetDefaultDomainName &&
         g_pfnGetDefaultDomainName((LPSTR) &achDefaultDomain, DNLEN) )
    {
        pU = achDefaultDomain;
    }
    }

    if ( pUser != NULL &&
     pU != NULL &&
         pOld != NULL &&
         pNew != NULL
       )
    {
        LPWSTR pwszDomain = pU ? AnsiToUnicode( pU ) : NULL;
        LPWSTR pwszUser = AnsiToUnicode( pUser );
        LPWSTR pwszOld = AnsiToUnicode( pOld );
        LPWSTR pwszNew = AnsiToUnicode( pNew );

        if ( pwszUser && pwszOld && pwszNew )
        {
        fGotAllParams = TRUE;

            if ( (s = NetUserChangePassword( pwszDomain,
                                             pwszUser,
                                             pwszOld,
                                             pwszNew )) != 0 )
            {
                GetMapper()->SetRPCStatus( s );
                GetMapper()->SetRequestStatus( HTR_VALIDATION_FAILED );
            }
        }

        if ( pSep )
        {
            *pSep = '\\';
        }
    }

    //
    // If we didn't get enough parameters, eg no user name or couldn't convert some of them into
    // the correct format, set error status. We could set more specific error code, eg
    // ERROR_INVALID_PASSWORD, ERROR_BAD_USERNAME, but this would be misleading if more than
    // one of these error conditions happens, so just return generic "bad parameter"
    //
    if (!fGotAllParams)
    {
    GetMapper()->SetRPCStatus( ERROR_INVALID_PARAMETER );
        GetMapper()->SetRequestStatus( HTR_BAD_PARAM );
    }

    if ( fDomain )
    {
        delete [] pDomain;
    }

    if ( fUser )
    {
        delete [] pUser;
    }

    if ( fOld )
    {
        delete [] pOld;
    }

    if ( fNew )
    {
        delete [] pNew;
    }

    return fSt;
}


BOOL
CInetInfoRequest::DisconnectUser(
    VOID )
/*++

Routine Description:

    Disconnect the user specified by a numeric ID from the service
    mapped to this request.
    This ID is an opaque numeric value returned by the server
    in one of the RPC structure

Arguments:

    None

HTMLA Arguments:

    User numeric ID

Returns:

    TRUE if success, otherwise FALSE
    updates reqstatus

--*/
{
    BOOL fSt = FALSE;
    LPSTR pV;
    BOOL fF;

    if ( (pV = GetVarAsString( 0, &fF )) != NULL )
    {
        fSt = GetMapper()->DisconnectUser( pV );
        if ( fF )
        {
            delete [] pV;
        }
    }

    return fSt;
}


BOOL
CInetInfoRequest::DisconnectAll(
    VOID )
/*++

Routine Description:

    Disconnect all users from the service mapped to this request

Arguments:

    None

HTMLA Arguments:

    None

Returns:

    TRUE if success, otherwise FALSE
    updates reqstatus

--*/
{
    return GetMapper()->DisconnectAll();
}


BOOL
CInetInfoRequest::GetStatus(
    VOID )
/*++

Routine Description:

    Updates the HTMLA variables exposing the status of IP services
    ( HTTP, FTP, Gopher ) so that they can be accessed in the HTMLA
    script.

Arguments:

    None

HTMLA Arguments:

    None

Returns:

    TRUE if success, otherwise FALSE
    updates reqstatus

--*/
{
    return GetMapper()->GetStatus();
}


BOOL
CInetInfoRequest::ValidateDir(
    VOID )
/*++

Routine Description:

    Validate a directory path ( checks for existence )

Arguments:

    None

HTMLA Arguments:

    Directory path to validate

Returns:

    TRUE if success, otherwise FALSE
    updates reqstatus

--*/
{
    BOOL fSt = FALSE;
    LPSTR pV;
    BOOL fF;

    if ( (pV = GetVarAsString( 0, &fF )) != NULL )
    {
        fSt = GetMapper()->ValidateDir( pV );
        if ( fF )
        {
            delete [] pV;
        }
    }

    return fSt;
}


BOOL
CInetInfoRequest::CreateDir(
    VOID )
/*++

Routine Description:

    Validate a directory path ( checks for existence )

Arguments:

    None

HTMLA Arguments:

    - Directory path where to create directory
    - Directory name to create ( w/o '\' )

Returns:

    TRUE if success, otherwise FALSE
    updates reqstatus

--*/
{
    BOOL fSt = FALSE;
    LPSTR pV1, pV2;
    BOOL fF1 = FALSE, fF2 = FALSE;

    pV1 = GetVarAsString( 0, &fF1 );
    pV2 = GetVarAsString( 1, &fF2 );

    if ( pV1 != NULL && pV2 != NULL )
    {
        fSt = GetMapper()->CreateDir( pV1, pV2 );
    }

    if ( fF1 )
    {
        delete [] pV1;
    }

    if ( fF2 )
    {
        delete [] pV2;
    }

    return fSt;
}


BOOL
CInetInfoRequest::CheckForVirtDir(
    VOID )
/*++

Routine Description:

    Handle the _VIRT_DIR_REQ_CHECK command.
    see HandleVirtDirRequest() below

Arguments:

    None

Returns:

    TRUE on success, FALSE on failure
    updates reqstatus

--*/
{
    return HandleVirtDirRequest( _VIRT_DIR_REQ_CHECK );
}


BOOL
CInetInfoRequest::AliasVirtDir(
    VOID )
/*++

Routine Description:

    Handle the _VIRT_DIR_REQ_ALIAS command.
    see HandleVirtDirRequest() below

Arguments:

    None

Returns:

    TRUE on success, FALSE on failure
    updates reqstatus

--*/
{
    return HandleVirtDirRequest( _VIRT_DIR_REQ_ALIAS );
}


BOOL
CInetInfoRequest::HandleVirtDirRequest(
    int iReq )
/*++

Routine Description:

    Handle a virtual root command. can be one of :

    _VIRT_DIR_REQ_ALIAS : create an alias for the matching virtual root
                          by coalescing all alpha-numeric characters
                          from the virtual root physical path

    _VIRT_DIR_REQ_CHECK : check for the existence of the specified
                          virtual root, set reqstatus to HTR_DIR_SAME_NAME
                          if present

Arguments:

    iReq : a _VIRT_DIR_REQ_ command

HTMLA Arguments:

    - Virtual root name ( e.g. "/scripts" )
    - Virtual root IP address or empty string

Returns:

    TRUE on success, FALSE on failure
    updates reqstatus

--*/
{
    BOOL fSt = FALSE;
    LPSTR pV1, pV2;
    BOOL fF1 = FALSE, fF2 = FALSE;

    pV1 = GetVarAsString( 0, &fF1 );
    pV2 = GetVarAsString( 1, &fF2 );

    if ( pV1 != NULL && pV2 != NULL )
    {
        fSt = GetMapper()->HandleVirtDirRequest( pV1, pV2, iReq );
    }

    if ( fF1 )
    {
        delete [] pV1;
    }

    if ( fF2 )
    {
        delete [] pV2;
    }

    return fSt;
}


BOOL
CInetInfoRequest::GenerateDirList(
    VOID )
/*++

Routine Description:

    Generate the vairous lists used by the directory browsing capability
    cf. CDriveView::GenerateDirList()

Arguments:

    None

HTMLA Arguments:

    Path of the root of the directory structure to browse

Returns:

    TRUE if success, otherwise FALSE
    updates reqstatus

--*/
{
    BOOL fSt = FALSE;
    LPSTR pV;
    BOOL fF;

    if ( (pV = GetVarAsString( 0, &fF )) != NULL )
    {
        fSt = GetMapper()->GenerateDirList( pV );
        if ( fF )
        {
            delete [] pV;
        }
    }

    return fSt;
}


BOOL
CInetInfoRequest::Clear(
    VOID )
/*++

Routine Description:

    Clear ( set to 0 ) a numeric HTMLA script variable
    Used to clear variables used in HTML checkboxes, as an
    unchecked box will not be transmitted in the FORM request

Arguments:

    None

HTMLA Arguments:

    HTMLA variable name

Returns:

    TRUE if success, otherwise FALSE
    updates reqstatus

--*/
{
    BOOL fSt = TRUE;

    LPSTR pResult;
    DWORD dwResLen;
    LPVOID pV;


    if ( m_pVerbContext->GetNbInfoMap() > 0 )
    {
        CInetInfoMap *pMap = m_pVerbContext->GetInfoMap(0);
        switch ( pMap->iType )
        {
            case ITYPE_DWORD:
            case ITYPE_SHORTDW:
            case ITYPE_BOOL:
            case ITYPE_1K:
            case ITYPE_1M:
                (GetMapper()->*pMap->GetAddr)( (LPVOID*)&pV );
                *(DWORD*)pV = 0;
                (GetMapper()->*pMap->UpdateIndication)();
                break;

            default:
                GetMapper()->SetRequestStatus( HTR_INVALID_VAR_TYPE );
                fSt = FALSE;
        }
    }
    else
    {
        GetMapper()->SetRequestStatus( HTR_BAD_PARAM );
        fSt = FALSE;
    }

    return fSt;
}


BOOL
CInetInfoRequest::Update(
    VOID )
/*++

Routine Description:

    Scan the request message body as a FORM request
    updating HTMLA variables
    If parsing successfull, calls the RPC layer to updates
    the Web Server status.

Arguments:

    None

HTMLA Arguments:

    None

Returns:

    TRUE if success, otherwise FALSE
    updates reqstatus

--*/
{
    BOOL fSt = TRUE;
    DWORD dwL;
    LPSTR pV = m_pData;     // request body

    for ( ; *pV ; )
    {
        while ( isspace((UCHAR)(*pV)) )
        {
            ++pV;
        }

        LPSTR pE = strchr( pV, '=' );
        BOOL fIsLast = FALSE;
        if ( pE != NULL )
        {
            // find end of value

            LPSTR pN = strchr( pE + 1, '&' );
            if ( pN == NULL )
            {
                if ( (pN = strchr( pE + 1, '\r' )) != NULL )
                {
                    *pN = '\0';
                }
                if ( (pN = strchr( pE + 1, '\n' )) != NULL )
                {
                    *pN = '\0';
                }

                fIsLast = TRUE;
            }
            else
            {
                *pN = '\0';
            }

            //TR_DEBUG( 0, "Update Mapping %s, value %s<p>", pV, pE+1 );

            CInetInfoMap *pMap;
            if ( GetMapper()->Map( (LPBYTE)pV, DIFF(pE-pV), &pMap ) )
            {
                if ( GetMapper()->PutString( pMap, pE + 1 ) == FALSE )
                {
                    GetMapper()->SetRequestStatus( HTR_INVALID_FORM_PARAM );
                    fSt = FALSE;
                    break;
                }
            }

            if ( fIsLast )
            {
                break;
            }
            pV = pN + 1;
        }
        else
        {
            GetMapper()->SetRequestStatus( HTR_INVALID_FORM_PARAM_NAME );
            fSt = FALSE;
            break;
        }
    }

    // if success, call RPC to update server status

    if ( fSt == TRUE )
    {
        PDWORD pdwI;
        if ( GetMapper()->InvalidLogUpdate( (LPVOID*)&pdwI) && *pdwI )
        {
            GetMapper()->SetRequestStatus( HTR_INVALID_FORM_PARAM );
            fSt = FALSE;
        }
        else
        {
            fSt = GetMapper()->Update();
        }
    }

    return fSt;
}


////////////////////// Merger

CInetInfoMerger::CInetInfoMerger(
    VOID )
{
}


CInetInfoMerger::~CInetInfoMerger(
    VOID )
{
}


BOOL
CInetInfoMerger::Init(
    VOID )
{
    return TRUE;
}


CInetInfoMap *
CInetInfoMerger::GetVarMap(
    CInetInfoConfigInfoMapper *pM,
    LPBYTE pVS,
    DWORD dwSize )
/*++

Routine Description:

    Retrieve the variable descriptor from variable name and mapper object

Arguments:

    pM     - pointer to mapper object
    pVS    - variable name
    dwSize - size of variable name

Returns:

    Variable descriptor

--*/
{
    CInetInfoMap *pMap;

    LPBYTE pName = (LPBYTE)memchr( pVS, '%', dwSize );

    if ( pName != NULL )
    {
        CInetInfoMap *pMap;
        if ( pM->Map( pVS, (DWORD)(pName - pVS), &pMap ) )
        {
            return pMap;
        }
    }

    return NULL;
}


LPSTR
CInetInfoMerger::AllocDup(
    CInetInfoConfigInfoMapper *pM,
    LPBYTE pDup,
    DWORD dwL )
/*++

Routine Description:

    Duplicate a memory block using Alloc()

Arguments:

    pM   - mapper object providing the Alloc() function
    pDup - memory block to duplicate
    dwL  - length of emory block to duplicate

Returns:

    Duplicated memory block, zero-terminated, auto-deallocate

--*/
{
    LPSTR pD = (LPSTR)pM->Alloc( dwL + 1 );
    if ( pD == NULL )
    {
        return NULL;
    }
    memcpy( pD, pDup, dwL );
    pD[dwL] = '\0';

    return pD;
}


BOOL
CInetInfoMerger::GetToken(
    LPBYTE pVS,
    DWORD dwSize,
    LPBYTE* pStart,
    DWORD* pdwL )
/*++

Routine Description:

    Scan for token, returning its length

Arguments:

    pVS    - pointer to memory block to scan
    dwSize - length of memory block to scan
    pStart - updated with pointer to start of token
    pdwL   - updated with token length

Returns:

    TRUE if succes, FALSE if failure

--*/
{
    // skip initial spaces

    while ( dwSize && *pVS == ' ' )
    {
        --dwSize;
        ++pVS;
    }

    *pStart = pVS;

    // get length

    LPBYTE pName = (LPBYTE)memchr( pVS, '%', dwSize );
    if ( pName != NULL )
    {
        *pdwL = DIFF(pName - pVS);
        return TRUE;
    }

    return FALSE;
}


BOOL
CInetInfoMerger::Merge(
    CInetInfoRequest* pR )
/*++

Routine Description:

    Merge a template ( .htr ) file with variables as exposed in the
    context of the specified HTMLA request.
    This function opens and closes the file for each request, no caching
    is done. The file is mapped in memory for access.

Arguments:

    pR - HTMLA request object, linked to a mapper object

Returns:

    TRUE if succes, FALSE if failure

--*/
{
    CInetInfoConfigInfoMapper *pM = pR->GetMapper();
    CExtBuff *pB = pR->GetBuffer();
    DWORD dwE;
    BOOL fSt = TRUE;

    // build filename, open file, map

    HANDLE hFile;
    HANDLE hFileMapping;
    PBYTE pF;
    DWORD dwFileSize;
    char achFileName[MAX_PATH+1];
    DWORD dwL;
    int iIsSkip = HSS_NO_SKIP;
    CExpr v1( pM ), v2( pM );
    CRelop r1;
    UINT cNestedIf = 0;
    int aiNestedIf[MAX_NESTED_IF] = { 0 };
    DWORD dwNewStat, dwOldStat = HTR_OK;
    LPSTR pchGoto = NULL;
    LPSTR pchOnError = NULL;
    LPBYTE pStart;
    BOOL fValid;


    if ( pR->GetScr()[1] == ':' )
    {
        // absolute file name, keep as is
        dwL = 0;
    }
    else
    {
        if ( g_fFakeServer )
        {
            strcpy( achFileName, "\\inetsrv\\scripts\\");
            dwL = lstrlen( achFileName );
        }
        else
        {
            if ( (dwL = GetModuleFileName( g_hModule, achFileName, sizeof(achFileName) )) != 0 )
            {
                // back to last directory marker
                char *p = (LPSTR)_mbsrchr((LPBYTE)achFileName, '\\');
                dwL = (p) ? DIFF(p-achFileName)+1 : 0;
            }
        }
    }

    strncpy( achFileName+dwL, pR->GetScr(), sizeof(achFileName) - dwL - 5 );
    achFileName[ sizeof( achFileName ) - 1 ] = '\0';
    if ( strchr( achFileName, '.' ) == NULL )
    {
        strcat( achFileName, ".htr" );
    }

    if ( (hFile = CreateFile( achFileName, GENERIC_READ, FILE_SHARE_READ,
            NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL ))
            != INVALID_HANDLE_VALUE )
    {
        if( (hFileMapping = CreateFileMapping( hFile, NULL, PAGE_READONLY,
                0, 0, NULL )) != NULL )
        {
            dwFileSize = GetFileSize( hFile, NULL );
            if ( dwFileSize != 0xffffffff && (pF = (LPBYTE)MapViewOfFile(
                    hFileMapping, FILE_MAP_READ, 0, 0, 0 )) != NULL )
            {
                LPBYTE pS, pOS, pAfter = pF+dwFileSize;

                // remembered position
                LPBYTE pIterS = NULL;
                DWORD dwIterFileSize;
                DWORD dwIter = 0;

                for ( pOS = pS = pF ; dwFileSize; pOS = pS )
                {
                    // check for error raised ( only once )
                    if ( (dwNewStat = pM->GetRequestStatus()) != dwOldStat )
                    {
                        if ( dwOldStat == HTR_OK && pchOnError != NULL )
                        {
                            iIsSkip |= HSS_SKIP_GOTO;
                            // copy onerror label to goto target label
                            if ( (pchGoto = AllocDup( pM, (LPBYTE)pchOnError,
                                    strlen(pchOnError) )) == NULL )
                            {
                                pR->SetHTTPStatus( HT_BAD_GATEWAY );
                                fSt = FALSE;
                                // can't continue parsing : nested errors
                                break;
                            }
                        }
                        dwOldStat = dwNewStat;
                    }

                    if ( (pS = (LPBYTE)memchr( pOS, '<', (size_t)dwFileSize ))
                            == NULL )
                    {
                        if ( !iIsSkip )
                        {
                            pB->CopyBuff( pOS, dwFileSize );
                        }
                        break;  // end of file
                    }

                    // copy up to ( but not including ) '<'
                    if ( !iIsSkip )
                    {
                        pB->CopyBuff( pOS, DIFF(pS - pOS) );
                    }

                    ++pS;
                    dwFileSize = DIFF(pAfter - pS);

                    if ( dwFileSize && *pS == '%' )
                    {
                        LPBYTE pVS = ++pS;
                        DWORD dwSize = --dwFileSize;

                        // skip to next '>'
                        while ( dwFileSize )
                        {
                            int c = *pS++;
                            --dwFileSize;

                            if ( c == '>' )
                            {
                                break;
                            }
                        }

                        if ( dwSize && *pVS == '!' )
                        {
                            if ( !iIsSkip )
                            {
                                ++pVS;
                                --dwSize;

                                // verb : must build CVerbContext
                                CVerbContext *pVerb = new CVerbContext();
                                if ( pVerb == NULL )
                                {
                                    pR->SetHTTPStatus( HT_BAD_GATEWAY );
                                    fSt = FALSE;
                                    break;
                                }
                                DWORD dwL;
                                if ( dwL = pVerb->Parse( pM, pVS, dwSize ) )
                                {
                                    pR->DoVerb( pVerb );
                                }
                                delete pVerb;
                            }
                        }

                        else if ( dwSize>sizeof(TOKEN_REDIRECT)-1
                                && !memcmp( pVS, TOKEN_REDIRECT,
                                sizeof(TOKEN_REDIRECT)-1) )
                        {
                            if ( !iIsSkip )
                            {
                                pB->Reset();
                            }
                        }

                        else if ( dwSize>sizeof(TOKEN_REDIRECTH)-1
                                && !memcmp( pVS, TOKEN_REDIRECTH,
                                sizeof(TOKEN_REDIRECTH)-1) )
                        {
                            if ( !iIsSkip )
                            {
                                pB->Reset();
                            }
                        }

                        else if ( dwSize>sizeof(TOKEN_END_REDIRECT)-1
                                && !memcmp( pVS, TOKEN_END_REDIRECT,
                                sizeof(TOKEN_END_REDIRECT)-1) )
                        {
                            if ( !iIsSkip )
                            {
                                pB->CopyBuff( (LPBYTE)"", 1 );  // add delimiter
                                pR->SetHTTPStatus( HT_REDIRECT );
                                break;
                            }
                        }

                        else if ( dwSize>sizeof(TOKEN_END_REDIRECTH)-1
                                && !memcmp( pVS, TOKEN_END_REDIRECTH,
                                sizeof(TOKEN_END_REDIRECTH)-1) )
                        {
                            if ( !iIsSkip )
                            {
                                pB->CopyBuff( (LPBYTE)"", 1 );  // add delimiter
                                pR->SetHTTPStatus( HT_REDIRECTH );
                                break;
                            }
                        }

                        else if ( dwSize>sizeof(TOKEN_POST)-1
                                && !memcmp( pVS, TOKEN_POST,
                                sizeof(TOKEN_POST)-1) )
                        {
                            if ( !iIsSkip )
                            {
                                pB->Reset();
                            }
                        }

                        else if ( dwSize>sizeof(TOKEN_END_POST)-1
                                && !memcmp( pVS, TOKEN_END_POST,
                                sizeof(TOKEN_END_POST)-1) )
                        {
                            if ( !iIsSkip )
                            {
                                pR->SetHTTPStatus( HT_REPROCESS );
                                break;
                            }
                        }

                        else if ( dwSize>sizeof(TOKEN_GOTO)-1
                                && !memcmp( pVS, TOKEN_GOTO,
                                sizeof(TOKEN_GOTO)-1) )
                        {
                            if ( !iIsSkip )
                            {
                                pVS += sizeof(TOKEN_GOTO)-1;
                                dwSize -= sizeof(TOKEN_GOTO)-1;
                                // ignore all other skip status
                                // i.e. cancel If, BeginIteration status
                                iIsSkip = HSS_SKIP_GOTO;
                                // store goto target
                                if ( GetToken( pVS, dwSize, &pStart, &dwL ) )
                                {
                                    if ( (pchGoto = AllocDup( pM, pStart,
                                            dwL)) == NULL )
                                    {
                                        pR->SetHTTPStatus( HT_BAD_GATEWAY );
                                        fSt = FALSE;
                                        // can't continue parsing : nested errors
                                        break;
                                    }
                                }
                                else
                                {
                                    pM->SetRequestStatus( HTR_BAD_PARAM );
                                }
                            }
                        }

                        else if ( dwSize>sizeof(TOKEN_LABEL)-1
                                && !memcmp( pVS, TOKEN_LABEL,
                                sizeof(TOKEN_LABEL)-1) )
                        {
                            if ( iIsSkip&HSS_SKIP_GOTO )
                            {
                                pVS += sizeof(TOKEN_LABEL)-1;
                                dwSize -= sizeof(TOKEN_LABEL)-1;
                                if ( GetToken( pVS, dwSize, &pStart, &dwL ) )
                                {
                                    if ( pchGoto && dwL == (DWORD)lstrlen(
                                            pchGoto)
                                            && !memcmp( pStart, pchGoto, dwL ) )
                                    {
                                        iIsSkip &= ~HSS_SKIP_GOTO;
                                    }
                                }
                                else
                                {
                                    pM->SetRequestStatus( HTR_BAD_PARAM );
                                }
                            }
                        }

                        else if ( dwSize>sizeof(TOKEN_ONERROR)-1
                                && !memcmp( pVS, TOKEN_ONERROR,
                                sizeof(TOKEN_ONERROR)-1) )
                        {
                            if ( !iIsSkip )
                            {
                                pVS += sizeof(TOKEN_ONERROR)-1;
                                dwSize -= sizeof(TOKEN_ONERROR)-1;
                                // store onerror target
                                if ( GetToken( pVS, dwSize, &pStart, &dwL ) )
                                {
                                    if ( (pchOnError = AllocDup( pM, pStart,
                                            dwL)) == NULL )
                                    {
                                        pR->SetHTTPStatus( HT_BAD_GATEWAY );
                                        fSt = FALSE;
                                        // can't continue parsing : no onerror target
                                        break;
                                    }
                                }
                                else
                                {
                                    pM->SetRequestStatus( HTR_BAD_PARAM );
                                }
                            }
                        }

                        else if ( dwSize>sizeof(TOKEN_IF)-1
                                && !memcmp( pVS, TOKEN_IF,
                                sizeof(TOKEN_IF)-1) )
                        {
                            if ( cNestedIf == MAX_NESTED_IF-1 )
                            {
                                pM->SetRequestStatus( HTR_TOO_MANY_NESTED_IF );
                                continue;
                            }

                            pVS += sizeof(TOKEN_IF)-1;
                            dwSize -= sizeof(TOKEN_IF)-1;

                            ++cNestedIf;
                            if ( iIsSkip & (HSS_SKIP_IF|HSS_WAIT_ENDIF) )
                            {
                                aiNestedIf[cNestedIf] = HSS_WAIT_ENDIF;
                            }
                            else
                            {
                                aiNestedIf[cNestedIf] = HSS_NO_SKIP;
                                //iIsSkip &= ~HSS_SKIP_IF;
                            }

                            if ( iIsSkip )
                            {
                                continue;
                            }
as_if_token:
                            // get 1st var
                            if ( dwL = v1.Get( pVS, dwSize ) )
                            {
                                pVS += dwL;
                                dwSize -= dwL;
                            }
                            else
                            {
                                pM->SetRequestStatus( HTR_VAR_NOT_FOUND );
                                goto inv_if;
                            }

                            // get relop
                            if ( dwL = r1.Get( pVS, dwSize ) )
                            {
                                pVS += dwL;
                                dwSize -= dwL;
                            }
                            else
                            {
                                pM->SetRequestStatus( HTR_BAD_PARAM );
                                goto inv_if;
                            }

                            // get 2nd var
                            if ( dwL = v2.Get( pVS, dwSize ) )
                            {
                                pVS += dwL;
                                dwSize -= dwL;
                            }
                            else
                            {
                                pM->SetRequestStatus( HTR_VAR_NOT_FOUND );
                                goto inv_if;
                            }

                            if ( !r1.IsTrue( v1, v2, &fValid ) )
                            {
                                if ( !fValid )
                                {
                                    pM->SetRequestStatus( HTR_INVALID_VAR_TYPE );
inv_if:
                                    aiNestedIf[cNestedIf] = HSS_WAIT_ENDIF;
                                    Adjust( &iIsSkip, aiNestedIf[cNestedIf] );
                                }
                                else
                                {
                                    aiNestedIf[cNestedIf] = HSS_SKIP_IF;
                                    Adjust( &iIsSkip, aiNestedIf[cNestedIf] );
                                }
                            }
                        }
                        else if ( dwSize>sizeof(TOKEN_ELSE)-1
                                && !memcmp( pVS, TOKEN_ELSE,
                                sizeof(TOKEN_ELSE)-1) )
                        {
                            if ( aiNestedIf[cNestedIf] == HSS_SKIP_IF )
                            {
                                aiNestedIf[cNestedIf] = HSS_NO_SKIP;
                            }
                            else
                            {
                                aiNestedIf[cNestedIf] = HSS_WAIT_ENDIF;
                            }
                            Adjust( &iIsSkip, aiNestedIf[cNestedIf] );
                        }
                        else if ( dwSize>sizeof(TOKEN_ELIF)-1
                                && !memcmp( pVS, TOKEN_ELIF,
                                sizeof(TOKEN_ELIF)-1) )
                        {
                            if ( aiNestedIf[cNestedIf] == HSS_SKIP_IF )
                            {
                                pVS += sizeof(TOKEN_ELIF)-1;
                                dwSize -= sizeof(TOKEN_ELIF)-1;

                                aiNestedIf[cNestedIf] = HSS_NO_SKIP;
                                Adjust( &iIsSkip, aiNestedIf[cNestedIf] );
                                goto as_if_token;
                            }
                            else
                            {
                                aiNestedIf[cNestedIf] = HSS_WAIT_ENDIF;
                            }
                            Adjust( &iIsSkip, aiNestedIf[cNestedIf] );
                        }
                        else if ( dwSize>sizeof(TOKEN_ENDIF)-1
                                && !memcmp( pVS, TOKEN_ENDIF,
                                sizeof(TOKEN_ENDIF)-1) )
                        {
                            if ( cNestedIf )
                            {
                                --cNestedIf;
                                Adjust( &iIsSkip, aiNestedIf[cNestedIf] );
                            }
                            else
                            {
                                pM->SetRequestStatus( HTR_IF_UNDERFLOW );
                            }
                        }
                        else if ( dwSize>sizeof(TOKEN_BEGIN_ITERATION)-1
                                && !memcmp( pVS, TOKEN_BEGIN_ITERATION,
                                sizeof(TOKEN_BEGIN_ITERATION)-1) )
                        {
                            // get counter
                            dwSize -= sizeof(TOKEN_BEGIN_ITERATION)-1;
                            pVS += sizeof(TOKEN_BEGIN_ITERATION)-1;
                            while ( dwSize && isspace((UCHAR)(*pVS)) )
                            {
                                --dwSize;
                                ++pVS;
                            }
                            CInetInfoMap *pVar = GetVarMap( pM, pVS, dwSize );
                            DWORD *pdwV;
                            if ( pVar != NULL && (pVar->iType == ITYPE_DWORD
                                    || pVar->iType == ITYPE_BOOL) )
                            {
                                (pM->*pVar->GetAddr)( (LPVOID*)&pdwV );
                                dwIter = *pdwV;
                            }
                            else
                            {
                                pM->SetRequestStatus( HTR_VAR_NOT_FOUND );
                                dwIter = 0;
                                continue;
                            }
                            // remember position to loop on enditeration
                            pIterS = pS;
                            dwIterFileSize = dwFileSize;
                            pM->ResetIter();
                            if ( dwIter )
                            {
                                --dwIter;
                            }
                            else
                            {
                                iIsSkip |= HSS_SKIP_ITER;
                            }
                        }
                        else if ( dwSize>sizeof(TOKEN_END_ITERATION)-1
                                && !memcmp( pVS, TOKEN_END_ITERATION,
                                sizeof(TOKEN_END_ITERATION)-1) )
                        {
                            pM->IncIter();
                            if ( dwIter )
                            {
                                --dwIter;
                                pS = pIterS;
                                dwFileSize = dwIterFileSize;
                            }
                            else
                            {
                                iIsSkip &=  ~HSS_SKIP_ITER;
                            }
                        }
                        else if ( !iIsSkip )
                        {
                            // is a variable
                            LPSTR pRes;
                            DWORD dwResLen;
                            BOOL fFree;
                            LPBYTE pAF = (LPBYTE)memchr( pVS, '%', dwSize );
                            if ( pAF && pM->GetString( pVS, DIFF(pAF - pVS),
                                    &pRes, &dwResLen, &fFree ) )
                            {
                                pB->CopyBuff( (LPBYTE)pRes, dwResLen );
                                if ( fFree )
                                {
                                    delete [] pRes;
                                }
                            }
                            else
                            {
                                pM->SetRequestStatus( HTR_VAR_NOT_FOUND );
                                break;
                            }
                        }
                    }
                    else if ( !iIsSkip )
                    {
                        pB->CopyBuff( (LPBYTE)"<", 1 );
                    }
                }

                UnmapViewOfFile( (LPVOID)pF );
            }
            else
            {
                pR->SetHTTPStatus( HT_BAD_GATEWAY );
                fSt = FALSE;
            }

            CloseHandle( hFileMapping );
        }
        else
        {
            pR->SetHTTPStatus( HT_BAD_GATEWAY );
            fSt = FALSE;
        }

        CloseHandle( hFile );
    }
    else
    {
        switch ( GetLastError() )
        {
        case ERROR_FILE_NOT_FOUND :
            pR->SetHTTPStatus( HT_NOT_FOUND );
            break;

        case ERROR_ACCESS_DENIED:
            pR->SetHTTPStatus( HT_DENIED );
            break;

        default:

            pR->SetHTTPStatus( HT_SERVER_ERROR );
            break;
        }

        fSt = FALSE;
    }

    return fSt;
}


////////////// Dispatcher

CInetInfoRequestMap g_aIReqMap[] = {
    { "display", &CInetInfoDispatcher::HandleDisplay, TRUE },   // all displays
} ;


CInetInfoDispatcher::CInetInfoDispatcher(
    VOID )
{
}


CInetInfoDispatcher::~CInetInfoDispatcher(
    VOID )
{
}


// map a service name to a CInetInfoConfigInfoMapper

CInetInfoConfigInfoMapper*
CInetInfoDispatcher::GetMapperFromString(
    LPSTR pszServ )
{
    if ( !strcmp( pszServ, "http" ) )
    {
        return &m_MapperHTTP;
    }
    else if ( !strcmp( pszServ, "ftp" ) )
    {
        return &m_MapperFTP;
    }
    else if ( !strcmp( pszServ, "gopher" ) )
    {
        return &m_MapperGOPHER;
    }
    else if ( !strcmp( pszServ, "dns" ) )
    {
        return &m_MapperDNS;
    }
    else if ( !strcmp( pszServ, "dir" ) )
    {
        return &m_MapperDIR;
    }

    // default is HTTP
    return &m_MapperHTTP;
}


BOOL
CInetInfoDispatcher::HandleDisplay(
    CInetInfoRequest* pR )
{
    BOOL fSt = FALSE;

    // display screen

    fSt = m_IFMerger.Merge( pR );

    return fSt;
}


BOOL
CInetInfoDispatcher::Init(
    VOID )
{
    m_apH = g_aIReqMap;
    m_cH = sizeof(g_aIReqMap)/sizeof(CInetInfoRequestMap);

    // initialize mappers
    m_MapperHTTP.Init( g_InetInfoConfigInfoMap,
            sizeof(g_InetInfoConfigInfoMap)/sizeof(CInetInfoMap),
            INET_HTTP_SVC_ID );
    m_MapperFTP.Init( g_InetInfoConfigInfoMap,
            sizeof(g_InetInfoConfigInfoMap)/sizeof(CInetInfoMap),
            INET_FTP_SVC_ID );
    m_MapperGOPHER.Init( g_InetInfoConfigInfoMap,
            sizeof(g_InetInfoConfigInfoMap)/sizeof(CInetInfoMap),
            INET_GOPHER_SVC_ID );
    m_MapperDNS.Init( g_InetInfoConfigInfoMap,
            sizeof(g_InetInfoConfigInfoMap)/sizeof(CInetInfoMap),
            INET_DNS_SVC_ID );

    m_MapperDIR.Init( g_InetInfoDirInfoMap,
            sizeof(g_InetInfoDirInfoMap)/sizeof(CInetInfoMap),
            INET_DIR );

    // initialize merger
    m_IFMerger.Init();

    return TRUE;
}


DWORD
CInetInfoDispatcher::Invoke(
    EXTENSION_CONTROL_BLOCK *pECB )
/*++

Routine Description:

    Handle an ISAPI request.

Arguments:

    pECB - pointer ISAPI object

Returns:

    ISAPI status

--*/
{
    LPSTR pScr;
    CInetInfoConfigInfoMapper *pIFMapper;
    LPSTR pParam;
    LPSTR p;
    DWORD dwS = HSE_STATUS_ERROR;
    LPSTR pMsgBody = NULL;
    int   cMsgBody = 0;
    LPSTR pQueryString = NULL;

#if 0
    // check authentication

    char achRemoteUser[128];
    DWORD dwRemoteUser = sizeof( achRemoteUser );
    if ( !g_fFakeServer )
    {
        if ( pECB->GetServerVariable( (HCONN)pECB->ConnID,
                "REMOTE_USER", achRemoteUser, &dwRemoteUser ) == FALSE
                || achRemoteUser[0] == '\0' )
        {
            // send back authentication required header
#if defined(GENERATE_AUTH_HEADERS)
            g_AuthReqs.Lock();
            DWORD dwLen;
            LPSTR pszAuthReqs = g_AuthReqs.GetAuthenticationListHeader();
            if ( pszAuthReqs != NULL )
            {
                dwLen = lstrlen( pszAuthReqs );
                pECB->ServerSupportFunction( pECB->ConnID,
                        HSE_REQ_SEND_RESPONSE_HEADER,
                        g_achAccessDenied,
                        &dwLen,
                        (LPDWORD)pszAuthReqs );
            }
            else
            {
#if 0
                dwLen = 0;
                pECB->ServerSupportFunction( pECB->ConnID,
                        HSE_REQ_SEND_RESPONSE_HEADER,
                        "500 Authentication access failed",
                        &dwLen,
                        (LPDWORD)NULL );
#else
            // no authentication method supported by server
            // allow anonymous access ( likely to fail access to RPC,
            // this will set reqstatus and give a chance to the .htr
            // to handle it ).
            g_AuthReqs.UnLock();
            goto allow_in;
#endif
            }
            g_AuthReqs.UnLock();
            dwS = HSE_STATUS_SUCCESS;
#else
            DWORD dwLen = strlen(g_achAccessDeniedBody);
            if ( !pECB->ServerSupportFunction( pECB->ConnID,
                    HSE_REQ_SEND_RESPONSE_HEADER,
                    g_achAccessDenied,
                    &dwLen,
                    (LPDWORD)g_achAccessDeniedBody ) )
            {
                dwS = HSE_STATUS_ERROR;
            }
#endif
            return dwS;
        }
    }
#endif

    if ( pECB->lpszPathTranslated
            && pECB->lpszPathInfo[0]
            && pECB->lpszPathTranslated[0] )
    {
        if ( (pQueryString = new char[sizeof("dir/")
                + strlen( pECB->lpszQueryString ) + 1
                + strlen(pECB->lpszPathTranslated)]) == NULL )
        {
            return HSE_STATUS_ERROR;
        }
        memcpy( pQueryString, "dir/", sizeof("dir/")-1 );
        strcpy( pQueryString + sizeof("dir/")-1, pECB->lpszPathTranslated );
        strcat( pQueryString, "+" );
        strcat( pQueryString, pECB->lpszQueryString );
    }

allow_in:

    if ( (p = strchr( pQueryString ? pQueryString : pECB->lpszQueryString,
                '/' )) != NULL )
    {
        *p = '\0';
        pIFMapper = GetMapperFromString( pQueryString
                ? pQueryString : pECB->lpszQueryString );
        pScr = p + 1;

        // Look for parameter ( exposed as %urlparam% ) after '+'
        if ( (pParam = strchr( pScr, '+' )) != NULL )
        {
            if ( pParam > pScr && pParam[-1] == '%' )
            {
                pParam[-1] = '\0';
            }
            else
            {
                *pParam = '\0';
            }
            ++pParam;
        }
        else
        {
            pParam = "";
        }

        UINT iH = 0;

        CInetInfoRequest  *pR = new CInetInfoRequest( pECB, pIFMapper,
                pScr, pParam );
#if defined(DEBUG_LEVEL)
        g_pReq = pR;
#endif
        BOOL fSt = FALSE;

        if ( pR != NULL && pR->Init( pMsgBody, cMsgBody ) )
        {
            // current methods are all Std
            if ( m_apH[iH].fIsStd )
            {
                // Standard shell : retrieve info inside lock
                pIFMapper->Lock();
                pIFMapper->SetRequestStatus( HTR_OK );
                pIFMapper->SetURLParam( pParam );
                pIFMapper->SetReqParam( pR->GetData(), pR, pR->GetDataRaw() );
                pIFMapper->GetCurrentConfig();
                if ( pIFMapper->GetRPCStatus() == ERROR_ACCESS_DENIED )
                {
                    pR->SetHTTPStatus( HT_DENIED );
                    fSt = TRUE;
                }
                else
                {
                    fSt = (this->*m_apH[iH].pHandler)( pR );
                }
                pIFMapper->FreeInfo();
                pIFMapper->UnLock();
            }
            else
            {
                fSt = (this->*m_apH[iH].pHandler)( pR );
            }

            //
            // Always send back the response to the client
            //
            DWORD dwStatus = pR->Done();

            dwS = fSt ? dwStatus : HSE_STATUS_ERROR;

            if ( pMsgBody )
            {
                delete [] pMsgBody;
            }

            if ( pQueryString )
            {
                delete [] pQueryString;
            }

            if ( dwS == HSE_REPROCESS )
            {
                // store msg body, query string
                LPSTR pB = (LPSTR)pR->GetBuffer()->GetPtr();
                LPSTR pD = strchr( pB ? pB : "", '?' );
                if ( pD != NULL )
                {
                    cMsgBody = pR->GetBuffer()->GetLen() - DIFF( pD - pB ) - 1;
                    pQueryString = new char[ DIFF(pD - pB) + 1 ];
                    pMsgBody = new char[ cMsgBody + 1];
                    if ( pQueryString == NULL || pMsgBody == NULL )
                        goto no_rep;
                    DelimStrcpyN( pQueryString, pB, DIFF(pD - pB) );
                    DelimStrcpyN( pMsgBody, pB + ( pD - pB ) + 1, cMsgBody++ );
                }
            }
            else
            {
no_rep:
                pMsgBody = NULL;
                cMsgBody = 0;
                pQueryString = NULL;
            }
        }
        else
        {
            DWORD dwLen = 0;
            pECB->ServerSupportFunction( pECB->ConnID,
                    HSE_REQ_SEND_RESPONSE_HEADER,
                    g_achInternalError,
                    &dwLen,
                    NULL );
            dwS = HSE_STATUS_SUCCESS;
        }
        if ( pR != NULL )
        {
            delete pR;
        }
    }

    if ( dwS == HSE_REPROCESS )
    {
        goto allow_in;
    }

    return dwS;
}


///////////// CExpr, CRelop

// Get an expr, returns length of relop token or 0 if error
// expr can be either a var reference or an unsigned numeric literal

DWORD
CExpr::Get(
    LPBYTE pS,
    DWORD dwL )
/*++

Routine Description:

    Parse memory block for expression
    expression can one of :
    - variable name
    - numeric literal
    - string literal ( inside "" )

Arguments:

    pS  - memory block to parse
    dwL - size of memory block to parse

Returns:

    # of bytes consumed to parse the expression or 0 if error

--*/
{
    DWORD dwW = dwL;
    int c;

    // check if this object is re-used from previous call
    if ( m_fMustFree )
    {
        delete [] m_pV;
        m_fMustFree = FALSE;
    }

    // skip white space
    while ( dwL && *pS == ' ' )
    {
        ++pS;
        --dwL;
    }

    LPBYTE pW = pS;
    DWORD dwLenTok = 0;
    DWORD dwRes;

    // get until '%', ' '
    while ( dwL && (c=*pS)!='%' && c!=' ' )
    {
        ++dwLenTok;
        ++pS;
        --dwL;
    }

    if ( dwLenTok )
    {
        if ( *pW>='0' && *pW<='9' )
        {
            // litteral num
            m_dwV = MultiByteToDWORD( (LPSTR)pW );
            m_iType = ITYPE_DWORD;
            return dwW - dwL;
        }
        else if ( *pW == '"' )
        {
            // String literal

            m_pV = new char[ dwLenTok - 1 ];
            if ( m_pV != NULL )
            {
                memcpy( m_pV, pW + 1, dwLenTok - 2 );
                m_pV[ dwLenTok - 2 ] = '\0';
                m_iType = ITYPE_LPSTR;
                m_fMustFree = TRUE;
                return dwW - dwL;
            }
        }
        else
        {
            CInetInfoMap* pMap;
            if ( m_pMap->Map( pW, dwLenTok, &pMap ) )
            {
                if ( pMap->iType == ITYPE_BOOL
                        || pMap->iType == ITYPE_DWORD
                        || pMap->iType == ITYPE_SHORT
                        || pMap->iType == ITYPE_SHORTDW )
                {
                    LPVOID pV;
                    if ( (m_pMap->*pMap->GetAddr)( (LPVOID*)&pV ) )
                    {
                        m_dwV = pMap->iType == ITYPE_SHORT
                                ? (DWORD)*(unsigned short*)pV : *(DWORD*)pV;
                        m_iType = ITYPE_DWORD;
                        return dwW - dwL;
                    }
                }
                else if ( m_pMap->GetString( pMap,
                        &m_pV, &dwLenTok, &m_fMustFree ) )
                {
                    m_iType = ITYPE_LPSTR;
                    return dwW - dwL;
                }
            }
            else if ( m_pMap->GetString( pW, dwLenTok,
                    &m_pV, &dwRes, &m_fMustFree ) )
            {
                m_iType = ITYPE_LPSTR;
                return dwW - dwL;
            }
        }
    }

    return 0;       // error
}


DWORD
CExpr::GetAsDWORD(
    )
/*++

Routine Description:

    Returns content as a DWORD, converting from string to DWORD
    if type is LPSR

Arguments:

    None

Returns:

    Value of object

--*/
{
    if ( m_iType == ITYPE_DWORD )
    {
        return m_dwV;
    }
    else if ( m_iType == ITYPE_LPSTR )
    {
        return MultiByteToDWORD( m_pV );
    }
    else
    {
        return 0;
    }
}


// relop list. Must be in sync with the RELOP_TYPE enum type.

LPSTR RELOP_TOKS[] = {
    "~~",   // invalid, not used
    "EQ",
    "NE",
    "GT",
    "LT",
    "GE",
    "LE",
    "RF",
    "BA",
} ;


DWORD
CRelop::Get(
    LPBYTE pS,
    DWORD dwL )
/*++

Routine Description:

    Parse memory block for relational operator
    as defined in RELOP_TOKS

Arguments:

    pS  - memory block to parse
    dwL - size of memory block to parse

Returns:

    # of bytes consumed to parse the operator or 0 if error

--*/
{
    DWORD dwW = dwL;
    UINT c;

    // skip white space
    while ( dwL && *pS == ' ' )
    {
        ++pS;
        --dwL;
    }

    LPBYTE pW = pS;
    DWORD dwLenTok = 0;

    // get until '%', ' '
    while ( dwL && (c=*pS)!='%' && c!=' ' )
    {
        ++dwLenTok;
        ++pS;
        --dwL;
    }

    if ( dwLenTok == 2 )
    {
        int x;
        for ( x = 1 ; x < sizeof(RELOP_TOKS)/sizeof(LPSTR) ; ++x )
        {
            if ( !memcmp( RELOP_TOKS[x], pW, 2 ) )
            {
                m_iType = (RELOP_TYPE)x;
                return dwW - dwL;
            }
        }
    }

    return 0;       // error
}


// return TRUE if v1 RELOP v2 is TRUE
// handle only LPSTR and DWORD types

BOOL
CRelop::IsTrue(
    CExpr& v1,
    CExpr& v2,
    BOOL *pfValid )
/*++

Routine Description:

    Test the specified expressions with the current relational operator

Arguments:

    v1 - left expression
    v2 - right expression
    pfValid - updated with FALSE is expression is invalid, else TRUE

Returns:

    TRUE if v1 relop v2 is TRUE, otherwise FALSE

--*/
{
    int iC;
    DWORD num1, num2;

    *pfValid = TRUE;

    if ( v1.GetType() != v2.GetType() )
    {
        if ( (v1.GetType() == ITYPE_DWORD && v2.GetType() == ITYPE_LPSTR)
            || (v1.GetType() == ITYPE_LPSTR && v2.GetType() == ITYPE_DWORD) )
        {
            goto as_dword;
        }
        *pfValid = FALSE;
        return FALSE;
    }
    else if ( v1.GetType() == ITYPE_DWORD )
    {
as_dword:
        iC = (v1.GetAsDWORD() < v2.GetAsDWORD()) ? -1
                : ((v1.GetAsDWORD() == v2.GetAsDWORD()) ? 0 : 1);
    }
    else if ( v1.GetType() == ITYPE_LPSTR )
    {
        if ( m_iType != RELOP_RF )
        {
            iC = lstrcmp( v1.GetAsStr(), v2.GetAsStr() );
        }
    }
    else
    {
        iC = 0;
    }

    BOOL fR;
    LPSTR pV;
    LPSTR p2;
    DWORD dwL2;

    switch ( m_iType )
    {
        case RELOP_EQ: fR = iC == 0; break;
        case RELOP_NE: fR = iC != 0; break;
        case RELOP_GT: fR = iC > 0; break;
        case RELOP_LT: fR = iC < 0; break;
        case RELOP_GE: fR = iC >= 0; break;
        case RELOP_LE: fR = iC <= 0; break;

        case RELOP_BA: fR = !!(v1.GetAsDWORD() & v2.GetAsDWORD());
            break;

        case RELOP_RF:
            fR = FALSE;

            if ( v1.GetType() == ITYPE_LPSTR )
            {
                // parse v1 for v2
                pV = v1.GetAsStr();
                p2 = v2.GetAsStr();
                dwL2 = lstrlen( p2 );

                for ( ; *pV ; )
                {
                    while ( isspace((UCHAR)(*pV)) )
                    {
                        ++pV;
                    }

                    LPSTR pE = strchr( pV, '=' );
                    BOOL fIsLast = FALSE;
                    if ( pE != NULL )
                    {
                        LPSTR pN = strchr( pE + 1, '&' );
                        if ( pN == NULL )
                        {
                            fIsLast = TRUE;
                        }

                        //TR_DEBUG( 0, "Update Mapping %s, value %s<p>", pV, pE+1 );

                        if ( (DWORD)(pE-pV) == dwL2
                                && !memcmp( pV, p2, DIFF(pE-pV) ) )
                        {
                            fR = TRUE;
                            break;
                        }

                        if ( fIsLast )
                        {
                            break;
                        }

                        pV = pN + 1;
                    }
                    else
                    {
                        break;
                    }
                }
            }
            break;

        default: fR = FALSE; break;
    }

    return fR;
}


/////////////

CInetInfoDispatcher g_InetInfoDispatcher;

/////////////


// version information

extern "C" BOOL WINAPI
GetExtensionVersion(
    HSE_VERSION_INFO *version
    )
/*++

Routine Description:

    ISAPI function : called once to return version #

Arguments:

    version - updated with version #

Returns:

    TRUE if initialization success, else FALSE

--*/
{
    version->dwExtensionVersion
            = MAKELONG(HSE_VERSION_MINOR, HSE_VERSION_MAJOR);

    strcpy(version->lpszExtensionDesc, "ism.dll v1.0");

    if ( !g_InitDone )
    {
        g_InetInfoDispatcher.Init();
#if defined(GENERATE_AUTH_HEADERS)
        g_AuthReqs.Init();
#endif
        // initialize host name

        char hn[MAX_DOMAIN_LENGTH + 1];
        struct hostent FAR* pH;
        if ( !gethostname( hn, sizeof(hn) )
                && (pH = gethostbyname( hn ))
                && pH->h_name
                && pH->h_addr_list
                && pH->h_addr_list[0]
                )
        {
            g_pszDefaultHostName = new char[strlen( pH->h_name ) + 1];
            if ( g_pszDefaultHostName == NULL )
            {
                return FALSE;
            }
            strcpy( g_pszDefaultHostName, pH->h_name );
        }

        // initialize htmla path

        HKEY hK;
        BOOL fDef = TRUE;
        if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                W3SVC_REGISTRY_PATH,
                0,
                KEY_READ,
                &hK ) == ERROR_SUCCESS )
        {
            DWORD dwType;
            DWORD cData = sizeof( g_achHtmlaPath );
            if ( RegQueryValueEx( hK, W3SVC_REGISTRY_HTMLAPATH,
                    NULL, &dwType, (PBYTE)g_achHtmlaPath, &cData )
                    == ERROR_SUCCESS && dwType == REG_SZ  )
            {
                fDef = FALSE;
            }
            RegCloseKey( hK );
        }
        if ( fDef )
        {
            strcpy( g_achHtmlaPath, "/htmla" );
        }

        //
        // init strings from resources
        //

        if ( LoadString( g_hModule,
                         IDS_HTRESPX_DENIED,
                         g_achAccessDenied,
                         sizeof( g_achAccessDenied ) ) == 0 )
        {
            strcpy( g_achAccessDenied, "401" );
        }

        if ( LoadString( g_hModule,
                         IDS_HTRESPX_DENIED_BODY,
                         g_achAccessDeniedBody,
                         sizeof( g_achAccessDeniedBody ) ) == 0 )
        {
            strcpy( g_achAccessDeniedBody, "<html>Error: access denied</html>" );
        }

        if ( LoadString( g_hModule,
                         IDS_HTRESPX_SERVER_ERROR,
                         g_achInternalError,
                         sizeof( g_achInternalError ) ) == 0 )
        {
            strcpy( g_achInternalError, "500" );
        }

        if ( LoadString( g_hModule,
                         IDS_HTRESPX_NOT_FOUND,
                         g_achNotFound,
                         sizeof( g_achNotFound ) ) == 0 )
        {
            strcpy( g_achNotFound, "404" );
        }

        if ( LoadString( g_hModule,
                         IDS_HTRESPX_NOT_FOUND_BODY,
                         g_achNotFoundBody,
                         sizeof( g_achNotFoundBody ) ) == 0 )
        {
            strcpy( g_achNotFoundBody,
                    "<html>Error : The requested file could not be found.</html>" );
        }

        for ( int x = 0 ;
            x < sizeof(g_aStatus)/sizeof(CStatusStringAndCode) ;
            ++x )
        {
            if ( LoadString( g_hModule,
                             g_aStatus[x].dwID,
                             g_aStatus[x].achStatus,
                             sizeof( g_aStatus[x].achStatus ) ) == 0 )
            {
                wsprintf( g_aStatus[x].achStatus,
                        "%d",
                        g_aStatus[x].dwStatus );
            }
        }

        g_InitDone = TRUE;
    }

    return TRUE;
}


extern "C"  DWORD WINAPI
HttpExtensionProc(
    EXTENSION_CONTROL_BLOCK* pEcb
    )
/*++

Routine Description:

    ISAPI function : called for each incoming HTTP request

Arguments:

    pEcb - pointer to ISAPI request object

Returns:

    ISAPI status

--*/
{
    return g_InetInfoDispatcher.Invoke( pEcb );
}


extern "C" BOOL WINAPI
DllMain(
    HANDLE hModule,
    DWORD dwReason,
    LPVOID )
/*++

Routine Description:

    DLL init/terminate notification function

Arguments:

    hModule  - DLL handle
    dwReason - notification type
    LPVOID   - not used

Returns:

    TRUE if success, FALSE if failure

--*/
{
    switch ( dwReason )
    {
        case DLL_PROCESS_ATTACH:
            // record the module handle to access module info later
            g_hModule = (HINSTANCE)hModule;
            if ( g_hLonsi = LoadLibrary("lonsint.dll") )
            {
                g_pfnGetDefaultDomainName = (GET_DEFAULT_DOMAIN_NAME_FN)
                            GetProcAddress( g_hLonsi, "IISGetDefaultDomainName" );
            }
            break;

        case DLL_PROCESS_DETACH:
#if defined(GENERATE_AUTH_HEADERS)
            g_AuthReqs.Terminate();
#endif
            if ( g_hLonsi )
            {
                g_pfnGetDefaultDomainName = NULL;
                FreeLibrary( g_hLonsi );
                g_hLonsi = NULL;
            }
            break;
    }

    return TRUE;
}


// Test shell. To be used to simulate a BGI call using a console app.

BYTE achTest[]="rootdir=c:\\inetsrv&rootishome=0&rootname=/w&rootacctname=&rootacctpw=&rootaddr=&rootisread=1";

void __declspec( dllexport )
Test(
    VOID )
{
    HSE_VERSION_INFO hv;
    EXTENSION_CONTROL_BLOCK Ecb;

    Ecb.cbTotalBytes = sizeof(achTest);
    Ecb.cbAvailable = sizeof(achTest);
    Ecb.lpbData = achTest;
    //Ecb.lpszQueryString = "http/w3/advdeny+/-c:\\inetsrv\\wwwroot";
    Ecb.lpszQueryString = "http/w3/serv+/syuyr!/ttt";
    printf( "Nb Handler : %d\n", g_InetInfoDispatcher.GetNbH() );

    GetExtensionVersion( &hv );
    g_fFakeServer = TRUE;
    HttpExtensionProc( &Ecb );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\addscrip.h ===
// addscrip.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CAddScript dialog

class CAddScript : public CDialog
{
// Construction
public:
	CAddScript(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CAddScript)
	enum { IDD = IDD_ADDSCRIPTDIALOG };
	CString	m_strFileExtension;
	CString	m_strScriptMap;
	//}}AFX_DATA

	LPCTSTR GetFileExtension();
	LPCTSTR GetScriptMap();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAddScript)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAddScript)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\compsdef.h ===
// Common Per Service Entry Defines

#ifndef		_Common_Per_Service_Defines
#define		_Common_Per_Service_Defines

#define ENABLESVCLOCNAME		"EnableSvcLoc"
#define DEFAULTENABLESVCLOC		TRUEVALUE

#define LOGANONYMOUSNAME		"LogAnonymous"
#define DEFAULTLOGANONYMOUS		TRUEVALUE

#define LOGNONANONYMOUSNAME		"LogNonAnonymous"
#define DEFAULTLOGNONANONYMOUS	TRUEVALUE

#define CHECKFORWAISDBNAME		"CheckForWAISDB"
#define DEFAULTCHECKFORWAISDB	TRUEVALUE

#define DEBUGFLAGSNAME	"DebugFlags"
#define DEFAULTDEBUGFLAGS	0

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\delmime.cpp ===
// delmime.cpp : implementation file
//

#include "stdafx.h"
#include "ISAdmin.h"
#include "delmime.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDelMime dialog


CDelMime::CDelMime(CWnd* pParent /*=NULL*/)
	: CDialog(CDelMime::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDelMime)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CDelMime::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDelMime)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDelMime, CDialog)
	//{{AFX_MSG_MAP(CDelMime)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CDelMime message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\compage1.cpp ===
// compage1.cpp : implementation file
//

#include "stdafx.h"
#include "afxcmn.h"
#include "ISAdmin.h"
#include "compage1.h"
#include "registry.h"
#include "genpage.h"
#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCOMPAGE1 property page				  

IMPLEMENT_DYNCREATE(CCOMPAGE1, CGenPage)

CCOMPAGE1::CCOMPAGE1() : CGenPage(CCOMPAGE1::IDD)
{


	//{{AFX_DATA_INIT(CCOMPAGE1)
	//}}AFX_DATA_INIT

}

CCOMPAGE1::~CCOMPAGE1()
{
}

void CCOMPAGE1::DoDataExchange(CDataExchange* pDX)
{
	CGenPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCOMPAGE1)
	DDX_Control(pDX, IDC_LISTENBACKLOGSPIN1, m_spinListenBacklog);
	DDX_Control(pDX, IDC_LOGBATSPIN1, m_spinLogBatSpin1);
	DDX_Control(pDX, IDC_CACHESPIN1, m_spinCacheSpin1);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCOMPAGE1, CGenPage)
	//{{AFX_MSG_MAP(CCOMPAGE1)
	ON_EN_CHANGE(IDC_CACHEDATA1, OnChangeCachedata1)
	ON_EN_CHANGE(IDC_LOGBATDATA1, OnChangeLogbatdata1)
	ON_EN_CHANGE(IDC_LISTENBACKLOGDATA1, OnChangeListenbacklogdata1)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CCOMPAGE1 message handlers



BOOL CCOMPAGE1::OnInitDialog() 
{
	int i;

	CGenPage::OnInitDialog();
	
	// TODO: Add extra initialization here

	
	for (i = 0; i < ComPage_TotalNumRegEntries; i++) {
	   m_binNumericRegistryEntries[i].bIsChanged = FALSE;
	   m_binNumericRegistryEntries[i].ulMultipleFactor = 1;
	   }

	m_binNumericRegistryEntries[ComPage_LogBat].strFieldName = _T(LOGBATNAME);	
	m_binNumericRegistryEntries[ComPage_LogBat].ulMultipleFactor = 1024;
	m_binNumericRegistryEntries[ComPage_LogBat].ulDefaultValue = DEFAULTLOGFILEBATCHSIZE;

	m_binNumericRegistryEntries[ComPage_MemCache].strFieldName = _T(MEMORYCACHENAME);
	m_binNumericRegistryEntries[ComPage_MemCache].ulMultipleFactor = 1024 * 1024;
	m_binNumericRegistryEntries[ComPage_MemCache].ulDefaultValue = DEFAULTMEMORYCACHESIZE;

	m_binNumericRegistryEntries[ComPage_ListenBacklog].strFieldName = _T(LISTENBACKLOGNAME);
	m_binNumericRegistryEntries[ComPage_ListenBacklog].ulDefaultValue = DEFAULTLISTENBACKLOG;

	for (i = 0; i < ComPage_TotalNumRegEntries; i++) {
	   if (m_rkMainKey->QueryValue(m_binNumericRegistryEntries[i].strFieldName, 
	      m_binNumericRegistryEntries[i].ulFieldValue) != ERROR_SUCCESS) {
		  m_binNumericRegistryEntries[i].ulFieldValue = m_binNumericRegistryEntries[i].ulDefaultValue;
	   }
	}
  
	m_spinLogBatSpin1.SetRange(MINLOGFILEBATCHSIZE, MAXLOGFILEBATCHSIZE);
	m_spinLogBatSpin1.SetPos(LESSOROF((m_binNumericRegistryEntries[ComPage_LogBat].ulFieldValue / 
	   m_binNumericRegistryEntries[ComPage_LogBat].ulMultipleFactor), MAXLOGFILEBATCHSIZE));
	m_spinCacheSpin1.SetRange(MINMEMORYCACHESIZE, MAXMEMORYCACHESIZE);
	m_spinCacheSpin1.SetPos(LESSOROF((m_binNumericRegistryEntries[ComPage_MemCache].ulFieldValue / 
	   m_binNumericRegistryEntries[ComPage_MemCache].ulMultipleFactor), MAXMEMORYCACHESIZE));
	m_spinListenBacklog.SetRange(MINLISTENBACKLOG, MAXLISTENBACKLOG);
	m_spinListenBacklog.SetPos(LESSOROF((m_binNumericRegistryEntries[ComPage_ListenBacklog].ulFieldValue / 
	   m_binNumericRegistryEntries[ComPage_ListenBacklog].ulMultipleFactor), MAXLISTENBACKLOG));
  
	m_bSetChanged = TRUE;	// Any more changes come from the user

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void CCOMPAGE1::OnChangeCachedata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[ComPage_MemCache].bIsChanged = TRUE;	
	   m_binNumericRegistryEntries[ComPage_MemCache].ulFieldValue = m_spinCacheSpin1.GetPos() 
	      * m_binNumericRegistryEntries[ComPage_MemCache].ulMultipleFactor;		

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
}

void CCOMPAGE1::OnChangeLogbatdata1() 
{				
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[ComPage_LogBat].bIsChanged = TRUE;
	   m_binNumericRegistryEntries[ComPage_LogBat].ulFieldValue = m_spinLogBatSpin1.GetPos() * 
	      m_binNumericRegistryEntries[ComPage_LogBat].ulMultipleFactor;		
	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
}

void CCOMPAGE1::OnChangeListenbacklogdata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[ComPage_ListenBacklog].bIsChanged = TRUE;	
	   m_binNumericRegistryEntries[ComPage_ListenBacklog].ulFieldValue = m_spinListenBacklog.GetPos() 
	      * m_binNumericRegistryEntries[ComPage_ListenBacklog].ulMultipleFactor;		

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
	
}

void CCOMPAGE1::SaveInfo()
{

if (m_bIsDirty) {
SaveNumericInfo(m_binNumericRegistryEntries, ComPage_TotalNumRegEntries);
}

CGenPage::SaveInfo();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\delscrip.cpp ===
// delscrip.cpp : implementation file
//

#include "stdafx.h"
#include "ISAdmin.h"
#include "delscrip.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDelScript dialog


CDelScript::CDelScript(CWnd* pParent /*=NULL*/)
	: CDialog(CDelScript::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDelScript)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}


void CDelScript::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDelScript)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDelScript, CDialog)
	//{{AFX_MSG_MAP(CDelScript)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CDelScript message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\compage1.h ===
// compage1.h : header file
//

//Common Page

#define LOGBATNAME	"LogFileBatchSize"
#define MINLOGFILEBATCHSIZE	0
#define MAXLOGFILEBATCHSIZE	0x7FFF							//Specify in KB
#define DEFAULTLOGFILEBATCHSIZE	(64 * 1024)

#define MEMORYCACHENAME	"MemoryCacheSize"
#define MINMEMORYCACHESIZE	0
#define MAXMEMORYCACHESIZE	(0xFFFFFFFF / (1024 * 1024))	//Specify in MB
#define DEFAULTMEMORYCACHESIZE	(3 * 1024 * 1024)

#define LISTENBACKLOGNAME	"ListenBacklog"
#define MINLISTENBACKLOG	0
#define MAXLISTENBACKLOG	0x7fff
#define DEFAULTLISTENBACKLOG	15

enum  COMMON_NUM_REG_ENTRIES {
     ComPage_LogBat,
	 ComPage_MemCache,
	 ComPage_ListenBacklog,
	 ComPage_TotalNumRegEntries
	 };

/////////////////////////////////////////////////////////////////////////////
// CCOMPAGE1 dialog

class CCOMPAGE1 : public CGenPage
{
	DECLARE_DYNCREATE(CCOMPAGE1)

// Construction
public:
	CCOMPAGE1();
	~CCOMPAGE1();

// Dialog Data
	//{{AFX_DATA(CCOMPAGE1)
	enum { IDD = IDD_COMPAGE1 };
	CSpinButtonCtrl	m_spinListenBacklog;
	CSpinButtonCtrl	m_spinLogBatSpin1;
	CSpinButtonCtrl	m_spinCacheSpin1;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CCOMPAGE1)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual	void SaveInfo(void);

	//}}AFX_VIRTUAL


// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CCOMPAGE1)
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeCachedata1();
	afx_msg void OnChangeLogbatdata1();
	afx_msg void OnChangeListenbacklogdata1();
	//}}AFX_MSG
	
	NUM_REG_ENTRY m_binNumericRegistryEntries[ComPage_TotalNumRegEntries];


	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\delmime.h ===
// delmime.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDelMime dialog

class CDelMime : public CDialog
{
// Construction
public:
	CDelMime(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDelMime)
	enum { IDD = IDD_DELMIMEDIALOG };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDelMime)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDelMime)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\dlgdata.cpp ===
// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992 Microsoft Corporation
// All rights reserved.

// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "stdafx.h"
#include "afximpl.h"
#include "afxpriv.h"
#ifdef AFX_CORE3_SEG
#pragma code_seg(AFX_CORE3_SEG)
#endif

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDataExchange member functions (contructor is in wincore.cpp for swap tuning)

HWND CDataExchange::PrepareEditCtrl(int nIDC)
{
	HWND hWndCtrl = PrepareCtrl(nIDC);
	ASSERT(hWndCtrl != NULL);
	m_bEditLastControl = TRUE;
	return hWndCtrl;
}

HWND CDataExchange::PrepareCtrl(int nIDC)
{
	ASSERT(nIDC != 0);
	ASSERT(nIDC != -1); // not allowed
	HWND hWndCtrl = ::GetDlgItem(m_pDlgWnd->m_hWnd, nIDC);
	if (hWndCtrl == NULL)
	{
		TRACE1("Error: no data exchange control with ID 0x%04X.\n", nIDC);
		ASSERT(FALSE);
		AfxThrowNotSupportedException();
	}
	m_hWndLastControl = hWndCtrl;
	m_bEditLastControl = FALSE; // not an edit item by default
	ASSERT(hWndCtrl != NULL);   // never return NULL handle
	return hWndCtrl;
}

void CDataExchange::Fail()
{
	if (!m_bSaveAndValidate)
	{
		TRACE0("Warning: CDataExchange::Fail called when not validating.\n");
		// throw the exception anyway
	}
	else if (m_hWndLastControl != NULL)
	{
		// restore focus and selection to offending field
		::SetFocus(m_hWndLastControl);
		if (m_bEditLastControl) // select edit item
			::SendMessage(m_hWndLastControl, EM_SETSEL, 0, -1);
	}
	else
	{
		TRACE0("Error: fail validation with no control to restore focus to.\n");
		// do nothing more
	}

	AfxThrowUserException();
}

/////////////////////////////////////////////////////////////////////////////
// Notes for implementing dialog data exchange and validation procs:
//  * always start with PrepareCtrl or PrepareEditCtrl
//  * always start with 'pDX->m_bSaveAndValidate' check
//  * pDX->Fail() will throw an exception - so be prepared
//  * avoid creating temporary HWNDs for dialog controls - i.e.
//      use HWNDs for child elements
//  * validation procs should only act if 'm_bSaveAndValidate'
//  * use the suffices:
//      DDX_ = exchange proc
//      DDV_ = validation proc
//
/////////////////////////////////////////////////////////////////////////////

// only supports '%d', '%u', '%ld' and '%lu'
static BOOL AFXAPI AfxSimpleScanf(LPCTSTR lpszText,
	LPCTSTR lpszFormat, va_list pData)
{
	ASSERT(lpszText != NULL);
	ASSERT(lpszFormat != NULL);

	ASSERT(*lpszFormat == '%');
	lpszFormat++;        // skip '%'

	BOOL bLong = FALSE;
	if (*lpszFormat == 'l')
	{
		bLong = TRUE;
		lpszFormat++;
	}

	ASSERT(*lpszFormat == 'd' || *lpszFormat == 'u' || *lpszFormat == 'x');
	ASSERT(lpszFormat[1] == '\0');

	while (*lpszText == ' ' || *lpszText == '\t')
		lpszText++;
	TCHAR chFirst = lpszText[0];
	long l, l2;
	if (*lpszFormat == 'd')
	{
		// signed
		l = _tcstol(lpszText, (LPTSTR*)&lpszText, 10);
		l2 = (int)l;
	}
	else
	if (*lpszFormat == 'u')
	{
		// unsigned
		l = (long)_tcstoul(lpszText, (LPTSTR*)&lpszText, 10);
		l2 = (unsigned int)l;
	}
	else
	{
		// hex
		l = (long)_tcstoul(lpszText, (LPTSTR*)&lpszText, 16);
		l2 = (unsigned int)l;
	}
	if (l == 0 && chFirst != '0')
		return FALSE;   // could not convert

	while (*lpszText == ' ' || *lpszText == '\t')
		lpszText++;
	if (*lpszText != '\0')
		return FALSE;   // not terminated properly

	if (bLong)
		*va_arg(pData, long*) = l;
	else if (l == l2)
		*va_arg(pData, int*) = (int)l;
	else
		return FALSE;       // too big for int

	// all ok
	return TRUE;
}

static void DDX_TextWithFormat(CDataExchange* pDX, int nIDC,
	LPCTSTR lpszFormat, UINT nIDPrompt, ...)

	// only supports windows output formats - no floating point
{
	va_list pData;
	va_start(pData, nIDPrompt);

	HWND hWndCtrl = pDX->PrepareEditCtrl(nIDC);
	TCHAR szT[32];
	if (pDX->m_bSaveAndValidate)
	{
		// the following works for %d, %u, %ld, %lu
		::GetWindowText(hWndCtrl, szT, _countof(szT));
		if (!AfxSimpleScanf(szT, lpszFormat, pData))
		{
			AfxMessageBox(nIDPrompt);
			pDX->Fail();        // throws exception
		}
	}
	else
	{
		wvsprintf(szT, lpszFormat, pData);
			// does not support floating point numbers - see dlgfloat.cpp
		AfxSetWindowText(hWndCtrl, szT);
	}

	va_end(pData);
}
/////////////////////////////////////////////////////////////////////////////
// Simple formatting to text item
/*
void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, BYTE& value)
{
	int n = (int)value;
	if (pDX->m_bSaveAndValidate)
	{
		DDX_TextWithFormat(pDX, nIDC, _T("%u"), AFX_IDP_PARSE_BYTE, &n);
		if (n > 255)
		{
			AfxMessageBox(AFX_IDP_PARSE_BYTE);
			pDX->Fail();        // throws exception
		}
		value = (BYTE)n;
	}
	else
		DDX_TextWithFormat(pDX, nIDC, _T("%u"), AFX_IDP_PARSE_BYTE, n);
}

void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, int& value)
{
	if (pDX->m_bSaveAndValidate)
		DDX_TextWithFormat(pDX, nIDC, _T("%d"), AFX_IDP_PARSE_INT, &value);
	else
		DDX_TextWithFormat(pDX, nIDC, _T("%d"), AFX_IDP_PARSE_INT, value);
}

void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, UINT& value)
{
	if (pDX->m_bSaveAndValidate)
		DDX_TextWithFormat(pDX, nIDC, _T("%u"), AFX_IDP_PARSE_UINT, &value);
	else
		DDX_TextWithFormat(pDX, nIDC, _T("%u"), AFX_IDP_PARSE_UINT, value);
}

void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, long& value)
{
	if (pDX->m_bSaveAndValidate)
		DDX_TextWithFormat(pDX, nIDC, _T("%ld"), AFX_IDP_PARSE_INT, &value);
	else
		DDX_TextWithFormat(pDX, nIDC, _T("%ld"), AFX_IDP_PARSE_INT, value);
}

void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, DWORD& value)
{
	if (pDX->m_bSaveAndValidate)
		DDX_TextWithFormat(pDX, nIDC, _T("%lu"), AFX_IDP_PARSE_UINT, &value);
	else
		DDX_TextWithFormat(pDX, nIDC, _T("%lu"), AFX_IDP_PARSE_UINT, value);
}

void AFXAPI DDX_Text(CDataExchange* pDX, int nIDC, CString& value)
{
	HWND hWndCtrl = pDX->PrepareEditCtrl(nIDC);
	if (pDX->m_bSaveAndValidate)
	{
		int nLen = ::GetWindowTextLength(hWndCtrl);
		::GetWindowText(hWndCtrl, value.GetBufferSetLength(nLen), nLen+1);
		value.ReleaseBuffer();
	}
	else
	{
		AfxSetWindowText(hWndCtrl, value);
	}
}
*/
void AFXAPI DDX_TexttoHex(CDataExchange* pDX, int nIDC, DWORD& value)
{
	if (pDX->m_bSaveAndValidate)
		DDX_TextWithFormat(pDX, nIDC, _T("%lx"), AFX_IDP_PARSE_INT, &value);
	else
		DDX_TextWithFormat(pDX, nIDC, _T("%lx"), AFX_IDP_PARSE_INT, value);
}



/////////////////////////////////////////////////////////////////////////////
// Data exchange for special control

void AFXAPI DDX_Check(CDataExchange* pDX, int nIDC, int& value)
{
	HWND hWndCtrl = pDX->PrepareCtrl(nIDC);
	if (pDX->m_bSaveAndValidate)
	{
		value = (int)::SendMessage(hWndCtrl, BM_GETCHECK, 0, 0L);
		ASSERT(value >= 0 && value <= 2);
	}
	else
	{
		if (value < 0 || value > 2)
		{
			value = 0;  // default to off
			TRACE1("Warning: dialog data checkbox value (%d) out of range.\n",
				 value);
		}
		::SendMessage(hWndCtrl, BM_SETCHECK, (WPARAM)value, 0L);
	}
}

void AFXAPI DDX_Radio(CDataExchange* pDX, int nIDC, int& value)
	// must be first in a group of auto radio buttons
{
	HWND hWndCtrl = pDX->PrepareCtrl(nIDC);

	ASSERT(::GetWindowLong(hWndCtrl, GWL_STYLE) & WS_GROUP);
	ASSERT(::SendMessage(hWndCtrl, WM_GETDLGCODE, 0, 0L) & DLGC_RADIOBUTTON);

	if (pDX->m_bSaveAndValidate)
		value = -1;     // value if none found

	// walk all children in group
	int iButton = 0;
	do
	{
		if (::SendMessage(hWndCtrl, WM_GETDLGCODE, 0, 0L) & DLGC_RADIOBUTTON)
		{
			// control in group is a radio button
			if (pDX->m_bSaveAndValidate)
			{
				if (::SendMessage(hWndCtrl, BM_GETCHECK, 0, 0L) != 0)
				{
					ASSERT(value == -1);    // only set once
					value = iButton;
				}
			}
			else
			{
				// select button
				::SendMessage(hWndCtrl, BM_SETCHECK, (iButton == value), 0L);
			}
			iButton++;
		}
		else
		{
			TRACE0("Warning: skipping non-radio button in group.\n");
		}
		hWndCtrl = ::GetWindow(hWndCtrl, GW_HWNDNEXT);

	} while (hWndCtrl != NULL &&
		!(GetWindowLong(hWndCtrl, GWL_STYLE) & WS_GROUP));
}

/////////////////////////////////////////////////////////////////////////////
// Listboxes, comboboxes

void AFXAPI DDX_LBString(CDataExchange* pDX, int nIDC, CString& value)
{
	HWND hWndCtrl = pDX->PrepareCtrl(nIDC);
	if (pDX->m_bSaveAndValidate)
	{
		int nIndex = (int)::SendMessage(hWndCtrl, LB_GETCURSEL, 0, 0L);
		if (nIndex != -1)
		{
			int nLen = (int)::SendMessage(hWndCtrl, LB_GETTEXTLEN, nIndex, 0L);
			::SendMessage(hWndCtrl, LB_GETTEXT, nIndex,
					(LPARAM)(LPVOID)value.GetBufferSetLength(nLen));
		}
		else
		{
			// no selection
			value.Empty();
		}
		value.ReleaseBuffer();
	}
	else
	{
		// set current selection based on data string
		if (::SendMessage(hWndCtrl, LB_SELECTSTRING, (WPARAM)-1,
		  (LPARAM)(LPCTSTR)value) == LB_ERR)
		{
			// no selection match
			TRACE0("Warning: no listbox item selected.\n");
		}
	}
}

void AFXAPI DDX_LBStringExact(CDataExchange* pDX, int nIDC, CString& value)
{
	HWND hWndCtrl = pDX->PrepareCtrl(nIDC);
	if (pDX->m_bSaveAndValidate)
	{
		DDX_LBString(pDX, nIDC, value);
	}
	else
	{
		// set current selection based on data string
		int i = (int)::SendMessage(hWndCtrl, LB_FINDSTRINGEXACT, (WPARAM)-1,
		  (LPARAM)(LPCTSTR)value);
		if (i < 0)
		{
			// no selection match
			TRACE0("Warning: no listbox item selected.\n");
		}
		else
		{
			// select it
			SendMessage(hWndCtrl, LB_SETCURSEL, i, 0L);
		}
	}
}

void AFXAPI DDX_CBString(CDataExchange* pDX, int nIDC, CString& value)
{
	HWND hWndCtrl = pDX->PrepareCtrl(nIDC);
	if (pDX->m_bSaveAndValidate)
	{
		// just get current edit item text (or drop list static)
		int nLen = ::GetWindowTextLength(hWndCtrl);
		if (nLen != -1)
		{
			// get known length
			::GetWindowText(hWndCtrl, value.GetBufferSetLength(nLen), nLen+1);
		}
		else
		{
			// for drop lists GetWindowTextLength does not work - assume
			//  max of 255 characters
			::GetWindowText(hWndCtrl, value.GetBuffer(255), 255+1);
		}
		value.ReleaseBuffer();
	}
	else
	{
		// set current selection based on model string
		if (::SendMessage(hWndCtrl, CB_SELECTSTRING, (WPARAM)-1,
			(LPARAM)(LPCTSTR)value) == CB_ERR)
		{
			// just set the edit text (will be ignored if DROPDOWNLIST)
			AfxSetWindowText(hWndCtrl, value);
		}
	}
}

void AFXAPI DDX_CBStringExact(CDataExchange* pDX, int nIDC, CString& value)
{
	HWND hWndCtrl = pDX->PrepareCtrl(nIDC);
	if (pDX->m_bSaveAndValidate)
	{
		DDX_CBString(pDX, nIDC, value);
	}
	else
	{
		// set current selection based on data string
		int i = (int)::SendMessage(hWndCtrl, CB_FINDSTRINGEXACT, (WPARAM)-1,
		  (LPARAM)(LPCTSTR)value);
		if (i < 0)
		{
			// no selection match
			TRACE0("Warning: no combobox item selected.\n");
		}
		else
		{
			// select it
			SendMessage(hWndCtrl, CB_SETCURSEL, i, 0L);
		}
	}
}

void AFXAPI DDX_LBIndex(CDataExchange* pDX, int nIDC, int& index)
{
	HWND hWndCtrl = pDX->PrepareCtrl(nIDC);
	if (pDX->m_bSaveAndValidate)
		index = (int)::SendMessage(hWndCtrl, LB_GETCURSEL, 0, 0L);
	else
		::SendMessage(hWndCtrl, LB_SETCURSEL, (WPARAM)index, 0L);
}

void AFXAPI DDX_CBIndex(CDataExchange* pDX, int nIDC, int& index)
{
	HWND hWndCtrl = pDX->PrepareCtrl(nIDC);
	if (pDX->m_bSaveAndValidate)
		index = (int)::SendMessage(hWndCtrl, CB_GETCURSEL, 0, 0L);
	else
		::SendMessage(hWndCtrl, CB_SETCURSEL, (WPARAM)index, 0L);
}

void AFXAPI DDX_Scroll(CDataExchange* pDX, int nIDC, int& value)
{
	HWND hWndCtrl = pDX->PrepareCtrl(nIDC);
	if (pDX->m_bSaveAndValidate)
		value = GetScrollPos(hWndCtrl, SB_CTL);
	else
		SetScrollPos(hWndCtrl, SB_CTL, value, TRUE);
}
/////////////////////////////////////////////////////////////////////////////
// Range Dialog Data Validation

static void AFXAPI FailMinMaxWithFormat(CDataExchange* pDX,
	 long minVal, long maxVal, LPCTSTR lpszFormat, UINT nIDPrompt)
	// error string must have '%1' and '%2' strings for min and max values
	// wsprintf formatting uses long values (format should be '%ld' or '%lu')
{
	ASSERT(lpszFormat != NULL);

	if (!pDX->m_bSaveAndValidate)
	{
		TRACE0("Warning: initial dialog data is out of range.\n");
		return;     // don't stop now
	}
	TCHAR szMin[32];
	TCHAR szMax[32];
	wsprintf(szMin, lpszFormat, minVal);
	wsprintf(szMax, lpszFormat, maxVal);
	CString prompt;
	AfxFormatString2(prompt, nIDPrompt, szMin, szMax);
	AfxMessageBox(prompt, MB_ICONEXCLAMATION, nIDPrompt);
	prompt.Empty(); // exception prep
	pDX->Fail();
}

//NOTE: don't use overloaded function names to avoid type ambiguities
void AFXAPI DDV_MinMaxByte(CDataExchange* pDX, BYTE value, BYTE minVal, BYTE maxVal)
{
	ASSERT(minVal <= maxVal);
	if (value < minVal || value > maxVal)
		FailMinMaxWithFormat(pDX, (long)minVal, (long)maxVal, _T("%u"),
			AFX_IDP_PARSE_INT_RANGE);
}

void AFXAPI DDV_MinMaxInt(CDataExchange* pDX, int value, int minVal, int maxVal)
{
	ASSERT(minVal <= maxVal);
	if (value < minVal || value > maxVal)
		FailMinMaxWithFormat(pDX, (long)minVal, (long)maxVal, _T("%ld"),
			AFX_IDP_PARSE_INT_RANGE);
}

void AFXAPI DDV_MinMaxLong(CDataExchange* pDX, long value, long minVal, long maxVal)
{
	ASSERT(minVal <= maxVal);
	if (value < minVal || value > maxVal)
		FailMinMaxWithFormat(pDX, (long)minVal, (long)maxVal, _T("%ld"),
			AFX_IDP_PARSE_INT_RANGE);
}

void AFXAPI DDV_MinMaxUInt(CDataExchange* pDX, UINT value, UINT minVal, UINT maxVal)
{
	ASSERT(minVal <= maxVal);
	if (value < minVal || value > maxVal)
		FailMinMaxWithFormat(pDX, (long)minVal, (long)maxVal, _T("%lu"),
			AFX_IDP_PARSE_INT_RANGE);
}

void AFXAPI DDV_MinMaxDWord(CDataExchange* pDX, DWORD value, DWORD minVal, DWORD maxVal)
{
	ASSERT(minVal <= maxVal);
	if (value < minVal || value > maxVal)
		FailMinMaxWithFormat(pDX, (long)minVal, (long)maxVal, _T("%lu"),
			AFX_IDP_PARSE_INT_RANGE);
}

/////////////////////////////////////////////////////////////////////////////
// Max Chars Dialog Data Validation

void AFXAPI DDV_MaxChars(CDataExchange* pDX, CString const& value, int nChars)
{
	ASSERT(nChars >= 1);        // allow them something
	if (pDX->m_bSaveAndValidate && value.GetLength() > nChars)
	{
		TCHAR szT[32];
		wsprintf(szT, _T("%d"), nChars);
		CString prompt;
		AfxFormatString1(prompt, AFX_IDP_PARSE_STRING_SIZE, szT);
		AfxMessageBox(prompt, MB_ICONEXCLAMATION, AFX_IDP_PARSE_STRING_SIZE);
		prompt.Empty(); // exception prep
		pDX->Fail();
	}
}

/////////////////////////////////////////////////////////////////////////////
// Special DDX_ proc for subclassing controls

void AFXAPI DDX_Control(CDataExchange* pDX, int nIDC, CWnd& rControl)
{
	if (rControl.m_hWnd == NULL)    // not subclassed yet
	{
		ASSERT(!pDX->m_bSaveAndValidate);
		HWND hWndCtrl = pDX->PrepareCtrl(nIDC);
		if (!rControl.SubclassWindow(hWndCtrl))
		{
			ASSERT(FALSE);      // possibly trying to subclass twice?
			AfxThrowNotSupportedException();
		}
	}
}

/////////////////////////////////////////////////////////////////////////////

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\editmime.cpp ===
// editmime.cpp : implementation file
//

#include "stdafx.h"
#include "ISAdmin.h"
#include "editmime.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CEditMime dialog


CEditMime::CEditMime(CWnd* pParent, /*=NULL*/
      LPCTSTR pchFileExtension,
      LPCTSTR pchMimeType,
      LPCTSTR pchImageFile,
      LPCTSTR pchGopherType
	  )
	: CDialog(CEditMime::IDD, pParent)
{
	//{{AFX_DATA_INIT(CEditMime)
	m_strFileExtension = pchFileExtension;
	m_strMimeType = pchMimeType;
	m_strImageFile = pchImageFile;
	m_strGopherType = pchGopherType;
	//}}AFX_DATA_INIT
}


void CEditMime::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CEditMime)
	DDX_Text(pDX, IDC_EDITMIMEFILEEXTENSIONDATA1, m_strFileExtension);
	DDX_Text(pDX, IDC_EDITMIMEGOPHERTYPEDATA1, m_strGopherType);
	DDX_Text(pDX, IDC_EDITMIMEIMAGEFILEDATA1, m_strImageFile);
	DDX_Text(pDX, IDC_EDITMIMEMIMETYPEDATA1, m_strMimeType);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CEditMime, CDialog)
	//{{AFX_MSG_MAP(CEditMime)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CEditMime message handlers

void CEditMime::OnOK() 
{
	// TODO: Add extra validation here
	
	CDialog::OnOK();
}

///////////////////////////////////////////////////////////////////////////
// Other Public Functions

	LPCTSTR CEditMime::GetFileExtension()
	{
	return (m_strFileExtension);
	}

	LPCTSTR CEditMime::GetGopherType()
	{
	return (m_strGopherType);
	}

	LPCTSTR CEditMime::GetImageFile()
	{
	return (m_strImageFile);
	}

	LPCTSTR CEditMime::GetMimeType()
	{
	return (m_strMimeType);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\delscrip.h ===
// delscrip.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDelScript dialog

class CDelScript : public CDialog
{
// Construction
public:
	CDelScript(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDelScript)
	enum { IDD = IDD_DELSCRIPTDIALOG };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDelScript)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDelScript)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\editscri.cpp ===
// editscri.cpp : implementation file
//

#include "stdafx.h"
#include "ISAdmin.h"
#include "editscri.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CEditScript dialog

CEditScript::CEditScript(CWnd* pParent, LPCTSTR pchFileExtension, LPCTSTR pchScriptMap)
	: CDialog(CEditScript::IDD, pParent)
{
	//{{AFX_DATA_INIT(CEditScript)
	m_strFileExtension = pchFileExtension;
	m_strScriptMap = pchScriptMap;
	//}}AFX_DATA_INIT
}


void CEditScript::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CEditScript)
	DDX_Text(pDX, IDC_EDITSCRIPTFILEEXTENSIONDATA1, m_strFileExtension);
	DDX_Text(pDX, IDC_EDITSCRIPTMAPPINGDATA1, m_strScriptMap);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CEditScript, CDialog)
	//{{AFX_MSG_MAP(CEditScript)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CEditScript message handlers
	LPCTSTR CEditScript::GetFileExtension()
	{
	return (m_strFileExtension);
	}

	LPCTSTR CEditScript::GetScriptMap()
	{
	return (m_strScriptMap);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\editmime.h ===
// editmime.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CEditMime dialog

class CEditMime : public CDialog
{
// Construction
public:
	CEditMime(CWnd* pParent,
      LPCTSTR pchFileExtension,
      LPCTSTR pchMimeType,
      LPCTSTR pchImageFile,
      LPCTSTR pchGopherType
      );   // standard constructor

// Dialog Data
	//{{AFX_DATA(CEditMime)
	enum { IDD = IDD_EDITMIMEMAPDIALOG };
	CString	m_strFileExtension;
	CString	m_strGopherType;
	CString	m_strImageFile;
	CString	m_strMimeType;
	//}}AFX_DATA

  	LPCTSTR GetFileExtension();
	LPCTSTR GetGopherType();
	LPCTSTR GetImageFile();
	LPCTSTR GetMimeType();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEditMime)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CEditMime)
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\formvw1.h ===
// formvw1.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CFormVw1 form view

#ifndef __AFXEXT_H__
#include <afxext.h>
#endif

class CFormVw1 : public CFormView
{
protected:
	CFormVw1();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CFormVw1)

// Form Data
public:
	//{{AFX_DATA(CFormVw1)
	enum { IDD = IDD_FORMVIEW1 };
	CBitmapButton	m_buttonWebSettings;
	CBitmapButton	m_buttonGopherSettings;
	CBitmapButton	m_buttonFTPSettings;
	CString	m_strMachineNameData1;
	//}}AFX_DATA

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFormVw1)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CFormVw1();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif
	// Generated message map functions
	//{{AFX_MSG(CFormVw1)
	afx_msg void OnWwwset4();
	afx_msg void OnComset1();
	afx_msg void OnFtpset1();
	afx_msg void OnGophset1();
	afx_msg HBRUSH OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\ftpadvp1.cpp ===
// ftpadvp1.cpp : implementation file
//

#include "stdafx.h"
#include "ISAdmin.h"
#include "ftpadvp1.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFTPADVP1 dialog

IMPLEMENT_DYNCREATE(CFTPADVP1, CGenPage)


CFTPADVP1::CFTPADVP1()	: CGenPage(CFTPADVP1::IDD)
{
	//{{AFX_DATA_INIT(CFTPADVP1)
	//}}AFX_DATA_INIT
}

CFTPADVP1::~CFTPADVP1()
{
}

void CFTPADVP1::DoDataExchange(CDataExchange* pDX)
{
	CGenPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFTPADVP1)
	DDX_Control(pDX, IDC_FTPDBGFLAGSDATA1, m_editFTPDbgFlags);
	DDX_TexttoHex(pDX, IDC_FTPDBGFLAGSDATA1, m_ulFTPDbgFlags);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFTPADVP1, CGenPage)
	//{{AFX_MSG_MAP(CFTPADVP1)
	ON_EN_CHANGE(IDC_FTPDBGFLAGSDATA1, OnChangeFtpdbgflagsdata1)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CFTPADVP1 message handlers

BOOL CFTPADVP1::OnInitDialog() 
{
	int i;
	CGenPage::OnInitDialog();
	
	// TODO: Add extra initialization here
	
	for (i = 0; i < AdvFTPPage_TotalNumRegEntries; i++) {
	   m_binNumericRegistryEntries[i].bIsChanged = FALSE;
	   m_binNumericRegistryEntries[i].ulMultipleFactor = 1;
	   }
	
 	m_binNumericRegistryEntries[AdvFTPPage_DebugFlags].strFieldName = _T(DEBUGFLAGSNAME);	
	m_binNumericRegistryEntries[AdvFTPPage_DebugFlags].ulDefaultValue = DEFAULTDEBUGFLAGS;

	for (i = 0; i < AdvFTPPage_TotalNumRegEntries; i++) {
	   if (m_rkMainKey->QueryValue(m_binNumericRegistryEntries[i].strFieldName, 
	      m_binNumericRegistryEntries[i].ulFieldValue) != ERROR_SUCCESS) {
		  m_binNumericRegistryEntries[i].ulFieldValue = m_binNumericRegistryEntries[i].ulDefaultValue;
	   }
	}
   	m_editFTPDbgFlags.LimitText(8);
	m_ulFTPDbgFlags = m_binNumericRegistryEntries[AdvFTPPage_DebugFlags].ulFieldValue;
	UpdateData(FALSE);		// Force Edit box(es) to pick up value(s)

	m_bSetChanged = TRUE;	// Any more changes come from the user

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CFTPADVP1::OnChangeFtpdbgflagsdata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[AdvFTPPage_DebugFlags].bIsChanged = TRUE;
	   	   
	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
}

void CFTPADVP1::SaveInfo()
{

if (m_bIsDirty) {
   m_binNumericRegistryEntries[AdvFTPPage_DebugFlags].ulFieldValue = m_ulFTPDbgFlags;

   SaveNumericInfo(m_binNumericRegistryEntries, AdvFTPPage_TotalNumRegEntries);
}

CGenPage::SaveInfo();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\ftpgenp1.cpp ===
// ftpgenp1.cpp : implementation file
//

#include "stdafx.h"
#include "ISAdmin.h"
#include "compsdef.h"
#include "ftpgenp1.h"
#include "ftpadvp1.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFTPGENP1 property page

IMPLEMENT_DYNCREATE(CFTPGENP1, CGenPage)

CFTPGENP1::CFTPGENP1() : CGenPage(CFTPGENP1::IDD)
{
	//{{AFX_DATA_INIT(CFTPGENP1)
	//}}AFX_DATA_INIT
}

CFTPGENP1::~CFTPGENP1()
{
}

void CFTPGENP1::DoDataExchange(CDataExchange* pDX)
{
	CGenPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFTPGENP1)
	DDX_Control(pDX, IDC_LOWERCASEFILESDATA1, m_cboxLowercaseFiles);
	DDX_Control(pDX, IDC_MSDOSDIROUTPUT, m_cboxMsdosDirOutput);
	DDX_Control(pDX, IDC_ENPORTATTACKDATA1, m_cboxEnPortAttack);
	DDX_Control(pDX, IDC_ANNOTATEDIRECTORIESDATA1, m_cboxAnnotateDirectories);
	DDX_Control(pDX, IDC_ALLOWGUESTACCESSDATA1, m_cboxAllowGuestAccess);
	DDX_Control(pDX, IDC_LOGNONANONDATA1, m_cboxLogNonAnon);
	DDX_Control(pDX, IDC_LOGANONDATA1, m_cboxLogAnon);
	DDX_Control(pDX, IDC_ENSVCLOCDATA1, m_cboxEnSvcLoc);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFTPGENP1, CGenPage)
	//{{AFX_MSG_MAP(CFTPGENP1)
	ON_BN_CLICKED(IDC_ENPORTATTACKDATA1, OnEnportattackdata1)
	ON_BN_CLICKED(IDC_ENSVCLOCDATA1, OnEnsvclocdata1)
	ON_BN_CLICKED(IDC_LOGANONDATA1, OnLoganondata1)
	ON_BN_CLICKED(IDC_LOGNONANONDATA1, OnLognonanondata1)
	ON_BN_CLICKED(IDC_ALLOWGUESTACCESSDATA1, OnAllowguestaccessdata1)
	ON_BN_CLICKED(IDC_ANNOTATEDIRECTORIESDATA1, OnAnnotatedirectoriesdata1)
	ON_BN_CLICKED(IDC_LOWERCASEFILESDATA1, OnLowercasefilesdata1)
	ON_BN_CLICKED(IDC_MSDOSDIROUTPUT, OnMsdosdiroutput)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()



/////////////////////////////////////////////////////////////////////////////
// CFTPGENP1 message handlers

BOOL CFTPGENP1::OnInitDialog() 
{
	int i;
	CGenPage::OnInitDialog();
	
	// TODO: Add extra initialization here

	for (i = 0; i < FTPPage_TotalNumRegEntries; i++) {
	   m_binNumericRegistryEntries[i].bIsChanged = FALSE;
	   m_binNumericRegistryEntries[i].ulMultipleFactor = 1;
	   }
	
	m_binNumericRegistryEntries[FTPPage_EnableSvcLoc].strFieldName = _T(ENABLESVCLOCNAME);	
	m_binNumericRegistryEntries[FTPPage_EnableSvcLoc].ulDefaultValue = DEFAULTENABLESVCLOC;

	m_binNumericRegistryEntries[FTPPage_LogAnonymous].strFieldName = _T(LOGANONYMOUSNAME);	
	m_binNumericRegistryEntries[FTPPage_LogAnonymous].ulDefaultValue = DEFAULTLOGANONYMOUS;

	m_binNumericRegistryEntries[FTPPage_LogNonAnonymous].strFieldName = _T(LOGNONANONYMOUSNAME);	
	m_binNumericRegistryEntries[FTPPage_LogNonAnonymous].ulDefaultValue = DEFAULTLOGNONANONYMOUS;

	m_binNumericRegistryEntries[FTPPage_EnablePortAttack].strFieldName = _T(ENABLEPORTATTACKNAME);	
	m_binNumericRegistryEntries[FTPPage_EnablePortAttack].ulDefaultValue = DEFAULTENABLEPORTATTACK;

	m_binNumericRegistryEntries[FTPPage_AllowGuestAccess].strFieldName = _T(ALLOWGUESTACCESSNAME);	
	m_binNumericRegistryEntries[FTPPage_AllowGuestAccess].ulDefaultValue = DEFAULTALLOWGUESTACCESS;

	m_binNumericRegistryEntries[FTPPage_AnnotateDirectories].strFieldName = _T(ANNOTATEDIRECTORIESNAME);	
	m_binNumericRegistryEntries[FTPPage_AnnotateDirectories].ulDefaultValue = DEFAULTANNOTATEDIRECTORIES;

	m_binNumericRegistryEntries[FTPPage_MsdosDirOutput].strFieldName = _T(MSDOSDIROUTPUTNAME);	
	m_binNumericRegistryEntries[FTPPage_MsdosDirOutput].ulDefaultValue = DEFAULTMSDOSDIROUTPUT;

	m_binNumericRegistryEntries[FTPPage_LowercaseFiles].strFieldName = _T(LOWERCASEFILESNAME);	
	m_binNumericRegistryEntries[FTPPage_LowercaseFiles].ulDefaultValue = DEFAULTLOWERCASEFILES;

	for (i = 0; i < FTPPage_TotalNumRegEntries; i++) {
	   if (m_rkMainKey->QueryValue(m_binNumericRegistryEntries[i].strFieldName, 
	      m_binNumericRegistryEntries[i].ulFieldValue) != ERROR_SUCCESS) {
		  m_binNumericRegistryEntries[i].ulFieldValue = m_binNumericRegistryEntries[i].ulDefaultValue;
	   }
	}

	m_cboxEnSvcLoc.SetCheck(GETCHECKBOXVALUEFROMREG(m_binNumericRegistryEntries[FTPPage_EnableSvcLoc].ulFieldValue));

	m_cboxLogAnon.SetCheck(GETCHECKBOXVALUEFROMREG(m_binNumericRegistryEntries[FTPPage_LogAnonymous].ulFieldValue));

	m_cboxLogNonAnon.SetCheck(GETCHECKBOXVALUEFROMREG(m_binNumericRegistryEntries[FTPPage_LogNonAnonymous].ulFieldValue));

	m_cboxEnPortAttack.SetCheck(GETCHECKBOXVALUEFROMREG(m_binNumericRegistryEntries[FTPPage_EnablePortAttack].ulFieldValue));

	m_cboxAllowGuestAccess.SetCheck(GETCHECKBOXVALUEFROMREG(m_binNumericRegistryEntries[FTPPage_AllowGuestAccess].ulFieldValue));

	m_cboxAnnotateDirectories.SetCheck(GETCHECKBOXVALUEFROMREG(m_binNumericRegistryEntries[FTPPage_AnnotateDirectories].ulFieldValue));

	m_cboxMsdosDirOutput.SetCheck(GETCHECKBOXVALUEFROMREG(m_binNumericRegistryEntries[FTPPage_MsdosDirOutput].ulFieldValue));

	m_cboxLowercaseFiles.SetCheck(GETCHECKBOXVALUEFROMREG(m_binNumericRegistryEntries[FTPPage_LowercaseFiles].ulFieldValue));

   	m_bSetChanged = TRUE;	// Any more changes come from the user
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}



void CFTPGENP1::OnEnportattackdata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[FTPPage_EnablePortAttack].bIsChanged = TRUE;
	   
	   m_binNumericRegistryEntries[FTPPage_EnablePortAttack].ulFieldValue = 
	      GETREGVALUEFROMCHECKBOX(m_cboxEnPortAttack.GetCheck());

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
	
	
}

void CFTPGENP1::OnEnsvclocdata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[FTPPage_EnableSvcLoc].bIsChanged = TRUE;
	   
	   m_binNumericRegistryEntries[FTPPage_EnableSvcLoc].ulFieldValue = 
	      GETREGVALUEFROMCHECKBOX(m_cboxEnSvcLoc.GetCheck());

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
	
	
}

void CFTPGENP1::OnLoganondata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[FTPPage_LogAnonymous].bIsChanged = TRUE;
	   
	   m_binNumericRegistryEntries[FTPPage_LogAnonymous].ulFieldValue = 
	      GETREGVALUEFROMCHECKBOX(m_cboxLogAnon.GetCheck());

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
	
}

void CFTPGENP1::OnLognonanondata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[FTPPage_LogNonAnonymous].bIsChanged = TRUE;
	   
	   m_binNumericRegistryEntries[FTPPage_LogNonAnonymous].ulFieldValue = 
	      GETREGVALUEFROMCHECKBOX(m_cboxLogNonAnon.GetCheck());

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
	
	
}

void CFTPGENP1::OnAllowguestaccessdata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[FTPPage_AllowGuestAccess].bIsChanged = TRUE;
	   
	   m_binNumericRegistryEntries[FTPPage_AllowGuestAccess].ulFieldValue = 
	      GETREGVALUEFROMCHECKBOX(m_cboxAllowGuestAccess.GetCheck());

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
	
	
}

void CFTPGENP1::OnAnnotatedirectoriesdata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[FTPPage_AnnotateDirectories].bIsChanged = TRUE;
	   
	   m_binNumericRegistryEntries[FTPPage_AnnotateDirectories].ulFieldValue = 
	      GETREGVALUEFROMCHECKBOX(m_cboxAnnotateDirectories.GetCheck());

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
	
	
}

void CFTPGENP1::OnMsdosdiroutput() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[FTPPage_MsdosDirOutput].bIsChanged = TRUE;
	   
	   m_binNumericRegistryEntries[FTPPage_MsdosDirOutput].ulFieldValue = 
	      GETREGVALUEFROMCHECKBOX(m_cboxMsdosDirOutput.GetCheck());

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
}

void CFTPGENP1::OnLowercasefilesdata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[FTPPage_LowercaseFiles].bIsChanged = TRUE;
	   
	   m_binNumericRegistryEntries[FTPPage_LowercaseFiles].ulFieldValue = 
	      GETREGVALUEFROMCHECKBOX(m_cboxLowercaseFiles.GetCheck());

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
	
	
}

void CFTPGENP1::SaveInfo()
{

if (m_bIsDirty) {
SaveNumericInfo(m_binNumericRegistryEntries, FTPPage_TotalNumRegEntries);
}

CGenPage::SaveInfo();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\formvw1.cpp ===
// formvw1.cpp : implementation file
//

#include "stdafx.h"
#include "afxcmn.h"
#include "ISAdmin.h"
#include "formvw1.h"
#include "mimemap1.h"
#include "scrmap1.h"
#include "ssl1.h"

#include "gensheet.h"
#include "compage1.h"
#include "advcom1.h"
#include "ftpgenp1.h"
#include "ftpadvp1.h"
#include "gopgenp1.h"
#include "gopadvp1.h"
#include "webgenp1.h"
#include "webadvp1.h"


#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CFormVw1

IMPLEMENT_DYNCREATE(CFormVw1, CFormView)

CFormVw1::CFormVw1()
	: CFormView(CFormVw1::IDD)
{
	TCHAR	strTempComputerName[MAX_COMPUTERNAME_LENGTH + 1];
	DWORD   ulTempComputerNameLen = MAX_COMPUTERNAME_LENGTH + 1;
	if (GetComputerName(strTempComputerName, &ulTempComputerNameLen))
	  m_strMachineNameData1 = strTempComputerName;
	else
	  m_strMachineNameData1 = (TCHAR *) NULL;
	
	m_buttonFTPSettings.LoadBitmaps(IDB_FTPUPBITMAP, IDB_FTPDOWNBITMAP);
	m_buttonGopherSettings.LoadBitmaps(IDB_GOPHERUPBITMAP,IDB_GOPHERDOWNBITMAP);
	m_buttonWebSettings.LoadBitmaps(IDB_WEBUPBITMAP,IDB_WEBDOWNBITMAP);

#if 0
	//{{AFX_DATA_INIT(CFormVw1)
	m_strMachineNameData1 = _T("");
	//}}AFX_DATA_INIT
#endif
}

CFormVw1::~CFormVw1()
{
}

void CFormVw1::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CFormVw1)
	DDX_Control(pDX, IDC_WWWSET4, m_buttonWebSettings);
	DDX_Control(pDX, IDC_GOPHSET1, m_buttonGopherSettings);
	DDX_Control(pDX, IDC_FTPSET1, m_buttonFTPSettings);
	DDX_Text(pDX, IDC_MACHINENAMEDATA1, m_strMachineNameData1);
	DDV_MaxChars(pDX, m_strMachineNameData1, 256);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CFormVw1, CFormView)
	//{{AFX_MSG_MAP(CFormVw1)
	ON_BN_CLICKED(IDC_WWWSET4, OnWwwset4)
	ON_BN_CLICKED(IDC_COMSET1, OnComset1)
	ON_BN_CLICKED(IDC_FTPSET1, OnFtpset1)
	ON_BN_CLICKED(IDC_GOPHSET1, OnGophset1)
	ON_WM_CTLCOLOR()
//}}AFX_MSG_MAP
END_MESSAGE_MAP()



/////////////////////////////////////////////////////////////////////////////
// CFormVw1 diagnostics

#ifdef _DEBUG
void CFormVw1::AssertValid() const
{
	CFormView::AssertValid();
}

void CFormVw1::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CFormVw1 message handlers


void CFormVw1::OnWwwset4()
{
	// TODO: Add your control notification handler code here
	UpdateData(TRUE);
	CRegKey rkWebSet(HKEY_LOCAL_MACHINE, _T(WEB_REGISTRY_MAINKEY),
				REGISTRY_ACCESS_RIGHTS, m_strMachineNameData1);


	if (rkWebSet != NULL) {


       CGENSHEET s(_T("Web Settings"));

	   CWEBGENP1 WebPage;

	   WebPage.m_rkMainKey = &rkWebSet;

	   s.AddPage(&WebPage);

	   ScrMap1 ScriptPage;

	   ScriptPage.m_rkMainKey = &rkWebSet;

	   s.AddPage(&ScriptPage);

	   SSL1 SSLPage;

	   SSLPage.m_rkMainKey = &rkWebSet;

	   s.AddPage(&SSLPage);
		
	   CWEBADVP1 WebAdvPage;

	   WebAdvPage.m_rkMainKey = &rkWebSet;

	   s.AddPage(&WebAdvPage);


	   if (s.DoModal() == IDOK)
	      s.SavePageData();

	}
	else {
	   CString strWebErrMsg(_T(""));
	   AfxFormatString1(strWebErrMsg, IDS_WEBOPENREGERRMSG1, m_strMachineNameData1);
	   AfxMessageBox(strWebErrMsg);
	}
	
}

void CFormVw1::OnComset1()
{
	// TODO: Add your control notification handler code here

	UpdateData(TRUE);
	CRegKey rkComSet(HKEY_LOCAL_MACHINE, _T(COMMON_REGISTRY_MAINKEY),
				REGISTRY_ACCESS_RIGHTS, m_strMachineNameData1);


	if (rkComSet != NULL) {

       CGENSHEET s(_T("Common Settings"));

	   CCOMPAGE1 ComPage;

	   ComPage.m_rkMainKey = &rkComSet;

	   s.AddPage(&ComPage);
	
//	   CRegKey rkMimeKey(rkComSet,_T("MimeMap"),REGISTRY_ACCESS_RIGHTS);

//	   if (rkMimeKey != NULL) {

	      MIMEMAP1 MimePage;
	
//	      MimePage.m_rkMimeKey = &rkMimeKey;
	
	      MimePage.m_rkMainKey = &rkComSet;

	      s.AddPage(&MimePage);

//	   }
	
	   CADVCOM1 ComAdvPage;

	   ComAdvPage.m_rkMainKey = &rkComSet;

	   s.AddPage(&ComAdvPage);

	   if (s.DoModal() == IDOK)
	      s.SavePageData();
	}
	else {
	   CString strComErrMsg(_T(""));
	   AfxFormatString1(strComErrMsg, IDS_COMOPENREGERRMSG1, m_strMachineNameData1);
	   AfxMessageBox(strComErrMsg);
	}
	
}

void CFormVw1::OnFtpset1()
{
	// TODO: Add your control notification handler code here
	UpdateData(TRUE);
	CRegKey rkFtpSet(HKEY_LOCAL_MACHINE, _T(FTP_REGISTRY_MAINKEY),
				REGISTRY_ACCESS_RIGHTS, m_strMachineNameData1);


	if (rkFtpSet != NULL) {

	
       CGENSHEET s(_T("FTP Settings"));

	   CFTPGENP1 FTPPage;
	
	   FTPPage.m_rkMainKey = &rkFtpSet;

	   s.AddPage(&FTPPage);

	   CFTPADVP1 FTPAdvPage;

	   FTPAdvPage.m_rkMainKey = &rkFtpSet;

	   s.AddPage(&FTPAdvPage);

	   if (s.DoModal() == IDOK)
	      s.SavePageData();

	}
	else {
	   CString strWebErrMsg(_T(""));
	   AfxFormatString1(strWebErrMsg, IDS_FTPOPENREGERRMSG1, m_strMachineNameData1);
	   AfxMessageBox(strWebErrMsg);
	}

}

void CFormVw1::OnGophset1()
{
	// TODO: Add your control notification handler code here
	UpdateData(TRUE);
	CRegKey rkGopSet(HKEY_LOCAL_MACHINE, _T(GOPHER_REGISTRY_MAINKEY),
				REGISTRY_ACCESS_RIGHTS, m_strMachineNameData1);


	if (rkGopSet != NULL) {


       CGENSHEET s(_T("Gopher Settings"));

	   CGOPGENP1 GopherPage;

	   GopherPage.m_rkMainKey = &rkGopSet;

	   s.AddPage(&GopherPage);	

	   CGOPADVP1 GopherAdvPage;

	   GopherAdvPage.m_rkMainKey = &rkGopSet;

	   s.AddPage(&GopherAdvPage);

	   if (s.DoModal() == IDOK)
	      s.SavePageData();

	}
	else {
	   CString strGopErrMsg(_T(""));
	   AfxFormatString1(strGopErrMsg, IDS_GOPOPENREGERRMSG1, m_strMachineNameData1);
	   AfxMessageBox(strGopErrMsg);
	}
	
}


HBRUSH CFormVw1::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor)
{
/*	if (pWnd->GetDlgCtrlID() == IDC_FTPSET1) {
		  pDC->SetBkColor(RGB(255,255,255));
          return((HBRUSH)::GetStockObject(WHITE_BRUSH));
	   }
*/	
	if (nCtlColor == CTLCOLOR_STATIC) {
	   if (pWnd->GetDlgCtrlID() == IDC_MAINGROUP) {
		  pDC->SetBkColor(RGB(255,255,255));
          return((HBRUSH)::GetStockObject(WHITE_BRUSH));
	   }
	}
	else if (nCtlColor == CTLCOLOR_BTN) {
	   int iTempDlgCtrlID = pWnd->GetDlgCtrlID();
	   if ((iTempDlgCtrlID == IDC_FTPSET1) || (iTempDlgCtrlID == IDC_GOPHSET1)
	      || (iTempDlgCtrlID == IDC_WWWSET4)) {
		  pDC->SetBkColor(RGB(255,255,255));
          return((HBRUSH)::GetStockObject(WHITE_BRUSH));
	   }
	}

	HBRUSH hbr = CFormView::OnCtlColor(pDC, pWnd, nCtlColor);
	
	// TODO: Change any attributes of the DC here
	
	// TODO: Return a different brush if the default is not desired
	return hbr;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\ftpadvp1.h ===
// ftpadvp1.h : header file
//

enum ADV_FTP_NUM_REG_ENTRIES {
	 AdvFTPPage_DebugFlags,
	 AdvFTPPage_TotalNumRegEntries
	 };



/////////////////////////////////////////////////////////////////////////////
// CFTPADVP1 dialog

class CFTPADVP1 : public CGenPage
{
    DECLARE_DYNCREATE(CFTPADVP1)
// Construction
public:
	CFTPADVP1();
	~CFTPADVP1();

// Dialog Data
	//{{AFX_DATA(CFTPADVP1)
	enum { IDD = IDD_FTPADVPAGE1 };
	CEdit	m_editFTPDbgFlags;
	DWORD	m_ulFTPDbgFlags;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CFTPADVP1)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual	void SaveInfo(void);
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CFTPADVP1)
	afx_msg void OnChangeFtpdbgflagsdata1();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG

	NUM_REG_ENTRY m_binNumericRegistryEntries[AdvFTPPage_TotalNumRegEntries];

	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\editscri.h ===
// editscri.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CEditScript dialog

class CEditScript : public CDialog
{
// Construction
public:
	CEditScript(CWnd* pParent, LPCTSTR pchFileExtension, LPCTSTR pchScriptMap);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CEditScript)
	enum { IDD = IDD_EDITSCRIPTDIALOG };
	CString	m_strFileExtension;
	CString	m_strScriptMap;
	//}}AFX_DATA
  	LPCTSTR GetFileExtension();
	LPCTSTR GetScriptMap();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEditScript)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CEditScript)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\ftpgenp1.h ===
// ftpgenp1.h : header file
//

#define ENABLEPORTATTACKNAME	"EnablePortAttack"
#define DEFAULTENABLEPORTATTACK	FALSEVALUE

#define ALLOWGUESTACCESSNAME	"AllowGuestAccess"
#define DEFAULTALLOWGUESTACCESS	TRUEVALUE

#define ANNOTATEDIRECTORIESNAME	"AnnotateDirectories"
#define DEFAULTANNOTATEDIRECTORIES	FALSEVALUE

#define MSDOSDIROUTPUTNAME	"MsdosDirOutput"
#define DEFAULTMSDOSDIROUTPUT	TRUEVALUE

#define LOWERCASEFILESNAME	"LowercaseFiles"
#define DEFAULTLOWERCASEFILES	FALSEVALUE



enum  FTP_NUM_REG_ENTRIES {
     FTPPage_EnableSvcLoc,
	 FTPPage_LogAnonymous,
	 FTPPage_LogNonAnonymous,
	 FTPPage_EnablePortAttack,
	 FTPPage_AllowGuestAccess,
	 FTPPage_AnnotateDirectories,
	 FTPPage_MsdosDirOutput,
	 FTPPage_LowercaseFiles,
	 FTPPage_TotalNumRegEntries
	 };



/////////////////////////////////////////////////////////////////////////////
// CFTPGENP1 dialog

class CFTPGENP1 : public CGenPage
{
	DECLARE_DYNCREATE(CFTPGENP1)

// Construction
public:
	CFTPGENP1();
	~CFTPGENP1();

// Dialog Data
	//{{AFX_DATA(CFTPGENP1)
	enum { IDD = IDD_FTPPAGE1 };
	CButton	m_cboxLowercaseFiles;
	CButton	m_cboxMsdosDirOutput;
	CButton	m_cboxEnPortAttack;
	CButton	m_cboxAnnotateDirectories;
	CButton	m_cboxAllowGuestAccess;
	CButton	m_cboxLogNonAnon;
	CButton	m_cboxLogAnon;
	CButton	m_cboxEnSvcLoc;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CFTPGENP1)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual	void SaveInfo(void);
//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CFTPGENP1)
	virtual BOOL OnInitDialog();
	afx_msg void OnEnportattackdata1();
	afx_msg void OnEnsvclocdata1();
	afx_msg void OnLoganondata1();
	afx_msg void OnLognonanondata1();
	afx_msg void OnAllowguestaccessdata1();
	afx_msg void OnAnnotatedirectoriesdata1();
	afx_msg void OnLowercasefilesdata1();
	afx_msg void OnMsdosdiroutput();
	//}}AFX_MSG

	NUM_REG_ENTRY m_binNumericRegistryEntries[FTPPage_TotalNumRegEntries];

	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\genpage.cpp ===
// genpage.cpp : implementation file
//

#include "stdafx.h"
#include "ISAdmin.h"
#include "genpage.h"

#include "afximpl.h"
#include "afxpriv.h"



#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CGenPage property page

IMPLEMENT_DYNAMIC(CGenPage, CPropertyPage)

//CGenPage::CGenPage() : CPropertyPage(CGenPage::IDD)
CGenPage::CGenPage(UINT nIDTemplate, UINT nIDCaption):CPropertyPage( nIDTemplate, nIDCaption )
{
	m_bSetChanged = FALSE;	//Do not mark vaues as changed during initialization
	m_bIsDirty = FALSE;
};
CGenPage::CGenPage(LPCTSTR lpszTemplateName, UINT nIDCaption): CPropertyPage(lpszTemplateName, nIDCaption)
{ 	
m_bSetChanged = FALSE;	//Do not mark vaues as changed during initialization
m_bIsDirty = FALSE;
};


CGenPage::~CGenPage()
{
}

void CGenPage::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGenPage)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CGenPage, CPropertyPage)
	//{{AFX_MSG_MAP(CGenPage)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CGenPage message handlers

void CGenPage::SaveInfo()
{
if (m_bIsDirty) {
   m_bIsDirty = FALSE;
   SetModified(FALSE);
}
}

void CGenPage::SaveNumericInfo(PNUM_REG_ENTRY lpbinNumEntries, int iNumEntries)
{
int i;
for (i = 0; i < iNumEntries; i++) {
   if (lpbinNumEntries[i].bIsChanged) {
      lpbinNumEntries[i].bIsChanged = FALSE;
      m_rkMainKey->SetValue(lpbinNumEntries[i].strFieldName, lpbinNumEntries[i].ulFieldValue);
   }
}
}

void CGenPage::SaveStringInfo(PSTRING_REG_ENTRY lpbinStringEntries, int iStringEntries)
{
int i;
for (i = 0; i < iStringEntries; i++) {
   if (lpbinStringEntries[i].bIsChanged) {
      lpbinStringEntries[i].bIsChanged = FALSE;
      m_rkMainKey->SetValue(lpbinStringEntries[i].strFieldName, lpbinStringEntries[i].strFieldValue);
   }
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\genpage.h ===
// genpage.h : header file
//

#ifndef _GEN_PAGE_
#define _GEN_PAGE_

#include "compsdef.h"

enum YES_NO_ENTRIES {
YESNO_NO,
YESNO_YES
};

// These are checkbox states
#define	CHECKEDVALUE	1
#define UNCHECKEDVALUE	0

// These are our true/false values for the registry
#define TRUEVALUE		1
#define FALSEVALUE		0

// Since TRUEVALUE = CHECKEDVALUE and FALSEVALUE = UNCHECKEDVALUE, we don't really need this.
// This avoids dependency on that correlation
#define GETREGVALUEFROMCHECKBOX(p)	((p) == UNCHECKEDVALUE) ? FALSEVALUE : TRUEVALUE
	
#define GETCHECKBOXVALUEFROMREG(p)	((p) == FALSEVALUE) ? UNCHECKEDVALUE : CHECKEDVALUE
	

// Data Structure for numeric registry entries, all pages

typedef struct _NUM_REG_ENTRY {
   LPTSTR	strFieldName;
   DWORD	ulFieldValue;
   DWORD	ulMultipleFactor; 		//for entries where the use specifies MB, KB, minutes, etc.
   DWORD	ulDefaultValue;
   BOOL		bIsChanged;
   } NUM_REG_ENTRY, *PNUM_REG_ENTRY;

typedef struct _STRING_REG_ENTRY {
   LPTSTR	strFieldName;
   CString	strFieldValue;		
   CString	strDefaultValue;		
   BOOL		bIsChanged;
   } STRING_REG_ENTRY, *PSTRING_REG_ENTRY;

void AFXAPI DDX_TexttoHex(CDataExchange* pDX, int nIDC, DWORD& value);

/////////////////////////////////////////////////////////////////////////////
// CGenPage dialog

class CGenPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CGenPage)

// Construction
public:
	CGenPage(UINT nIDTemplate, UINT nIDCaption = 0);
	CGenPage(LPCTSTR lpszTemplateName, UINT nIDCaption = 0);
	~CGenPage();
// Dialog Data
	//{{AFX_DATA(CGenPage)
//	enum { IDD = _UNKNOWN_RESOURCE_ID_ };
		// NOTE - ClassWizard will add data members here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DATA

    /* PURE */ virtual void SaveInfo(void);

	CRegKey *m_rkMainKey;


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CGenPage)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CGenPage)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	
	BOOL m_bIsDirty;
	BOOL m_bSetChanged;

	void SaveNumericInfo(PNUM_REG_ENTRY lpbinNumEntries, int iNumEntries);
	void SaveStringInfo(PSTRING_REG_ENTRY lpbinStringEntries, int iStringEntries);

	DECLARE_MESSAGE_MAP()

};

#endif  //_GEN_PAGE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\gensheet.cpp ===
// gensheet.cpp : implementation file
//

#include "stdafx.h"
#include "afxcmn.h"
#include "ISAdmin.h"
#include "gensheet.h"
#include "genpage.h"

#include "compage1.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CGENSHEET

IMPLEMENT_DYNAMIC(CGENSHEET, CPropertySheet)

CGENSHEET::CGENSHEET(UINT nIDCaption, CWnd* pParentWnd, UINT iSelectPage)
	:CPropertySheet(nIDCaption, pParentWnd, iSelectPage)
{
}

CGENSHEET::CGENSHEET(LPCTSTR pszCaption, CWnd* pParentWnd, UINT iSelectPage)
	:CPropertySheet(pszCaption, pParentWnd, iSelectPage)
{
}

CGENSHEET::~CGENSHEET()
{
}


BEGIN_MESSAGE_MAP(CGENSHEET, CPropertySheet)
	//{{AFX_MSG_MAP(CGENSHEET)
	ON_BN_CLICKED (ID_APPLY_NOW, OnApplyNow)
	ON_COMMAND(ID_HELP, OnHelp)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CGENSHEET message handlers

  void CGENSHEET::OnApplyNow ()
  {	
    if (GetActivePage ()->UpdateData (TRUE))
	   SavePageData();
  }


void CGENSHEET::SavePageData ()
  {	
    CGenPage * pPage = NULL;

    for (int i = 0; i < GetPageCount(); ++i)
    {
        pPage = (CGenPage *)GetPage(i);
        ASSERT(pPage != NULL);
        //
        // Update the data in each page and save
        //
        pPage->SaveInfo();
	}
  }




void CGENSHEET::OnHelp() 
{
	// TODO: Add your command handler code here
AfxGetApp()->WinHelp(0x20080);	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\gensheet.h ===
// gensheet.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CGENSHEET

#ifndef _GEN_SHEET_
#define _GEN_SHEET_


class CGENSHEET : public CPropertySheet
{
	DECLARE_DYNAMIC(CGENSHEET)

// Construction
public:
	CGENSHEET(UINT nIDCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);
	CGENSHEET(LPCTSTR pszCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGENSHEET) 
	//}}AFX_VIRTUAL

afx_msg void CGENSHEET::OnApplyNow ();
void SavePageData(void);
// Implementation
public:
	virtual ~CGENSHEET();

	// Generated message map functions
protected:
	//{{AFX_MSG(CGENSHEET)
	afx_msg void OnHelp();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\gopadvp1.cpp ===
// gopadvp1.cpp : implementation file
//

#include "stdafx.h"
#include "ISAdmin.h"
#include "gopadvp1.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CGOPADVP1 dialog

IMPLEMENT_DYNCREATE(CGOPADVP1, CGenPage)

CGOPADVP1::CGOPADVP1(): CGenPage(CGOPADVP1::IDD)
{
	//{{AFX_DATA_INIT(CGOPADVP1)
	m_ulGopDbgFlags = 0;
	//}}AFX_DATA_INIT
}

CGOPADVP1::~CGOPADVP1()
{
}

void CGOPADVP1::DoDataExchange(CDataExchange* pDX)
{
	CGenPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGOPADVP1)
	DDX_Control(pDX, IDC_GOPDBGFLAGSDATA1, m_editGopDbgFlags);
	DDX_TexttoHex(pDX, IDC_GOPDBGFLAGSDATA1, m_ulGopDbgFlags);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CGOPADVP1, CGenPage)
	//{{AFX_MSG_MAP(CGOPADVP1)
	ON_EN_CHANGE(IDC_GOPDBGFLAGSDATA1, OnChangeGopdbgflagsdata1)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CGOPADVP1 message handlers

BOOL CGOPADVP1::OnInitDialog() 
{
	CGenPage::OnInitDialog();

	int i;
	// TODO: Add extra initialization here
	for (i = 0; i < AdvGopPage_TotalNumRegEntries; i++) {
	   m_binNumericRegistryEntries[i].bIsChanged = FALSE;
	   m_binNumericRegistryEntries[i].ulMultipleFactor = 1;
	   }
	
 	m_binNumericRegistryEntries[AdvGopPage_DebugFlags].strFieldName = _T(DEBUGFLAGSNAME);	
	m_binNumericRegistryEntries[AdvGopPage_DebugFlags].ulDefaultValue = DEFAULTDEBUGFLAGS;

	for (i = 0; i < AdvGopPage_TotalNumRegEntries; i++) {
	   if (m_rkMainKey->QueryValue(m_binNumericRegistryEntries[i].strFieldName, 
	      m_binNumericRegistryEntries[i].ulFieldValue) != ERROR_SUCCESS) {
		  m_binNumericRegistryEntries[i].ulFieldValue = m_binNumericRegistryEntries[i].ulDefaultValue;
	   }
	}
   	m_editGopDbgFlags.LimitText(8);
	m_ulGopDbgFlags = m_binNumericRegistryEntries[AdvGopPage_DebugFlags].ulFieldValue;
	UpdateData(FALSE);		// Force Edit box(es) to pick up value(s)

	m_bSetChanged = TRUE;	// Any more changes come from the user

	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CGOPADVP1::OnChangeGopdbgflagsdata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[AdvGopPage_DebugFlags].bIsChanged = TRUE;
	   	   
	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
}

void CGOPADVP1::SaveInfo()
{

if (m_bIsDirty) {
   m_binNumericRegistryEntries[AdvGopPage_DebugFlags].ulFieldValue = m_ulGopDbgFlags;

   SaveNumericInfo(m_binNumericRegistryEntries, AdvGopPage_TotalNumRegEntries);
}

CGenPage::SaveInfo();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\gopgenp1.cpp ===
// gopgenp1.cpp : implementation file
//

#include "stdafx.h"
#include "ISAdmin.h"
#include "compsdef.h"
#include "gopgenp1.h"
#include "gopadvp1.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CGOPGENP1 property page

IMPLEMENT_DYNCREATE(CGOPGENP1, CGenPage)

CGOPGENP1::CGOPGENP1() : CGenPage(CGOPGENP1::IDD)
{
	//{{AFX_DATA_INIT(CGOPGENP1)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
}

CGOPGENP1::~CGOPGENP1()
{
}

void CGOPGENP1::DoDataExchange(CDataExchange* pDX)
{
	CGenPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGOPGENP1)
	DDX_Control(pDX, IDC_LOGANONDATA1, m_cboxLogAnon);
	DDX_Control(pDX, IDC_ENWAISDATA1, m_cboxEnWais);
	DDX_Control(pDX, IDC_ENSVCLOCDATA1, m_cboxEnSvcLoc);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CGOPGENP1, CGenPage)
	//{{AFX_MSG_MAP(CGOPGENP1)
	ON_BN_CLICKED(IDC_ENSVCLOCDATA1, OnEnsvclocdata1)
	ON_BN_CLICKED(IDC_ENWAISDATA1, OnEnwaisdata1)
	ON_BN_CLICKED(IDC_LOGANONDATA1, OnLoganondata1)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CGOPGENP1 message handlers

BOOL CGOPGENP1::OnInitDialog() 
{
	int i;
	CGenPage::OnInitDialog();
	
	// TODO: Add extra initialization here

	for (i = 0; i < GopPage_TotalNumRegEntries; i++) {
	   m_binNumericRegistryEntries[i].bIsChanged = FALSE;
	   m_binNumericRegistryEntries[i].ulMultipleFactor = 1;
	   }
	
	m_binNumericRegistryEntries[GopPage_EnableSvcLoc].strFieldName = _T(ENABLESVCLOCNAME);	
	m_binNumericRegistryEntries[GopPage_EnableSvcLoc].ulDefaultValue = DEFAULTENABLESVCLOC;

	m_binNumericRegistryEntries[GopPage_LogAnonymous].strFieldName = _T(LOGANONYMOUSNAME);	
	m_binNumericRegistryEntries[GopPage_LogAnonymous].ulDefaultValue = DEFAULTLOGANONYMOUS;

	m_binNumericRegistryEntries[GopPage_CheckForWAISDB].strFieldName = _T(CHECKFORWAISDBNAME);	
	m_binNumericRegistryEntries[GopPage_CheckForWAISDB].ulDefaultValue = DEFAULTCHECKFORWAISDB;

	for (i = 0; i < GopPage_TotalNumRegEntries; i++) {
	   if (m_rkMainKey->QueryValue(m_binNumericRegistryEntries[i].strFieldName, 
	      m_binNumericRegistryEntries[i].ulFieldValue) != ERROR_SUCCESS) {
		  m_binNumericRegistryEntries[i].ulFieldValue = m_binNumericRegistryEntries[i].ulDefaultValue;
	   }
	}

	m_cboxEnSvcLoc.SetCheck(GETCHECKBOXVALUEFROMREG(m_binNumericRegistryEntries[GopPage_EnableSvcLoc].ulFieldValue));

	m_cboxLogAnon.SetCheck(GETCHECKBOXVALUEFROMREG(m_binNumericRegistryEntries[GopPage_LogAnonymous].ulFieldValue));
	
	m_cboxEnWais.SetCheck(GETCHECKBOXVALUEFROMREG(m_binNumericRegistryEntries[GopPage_CheckForWAISDB].ulFieldValue));
	
   	m_bSetChanged = TRUE;	// Any more changes come from the user
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CGOPGENP1::OnEnsvclocdata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[GopPage_EnableSvcLoc].bIsChanged = TRUE;
	   
	   m_binNumericRegistryEntries[GopPage_EnableSvcLoc].ulFieldValue = 
	      GETREGVALUEFROMCHECKBOX(m_cboxEnSvcLoc.GetCheck());

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
	
}

void CGOPGENP1::OnEnwaisdata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[GopPage_CheckForWAISDB].bIsChanged = TRUE;
	   
	   m_binNumericRegistryEntries[GopPage_CheckForWAISDB].ulFieldValue = 
	      GETREGVALUEFROMCHECKBOX(m_cboxEnWais.GetCheck());

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
	
}

void CGOPGENP1::OnLoganondata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[GopPage_LogAnonymous].bIsChanged = TRUE;
	   
	   m_binNumericRegistryEntries[GopPage_LogAnonymous].ulFieldValue = 
	      GETREGVALUEFROMCHECKBOX(m_cboxLogAnon.GetCheck());

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
	
}

void CGOPGENP1::SaveInfo()
{

if (m_bIsDirty) {
SaveNumericInfo(m_binNumericRegistryEntries, GopPage_TotalNumRegEntries);
}

CGenPage::SaveInfo();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\gopadvp1.h ===
// gopadvp1.h : header file
//

enum ADV_GOP_NUM_REG_ENTRIES {
	 AdvGopPage_DebugFlags,
	 AdvGopPage_TotalNumRegEntries
	 };

/////////////////////////////////////////////////////////////////////////////
// CGOPADVP1 dialog

class CGOPADVP1 : public CGenPage
{ 	
DECLARE_DYNCREATE(CGOPADVP1)

// Construction
public:
	CGOPADVP1();
	~CGOPADVP1();

// Dialog Data
	//{{AFX_DATA(CGOPADVP1)
	enum { IDD = IDD_GOPADVPAGE1 };
	CEdit	m_editGopDbgFlags;
	DWORD	m_ulGopDbgFlags;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGOPADVP1)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual	void SaveInfo(void);
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CGOPADVP1)
	afx_msg void OnChangeGopdbgflagsdata1();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG

	NUM_REG_ENTRY m_binNumericRegistryEntries[AdvGopPage_TotalNumRegEntries];

	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\isadmdoc.h ===
// ISAdmdoc.h : interface of the CISAdminDoc class
//
/////////////////////////////////////////////////////////////////////////////

class CISAdminDoc : public CDocument
{
protected: // create from serialization only
	CISAdminDoc();
	DECLARE_DYNCREATE(CISAdminDoc)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CISAdminDoc)
	public:
	virtual BOOL OnNewDocument();
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CISAdminDoc();
	virtual void Serialize(CArchive& ar);   // overridden for document i/o
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CISAdminDoc)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\gopgenp1.h ===
// gopgenp1.h : header file
//

enum  Gop_NUM_REG_ENTRIES {
     GopPage_EnableSvcLoc,
	 GopPage_LogAnonymous,
	 GopPage_CheckForWAISDB,
	 GopPage_TotalNumRegEntries
	 };




/////////////////////////////////////////////////////////////////////////////
// CGOPGENP1 dialog

class CGOPGENP1 : public CGenPage
{
	DECLARE_DYNCREATE(CGOPGENP1)

// Construction
public:
	CGOPGENP1();
	~CGOPGENP1();

// Dialog Data
	//{{AFX_DATA(CGOPGENP1)
	enum { IDD = IDD_GOPHERGENPAGE1 };
	CButton	m_cboxLogAnon;
	CButton	m_cboxEnWais;
	CButton	m_cboxEnSvcLoc;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CGOPGENP1)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual	void SaveInfo(void);
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CGOPGENP1)
	afx_msg void OnEnsvclocdata1();
	afx_msg void OnEnwaisdata1();
	afx_msg void OnLoganondata1();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	NUM_REG_ENTRY m_binNumericRegistryEntries[GopPage_TotalNumRegEntries];

	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\isadmin.cpp ===
// ISAdmin.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "ISAdmin.h"

#include "mainfrm.h"
#include "ISAdmdoc.h"
#include "ISAdmvw.h"
#include "formvw1.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CISAdminApp

BEGIN_MESSAGE_MAP(CISAdminApp, CWinApp)
	//{{AFX_MSG_MAP(CISAdminApp)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
	// Standard file based document commands
	ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
	ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
	// Standard print setup command
	ON_COMMAND(ID_FILE_PRINT_SETUP, CWinApp::OnFilePrintSetup)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CISAdminApp construction

CISAdminApp::CISAdminApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CISAdminApp object

CISAdminApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CISAdminApp initialization

BOOL CISAdminApp::InitInstance()
{
	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

	Enable3dControls();

	LoadStdProfileSettings();  // Load standard INI file options (including MRU)

	// Register the application's document templates.  Document templates
	//  serve as the connection between documents, frame windows and views.

	CSingleDocTemplate* pDocTemplate;
	pDocTemplate = new CSingleDocTemplate(
		IDR_MAINFRAME,
		RUNTIME_CLASS(CISAdminDoc),
		RUNTIME_CLASS(CMainFrame),       // main SDI frame window
	//	RUNTIME_CLASS(CISAdminView));
		RUNTIME_CLASS(CFormVw1));
	AddDocTemplate(pDocTemplate);

	// create a new (empty) document
	OnFileNew();

	if (m_lpCmdLine[0] != '\0')
	{
		// TODO: add command line processing here
	}



	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//{{AFX_MSG(CAboutDlg)
		// No message handlers
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CISAdminApp::OnAppAbout()
{
	CAboutDlg aboutDlg;
	aboutDlg.DoModal();

}

/////////////////////////////////////////////////////////////////////////////
// CISAdminApp commands
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\isadmdoc.cpp ===
// ISAdmdoc.cpp : implementation of the CISAdminDoc class
//

#include "stdafx.h"
#include "ISAdmin.h"

#include "ISAdmdoc.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CISAdminDoc

IMPLEMENT_DYNCREATE(CISAdminDoc, CDocument)

BEGIN_MESSAGE_MAP(CISAdminDoc, CDocument)
	//{{AFX_MSG_MAP(CISAdminDoc)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CISAdminDoc construction/destruction

CISAdminDoc::CISAdminDoc()
{
	// TODO: add one-time construction code here

}

CISAdminDoc::~CISAdminDoc()
{
}

BOOL CISAdminDoc::OnNewDocument()
{
	if (!CDocument::OnNewDocument())
		return FALSE;

	// TODO: add reinitialization code here
	// (SDI documents will reuse this document)

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CISAdminDoc serialization

void CISAdminDoc::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
		// TODO: add storing code here
	}
	else
	{
		// TODO: add loading code here
	}
}

/////////////////////////////////////////////////////////////////////////////
// CISAdminDoc diagnostics

#ifdef _DEBUG
void CISAdminDoc::AssertValid() const
{
	CDocument::AssertValid();
}

void CISAdminDoc::Dump(CDumpContext& dc) const
{
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CISAdminDoc commands
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\isadmin.h ===
// ISAdmin.h : main header file for the ISADMIN application
//

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols
#include "afxcmn.h"
#include "registry.h"
#include "gensheet.h"
#include "genpage.h"
#include <inetinfo.h>


// Registry defines

#define REGISTRY_ACCESS_RIGHTS STANDARD_RIGHTS_REQUIRED	| GENERIC_ALL
#define COMMON_REGISTRY_MAINKEY "System\\CurrentControlSet\\Services\\InetInfo\\Parameters"
#define FTP_REGISTRY_MAINKEY "System\\CurrentControlSet\\Services\\MSFTPSVC\\Parameters"
#define GOPHER_REGISTRY_MAINKEY "System\\CurrentControlSet\\Services\\GOPHERSVC\\Parameters"
#define WEB_REGISTRY_MAINKEY "System\\CurrentControlSet\\Services\\W3SVC\\Parameters"

// Useful macros

#define LESSOROF(p1,p2) ((p1) < (p2)) ? (p1) : (p2)


/////////////////////////////////////////////////////////////////////////////
// CISAdminApp:
// See ISAdmin.cpp for the implementation of this class
//

class CISAdminApp : public CWinApp
{
public:
	CISAdminApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CISAdminApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CISAdminApp)
	afx_msg void OnAppAbout();
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\isadmvw.cpp ===
// ISAdmvw.cpp : implementation of the CISAdminView class
//

#include "stdafx.h"
#include "ISAdmin.h"

#include "ISAdmdoc.h"
#include "ISAdmvw.h"
#include "mimemap1.h"
#include "scrmap1.h"
#include "ssl1.h"
//#include "combut1.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CISAdminView

IMPLEMENT_DYNCREATE(CISAdminView, CView)

BEGIN_MESSAGE_MAP(CISAdminView, CView)
	//{{AFX_MSG_MAP(CISAdminView)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
	// Standard printing commands
	ON_COMMAND(ID_FILE_PRINT, CView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_PREVIEW, CView::OnFilePrintPreview)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CISAdminView construction/destruction

CISAdminView::CISAdminView()
{
	// TODO: add construction code here

}

CISAdminView::~CISAdminView()
{
}

/////////////////////////////////////////////////////////////////////////////
// CISAdminView drawing

void CISAdminView::OnDraw(CDC* pDC)
{
	CISAdminDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);
/*					  
    CPropertySheet s(_T("Web Settings"));
	MIMEMAP1 MimePage;

	s.AddPage(&MimePage);

	ScrMap1 ScriptPage;

	s.AddPage(&ScriptPage);

	SSL1 SSLPage;

	s.AddPage(&SSLPage);

	s.DoModal();

*/

/*
CButton *pComButton;
DWORD dwBtnStyle = WS_CHILD | WS_VISIBLE | BS_PUSHBUTTON;
const RECT rect = {20, 20, 100, 100};

pComButton->Create("Common", dwBtnStyle, rect, , 12345);
*/

	// TODO: add draw code for native data here
}

/////////////////////////////////////////////////////////////////////////////
// CISAdminView printing

BOOL CISAdminView::OnPreparePrinting(CPrintInfo* pInfo)
{
	// default preparation
	return DoPreparePrinting(pInfo);
}

void CISAdminView::OnBeginPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
	// TODO: add extra initialization before printing
}

void CISAdminView::OnEndPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
	// TODO: add cleanup after printing
}

/////////////////////////////////////////////////////////////////////////////
// CISAdminView diagnostics

#ifdef _DEBUG
void CISAdminView::AssertValid() const
{
	CView::AssertValid();
}

void CISAdminView::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);
}

CISAdminDoc* CISAdminView::GetDocument() // non-debug version is inline
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CISAdminDoc)));
	return (CISAdminDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CISAdminView message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\isadmvw.h ===
// ISAdmvw.h : interface of the CISAdminView class
//
/////////////////////////////////////////////////////////////////////////////

class CISAdminView : public CView
{
protected: // create from serialization only
	CISAdminView();
	DECLARE_DYNCREATE(CISAdminView)

// Attributes
public:
	CISAdminDoc* GetDocument();

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CISAdminView)
	public:
	virtual void OnDraw(CDC* pDC);  // overridden to draw this view
	protected:
	virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
	virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CISAdminView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CISAdminView)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in ISAdmvw.cpp
inline CISAdminDoc* CISAdminView::GetDocument()
   { return (CISAdminDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\maindoc.cpp ===
// maindoc.cpp : implementation file
//

#include "stdafx.h"
#include "ISAdmin.h"
#include "maindoc.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// MAINDOC

IMPLEMENT_DYNCREATE(MAINDOC, CView)

MAINDOC::MAINDOC()
{
}

MAINDOC::~MAINDOC()
{
}


BEGIN_MESSAGE_MAP(MAINDOC, CView)
	//{{AFX_MSG_MAP(MAINDOC)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// MAINDOC drawing

void MAINDOC::OnDraw(CDC* pDC)
{
	CDocument* pDoc = GetDocument();
	// TODO: add draw code here
}

/////////////////////////////////////////////////////////////////////////////
// MAINDOC diagnostics

#ifdef _DEBUG
void MAINDOC::AssertValid() const
{
	CView::AssertValid();
}

void MAINDOC::Dump(CDumpContext& dc) const
{
	CView::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// MAINDOC message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\maindoc.h ===
// maindoc.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// MAINDOC view

class MAINDOC : public CView
{
protected:
	MAINDOC();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(MAINDOC)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(MAINDOC)
	protected:
	virtual void OnDraw(CDC* pDC);      // overridden to draw this view
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~MAINDOC();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
protected:
	//{{AFX_MSG(MAINDOC)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\mimemap1.cpp ===
// mimemap1.cpp : implementation file
//

#include "stdafx.h"
#include "afxcmn.h"
#include "ISAdmin.h"
#include "mimemap1.h"
#include "addmime.h"
#include "delmime.h"
#include "editmime.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// MIMEMAP1 property page

IMPLEMENT_DYNCREATE(MIMEMAP1, CGenPage)

MIMEMAP1::MIMEMAP1() : CGenPage(MIMEMAP1::IDD)
{
	//{{AFX_DATA_INIT(MIMEMAP1)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	m_rkMimeKey = NULL;
	m_pmeMimeMapList = NULL;
}

MIMEMAP1::~MIMEMAP1()
{
	if (m_rkMimeKey != NULL)
	   delete(m_rkMimeKey);
	DeleteMimeList();
}

void MIMEMAP1::DoDataExchange(CDataExchange* pDX)
{
	CGenPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(MIMEMAP1)
	DDX_Control(pDX, IDC_MIMEMAPLIST1, m_lboxMimeMapList);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(MIMEMAP1, CGenPage)
	//{{AFX_MSG_MAP(MIMEMAP1)
	ON_BN_CLICKED(IDC_MIMEMAPADDBUTTON, OnMimemapaddbutton)
	ON_BN_CLICKED(IDC_MIMEMAPREMOVEBUTTON, OnMimemapremovebutton)
	ON_BN_CLICKED(IDC_MIMEMAPEDITBUTTON, OnMimemapeditbutton)
	ON_LBN_DBLCLK(IDC_MIMEMAPLIST1, OnDblclkMimemaplist1)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// MIMEMAP1 message handlers

BOOL MIMEMAP1::OnInitDialog() 
{
	CGenPage::OnInitDialog();
/*
CMimeMap mimeTestMime(_T("mimetype,fileextension,imagefile,g"));
CMimeMap *pmimeTestMimePtr;
*/
CString strNextValue;
BOOL bAllocationError = FALSE;
int	lpiTabStops[2];

	CRegValueIter *rviMimeKeys;
	DWORD err, ulRegType;

lpiTabStops[0] = 58;
lpiTabStops[1] = 191;

m_ulMimeIndex = 0;

m_lboxMimeMapList.SetTabStops(2,lpiTabStops);

m_bMimeEntriesExist = FALSE;

m_rkMimeKey = new CRegKey(*m_rkMainKey,_T("MimeMap"),REGISTRY_ACCESS_RIGHTS);

// Anything under this key should be a mime mapping. 
// No way to verify that, but non-string entries are invalid
// so ignore them

if (m_rkMimeKey != NULL) {
   if (*m_rkMimeKey != NULL) {
      if (rviMimeKeys = new CRegValueIter(*m_rkMimeKey)) {
         while ((err = rviMimeKeys->Next(&strNextValue, &ulRegType)) == ERROR_SUCCESS) {
		    if (ulRegType == REG_SZ) {
		       if (!AddMimeEntry(strNextValue))
			      bAllocationError = TRUE;
			}
   		 }
		 delete (rviMimeKeys);
	  }	
	  m_bMimeEntriesExist = TRUE;
   }
}


if (!m_bMimeEntriesExist) {				//Can't open registry key
   CString strNoMimeEntriesMsg;
   strNoMimeEntriesMsg.LoadString(IDS_MIMENOMIMEENTRIESMSG);
   AfxMessageBox(strNoMimeEntriesMsg);
}

if (bAllocationError) {				//Error adding one or more entries
   CString strAllocFailMsg;
   strAllocFailMsg.LoadString(IDS_MIMEENTRIESALLOCFAILMSG);
   AfxMessageBox(strAllocFailMsg);
}


/*
strTestString = _T("mimetype,fileextension,,g");

pmimeTestMimePtr = new CMimeMap(strTestString);

strTestString = mimeTestMime;
*/
	// TODO: Add extra initialization here
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void MIMEMAP1::OnMimemapaddbutton() 
{
	// TODO: Add your control notification handler code here
if (m_bMimeEntriesExist) {
   CAddMime addmimeGetInfo(this);	

   if (addmimeGetInfo.DoModal() == IDOK) {
      if (AddMimeEntry(addmimeGetInfo.GetFileExtension(), addmimeGetInfo.GetMimeType(), addmimeGetInfo.GetImageFile(),
         addmimeGetInfo.GetGopherType())) {
         m_bIsDirty = TRUE;
         SetModified(TRUE);
	  }
	  else {
         CString strAllocFailMsg;
         strAllocFailMsg.LoadString(IDS_MIMEENTRYALLOCFAILMSG);
         AfxMessageBox(strAllocFailMsg);
	  }
   }
}
else {
   CString strNoMimeEntriesMsg;
   strNoMimeEntriesMsg.LoadString(IDS_MIMENOMIMEENTRIESMSG);
   AfxMessageBox(strNoMimeEntriesMsg);
}
}


void MIMEMAP1::OnMimemapremovebutton() 
{
	// TODO: Add your control notification handler code here
if (m_bMimeEntriesExist) {
   int iCurSel;
   CDelMime delmimeGetInfo(this);

   if ((iCurSel = m_lboxMimeMapList.GetCurSel())	!= LB_ERR) {
      if (delmimeGetInfo.DoModal() == IDOK) {
         DeleteMimeMapping(iCurSel);
	     m_bIsDirty = TRUE;
	     SetModified(TRUE);
      }
   }
   else {
      CString strNoHighlightMsg;
      strNoHighlightMsg.LoadString(IDS_NOHIGHLIGHTMSG);
      AfxMessageBox(strNoHighlightMsg);
   }
}
else {
   CString strNoMimeEntriesMsg;
   strNoMimeEntriesMsg.LoadString(IDS_MIMENOMIMEENTRIESMSG);
   AfxMessageBox(strNoMimeEntriesMsg);
}
}

void MIMEMAP1::OnMimemapeditbutton() 
{
	// TODO: Add your control notification handler code here
if (m_bMimeEntriesExist) {
   int iCurSel;
   PMIME_ENTRY pmeEditEntry;


   if ((iCurSel = m_lboxMimeMapList.GetCurSel())	!= LB_ERR) {
      for (pmeEditEntry = m_pmeMimeMapList;(pmeEditEntry != NULL) && 
         (m_lboxMimeMapList.GetItemData(iCurSel) != pmeEditEntry->iListIndex);
         pmeEditEntry = pmeEditEntry->NextPtr)
         ;
   
      ASSERT (pmeEditEntry != NULL);

      CEditMime editmimeGetInfo(this, 
         pmeEditEntry->mimeData->GetFileExtension(),
         pmeEditEntry->mimeData->GetMimeType(),
         pmeEditEntry->mimeData->GetImageFile(),
         pmeEditEntry->mimeData->GetGopherType());

      if (editmimeGetInfo.DoModal() == IDOK) {
         if (EditMimeMapping(iCurSel, 
   	          pmeEditEntry,
              editmimeGetInfo.GetFileExtension(), 
              editmimeGetInfo.GetMimeType(), 
              editmimeGetInfo.GetImageFile(),
              editmimeGetInfo.GetGopherType() )) {
            m_bIsDirty = TRUE;
	        SetModified(TRUE);
		 }
		 else {
            CString strEditErrorMsg;
            strEditErrorMsg.LoadString(IDS_MIMEEDITERRORMSG);
            AfxMessageBox(strEditErrorMsg);
		 }
      }
   }
   else {
      CString strNoHighlightMsg;
      strNoHighlightMsg.LoadString(IDS_NOHIGHLIGHTMSG);
      AfxMessageBox(strNoHighlightMsg);
   }
}
else {
   CString strNoMimeEntriesMsg;
   strNoMimeEntriesMsg.LoadString(IDS_MIMENOMIMEENTRIESMSG);
   AfxMessageBox(strNoMimeEntriesMsg);
}
}

void MIMEMAP1::OnDblclkMimemaplist1() 
{
	// TODO: Add your control notification handler code here
OnMimemapeditbutton();	
}

////////////////////////////////////////////////////////////////////////////////
// Other Functions


void MIMEMAP1::SaveInfo()
{
PMIME_ENTRY pmeSaveEntry;
CString strDummyValue(_T(""));
if (m_bIsDirty) {
   for (pmeSaveEntry = m_pmeMimeMapList;(pmeSaveEntry != NULL); pmeSaveEntry = pmeSaveEntry->NextPtr) {
      if (pmeSaveEntry->DeleteCurrent) {
	  	 m_rkMimeKey->DeleteValue(pmeSaveEntry->mimeData->GetPrevMimeMap());
		 pmeSaveEntry->DeleteCurrent = FALSE;
 	  }
      
      if (pmeSaveEntry->WriteNew) {
         m_rkMimeKey->SetValue(*(pmeSaveEntry->mimeData), strDummyValue);
		 pmeSaveEntry->mimeData->SetPrevMimeMap();
		 pmeSaveEntry->WriteNew = FALSE;
	  }
   }

}

CGenPage::SaveInfo();

}


//This version is called for existing entries
BOOL MIMEMAP1::AddMimeEntry(CString &strNewMimeMap)
{
PMIME_ENTRY pmeNewEntry;
int iCurSel;
BOOL bretcode = FALSE;

if ((pmeNewEntry = new MIME_ENTRY) != NULL) {

   if ((pmeNewEntry->mimeData = new CMimeMap(strNewMimeMap)) != NULL) {
      iCurSel = m_lboxMimeMapList.AddString(pmeNewEntry->mimeData->GetDisplayString()); 
	  if ((iCurSel != LB_ERR) && (iCurSel != LB_ERRSPACE)) {
         pmeNewEntry->DeleteCurrent = FALSE;
         pmeNewEntry->WriteNew = FALSE;
         m_lboxMimeMapList.SetItemData(iCurSel,m_ulMimeIndex);
         pmeNewEntry->iListIndex = m_ulMimeIndex++;
         pmeNewEntry->NextPtr = m_pmeMimeMapList;
         m_pmeMimeMapList = pmeNewEntry;
	     bretcode = TRUE;
	  }
	  else {
	     delete (pmeNewEntry->mimeData);
		 delete (pmeNewEntry);
	  }
   }
   else
      delete (pmeNewEntry);
}
return (bretcode);
}


// This version is called for new entries so set the write flag.
BOOL MIMEMAP1::AddMimeEntry(LPCTSTR pchFileExtension, LPCTSTR pchMimeType, LPCTSTR pchImageFile, LPCTSTR pchGoperType)
{
PMIME_ENTRY pmeNewEntry;
int iCurSel;
BOOL bretcode = FALSE;

if ((pmeNewEntry = new MIME_ENTRY) != NULL) {

   if ((pmeNewEntry->mimeData = new CMimeMap(pchFileExtension, pchMimeType, pchImageFile, pchGoperType)) != NULL) {
      iCurSel = m_lboxMimeMapList.AddString(pmeNewEntry->mimeData->GetDisplayString()); 
	  if ((iCurSel != LB_ERR) && (iCurSel != LB_ERRSPACE)) {
         pmeNewEntry->DeleteCurrent = FALSE;
         pmeNewEntry->WriteNew = TRUE;
         m_lboxMimeMapList.SetItemData(iCurSel,m_ulMimeIndex);
	     m_lboxMimeMapList.SetCurSel(iCurSel);
         pmeNewEntry->iListIndex = m_ulMimeIndex++;
         pmeNewEntry->NextPtr = m_pmeMimeMapList;
         m_pmeMimeMapList = pmeNewEntry;
	     bretcode = TRUE;
	  }
	  else {
	     delete (pmeNewEntry->mimeData);
		 delete (pmeNewEntry);
	  }
   }
   else
      delete (pmeNewEntry);
}
return (bretcode);
}

void MIMEMAP1::DeleteMimeList()
{
PMIME_ENTRY pmeCurEntry;

while (m_pmeMimeMapList != NULL) {
   delete (m_pmeMimeMapList->mimeData);
   pmeCurEntry = m_pmeMimeMapList;
   m_pmeMimeMapList = m_pmeMimeMapList->NextPtr;
   delete (pmeCurEntry);
}
}

void MIMEMAP1::DeleteMimeMapping(int iCurSel)
{
PMIME_ENTRY pmeDelEntry;
for (pmeDelEntry = m_pmeMimeMapList;(pmeDelEntry != NULL) && 
   (m_lboxMimeMapList.GetItemData(iCurSel) != pmeDelEntry->iListIndex);
   pmeDelEntry = pmeDelEntry->NextPtr)
   ;
ASSERT (pmeDelEntry != NULL);

if (pmeDelEntry->mimeData->PrevMimeMapExists())
   pmeDelEntry->DeleteCurrent = TRUE;
pmeDelEntry->WriteNew = FALSE;			
m_lboxMimeMapList.DeleteString(iCurSel);
}
    

BOOL MIMEMAP1::EditMimeMapping(int iCurSel, 
   PMIME_ENTRY pmeEditEntry, 
   LPCTSTR pchFileExtension, 
   LPCTSTR pchMimeType, 
   LPCTSTR pchImageFile, 
   LPCTSTR pchGopherType)
{
BOOL bretcode = FALSE;

pmeEditEntry->mimeData->SetFileExtension(pchFileExtension);
pmeEditEntry->mimeData->SetMimeType(pchMimeType);
pmeEditEntry->mimeData->SetImageFile(pchImageFile);
pmeEditEntry->mimeData->SetGopherType(pchGopherType);

m_lboxMimeMapList.DeleteString(iCurSel); 		// Delete first so memory is freed
iCurSel = m_lboxMimeMapList.AddString(pmeEditEntry->mimeData->GetDisplayString()); 

// There error case on this is incredibly rare, so don't bother saving and restoring the above fields
// Just don't set flags so registry is not updated.

if ((iCurSel != LB_ERR) && (iCurSel != LB_ERRSPACE)) {
   m_lboxMimeMapList.SetItemData(iCurSel,pmeEditEntry->iListIndex);
   if (pmeEditEntry->mimeData->PrevMimeMapExists())
      pmeEditEntry->DeleteCurrent = TRUE;
   
   pmeEditEntry->WriteNew = TRUE;
   bretcode = TRUE;
} 

return (bretcode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\mainfrm.h ===
// mainfrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

class CMainFrame : public CFrameWnd
{
protected: // create from serialization only
	CMainFrame();
	DECLARE_DYNCREATE(CMainFrame)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	protected:
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // control bar embedded members
	CStatusBar  m_wndStatusBar;
	CToolBar    m_wndToolBar;

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\mainfrm.cpp ===
// mainfrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"
#include "ISAdmin.h"

#include "mainfrm.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
	//{{AFX_MSG_MAP(CMainFrame)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
	// Global help commands
	ON_COMMAND(ID_HELP_INDEX, CFrameWnd::OnHelpIndex)
	ON_COMMAND(ID_HELP_USING, CFrameWnd::OnHelpUsing)
	ON_COMMAND(ID_HELP, CFrameWnd::OnHelp)
	ON_COMMAND(ID_CONTEXT_HELP, CFrameWnd::OnContextHelp)
	ON_COMMAND(ID_DEFAULT_HELP, CFrameWnd::OnHelpIndex)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// arrays of IDs used to initialize control bars
	
// toolbar buttons - IDs are command buttons
static UINT BASED_CODE buttons[] =
{
	// same order as in the bitmap 'toolbar.bmp'
//	ID_FILE_NEW,
//	ID_FILE_OPEN,
//	ID_FILE_SAVE,
//		ID_SEPARATOR,
	ID_EDIT_CUT,
	ID_EDIT_COPY,
	ID_EDIT_PASTE,
		ID_SEPARATOR,
//	ID_FILE_PRINT,
	ID_APP_ABOUT,
	ID_HELP,
};

static UINT BASED_CODE indicators[] =
{
	ID_SEPARATOR,           // status line indicator
	ID_INDICATOR_CAPS,
	ID_INDICATOR_NUM,
	ID_INDICATOR_SCRL,
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
	// TODO: add member initialization code here
	
}

CMainFrame::~CMainFrame()
{
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
	if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	if (!m_wndToolBar.Create(this) ||
		!m_wndToolBar.LoadBitmap(IDR_MAINFRAME) ||
		!m_wndToolBar.SetButtons(buttons,
		  sizeof(buttons)/sizeof(UINT)))
	{
		TRACE0("Failed to create toolbar\n");
		return -1;      // fail to create
	}

	if (!m_wndStatusBar.Create(this) ||
		!m_wndStatusBar.SetIndicators(indicators,
		  sizeof(indicators)/sizeof(UINT)))
	{
		TRACE0("Failed to create status bar\n");
		return -1;      // fail to create
	}

	// TODO: Delete these three lines if you don't want the toolbar to
	//  be dockable
	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	EnableDocking(CBRS_ALIGN_ANY);
	DockControlBar(&m_wndToolBar);

	// TODO: Remove this if you don't want tool tips
	m_wndToolBar.SetBarStyle(m_wndToolBar.GetBarStyle() |
		CBRS_TOOLTIPS | CBRS_FLYBY);

	return 0;
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
	CFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs) 
{
	// TODO: Add your specialized code here and/or call the base class
    cs.style &= ~((LONG)FWS_ADDTOTITLE);
	
	return CFrameWnd::PreCreateWindow(cs);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\mimemap1.h ===
// mimemap1.h : header file
//
#include "mimemapc.h"

typedef struct _MIME_ENTRY {
   struct _MIME_ENTRY	*NextPtr;
   CMimeMap				*mimeData;
   DWORD				iListIndex;
   BOOL					DeleteCurrent;
   BOOL					WriteNew;
   } MIME_ENTRY, *PMIME_ENTRY;


/////////////////////////////////////////////////////////////////////////////
// MIMEMAP1 dialog

class MIMEMAP1 : public CGenPage
{
	DECLARE_DYNCREATE(MIMEMAP1)

// Construction
public:
	MIMEMAP1();
	~MIMEMAP1();

// Dialog Data
	//{{AFX_DATA(MIMEMAP1)
	enum { IDD = IDD_MIMEMAP1 };
	CListBox	m_lboxMimeMapList;
	//}}AFX_DATA

	CRegKey *m_rkMimeKey;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(MIMEMAP1)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual	void SaveInfo(void);
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(MIMEMAP1)
	virtual BOOL OnInitDialog();
	afx_msg void OnMimemapaddbutton();
	afx_msg void OnMimemapremovebutton();
	afx_msg void OnMimemapeditbutton();
	afx_msg void OnDblclkMimemaplist1();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	BOOL AddMimeEntry(CString &);
	BOOL AddMimeEntry(LPCTSTR pchFileExtension, LPCTSTR pchMimeType, LPCTSTR pchImageFile, LPCTSTR pchGoperType);
	void DeleteMimeList();
	void DeleteMimeMapping(int iCurSel);
	BOOL EditMimeMapping(int iCurSel, PMIME_ENTRY pmeEditEntry, LPCTSTR pchFileExtension, LPCTSTR pchMimeType, 
	   LPCTSTR pchImageFile, LPCTSTR pchGopherType);

	DWORD	m_ulMimeIndex;
	BOOL	m_bMimeEntriesExist;
	PMIME_ENTRY m_pmeMimeMapList;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\mimemapc.cpp ===
#include "stdafx.h"
#include "mimemapc.h"


CMimeMap::CMimeMap ( LPCTSTR pchOriginalMimeMap) 
{
	CString strOriginalMimeMap = pchOriginalMimeMap;
	int iCharIndex;

//Save this away and never change it.
	m_strPrevMimeMap = pchOriginalMimeMap;

	if ((iCharIndex = strOriginalMimeMap.Find(',')) != -1) {
	   m_strMimeType = strOriginalMimeMap.Left(iCharIndex);
	   strOriginalMimeMap = strOriginalMimeMap.Mid(iCharIndex + 1);
	}
	else {
	   m_strMimeType = strOriginalMimeMap;
	   strOriginalMimeMap = _T("");
	}

	if ((iCharIndex = strOriginalMimeMap.Find(',')) != -1) {
	   m_strFileExtension = strOriginalMimeMap.Left(iCharIndex);
	   strOriginalMimeMap = strOriginalMimeMap.Mid(iCharIndex + 1);
	}
	else {
	   m_strFileExtension = strOriginalMimeMap;
	   strOriginalMimeMap = _T("");
	}

	if ((iCharIndex = strOriginalMimeMap.Find(',')) != -1) {
	   m_strImageFile = strOriginalMimeMap.Left(iCharIndex);
	   strOriginalMimeMap = strOriginalMimeMap.Mid(iCharIndex + 1);
	}
	else {
	   m_strImageFile = strOriginalMimeMap;
	   strOriginalMimeMap = _T("");
	}

	m_strGopherType = strOriginalMimeMap;
}

CMimeMap::CMimeMap ( LPCTSTR pchFileExtension, LPCTSTR pchMimeType, LPCTSTR pchImageFile, LPCTSTR pchGopherType) 
{

	m_strPrevMimeMap = _T("");

	m_strMimeType = pchMimeType;
	SetFileExtension(pchFileExtension);
	m_strImageFile = pchImageFile;
	m_strGopherType = pchGopherType;
}


	

	


CMimeMap::~CMimeMap()
{
}

void CMimeMap::SetMimeType(LPCTSTR pchMimeType)
{
	m_strMimeType = pchMimeType;
}
 
LPCTSTR CMimeMap::GetMimeType()
{
	return (m_strMimeType);
}

void CMimeMap::SetGopherType(LPCTSTR pchGopherType)
{
	m_strGopherType = pchGopherType;
}


LPCTSTR CMimeMap::GetGopherType()
{
	return (m_strGopherType);
}

void CMimeMap::SetImageFile(LPCTSTR pchImageFile)
{
	m_strImageFile = pchImageFile;
}


LPCTSTR CMimeMap::GetImageFile()
{
	return(m_strImageFile);
}


void CMimeMap::SetFileExtension(LPCTSTR pchFileExtension)
{
	CString strTempFileExtension = pchFileExtension;
	CheckDot(strTempFileExtension);
	m_strFileExtension = strTempFileExtension;
}

LPCTSTR CMimeMap::GetFileExtension()
{
	return(m_strFileExtension);
}

LPCTSTR CMimeMap::GetPrevMimeMap()
{
	return(m_strPrevMimeMap);
}

void CMimeMap::SetPrevMimeMap()
{
	m_strPrevMimeMap = GetMimeMapping();
}

BOOL CMimeMap::PrevMimeMapExists()
{
return (m_strPrevMimeMap != _T(""));
}


////////////////////////////////////////////////////////////////////////////////
// Private functions

LPCTSTR CMimeMap::GetMimeMapping()
{
m_strCurrentMimeMap = m_strMimeType;
m_strCurrentMimeMap += _T(",");
m_strCurrentMimeMap += m_strFileExtension;
m_strCurrentMimeMap += _T(",");
m_strCurrentMimeMap += m_strImageFile;
m_strCurrentMimeMap += _T(",");
m_strCurrentMimeMap += m_strGopherType;
return (m_strCurrentMimeMap);
}

LPCTSTR CMimeMap::GetDisplayString()
{
m_strDisplayString = m_strFileExtension;
m_strDisplayString += _T("\t");
m_strDisplayString += m_strMimeType;
m_strDisplayString += _T("\t");
m_strDisplayString += m_strGopherType;
return (m_strDisplayString);
}

void CMimeMap::CheckDot(CString &strFileExtension)
{
if (strFileExtension.Left(1) == _T(".")) {
   CString strTemp = strFileExtension.Mid(1);
   strFileExtension = strTemp;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\mimemapc.h ===
/****************************************************************************
MIMEMAPC.H	
Mime Map Class Definition
****************************************************************************/
#ifndef _mimemapc_h 

#define _mimemapc_h


//  Forward declarations
class CMimeMap ;

//  Maximum size of a Registry class name
#define CREGKEY_MAX_CLASS_NAME MAX_PATH

//  Wrapper for a Registry key handle.

class CMimeMap : public CObject
{
protected:

	CString m_strPrevMimeMap;
	CString m_strCurrentMimeMap;
	CString m_strDisplayString;
	CString	m_strMimeType;
	CString m_strGopherType;
	CString m_strImageFile;
	CString m_strFileExtension;

	LPCTSTR GetMimeMapping();
	void CheckDot(CString &pchFileExtension);

public:
    //  Standard constructor
    CMimeMap ( LPCTSTR pchOriginalMimeMap) ;
	CMimeMap ( LPCTSTR pchFileExtension, LPCTSTR pchMimeType, LPCTSTR pchImageFile, LPCTSTR pchGopherType);
	~CMimeMap();
    //  Allow a CRegKey to be used anywhere an HKEY is required.
    operator LPCTSTR ()
        { return GetMimeMapping(); }

	void SetMimeType(LPCTSTR);
	LPCTSTR GetMimeType();
	void SetGopherType(LPCTSTR);
	LPCTSTR GetGopherType();
	void SetImageFile(LPCTSTR);
	LPCTSTR GetImageFile();
	void SetFileExtension(LPCTSTR);
	LPCTSTR GetFileExtension();
	void SetPrevMimeMap();
	LPCTSTR GetPrevMimeMap();
	BOOL PrevMimeMapExists();
	LPCTSTR GetDisplayString();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\registry.cpp ===
#include "stdafx.h"
#include <stdlib.h>
#include <memory.h>
#include <ctype.h>
#include "registry.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

CRegKey::CRegKey (
    HKEY hKeyBase,
    LPCTSTR pchSubKey,
    REGSAM regSam,
    LPCTSTR pchServerName
    )
    : m_hKey(NULL),
      m_dwDisposition(0)
{
    HKEY hkBase = NULL ;
    LONG err = ERROR_SUCCESS;

    if ( pchServerName != NULL)
    {
        //
        // This is a remote connection.
        //
        err = ::RegConnectRegistry((LPTSTR)pchServerName, hKeyBase, &hkBase);
        if (err != ERROR_SUCCESS)
        {
            hkBase = NULL ;
        }

        // hkBase == NULL ;
    }
    else
    {
        hkBase = hKeyBase ;
    }

    if (err == ERROR_SUCCESS)
    {
        if ( pchSubKey )
        {
            err = ::RegOpenKeyEx( hkBase, pchSubKey, 0, regSam, & m_hKey ) ;
        }
        else
        {
            m_hKey = hkBase ;
            hkBase = NULL ;
        }

        if ( hkBase && hkBase != hKeyBase )
        {
            ::RegCloseKey( hkBase ) ;
        }
    }

    if ( err != ERROR_SUCCESS)
    {
        m_hKey = NULL ;
    }
}

//
//  Constructor creating a new key.
//
CRegKey::CRegKey (
    LPCTSTR pchSubKey,
    HKEY hKeyBase,
    DWORD dwOptions,
    REGSAM regSam,
    LPSECURITY_ATTRIBUTES pSecAttr,
    LPCTSTR pchServerName
    )
    : m_hKey(NULL),
      m_dwDisposition(0)
{
    HKEY hkBase = NULL ;
    LONG err = 0;

    if (pchServerName != NULL)
    {
        //
        // This is a remote connection.
        //
        err = ::RegConnectRegistry((LPTSTR)pchServerName, hKeyBase, & hkBase);
        if (err != ERROR_SUCCESS)
        {
            hkBase = NULL;
        }

        // hkBase == NULL;
    }
    else
    {
        hkBase = hKeyBase ;
    }

    if (err == ERROR_SUCCESS)
    {
        LPCTSTR szEmpty = _T("") ;

        err = ::RegCreateKeyEx( hkBase, pchSubKey, 0, (TCHAR *) szEmpty,
            dwOptions, regSam, pSecAttr, &m_hKey, &m_dwDisposition );
    }
    if (err != ERROR_SUCCESS)
    {
        m_hKey = NULL ;
    }
}

CRegKey::~CRegKey()
{
    if (m_hKey != NULL)
    {
        ::RegCloseKey( m_hKey ) ;
    }
}

//
//  Prepare to read a value by finding the value's size.
//
LONG
CRegKey :: PrepareValue (
    LPCTSTR pchValueName,
    DWORD * pdwType,
    DWORD * pcbSize,
    BYTE ** ppbData
    )
{
    LONG err = 0 ;

    BYTE chDummy[2] ;
    DWORD cbData = 0 ;

    do
    {
        //
        //  Set the resulting buffer size to 0.
        //
        *pcbSize = 0 ;
        *ppbData = NULL ;

        err = ::RegQueryValueEx(*this, (LPTSTR) pchValueName,
            0, pdwType, chDummy, &cbData);

        //
        //  The only error we should get here is ERROR_MORE_DATA, but
        //  we may get no error if the value has no data.
        //
        if (err == ERROR_SUCCESS)
        {
            cbData = sizeof(LONG);  //  Just a fudgy number
        }
        else
        {
            if ( err != ERROR_MORE_DATA )
            {
                break;
            }
        }

        //
        //  Allocate a buffer large enough for the data.
        //
        *ppbData = new BYTE [ (*pcbSize = cbData) + sizeof (LONG) ] ;

        if ( *ppbData == NULL )
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
            break ;
        }

        //
        //  Now that have a buffer, re-fetch the value.
        //
        err = ::RegQueryValueEx( *this, (LPTSTR)pchValueName,
            0, pdwType, *ppbData, pcbSize );

    } while (FALSE);

    if (err != ERROR_SUCCESS)
    {
        delete [] *ppbData;
    }

    return err;
}

//
//  Overloaded value query members; each returns ERROR_INVALID_PARAMETER
//  if data exists but not in correct form to deliver into result object.
//
LONG
CRegKey::QueryValue (
    const TCHAR * pchValueName,
    CString &strResult
    )
{
    LONG err = 0;

    DWORD dwType;
    DWORD cbData;
    BYTE * pabData = NULL;

    do
    {
        if ( err = PrepareValue( pchValueName, & dwType, & cbData, & pabData ) )
        {
            break;
        }

        if ( dwType != REG_SZ )
        {
            err = ERROR_INVALID_PARAMETER ;
            break ;
        }

        //
        //  Guarantee that the data looks like a string
        //
        pabData[cbData] = 0 ;

        //
        //  Catch exceptions trying to assign to the caller's string
        //
        TRY
        {
            strResult = (TCHAR *) pabData ;
        }
        CATCH_ALL(e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL
    }
    while (FALSE);

    delete [] pabData ;

    return err ;
}

LONG
CRegKey::QueryValue (
    LPCTSTR pchValueName,
    CStringList &strList
    )
{
    LONG err = 0;

    DWORD dwType;
    DWORD cbData;
    BYTE * pabData = NULL;
    LPTSTR pbTemp, pbTempLimit;

    do
    {
        if ( err = PrepareValue( pchValueName, & dwType, & cbData, & pabData ))
        {
            break;
        }

        if ( dwType != REG_MULTI_SZ )
        {
            err = ERROR_INVALID_PARAMETER ;
            break ;
        }

        //
        //  Guarantee that the trailing data looks like a string
        //
        pabData[cbData] = 0 ;
        pbTemp = (TCHAR *) pabData ;
        pbTempLimit = & pbTemp[cbData] ;

        //
        //  Catch exceptions trying to build the list
        //
        TRY
        {
            for ( /**/ ; pbTemp < pbTempLimit ; /**/ )
            {
                strList.AddTail( pbTemp ) ;
                pbTemp += ::_tcslen( pbTemp ) + sizeof(TCHAR) ;
            }
        }
        CATCH_ALL(e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL
    }
    while ( FALSE );

    delete [] pabData ;

    return err;
}

LONG
CRegKey :: QueryValue (
    LPCTSTR pchValueName,
    DWORD &dwResult
    )
{
    LONG err = 0 ;

    DWORD dwType ;
    DWORD cbData ;
    BYTE * pabData = NULL ;

    do
    {
        if ( err = PrepareValue( pchValueName, & dwType, & cbData, & pabData ) )
        {
            break ;
        }

        if ( dwType != REG_DWORD || cbData != sizeof dwResult )
        {
            err = ERROR_INVALID_PARAMETER ;
            break ;
        }

        dwResult = *((DWORD *) pabData) ;
    }
    while ( FALSE ) ;

    delete [] pabData ;

    return err ;
}

LONG
CRegKey :: QueryValue (
    LPCTSTR pchValueName,
    CByteArray &abResult
    )
{
    LONG err = 0 ;

    DWORD dwType ;
    DWORD cbData ;
    BYTE * pabData = NULL ;

    do
    {
        if ( err = PrepareValue( pchValueName, & dwType, & cbData, & pabData ) )
        {
            break ;
        }

        if ( dwType != REG_BINARY )
        {
            err = ERROR_INVALID_PARAMETER ;
            break ;
        }

        //
        //  Catch exceptions trying to grow the result array
        //
        TRY
        {
            abResult.SetSize( cbData ) ;
        }
        CATCH_ALL(e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL

        if ( err != ERROR_SUCCESS)
        {
            break ;
        }

        //
        //  Move the data to the result array.
        //
        for ( DWORD i = 0 ; i < cbData ; ++i )
        {
            abResult[i] = pabData[i] ;
        }
    }
    while ( FALSE ) ;

    delete [] pabData ;

    return err ;
}

LONG
CRegKey::QueryValue (
    LPCTSTR pchValueName,
    void * pvResult,
    DWORD cbSize
    )
{
    LONG err = 0 ;

    DWORD dwType ;
    DWORD cbData ;
    BYTE * pabData = NULL ;

    do
    {
        if ( err = PrepareValue( pchValueName, & dwType, & cbData, & pabData ) )
        {
            break;
        }

        if ( dwType != REG_BINARY )
        {
            err = ERROR_INVALID_PARAMETER ;
            break ;
        }

        if ( cbSize < cbData )
        {
            err = ERROR_MORE_DATA;
            break;
        }

        ::memcpy(pvResult, pabData, cbData);
    }
    while ( FALSE ) ;

    delete [] pabData ;

    return err ;
}

//
//  Overloaded value setting members.
//
LONG
CRegKey::SetValue (
    LPCTSTR pchValueName,
    CString & strResult
    )
{
    return ::RegSetValueEx( *this, pchValueName, 0, REG_SZ,
        (const BYTE *) (const TCHAR *) strResult, strResult.GetLength() + 1 );
}

LONG
CRegKey :: SetValue (
    LPCTSTR pchValueName,
    CStringList & strList
    )
{
    LONG err = 0;

    DWORD cbSize ;
    BYTE * pbData = NULL ;

    err = FlattenValue( strList, & cbSize, & pbData ) ;

    if ( err == ERROR_SUCCESS )
    {
        err = ::RegSetValueEx(*this, pchValueName, 0, REG_MULTI_SZ, pbData, cbSize);
    }

    delete pbData ;

    return err ;
}

LONG
CRegKey::SetValue (
    LPCTSTR pchValueName,
    DWORD &dwResult
    )
{
    return ::RegSetValueEx(*this, pchValueName, 0, REG_DWORD,
        (const BYTE *) & dwResult, sizeof dwResult);
}

LONG
CRegKey::SetValue (
    LPCTSTR pchValueName,
    CByteArray & abResult
    )
{
    LONG err = 0;

    DWORD cbSize ;
    BYTE * pbData = NULL ;

    err = FlattenValue(abResult, &cbSize, &pbData);

    if (err == ERROR_SUCCESS)
    {
        err = ::RegSetValueEx(*this, pchValueName,
            0,REG_BINARY, pbData, cbSize);
    }

    delete pbData;

    return err;
}

LONG
CRegKey::SetValue (
    LPCTSTR pchValueName,
    void * pvResult,
    DWORD cbSize
    )
{
    return ::RegSetValueEx( *this, pchValueName,
        0, REG_BINARY, (const BYTE *)pvResult, cbSize );
}

LONG
CRegKey::DeleteValue (
    LPCTSTR pchValueName
    )
{
    return ::RegDeleteValue( *this, (LPTSTR) pchValueName);
}





LONG
CRegKey::FlattenValue (
    CStringList & strList,
    DWORD * pcbSize,
    BYTE ** ppbData
    )
{
    LONG err = 0 ;

    POSITION pos ;
    CString * pstr ;
    int cbTotal = 0 ;

    //
    //  Walk the list accumulating sizes
    //
    for (pos = strList.GetHeadPosition();
         pos != NULL && (pstr = & strList.GetNext( pos )) ; /**/ )
    {
        cbTotal += pstr->GetLength() + 1;
    }

    //
    //  Allocate and fill a temporary buffer
    //
    if (*pcbSize = cbTotal)
    {
        TRY
        {
            *ppbData = new BYTE[ *pcbSize ] ;

            BYTE * pbData = *ppbData ;

            //
            //  Populate the buffer with the strings.
            //
            for (pos = strList.GetHeadPosition();
                 pos != NULL && (pstr = & strList.GetNext( pos )) ; /**/ )
            {
                int cb = pstr->GetLength() + 1 ;
                ::memcpy( pbData, (LPCTSTR) *pstr, cb );
                pbData += cb ;
            }
        }
        CATCH_ALL(e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL
    }
    else
    {
        *ppbData = NULL;
    }

    return err ;
}

LONG
CRegKey::FlattenValue(
    CByteArray & abData,
    DWORD * pcbSize,
    BYTE ** ppbData
    )
{
    LONG err = 0 ;

    DWORD i ;

    //
    //  Allocate and fill a temporary buffer
    //
    if (*pcbSize = (DWORD)abData.GetSize())
    {
        TRY
        {
            *ppbData = new BYTE[*pcbSize] ;

            for ( i = 0 ; i < *pcbSize ; i++ )
            {
                (*ppbData)[i] = abData[i] ;
            }

        }
        CATCH_ALL(e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL
    }
    else
    {
        *ppbData = NULL;
    }

    return err;
}


LONG
CRegKey::QueryKeyInfo (
    CREGKEY_KEY_INFO * pRegKeyInfo
    )
{
    LONG err = 0 ;

    pRegKeyInfo->dwClassNameSize = sizeof pRegKeyInfo->chBuff - 1 ;

    err = ::RegQueryInfoKey(*this,
        pRegKeyInfo->chBuff,
        &pRegKeyInfo->dwClassNameSize,
        NULL,
        &pRegKeyInfo->dwNumSubKeys,
        &pRegKeyInfo->dwMaxSubKey,
        &pRegKeyInfo->dwMaxClass,
        &pRegKeyInfo->dwMaxValues,
        &pRegKeyInfo->dwMaxValueName,
        &pRegKeyInfo->dwMaxValueData,
        &pRegKeyInfo->dwSecDesc,
        &pRegKeyInfo->ftKey
        );

    return err ;
}

//
// Iteration class
//
CRegKeyIter::CRegKeyIter (
    CRegKey & regKey
    )
    : m_rk_iter( regKey ),
      m_p_buffer( NULL ),
      m_cb_buffer( 0 )
{
    LONG err = 0 ;

    CRegKey::CREGKEY_KEY_INFO regKeyInfo ;

    Reset() ;

    err = regKey.QueryKeyInfo( & regKeyInfo ) ;

    if ( err == 0 )
    {
        TRY
        {
            m_cb_buffer = regKeyInfo.dwMaxSubKey + sizeof (DWORD) ;
            m_p_buffer = new TCHAR [ m_cb_buffer ] ;
        }
        CATCH_ALL(e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL
    }
}

CRegKeyIter :: ~ CRegKeyIter ()
{
    delete [] m_p_buffer ;
}

//
// Get the name (and optional last write time) of the next key.
//
LONG CRegKeyIter::Next(
    CString * pstrName,
    CTime * pTime
    )
{
    LONG err = 0;

    FILETIME ftDummy ;
    DWORD dwNameSize = m_cb_buffer ;

    err = ::RegEnumKeyEx( m_rk_iter, m_dw_index, m_p_buffer, & dwNameSize,
        NULL, NULL, NULL, & ftDummy ) ;

    if (err == ERROR_SUCCESS)
    {
        ++m_dw_index;

        if ( pTime )
        {
            *pTime = ftDummy ;
        }

        TRY
        {
            *pstrName = m_p_buffer ;
        }
        CATCH_ALL(e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL
    }

    return err;
}

CRegValueIter::CRegValueIter (
    CRegKey &regKey
    )
    : m_rk_iter(regKey),
      m_p_buffer(NULL),
      m_cb_buffer(0)
{
    LONG err = 0;

    CRegKey::CREGKEY_KEY_INFO regKeyInfo ;

    Reset() ;

    err = regKey.QueryKeyInfo( & regKeyInfo ) ;

    if (err == ERROR_SUCCESS)
    {
        TRY
        {
            m_cb_buffer = regKeyInfo.dwMaxValueName + sizeof (DWORD);
            m_p_buffer = new TCHAR [ m_cb_buffer ] ;
        }
        CATCH_ALL(e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL
    }
}

CRegValueIter::~ CRegValueIter()
{
    delete [] m_p_buffer;
}

LONG
CRegValueIter::Next (
    CString * pstrName,
    DWORD * pdwType
    )
{
    LONG err = 0 ;

    DWORD dwNameLength = m_cb_buffer ;

    err = ::RegEnumValue(m_rk_iter, m_dw_index, m_p_buffer,
        &dwNameLength, NULL, pdwType, NULL, NULL );

    if ( err == ERROR_SUCCESS )
    {
        ++m_dw_index;

        TRY
        {
            *pstrName = m_p_buffer;
        }
        CATCH_ALL(e)
        {
            err = ERROR_NOT_ENOUGH_MEMORY ;
        }
        END_CATCH_ALL
    }

    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by ISAdmin.rc
//
#define IDD_ABOUTBOX                    100
#define IDR_MAINFRAME                   128
#define IDR_ISADMITYPE                  129
#define IDD_MIMEMAP1                    131
#define IDD_SCRIPTMAP1                  132
#define IDD_SSL                         133
#define IDI_COMICON1                    134
#define IDD_FORMVIEW1                   135
#define IDD_COMPAGE1                    136
#define IDD_ADVCOMSET1                  138
#define IDD_FTPPAGE1                    139
#define IDD_FTPADVPAGE1                 140
#define IDD_GOPHERGENPAGE1              141
#define IDD_WEBGENPAGE1                 142
#define IDD_DIALOG1                     143
#define IDD_GOPADVPAGE1                 144
#define IDD_WEBADVPAGE1                 145
#define IDD_ADDMIMEMAPDIALOG            148
#define IDD_DELMIMEDIALOG               149
#define IDD_EDITMIMEMAPDIALOG           150
#define IDB_BITMAP1                     151
#define IDB_GOPHERUPBITMAP              154
#define IDB_GOPHERDOWNBITMAP            155
#define IDB_FTPUPBITMAP                 157
#define IDB_FTPDOWNBITMAP               158
#define IDB_WEBUPBITMAP                 159
#define IDB_WEBDOWNBITMAP               160
#define IDD_ADDSCRIPTDIALOG             161
#define IDD_EDITSCRIPTDIALOG            162
#define IDD_DELSCRIPTDIALOG             163
#define IDI_ICON1                       164
#define IDC_LIST1                       1000
#define IDC_SCRIPTMAPLISTBOX            1000
#define IDC_BUTTON1                     1001
#define IDC_SCRIPTMAPADDBUTTON          1001
#define IDC_BUTTON2                     1002
#define IDC_SCRIPTMAPEDITBUTTON         1002
#define IDC_BUTTON3                     1003
#define IDC_SCRIPTMAPREMOVEBUTTON       1003
#define IDC_COMSET1                     1004
#define IDC_WWWSET4                     1005
#define IDC_FTPSET1                     1006
#define IDC_GOPHSET1                    1007
#define IDC_CACHETEXT1                  1008
#define IDC_CACHEDATA1                  1009
#define IDC_LOGBATCHTEXT1               1010
#define IDC_LOGBATDATA1                 1011
#define IDC_COMADVBUT1                  1013
#define IDC_LOGBATTEXT2                 1014
#define IDC_CACHETEXT2                  1015
#define IDC_MAXPOOLTEXT1                1016
#define IDC_MAXPOOLDATA1                1017
#define IDC_MAXPOOLTEXT2                1018
#define IDC_MAXCONCUR1                  1019
#define IDC_MAXCONCURDATA1              1020
#define IDC_MAXCONCURTEXT2              1022
#define IDC_THREADTOTEXT1               1023
#define IDC_THREADTODATA1               1024
#define IDC_THREADTOTEXT2               1025
#define IDC_USEACCEPTEXTEXT1            1026
#define IDC_USEACCEPTEXTEXT2            1028
#define IDC_USEACCEPTEXDATA1            1029
#define IDC_OBJCACHETEXT1               1030
#define IDC_OBJCACHEDATA1               1031
#define IDC_OBJCACHETEXT2               1032
#define IDC_ACCEPTEXOUTTEXT1            1033
#define IDC_ACCEPTEXOUTDATA1            1034
#define IDC_ACCEPTEXOUTTEXT2            1035
#define IDC_ACCEPTEXTOTEXT1             1036
#define IDC_ACCEPTEXTODATA1             1037
#define IDC_ACCEPTEXTOTEXT2             1038
#define IDC_COMDBGFLAGSTEXT1            1039
#define IDC_COMDBGFLAGSDATA1            1040
#define IDC_COMDBGFLAGSTEXT2            1041
#define IDC_ENSVCLOCTEXT1               1042
#define IDC_ENSVCLOCDATA1               1043
#define IDC_ENSVCLOCTEXT2               1044
#define IDC_LOGANONTEXT1                1045
#define IDC_LOGANONDATA1                1046
#define IDC_LOGANONTEXT2                1047
#define IDC_LOGNONANONTEXT1             1048
#define IDC_LOGNONANONDATA1             1049
#define IDC_LOGNONANONTEXT2             1050
#define IDC_ENPORTATTACKTEXT1           1051
#define IDC_ENPORTATTACKDATA1           1052
#define IDC_ENPORTATTACKTEXT2           1053
#define IDC_FTPADVBUT1                  1054
#define IDC_FTPDBGFLAGSTEXT1            1055
#define IDC_FTPDBGFLAGSDATA1            1056
#define IDC_FTPDBGFLAGSTEXT2            1057
#define IDC_CENWAISTEXT1                1058
#define IDC_ENWAISDATA1                 1060
#define IDC_ENWAISTEXT2                 1061
#define IDC_GOPADVBUT1                  1062
#define IDC_WEBADVBUT1                  1063
#define IDC_GOPDBGFLAGSTEXT1            1064
#define IDC_GOPDBGFLAGSDATA1            1065
#define IDC_GOPDBFFLAGSTEXT2            1066
#define IDC_WEBDBGFLAGSTEXT1            1067
#define IDC_WEBDBGFLAGSDATA1            1068
#define IDC_WEBDBGFLAGSTEXT2            1069
#define IDC_MACHINENAMEDATA1            1071
#define IDC_MACHINENAMETEXT1            1072
#define IDC_CACHESPIN1                  1073
#define IDC_LOGBATSPIN1                 1074
#define IDC_MAXPOOLSPIN1                1075
#define IDC_MAXCONCURSPIN1              1076
#define IDC_THREADTOSPIN1               1077
#define IDC_USEACCEPTEXSPIN1            1078
#define IDC_ACCEPTEXOUTSPIN1            1079
#define IDC_ACCEPTEXTOSPIN1             1080
#define IDC_OBJCACHESPIN1               1081
#define IDC_COMDBGFLAGSSPIN1            1082
#define IDC_ENPORTATTACK                1090
#define IDC_ACCEPTEXGROUP               1098
#define IDC_USEOBJECTCACHETTLDATA1      1099
#define IDC_OBJCECTCACHETTLGROUP        1100
#define IDC_OBJECTCACHETTLGROUP         1100
#define IDC_USERTOKENTTLTEXT1           1101
#define IDC_USERTOKENTTLDATA1           1102
#define IDC_USERTOKENTTLSPIN1           1103
#define IDC_USERTOKENTTLTEXT2           1104
#define IDC_ALLOWGUESTACCESSDATA1       1105
#define IDC_ANNOTATEDIRECTORIESDATA1    1106
#define IDC_MSDOSDIROUTPUT              1107
#define IDC_LOWERCASEFILESDATA1         1108
#define IDC_LISTENBACKLOGTEXT1          1109
#define IDC_LISTENBACKLOGDATA1          1110
#define IDC_LISTENBACKLOGSPIN1          1111
#define IDC_LISTENBACKLOGTEXT2          1112
#define IDC_NTAUTHENTICATIONPROVIDERSTEXT1 1114
#define IDC_NTAUTHENTICATIONPROVIDERSDATA1 1115
#define IDC_NTAUTHENTICATIONPROVIDERSTEXT2 1116
#define IDC_DIRBROWSECONTROLTEXT1       1117
#define IDC_DIRBROWSECONTROLDATA1       1119
#define IDC_DIRBROWSECONTROLTEXT2       1120
#define IDC_MAXCONNECTIONSTEXT1         1121
#define IDC_MAXCONNECTIONSDATA1         1122
#define IDC_MAXCONNECTIONSSPIN1         1123
#define IDC_MAXCONNECTIONSTEXT2         1124
#define IDC_SCRIPTTIMEOUTTEXT1          1126
#define IDC_SCRIPTTIMEOUTDATA1          1127
#define IDC_SCRIPTTIMEOUTSPIN1          1128
#define IDC_SCRIPTTIMEOUTTEXT2          1129
#define IDC_CACHEEXTENSIONSDATA1        1130
#define IDC_SERVERSIDEINCLUDESGROUP     1131
#define IDC_SERVERSIDEINCLUDESENABLEDDATA1 1132
#define IDC_SERVERSIDEINCLUDESEXTENSIONTEXT1 1133
#define IDC_SERVERSIDEINCLUDESEXTENSIONDATA1 1134
#define IDC_GLOBALEXPIREGROUP           1135
#define IDC_ENABLEGLOBALEXPIREDATA1     1136
#define IDC_GLOBALEXPIRETEXT1           1137
#define IDC_GLOBALEXPIREDATA1           1138
#define IDC_GLOBALEXPIRESPIN1           1139
#define IDC_GLOBALEXPIRETEXT2           1140
#define IDC_LOGFILEFLUSHINTERVAL        1141
#define IDC_USELOGFILEFLUSHINTERNVALDATA1 1142
#define IDC_LOGFILEFLUSHINTERVALTEXT1   1143
#define IDC_LOGFILEFLUSHINTERVALDATA1   1144
#define IDC_LOGFILEFLUSHINTERVALSPIN1   1145
#define IDC_LOGFILEFLUSHINTERVALTEXT2   1146
#define IDC_MIMEMAPLIST1                1148
#define IDC_ADDMIMEFILEEXTTEXT1         1149
#define IDC_ADDMIMEMIMETYPETEXT1        1150
#define IDC_ADDMIMEGOPHERTYPETEXT1      1151
#define IDC_ADDMIMEIMAGEFILETEXT1       1152
#define IDC_ADDMIMEFILEEXTENSIONDATA1   1153
#define IDC_ADDMIMEMIMETYPEDATA1        1154
#define IDC_ADDMIMEGOPHERTYPEDATA1      1155
#define IDC_ADDMIMEIMAGEFILEDATA1       1156
#define IDC_MIMEMAPADDBUTTON            1157
#define IDC_MIMEMAPEDITBUTTON           1158
#define IDC_MIMEMAPREMOVEBUTTON         1159
#define IDC_DELMIMETEXT1                1160
#define IDC_EDITMIMEFILEXTENSIONTEXT1   1161
#define IDC_EDITMIMEMIMETYPETEXT1       1162
#define IDC_EDITMIMEIMAGEFILETEXT1      1163
#define IDC_EDITMIMEGOPHERTYPETEXT1     1164
#define IDC_EDITMIMEFILEEXTENSIONDATA1  1165
#define IDC_EDITMIMEMIMETYPEDATA1       1166
#define IDC_EDITMIMEGOPHERTYPEDATA1     1167
#define IDC_EDITMIMEIMAGEFILEDATA1      1168
#define IDC_ADDIMAGEFILETEXT2           1169
#define IDC_EDITMIMEIMAGEFILETEXT2      1170
#define IDC_MAINGROUP                   1173
#define IDC_ADDSCRIPTFILEEXTENSIONTEXT1 1178
#define IDC_ADDSCRIPTFILEEXTENSIONDATA1 1179
#define IDC_ADDSCRIPTMAPPINGTEXT1       1180
#define IDC_ADDSCRIPTMAPPINGDATA1       1181
#define IDC_EDITSCRIPTFILEEXTENSIONTEXT1 1182
#define IDC_EDITSCRIPTFILEEXTENSIONDATA1 1183
#define IDC_EDITSCRIPTMAPPINGTEXT1      1184
#define IDC_EDITSCRIPTMAPPINGDATA1      1185
#define IDC_DELSCRIPTTEXT1              1186
#define IDC_WEBACCESSDENIEDMESSAGETEXT1 1187
#define IDC_WEBACCESSDENIEDMESSAGEDATA1 1188
#define IDC_SSLSECUREPORTTEXT1          1189
#define IDC_SSLSECUREPORTDATA1          1190
#define IDC_SSLENABLESSLDATA1           1191
#define IDC_SSLENABLEPCTDATA1           1192
#define IDC_SSLCREATEPROCESSASUSERDATA1 1193
#define IDS_COMOPENREGERRMSG1           60446
#define IDS_FTPOPENREGERRMSG1           60447
#define IDS_WEBOPENREGERRMSG1           60448
#define IDS_GOPOPENREGERRMSG1           60449
#define IDS_MIMENOHIGHLIGHTMSG          60450
#define IDS_NOHIGHLIGHTMSG              60450
#define IDS_MIMENOMIMEENTRIESMSG        60451
#define IDS_MIMEENTRYALLOCFAILMSG       60452
#define IDS_MIMEENTRIESALLOCFAILMSG     60453
#define IDS_MIMEEDITERRORMSG            60454
#define IDS_SCRIPTNOSCRIPTENTRIESMSG    60455
#define IDS_SCRIPTENTRIESALLOCFAILMSG   60456
#define IDS_SCRIPTENTRYALLOCFAILMSG     60457
#define IDS_SCRIPTEDITERRORMSG          60458
#define IDS_SCRIPTREADERRORMSG          60459

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        165
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1194
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\scripmap.cpp ===
#include "stdafx.h"
#include "scripmap.h"

CScriptMap::CScriptMap ( LPCTSTR pchFileExtension, LPCTSTR pchScriptMap, BOOL bExistingEntry)
{

	m_strScriptMap = pchScriptMap;

    if (bExistingEntry) {
	   m_strPrevFileExtension = pchFileExtension;
	   m_strFileExtension = pchFileExtension;
       }
    else {
	   m_strPrevFileExtension= _T("");
	   SetFileExtension(pchFileExtension);
	   }

}

CScriptMap::~CScriptMap()
{
}

void CScriptMap::SetScriptMap(LPCTSTR pchScriptMap)
{
	m_strScriptMap = pchScriptMap;
}

LPCTSTR CScriptMap::GetScriptMap()
{
	return (m_strScriptMap);
}

void CScriptMap::SetFileExtension(LPCTSTR pchFileExtension)
{
	CString strTempFileExtension = pchFileExtension;
	CheckDot(strTempFileExtension);
	m_strFileExtension = strTempFileExtension;
}

LPCTSTR CScriptMap::GetFileExtension()
{
	return(m_strFileExtension);
}

LPCTSTR CScriptMap::GetPrevFileExtension()
{
	return(m_strPrevFileExtension);
}

void CScriptMap::SetPrevFileExtension()
{
	m_strPrevFileExtension = m_strFileExtension;
}

BOOL CScriptMap::PrevScriptMapExists()
{
return (m_strPrevFileExtension != _T(""));
}

LPCTSTR CScriptMap::GetDisplayString()
{
m_strDisplayString = m_strFileExtension;
m_strDisplayString += _T("\t");
m_strDisplayString += m_strScriptMap;
return (m_strDisplayString);
}


////////////////////////////////////////////////////////////////////////////////
// Private functions

void CScriptMap::CheckDot(CString &strFileExtension)
{
if (strFileExtension.Left(1) != _T(".")) {
   CString strTemp = _T(".") + strFileExtension;
   strFileExtension = strTemp;
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\scripmap.h ===
/****************************************************************************
MIMEMAPC.H	
Mime Map Class Definition
****************************************************************************/
#ifndef _scriptmapc_h

#define _scriptmapc_h


//  Forward declarations
class CScriptMap ;

//  Maximum size of a Registry class name
#define CREGKEY_MAX_CLASS_NAME MAX_PATH

//  Wrapper for a Registry key handle.

class CScriptMap : public CObject
{
protected:

	CString m_strPrevFileExtension;
	CString m_strScriptMap;
 	CString m_strFileExtension;
	CString m_strDisplayString;

	void CheckDot(CString &strFileExtension);
public:
    //  Standard constructor
	CScriptMap ( LPCTSTR pchFileExtension, LPCTSTR pchScriptMap, BOOL bExistingEntry);
	~CScriptMap();
    //  Allow a CRegKey to be used anywhere an HKEY is required.
	void SetScriptMap(LPCTSTR);
	LPCTSTR GetScriptMap();
	void SetFileExtension(LPCTSTR);
	LPCTSTR GetFileExtension();
	void SetPrevFileExtension();
	LPCTSTR GetPrevFileExtension();
	BOOL PrevScriptMapExists();
	LPCTSTR GetDisplayString();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\registry.h ===
/****************************************************************************
REGISTRY.H
****************************************************************************/
#ifndef _registry_h 

#define _registry_h


//  Forward declarations
class CRegKey ;
class CRegValueIter ;
class CRegKeyIter ;

//  Maximum size of a Registry class name
#define CREGKEY_MAX_CLASS_NAME MAX_PATH

//  Wrapper for a Registry key handle.

class CRegKey : public CObject
{
protected:
    HKEY m_hKey ;
    DWORD m_dwDisposition ;

    //  Prepare to read a value by finding the value's size.
    LONG PrepareValue ( const TCHAR * pchValueName,
                        DWORD * pdwType,
                        DWORD * pcbSize,
                        BYTE ** ppbData ) ;

    //  Convert a CStringList to the REG_MULTI_SZ format
    static LONG FlattenValue ( CStringList & strList,
                            DWORD * pcbSize,
                        BYTE ** ppbData ) ;

    //  Convert a CByteArray to a REG_BINARY block
    static LONG FlattenValue ( CByteArray & abData,
                        DWORD * pcbSize,
                        BYTE ** ppbData ) ;

public:
    //  Key information return structure
    typedef struct
    {
        TCHAR chBuff [CREGKEY_MAX_CLASS_NAME] ;
        DWORD dwClassNameSize,
              dwNumSubKeys,
              dwMaxSubKey,
              dwMaxClass,
              dwMaxValues,
              dwMaxValueName,
              dwMaxValueData,
              dwSecDesc ;
        FILETIME ftKey ;
    } CREGKEY_KEY_INFO ;

    //  Standard constructor for an existing key
    CRegKey ( HKEY hKeyBase,
              const TCHAR * pchSubKey = NULL,
              REGSAM regSam = KEY_ALL_ACCESS,
              const TCHAR * pchServerName = NULL ) ;

    //  Constructor creating a new key.
    CRegKey ( const TCHAR * pchSubKey,
              HKEY hKeyBase,
              DWORD dwOptions = 0,
              REGSAM regSam = KEY_ALL_ACCESS,
              LPSECURITY_ATTRIBUTES pSecAttr = NULL,
              const TCHAR * pchServerName = NULL ) ;

    ~ CRegKey () ;

    //  Allow a CRegKey to be used anywhere an HKEY is required.
    operator HKEY ()
        { return m_hKey ; }

    //  Fill a key information structure
    LONG QueryKeyInfo ( CREGKEY_KEY_INFO * pRegKeyInfo ) ;

    //  Overloaded value query members; each returns ERROR_INVALID_PARAMETER
        //  if data exists but not in correct form to deliver into result object.
    LONG QueryValue ( const TCHAR * pchValueName, CString & strResult ) ;
    LONG QueryValue ( const TCHAR * pchValueName, CStringList & strList ) ;
    LONG QueryValue ( const TCHAR * pchValueName, DWORD & dwResult ) ;
    LONG QueryValue ( const TCHAR * pchValueName, CByteArray & abResult ) ;
    LONG QueryValue ( const TCHAR * pchValueName, void * pvResult, DWORD cbSize );

    //  Overloaded value setting members.
    LONG SetValue ( const TCHAR * pchValueName, CString & strResult ) ;
    LONG SetValue ( const TCHAR * pchValueName, CStringList & strList ) ;
    LONG SetValue ( const TCHAR * pchValueName, DWORD & dwResult ) ;
    LONG SetValue ( const TCHAR * pchValueName, CByteArray & abResult ) ;
    LONG SetValue ( const TCHAR * pchValueName, void * pvResult, DWORD cbSize );
    LONG DeleteValue ( const TCHAR * pchValueName);
};


    //  Iterate the values of a key, return the name and type
    //  of each.
class CRegValueIter : public CObject
{
protected:
    CRegKey & m_rk_iter ;
    DWORD m_dw_index ;
    TCHAR * m_p_buffer ;
    DWORD m_cb_buffer ;

public:
    CRegValueIter ( CRegKey & regKey ) ;
    ~ CRegValueIter () ;

    // Get the name (and optional last write time) of the next key.
    LONG Next ( CString * pstrName, DWORD * pdwType ) ;

    // Reset the iterator
    void Reset ()
        { m_dw_index = 0 ; }
};

    //  Iterate the sub-key names of a key.
class CRegKeyIter : public CObject
{
protected:
    CRegKey & m_rk_iter ;
    DWORD m_dw_index ;
    TCHAR * m_p_buffer ;
    DWORD m_cb_buffer ;

public:
    CRegKeyIter ( CRegKey & regKey ) ;
    ~ CRegKeyIter () ;

    // Get the name (and optional last write time) of the next key.
    LONG Next ( CString * pstrName, CTime * pTime = NULL ) ;

    // Reset the iterator
    void Reset ()
        { m_dw_index = 0 ; }
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\ssl1.cpp ===
// ssl1.cpp : implementation file
//

#include "stdafx.h"
#include "ISAdmin.h"
#include "ssl1.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// SSL1 property page

IMPLEMENT_DYNCREATE(SSL1, CGenPage)

SSL1::SSL1() : CGenPage(SSL1::IDD)
{
	//{{AFX_DATA_INIT(SSL1)
	m_ulSecurePort = 0;
	//}}AFX_DATA_INIT
}

SSL1::~SSL1()
{
}

void SSL1::DoDataExchange(CDataExchange* pDX)
{
	CGenPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(SSL1)
	DDX_Control(pDX, IDC_SSLENABLESSLDATA1, m_cboxEnableSSL);
	DDX_Control(pDX, IDC_SSLENABLEPCTDATA1, m_cboxEnablePCT);
	DDX_Control(pDX, IDC_SSLCREATEPROCESSASUSERDATA1, m_cboxCreateProcessAsUser);
	DDX_Text(pDX, IDC_SSLSECUREPORTDATA1, m_ulSecurePort);
	DDV_MinMaxDWord(pDX, m_ulSecurePort, 0, 4294967295);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(SSL1, CGenPage)
	//{{AFX_MSG_MAP(SSL1)
	ON_EN_CHANGE(IDC_SSLSECUREPORTDATA1, OnChangeSslsecureportdata1)
	ON_BN_CLICKED(IDC_SSLCREATEPROCESSASUSERDATA1, OnSslcreateprocessasuserdata1)
	ON_BN_CLICKED(IDC_SSLENABLEPCTDATA1, OnSslenablepctdata1)
	ON_BN_CLICKED(IDC_SSLENABLESSLDATA1, OnSslenablessldata1)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// SSL1 message handlers

BOOL SSL1::OnInitDialog() 
{
	int i;
	CGenPage::OnInitDialog();
	
	// TODO: Add extra initialization here
	for (i = 0; i < SSLPage_TotalNumRegEntries; i++) {
	   m_binNumericRegistryEntries[i].bIsChanged = FALSE;
	   m_binNumericRegistryEntries[i].ulMultipleFactor = 1;
	   }

 	m_binNumericRegistryEntries[SSLPage_SecurePort].strFieldName = _T(SECUREPORTNAME);	
	m_binNumericRegistryEntries[SSLPage_SecurePort].ulDefaultValue = DEFAULTSECUREPORT;

 	m_binNumericRegistryEntries[SSLPage_EncryptionFlags].strFieldName = _T(ENCRYPTIONFLAGSNAME);	
	m_binNumericRegistryEntries[SSLPage_EncryptionFlags].ulDefaultValue = DEFAULTENCRYPTIONFLAGS;

 	m_binNumericRegistryEntries[SSLPage_CreateProcessAsUser].strFieldName = _T(CREATEPROCESSASUSERNAME);	
	m_binNumericRegistryEntries[SSLPage_CreateProcessAsUser].ulDefaultValue = DEFAULTCREATEPROCESSASUSER;

	for (i = 0; i < SSLPage_TotalNumRegEntries; i++) {
	   if (m_rkMainKey->QueryValue(m_binNumericRegistryEntries[i].strFieldName, 
	      m_binNumericRegistryEntries[i].ulFieldValue) != ERROR_SUCCESS) {
		  m_binNumericRegistryEntries[i].ulFieldValue = m_binNumericRegistryEntries[i].ulDefaultValue;
	   }
	}
 
	m_ulSecurePort =  m_binNumericRegistryEntries[SSLPage_SecurePort].ulFieldValue;

   	m_cboxEnableSSL.SetCheck(GETCHECKBOXVALUEFROMREG(
   	   (m_binNumericRegistryEntries[SSLPage_EncryptionFlags].ulFieldValue & ENC_CAPS_SSL)
	   ? TRUEVALUE : FALSEVALUE));

   	m_cboxEnablePCT.SetCheck(GETCHECKBOXVALUEFROMREG(
   	   (m_binNumericRegistryEntries[SSLPage_EncryptionFlags].ulFieldValue & ENC_CAPS_PCT)
	   ? TRUEVALUE : FALSEVALUE));

	m_cboxCreateProcessAsUser.SetCheck(GETCHECKBOXVALUEFROMREG(m_binNumericRegistryEntries[SSLPage_CreateProcessAsUser].ulFieldValue));


	UpdateData(FALSE);		// Force Edit box(es) to pick up value(s)

   	m_bSetChanged = TRUE;	// Any more changes come from the user

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void SSL1::OnChangeSslsecureportdata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[SSLPage_SecurePort].bIsChanged = TRUE;
	   	   
	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}

}

void SSL1::OnSslcreateprocessasuserdata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[SSLPage_CreateProcessAsUser].bIsChanged = TRUE;
	   
	   m_binNumericRegistryEntries[SSLPage_CreateProcessAsUser].ulFieldValue = 
	      GETREGVALUEFROMCHECKBOX(m_cboxCreateProcessAsUser.GetCheck());

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
	
}

void SSL1::OnSslenablepctdata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[SSLPage_EncryptionFlags].bIsChanged = TRUE;
	   
	   if (GETREGVALUEFROMCHECKBOX(m_cboxEnablePCT.GetCheck()) == TRUEVALUE)
	      m_binNumericRegistryEntries[SSLPage_EncryptionFlags].ulFieldValue |= ENC_CAPS_PCT;
	   else
	      m_binNumericRegistryEntries[SSLPage_EncryptionFlags].ulFieldValue &= ~ENC_CAPS_PCT;

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
	
	
}

void SSL1::OnSslenablessldata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[SSLPage_EncryptionFlags].bIsChanged = TRUE;
	   
	   if (GETREGVALUEFROMCHECKBOX(m_cboxEnableSSL.GetCheck()) == TRUEVALUE)
	      m_binNumericRegistryEntries[SSLPage_EncryptionFlags].ulFieldValue |= ENC_CAPS_SSL;
	   else
	      m_binNumericRegistryEntries[SSLPage_EncryptionFlags].ulFieldValue &= ~ENC_CAPS_SSL;
	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
	
}

void SSL1::SaveInfo()
{

if (m_bIsDirty) {
   m_binNumericRegistryEntries[SSLPage_SecurePort].ulFieldValue = m_ulSecurePort;

   SaveNumericInfo(m_binNumericRegistryEntries, SSLPage_TotalNumRegEntries);

}

CGenPage::SaveInfo();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	ISAdmin.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\scrmap1.cpp ===
// scrmap1.cpp : implementation file
//

#include "stdafx.h"
#include "ISAdmin.h"
#include "scrmap1.h"
#include "scripmap.h"
#include "addscrip.h"
#include "editscri.h"
#include "delscrip.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// ScrMap1 property page

IMPLEMENT_DYNCREATE(ScrMap1, CGenPage)

ScrMap1::ScrMap1() : CGenPage(ScrMap1::IDD)
{
	//{{AFX_DATA_INIT(ScrMap1)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	m_rkScriptKey = NULL;
	m_pseScriptMapList = NULL;

}

ScrMap1::~ScrMap1()
{
	if (m_rkScriptKey != NULL)
	   delete(m_rkScriptKey);
	DeleteScriptList();

}

void ScrMap1::DoDataExchange(CDataExchange* pDX)
{
	CGenPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(ScrMap1)
	DDX_Control(pDX, IDC_SCRIPTMAPLISTBOX, m_lboxScriptMap);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(ScrMap1, CGenPage)
	//{{AFX_MSG_MAP(ScrMap1)
	ON_BN_CLICKED(IDC_SCRIPTMAPADDBUTTON, OnScriptmapaddbutton)
	ON_BN_CLICKED(IDC_SCRIPTMAPEDITBUTTON, OnScriptmapeditbutton)
	ON_BN_CLICKED(IDC_SCRIPTMAPREMOVEBUTTON, OnScriptmapremovebutton)
	ON_LBN_DBLCLK(IDC_SCRIPTMAPLISTBOX, OnDblclkScriptmaplistbox)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// ScrMap1 message handlers

BOOL ScrMap1::OnInitDialog() 
{
	CGenPage::OnInitDialog();
CString strNextValueName, strNextValue;
BOOL bAllocationError = FALSE;
CRegValueIter *rviScriptKeys;
DWORD err, ulRegType;
m_ulScriptIndex = 0;
BOOL bReadError = FALSE;
int	iTabSpacing = 58;

m_lboxScriptMap.SetTabStops(iTabSpacing);

m_bScriptEntriesExist = FALSE;

m_rkScriptKey = new CRegKey(*m_rkMainKey,_T("Script Map"),REGISTRY_ACCESS_RIGHTS);

// Anything under this key should be a mime mapping. 
// No way to verify that, but non-string entries are invalid
// so ignore them.

if (m_rkScriptKey != NULL) {
   if (*m_rkScriptKey != NULL) {
      if (rviScriptKeys = new CRegValueIter(*m_rkScriptKey)) {
         while ((err = rviScriptKeys->Next(&strNextValueName, &ulRegType)) == ERROR_SUCCESS) {
		    if (ulRegType == REG_SZ) {
		       if (m_rkScriptKey->QueryValue(strNextValueName, strNextValue) == 0) {
		          if (!AddScriptEntry(strNextValueName, strNextValue, TRUE))
			         bAllocationError = TRUE;
			   }
			   else {
			      bReadError = TRUE;
			   }
			}
   		 }
		 delete (rviScriptKeys);
	  }	
	  m_bScriptEntriesExist = TRUE;
   }
}

if (!m_bScriptEntriesExist) {				//Can't open registry key
   CString strNoScriptEntriesMsg;
   strNoScriptEntriesMsg.LoadString(IDS_SCRIPTNOSCRIPTENTRIESMSG);
   AfxMessageBox(strNoScriptEntriesMsg);
}

if (bAllocationError) {				//Error adding one or more entries
   CString strAllocFailMsg;
   strAllocFailMsg.LoadString(IDS_SCRIPTENTRIESALLOCFAILMSG);
   AfxMessageBox(strAllocFailMsg);
}

if (bReadError) {				//Error reading one or more entries
   CString strReadErrorMsg;
   strReadErrorMsg.LoadString(IDS_SCRIPTREADERRORMSG);
   AfxMessageBox(strReadErrorMsg);
}

	// TODO: Add extra initialization here
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}


void ScrMap1::OnScriptmapaddbutton() 
{
	// TODO: Add your control notification handler code here
if (m_bScriptEntriesExist) {
   CAddScript addscriptGetInfo(this);	

   if (addscriptGetInfo.DoModal() == IDOK) {
      if (AddScriptEntry(addscriptGetInfo.GetFileExtension(), addscriptGetInfo.GetScriptMap(),FALSE)) {
         m_bIsDirty = TRUE;
         SetModified(TRUE);
	  }
	  else {
         CString strAllocFailMsg;
         strAllocFailMsg.LoadString(IDS_SCRIPTENTRYALLOCFAILMSG);
         AfxMessageBox(strAllocFailMsg);
	  }
   }
}
else {
   CString strNoScriptEntriesMsg;
   strNoScriptEntriesMsg.LoadString(IDS_SCRIPTNOSCRIPTENTRIESMSG);
   AfxMessageBox(strNoScriptEntriesMsg);
}
}

void ScrMap1::OnScriptmapeditbutton() 
{
	// TODO: Add your control notification handler code here
if (m_bScriptEntriesExist) {
   int iCurSel;
   PSCRIPT_ENTRY pseEditEntry;


   if ((iCurSel = m_lboxScriptMap.GetCurSel())	!= LB_ERR) {
      for (pseEditEntry = m_pseScriptMapList;(pseEditEntry != NULL) && 
         (m_lboxScriptMap.GetItemData(iCurSel) != pseEditEntry->iListIndex);
         pseEditEntry = pseEditEntry->NextPtr)
         ;
   
      ASSERT (pseEditEntry != NULL);

      CEditScript editscriptGetInfo(this, 
         pseEditEntry->scriptData->GetFileExtension(),
         pseEditEntry->scriptData->GetScriptMap());

      if (editscriptGetInfo.DoModal() == IDOK) {
         if (EditScriptMapping(iCurSel, 
   	          pseEditEntry,
              editscriptGetInfo.GetFileExtension(), 
              editscriptGetInfo.GetScriptMap())) {
            m_bIsDirty = TRUE;
	        SetModified(TRUE);
		 }
		 else {
            CString strEditErrorMsg;
            strEditErrorMsg.LoadString(IDS_SCRIPTEDITERRORMSG);
            AfxMessageBox(strEditErrorMsg);
		 }
      }
   }
   else {
      CString strNoHighlightMsg;
      strNoHighlightMsg.LoadString(IDS_NOHIGHLIGHTMSG);
      AfxMessageBox(strNoHighlightMsg);
   }
}
else {
   CString strNoScriptEntriesMsg;
   strNoScriptEntriesMsg.LoadString(IDS_SCRIPTNOSCRIPTENTRIESMSG);
   AfxMessageBox(strNoScriptEntriesMsg);
}
}


void ScrMap1::OnScriptmapremovebutton() 
{
	// TODO: Add your control notification handler code here
if (m_bScriptEntriesExist) {
   int iCurSel;
   CDelScript delscriptGetInfo(this);

   if ((iCurSel = m_lboxScriptMap.GetCurSel())	!= LB_ERR) {
      if (delscriptGetInfo.DoModal() == IDOK) {
         DeleteScriptMapping(iCurSel);
	     m_bIsDirty = TRUE;
	     SetModified(TRUE);
      }
   }
   else {
      CString strNoHighlightMsg;
      strNoHighlightMsg.LoadString(IDS_NOHIGHLIGHTMSG);
      AfxMessageBox(strNoHighlightMsg);
   }
}
else {
   CString strNoScriptEntriesMsg;
   strNoScriptEntriesMsg.LoadString(IDS_SCRIPTNOSCRIPTENTRIESMSG);
   AfxMessageBox(strNoScriptEntriesMsg);
}
}

void ScrMap1::OnDblclkScriptmaplistbox() 
{
	// TODO: Add your control notification handler code here
OnScriptmapeditbutton();	
}

////////////////////////////////////////////////////////////////////////
// Other Functions

void ScrMap1::SaveInfo()
{
PSCRIPT_ENTRY pseSaveEntry;
CString strTempValue;
if (m_bIsDirty) {
   for (pseSaveEntry = m_pseScriptMapList;(pseSaveEntry != NULL); pseSaveEntry = pseSaveEntry->NextPtr) {
      if (pseSaveEntry->DeleteCurrent) {
	  	 m_rkScriptKey->DeleteValue(pseSaveEntry->scriptData->GetPrevFileExtension());
		 pseSaveEntry->DeleteCurrent = FALSE;
 	  }
      
      if (pseSaveEntry->WriteNew) {
	     strTempValue = pseSaveEntry->scriptData->GetScriptMap();
         m_rkScriptKey->SetValue(pseSaveEntry->scriptData->GetFileExtension(), strTempValue);
		 pseSaveEntry->scriptData->SetPrevFileExtension();
		 pseSaveEntry->WriteNew = FALSE;
	  }
   }

}

CGenPage::SaveInfo();

}

BOOL ScrMap1::AddScriptEntry(LPCTSTR pchFileExtension, LPCTSTR pchScriptMap, BOOL bExistingEntry)
{
PSCRIPT_ENTRY pseNewEntry;
int iCurSel;
BOOL bretcode = FALSE;

if ((pseNewEntry = new SCRIPT_ENTRY) != NULL) {

   if ((pseNewEntry->scriptData = new CScriptMap(pchFileExtension, pchScriptMap, bExistingEntry)) != NULL) {
      iCurSel = m_lboxScriptMap.AddString(pseNewEntry->scriptData->GetDisplayString()); 
	  if ((iCurSel != LB_ERR) && (iCurSel != LB_ERRSPACE)) {
         pseNewEntry->DeleteCurrent = FALSE;
         pseNewEntry->WriteNew = TRUE;
         m_lboxScriptMap.SetItemData(iCurSel,m_ulScriptIndex);
	     m_lboxScriptMap.SetCurSel(iCurSel);
         pseNewEntry->iListIndex = m_ulScriptIndex++;
         pseNewEntry->NextPtr = m_pseScriptMapList;
         m_pseScriptMapList = pseNewEntry;
	     bretcode = TRUE;
	  }
	  else {
	     delete (pseNewEntry->scriptData);
		 delete (pseNewEntry);
	  }
   }
   else
      delete (pseNewEntry);
}
return (bretcode);
}

void ScrMap1::DeleteScriptList()
{
PSCRIPT_ENTRY pseCurEntry;

while (m_pseScriptMapList != NULL) {
   delete (m_pseScriptMapList->scriptData);
   pseCurEntry = m_pseScriptMapList;
   m_pseScriptMapList = m_pseScriptMapList->NextPtr;
   delete (pseCurEntry);
}
}

void ScrMap1::DeleteScriptMapping(int iCurSel)
{
PSCRIPT_ENTRY pseDelEntry;
for (pseDelEntry = m_pseScriptMapList;(pseDelEntry != NULL) && 
   (m_lboxScriptMap.GetItemData(iCurSel) != pseDelEntry->iListIndex);
   pseDelEntry = pseDelEntry->NextPtr)
   ;
ASSERT (pseDelEntry != NULL);

if (pseDelEntry->scriptData->PrevScriptMapExists())
   pseDelEntry->DeleteCurrent = TRUE;
pseDelEntry->WriteNew = FALSE;			
m_lboxScriptMap.DeleteString(iCurSel);
}
    

BOOL ScrMap1::EditScriptMapping(int iCurSel, 
   PSCRIPT_ENTRY pseEditEntry, 
   LPCTSTR pchFileExtension, 
   LPCTSTR pchScriptMap)
{
BOOL bretcode = FALSE;

pseEditEntry->scriptData->SetFileExtension(pchFileExtension);
pseEditEntry->scriptData->SetScriptMap(pchScriptMap);

m_lboxScriptMap.DeleteString(iCurSel); 		// Delete first so memory is freed
iCurSel = m_lboxScriptMap.AddString(pseEditEntry->scriptData->GetDisplayString()); 

// There error case on this is incredibly rare, so don't bother saving and restoring the above fields
// Just don't set flags so registry is not updated.

if ((iCurSel != LB_ERR) && (iCurSel != LB_ERRSPACE)) {
   m_lboxScriptMap.SetItemData(iCurSel,pseEditEntry->iListIndex);
   if (pseEditEntry->scriptData->PrevScriptMapExists())
      pseEditEntry->DeleteCurrent = TRUE;
   
   pseEditEntry->WriteNew = TRUE;
   bretcode = TRUE;
} 

return (bretcode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\scrmap1.h ===
// scrmap1.h : header file
//
#include "scripmap.h"

typedef struct _SCRIPT_ENTRY {
   struct _SCRIPT_ENTRY	*NextPtr;
   CScriptMap			*scriptData;
   DWORD				iListIndex;
   BOOL					DeleteCurrent;
   BOOL					WriteNew;
   } SCRIPT_ENTRY, *PSCRIPT_ENTRY;

////////////////////////////////////////////////////////////////////////////////////
// ScrMap1 dialog

class ScrMap1 : public CGenPage
{
	DECLARE_DYNCREATE(ScrMap1)

// Construction
public:
	ScrMap1();
	~ScrMap1();

// Dialog Data
	//{{AFX_DATA(ScrMap1)
	enum { IDD = IDD_SCRIPTMAP1 };
	CListBox	m_lboxScriptMap;
	//}}AFX_DATA

	CRegKey *m_rkScriptKey;

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(ScrMap1)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual	void SaveInfo(void);
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(ScrMap1)
	afx_msg void OnScriptmapaddbutton();
	afx_msg void OnScriptmapeditbutton();
	afx_msg void OnScriptmapremovebutton();
	virtual BOOL OnInitDialog();
	afx_msg void OnDblclkScriptmaplistbox();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	BOOL AddScriptEntry(LPCTSTR pchFileExtension, LPCTSTR pchScriptMap, BOOL bExistingEntry);
	void DeleteScriptList();
	void DeleteScriptMapping(int iCurSel);
	BOOL EditScriptMapping(int iCurSel, PSCRIPT_ENTRY pseEditEntry, LPCTSTR pchFileExtension, LPCTSTR pchScriptMap);



	DWORD	m_ulScriptIndex;
 	BOOL	m_bScriptEntriesExist;
	PSCRIPT_ENTRY m_pseScriptMapList;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\ssl1.h ===
// ssl1.h : header file
//

#define SECUREPORTNAME			"SecurePort"
#define DEFAULTSECUREPORT		443

#define ENCRYPTIONFLAGSNAME			"EncryptionFlags"
#define DEFAULTENCRYPTIONFLAGS		ENC_CAPS_SSL | ENC_CAPS_PCT

#define CREATEPROCESSASUSERNAME			"CreateProcessAsUser"
#define DEFAULTCREATEPROCESSASUSER		TRUEVALUE

enum SSL_NUM_REG_ENTRIES {
	 SSLPage_SecurePort,
	 SSLPage_EncryptionFlags,
	 SSLPage_CreateProcessAsUser,
	 SSLPage_TotalNumRegEntries
	 };


/////////////////////////////////////////////////////////////////////////////
// SSL1 dialog

class SSL1 : public CGenPage
{
	DECLARE_DYNCREATE(SSL1)

// Construction
public:
	SSL1();
	~SSL1();

// Dialog Data
	//{{AFX_DATA(SSL1)
	enum { IDD = IDD_SSL };
	CButton	m_cboxEnableSSL;
	CButton	m_cboxEnablePCT;
	CButton	m_cboxCreateProcessAsUser;
	DWORD	m_ulSecurePort;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(SSL1)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual	void SaveInfo(void);
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(SSL1)
	afx_msg void OnChangeSslsecureportdata1();
	afx_msg void OnSslcreateprocessasuserdata1();
	afx_msg void OnSslenablepctdata1();
	afx_msg void OnSslenablessldata1();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	NUM_REG_ENTRY m_binNumericRegistryEntries[SSLPage_TotalNumRegEntries];
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\webadvp1.cpp ===
// webadvp1.cpp : implementation file
//

#include "stdafx.h"
#include "ISAdmin.h"
#include "webadvp1.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWEBADVP1 dialog

IMPLEMENT_DYNCREATE(CWEBADVP1, CGenPage)

CWEBADVP1::CWEBADVP1()	: CGenPage(CWEBADVP1::IDD)
{
	//{{AFX_DATA_INIT(CWEBADVP1)
	m_strServerSideIncludesExtension = _T("");
	//}}AFX_DATA_INIT
}

CWEBADVP1::~CWEBADVP1()
{
}


void CWEBADVP1::DoDataExchange(CDataExchange* pDX)
{
	CGenPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWEBADVP1)
	DDX_Control(pDX, IDC_SERVERSIDEINCLUDESEXTENSIONDATA1, m_editServerSideIncludesExtension);
	DDX_Control(pDX, IDC_SERVERSIDEINCLUDESENABLEDDATA1, m_cboxServerSideIncludesEnabled);
	DDX_Control(pDX, IDC_ENABLEGLOBALEXPIREDATA1, m_cboxEnableGlobalExpire);
	DDX_Control(pDX, IDC_GLOBALEXPIREDATA1, m_editGlobalExpire);
	DDX_Control(pDX, IDC_GLOBALEXPIRESPIN1, m_spinGlobalExpire);
	DDX_Control(pDX, IDC_CACHEEXTENSIONSDATA1, m_cboxCacheExtensions);
	DDX_Control(pDX, IDC_SCRIPTTIMEOUTSPIN1, m_spinScriptTimeout);
	DDX_Control(pDX, IDC_WEBDBGFLAGSDATA1, m_editWebDbgFlags);
	DDX_TexttoHex(pDX, IDC_WEBDBGFLAGSDATA1, m_ulWebDbgFlags);
	DDX_Text(pDX, IDC_SERVERSIDEINCLUDESEXTENSIONDATA1, m_strServerSideIncludesExtension);
	DDV_MaxChars(pDX, m_strServerSideIncludesExtension, 256);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWEBADVP1, CGenPage)
	//{{AFX_MSG_MAP(CWEBADVP1)
	ON_EN_CHANGE(IDC_WEBDBGFLAGSDATA1, OnChangeWebdbgflagsdata1)
	ON_EN_CHANGE(IDC_SCRIPTTIMEOUTDATA1, OnChangeScripttimeoutdata1)
	ON_BN_CLICKED(IDC_CACHEEXTENSIONSDATA1, OnCacheextensionsdata1)
	ON_EN_CHANGE(IDC_GLOBALEXPIREDATA1, OnChangeGlobalexpiredata1)
	ON_BN_CLICKED(IDC_ENABLEGLOBALEXPIREDATA1, OnEnableglobalexpiredata1)
	ON_EN_CHANGE(IDC_SERVERSIDEINCLUDESEXTENSIONDATA1, OnChangeServersideincludesextensiondata1)
	ON_BN_CLICKED(IDC_SERVERSIDEINCLUDESENABLEDDATA1, OnServersideincludesenableddata1)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CWEBADVP1 message handlers

BOOL CWEBADVP1::OnInitDialog() 
{
	int i;
	CGenPage::OnInitDialog();
	
	// TODO: Add extra initialization here
	for (i = 0; i < AdvWebPage_TotalNumRegEntries; i++) {
	   m_binNumericRegistryEntries[i].bIsChanged = FALSE;
	   m_binNumericRegistryEntries[i].ulMultipleFactor = 1;
	   }
	
	for (i = 0; i < AdvWebPage_TotalStringRegEntries; i++) {
	   m_binStringRegistryEntries[i].bIsChanged = FALSE;
	   }
	

 	m_binNumericRegistryEntries[AdvWebPage_DebugFlags].strFieldName = _T(DEBUGFLAGSNAME);	
	m_binNumericRegistryEntries[AdvWebPage_DebugFlags].ulDefaultValue = DEFAULTDEBUGFLAGS;

 	m_binNumericRegistryEntries[AdvWebPage_ScriptTimeout].strFieldName = _T(SCRIPTTIMEOUTNAME);	
 	m_binNumericRegistryEntries[AdvWebPage_ScriptTimeout].ulMultipleFactor = 60;
	m_binNumericRegistryEntries[AdvWebPage_ScriptTimeout].ulDefaultValue = DEFAULTSCRIPTTIMEOUT;

 	m_binNumericRegistryEntries[AdvWebPage_CacheExtensions].strFieldName = _T(CACHEEXTENSIONSNAME);	
	m_binNumericRegistryEntries[AdvWebPage_CacheExtensions].ulDefaultValue = DEFAULTCACHEEXTENSIONS;

	m_binNumericRegistryEntries[AdvWebPage_ServerSideIncludesEnabled].strFieldName = _T(SERVERSIDEINCLUDESENABLEDNAME);	
	m_binNumericRegistryEntries[AdvWebPage_ServerSideIncludesEnabled].ulDefaultValue = DEFAULTSERVERSIDEINCLUDESENABLED;

	m_binNumericRegistryEntries[AdvWebPage_GlobalExpire].strFieldName = _T(GLOBALEXPIRENAME);	
	m_binNumericRegistryEntries[AdvWebPage_GlobalExpire].ulDefaultValue = DEFAULTGLOBALEXPIRE;
	m_binNumericRegistryEntries[AdvWebPage_GlobalExpire].ulMultipleFactor = 60;

	m_binStringRegistryEntries[AdvWebPage_ServerSideIncludesExtension].strFieldName = _T(SERVERSIDEINCLUDESEXTENSIONNAME);	
	m_binStringRegistryEntries[AdvWebPage_ServerSideIncludesExtension].strFieldValue = _T(DEFAULTSERVERSIDEINCLUDESEXTENSION);
	
	for (i = 0; i < AdvWebPage_TotalNumRegEntries; i++) {
	   if (m_rkMainKey->QueryValue(m_binNumericRegistryEntries[i].strFieldName, 
	      m_binNumericRegistryEntries[i].ulFieldValue) != ERROR_SUCCESS) {
		  m_binNumericRegistryEntries[i].ulFieldValue = m_binNumericRegistryEntries[i].ulDefaultValue;
	   }
	}
 
 	for (i = 0; i < AdvWebPage_TotalStringRegEntries; i++) {
	   m_rkMainKey->QueryValue(m_binStringRegistryEntries[i].strFieldName, 
	      m_binStringRegistryEntries[i].strFieldValue);
	}
   	
	m_spinScriptTimeout.SetRange(MINSCRIPTTIMEOUT, MAXSCRIPTTIMEOUT);
	m_spinScriptTimeout.SetPos(LESSOROF((m_binNumericRegistryEntries[AdvWebPage_ScriptTimeout].ulFieldValue / 
	   m_binNumericRegistryEntries[AdvWebPage_ScriptTimeout].ulMultipleFactor), MAXSCRIPTTIMEOUT));
   	
	m_cboxCacheExtensions.SetCheck(GETCHECKBOXVALUEFROMREG(m_binNumericRegistryEntries[AdvWebPage_CacheExtensions].ulFieldValue));

 	m_strServerSideIncludesExtension =  m_binStringRegistryEntries[AdvWebPage_ServerSideIncludesExtension].strFieldValue;

	m_cboxServerSideIncludesEnabled.SetCheck(GETCHECKBOXVALUEFROMREG(m_binNumericRegistryEntries[AdvWebPage_ServerSideIncludesEnabled].ulFieldValue));
	SetServerSideIncludesEnabledState();
	

	m_spinGlobalExpire.SetRange(MINGLOBALEXPIRE, MAXGLOBALEXPIRE);
	if (m_binNumericRegistryEntries[AdvWebPage_GlobalExpire].ulFieldValue != 0xffffffff) {
	   m_spinGlobalExpire.SetPos(LESSOROF ((m_binNumericRegistryEntries[AdvWebPage_GlobalExpire].ulFieldValue / 
	      m_binNumericRegistryEntries[AdvWebPage_GlobalExpire].ulMultipleFactor),MAXGLOBALEXPIRE));
	   SetGlobalExpireEnabledState(TRUE);
	}
	else {
	   m_spinGlobalExpire.SetPos(LESSOROF((m_binNumericRegistryEntries[AdvWebPage_GlobalExpire].ulDefaultValue /
  	      m_binNumericRegistryEntries[AdvWebPage_GlobalExpire].ulMultipleFactor),MAXGLOBALEXPIRE));
	   SetGlobalExpireEnabledState(FALSE);
	}


	m_editWebDbgFlags.LimitText(8);
	m_ulWebDbgFlags = m_binNumericRegistryEntries[AdvWebPage_DebugFlags].ulFieldValue;
	UpdateData(FALSE);		// Force Edit box(es) to pick up value(s)

	m_bSetChanged = TRUE;	// Any more changes come from the user

	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CWEBADVP1::OnChangeWebdbgflagsdata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[AdvWebPage_DebugFlags].bIsChanged = TRUE;
	   	   
	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}

}


void CWEBADVP1::OnChangeScripttimeoutdata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[AdvWebPage_ScriptTimeout].bIsChanged = TRUE;
	   m_binNumericRegistryEntries[AdvWebPage_ScriptTimeout].ulFieldValue = m_spinScriptTimeout.GetPos() * 
	      m_binNumericRegistryEntries[AdvWebPage_ScriptTimeout].ulMultipleFactor;		
	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
}

void CWEBADVP1::OnCacheextensionsdata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[AdvWebPage_CacheExtensions].bIsChanged = TRUE;
	   
	   m_binNumericRegistryEntries[AdvWebPage_CacheExtensions].ulFieldValue = 
	      GETREGVALUEFROMCHECKBOX(m_cboxCacheExtensions.GetCheck());

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
	
}

void CWEBADVP1::OnServersideincludesenableddata1() 
{
	// TODO: Add your control notification handler code here
	SetServerSideIncludesEnabledState();

	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[AdvWebPage_ServerSideIncludesEnabled].bIsChanged = TRUE;
	   
	   m_binNumericRegistryEntries[AdvWebPage_ServerSideIncludesEnabled].ulFieldValue = 
	      GETREGVALUEFROMCHECKBOX(m_cboxServerSideIncludesEnabled.GetCheck());

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
	
	
}

void CWEBADVP1::OnChangeServersideincludesextensiondata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binStringRegistryEntries[AdvWebPage_ServerSideIncludesExtension].bIsChanged = TRUE;
	   	   
	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}

}


void CWEBADVP1::OnEnableglobalexpiredata1() 
{
	// TODO: Add your control notification handler code here
SetGlobalExpireEnabledState(m_cboxEnableGlobalExpire.GetCheck());
if (m_bSetChanged) {
   m_binNumericRegistryEntries[AdvWebPage_GlobalExpire].bIsChanged = TRUE;	

   m_bIsDirty = TRUE;
   SetModified(TRUE);
   }


}
void CWEBADVP1::OnChangeGlobalexpiredata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[AdvWebPage_GlobalExpire].bIsChanged = TRUE;	
	   m_binNumericRegistryEntries[AdvWebPage_GlobalExpire].ulFieldValue = m_spinGlobalExpire.GetPos() 
	      * m_binNumericRegistryEntries[AdvWebPage_GlobalExpire].ulMultipleFactor;		

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
	
}

void CWEBADVP1::SaveInfo()
{

if (m_bIsDirty) {
   m_binNumericRegistryEntries[AdvWebPage_DebugFlags].ulFieldValue = m_ulWebDbgFlags;
   m_binStringRegistryEntries[AdvWebPage_ServerSideIncludesExtension].strFieldValue = m_strServerSideIncludesExtension;

   SaveNumericInfo(m_binNumericRegistryEntries, AdvWebPage_TotalNumRegEntries);
   SaveStringInfo(m_binStringRegistryEntries, AdvWebPage_TotalStringRegEntries);

}

CGenPage::SaveInfo();

}


void CWEBADVP1::SetGlobalExpireEnabledState(BOOL bEnabled)
{
	if (bEnabled) {
	   m_binNumericRegistryEntries[AdvWebPage_GlobalExpire].ulFieldValue = 
	      m_spinGlobalExpire.GetPos() * 
	      m_binNumericRegistryEntries[AdvWebPage_GlobalExpire].ulMultipleFactor;
	   m_cboxEnableGlobalExpire.SetCheck(CHECKEDVALUE);
	   m_spinGlobalExpire.EnableWindow(TRUE);
	   m_editGlobalExpire.EnableWindow(TRUE);
	}
	else {
	   m_binNumericRegistryEntries[AdvWebPage_GlobalExpire].ulFieldValue = 0xffffffff;
	   m_cboxEnableGlobalExpire.SetCheck(UNCHECKEDVALUE);
	   m_spinGlobalExpire.EnableWindow(FALSE);
	   m_editGlobalExpire.EnableWindow(FALSE);
	}
}	


void CWEBADVP1::SetServerSideIncludesEnabledState()
{
if (m_cboxServerSideIncludesEnabled.GetCheck() != 0) {
   m_editServerSideIncludesExtension.EnableWindow(TRUE);
   if (m_bSetChanged) {		//if user enabled this, make sure there's a value there
	  m_binStringRegistryEntries[AdvWebPage_ServerSideIncludesExtension].bIsChanged = TRUE;	
   }  // Don't need to set bIsDirty, as get's set anyway
}
else {
   m_editServerSideIncludesExtension.EnableWindow(FALSE);
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\webgenp1.h ===
// webgenp1.h : header file
//

#define MAXCONNECTIONSNAME	"MaxConnections"
#define MINMAXCONNECTIONS	0
#define MAXMAXCONNECTIONS	0x7fff
#define DEFAULTMAXCONNECTIONS	20 * 100

#define DIRBROWSECONTROLNAME	"Dir Browse Control"
#define DEFAULTDIRBROWSECONTROL	0xc000001e

#define NTAUTHENTICATIONPROVIDERSNAME	"NTAuthenticationProviders"
#define DEFAULTNTAUTHENTICATIONPROVIDERS  "NTLM"

#define ACCESSDENIEDMESSAGENAME	"AccessDeniedMessage"
#define DEFAULTACCESSDENIEDMESSAGE  ""

enum  WEB_NUM_REG_ENTRIES {
     WebPage_EnableSvcLoc,
	 WebPage_LogAnonymous,
	 WebPage_LogNonAnonymous,
	 WebPage_CheckForWAISDB,
	 WebPage_MaxConnections,
	 WebPage_DirBrowseControl,
	 WebPage_TotalNumRegEntries
	 };

enum  WEB_STRING_REG_ENTRIES {
	WebPage_NTAuthenticationProviders,
	WebPage_AccessDeniedMessage,
	WebPage_TotalStringRegEntries
	};

/////////////////////////////////////////////////////////////////////////////
// CWEBGENP1 dialog

class CWEBGENP1 : public CGenPage
{
	DECLARE_DYNCREATE(CWEBGENP1)

// Construction
public:
	CWEBGENP1();
	~CWEBGENP1();

// Dialog Data
	//{{AFX_DATA(CWEBGENP1)
	enum { IDD = IDD_WEBGENPAGE1 };
	CEdit	m_editDirBrowseControl;
	CSpinButtonCtrl	m_spinMaxConnections;
	CButton	m_cboxLogNonAnon;
	CButton	m_cboxLogAnon;
	CButton	m_cboxEnWais;
	CButton	m_cboxEnSvcLoc;
	DWORD	m_ulDirBrowseControl;
	CString	m_strNTAuthenticationProviders;
	CString	m_strWebAccessDeniedMessage;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CWEBGENP1)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual	void SaveInfo(void);
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CWEBGENP1)
	afx_msg void OnEnsvclocdata1();
	afx_msg void OnEnwaisdata1();
	afx_msg void OnLoganondata1();
	afx_msg void OnLognonanondata1();
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeMaxconnectionsdata1();
	afx_msg void OnChangeDirbrowsecontroldata1();
	afx_msg void OnChangeNtauthenticatoinprovidersdata1();
	afx_msg void OnChangeNtauthenticationprovidersdata1();
	afx_msg void OnChangeWebaccessdeniedmessagedata1();
	//}}AFX_MSG
	NUM_REG_ENTRY m_binNumericRegistryEntries[WebPage_TotalNumRegEntries];
	STRING_REG_ENTRY m_binStringRegistryEntries[WebPage_TotalStringRegEntries];

	DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\webadvp1.h ===
// webadvp1.h : header file
//

#define CACHEEXTENSIONSNAME	"CacheExtensions"
#define DEFAULTCACHEEXTENSIONS	TRUEVALUE

#define SCRIPTTIMEOUTNAME	"ScriptTimeout"
#define MINSCRIPTTIMEOUT	0
#define MAXSCRIPTTIMEOUT	0x7FFF							//Specify in minutes
#define DEFAULTSCRIPTTIMEOUT	(60 * 15)

#define SERVERSIDEINCLUDESENABLEDNAME		"ServerSideIncludesEnabled"
#define DEFAULTSERVERSIDEINCLUDESENABLED	TRUEVALUE

#define SERVERSIDEINCLUDESEXTENSIONNAME		"ServerSideIncludesExtension"
#define	DEFAULTSERVERSIDEINCLUDESEXTENSION	".stm"


#define GLOBALEXPIRENAME	"GlobalExpire"
#define MINGLOBALEXPIRE	0
#define MAXGLOBALEXPIRE	0x7FFF 						//Specify in Minutes
#define DEFAULTGLOBALEXPIRE	0xffffffff


enum ADV_WEB_NUM_REG_ENTRIES {
	 AdvWebPage_ScriptTimeout,
	 AdvWebPage_CacheExtensions,
	 AdvWebPage_ServerSideIncludesEnabled,
	 AdvWebPage_GlobalExpire,
	 AdvWebPage_DebugFlags,
	 AdvWebPage_TotalNumRegEntries
	 };

enum ADV_WEB_STRING_REG_ENTRIES {
	 AdvWebPage_ServerSideIncludesExtension,
	 AdvWebPage_TotalStringRegEntries
	 };


/////////////////////////////////////////////////////////////////////////////
// CWEBADVP1 dialog

class CWEBADVP1 : public CGenPage
{	 	
	DECLARE_DYNCREATE(CWEBADVP1)
// Construction
public:
	CWEBADVP1(); 
	~CWEBADVP1();

	// Dialog Data
	//{{AFX_DATA(CWEBADVP1)
	enum { IDD = IDD_WEBADVPAGE1 };
	CEdit	m_editServerSideIncludesExtension;
	CButton	m_cboxServerSideIncludesEnabled;
	CButton	m_cboxEnableGlobalExpire;
	CEdit	m_editGlobalExpire;
	CSpinButtonCtrl	m_spinGlobalExpire;
	CButton	m_cboxCacheExtensions;
	CSpinButtonCtrl	m_spinScriptTimeout;
	CEdit	m_editWebDbgFlags;
	DWORD	m_ulWebDbgFlags;
	CString	m_strServerSideIncludesExtension;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWEBADVP1)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual	void SaveInfo(void);
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CWEBADVP1)
	afx_msg void OnChangeWebdbgflagsdata1();
	virtual BOOL OnInitDialog();
	afx_msg void OnChangeScripttimeoutdata1();
	afx_msg void OnCacheextensionsdata1();
	afx_msg void OnChangeGlobalexpiredata1();
	afx_msg void OnEnableglobalexpiredata1();
	afx_msg void OnChangeServersideincludesextensiondata1();
	afx_msg void OnServersideincludesenableddata1();
	//}}AFX_MSG

	void SetGlobalExpireEnabledState(BOOL bEnabled);
	void SetServerSideIncludesEnabledState();

	NUM_REG_ENTRY m_binNumericRegistryEntries[AdvWebPage_TotalNumRegEntries];
	STRING_REG_ENTRY m_binStringRegistryEntries[AdvWebPage_TotalStringRegEntries];

	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\isadmin\webgenp1.cpp ===
// webgenp1.cpp : implementation file
//

#include "stdafx.h"
#include "ISAdmin.h"
#include "compsdef.h"
#include "webgenp1.h"
#include "webadvp1.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWEBGENP1 property page

IMPLEMENT_DYNCREATE(CWEBGENP1, CGenPage)

CWEBGENP1::CWEBGENP1() : CGenPage(CWEBGENP1::IDD)
{
	//{{AFX_DATA_INIT(CWEBGENP1)
	m_strWebAccessDeniedMessage = _T("");
	//}}AFX_DATA_INIT
}

CWEBGENP1::~CWEBGENP1()
{
}

void CWEBGENP1::DoDataExchange(CDataExchange* pDX)
{
	CGenPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CWEBGENP1)
	DDX_Control(pDX, IDC_DIRBROWSECONTROLDATA1, m_editDirBrowseControl);
	DDX_Control(pDX, IDC_MAXCONNECTIONSSPIN1, m_spinMaxConnections);
	DDX_Control(pDX, IDC_LOGNONANONDATA1, m_cboxLogNonAnon);
	DDX_Control(pDX, IDC_LOGANONDATA1, m_cboxLogAnon);
	DDX_Control(pDX, IDC_ENWAISDATA1, m_cboxEnWais);
	DDX_Control(pDX, IDC_ENSVCLOCDATA1, m_cboxEnSvcLoc);
	DDX_TexttoHex(pDX, IDC_DIRBROWSECONTROLDATA1, m_ulDirBrowseControl);
	DDX_Text(pDX, IDC_NTAUTHENTICATIONPROVIDERSDATA1, m_strNTAuthenticationProviders);
	DDV_MaxChars(pDX, m_strNTAuthenticationProviders, 512);
	DDX_Text(pDX, IDC_WEBACCESSDENIEDMESSAGEDATA1, m_strWebAccessDeniedMessage);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CWEBGENP1, CGenPage)
	//{{AFX_MSG_MAP(CWEBGENP1)
	ON_BN_CLICKED(IDC_ENSVCLOCDATA1, OnEnsvclocdata1)
	ON_BN_CLICKED(IDC_ENWAISDATA1, OnEnwaisdata1)
	ON_BN_CLICKED(IDC_LOGANONDATA1, OnLoganondata1)
	ON_BN_CLICKED(IDC_LOGNONANONDATA1, OnLognonanondata1)
	ON_EN_CHANGE(IDC_MAXCONNECTIONSDATA1, OnChangeMaxconnectionsdata1)
	ON_EN_CHANGE(IDC_DIRBROWSECONTROLDATA1, OnChangeDirbrowsecontroldata1)
	ON_EN_CHANGE(IDC_NTAUTHENTICATIONPROVIDERSDATA1, OnChangeNtauthenticationprovidersdata1)
	ON_EN_CHANGE(IDC_WEBACCESSDENIEDMESSAGEDATA1, OnChangeWebaccessdeniedmessagedata1)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CWEBGENP1 message handlers

BOOL CWEBGENP1::OnInitDialog() 
{
	int i;
	CGenPage::OnInitDialog();
	
	// TODO: Add extra initialization here
	for (i = 0; i < WebPage_TotalNumRegEntries; i++) {
	   m_binNumericRegistryEntries[i].bIsChanged = FALSE;
	   m_binNumericRegistryEntries[i].ulMultipleFactor = 1;
	   }
	
	for (i = 0; i < WebPage_TotalStringRegEntries; i++) {
	   m_binStringRegistryEntries[i].bIsChanged = FALSE;
	   }
	
	m_binNumericRegistryEntries[WebPage_EnableSvcLoc].strFieldName = _T(ENABLESVCLOCNAME);	
	m_binNumericRegistryEntries[WebPage_EnableSvcLoc].ulDefaultValue = DEFAULTENABLESVCLOC;

	m_binNumericRegistryEntries[WebPage_LogAnonymous].strFieldName = _T(LOGANONYMOUSNAME);	
	m_binNumericRegistryEntries[WebPage_LogAnonymous].ulDefaultValue = DEFAULTLOGANONYMOUS;

	m_binNumericRegistryEntries[WebPage_LogNonAnonymous].strFieldName = _T(LOGNONANONYMOUSNAME);	
	m_binNumericRegistryEntries[WebPage_LogNonAnonymous].ulDefaultValue = DEFAULTLOGNONANONYMOUS;

	m_binNumericRegistryEntries[WebPage_CheckForWAISDB].strFieldName = _T(CHECKFORWAISDBNAME);	
	m_binNumericRegistryEntries[WebPage_CheckForWAISDB].ulDefaultValue = DEFAULTCHECKFORWAISDB;

	m_binNumericRegistryEntries[WebPage_MaxConnections].strFieldName = _T(MAXCONNECTIONSNAME);	
	m_binNumericRegistryEntries[WebPage_MaxConnections].ulMultipleFactor = 100;
	m_binNumericRegistryEntries[WebPage_MaxConnections].ulDefaultValue = DEFAULTMAXCONNECTIONS;
	
	m_binNumericRegistryEntries[WebPage_DirBrowseControl].strFieldName = _T(DIRBROWSECONTROLNAME);	
	m_binNumericRegistryEntries[WebPage_DirBrowseControl].ulDefaultValue = DEFAULTDIRBROWSECONTROL;
	
	m_binStringRegistryEntries[WebPage_NTAuthenticationProviders].strFieldName = _T(NTAUTHENTICATIONPROVIDERSNAME);	
	m_binStringRegistryEntries[WebPage_NTAuthenticationProviders].strFieldValue = _T(DEFAULTNTAUTHENTICATIONPROVIDERS);
	
	m_binStringRegistryEntries[WebPage_AccessDeniedMessage].strFieldName = _T(ACCESSDENIEDMESSAGENAME);	
	m_binStringRegistryEntries[WebPage_AccessDeniedMessage].strFieldValue = _T(DEFAULTACCESSDENIEDMESSAGE);
	
	for (i = 0; i < WebPage_TotalNumRegEntries; i++) {
	   if (m_rkMainKey->QueryValue(m_binNumericRegistryEntries[i].strFieldName, 
	      m_binNumericRegistryEntries[i].ulFieldValue) != ERROR_SUCCESS) {
		  m_binNumericRegistryEntries[i].ulFieldValue = m_binNumericRegistryEntries[i].ulDefaultValue;
	   }

	}

	for (i = 0; i < WebPage_TotalStringRegEntries; i++) {
	   m_rkMainKey->QueryValue(m_binStringRegistryEntries[i].strFieldName, 
	      m_binStringRegistryEntries[i].strFieldValue);
	}

	m_cboxEnSvcLoc.SetCheck(GETCHECKBOXVALUEFROMREG(m_binNumericRegistryEntries[WebPage_EnableSvcLoc].ulFieldValue));

	m_cboxLogAnon.SetCheck(GETCHECKBOXVALUEFROMREG(m_binNumericRegistryEntries[WebPage_LogAnonymous].ulFieldValue));
	
	m_cboxLogNonAnon.SetCheck(GETCHECKBOXVALUEFROMREG(m_binNumericRegistryEntries[WebPage_LogNonAnonymous].ulFieldValue));
	
	m_cboxEnWais.SetCheck(GETCHECKBOXVALUEFROMREG(m_binNumericRegistryEntries[WebPage_CheckForWAISDB].ulFieldValue));
	
	m_spinMaxConnections.SetRange(MINMAXCONNECTIONS, MAXMAXCONNECTIONS);
	m_spinMaxConnections.SetPos(LESSOROF((m_binNumericRegistryEntries[WebPage_MaxConnections].ulFieldValue / 
	   m_binNumericRegistryEntries[WebPage_MaxConnections].ulMultipleFactor), MAXMAXCONNECTIONS));
  
   	m_editDirBrowseControl.LimitText(8);
	m_ulDirBrowseControl = m_binNumericRegistryEntries[WebPage_DirBrowseControl].ulFieldValue;

	m_strNTAuthenticationProviders =  m_binStringRegistryEntries[WebPage_NTAuthenticationProviders].strFieldValue;
	m_strWebAccessDeniedMessage =  m_binStringRegistryEntries[WebPage_AccessDeniedMessage].strFieldValue;

	UpdateData(FALSE);		// Force Edit box(es) to pick up value(s)



   	m_bSetChanged = TRUE;	// Any more changes come from the user
	
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CWEBGENP1::OnEnsvclocdata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[WebPage_EnableSvcLoc].bIsChanged = TRUE;
	   
	   m_binNumericRegistryEntries[WebPage_EnableSvcLoc].ulFieldValue = 
	      GETREGVALUEFROMCHECKBOX(m_cboxEnSvcLoc.GetCheck());

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
	
}

void CWEBGENP1::OnEnwaisdata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[WebPage_CheckForWAISDB].bIsChanged = TRUE;
	   
	   m_binNumericRegistryEntries[WebPage_CheckForWAISDB].ulFieldValue = 
	      GETREGVALUEFROMCHECKBOX(m_cboxEnWais.GetCheck());

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
	
}

void CWEBGENP1::OnLoganondata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[WebPage_LogAnonymous].bIsChanged = TRUE;
	   
	   m_binNumericRegistryEntries[WebPage_LogAnonymous].ulFieldValue = 
	      GETREGVALUEFROMCHECKBOX(m_cboxLogAnon.GetCheck());

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
	
}

void CWEBGENP1::OnLognonanondata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[WebPage_LogNonAnonymous].bIsChanged = TRUE;
	   
	   m_binNumericRegistryEntries[WebPage_LogNonAnonymous].ulFieldValue = 
	      GETREGVALUEFROMCHECKBOX(m_cboxLogNonAnon.GetCheck());

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
	
}


void CWEBGENP1::OnChangeMaxconnectionsdata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[WebPage_MaxConnections].bIsChanged = TRUE;	
	   m_binNumericRegistryEntries[WebPage_MaxConnections].ulFieldValue = m_spinMaxConnections.GetPos() 
	      * m_binNumericRegistryEntries[WebPage_MaxConnections].ulMultipleFactor;		

	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
	
}

void CWEBGENP1::OnChangeDirbrowsecontroldata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binNumericRegistryEntries[WebPage_DirBrowseControl].bIsChanged = TRUE;
	   	   
	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
	
}

void CWEBGENP1::OnChangeNtauthenticationprovidersdata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binStringRegistryEntries[WebPage_NTAuthenticationProviders].bIsChanged = TRUE;
	   	   
	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
	
}


void CWEBGENP1::OnChangeWebaccessdeniedmessagedata1() 
{
	// TODO: Add your control notification handler code here
	if (m_bSetChanged) {
	   m_binStringRegistryEntries[WebPage_AccessDeniedMessage].bIsChanged = TRUE;
	   	   
	   m_bIsDirty = TRUE;
	   SetModified(TRUE);
	}
	
	
}

void CWEBGENP1::SaveInfo()
{

if (m_bIsDirty) {
   m_binNumericRegistryEntries[WebPage_DirBrowseControl].ulFieldValue = m_ulDirBrowseControl;

   m_binStringRegistryEntries[WebPage_NTAuthenticationProviders].strFieldValue = m_strNTAuthenticationProviders;
   m_binStringRegistryEntries[WebPage_AccessDeniedMessage].strFieldValue = m_strWebAccessDeniedMessage;

   SaveNumericInfo(m_binNumericRegistryEntries, WebPage_TotalNumRegEntries);
   SaveStringInfo(m_binStringRegistryEntries, WebPage_TotalStringRegEntries);


}

CGenPage::SaveInfo();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\addons.cpp ===
// low-level support for the add-on services

// this may be superceeded if the add-on services go to ocxs

#include "stdafx.h"
#include "keyobjs.h"
#include "addons.h"


//----------------------------------------------------------------
// construction
//----------------------------------------------------------------
CAddOnService::CAddOnService() :
		m_library( NULL ),
		m_proc( NULL )
	{;}

//----------------------------------------------------------------
// destruction
//----------------------------------------------------------------
CAddOnService::~CAddOnService()
	{
	// free the library if it has been loaded
	if ( m_library )
		FreeLibrary( m_library );
	m_library = NULL;
	}

//----------------------------------------------------------------
// Initialize the service. Loads the dll and makes sure
// the callback we need is there
//----------------------------------------------------------------
BOOL CAddOnService::FInitializeAddOnService( CString &szName )
	{
	// load the library module
	m_library = LoadLibrary( szName );

	DWORD err = GetLastError();

	// did we successfully load the library?
	if ( !m_library ) return FALSE;

	// get the main procedure address
	m_proc = (LOADPROC)GetProcAddress( m_library, "LoadService" );

	// did we successfully load the procedure address?
	if ( !m_proc )
		{
		FreeLibrary( m_library );
		m_library = NULL;
		return FALSE;
		}

	// success!
	return TRUE;
	}

//----------------------------------------------------------------
// call into the dll to create a new service object that
// gets connected to a machine object
//----------------------------------------------------------------
BOOL CAddOnService::LoadService( CMachine* pMachine )
	{
	ASSERT( m_library );
	ASSERT( m_proc );

	// call into the dll to load a service object into the machine object
	return (*m_proc)( pMachine );
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\admninfo.cpp ===
// AdmnInfo.cpp : implementation file
//

/*
IDD_ADNIM_INFO DIALOG DISCARDABLE  0, 0, 216, 58
STYLE DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Administrator Information"
FONT 8, "MS Sans Serif"
BEGIN
    DEFPUSHBUTTON   "OK",IDOK,159,7,50,14
    PUSHBUTTON      "Cancel",IDCANCEL,159,24,50,14
    LTEXT           "E-mail address:",IDC_STATIC,7,9,48,8
    LTEXT           "Phone number:",IDC_STATIC,7,26,49,8
    EDITTEXT        IDC_EMAIL_ADDRESS,60,7,82,14,ES_AUTOHSCROLL
    EDITTEXT        IDC_PHONE_NUMBER,60,24,82,14,ES_AUTOHSCROLL
END

    IDS_SERVER_INFO_STRING  "Microsoft Key Manager 1.0 for IIS 2.0"


	#define IDS_SERVER_INFO_STRING          61450
*/

#include "stdafx.h"
#include "keyring.h"
#include "AdmnInfo.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAdminInfoDlg dialog


CAdminInfoDlg::CAdminInfoDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CAdminInfoDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CAdminInfoDlg)
	m_sz_email = _T("");
	m_sz_phone = _T("");
	//}}AFX_DATA_INIT
}


void CAdminInfoDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAdminInfoDlg)
	DDX_Text(pDX, IDC_EMAIL_ADDRESS, m_sz_email);
	DDX_Text(pDX, IDC_PHONE_NUMBER, m_sz_phone);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAdminInfoDlg, CDialog)
	//{{AFX_MSG_MAP(CAdminInfoDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAdminInfoDlg message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\addons.h ===
// low-level support for the add-on services

typedef BOOL (FAR _cdecl *LOADPROC)( CMachine* pMachine );


//----------------------------------------------------
class CAddOnService : public CObject
	{
	public:
		// construction
		CAddOnService();
		// destruction
		~CAddOnService();

		// Initialize the service. Loads the dll and makes sure
		// the callback we need is there
		BOOL FInitializeAddOnService( CString &szName );

		// call into the dll to create a new service object that
		// gets connected to a machine object
		BOOL LoadService( CMachine* pMachine );

	private:
		HINSTANCE	m_library;
		LOADPROC	m_proc;
//		BOOL		(*m_proc) ();
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\certcli.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.02.88 */
/* at Thu Jun 05 08:58:34 1997
 */
/* Compiler settings for certcli.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __certcli_h__
#define __certcli_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __ICertGetConfig_FWD_DEFINED__
#define __ICertGetConfig_FWD_DEFINED__
typedef interface ICertGetConfig ICertGetConfig;
#endif 	/* __ICertGetConfig_FWD_DEFINED__ */


#ifndef __ICertConfig_FWD_DEFINED__
#define __ICertConfig_FWD_DEFINED__
typedef interface ICertConfig ICertConfig;
#endif 	/* __ICertConfig_FWD_DEFINED__ */


#ifndef __ICertRequest_FWD_DEFINED__
#define __ICertRequest_FWD_DEFINED__
typedef interface ICertRequest ICertRequest;
#endif 	/* __ICertRequest_FWD_DEFINED__ */


#ifndef __CCertGetConfig_FWD_DEFINED__
#define __CCertGetConfig_FWD_DEFINED__

#ifdef __cplusplus
typedef class CCertGetConfig CCertGetConfig;
#else
typedef struct CCertGetConfig CCertGetConfig;
#endif /* __cplusplus */

#endif 	/* __CCertGetConfig_FWD_DEFINED__ */


#ifndef __CCertConfig_FWD_DEFINED__
#define __CCertConfig_FWD_DEFINED__

#ifdef __cplusplus
typedef class CCertConfig CCertConfig;
#else
typedef struct CCertConfig CCertConfig;
#endif /* __cplusplus */

#endif 	/* __CCertConfig_FWD_DEFINED__ */


#ifndef __CCertRequest_FWD_DEFINED__
#define __CCertRequest_FWD_DEFINED__

#ifdef __cplusplus
typedef class CCertRequest CCertRequest;
#else
typedef struct CCertRequest CCertRequest;
#endif /* __cplusplus */

#endif 	/* __CCertRequest_FWD_DEFINED__ */


/* header files for imported files */
#include "wtypes.h"
#include "oaidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __ICertGetConfig_INTERFACE_DEFINED__
#define __ICertGetConfig_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICertGetConfig
 * at Thu Jun 05 08:58:34 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_ICertGetConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("c7ea09c0-ce17-11d0-8833-00a0c903b83c")
    ICertGetConfig : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetConfig( 
            /* [in] */ LONG Flags,
            /* [retval][out] */ BSTR __RPC_FAR *pstrOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICertGetConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICertGetConfig __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICertGetConfig __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICertGetConfig __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICertGetConfig __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICertGetConfig __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICertGetConfig __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICertGetConfig __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConfig )( 
            ICertGetConfig __RPC_FAR * This,
            /* [in] */ LONG Flags,
            /* [retval][out] */ BSTR __RPC_FAR *pstrOut);
        
        END_INTERFACE
    } ICertGetConfigVtbl;

    interface ICertGetConfig
    {
        CONST_VTBL struct ICertGetConfigVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICertGetConfig_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICertGetConfig_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICertGetConfig_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICertGetConfig_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICertGetConfig_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICertGetConfig_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICertGetConfig_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICertGetConfig_GetConfig(This,Flags,pstrOut)	\
    (This)->lpVtbl -> GetConfig(This,Flags,pstrOut)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICertGetConfig_GetConfig_Proxy( 
    ICertGetConfig __RPC_FAR * This,
    /* [in] */ LONG Flags,
    /* [retval][out] */ BSTR __RPC_FAR *pstrOut);


void __RPC_STUB ICertGetConfig_GetConfig_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICertGetConfig_INTERFACE_DEFINED__ */


#ifndef __ICertConfig_INTERFACE_DEFINED__
#define __ICertConfig_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICertConfig
 * at Thu Jun 05 08:58:34 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_ICertConfig;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("372fce34-4324-11d0-8810-00a0c903b83c")
    ICertConfig : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Reset( 
            /* [in] */ LONG Index,
            /* [retval][out] */ LONG __RPC_FAR *pCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [retval][out] */ LONG __RPC_FAR *pIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetField( 
            /* [in] */ const BSTR strFieldName,
            /* [retval][out] */ BSTR __RPC_FAR *pstrOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConfig( 
            /* [in] */ LONG Flags,
            /* [retval][out] */ BSTR __RPC_FAR *pstrOut) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICertConfigVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICertConfig __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICertConfig __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICertConfig __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICertConfig __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICertConfig __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICertConfig __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICertConfig __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            ICertConfig __RPC_FAR * This,
            /* [in] */ LONG Index,
            /* [retval][out] */ LONG __RPC_FAR *pCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            ICertConfig __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *pIndex);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetField )( 
            ICertConfig __RPC_FAR * This,
            /* [in] */ const BSTR strFieldName,
            /* [retval][out] */ BSTR __RPC_FAR *pstrOut);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConfig )( 
            ICertConfig __RPC_FAR * This,
            /* [in] */ LONG Flags,
            /* [retval][out] */ BSTR __RPC_FAR *pstrOut);
        
        END_INTERFACE
    } ICertConfigVtbl;

    interface ICertConfig
    {
        CONST_VTBL struct ICertConfigVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICertConfig_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICertConfig_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICertConfig_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICertConfig_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICertConfig_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICertConfig_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICertConfig_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICertConfig_Reset(This,Index,pCount)	\
    (This)->lpVtbl -> Reset(This,Index,pCount)

#define ICertConfig_Next(This,pIndex)	\
    (This)->lpVtbl -> Next(This,pIndex)

#define ICertConfig_GetField(This,strFieldName,pstrOut)	\
    (This)->lpVtbl -> GetField(This,strFieldName,pstrOut)

#define ICertConfig_GetConfig(This,Flags,pstrOut)	\
    (This)->lpVtbl -> GetConfig(This,Flags,pstrOut)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICertConfig_Reset_Proxy( 
    ICertConfig __RPC_FAR * This,
    /* [in] */ LONG Index,
    /* [retval][out] */ LONG __RPC_FAR *pCount);


void __RPC_STUB ICertConfig_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICertConfig_Next_Proxy( 
    ICertConfig __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *pIndex);


void __RPC_STUB ICertConfig_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICertConfig_GetField_Proxy( 
    ICertConfig __RPC_FAR * This,
    /* [in] */ const BSTR strFieldName,
    /* [retval][out] */ BSTR __RPC_FAR *pstrOut);


void __RPC_STUB ICertConfig_GetField_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICertConfig_GetConfig_Proxy( 
    ICertConfig __RPC_FAR * This,
    /* [in] */ LONG Flags,
    /* [retval][out] */ BSTR __RPC_FAR *pstrOut);


void __RPC_STUB ICertConfig_GetConfig_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICertConfig_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_certcli_0092
 * at Thu Jun 05 08:58:34 1997
 * using MIDL 3.02.88
 ****************************************/
/* [local] */ 


#define	CR_IN_BASE64HEADER	( 0 )

#define	CR_IN_BASE64	( 0x1 )

#define	CR_IN_BINARY	( 0x2 )

#define	CR_IN_ENCODEMASK	( 0xff )

#define	CR_IN_PKCS10	( 0x100 )

#define	CR_IN_KEYGEN	( 0x200 )

#define	CR_IN_FORMATMASK	( 0xff00 )

#define	CR_IN_ENCRYPTED_REQUEST	( 0x10000 )

#define	CR_IN_ENCRYPTED_ATTRIBUTES	( 0x20000 )

#define	CR_DISP_INCOMPLETE	( 0 )

#define	CR_DISP_ERROR	( 0x1 )

#define	CR_DISP_DENIED	( 0x2 )

#define	CR_DISP_ISSUED	( 0x3 )

#define	CR_DISP_ISSUED_OUT_OF_BAND	( 0x4 )

#define	CR_DISP_UNDER_SUBMISSION	( 0x5 )

#define	CR_OUT_BASE64HEADER	( 0 )

#define	CR_OUT_BASE64	( 0x1 )

#define	CR_OUT_BINARY	( 0x2 )

#define	CR_OUT_ENCODEMASK	( 0xff )

#define	CR_OUT_CHAIN	( 0x100 )



extern RPC_IF_HANDLE __MIDL_itf_certcli_0092_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_certcli_0092_v0_0_s_ifspec;

#ifndef __ICertRequest_INTERFACE_DEFINED__
#define __ICertRequest_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICertRequest
 * at Thu Jun 05 08:58:34 1997
 * using MIDL 3.02.88
 ****************************************/
/* [unique][helpstring][dual][uuid][object] */ 



EXTERN_C const IID IID_ICertRequest;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("014e4840-5523-11d0-8812-00a0c903b83c")
    ICertRequest : public IDispatch
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Submit( 
            /* [in] */ LONG Flags,
            /* [in] */ const BSTR strRequest,
            /* [in] */ const BSTR strAttributes,
            /* [in] */ const BSTR strConfig,
            /* [retval][out] */ LONG __RPC_FAR *pDisposition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RetrievePending( 
            /* [in] */ LONG RequestId,
            /* [in] */ const BSTR strConfig,
            /* [retval][out] */ LONG __RPC_FAR *pDisposition) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLastStatus( 
            /* [retval][out] */ LONG __RPC_FAR *pStatus) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRequestId( 
            /* [retval][out] */ LONG __RPC_FAR *pRequestId) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDispositionMessage( 
            /* [retval][out] */ BSTR __RPC_FAR *pstrDispositionMessage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCACertificate( 
            /* [in] */ LONG fExchangeCertificate,
            /* [in] */ const BSTR strConfig,
            /* [in] */ LONG Flags,
            /* [retval][out] */ BSTR __RPC_FAR *pstrCertificate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCertificate( 
            /* [in] */ LONG Flags,
            /* [retval][out] */ BSTR __RPC_FAR *pstrCertificate) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICertRequestVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICertRequest __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICertRequest __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICertRequest __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICertRequest __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICertRequest __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICertRequest __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICertRequest __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Submit )( 
            ICertRequest __RPC_FAR * This,
            /* [in] */ LONG Flags,
            /* [in] */ const BSTR strRequest,
            /* [in] */ const BSTR strAttributes,
            /* [in] */ const BSTR strConfig,
            /* [retval][out] */ LONG __RPC_FAR *pDisposition);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RetrievePending )( 
            ICertRequest __RPC_FAR * This,
            /* [in] */ LONG RequestId,
            /* [in] */ const BSTR strConfig,
            /* [retval][out] */ LONG __RPC_FAR *pDisposition);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLastStatus )( 
            ICertRequest __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *pStatus);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRequestId )( 
            ICertRequest __RPC_FAR * This,
            /* [retval][out] */ LONG __RPC_FAR *pRequestId);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDispositionMessage )( 
            ICertRequest __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pstrDispositionMessage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCACertificate )( 
            ICertRequest __RPC_FAR * This,
            /* [in] */ LONG fExchangeCertificate,
            /* [in] */ const BSTR strConfig,
            /* [in] */ LONG Flags,
            /* [retval][out] */ BSTR __RPC_FAR *pstrCertificate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCertificate )( 
            ICertRequest __RPC_FAR * This,
            /* [in] */ LONG Flags,
            /* [retval][out] */ BSTR __RPC_FAR *pstrCertificate);
        
        END_INTERFACE
    } ICertRequestVtbl;

    interface ICertRequest
    {
        CONST_VTBL struct ICertRequestVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICertRequest_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICertRequest_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICertRequest_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICertRequest_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICertRequest_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICertRequest_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICertRequest_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICertRequest_Submit(This,Flags,strRequest,strAttributes,strConfig,pDisposition)	\
    (This)->lpVtbl -> Submit(This,Flags,strRequest,strAttributes,strConfig,pDisposition)

#define ICertRequest_RetrievePending(This,RequestId,strConfig,pDisposition)	\
    (This)->lpVtbl -> RetrievePending(This,RequestId,strConfig,pDisposition)

#define ICertRequest_GetLastStatus(This,pStatus)	\
    (This)->lpVtbl -> GetLastStatus(This,pStatus)

#define ICertRequest_GetRequestId(This,pRequestId)	\
    (This)->lpVtbl -> GetRequestId(This,pRequestId)

#define ICertRequest_GetDispositionMessage(This,pstrDispositionMessage)	\
    (This)->lpVtbl -> GetDispositionMessage(This,pstrDispositionMessage)

#define ICertRequest_GetCACertificate(This,fExchangeCertificate,strConfig,Flags,pstrCertificate)	\
    (This)->lpVtbl -> GetCACertificate(This,fExchangeCertificate,strConfig,Flags,pstrCertificate)

#define ICertRequest_GetCertificate(This,Flags,pstrCertificate)	\
    (This)->lpVtbl -> GetCertificate(This,Flags,pstrCertificate)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICertRequest_Submit_Proxy( 
    ICertRequest __RPC_FAR * This,
    /* [in] */ LONG Flags,
    /* [in] */ const BSTR strRequest,
    /* [in] */ const BSTR strAttributes,
    /* [in] */ const BSTR strConfig,
    /* [retval][out] */ LONG __RPC_FAR *pDisposition);


void __RPC_STUB ICertRequest_Submit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICertRequest_RetrievePending_Proxy( 
    ICertRequest __RPC_FAR * This,
    /* [in] */ LONG RequestId,
    /* [in] */ const BSTR strConfig,
    /* [retval][out] */ LONG __RPC_FAR *pDisposition);


void __RPC_STUB ICertRequest_RetrievePending_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICertRequest_GetLastStatus_Proxy( 
    ICertRequest __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *pStatus);


void __RPC_STUB ICertRequest_GetLastStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICertRequest_GetRequestId_Proxy( 
    ICertRequest __RPC_FAR * This,
    /* [retval][out] */ LONG __RPC_FAR *pRequestId);


void __RPC_STUB ICertRequest_GetRequestId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICertRequest_GetDispositionMessage_Proxy( 
    ICertRequest __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pstrDispositionMessage);


void __RPC_STUB ICertRequest_GetDispositionMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICertRequest_GetCACertificate_Proxy( 
    ICertRequest __RPC_FAR * This,
    /* [in] */ LONG fExchangeCertificate,
    /* [in] */ const BSTR strConfig,
    /* [in] */ LONG Flags,
    /* [retval][out] */ BSTR __RPC_FAR *pstrCertificate);


void __RPC_STUB ICertRequest_GetCACertificate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICertRequest_GetCertificate_Proxy( 
    ICertRequest __RPC_FAR * This,
    /* [in] */ LONG Flags,
    /* [retval][out] */ BSTR __RPC_FAR *pstrCertificate);


void __RPC_STUB ICertRequest_GetCertificate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICertRequest_INTERFACE_DEFINED__ */



#ifndef __CERTCLIENTLib_LIBRARY_DEFINED__
#define __CERTCLIENTLib_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: CERTCLIENTLib
 * at Thu Jun 05 08:58:34 1997
 * using MIDL 3.02.88
 ****************************************/
/* [helpstring][version][uuid] */ 



EXTERN_C const IID LIBID_CERTCLIENTLib;

EXTERN_C const CLSID CLSID_CCertGetConfig;

#ifdef __cplusplus

class DECLSPEC_UUID("c6cc49b0-ce17-11d0-8833-00a0c903b83c")
CCertGetConfig;
#endif

EXTERN_C const CLSID CLSID_CCertConfig;

#ifdef __cplusplus

class DECLSPEC_UUID("372fce38-4324-11d0-8810-00a0c903b83c")
CCertConfig;
#endif

EXTERN_C const CLSID CLSID_CCertRequest;

#ifdef __cplusplus

class DECLSPEC_UUID("98aff3f0-5524-11d0-8812-00a0c903b83c")
CCertRequest;
#endif
#endif /* __CERTCLIENTLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\cmachine.cpp ===
// implements much of the exported CMachine

#include "stdafx.h"
#include "KeyObjs.h"

IMPLEMENT_DYNCREATE(CMachine, CTreeItem);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\algid.h ===
// ALG_ID crackers
#define GET_ALG_CLASS(x)                (x & (3 << 14))
#define GET_ALG_TYPE(x)                 (x & (15 << 10))
#define GET_ALG_SID(x)                  (x & (511))

// Algorithm classes
//
#define ALG_CLASS_SIGNATURE             (0 << 14)
#define ALG_CLASS_MSG_ENCRYPT   (1 << 14)
#define ALG_CLASS_DATA_ENCRYPT  (2 << 14)
#define ALG_CLASS_HASH                  (3 << 14)
#define ALG_CLASS_KEY_EXCHANGE  (4 << 14)

// Algorithm types
//
#define ALG_TYPE_ANY                    (0)
#define ALG_TYPE_DSA                    (1 << 10)
#define ALG_TYPE_RSA                    (2 << 10)
#define ALG_TYPE_BLOCK                  (3 << 10)
#define ALG_TYPE_STREAM                 (4 << 10)

// Some RSA sub-ids
//
#define ALG_SID_RSA_ANY                         0
#define ALG_SID_RSA_PKCS                        1
#define ALG_SID_RSA_MSATWORK            2
#define ALG_SID_RSA_ENTRUST                     3
#define ALG_SID_RSA_PGP                         4

// Some DSS sub-ids
//
#define ALG_SID_DSS_ANY                         0
#define ALG_SID_DSS_PKCS                        1
#define ALG_SID_DSS_DMS                         2

// Block cipher sub ids
// DES sub_ids
#define ALG_SID_DES_ECB                         0
#define ALG_SID_DES_CBC                         1
#define ALG_SID_DES_CFB                         2
#define ALG_SID_DES_OFB                         3

// RC2 sub-ids
#define ALG_SID_RC2_ECB                         4
#define ALG_SID_RC2_CBC                         5
#define ALG_SID_RC2_CFB                         6
#define ALG_SID_RC2_OFB                         7

// Stream cipher sub-ids
#define ALG_SID_RC4                                     0
#define ALG_SID_SEAL                            1

// Hash sub ids
#define ALG_SID_MD2                                     0
#define ALG_SID_MD4                                     1
#define ALG_SID_MD5                                     2
#define ALG_SID_SHA                                     3

// Our example sub-id
#define ALG_SID_EXAMPLE         80

typedef int ALG_ID;


#define MD2                                     ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_MD2
#define MD4                                     ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_MD4
#define MD5                                     ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_MD5
#define SHA                                     ALG_CLASS_HASH | ALG_TYPE_ANY | ALG_SID_SHA
#define RSA_SIGNATURE           ALG_CLASS_SIGNATURE | ALG_TYPE_RSA | ALG_SID_RSA_ANY
#define DSS_SIGNATURE           ALG_CLASS_SIGNATURE | ALG_TYPE_DSA | ALG_SID_DSA_ANY
#define RSA_KEYEXCHANGE         ALG_CLASS_KEY_EXCHANGE | ALG_TYPE_RSA | ALG_SID_RSA_ANY
#define DES_ECB                         ALG_CLASS_DATA_ENCRYPT | ALG_TYPE_BLOCK | ALG_SID_DES_ECB
#define DES_CBC                         ALG_CLASS_DATA_ENCRYPT | ALG_TYPE_BLOCK | ALG_SID_DES_CBC
#define DES_CFB                         ALG_CLASS_DATA_ENCRYPT | ALG_TYPE_BLOCK | ALG_SID_DES_CFB
#define DES_OFB                         ALG_CLASS_DATA_ENCRYPT | ALG_TYPE_BLOCK | ALG_SID_DES_OFB
#define RC2_ECB                         ALG_CLASS_DATA_ENCRYPT | ALG_TYPE_BLOCK | ALG_SID_RC2_ECB
#define RC2_CBC                         ALG_CLASS_DATA_ENCRYPT | ALG_TYPE_BLOCK | ALG_SID_RC2_CBC
#define RC2_CFB                         ALG_CLASS_DATA_ENCRYPT | ALG_TYPE_BLOCK | ALG_SID_RC2_CFB
#define RC2_OFB                         ALG_CLASS_DATA_ENCRYPT | ALG_TYPE_BLOCK | ALG_SID_RC2_OFB
#define RC4                                     ALG_CLASS_DATA_ENCRYPT | ALG_TYPE_STREAM | ALG_SID_RC4
#define SEAL                            ALG_CLASS_DATA_ENCRYPT | ALG_TYPE_STREAM | ALG_SID_SEAL



#define MAXNAMELEN                      0x60

#define BASIC_RSA       0
#define MD2_WITH_RSA    1
#define MD5_WITH_RSA    2
#define RC4_STREAM      3
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\ckey.cpp ===
// implements much of the exported CKey

#include "stdafx.h"
#include "resource.h"
#include "KeyObjs.h"
#include "passdlg.h"
#include "AdmnInfo.h"

#include "NKChseCA.h"
#include "NKDN.h"
#include "NKDN2.h"
#include "NKKyInfo.h"
#include "NKUsrInf.h"
#include "creating.h"

#include "resource.h"
#include "intrlkey.h"

#include <iis64.h>

#define SECURITY_WIN32
extern "C"
{
    #include <wincrypt.h>
//  #include <sslsp.h>
    #include <schnlsp.h>
    #include <sspi.h>
    #include <ISSPERR.h>
}

#include "mismtchd.h"

#define CRLF "\r\n"
// NON_LOCALIZABLE strings for use in the request header
#define HEADER_ADMINISTRATOR    _T(CRLF "Webmaster: ")
#define HEADER_PHONE            _T(CRLF "Phone: ")
#define HEADER_SERVER           _T(CRLF "Server: ")
#define HEADER_COMMON_NAME      _T(CRLF CRLF "Common-name: ")
#define HEADER_ORG_UNIT         _T(CRLF "Organization Unit: ")
#define HEADER_ORGANIZATION     _T(CRLF "Organization: ")
#define HEADER_LOCALITY         _T(CRLF "Locality: ")
#define HEADER_STATE            _T(CRLF "State: ")
#define HEADER_COUNTRY          _T(CRLF "Country: ")
#define HEADER_END_SPACING      _T(CRLF CRLF )

// defines taken from the old KeyGen utility
#define MESSAGE_HEADER  "-----BEGIN NEW CERTIFICATE REQUEST-----\r\n"
#define MESSAGE_TRAILER "-----END NEW CERTIFICATE REQUEST-----\r\n"
#define MIME_TYPE       "Content-Type: application/x-pkcs10\r\n"
#define MIME_ENCODING   "Content-Transfer-Encoding: base64\r\n\r\n"

int HTUU_encode(unsigned char *bufin, unsigned int nbytes, char *bufcoded);


#define     BACKUP_ID   'KRBK'


IMPLEMENT_DYNCREATE(CKey, CTreeItem);

//------------------------------------------------------------------------------
CKey::CKey():
        m_cbPrivateKey( 0 ),
        m_pPrivateKey( NULL ),
        m_cbCertificate( 0 ),
        m_pCertificate( NULL ),
        m_cbCertificateRequest( 0 ),
        m_pCertificateRequest( NULL )
    {;}

//------------------------------------------------------------------------------
CKey::~CKey()
    {
    LPTSTR pBuff;

    // specifically write zeros out over the password
    try
        {
        pBuff = m_szPassword.GetBuffer(256);
        }
    catch( CException e )
        {
        pBuff = NULL;
        }

    if ( pBuff )
        {
        // zero out the buffer
        ZeroMemory( pBuff, 256 );
        // release the buffer
        m_szPassword.ReleaseBuffer(0);
        }

    // zero out the private key and the certificate
    if ( m_pPrivateKey )
        {
        // zero out the buffer
        ZeroMemory( m_pPrivateKey, m_cbPrivateKey );
        // free the pointer
        GlobalFree( (HANDLE)m_pPrivateKey );
        m_pPrivateKey = NULL;
        }
    if ( m_pCertificate )
        {
        // zero out the buffer
        ZeroMemory( m_pCertificate, m_cbCertificate );
        // free the pointer
        GlobalFree( (HANDLE)m_pCertificate );
        m_pCertificate = NULL;
        }
    if ( m_pCertificateRequest )
        {
        // zero out the buffer
        ZeroMemory( m_pCertificateRequest, m_cbCertificateRequest );
        // free the pointer
        GlobalFree( (HANDLE)m_pCertificateRequest );
        m_pCertificate = NULL;
        }
    }

//------------------------------------------------------------------------------
CKey* CKey::PClone( void )
    {
    CKey*   pClone = NULL;

    // TRY to make a new key object
    try
        {
        pClone = new CKey();
        // copy over all the data
        pClone->CopyDataFrom( this );
        }
    catch( CException e )
        {
        // if the object had been made, delete it
        if ( pClone )
            delete pClone;
        return NULL;
        }

    return pClone;
    }

//------------------------------------------------------------------------------
void CKey::CopyDataFrom( CKey* pKey )
    {
    // make sure this is ok
    ASSERT( pKey );
    ASSERT( pKey->IsKindOf(RUNTIME_CLASS(CKey)) );
    if ( !pKey ) return;

    // delete any data currently in this key
    // zero out the private key and the certificate
    if ( m_pPrivateKey )
        {
        ZeroMemory( m_pPrivateKey, m_cbPrivateKey );
        GlobalFree( (HANDLE)m_pPrivateKey );
        m_pPrivateKey = NULL;
        }
    if ( m_pCertificate )
        {
        ZeroMemory( m_pCertificate, m_cbCertificate );
        GlobalFree( (HANDLE)m_pCertificate );
        m_pCertificate = NULL;
        }
    if ( m_pCertificateRequest )
        {
        ZeroMemory( m_pCertificateRequest, m_cbCertificateRequest );
        GlobalFree( (HANDLE)m_pCertificateRequest );
        m_pCertificate = NULL;
        }

    // copy over the basic stuff
    m_szItemName = pKey->m_szItemName;
    m_iImage = pKey->m_iImage;
    m_szPassword = pKey->m_szPassword;
    m_cbPrivateKey = pKey->m_cbPrivateKey;
    m_cbCertificate = pKey->m_cbCertificate;
    m_cbCertificateRequest = pKey->m_cbCertificateRequest;

    // now the pointer based data
    if ( pKey->m_pPrivateKey )
        {
        m_pPrivateKey = GlobalAlloc( GPTR, m_cbPrivateKey );
        if ( !m_pPrivateKey ) AfxThrowMemoryException();
        memcpy( m_pPrivateKey, pKey->m_pPrivateKey, m_cbPrivateKey );
        }

    if ( pKey->m_pCertificate )
        {
        m_pCertificate = GlobalAlloc( GPTR, m_cbCertificate );
        if ( !m_pCertificate ) AfxThrowMemoryException();
        memcpy( m_pCertificate, pKey->m_pCertificate, m_cbCertificate );
        }

    if ( pKey->m_pCertificateRequest )
        {
        m_pCertificateRequest = GlobalAlloc( GPTR, m_cbCertificateRequest );
        if ( !m_pCertificateRequest ) AfxThrowMemoryException();
        memcpy( m_pCertificateRequest, pKey->m_pCertificateRequest,
                m_cbCertificateRequest );
        }
    }

//------------------------------------------------------------------------------
void CKey::SetName( CString &szNewName )
    {
    m_szItemName = szNewName;
    UpdateCaption();
    SetDirty( TRUE );
    }

//------------------------------------------------------------------------------
void CKey::UpdateIcon( void )
    {
    // if there is no certificate, then the immature key
    if ( !m_pCertificate )
        {
        m_iImage = TREE_ICON_KEY_IMMATURE;
        FSetImage( m_iImage );
        return;
        }

    // there is a certificate, but we need to see if it has
    // expired or not. We do that by cracking the certificate
    // default the key to being ok
    m_iImage = TREE_ICON_KEY_OK;
    CKeyCrackedData cracker;

    // crack the key
    if ( cracker.CrackKey(this) )
        {
        // get the expiration time
        CTime   ctimeExpires( cracker.GetValidUntil() );

        // get the current time
        CTime   ctimeCurrent = CTime::GetCurrentTime();

        // test if it has expired first
        if ( ctimeCurrent > ctimeExpires )
            m_iImage = TREE_ICON_KEY_EXPIRED;
        }

    // set the image
    FSetImage( m_iImage );
    }

//------------------------------------------------------------------------------
BOOL CKey::FInstallCertificate( CString szPath, CString szPass )
    {
    CFile       cfile;
    PVOID       pData = NULL;
    BOOL        fSuccess =FALSE;;

    // open the file
    if ( !cfile.Open( szPath, CFile::modeRead | CFile::shareDenyNone ) )
        return FALSE;

    // how big is the file - add one so we can zero terminate the buffer
    DWORD   cbCertificate = cfile.GetLength() + 1;

    // make sure the file has some size
    if ( !cbCertificate )
        {
        AfxMessageBox( IDS_ERR_INVALID_CERTIFICATE, MB_OK | MB_ICONINFORMATION );
        return FALSE;
        }

    // put the rest of the operation in a try/catch
    // specifically write zeros out over the password
    try
        {
        // allocate space for the data
        pData = GlobalAlloc( GPTR, cbCertificate );
        if ( !pData ) AfxThrowMemoryException();

        // copy in the data from the file to the pointer - will throw and exception
        DWORD cbRead = cfile.Read( pData, cbCertificate );

        // zero terminate for decoding
        ((BYTE*)pData)[cbRead] = 0;

        // great. The last thing left is to uudecode the data we got
        uudecode_cert( (char*)pData, &cbCertificate );

        // close the file
        cfile.Close();

        // install the certificate
        fSuccess = FInstallCertificate( pData, cbCertificate, szPass );
        }
    catch( CException e )
        {
        // if the pointer was allocated, deallocate it
        if ( pData )
            {
            GlobalFree( pData );
            pData = NULL;
            }
        // return failure
        return FALSE;
        }

    // return success
    return fSuccess;
    }

//------------------------------------------------------------------------------
// it is up to the module to verify the certificate
BOOL CKey::FInstallCertificate( PVOID pCert, DWORD cbCert, CString &szPass )
    {
    // cache the old certificate in case the new one fails
    DWORD   old_cbCertificate = m_cbCertificate;
    PVOID   old_pCertificate = m_pCertificate;

    // set the new one into place
    m_cbCertificate = cbCert;
    m_pCertificate = pCert;

/*  // MOVED TO THE MODULE
    // verify the password
    if ( !FVerifyValidPassword(szPass) )
        {
        // resore the old values
        m_cbCertificate = old_cbCertificate;
        m_pCertificate = old_pCertificate;

        // dispose of the new stuff
        GlobalFree( pCert );

        // return false
        return FALSE;
        }
*/

    // Re-Set the password, incase we stored a request from Backup file.
    m_szPassword = szPass;

    // it checks out ok, so we can get rid of the old stuff
    // be careful not to get rid of the current test cert if that is whats there
    if ( old_pCertificate && (old_pCertificate != pCert) )
        {
        GlobalFree( old_pCertificate );
        old_pCertificate = NULL;
        }

    // mark the key as dirty
    SetDirty( TRUE );
    return TRUE;
    }

//------------------------------------------------------------------------------
// verfying a valid password is now a several-stop process. First we have to verify
// that the certificate is the correct one that was requested. Apparenly lots of
// users out there are attempting to install either invalid certificates, or valid
// certificates on the wrong key. Then, when they can't figure out that they messed
// it up, they call us. Or Verisign. To do this we use CAPI2 to get a certificate context
// from the certificate. If that fails is in an invalid cert (say... an EXE file).
// Then we test that certificat's public key to see if it matches the public key
// stored in the request (which we also have to use CAPI2 to crack) If there is no
// request (keyset files) then tough bannanas. They will have to rely on the errors
// returned by the AcquireCredentialsHandle routine.

BOOL CKey::FVerifyValidPassword( CString szPassword )
    {
    PVOID                       pRequestObject = NULL;
    PCCERT_CONTEXT              pcontextCertificate = NULL;
    BOOL                        fAnswer = TRUE;

    SSL_CREDENTIAL_CERTIFICATE  creds;
    CredHandle                  hCreds;
    SECURITY_STATUS             scRet;
    TimeStamp                   ts;
    DWORD                       err;

    CString                     sz;
    CString                     szErr;

    // skip the private, internal request header
    PUCHAR      pRequest = NULL;
    DWORD       cbRequest = 0;

    PUCHAR      pcert = (PUCHAR)m_pCertificate;
    DWORD       cbcert = m_cbCertificate;

    // if the request is there, get its context
    if ( m_pCertificateRequest )
        {
        // see if this request has a header block in front of it. If it does, then use
        // it to get the real request. If it doesn't then just use the request.
        // if it does have a header the first DWORD will be REQUEST_HEADER_IDENTIFIER
        if ( *(DWORD*)m_pCertificateRequest == REQUEST_HEADER_IDENTIFIER )
            {
            // get the real request that comes after the request header
            pRequest = (PUCHAR)m_pCertificateRequest +
                        ((LPREQUEST_HEADER)m_pCertificateRequest)->cbSizeOfHeader;
            cbRequest = ((LPREQUEST_HEADER)m_pCertificateRequest)->cbRequestSize;
            }
        else
            {
            // there is no header
            pRequest = (PUCHAR)m_pCertificateRequest;
            cbRequest = m_cbCertificateRequest;
            }

        // note that if the request isn't there or if it is invalid it is still
        // ok to try and verify the certificate
        DWORD   cbBuffSize = 0;
        // start by decoding the request object - get the size of the required buffer
        CryptDecodeObject( X509_ASN_ENCODING,
                                X509_CERT_REQUEST_TO_BE_SIGNED,
                                pRequest,
                                cbRequest,
                                0,
                                NULL,
                                &cbBuffSize );

        // now make an attempt to decode it
        pRequestObject = GlobalAlloc( GPTR, cbBuffSize );
        if ( !pRequestObject )
            goto GetCredentials;
        if ( !CryptDecodeObject( X509_ASN_ENCODING,
                                X509_CERT_REQUEST_TO_BE_SIGNED,
                                pRequest,
                                cbRequest,
                                0,
                                pRequestObject,
                                &cbBuffSize ) )
            {
            GlobalFree( pRequestObject );
            pRequestObject = NULL;
            goto GetCredentials;
            }

        }

  GetCredentials:

    // OK. Verisign and Certsrv and probably others too wrap the certificate in a wrapper
    // that, while following the normal formatting convensions, causes the context routine
    // below to fail. This means that we have to detect if the wrapper is there and, if it
    // is, we need to skip it. Fortunately, the wrapper contains the word "certificate"
    // yes, this is sorta grungy, but its what petesk said to do.
    sz = pcert;
    sz = sz.Left(20);
    if ( sz.Find("certificate") == 6 )
        {
        pcert += 17;
        }

    // get the context on the certificate
    pcontextCertificate = CertCreateCertificateContext( X509_ASN_ENCODING, pcert, cbcert );
    // if we were unable to create the context, then fail with an appropriate error message
    if ( !pcontextCertificate )
        {
        // get the error for the dialog
        err = GetLastError();

        // tell the user that they chose an invalid certificate
        sz.LoadString( IDS_CERTERR_INVALID_CERTIFICATE );
        sz.Format( "%s%x", sz, err );
        AfxMessageBox( sz );

        // time to leave with a failure
        fAnswer = FALSE;
        goto cleanup;
        }


    // if we have both a cert context AND a decoded request object, then we can confirm that
    // they are in fact matched to each other.
    if ( pcontextCertificate && pRequestObject )
        {
        // use CAPI2 to do the comparison between the two public key info structures
        if ( !CertComparePublicKeyInfo( X509_ASN_ENCODING,
                            &((PCERT_REQUEST_INFO)pRequestObject)->SubjectPublicKeyInfo,
                            &pcontextCertificate->pCertInfo->SubjectPublicKeyInfo ) )
            {
            // The certificate is mis-matched to the request. Fail with the right message
            CMismatchedCertDlg  mismatchdlg(
                        &((PCERT_REQUEST_INFO)pRequestObject)->Subject,
                        &pcontextCertificate->pCertInfo->Subject);
            mismatchdlg.DoModal();

            fAnswer = FALSE;
            goto cleanup;
            }
        }


    // use SSL to finish verifying the password
    // fill in the credentials record
    creds.cbPrivateKey = m_cbPrivateKey;
    creds.pPrivateKey = (PUCHAR)m_pPrivateKey;
    creds.cbCertificate = m_cbCertificate;
    creds.pCertificate = (PUCHAR)m_pCertificate;

    // prepare the password
    creds.pszPassword = (PSTR)LPCTSTR(szPassword);

    // attempt to get the credentials
    scRet = AcquireCredentialsHandleW(  NULL,                   // My name (ignored)
                                        UNISP_NAME_W,           // Package
                                        SECPKG_CRED_INBOUND,    // Use
                                        NULL,                   // Logon ID (ignored)
                                        &creds,                 // auth data
                                        NULL,                   // dce-stuff
                                        NULL,                   // dce-stuff
                                        &hCreds,                // handle
                                        &ts );                  // we really get it below

    // check the results
    if ( FAILED(scRet) )
        {
        sz.Empty();

        // add on the appropriate sub-error message
        switch( scRet )
            {
            case SEC_E_UNKNOWN_CREDENTIALS:
            case SEC_E_NO_CREDENTIALS:
            case SEC_E_INTERNAL_ERROR:
                // Unfortunately, SChannel returns the "internal error" when a bad password
                // is returned. There may or may not be other circumstances under which this
                // error is returned, but this is by far the most common. Also I taked to
                // PeteSk about it and he agreed that this is how it should be used.
                // bad password
                sz.LoadString( IDS_CERTERROR_BADPASSWORD );
                break;
            case SEC_E_SECPKG_NOT_FOUND:
            case SEC_E_BAD_PKGID:
                // the system does not have the package installed
                sz.LoadString( IDS_CERTERROR_PACKAGELOAD_ERROR );
                break;
            case SEC_E_INSUFFICIENT_MEMORY:
                sz.LoadString( IDS_CERTERR_LOMEM );
                break;
            case SEC_E_CANNOT_INSTALL:
                sz.LoadString( EDS_CERTERR_SCHNL_BAD_INIT );
                break;
            default:
                sz.LoadString( IDS_CERTERR_SCHNL_GENERIC );
                break;
            }

        // put up the error message
        szErr.LoadString( IDS_CERTERR_SCHANNEL_ERR );
        sz.Format( "%s%s%x", sz, szErr, scRet );
        AfxMessageBox( sz );

        // return failure
        fAnswer = FALSE;
        goto cleanup;
        }

    // close the credentials handle
    FreeCredentialsHandle( &hCreds );

    // clean up the certificate contexts
cleanup:
    if ( pRequestObject )
        GlobalFree( pRequestObject );
    if ( pcontextCertificate )
        CertFreeCertificateContext( pcontextCertificate );

    // return success
    return fAnswer;
    }

//------------------------------------------------------------------------------
void CKey::OutputHeader( CFile* pFile, PVOID privData1, PVOID privData2 )
    {
    PADMIN_INFO pInfo = (PADMIN_INFO)privData1;

    // we start this by getting the DN strings from either the dialog that was
    // passed in through privData or throught cracking the certificate.
    CString szCN, szOU, szO, szL, szS, szC;
    CKeyCrackedData cracker;
    // the only way to get the info is from cracking an existing cert
    if ( cracker.CrackKey(this) )
        {
        cracker.GetDNNetAddress( szCN );
        cracker.GetDNUnit( szOU );
        cracker.GetDNOrganization( szO );
        cracker.GetDNLocality( szL );
        cracker.GetDNState( szS );
        cracker.GetDNCountry( szC );
        }
    else
        {
        if (pInfo->pCommonName) szCN = *pInfo->pCommonName;
        if (pInfo->pOrgUnit) szOU = *pInfo->pOrgUnit;
        if (pInfo->pOrg) szO = *pInfo->pOrg;
        if (pInfo->pLocality) szL = *pInfo->pLocality;
        if (pInfo->pState) szS = *pInfo->pState;
        if (pInfo->pCountry) szC = *pInfo->pCountry;
        }

    // ok, output all the strings, starting with the administrator information
    CString     sz = HEADER_ADMINISTRATOR;
    pFile->Write( sz, sz.GetLength() );
    if ( pInfo->pEmail )
        pFile->Write( *pInfo->pEmail, pInfo->pEmail->GetLength() );

    sz = HEADER_PHONE;
    pFile->Write( sz, sz.GetLength() );
    if ( pInfo->pPhone )
        pFile->Write( *pInfo->pPhone, pInfo->pPhone->GetLength() );

    sz = HEADER_SERVER;
    pFile->Write( sz, sz.GetLength() );
    sz.LoadString( IDS_SERVER_INFO_STRING );
    pFile->Write( sz, sz.GetLength() );

    sz = HEADER_COMMON_NAME;
    pFile->Write( sz, sz.GetLength() );
    pFile->Write( szCN, szCN.GetLength() );

    sz = HEADER_ORG_UNIT;
    pFile->Write( sz, sz.GetLength() );
    pFile->Write( szOU, szOU.GetLength() );

    sz = HEADER_ORGANIZATION;
    pFile->Write( sz, sz.GetLength() );
    pFile->Write( szO, szO.GetLength() );

    sz = HEADER_LOCALITY;
    pFile->Write( sz, sz.GetLength() );
    pFile->Write( szL, szL.GetLength() );

    sz = HEADER_STATE;
    pFile->Write( sz, sz.GetLength() );
    pFile->Write( szS, szS.GetLength() );

    sz = HEADER_COUNTRY;
    pFile->Write( sz, sz.GetLength() );
    pFile->Write( szC, szC.GetLength() );

    sz = HEADER_END_SPACING;
    pFile->Write( sz, sz.GetLength() );
    }

//------------------------------------------------------------------------------
// this routine is based on the routine "Requestify" from KeyGen
BOOL CKey::FOutputRequestFile( CString szFile, BOOL fMime, PVOID privData )
    {
    PADMIN_INFO     pAdminInfo= (PADMIN_INFO)privData;
    ADMIN_INFO      AdminInfo;
    CAdminInfoDlg   aiDlg;

    // ok, the priv data points to a structure that contains three strings
    // describing the admin requesting this request. If it is null, then we
    // must ask this information.
    if ( !pAdminInfo )
        {
        if ( aiDlg.DoModal() != IDOK )
            return FALSE;

        // fill the darned thing in
        ZeroMemory( &AdminInfo, sizeof(AdminInfo) );
        pAdminInfo = &AdminInfo;
        AdminInfo.pEmail = &aiDlg.m_sz_email;
        AdminInfo.pPhone = &aiDlg.m_sz_phone;
        }


    PUCHAR  pEncoded;
    DWORD   cbData = m_cbCertificateRequest;

    // encode the request into a new pointer
    pEncoded = PCreateEncodedRequest( m_pCertificateRequest, &cbData, FALSE );

/*
    PUCHAR  pb;
    DWORD   cb;
    PUCHAR  p;
    DWORD   Size;

    PUCHAR  pSource;
    DWORD   cbSource;

    ASSERT( pSource );
    ASSERT( cbSource );

    // we don't actually want to change the source data, so make a copy of it first
    pSource = (PUCHAR)GlobalAlloc( GPTR, m_cbCertificateRequest );
    if ( !pSource )
        {
        AfxThrowMemoryException();
        return FALSE;
        }
    cbSource = m_cbCertificateRequest;
    // copy over the data
    CopyMemory( pSource, m_pCertificateRequest, cbSource );

    cb = (cbSource * 3 / 4) + 1024;

    pb = (PUCHAR)LocalAlloc( LMEM_FIXED, cb );

    if ( !pb )
        return FALSE;

    p = pb;

    if ( fMime )
        {
        Size = strlen( MIME_TYPE );
        CopyMemory( p, MIME_TYPE, Size );
        p += Size;

        Size = strlen( MIME_ENCODING );
        CopyMemory( p, MIME_ENCODING, Size );
        p += Size;
        }
    else
        {
        Size = strlen( MESSAGE_HEADER );
        CopyMemory( p, MESSAGE_HEADER, Size );
        p += Size;
        }

    do
        {
        Size = HTUU_encode( pSource,
                        (cbSource > 48 ? 48 : cbSource),
                        (PCHAR)p );
        p += Size;

        *p++ = '\r';
        *p++ = '\n';

        if ( cbSource < 48 )
            break;

        cbSource -= 48;
        pSource += 48;
        } while (cbSource);

    if ( !fMime )
        {
        Size = strlen( MESSAGE_TRAILER );
        CopyMemory( p, MESSAGE_TRAILER, Size );
        p += Size;
        }
*/

    // write the requestified data into the target file
    try
        {
        // try to open the file
        CFile   cfile;
        if ( !cfile.Open(szFile, CFile::modeCreate | CFile::modeWrite) )
            {
            AfxMessageBox( IDS_IO_ERROR );
            return FALSE;
            }

        // write out the header stuff that simon at Verisign
        // requested at the LAST POSSIBLE MINUTE!!!
        OutputHeader( &cfile, pAdminInfo, NULL );

        // write the data to the file
//      cfile.Write( pb, (p - pb) );
        cfile.Write( pEncoded, cbData );

        // close the file
        cfile.Close();
        }
    catch( CException e )
        {
        if ( pEncoded )
            LocalFree( pEncoded );
        return FALSE;
        }

    if ( pEncoded )
        LocalFree( pEncoded );
    return TRUE;
    }

//------------------------------------------------------------------------
PUCHAR  PCreateEncodedRequest( PVOID pRequest, DWORD* pcb, BOOL fMime )
    {
    PUCHAR  pb;
    DWORD   cb;
    PUCHAR  p;
    DWORD   Size;

    PUCHAR  pSource;
    DWORD   cbSource;

    DWORD   cbRequest = *pcb;

    ASSERT( pcb && *pcb );
    ASSERT( pRequest );

    // get the correct pointer to and size of the request, taking into account the header
    LPREQUEST_HEADER pHeader = (LPREQUEST_HEADER)pRequest;
    if ( pHeader->Identifier == REQUEST_HEADER_IDENTIFIER )
        {
        pRequest = (PUCHAR)pRequest + pHeader->cbSizeOfHeader;
        cbRequest = *pcb = pHeader->cbRequestSize;
        }

    // we don't actually want to change the source data, so make a copy of it first
    pSource = (PUCHAR)GlobalAlloc( GPTR, cbRequest );
    if ( !pSource )
        {
        AfxThrowMemoryException();
        return FALSE;
        }
    cbSource = cbRequest;
    // copy over the data
    CopyMemory( pSource, pRequest, cbSource );

    cb = (cbSource * 3 / 4) + 1024;

    pb = (PUCHAR)LocalAlloc( LMEM_FIXED, cb );

    if ( !pb )
        return FALSE;

    p = pb;

    if ( fMime )
        {
        Size = strlen( MIME_TYPE );
        CopyMemory( p, MIME_TYPE, Size );
        p += Size;

        Size = strlen( MIME_ENCODING );
        CopyMemory( p, MIME_ENCODING, Size );
        p += Size;
        }
    else
        {
        Size = strlen( MESSAGE_HEADER );
        CopyMemory( p, MESSAGE_HEADER, Size );
        p += Size;
        }

    do
        {
        Size = HTUU_encode( pSource,
                        (cbSource > 48 ? 48 : cbSource),
                        (PCHAR)p );
        p += Size;

        *p++ = '\r';
        *p++ = '\n';

        if ( cbSource < 48 )
            break;

        cbSource -= 48;
        pSource += 48;
        } while (cbSource);

    if ( !fMime )
        {
        Size = strlen( MESSAGE_TRAILER );
        CopyMemory( p, MESSAGE_TRAILER, Size );
        p += Size;
        }

    // set the count of bytes into place
    *pcb = DIFF(p - pb);

    //return the pointer to the encoded information
    return pb;
    }


// Taken right out of KenGen.c
static char six2pr[64] =
{
        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
        'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
        'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',
        'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
        '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'
};

// Taken right out of KenGen.c
/*--- function HTUU_encode -----------------------------------------------
 *
 *   Encode a single line of binary data to a standard format that
 *   uses only printing ASCII characters (but takes up 33% more bytes).
 *
 *    Entry    bufin    points to a buffer of bytes.  If nbytes is not
 *                      a multiple of three, then the byte just beyond
 *                      the last byte in the buffer must be 0.
 *             nbytes   is the number of bytes in that buffer.
 *                      This cannot be more than 48.
 *             bufcoded points to an output buffer.  Be sure that this
 *                      can hold at least 1 + (4*nbytes)/3 characters.
 *
 *    Exit     bufcoded contains the coded line.  The first 4*nbytes/3 bytes
 *                      contain printing ASCII characters representing
 *                      those binary bytes. This may include one or
 *                      two '=' characters used as padding at the end.
 *                      The last byte is a zero byte.
 *             Returns the number of ASCII characters in "bufcoded".
 */

// Now the HTUU_encode is taken from infocomm/common/fcache and has been fixed by amallet
// it has been modified slightly to take into account that the output buffer was resized above
int HTUU_encode(unsigned char *bufin, unsigned int nbytes, char *bufcoded)
{
   register char *outptr = bufcoded;
   unsigned int i;
   BOOL fOneByteDiff = FALSE;
   BOOL fTwoByteDiff = FALSE;
   unsigned int iRemainder = 0;
   unsigned int iClosestMultOfThree = 0;

   iRemainder = nbytes % 3; //also works for nbytes == 1, 2
   fOneByteDiff = (iRemainder == 1 ? TRUE : FALSE);
   fTwoByteDiff = (iRemainder == 2 ? TRUE : FALSE);
   iClosestMultOfThree = ((nbytes - iRemainder)/3) * 3 ;

   //
   // Encode bytes in buffer up to multiple of 3 that is closest to nbytes.
   //
   for (i=0; i< iClosestMultOfThree ; i += 3) {
      *(outptr++) = six2pr[*bufin >> 2];            /* c1 */
      *(outptr++) = six2pr[((*bufin << 4) & 060) | ((bufin[1] >> 4) & 017)]; /*c2*/
      *(outptr++) = six2pr[((bufin[1] << 2) & 074) | ((bufin[2] >> 6) & 03)];/*c3*/
      *(outptr++) = six2pr[bufin[2] & 077];         /* c4 */

      bufin += 3;
   }

   //
   // We deal with trailing bytes by pretending that the input buffer has been padded with
   // zeros. Expressions are thus the same as above, but the second half drops off b'cos
   // ( a | ( b & 0) ) = ( a | 0 ) = a
   //
   if (fOneByteDiff)
   {
       *(outptr++) = six2pr[*bufin >> 2]; /* c1 */
       *(outptr++) = six2pr[((*bufin << 4) & 060)]; /* c2 */

       //pad with '='
       *(outptr++) = '='; /* c3 */
       *(outptr++) = '='; /* c4 */
   }
   else if (fTwoByteDiff)
   {
      *(outptr++) = six2pr[*bufin >> 2];            /* c1 */
      *(outptr++) = six2pr[((*bufin << 4) & 060) | ((bufin[1] >> 4) & 017)]; /*c2*/
      *(outptr++) = six2pr[((bufin[1] << 2) & 074)];/*c3*/

      //pad with '='
       *(outptr++) = '='; /* c4 */
   }

   //encoded buffer must be zero-terminated
   *outptr = '\0';

   return DIFF(outptr - bufcoded);
}


//============================ BASED ON SETKEY
const int pr2six[256]={
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,62,64,64,64,63,
    52,53,54,55,56,57,58,59,60,61,64,64,64,64,64,64,64,0,1,2,3,4,5,6,7,8,9,
    10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,64,64,64,64,64,64,26,27,
    28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,64,
    64,64,64,64,64,64,64,64,64,64,64,64,64
};

//
//  We have to squirt a record into the decoded stream
//

#define CERT_RECORD            13
#define CERT_SIZE_HIBYTE        2       //  Index into record of record size
#define CERT_SIZE_LOBYTE        3

unsigned char abCertHeader[] = {0x30, 0x82,           // Record
                                0x00, 0x00,           // Size of cert + buff
                                0x04, 0x0b, 0x63, 0x65,// Cert record data
                                0x72, 0x74, 0x69, 0x66,
                                0x69, 0x63, 0x61, 0x74,
                                0x65 };

void uudecode_cert(char *bufcoded, DWORD *pcbDecoded )
{
    int nbytesdecoded;
    char *bufin = bufcoded;
    unsigned char *bufout = (unsigned char *)bufcoded;
    unsigned char *pbuf;
    int nprbytes;
    char * beginbuf = bufcoded;

    ASSERT(bufcoded);
    ASSERT(pcbDecoded);

    /* Strip leading whitespace. */

    while(*bufcoded==' ' ||
          *bufcoded == '\t' ||
          *bufcoded == '\r' ||
          *bufcoded == '\n' )
    {
          bufcoded++;
    }

    //
    //  If there is a beginning '---- ....' then skip the first line
    //

    if ( bufcoded[0] == '-' && bufcoded[1] == '-' )
    {
        bufin = strchr( bufcoded, '\n' );

        if ( bufin )
        {
            bufin++;
            bufcoded = bufin;
        }
        else
        {
            bufin = bufcoded;
        }
    }
    else
    {
        bufin = bufcoded;
    }

    //
    //  Strip all cr/lf from the block
    //

    pbuf = (unsigned char *)bufin;
    while ( *pbuf )
    {
        if ( *pbuf == '\r' || *pbuf == '\n' )
        {
            memmove( (void*)pbuf, pbuf+1, strlen( (char*)pbuf + 1) + 1 );
        }
        else
        {
            pbuf++;
        }
    }

    /* Figure out how many characters are in the input buffer.
     * If this would decode into more bytes than would fit into
     * the output buffer, adjust the number of input bytes downwards.
     */

    while(pr2six[*(bufin++)] <= 63);
    nprbytes = DIFF(bufin - bufcoded) - 1;
    nbytesdecoded = ((nprbytes+3)/4) * 3;

    bufin  = bufcoded;

    while (nprbytes > 0) {
        *(bufout++) =
            (unsigned char) (pr2six[*bufin] << 2 | pr2six[bufin[1]] >> 4);
        *(bufout++) =
            (unsigned char) (pr2six[bufin[1]] << 4 | pr2six[bufin[2]] >> 2);
        *(bufout++) =
            (unsigned char) (pr2six[bufin[2]] << 6 | pr2six[bufin[3]]);
        bufin += 4;
        nprbytes -= 4;
    }

    if(nprbytes & 03) {
        if(pr2six[bufin[-2]] > 63)
            nbytesdecoded -= 2;
        else
            nbytesdecoded -= 1;
    }

    //
    //  Now we need to add a new wrapper sequence around the certificate
    //  indicating this is a certificate
    //

    memmove( beginbuf + sizeof(abCertHeader),
             beginbuf,
             nbytesdecoded );

    memcpy( beginbuf,
            abCertHeader,
            sizeof(abCertHeader) );

    //
    //  The beginning record size is the total number of bytes decoded plus
    //  the number of bytes in the certificate header
    //

    beginbuf[CERT_SIZE_HIBYTE] = (BYTE) (((USHORT)nbytesdecoded+CERT_RECORD) >> 8);
    beginbuf[CERT_SIZE_LOBYTE] = (BYTE) ((USHORT)nbytesdecoded+CERT_RECORD);

    nbytesdecoded += sizeof(abCertHeader);

    if ( pcbDecoded )
        *pcbDecoded = nbytesdecoded;
}
// ============ END BASED ON SETKEY



//------------------------------------------------------------------------------
BOOL CKey::FImportKeySetFiles( CString szPrivate, CString szPublic, CString &szPass )
    {
    BOOL fSuccess = TRUE;

    // in this routine, we load the data from the file, initialize it, and ask
    // the user for a password, which we then confirm with AcquireCredHandle.

    // several things we will be doing can throw, so use a try/catch
    try
        {
        // start by opening the private data file
        CFile   cfile( szPrivate, CFile::modeRead|CFile::shareDenyWrite );
        // get the length of the file
        m_cbPrivateKey = cfile.GetLength();
        // create a handle to hold the data
        m_pPrivateKey = GlobalAlloc( GPTR, m_cbPrivateKey );
        if ( !m_pPrivateKey )
            {
            cfile.Close();
            AfxThrowMemoryException();
            };
        // great, now read the data out of the file
        cfile.Read( m_pPrivateKey, m_cbPrivateKey );
        // close the file
        cfile.Close();


        // reading in the certificate is easy because that was done elsewhere
        if ( szPublic && !szPublic.IsEmpty() )
            {
            fSuccess = FInstallCertificate( szPublic, szPass );
            if ( fSuccess )
                // set the password
                m_szPassword = szPass;
            }
        }
    catch( CException e )
        {
        return FALSE;
        }

    return fSuccess;
    }

//------------------------------------------------------------------------------
void ReadWriteDWORD( CFile *pFile, DWORD *pDword, BOOL fRead );
void ReadWriteString( CFile *pFile, CString &sz, BOOL fRead );
void ReadWriteBlob( CFile *pFile, PVOID pBlob, DWORD cbBlob, BOOL fRead );
//------------------------------------------------------------------------------
BOOL CKey::FImportExportBackupFile( CString szFile, BOOL fImport )
    {
    DWORD   dword;
    UINT nOpenFlags;
    CConfirmPassDlg     dlgconfirm;


    // set up the right open flags
    if ( fImport )
        nOpenFlags = CFile::modeRead | CFile::shareDenyNone;
    else
        nOpenFlags = CFile::modeCreate | CFile::modeReadWrite | CFile::shareExclusive;

    // put it in a try/catch to get any errors
    try
        {
        CFile   file( szFile, nOpenFlags );

        // do the backup id
        dword = BACKUP_ID;
        ReadWriteDWORD( &file, &dword, fImport );

        // check the backup id
        if ( dword != BACKUP_ID )
            {
            AfxMessageBox( IDS_KEY_FILE_INVALID );
            return FALSE;
            }


        // start with the name of the key
        CString szName = GetName();
        ReadWriteString( &file, szName, fImport );
        if ( fImport ) SetName( szName );


        // now the private key data size
        ReadWriteDWORD( &file, &m_cbPrivateKey, fImport );

        // make a private key data pointer if necessary
        if ( fImport && m_cbPrivateKey )
            {
            m_pPrivateKey = GlobalAlloc( GPTR, m_cbPrivateKey );
            if ( !m_pPrivateKey ) AfxThrowMemoryException();
            }

        // use the private key pointer
        if ( m_cbPrivateKey )
            ReadWriteBlob( &file, m_pPrivateKey, m_cbPrivateKey, fImport );


        // now the certificate
        ReadWriteDWORD( &file, &m_cbCertificate, fImport );

        // make a data pointer if necessary
        if ( fImport && m_cbCertificate )
            {
            m_pCertificate = GlobalAlloc( GPTR, m_cbCertificate );
            if ( !m_pCertificate ) AfxThrowMemoryException();
            }

        // use the private key pointer
        if ( m_cbCertificate )
            ReadWriteBlob( &file, m_pCertificate, m_cbCertificate, fImport );


        // now the request
        ReadWriteDWORD( &file, &m_cbCertificateRequest, fImport );

        // make a data pointer if necessary
        if ( fImport && m_cbCertificateRequest )
            {
            m_pCertificateRequest = GlobalAlloc( GPTR, m_cbCertificateRequest );
            if ( !m_pCertificateRequest ) AfxThrowMemoryException();
            }

        // use the private key pointer
        if ( m_cbCertificateRequest )
            ReadWriteBlob( &file, m_pCertificateRequest, m_cbCertificateRequest, fImport );


        // finally, if we are importing, we need to confirm the password
        // Except if there is no Cert, which means Import of a Request
        if ( m_cbCertificate && fImport )
            {
            //if we are importing, get the password first
            if ( dlgconfirm.DoModal() != IDOK )
                return FALSE;

            if ( !FVerifyValidPassword(dlgconfirm.m_szPassword) )
                {
                // the Verify Valid Password routine puts up all
                // the correct error dialogs now
                return FALSE;
                }

            // set the password into place
            m_szPassword = dlgconfirm.m_szPassword;
            }

        }
    catch( CException e )
        {
        // return failure
        return FALSE;
        }

    // return success
    return TRUE;
    }



// file utilities
//---------------------------------------------------------------------------
void ReadWriteDWORD( CFile *pFile, DWORD *pDword, BOOL fRead )
    {
    ASSERT(pFile);
    ASSERT(pDword);

    // read it or write it
    if ( fRead )
        pFile->Read( (void*)pDword, sizeof(DWORD) );
    else
        pFile->Write( (void*)pDword, sizeof(DWORD) );
    }

//---------------------------------------------------------------------------
void ReadWriteString( CFile *pFile, CString &sz, BOOL fRead )
    {
    ASSERT(pFile);
    ASSERT(sz);

    // get the length of the string
    DWORD   cbLength = sz.GetLength();
    ReadWriteDWORD(pFile,&cbLength,fRead );

    // read or write the string
    LPTSTR psz = sz.GetBuffer( cbLength+1 );
    ReadWriteBlob(pFile, psz, cbLength+1, fRead);

    // free the string buffer
    sz.ReleaseBuffer();
    }

//---------------------------------------------------------------------------
void ReadWriteBlob( CFile *pFile, PVOID pBlob, DWORD cbBlob, BOOL fRead )
    {
    ASSERT(pFile);
    ASSERT(pBlob);
    ASSERT(cbBlob);

    // read it or write it
    if ( fRead )
        pFile->Read( pBlob, cbBlob );
    else
        pFile->Write( pBlob, cbBlob );
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\conctdlg.cpp ===
// ConnectOneDialog.cpp : implementation file
//

#include "stdafx.h"
#include "KeyRing.h"
#include "ConctDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CConnectOneDialog dialog


CConnectOneDialog::CConnectOneDialog(CWnd* pParent /*=NULL*/)
        : CDialog(CConnectOneDialog::IDD, pParent)
{
        //{{AFX_DATA_INIT(CConnectOneDialog)
        m_ServerName = _T("");
        //}}AFX_DATA_INIT
}


void CConnectOneDialog::DoDataExchange(CDataExchange* pDX)
{
        CDialog::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CConnectOneDialog)
        DDX_Control(pDX, IDOK, m_btnOK);
        DDX_Text(pDX, IDC_CONNECT_ServerName, m_ServerName);
        DDV_MaxChars(pDX, m_ServerName, 256);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CConnectOneDialog, CDialog)
        //{{AFX_MSG_MAP(CConnectOneDialog)
        ON_EN_CHANGE(IDC_CONNECT_ServerName, OnChangeCONNECTServerName)
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConnectOneDialog message handlers

//----------------------------------------------------------------
// override virtual oninitdialog
BOOL CConnectOneDialog::OnInitDialog( )
        {
        // call the base oninit
        CDialog::OnInitDialog();

        // we start with no password, so diable the ok window
        m_btnOK.EnableWindow( FALSE );

        // return 0 to say we set the default item
        // return 1 to just select the default default item
        return 1;
        }

//----------------------------------------------------------------
void CConnectOneDialog::OnChangeCONNECTServerName() 
        {
        // if there is no server, disable the ok button.
        // otherwise, enable it
        UpdateData( TRUE );
        m_btnOK.EnableWindow( !m_ServerName.IsEmpty() );
        }

//----------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\admninfo.h ===
// AdmnInfo.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CAdminInfoDlg dialog

class CAdminInfoDlg : public CDialog
{
// Construction
public:
	CAdminInfoDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CAdminInfoDlg)
	enum { IDD = IDD_ADNIM_INFO };
	CString	m_sz_email;
	CString	m_sz_phone;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAdminInfoDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAdminInfoDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\crackkey.cpp ===
// implements the exported CKeyCrackedData

#include "stdafx.h"
#include "KeyObjs.h"
#include "resource.h"
#include "NKChseCA.h"
#include "NKDN.h"
#include "NKDN2.h"
#include "NKKyInfo.h"
#include "NKUsrInf.h"
#include "Creating.h"

extern "C"
{
    #include <wincrypt.h>
    #include <sslsp.h>
}

//-------------------------------------------------
CKeyCrackedData:: CKeyCrackedData()
        :m_pKey(NULL),
        m_pData(NULL)
    {
    }

//-------------------------------------------------
CKeyCrackedData::~CKeyCrackedData()
    {
    PX509Certificate    p509 = (PX509Certificate)m_pData;

    // if the cracked data is there, free it
    if ( m_pData )
        SslFreeCertificate( (PX509Certificate)m_pData );
    }

//-------------------------------------------------
// adds a key to the service. They CKey object is added to the
// array object below. If this Service is connected to a machine,
// then the key is also added to the tree view below the service.
//-------------------------------------------------
WORD CKeyCrackedData::CrackKey( CKey* pKey )
    {
    ASSERT(!m_pData);

    PX509Certificate    p509 = NULL;
    PUCHAR  pCert = (PUCHAR)pKey->m_pCertificate;
    DWORD   cbCert = pKey->m_cbCertificate;


    if ( !pCert )
    {
        pCert = (PUCHAR)pKey->m_pCertificateRequest;
        cbCert = pKey->m_cbCertificateRequest;
    }

    if ( !pCert )
    {
        return FALSE;
    }


    BOOL f = SslCrackCertificate( pCert, cbCert, CF_CERT_FROM_FILE, &p509 );

    m_pData = (PVOID)p509;
    return (WORD)f;
    }

//-------------------------------------------------
// The rest of the methods access the data in the cracked certificate
//-------------------------------------------------
DWORD CKeyCrackedData::GetVersion()
    {
    ASSERT(m_pData);
    PX509Certificate pCert = (PX509Certificate)m_pData;
    return pCert->Version;
    }

//-------------------------------------------------
// returns a pointer to a DWORD[4]
DWORD* CKeyCrackedData::PGetSerialNumber()
    {
    ASSERT(m_pData);
    PX509Certificate pCert = (PX509Certificate)m_pData;
    return (DWORD*)&pCert->SerialNumber;
    }

//-------------------------------------------------
int CKeyCrackedData::GetSignatureAlgorithm()
    {
    ASSERT(m_pData);
    PX509Certificate pCert = (PX509Certificate)m_pData;
    return pCert->SignatureAlgorithm;
    }

//-------------------------------------------------
FILETIME CKeyCrackedData::GetValidFrom()
    {
    PX509Certificate pCert = (PX509Certificate)m_pData;
    ASSERT(m_pData);
    return pCert->ValidFrom;
    }

//-------------------------------------------------
FILETIME CKeyCrackedData::GetValidUntil()
    {
    PX509Certificate pCert = (PX509Certificate)m_pData;
    ASSERT(m_pData);
    return pCert->ValidUntil;
    }

//-------------------------------------------------
PVOID CKeyCrackedData::PSafePublicKey()
    {
    PX509Certificate pCert = (PX509Certificate)m_pData;
    ASSERT(m_pData);
    return pCert->pPublicKey;
    }

//-------------------------------------------------
DWORD CKeyCrackedData::GetBitLength()
    {
    PX509Certificate pCert = (PX509Certificate)m_pData;
    LPPUBLIC_KEY pPubKey = (LPPUBLIC_KEY)(pCert->pPublicKey);
    ASSERT(m_pData);
    return pPubKey->bitlen;
    }

//-------------------------------------------------
void CKeyCrackedData::GetIssuer( CString &sz )
    {
    PX509Certificate pCert = (PX509Certificate)m_pData;
    ASSERT(m_pData);
    sz = pCert->pszIssuer;
    }

//-------------------------------------------------
void CKeyCrackedData::GetSubject( CString &sz )
    {
//  sz = "C=Albania, O=AlbaniaSoft, OU=Testing, CN=name";
//  return;     // debug
    PX509Certificate pCert = (PX509Certificate)m_pData;
    ASSERT(m_pData);
    sz = pCert->pszSubject;
    }

//-------------------------------------------------
// gets a part of the distinguishing information
void CKeyCrackedData::GetDN( CString &szDN, LPCSTR szKey )
    {
    // clear the szDN
    szDN.Empty();

    // start with the dn (aka subject) string
    CString     szSubject;
    GetSubject( szSubject );

    // find the position of the key in the subject
    int cPos = szSubject.Find( szKey );

    // if we got it, get it
    if ( cPos >= 0 )
        {
        szDN = szKey;
        // get the string
        szDN = szSubject.Mid( cPos + szDN.GetLength() );
        // get the comma
        cPos = szDN.Find( _T(',') );
        // truncate at the comma
        if ( cPos >=0 )
            szDN = szDN.Left( cPos );
        }
    }

//-------------------------------------------------
void CKeyCrackedData::GetDNCountry( CString &sz )
    {
    GetDN( sz, SZ_KEY_COUNTRY );
    }

//-------------------------------------------------
void CKeyCrackedData::GetDNState( CString &sz )
    {
    GetDN( sz, SZ_KEY_STATE );
    }

//-------------------------------------------------
void CKeyCrackedData::GetDNLocality( CString &sz )
    {
    GetDN( sz, SZ_KEY_LOCALITY );
    }

//-------------------------------------------------
void CKeyCrackedData::GetDNNetAddress( CString &sz )
    {
    GetDN( sz, SZ_KEY_COMNAME );
    }

//-------------------------------------------------
void CKeyCrackedData::GetDNOrganization( CString &sz )
    {
    GetDN( sz, SZ_KEY_ORGANIZATION );
    }

//-------------------------------------------------
void CKeyCrackedData::GetDNUnit( CString &sz )
    {
    GetDN( sz, SZ_KEY_ORGUNIT );
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\conctdlg.h ===
// ConnectOneDialog.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CConnectOneDialog dialog

class CConnectOneDialog : public CDialog
{
// Construction
public:
        CConnectOneDialog(CWnd* pParent = NULL);   // standard constructor
        BOOL OnInitDialog( );


// Dialog Data
        //{{AFX_DATA(CConnectOneDialog)
        enum { IDD = IDD_CONNECT_SERVER };
        CButton m_btnOK;
        CString m_ServerName;
        //}}AFX_DATA


// Overrides
        // ClassWizard generated virtual function overrides
        //{{AFX_VIRTUAL(CConnectOneDialog)
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        //}}AFX_VIRTUAL

// Implementation
protected:

        // Generated message map functions
        //{{AFX_MSG(CConnectOneDialog)
        afx_msg void OnChangeCONNECTServerName();
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\creating.h ===
// CreatingKeyDlg.h : header file
//

// string constants for distinguishing names. Non-localized
#define		SZ_KEY_COUNTRY			_T("C=")
#define		SZ_KEY_STATE			_T("S=")
#define		SZ_KEY_LOCALITY			_T("L=")
#define		SZ_KEY_ORGANIZATION		_T("O=")
#define		SZ_KEY_ORGUNIT			_T("OU=")
#define		SZ_KEY_COMNAME			_T("CN=")


// declared here, but implemented in ckey.cpp
PUCHAR	PCreateEncodedRequest( PVOID pRequest, DWORD* cbRequest, BOOL fMime );
void uudecode_cert(char *bufcoded, DWORD *pcbDecoded );

typedef struct ADMIN_INFO
	{
	CString* pName;
	CString* pEmail;
	CString* pPhone;

	CString* pCommonName;
	CString* pOrgUnit;
	CString* pOrg;
	CString* pLocality;
	CString* pState;
	CString* pCountry;
	} ADMIN_INFO, *PADMIN_INFO;

/////////////////////////////////////////////////////////////////////////////
// CCreatingKeyDlg dialog
class CCreatingKeyDlg : public CDialog
{
// Construction
public:
	CCreatingKeyDlg(CWnd* pParent = NULL);	// standard constructor
	~CCreatingKeyDlg();						// standard destructor
	BOOL FGenerateKeyPair( void );
	void	PostGenerateKeyPair();

	// the info has to come from somewhere...
	CNKChooseCA*			m_ppage_Choose_CA;
	CNKUserInfo*			m_ppage_User_Info;
	CNKKeyInfo*				m_ppage_Key_Info;
	CNKDistinguishedName*	m_ppage_DN;
	CNKDistinguisedName2*	m_ppage_DN2;

	BOOL					m_fGenerateKeyPair;
	BOOL					m_fResubmitKey;
	BOOL					m_fRenewExistingKey;

	// the service that controls the key
	CService*				m_pService;

	// the key that is being made
	CKey*					m_pKey;


	// the data that is being output
	DWORD			m_cbPrivateKey;
	PVOID			m_pPrivateKey;
	DWORD			m_cbCertificate;
	PVOID			m_pCertificate;
	DWORD			m_cbCertificateRequest;
	PVOID			m_pCertificateRequest;

// Dialog Data
	//{{AFX_DATA(CCreatingKeyDlg)
	enum { IDD = IDD_CREATING_NEW_KEY };
	CStatic	m_cstatic_message;
	CButton	m_btn_ok;
	CAnimateCtrl	m_animation;
	CString	m_sz_message;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCreatingKeyDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual BOOL OnInitDialog();
	void	CreateNewKey();
	BOOL	WriteRequestToFile();
	BOOL	SubmitRequestToAuthority();
	BOOL	RetargetKey();

	void	BuildAuthErrorMessage( BSTR bstrMesage, HRESULT hErr );
	
	// Generated message map functions
	//{{AFX_MSG(CCreatingKeyDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\creating.cpp ===
// CreatingKeyDlg.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "keyobjs.h"

#include "NKChseCA.h"
#include "NKDN.h"
#include "NKDN2.h"
#include "NKKyInfo.h"
#include "NKUsrInf.h"

#include "Creating.h"
#include "certcli.h"
#include "OnlnAuth.h"

#include "intrlkey.h"


#define SECURITY_WIN32
extern "C"
	{
	#include <wincrypt.h>
	#include <Sslsp.h>
	#include <sspi.h>
	#include <issperr.h>
	}


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

UINT MyThreadProc( LPVOID pParam );

/////////////////////////////////////////////////////////////////////////////
// CCreateKeyProgThread thread controller

/////////////////////////////////////////////////////////////////////////////
// CCreatingKeyDlg dialog
//----------------------------------------------------------------
CCreatingKeyDlg::CCreatingKeyDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CCreatingKeyDlg::IDD, pParent),
	m_cbPrivateKey( 0 ),
	m_pPrivateKey( NULL ),
	m_cbCertificate( 0 ),
	m_pCertificate( NULL ),
	m_cbCertificateRequest( 0 ),
	m_pCertificateRequest( NULL ),
	m_pKey( NULL ),
	m_pService( NULL ),
	m_fResubmitKey( FALSE ),
	m_fRenewExistingKey( FALSE ),
	m_fGenerateKeyPair( FALSE )
	{
	//{{AFX_DATA_INIT(CCreatingKeyDlg)
	m_sz_message = _T("");
	//}}AFX_DATA_INIT
	}

//----------------------------------------------------------------
CCreatingKeyDlg::~CCreatingKeyDlg()
	{
	// now that I'm adding a header in front of the requests, we need
	// to dispose of it here.
	if ( m_pCertificateRequest )
		GlobalFree( m_pCertificateRequest );
	m_pCertificateRequest = NULL;
	}

//----------------------------------------------------------------
void CCreatingKeyDlg::DoDataExchange(CDataExchange* pDX)
	{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCreatingKeyDlg)
	DDX_Control(pDX, IDC_MESSAGE, m_cstatic_message);
	DDX_Control(pDX, IDOK, m_btn_ok);
	DDX_Control(pDX, IDC_GRINDER_ANIMATION, m_animation);
	DDX_Text(pDX, IDC_MESSAGE, m_sz_message);
	//}}AFX_DATA_MAP
	}


//----------------------------------------------------------------
BEGIN_MESSAGE_MAP(CCreatingKeyDlg, CDialog)
	//{{AFX_MSG_MAP(CCreatingKeyDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCreatingKeyDlg message handlers
//----------------------------------------------------------------
// override virtual oninitdialog
BOOL CCreatingKeyDlg::OnInitDialog( )
	{
	// tell the user that we are generating the new key request
	// might as well do that here, since it is first
	m_sz_message.LoadString( IDS_GRIND_GENERATING );
	
	// call the base oninit
	CDialog::OnInitDialog();

	// disable the ok button
	m_btn_ok.EnableWindow( FALSE );

	// tell the animation control to set itself up
	CString	szAnimName;
	szAnimName.LoadString(IDS_CREATING_ANIMATION);
	m_animation.Open( IDR_AVI_CREATING_KEY );

	// start up the worker thread
	AfxBeginThread( (AFX_THREADPROC)MyThreadProc, this);

	// return 0 to say we set the default item
	// return 1 to just select the default default item
	return 1;
	}

//----------------------------------------------------------------
UINT MyThreadProc( LPVOID pParam )
	{
	CCreatingKeyDlg*	pDlg = (CCreatingKeyDlg*)pParam;
	BOOL				fSuccess = TRUE;

    // this thread needs its own coinitialize
    HRESULT hRes = CoInitialize(NULL);
    if ( FAILED(hRes) )
        return GetLastError();

	// if the flag is set, generate the key pair
	if ( pDlg->m_fGenerateKeyPair )
		fSuccess = pDlg->FGenerateKeyPair();


	// do the work that needs to get done
	if ( fSuccess )
		{
		// if the request was generated, go to post
		pDlg->PostGenerateKeyPair();
		}
	else
		{
		// we weren't able to generate the keypair. Leave.
		AfxMessageBox( IDS_GEN_KEYPAIR_ERR );
		pDlg->EndDialog( IDCANCEL );
		}

	// return
	return 0;
	}

//------------------------------------------------------------------------------
void	CCreatingKeyDlg::PostGenerateKeyPair()
	{
	BOOL	fPlacedRequest = TRUE;

	// first we create the new key object and fill it in as best we can
	if ( !m_pKey )
		{
		ASSERT( !m_fRenewExistingKey );
		ASSERT( !m_fResubmitKey );
		try
			{
			CreateNewKey();
			}
		catch (CException e)
			{
			AfxMessageBox( IDS_GEN_KEYPAIR_ERR );
			EndDialog( IDCANCEL );
			return;
			}
		}

	// if we are renewing an existing key, target the key appropriately
	if ( m_fRenewExistingKey )
		RetargetKey();


	// if resubmitting the key, do so
	if ( m_fResubmitKey )
		{
		// tell the user that we are attempting to submit the request
		m_sz_message.LoadString( IDS_GRIND_RESUBMITTING );
		m_cstatic_message.SetWindowText(m_sz_message);

		// submit the request
		SubmitRequestToAuthority();
		}
	else
	// send the request off to the online service, if that was chosen.
	if ( m_ppage_Choose_CA && m_ppage_Choose_CA->m_nkca_radio == 1 )
		{
		// tell the user that we are attempting to submit the request
		m_sz_message.LoadString( IDS_GRIND_SUBMITTING );
		m_cstatic_message.SetWindowText(m_sz_message);

		// submit the request
		SubmitRequestToAuthority();
		}
	else
		// if targeted as such, write it to the file
		{
		// write the request out
		fPlacedRequest = WriteRequestToFile();
		}

	// one final show string
	// NOTE: cannot use UpdateData because we are in a different
	// thread than the dialog. UpdateData crashes.
	if ( fPlacedRequest )
		m_cstatic_message.SetWindowText(m_sz_message);
	else
		{
		m_sz_message.LoadString( IDS_IO_ERROR );
		m_cstatic_message.SetWindowText(m_sz_message);
		}

	// activate the ok button so we can close
	m_btn_ok.EnableWindow( TRUE );

	// stop the avi from spinning. That would give the wrong impression
	m_animation.Stop();
	}

//------------------------------------------------------------------------------
BOOL	CCreatingKeyDlg::RetargetKey()
	{
	ASSERT( m_ppage_Choose_CA );
	LPREQUEST_HEADER pHeader = (LPREQUEST_HEADER)m_pKey->m_pCertificateRequest;

	// if we are sending the key to an online authority, record which one
	if ( m_ppage_Choose_CA->m_nkca_radio == 1 )
		{
		// get the path of the authority dll
		CString	szCA;
		if ( m_ppage_Choose_CA->GetSelectedCA(szCA) == ERROR_SUCCESS )
			{
			// fill in the rest of the request header, indicating the online authority
			pHeader->fReqSentToOnlineCA = TRUE;
			strncpy( pHeader->chCA, szCA, MAX_PATH-1 );
			}
		}
	else
		{
		// clear it for the file
		pHeader->fReqSentToOnlineCA = FALSE;
		}
	
	return TRUE;
	}

//------------------------------------------------------------------------------
void	CCreatingKeyDlg::CreateNewKey()
	{
	// create the new key object
	m_pKey = m_pService->PNewKey();

	// put in the name of the key
	m_pKey->SetName( m_ppage_Key_Info->m_nkki_sz_name );
	// put in the password too
	m_pKey->m_szPassword = m_ppage_Key_Info->m_nkki_sz_password;

	// set the private data into place
	ASSERT( m_cbPrivateKey );
	ASSERT( m_pPrivateKey );
	m_pKey->m_cbPrivateKey = m_cbPrivateKey;
	m_pKey->m_pPrivateKey = m_pPrivateKey;

	// set the request into place
	// not quite as simple because now we have the header that goes in first.
	ASSERT( m_cbCertificateRequest );
	ASSERT( m_pCertificateRequest );

	// allocate the the request pointer - include space for the header
	DWORD	cbRequestAndHeader = m_cbCertificateRequest + sizeof(KeyRequestHeader);
	m_pKey->m_cbCertificateRequest = cbRequestAndHeader;
	m_pKey->m_pCertificateRequest = GlobalAlloc( GPTR, cbRequestAndHeader );
	ASSERT( m_pKey->m_pCertificateRequest );
	if ( !m_pKey->m_pCertificateRequest ) AfxThrowMemoryException();

	// fill in the basic header. Assume there is no online ca for now
	ZeroMemory( m_pKey->m_pCertificateRequest, sizeof(KeyRequestHeader) );
	LPREQUEST_HEADER pHeader = (LPREQUEST_HEADER)m_pKey->m_pCertificateRequest;
	pHeader->Identifier = REQUEST_HEADER_IDENTIFIER;	// required
	pHeader->Version = REQUEST_HEADER_CURVERSION;		// required
	pHeader->cbSizeOfHeader = sizeof(KeyRequestHeader);	// required
	pHeader->cbRequestSize = m_cbCertificateRequest;	// required

	// copy over the request data
	memcpy( (PUCHAR)m_pKey->m_pCertificateRequest + sizeof(KeyRequestHeader),
		(PUCHAR)m_pCertificateRequest, m_cbCertificateRequest );

	// if we are sending the key to an online authority, record which one
	if ( m_ppage_Choose_CA->m_nkca_radio == 1 )
		{
		// get the path of the authority dll
		CString	szCA;
		if ( m_ppage_Choose_CA->GetSelectedCA(szCA) == ERROR_SUCCESS )
			{
			// fill in the rest of the request header, indicating the online authority
			pHeader->fReqSentToOnlineCA = TRUE;
			strncpy( pHeader->chCA, szCA, MAX_PATH-1 );
			}
		}
	}

//------------------------------------------------------------------------------
BOOL	CCreatingKeyDlg::SubmitRequestToAuthority()
	{
	DWORD		err;
	BOOL		fAnswer = FALSE;
	HINSTANCE	hLibrary = NULL;
	PUCHAR	    pEncoded;
	DWORD	    cbEncoded = m_pKey->m_cbCertificateRequest;
	PUCHAR	    pResponse;
    HRESULT     hErr;

    LPTSTR      szTCert;
    CString     szRawCert;
    BSTR        bstrCert = NULL;

    BSTR        bstrDisposition = NULL;

	LPREQUEST_HEADER pHeader = (LPREQUEST_HEADER)m_pKey->m_pCertificateRequest;

    // make sure the header is a valid version (the K2 alpha/beta1 version is no
    // longer valid because the interface to the CA server has totally changed.
    // specifically we now track GUIDs instead of dll paths
    if ( pHeader->Version < REQUEST_HEADER_K2B2VERSION )
        {
        m_sz_message.LoadString( IDS_CA_ERROR );
        AfxMessageBox( IDS_INVALID_CA_REQUEST_OLD );
        return FALSE;
        }

    // initialize the authority object
    // prepare the authority object
    COnlineAuthority    authority;
    if ( !authority.FInitSZ(pHeader->chCA) )
        {
        m_sz_message.LoadString( IDS_CA_ERROR );
		AfxMessageBox( IDS_CA_NO_INTERFACE );
		return FALSE;
        }

    // get the previously set up configuration string
    BSTR    bstrConfig = NULL;
    if ( !authority.FGetPropertyString( &bstrConfig ) )
		{
        m_sz_message.LoadString( IDS_CA_ERROR );
		AfxMessageBox( IDS_CA_NO_INTERFACE );
		return FALSE;
		}


    // YES - I HAVE tried to pass this in as binary, but that doesn't seem to work right now.

    // generate a base-64 encoded request
    DWORD   cbReq = m_pKey->m_cbCertificateRequest;
    PUCHAR	preq = PCreateEncodedRequest( m_pKey->m_pCertificateRequest, &cbReq, FALSE );
    preq[cbReq] = 0;

    // Great. Now this needs to be unicode.
    OLECHAR*    poch = NULL;
    // get the number of characters in the encoded request, plus some
    DWORD       cchReq = _tcslen((PCHAR)preq) + 60;
    poch = (OLECHAR*)GlobalAlloc( GPTR, cchReq * 2 );
    // unicodize the name into the buffer
    if ( poch )
	    MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, (PCHAR)preq, -1,
						    poch, cchReq );

    // prepare the BSTR containing the request
    BSTR    bstrRequest = NULL;
    bstrRequest = SysAllocString(poch);
    // cleanup
    GlobalFree( poch );


    // prepare the extra attributes string
    BSTR    bstrAttrib = NULL;
	WORD	zero = 0;
    bstrAttrib = SysAllocString(&zero);

    LONG    longDisposition;

    // if this is the first time for this cert, call the submit method
    if ( !pHeader->fWaitingForApproval )
        {
        // set the flag
        pHeader->fReqSentToOnlineCA = TRUE;

        // make the call
        hErr = authority.pIRequest->Submit(
//          CR_IN_BINARY | CR_IN_PKCS10,
            CR_IN_BASE64HEADER | CR_IN_PKCS10,
            bstrRequest,
            bstrAttrib,
            bstrConfig,
            &longDisposition);

		// get the full error message text
        authority.pIRequest->GetDispositionMessage( &bstrDisposition );
        // get the string out and put it in m_sz_message
        BuildAuthErrorMessage( bstrDisposition, hErr );

        // no matter what, try to get the request ID
        authority.pIRequest->GetRequestId( &pHeader->longRequestID );
        }
    else
        // if it has already been submitted, call the pending method
        {
        // make the call
        hErr = authority.pIRequest->RetrievePending(
            pHeader->longRequestID,
            bstrConfig,
            &longDisposition);

		// get the full error message text
        authority.pIRequest->GetDispositionMessage( &bstrDisposition );
        // get the string out and put it in m_sz_message
        BuildAuthErrorMessage( bstrDisposition, hErr );
	}

    // do the appropriate thing depending on the disposition of the response
    switch( longDisposition )
        {
        case CR_DISP_INCOMPLETE:
        case CR_DISP_ERROR:
        case CR_DISP_DENIED:
			// error message obtained via BuildAuthErrorMessage above
            break;

        case CR_DISP_UNDER_SUBMISSION:
            // we need to try again later
            m_sz_message.LoadString( IDS_GRIND_DELAYED );

            // set the waiting for response flag
            pHeader->fWaitingForApproval = TRUE;
            break;
        case CR_DISP_ISSUED_OUT_OF_BAND:
        case CR_DISP_ISSUED:
            // get the certificate
            hErr = authority.pIRequest->GetCertificate( CR_OUT_BASE64HEADER, &bstrCert);
            if ( FAILED(hErr) )
                {
                // get the detailed error disposition string - reuse bstrAttrib
                authority.pIRequest->GetDispositionMessage( &bstrDisposition );
                // get the string out and put it in m_sz_message
                BuildAuthErrorMessage( bstrDisposition, hErr );
                break;
                }

            // make sure the "waiting" flag is cleared
			pHeader->fWaitingForApproval = FALSE;

            // extract the certificate from the bstr
            szRawCert = bstrCert;
            szTCert = szRawCert.GetBuffer(szRawCert.GetLength()+1);

            // great. The last thing left is to uudecode the data we got
			uudecode_cert( szTCert, &m_pKey->m_cbCertificate );

            //copy it into place
            if ( m_pKey->m_pCertificate )
                GlobalFree( m_pKey->m_pCertificate );
            m_pKey->m_pCertificate = GlobalAlloc( GPTR, m_pKey->m_cbCertificate );
            CopyMemory( m_pKey->m_pCertificate, szTCert, m_pKey->m_cbCertificate );
            szRawCert.ReleaseBuffer(0);

            // tell the key it is done
            // success! Let the user know about it
            m_sz_message.LoadString( IDS_GRIND_SUCCESS );

			// cleanup
			fAnswer = TRUE;
            break;
        };

    // clean up all the bstrings
    if ( bstrCert ) SysFreeString( bstrCert );
    if ( bstrConfig ) SysFreeString( bstrConfig );
    if ( bstrRequest ) SysFreeString( bstrRequest );
    if ( bstrAttrib ) SysFreeString( bstrAttrib );
    if ( bstrDisposition ) SysFreeString( bstrDisposition );
    
	// return the answer
	return fAnswer;
	}


//------------------------------------------------------------------------------
void CCreatingKeyDlg::BuildAuthErrorMessage( BSTR bstrMesage, HRESULT hErr )
	{
    // set the header to the message first
    m_sz_message.LoadString( IDS_GRIND_ONLINE_FAILURE );

    // add the specific message from the certificate authority
    if ( bstrMesage )
        m_sz_message += bstrMesage;

    // get the error code part going too.
    CString     szErr;
    szErr.LoadString( IDS_ERR_GENERIC_ERRCODE );

    // put it all together
    m_sz_message.Format( "%s%s%x", m_sz_message, szErr, hErr );
	}

	
//------------------------------------------------------------------------------
BOOL	CCreatingKeyDlg::WriteRequestToFile()
	{
	// fill in a admin info structure
	ADMIN_INFO	info;
	info.pName = &m_ppage_User_Info->m_nkui_sz_name;
	info.pEmail = &m_ppage_User_Info->m_nkui_sz_email;
	info.pPhone = &m_ppage_User_Info->m_nkui_sz_phone;

	if ( m_ppage_DN )
		{
		info.pCommonName = &m_ppage_DN->m_nkdn_sz_CN;
		info.pOrgUnit = &m_ppage_DN->m_nkdn_sz_OU;
		info.pOrg = &m_ppage_DN->m_nkdn_sz_O;
		info.pLocality = &m_ppage_DN2->m_nkdn2_sz_L;
		info.pState = &m_ppage_DN2->m_nkdn2_sz_S;
		info.pCountry = &m_ppage_DN2->m_nkdn2_sz_C;
		}
	else
		{
		info.pCommonName = NULL;
		info.pOrgUnit = NULL;
		info.pOrg = NULL;
		info.pLocality = NULL;
		info.pState = NULL;
		info.pCountry = NULL;
		}

	// tell the key to write itself out to the disk
	if ( !m_pKey->FOutputRequestFile( m_ppage_Choose_CA->m_nkca_sz_file, FALSE, &info ) )
		return FALSE;

	// tell the user its there
	m_sz_message.LoadString( IDS_GRIND_FILE );
	m_sz_message += m_ppage_Choose_CA->m_nkca_sz_file;

	// success
	return TRUE;
	}

//------------------------------------------------------------------------------
BOOL	CCreatingKeyDlg::FGenerateKeyPair()
	{
	BOOL						fSuccess = FALSE;
	CString						szDistinguishedName;
	SSL_CREDENTIAL_CERTIFICATE	certs;
	LPTSTR						pSzDN, pSzPassword;
	BOOL						fAddComma = FALSE;

	// generate the distinguished name string
	try
		{
		szDistinguishedName.Empty();
		// we should never put an empty parameter in the list

		// start with the country code
		if ( !m_ppage_DN2->m_nkdn2_sz_C.IsEmpty() )
			{
			szDistinguishedName = SZ_KEY_COUNTRY;
			szDistinguishedName += m_ppage_DN2->m_nkdn2_sz_C;
			fAddComma = TRUE;
			}

		// now add on the state/province
		if ( !m_ppage_DN2->m_nkdn2_sz_S.IsEmpty() )
			{
			if ( fAddComma )
				szDistinguishedName += ",";
			szDistinguishedName += SZ_KEY_STATE;
			szDistinguishedName += m_ppage_DN2->m_nkdn2_sz_S;
			fAddComma = TRUE;
			}
		
		// now add on the locality
		if ( !m_ppage_DN2->m_nkdn2_sz_L.IsEmpty() )
			{
			if ( fAddComma )
				szDistinguishedName += ",";
			szDistinguishedName += SZ_KEY_LOCALITY;
			szDistinguishedName += m_ppage_DN2->m_nkdn2_sz_L;
			fAddComma = TRUE;
			}
		
		// now add on the organization
		if ( !m_ppage_DN->m_nkdn_sz_O.IsEmpty() )
			{
			if ( fAddComma )
				szDistinguishedName += ",";
			szDistinguishedName += SZ_KEY_ORGANIZATION;
			szDistinguishedName += m_ppage_DN->m_nkdn_sz_O;
			fAddComma = TRUE;
			}

		// now add on the organizational unit (optional)
		if ( !m_ppage_DN->m_nkdn_sz_OU.IsEmpty() )
			{
			if ( fAddComma )
				szDistinguishedName += ",";
			szDistinguishedName += SZ_KEY_ORGUNIT;
			szDistinguishedName += m_ppage_DN->m_nkdn_sz_OU;
			fAddComma = TRUE;
			}

		// now add on the common name (netaddress)
		if ( !m_ppage_DN->m_nkdn_sz_CN.IsEmpty() )
			{
			if ( fAddComma )
				szDistinguishedName += ",";
			szDistinguishedName += SZ_KEY_COMNAME;
			szDistinguishedName += m_ppage_DN->m_nkdn_sz_CN;
			fAddComma = TRUE;
			}
		}
	catch( CException e )
		{
		return FALSE;
		}

	// prep the strings - we need a pointer to the data
	pSzDN = szDistinguishedName.GetBuffer( szDistinguishedName.GetLength()+2 );
	pSzPassword = m_ppage_Key_Info->m_nkki_sz_password.GetBuffer(
							m_ppage_Key_Info->m_nkki_sz_password.GetLength()+2 );

	// zero out the certs
	ZeroMemory( &certs, sizeof(certs) );

	// generate the key pair
	fSuccess = SslGenerateKeyPair( &certs, pSzDN, pSzPassword, m_ppage_Key_Info->m_nBits );

	// release the string buffers
	m_ppage_Key_Info->m_nkki_sz_password.ReleaseBuffer( -1 );
	szDistinguishedName.ReleaseBuffer( -1 );

	// if generating the key pair failed, leave now
	if ( !fSuccess )
		{
		return FALSE;
		}

	// store away the cert and the key
	m_cbPrivateKey = certs.cbPrivateKey;
	m_pPrivateKey = certs.pPrivateKey;
	m_cbCertificateRequest = certs.cbCertificate;
	m_pCertificateRequest = certs.pCertificate;

	// return the success flag
	return fSuccess;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\hotlink.cpp ===
// HotLink.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "HotLink.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define COLOR_BLUE			RGB(0, 0, 0xFF)

/////////////////////////////////////////////////////////////////////////////
// CHotLink

CHotLink::CHotLink():
    m_CapturedMouse( FALSE ),
    m_fBrowse( FALSE ),
    m_fExplore( FALSE ),
    m_fOpen( FALSE ),
    m_fInitializedFont( FALSE )
{
}

CHotLink::~CHotLink()
{
}

BEGIN_MESSAGE_MAP(CHotLink, CButton)
	//{{AFX_MSG_MAP(CHotLink)
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONUP()
	ON_WM_MOUSEMOVE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

//------------------------------------------------------------------------
// set the title string
void CHotLink::SetTitle( CString sz )
    {
    // set the title
    SetWindowText( sz );
    // force the window to redraw
    Invalidate( TRUE );
    }

/////////////////////////////////////////////////////////////////////////////
// CHotLink message handlers

//------------------------------------------------------------------------
void CHotLink::DrawItem( LPDRAWITEMSTRUCT lpDrawItemStruct )
    {
    // prep the device context
    CDC* pdc = CDC::FromHandle(lpDrawItemStruct->hDC);

    // get the drawing rect
    CRect rect = lpDrawItemStruct->rcItem;

    if ( ! m_fInitializedFont )
        {
        // get the window font
        CFont* pfont = GetFont();
        LOGFONT logfont;
        pfont->GetLogFont( &logfont );

        // modify the font  - add underlining
        logfont.lfUnderline = TRUE;

        // set the font back
        pfont->CreateFontIndirect( &logfont );
        SetFont( pfont, TRUE );

        m_fInitializedFont = TRUE;
        }

    // draw the text in blue
    pdc->SetTextColor( COLOR_BLUE );

    // draw the text
    CString sz;
    GetWindowText( sz );
    pdc->DrawText( sz, &rect, DT_LEFT|DT_SINGLELINE|DT_VCENTER );

    // get the extents fo the text for later reference
    m_cpTextExtents = pdc->GetOutputTextExtent( sz );
    }

//------------------------------------------------------------------------
// calculate the rectangle that surrounds the text
void CHotLink::GetTextRect( CRect &rect )
    {
    // get the main rect
    GetClientRect( rect );

    // reduce it by the width of the text
    rect.right = rect.left + m_cpTextExtents.cx;
    }

//------------------------------------------------------------------------
void CHotLink::OnLButtonDown(UINT nFlags, CPoint point)
    {
    // don't do the hotlink thing if there is no text
    CString sz;
    GetWindowText( sz );
    if ( sz.IsEmpty() )
        return;

    CRect   rect;
    GetTextRect( rect );
    if ( !m_CapturedMouse && rect.PtInRect(point) )
        {
        SetCapture( );
        m_CapturedMouse = TRUE;
        }
    }

//------------------------------------------------------------------------
void CHotLink::OnLButtonUp(UINT nFlags, CPoint point)
    {
    // only bother if we have the capture
    if ( m_CapturedMouse )
        {
        ReleaseCapture();
        if ( m_fBrowse )
            Browse();
        if ( m_fExplore )
            Explore();
        if ( m_fOpen )
            Open();
        }
    }

//------------------------------------------------------------------------
void CHotLink::Browse()
    {
    // get the window text
    CString sz;
    GetWindowText( sz );

    // and do it to it!
    ShellExecute(
        NULL,	// handle to parent window
        NULL,	// pointer to string that specifies operation to perform
        sz,	// pointer to filename or folder name string
        NULL,	// pointer to string that specifies executable-file parameters
        NULL,	// pointer to string that specifies default directory
        SW_SHOW 	// whether file is shown when opened
       );
    }

//------------------------------------------------------------------------
void CHotLink::Explore()
    {
    // get the window text
    CString sz;
    GetWindowText( sz );

    // and do it to it!
    ShellExecute(
        NULL,	// handle to parent window
        "explore",	// pointer to string that specifies operation to perform
        sz,	// pointer to filename or folder name string
        NULL,	// pointer to string that specifies executable-file parameters
        NULL,	// pointer to string that specifies default directory
        SW_SHOW 	// whether file is shown when opened
       );
    }

//------------------------------------------------------------------------
void CHotLink::Open()
    {
    // get the window text
    CString sz;
    GetWindowText( sz );

    // and do it to it!
    ShellExecute(
        NULL,	// handle to parent window
        "open",	// pointer to string that specifies operation to perform
        sz,	// pointer to filename or folder name string
        NULL,	// pointer to string that specifies executable-file parameters
        NULL,	// pointer to string that specifies default directory
        SW_SHOW 	// whether file is shown when opened
       );
    }

//------------------------------------------------------------------------
void CHotLink::OnMouseMove(UINT nFlags, CPoint point)
    {
    CRect   rect;
    GetTextRect( rect );
    // if the mouse is over the hot area, show the right cursor
    if ( rect.PtInRect(point) )
        ::SetCursor(AfxGetApp()->LoadCursor( IDC_BROWSE ));

//	CButton::OnMouseMove(nFlags, point);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\cservice.cpp ===
// implements the exported CService

#include "stdafx.h"
#include "KeyObjs.h"

IMPLEMENT_DYNCREATE(CService, CTreeItem);

//---------------------------------------------------------
void CService::CloseConnection()
	{
	CKey* pKey;

	// delete all the keys
	while( pKey = (CKey*)GetFirstChild() )
		{
		pKey->FRemoveFromTree();
		delete pKey;
		}
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\imprtdlg.cpp ===
// ImprtDlg.cpp : implementation file
//

#include "stdafx.h"
#include "keyring.h"
#include "ImprtDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CImportDialog dialog


CImportDialog::CImportDialog(CWnd* pParent /*=NULL*/)
	: CDialog(CImportDialog::IDD, pParent)
{
	//{{AFX_DATA_INIT(CImportDialog)
	m_cstring_CertFile = _T("");
	m_cstring_PrivateFile = _T("");
	//}}AFX_DATA_INIT
}


void CImportDialog::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CImportDialog)
	DDX_Control(pDX, IDC_PRIVATE_FILE, m_cedit_Private);
	DDX_Control(pDX, IDC_CERT_FILE, m_cedit_Cert);
	DDX_Text(pDX, IDC_CERT_FILE, m_cstring_CertFile);
	DDX_Text(pDX, IDC_PRIVATE_FILE, m_cstring_PrivateFile);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CImportDialog, CDialog)
	//{{AFX_MSG_MAP(CImportDialog)
	ON_BN_CLICKED(IDC_BROWSE_CERT, OnBrowseCert)
	ON_BN_CLICKED(IDC_BROWSE_PRIVATE, OnBrowsePrivate)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CImportDialog message handlers

//------------------------------------------------------------------------------
void CImportDialog::OnBrowseCert() 
	{
	UpdateData(TRUE);
	if ( FBrowseForAFile( m_cstring_CertFile, TRUE ) )
		UpdateData(FALSE);
	}

//------------------------------------------------------------------------------
void CImportDialog::OnBrowsePrivate() 
	{
	UpdateData(TRUE);
	if ( FBrowseForAFile( m_cstring_PrivateFile, FALSE ) )
		UpdateData(FALSE);
	}

// go browsing for a file
//------------------------------------------------------------------------------
BOOL CImportDialog::FBrowseForAFile( CString &szFile, BOOL fBrowseForCertificate )
	{
	CString			szFilter;
    CString         szTitle;
    CString         szFileStart = szFile;
	WORD			i = 0;
	LPSTR			lpszBuffer;
	BOOL			fAnswer = FALSE;

    // set up to look for either certs or private keys
    if ( fBrowseForCertificate )
        {
        szFilter.LoadString( IDS_CERTIFICATE_FILTER );
        szTitle.LoadString( IDS_OPEN_PUBLIC_KEY );
        }
    else
        {
        szFilter.LoadString( IDS_PRIVATE_FILE_TYPE );
        szTitle.LoadString( IDS_OPEN_PRIVATE_KEY );
        }

	// prep the dialog
	CFileDialog		cfdlg(TRUE );

	// replace the "!" characters with nulls
	lpszBuffer = szFilter.GetBuffer(MAX_PATH+1);
	while( lpszBuffer[i] )
		{
		if ( lpszBuffer[i] == _T('!') )
			lpszBuffer[i] = _T('\0');			// yes, set \0 on purpose
		i++;
		}
	cfdlg.m_ofn.lpstrFilter = lpszBuffer;

    // finish prepping the title
    cfdlg.m_ofn.lpstrTitle = szTitle.GetBuffer(MAX_PATH+1);

    // finish prepping the starting location
    cfdlg.m_ofn.lpstrFile = szFileStart.GetBuffer(MAX_PATH+1);


	// run the dialog
	if ( cfdlg.DoModal() == IDOK )
		{
		fAnswer = TRUE;
		szFile = cfdlg.GetPathName();
		}

	// release the buffer in the filter string
	szFilter.ReleaseBuffer();
	szTitle.ReleaseBuffer();
    szFileStart.ReleaseBuffer();

	// return the answer
	return fAnswer;
	}


//------------------------------------------------------------------------------
void CImportDialog::OnOK() 
	{
	UpdateData(TRUE);

	// make sure the user has chosen two valid files
	CFile cfile;

	// test the private key file
	if ( !cfile.Open( m_cstring_PrivateFile, CFile::modeRead|CFile::shareDenyNone ) )
		{
		// beep and select the bad field
		MessageBeep(0);
		m_cedit_Private.SetFocus();
		m_cedit_Private.SetSel(0xFFFF0000);
		return;
		}
	cfile.Close();

	// test the certificate file
	if ( !cfile.Open( m_cstring_CertFile, CFile::modeRead|CFile::shareDenyNone ) )
		{
		// beep and select the bad field
		MessageBeep(0);
		m_cedit_Cert.SetFocus();
		m_cedit_Cert.SetSel(0xFFFF0000);
		return;
		}
	cfile.Close();

	// all is ok. do the normal ok
	CDialog::OnOK();
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\hotlink.h ===
// HotLink.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CHotLink window

class CHotLink : public CButton
{
// Construction
public:
	CHotLink();

// Attributes
public:
    BOOL    m_fBrowse;
    BOOL    m_fExplore;
    BOOL    m_fOpen;

// Operations
public:
    void Browse();
    void Explore();
    void Open();

    virtual void DrawItem( LPDRAWITEMSTRUCT lpDrawItemStruct );

    // set the title string
    void SetTitle( CString sz );

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CHotLink)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CHotLink();

	// Generated message map functions
protected:
	//{{AFX_MSG(CHotLink)
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()

    // height and width of the displayed text
    void GetTextRect( CRect &rect );
    CSize   m_cpTextExtents;

    // tracking the mouse flag
    BOOL    m_CapturedMouse;

    // init the font
    BOOL    m_fInitializedFont;
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\imprtdlg.h ===
// ImprtDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CImportDialog dialog

class CImportDialog : public CDialog
{
// Construction
public:
	CImportDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CImportDialog)
	enum { IDD = IDD_IMPORT_KEY_PAIR };
	CEdit	m_cedit_Private;
	CEdit	m_cedit_Cert;
	CString	m_cstring_CertFile;
	CString	m_cstring_PrivateFile;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CImportDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CImportDialog)
	afx_msg void OnBrowseCert();
	afx_msg void OnBrowsePrivate();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP();

	// go browsing for a file
	BOOL FBrowseForAFile( CString &szFile, BOOL fBrowseForCertificate );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\intrlkey.h ===
// internal key headers stuff

// header structure for the key request data.
// the first version of Keyring just saved the raw request data
// in the object. Now, however, we wish to store additional data
// A typical example is a key request that was sent to an online
// authority, but the response was delayed. We need to mark it
// somewhere so we know to go back to the authority and see if it
// is ready at a later date. In some ways, it would make sense to
// store that in the certificate pointer, but the key services
// assume that that is an actual certificate. The request pointer,
// however, is stored by the services, but its content is private
// to the keyring application. Thus, that is where it goes.

// 5/19/97 Boydm - changed string from dll path to interface GUID - set to version x0101


#define REQUEST_HEADER_K2B2VERSION  0x0101

#define REQUEST_HEADER_IDENTIFIER	'RHDR'
#define REQUEST_HEADER_CURVERSION	0x0101



typedef struct _KeyRequestHeader
	{
	DWORD	Identifier;				// must be 'RHDR'
	DWORD	Version;				// version of header record
	DWORD	cbSizeOfHeader;			// byte count of header. Afterwards is the request.
	DWORD	cbRequestSize;			// size of the request that follows
	BOOL	fReqSentToOnlineCA;
    LONG    longRequestID;
	BOOL	fWaitingForApproval;
	char	chCA[MAX_PATH];
	} KeyRequestHeader, *LPREQUEST_HEADER;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\infodlg.cpp ===
// NewKeyInfoDlg.cpp : implementation file
//

#include "stdafx.h"
#include "KeyRing.h"
#include "InfoDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CNewKeyInfoDlg dialog


CNewKeyInfoDlg::CNewKeyInfoDlg(CWnd* pParent /*=NULL*/)
        : CDialog(CNewKeyInfoDlg::IDD, pParent),
        m_fNewKeyInfo(TRUE)
{
        //{{AFX_DATA_INIT(CNewKeyInfoDlg)
        m_szFilePart = _T("");
        m_szBase = _T("");
        //}}AFX_DATA_INIT
}


void CNewKeyInfoDlg::DoDataExchange(CDataExchange* pDX)
{
        CDialog::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CNewKeyInfoDlg)
        DDX_Text(pDX, IDC_NEW_KEY_INFO_FILE_PART, m_szFilePart);
        DDX_Text(pDX, IDC_INFO_BASE, m_szBase);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CNewKeyInfoDlg, CDialog)
        //{{AFX_MSG_MAP(CNewKeyInfoDlg)
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNewKeyInfoDlg message handlers

//----------------------------------------------------------------
// override virtual oninitdialog
BOOL CNewKeyInfoDlg::OnInitDialog( )
        {
        CString szTemp;

        // put the appropriate first string into the dialog
        if ( m_fNewKeyInfo )
                m_szBase.LoadString( IDS_NEW_KEY_INFO_BASE );
        else
                m_szBase.LoadString( IDS_RENEW_KEY_INFO_BASE );

        // build the file part of the info dialog
        m_szFilePart.LoadString( IDS_NEW_KEY_INFO_1 );
        m_szFilePart += m_szRequestFile;
        if ( m_fNewKeyInfo )
                szTemp.LoadString( IDS_NEW_KEY_INFO_2 );
        else
                szTemp.LoadString( IDS_RENEW_KEY_INFO_2 );
        m_szFilePart += szTemp;
        
        // call the base oninit
        CDialog::OnInitDialog();

        // return 0 to say we set the default item
        // return 1 to just select the default default item
        return 1;
        }

//----------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\keydview.h ===
// KeyDView.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CKeyDataView form view

#ifndef __AFXEXT_H__
#include <afxext.h>
#endif

class CKeyDataView : public CFormView
{
protected:
	CKeyDataView();           // protected constructor used by dynamic creation
	DECLARE_DYNCREATE(CKeyDataView)

// Form Data
public:
	//{{AFX_DATA(CKeyDataView)
	enum { IDD = IDD_KEY_DATA_VIEW };
	CButton	m_ctrlGroupDN;
	CStatic	m_ctrlStarts;
	CStatic	m_ctrlExpires;
	CStatic	m_ctrlState;
	CStatic	m_ctrlLocality;
	CStatic	m_ctrlUnit;
	CStatic	m_ctrlOrg;
	CStatic	m_ctrlNetAddr;
	CStatic	m_ctrlStaticName;
	CStatic	m_ctrlCountry;
	CStatic	m_ctrlBits;
	CEdit	m_ctrlName;
	CString	m_szBits;
	CString	m_szCountry;
	CString	m_szName;
	CString	m_szDNNetAddress;
	CString	m_szOrganization;
	CString	m_szStatus;
	CString	m_szUnit;
	CString	m_szState;
	CString	m_szLocality;
	CString	m_szExpires;
	CString	m_szStarts;
	//}}AFX_DATA

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CKeyDataView)
	public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual void OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint);
	//}}AFX_VIRTUAL

// Implementation
protected:
	virtual ~CKeyDataView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	// Generated message map functions
	//{{AFX_MSG(CKeyDataView)
	afx_msg void OnChangeViewkeyName();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
	void EnableDataView( BOOL fEnable, BOOL fEnableName );
	void FillInCrackedInfo( CKey* pKey );

};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\infodlg.h ===
// NewKeyInfoDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CNewKeyInfoDlg dialog

class CNewKeyInfoDlg : public CDialog
{
// Construction
public:
        CNewKeyInfoDlg(CWnd* pParent = NULL);   // standard constructor
        CString         m_szRequestFile;
        BOOL m_fNewKeyInfo;                     // is this for a new key, or a key renewal? - defaults to new key


// Dialog Data
        //{{AFX_DATA(CNewKeyInfoDlg)
        enum { IDD = IDD_NEW_KEY_INFO };
        CString m_szFilePart;
        CString m_szBase;
        //}}AFX_DATA


// Overrides
        // ClassWizard generated virtual function overrides
        //{{AFX_VIRTUAL(CNewKeyInfoDlg)
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        //}}AFX_VIRTUAL

// Implementation
protected:
        BOOL OnInitDialog( );           // override virtual oninitdialog

        // Generated message map functions
        //{{AFX_MSG(CNewKeyInfoDlg)
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\keyobjs.h ===
// protect this file against multiple inclusion
#ifndef _KEYRINGOBJECTS_
#define _KEYRINGOBJECTS_


/*	STARTING
	When creating your dll using this api, you will be mostly concerned
	the CService and CKey object classes. You are expected to override
	both of these and provide functionality for storing/retrieving the
	keys and maintaining any service specific properites.

	Your dll needs only one exported routine "LoadService" defined below.
	This routine creates your overridden service object, populates it
	with retrieve keys, and connects it to its host machine. The Machine
	object is passed in to this routine and the service is returned.

	If the host machine does not have your service on it, simply return
	from LoadService without attaching a service object to it.

	PROPERTIES
	You can enable the properties item in the context menu for either your
	keys or your service by overridding the classes' OnUpdateProperties
	and OnProperties routines. These are very similar to MFC command
	handlers. In fact, they are just passed in from a command handler.
	You can do whatever you feel like in the OnProperties routine, although
	some sort of dialog is probably appropriate;

	INFO STRING
	Services and Keys also have the option of displaying a one-line
	information string in the right-hand pand of the keyring application,
	To do this, override the GetInfoString methode and return
	something.

	KEY NAMES
	All keys have names and you are expected to store/retrieve them. The
	name is automatically editable in the right-hand pane of the main app.
	The name, however, can be different from the caption in the tree view.
	To do this, override the UpdateCaption routine and use it to call
	FSetCaption with a modified string name. An example can be seen in the
	W3 server, which displays the name of the key followed by the ip
	address it is attached to in brackets. MyKey<100.200.150.250>

	CUSTOM ICONS IN TREEVIEW
	You can add your own custom icons to the tree view in addition to the
	standard machine, key, unfinished key icons. To do this, get the
	CTreeCtrl object by calling PGetTreeCtrl. Then use that to get the
	CImageList. From there, you can add your own icons (making sure to note
	down the starting index). See CTreeCtrl and CImageList docs for details.
*/



// basic icon numbers
enum
	{
	TREE_ICON_MACHINE = 0,
	TREE_ICON_KEY_OK,
	TREE_ICON_KEY_IMMATURE,
	TREE_ICON_KEY_EXPIRED
	};


// declare the correct dllexport definitions
#ifdef _EXE_
	// we are exporting the classes - this is the main application
	#define DLL_SHARE	__declspec( dllexport )
#else
	// we are importing the classes - this is your dll
	#define DLL_SHARE	__declspec( dllimport )
#endif _EXE_


//====================== Forward class declarations
class DLL_SHARE CMachine;

//====================== Template for the exported routine
extern  BOOL _cdecl LoadService( CMachine* pMachine );

//---------------------------------------------------------------
// CTreeItem
// This is the base class for all objects that can be in the tree view.
// This includes machines, services, keys and key folders. Note that each
// tree item object can contain other tree item objects. This interface
// allows you to access the item's handle in the tree.
class DLL_SHARE CTreeItem : public CObject
	{
	public:
		// constructors
		CTreeItem();

		// get the parent object
		CTreeItem* PGetParent( void );

		// remove this item from the tree
		BOOL FRemoveFromTree();

		// access the name of the item
		// Must be added to parent first!
		virtual void UpdateCaption( void )	{;}
		BOOL FSetCaption( CString& szName );

		// a informational string that is displayed in the right-hand
		// pane of the main application. Override to actually show something
		virtual void GetInfoString( CString& szInfo )
			{ szInfo.Empty(); }

		// access the image shown in the tree view
		// Must be added to parent first!
		WORD IGetImage( void )		{ return m_iImage; }
		BOOL FSetImage( WORD i );

		// get the grandparental ctreectrl object
		CTreeCtrl* PGetTreeCtrl( void );

		// add the item to the tree
		BOOL FAddToTree( CTreeItem* pParent );

		// how many children does this item have?
		WORD GetChildCount();

		// get the HTREEITEM handle
		HTREEITEM HGetTreeItem() { return m_hTreeItem; }


		// do you want the properties item in the context menu?
		// the default is NO - Override these in your subclasses
		// to provide specific properties dialogs
		virtual void OnUpdateProperties(CCmdUI* pCmdUI)
			{pCmdUI->Enable(FALSE);}
		// your properties item has been selected
		virtual void OnProperties() {ASSERT(FALSE);}

		// helpful utilities for scanning the
		// children contained by a object
		CTreeItem* GetFirstChild();
		CTreeItem* GetNextChild( CTreeItem* pKid );

		// access to the dirty flag
		// setting dirty affects parents too (in the default method)
		virtual void SetDirty( BOOL fDirty );
		virtual BOOL FGetDirty()
			{ return m_fDirty; }

	protected:
		// DO declare all this stuff DYNCREATE
		DECLARE_DYNCREATE(CTreeItem);

		// the name of the item. In the case of keys, you should
		// store this name and retrieve it later
		CString		m_szItemName;

		// index of the item's image in the image list
		// Note: if you wish to have a special icon different from
		// the standard icons enumerated above, (e.g. for a service)
		// you get the tree control, then use that to get its CImageList
		// object. Then you call the Add member of the image list.
		// That call does return the index of your first added image.
		WORD		m_iImage;

		// the dirty flag
		BOOL		m_fDirty;

	private:
		// the item's reference handle in the tree
		// access it using the api above
		HTREEITEM	m_hTreeItem;
	};


//---------------------------------------------------------------
// CKey
// This class is what its all about. This is a key. You should override
// this class. You are expected to provide storage and retrieval of this
// key. You are also expected to provide any properties dialogs and such.
// basic SSL functionality has already been built in.
class DLL_SHARE CKey : public CTreeItem
	{
	public:
		CKey();
		~CKey();

	// override the update caption so the name is automatically shown
	virtual void UpdateCaption( void )
		{
		FSetCaption(m_szItemName);
		UpdateIcon();
		}
	// update the currently shown icon
	virtual void UpdateIcon( void );

	// the private key - keep this safe!	// must store!
	DWORD		m_cbPrivateKey;
	PVOID		m_pPrivateKey;

	// the certificate						// must store!
	DWORD		m_cbCertificate;
	PVOID		m_pCertificate;

	// the certificate request				// must store!
	DWORD		m_cbCertificateRequest;
	PVOID		m_pCertificateRequest;

	// the password. Be careful where you
	// store this.
	CString		m_szPassword;

	// make a copy of the key
	virtual CKey*	PClone( void );

	// checks that the key, certificate and password all match
	BOOL FVerifyValidPassword( CString szPassword );

	// routine for installing the certificate
	virtual BOOL FInstallCertificate( CString szPath, CString szPass );
	virtual BOOL FInstallCertificate( PVOID pCert, DWORD cbCert, CString &szPass );

	// write out the request file
	virtual BOOL FOutputRequestFile( CString szFile, BOOL fMime = FALSE, PVOID privData = NULL );

	// copy the members from a key into this key
	virtual void CopyDataFrom( CKey* pKey );

	// called by the right-hand dialog pane
	virtual void SetName( CString &szNewName );
	virtual CString GetName()
		{ return m_szItemName; }


	// import/export routines
	virtual BOOL FImportKeySetFiles( CString szPrivate, CString szPublic, CString &szPass );
	BOOL FImportExportBackupFile( CString szFile, BOOL fImport );

	protected:
	// DO declare all this stuff DYNCREATE
	DECLARE_DYNCREATE(CKey);

	private:
	void OutputHeader( CFile* pFile, PVOID privData1, PVOID privData2 );
	};

//---------------------------------------------------------------
// CService
// This class MUST be overridden in your dll! It is your main link to the app.
// It resides on a machine and contains keys
class DLL_SHARE CService : public CTreeItem
	{
	public:
	// create a new key. You can override to
	// create a key of your own class type
	virtual CKey* PNewKey() {return new CKey;}

	// load the existing keys
	virtual void LoadKeys( CMachine* pMachine ) {;}

	// the order in which things happen is that you are responsible
	// for creating this service object and populating it with key
	// objects that you retrieve from whatever storage medium you want
	// to use. Then, if that is successful, you attach this service
	// to the machine that is passed in to you through the LoadService
	// routine. - NOTE that routine is a direct export of your DLL;
	// see the definition of that routine above.

	// CommitChanges is where you write out any and all changes in
	// the service's key list to some storage facility. The storage
	// facility and the manner in which you access it is up to you.
	virtual BOOL FCommitChangesNow() {return FALSE;}

	// CloseConnection is called before disconnecting a machine from
	// the tree, or when application is exiting.
	virtual void CloseConnection();

	protected:
	// DO declare all this stuff DYNCREATE
	DECLARE_DYNCREATE(CService);

	private:
	};

//---------------------------------------------------------------
// CKeyCrackedData
// This is a special purpose class. You give it a key object (must have a
// valid certificate attached to it) and it will crack the certificate.
// you can then use the supplied methods to access the data in the cert.

// This uses a two-step construction. First, declare the object, then
// crack it using the CrackKey command, which returns an error code
class DLL_SHARE CKeyCrackedData : public CObject
	{
	public:
	// constructor
	CKeyCrackedData();
	~CKeyCrackedData();

	// give it a key to crack. If this object was previously used to
	// crack a key, cleanup is automatically done and the new key is
	// cracked. - NOTE: The target key MUST have either a certificate
	// or a certificate request. Those are what get cracked. A return
	// value of 0 indicates success
	WORD CrackKey( CKey* pKey );

	// The rest of the methods access the data in the cracked certificate
	DWORD		GetVersion();
	DWORD*		PGetSerialNumber();	// returns a pointer to a DWORD[4]
	int			GetSignatureAlgorithm();
	FILETIME	GetValidFrom();
	FILETIME	GetValidUntil();
	PVOID		PSafePublicKey();
	DWORD		GetBitLength();
	void		GetIssuer( CString &sz );
	void		GetSubject( CString &sz );
	void		GetDNCountry( CString &sz );
	void		GetDNState( CString &sz );
	void		GetDNLocality( CString &sz );
	void		GetDNNetAddress( CString &sz );
	void		GetDNOrganization( CString &sz );
	void		GetDNUnit( CString &sz );

	protected:

	private:
	void		GetDN( CString &szDN, LPCSTR szKey );
		CKey*	m_pKey;
		PVOID	m_pData;
	};

//---------------------------------------------------------------
// CMachine
// This class is almost always used just by the application. It is the
// machine that the services and keys reside on. It is very simple and
// is to be used just to attach the services to something. Otherwise it
// maintains where the machine is.
class DLL_SHARE CMachine : public CTreeItem
	{
	public:
	// the machine objects are always created and maintained by the
	// application. This interface is provided just so that you can
	// attach and detach services to it.

	// query this method to see if this is the local machine or
	// a remote machine on the net.
	virtual BOOL FLocal();

	// NOTE: when you add the service to the machine it is also added
	// to the tree view. The machine is always added to the tree view
	// before you are asked to load your service. Immediately after
	// adding your service to the machine, don't forget to set the
	// service's caption string.
	virtual void GetMachineName(CString& sz);

	protected:
	// DO declare all this stuff DYNCREATE
	DECLARE_DYNCREATE(CMachine);

	// The name of the machine. - This MAY be different from the caption
	// in the tree view. This is the name you use to link to the machine
	// over the net. In the case of the local machine, this string will
	// be empty. Use SZGetMachineName() above to access it.
	CString		m_szNetMachineName;
	private:
	};


// end inclusion protection
#endif //_KEYRINGOBJECTS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\keyring.h ===
// KeyRing.h : main header file for the KEYRING application
//

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CKeyRingApp:
// See KeyRing.cpp for the implementation of this class
//

class CKeyRingApp : public CWinApp
{
public:
	CKeyRingApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CKeyRingApp)
	public:
	virtual BOOL InitInstance();
	virtual BOOL OnIdle(LONG lCount);
	virtual int ExitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CKeyRingApp)
	afx_msg void OnAppAbout();
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
    BOOL DealWithParameters();

	BOOL m_fInitialized;
};


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\keydview.cpp ===
// KeyDView.cpp : implementation file
//

#include "stdafx.h"
#include "KeyRing.h"
#include "MainFrm.h"
#include "keyobjs.h"
#include "KeyDView.h"

#include "machine.h"
#include "KRDoc.h"
#include "KRView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern CKeyRingView*	g_pTreeView;

/////////////////////////////////////////////////////////////////////////////
// CKeyDataView

IMPLEMENT_DYNCREATE(CKeyDataView, CFormView)

CKeyDataView::CKeyDataView()
	: CFormView(CKeyDataView::IDD)
	{
	//{{AFX_DATA_INIT(CKeyDataView)
	m_szBits = _T("");
	m_szCountry = _T("");
	m_szName = _T("");
	m_szDNNetAddress = _T("");
	m_szOrganization = _T("");
	m_szStatus = _T("");
	m_szUnit = _T("");
	m_szState = _T("");
	m_szLocality = _T("");
	m_szExpires = _T("");
	m_szStarts = _T("");
	//}}AFX_DATA_INIT
	}

CKeyDataView::~CKeyDataView()
	{
	}

void CKeyDataView::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CKeyDataView)
	DDX_Control(pDX, IDC_GROUP_DN, m_ctrlGroupDN);
	DDX_Control(pDX, IDC_STATIC_STARTS, m_ctrlStarts);
	DDX_Control(pDX, IDC_STATIC_EXPIRES, m_ctrlExpires);
	DDX_Control(pDX, IDC_STATIC_STATEPROVICE, m_ctrlState);
	DDX_Control(pDX, IDC_STATIC_LOCALITY, m_ctrlLocality);
	DDX_Control(pDX, IDC_STATIC_UNIT, m_ctrlUnit);
	DDX_Control(pDX, IDC_STATIC_ORG, m_ctrlOrg);
	DDX_Control(pDX, IDC_STATIC_NETADDR, m_ctrlNetAddr);
	DDX_Control(pDX, IDC_STATIC_NAME, m_ctrlStaticName);
	DDX_Control(pDX, IDC_STATIC_COUNTRY, m_ctrlCountry);
	DDX_Control(pDX, IDC_STATIC_BITS, m_ctrlBits);
	DDX_Control(pDX, IDC_VIEWKEY_NAME, m_ctrlName);
	DDX_Text(pDX, IDC_VIEWKEY_BITS, m_szBits);
	DDX_Text(pDX, IDC_VIEWKEY_COUNTRY, m_szCountry);
	DDX_Text(pDX, IDC_VIEWKEY_NAME, m_szName);
	DDX_Text(pDX, IDC_VIEWKEY_NETADDR, m_szDNNetAddress);
	DDX_Text(pDX, IDC_VIEWKEY_ORG, m_szOrganization);
	DDX_Text(pDX, IDC_VIEWKEY_STATUS, m_szStatus);
	DDX_Text(pDX, IDC_VIEWKEY_UNIT, m_szUnit);
	DDX_Text(pDX, IDC_VIEWKEY_STATEPROVINCE, m_szState);
	DDX_Text(pDX, IDC_VIEWKEY_LOCALITY, m_szLocality);
	DDX_Text(pDX, IDC_VIEWKEY_EXPIRES, m_szExpires);
	DDX_Text(pDX, IDC_VIEWKEY_STARTS, m_szStarts);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CKeyDataView, CFormView)
	//{{AFX_MSG_MAP(CKeyDataView)
	ON_EN_CHANGE(IDC_VIEWKEY_NAME, OnChangeViewkeyName)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CKeyDataView diagnostics

#ifdef _DEBUG
void CKeyDataView::AssertValid() const
	{
	CFormView::AssertValid();
	}

void CKeyDataView::Dump(CDumpContext& dc) const
	{
	CFormView::Dump(dc);
	}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CKeyDataView message handlers

//----------------------------------------------------------------------------
void CKeyDataView::OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint) 
	{
	CKey*	pKey = (CKey*)g_pTreeView->PGetSelectedItem();

	// we only work on selection changes an "none" hints
	switch ( lHint )
		{
		case HINT_None:
		case HINT_ChangeSelection:
			break;
		default:
			return;
		}

	// if there is no selected key, bail
	if ( !pKey || !pKey->IsKindOf(RUNTIME_CLASS(CKey)) )
		{
		EnableDataView( FALSE, FALSE );
		return;
		}
	else
		{
		EnableDataView( TRUE, TRUE );
		}

	// put all the string stuff into a try/catch to get mem errors
	try
		{
		ASSERT( pKey );
		ASSERT( pKey->IsKindOf(RUNTIME_CLASS(CKey)) );

		// set the character strings
		m_szName = pKey->GetName();

		// get certificate specific info directly out of the certifiect
		FillInCrackedInfo( pKey );

		// if this key is not completed, disable the button altogether
		if ( !pKey->m_pCertificate )
			// the item is not completed
			{
			EnableDataView( FALSE, TRUE );
			m_szStatus.LoadString(IDS_KEY_STATUS_INCOMPLETE);
			}

		// set the data into the form
		UpdateData( FALSE );
		}
	catch( CException e )
		{
		}
	}

//----------------------------------------------------------------------------
void CKeyDataView::OnChangeViewkeyName() 
	{
	CKey*	pKey = (CKey*)g_pTreeView->PGetSelectedItem();
	if ( !pKey || !pKey->IsKindOf(RUNTIME_CLASS(CKey)) )
		{
		ASSERT( FALSE );
		return;
		}

	// get the data from the form
	UpdateData( TRUE );
	pKey->SetName( m_szName );
	}

//----------------------------------------------------------------------------
void CKeyDataView::EnableDataView( BOOL fEnable, BOOL fEnableName )
	{
	// enable the name seperately from the rest
	if ( fEnableName )
		{
		m_ctrlName.EnableWindow( TRUE );
		m_ctrlStaticName.EnableWindow( TRUE );
		}
	else
		{
		m_szName.Empty();
		m_ctrlName.EnableWindow( FALSE );
		m_ctrlStaticName.EnableWindow( FALSE );
		}

	// do the right thing. (wasn't a bad movie)
	if ( fEnable )
		{
		// enable what needs to be enabled. The DoUpdate routine takes care of the rest
		m_ctrlGroupDN.EnableWindow( TRUE );
		m_ctrlUnit.EnableWindow( TRUE );
		m_ctrlUnit.EnableWindow( TRUE );
		m_ctrlNetAddr.EnableWindow( TRUE );
		m_ctrlCountry.EnableWindow( TRUE );
		m_ctrlState.EnableWindow( TRUE );
		m_ctrlLocality.EnableWindow( TRUE );
		m_ctrlBits.EnableWindow( TRUE );
		m_ctrlOrg.EnableWindow( TRUE );
		m_ctrlExpires.EnableWindow( TRUE );
		m_ctrlStarts.EnableWindow( TRUE );
		}
	else
		// disabling the window
		{
		// empty the information strings
		m_szCountry.Empty();
		m_szState.Empty();
		m_szLocality.Empty();
		m_szDNNetAddress.Empty();
		m_szOrganization.Empty();
		m_szUnit.Empty();
		m_szBits.Empty();
		m_szExpires.Empty();
		m_szStarts.Empty();

		// set the status string
		m_szStatus.LoadString(IDS_MACHINE_SELECTED);

		// set the data into the form
		UpdateData( FALSE );
		
		// disable everything
		m_ctrlGroupDN.EnableWindow( FALSE );
		m_ctrlUnit.EnableWindow( FALSE );
		m_ctrlOrg.EnableWindow( FALSE );
		m_ctrlNetAddr.EnableWindow( FALSE );
		m_ctrlCountry.EnableWindow( FALSE );
		m_ctrlState.EnableWindow( FALSE );
		m_ctrlLocality.EnableWindow( FALSE );
		m_ctrlBits.EnableWindow( FALSE );
		m_ctrlExpires.EnableWindow( FALSE );
		m_ctrlStarts.EnableWindow( FALSE );
		}
	}

//----------------------------------------------------------------------------
void CKeyDataView::FillInCrackedInfo( CKey* pKey )
	{
	CKeyCrackedData cracker;

	// crack the key
	if ( !cracker.CrackKey(pKey) )
		return;

	// fill in the distinguishing information
	cracker.GetDNCountry( m_szCountry );
	cracker.GetDNState( m_szState );
	cracker.GetDNLocality( m_szLocality );
	cracker.GetDNNetAddress( m_szDNNetAddress );
	cracker.GetDNOrganization( m_szOrganization );
	cracker.GetDNUnit( m_szUnit );

	// set the bit length
	DWORD nBits = cracker.GetBitLength();
	if ( nBits )
		m_szBits.Format( "%d", nBits );
	else
		m_szBits.LoadString( IDS_KEY_UNKNOWN );

	// get the dates
	FILETIME timeStart = cracker.GetValidFrom();
	FILETIME timeEnd = cracker.GetValidUntil();

	// set the start date string
	CTime	ctimeStart( timeStart );
	m_szStarts = ctimeStart.Format( IDS_EXPIRETIME_FORMAT );

	// set the end date string
	CTime	ctimeEnd( timeEnd );
	m_szExpires = ctimeEnd.Format( IDS_EXPIRETIME_FORMAT );

	// get the current time
	CTime	ctimeCurrent = CTime::GetCurrentTime();

#ifdef _DEBUG
	CString szTest = ctimeCurrent.Format( IDS_EXPIRETIME_FORMAT );
#endif

	// get the expire soon test time - current time plus two weeks
	CTimeSpan	ctsSoonSpan(14,0,0,0);	// two weeks
	CTime	ctimeSoon = ctimeCurrent + ctsSoonSpan;

#ifdef _DEBUG
	szTest = ctimeSoon.Format( IDS_EXPIRETIME_FORMAT );
#endif

	// test if it has expired first
	if ( ctimeCurrent > ctimeEnd )
		{
		m_szStatus.LoadString(IDS_KEY_STATUS_EXPIRED);
		}
	else if ( ctimeSoon > ctimeEnd )
		{
		// well then does it expire soon?
		m_szStatus.LoadString(IDS_KEY_STATUS_EXPIRES_SOON);
		}
	else
		{
		// that must mean it is ok
		m_szStatus.LoadString(IDS_KEY_STATUS_COMPLETE);
		}
	}

//----------------------------------------------------------------------------
BOOL CKeyDataView::PreTranslateMessage(MSG* pMsg) 
{
	// The user pushes the tab button, send the focus back to the tree view
	if ( pMsg->message == WM_KEYDOWN )
		{
		int nVirtKey = (int) pMsg->wParam;
		if ( nVirtKey == VK_TAB )
			{
			// get the parental frame window
			CMainFrame* pFrame = (CMainFrame*)GetParentFrame();
			// give the data view the focus
			pFrame->SetActiveView( g_pTreeView );
			return TRUE;
			}
		}
	return CFormView::PreTranslateMessage(pMsg);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\keyring.cpp ===
// KeyRing.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include <afxdisp.h>        // MFC OLE automation classes
#include "KeyRing.h"

#include "MainFrm.h"
#include "KeyObjs.h"
#include "KRDoc.h"
#include "KRView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern CKeyRingDoc*		g_pDocument;

// remote machine specified in the command line
CString                 g_szRemoteCommand;


#define CMD_SEPS            _T("/ ")
#define CMD_REMOTE          _T("remote:")


/////////////////////////////////////////////////////////////////////////////
// CKeyRingApp

BEGIN_MESSAGE_MAP(CKeyRingApp, CWinApp)
	//{{AFX_MSG_MAP(CKeyRingApp)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
	// Standard file based document commands
	ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
	ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
	// Standard print setup command
	ON_COMMAND(ID_FILE_PRINT_SETUP, CWinApp::OnFilePrintSetup)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CKeyRingApp construction

CKeyRingApp::CKeyRingApp():
	m_fInitialized( FALSE )
	{
	}

/////////////////////////////////////////////////////////////////////////////
// The one and only CKeyRingApp object

CKeyRingApp theApp;


int CKeyRingApp::ExitInstance() 
	{
	CoUninitialize();
	return CWinApp::ExitInstance();
	}


/////////////////////////////////////////////////////////////////////////////
// CKeyRingApp initialization

//----------------------------------------------------------------------
BOOL CKeyRingApp::DealWithParameters()
    {
    BOOL    fAnswer = FALSE;

    CString sz = m_lpCmdLine;
    sz.TrimRight();
    // the first one is easy. If there is no command line, invoke the UI and leave
    if ( sz.IsEmpty() )
        return FALSE;

    // copy the command line into a buffer
    TCHAR   buff[MAX_PATH];
    strcpy( buff, sz );

    // just so we don't do it in the loop, initialize the open: string
    // length variable
    WORD    cchConnect = strlen( CMD_REMOTE );

    // parse out the arguments
    PCHAR   pTok;
    pTok = strtok( buff, CMD_SEPS );
    while ( pTok )
        {
        // look for the connect: command
        if ( _strnicmp(pTok, CMD_REMOTE, cchConnect) == 0 )
            {
            // just put the command parameter in a string
            g_szRemoteCommand = pTok;
            g_szRemoteCommand = g_szRemoteCommand.Right(
                            g_szRemoteCommand.GetLength() - cchConnect );
            }

        // Get next token
        pTok = strtok( NULL, CMD_SEPS );
        }

    return fAnswer;
    }

//----------------------------------------------------------------------
BOOL CKeyRingApp::InitInstance()
	{
	BOOL f;

	HRESULT hRes = CoInitialize(NULL);
	AfxEnableControlContainer();
	if ( hRes == S_OK )
		f = TRUE;

    // check for remote specifications on the command line
    DealWithParameters();

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	// Register the application's document templates.  Document templates
	//  serve as the connection between documents, frame windows and views.

	CSingleDocTemplate* pDocTemplate;
	pDocTemplate = new CSingleDocTemplate(
		IDR_MAINFRAME,
		RUNTIME_CLASS(CKeyRingDoc),
		RUNTIME_CLASS(CMainFrame),       // main SDI frame window
		RUNTIME_CLASS(CKeyRingView));
	AddDocTemplate(pDocTemplate);


    // save the command line for later use
    CString szCmdLine = m_lpCmdLine;

    /*
    // kill the command line now that we have caputured it. If we don't do this
    // then MFC takes a stab at "opening" the file that is named. Duh. We aren't
    // trying to open a file. We want to connect to that machine.
    m_lpCmdLine[0] = 0;
    */

    // Parse command line for standard shell commands, DDE, file open
	CCommandLineInfo cmdInfo;
	ParseCommandLine(cmdInfo);

	// Dispatch commands specified on the command line
	if (!ProcessShellCommand(cmdInfo))
		return FALSE;

    // finally, we need to redirect the winhelp file location to something more desirable
    CString sz;
    CString szHelpPath;
    sz.LoadString( IDS_HELPLOC_KEYRINGHELP );

    // expand the path
    ExpandEnvironmentStrings(
        sz,	                                        // pointer to string with environment variables 
        szHelpPath.GetBuffer(MAX_PATH + 1),   // pointer to string with expanded environment variables  
        MAX_PATH                                    // maximum characters in expanded string 
       );
    szHelpPath.ReleaseBuffer();

    // free the existing path, and copy in the new one
    free((void*)m_pszHelpFilePath);
    m_pszHelpFilePath = _tcsdup(szHelpPath);

	return TRUE;
	}

//----------------------------------------------------------------------
// App command to run the dialog
void CKeyRingApp::OnAppAbout()
	{
	// load the about strings
	CString		szAbout1;
	CString		szAbout2;
	szAbout1.LoadString(IDS_ABOUT_MAIN);
	szAbout2.LoadString(IDS_ABOUT_SECONDARY);

	// run the shell about dialog
	ShellAbout(  AfxGetMainWnd()->GetSafeHwnd(), szAbout1,szAbout2, LoadIcon(IDR_MAINFRAME) );
	}

/////////////////////////////////////////////////////////////////////////////
// CKeyRingApp commands

BOOL CKeyRingApp::OnIdle(LONG lCount) 
	{
	Sleep(1000);

	// the first time we get here, initialize the remote machines
	if ( !m_fInitialized )
		{
		// we are initializing here because it can take some time
		// and we want the main window to be showing
		ASSERT( g_pDocument );
		g_pDocument->Initialize();

		// set the flag so we don't do this again
		m_fInitialized = TRUE;
		}

	return CWinApp::OnIdle(lCount);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\krdoc.cpp ===
// KRDoc.cpp : implementation of the CKeyRingDoc class
//

#include "stdafx.h"
#include "keyobjs.h"
#include "intrlkey.h"

#include <shlobj.h>

#include "machine.h"
#include "KeyRing.h"
#include "KRDoc.h"
#include "KRView.h"

#include "ConctDlg.h"
#include "InfoDlg.h"
#include "passdlg.h"
#include "ImprtDlg.h"

//#include "WizSheet.h"
#include "NKChseCA.h"
#include "NKDN.h"
#include "NKDN2.h"
#include "NKFlInfo.h"
#include "NKKyInfo.h"
#include "NKUsrInf.h"

#include "Creating.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern CKeyRingView*    g_pTreeView;
extern CString          g_szRemoteCommand;


// a global reference to this doc object
CKeyRingDoc*        g_pDocument = NULL;

/////////////////////////////////////////////////////////////////////////////
// CKeyRingDoc

IMPLEMENT_DYNCREATE(CKeyRingDoc, CDocument)

BEGIN_MESSAGE_MAP(CKeyRingDoc, CDocument)
    //{{AFX_MSG_MAP(CKeyRingDoc)
    ON_UPDATE_COMMAND_UI(ID_SERVER_CONNECT, OnUpdateServerConnect)
    ON_COMMAND(ID_SERVER_CONNECT, OnServerConnect)
    ON_UPDATE_COMMAND_UI(ID_EDIT_COPY, OnUpdateEditCopy)
    ON_COMMAND(ID_EDIT_COPY, OnEditCopy)
    ON_UPDATE_COMMAND_UI(ID_EDIT_CUT, OnUpdateEditCut)
    ON_COMMAND(ID_EDIT_CUT, OnEditCut)
    ON_UPDATE_COMMAND_UI(ID_EDIT_PASTE, OnUpdateEditPaste)
    ON_COMMAND(ID_EDIT_PASTE, OnEditPaste)
    ON_UPDATE_COMMAND_UI(ID_PROPERTIES, OnUpdateProperties)
    ON_COMMAND(ID_PROPERTIES, OnProperties)
    ON_UPDATE_COMMAND_UI(ID_SERVER_COMMIT_NOW, OnUpdateServerCommitNow)
    ON_COMMAND(ID_SERVER_COMMIT_NOW, OnServerCommitNow)
    ON_UPDATE_COMMAND_UI(ID_KEY_CREATE_REQUEST, OnUpdateKeyCreateRequest)
    ON_COMMAND(ID_KEY_CREATE_REQUEST, OnKeyCreateRequest)
    ON_UPDATE_COMMAND_UI(ID_KEY_INSTALL_CERTIFICATE, OnUpdateKeyInstallCertificate)
    ON_COMMAND(ID_KEY_INSTALL_CERTIFICATE, OnKeyInstallCertificate)
    ON_UPDATE_COMMAND_UI(ID_KEY_SAVE_REQUEST, OnUpdateKeySaveRequest)
    ON_COMMAND(ID_KEY_SAVE_REQUEST, OnKeySaveRequest)
    ON_UPDATE_COMMAND_UI(ID_KEY_EXPORT_BACKUP, OnUpdateKeyExportBackup)
    ON_COMMAND(ID_KEY_EXPORT_BACKUP, OnKeyExportBackup)
    ON_UPDATE_COMMAND_UI(ID_KEY_IMPORT_BACKUP, OnUpdateKeyImportBackup)
    ON_COMMAND(ID_KEY_IMPORT_BACKUP, OnKeyImportBackup)
    ON_UPDATE_COMMAND_UI(ID_KEY_IMPORT_KEYSET, OnUpdateKeyImportKeyset)
    ON_COMMAND(ID_KEY_IMPORT_KEYSET, OnKeyImportKeyset)
    ON_COMMAND(ID_KEY_DELETE, OnKeyDelete)
    ON_UPDATE_COMMAND_UI(ID_KEY_DELETE, OnUpdateKeyDelete)
    ON_COMMAND(IDS_NEW_CREATE_NEW, OnNewCreateNew)
    ON_UPDATE_COMMAND_UI(IDS_NEW_CREATE_NEW, OnUpdateNewCreateNew)
    ON_COMMAND(ID_HELPTOPICS, OnHelptopics)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CKeyRingDoc construction/destruction

//----------------------------------------------------------------
CKeyRingDoc::CKeyRingDoc():
        m_pScrapKey(NULL),
        m_fDirty( FALSE )
    {
    g_pDocument = this;
    }

//----------------------------------------------------------------
CKeyRingDoc::~CKeyRingDoc()
    {
    // clean up the add-on services
    DeleteAddOnServices();
    }

//----------------------------------------------------------------
// this is called once
BOOL CKeyRingDoc::Initialize()
    {
    // see which machines we were logged into last time and restore their connections
    RestoreConnectedMachines();

    // set the selection to the first service on the first machine
    // get the first item (a machine) in the list
    CTreeCtrl* pTree = (CTreeCtrl*)g_pTreeView;
    HTREEITEM hItem = pTree->GetRootItem();
    // if that worked, get the next sub item. (a service)
    if ( hItem )
        {
        hItem = pTree->GetChildItem(hItem);
        // if that worked, select the item
        if ( hItem )
            pTree->SelectItem(hItem);
        }

    // return success
    return TRUE;
    }

//----------------------------------------------------------------
BOOL CKeyRingDoc::OnNewDocument()
{
    CLocalMachine   *pLocalMachine;

    if (!CDocument::OnNewDocument())
        return FALSE;

    // initialize the add on services
    if( !FInitAddOnServices() )
        AfxMessageBox( IDS_NO_SERVICE_MODS );

    // connect to the local machine
    try {
        pLocalMachine = new CLocalMachine;
        }
    catch( CException e )
        {
        return FALSE;
        }

    // add it to the tree at the top level
    pLocalMachine->FAddToTree( NULL );

    // load the services add-ons into the machine
    if ( !FLoadAddOnServicesOntoMachine( pLocalMachine ) )
        {
        pLocalMachine->FRemoveFromTree();
        delete pLocalMachine;
        }

    // return success
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CKeyRingDoc serialization

void CKeyRingDoc::Serialize(CArchive& ar)
{
    if (ar.IsStoring())
    {
        // TODO: add storing code here
    }
    else
    {
        // TODO: add loading code here
    }
}

/////////////////////////////////////////////////////////////////////////////
// CKeyRingDoc diagnostics

#ifdef _DEBUG
void CKeyRingDoc::AssertValid() const
    {
    CDocument::AssertValid();
    }

void CKeyRingDoc::Dump(CDumpContext& dc) const
    {
    CDocument::Dump(dc);
    }
#endif //_DEBUG




/////////////////////////////////////////////////////////////////////////////
// test what is selected in the treeview
// if the selcted item is not of the requested type (machine, key, etc...)

//--------------------------------------------------------------
// then it returns a NULL
CTreeItem*  CKeyRingDoc::PGetSelectedItem()
    {
    ASSERT( g_pTreeView );
    CTreeCtrl*  pTree = (CTreeCtrl*)g_pTreeView;

    // get the selected item
    HTREEITEM hTreeItem = pTree->GetSelectedItem();

    // if nothing is selected, return a null
    if ( !hTreeItem ) return NULL;

    // get the associated internal object and return it
    CTreeItem* pItem = (CTreeItem*)pTree->GetItemData( hTreeItem );
    return ( pItem );
    }

//--------------------------------------------------------------
CMachine*   CKeyRingDoc::PGetSelectedMachine()
    {
    CMachine*   pMachine = (CMachine*)PGetSelectedItem();
    // make sure it is a machine object
    if ( !pMachine || pMachine->IsKindOf(RUNTIME_CLASS(CMachine)) )
        return NULL;
    // its OK
    return pMachine;
    }

//--------------------------------------------------------------
CService*   CKeyRingDoc::PGetSelectedService()
    {
    CService*   pService = (CService*)PGetSelectedItem();
    // make sure it is a machine object
    if ( !pService || pService->IsKindOf(RUNTIME_CLASS(CService)) )
        return NULL;
    // its OK
    return pService;
    }

//--------------------------------------------------------------
CKey*       CKeyRingDoc::PGetSelectedKey()
    {
    CKey*   pKey = (CKey*)PGetSelectedItem();
    // make sure it is a machine object
    if ( !pKey || pKey->IsKindOf(RUNTIME_CLASS(CKey)) )
        return NULL;
    // its OK
    return pKey;
    }


/////////////////////////////////////////////////////////////////////////////
// add-on service management
//----------------------------------------------------------------
// pointers to the add-on services are stored in the registry
//----------------------------------------------------------------
BOOL CKeyRingDoc::FInitAddOnServices()
    {
    DWORD       err;
    CString     szRegKeyName;
    HKEY        hKey;
    DWORD       iValue = 0;
    DWORD       dwordType;
    DWORD       cbValName = MAX_PATH+1;
    DWORD       cbBuff = MAX_PATH+1;

    CString     szValName, szServiceName;
    LPTSTR      pValName, pServiceName;

    BOOL        fLoadedOne = FALSE;

    CWaitCursor     waitcursor;

    // load the registry key name
    szRegKeyName.LoadString( IDS_ADDONS_LOCATION );

    // open the registry key, if it exists
    err = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE, // handle of open key
            szRegKeyName,       // address of name of subkey to open
            0,                  // reserved
            KEY_READ,           // security access mask
            &hKey               // address of handle of open key
           );

    // if we did not open the key for any reason (say... it doesn't exist)
    // then leave right away
    if ( err != ERROR_SUCCESS )
        return FALSE;

    // set up the buffers
    pValName = szValName.GetBuffer( MAX_PATH+1 );
    pServiceName = szServiceName.GetBuffer( MAX_PATH+1 );

    // we opened the key. Now we enumerate the values and reconnect the machines
    while ( RegEnumValue(hKey, iValue, pValName,
                &cbValName, NULL, &dwordType,
                (PUCHAR)pServiceName, &cbBuff) == ERROR_SUCCESS )
        {
        // release the buffer so we can use the string
        szServiceName.ReleaseBuffer();

        // attempt to load and initialize the add on service module
        CAddOnService* pService;
        try {
            // create the service object
            pService = new CAddOnService;
            
            // initialize it
            if ( pService->FInitializeAddOnService( szServiceName ) )
                {
                // add it to the list
                m_AddOnServiceArray.Add( pService );

                // we did load one
                fLoadedOne = TRUE;
                }
            else
                {
                // delete the services object because it didn't work
                delete pService;
                pService = NULL;
                }
            }
        catch (CException e)
            {
            // delete the services object because it didn't work
            if ( pService )
                delete pService;
            pService = NULL;
            }

        // get the buffer again so we can get the next machine
        pServiceName = szServiceName.GetBuffer( MAX_PATH+1 );

        // increment the value counter
        iValue++;
        cbValName = MAX_PATH+1;
        cbBuff = MAX_PATH+1;
        }

    // release the name buffers
    szValName.ReleaseBuffer();
    szServiceName.ReleaseBuffer();

    // all done, close the key before leaving
    RegCloseKey( hKey );

    // return whether or not we loaded something
    return fLoadedOne;
    }

//----------------------------------------------------------------
BOOL CKeyRingDoc::FLoadAddOnServicesOntoMachine( CMachine* pMachine )
    {
    BOOL    fAddedOne = FALSE;

    // loop though the list of add on services and add them to the machine
    WORD num = (WORD)m_AddOnServiceArray.GetSize();
    for ( WORD i = 0; i < num; i++ )
        fAddedOne |= m_AddOnServiceArray[i]->LoadService( pMachine );

    // return whether or not we added something
    return fAddedOne;
    }

//----------------------------------------------------------------
void CKeyRingDoc::DeleteAddOnServices()
    {
    // loop backwards through the array and delete the objects
    for ( LONG i = m_AddOnServiceArray.GetSize()-1; i >= 0; i-- )
        delete m_AddOnServiceArray[i];

    // clear out the array
    m_AddOnServiceArray.RemoveAll();
    }


/////////////////////////////////////////////////////////////////////////////
// CKeyRingDoc commands

//----------------------------------------------------------------
void CKeyRingDoc::OnUpdateServerConnect(CCmdUI* pCmdUI)
    { pCmdUI->Enable( TRUE ); }

//----------------------------------------------------------------
void CKeyRingDoc::OnServerConnect()
    {
    BROWSEINFO bi;
    LPSTR lpBuffer;
    LPITEMIDLIST pidlBrowse, pidlStart;    // PIDL selected by user

    // Allocate a buffer to receive browse information.
    lpBuffer = (LPSTR) GlobalAlloc( GPTR, MAX_PATH );
    if ( !lpBuffer )
        return;

    // load the title
    CString szTitle;
    szTitle.LoadString( IDS_CHOOSE_COMPUTER );

    // tell it where to start looking
    SHGetSpecialFolderLocation( AfxGetMainWnd()->m_hWnd, CSIDL_NETWORK, &pidlStart );

    // Fill in the BROWSEINFO structure.
    bi.hwndOwner = AfxGetMainWnd()->m_hWnd;
    bi.pidlRoot = pidlStart;
    bi.pszDisplayName = lpBuffer;
    bi.lpszTitle = szTitle;
    bi.ulFlags = BIF_BROWSEFORCOMPUTER;
    bi.lpfn = NULL;
    bi.lParam = 0;

    // Browse for a folder and return its PIDL.
    pidlBrowse = SHBrowseForFolder(&bi);
    if (pidlBrowse != NULL)
        {
        CString sz = lpBuffer;
        ConnectToMachine( sz );

        // Free the PIDL returned by SHBrowseForFolder.
        GlobalFree(pidlBrowse);
        }

    //clean up the pidl
    if ( pidlStart )
        GlobalFree(pidlStart);
    }

// manage connections to machines
//----------------------------------------------------------------
void CKeyRingDoc::ConnectToMachine( CString &sz )
    {
    CRemoteMachine  *pRemoteMachine;

    // don't "remote" connect to the local machine
    CString         szLocalName;
    DWORD           cbBuff = MAX_COMPUTERNAME_LENGTH+1;
    GetComputerName(szLocalName.GetBuffer((cbBuff)*2), &cbBuff);
    szLocalName.ReleaseBuffer();

    // if sz is the same as the local machine name, don't connect to it
    if ( sz.CompareNoCase(szLocalName) == 0 )
        return;

    // see if we already are connected
    // to the remote machine. If we are, then just hilight that one
    if ( g_pTreeView )
        {
        CString     szItem;
        CTreeCtrl* pTree = (CTreeCtrl*)g_pTreeView;
        HTREEITEM hItem = pTree->GetRootItem();
        while ( hItem )
            {
            szItem = pTree->GetItemText(hItem);
            if ( sz.CompareNoCase(szItem) == 0 )
                {
                // we are already connected to this machine
                // select the item in the tree
                pTree->Select( hItem, TVGN_CARET );
                return;
                }
            // get the next item
            hItem = pTree->GetNextSiblingItem( hItem );
            }
        }

    // since this could take a few seconds, put up a wait cursor
    CWaitCursor waitCursor;

    // connect to the local machine
    try {
        pRemoteMachine = new CRemoteMachine( sz );
        }
    catch( CException e )
        {
        AfxMessageBox( IDS_ERR_CONNECT );
        return;
        }

    // add it to the tree at the top level
    pRemoteMachine->FAddToTree( NULL );

    // load the services add-ons into the machine
    if ( !FLoadAddOnServicesOntoMachine( pRemoteMachine ) )
        {
        AfxMessageBox( IDS_ERR_CONNECT );
        pRemoteMachine->FRemoveFromTree();
        delete pRemoteMachine;
        }
    }
//----------------------------------------------------------------
// we want to save the machines the user was connected to so they remain connected
// the next time we launch the program
void    CKeyRingDoc::StoreConnectedMachines( void )
    {
    DWORD       err, disposition;
    CString     szRegKeyName;
    HKEY        hKey;
    WORD        cMachine = 1;

    // load the registry key name
    szRegKeyName.LoadString( IDS_REG_SERVER_STORAGE );

    // first, we delete the machine subkey to get rid of all the previous values
    err = RegDeleteKey( HKEY_CURRENT_USER, szRegKeyName );

    // create the registry key. If it already exists it merely opens it
    err = RegCreateKeyEx(
        HKEY_CURRENT_USER,          // handle of an open key
        szRegKeyName,               // address of subkey name
        0,                          // reserved
        NULL,                       // address of class string
        REG_OPTION_NON_VOLATILE,    // special options flag
        KEY_ALL_ACCESS,             // desired security access
        NULL,                       // address of key security structure
        &hKey,                      // address of buffer for opened handle
        &disposition                // address of disposition value buffer
       );

    // if we did not open the key, give up
    if ( err != ERROR_SUCCESS )
        return;

    // loop through the machines
    CTreeCtrl* pTree = (CTreeCtrl*)g_pTreeView;
    HTREEITEM hItem = pTree->GetRootItem();
    while ( hItem )
        {
        CRemoteMachine* pMachine = (CRemoteMachine*)pTree->GetItemData( hItem );
        ASSERT( pMachine->IsKindOf( RUNTIME_CLASS(CMachine) ) );

        // only bother if this is a remote machine
        if ( pMachine->IsKindOf(RUNTIME_CLASS(CRemoteMachine)) )
            {
            // build the registry value name
            CString szMachineValue;
            szMachineValue.Format( "Machine#%d", cMachine );

            // get the machine name
            CString szMachineName;
            pMachine->GetMachineName( szMachineName );

            // set the data into place
            err = RegSetValueEx(
                hKey,                           // handle of key to set value for
                szMachineValue,                     // address of value to set
                0,                              // reserved
                REG_SZ,                         // flag for value type
                (unsigned char *)LPCSTR(szMachineName), // address of value data
                (szMachineName.GetLength() + 1) * sizeof(TCHAR)// size of value data
               );

            // increment the machine counter
            cMachine++;
            }

        // get the next item
        hItem = pTree->GetNextSiblingItem( hItem );
        }

    // close the key
    RegCloseKey( hKey );
    }

//----------------------------------------------------------------
void    CKeyRingDoc::RestoreConnectedMachines( void )
    {
    DWORD       err;
    CString     szRegKeyName;
    HKEY        hKey;
    DWORD       iValue = 0;
    DWORD       dwordType;
    DWORD       cbValName = MAX_PATH+1;
    DWORD       cbBuff = MAX_PATH+1;

    CString     szValName, szMachineName;
    LPTSTR      pValName, pMachineName;

    CWaitCursor     waitcursor;

    // load the registry key name
    szRegKeyName.LoadString( IDS_REG_SERVER_STORAGE );

    // open the registry key, if it exists
    err = RegOpenKeyEx(
            HKEY_CURRENT_USER,  // handle of open key
            szRegKeyName,       // address of name of subkey to open
            0,                  // reserved
            KEY_READ,           // security access mask
            &hKey               // address of handle of open key
           );

    // if we did not open the key for any reason (say... it doesn't exist)
    // then leave right away
    if ( err != ERROR_SUCCESS )
        return;

    // set up the buffers
    pValName = szValName.GetBuffer( MAX_PATH+1 );
    pMachineName = szMachineName.GetBuffer( MAX_PATH+1 );

    // we opened the key. Now we enumerate the values and reconnect the machines
    while ( RegEnumValue(hKey, iValue, pValName,
                &cbValName, NULL, &dwordType,
                (PUCHAR)pMachineName, &cbBuff) == ERROR_SUCCESS )
        {
        // release the buffer so we can use the string
        szMachineName.ReleaseBuffer();

        // attempt to connect to the remote machine
        ConnectToMachine(szMachineName);

        // get the buffer again so we can get the next machine
        pMachineName = szMachineName.GetBuffer( MAX_PATH+1 );

        // increment the value counter
        iValue++;
        cbValName = MAX_PATH+1;
        cbBuff = MAX_PATH+1;
        }

    // release the name buffers
    szValName.ReleaseBuffer();
    szMachineName.ReleaseBuffer();

    // all done, close the key before leaving
    RegCloseKey( hKey );

    // finally, if the user requested a specific remote machine
    // on the command line, connect to that one too
    if ( !g_szRemoteCommand.IsEmpty() )
        {
        ConnectToMachine( g_szRemoteCommand );
        }
    }

//----------------------------------------------------------------
void CKeyRingDoc::OnCloseDocument()
    {
    if ( g_pTreeView )
        ((CKeyRingView*)g_pTreeView)->DestroyItems();

    // if we have a scrap key, delete it
    if ( m_pScrapKey )
        {
        delete m_pScrapKey;
        m_pScrapKey = NULL;
        }

    CDocument::OnCloseDocument();
    }




// actions that depend on the selected item
//----------------------------------------------------------------
void CKeyRingDoc::OnUpdateProperties(CCmdUI* pCmdUI)
    {
    CTreeItem*  pItem = g_pTreeView->PGetSelectedItem();
    // let the item decide
    if ( pItem )
        pItem->OnUpdateProperties( pCmdUI );
    else
        pCmdUI->Enable( FALSE );
    }

//----------------------------------------------------------------
void CKeyRingDoc::OnProperties()
    {
    CTreeItem*  pItem = g_pTreeView->PGetSelectedItem();
    ASSERT( pItem );
    // let the item handle it
    pItem->OnProperties();
    }


//----------------------------------------------------------------
void CKeyRingDoc::OnUpdateServerCommitNow(CCmdUI* pCmdUI)
    {
    pCmdUI->Enable( m_fDirty );
    }

//----------------------------------------------------------------
void CKeyRingDoc::OnServerCommitNow()
    {
    ASSERT( m_fDirty );

    // confirm that the user really wants to commit the changes
    if ( AfxMessageBox(IDS_SERVER_COMMIT, MB_YESNO) == IDNO )
        return;

    // commit all the servers
    ASSERT(g_pTreeView);
    BOOL fSuccess = g_pTreeView->FCommitMachinesNow();
    SetDirty( !fSuccess );
    }

//----------------------------------------------------------------
void CKeyRingDoc::OnUpdateKeyDelete(CCmdUI* pCmdUI)
    {
    CTreeItem*  pItem = g_pTreeView->PGetSelectedItem();
    if ( pItem )
        pCmdUI->Enable( pItem->IsKindOf(RUNTIME_CLASS(CKey)) );
    else
        pCmdUI->Enable( FALSE );
    }

//----------------------------------------------------------------
void CKeyRingDoc::OnKeyDelete()
    {
    CKey*   pKey = (CKey*)g_pTreeView->PGetSelectedItem();
    ASSERT( pKey );
    ASSERT( pKey->IsKindOf(RUNTIME_CLASS(CKey)) );

    // make sure the user REALLY wants to do this
    if ( pKey && (AfxMessageBox(IDS_KEY_DELETE_WARNING, MB_OKCANCEL) == IDOK) )
        {
        // dirty things first
        pKey->SetDirty(TRUE);
        // update the view
        pKey->FRemoveFromTree();
        delete pKey;
        }
    }

//----------------------------------------------------------------
// set scrap key does NOT make a copy of the key. Thus, CUT would pass in
// the key itself, but COPY would make a copy of the key object first, then
// pass it over to SetScrapKey.
void CKeyRingDoc::SetScrapKey( CKey* pKey )
    {
    // if there already is a key in the scrap, delete it
    if ( m_pScrapKey )
        delete m_pScrapKey;

    // set the new key into position
    m_pScrapKey = pKey;
    }

//----------------------------------------------------------------
void CKeyRingDoc::OnUpdateEditCopy(CCmdUI* pCmdUI)
    {
    CTreeItem*  pItem = g_pTreeView->PGetSelectedItem();
    if ( pItem )
        pCmdUI->Enable( pItem->IsKindOf(RUNTIME_CLASS(CKey)) );
    else
        pCmdUI->Enable( FALSE );
    }

//----------------------------------------------------------------
void CKeyRingDoc::OnUpdateEditCut(CCmdUI* pCmdUI)
    {
    CTreeItem*  pItem = g_pTreeView->PGetSelectedItem();
    if ( pItem )
        pCmdUI->Enable( pItem->IsKindOf(RUNTIME_CLASS(CKey)) );
    else
        pCmdUI->Enable( FALSE );
    }

//----------------------------------------------------------------
void CKeyRingDoc::OnEditCut()
    {
    CKey*   pKey = (CKey*)g_pTreeView->PGetSelectedItem();
    ASSERT( pKey );
    ASSERT( pKey->IsKindOf(RUNTIME_CLASS(CKey)) );

    // mark the key dirty before we remove it so the dirty is propagated up
    // to the machine and the document
    pKey->SetDirty( TRUE );

    // cut is the easiest. Remove it from the machine and put in on the doc scrap
    pKey->FRemoveFromTree();
    SetScrapKey( pKey );
    }

//----------------------------------------------------------------
void CKeyRingDoc::OnEditCopy()
    {
    CKey*   pKeySel = (CKey*)g_pTreeView->PGetSelectedItem();
    CKey*   pKeyCopy;
    ASSERT( pKeySel );
    ASSERT( pKeySel->IsKindOf(RUNTIME_CLASS(CKey)) );
    if ( !pKeySel ) return;

    // make a full copy of the key
    try
        {
        pKeyCopy = pKeySel->PClone();
        }
    catch( CException e )
        {
        return;
        }
    ASSERT( pKeyCopy );

    // put the clone on the doc scrap
    SetScrapKey( pKeyCopy );
    }

//----------------------------------------------------------------
void CKeyRingDoc::OnUpdateEditPaste(CCmdUI* pCmdUI)
    {
    CTreeItem*  pItem = g_pTreeView->PGetSelectedItem();
    if ( pItem )
        {
        pCmdUI->Enable( (pItem->IsKindOf(RUNTIME_CLASS(CService)) ||
            pItem->IsKindOf(RUNTIME_CLASS(CKey))) && PGetScrapKey() );
        }
    else
        pCmdUI->Enable( FALSE );
    }

//----------------------------------------------------------------
void CKeyRingDoc::OnEditPaste()
    {
    ASSERT( PGetScrapKey() );
    CService*   pService = (CService*)g_pTreeView->PGetSelectedItem();
    ASSERT( pService );
    ASSERT( pService->IsKindOf(RUNTIME_CLASS(CService)) ||
        pService->IsKindOf(RUNTIME_CLASS(CKey)));

    // if the selection is a key, get the key's parent, which should be a service
    if ( pService->IsKindOf(RUNTIME_CLASS(CKey)) )
        {
        pService = (CService*)pService->PGetParent();
        ASSERT( pService );
        ASSERT( pService->IsKindOf(RUNTIME_CLASS(CService)) );
        }

    // clone the scrap key so we put a copy in the machine
    CKey*   pClone;
    try
        {
        pClone = pService->PNewKey();
        pClone->CopyDataFrom( PGetScrapKey() );

        // if this is a full key - i.e. it has a certificate - we need to check it
        if ( pClone->m_pCertificate )
            {
            // we are going to re-install the cert anyway, so prevent it from being freed
            PVOID pCert = pClone->m_pCertificate;
            DWORD cbCert = pClone->m_cbCertificate;
            CString szPass = pClone->m_szPassword;
            pClone->m_pCertificate = NULL;
            pClone->m_cbCertificate = 0;
            pClone->m_szPassword.Empty();
            // make sure it can deal with the certificate.
            if ( !pClone->FInstallCertificate(pCert,cbCert,szPass) )
                {
                delete pClone;
                return;
                }
            }

        // add the key to the service
        pClone->FAddToTree( pService );
        // make sure the cloned key has a caption
        pClone->UpdateCaption();

        // select the newly added key
        if ( g_pTreeView )
            ((CTreeCtrl*)g_pTreeView)->SelectItem(pClone->HGetTreeItem());

        // if there is a certificate, then bring up the properties dialog
        if ( pClone->m_cbCertificate )
            {
            pClone->OnProperties();
            }

        // set the dirty flag
        pClone->SetDirty( TRUE );
        }
    catch( CException e )
        {
        return;
        }

    // set the dirty flag
    pService->SetDirty( TRUE );
    }


//----------------------------------------------------------------
void CKeyRingDoc::OnUpdateKeyCreateRequest(CCmdUI* pCmdUI)
    {
    CTreeItem*  pItem = g_pTreeView->PGetSelectedItem();
    if ( pItem )
        {
        pCmdUI->Enable( pItem->IsKindOf(RUNTIME_CLASS(CService)) ||
            pItem->IsKindOf(RUNTIME_CLASS(CKey)) );
        }
    else
        pCmdUI->Enable( FALSE );
    }

//----------------------------------------------------------------
void CKeyRingDoc::OnKeyCreateRequest()
    {
    }

//----------------------------------------------------------------
// if the key is targeted to an online authority, then we need to take
// special care. Otherwise, just go ahead and let them install a file cert.
void CKeyRingDoc::OnUpdateKeyInstallCertificate(CCmdUI* pCmdUI)
    {
    CTreeItem*  pItem = g_pTreeView->PGetSelectedItem();
    BOOL        fEnable = FALSE;

    // make sure we have a selected item and that it is a key
    if ( pItem && pItem->IsKindOf(RUNTIME_CLASS(CKey)) )
        {
        // cast the key
        CKey*   pKey = (CKey*)pItem;

        // determine if this is a online authority key
        LPREQUEST_HEADER pHeader = (LPREQUEST_HEADER)pKey->m_pCertificateRequest;
        if ( pHeader &&
                pHeader->Identifier == REQUEST_HEADER_IDENTIFIER &&
                pHeader->fReqSentToOnlineCA )
            {
            // this key does target an online authority

            // if the fWaitingForApproval is set then allow the action
            if ( pHeader->fWaitingForApproval )
                fEnable = TRUE;

            // can optionally alter the text of the meny item here
            }
        else
            {
            // the key does not target an online authority, just
            // let the user attach a file-based certificate
            fEnable = TRUE;
            }
        }

    // do the enabling
    pCmdUI->Enable( fEnable );
    }

//----------------------------------------------------------------
void CKeyRingDoc::OnKeyInstallCertificate()
    {
    CKey*   pKey = (CKey*)g_pTreeView->PGetSelectedItem();
    ASSERT( pKey );
    ASSERT( pKey->IsKindOf(RUNTIME_CLASS(CKey)) );

    // put this in a try/catch to make errors easier to deal with
    try {

        // start by seeing if this is a online based key waiting for a response
        LPREQUEST_HEADER pHeader = (LPREQUEST_HEADER)pKey->m_pCertificateRequest;
        if ( pHeader &&
                pHeader->Identifier == REQUEST_HEADER_IDENTIFIER &&
                pHeader->fReqSentToOnlineCA )
            {
            // should be waiting for approval
            ASSERT( pHeader->fWaitingForApproval );

            // contact the online authority to get the certificate
            GetOnlineKeyApproval( pKey );

            // avoid all the file based stuff and leave now
            return;
            }

        // the old, file based stuff    

        // prepare the file dialog variables
        CFileDialog     cfdlg(TRUE);
        CString         szFilter;
        WORD            i = 0;
        LPSTR           lpszBuffer;
    
        // prepare the filter string
        szFilter.LoadString( IDS_CERTIFICATE_FILTER );
    
        // replace the "!" characters with nulls
        lpszBuffer = szFilter.GetBuffer(MAX_PATH+1);
        while( lpszBuffer[i] )
            {
            if ( lpszBuffer[i] == _T('!') )
                lpszBuffer[i] = _T('\0');           // yes, set \0 on purpose
            i++;
            }

        // prep the dialog
        cfdlg.m_ofn.lpstrFilter = lpszBuffer;
        cfdlg.m_ofn.lpstrDefExt = NULL;


        // run the dialog
        if ( cfdlg.DoModal() == IDOK )
            {
            // get the password string
            CConfirmPassDlg     dlgconfirm;
            if ( dlgconfirm.DoModal() == IDOK )
                {
                // tell the key to install the certificate
                if ( pKey->FInstallCertificate( cfdlg.GetPathName(), dlgconfirm.m_szPassword ) )
                    {
                    pKey->OnProperties();
                    pKey->SetDirty( TRUE );
                    UpdateAllViews( NULL, HINT_None );
                    }
                else
                    {
                    // now the plugin is responsible fot telling the user
                    // that the cert didn't install right


                    // tell the user that it didn't work
//                    AfxMessageBox( IDS_ERR_INSTALLING_CERT );
                    }
                }
            }

        // release the buffer in the filter string
        szFilter.ReleaseBuffer(-1);
        }
    catch ( CException e )
        {
        }
    }

//----------------------------------------------------------------
void CKeyRingDoc::OnUpdateKeySaveRequest(CCmdUI* pCmdUI)
    {
    BOOL    fEnable = FALSE;
    CKey*   pKey = (CKey*)g_pTreeView->PGetSelectedItem();

    // quite a few conditions here, so do them one at a time
    if ( pKey && pKey->IsKindOf(RUNTIME_CLASS(CKey)) )
        {

        // determine if this is a online authority key
        LPREQUEST_HEADER pHeader = (LPREQUEST_HEADER)pKey->m_pCertificateRequest;
        if ( pHeader &&
                pHeader->Identifier == REQUEST_HEADER_IDENTIFIER &&
                pHeader->fReqSentToOnlineCA )
            {
            // if we are already waiting for approval, do not ask for a new cert
            fEnable = !pHeader->fWaitingForApproval;
            }
        else
            {
            // a file-based key
            fEnable = TRUE;
            if ( fEnable )
                fEnable &= (pKey->m_cbCertificateRequest > 0);
            if ( fEnable )
                fEnable &= (pKey->m_pCertificateRequest != NULL);
            }
        }

    // enable the item
    pCmdUI->Enable( fEnable );
    }

//----------------------------------------------------------------
void CKeyRingDoc::OnKeySaveRequest()
    {
    CKey*   pKey = (CKey*)g_pTreeView->PGetSelectedItem();
    ASSERT( pKey );
    ASSERT( pKey->IsKindOf(RUNTIME_CLASS(CKey)) );
    ASSERT( pKey->m_cbCertificateRequest );
    ASSERT( pKey->m_pCertificateRequest );

    // start by seeing if this is a new style key request
    LPREQUEST_HEADER pHeader = (LPREQUEST_HEADER)pKey->m_pCertificateRequest;
    if ( pHeader &&
            pHeader->Identifier == REQUEST_HEADER_IDENTIFIER )
        {
        // should not be waiting for approval
        ASSERT( !pHeader->fWaitingForApproval );

        // send out the online key renewal request
        DoKeyRenewal( pKey );

        // avoid all the file based stuff and leave now
        return;
        }


    // the old, file based stuff

    // get the key name
    CString szKeyName = pKey->GetName();

    // make the default file name
    CString szDefaultFile;
    szDefaultFile = _T("C:\\");
    szDefaultFile += szKeyName;
    szDefaultFile += _T(".req");

    CFileDialog     cfdlg(FALSE, _T("*.req"), szDefaultFile);
    CString         szFilter;
    WORD            i = 0;
    LPSTR           lpszBuffer;
    
    // prepare the filter string
    szFilter.LoadString( IDS_REQUEST_FILTER );
    
    // replace the "!" characters with nulls
    lpszBuffer = szFilter.GetBuffer(MAX_PATH+1);
    while( lpszBuffer[i] )
        {
        if ( lpszBuffer[i] == _T('!') )
            lpszBuffer[i] = _T('\0');           // yes, set \0 on purpose
        i++;
        }

    // prep the dialog
    cfdlg.m_ofn.lpstrFilter = lpszBuffer;

    // run the dialog
    if ( cfdlg.DoModal() == IDOK )
        {
        // output the request file
        if ( !pKey->FOutputRequestFile(cfdlg.GetPathName()) )
            {
            AfxMessageBox( IDS_ERR_WRITEREQUEST );
            }
        else
            {
            // put up the user information box
            CNewKeyInfoDlg      dlg;
            dlg.m_fNewKeyInfo = FALSE;
            dlg.m_szRequestFile = cfdlg.GetPathName();
            dlg.DoModal();
            }
        }

    // release the buffer in the filter string
    szFilter.ReleaseBuffer(60);
    }

//----------------------------------------------------------------
void CKeyRingDoc::OnUpdateKeyImportKeyset(CCmdUI* pCmdUI)
    {
    CTreeItem*  pItem = g_pTreeView->PGetSelectedItem();
    if ( pItem )
        pCmdUI->Enable( pItem->IsKindOf(RUNTIME_CLASS(CService)) ||
            pItem->IsKindOf(RUNTIME_CLASS(CKey)) );
    else
        pCmdUI->Enable( FALSE );
    }

//----------------------------------------------------------------
void CKeyRingDoc::OnKeyImportKeyset()
    {
    CService*   pService = (CService*)g_pTreeView->PGetSelectedItem();
    ASSERT( pService );
    ASSERT( pService->IsKindOf(RUNTIME_CLASS(CService)) ||
        pService->IsKindOf(RUNTIME_CLASS(CKey)));

    // if the selection is a key, get the key's parent, which should be a service
    if ( pService->IsKindOf(RUNTIME_CLASS(CKey)) )
        {
        pService = (CService*)pService->PGetParent();
        ASSERT( pService );
        ASSERT( pService->IsKindOf(RUNTIME_CLASS(CService)) );
        }

    CString szPrivateKey;
    CString szPublicKey;

    // get the names of the key files
    CImportDialog   ImprtDlg;
    if ( ImprtDlg.DoModal() != IDOK )
        {
        // exit because the user canceled
        return;
        }

    // the user must also give a password
    CConfirmPassDlg     dlgconfirm;
    if ( dlgconfirm.DoModal() != IDOK )
        return;

    try
        {
        // create the new import key object
        CKey*   pKey = pService->PNewKey();

        // tell it to do the importing
        if ( !pKey->FImportKeySetFiles(ImprtDlg.m_cstring_PrivateFile,
                ImprtDlg.m_cstring_CertFile, dlgconfirm.m_szPassword) )
            {
            delete pKey;
            return;
            }

        // make sure its name is untitled
        CString szName;
        szName.LoadString( IDS_UNTITLED );
        pKey->SetName( szName );

        // add the key to the service
        pKey->FAddToTree( pService );

        // make sure the key has a caption
        pKey->UpdateCaption();

        // set the dirty flag
        pKey->SetDirty( TRUE );

        // select the newly added key
        if ( g_pTreeView )
            ((CTreeCtrl*)g_pTreeView)->SelectItem(pKey->HGetTreeItem());

        // force properties dlg
        pKey->OnProperties();
        }
    catch( CException e )
        {
        return;
        }
    }

//----------------------------------------------------------------
void CKeyRingDoc::OnUpdateKeyExportBackup(CCmdUI* pCmdUI)
    {
    CTreeItem*  pItem = g_pTreeView->PGetSelectedItem();
    if ( pItem )
        pCmdUI->Enable( pItem->IsKindOf(RUNTIME_CLASS(CKey)) );
    else
        pCmdUI->Enable( FALSE );
    }

//----------------------------------------------------------------
void CKeyRingDoc::OnKeyExportBackup()
    {
    CKey*   pKey = (CKey*)g_pTreeView->PGetSelectedItem();
    ASSERT( pKey );
    ASSERT( pKey->IsKindOf(RUNTIME_CLASS(CKey)) );

    CFileDialog     cfdlg(FALSE, _T("*.key"));
    CString         szFilter;
    WORD            i = 0;
    LPSTR           lpszBuffer;
    
    ASSERT(pKey);
    if ( !pKey ) return;

    // warn the user about security
    if ( AfxMessageBox(IDS_KEYFILE_WARNING, MB_OKCANCEL|MB_ICONEXCLAMATION) == IDCANCEL )
        return;

    // prepare the filter string
    szFilter.LoadString( IDS_KEY_FILE_TYPE );
    
    // replace the "!" characters with nulls
    lpszBuffer = szFilter.GetBuffer(MAX_PATH+1);
    while( lpszBuffer[i] )
        {
        if ( lpszBuffer[i] == _T('!') )
            lpszBuffer[i] = _T('\0');           // yes, set \0 on purpose
        i++;
        }

    // prep the dialog
    cfdlg.m_ofn.lpstrFilter = lpszBuffer;

    // run the dialog
    if ( cfdlg.DoModal() == IDOK )
        {
        // tell the key to export itself
        pKey->FImportExportBackupFile( cfdlg.GetPathName(), FALSE );
        }

    // release the buffer in the filter string
    szFilter.ReleaseBuffer(60);
    }

//----------------------------------------------------------------
void CKeyRingDoc::OnUpdateKeyImportBackup(CCmdUI* pCmdUI)
    {
    CTreeItem*  pItem = g_pTreeView->PGetSelectedItem();
    if ( pItem )
        pCmdUI->Enable( pItem->IsKindOf(RUNTIME_CLASS(CService)) ||
            pItem->IsKindOf(RUNTIME_CLASS(CKey)) );
    else
        pCmdUI->Enable( FALSE );
    }

//----------------------------------------------------------------
void CKeyRingDoc::OnKeyImportBackup()
    {
    CService*   pService = (CService*)g_pTreeView->PGetSelectedItem();
    ASSERT( pService );
    ASSERT( pService->IsKindOf(RUNTIME_CLASS(CService)) ||
        pService->IsKindOf(RUNTIME_CLASS(CKey)));

    // if the selection is a key, get the key's parent, which should be a service
    if ( pService->IsKindOf(RUNTIME_CLASS(CKey)) )
        {
        pService = (CService*)pService->PGetParent();
        ASSERT( pService );
        ASSERT( pService->IsKindOf(RUNTIME_CLASS(CService)) );
        }

    CFileDialog     cfdlg(TRUE );
    CString         szFilter;
    WORD            i = 0;
    LPSTR           lpszBuffer;

    // make sure we are ok
    if ( !pService )
        return;

    // prepare the filter string
    szFilter.LoadString( IDS_KEY_FILE_TYPE );
    
    // replace the "!" characters with nulls
    lpszBuffer = szFilter.GetBuffer(MAX_PATH+1);
    while( lpszBuffer[i] )
        {
        if ( lpszBuffer[i] == _T('!') )
            lpszBuffer[i] = _T('\0');           // yes, set \0 on purpose
        i++;
        }

    // prep the dialog
    cfdlg.m_ofn.lpstrFilter = lpszBuffer;

    // run the dialog
    if ( cfdlg.DoModal() == IDOK )
        {
        try
            {
            // create the new import key object
            CKey*   pKey = pService->PNewKey();

            // tell it to do the importing
            if ( !pKey->FImportExportBackupFile(cfdlg.GetPathName(), TRUE) )
                {
                delete pKey;
                return;
                }

            // if this is a full key - i.e. it has a certificate - we need to check it
            if ( pKey->m_pCertificate )
                {
                // we are going to re-install the cert anyway, so prevent it from being freed
                PVOID pCert = pKey->m_pCertificate;
                DWORD cbCert = pKey->m_cbCertificate;
                CString szPass = pKey->m_szPassword;
                pKey->m_pCertificate = NULL;
                pKey->m_cbCertificate = 0;
                pKey->m_szPassword.Empty();

                // make sure it can deal with the certificate.
                if ( !pKey->FInstallCertificate(pCert,cbCert,szPass) )
                    {
                    delete pKey;
                    return;
                    }
                }

            // add the key to the service
            pKey->FAddToTree( pService );

            // make sure the key has a caption
            pKey->UpdateCaption();

            // set the dirty flag
            pKey->SetDirty( TRUE );

            // select the newly added key
            if ( g_pTreeView )
                ((CTreeCtrl*)g_pTreeView)->SelectItem(pKey->HGetTreeItem());

            // if there is a certificate, then bring up the properties dialog
            if ( pKey->m_cbCertificate )
                {
                pKey->OnProperties();
                }

            }
        catch( CException e )
            {
            return;
            }
        }
    }

//----------------------------------------------------------------
BOOL CKeyRingDoc::CanCloseFrame(CFrameWnd* pFrame)
    {
    BOOL fSuccess;

    // if we are dirty, ask the user what to do - they can cancel here
    if ( m_fDirty )
        {
        switch( AfxMessageBox(IDS_SERVER_COMMIT, MB_YESNOCANCEL|MB_ICONQUESTION) )
            {
            case IDYES:     // yes, they do want to commit
                // commit all the servers
                ASSERT(g_pTreeView);
                fSuccess = g_pTreeView->FCommitMachinesNow();
                break;
            case IDNO:      // no, they don't want to commit
                break;
            case IDCANCEL:  // whoa nellie! Stop this
                return FALSE;
            }
        }

    // make a note in the user registry of which machines we are logged into so we
    // administer them again later
    StoreConnectedMachines();

    // of course we can close the frame
    return TRUE;
    }

//----------------------------------------------------------------
void CKeyRingDoc::OnUpdateNewCreateNew(CCmdUI* pCmdUI)
    {
    OnUpdateKeyCreateRequest(pCmdUI);
    }

//----------------------------------------------------------------
void CKeyRingDoc::OnNewCreateNew()
    {
    CService*   pService = (CService*)g_pTreeView->PGetSelectedItem();
    ASSERT( pService );
    ASSERT( pService->IsKindOf(RUNTIME_CLASS(CService)) ||
        pService->IsKindOf(RUNTIME_CLASS(CKey)));

    // if the selection is a key, get the key's parent, which should be a service
    if ( pService->IsKindOf(RUNTIME_CLASS(CKey)) )
        {
        pService = (CService*)pService->PGetParent();
        ASSERT( pService );
        ASSERT( pService->IsKindOf(RUNTIME_CLASS(CService)) );
        }

    //run the create key wizard. We start by declaring all the pieces of it
    CPropertySheet          propsheet(IDS_TITLE_CREATE_WIZ);
    CNKChooseCA             page_Choose_CA;
    CNKUserInfo             page_User_Info;
    CNKKeyInfo              page_Key_Info;
    CNKDistinguishedName    page_DN;
    CNKDistinguisedName2    page_DN2;
    CNKFileInfo             page_File_Info;

    // fill in the member variables.
    page_Choose_CA.m_pPropSheet = &propsheet;
    page_Choose_CA.m_pChooseCAPage = &page_Choose_CA;
    page_User_Info.m_pPropSheet = &propsheet;
    page_User_Info.m_pChooseCAPage = &page_Choose_CA;
    page_Key_Info.m_pPropSheet = &propsheet;
    page_Key_Info.m_pChooseCAPage = &page_Choose_CA;
    page_DN.m_pPropSheet = &propsheet;
    page_DN.m_pChooseCAPage = &page_Choose_CA;
    page_DN2.m_pPropSheet = &propsheet;
    page_DN2.m_pChooseCAPage = &page_Choose_CA;
    page_File_Info.m_pPropSheet = &propsheet;
    page_File_Info.m_pChooseCAPage = &page_Choose_CA;

    // clear the help button bits
    if ( propsheet.m_psh.dwFlags & PSH_HASHELP )
        propsheet.m_psh.dwFlags &= ~PSH_HASHELP;
    page_Choose_CA.m_psp.dwFlags &= ~(PSP_HASHELP);
    page_User_Info.m_psp.dwFlags &= ~(PSP_HASHELP);
    page_Key_Info.m_psp.dwFlags &= ~(PSP_HASHELP);
    page_DN.m_psp.dwFlags &= ~(PSP_HASHELP);
    page_DN2.m_psp.dwFlags &= ~(PSP_HASHELP);
    page_File_Info.m_psp.dwFlags &= ~(PSP_HASHELP);

    // add the pages to the property sheet
    propsheet.AddPage( &page_Choose_CA );
    propsheet.AddPage( &page_Key_Info );
    propsheet.AddPage( &page_DN );
    propsheet.AddPage( &page_DN2 );
    propsheet.AddPage( &page_User_Info );
    propsheet.AddPage( &page_File_Info );

    // set the wizard property
    propsheet.SetWizardMode();

    // run the property sheet
    int i = IDOK;
    i = IDCANCEL;
    i = propsheet.DoModal();
    if ( i != IDCANCEL )
        {
        // tell all the pages that it was successful
        page_Choose_CA.OnFinish();
        page_User_Info.OnFinish();
        page_Key_Info.OnFinish();
        page_DN.OnFinish();
        page_DN2.OnFinish();
        page_File_Info.OnFinish();

        // ok, the wizard succeeded, now run the grinder.
        CCreatingKeyDlg     grinder;

        // set the grinder up
        grinder.m_ppage_Choose_CA = &page_Choose_CA;
        grinder.m_ppage_User_Info = &page_User_Info;
        grinder.m_ppage_Key_Info = &page_Key_Info;
        grinder.m_ppage_DN = &page_DN;
        grinder.m_ppage_DN2 = &page_DN2;
        grinder.m_pService = pService;
        grinder.m_fGenerateKeyPair = TRUE;

        // let'er rip
        if ( grinder.DoModal() == IDOK )
            {
            ASSERT( grinder.m_pKey );
            // add the new key to the tree
            grinder.m_pKey->FAddToTree( pService );
            // make sure the new key has a caption
            grinder.m_pKey->UpdateCaption();
            // make it dirty too
            grinder.m_pKey->SetDirty(TRUE);

            // select the newly added key
            if ( g_pTreeView )
                ((CTreeCtrl*)g_pTreeView)->SelectItem(grinder.m_pKey->HGetTreeItem());

            // if the key is already complete, then bring up its properties dialog
            if ( grinder.m_pKey->m_pCertificate )
                grinder.m_pKey->OnProperties();
            }
        }
    }


// online key support utilities
//----------------------------------------------------------------
void CKeyRingDoc::DoKeyRenewal( CKey* pKey )
    {
    LPREQUEST_HEADER pHeader = (LPREQUEST_HEADER)pKey->m_pCertificateRequest;

    CPropertySheet          propsheet( IDS_TITLE_RENEW );
    CNKChooseCA             page_Choose_CA;
    CNKUserInfo             page_User_Info;

    page_Choose_CA.m_pPropSheet = &propsheet;
    page_Choose_CA.m_pChooseCAPage = &page_Choose_CA;
    page_User_Info.m_pPropSheet = &propsheet;
    page_User_Info.m_pChooseCAPage = &page_Choose_CA;

    // set the renewal flag on the user page
    page_User_Info.fRenewingKey = TRUE;

    // add the pages to the property sheet
    propsheet.AddPage( &page_Choose_CA );
    propsheet.AddPage( &page_User_Info );
    
    // set the wizard property
    propsheet.SetWizardMode();

    // get rid of the help button
    DWORD       NoHelpMask = 0xFFFFFFFF ^ PSH_HASHELP;
    propsheet.m_psh.dwFlags &= NoHelpMask;

    // run the property sheet
    int i = IDOK;
    i = IDCANCEL;
    i = propsheet.DoModal();
    if ( i != IDCANCEL )
        {
        // tell all the pages that it was successful
        page_Choose_CA.OnFinish();
        page_User_Info.OnFinish();
    
        // create the grinder and prepare it
        CCreatingKeyDlg     grinder;

        // set the grinder up
        grinder.m_ppage_Choose_CA = &page_Choose_CA;
        grinder.m_ppage_User_Info = &page_User_Info;
        grinder.m_ppage_Key_Info = NULL;
        grinder.m_ppage_DN = NULL;
        grinder.m_ppage_DN2 = NULL;
        grinder.m_pService = NULL;

        grinder.m_pKey = pKey;
        grinder.m_fRenewExistingKey = TRUE;

        // let'er rip
        if ( grinder.DoModal() )
            {
            // make it dirty
            grinder.m_pKey->SetDirty(TRUE);

            // it has been decided not to bring up the properties dialog in the event
            // a renewal request - the properties have already been set
//          if ( grinder.m_pKey->m_pCertificate )
//              grinder.m_pKey->OnProperties();
            }
        }
    }

//----------------------------------------------------------------
void CKeyRingDoc::GetOnlineKeyApproval( CKey* pKey )
    {
    // create the grinder and prepare it
    CCreatingKeyDlg     grinder;

    // set the grinder up
    grinder.m_ppage_Choose_CA = NULL;
    grinder.m_ppage_User_Info = NULL;
    grinder.m_ppage_Key_Info = NULL;
    grinder.m_ppage_DN = NULL;
    grinder.m_ppage_DN2 = NULL;
    grinder.m_pService = NULL;

    grinder.m_pKey = pKey;
    grinder.m_fResubmitKey = TRUE;

    // let'er rip
    if ( grinder.DoModal() )
        {
        // make it dirty
        grinder.m_pKey->SetDirty(TRUE);
        // if the key is already complete, then bring up its properties dialog
        if ( grinder.m_pKey->m_pCertificate )
            grinder.m_pKey->OnProperties();
        }
    }

//----------------------------------------------------------------
// invoke the help with a standard help ID
void CKeyRingDoc::OnHelptopics()
    {
    if ( g_pTreeView )
        g_pTreeView->WinHelp( 0x50000 );
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\krdoc.h ===
// KRDoc.h : interface of the CKeyRingDoc class
//
/////////////////////////////////////////////////////////////////////////////

#include "addons.h"

enum {
	HINT_None = 0,
	HINT_ChangeSelection
	};


class CKeyRingDoc : public CDocument
{
protected: // create from serialization only
	CKeyRingDoc();
	DECLARE_DYNCREATE(CKeyRingDoc)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CKeyRingDoc)
	public:
	virtual BOOL OnNewDocument();
	virtual void Serialize(CArchive& ar);
	virtual void OnCloseDocument();
	virtual BOOL CanCloseFrame(CFrameWnd* pFrame);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CKeyRingDoc();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

	BOOL Initialize();

	// test what is selected in the treeview
	// if the selcted item is not of the requested type (machine, key, etc...)
	// then it returns a NULL
	CTreeItem*	PGetSelectedItem();
	CMachine*	PGetSelectedMachine();
	CService*	PGetSelectedService();
	CKey*		PGetSelectedKey();

	// Access the dirty flag
	void SetDirty( BOOL fDirty ) {m_fDirty = fDirty;}
	BOOL FGetDirty() {return m_fDirty;}

	// key scrap stuff
	void	SetScrapKey( CKey* pKey );
	CKey*	PGetScrapKey( void )
		{ return m_pScrapKey; }
protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CKeyRingDoc)
	afx_msg void OnUpdateServerConnect(CCmdUI* pCmdUI);
	afx_msg void OnServerConnect();
	afx_msg void OnUpdateEditCopy(CCmdUI* pCmdUI);
	afx_msg void OnEditCopy();
	afx_msg void OnUpdateEditCut(CCmdUI* pCmdUI);
	afx_msg void OnEditCut();
	afx_msg void OnUpdateEditPaste(CCmdUI* pCmdUI);
	afx_msg void OnEditPaste();
	afx_msg void OnUpdateProperties(CCmdUI* pCmdUI);
	afx_msg void OnProperties();
	afx_msg void OnUpdateServerCommitNow(CCmdUI* pCmdUI);
	afx_msg void OnServerCommitNow();
	afx_msg void OnUpdateKeyCreateRequest(CCmdUI* pCmdUI);
	afx_msg void OnKeyCreateRequest();
	afx_msg void OnUpdateKeyInstallCertificate(CCmdUI* pCmdUI);
	afx_msg void OnKeyInstallCertificate();
	afx_msg void OnUpdateKeySaveRequest(CCmdUI* pCmdUI);
	afx_msg void OnKeySaveRequest();
	afx_msg void OnUpdateKeyExportBackup(CCmdUI* pCmdUI);
	afx_msg void OnKeyExportBackup();
	afx_msg void OnUpdateKeyImportBackup(CCmdUI* pCmdUI);
	afx_msg void OnKeyImportBackup();
	afx_msg void OnUpdateKeyImportKeyset(CCmdUI* pCmdUI);
	afx_msg void OnKeyImportKeyset();
	afx_msg void OnKeyDelete();
	afx_msg void OnUpdateKeyDelete(CCmdUI* pCmdUI);
	afx_msg void OnNewCreateNew();
	afx_msg void OnUpdateNewCreateNew(CCmdUI* pCmdUI);
	afx_msg void OnHelptopics();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()


	// manage connections to machines
	void ConnectToMachine( CString &sz );
	
	void StoreConnectedMachines( void );
	void RestoreConnectedMachines( void );

private:

	// manage the add-on services
	BOOL FInitAddOnServices();
	BOOL FLoadAddOnServicesOntoMachine( CMachine* pMachine );
	void DeleteAddOnServices();

	// online key support utilities
	void DoKeyRenewal( CKey* pKey );
	void GetOnlineKeyApproval( CKey* pKey );

	// commit
	void DoCommitNow();

	// the service array
	CTypedPtrArray<CObArray, CAddOnService*>	m_AddOnServiceArray;

	// a dirty flag
	BOOL	m_fDirty;

	// the scrap key
	CKey*	m_pScrapKey;
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\krview.h ===
// KRView.h : interface of the CKeyRingView class
//
/////////////////////////////////////////////////////////////////////////////

class CKeyRingView : public CTreeView
{
protected: // create from serialization only
	afx_msg void OnContextMenu(CWnd*, CPoint point);
	CKeyRingView();
	DECLARE_DYNCREATE(CKeyRingView)

// Attributes
public:
	CKeyRingDoc* GetDocument();
	CTreeItem* PGetSelectedItem();

	BOOL FCommitMachinesNow();

	void DestroyItems();
	void DisconnectMachine( CMachine* pMachine );



// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CKeyRingView)
	public:
	virtual void OnDraw(CDC* pDC);  // overridden to draw this view
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	virtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext = NULL);
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	protected:
	virtual BOOL OnPreparePrinting(CPrintInfo* pInfo);
	virtual void OnBeginPrinting(CDC* pDC, CPrintInfo* pInfo);
	virtual void OnEndPrinting(CDC* pDC, CPrintInfo* pInfo);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CKeyRingView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CKeyRingView)
	afx_msg void OnRButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnSelchanged(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnUpdateServerDisconnect(CCmdUI* pCmdUI);
	afx_msg void OnServerDisconnect();
	afx_msg void OnDblclk(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnChar(UINT nChar, UINT nRepCnt, UINT nFlags);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	CImageList	m_imageList;
};

#ifndef _DEBUG  // debug version in KRView.cpp
inline CKeyRingDoc* CKeyRingView::GetDocument()
   { return (CKeyRingDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\krview.cpp ===
// KRView.cpp : implementation of the CKeyRingView class
//

#include "stdafx.h"
#include "KeyRing.h"
#include "MainFrm.h"

#include "KeyObjs.h"
#include "machine.h"
#include "KRDoc.h"
#include "KeyDView.h"
#include "KRView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern CKeyDataView*	g_pDataView;

/////////////////////////////////////////////////////////////////////////////
// CKeyRingView

IMPLEMENT_DYNCREATE(CKeyRingView, CTreeView)

BEGIN_MESSAGE_MAP(CKeyRingView, CTreeView)
	//{{AFX_MSG_MAP(CKeyRingView)
	ON_WM_RBUTTONDOWN()
	ON_NOTIFY_REFLECT(TVN_SELCHANGED, OnSelchanged)
	ON_UPDATE_COMMAND_UI(ID_SERVER_DISCONNECT, OnUpdateServerDisconnect)
	ON_COMMAND(ID_SERVER_DISCONNECT, OnServerDisconnect)
	ON_NOTIFY_REFLECT(NM_DBLCLK, OnDblclk)
	ON_WM_CHAR()
	//}}AFX_MSG_MAP
	// Standard printing commands
	ON_COMMAND(ID_FILE_PRINT, CTreeView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_DIRECT, CTreeView::OnFilePrint)
	ON_COMMAND(ID_FILE_PRINT_PREVIEW, CTreeView::OnFilePrintPreview)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CKeyRingView construction/destruction

CKeyRingView::CKeyRingView()
{
	// TODO: add construction code here

}

CKeyRingView::~CKeyRingView()
	{
	}

BOOL CKeyRingView::PreCreateWindow(CREATESTRUCT& cs)
{
	cs.style |= (TVS_HASLINES | TVS_HASBUTTONS | TVS_LINESATROOT);
	return CTreeView::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CKeyRingView drawing

void CKeyRingView::OnDraw(CDC* pDC)
{
	CKeyRingDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);

	// TODO: add draw code for native data here
}

/////////////////////////////////////////////////////////////////////////////
// CKeyRingView printing

BOOL CKeyRingView::OnPreparePrinting(CPrintInfo* pInfo)
{
	// default preparation
	return DoPreparePrinting(pInfo);
}

void CKeyRingView::OnBeginPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
	// TODO: add extra initialization before printing
}

void CKeyRingView::OnEndPrinting(CDC* /*pDC*/, CPrintInfo* /*pInfo*/)
{
	// TODO: add cleanup after printing
}

/////////////////////////////////////////////////////////////////////////////
// CKeyRingView diagnostics

#ifdef _DEBUG
void CKeyRingView::AssertValid() const
{
	CTreeView::AssertValid();
}

void CKeyRingView::Dump(CDumpContext& dc) const
{
	CTreeView::Dump(dc);
}

CKeyRingDoc* CKeyRingView::GetDocument() // non-debug version is inline
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CKeyRingDoc)));
	return (CKeyRingDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CKeyRingView message handlers

//-----------------------------------------------------------------------
void CKeyRingView::DestroyItems() 
	{
	HTREEITEM hRoot;
	CTreeCtrl* pTree = (CTreeCtrl*)this;

	// make sure the items in the tree are deleted as well
	while ( hRoot = pTree->GetRootItem() )
		{
		CMachine* pMachine = (CMachine*)pTree->GetItemData( hRoot );
		ASSERT( pMachine->IsKindOf( RUNTIME_CLASS(CMachine) ) );
		DisconnectMachine( pMachine );
		delete pMachine;
		}
	}

//-----------------------------------------------------------------------
void CKeyRingView::DisconnectMachine( CMachine* pMachine ) 
	{
	// loop through the services and disconnect them all
	CService* pService;
	while( pService = (CService*)pMachine->GetFirstChild() )
		{
		ASSERT( pService->IsKindOf( RUNTIME_CLASS(CService) ) );
		pService->CloseConnection();
		pService->FRemoveFromTree();
		delete pService;
		}

	// now remove the machine itself
	pMachine->FRemoveFromTree();
	}

//-----------------------------------------------------------------------
BOOL CKeyRingView::FCommitMachinesNow() 
	{
	CTreeCtrl* pTree = (CTreeCtrl*)this;

	// the success flag
	BOOL fSuccess = TRUE;

	// make sure the items in the tree are deleted as well
	HTREEITEM hItem = pTree->GetRootItem();
	while ( hItem )
		{
		CInternalMachine* pMachine = (CInternalMachine*)pTree->GetItemData( hItem );
		ASSERT( pMachine->IsKindOf( RUNTIME_CLASS(CMachine) ) );
		fSuccess &= pMachine->FCommitNow();

		// get the next item
		hItem = pTree->GetNextSiblingItem( hItem );
		}

	// return whether or not it succeeded
	return fSuccess;
	}

//-----------------------------------------------------------------------
BOOL CKeyRingView::Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext) 
	{
	BOOL	f;

	// create the main object
	f = CTreeView::Create(lpszClassName, lpszWindowName, dwStyle, rect, pParentWnd, nID, pContext);

	// assuming that worked, create the image list and set it into the tree view control
	if ( f )
		{
		CTreeCtrl	*pTree = (CTreeCtrl*)this;;

		// create the image list
		f = m_imageList.Create( IDB_TREEIMAGES, 16, 3, 0x00FF00FF );

		// set the image list into the tree control
		pTree->SetImageList( &m_imageList, TVSIL_NORMAL );
		}
	
	// return the answer
	return f;
	}

//------------------------------------------------------------------------------
void CKeyRingView::OnContextMenu(CWnd*, CPoint point)
	{
	// lets see, what is that point in client coordinates.....
	CPoint	ptClient = point;
	ScreenToClient( &ptClient );

	// we need to start this by selecting the correct item that
	// is being clicked on. First, find the item
	CTreeCtrl*		pTree = (CTreeCtrl*)this;
	UINT			flagsHit;
	HTREEITEM		hHit = pTree->HitTest( ptClient, &flagsHit );

	// if nothing was hit, then don't bother with a context menu
	if ( !hHit ) return;

	// select the item that was hit
	pTree->SelectItem( hHit );

	// double check that we have the right selection
	// now get that item's CTreeItem
	CTreeItem* pItem = PGetSelectedItem();
	if ( !pItem ) return;

	// get on with the context menu...
	CMenu menu;
	VERIFY(menu.LoadMenu(IDR_KEYPROP));

	// determine which sub menu to display
	WORD	iSubMenu;
	if ( pItem->IsKindOf(RUNTIME_CLASS(CKey)) )
		iSubMenu = 0;		// key menu
	else if ( pItem->IsKindOf(RUNTIME_CLASS(CMachine)) )
		iSubMenu = 1;		// machine menu
	else if ( pItem->IsKindOf(RUNTIME_CLASS(CService)) )
		iSubMenu = 2;		// server menu
	else
		{
		ASSERT( FALSE );
		return;				// we can't handle it
		}

	CMenu* pPopup = menu.GetSubMenu(iSubMenu);
	ASSERT(pPopup != NULL);

	CWnd* pWndPopupOwner = this;
	while (pWndPopupOwner->GetStyle() & WS_CHILD)
		pWndPopupOwner = pWndPopupOwner->GetParent();

	pPopup->TrackPopupMenu(TPM_LEFTALIGN | TPM_RIGHTBUTTON, point.x, point.y,
		pWndPopupOwner);
	}

//-----------------------------------------------------------------------
BOOL CKeyRingView::PreTranslateMessage(MSG* pMsg) 
	{
	short a;
	if ( pMsg->message == WM_KEYDOWN )
		a = 0;

	// CG: This block was added by the Pop-up Menu component
		{
		// Shift+F10: show pop-up menu.
		if ((((pMsg->message == WM_KEYDOWN || pMsg->message == WM_SYSKEYDOWN) && // If we hit a key and
			(pMsg->wParam == VK_F10) && (GetKeyState(VK_SHIFT) & ~1)) != 0) ||	// it's Shift+F10 OR
			(pMsg->message == WM_CONTEXTMENU))									// Natural keyboard key
			{

			// get the rect of the selected item and base the position of the menu
			// off of that.
			CRect rect;
			CTreeCtrl*	pTree = (CTreeCtrl*)this;
			HTREEITEM	hSelItem = pTree->GetSelectedItem();

			// if no item is selected, bail
			if ( !hSelItem )
				return TRUE;

			// now get that rect...
			if ( !pTree->GetItemRect( hSelItem, &rect, TRUE ) )
				return TRUE;

			// finish prepping and call the menu
			ClientToScreen(rect);
			CPoint point = rect.BottomRight();
			point.Offset(-10, -10);
			OnContextMenu(NULL, point);

			return TRUE;
			}
		}

	return CTreeView::PreTranslateMessage(pMsg);
	}

//-----------------------------------------------------------------------
void CKeyRingView::OnRButtonDown(UINT nFlags, CPoint point) 
	{
	// let the sub class do its thing
	CTreeView::OnRButtonDown(nFlags, point);

	// convert the point to screen coordinates
	ClientToScreen( &point );

	// run the context menu
	OnContextMenu(NULL, point);
	}

//-----------------------------------------------------------------------
CTreeItem* CKeyRingView::PGetSelectedItem()
	{
	CTreeCtrl*		pTree = (CTreeCtrl*)this;
	HTREEITEM hHit = pTree->GetSelectedItem();
	if ( !hHit ) return NULL;
	// now get that item's CTreeItem
	return (CTreeItem*)pTree->GetItemData( hHit );
	}

//-----------------------------------------------------------------------
void CKeyRingView::OnSelchanged(NMHDR* pNMHDR, LRESULT* pResult) 
	{
	NM_TREEVIEW*	pNMTreeView = (NM_TREEVIEW*)pNMHDR;
	CKeyRingDoc* pDoc = GetDocument();
	
	// make sure the key data view updates
	pDoc->UpdateAllViews( this, HINT_ChangeSelection, NULL );

	*pResult = 0;
	}

//-----------------------------------------------------------------------
void CKeyRingView::OnUpdateServerDisconnect(CCmdUI* pCmdUI) 
	{
	CTreeItem*	pItem = PGetSelectedItem();
	if ( pItem )
		pCmdUI->Enable( pItem->IsKindOf(RUNTIME_CLASS(CRemoteMachine)) );
	else
		pCmdUI->Enable( FALSE );
	}

//-----------------------------------------------------------------------
void CKeyRingView::OnServerDisconnect() 
	{
	CRemoteMachine*	pMachine = (CRemoteMachine*)PGetSelectedItem();
	ASSERT( pMachine->IsKindOf(RUNTIME_CLASS(CRemoteMachine)) );

	// if the machine is dirty, try to commit it
	if ( pMachine->FGetDirty() )
		{
		// ask the user if they want to commit
		switch( AfxMessageBox(IDS_SERVER_COMMIT, MB_YESNOCANCEL|MB_ICONQUESTION) )
			{
			case IDYES:		// yes, they do want to commit
				pMachine->FCommitNow();
				break;
			case IDNO:		// no, they don't want to commit
				break;
			case IDCANCEL:	// whoa nellie! Stop this
				return;
			}
		}

	DisconnectMachine( pMachine );
	delete pMachine;
	}

//-----------------------------------------------------------------------
// A double click on a key should bring up the properties dialog
void CKeyRingView::OnDblclk(NMHDR* pNMHDR, LRESULT* pResult) 
	{
	CKey*	pKey = (CKey*)PGetSelectedItem();
	if ( pKey && pKey->IsKindOf(RUNTIME_CLASS(CKey)) )
		pKey->OnProperties();

	*pResult = 0;
	}

//-----------------------------------------------------------------------
// allow the user to tab to the data view
void CKeyRingView::OnChar(UINT nChar, UINT nRepCnt, UINT nFlags) 
	{
	if ( nChar == _T('	') )
		{
		// get the parental frame window
		CMainFrame* pFrame = (CMainFrame*)GetParentFrame();
		// give the data view the focus
		pFrame->SetActiveView( g_pDataView );
		}
	else
		CTreeView::OnChar(nChar, nRepCnt, nFlags);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\machine.cpp ===
// the machine objects
// this is internal to the keyring application

#include "stdafx.h"
#include "KeyObjs.h"
#include "machine.h"
#include "KRDoc.h"

#include "resource.h"

IMPLEMENT_DYNCREATE(CLocalMachine, CMachine);
IMPLEMENT_DYNCREATE(CRemoteMachine, CMachine);

// a global reference to this doc object
extern CKeyRingDoc*		g_pDocument;

//----------------------------------------------------------------
void CInternalMachine::SetDirty( BOOL fDirty )
	{
	// we are dirtying, tell the doc so the commit flag
	// can be activated
	if ( fDirty )
		{
		ASSERT( g_pDocument );
		g_pDocument->SetDirty( fDirty );
		}

	// set the dirty flag
	m_fDirty = fDirty;
	}

//----------------------------------------------------------------
 BOOL CInternalMachine::FCommitNow()
	{
	// if we are not diry, there is nothing to do
	if ( !m_fDirty ) return TRUE;

	// the success flag
	BOOL fSuccess = TRUE;

	// loop through the services and tell each to commit
	CService*	pService = (CService*)GetFirstChild();
	while( pService )
		{
		// tell the service to commit
		fSuccess &= pService->FCommitChangesNow();

		// get the next service
		pService = (CService*)GetNextChild( pService );
		}

	// set the dirty flag
	SetDirty( !fSuccess );

	// return whether or not it all worked
	return fSuccess;
	}


//----------------------------------------------------------------
BOOL CMachine::FLocal()
	{
	return TRUE;
	}

//----------------------------------------------------------------
void CMachine::GetMachineName( CString& sz )
	{
	sz = m_szNetMachineName;
	}

//----------------------------------------------------------------
void CLocalMachine::UpdateCaption( void )
	{
	CString szCaption;
	szCaption.LoadString(IDS_MACHINE_LOCAL);
	FSetCaption( szCaption );
	}

//----------------------------------------------------------------
CRemoteMachine::CRemoteMachine( CString sz )
	{
	m_szNetMachineName = sz;
	}

//----------------------------------------------------------------
void CRemoteMachine::UpdateCaption( void )
	{
	FSetCaption( m_szNetMachineName );
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\mainfrm.cpp ===
// MainFrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"
#include "KeyRing.h"

#include "MainFrm.h"

#include "keyobjs.h"
#include "machine.h"
#include "KeyDView.h"
#include "KRDoc.h"
#include "KRView.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CKeyRingView*	g_pTreeView;
CKeyDataView*	g_pDataView;


/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
	//{{AFX_MSG_MAP(CMainFrame)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
	// Global help commands
	ON_COMMAND(ID_HELP_FINDER, CFrameWnd::OnHelpFinder)
	ON_COMMAND(ID_HELP, CFrameWnd::OnHelp)
	ON_COMMAND(ID_CONTEXT_HELP, CFrameWnd::OnContextHelp)
	ON_COMMAND(ID_DEFAULT_HELP, CFrameWnd::OnHelpFinder)
END_MESSAGE_MAP()

static UINT indicators[] =
{
	ID_SEPARATOR,           // status line indicator
	ID_INDICATOR_CAPS,
	ID_INDICATOR_NUM,
	ID_INDICATOR_SCRL,
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

//--------------------------------------------------------------
CMainFrame::CMainFrame()
	{
	}

//--------------------------------------------------------------
CMainFrame::~CMainFrame()
	{
	}

//--------------------------------------------------------------
int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
	{
	if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
		return -1;
	
	if (!m_wndToolBar.Create(this) ||
		!m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
		{
		TRACE0("Failed to create toolbar\n");
		return -1;      // fail to create
		}

	if (!m_wndStatusBar.Create(this) ||
		!m_wndStatusBar.SetIndicators(indicators,
		  sizeof(indicators)/sizeof(UINT)))
		{
		TRACE0("Failed to create status bar\n");
		return -1;      // fail to create
		}

	// TODO: Remove this if you don't want tool tips or a resizeable toolbar
	m_wndToolBar.SetBarStyle(m_wndToolBar.GetBarStyle() |
		CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC);

	// TODO: Delete these three lines if you don't want the toolbar to
	//  be dockable
	m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
	EnableDocking(CBRS_ALIGN_ANY);
	DockControlBar(&m_wndToolBar);

	return 0;
	}

//--------------------------------------------------------------
BOOL CMainFrame::OnCreateClient( LPCREATESTRUCT /*lpcs*/,
	CCreateContext* pContext)
	{
	// create the static splitter window	
	if ( !m_wndSplitter.CreateStatic( this, 1, 2 ) )
		{
		TRACE0("Failed to CreateStaticSplitter\n");
		return FALSE;
		}

	// the initial size of the first pane should be a function of the width of the view
	// add the first splitter pane - The machine tree view
	if (!m_wndSplitter.CreateView(0, 0,
		pContext->m_pNewViewClass, CSize(260, 50), pContext))
		{
		TRACE0("Failed to create machine tree pane\n");
		return FALSE;
		}

	// add the second splitter pane - the key list view
	if (!m_wndSplitter.CreateView(0, 1,
		RUNTIME_CLASS(CKeyDataView), CSize(0, 0), pContext))
		{
		TRACE0("Failed to create key data view pane\n");
		return FALSE;
		}

	// activate the machine tree view
	SetActiveView((CView*)m_wndSplitter.GetPane(0,0));
	g_pTreeView = (CKeyRingView*)m_wndSplitter.GetPane(0,0);
	g_pDataView = (CKeyDataView*)m_wndSplitter.GetPane(0,1);
	
	// return success
	return TRUE;
	}

//--------------------------------------------------------------
BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
	{
	// set the initial size of the application window
	// it is sized to fit the data form view pane
	cs.cx = 566;
	cs.cy = 530;

	return CFrameWnd::PreCreateWindow(cs);
	}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
//--------------------------------------------------------------
void CMainFrame::AssertValid() const
	{
	CFrameWnd::AssertValid();
	}

//--------------------------------------------------------------
void CMainFrame::Dump(CDumpContext& dc) const
	{
	CFrameWnd::Dump(dc);
	}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers
//--------------------------------------------------------------
// we just want the title of the app in the title bar
void CMainFrame::OnUpdateFrameTitle(BOOL bAddToTitle)
	{
	CFrameWnd::OnUpdateFrameTitle(FALSE);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\machine.h ===
// machine.h

// the internal machine objects
class CInternalMachine : public CMachine
	{
	public:
		// commit the services on the machine
		BOOL FCommitNow( void );

		// access to the dirty flag
		void SetDirty( BOOL fDirty );
	private:
		// need to be committed?
		BOOL			m_fDirty;

	};


// the local machine object
class CLocalMachine : public CInternalMachine
	{
	public:
		void UpdateCaption( void );
		BOOL FLocal() { return TRUE; }

	protected:
	// DO declare DYNCREATE
	DECLARE_DYNCREATE(CLocalMachine);
	};


// the remove machine class
class CRemoteMachine : public CInternalMachine
	{
	public:
		CRemoteMachine() {;}
		CRemoteMachine( CString sz );
		void UpdateCaption( void );
		BOOL FLocal() { return FALSE; }

	protected:
	// DO declare DYNCREATE
	DECLARE_DYNCREATE(CRemoteMachine);
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\mainfrm.h ===
// MainFrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

class CMainFrame : public CFrameWnd
{
protected: // create from serialization only
	CMainFrame();
	DECLARE_DYNCREATE(CMainFrame)

// Attributes
protected:
	CSplitterWnd m_wndSplitter;
public:

// Operations
public:
	virtual void OnUpdateFrameTitle(BOOL bAddToTitle);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	public:
	virtual BOOL OnCreateClient(LPCREATESTRUCT lpcs, CCreateContext* pContext);
	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // control bar embedded members
	CStatusBar  m_wndStatusBar;
	CToolBar    m_wndToolBar;

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\nkchseca.h ===
// NKChseCA.h : header file
//
// forward declarations
class CNKChooseCA;

/////////////////////////////////////////////////////////////////////////////
// a common object to go above the various wizard pages
class CNKPages : public CPropertyPage
	{
	// Construction
	public:
		CNKPages( UINT nIDCaption ); 

		// called when the finish button was selected
		// actually, called afterwards
		virtual void OnFinish();

		// member variables
		CPropertySheet*		m_pPropSheet;
		CNKChooseCA*		m_pChooseCAPage;

	// protected stuff
	protected:
		BOOL FGetStoredString( CString &sz, LPCSTR szValueName );
		void SetStoredString( CString &sz, LPCSTR szValueName );
	};


/////////////////////////////////////////////////////////////////////////////
// CNKChooseCA dialog

class CNKChooseCA : public CNKPages
{
// Construction
public:
	CNKChooseCA(CWnd* pParent = NULL);   // standard constructor
	virtual void OnFinish();
	virtual BOOL OnInitDialog();           // override virtual oninitdialog
	virtual BOOL OnSetActive();
	virtual BOOL OnKillActive();

	DWORD GetSelectedCA( CString &szCA );


// Dialog Data
	//{{AFX_DATA(CNKChooseCA)
	enum { IDD = IDD_NK_CHOOSE_CA };
	CComboBox	m_nkca_ccombo_online;
	CEdit	m_nkca_cedit_file;
	CButton	m_nkca_btn_browse;
	CButton	m_nkca_btn_properties;
	CString	m_nkca_sz_file;
	int		m_nkca_radio;
	CString	m_nkca_sz_online;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNKChooseCA)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CNKChooseCA)
	afx_msg void OnNkCaOnlineRadio();
	afx_msg void OnNkCaFileRadio();
	afx_msg void OnNkCaBrowse();
	afx_msg void OnBkCaProperties();
	afx_msg void OnSelchangeNkCaOnline();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	WORD InitOnlineList();

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\nkdn.cpp ===
// NKDNcpp : implementation file
//

#include "stdafx.h"
#include "keyring.h"
#include "NKChseCA.h"
#include "NKDN.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNKDistinguishedName dialog


CNKDistinguishedName::CNKDistinguishedName(CWnd* pParent /*=NULL*/)
	: CNKPages(CNKDistinguishedName::IDD)
{
	//{{AFX_DATA_INIT(CNKDistinguishedName)
	m_nkdn_sz_CN = _T("");
	m_nkdn_sz_O = _T("");
	m_nkdn_sz_OU = _T("");
	//}}AFX_DATA_INIT
}


void CNKDistinguishedName::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNKDistinguishedName)
	DDX_Control(pDX, IDC_NEWKEY_COMMONNAME, m_control_CN);
	DDX_Control(pDX, IDC_NEWKEY_ORGUNIT, m_control_OU);
	DDX_Control(pDX, IDC_NEWKEY_ORG, m_control_O);
	DDX_Text(pDX, IDC_NEWKEY_COMMONNAME, m_nkdn_sz_CN);
	DDV_MaxChars(pDX, m_nkdn_sz_CN, 64);
	DDX_Text(pDX, IDC_NEWKEY_ORG, m_nkdn_sz_O);
	DDV_MaxChars(pDX, m_nkdn_sz_O, 64);
	DDX_Text(pDX, IDC_NEWKEY_ORGUNIT, m_nkdn_sz_OU);
	DDV_MaxChars(pDX, m_nkdn_sz_OU, 64);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CNKDistinguishedName, CDialog)
	//{{AFX_MSG_MAP(CNKDistinguishedName)
	ON_EN_CHANGE(IDC_NEWKEY_COMMONNAME, OnChangeNewkeyCommonname)
	ON_EN_CHANGE(IDC_NEWKEY_ORG, OnChangeNewkeyOrg)
	ON_EN_CHANGE(IDC_NEWKEY_ORGUNIT, OnChangeNewkeyOrgunit)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

#define	SZ_DN_CN	"DN_COMMON_NAME"
#define	SZ_DN_O		"DN_ORGANIZATION"
#define	SZ_DN_OU	"DN_ORG_UNIT"

//----------------------------------------------------------------
void CNKDistinguishedName::OnFinish()
	{
	// store the user entries
	SetStoredString( m_nkdn_sz_CN, SZ_DN_CN );
	SetStoredString( m_nkdn_sz_O, SZ_DN_O );
	SetStoredString( m_nkdn_sz_OU, SZ_DN_OU );
	}

//----------------------------------------------------------------
BOOL CNKDistinguishedName::OnInitDialog( )
	{
	// if the entries from last time are available, use them
	try
		{
		FGetStoredString( m_nkdn_sz_CN, SZ_DN_CN );
		FGetStoredString( m_nkdn_sz_O, SZ_DN_O );
		FGetStoredString( m_nkdn_sz_OU, SZ_DN_OU );
		}
	catch( CException e )
		{
		}

	// call superclass
	CPropertyPage::OnInitDialog();

	// return 0 to say we set the default item
    // return 1 to just select the default default item
    return 1;
	}

//----------------------------------------------------------------
BOOL CNKDistinguishedName::OnSetActive()
	{
	ActivateButtons();
	return CPropertyPage::OnSetActive();
	}

//----------------------------------------------------------------
void CNKDistinguishedName::ActivateButtons()
	{
	DWORD	flags = PSWIZB_BACK;
	BOOL	fCanGoOn = TRUE;

	UpdateData(TRUE);

	//now make sure there is something in each of the required fields
	fCanGoOn &= !m_nkdn_sz_CN.IsEmpty();
	fCanGoOn &= !m_nkdn_sz_O.IsEmpty();
	fCanGoOn &= !m_nkdn_sz_OU.IsEmpty();

	// if we can go on, hilite the button
	if ( fCanGoOn )
		{
		flags |= PSWIZB_NEXT;
		}

	// update the property sheet buttons
	m_pPropSheet->SetWizardButtons( flags );
	}

/////////////////////////////////////////////////////////////////////////////
// CNKDistinguishedName message handlers

//----------------------------------------------------------------
void CNKDistinguishedName::OnChangeNewkeyCommonname() 
	{
	ActivateButtons();
	}

//----------------------------------------------------------------
void CNKDistinguishedName::OnChangeNewkeyOrg() 
	{
	ActivateButtons();
	}

//----------------------------------------------------------------
void CNKDistinguishedName::OnChangeNewkeyOrgunit() 
	{
	ActivateButtons();
	}



/////////////////////////////////////////////////////////////////////////////
//----------------------------------------------------------------
CDNEdit::CDNEdit()
	{
	szExclude.LoadString( IDS_ILLEGAL_DN_CHARS );
    szTotallyExclude.LoadString( IDS_TOTALLY_ILLEGAL_CHARS );
	}

//----------------------------------------------------------------
BOOL CDNEdit::OnWndMsg(UINT message, WPARAM wParam, LPARAM lParam, LRESULT* pResult)
	{
	// if it is a character
	if ( message == WM_CHAR )
		{
		TCHAR chCharCode = (TCHAR)wParam;

        // first test the totally bad characters
		if ( strchr(szTotallyExclude, chCharCode) )
            {
            MessageBeep(0);
            return 1;
            }

        // now test the potentially bad characters
		if ( strchr(szExclude, chCharCode) )
			switch( AfxMessageBox(IDS_BADCHARMSG, MB_YESNO|MB_ICONQUESTION) )
			{
			case IDYES:		
				break;
			case IDNO:		
				// reject the character
				MessageBeep(0);
				return 1;
			}
		}

	// return the default answer
	return CEdit::OnWndMsg( message, wParam, lParam, pResult);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\mismtchd.h ===
#if !defined(AFX_MISMTCHD_H__0919577F_39E4_11D1_8BA2_00C04FB6678B__INCLUDED_)
#define AFX_MISMTCHD_H__0919577F_39E4_11D1_8BA2_00C04FB6678B__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// mismtchd.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CMismatchedCertDlg dialog

class CMismatchedCertDlg : public CDialog
{
// Construction
public:
	CMismatchedCertDlg( PCERT_NAME_BLOB pRequestNameBlob,
                        PCERT_NAME_BLOB pCertNameBlob,
                        CWnd* pParent = NULL);
    virtual BOOL OnInitDialog();

// Dialog Data
	//{{AFX_DATA(CMismatchedCertDlg)
	enum { IDD = IDD_CERT_MISMATCH };
	CListCtrl	m_clist_request;
	CListCtrl	m_clist_certificate;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMismatchedCertDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CMismatchedCertDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    void InitCrackerList( CListCtrl* pList);
    void FillInCrackerList( PCERT_NAME_BLOB pNameBlob, CListCtrl* pList);
    void AddOneCrackerItem( CString& szItem, CListCtrl* pList);

    // the info to crack
    PCERT_NAME_BLOB     m_pRequestNameBlob;
    PCERT_NAME_BLOB     m_pCertNameBlob;
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MISMTCHD_H__0919577F_39E4_11D1_8BA2_00C04FB6678B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\mismtchd.cpp ===
// mismtchd.cpp : implementation file
//

#include "stdafx.h"
#include "keyring.h"

#define SECURITY_WIN32
extern "C"
    {
    #include <wincrypt.h>
    }

#include "mismtchd.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


enum {
    COL_IDENTIFIER = 0,
    COL_CONTENT
    };


/////////////////////////////////////////////////////////////////////////////
// CMismatchedCertDlg dialog

CMismatchedCertDlg::CMismatchedCertDlg(
                        PCERT_NAME_BLOB pRequestNameBlob,
                        PCERT_NAME_BLOB pCertNameBlob,
                        CWnd* pParent)
	: CDialog(CMismatchedCertDlg::IDD, pParent),
    m_pRequestNameBlob( pRequestNameBlob ),
    m_pCertNameBlob( pCertNameBlob )
    {
    //{{AFX_DATA_INIT(CMismatchedCertDlg)
    //}}AFX_DATA_INIT
    }

void CMismatchedCertDlg::DoDataExchange(CDataExchange* pDX)
    {
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CMismatchedCertDlg)
    DDX_Control(pDX, IDC_LIST_REQUEST, m_clist_request);
    DDX_Control(pDX, IDC_LIST_CERTIFICATE, m_clist_certificate);
    //}}AFX_DATA_MAP
    }


BEGIN_MESSAGE_MAP(CMismatchedCertDlg, CDialog)
    //{{AFX_MSG_MAP(CMismatchedCertDlg)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMismatchedCertDlg message handlers


//----------------------------------------------------------------
// override virtual oninitdialog
BOOL CMismatchedCertDlg::OnInitDialog( )
    {
    // call the base oninit
    CDialog::OnInitDialog();

    // initialize the lists
    InitCrackerList( &m_clist_request );
    InitCrackerList( &m_clist_certificate );

    // fill in the request list
    FillInCrackerList( m_pRequestNameBlob, &m_clist_request );

    // fill in the certificate list
    FillInCrackerList( m_pCertNameBlob, &m_clist_certificate );

    // return 0 to say we set the default item
    // return 1 to just select the default default item
    return 1;
    }

//----------------------------------------------------------------
// fill in one of the info cracker lists
void CMismatchedCertDlg::FillInCrackerList( PCERT_NAME_BLOB pNameBlob, CListCtrl* pList)
    {
    DWORD       cch;
    CString     szCrackedInfo;
    int         iSemicolon;

    // first, use CAPI to get the required size of the string to hold the cracked info
    cch = CertNameToStr( X509_ASN_ENCODING,      // type of encoding in the blob
                            pNameBlob,              // the name blob
                            CERT_X500_NAME_STR|
                                CERT_NAME_STR_SEMICOLON_FLAG|
                                CERT_NAME_STR_NO_QUOTING_FLAG,     // tell it we want the "OU" type labels
                            NULL,                   // NULL because we want the size
                            0) + 1;                 // add a character for the null term

    // if we didn't get anything, fail
    if ( cch == 0 ) return;

    // do it again, with the right size stuff
    cch = CertNameToStr( X509_ASN_ENCODING,      // type of encoding in the blob
                            pNameBlob,              // the name blob
                            CERT_X500_NAME_STR|
                                CERT_NAME_STR_SEMICOLON_FLAG|
                                CERT_NAME_STR_NO_QUOTING_FLAG,     // tell it we want the "OU" type labels
                            szCrackedInfo.GetBuffer(cch*2), // buffer - account for DBCS
                            cch);                   // size from above
    // let go of the name buffer
    szCrackedInfo.ReleaseBuffer();

    // if we didn't get anything, fail
    if ( cch == 0 ) return;

    // parse the name string we got back and use it to fill in the list

    // loop the items in the list
    do {
        // get the location of the last ";"
        iSemicolon = szCrackedInfo.ReverseFind( _T(';') );

        // if there is a semicolon, then add the string to the left of it
        if ( iSemicolon >= 0 )
            {
            AddOneCrackerItem( szCrackedInfo.Right(szCrackedInfo.GetLength() - (iSemicolon+1)), pList);
            // remove it from the list
            szCrackedInfo = szCrackedInfo.Left( iSemicolon );
            }
        // if there is no semicolon, then add the string
        else
            {
            AddOneCrackerItem( szCrackedInfo, pList);
            }

        // loop back
        }while ( iSemicolon >= 0);
    }

//----------------------------------------------------------------
void CMismatchedCertDlg::AddOneCrackerItem( CString& szItem, CListCtrl* pList)
    {
    // remove any fluff spaces
    szItem.TrimLeft();
    szItem.TrimRight();

    // get the position of the '=' character
    int iEqual = szItem.Find( _T('=') );

    // if it isn't there, fail
    if ( iEqual < 0 ) return;

    // get the identifier and content strings
    CString szIdent = szItem.Left( iEqual );
    CString szContent = szItem.Right( szItem.GetLength() - (iEqual+1) );

    // add the strings to the list
	DWORD i = pList->InsertItem( 0, szIdent );
    pList->SetItemText( i, COL_CONTENT, szContent );
    }

//----------------------------------------------------------------
void CMismatchedCertDlg::InitCrackerList( CListCtrl* pList)
    {
    CString sz;
    // prepare the list for use
	sz.LoadString( IDS_APP_EXTENSION );
	DWORD i = pList->InsertColumn( COL_IDENTIFIER, sz, LVCFMT_LEFT, 45 );

	sz.LoadString( IDS_APP_EXE_PATH );
	i = pList->InsertColumn( COL_CONTENT, sz, LVCFMT_LEFT, 176 );
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\nkchseca.cpp ===
// NKChseCA.cpp : implementation file
//

#include "stdafx.h"
#include "keyring.h"
#include "NKChseCA.h"

#include "certcli.h"
#include "OnlnAuth.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CNKPages dialog
CNKPages::CNKPages( UINT nIDCaption )
	: CPropertyPage( nIDCaption )
	{
	}

// resource strings
#define	SZ_PARAMETERS	"Software\\Microsoft\\Keyring\\Parameters"

//---------------------------------------------------------------------------
void CNKPages::OnFinish()
	{}

//---------------------------------------------------------------------------
// returns TRUE if it was able get the value
BOOL CNKPages::FGetStoredString( CString &sz, LPCSTR szValueName )
	{
	// start by opening the key
	DWORD		err;
	HKEY		hKey;
	err = RegOpenKeyEx(
			HKEY_CURRENT_USER,	// handle of open key 
			SZ_PARAMETERS,		// address of name of subkey to open 
			0,					// reserved 
			KEY_READ,			// security access mask 
			&hKey 				// address of handle of open key 
		   );
	ASSERT(err == ERROR_SUCCESS);
	if ( err != ERROR_SUCCESS )
		return FALSE;

	// prepare to get the value
	LPTSTR		pszValue;
	pszValue = sz.GetBuffer( MAX_PATH+1 );

	// get the value of the item in the key
	DWORD		type;
	DWORD		cbData = MAX_PATH;
	err = RegQueryValueEx(
		hKey,				// handle of key to query 
		szValueName,		// name of value to query 
		NULL,				// reserved 
		&type,				// address of buffer for value type 
		(PUCHAR)pszValue,	// address of data buffer 
		&cbData			 	// address of data buffer size 
		);	

	// release the string so we can use it
	sz.ReleaseBuffer();

	// all done, close the key before leaving
	if ( hKey )
		RegCloseKey( hKey );

	// check to see if we got the value
	if ( err != ERROR_SUCCESS )
		return FALSE;

	// return any errors
	return TRUE;
	}

//---------------------------------------------------------------------------
void CNKPages::SetStoredString( CString &sz, LPCSTR szValueName )
	{
	// start by opening the key
	DWORD		err;
	HKEY		hKey;
	err = RegOpenKeyEx(
			HKEY_CURRENT_USER,	// handle of open key 
			SZ_PARAMETERS,		// address of name of subkey to open 
			0,					// reserved 
			KEY_ALL_ACCESS,			// security access mask 
			&hKey 				// address of handle of open key 
		   );
	ASSERT(err == ERROR_SUCCESS);
	if ( err != ERROR_SUCCESS )
		return;
	
	// set the value of the item in the key
	err = RegSetValueEx
		(
		hKey,					// handle of key to query 
		szValueName,			// name of value to query 
		NULL,					// reserved 
		REG_SZ,					// address of buffer for value type 
		(PUCHAR)(LPCTSTR)sz,	// address of data buffer 
		sz.GetLength() + 1		// data buffer size 
		);	

	// all done, close the key before leaving
	if ( hKey )
		RegCloseKey( hKey );
	}


/////////////////////////////////////////////////////////////////////////////
// CNKChooseCA dialog

CNKChooseCA::CNKChooseCA(CWnd* pParent /*=NULL*/)
	: CNKPages(CNKChooseCA::IDD)
{
	//{{AFX_DATA_INIT(CNKChooseCA)
	m_nkca_sz_file = _T("");
	m_nkca_radio = -1;
	m_nkca_sz_online = _T("");
	//}}AFX_DATA_INIT
}


void CNKChooseCA::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNKChooseCA)
	DDX_Control(pDX, IDC_NK_CA_ONLINE, m_nkca_ccombo_online);
	DDX_Control(pDX, IDC_NK_CA_FILE, m_nkca_cedit_file);
	DDX_Control(pDX, IDC_NK_CA_BROWSE, m_nkca_btn_browse);
	DDX_Control(pDX, IDC_BK_CA_PROPERTIES, m_nkca_btn_properties);
	DDX_Text(pDX, IDC_NK_CA_FILE, m_nkca_sz_file);
	DDX_Radio(pDX, IDC_NK_CA_FILE_RADIO, m_nkca_radio);
	DDX_CBString(pDX, IDC_NK_CA_ONLINE, m_nkca_sz_online);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CNKChooseCA, CDialog)
	//{{AFX_MSG_MAP(CNKChooseCA)
	ON_BN_CLICKED(IDC_NK_CA_ONLINE_RADIO, OnNkCaOnlineRadio)
	ON_BN_CLICKED(IDC_NK_CA_FILE_RADIO, OnNkCaFileRadio)
	ON_BN_CLICKED(IDC_NK_CA_BROWSE, OnNkCaBrowse)
	ON_BN_CLICKED(IDC_BK_CA_PROPERTIES, OnBkCaProperties)
	ON_CBN_SELCHANGE(IDC_NK_CA_ONLINE, OnSelchangeNkCaOnline)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

#define	SZ_TARGET_CA	"TARGET_CA"
#define	SZ_FILE_BASED	"FILE_BASED"

//---------------------------------------------------------------------------
void CNKChooseCA::OnFinish()
	{
	try
		{
		CString szCA;

		// if we are targeting a manual/remote ca, loat the "FileBased" string
		if ( m_nkca_radio == 0 )
			szCA = SZ_FILE_BASED;
		// othewise, it should be the name of the chosen online ca
		else
			szCA = m_nkca_sz_online;

		// now store that value away
		SetStoredString( szCA, SZ_TARGET_CA );
		}
	catch (CException e)
		{
		}
	}

//----------------------------------------------------------------
BOOL CNKChooseCA::OnInitDialog( )
	{
	// load the default file name
	m_nkca_sz_file.LoadString( IDS_DEFAULT_REQUEST_FILE );

	// default to targeting the request towards a file
	m_nkca_radio = 0;

    // call the base oninit
    CPropertyPage::OnInitDialog();

	// Initialze the list of available online authorties. Record how many there were
	DWORD numCA = InitOnlineList();

	// now get the default authority used from last time
	CString szLastCA;
	BOOL fGotLastCA = FGetStoredString( szLastCA, SZ_TARGET_CA );

	// if there were no online authorities, disable that option
	if ( numCA == 0 )
		GetDlgItem(IDC_NK_CA_ONLINE_RADIO)->EnableWindow(FALSE);

	// initialze to the appropriate item
	if ( (numCA == 0) || (szLastCA == SZ_FILE_BASED) )
		{
		// by default, select the first item in the list
		m_nkca_ccombo_online.SetCurSel(0);
		// set up windows
		m_nkca_ccombo_online.EnableWindow( FALSE );
		m_nkca_btn_properties.EnableWindow( FALSE );
		// finish getting ready by calling OnNkCaFileRadio
		OnNkCaFileRadio();
		}
	else
		// there are items in the online dropdown
		{
		// by default, select the first item in the list
		m_nkca_ccombo_online.SetCurSel(0);

		// if we retrieved a default from last time, select that
		if ( fGotLastCA )
			m_nkca_ccombo_online.SelectString( -1, szLastCA );

		// since there are online authorities available, default to them
		m_nkca_radio = 1;
		UpdateData( FALSE );
		// finish getting ready by calling OnNkCaOnlineRadio
		OnNkCaOnlineRadio();
		}

	// return 0 to say we set the default item
    // return 1 to just select the default default item
    return 1;
	}

//----------------------------------------------------------------
// returns the number of items in the dropdown
DWORD CNKChooseCA::GetSelectedCA( CString &szCA)
    {
    ASSERT( m_nkca_radio == 1 );

    // this becomes easy
    szCA = m_nkca_sz_online;

    return ERROR_SUCCESS;

    /*
    // now load up the registry key
    CString		szRegKeyName;
    szRegKeyName.LoadString( IDS_CA_LOCATION );

    // and open the key
    DWORD		err;
    HKEY		hKey;
    err = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,	// handle of open key 
            szRegKeyName,		// address of name of subkey to open 
            0,					// reserved 
            KEY_READ,			// security access mask 
            &hKey 				// address of handle of open key 
            );
    ASSERT(err == ERROR_SUCCESS);
    if ( err != ERROR_SUCCESS )
        {
        szGUID.Empty();
        return err;
        }

    // prepare to get the name
    LPTSTR		pGUID;
    pGUID = szGUID.GetBuffer( MAX_PATH+1 );

    // get the value of the item in the key
    DWORD		type;
    DWORD		cbData = MAX_PATH;
    err = RegQueryValueEx(
        hKey,               // handle of key to query 
        m_nkca_sz_online,   // name of value to query 
        NULL,               // reserved 
        &type,              // address of buffer for value type 
        (PUCHAR)pGUID,      // address of data buffer 
        &cbData             // address of data buffer size 
        );	

    // release the string so we can use it
    szGUID.ReleaseBuffer();

    // all done, close the key before leaving
    if ( hKey )
        RegCloseKey( hKey );

    ASSERT(err == ERROR_SUCCESS);
    if ( err != ERROR_SUCCESS )
        szGUID.Empty();

    // return any errors
    return err;
*/
    }

//----------------------------------------------------------------
// returns the number of items in the dropdown
WORD CNKChooseCA::InitOnlineList()
	{
	DWORD		err;
	CString		szRegKeyName;
	HKEY		hKey;
	DWORD		cbCAName = MAX_PATH+1;

	CString		szCAName;
	LPTSTR		pCAName;
    FILETIME    filetime;

	WORD		i = 0;

	CWaitCursor		waitcursor;

	// load the registry key name
	szRegKeyName.LoadString( IDS_CA_LOCATION );

	// open the registry key, if it exists
	err = RegOpenKeyEx(
			HKEY_LOCAL_MACHINE,	// handle of open key 
			szRegKeyName,		// address of name of subkey to open 
			0,					// reserved 
			KEY_READ,			// security access mask 
			&hKey 				// address of handle of open key 
		   );

	// if we did not open the key for any reason (say... it doesn't exist)
	// then leave right away
	if ( err != ERROR_SUCCESS )
		return FALSE;

	// set up the buffers
	pCAName = szCAName.GetBuffer( MAX_PATH+1 );

    // each onling authority sets up a key under "Certificate Authorities"
    // the title of that key is the title that shows up in the list. The
    // key itself contains the CLSIDs of the necessary class factories to
    // instantiate the com objects that we need to do all this stuff

	// we opened the key. Now we enumerate the values and reconnect the machines
	while (  RegEnumKeyEx(hKey, i, pCAName,
				&cbCAName, NULL, NULL,
				0, &filetime) == ERROR_SUCCESS )
		{
		// add the name of the certificate authority to the list
		m_nkca_ccombo_online.AddString( pCAName );

		// increment the number found counter
		i++;
		cbCAName = MAX_PATH+1;
		}

	// release the name buffers
	szCAName.ReleaseBuffer();

	// all done, close the key before leaving
	RegCloseKey( hKey );

	// return how many we found
	return i;
	}


//----------------------------------------------------------------
BOOL CNKChooseCA::OnSetActive()
	{
    CString sz;
    sz.LoadString(IDS_TITLE_CREATE_WIZ);
    m_pPropSheet->SetTitle( sz );

	m_pPropSheet->SetWizardButtons( PSWIZB_NEXT );
	return CPropertyPage::OnSetActive();
	}

/////////////////////////////////////////////////////////////////////////////
// CNKChooseCA message handlers

//----------------------------------------------------------------
BOOL CNKChooseCA::OnKillActive()
	{
	UpdateData( TRUE );

    // if the target is an online certificate authority - we don't have to bother
    // with checking the file.
    if ( m_nkca_radio == 1 )
        return TRUE;

	// get the attributes of the specified file
	DWORD	dwAttrib = GetFileAttributes( m_nkca_sz_file );

	// we actually want the function to fail - then the file doesn't exist
	if ( dwAttrib == 0xFFFFFFFF )
		return TRUE;

	// if the name is a directory, or system file, don't allow it
	if ( (dwAttrib & FILE_ATTRIBUTE_DIRECTORY) || (dwAttrib & FILE_ATTRIBUTE_SYSTEM) )
		{
		AfxMessageBox( IDS_BAD_FILE_NAME );
		// set the focus back to the file name
		m_nkca_cedit_file.SetFocus();
		return FALSE;
		}

	// ah. Well the file already exits. Warn the user
	CString	szWarning;
	AfxFormatString1( szWarning, IDS_FILE_EXISTS, m_nkca_sz_file ); 
	if ( AfxMessageBox( szWarning, MB_YESNO ) == IDYES )
		return TRUE;

	// set the focus back to the file name
	m_nkca_cedit_file.SetFocus();
	return FALSE;
	}

//----------------------------------------------------------------
void CNKChooseCA::OnNkCaFileRadio() 
	{
	// enable the file related items
	m_nkca_cedit_file.EnableWindow( TRUE );
	m_nkca_btn_browse.EnableWindow( TRUE );

	// disable the online related items
	m_nkca_ccombo_online.EnableWindow( FALSE );
	m_nkca_btn_properties.EnableWindow( FALSE );
	}

//----------------------------------------------------------------
void CNKChooseCA::OnNkCaOnlineRadio() 
	{
	// disable the file related items
	m_nkca_cedit_file.EnableWindow( FALSE );
	m_nkca_btn_browse.EnableWindow( FALSE );

	// enable the online related items
	m_nkca_ccombo_online.EnableWindow( TRUE );
	m_nkca_btn_properties.EnableWindow( TRUE );
	}

//----------------------------------------------------------------
void CNKChooseCA::OnNkCaBrowse() 
	{
	UpdateData( TRUE );
    CFileDialog             cfdlg(FALSE, _T("txt"), m_nkca_sz_file);
    CString                 szFilter;
    WORD                    i = 0;
    LPSTR                   lpszBuffer;
    
    // prepare the filter string
    szFilter.LoadString( IDS_CERTIFICATE_FILTER );
    
    // replace the "!" characters with nulls
    lpszBuffer = szFilter.GetBuffer(MAX_PATH+1);
    while( lpszBuffer[i] )
            {
            if ( lpszBuffer[i] == _T('!') )
                    lpszBuffer[i] = _T('\0');                       // yes, set \0 on purpose
            i++;
            }

    // prep the dialog
    cfdlg.m_ofn.lpstrFilter = lpszBuffer;
    // we prompt for the overwrite when the "Next" button is pushed
    cfdlg.m_ofn.Flags &= ~OFN_OVERWRITEPROMPT;

    // run the dialog
    if ( cfdlg.DoModal() == IDOK )
            {
            // get the path for the file from the dialog
            m_nkca_sz_file = cfdlg.GetPathName();
            UpdateData( FALSE );
            }

    // release the buffer in the filter string
    szFilter.ReleaseBuffer(60);
	}

//----------------------------------------------------------------
void CNKChooseCA::OnBkCaProperties() 
	{
    HRESULT hErr;

	// get the string for the CA
	CString szCA;
	UpdateData( TRUE );
	if ( GetSelectedCA(szCA) != ERROR_SUCCESS )
		{
		AfxMessageBox( IDS_LOAD_CA_ERR );
		return;
		}

    // prepare the authority object
    COnlineAuthority    authority;
    if ( !authority.FInitSZ(szCA) )
        {
		AfxMessageBox( IDS_CA_NO_INTERFACE );
		return;
        }

    // run the UI
    BSTR    bstr;
    hErr = authority.pIConfig->GetConfig(0, &bstr);

    // save the config string
    if ( SUCCEEDED(hErr ) )
        authority.FSetPropertyString( bstr  );

    // clean up
    SysFreeString( bstr );
	}

//----------------------------------------------------------------
void CNKChooseCA::OnSelchangeNkCaOnline() 
	{
	// check if there are stored preferences for the selected ca server
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\nkdn.h ===
// NKDN.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CDNEdit

class CDNEdit : public CEdit
	{
	public:
		CDNEdit();
	protected:
		virtual BOOL OnWndMsg(UINT message, WPARAM wParam, LPARAM lParam, LRESULT* pResult);
		CString	szExclude;
		CString	szTotallyExclude;
	};

/////////////////////////////////////////////////////////////////////////////
// CNKDistinguishedName dialog

class CNKDistinguishedName : public CNKPages
{
// Construction
public:
	CNKDistinguishedName(CWnd* pParent = NULL);   // standard constructor
	virtual void OnFinish();
	virtual BOOL OnInitDialog();           // override virtual oninitdialog
	virtual BOOL OnSetActive();


	// NOTE: if you want to exclude characters from being entered into any
	// edit field here, make sure the control belowis of type CDNEdit. Then
	// add the character you want to exclude to the IDS_ILLEGAL_DN_CHARS string

// Dialog Data
	//{{AFX_DATA(CNKDistinguishedName)
	enum { IDD = IDD_NK_DN1 };
	CDNEdit	m_control_CN;
	CDNEdit	m_control_OU;
	CDNEdit	m_control_O;
	CString	m_nkdn_sz_CN;
	CString	m_nkdn_sz_O;
	CString	m_nkdn_sz_OU;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNKDistinguishedName)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CNKDistinguishedName)
	afx_msg void OnChangeNewkeyCommonname();
	afx_msg void OnChangeNewkeyOrg();
	afx_msg void OnChangeNewkeyOrgunit();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void ActivateButtons();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\nkdn2.cpp ===
// NKDN2.cpp : implementation file
//

#include "stdafx.h"
#include "keyring.h"
#include "NKChseCA.h"
#include "NKDN.h"
#include "NKDN2.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#define SZ_CCODES_FILE          _T("ccodes.txt")
#define SZ_CCODES_SECTION       _T("CountryCodes")

#define REGKEY_STP          _T("SOFTWARE\\Microsoft\\INetStp")
#define REGKEY_INSTALLKEY   _T("InstallPath")

    enum {
        WM_INTERNAL_SETCOUNTRYCODE = WM_USER
        };


/////////////////////////////////////////////////////////////////////////////
// CNKDistinguisedName2 dialog


CNKDistinguisedName2::CNKDistinguisedName2(CWnd* pParent /*=NULL*/)
	: CNKPages(CNKDistinguisedName2::IDD)
{
	//{{AFX_DATA_INIT(CNKDistinguisedName2)
	m_nkdn2_sz_L = _T("");
	m_nkdn2_sz_S = _T("");
	m_nkdn2_sz_C = _T("");
	//}}AFX_DATA_INIT
    m_hotlink_codessite.m_fBrowse = TRUE;
}


void CNKDistinguisedName2::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNKDistinguisedName2)
	DDX_Control(pDX, IDC_HOTLINK_CCODES, m_hotlink_codessite);
	DDX_Control(pDX, IDC_NEWKEY_COUNTRY, m_control_C);
	DDX_Control(pDX, IDC_NEWKEY_STATE, m_control_S);
	DDX_Control(pDX, IDC_NEWKEY_LOCALITY, m_control_L);
	DDX_Text(pDX, IDC_NEWKEY_LOCALITY, m_nkdn2_sz_L);
	DDV_MaxChars(pDX, m_nkdn2_sz_L, 128);
	DDX_Text(pDX, IDC_NEWKEY_STATE, m_nkdn2_sz_S);
	DDV_MaxChars(pDX, m_nkdn2_sz_S, 128);
	DDX_CBString(pDX, IDC_NEWKEY_COUNTRY, m_nkdn2_sz_C);
	DDV_MaxChars(pDX, m_nkdn2_sz_C, 2);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CNKDistinguisedName2, CDialog)
	//{{AFX_MSG_MAP(CNKDistinguisedName2)
	ON_EN_CHANGE(IDC_NEWKEY_COUNTRY, OnChangeNewkeyCountry)
	ON_EN_CHANGE(IDC_NEWKEY_LOCALITY, OnChangeNewkeyLocality)
	ON_EN_CHANGE(IDC_NEWKEY_STATE, OnChangeNewkeyState)
	ON_CBN_CLOSEUP(IDC_NEWKEY_COUNTRY, OnCloseupNewkeyCountry)
	ON_CBN_SELCHANGE(IDC_NEWKEY_COUNTRY, OnSelchangeNewkeyCountry)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

#define	SZ_DN_C		"DN_COUNTRY"
#define	SZ_DN_L		"DN_LOCALITY"
#define	SZ_DN_S		"DN_STATE"

//----------------------------------------------------------------
void CNKDistinguisedName2::OnFinish()
	{
    m_nkdn2_sz_C.MakeUpper();
	// store the user entries
	SetStoredString( m_nkdn2_sz_C, SZ_DN_C );
	SetStoredString( m_nkdn2_sz_L, SZ_DN_L );
	SetStoredString( m_nkdn2_sz_S, SZ_DN_S );
	}

//----------------------------------------------------------------
BOOL CNKDistinguisedName2::OnInitDialog()
	{
	// if the entries from last time are available, use them
	try
		{
		FGetStoredString( m_nkdn2_sz_L, SZ_DN_L );
		FGetStoredString( m_nkdn2_sz_S, SZ_DN_S );
		}
	catch( CException e )
		{
		}

    // initialize the  edit field part with the ISO code returned by GetLocalInfo
    GetLocaleInfo(
            LOCALE_SYSTEM_DEFAULT,      // locale identifier  
            LOCALE_SABBREVCTRYNAME,     // type of information  
            m_nkdn2_sz_C.GetBuffer(4),  // address of buffer for information  
            2                           // size of buffer  
            );
    m_nkdn2_sz_C.ReleaseBuffer(2);
    
    // call superclass
	CPropertyPage::OnInitDialog();

    // fill in the country code drop-down list
    InitCountryCodeDropDown();

	// return 0 to say we set the default item
    // return 1 to just select the default default item
    return 1;
	}

//----------------------------------------------------------------
BOOL CNKDistinguisedName2::OnSetActive()
	{
	ActivateButtons();
	return CPropertyPage::OnSetActive();
	}

//----------------------------------------------------------------
void CNKDistinguisedName2::ActivateButtons()
	{
	DWORD	flags = PSWIZB_BACK;
	BOOL	fFinish = FALSE;
	BOOL	fCanGoOn = TRUE;

	// first, see if this is the end of the road by checing the chooseca page
	if ( m_pChooseCAPage->m_nkca_radio == 1 )
		fFinish = TRUE;

	UpdateData(TRUE);

	//now make sure there is something in each of the required fields
	fCanGoOn &= !m_nkdn2_sz_C.IsEmpty();
	fCanGoOn &= !m_nkdn2_sz_S.IsEmpty();
	fCanGoOn &= !m_nkdn2_sz_L.IsEmpty();

	// if we can go on, hilite the button
	if ( fCanGoOn )
		{
		if ( fFinish )
			flags |= PSWIZB_FINISH;
		else
			flags |= PSWIZB_NEXT;
		}
	else
		// cannot go on
		{
		if ( fFinish )
			flags |= PSWIZB_DISABLEDFINISH;
		}

	// update the property sheet buttons
	m_pPropSheet->SetWizardButtons( flags );
	}

//----------------------------------------------------------------
void CNKDistinguisedName2::GetCCodePath( CString &sz )
	{
    HKEY		hKey;
    TCHAR		chPath[MAX_PATH+1];
    DWORD       cbPath;
    DWORD       err, type;

    // get the server install path from the registry
    // open the registry key, if it exists
    err = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,	// handle of open key 
            REGKEY_STP,		    // address of name of subkey to open 
            0,					// reserved 
            KEY_READ,			// security access mask 
            &hKey 				// address of handle of open key 
            );

    // if we did not open the key for any reason (say... it doesn't exist)
    // then leave right away
    if ( err != ERROR_SUCCESS )
    return;

    cbPath = sizeof(chPath);
    type = REG_SZ;
    err = RegQueryValueEx(
            hKey,	            // handle of key to query 
            REGKEY_INSTALLKEY,	// address of name of value to query 
            NULL,	            // reserved 
            &type,	            // address of buffer for value type 
            (PUCHAR)chPath,	    // address of data buffer 
            &cbPath 	        // address of data buffer size 
            );

    // close the key
    RegCloseKey( hKey );

    // if we did get the key for any reason (say... it doesn't exist)
    // then leave right away
    if ( err != ERROR_SUCCESS )
        return;

    // put it all together
    sz = chPath;
    sz += _T('\\');
    sz += SZ_CCODES_FILE;
	}

//----------------------------------------------------------------
void CNKDistinguisedName2::InitCountryCodeDropDown() 
	{
    WIN32_FILE_ATTRIBUTE_DATA   dataFile;
    CString                     szCCodesFile;

    PTCHAR                      pszCode;

    // get the location of the codes file
    GetCCodePath( szCCodesFile );

    // make sure the file exists and get info on it at the same time
    if ( !GetFileAttributesEx(szCCodesFile, GetFileExInfoStandard, &dataFile) )
        return;

    // Allocate a buffer to recieve the data based on the size of the file
    PTCHAR pBuff = (PTCHAR)GlobalAlloc( GPTR, dataFile.nFileSizeLow * 2 );

    DWORD cch = GetPrivateProfileSection(
                SZ_CCODES_SECTION,          // address of section name  
                pBuff,                      // address of return buffer  
                dataFile.nFileSizeLow,      // size of return buffer  
                szCCodesFile                // address of initialization filename  
                );
    pszCode = pBuff;

    // loop through the items, adding each
    while ( *pszCode != 0 )
        {
        // add the country code
        InitOneCountryCode( pszCode );

        // increment the list
        pszCode = _tcsninc( pszCode, _tcslen(pszCode)+1 );
        }

    GlobalFree( pBuff );
	}

//----------------------------------------------------------------
void CNKDistinguisedName2::InitOneCountryCode( LPCTSTR pszCode ) 
	{
    CString szData = pszCode;
    CString szCountry;
    INT     iCode;

    // get the location of the equals character - it MUST be the third character
    if ( szData.Find(_T('=')) != 2 )
        return;
    szCountry = szData.Right( szData.GetLength() - 3 );

    // add the code to the cstring list and save its index position
    iCode = m_rgbszCodes.Add( szData.Left(2) );

    // add the item to the combo box
    int iPos = m_control_C.AddString( szCountry );

    // attach the index into the string array
    m_control_C.SetItemData( iPos, iCode );
	}

/////////////////////////////////////////////////////////////////////////////
// CNKDistinguisedName2 message handlers

//----------------------------------------------------------------
void CNKDistinguisedName2::OnChangeNewkeyCountry() 
	{
	ActivateButtons();
	}

//----------------------------------------------------------------
void CNKDistinguisedName2::OnChangeNewkeyLocality() 
	{
	ActivateButtons();
	}

//----------------------------------------------------------------
void CNKDistinguisedName2::OnChangeNewkeyState() 
	{
	ActivateButtons();
	}

//----------------------------------------------------------------
void CNKDistinguisedName2::OnCloseupNewkeyCountry() 
    {
    // if there is no current selected item, do nothing
    if ( m_control_C.GetCurSel() == -1 )
        return;

    // get the selection's hidden dword
    ULONG_PTR   iCode = m_control_C.GetItemData( m_control_C.GetCurSel() );

    m_control_C.SetCurSel(-1);

    // for some reason, attempting to set the string directly here isn't working.
    PostMessage( WM_INTERNAL_SETCOUNTRYCODE, 0, iCode );
    }

//----------------------------------------------------------------
void CNKDistinguisedName2::OnSelchangeNewkeyCountry() 
    {
    // if there is no current selected item, do nothing
    if ( m_control_C.GetCurSel() == -1 )
        return;

    // get the selection's hidden dword
    ULONG_PTR   iCode = m_control_C.GetItemData( m_control_C.GetCurSel() );

    m_control_C.SetCurSel(-1);

    // for some reason, attempting to set the string directly here isn't working.
    PostMessage( WM_INTERNAL_SETCOUNTRYCODE, 0, iCode );
    }

//----------------------------------------------------------------
LRESULT CNKDistinguisedName2::WindowProc(UINT message, WPARAM wParam, LPARAM lParam) 
    {
    if ( message == WM_INTERNAL_SETCOUNTRYCODE )
        {
        INT iCode = (INT)lParam;

        // set the text of the box
        m_control_C.SetWindowText( m_rgbszCodes.GetAt(iCode) );
        }

    return CDialog::WindowProc(message, wParam, lParam);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\nkdn2.h ===
// NKDN2.h : header file
//

#include "HotLink.h"

/////////////////////////////////////////////////////////////////////////////
// CNKDistinguisedName2 dialog

class CNKDistinguisedName2 : public CNKPages
{
// Construction
public:
// standard constructor
	CNKDistinguisedName2(CWnd* pParent = NULL);
	virtual void OnFinish();
	virtual BOOL OnInitDialog();
	virtual BOOL OnSetActive();

// Dialog Data
	//{{AFX_DATA(CNKDistinguisedName2)
	enum { IDD = IDD_NK_DN2 };
	CHotLink	m_hotlink_codessite;
	CComboBox	m_control_C;
	CDNEdit	m_control_S;
	CDNEdit	m_control_L;
	CString	m_nkdn2_sz_L;
	CString	m_nkdn2_sz_S;
	CString	m_nkdn2_sz_C;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNKDistinguisedName2)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual LRESULT WindowProc(UINT message, WPARAM wParam, LPARAM lParam);
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CNKDistinguisedName2)
	afx_msg void OnChangeNewkeyCountry();
	afx_msg void OnChangeNewkeyLocality();
	afx_msg void OnChangeNewkeyState();
	afx_msg void OnCloseupNewkeyCountry();
	afx_msg void OnSelchangeNewkeyCountry();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

    void InitCountryCodeDropDown();
    void InitOneCountryCode( LPCTSTR pszCode );
    void GetCCodePath( CString &sz );

	void ActivateButtons();

    CStringArray     m_rgbszCodes;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\nkflinfo.cpp ===
// NKFlInfo.cpp : implementation file
//

#include "stdafx.h"
#include "keyring.h"
#include "NKChseCA.h"
#include "NKFlInfo.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNKFileInfo dialog


CNKFileInfo::CNKFileInfo(CWnd* pParent /*=NULL*/)
	: CNKPages(CNKFileInfo::IDD)
{
	//{{AFX_DATA_INIT(CNKFileInfo)
	m_nkfi_sz_filename = _T("");
	//}}AFX_DATA_INIT
}


void CNKFileInfo::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNKFileInfo)
	DDX_Text(pDX, IDC_NK_INFO_FILENAME, m_nkfi_sz_filename);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CNKFileInfo, CDialog)
	//{{AFX_MSG_MAP(CNKFileInfo)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

//----------------------------------------------------------------
BOOL CNKFileInfo::OnSetActive()
	{
	// show the target file
	m_nkfi_sz_filename = m_pChooseCAPage->m_nkca_sz_file;
	UpdateData( FALSE );

	m_pPropSheet->SetWizardButtons( PSWIZB_BACK | PSWIZB_FINISH );
	return CPropertyPage::OnSetActive();
	}

/////////////////////////////////////////////////////////////////////////////
// CNKFileInfo message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\nkkyinfo.cpp ===
// NKKyInfo.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "keyring.h"
#include "NKChseCA.h"
#include "NKKyInfo.h"


extern "C"
{
	#include <wincrypt.h>
	#include <sslsp.h>
}


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNKKeyInfo dialog


CNKKeyInfo::CNKKeyInfo(CWnd* pParent /*=NULL*/)
	: CNKPages(CNKKeyInfo::IDD)
{
	//{{AFX_DATA_INIT(CNKKeyInfo)
	m_nkki_sz_password = _T("");
	m_nkki_sz_password2 = _T("");
	m_nkki_sz_name = _T("");
	//}}AFX_DATA_INIT
}


void CNKKeyInfo::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNKKeyInfo)
	DDX_Control(pDX, IDC_NEW_NKKI_PASSWORD, m_nkki_cedit_password);
	DDX_Control(pDX, IDC_NKKI_BITS, m_nkki_ccombo_bits);
	DDX_Text(pDX, IDC_NEW_NKKI_PASSWORD, m_nkki_sz_password);
	DDX_Text(pDX, IDC_NEW_NKKI_PASSWORD2, m_nkki_sz_password2);
	DDX_Text(pDX, IDC_NKKI_NAME, m_nkki_sz_name);
	DDV_MaxChars(pDX, m_nkki_sz_name, 128);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CNKKeyInfo, CDialog)
	//{{AFX_MSG_MAP(CNKKeyInfo)
	ON_EN_CHANGE(IDC_NEW_NKKI_PASSWORD, OnChangeNewNkkiPassword)
	ON_EN_CHANGE(IDC_NEW_NKKI_PASSWORD2, OnChangeNewNkkiPassword2)
	ON_EN_CHANGE(IDC_NKKI_NAME, OnChangeNkkiName)
	ON_EN_KILLFOCUS(IDC_NEW_NKKI_PASSWORD2, OnKillfocusNewNkkiPassword2)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

//----------------------------------------------------------------
BOOL CNKKeyInfo::OnInitDialog( )
	{
	// give the key a default name
	m_nkki_sz_name.LoadString( IDS_CREATE_KEY_NEW_NAME );

	// call superclass
	CPropertyPage::OnInitDialog();

	// to comply with the munitions export laws, we need to limit the max bits available
	m_nMaxBits = 1024;
	m_nMaxBits = SslGetMaximumKeySize(NULL);

	 // set the default bit size
    m_nBits = m_nMaxBits;
    m_nkki_ccombo_bits.SetCurSel( 2 );

	// if necessary, remove items from the bits combo box
	if ( m_nMaxBits < 1024 )
		{
		m_nkki_ccombo_bits.DeleteString(2);
		m_nkki_ccombo_bits.SetCurSel( 1 );
		}
	if ( m_nMaxBits < 768 )
		{
		m_nkki_ccombo_bits.DeleteString(1);
		m_nkki_ccombo_bits.SetCurSel( 0 );
		}

	// return 0 to say we set the default item
    // return 1 to just select the default default item
    return 1;
	}

//----------------------------------------------------------------
BOOL CNKKeyInfo::OnSetActive()
	{
	ActivateButtons();
	return CPropertyPage::OnSetActive();
	}

//----------------------------------------------------------------
void CNKKeyInfo::ActivateButtons()
	{
	DWORD	flags = PSWIZB_BACK;
	BOOL	fCanGoOn = TRUE;

	UpdateData(TRUE);

	//now make sure there is something in each of the required fields
	fCanGoOn &= !m_nkki_sz_name.IsEmpty();
	fCanGoOn &= !m_nkki_sz_password.IsEmpty();
	fCanGoOn &= !m_nkki_sz_password2.IsEmpty();

	// if we can go on, hilite the button
	if ( fCanGoOn )
		{
		flags |= PSWIZB_NEXT;
		}

	// update the property sheet buttons
	m_pPropSheet->SetWizardButtons( flags );
	}

//----------------------------------------------------------------
LRESULT CNKKeyInfo::OnWizardNext()
	{
    // get the data
    UpdateData(TRUE);

    // start by testing that the passwords match each other
    if ( m_nkki_sz_password != m_nkki_sz_password2 )
        {
        // the fields are not equal. start with the error dialog
	    AfxMessageBox( IDS_PASSWORD_ERROR );

	    // blank out both the fields
	    m_nkki_sz_password.Empty();
	    m_nkki_sz_password2.Empty();
	    UpdateData(FALSE);

	    // set the focus to the first password field
	    m_nkki_cedit_password.SetFocus();

        // return -1 to prevent going to the next pane
        return -1;
        }

    // get the bit size
    switch( m_nkki_ccombo_bits.GetCurSel() )
        {
        case 0:         // bits == 512
                m_nBits = 512;
                break;
        case 1:         // bits == 768
                m_nBits = 768;
                break;
        case 2:         // bits == 1024
                m_nBits = 1024;
                break;
        };

	// call the superclass OnWizardNext
	return CPropertyPage::OnWizardNext();
	}

/////////////////////////////////////////////////////////////////////////////
// CNKKeyInfo message handlers

//----------------------------------------------------------------
void CNKKeyInfo::OnChangeNewNkkiPassword()
	{
	// let them know they have to confirm, or re-confirm it
	UpdateData(TRUE);
	m_nkki_sz_password2.Empty();
	UpdateData(FALSE);

	ActivateButtons();
	}

//----------------------------------------------------------------
void CNKKeyInfo::OnChangeNewNkkiPassword2()
	{
	ActivateButtons();
	}

//----------------------------------------------------------------
void CNKKeyInfo::OnChangeNkkiName()
	{
	ActivateButtons();
	}

//----------------------------------------------------------------
// this is the main place we check to see if the passwords are the same.
// if they are not, then we should put up an error dialog and blank out
// both of the password fields, putting the focus into password1
void CNKKeyInfo::OnKillfocusNewNkkiPassword2()
	{
/*
	// get the data
	UpdateData(TRUE);

	// if the fields are equal, leave now
	if ( m_nkki_sz_password == m_nkki_sz_password2 )
		return;

	// the fields are not equal. start with the error dialog
	AfxMessageBox( IDS_PASSWORD_ERROR );

	// blank out both the fields
	m_nkki_sz_password.Empty();
	m_nkki_sz_password2.Empty();
	UpdateData(FALSE);

	// set the focus to the first password field
	m_nkki_cedit_password.SetFocus();
*/
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\nkusrinf.cpp ===
// NKUsrInf.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "keyring.h"
#include "NKChseCA.h"
#include "NKUsrInf.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// defines for value names in the registry - not to be localized
#define	SZ_EMAIL	"email"
#define	SZ_PHONE	"phone"


/////////////////////////////////////////////////////////////////////////////
// CNKUserInfo property page

IMPLEMENT_DYNCREATE(CNKUserInfo, CPropertyPage)

CNKUserInfo::CNKUserInfo()
	: CNKPages(CNKUserInfo::IDD),
	fRenewingKey( FALSE )
	{
	//{{AFX_DATA_INIT(CNKUserInfo)
	m_nkui_sz_email = _T("");
	m_nkui_sz_phone = _T("");
	m_nkui_sz_name = _T("");
	//}}AFX_DATA_INIT
	}

CNKUserInfo::~CNKUserInfo()
{
}

void CNKUserInfo::DoDataExchange(CDataExchange* pDX)
{
	CPropertyPage::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CNKUserInfo)
	DDX_Text(pDX, IDC_NKUI_EMAIL_ADDRESS, m_nkui_sz_email);
	DDV_MaxChars(pDX, m_nkui_sz_email, 128);
	DDX_Text(pDX, IDC_NKUI_PHONE_NUMBER, m_nkui_sz_phone);
	DDV_MaxChars(pDX, m_nkui_sz_phone, 80);
	DDX_Text(pDX, IDC_NKUI_USER_NAME, m_nkui_sz_name);
	DDV_MaxChars(pDX, m_nkui_sz_name, 128);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CNKUserInfo, CPropertyPage)
	//{{AFX_MSG_MAP(CNKUserInfo)
	ON_EN_CHANGE(IDC_NKUI_EMAIL_ADDRESS, OnChangeNkuiEmailAddress)
	ON_EN_CHANGE(IDC_NKUI_PHONE_NUMBER, OnChangeNkuiPhoneNumber)
	ON_EN_CHANGE(IDC_NKUI_USER_NAME, OnChangeNkuiUserName)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


#define	SZ_USER_NAME	"USER_NAME"
#define	SZ_USER_PHONE	"USER_PHONE"
#define	SZ_USER_EMAIL	"USER_EMAIL"

//----------------------------------------------------------------
void CNKUserInfo::OnFinish()
	{
	// store the user entries
	SetStoredString( m_nkui_sz_name, SZ_USER_NAME );
	SetStoredString( m_nkui_sz_phone, SZ_USER_PHONE );
	SetStoredString( m_nkui_sz_email, SZ_USER_EMAIL );
	}

//----------------------------------------------------------------
BOOL CNKUserInfo::OnInitDialog( )
	{
	// if the entries from last time are available, use them, otherwise just
	// use the system's user name as a default
	try
		{
		FGetStoredString( m_nkui_sz_name, SZ_USER_NAME );
		FGetStoredString( m_nkui_sz_phone, SZ_USER_PHONE );
		FGetStoredString( m_nkui_sz_email, SZ_USER_EMAIL );

		// if we didn't get the user name, use the default
		if ( m_nkui_sz_name.IsEmpty() )
			{
			LPTSTR	pName = m_nkui_sz_name.GetBuffer( MAX_PATH+1 );
			DWORD	cbName = MAX_PATH;
			GetUserName( pName, &cbName );
			m_nkui_sz_name.ReleaseBuffer();
			}
		}
	catch( CException e )
		{
		m_nkui_sz_name.Empty();
		}

	// call superclass
	CPropertyPage::OnInitDialog();

	// return 0 to say we set the default item
    // return 1 to just select the default default item
    return 1;
	}

//----------------------------------------------------------------
BOOL CNKUserInfo::OnSetActive()
	{
	ActivateButtons();
	return CPropertyPage::OnSetActive();
	}

//----------------------------------------------------------------
void CNKUserInfo::ActivateButtons()
	{
	DWORD	flags = PSWIZB_BACK;
	BOOL	fCanGoOn = TRUE;

	UpdateData(TRUE);

	//now make sure there is something in each of the required fields
	fCanGoOn &= !m_nkui_sz_name.IsEmpty();
	fCanGoOn &= !m_nkui_sz_email.IsEmpty();
	fCanGoOn &= !m_nkui_sz_phone.IsEmpty();

	// if we can go on, hilite the button
	if ( fCanGoOn )
		{
		if ( fRenewingKey )
			flags |= PSWIZB_FINISH;
		else
			flags |= PSWIZB_NEXT;
		}

	// update the property sheet buttons
	m_pPropSheet->SetWizardButtons( flags );
	}

//----------------------------------------------------------------
BOOL CNKUserInfo::OnWizardFinish()
	{
	/*
	// now load up the registry key
	CString		szRegKeyName;
	szRegKeyName.LoadString( IDS_REG_USER_INFO );

	// and open the key
	HKEY		hKey;
	DWORD		dwdisposition;
	if ( RegCreateKeyEx(
			HKEY_CURRENT_USER,	// handle of open key
			szRegKeyName,		// address of name of subkey to open
			0,					// reserved
			NULL,				// pClass
			REG_OPTION_NON_VOLATILE,	// special options flag
			KEY_ALL_ACCESS,		// desired security access
			NULL,				// address of key security
			&hKey, 				// address of handle of open key
			&dwdisposition
		   ) == ERROR_SUCCESS )
		{
		// store the email name for later use
		RegSetValueEx( hKey, SZ_EMAIL, 0, REG_SZ, (PUCHAR)(LPCTSTR)m_nkui_sz_email, m_nkui_sz_email.GetLength()+1 );
		RegSetValueEx( hKey, SZ_PHONE, 0, REG_SZ, (PUCHAR)(LPCTSTR)m_nkui_sz_phone, m_nkui_sz_phone.GetLength()+1 );

		// close the key
		RegCloseKey( hKey );
		}
*/
	// finish by calling the superclass
	return CPropertyPage::OnWizardFinish();
	}

/////////////////////////////////////////////////////////////////////////////
// CNKUserInfo message handlers

//----------------------------------------------------------------
void CNKUserInfo::OnChangeNkuiEmailAddress()
	{
	ActivateButtons();
	}

//----------------------------------------------------------------
void CNKUserInfo::OnChangeNkuiPhoneNumber()
	{
	ActivateButtons();
	}

//----------------------------------------------------------------
void CNKUserInfo::OnChangeNkuiUserName()
	{
	ActivateButtons();
	}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\nkusrinf.h ===
// NKUsrInf.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CNKUserInfo dialog

class CNKUserInfo : public CNKPages
{
	DECLARE_DYNCREATE(CNKUserInfo)

// Construction
public:
	CNKUserInfo();
	~CNKUserInfo();
	virtual void OnFinish();
	BOOL OnInitDialog();
	virtual BOOL OnSetActive();
	virtual BOOL OnWizardFinish();

	BOOL	fRenewingKey;

// Dialog Data
	//{{AFX_DATA(CNKUserInfo)
	enum { IDD = IDD_NK_USER_INFO };
	CString	m_nkui_sz_email;
	CString	m_nkui_sz_phone;
	CString	m_nkui_sz_name;
	//}}AFX_DATA


// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CNKUserInfo)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	// Generated message map functions
	//{{AFX_MSG(CNKUserInfo)
	afx_msg void OnChangeNkuiEmailAddress();
	afx_msg void OnChangeNkuiPhoneNumber();
	afx_msg void OnChangeNkuiUserName();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void ActivateButtons();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\nkflinfo.h ===
// NKFlInfo.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CNKFileInfo dialog

class CNKFileInfo : public CNKPages
{
// Construction
public:
	CNKFileInfo(CWnd* pParent = NULL);   // standard constructor
	virtual BOOL OnSetActive();

// Dialog Data
	//{{AFX_DATA(CNKFileInfo)
	enum { IDD = IDD_NK_FILE_INFO };
	CString	m_nkfi_sz_filename;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNKFileInfo)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CNKFileInfo)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\nwkeydlg.h ===
// CreateKeyDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CCreateKeyDlg dialog

class CCreateKeyDlg : public CDialog
{
// Construction
public:
        CCreateKeyDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
        //{{AFX_DATA(CCreateKeyDlg)
        enum { IDD = IDD_CREATE_KEY_REQUEST };
        CEdit   m_ceditPassword;
        CButton m_btnOK;
        CComboBox       m_comboBits;
        CString m_szNetAddress;
        CString m_szCountry;
        CString m_szLocality;
        CString m_szOrganization;
        CString m_szUnit;
        CString m_szState;
        CString m_szKeyName;
        CString m_szCertificateFile;
        CString m_szPassword;
        //}}AFX_DATA
        
        // ends up holding the number of bits
        DWORD   m_nBits;
        DWORD   m_nMaxBits;
protected:
        // override the OnOK routine
        void OnOK();

        // specifies whether or not the user has specifically chosen a file name
        BOOL    m_fKeyNameChangedFile;

        // specifies whether or not the user has specifically chosen a file name
        BOOL    m_fSpecifiedFile;


// Overrides
        // ClassWizard generated virtual function overrides
        //{{AFX_VIRTUAL(CCreateKeyDlg)
        public:
        virtual BOOL PreTranslateMessage(MSG* pMsg);
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        //}}AFX_VIRTUAL

// Implementation
protected:

        // Generated message map functions
        //{{AFX_MSG(CCreateKeyDlg)
        afx_msg void OnChangeNewKeyName();
        afx_msg void OnNewKeyBrowse();
        afx_msg void OnChangeNewKeyRequestFile();
        afx_msg void OnChangeNewKeyPassword();
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()

        // my routines to help this puppy out
protected:
        BOOL OnInitDialog( );           // override virtual oninitdialog

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\nwkeydlg.cpp ===
// CreateKeyDlg.cpp : implementation file
//

#include "stdafx.h"
#include "KeyRing.h"

extern "C"
{
	#include <wincrypt.h>
	#include <sslsp.h>
}


#include "NwKeyDlg.h"
#include "PassDlg.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CCreateKeyDlg dialog


CCreateKeyDlg::CCreateKeyDlg(CWnd* pParent /*=NULL*/)
        : CDialog(CCreateKeyDlg::IDD, pParent)
{
        //{{AFX_DATA_INIT(CCreateKeyDlg)
        m_szNetAddress = _T("");
        m_szCountry = _T("");
        m_szLocality = _T("");
        m_szOrganization = _T("");
        m_szUnit = _T("");
        m_szState = _T("");
        m_szKeyName = _T("");
        m_szCertificateFile = _T("");
        m_szPassword = _T("");
        //}}AFX_DATA_INIT
}


void CCreateKeyDlg::DoDataExchange(CDataExchange* pDX)
{
        CDialog::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CCreateKeyDlg)
        DDX_Control(pDX, IDC_NEW_KEY_PASSWORD, m_ceditPassword);
        DDX_Control(pDX, IDOK, m_btnOK);
        DDX_Control(pDX, IDC_NEW_KEY_BITS, m_comboBits);
        DDX_Text(pDX, IDC_NEWKEY_COMMONNAME, m_szNetAddress);
        DDX_Text(pDX, IDC_NEWKEY_COUNTRY, m_szCountry);
        DDV_MaxChars(pDX, m_szCountry, 2);
        DDX_Text(pDX, IDC_NEWKEY_LOCALITY, m_szLocality);
        DDX_Text(pDX, IDC_NEWKEY_ORG, m_szOrganization);
        DDX_Text(pDX, IDC_NEWKEY_ORGUNIT, m_szUnit);
        DDX_Text(pDX, IDC_NEWKEY_STATE, m_szState);
        DDX_Text(pDX, IDC_NEW_KEY_NAME, m_szKeyName);
        DDX_Text(pDX, IDC_NEW_KEY_REQUEST_FILE, m_szCertificateFile);
        DDX_Text(pDX, IDC_NEW_KEY_PASSWORD, m_szPassword);
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CCreateKeyDlg, CDialog)
        //{{AFX_MSG_MAP(CCreateKeyDlg)
        ON_EN_CHANGE(IDC_NEW_KEY_NAME, OnChangeNewKeyName)
        ON_BN_CLICKED(IDC_NEW_KEY_BROWSE, OnNewKeyBrowse)
        ON_EN_CHANGE(IDC_NEW_KEY_REQUEST_FILE, OnChangeNewKeyRequestFile)
        ON_EN_CHANGE(IDC_NEW_KEY_PASSWORD, OnChangeNewKeyPassword)
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CCreateKeyDlg message handlers





/////////////////////////////////////////////////////////////////////////////
// members
//----------------------------------------------------------------
// override virtual oninitdialog
BOOL CCreateKeyDlg::OnInitDialog( )
        {
        // set the initial strings
        m_szKeyName.LoadString( IDS_CREATE_KEY_NEW_NAME );
        m_szOrganization.LoadString( IDS_CREATE_KEY_YOUR_COMPANY );
        m_szUnit.LoadString( IDS_CREATE_KEY_YOUR_UNIT );
        m_szNetAddress.LoadString( IDS_CREATE_KEY_YOUR_ADDRESS );
        m_szCountry.LoadString( IDS_LOCALIZED_DEFAULT_COUNTRY_CODE );

        m_szState.LoadString( IDS_CREATE_KEY_YOUR_STATE );
        m_szLocality.LoadString( IDS_CREATE_KEY_YOUR_LOCALITY );

        // call the base oninit
        CDialog::OnInitDialog();


		// to comply with the munitions export laws, we need to limit the max bits available
		m_nMaxBits = 1024;
// LOOK HERE KIM
		m_nMaxBits = SslGetMaximumKeySize(NULL);

		 // set the default bit size
        m_nBits = m_nMaxBits;
        m_comboBits.SetCurSel( 2 );

		// if necessary, remove items from the bits combo box
		if ( m_nMaxBits < 1024 )
			{
			m_comboBits.DeleteString(2);
			m_comboBits.SetCurSel( 1 );
			}
		if ( m_nMaxBits < 768 )
			{
			m_comboBits.DeleteString(1);
			m_comboBits.SetCurSel( 0 );
			}

        // any other defaults
        m_fKeyNameChangedFile = FALSE;
        m_fSpecifiedFile = FALSE;
        OnChangeNewKeyName();

        // we start with no password, so diable the ok window
        m_btnOK.EnableWindow( FALSE );

        // return 0 to say we set the default item
        // return 1 to just select the default default item
        return 1;
        }

//----------------------------------------------------------------
void CCreateKeyDlg::OnChangeNewKeyName() 
        {
        // if the user has not specifically chosen a file, update the
        // path of the request file to reflect the new file name
        if ( !m_fSpecifiedFile )
                {
                UpdateData( TRUE );
                m_szCertificateFile = _T("C:\\");
                m_szCertificateFile += m_szKeyName;
                m_szCertificateFile += _T(".req");
                UpdateData( FALSE );
                }
        }

//----------------------------------------------------------------
void CCreateKeyDlg::OnChangeNewKeyRequestFile() 
        {
        if ( m_fKeyNameChangedFile )
                {
                // the change is because of a key name change. No big deal.
                // reset the flag and return
                m_fKeyNameChangedFile = FALSE;
                return;
                }

        // the user has been typing in the file box, or chose something in
        // the dialog. Either way, set the m_fSpecifiedFile flag so that
        // we stop changing the path with the key name is changed
        m_fSpecifiedFile = TRUE;
        }

//----------------------------------------------------------------
void CCreateKeyDlg::OnNewKeyBrowse() 
        {
        CFileDialog             cfdlg(FALSE, _T("*.req"), m_szCertificateFile);
        CString                 szFilter;
        WORD                    i = 0;
        LPSTR                   lpszBuffer;
        
        // prepare the filter string
        szFilter.LoadString( IDS_CERTIFICATE_FILTER );
        
        // replace the "!" characters with nulls
        lpszBuffer = szFilter.GetBuffer(MAX_PATH+1);
        while( lpszBuffer[i] )
                {
                if ( lpszBuffer[i] == _T('!') )
                        lpszBuffer[i] = _T('\0');                       // yes, set \0 on purpose
                i++;
                }

        // prep the dialog
        cfdlg.m_ofn.lpstrFilter = lpszBuffer;

        // run the dialog
        if ( cfdlg.DoModal() == IDOK )
                {
                // get the current data out of the dialog
                UpdateData( TRUE );

                // get the path for the file from the dialog
                m_szCertificateFile = cfdlg.GetPathName();
                UpdateData( FALSE );

                // the user has been typing in the file box, or chose something in
                // the dialog. Either way, set the m_fSpecifiedFile flag so that
                // we stop changing the path with the key name is changed
                m_fSpecifiedFile = TRUE;
                }

        // release the buffer in the filter string
        szFilter.ReleaseBuffer(60);
        }


//----------------------------------------------------------------
void CCreateKeyDlg::OnOK()
        {
        HANDLE  hFile;

        // get the data out of the dialog
        UpdateData( TRUE );

        // if the file already exists, ask the user if they want to overwrite it
        // also, make sure that it is a valid pathname
        hFile = CreateFile( m_szCertificateFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
        // if we opened the file, we have an error
        if ( hFile != INVALID_HANDLE_VALUE )
                {
                // well, first we close the handle, we were only checking if the file was there after all
                CloseHandle( hFile );

                // ask the user if they really want to overwrite the file
                try
                        {
                        // get the second part of the message from the resources
                        CString szMessageNote;
                        szMessageNote.LoadString( IDS_CERT_FILE_EXISTS );

                        // next, build the string we will use in the message box
                        CString szMessage;
                        szMessage = m_szCertificateFile;
                        szMessage += szMessageNote;

                        // put up the message box, if the user choose no, they do not want to overwrite the
                        // file. Then we should exit now
                        if ( AfxMessageBox(szMessage, MB_ICONQUESTION|MB_YESNO) == IDNO )
                                return;
                        }
                catch( CException e )
                        {
                        return;
                        }
                }


        // first, we need to confirm that the password is alright
        // the user must re-enter the password to confirm it
        CConfirmPassDlg         dlgconfirm;
        if ( dlgconfirm.DoModal() != IDOK )
                return;
        // confirm the password
        if ( dlgconfirm.m_szPassword != m_szPassword )
                {
                AfxMessageBox( IDS_INCORRECT_PASSWORD );
                return;
                }

        // set the default bit size
        switch( m_comboBits.GetCurSel() )
                {
                case 0:         // bits == 512
                        m_nBits = 512;
                        break;
                case 1:         // bits == 768
                        m_nBits = 768;
                        break;
                case 2:         // bits == 1024
                        m_nBits = 1024;
                        break;
                };
        
        // call the inherited OnOK
        CDialog::OnOK();
        }


//----------------------------------------------------------------
void CCreateKeyDlg::OnChangeNewKeyPassword() 
        {
        // if there is no password, disable the ok button.
        // otherwise, enable it
        UpdateData( TRUE );
        m_btnOK.EnableWindow( !m_szPassword.IsEmpty() );
        }

//----------------------------------------------------------------
BOOL CCreateKeyDlg::PreTranslateMessage(MSG* pMsg) 
        {
        // filter commas out of all edit fields except the password field.
        // commas would interfere with the distinguishing name information
        if ( (pMsg->message == WM_CHAR) && 
                        (pMsg->hwnd != m_ceditPassword) &&
                        ((TCHAR)pMsg->wParam == _T(',')) )
                {
                MessageBeep(0);
                return TRUE;
                }

        // translate normally
        return CDialog::PreTranslateMessage(pMsg);
        }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\nkkyinfo.h ===
// NKKyInfo.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CNKKeyInfo dialog

class CNKKeyInfo : public CNKPages
{
// Construction
public:
	CNKKeyInfo(CWnd* pParent = NULL);   // standard constructor
	virtual BOOL OnInitDialog();		// override virtual oninitdialog
	virtual BOOL OnSetActive();
	virtual LRESULT OnWizardNext();

    // ends up holding the number of bits
    DWORD   m_nBits;
    DWORD   m_nMaxBits;

// Dialog Data
	//{{AFX_DATA(CNKKeyInfo)
	enum { IDD = IDD_NK_KEY_INFO };
	CEdit	m_nkki_cedit_password;
	CComboBox	m_nkki_ccombo_bits;
	CString	m_nkki_sz_password;
	CString	m_nkki_sz_password2;
	CString	m_nkki_sz_name;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CNKKeyInfo)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CNKKeyInfo)
	afx_msg void OnChangeNewNkkiPassword();
	afx_msg void OnChangeNewNkkiPassword2();
	afx_msg void OnChangeNkkiName();
	afx_msg void OnKillfocusNewNkkiPassword2();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void ActivateButtons();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\onlnauth.cpp ===
// COnlineAuthority
// copyright 1997 Microsoft Corp
// created 5/19/97 by boydm

#include "stdafx.h"
#define INITGUID
#include "keyring.h"

#include "certcli.h"
#include "OnlnAuth.h"


DEFINE_GUID(IID_ICertGetConfig,
    0xc7ea09c0, 0xce17, 0x11d0, 0x88, 0x33, 0x00, 0xa0, 0xc9, 0x03, 0xb8, 0x3c);

//DEFINE_GUID(IID_ICertConfig,
//    0x372fce34, 0x4324, 0x11d0, 0x88, 0x10, 0x00, 0xa0, 0xc9, 0x03, 0xb8, 0x3c);

DEFINE_GUID(IID_ICertRequest,
    0x014e4840, 0x5523, 0x11d0, 0x88, 0x12, 0x00, 0xa0, 0xc9, 0x03, 0xb8, 0x3c);

// defines to get the class factory ids out of the registry
#define SZREG_CERTGETCONFIG     _T("CertGetConfig")
#define SZREG_CERTREQUEST       _T("CertRequest")

//---------------------------------------------------------------------------
COnlineAuthority::COnlineAuthority():
        pIConfig(NULL),
        pIRequest(NULL)
    {
    }

//---------------------------------------------------------------------------
COnlineAuthority::~COnlineAuthority()
    {
    // if we already have interfaces - release them
    if ( pIConfig )
        pIConfig->Release();
    if ( pIRequest )
        pIRequest->Release();
    }

//---------------------------------------------------------------------------
// initialize the class with an interface string
BOOL COnlineAuthority::FInitSZ( CString szCA )
    {
    HRESULT     hresError;
    IID         iidConfig, iidRequest;
    OLECHAR*    poch = NULL;
    CString     szConfig, szRequest;

    CString     szRegKeyName;
    DWORD       dwType;
    DWORD       cbBuff;
    DWORD       err;
    HKEY        hKey;

    // load the base registry key name
    szRegKeyName.LoadString( IDS_CA_LOCATION );

    // add the CA
    szRegKeyName += _T("\\");
    szRegKeyName += szCA;

    // open the registry key, if it exists
    err = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE, // handle of open key
            szRegKeyName,       // address of name of subkey to open
            0,                  // reserved
            KEY_READ,           // security access mask
            &hKey               // address of handle of open key
           );

    // if we did not open the key for any reason (say... it doesn't exist)
    // then leave right away
    if ( err != ERROR_SUCCESS )
        return FALSE;

    // get the config value
    cbBuff = MAX_PATH;
    err =  RegQueryValueEx(
        hKey,               // handle of key to query
        SZREG_CERTGETCONFIG,// address of name of value to query
        NULL,               // reserved
        &dwType,            // address of buffer for value type
        (PUCHAR)szConfig.GetBuffer(cbBuff+1), // address of data buffer
        &cbBuff // address of data buffer size
        );
    szConfig.ReleaseBuffer();
    if ( err != ERROR_SUCCESS )
        {
        RegCloseKey( hKey );
        return FALSE;
        }

    // get the request value
    cbBuff = MAX_PATH;
    err =  RegQueryValueEx(
        hKey,               // handle of key to query
        SZREG_CERTREQUEST,  // address of name of value to query
        NULL,               // reserved
        &dwType,            // address of buffer for value type
        (PUCHAR)szRequest.GetBuffer(cbBuff+1), // address of data buffer
        &cbBuff // address of data buffer size
        );
    szRequest.ReleaseBuffer();
    if ( err != ERROR_SUCCESS )
        {
        RegCloseKey( hKey );
        return FALSE;
        }

    // all done, close the key before leaving
    RegCloseKey( hKey );

    //======= first, convert the szGuid to a real binary GUID
    // allocate the name buffer
    poch = (OLECHAR*)GlobalAlloc( GPTR, MAX_PATH * 2 );

    // unicodize the name into the buffer
    if ( poch )
        MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, szConfig, -1,
                            poch, MAX_PATH * 2 );

    // convert the string to an IID that we can use
    hresError = CLSIDFromString( poch, &iidConfig );

    // unicodize the name into the buffer
    if ( poch )
        MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, szRequest, -1,
                            poch, MAX_PATH * 2 );

    // convert the string to an IID that we can use
    hresError = CLSIDFromString( poch, &iidRequest );

    // cleanup
    GlobalFree( poch );
    if ( FAILED(hresError) )
        {
        AfxMessageBox( IDS_CA_INVALID );
        return FALSE;
        }

    //======= if we already have interfaces - release them
    if ( pIConfig )
        pIConfig->Release();
    pIConfig = NULL;
    if ( pIRequest )
        pIRequest->Release();
    pIRequest = NULL;

    //======= start by obtaining the class factory pointer
    IClassFactory*      pcsfFactory = NULL;
    COSERVERINFO        csiMachineName;

    //fill the structure for CoGetClassObject
    ZeroMemory( &csiMachineName, sizeof(csiMachineName) );
    // csiMachineName.pAuthInfo = NULL;
    // csiMachineName.dwFlags = 0;
    // csiMachineName.pServerInfoExt = NULL;
    csiMachineName.pwszName = NULL;

    // get the class factory
    hresError = CoGetClassObject( iidConfig, CLSCTX_INPROC, NULL,
            IID_IClassFactory, (void**) &pcsfFactory);
    if (FAILED(hresError))
        return FALSE;

    //======= now we get the interfaces themselves
    hresError = pcsfFactory->CreateInstance(NULL, IID_ICertGetConfig, (void **)&pIConfig);
    if (FAILED(hresError))
        {
        pcsfFactory->Release();
        return FALSE;
        }

    // release the factory
    pcsfFactory->Release();

    // get the class factory
    hresError = CoGetClassObject( iidRequest, CLSCTX_INPROC, NULL,
            IID_IClassFactory, (void**) &pcsfFactory);
    if (FAILED(hresError))
        return FALSE;

    hresError = pcsfFactory->CreateInstance(NULL, IID_ICertRequest, (void **)&pIRequest);
    if (FAILED(hresError))
        {
        pIConfig->Release();
        pcsfFactory->Release();
        return FALSE;
        }

    // release the factory
    pcsfFactory->Release();

    // success
    return TRUE;
    }

//---------------------------------------------------------------------------
// stored property strings
BOOL COnlineAuthority::FSetPropertyString( BSTR bstr )
    {
    return FALSE;
    }

//---------------------------------------------------------------------------
BOOL COnlineAuthority::FGetPropertyString( BSTR* pBstr )
    {
    HRESULT     hErr;

    // make the call
    hErr = pIConfig->GetConfig( 0, pBstr);

    return SUCCEEDED(hErr);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\onlnauth.h ===
// COnlineAuthority
// helper class for interfacing with the online authority interfaces
// note that this is not actually an interface, just a tool to use them

class COnlineAuthority
    {
    public:
    COnlineAuthority();
    ~COnlineAuthority();

    // initialize the class with an interface string
    BOOL FInitSZ( CString szGUID );

    // stored property strings
    BOOL FSetPropertyString( BSTR bstr );
    BOOL FGetPropertyString( BSTR* pBstr );

    // the interfaces
    ICertGetConfig  *pIConfig;
    ICertRequest    *pIRequest;
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\protos.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       protos.h
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    8-08-95   RichardW   Created
//
//----------------------------------------------------------------------------



VOID
InitializeCipherMappings(VOID);

VOID
InitializeWellKnownKeys( VOID );

SslGenRandom(
    DWORD       cbRandom,
    PBYTE       pbRandom);

BSAFE_PUB_KEY *
FindIssuerKey(
    PSTR    pszIssuer);


BOOL
SslInitializeSessions( VOID );



///////////////////////////////////////////////////////
//
// Prototypes for SSL SSPI
//
///////////////////////////////////////////////////////


SECURITY_STATUS SEC_ENTRY
SslAcquireCredentialsHandleW(
    SEC_WCHAR SEC_FAR *         pszPrincipal,       // Name of principal
    SEC_WCHAR SEC_FAR *         pszPackageName,     // Name of package
    unsigned long               fCredentialUse,     // Flags indicating use
    void SEC_FAR *              pvLogonId,          // Pointer to logon ID
    void SEC_FAR *              pAuthData,          // Package specific data
    SEC_GET_KEY_FN              pGetKeyFn,          // Pointer to GetKey() func
    void SEC_FAR *              pvGetKeyArgument,   // Value to pass to GetKey()
    PCredHandle                 phCredential,       // (out) Cred Handle
    PTimeStamp                  ptsExpiry           // (out) Lifetime (optional)
    );

SECURITY_STATUS SEC_ENTRY
SslAcquireCredentialsHandleA(
    SEC_CHAR SEC_FAR *         pszPrincipal,       // Name of principal
    SEC_CHAR SEC_FAR *         pszPackageName,     // Name of package
    unsigned long               fCredentialUse,     // Flags indicating use
    void SEC_FAR *              pvLogonId,          // Pointer to logon ID
    void SEC_FAR *              pAuthData,          // Package specific data
    SEC_GET_KEY_FN              pGetKeyFn,          // Pointer to GetKey() func
    void SEC_FAR *              pvGetKeyArgument,   // Value to pass to GetKey()
    PCredHandle                 phCredential,       // (out) Cred Handle
    PTimeStamp                  ptsExpiry           // (out) Lifetime (optional)
    );


SECURITY_STATUS SEC_ENTRY
SslFreeCredentialHandle(
    PCredHandle                 phCredential        // Handle to free
    );


SECURITY_STATUS SEC_ENTRY
SslInitializeSecurityContextW(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    SEC_WCHAR SEC_FAR *          pszTargetName,      // Name of target
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               Reserved1,          // Reserved, MBZ
    unsigned long               TargetDataRep,      // Data rep of target
    PSecBufferDesc              pInput,             // Input Buffers
    unsigned long               Reserved2,          // Reserved, MBZ
    PCtxtHandle                 phNewContext,       // (out) New Context handle
    PSecBufferDesc              pOutput,            // (inout) Output Buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attrs
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    );

SECURITY_STATUS SEC_ENTRY
SslInitializeSecurityContextA(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    SEC_CHAR SEC_FAR *          pszTargetName,      // Name of target
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               Reserved1,          // Reserved, MBZ
    unsigned long               TargetDataRep,      // Data rep of target
    PSecBufferDesc              pInput,             // Input Buffers
    unsigned long               Reserved2,          // Reserved, MBZ
    PCtxtHandle                 phNewContext,       // (out) New Context handle
    PSecBufferDesc              pOutput,            // (inout) Output Buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attrs
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    );


SECURITY_STATUS SEC_ENTRY
SslAcceptSecurityContext(
    PCredHandle                 phCredential,       // Cred to base context
    PCtxtHandle                 phContext,          // Existing context (OPT)
    PSecBufferDesc              pInput,             // Input buffer
    unsigned long               fContextReq,        // Context Requirements
    unsigned long               TargetDataRep,      // Target Data Rep
    PCtxtHandle                 phNewContext,       // (out) New context handle
    PSecBufferDesc              pOutput,            // (inout) Output buffers
    unsigned long SEC_FAR *     pfContextAttr,      // (out) Context attributes
    PTimeStamp                  ptsExpiry           // (out) Life span (OPT)
    );


SECURITY_STATUS SEC_ENTRY
SslDeleteSecurityContext(
    PCtxtHandle                 phContext           // Context to delete
    );



SECURITY_STATUS SEC_ENTRY
SslApplyControlToken(
    PCtxtHandle                 phContext,          // Context to modify
    PSecBufferDesc              pInput              // Input token to apply
    );


SECURITY_STATUS SEC_ENTRY
SslEnumerateSecurityPackagesW(
    unsigned long SEC_FAR *     pcPackages,         // Receives num. packages
    PSecPkgInfoW SEC_FAR *      ppPackageInfo       // Receives array of info
    );

SECURITY_STATUS SEC_ENTRY
SslEnumerateSecurityPackagesA(
    unsigned long SEC_FAR *     pcPackages,         // Receives num. packages
    PSecPkgInfoA SEC_FAR *      ppPackageInfo       // Receives array of info
    );


SECURITY_STATUS SEC_ENTRY
SslQuerySecurityPackageInfoW(
    SEC_WCHAR SEC_FAR *         pszPackageName,     // Name of package
    PSecPkgInfoW *              ppPackageInfo       // Receives package info
    );

SECURITY_STATUS SEC_ENTRY
SslQuerySecurityPackageInfoA(
    SEC_CHAR SEC_FAR *         pszPackageName,     // Name of package
    PSecPkgInfoA *              ppPackageInfo       // Receives package info
    );


SECURITY_STATUS SEC_ENTRY
SslFreeContextBuffer(
    void SEC_FAR *      pvContextBuffer
    );


SECURITY_STATUS SEC_ENTRY
SslQueryCredentialsAttributesW(
    PCredHandle phCredential,
    ULONG ulAttribute,
    PVOID pBuffer
    );


SECURITY_STATUS SEC_ENTRY
SslCompleteAuthToken(
    PCtxtHandle                 phContext,          // Context to complete
    PSecBufferDesc              pToken              // Token to complete
    );


SECURITY_STATUS SEC_ENTRY
SslImpersonateSecurityContext(
    PCtxtHandle                 phContext           // Context to impersonate
    );


SECURITY_STATUS SEC_ENTRY
SslRevertSecurityContext(
    PCtxtHandle                 phContext           // Context from which to re
    );


SECURITY_STATUS SEC_ENTRY
SslQueryContextAttributesW(
    PCtxtHandle                 phContext,          // Context to query
    unsigned long               ulAttribute,        // Attribute to query
    void SEC_FAR *              pBuffer             // Buffer for attributes
    );

SECURITY_STATUS SEC_ENTRY
SslQueryContextAttributesA(
    PCtxtHandle                 phContext,          // Context to query
    unsigned long               ulAttribute,        // Attribute to query
    void SEC_FAR *              pBuffer             // Buffer for attributes
    );


SECURITY_STATUS SEC_ENTRY
SslMakeSignature(
    PCtxtHandle         phContext,
    DWORD               fQOP,
    PSecBufferDesc      pMessage,
    ULONG               MessageSeqNo
    );

SECURITY_STATUS SEC_ENTRY
SslVerifySignature(
    PCtxtHandle     phContext,
    PSecBufferDesc  pMessage,
    ULONG           MessageSeqNo,
    DWORD *         pfQOP
    );


SECURITY_STATUS SEC_ENTRY
SslSealMessage(
    PCtxtHandle         phContext,
    DWORD               fQOP,
    PSecBufferDesc      pMessage,
    ULONG               MessageSeqNo
    );


SECURITY_STATUS SEC_ENTRY
SslUnsealMessage(
    PCtxtHandle         phContext,
    PSecBufferDesc      pMessage,
    ULONG               MessageSeqNo,
    DWORD *             pfQOP
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	KeyRing.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
//#include <afxdisp.h>        // MFC OLE automation classes
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows 95 Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <afxcview.h>
#include <afxtempl.h>

#include <winnls.h>
#include <winreg.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\passdlg.h ===
// DConfirmPassDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// DConfirmPassDlg dialog

class CConfirmPassDlg : public CDialog
{
// Construction
public:
	CConfirmPassDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CConfirmPassDlg)
	enum { IDD = IDD_CONFIRM_PASSWORD };
	CString	m_szPassword;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CConfirmPassDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	BOOL OnInitDialog( );

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CConfirmPassDlg)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\passdlg.cpp ===
// DConfirmPassDlg.cpp : implementation file
//

#include "stdafx.h"
#include "KeyRing.h"
#include "PassDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// DConfirmPassDlg dialog


CConfirmPassDlg::CConfirmPassDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CConfirmPassDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CConfirmPassDlg)
	m_szPassword = _T("");
	//}}AFX_DATA_INIT
}


void CConfirmPassDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(DConfirmPassDlg)
	DDX_Text(pDX, IDC_CONFIRM_PASSWORD, m_szPassword);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CConfirmPassDlg, CDialog)
	//{{AFX_MSG_MAP(CConfirmPassDlg)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConfirmPassDlg message handlers
//----------------------------------------------------------------
// override virtual oninitdialog
BOOL CConfirmPassDlg::OnInitDialog( )
	{
	// call the base oninit
	CDialog::OnInitDialog();

	// set the focus to the edit box
	GotoDlgCtrl(GetDlgItem(IDC_CONFIRM_PASSWORD));

	// we start with no password, so diable the ok window
//	m_btnOK.EnableWindow( FALSE );

	return 1;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\treeitem.cpp ===
// implements the exported CTreeItem

#include "stdafx.h"
#include "KeyObjs.h"
#include "machine.h"
#include "KeyRing.h"
#include "KRDoc.h"
#include "KRView.h"

IMPLEMENT_DYNCREATE(CTreeItem, CObject);

extern CKeyRingView*    g_pTreeView;


//-------------------------------------------------
// constructor. it is NOT added to the parent immediately
//-------------------------------------------------
CTreeItem::CTreeItem():
        m_iImage(0),
        m_hTreeItem(NULL),
        m_fDirty( FALSE )
    {
    m_szItemName.Empty();
    }

//-------------------------------------------------
// remove the item from the ctreectrl
//-------------------------------------------------
BOOL CTreeItem::FRemoveFromTree()
    {
    CTreeCtrl   *pTree = PGetTreeCtrl();
    ASSERT(pTree);
    ASSERT(m_hTreeItem);
    return pTree->DeleteItem( m_hTreeItem );
    }

//-------------------------------------------------
// add the item to the ctreectrl
//-------------------------------------------------
BOOL CTreeItem::FAddToTree( CTreeItem* pParent )
    {
    HTREEITEM hParent = TVI_ROOT;

    // this item should NOT have already been added
    ASSERT( !m_hTreeItem );

    // get the tree control
    CTreeCtrl* pTree = PGetTreeCtrl();
    ASSERT( pTree );
    if ( !pTree ) return FALSE;

    // get the parent's htree item
    if ( pParent )
        {
        hParent = pParent->HGetTreeItem();
        ASSERT( hParent );
        }

    // add this item to the tree
    HTREEITEM hTreeItem = pTree->InsertItem( m_szItemName, hParent );
    ASSERT( hTreeItem );
    if ( !hTreeItem ) return FALSE;

    // set the item's image to be the correct icon
    BOOL f = pTree->SetItemImage( hTreeItem, m_iImage, m_iImage );
    // set the item's private data to point back to the host object
    f = pTree->SetItemData( hTreeItem, (ULONG)this );

    // now set the tree item back into this so we can backtrack later
    m_hTreeItem = hTreeItem;

    // tell the item to update its caption
    UpdateCaption();

    // we always expand the parent after adding something to it
    // and we also alphabetize it
    if ( pParent )
        {
        pTree->SortChildren( hParent );
        pTree->Expand( hParent, TVE_EXPAND );
        }
    else
        {
        // this item is at the root level
        pTree->SortChildren( TVI_ROOT );
        }

    // looks successful to me
    return TRUE;
    }

//-------------------------------------------------
// get the parent item to this tree item
//-------------------------------------------------
CTreeItem* CTreeItem::PGetParent()
    {
    if ( !m_hTreeItem ) return NULL;
    CTreeCtrl   *pTree = PGetTreeCtrl();
    ASSERT(pTree);
    ASSERT(m_hTreeItem);

    // get the parent tree item
    HTREEITEM hParent = pTree->GetParentItem( m_hTreeItem );
    ASSERT( hParent );
    if ( !hParent ) return NULL;

    // return the parent
    return (CTreeItem*)pTree->GetItemData( hParent );
    }

//-------------------------------------------------
// access the name shown in the tree view
//-------------------------------------------------
BOOL CTreeItem::FSetCaption( CString& szCaption )
    {
    CTreeCtrl   *pTree = PGetTreeCtrl();
    ASSERT( szCaption );
    ASSERT( pTree );
    if ( m_hTreeItem )
        return pTree->SetItemText( m_hTreeItem, szCaption );
    else
        return FALSE;
    }

//-------------------------------------------------
// set the image shown in the tree view
//-------------------------------------------------
BOOL CTreeItem::FSetImage( WORD i )
    {
    if ( !m_hTreeItem )
        return FALSE;

    // store away the image index
    m_iImage = i;

    CTreeCtrl   *pTree = PGetTreeCtrl();
    ASSERT( i );
    ASSERT( pTree );
    ASSERT( m_hTreeItem );
    return pTree->SetItemImage( m_hTreeItem, m_iImage, m_iImage );
    }

//-------------------------------------------------
// get the grandparental ctreectrl object
//-------------------------------------------------
CTreeCtrl* CTreeItem::PGetTreeCtrl( void )
    {
    return (CTreeCtrl*)g_pTreeView;
    }

//-------------------------------------------------
WORD CTreeItem::GetChildCount()
    {
    WORD cChildren = 0;

    // loop through the children and count them
    CTreeItem* pChild = GetFirstChild();
    while( pChild )
        {
        // as the great Count Von Count would say.....
        cChildren++;

        // get the next child
        pChild = GetNextChild( pChild );
        }

    // how many where there?
    return cChildren;
    }

//-------------------------------------------------
CTreeItem* CTreeItem::GetFirstChild()
    {
    ASSERT(HGetTreeItem());
    if ( !HGetTreeItem() ) return NULL;

    // get the tree control
    CTreeCtrl* pTree = PGetTreeCtrl();

    // get the first child
    HTREEITEM hTree = pTree->GetChildItem( HGetTreeItem() );

    // if there is no item, don't return anything
    if ( !hTree )
        return NULL;

    // return the object
    return (CTreeItem*)pTree->GetItemData( hTree );
    }

//-------------------------------------------------
CTreeItem* CTreeItem::GetNextChild( CTreeItem* pKid )
    {
    ASSERT(pKid->HGetTreeItem());
    if ( !pKid->HGetTreeItem() ) return NULL;

    // get the tree control
    CTreeCtrl* pTree = PGetTreeCtrl();

    // get the first child
    HTREEITEM hTree = pTree->GetNextSiblingItem( pKid->HGetTreeItem() );

    // if there is no item, don't return anything
    if ( !hTree )
        return NULL;

    // return the object
    return (CTreeItem*)pTree->GetItemData( hTree );
    }

//-------------------------------------------------
void CTreeItem::SetDirty( BOOL fDirty )
    {
    // get the parent item
    CTreeItem* pParent = PGetParent();
    // set the parent dirty
    if ( pParent && fDirty )
        pParent->SetDirty( fDirty );

    // set the dirty flag
    m_fDirty = fDirty;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by KeyRing.rc
//
#define IDD_ABOUTBOX                    100
#define CG_IDS_PHYSICAL_MEM             103
#define CG_IDS_DISK_SPACE               104
#define CG_IDS_DISK_SPACE_UNAVAIL       105
#define IDR_KEYPROP1                    107
#define IDR_MAINFRAME                   128
#define IDR_KEYMANTYPE                  129
#define IDD_CONNECT_SERVER              130
#define IDB_TREEIMAGES                  131
#define IDD_INSTALL_CERTIFICATE         135
#define IDB_KEYIMAGES                   136
#define IDD_KEY_VIEWEDIT                137
#define IDR_KEYPROP                     138
#define IDD_CONFIRM_PASSWORD            139
#define IDD_KEY_DATA_VIEW               140
#define IDD_CHOOSE_IPADDRESS            141
#define IDD_NEW_KEY_INFO                142
#define IDI_ICONINFORMATION             143
#define IDD_DIALOG1                     145
#define IDD_CREATING_NEW_KEY            145
#define IDD_ADNIM_INFO                  146
#define IDD_DEFAULT_CONFIRM             147
#define IDI_ICONQUESTION                148
#define IDR_AVI_CREATING_KEY            149
#define IDD_IMPORT_KEY_PAIR             151
#define IDD_NK_CHOOSE_CA                153
#define IDD_NK_FILE_INFO                154
#define IDD_NK_DN1                      155
#define IDD_NK_KEY_INFO                 157
#define IDD_NK_USER_INFO                158
#define IDD_NK_DN2                      159
#define IDB_KEYWIZ                      160
#define IDD_CERT_MISMATCH               161
#define IDC_CONNECT_ServerName          1000
#define IDC_NEW_KEY_NAME                1002
#define IDC_NEW_KEY_REQUEST_FILE        1003
#define IDC_NEW_KEY_BROWSE              1004
#define IDC_NEW_KEY_BITS                1015
#define IDC_NEW_KEY_ORGANIZATION        1017
#define IDC_NEWKEY_COUNTRY              1017
#define IDC_NEW_KEY_UNIT                1018
#define IDC_NEWKEY_ORG                  1018
#define IDC_NEW_KEY_NETADDRESS          1019
#define IDC_NEWKEY_STATE                1019
#define IDC_NEW_KEY_COUNTRY             1020
#define IDC_NEWKEY_ORGUNIT              1020
#define IDC_NEW_KEY_PASSWORD            1021
#define IDC_NEW_NKKI_PASSWORD           1021
#define IDC_INSTALL_PASSWORD            1022
#define IDC_NEWKEY_LOCALITY             1022
#define IDC_NEW_NKKI_PASSWORD2          1022
#define IDC_INSTALL_BROWSE              1023
#define IDC_NEWKEY_COMMONNAME           1023
#define IDC_INSTALL_CERT_FILE           1024
#define IDC_VIEWKEY_NAME                1025
#define IDC_VIEWKEY_BITS                1026
#define IDC_VIEWKEY_ORG                 1027
#define IDC_VIEWKEY_UNIT                1028
#define IDC_VIEWKEY_NETADDR             1029
#define IDC_VIEWKEY_COUNTRY             1030
#define IDC_VIEWKEY_STATUS              1031
#define IDC_CONFIRM_PASSWORD            1032
#define IDC_VIEWKEY_STATEPROVINCE       1032
#define IDC_VIEWKEY_LOCALITY            1033
#define IDC_BTN_KEYVIEW_NONE            1034
#define IDC_BTN_KEYVIEW_DEFAULT         1035
#define IDC_BTN_KEYVIEW_IPADDR          1036
#define IDC_KEYDATAVIEW_IPADDRESS       1037
#define IDC_BTN_SELECT_IPADDRESS        1039
#define IDC_GROUP_DN                    1040
#define IDC_BROWSE                      1040
#define IDC_GROUP_CONNECTION            1041
#define IDC_STATIC_BITS                 1042
#define IDC_STATIC_ORG                  1043
#define IDC_STATIC_UNIT                 1044
#define IDC_STATIC_NETADDR              1045
#define IDC_STATIC_COUNTRY              1046
#define IDC_STATIC_NAME                 1047
#define IDC_CHOOSER_SERVER_DLG_HELP     1048
#define IDC_STATIC_STATEPROVICE         1048
#define IDC_CHOOSER_HELP_CHOOSE_IP      1048
#define IDC_LIST_IPADDRESSES            1049
#define IDC_STATIC_LOCALITY             1049
#define IDC_HELP_INSTALL_CERTIFICATE    1051
#define IDC_HELP_MORE_NEW_KEY_HELP      1051
#define IDC_BUTTON1                     1052
#define IDC_HELP_CONNECT_SERVER         1052
#define IDC_BROWSE_PRIVATE              1052
#define IDC_BK_CA_PROPERTIES            1052
#define IDC_HOTLINK_CCODES              1052
#define IDC_NEW_KEY_INFO_FILE_PART      1053
#define IDC_DISK_SPACE                  1056
#define IDC_PHYSICAL_MEM                1057
#define IDC_REPDEF_CURRENT              1059
#define IDC_REPDEF_NEW                  1060
#define IDC_STATIC_CREATED              1061
#define IDC_STATIC_EXPIRES              1062
#define IDC_VIEWKEY_CREATED             1063
#define IDC_STATIC_STARTS               1063
#define IDC_VIEWKEY_EXPIRES             1064
#define IDC_VIEWKEY_STARTS              1065
#define IDC_INFO_BASE                   1066
#define IDC_GRINDER_ANIMATION           1067
#define IDC_STATIC_VERIFIER             1068
#define IDC_HELP_CREATE_KEY             1069
#define IDC_BROWSE_CERT                 1070
#define IDC_RADIO1                      1070
#define IDC_NK_CA_FILE_RADIO            1070
#define IDC_CERT_FILE                   1071
#define IDC_RADIO2                      1071
#define IDC_NK_CA_ONLINE_RADIO          1071
#define IDC_PRIVATE_FILE                1072
#define IDC_COMBO1                      1072
#define IDC_NK_CA_ONLINE                1072
#define IDC_EDIT1                       1073
#define IDC_NKUI_USER_NAME              1073
#define IDC_BUTTON2                     1074
#define IDC_NK_CA_BROWSE                1074
#define IDC_NK_INFO_FILENAME            1080
#define IDC_NK_CA_FILE                  1082
#define IDC_NKUI_EMAIL_ADDRESS          1083
#define IDC_NKUI_PHONE_NUMBER           1084
#define IDC_NKKI_NAME                   1085
#define IDC_NKKI_BITS                   1086
#define IDC_MESSAGE                     1087
#define IDC_LIST_REQUEST                1088
#define IDC_LIST_CERTIFICATE            1089
#define IDC_IPA_IPADDRESS               1107
#define IDC_EMAIL_ADDRESS               1108
#define IDC_PHONE_NUMBER                1109
#define IDS_ERR_CONNECT                 1446
#define IDS_MACHINE_LOCAL               1447
#define IDS_SERVER_NONE                 1448
#define IDS_CREATE_KEY_NEW_NAME         1449
#define IDS_CREATE_KEY_YOUR_COMPANY     1450
#define IDS_CREATE_KEY_YOUR_UNIT        1451
#define IDS_CERTIFICATE_FILTER          1452
#define IDS_CREATE_KEY_YOUR_ADDRESS     1453
#define IDS_KEY_DELETE_WARNING          1454
#define IDS_SERVER_COMMIT               1455
#define IDS_ERR_GENERATEPAIR            1456
#define IDS_ERR_WRITEREQUEST            1457
#define IDS_ERR_WRITEKEYS               1458
#define IDS_KEY_STATUS_COMPLETE         1459
#define IDS_KEY_STATUS_INCOMPLETE       1460
#define IDS_KEY_UNKNOWN                 1461
#define IDS_CREATE_KEY_PASSREQUIRED     1462
#define IDS_INCORRECT_PASSWORD          1463
#define IDS_CERT_FILE_EXISTS            1464
#define IDS_REG_SERVER_STORAGE          1465
#define IDS_COMMIT_ERROR                1466
#define IDS_MACHINE_DEFAULT             1467
#define IDS_MACHINE_SELECTED            1468
#define IDS_ERR_INVALID_CERTIFICATE     1469
#define IDS_NEW_KEY_INFO_1              1470
#define IDS_NEW_KEY_INFO_2              1471
#define IDS_ABOUT_MAIN                  1472
#define IDS_ABOUT_SECONDARY             1473
#define IDS_HTTP_COMM_ERROR             1474
#define IDS_NO_VIRT_ROOTS               1475
#define IDS_FOUND_KEYSET_KEYS           1476
#define IDS_UNTITLED                    1477
#define IDS_IMPORT_KEYSET_ERROR         1478
#define IDS_LOCALIZED_DEFAULT_COUNTRY_CODE 1479
#define IDS_GENERATE_KEY_ERROR          1480
#define IDS_INVALID_KEY                 1481
#define IDS_CREATE_KEY_YOUR_STATE       1482
#define IDS_CREATE_KEY_YOUR_LOCALITY    1483
#define IDS_CRED_PASS_ERROR             1484
#define IDS_CRED_PACK_ERROR             1485
#define IDS_KEY_STATUS_EXPIRED          1486
#define IDS_KEY_STATUS_EXPIRES_SOON     1487
#define IDS_EXPIRETIME_FORMAT           1488
#define IDS_RENEW_KEY_INFO_2            1489
#define IDS_NEW_KEY_INFO_BASE           1490
#define IDS_RENEW_KEY_INFO_BASE         1491
#define IDS_CREATING_ANIMATION          1492
#define IDS_CRACKING_ERROR              1493
#define IDS_IMPORT_KEYSET_PRIV_ERROR    1494
#define IDS_IMPORT_KEYSET_PUB_ERROR     1495
#define IDS_IMPORT_KEYSET_PASS_ERROR    1496
#define IDS_KEY_FILE_TYPE               1497
#define IDS_KEY_FILE_INVALID            1498
#define IDS_CERT_FILE_TYPE              1499
#define IDS_REG_USER_INFO               1499
#define IDS_KEYFILE_WARNING             1500
#define IDS_PRIVATE_FILE_TYPE           1501
#define ID_SERVER_COMMIT_NOW            2771
#define ID_KEY_CREATE_REQUEST           2772
#define ID_KEY_INSTALL_NEW              2773
#define ID_KEY_DELETE                   2774
#define ID_SERVER_CONNECT               2775
#define ID_KEY_ACTIVATE                 2776
#define ID_KEY_DEACTIVATE               2777
#define ID_KEY_INSTALL_CERTIFICATE      2778
#define ID_KEY_PROPERTIES               2780
#define ID_KEYPROP_PASTE                2781
#define ID_MAIN_HELP                    2784
#define ID_SERVER_DISCONNECT            2786
#define ID_KEY_SAVE_REQUEST             2787
#define ID_KEYPROP_WRITEKEYREQUEST      2788
#define ID_KEY_CREATE_RENEWAL           2789
#define ID_KEY_IMPORT                   2791
#define ID_KEY_EXPORT                   2792
#define ID_KEY_EXPORT_BACKUP            2793
#define ID_KEY_EXPORT_KEYSET            2794
#define ID_KEY_IMPORT_BACKUP            2795
#define ID_KEY_IMPORT_KEYSET            2796
#define ID_TEST_DATA                    2797
#define ID_SERVPROP_CUT                 2798
#define ID_PROPERTIES                   2799
#define IDS_NEW_CREATE_NEW              2801
#define IDS_SelectConnectMsg            2802
#define IDS_ADDONS_LOCATION             2803
#define ID_HELPTOPICS                   2803
#define IDS_NO_SERVICE_MODS             2804
#define IDS_REQUEST_FILTER              2805
#define IDS_SERVER_INFO_STRING          2806
#define IDS_CA_LOCATION                 2807
#define IDS_LOAD_CA_ERR                 2808
#define IDS_DEFAULT_REQUEST_FILE        2809
#define IDS_GEN_KEYPAIR_ERR             2810
#define IDS_GRIND_GENERATING            2811
#define IDS_GRIND_SUBMITTING            2812
#define IDS_GRIND_SUCCESS               2813
#define IDS_GRIND_DELAYED               2814
#define IDS_GRIND_FILE                  2815
#define IDS_GRIND_ONLINE_FAILURE        2816
#define IDS_PASSWORD_ERROR              2817
#define IDS_GRIND_RESUBMITTING          2818
#define IDS_ILLEGAL_DN_CHARS            2819
#define IDS_BADCHARMSG                  2820
#define IDS_GENERATE_KEY_TITLE          2821
#define IDS_RESTART_PROMPT              2822
#define IDS_IO_ERROR                    2823
#define IDS_BAD_FILE_NAME               2824
#define IDS_FILE_EXISTS                 2825
#define IDS_CHOOSE_COMPUTER             2826
#define IDS_TITLE_CREATE_WIZ            2827
#define IDS_TITLE_RENEW                 2828
#define IDS_INVALID_CA_REQUEST_OLD      2829
#define IDS_CA_NO_INTERFACE             2830
#define IDS_CA_INVALID                  2831
#define IDS_CA_FACTORY_ERR              2832
#define IDS_CA_DENIED                   2833
#define IDS_CA_ERROR                    2834
#define IDS_HELPLOC_KEYRINGHELP         2835
#define IDS_ERR_INSTALLING_CERT         2836
#define IDS_TOTALLY_ILLEGAL_CHARS       2837
#define IDS_CERTERR_INVALID_CERTIFICATE 2838
#define IDS_CERTERR_MISMATCHED_CERT     2839
#define IDS_CERTERR_SCHANNEL_ERR        2840
#define IDS_CERTERROR_PACKAGELOAD_ERROR 2841
#define IDS_CERTERROR_BADPASSWORD       2842
#define IDS_CERTERR_LOMEM               2843
#define IDS_CERTERR_SCHNL_GENERIC       2844
#define EDS_CERTERR_SCHNL_BAD_INIT      2845
#define IDS_OPEN_PRIVATE_KEY            2846
#define IDS_OPEN_PUBLIC_KEY             2847
#define IDS_APP_EXTENSION               2848
#define IDS_APP_EXE_PATH                2849
#define IDS_ERR_GENERIC_ERRCODE         2850

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        164
#define _APS_NEXT_COMMAND_VALUE         2804
#define _APS_NEXT_CONTROL_VALUE         1093
#define _APS_NEXT_SYMED_VALUE           110
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\wizsheet.cpp ===
// WizSheet.cpp : implementation file
//

#include "stdafx.h"
#include "keyring.h"
#include "WizSheet.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CWizardSheet

IMPLEMENT_DYNAMIC(CWizardSheet, CPropertySheet)

//---------------------------------------------------------------------------
CWizardSheet::CWizardSheet()
	:CPropertySheet()
{
short booger;
	booger = 1;
	booger += 2;
	// That makes three boogers.
}

//---------------------------------------------------------------------------
CWizardSheet::CWizardSheet(UINT nIDCaption, CWnd* pParentWnd, UINT iSelectPage)
	:CPropertySheet(nIDCaption, pParentWnd, iSelectPage)
{
}

//---------------------------------------------------------------------------
CWizardSheet::CWizardSheet(LPCTSTR pszCaption, CWnd* pParentWnd, UINT iSelectPage)
	:CPropertySheet(pszCaption, pParentWnd, iSelectPage)
{
}

//---------------------------------------------------------------------------
CWizardSheet::~CWizardSheet()
{
}


BEGIN_MESSAGE_MAP(CWizardSheet, CPropertySheet)
	//{{AFX_MSG_MAP(CWizardSheet)
		// NOTE - the ClassWizard will add and remove mapping macros here.
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CWizardSheet message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\setup\dll\main.cpp ===
// main routine for the dll


void main ( void )
	{
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\setup\dll\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by setup.rc
//
#define IDB_ALL_BTN                     101
#define IDB_CUST_BTN                    102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\linkchk\athendlg.cpp ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        athendlg.cpp

   Abstract:

        CAthenicationDialog dialog implementation.

   Author:

        Michael Cheuk (mcheuk)

   Project:

        Link Checker

   Revision History:

--*/

#include "stdafx.h"
#include "linkchk.h"
#include "athendlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CAthenicationDialog::CAthenicationDialog(
    CWnd* pParent /*=NULL*/
    ): 
/*++

Routine Description:

    Constructor.

Arguments:

    pParent - Pointer to parent CWnd

Return Value:

    N/A

--*/
CDialog(CAthenicationDialog::IDD, pParent)
{
	//{{AFX_DATA_INIT(CAthenicationDialog)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

} // CAthenicationDialog::CAthenicationDialog


void 
CAthenicationDialog::DoDataExchange(
    CDataExchange* pDX
    )
/*++

Routine Description:

    Called by MFC to change/retrieve dialog data

Arguments:

    pDX - 

Return Value:

    N/A

--*/
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAthenicationDialog)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP

} // CAthenicationDialog::DoDataExchange


BEGIN_MESSAGE_MAP(CAthenicationDialog, CDialog)
	//{{AFX_MSG_MAP(CAthenicationDialog)
		// NOTE: the ClassWizard will add message map macros here
	//}}AFX_MSG_MAP
	ON_BN_CLICKED(IDC_ATHENICATION_OK, CDialog::OnOK)
	ON_BN_CLICKED(IDC_ATHENICATION_CANCEL, CDialog::OnCancel)
END_MESSAGE_MAP()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\keyring\wizsheet.h ===
// WizSheet.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CWizardSheet

class CWizardSheet : public CPropertySheet
{
	DECLARE_DYNAMIC(CWizardSheet)

// Construction
public:
	CWizardSheet();
	CWizardSheet(UINT nIDCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);
	CWizardSheet(LPCTSTR pszCaption, CWnd* pParentWnd = NULL, UINT iSelectPage = 0);

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWizardSheet)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CWizardSheet();

	// Generated message map functions
protected:
	//{{AFX_MSG(CWizardSheet)
		// NOTE - the ClassWizard will add and remove member functions here.
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\linkchk\athendlg.h ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        athendlg.h

   Abstract:

        CAthenicationDialog dialog declaration.

   Author:

        Michael Cheuk (mcheuk)

   Project:

        Link Checker

   Revision History:

--*/

#ifndef _ATHENDLG_H_
#define _ATHENDLG_H_

//---------------------------------------------------------------------------
// Athenication dialog class
//
class CAthenicationDialog : public CDialog
{

// Construction
public:
	CAthenicationDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CAthenicationDialog)
	enum { IDD = IDD_ATHENICATION };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAthenicationDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAthenicationDialog)
		// NOTE: the ClassWizard will add member functions here
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#endif // _ATHENDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\linkchk\appdlg.h ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        appdlg.h

   Abstract:

        CAppDialog dialog class declaration. This is the base clas for 
        the main dialog. This class resposible for adding "about.." to
        system menu and application icon.

   Author:

        Michael Cheuk (mcheuk)

   Project:

        Link Checker

   Revision History:

--*/

#ifndef _APPDLG_H_
#define _APPDLG_H_

//---------------------------------------------------------------------------
// This is the base clas for the main dialog. This class resposible for 
// adding "about.." to system menu and application icon.
//
class CAppDialog : public CDialog
{

// Construction
public:
	CAppDialog(UINT nIDTemplate, CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CAppDialog)
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAppDialog)
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CAppDialog)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#endif // _APPDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\linkchk\browser.h ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        browser.h

   Abstract:

         Hard coded available browser & language emulation. This
         should be read from browser.ini file.

   Author:

        Michael Cheuk (mcheuk)

   Project:

        Link Checker

   Revision History:

--*/

#ifndef _BROWSER_H_
#define _BROWSER_H_

#include "useropt.h"

//------------------------------------------------------------------
// Browsers Available
//
const CBrowserInfo BrowsersAvailable_c[] = 
{
	CBrowserInfo(_T("Microsoft Internet Explorer 1.5"),
		_T("Mozilla/1.22 (compatible; MSIE 1.5; Windows NT)"), FALSE),

	CBrowserInfo(_T("Microsoft Internet Explorer 2.0"),
		_T("Mozilla/1.22 (compatible; MSIE 2.0; Windows NT)"), FALSE),

	CBrowserInfo(_T("Microsoft Internet Explorer 3.0"),
		_T("Mozilla/2.0 (compatible; MSIE 3.0; Windows NT)"), TRUE),
	
	CBrowserInfo(_T("Netscape 2.0"),
		_T("Mozilla/2.0 (WinNT; I)"), FALSE),

	CBrowserInfo(_T("Netscape 3.0"),
		_T("Mozilla/3.0Gold (WinNT; I)"), FALSE),

	CBrowserInfo(_T("Oracle 1.5"), 
		_T("Mozilla/2.01 (Compatible) Oracle(tm) PowerBrowser(tm)/1.0a"), FALSE)
};
const int iNumBrowsersAvailable_c = sizeof(BrowsersAvailable_c) / sizeof(CBrowserInfo);

//------------------------------------------------------------------
// Languages Available
//
const CLanguageInfo LanguagesAvailable_c[] = 
{
	CLanguageInfo(_T("English"), _T("en"), TRUE)
};
const int iNumLanguagesAvailable_c = sizeof(LanguagesAvailable_c) / sizeof(CLanguageInfo);

#endif // _BROWSER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\linkchk\appdlg.cpp ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        appdlg.cpp

   Abstract:

        CAppDialog dialog class implementation. This is the base clas for 
        the main dialog. This class resposible for adding "about.." to
        system menu and application icon.

        CAboutDialog dialog class declaration/implementation.

   Author:

        Michael Cheuk (mcheuk)

   Project:

        Link Checker

   Revision History:

--*/

#include "stdafx.h"
#include "resource.h"
#include "appdlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//---------------------------------------------------------------------------
// CAboutDlg dialog
//

// About dialog class
class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

}; // class CAboutDlg


CAboutDlg::CAboutDlg(
    ) : 
/*++

Routine Description:

    Constructor.

Arguments:

    pParent - Pointer to parent CWnd

Return Value:

    N/A

--*/
CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void 
CAboutDlg::DoDataExchange(
    CDataExchange* pDX
    )
/*++

Routine Description:

    Called by MFC to change/retrieve dialog data

Arguments:

    pDX - 

Return Value:

    N/A

--*/
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
	ON_BN_CLICKED(IDC_ABOUT_OK, CDialog::OnOK)
END_MESSAGE_MAP()

//---------------------------------------------------------------------------
// CAppDialog dialog
//

CAppDialog::CAppDialog(
    UINT nIDTemplate, 
    CWnd* pParent /*=NULL*/
    ) : 
/*++

Routine Description:

    Constructor.

Arguments:

    nIDTemplate - dialog template resource ID
    pParent - pointer to parent CWnd

Return Value:

    N/A

--*/
CDialog(nIDTemplate, pParent)
{
	//{{AFX_DATA_INIT(CAppDialog)
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}


BEGIN_MESSAGE_MAP(CAppDialog, CDialog)
	//{{AFX_MSG_MAP(CAppDialog)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

//---------------------------------------------------------------------------
// CAppDialog message handlers
//

BOOL 
CAppDialog::OnInitDialog(
)
/*++

Routine Description:

    WM_INITDIALOG message handler

Arguments:

    N/A

Return Value:

    BOOL - TRUE if sucess. FALSE otherwise.

--*/
{
	CDialog::OnInitDialog();

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	CString strAboutMenu;
	strAboutMenu.LoadString(IDS_ABOUTBOX);
	if (!strAboutMenu.IsEmpty())
	{
		pSysMenu->AppendMenu(MF_SEPARATOR);
		pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	
	// TODO: Add extra initialization here
	
	return TRUE;  // return TRUE  unless you set the focus to a control

} // CAppDialog::OnInitDialog


void 
CAppDialog::OnSysCommand(
    UINT nID, 
    LPARAM lParam
    )
/*++

Routine Description:

    WM_SYSCOMMAND message handler

Arguments:

    nID - 
    lParam -

Return Value:

    N/A

--*/
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}

} // CAppDialog::OnSysCommand


void 
CAppDialog::OnPaint(
    ) 
/*++

Routine Description:

    WM_PAINT message handler.
    If you add a minimize button to your dialog, you will need the code below
    to draw the icon.  For MFC applications using the document/view model,
    this is automatically done for you by the framework.


Arguments:

    N/A

Return Value:

    N/A

--*/
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}

}  // CAppDialog::OnPaint


HCURSOR CAppDialog::OnQueryDragIcon()
/*++

Routine Description:

    The system calls this to obtain the cursor to display while the user drags
    the minimized window.


Arguments:

    N/A

Return Value:

    HCURSOR - 

--*/
{
	return (HCURSOR) m_hIcon;

} // CAppDialog::OnQueryDragIcon
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\linkchk\cmdline.cpp ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        cmdline.cpp

   Abstract:

        Command line class implementation. This class takes care of command line
		parsing and validation. And, it will add the user options to global
		CUserOptions object.

   Author:

        Michael Cheuk (mcheuk)

   Project:

        Link Checker

   Revision History:

--*/

#include "stdafx.h"
#include "cmdline.h"

#include "resource.h"
#include "lcmgr.h"
#include "iisinfo.h"
#include "afxpriv.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CCmdLine::CCmdLine(
	)
/*++

Routine Description:

    Constructor.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    m_iInstance = -1;
	m_fInvalidParam = FALSE;

} // CCmdLine::CCmdLine


BOOL 
CCmdLine::CheckAndAddToUserOptions(
	)
/*++

Routine Description:

    Validate the command line paramters and add them to global CUserOptions object

Arguments:

    N/A

Return Value:

    BOOL - TRUE if sucess. FALSE otherwise

--*/
{
    // Do we have any invalid parameters so far?
	if(m_fInvalidParam)
	{
        ::MessageBeep(MB_ICONEXCLAMATION);

		CDialog dlg(IDD_USAGE);
		dlg.DoModal();

		return FALSE;
	}

    // Is the user options valid ?
	BOOL fURL = !m_strURL.IsEmpty();
	BOOL fDirectories = !m_strAlias.IsEmpty() && !m_strPath.IsEmpty() && !m_strHostName.IsEmpty();
	BOOL fInstance = !m_strHostName.IsEmpty() && m_iInstance != -1;

    //  Command line: linkchk -u URL
	if(fURL && !fDirectories && !fInstance)
	{
		GetLinkCheckerMgr().GetUserOptions().AddURL(m_strURL);
		return TRUE;
	}
    //  Command line: linkchk -s ServerName -a VirtualDirectoryAlias -p VirtualDirectoryPath
	else if(!fURL && fDirectories && !fInstance)
	{
		GetLinkCheckerMgr().GetUserOptions().AddDirectory(CVirtualDirInfo(m_strAlias, m_strPath));
		GetLinkCheckerMgr().GetUserOptions().SetHostName(m_strHostName);
		return TRUE;
	}
    //  Command line: linkchk -s ServerName -i InstanceNumber
	else if(!fURL && !fDirectories && fInstance)
	{
		GetLinkCheckerMgr().GetUserOptions().SetHostName(m_strHostName);
		return QueryAndAddDirectories();
	}
    else
    {
        ::MessageBeep(MB_ICONEXCLAMATION);

		CDialog dlg(IDD_USAGE);
		dlg.DoModal();

		return FALSE;
    }

} // CCmdLine::CheckAndAddToUserOptions


void 
CCmdLine::ParseParam(
	TCHAR chFlag, 
	LPCTSTR lpszParam
	)
/*++

Routine Description:

    Called by CLinkCheckApp for each parameters.

Arguments:

    chFlag - parameter flag
    lpszParam - value

Return Value:

    N/A

--*/
{
	// It is invalid to have a flag without any parameters
	if(lpszParam == NULL)
	{
		m_fInvalidParam = TRUE;
		return;
	}

	switch(chFlag)
	{
	case _TCHAR('a'):
		m_strAlias = lpszParam;
		break;

	case _TCHAR('h'):
		m_strHostName = lpszParam;
		break;

	case _TCHAR('i'):
		m_iInstance = _ttoi(lpszParam);
		break;

	case _TCHAR('u'):
		m_strURL = lpszParam;
		break;

	case _TCHAR('p'):
		m_strPath = lpszParam;

	default: // unknown flag
		m_fInvalidParam = FALSE;
	}

} // CCmdLine::ParseParam


BOOL
CCmdLine::QueryAndAddDirectories(
	)
/*++

Routine Description:

    Query the metabase for server/instance directories and 
    add them to the global CUserOptions object

Arguments:

    N/A

Return Value:

    BOOL - TRUE if sucess. FALSE otherwise

--*/
{

	USES_CONVERSION; // for A2W

    // Get the server info
	LPIIS_INSTANCE_INFO_1 lpInfo = NULL;
    NET_API_STATUS err = IISGetAdminInformation(
                                A2W((LPCSTR)m_strHostName),
                                1,
                                INET_HTTP_SVC_ID,
                                m_iInstance,
                                (LPBYTE*)&lpInfo
                                );

	if(err != ERROR_SUCCESS)
	{
		AfxMessageBox(IDS_IISGETADMININFORMATION_ERROR);
		return FALSE;
	}
	
    // Do we have any virtual directories ?
    if(lpInfo->VirtualRoots == NULL)
    {
        AfxMessageBox(IDS_IIS_VIRTUALROOT_NOT_EXIST);
        return FALSE;
    }

    // Get the virutal directory info
	_INET_INFO_VIRTUAL_ROOT_ENTRY_1* pVRoot = NULL;

	for(DWORD i=0; i<lpInfo->VirtualRoots->cEntries; i++)
    {
		pVRoot = &(lpInfo->VirtualRoots->aVirtRootEntry[i]);
		GetLinkCheckerMgr().GetUserOptions().
			AddDirectory(CVirtualDirInfo(pVRoot->pszRoot, pVRoot->pszDirectory));
	}

	return TRUE;

} // CCmdLine::QueryAndAddDirectories
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\linkchk\cmdline.h ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        cmdline.h

   Abstract:

        Command line class declarations. This class takes care of command line
		parsing and validation. And, it will add the user options to global
		CUserOptions object.

   Author:

        Michael Cheuk (mcheuk)

   Project:

        Link Checker

   Revision History:

--*/

#ifndef _CMDINFO_H_
#define _CMDINFO_H_

#include "lcmgr.h"

//---------------------------------------------------------------------------
// Command line class. It accepts 3 valid set of parameters
//  1. linkchk -s ServerName -i InstanceNumber
//  2. linkchk -s ServerName -a VirtualDirectoryAlias -p VirtualDirectoryPath
//  3. linkchk -u URL
//
class CCmdLine
{

// Public interfaces
public:

	// Constructor
	CCmdLine();

	// Validate the command line paramters and add them to global CUserOptions object
	BOOL CheckAndAddToUserOptions();

    // Called by CLinkCheckApp for each parameters
	void ParseParam(
		TCHAR chFlag,       // parameter flag
		LPCTSTR lpszParam   // value
		);

// Protected funtions
protected:

    // Query the metabase for server/instance directories and 
    // add them to the global CUserOptions object
	BOOL QueryAndAddDirectories();

// Protected members
protected:

	CString m_strHostName;      // hostname (eg. localhost)
	CString m_strAlias;         // virtual directory alias
	CString m_strPath;          // virtual directory path
	
	int m_iInstance;            // server instance

	CString m_strURL;           // URL path

	BOOL m_fInvalidParam;       // Is parameters invalid?

}; // class CCmdLine

#endif // _CMDINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\linkchk\inetapi.h ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        inetapi.h

   Abstract:

        wininet.dll wrapper class declaration.

   Author:

        Michael Cheuk (mcheuk)

   Project:

        Link Checker

   Revision History:

--*/

#ifndef _INETAPI_H_
#define _INETAPI_H_

#include <windows.h>
#include <wininet.h>

//------------------------------------------------------------------
// wininet.dll entry points definitons
typedef
INTERNETAPI
HINTERNET
(WINAPI *
pfnInternetOpenA)(
    IN LPCSTR lpszAgent,
    IN DWORD dwAccessType,
    IN LPCSTR lpszProxy OPTIONAL,
    IN LPCSTR lpszProxyBypass OPTIONAL,
    IN DWORD dwFlags
    );

typedef
INTERNETAPI
INTERNET_STATUS_CALLBACK
(WINAPI *
pfnInternetSetStatusCallback)(
    IN HINTERNET hInternet,
    IN INTERNET_STATUS_CALLBACK lpfnInternetCallback
    );

typedef
INTERNETAPI
HINTERNET
(WINAPI *
pfnInternetConnectA)(
    IN HINTERNET hInternet,
    IN LPCSTR lpszServerName,
    IN INTERNET_PORT nServerPort,
    IN LPCSTR lpszUserName OPTIONAL,
    IN LPCSTR lpszPassword OPTIONAL,
    IN DWORD dwService,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );

typedef
INTERNETAPI
HINTERNET
(WINAPI *
pfnHttpOpenRequestA)(
    IN HINTERNET hConnect,
    IN LPCSTR lpszVerb,
    IN LPCSTR lpszObjectName,
    IN LPCSTR lpszVersion,
    IN LPCSTR lpszReferrer OPTIONAL,
    IN LPCSTR FAR * lplpszAcceptTypes OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );

typedef
INTERNETAPI
BOOL
(WINAPI *
pfnHttpAddRequestHeadersA)(
    IN HINTERNET hRequest,
    IN LPCSTR lpszHeaders,
    IN DWORD dwHeadersLength,
    IN DWORD dwModifiers
    );

typedef
INTERNETAPI
BOOL
(WINAPI *
pfnHttpSendRequestA)(
    IN HINTERNET hRequest,
    IN LPCSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN LPVOID lpOptional OPTIONAL,
    IN DWORD dwOptionalLength
    );

typedef
INTERNETAPI
BOOL
(WINAPI *
pfnHttpQueryInfoA)(
    IN HINTERNET hRequest,
    IN DWORD dwInfoLevel,
    IN OUT LPVOID lpBuffer OPTIONAL,
    IN OUT LPDWORD lpdwBufferLength,
    IN OUT LPDWORD lpdwIndex OPTIONAL
    );

typedef
INTERNETAPI
BOOL
(WINAPI *
pfnInternetCloseHandle)(
    IN HINTERNET hInternet
    );

typedef
INTERNETAPI
BOOL
(WINAPI *
pfnInternetReadFile)(
    IN HINTERNET hFile,
    IN LPVOID lpBuffer,
    IN DWORD dwNumberOfBytesToRead,
    OUT LPDWORD lpdwNumberOfBytesRead
    );

typedef
INTERNETAPI
BOOL
(WINAPI *
pfnInternetCrackUrlA)(
    IN LPCSTR lpszUrl,
    IN DWORD dwUrlLength,
    IN DWORD dwFlags,
    IN OUT LPURL_COMPONENTS lpUrlComponents
    );

typedef
INTERNETAPI
BOOL
(WINAPI *
pfnInternetCombineUrlA)(
    IN LPCSTR lpszBaseUrl,
    IN LPCSTR lpszRelativeUrl,
    OUT LPSTR lpszBuffer,
    IN OUT LPDWORD lpdwBufferLength,
    IN DWORD dwFlags
    );

typedef
INTERNETAPI
HINTERNET
(WINAPI *
pfnInternetOpenUrlA)(
    IN HINTERNET hInternet,
    IN LPCSTR lpszUrl,
    IN LPCSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN DWORD dwFlags,
    IN DWORD dwContext
    );

#define LOAD_ENTRY( hMod, Name )  \
(##Name = (pfn##Name) GetProcAddress( (hMod), #Name ))

//------------------------------------------------------------------
// wininet.dll wrapper class
class CWininet
{

// Public funtions
public:

	// Constructor
	~CWininet();
	
	// Destructor
	CWininet();

	// Load wininet.dll
	BOOL Load();

	// Is wininet.dll loaded in memory?
	static BOOL IsLoaded() 
	{
		return (sm_hWininet != NULL);
	}

	// Get the wininet.dll static HMODULE
	static HMODULE GetWininetModule()
	{
		return sm_hWininet;
	}

	// Static wininet.dll API
    static pfnInternetOpenA              InternetOpenA;
    static pfnInternetSetStatusCallback  InternetSetStatusCallback;
    static pfnInternetConnectA           InternetConnectA;
    static pfnHttpOpenRequestA           HttpOpenRequestA;
    static pfnHttpAddRequestHeadersA     HttpAddRequestHeadersA;
    static pfnHttpSendRequestA           HttpSendRequestA;
    static pfnHttpQueryInfoA             HttpQueryInfoA;
    static pfnInternetCloseHandle        InternetCloseHandle;
    static pfnInternetReadFile           InternetReadFile;
	static pfnInternetCrackUrlA			 InternetCrackUrlA;
	static pfnInternetCombineUrlA		 InternetCombineUrlA;
	static pfnInternetOpenUrlA			 InternetOpenUrlA;


// Protected members
protected:
	
	// Static wininet.dll HMODULE
	static HMODULE sm_hWininet;

	// Static instance count
	static int sm_iInstanceCount;

}; // class CWininet

#endif // _INETAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\linkchk\enumdir.cpp ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        enumdir.cpp

   Abstract:

        Directory enumerations object implementation. Caller instantiates a instance
        of this object with a root directory path. The object will return all the
        sibbling files as a URL.

   Author:

        Michael Cheuk (mcheuk)

   Project:

        Link Checker

   Revision History:

--*/

#include "stdafx.h"
#include "enumdir.h"

#include "lcmgr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CEnumerateDirTree::CEnumerateDirTree(
	CVirtualDirInfo DirInfo
	)
/*++

Routine Description:

    Constructor.

Arguments:

    DirInfo - // root virtual directory to start with

Return Value:

    N/A

--*/
{
	m_hFind = INVALID_HANDLE_VALUE;

	try
	{
		m_VirtualDirInfoList.AddTail(DirInfo);
	}
	catch(CMemoryException* pEx)
	{
		pEx->Delete();
		TRACE(_T("CEnumerateDirTree::CEnumerateDirTree() - fail to add to VirtualDirInfoList\n"));
	}

} // CEnumerateDirTree::CEnumerateDirTree


CEnumerateDirTree::~CEnumerateDirTree(
	)
/*++

Routine Description:

    Destructor.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
	if(m_hFind != INVALID_HANDLE_VALUE)
	{
		FindClose(m_hFind);
	}

} // CEnumerateDirTree::~CEnumerateDirTree


BOOL 
CEnumerateDirTree::Next(
	CString& strURL
	)
/*++

Routine Description:

    Get the next URL

Arguments:

    N/A

Return Value:

    N/A

--*/
{
	WIN32_FIND_DATA FindData;

	// Loop if 1. the find handle is valid
	//		or 2. the directory stack is not empty
	while(m_hFind != INVALID_HANDLE_VALUE || m_VirtualDirInfoList.GetCount() > 0)
	{
		// If we do not have a valid handle
		if(m_hFind == INVALID_HANDLE_VALUE)
		{
			// get the dir from the stack
			m_VirtualDirInfo = m_VirtualDirInfoList.GetHead();
			m_VirtualDirInfoList.RemoveHead();

			if(SetCurrentDirectory(m_VirtualDirInfo.GetPath()))
			{
				// Find the first one from the new dir
				m_hFind = FindFirstFile(_T("*.*"), &FindData);
			}
		}
		else
		{
			if(!FindNextFile(m_hFind, &FindData))
			{
				FindClose(m_hFind);
				m_hFind = INVALID_HANDLE_VALUE;
			}
		}

		// If we find a valid file
		if(m_hFind != INVALID_HANDLE_VALUE)
		{
			// It is a directory
			if(FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
			{
				// It is a valid directory
				if(FindData.cFileName != _tcsstr(FindData.cFileName, _T("..\0")) &&
					FindData.cFileName != _tcsstr(FindData.cFileName, _T(".\0")) )

				{
					CVirtualDirInfo NewDirInfo;

					NewDirInfo.SetAlias( m_VirtualDirInfo.GetAlias() + FindData.cFileName + _TCHAR('/') );
					NewDirInfo.SetPath( m_VirtualDirInfo.GetPath() + FindData.cFileName + _TCHAR('\\') );
					
					m_VirtualDirInfoList.AddTail(NewDirInfo);
				}
			}
			// It is a file
			else
			{
				strURL = _T("http://") + GetLinkCheckerMgr().GetUserOptions().GetHostName() + m_VirtualDirInfo.GetAlias() + FindData.cFileName;

				return TRUE;
			}
		}
	}

	return FALSE;

} // CEnumerateDirTree::Next
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\linkchk\errlog.h ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        errlog.h

   Abstract:

        Error logging object declarations. This object will log the link
        checking error according to the user options (CUserOptions)

   Author:

        Michael Cheuk (mcheuk)

   Project:

        Link Checker

   Revision History:

--*/

#ifndef _ERRLOG_H_
#define _ERRLOG_H_

//---------------------------------------------------------------------------
// Forward declaration
//
class CLink;

//---------------------------------------------------------------------------
// Error logging class
//
class CErrorLog
{

// Public interfaces
public:

    // Destructor
	~CErrorLog();

    // Create object
	BOOL Create();

    // Write to log
	void Write(
        const CLink& link
        );

    // Set the current browser name
	void SetBrowser(
        const CString& strBrowser
        )
	{
		m_strBrowser = strBrowser;
	}

    // Set the current language name
	void SetLanguage(
        const CString& strLanguage
        )
	{
		m_strLanguage = strLanguage;
	}

    // Write the log header & footer
	void WriteHeader();
	void WriteFooter();

// Protected members
protected:

	CFile m_LogFile; // log file object

	CString m_strBrowser;   // current browser name
	CString m_strLanguage;  // current language name

}; // class CErrorLog

#endif // _ERRLOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\linkchk\enumdir.h ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        enumdir.h

   Abstract:

        Directory enumerations object declarations. Caller instantiates a instance
        of this object with a root directory path. The object will return all the
        sibbling files as a URL.

   Author:

        Michael Cheuk (mcheuk)

   Project:

        Link Checker

   Revision History:

--*/

#ifndef _ENUMDIR_H_
#define _ENUMDIR_H_

#include "useropt.h"

//---------------------------------------------------------------------------
// Directory enumeration class
//
class CEnumerateDirTree
{

// Public funtions
public:

    // Constructor
	CEnumerateDirTree(
        CVirtualDirInfo DirInfo // root virtual directory to start with
        );

    // Desctructor
	~CEnumerateDirTree();

    // Get the next URL
	BOOL Next(
        CString& strURL
        );

// Protected members
protected:
	
	HANDLE m_hFind; // Win32 FindFile handle

	CVirtualDirInfo m_VirtualDirInfo;         // current virtual directory enumerating
	CVirtualDirInfoList m_VirtualDirInfoList; // child directoris left to enumerate

}; // class CEnumerateDirTree

#endif // _ENUMDIR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\linkchk\errlog.cpp ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        errlog.cpp

   Abstract:

        Error logging object implementation. This object will log the link
        checking error according to the user options (CUserOptions)

   Author:

        Michael Cheuk (mcheuk)

   Project:

        Link Checker

   Revision History:

--*/

#include "stdafx.h"
#include "errlog.h"

#include "lcmgr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


// Constant string (TODO: put this in resource)
const CString strHeaderText_c(_T("Start Link Checker"));
const CString strFooterText_c(_T("End Link Checker"));
const CString strWininetError_c(_T("Internet Error"));

CErrorLog::~CErrorLog(
    )
/*++

Routine Description:

    Destructor.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
	if(m_LogFile.m_hFile != CFile::hFileNull)
	{
		try
		{
			m_LogFile.Close();
		}
		catch(CFileException* pEx)
		{
			ASSERT(FALSE);
			pEx->Delete();
		}
	}

} // CErrorLog::~CErrorLog


BOOL 
CErrorLog::Create(
	)
/*++

Routine Description:

    Create this object. You must call this before using CErrorLog

Arguments:

    N/A

Return Value:

    BOOL - TRUE if sucess. FALSE otherwise

--*/
{
    // Get the user input log filename
	const CString& strLogFilename = GetLinkCheckerMgr().GetUserOptions().GetLogFilename();

    // Create the file 
	if(GetLinkCheckerMgr().GetUserOptions().IsLogToFile() &&
        !strLogFilename.IsEmpty())
	{
		if(m_LogFile.Open(
			strLogFilename, 
			CFile::modeCreate | CFile::modeNoTruncate | 
            CFile::shareDenyWrite | CFile::modeWrite))
		{
			try
			{
				m_LogFile.SeekToEnd();
			}
			catch(CFileException* pEx)
			{
				ASSERT(FALSE);
				pEx->Delete();
				return FALSE;
			}

			return TRUE;
		}
		else
		{
			return FALSE;
		}

	}

	return TRUE;

} // CErrorLog::Create


void 
CErrorLog::Write(
	const CLink& link)
/*++

Routine Description:

    Write to log

Arguments:

    N/A

Return Value:

    N/A

--*/
{
	// Make sure the link is invalid
	ASSERT(link.GetState() == CLink::eInvalidHTTP || 
		link.GetState() == CLink::eInvalidWininet);

	if(m_LogFile.m_hFile != CFile::hFileNull)
	{
		CString strDateTime = link.GetTime().Format("%x\t%X");

		CString strLog;
		
		if(link.GetState() == CLink::eInvalidHTTP)
		{
			strLog.Format(_T("%s\t%s\t%s\t%s\t%d\t%s\t%s\n"), 
				link.GetBase(), m_strBrowser,
				m_strLanguage, strDateTime, 
				link.GetStatusCode(), link.GetStatusText(), link.GetRelative());
		}
		else if(link.GetState() == CLink::eInvalidWininet)
		{
			strLog.Format(_T("%s\t%s\t%s\t%s\t%s\t%s\t%s\n"), 
				link.GetBase(), m_strBrowser,
				m_strLanguage, strDateTime, 
				strWininetError_c, link.GetStatusText(), link.GetRelative());
		}

		try
		{
			m_LogFile.Write(strLog, strLog.GetLength());
			m_LogFile.Flush();
		}
		catch(CFileException* pEx)
		{
			ASSERT(FALSE);
			pEx->Delete();
		}
	}

} // CErrorLog::Write


void
CErrorLog::WriteHeader(
	)
/*++

Routine Description:

    Write the log header

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    if(m_LogFile.m_hFile != CFile::hFileNull)
	{
	    CString strLog;
	    strLog.Format(_T("*** %s *** %s\n"), strHeaderText_c,
		    CTime::GetCurrentTime().Format("%x\t%X"));

	    try
	    {
		    m_LogFile.Write(strLog, strLog.GetLength());
		    m_LogFile.Flush();
	    }
	    catch(CFileException* pEx)
	    {
		    ASSERT(FALSE);
		    pEx->Delete();
	    }
    }

} // CErrorLog::WriteHeader


void
CErrorLog::WriteFooter(
	)
/*++

Routine Description:

    Write the log footer

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    if(m_LogFile.m_hFile != CFile::hFileNull)
	{
	    CString strLog;
	    strLog.Format(_T("*** %s *** %s\n"), strFooterText_c,
		    CTime::GetCurrentTime().Format(_T("%x\t%X")));

	    try
	    {
		    m_LogFile.Write(strLog, strLog.GetLength());
		    m_LogFile.Flush();
	    }
	    catch(CFileException* pEx)
	    {
		    ASSERT(FALSE);
		    pEx->Delete();
	    }
    }

} // CErrorLog::WriteFooter
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\linkchk\lcmgr.h ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        lcmgr.h

   Abstract:

        Link checker manager class declaration. This class provides the
		interfaces for creating and customizing the worker thread (link 
		checking thread).

		NOTE: You should only have a aingle instance of CLinkCheckerMgr.

   Author:

        Michael Cheuk (mcheuk)

   Project:

        Link Checker

   Revision History:

--*/

#ifndef _LCMGR_H_
#define _LCMGR_H_

#include "link.h"
#include "linkload.h"
#include "linkpars.h"
#include "linklkup.h"
#include "errlog.h"
#include "useropt.h"
#include "inetapi.h"

//------------------------------------------------------------------
//	Forward declaration
//
class CLinkCheckerSingleton;
class CProgressLog;
class CLinkCheckerMgr;

//------------------------------------------------------------------
// Global fucntion for retrieve the link checker manager
//
CLinkCheckerMgr& GetLinkCheckerMgr();

//------------------------------------------------------------------
//	Link checker manager
//
class CLinkCheckerMgr
{

// Public interfaces
public:

	// Constructor
	CLinkCheckerMgr();

	// Destructor
	~CLinkCheckerMgr();

	// Load wininet.dll. This must be called before initialize()
	BOOL LoadWininet();

	// Initialize the link checker manager. The link checker manager
	// will initialize the link loader, link parser, ...etc
	BOOL Initialize(
		CProgressLog* pProgressLog
		);
	
	// Get the CUserOptions object
	CUserOptions& GetUserOptions()
	{
		return m_UserOptions;
	}

	// Begin the link checking thread
	BOOL BeginWorkerThread();

	// Signal the worker thread to terminate
	void SignalWorkerThreadToTerminate();

	// Is worker thread running ?
	BOOL IsWorkerThreadRunning()
	{
		return (m_lWorkerThreadRunning == 0);
	}

	// Static functions for changing '\' to '/' in string
	static void ChangeBackSlash(LPTSTR lpsz);
	static void ChangeBackSlash(CString& str);


// Protected interfaces
protected:

	// Worker thread entry point
	static UINT WorkerThreadForwarder(
		LPVOID pParam
		);

	// Actual worker thread function (non-static)
	UINT WorkerThread(
		LPVOID pParam
		);

	// Is thread terminating ?
	BOOL IsThreadTerminating()
	{
		return (m_lTerminatingThread == 0);
	}

	// Check this URL. This is the core of link checking.
	void CheckThisURL(LPCTSTR lpszURL);

// Protected members
protected:

	CWininet m_Wininet;		// wininet.dll wrapper
	BOOL m_fWininetLoaded;	// is wininet.dll loaded?

	BOOL m_fInitialized;	// is link checker manager initialized?

	long m_lWorkerThreadRunning; // is worker thread running? (TRUE = 0, FALSE = -1)
	long m_lTerminatingThread;	 // is worker thread terminating? (TRUE = 0, FALSE = -1)

	HANDLE m_hWorkerThread; // handle to the worker thread
	
	CLinkLoader m_Loader;		// link loader
	CLinkParser m_Parser;		// link parser
	CLinkLookUpTable m_Lookup;	// link look up table
	CErrorLog m_ErrLog;			// error log
	
	CUserOptions m_UserOptions;	  // user options
	CProgressLog* m_pProgressLog; // progress log pointer

}; // class CLinkCheckerMgr

#endif // _LCMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\linkchk\lcmgr.cpp ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        lcmgr.cpp

   Abstract:

        Link checker manager class implementation. This class provides the
		interfaces for creating and customizing the worker thread (link 
		checking thread).

		NOTE: You should only have a aingle instance of CLinkCheckerMgr.

   Author:

        Michael Cheuk (mcheuk)

   Project:

        Link Checker

   Revision History:

--*/

#include "stdafx.h"
#include "lcmgr.h"

#include "enumdir.h"
#include "proglog.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// Constants (TODO: put this in resource)
const CString strParsing_c(_T("Parsing"));
const CString strLoading_c(_T("Loading"));

//------------------------------------------------------------------
// Global fucntion for retrieve the link checker manager
//

// Global link checker manager pointer
CLinkCheckerMgr* g_pLinkCheckerMgr = NULL;

CLinkCheckerMgr& 
GetLinkCheckerMgr(
	)
/*++

Routine Description:

    Global fucntion for retrieve the link checker manager

Arguments:

    N/A

Return Value:

    CLinkCheckMgr& - reference to the link checker manager

--*/
{
	ASSERT(g_pLinkCheckerMgr);
	return *g_pLinkCheckerMgr;
}

//------------------------------------------------------------------
// CLinkCheckerMgr implementation
//

CLinkCheckerMgr::CLinkCheckerMgr(
	)
/*++

Routine Description:

    Constructor.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
	ASSERT(g_pLinkCheckerMgr == NULL);
	g_pLinkCheckerMgr = this;

	m_fWininetLoaded = FALSE;
	m_fInitialized = FALSE;

	m_lWorkerThreadRunning = -1;
	m_lTerminatingThread = -1;
	m_hWorkerThread = NULL;

	m_pProgressLog = NULL;

} // CLinkCheckerMgr::CLinkCheckerMgr


CLinkCheckerMgr::~CLinkCheckerMgr(
	)
/*++

Routine Description:

    Destructor.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
	// The worker must be terminated
	ASSERT(!IsWorkerThreadRunning());

	// Nuke the global pointer
	ASSERT(g_pLinkCheckerMgr);
	g_pLinkCheckerMgr = NULL;

} // CLinkCheckerMgr::~CLinkCheckerMgr


BOOL 
CLinkCheckerMgr::LoadWininet(
	)
/*++

Routine Description:

    Load wininet.dll. This must be called before initialize()

Arguments:

    N/A

Return Value:

    BOOL - TRUE if success. FALSE otherwise.

--*/
{
	// Make sure LoadWininet() only call once
	ASSERT(!m_fWininetLoaded);
	if(m_fWininetLoaded)
	{
		return FALSE;
	}
	m_fWininetLoaded = TRUE;

	return m_Wininet.Load();

} // CLinkCheckerMgr::LoadWininet
	

BOOL 
CLinkCheckerMgr::Initialize(
	CProgressLog* pProgressLog
	)
/*++

Routine Description:

    Initialize the link checker manager. The link checker manager
	will initialize the link loader, link parser, ...etc

Arguments:

    pProgressLog - pointer to an instance of progress logging object

Return Value:

    BOOL - TRUE if success. FALSE otherwise.

--*/
{
	// Make sure Initialize() only call once
	ASSERT(!m_fInitialized);
	if(m_fInitialized)
	{
		return FALSE;
	}
	m_fInitialized = TRUE;

	// pProgressLog is ok to be NULL
	m_pProgressLog = pProgressLog;

	// Create the link loader
	if(!m_Loader.Create(_T(""), _T("")))
	{
		return FALSE;
	}

	// Create the error log
	if(!m_ErrLog.Create())
	{
		return FALSE;
	}

	// Set the local host name in the paser
	m_Parser.SetLocalHostName(GetUserOptions().GetHostName());

	return TRUE;

} // CLinkCheckerMgr::Initialize


BOOL 
CLinkCheckerMgr::BeginWorkerThread(
	)
/*++

Routine Description:

	Begin the link checking thread

Arguments:

    N/A

Return Value:

    BOOL - TRUE if success. FALSE otherwise.

--*/
{
	// Start 1 thread only
	if(IsWorkerThreadRunning())
	{
		return FALSE;
	}

	CWinThread* pWorkerThread = ::AfxBeginThread((AFX_THREADPROC)WorkerThreadForwarder, NULL);
	if(pWorkerThread == NULL)
	{
		return FALSE;
	}
	else
	{
		m_hWorkerThread = pWorkerThread->m_hThread;
		return TRUE;
	}

} // CLinkCheckerMgr::BeginWorkerThread


void 
CLinkCheckerMgr::SignalWorkerThreadToTerminate(
	)
/*++

Routine Description:

	Signal the worker thread to terminate

Arguments:

    N/A

Return Value:

    N/A

--*/
{
	if(IsWorkerThreadRunning() && !IsThreadTerminating())
	{
		InterlockedIncrement(&m_lTerminatingThread);
	}

} // CLinkCheckerMgr::SignalWorkerThreadToTerminate


UINT 
CLinkCheckerMgr::WorkerThreadForwarder(
	LPVOID pParam
	)
/*++

Routine Description:

	Worker thread entry point

Arguments:

    pParam - unused 

Return Value:

    UINT - unsed

--*/
{
	// Now IsWorkerThreadRunnig() return TRUE
	InterlockedIncrement(&GetLinkCheckerMgr().m_lWorkerThreadRunning);

	UINT nRet = GetLinkCheckerMgr().WorkerThread(pParam);

	// Now IsWorkerThreadRunnig() return FLASE
	InterlockedDecrement(&GetLinkCheckerMgr().m_lWorkerThreadRunning);
	
	// Notify the progress log, the worker thread is completed
	if(GetLinkCheckerMgr().m_pProgressLog)
	{
		// Possible deadlock. Use message instead ?
		GetLinkCheckerMgr().m_pProgressLog->WorkerThreadComplete();
	}

	return nRet;

} // CLinkCheckerMgr::WorkerThreadForwarder


UINT 
CLinkCheckerMgr::WorkerThread(
	LPVOID pParam
	)
/*++

Routine Description:

	Actual worker thread function

Arguments:

    pParam - unused 

Return Value:

    UINT - unsed

--*/
{
	UNUSED_ALWAYS(pParam);

	// Write the error log header
	m_ErrLog.WriteHeader();
	
	// Go thru all the combination of browser & language
	POSITION PosBrowser;
	CBrowserInfo BrowserInfo;

	POSITION PosLanguage;
	CLanguageInfo LanguageInfo;

	PosBrowser = GetUserOptions().GetAvailableBrowsers().GetHeadSelectedPosition();
	do
	{
		// Get the next browser
		BrowserInfo = GetUserOptions().GetAvailableBrowsers().GetNextSelected(PosBrowser);
		m_ErrLog.SetBrowser(BrowserInfo.GetName());

		// Reset language position
		PosLanguage = GetUserOptions().GetAvailableLanguages().GetHeadSelectedPosition();
		do
		{
			// Get the language
			LanguageInfo = GetUserOptions().GetAvailableLanguages().GetNextSelected(PosLanguage);

			m_ErrLog.SetLanguage(LanguageInfo.GetName());

			// Change the loader properties
			CString strAdditionalHeaders;
			strAdditionalHeaders.Format(_T("Accept: */*\r\nAccept-Language: %s"), LanguageInfo.GetAcceptName());
			if(!m_Loader.ChangeProperties(BrowserInfo.GetUserAgent(), strAdditionalHeaders))
			{
				return 1;
			}

			// Remove everything in the look up table
			m_Lookup.RemoveAll();


			// *EITHER* We are checking for virtual directories
			const CVirtualDirInfoList& DirInfoList = GetUserOptions().GetDirectoryList();
			int iSize = DirInfoList.GetCount();

			if(DirInfoList.GetCount() > 0)
			{
				POSITION Pos = DirInfoList.GetHeadPosition();

				// For each user input directory
				for(int i=0; !IsThreadTerminating() && i<iSize; i++)
				{
					CEnumerateDirTree Eumerator(DirInfoList.GetNext(Pos));
					CString strURL;

					// For each file in this directory tree, create an empty
					// stack with one file in
					while(!IsThreadTerminating() && Eumerator.Next(strURL))
					{
						CheckThisURL(strURL);
					}
				}
			}

			// *OR* We are checking for URL path
			const CStringList& URLList = GetUserOptions().GetURLList();
			iSize = URLList.GetCount();

			if(iSize > 0)
			{
				POSITION Pos = URLList.GetHeadPosition();

				for(int i=0; !IsThreadTerminating() && i<iSize; i++)
				{
					CheckThisURL(URLList.GetNext(Pos));
				}
			}
			
		}while(!IsThreadTerminating() && PosLanguage != NULL);
	}while(!IsThreadTerminating() && PosBrowser != NULL);

	// Write the error log footer
	m_ErrLog.WriteFooter();

    return 1;

} // CLinkCheckerMgr::WorkerThread


void 
CLinkCheckerMgr::CheckThisURL(
	LPCTSTR lpszURL
	)
/*++

Routine Description:

	Check this URL. This is the core of link checking.

Arguments:

    lpszURL - URL to check

Return Value:

    N/A

--*/
{
	// Create a link object for the input
	CLink Link(lpszURL, _T("Link Checker"), lpszURL, TRUE);

	// If not found in the lookup table
	if(!m_Lookup.Get(Link.GetURL(), Link))
	{
		if(m_pProgressLog)
		{
			CString strLog;
			strLog.Format(_T("Loading %s"), Link.GetURL());
			m_pProgressLog->Log(strLog);
			TRACE(_T("%s\n"), strLog);
		}

		// Load it ( with ReadFile )
		int iRet = m_Loader.Load(Link, TRUE);

		// Set the load time in the object
		Link.SetTime(CTime::GetCurrentTime());

		// Update the lookup table with this link
		m_Lookup.Add(Link.GetURL(), Link);
	}

	ASSERT(Link.GetState() != CLink::eUnit);

	// If the link is invalid, write to error log & return
	if(Link.GetState() == CLink::eInvalidHTTP ||
		Link.GetState() == CLink::eInvalidWininet)
	{
		
		m_ErrLog.Write(Link);
		return;
	}

	// If the link is not a text file, nothing
	// to parse
	if(Link.GetContentType() != CLink::eText)
	{
		return;
	}

	if(m_pProgressLog)
	{
		CString strLog;
		strLog.Format(_T("%s %s"), strParsing_c, Link.GetURL());
		m_pProgressLog->Log(strLog);
		TRACE(_T("%s\n"), strLog);
	}

	// Add the links in this html to the stack
	CLinkPtrList List;
	m_Parser.Parse(Link.GetData(), Link.GetURL(), List);

	// While the link stack is not empty
	while(!IsThreadTerminating() && List.GetCount() > 0)
	{
		// Pop a new link
		CLink* pLink = List.GetHead();
		List.RemoveHead();

		// If not found in the lookup table
		if(!m_Lookup.Get(pLink->GetURL(), *pLink))
		{
			if(m_pProgressLog)
			{
				CString strLog;
				strLog.Format(_T("%s %s"), strLoading_c, pLink->GetURL());
				m_pProgressLog->Log(strLog);
				TRACE(_T("%s\n"), strLog);
			}

			// Load it
			m_Loader.Load(*pLink, FALSE);

			// Set the load time in the object
			pLink->SetTime(CTime::GetCurrentTime());

			// Update the lookup table with this link
			m_Lookup.Add(pLink->GetURL(), *pLink);
		}

		// Make sure all the links were initialized
		ASSERT(pLink->GetState() != CLink::eUnit);
		
		// If the link is invalid, write to error log & return
		if(pLink->GetState() == CLink::eInvalidHTTP ||
			pLink->GetState() == CLink::eInvalidWininet)
		{
			m_ErrLog.Write(*pLink);
		}

		delete pLink;
	}

} // CLinkCheckerMgr::CheckThisURL


void 
CLinkCheckerMgr::ChangeBackSlash(
	LPTSTR lpsz
	)
/*++

Routine Description:

	Static functions for changing '\' to '/' in string

Arguments:

    lpsz - input string pointer

Return Value:

    N/A

--*/
{
	lpsz = _tcschr(lpsz, _TUCHAR('\\'));
	while(lpsz != NULL)
	{
		lpsz[0] = _TCHAR('/');
		lpsz = _tcschr(lpsz, _TUCHAR('\\'));
	}

} // CLinkCheckerMgr::ChangeBackSlash


void 
CLinkCheckerMgr::ChangeBackSlash(
	CString& str
	)
/*++

Routine Description:

	Static functions for changing '\' to '/' in string

Arguments:

    str - input string

Return Value:

    N/A

--*/
{
	LPTSTR lpsz = str.GetBuffer(str.GetLength());
	ChangeBackSlash(lpsz);
	str.ReleaseBuffer();

} // CLinkCheckerMgr::ChangeBackSlash
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\linkchk\inetapi.cpp ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        inetapi.cpp

   Abstract:

        wininet.dll wrapper class implementation.

   Author:

        Michael Cheuk (mcheuk)

   Project:

        Link Checker

   Revision History:

--*/

#include "stdafx.h"
#include "inetapi.h"

// Diable the warning C4706: assignment within conditional expression
// for LOAD_ENTRY macro
#pragma warning( disable : 4706)

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// Initialize the static members

HMODULE CWininet::sm_hWininet = NULL;
int		CWininet::sm_iInstanceCount = 0;

pfnInternetOpenA              CWininet::InternetOpenA = NULL;
pfnInternetSetStatusCallback  CWininet::InternetSetStatusCallback = NULL;
pfnInternetConnectA           CWininet::InternetConnectA = NULL;
pfnHttpOpenRequestA           CWininet::HttpOpenRequestA = NULL;
pfnHttpAddRequestHeadersA     CWininet::HttpAddRequestHeadersA = NULL;
pfnHttpSendRequestA           CWininet::HttpSendRequestA = NULL;
pfnHttpQueryInfoA             CWininet::HttpQueryInfoA = NULL;
pfnInternetCloseHandle        CWininet::InternetCloseHandle = NULL;
pfnInternetReadFile           CWininet::InternetReadFile = NULL;
pfnInternetCrackUrlA		  CWininet::InternetCrackUrlA = NULL;
pfnInternetCombineUrlA        CWininet::InternetCombineUrlA = NULL;
pfnInternetOpenUrlA			  CWininet::InternetOpenUrlA = NULL;


CWininet::CWininet(
	)
/*++

Routine Description:

    Constructor. It increases the static instance count.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
	// Increment the instance count
	++sm_iInstanceCount;

} // CWininet::CWininet


CWininet::~CWininet(
	)
/*++

Routine Description:

    Destructor. It decrease the static instance count and/or
	free wininet.dll from memory.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
	// If the instance count is zero, free wininet.dll
	// from memory
	if(--sm_iInstanceCount == 0 && sm_hWininet)
    {
        VERIFY(FreeLibrary(sm_hWininet));

		sm_hWininet = NULL;
		InternetOpenA = NULL;
		InternetSetStatusCallback = NULL;
		InternetConnectA = NULL;
		HttpOpenRequestA = NULL;
		HttpAddRequestHeadersA = NULL;
		HttpSendRequestA = NULL;
		HttpQueryInfoA = NULL;
		InternetCloseHandle = NULL;
		InternetReadFile = NULL;
		InternetCrackUrlA = NULL;
		InternetCombineUrlA = NULL;
		InternetOpenUrlA = NULL;
    }

} // CWininet::~CWininet


BOOL 
CWininet::Load(
	)
/*++

Routine Description:

    Load the wininet.dll onto memory Or increase the wininet.dll
	system reference count by one.

Arguments:

    N/A

Return Value:

    BOOL - TRUE if wininet.dll loaded. FALSE otherwise.

--*/
{
    if ( !(sm_hWininet = LoadLibrary( _T("wininet.dll") )) )
    {
        TRACE(_T("CWininet::Load() - Failed to load wininet.dll\n"));
        return FALSE;
    }

	

	if ( !LOAD_ENTRY( sm_hWininet, InternetOpenA ) ||
         !LOAD_ENTRY( sm_hWininet, InternetSetStatusCallback ) ||
         !LOAD_ENTRY( sm_hWininet, InternetConnectA ) ||
         !LOAD_ENTRY( sm_hWininet, HttpOpenRequestA ) ||
         !LOAD_ENTRY( sm_hWininet, HttpAddRequestHeadersA ) ||
         !LOAD_ENTRY( sm_hWininet, HttpSendRequestA ) ||
         !LOAD_ENTRY( sm_hWininet, HttpQueryInfoA ) ||
         !LOAD_ENTRY( sm_hWininet, InternetCloseHandle ) ||
         !LOAD_ENTRY( sm_hWininet, InternetReadFile )  ||
		 !LOAD_ENTRY( sm_hWininet, InternetCrackUrlA) ||
		 !LOAD_ENTRY( sm_hWininet, InternetCombineUrlA) ||
		 !LOAD_ENTRY( sm_hWininet, InternetOpenUrlA) )
    {
        return FALSE;
    }

    return TRUE;

} // CWininet::Load
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\linkchk\linklkup.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name :

    linklkup.cpp

Abstract:

    Link look up table class implementaions. The is a MFC CMap
	constains the previous visited web link. This is used
	as a look up table for visited link.

Author:

    Michael Cheuk (mcheuk)				22-Nov-1996

Project:

    Link Checker

Revision History:

--*/

#include "stdafx.h"
#include "linklkup.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

void 
CLinkLookUpTable::Add(
	const CString& strKey, 
	const CLink& link
	)
/*++

Routine Description:

    Wrapper function for adding item to CMap

Arguments:

	strKey	- use URL string as map key
	link	- link object to add

Return Value:

    N/A

--*/
{
	LinkLookUpItem_t item;

	item.LinkState = link.GetState();
	item.nStatusCode = link.GetStatusCode();

	SetAt(strKey, item);

} // CLinkLookUpTable::Add


BOOL 
CLinkLookUpTable::Get(
	const CString& strKey, 
	CLink& link
	) const
/*++

Routine Description:

    Wrapper function for getting item from CMap

Arguments:

    strKey	- us URL string as map key
	link	- link object to fill in

Return Value:

    BOOL - TRUE if found. FALSE otherwise.

--*/
{
	LinkLookUpItem_t item;

	if(Lookup(strKey, item))
	{
		// Found the link
		link.SetState(item.LinkState);
		link.SetStatusCode(item.nStatusCode);

		return TRUE;
	}

	return FALSE;

} // CLinkLookUpTable::Get
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\linkchk\linkchk.h ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        linkchk.h

   Abstract:

         MFC CWinApp derived application class declaration.

   Author:

        Michael Cheuk (mcheuk)

   Project:

        Link Checker

   Revision History:

--*/

#ifndef _LINKCHK_H_
#define _LINKCHK_H_

#include "resource.h"
#include "cmdline.h"

#include "lcmgr.h"

//---------------------------------------------------------------------------
// MFC CWinApp derived application class.
// 
class CLinkCheckerApp : public CWinApp
{
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CLinkCheckerApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Protected funtions
protected:

    // Parse command line
    void ParseCmdLine(
        CCmdLine& CmdLine
        );

// Protected members
protected:

    CCmdLine m_CmdLine;                 // command line object
	CLinkCheckerMgr m_LinkCheckerMgr;   // link checker manager

// Implementation

	//{{AFX_MSG(CLinkCheckerApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

}; // class CLinkCheckerApp 

#endif // _LINKCHK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\linkchk\linkchk.cpp ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        linkchk.cpp

   Abstract:

         MFC CWinApp derived application class implementation.

   Author:

        Michael Cheuk (mcheuk)

   Project:

        Link Checker

   Revision History:

--*/

#include "stdafx.h"
#include "linkchk.h"
#include "maindlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

BEGIN_MESSAGE_MAP(CLinkCheckerApp, CWinApp)
	//{{AFX_MSG_MAP(CLinkCheckerApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

// The one and only CLinkCheckerApp object
CLinkCheckerApp theApp;

BOOL 
CLinkCheckerApp::InitInstance(
    )
/*++

Routine Description:

    CLinkCheckerApp initialization

Arguments:

    N/A

Return Value:

    BOOl - TRUE if success. FALSE otherwise.

--*/
{
	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	ParseCmdLine(m_CmdLine);

	if(!m_CmdLine.CheckAndAddToUserOptions())
	{
		return FALSE;
	}

	CMainDialog dlg;
	m_pMainWnd = &dlg;
	int nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;

}  // CLinkCheckerApp::InitInstance(

void 
CLinkCheckerApp::ParseCmdLine(
	CCmdLine& CmdLine
	)
/*++

Routine Description:

    Parse command line

Arguments:

    CmdLine - command line object to store the data

Return Value:

    N/A

--*/
{
	// Copy & modified from MFC
	for (int i=1; i<__argc; i++)
	{
		TCHAR chFlag = _TCHAR(' ');
		LPCTSTR lpszParam = __targv[i];

		// If this is a flag
		if (lpszParam[0] == _TCHAR('-'))
		{
			chFlag = lpszParam[1];
			
			if(i+1 < __argc)
			{
				lpszParam = __targv[++i];
			}
			else
			{
				lpszParam = NULL;
			}
		}

		// Parse the flag & the following parameter
		CmdLine.ParseParam(chFlag, lpszParam);
	}

} // CLinkCheckerApp::ParseCmdLine
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\linkchk\link.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name :

    link.h

Abstract:

    Link data class and link data class link list declarations. It 
    encapsulates all the informations about a web link.

Author:

    Michael Cheuk (mcheuk)

Project:

    Link Checker

Revision History:

--*/

#ifndef _LINK_H_
#define _LINK_H_

//------------------------------------------------------------------
// Link data object. Each instance represents a web link in a
// html document
//
class CLink
{
// Object specific enum
public:

    // The object's state
    enum LinkState 
    {
        eUnit,			// uninitialize
		eUnsupport,		// unsupport URL scheme
        eValidHTTP,		// a valid HTTP link
		eValidURL,		// a valid URL (except HTTP) link
        eInvalidHTTP,	// invalid link due to HTTP status code
		eInvalidWininet	// invalid link due to wininet API failure
    };

    // The content type of this web link
    enum ContentType
    {
        eBinary,
        eText
    };

// Public interfaces
public:

	// Constructor
    CLink(
		const CString& strURL,      // URL
		const CString& strBase,     // base URL used to generate the strURL
		const CString& strRelative, // relative URL used to generate the strURL
		BOOL fLocalLink
		);

	// Get the object's URL 
    const CString& GetURL() const
    {
        return m_strURL;
    }

    // Set the object's URL
	void SetURL(
        const CString& strURL
        );

	// Get the object's base URL
    CString GetBase() const
    {
        return m_strBase;
    }

    // Get the object's relative URL
	const CString& GetRelative() const 
	{
		return m_strRelative;
	}

	// Set the object state
    void SetState(
		LinkState state
		)
    {
        m_LinkState = state;
    }
    
    // Get the object state
	LinkState GetState() const
    {
        return m_LinkState;
    }

    // Get the current content type
    ContentType GetContentType() const
    {
        return m_ContentType;
    }

	// Set the current content type
    void SetContentType(
		ContentType type
		)
    {
        m_ContentType = type;
    }
    
    // Get the HTTP reponse status code or wininet last error code
    UINT GetStatusCode() const
    {
        return m_nStatusCode;
    }

	// Set the HTTP reponse status code or wininet last error code
    void SetStatusCode(
		UINT nStatusCode
		)
    {
        m_nStatusCode = nStatusCode;
    }

	// Get link data content
    CString GetData() const
    {
        return m_strData;
    }
    
    // Set link data content
    void SetData(
		CString strData
		)
    {
        m_strData = strData;
    }

    // Empty the link data content
    void EmptyData()
    {
        m_strData.Empty();
    }

    // Is this object represents a local link
	BOOL IsLocalLink() const
	{
		return m_fLocalLink;
	}

    // Get the object load time
	const CTime& GetTime() const
	{
		return m_Time;
	}
    
    // Set the object load time
    void SetTime(
        const CTime& Time
        )
	{
		m_Time = Time;
	}

    // Get the HTTP error status text of wininet error message
    const CString& GetStatusText() const
	{
		return m_strStatusText;
	}

    // Set the HTTP error status text of wininet error message
	void SetStatusText(
        LPCTSTR lpszStatusText
        )
	{
		m_strStatusText = lpszStatusText;
	}

// Protected interfaces
protected:

    // Preprocess the m_strURL to clean up "\r\n" and change '\' to '/'
    void PreprocessURL();

// Protected members
protected:

    CString m_strURL;       // URL
    CString m_strBase;      // base URL used to generate the strURL
	CString m_strRelative;  // relative URL used to generate the strURL

    // Link data. We only read & store text file which will
	// parse for addtional link.
    CString m_strData;

    CString m_strStatusText; // the HTTP error status text of wininet error message
    UINT m_nStatusCode;      // the HTTP reponse status code or wininet last error code

    LinkState m_LinkState;      // current state of this object
    ContentType m_ContentType;  // the link data content type

	BOOL m_fLocalLink;  // is this a local link ?

	CTime m_Time; // object load time
	
}; // class CLink


//------------------------------------------------------------------
// Link object pointer class
//
class CLinkPtrList : public CTypedPtrList<CPtrList, CLink*> 
{

// Public funtions
public:

    // Destructor
	~CLinkPtrList();

    // Add link object to list
	void AddLink(
        const CString& strURL, 
        const CString& strBase, 
	    const CString& strRelative,
        BOOL fLocalLink
        );

}; // class CLinkPtrList

#endif // _LINK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\linkchk\linklkup.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name :

    linklkup.h

Abstract:

    Link look up table class definitions. The is a MFC CMap
	constains the previos visited web link. This is used
	as a look up table for visited link.

Author:

    Michael Cheuk (mcheuk)				22-Nov-1996

Project:

    Link Checker

Revision History:

--*/

#ifndef _LINKLKUP_H_
#define _LINKLKUP_H_

#include "link.h"

// Lookup table item
typedef struct 
{
	CLink::LinkState LinkState; // link state
    UINT    nStatusCode;		// http status code or wininet error code
}LinkLookUpItem_t;

//---------------------------------------------------------------------------
// Link look up table. The is a MFC CMap constains the previous visited web 
// link. This is used as a look up table for visited link.
//
class CLinkLookUpTable : public CMap<CString, LPCTSTR, LinkLookUpItem_t, LinkLookUpItem_t&>
{

// Public interfaces
public:

	// Wrapper function for adding item to CMap
	void Add(
		const CString& strKey, // use URL as key
		const CLink& link
		);

	// Wrapper function for getting item from CMap
	BOOL Get(
		const CString& strKey, // use URL as key
		CLink& link
		) const;

}; // class CLinkLookUpTable

#endif // _LINKLKUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\linkchk\link.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name :

    link.cpp

Abstract:

    Link data class and link data class link list implementation. It 
    encapsulates all the informations about a web link.

Author:

    Michael Cheuk (mcheuk)

Project:

    Link Checker

Revision History:

--*/

#include "stdafx.h"
#include "link.h"

#include "lcmgr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CLink::CLink(
	const CString& strURL, 
	const CString& strBase, 
	const CString& strRelative, 
	BOOL fLocalLink
	):
/*++

Routine Description:

    Constructor. 

Arguments:

    strURL		- URL
	strBase	    - Base URL
	strRelative - Relative URL
	fLocalLink	- Is local link?

Return Value:

    N/A

--*/
m_strURL(strURL),
m_strBase(strBase),
m_strRelative(strRelative),
m_fLocalLink(fLocalLink)
{
	m_LinkState = eUnit;
    m_ContentType = eBinary;
    m_nStatusCode = 0;

	PreprocessURL();

} // CLink::CLink


void 
CLink::SetURL(
    const CString& strURL
    )
/*++

Routine Description:

    Set the URL. 

Arguments:

    strURL		- URL

Return Value:

    N/A

--*/
{
	m_strURL = strURL;
	PreprocessURL();

} // CLink::SetURL


void 
CLink::PreprocessURL(
    )
/*++

Routine Description:

    Preprocess the m_strURL to clean up "\r\n" and change '\' to '/'

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    // Change '\' to '\'
    CLinkCheckerMgr::ChangeBackSlash(m_strURL);

	// Remove all "\r\n" in the URL
	int iIndex = m_strURL.Find(_T("\r\n"));
	while(iIndex != -1)
	{
		m_strURL = m_strURL.Left(iIndex) + m_strURL.Mid(iIndex + _tcslen(_T("\r\n")));
		iIndex = m_strURL.Find(_T("\r\n"));
	}

} // CLink::PreprocessURL



CLinkPtrList::~CLinkPtrList(
    )
/*++

Routine Description:

    Destructor. Clean up all the object in link list.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
	if(!IsEmpty())
	{
		POSITION Pos = GetHeadPosition();
		do
		{
			CLink* pLink = GetNext(Pos);
			delete pLink;
		}
		while(Pos != NULL);
	}

} // CLinkPtrList::~CLinkPtrList


void 
CLinkPtrList::AddLink(
    const CString& strURL, 
    const CString& strBase, 
	const CString& strRelative,
	BOOL fLocalLink)
/*++

Routine Description:

    Add link object to list

Arguments:

    strURL		- URL
	strBase	    - Base URL
	strRelative - Relative URL
	fLocalLink	- Is local link?

Return Value:

    N/A

--*/
{
    CLink* pLink = new CLink(strURL, strBase, strRelative, fLocalLink);
    if(pLink)
    {
        try
        {
            AddTail(pLink);
        }
        catch(CMemoryException* pEx)
        {
            pEx->Delete();
        }
    }

} // CLinkPtrList::AddLink
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\linkchk\linkload.h ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name :

    linkload.h

Abstract:

    Link loader class definitions. It uses wininet API
	to load the web page from the internet. 

Author:

    Michael Cheuk (mcheuk)				22-Nov-1996

Project:

    Link Checker

Revision History:

--*/

#ifndef _LINKLOAD_H_
#define _LINKLOAD_H_

#include "inetapi.h"

//------------------------------------------------------------------
//	Forward declaration
//
class CLink;

//------------------------------------------------------------------
// This is a wrapper class for HINTERNET. It takes care of internet 
// handle cleaning up.
//
class CAutoInternetHandle
{

// Public interfaces
public:

	// Constructor
	CAutoInternetHandle(
		HINTERNET hHandle = NULL
		)
    {
        m_hHandle = hHandle;
    }

    // Destructor
	~CAutoInternetHandle()
    {
        if(m_hHandle)
	    {
		    ASSERT(CWininet::IsLoaded());
		    VERIFY(CWininet::InternetCloseHandle(m_hHandle));
        }
	}

	// Operator overloads. These functions make 
	// CAutoInternetHandle instance behaves like a HINTERNET
	operator HINTERNET() const
    {
        return m_hHandle;
    }

	const HINTERNET& operator=(
		const HINTERNET& hHandle
		)
    {
        m_hHandle = hHandle;
	    return m_hHandle;
    }

// Protected member
protected:

	HINTERNET m_hHandle; // Actual HINTERNET

}; // class CAutoInternetHandle


//------------------------------------------------------------------
// Link loader class. It uses wininet API to load the web 
// page from the internet. 
//
class CLinkLoader
{

// Public interfaces
public:

	// One time link loader create funtion
    BOOL Create(
		const CString& strUserAgent,         // HTTP user agent name
		const CString& strAdditionalHeaders  // addtional HTTP headers
		);

	// Load a web link
    BOOL Load(
		CLink& link,
		BOOL fLocalLink
		);

	// Change the loader properties
	BOOL ChangeProperties(
		const CString& strUserAgent, 
		const CString& strAdditionalHeaders
		);

// Protected interfaces
protected:

    // Load a HTTP link
	BOOL LoadHTTP(
		CLink& link,
		BOOL fReadFile,
		LPCTSTR szHostName,
		LPCTSTR szUrlPath,
		int iRedirectCount = 0
		);

    // Load a URL (non-HTTP) link
	BOOL LoadURL(
		CLink& link
		);

	// Wininet failed clean up subroutine
	BOOL WininetFailed(
		CLink& link
		);

// Protected interfaces
protected:

    // Handle for internet session (one per instance)
    CAutoInternetHandle m_hInternetSession;

	// Additional http header string
	CString m_strAdditionalHeaders;

}; // class CLinkLoader

#endif // _LINKLOAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\linkchk\maindlg.h ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        maindlg.cpp

   Abstract:

        CMainDialog dialog class declaration. This is link checker
        the main dialog. 

   Author:

        Michael Cheuk (mcheuk)

   Project:

        Link Checker

   Revision History:

--*/

#ifndef _MAINDLG_H_
#define _MAINDLG_H_

#include "appdlg.h"

//---------------------------------------------------------------------------
// CMainDialog dialog
//

class CMainDialog : public CAppDialog
{
// Construction
public:
	CMainDialog(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CMainDialog)
	enum { IDD = IDD_MAIN };
	BOOL	m_fLogToFile;
	CString	m_strLogFilename;
	BOOL	m_fCheckLocalLinks;
	BOOL	m_fCheckRemoteLinks;
	BOOL	m_fLogToEventMgr;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CMainDialog)
	afx_msg void OnMainRun();
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnAthenication();
	afx_msg void OnProperties();
	virtual BOOL OnInitDialog();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

}; // class CMainDialog

#endif // _MAINDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\linkchk\progdlg.cpp ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        progdlg.h

   Abstract:

        CProgressDialog dialog class implementation. This progress dialog 
		is shown 

   Author:

        Michael Cheuk (mcheuk)

   Project:

        Link Checker

   Revision History:

--*/

#include "stdafx.h"
#include "linkchk.h"
#include "progdlg.h"

#include "lcmgr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CProgressDialog::CProgressDialog(
	) : 
/*++

Routine Description:

    Constructor.

Arguments:

    N/A

Return Value:

    N/A

--*/
CDialog(CProgressDialog::IDD, NULL)
{
	//{{AFX_DATA_INIT(CProgressDialog)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

} // CProgressDialog::CProgressDialog


void 
CProgressDialog::DoDataExchange(
	CDataExchange* pDX
	)
/*++

Routine Description:

    Called by MFC to change/retrieve dialog data

Arguments:

    pDX - 

Return Value:

    N/A

--*/
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CProgressDialog)
	DDX_Control(pDX, IDC_PROGRESS_BUTTON, m_button);
	DDX_Control(pDX, IDC_PROGRESS_TEXT, m_staticProgressText);
	//}}AFX_DATA_MAP

} //CProgressDialog::DoDataExchange


BEGIN_MESSAGE_MAP(CProgressDialog, CDialog)
	//{{AFX_MSG_MAP(CProgressDialog)
	ON_BN_CLICKED(IDC_PROGRESS_BUTTON, OnProgressButton)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


BOOL 
CProgressDialog::OnInitDialog(
	) 
/*++

Routine Description:

    WM_INITDIALOG message handler

Arguments:

    N/A

Return Value:

    BOOL - TRUE if sucess. FALSE otherwise.

--*/
{
	CDialog::OnInitDialog();

	if(GetLinkCheckerMgr().Initialize((CProgressLog*)this))
	{
		if(GetLinkCheckerMgr().BeginWorkerThread())
		{
			return TRUE;
		}
	}

	CString str;

	str.LoadString(IDS_LC_FAIL);
	Log(str);

	str.LoadString(IDS_CLOSE);
	SetButtonText(str);

	return TRUE;

} // CProgressDialog::OnInitDialog


void 
CProgressDialog::OnProgressButton(
	) 
/*++

Routine Description:

    Progress button click handler. This functions will terminate the
	worker thread or close the dialog.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
	if(GetLinkCheckerMgr().IsWorkerThreadRunning())
	{
		CString str;
		str.LoadString(IDS_WORKER_THREAD_TERMINATE);
		Log(str);

		// signal the worker thread to terminate
		GetLinkCheckerMgr().SignalWorkerThreadToTerminate();
	}
	else
	{
		CDialog::OnOK();
	}

} // CProgressDialog::OnProgressButton


void 
CProgressDialog::WorkerThreadComplete(
	)
/*++

Routine Description:

    Worker thread notification.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
	CString str;

	str.LoadString(IDS_PROGRESS_FINISH);
	Log(str);
	
	str.LoadString(IDS_CLOSE);
	SetButtonText(str);

} // CProgressDialog::WorkerThreadComplete
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\linkchk\linkload.cpp ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name :

    linkload.cpp

Abstract:

    Link loader class definitions. It uses wininet API
	to load the web page from the internet. 

Author:

    Michael Cheuk (mcheuk)				22-Nov-1996

Project:

    Link Checker

Revision History:

--*/

#include "stdafx.h"
#include "linkload.h"

#include "link.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// Constants
const int iMaxRedirectCount_c = 3;
const UINT nReadFileBufferSize_c = 4096;
const UINT nQueryResultBufferSize_c = 1024;


BOOL 
CLinkLoader::Create(
	const CString& strUserAgent, 
	const CString& strAdditonalHeaders
	)
/*++

Routine Description:

    One time link loader create funtion

Arguments:

    strUserAgent - HTTP user agent name
	strAdditonalHeaders - addtional HTTP headers

Return Value:

    BOOL - TRUE if success. FALSE otherwise.

--*/
{
	// Make sure wininet.dll is loaded
	ASSERT(CWininet::IsLoaded());
    if(!CWininet::IsLoaded())
    {
        return FALSE;
    }

    // Save the additional header
	m_strAdditionalHeaders = strAdditonalHeaders;

	// Open an internet session
    m_hInternetSession = CWininet::InternetOpenA(
							strUserAgent,
							PRE_CONFIG_INTERNET_ACCESS, 
							NULL,
							INTERNET_INVALID_PORT_NUMBER,
							0);

#ifdef _DEBUG
	if(!m_hInternetSession)
	{
		TRACE(_T("CLinkLoader::Create() - InternetOpen() failed. GetLastError() = %d\n"),
		GetLastError());
	}
#endif

    return (m_hInternetSession != NULL);

} // CLinkLoader::Create


BOOL 
CLinkLoader::ChangeProperties(
	const CString& strUserAgent, 
	const CString& strAdditionalHeaders
	)
/*++

Routine Description:

    Change the loader properties

Arguments:

    strUserAgent - HTTP user agent name
	strAdditonalHeaders - addtional HTTP headers

Return Value:

    BOOL - TRUE if success. FALSE otherwise.

--*/
{
	if(m_hInternetSession)
	{
		// Close the previous internet session and
		// call Create() again
		VERIFY(CWininet::InternetCloseHandle(m_hInternetSession));
		return Create(strUserAgent, strAdditionalHeaders);
	}

	return FALSE;

} // CLinkLoader::ChangeProperties


BOOL 
CLinkLoader::Load(
	CLink& link,
	BOOL fReadFile
	)
/*++

Routine Description:

    Load a web link

Arguments:

    link - reference to the result link object
	fReadFile - read the file and save it in the link object

Return Value:

    BOOL - TRUE if success. FALSE otherwise.

--*/
{
	// Make sure we have a session avaiable
	ASSERT(m_hInternetSession);
    if(!m_hInternetSession)
	{
		return FALSE;
	}

	// Crack the URL 
	TCHAR szHostName[INTERNET_MAX_HOST_NAME_LENGTH];
	TCHAR szUrlPath[INTERNET_MAX_URL_LENGTH];
	URL_COMPONENTS urlcomp;

	memset(&urlcomp, 0, sizeof(urlcomp));
	urlcomp.dwStructSize = sizeof(urlcomp);

	urlcomp.lpszHostName = (LPTSTR) &szHostName;
	urlcomp.dwHostNameLength = INTERNET_MAX_HOST_NAME_LENGTH;

	urlcomp.lpszUrlPath = (LPTSTR) &szUrlPath;
	urlcomp.dwUrlPathLength = INTERNET_MAX_URL_LENGTH;

	if(!CWininet::InternetCrackUrlA(link.GetURL(), link.GetURL().GetLength(), NULL, &urlcomp))
	{
		TRACE(_T("CLinkLoader::Load() - InternetCrackUrl() failed. GetLastError() = %d\n"), 
			GetLastError());
		return FALSE;
	}

	// Make sure we have a valid (non zero length) URL path
	if(_tcslen(szUrlPath) == 0)
	{
		_tprintf(szUrlPath, "%s", _TCHAR('/'));
	}

	// Call the appropriate load funtion for different URL schemes
	if(urlcomp.nScheme == INTERNET_SCHEME_HTTP)
	{
		return LoadHTTP(link, fReadFile, szHostName, szUrlPath);
	}
	else if(urlcomp.nScheme >= INTERNET_SCHEME_FTP && 
		urlcomp.nScheme <= INTERNET_SCHEME_HTTPS)
	{
		return LoadURL(link);
	}
	else
	{
		TRACE(_T("CLinkLoader::Load() - unsupport URL scheme(%d)\n"), urlcomp.nScheme); 
		link.SetState(CLink::eUnsupport);
		return FALSE;
	}

} // CLinkLoader::Load


BOOL 
CLinkLoader::LoadURL(
	CLink& link
	)
/*++

Routine Description:

    Load a URL (non-HTTP) link

Arguments:

    link - reference to the result link object
    
Return Value:

    BOOL - TRUE if success. FALSE otherwise.

--*/
{
	// Use InternetOpenUrl for all URL scheme except HTTP
	CAutoInternetHandle hOpenURL;
	hOpenURL = CWininet::InternetOpenUrlA(
		m_hInternetSession,
		link.GetURL(),
		NULL,
		0,
		INTERNET_FLAG_DONT_CACHE,
		0);

	if(!hOpenURL)
	{
		TRACE(_T("CLinkLoader::LoadURL() - InternetOpenUrlA() failed."));
		return WininetFailed(link);
	}
	else
	{
		link.SetState(CLink::eValidURL);
		return TRUE;
	}

} // CLinkLoader::LoadURL


BOOL 
CLinkLoader::LoadHTTP(
	CLink& link,
	BOOL fReadFile,
	LPCTSTR lpszHostName,
	LPCTSTR lpszUrlPath,
	int iRedirectCount /* = 0 */
	)
/*++

Routine Description:

    Load a HTTP link

Arguments:

    link - reference to the result link object
    fReadFile - read the file and save it in the link object
    lpszHostName - hostname
	lpszUrlPath - URL path
	iRedirectCount - Looping count. It is used to keep track the
                     the number of redirection for current link.

Return Value:

    BOOL - TRUE if success. FALSE otherwise.

--*/
{
	// Open an http session
	CAutoInternetHandle hHttpSession;
	hHttpSession = CWininet::InternetConnectA(
						m_hInternetSession,				// hInternetSession
						lpszHostName,				// lpszServerName
						INTERNET_INVALID_PORT_NUMBER,	// nServerPort
						_T(""),								// lpszUsername
						_T(""),								// lpszPassword
						INTERNET_SERVICE_HTTP,			// dwService
						0,								// dwFlags
						0);								// dwContext
	
	if(!hHttpSession)
	{
		TRACE(_T("CLinkLoader::LoadHTTP() - InternetConnect() failed."));
		return WininetFailed(link);
	}

	// Open an http request
	CAutoInternetHandle hHttpRequest;
	hHttpRequest = CWininet::HttpOpenRequestA(
						hHttpSession,				// hHttpSession
						_T("GET"),				// lpszVerb
                        lpszUrlPath,			// lpszObjectName
						HTTP_VERSION,				// lpszVersion
						link.GetBase(),			// lpszReferer
						NULL,						// lpszAcceptTypes
						INTERNET_FLAG_NO_AUTO_REDIRECT | INTERNET_FLAG_DONT_CACHE,	// dwFlags
						0);							// dwContext

	if(!hHttpRequest)
	{
		TRACE(_T("CLinkLoader::LoadHTTP() - HttpOpenRequest() failed."));
		return WininetFailed(link);
	}

	// Sent the http request
	if(!CWininet::HttpSendRequestA(
				hHttpRequest,	// hHttpRequest
				m_strAdditionalHeaders,	// lpszHeaders
				(DWORD)-1,		// dwHeadersLength
				0,				// lpOptional
				0))				// dwOptionalLength
	{
		TRACE(_T("CLinkLoader::LoadHTTP() - HttpSendRequest() failed."));
		return WininetFailed(link);
	}

	TCHAR szQueryResult[nQueryResultBufferSize_c];
	DWORD dwQueryLength = sizeof(szQueryResult);

	// Check the result status code
	if(!CWininet::HttpQueryInfoA(
				hHttpRequest,			// hHttpRequest
				HTTP_QUERY_STATUS_CODE,	// dwInfoLevel
				szQueryResult,			// lpvBuffer
				&dwQueryLength,			// lpdwBufferLength
				NULL))					// lpdwIndex
	{
		TRACE(_T("CLinkLoader::LoadHTTP() - HttpQueryInfo() failed."));
		return WininetFailed(link);
	}

	// Check for 301 Move Permanently or 302 Move Temporarily
	if(_ttoi(szQueryResult) == 301 || _ttoi(szQueryResult) == 302)
	{
		// We can only redirect iMaxRedirectCount_c times
		if(iRedirectCount > iMaxRedirectCount_c)
		{
			return FALSE;
		}

		// Get the new location
		dwQueryLength = sizeof(szQueryResult);

		if(!CWininet::HttpQueryInfoA(
				hHttpRequest,			// hHttpRequest
				HTTP_QUERY_LOCATION,	// dwInfoLevel
				szQueryResult,			// lpvBuffer
				&dwQueryLength,			// lpdwBufferLength
				NULL))					// lpdwIndex
		{
			TRACE(_T("CLinkLoader::LoadHTTP() - HttpQueryInfo() failed."));
			return WininetFailed(link);
		}

		// We only update the URL in link object if
		// we are redirecting from http://hostname/xyz to http://hostname/xyz/
		if(link.GetURL().GetLength() + 1 == (int)dwQueryLength &&
		   link.GetURL().GetAt(link.GetURL().GetLength() - 1) != _TCHAR('/') &&
		   szQueryResult[dwQueryLength - 1] == _TCHAR('/'))
		{
			link.SetURL(szQueryResult);
		}

		// Crack the URL & call LoadHTTP again
		TCHAR szHostName[INTERNET_MAX_HOST_NAME_LENGTH];
		TCHAR szUrlPath[INTERNET_MAX_URL_LENGTH];

		// Crack the URL 
		URL_COMPONENTS urlcomp;

		memset(&urlcomp, 0, sizeof(urlcomp));
		urlcomp.dwStructSize = sizeof(urlcomp);

		urlcomp.lpszHostName = (LPTSTR) &szHostName;
		urlcomp.dwHostNameLength = INTERNET_MAX_HOST_NAME_LENGTH;

		urlcomp.lpszUrlPath = (LPTSTR) &szUrlPath;
		urlcomp.dwUrlPathLength = INTERNET_MAX_URL_LENGTH;

		VERIFY(CWininet::InternetCrackUrlA(szQueryResult, dwQueryLength, NULL, &urlcomp));

		return LoadHTTP(link, fReadFile, szHostName, szUrlPath, ++iRedirectCount);
	}


	// Update the HTTP status code
	link.SetStatusCode(_ttoi(szQueryResult));
	
	// If the status code is not 2xx. it is a invalid link
	if(szQueryResult[0] != '2')
	{
		link.SetState(CLink::eInvalidHTTP);

		// Get the new location
		dwQueryLength = sizeof(szQueryResult);

		if(CWininet::HttpQueryInfoA(
				hHttpRequest,			// hHttpRequest
				HTTP_QUERY_STATUS_TEXT,	// dwInfoLevel
				szQueryResult,			// lpvBuffer
				&dwQueryLength,			// lpdwBufferLength
				NULL))					// lpdwIndex
		{
			link.SetStatusText(szQueryResult);
		}

		return FALSE;
	}

	// Now we have a valid http link
	link.SetState(CLink::eValidHTTP);

	// If we are not reading the file, we can return now
	if(!fReadFile)
	{
		return TRUE;
	}

	// Check the result content-type
	dwQueryLength = sizeof(szQueryResult);
	if(!CWininet::HttpQueryInfoA(
				hHttpRequest,			// hHttpRequest
				HTTP_QUERY_CONTENT_TYPE,// dwInfoLevel
				szQueryResult,			// lpvBuffer
				&dwQueryLength,			// lpdwBufferLength
				NULL))					// lpdwIndex
	{
		TRACE(_T("CLinkLoader::LoadHTTP() - HttpQueryInfo() failed."));
		return WininetFailed(link);
	}
				
	// We only load the html text for parsing
	if(!_tcsstr(szQueryResult, _T("text/html")) )
	{
		return TRUE;
	}

	link.SetContentType(CLink::eText);

	CString strBuffer;
	TCHAR buf[nReadFileBufferSize_c];
	DWORD dwBytesRead;

	// Load the text html in a loop
	do
	{
		memset(buf, 0, sizeof(buf));

		if(CWininet::InternetReadFile(
						hHttpRequest,	// hFile
						buf,			// lpBuffer
						sizeof(buf),	// dwNumberOfBytesToRead
						&dwBytesRead))	// lpNumberOfBytesRead
		{
			strBuffer += buf;
		}
		else
		{
			TRACE(_T("CLinkLoader::LoadHTTP() - InternetReadFile() failed."));
			return WininetFailed(link);
		}
	}
	while(dwBytesRead);

	// Set the InternetReadFile result in the link object
	link.SetData(strBuffer);

	return TRUE;

} // CLinkLoader::LoadHTTP



BOOL 
CLinkLoader::WininetFailed(
	CLink& link
	)
/*++

Routine Description:

    Wininet failed clean up subroutine

Arguments:

    link - reference to the result link object

Return Value:

    BOOL - Alway return TRUE

--*/
{
	link.SetState(CLink::eInvalidWininet);
	link.SetStatusCode(GetLastError());
	TRACE(_T(" GetLastError() = %d\n"), link.GetStatusCode());

	LPTSTR lpMsgBuf;
 
	if(FormatMessage( 
		FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_FROM_SYSTEM,
		CWininet::GetWininetModule(),
		GetLastError(),
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
		(LPTSTR) &lpMsgBuf,
		0,
		NULL) > 0)
	{
		link.SetStatusText(lpMsgBuf);
		LocalFree(lpMsgBuf);
	}

	return FALSE;

} // CLinkLoader::WininetFailed
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\linkchk\linkpars.cpp ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        linkpars.cpp

   Abstract:

        Link parser class implementation. This class responsible for 
		parsing the html file for hyperlink.

   Author:

        Michael Cheuk (mcheuk)

   Project:

        Link Checker

   Revision History:

--*/

#include "stdafx.h"
#include "LinkPars.h"

#include "link.h"
#include "lcmgr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// Constants
const CString strLocalHost_c(_T("localhost"));

void 
CLinkParser::Parse(
	const CString& strData, 
	const CString& strBaseURL, 
	CLinkPtrList& rLinkPtrList
	)
/*++

Routine Description:

    Parse a page of html data

Arguments:

    strData - page of html
	strBaseURL - base URL
	rLinkPtrList - reference to links list. The new links will
				   will be added to this list.

Return Value:

    N/A

--*/
{
	// Look for the first '<'
	LPCTSTR lpszOpen = _tcschr(strData, _TUCHAR('<'));

	while(lpszOpen != NULL)
	{
		// Look for the '>'
		LPCTSTR lpszClose = _tcschr(lpszOpen, _TUCHAR('>'));
		if(lpszClose)
		{
			// The possible tag must be longer than 7 bytes (a href=)
			int iCount = (int)(lpszClose - lpszOpen) - 1; // skip the '<'
			if( iCount  > 7 )
			{
				int iIndex = lpszOpen - ((LPCTSTR)strData) + 1; // skip the '<'

				CString strPossibleURL(strData.Mid(iIndex, iCount));

				// Parse the possible tag
				if(ParsePossibleTag(strPossibleURL))
				{
					CString strURL;
					BOOL fLocalLink;

					// We found a valid tag. Time to create new link.
					if( CreateURL(strPossibleURL, strBaseURL, strURL, fLocalLink) )
					{
						rLinkPtrList.AddLink(strURL, strBaseURL, strPossibleURL, fLocalLink);
					}
				}
			}
		}

		// Look for the next '<'
		lpszOpen = _tcschr(++lpszOpen, _TUCHAR('<'));
	}

} // CLinkParser::Parse


BOOL 
CLinkParser::ParsePossibleTag(
	CString& strTag
	)
/*++

Routine Description:

    Parse a single "<.....>" for possible hyperlink

Arguments:

    strTag - value inside a "<.....>" excluding '<' & '>'
			 If this is a hyperlink tag, the hyperlink URL
			 will be put in strTag.

Return Value:

    BOOL - TRUE if hyperlink tag. FALSE otherwise.

--*/
{
	// Make a working copy
	CString strWorkCopy(strTag);

	// Let's work with lower case
	strWorkCopy.MakeLower();

	//
	// Check for,
	//
	// HyperLink:
	// <a href="url" ...>
	// <a href="url#anchor" ...>
	// <a href="#anchor" ...>
	//
	// CGI
	// <a href="url?parameters" ...>
	//
	// Style Sheet
	// <link rel="stylesheet" href="url" ...>
	//
	if( strWorkCopy[0] == _T('a') ||
		strWorkCopy.Find(_T("link")) == 0 )
	{
		return GetTagValue(strTag, CString(_T("href")));
	}

	//
	// Check for,
	//
	// <body background="url" ...>
	//
	// Table:
	// <table background="url" ...>
	// <th background="url" ...>
	// <td background="url" ...>
	//
	else if( strWorkCopy.Find(_T("body")) == 0 ||
             strWorkCopy.Find(_T("table")) == 0 ||
			 strWorkCopy.Find(_T("th")) == 0 ||
			 strWorkCopy.Find(_T("td")) == 0 )
	{
		return GetTagValue(strTag, CString(_T("background")));
	}

	//
	// Check for,
	//
	// Sound:
	// <bgsound src="url" ...>
	// <sound src="url" ...>
	//
	// Frame:
	// <frame src="url" ...>
	//
	// Netscape embeded:
	// <embed src="url" ...>
	//
	// JavaScript & VB Script
	// <script src="url" language="java or vbs" ...>
	//
	else if( strWorkCopy.Find(_T("bgsound")) == 0 ||
             strWorkCopy.Find(_T("sound")) == 0 ||
			 strWorkCopy.Find(_T("frame")) == 0 ||
			 strWorkCopy.Find(_T("embed")) == 0 ||
			 strWorkCopy.Find(_T("script")) == 0 )
	{
		return GetTagValue(strTag, CString(_T("src")));
	}

	// Check for,
	//
	// Image:
	// <img src="url" ...>
	//
	// Video:
	// <img dynsrc="url">
	// 
	// VRML:
	// <img vrml="url">
	//
	else if( strWorkCopy.Find(_T("img")) == 0 )
	{
		if(GetTagValue(strTag, CString(_T("src"))))
		{
			return TRUE;
		}

		if(GetTagValue(strTag, CString(_T("dynsrc"))))
		{
			return TRUE;
		}

		return GetTagValue(strTag, CString(_T("vrml")));
	}

	// Java
	// <applet code="name.class" codebase="url" ...>
	else if( strWorkCopy.Find(_T("applet")) == 0 )
	{
		return GetTagValue(strTag, CString(_T("codebase")));
	}

	// Form
	// <form action="url" ...>
	else if( strWorkCopy.Find(_T("form")) == 0 )
	{
		return GetTagValue(strTag, CString(_T("action")));
	}

	return FALSE;

} // CLinkParser::ParsePossibleTag


BOOL 
CLinkParser::GetTagValue(
	CString& strTag, 
	const CString& strParam
	)
/*++

Routine Description:

    Get the hyperlink value from "<.....>"

Arguments:

    strTag - value inside a "<.....>" excluding '<' & '>'
			 If this is a hyperlink tag, the hyperlink URL
			 will be put in strTag.

	strParam - parameter to look for. For example, src or href

Return Value:

    BOOL - TRUE if hyperlink tag. FALSE otherwise.

--*/
{
	// Make a copy of original tag
	CString strWorkCopy(strTag);
	strWorkCopy.MakeLower();

	int iLength = strParam.GetLength();

	// Look for the parameter
	int iIndex = strWorkCopy.Find(strParam);
	if(iIndex == -1)
	{
		return FALSE;
	}

	// Remove the parameter from the tag
	CString strResult( strTag.Mid(iIndex + iLength) );
	
	// Look for '='
	iIndex = strResult.Find(_T("="));
	if(iIndex == -1)
	{
		return FALSE;
	}

	// Remove the '=' from the tag
	strResult = strResult.Mid(iIndex+1);

	// Look for the value
	int iStart = -1;
	int iEnd = -1;
	int fPara = FALSE; // is the tag start with "

	// Search for the value 
	for(int i=0; i<strResult.GetLength(); i++)
	{
		// If we found the starting index of value, look
		// for the end of the value
		if(iStart!=-1 && 
			( !fPara && strResult[i] == _TCHAR(' ') || 
			  ( fPara && strResult[i] == _TCHAR('\"') ) 
			) 
		   )
		{
			iEnd = i;
			break;
		}

		// Look for the starting index of value
		if(iStart==-1 && strResult[i] != _TCHAR(' ') && strResult[i] != _TCHAR('\"') )
		{
			iStart = i;
			if(i - 1 >= 0)
			{
				fPara = (strResult[i-1] == _TCHAR('\"')); // found a "
			}
		}
	}

	// Found the starting index
	if(iStart != -1)
	{
		// If we didn't find the end of value, use the
		// last character as end
		if(iEnd == -1)
		{
			iEnd = strResult.GetLength();
		}

		// Copy the value to the input
		strTag = strResult.Mid(iStart, (iEnd - iStart));
		
		// Change '\' to '/'
		CLinkCheckerMgr::ChangeBackSlash(strTag);

		return TRUE;
	}

	return FALSE;

} // CLinkParser::GetTagValue


BOOL 
CLinkParser::CreateURL(
	const CString& strRelativeURL,		
	const CString& strBaseURL, 
	CString& strURL, 
	BOOL& fLocalLink
	)
/*++

Routine Description:

    Create a URL from base URL & relative URL. It also check 
	the result for local or remote link

Arguments:

	strRelativeURL - relative URL
	strBaseURL - base URL
	strURL - result URL
	fLocalLink - will be set to TRUE if this is a local link

Return Value:

    BOOL - TRUE if sucess. FALSE otherwise.

--*/
{
	ASSERT(CWininet::IsLoaded());

	// Remove the anchor from the relative URL
	CString strNewRelativeURL(strRelativeURL);
	int i = strNewRelativeURL.ReverseFind(_TCHAR('#'));
	if(i != -1)
	{
		strNewRelativeURL = strNewRelativeURL.Left(i);
	}

	// Combine the URLs
	DWORD dwLength = INTERNET_MAX_URL_LENGTH;
	LPTSTR lpBuffer = strURL.GetBuffer(dwLength);

	CWininet::InternetCombineUrlA(
		strBaseURL,
		strNewRelativeURL,
		lpBuffer,
		&dwLength, 
		ICU_ENCODE_SPACES_ONLY);

	strURL.ReleaseBuffer();

	// Check for local or remote link
	URL_COMPONENTS urlcomp;

	memset(&urlcomp, 0, sizeof(urlcomp));
	urlcomp.dwStructSize = sizeof(urlcomp);
	urlcomp.dwHostNameLength = 1;

	VERIFY(CWininet::InternetCrackUrlA(strURL, strURL.GetLength(), NULL, &urlcomp));

	// Check for possible local link
	if((int)urlcomp.dwHostNameLength == m_strLocalHostName.GetLength() ||
       (int)urlcomp.dwHostNameLength == strLocalHost_c.GetLength()) // localhost
	{
		if( _tcsnccmp( urlcomp.lpszHostName, m_strLocalHostName, m_strLocalHostName.GetLength() ) == 0 || 
            _tcsnccmp( urlcomp.lpszHostName, strLocalHost_c, strLocalHost_c.GetLength() ) == 0)
		{
			fLocalLink = TRUE;

			// Local link
			if(GetLinkCheckerMgr().GetUserOptions().IsCheckLocalLinks())
			{
				return TRUE;
			}
			else
			{
				return FALSE;
			}
		}
	}
	
	// Remote link
	fLocalLink = FALSE;
	if(GetLinkCheckerMgr().GetUserOptions().IsCheckRemoteLinks())
	{
		return TRUE;
	}
	else
	{
		return FALSE;
	}

} // CLinkParser::CreateURL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\linkchk\maindlg.cpp ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        maindlg.cpp

   Abstract:

        CMainDialog dialog class implementation. This is link checker
        the main dialog. 

   Author:

        Michael Cheuk (mcheuk)

   Project:

        Link Checker

   Revision History:

--*/

#include "stdafx.h"
#include "linkchk.h"
#include "maindlg.h"

#include "browser.h"

#include "progdlg.h"
#include "athendlg.h"
#include "propsdlg.h"

#include "lcmgr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

CMainDialog::CMainDialog(
	CWnd* pParent /*=NULL*/
	): 
/*++

Routine Description:

    Constructor.

Arguments:

    pParent - pointer to parent CWnd

Return Value:

    N/A

--*/
CAppDialog(CMainDialog::IDD, pParent)
{
	//{{AFX_DATA_INIT(CMainDialog)
	m_fLogToFile = TRUE;
	m_strLogFilename = _T("c:\\LinkError.log");
	m_fCheckLocalLinks = TRUE;
	m_fCheckRemoteLinks = TRUE;
	m_fLogToEventMgr = FALSE;
	//}}AFX_DATA_INIT

}  // CMainDialog::CMainDialog


void 
CMainDialog::DoDataExchange(
	CDataExchange* pDX
	)
/*++

Routine Description:

    Called by MFC to change/retrieve dialog data

Arguments:

    pDX - 

Return Value:

    N/A

--*/
{
	CAppDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMainDialog)
	DDX_Check(pDX, IDC_LOG_TO_FILE, m_fLogToFile);
	DDX_Text(pDX, IDC_LOG_FILENAME, m_strLogFilename);
	DDX_Check(pDX, IDC_CHECK_LOCAL_LINK, m_fCheckLocalLinks);
	DDX_Check(pDX, IDC_CHECK_REMOTE_LINK, m_fCheckRemoteLinks);
	DDX_Check(pDX, IDC_LOG_TO_EVENT_MANAGER, m_fLogToEventMgr);
	//}}AFX_DATA_MAP

} // CMainDialog::DoDataExchange

BEGIN_MESSAGE_MAP(CMainDialog, CAppDialog)
	//{{AFX_MSG_MAP(CMainDialog)
	ON_BN_CLICKED(IDC_MAIN_RUN, OnMainRun)
	ON_BN_CLICKED(IDC_MAIN_CLOSE, CAppDialog::OnOK)
	ON_WM_CREATE()
	ON_BN_CLICKED(IDC_ATHENICATION, OnAthenication)
	ON_BN_CLICKED(IDC_PROPERTIES, OnProperties)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()


void 
CMainDialog::OnMainRun(
	) 
/*++

Routine Description:

    OK button click handler. This functions brings up the progress
	dialog.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
	// Retrieve the data from dialog
	UpdateData();

	// Make sure we have at least one type
	// of link checking checked
	if(!m_fCheckLocalLinks && !m_fCheckRemoteLinks)
	{
		AfxMessageBox(IDS_LINKS_NOT_CHECKED);
		return;
	}

	// Set the user options in global CUserOptions
	GetLinkCheckerMgr().GetUserOptions().SetOptions(
		m_fCheckLocalLinks, 
		m_fCheckRemoteLinks, 
		m_fLogToFile,
		m_strLogFilename,
		m_fLogToEventMgr);

	// Show the progress dialog
	CProgressDialog dlg;
	dlg.DoModal();

	CAppDialog::OnOK();

} // CMainDialog::OnMainRun

int 
CMainDialog::OnCreate(
	LPCREATESTRUCT lpCreateStruct
	) 
/*++

Routine Description:

    WM_CREATE message handler. Load the wininet.dll at this
	point.

Arguments:

    N/A

Return Value:

    int - -1 if wininet.dll fail. 0 otherwise.

--*/
{
	if (CAppDialog::OnCreate(lpCreateStruct) == -1)
		return -1;

	// Load the wininet.dll
	if (!GetLinkCheckerMgr().LoadWininet())
	{
		AfxMessageBox(IDS_WININET_LOAD_FAIL);
		return -1;
	}
	
	return 0;

} // CMainDialog::OnCreate

void 
CMainDialog::OnAthenication(
	) 
/*++

Routine Description:

    Athenication button click handler. This functions brings up the 
	athenication dialog.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
	CAthenicationDialog dlg;
	dlg.DoModal();

} // CMainDialog::OnAthenication


void 
CMainDialog::OnProperties(
	) 
/*++

Routine Description:

    Browser Properties button click handler. This functions brings up the browser
	properties dialog.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
	CPropertiesDialog dlg;
	dlg.DoModal();

} // CMainDialog::OnProperties


BOOL 
CMainDialog::OnInitDialog(
	) 
/*++

Routine Description:

    WM_INITDIALOG message handler

Arguments:

    N/A

Return Value:

    BOOL - TRUE if sucess. FALSE otherwise.

--*/
{
	CAppDialog::OnInitDialog();

    // Add the available browser to CUserOptions
	for(int i=0; i<iNumBrowsersAvailable_c; i++)
	{
		GetLinkCheckerMgr().GetUserOptions().AddAvailableBrowser(BrowsersAvailable_c[i]);
	}

    // Add the available language to CUserOptions
	for(i=0; i<iNumLanguagesAvailable_c; i++)
	{
		GetLinkCheckerMgr().GetUserOptions().AddAvailableLanguage(LanguagesAvailable_c[i]);
	}
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE

} //CMainDialog::OnInitDialog
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\linkchk\proglog.h ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        progdlg.h

   Abstract:

        CProgressLog abstract base class. This defines the 
		interface for progress logging.

   Author:

        Michael Cheuk (mcheuk)

   Project:

        Link Checker

   Revision History:

--*/

#ifndef _PROGLOG_H_
#define _PROGLOG_H_

//---------------------------------------------------------------------------
// CProgressLog abstract base class. It defines the interfaces for progress
// logging
//
class CProgressLog
{

// Public interfaces
public:

	// Destructor
	virtual ~CProgressLog() {}

	// Write to log
	virtual void Log(const CString& strProgress) = 0;

	// Worker thread notification
	virtual void WorkerThreadComplete() = 0;

}; // class CProgressLog

#endif // _PROGLOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\linkchk\progdlg.h ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        progdlg.h

   Abstract:

        CProgressDialog dialog class declaration. This progress dialog 
		is shown 

   Author:

        Michael Cheuk (mcheuk)

   Project:

        Link Checker

   Revision History:

--*/

#ifndef _PROGDLG_H_
#define _PROGDLG_H_

#include "resource.h"
#include "proglog.h"

//---------------------------------------------------------------------------
// CProgressDialog dialog
//
class CProgressDialog : public CDialog, CProgressLog
{

// Construction
public:
	CProgressDialog();

// Dialog Data
	//{{AFX_DATA(CProgressDialog)
	enum { IDD = IDD_PROGRESS };
	CButton	m_button;
	CStatic m_staticProgressText;
	//}}AFX_DATA

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CProgressDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL


// Public interfaces
public:

	// Overwrite CProgressLog ABC virtual funtions

	// Write to log
	virtual void Log(
		const CString& strProgress
		)
	{
		m_staticProgressText.SetWindowText(strProgress);
	}

	// Worker thread notification
	virtual void WorkerThreadComplete();

// Protected interfaces
protected:

	// Set the button text
	void SetButtonText(
		const CString& strText
		)
	{
		m_button.SetWindowText(strText);
	}

	// Generated message map functions
	//{{AFX_MSG(CProgressDialog)
	virtual BOOL OnInitDialog();
	afx_msg void OnProgressButton();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

}; // class CProgressDialog 

#endif // _PROGDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\linkchk\linkpars.h ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        linkpars.h

   Abstract:

        Link parser class declaration. This class responsible for 
		parsing the html file for hyperlink.

   Author:

        Michael Cheuk (mcheuk)

   Project:

        Link Checker

   Revision History:

--*/

#ifndef _LINKPARS_H_
#define _LINKPARS_H_

#include "link.h"

//---------------------------------------------------------------------------
// Link parser
//
class CLinkParser
{

// Public interfaces
public:

	// Constructor
	CLinkParser() : 
		m_strLocalHostName(_T("localhost")) {}

	// Parse a page of html data
    void Parse(
		const CString& strData, 
		const CString& strBaseUrl, 
		CLinkPtrList& rLinkPtrList
		);

	// Setup the local hostname. It will be uses for distinguishing
	// between local and remote link
	void SetLocalHostName(
		const CString& strLocalHostName
		)
	{
		m_strLocalHostName = strLocalHostName;
	}

// Protected interfaces
protected:

	// Parse a single "<.....>" for possible hyperlink
	BOOL ParsePossibleTag(
		CString& strTag
		);

	// Get the hyperlink value from "<.....>"
	BOOL GetTagValue(
		CString& strTag, 
		const CString& strParam);

	// Create a URL from base URL & relative URL. It also check the 
	// result for local & remote link
	BOOL CreateURL(
		const CString& strRelativeURL,		
		const CString& strBaseURL, 
		CString& strURL, 
		BOOL& fLocalLink);

// Protected members
protected:

	CString m_strLocalHostName; // local hostname

}; // class CLinkParser

#endif // _LINKPARS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\linkchk\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	linkchk.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\linkchk\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#ifndef _STDAFX_H_
#define _STDAFX_H_

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <afxtempl.h>


#endif //  _STDAFX_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\linkchk\propsdlg.h ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        propsdlg.h

   Abstract:

         Link checker properties dialog class declaration.

   Author:

        Michael Cheuk (mcheuk)

   Project:

        Link Checker

   Revision History:

--*/

#ifndef _PROPSDLG_H_
#define _PROPSDLG_H_

//---------------------------------------------------------------------------
// CPropertiesDialog dialog
//
class CPropertiesDialog : public CDialog
{

// Public interfaces
public:

    // Construction
	CPropertiesDialog(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CPropertiesDialog)
	enum { IDD = IDD_PROPERTIES };
	CCheckListBox	m_LanguageCheckList;
	CCheckListBox	m_BrowserCheckList;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPropertiesDialog)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

    // Get the number of items checked in a check listbox.
    int NumItemsChecked(CCheckListBox& ListBox);

	// Generated message map functions
	//{{AFX_MSG(CPropertiesDialog)
	virtual BOOL OnInitDialog();
	afx_msg void OnPropertiesOk();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#endif // _PROPSDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\linkchk\propsdlg.cpp ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        propsdlg.h

   Abstract:

         Link checker properties dialog class implementation.

   Author:

        Michael Cheuk (mcheuk)

   Project:

        Link Checker

   Revision History:

--*/

#include "stdafx.h"
#include "linkchk.h"
#include "propsdlg.h"

#include "lcmgr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


CPropertiesDialog::CPropertiesDialog(
    CWnd* pParent /*=NULL*/
    ) : 
/*++

Routine Description:

    Constructor.

Arguments:

    pParent - pointer to parent CWnd

Return Value:

    N/A

--*/
CDialog(CPropertiesDialog::IDD, pParent)
{
	//{{AFX_DATA_INIT(CPropertiesDialog)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT

} // CPropertiesDialog::CPropertiesDialog


void 
CPropertiesDialog::DoDataExchange(
    CDataExchange* pDX
    )
/*++

Routine Description:

    Called by MFC to change/retrieve dialog data

Arguments:

    pDX - 

Return Value:

    N/A

--*/
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CPropertiesDialog)
	DDX_Control(pDX, IDC_LANGUAGE_LIST, m_LanguageCheckList);
	DDX_Control(pDX, IDC_BROWSER_LIST, m_BrowserCheckList);
	//}}AFX_DATA_MAP

} // CPropertiesDialog::DoDataExchange


BEGIN_MESSAGE_MAP(CPropertiesDialog, CDialog)
	//{{AFX_MSG_MAP(CPropertiesDialog)
	ON_BN_CLICKED(IDC_PROPERTIES_OK, OnPropertiesOk)
	//}}AFX_MSG_MAP
	ON_BN_CLICKED(IDC_PROPERTIES_CANCEL, CDialog::OnCancel)
END_MESSAGE_MAP()


BOOL 
CPropertiesDialog::OnInitDialog(
    ) 
/*++

Routine Description:

    WM_INITDIALOG message handler

Arguments:

    N/A

Return Value:

    BOOL - TRUE if sucess. FALSE otherwise.

--*/
{
	CDialog::OnInitDialog();
	
    // Add all the avaiable browsers to checked list box
    CUserOptions& UserOptions = GetLinkCheckerMgr().GetUserOptions();
    int iSize = UserOptions.GetAvailableBrowsers().GetCount();

    if(iSize > 0)
    {
        CBrowserInfo BrowserInfo;
        POSITION PosBrowser = UserOptions.GetAvailableBrowsers().GetHeadPosition();

	    for(int i=0; i<iSize; i++)
	    {
            BrowserInfo = UserOptions.GetAvailableBrowsers().GetNext(PosBrowser);

		    if(i != m_BrowserCheckList.AddString(BrowserInfo.GetName()))
		    {
			    ASSERT(FALSE);
			    return FALSE;
		    }
		    else
		    {
                // Make sure they all checked
                int iChecked = BrowserInfo.IsSelected() ? 1 : 0;
			    m_BrowserCheckList.SetCheck(i, iChecked);
		    }
	    }
    }
	
    // Add all the avaiable languages to checked list box
    iSize = UserOptions.GetAvailableLanguages().GetCount();

    if(iSize > 0)
    {
        CLanguageInfo LanguageInfo;
        POSITION PosLanguage = UserOptions.GetAvailableLanguages().GetHeadPosition();

	    for(int i=0; i<iSize; i++)
	    {
            LanguageInfo = UserOptions.GetAvailableLanguages().GetNext(PosLanguage);

		    if(i != m_LanguageCheckList.AddString(LanguageInfo.GetName()))
		    {
			    ASSERT(FALSE);
			    return FALSE;
		    }
		    else
		    {
                // Make sure they all checked
                int iChecked = LanguageInfo.IsSelected() ? 1 : 0;
			    m_LanguageCheckList.SetCheck(i, iChecked);
		    }
	    }
    }

	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE

} // CPropertiesDialog::OnInitDialog


void 
CPropertiesDialog::OnPropertiesOk(
    ) 
/*++

Routine Description:

    OK button click handler. This functions add all the user checked 
    item to CUserOptions.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
    // Make sure we have at least one item checked
    if(NumItemsChecked(m_BrowserCheckList) == 0 || NumItemsChecked(m_LanguageCheckList) == 0)
    {
        AfxMessageBox(IDS_ITEM_NOT_CHECKED);
        return;
    }

    // Add the checked browsers to CUserOptions
    CUserOptions& UserOptions = GetLinkCheckerMgr().GetUserOptions();
    int iSize = UserOptions.GetAvailableBrowsers().GetCount();

    if(iSize)
    {
        POSITION PosBrowser = UserOptions.GetAvailableBrowsers().GetHeadPosition();

	    for(int i=0; i<iSize; i++)
	    {
            CBrowserInfo& BrowserInfo = UserOptions.GetAvailableBrowsers().GetNext(PosBrowser);
			BrowserInfo.SetSelect(m_BrowserCheckList.GetCheck(i) == 1);
	    }
    }

    // Add the checked languages to CUserOptions
    iSize = UserOptions.GetAvailableLanguages().GetCount();

    if(iSize)
    {
        POSITION PosLanguage = UserOptions.GetAvailableLanguages().GetHeadPosition();

	    for(int i=0; i<iSize; i++)
	    {
            CLanguageInfo& LanguageInfo = UserOptions.GetAvailableLanguages().GetNext(PosLanguage);
			LanguageInfo.SetSelect(m_LanguageCheckList.GetCheck(i) == 1);
	    }
    }

	CDialog::OnOK();

} // CPropertiesDialog::OnPropertiesOk


int 
CPropertiesDialog::NumItemsChecked(
    CCheckListBox& ListBox
    )
/*++

Routine Description:

    Get the number of items checked in a check listbox.

Arguments:

    N/A

Return Value:

    int - number of items checked.

--*/
{
    int iCheckedCount = 0;
    int iSize = ListBox.GetCount();

    for(int i=0; i<iSize; i++)
    {
        if(ListBox.GetCheck(i) == 1)
        {
            iCheckedCount++;
        }
    }

    return iCheckedCount;

} // CPropertiesDialog::NumItemsChecked
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\linkchk\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by linkchk.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_MAIN                        102
#define IDS_IISGETADMININFORMATION_ERROR 102
#define IDS_IIS_VIRTUALROOT_NOT_EXIST   103
#define IDS_ITEM_NOT_CHECKED            104
#define IDS_WININET_LOAD_FAIL           105
#define IDS_LINKS_NOT_CHECKED           106
#define IDS_LC_FAIL                     107
#define IDS_CLOSE                       108
#define IDS_PROGRESS_FINISH             109
#define IDS_WORKER_THREAD_TERMINATE     110
#define IDR_MAINFRAME                   128
#define IDD_PROGRESS                    129
#define IDD_PROPERTIES                  130
#define IDD_ATHENICATION                131
#define IDD_USAGE                       132
#define IDC_ABOUT_OK                    1000
#define IDC_MAIN_RUN                    1001
#define IDC_MAIN_CLOSE                  1002
#define IDC_CHECK_REMOTE_LINK           1003
#define IDC_CHECK_LOCAL_LINK            1004
#define IDC_PROPERTIES                  1005
#define IDC_LOG_TO_EVENT_MANAGER        1006
#define IDC_LOG_TO_FILE                 1007
#define IDC_LOG_FILENAME                1008
#define IDC_ATHENICATION                1009
#define IDC_PROGRESS_BUTTON             1010
#define IDC_PROGRESS_TEXT               1011
#define IDC_PROPERTIES_OK               1012
#define IDC_PROPERTIES_CANCEL           1013
#define IDC_BROWSER_LIST                1014
#define IDC_LANGUAGE_LIST               1015
#define IDC_ATHENICATION_OK             1016
#define IDC_ATHENICATION_CANCEL         1017
#define IDC_NT_USERNAME                 1018
#define IDC_NT_PASSWORD                 1019
#define IDC_BROWSE_NT_USERNAME          1020
#define IDC_BASIC_USERNAME              1021
#define IDC_BASIC_PASSWORD              1022

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        134
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1023
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\mime\mainfrm.cpp ===
// mainfrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"
#include "mime.h"

#include "mainfrm.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
	//{{AFX_MSG_MAP(CMainFrame)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
	// TODO: add member initialization code here
	
}

CMainFrame::~CMainFrame()
{
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
	CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
	CFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\linkchk\useropt.cpp ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        useropt.h

   Abstract:

        Global user options class and help class implementations. This class 
		can only instantiate by CLinkCheckerMgr. Therefore, a single instance 
		of this class will live inside CLinkCheckerMgr. You can access
		the this instance by calling GetLinkCheckMgr().GetUserOptions().

   Author:

        Michael Cheuk (mcheuk)

   Project:

        Link Checker

   Revision History:

--*/

#include "stdafx.h"
#include "useropt.h"

#include "lcmgr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

//------------------------------------------------------------------
// CVirtualDirInfo
//

void 
CVirtualDirInfo::PreProcessAlias(
	)
/*++

Routine Description:

    Preprocess the current virtual directory alias. The alias will be in
	the form of / or /dir/

Arguments:

    N/A

Return Value:

    N/A

--*/
{
	// Change everything to lower case
	m_strAlias.MakeLower();

	// Change '\' to '/'
	CLinkCheckerMgr::ChangeBackSlash(m_strAlias);

	// Make sure strAlias is in the form of / or /dir/
	if( m_strAlias.GetAt( m_strAlias.GetLength() - 1 ) != _TCHAR('/') )
	{
		m_strAlias += _TCHAR('/');
	}

} // CVirtualDirInfo::PreProcessAlias


void 
CVirtualDirInfo::PreProcessPath(
	)
/*++

Routine Description:

    Preprocess the current virtual directory path. The alias will be in
	the form of c:\ or c:\dir\

Arguments:

    N/A

Return Value:

    N/A

--*/
{
	// Change everything to lower case
	m_strPath.MakeLower();

	// Make sure strPath is in the form of \ or \dir\
	if( m_strPath.GetAt( m_strPath.GetLength() - 1 ) != _TCHAR('\\') )
	{
		m_strPath += _TCHAR('\\');
	}

}  // CVirtualDirInfo::PreProcessPath

//------------------------------------------------------------------
// CBrowserInfoList
//

POSITION 
CBrowserInfoList::GetHeadSelectedPosition(
    ) const
/*++

Routine Description:

    Get the first selected browser. It works like GetHeadPosition()

Arguments:

    N/A
Return Value:

    POSITION - A POSITION value that can be used for iteration or 
               object pointer retrieval; NULL if the list is empty

--*/
{
    POSITION Pos = GetHeadPosition();

    while(Pos)
    {
        POSITION PosCurrent = Pos;
        if(GetNext(Pos).IsSelected())
        {
            return PosCurrent;
            break;
        }
    }

    return NULL;

} // CBrowserInfoList::GetHeadSelectedPosition

CBrowserInfo& 
CBrowserInfoList::GetNextSelected(
    POSITION& Pos
    )
/*++

Routine Description:

    Get next selected browser. It works like GetNext()

Arguments:

    Pos - A reference to a POSITION value returned by 
          a previous GetHeadSelectedPosition, GetNextSelected

Return Value:

    CBrowserInfo& - returns a reference to an element of the list

--*/
{
    CBrowserInfo& Info = GetNext(Pos);

    while(Pos)
    {
        POSITION PosCurrent = Pos;
        if(GetNext(Pos).IsSelected())
        {
            Pos = PosCurrent;
            break;
        }
    }

    return Info;

} // CBrowserInfoList::GetNextSelected

//------------------------------------------------------------------
// CLanguageInfoList
//

POSITION 
CLanguageInfoList::GetHeadSelectedPosition(
    ) const
/*++

Routine Description:

    Get the first selected browser. It works like GetHeadPosition()

Arguments:

    N/A
Return Value:

    POSITION - A POSITION value that can be used for iteration or 
               object pointer retrieval; NULL if the list is empty

--*/
{
    POSITION Pos = GetHeadPosition();

    while(Pos)
    {
        POSITION PosCurrent = Pos;
        if(GetNext(Pos).IsSelected())
        {
            return PosCurrent;
            break;
        }
    }

    return NULL;

} // CLanguageInfo::GetHeadSelectedPosition

CLanguageInfo& 
CLanguageInfoList::GetNextSelected(
    POSITION& Pos
    )
/*++

Routine Description:

    Get next selected language. It works like GetNext()

Arguments:

    Pos - A reference to a POSITION value returned by 
          a previous GetNext, GetHeadPosition, GetNextSelected, 
          or other member function call

Return Value:

    CLanguageInfo& - returns a reference to an element of the list

--*/
{
    CLanguageInfo& Info = GetNext(Pos);

    while(Pos)
    {
        POSITION PosCurrent = Pos;
        if(GetNext(Pos).IsSelected())
        {
            Pos = PosCurrent;
            break;
        }
    }

    return Info;

} // CLanguageInfoList::GetNextSelected

//------------------------------------------------------------------
// CUserOptions
//

void 
CUserOptions::AddDirectory(
	const CVirtualDirInfo& Info
	)
/*++

Routine Description:

    Add this virtual directory to the link list.

Arguments:

    Info - virtual directory infomation to add

Return Value:

    N/A

--*/
{
	// Finally, add it to the array
	try
	{
		m_VirtualDirInfoList.AddTail(Info);
	}
	catch(CMemoryException* pEx)
	{
		pEx->Delete();
	}

} // CUserOptions::AddDirectory


void  
CUserOptions::AddURL(
	LPCTSTR lpszURL
	)
/*++

Routine Description:

    Add this URL to the link list.

Arguments:

    lpszURL - URL to add

Return Value:

    N/A

--*/
{
	CString strURL(lpszURL);

	// Change '\' to '/'
	CLinkCheckerMgr::ChangeBackSlash(strURL);

	try
	{
		m_strURLList.AddTail(strURL);
	}
	catch(CMemoryException* pEx)
	{
		pEx->Delete();
	}

} // CUserOptions::AddURL


void 
CUserOptions::AddAvailableBrowser(
	const CBrowserInfo& Info
	)
/*++

Routine Description:

    Add this browser information to the available list.

Arguments:

    Info - Browser information to add

Return Value:

    N/A

--*/
{
	try
	{
		m_BrowserInfoList.AddTail(Info);
	}
	catch(CMemoryException* pEx)
	{
		pEx->Delete();
	}

} // CUserOptions::AddAvailableBrowser


void 
CUserOptions::AddAvailableLanguage(
	const CLanguageInfo& Info
	)
/*++

Routine Description:

    Add this language information to the available list.

Arguments:

    Info - Language information to add

Return Value:

    N/A

--*/
{
	try
	{
		m_LanguageInfoList.AddTail(Info);
	}
	catch(CMemoryException* pEx)
	{
		pEx->Delete();
	}

} // CUserOptions::AddAvailableLanguage


void 
CUserOptions::SetOptions(
	BOOL fCheckLocalLinks, 
	BOOL fCheckRemoteLinks, 
	BOOL fLogToFile,
	const CString& strLogFilename,
	BOOL fLogToEventMgr
	)
/*++

Routine Description:

    Set the user options in the main dialog

Arguments:

    N/A

Return Value:

    N/A

--*/
{
	m_fCheckLocalLinks = fCheckLocalLinks;
	m_fCheckRemoteLinks = fCheckRemoteLinks;

	m_fLogToFile= fLogToFile;
	m_strLogFilename = strLogFilename;

	m_fLogToEventMgr = fLogToEventMgr;

} // CUserOptions::SetOptions


void 
CUserOptions::SetAthenication(
	const CString& strNTUsername,
	const CString& strNTPassword,
	const CString& strBasicUsername,
	const CString& strBasicPassword
	)
/*++

Routine Description:

    Set NTLM & HTTP basic athenications.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
	m_strNTUsername = strNTUsername;
	m_strNTPassword = strNTPassword;

	m_strBasicUsername = strBasicUsername;
	m_strBasicPassword = strBasicPassword;

} // CUserOptions::SetAthenication


// Get the hostname
const CString& 
CUserOptions::GetHostName(
	)
/*++

Routine Description:

    Get the hostname.

Arguments:

    N/A

Return Value:

    N/A

--*/
{
	// If the hostname does not exists, it means the user pass in
	// a list of URL to link checker. (Server nane is not required for 
	// this case.) Now, we can get the hostname from the URL
	if(m_strHostName.IsEmpty() && m_strURLList.GetCount() > 0)
	{
		// Set up the current hostname string
		LPTSTR lpszHostName = m_strHostName.GetBuffer(INTERNET_MAX_HOST_NAME_LENGTH);

		URL_COMPONENTS urlcomp;
		memset(&urlcomp, 0, sizeof(urlcomp));
		urlcomp.dwStructSize = sizeof(urlcomp);
		urlcomp.lpszHostName = lpszHostName;
		urlcomp.dwHostNameLength = INTERNET_MAX_HOST_NAME_LENGTH;

		// Crack it
		VERIFY(CWininet::InternetCrackUrlA(
			m_strURLList.GetHead(), m_strURLList.GetHead().GetLength(), NULL, &urlcomp));

		m_strHostName.ReleaseBuffer();
	}

	return m_strHostName;

} // CUserOptions::GetHostName


void 
CUserOptions::PreProcessServerName(
	)
/*++

Routine Description:

    Preprocess the server name such that for server "\\hostname"
	- GetServerName() return \\hostname
	- GetHostName() return hostname

Arguments:

    N/A

Return Value:

    N/A

--*/
{
	// Change everything to lower case
	m_strHostName.MakeLower();

	// Change '\' to '/'
	CLinkCheckerMgr::ChangeBackSlash(m_strHostName);

	// Make sure m_strHostName is not in front of localhost
	const CString strBackSlash(_T("//"));
	if( m_strHostName.Find(strBackSlash) == 0 )
	{
		m_strHostName = m_strHostName.Mid(strBackSlash.GetLength());
	}

} // CUserOptions::PreProcessServerName
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\mime\mime.h ===
// mime.h : main header file for the MIME application
//

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CMimeApp:
// See mime.cpp for the implementation of this class
//

class CMimeApp : public CWinApp
{
public:
	CMimeApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMimeApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CMimeApp)
	afx_msg void OnAppAbout();
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\mime\mainfrm.h ===
// mainfrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

class CMainFrame : public CFrameWnd
{
protected: // create from serialization only
	CMainFrame();
	DECLARE_DYNCREATE(CMainFrame)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainFrame)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainFrame();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

// Generated message map functions
protected:
	//{{AFX_MSG(CMainFrame)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\linkchk\useropt.h ===
/*++

   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

        useropt.h

   Abstract:

        Global user options class and help classes declarations. This class 
		can only instantiate by CLinkCheckerMgr. Therefore, a single instance 
		of this class will live inside CLinkCheckerMgr. You can access
		the this instance by calling GetLinkCheckMgr().GetUserOptions().

   Author:

        Michael Cheuk (mcheuk)

   Project:

        Link Checker

   Revision History:

--*/

#ifndef _USEROPT_H_
#define _USEROPT_H_

//------------------------------------------------------------------
// IIS Virtual directory information
//
class CVirtualDirInfo
{

// Public Funtions
public:

	// Constructor
	CVirtualDirInfo() {}

	// Constructor
	inline CVirtualDirInfo(
		const CString& strAlias,	// virtual directory alias
		const CString& strPath		// virtual directory path
		) :
	m_strAlias(strAlias), m_strPath(strPath)
	{
		PreProcessAlias();
		PreProcessPath();
	}

	// Get the virtual directory alias
	const CString& GetAlias() const
	{
		return m_strAlias;
	}

	// Set the virtual directory alias
	void SetAlias(
		const CString& strAlias
		)
	{
		m_strAlias = strAlias;
		PreProcessAlias();
	}

	// Get the virtual directory path
	const CString& GetPath() const
	{
		return m_strPath;
	}

	// Set the virtual directory path
	void SetPath(
		const CString& strPath
		)
	{
		m_strPath = strPath;
		PreProcessPath();
	}

// Protected funtions
protected:

	// Preprocess the current virtual directory alias
	void PreProcessAlias();

	// Preprocess the current virtual directory path
	void PreProcessPath();

// Protected members
protected:

	CString m_strAlias;		// virtual directory alias
    CString m_strPath;		// virtual directory path

}; // class CVirtualDirInfo


//------------------------------------------------------------------
// CVirtualDirInfo (IIS Virtual directory information) link list
//
typedef
class CList<CVirtualDirInfo, const CVirtualDirInfo&>
CVirtualDirInfoList;


//------------------------------------------------------------------
// Browser information. Link checker uses this class to store
// the avaiable browser emulation.
//
class CBrowserInfo
{

// Public Funtions
public:

	// Constructor
	CBrowserInfo() 
    {
        m_fSelected = FALSE;
    }

	// Constructor
	CBrowserInfo(
		LPCTSTR lpszName,		// user friendly name
		LPCTSTR lpszUserAgent,	// HTTP user agent name
        BOOL fSelect            // select this browser to emulate
		):
	m_strName(lpszName), 
	m_strUserAgent(lpszUserAgent)
    {
        m_fSelected = fSelect;
    }

	// Get the user friendly browser name
	const CString& GetName() const
	{
		return m_strName;
	}

	// Set the user friendly browser name
	void SetName(
		const CString& strName 
		)
	{
		m_strName = strName;
	}

	// Get the HTTP user agent name
	const CString& GetUserAgent() const
	{
		return m_strUserAgent;
	}

	// Set the HTTP user agent name
	void SetUserAgent(
		const CString& strUserAgent
		)
	{
		m_strUserAgent = strUserAgent;
	}

    // Select or unselect this browser
    void SetSelect(BOOL fSelect)
    {
        m_fSelected = fSelect;
    }

    // Select or unselect this browser
    BOOL IsSelected() const 
    {
        return m_fSelected;
    }

// Protected members
protected:

	CString m_strName;		// user friendly browser name (eg. Microsoft Internet Explorer 4.0)
    CString m_strUserAgent; // HTTP user agent name
    BOOL m_fSelected;       // is browser selected ?

}; // class CBrowserInfo


//------------------------------------------------------------------
// CBrowserInfo (browser informations) link list
//
class CBrowserInfoList : public CList<CBrowserInfo, const CBrowserInfo&>
{

// Public interfaces
public:

    // Get the first selected browser. It works like GetHeadPosition()
    POSITION GetHeadSelectedPosition() const;

    // Get next selected browser. It works like GetNext()
    CBrowserInfo& GetNextSelected(
        POSITION& Pos
        );
};


//------------------------------------------------------------------
// Language informations. Link checker uses this class to store
// the avaiable language emulation.
//
class CLanguageInfo
{

// Public funtions
public:

	// Constructor
	CLanguageInfo() 
    {
        m_fSelected = FALSE;
    }

	// Constructor
	CLanguageInfo(
		LPCTSTR lpszName,		// language name
		LPCTSTR lpszAcceptName,	// HTTP accept language name
        BOOL fSelect            // select this language to emulate
		) :
	m_strName(lpszName), 
	m_strAcceptName(lpszAcceptName),
    m_fSelected(fSelect) {}

	// Get the language name
	const CString& GetName() const
	{
		return m_strName;
	}

	// Set the language name
	void SetName(
		const CString& strName
		)
	{
		m_strName = strName;
	}

	// Get the HTTP accept language name
	const CString& GetAcceptName() const
	{
		return m_strAcceptName;
	}

	// Get the HTTP accept language name
	void SetAcceptName(
		const CString& strAcceptName
		)
	{
		m_strAcceptName = strAcceptName;
	}

    // Select or unselect this language
    void SetSelect(BOOL fSelect)
    {
        m_fSelected = fSelect;
    }

    // Select or unselect this language
    BOOL IsSelected() const 
    {
        return m_fSelected;
    }

// Protected members
protected:

	CString m_strName;			// Language name (eg. Western English)
    CString m_strAcceptName;	// HTTP accept language name (eg. en)
    BOOL m_fSelected;           // is language selected ?

}; // class CLanguageInfo


//------------------------------------------------------------------
// CLanguageInfo (Language informations) link list
//
class CLanguageInfoList : public CList<CLanguageInfo, const CLanguageInfo&>
{

// Public interfaces
public:

    // Get the first selected browser. It works like GetHeadPosition()
    POSITION GetHeadSelectedPosition() const;

    // Get next selected language. It works like GetNext()
    CLanguageInfo& GetNextSelected(
        POSITION& Pos
        );
};


//------------------------------------------------------------------
// Forward declaration
//
class CLinkCheckerMgr;

//------------------------------------------------------------------
// Global user options class
//
class CUserOptions
{

// Protected interfaces
protected:

	// This class can only instantiate by CLinkCheckerMgr
	friend CLinkCheckerMgr;
	
	// Protected constructor & destructor
	CUserOptions() {}
	~CUserOptions() {}

// Public interfaces
public:

	// Set the user options in the main dialog
	void SetOptions(
		BOOL fCheckLocalLinks,			// check local link?
		BOOL fCheckRemoteLinks,			// check remote link?
		BOOL fLogToFile,				// log to file
		const CString& strLogFilename,	// log filename
		BOOL fLogToEventMgr				// log to event manager
		);

	// Check local links
	BOOL IsCheckLocalLinks() const
	{
		return  m_fCheckLocalLinks;
	}

	// Check remote links
	BOOL IsCheckRemoteLinks() const
	{
		return m_fCheckRemoteLinks;
	}

    // Is log to file ?
    BOOL IsLogToFile() const
    {
        return m_fLogToFile;
    }

	// Get log filename
	const CString& GetLogFilename() const
	{
		return m_strLogFilename;
	}

	// The following link lists are used 
	// for transversing the server
	// 
	// User can only have 
	// a list of virtual directory or a list of URL

	// Add this virtual directory to the link list
	void AddDirectory(
		const CVirtualDirInfo& Info
		);

	// Get virtual directory link list
	const CVirtualDirInfoList& GetDirectoryList() const
	{
		return m_VirtualDirInfoList;
	}

	// Add this URL to the link list
	void AddURL(
		LPCTSTR lpszURL
		);
	
	// Get the URL link list
	const CStringList& GetURLList() const
	{
		return m_strURLList;
	}

	// The following link lists are used 
	// to store the available browswers and languages
    // for user selection
	// 

	// Add this browser to the available list
	void AddAvailableBrowser(
		const CBrowserInfo& Info
		);

	// Get the browser available list
	CBrowserInfoList& GetAvailableBrowsers()
	{
		return m_BrowserInfoList;
	}

	// Add this language information to available list
	void AddAvailableLanguage(
		const CLanguageInfo& Info
		);

	// Get the language available list
	CLanguageInfoList& GetAvailableLanguages()
	{
		return m_LanguageInfoList;
	}

	// Log to event manager?
	BOOL IsLogToEventMgr()
	{
		return m_fLogToEventMgr;
	}

	// Set NTLM & basic athenications
	void SetAthenication(
		const CString& strNTUsername,
		const CString& strNTPassword,
		const CString& strBasicUsername,
		const CString& strBasicPassword
		);

	// Get NTLM athenication password username
	const CString& GetNTUsername() const
	{
		return m_strNTUsername;
	}

	// Get NTLM athenication password
	const CString& GetNTPassword() const
	{
		return m_strNTPassword;
	}

	// Get HTTP basic athenication username
	const CString& GetBasicUsername() const
	{
		return m_strBasicUsername;
	}

	// Get HTTP basic athenication password
	const CString& GetBasicPassword() const
	{
		return m_strBasicPassword;
	}

	// Set the server name
	void SetServerName(
		const CString& strServerName
		)
	{
		m_strHostName = strServerName;
		PreProcessServerName();
	}

	// Get the server name
	const CString& GetServerName()
	{
		return CString(_T("\\\\")) + GetHostName();
	}

    // Set the hostname
	void SetHostName(
		const CString& strHostName
		)
	{
		m_strHostName = strHostName;
		PreProcessServerName();
	}

	// Get the hostname
	const CString& GetHostName();

// Protected funtions
protected:

	// Preprocess the server name such that for server "\\hostname"
	//  GetServerName() return \\hostname
	//  GetHostName() return hostname
	void PreProcessServerName();

// Protected members
protected:
	
	CString m_strLogFilename;	// log filename

	CVirtualDirInfoList m_VirtualDirInfoList;	// virtual link list
	CStringList	m_strURLList;					// URL link list
	CBrowserInfoList m_BrowserInfoList;			// browswer infomation link list
	CLanguageInfoList m_LanguageInfoList;		// language information link list

	CString m_strNTUsername;	// NTLM athenication username
	CString m_strNTPassword;	// NTLM athenication password

	CString m_strBasicUsername;	// HTTP basic athenication username
	CString m_strBasicPassword; // HTTP basic athenication password

	CString m_strHostName; // hostname

	BOOL m_fCheckLocalLinks;	// check local links?
	BOOL m_fCheckRemoteLinks;	// check remote links?
	BOOL m_fLogToFile;			// log to file
	BOOL m_fLogToEventMgr;		// log to event manager
};


#endif //  _USEROPT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\mime\mimedoc.cpp ===
// mimedoc.cpp : implementation of the CMimeDoc class
//

#include "stdafx.h"
#include "mime.h"

#include "mimedoc.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMimeDoc

IMPLEMENT_DYNCREATE(CMimeDoc, CDocument)

BEGIN_MESSAGE_MAP(CMimeDoc, CDocument)
	//{{AFX_MSG_MAP(CMimeDoc)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMimeDoc construction/destruction

CMimeDoc::CMimeDoc()
{
	// TODO: add one-time construction code here

}

CMimeDoc::~CMimeDoc()
{
}

BOOL CMimeDoc::OnNewDocument()
{
	if (!CDocument::OnNewDocument())
		return FALSE;

	// TODO: add reinitialization code here
	// (SDI documents will reuse this document)

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CMimeDoc serialization

void CMimeDoc::Serialize(CArchive& ar)
{
	if (ar.IsStoring())
	{
		// TODO: add storing code here
	}
	else
	{
		// TODO: add loading code here
	}
}

/////////////////////////////////////////////////////////////////////////////
// CMimeDoc diagnostics

#ifdef _DEBUG
void CMimeDoc::AssertValid() const
{
	CDocument::AssertValid();
}

void CMimeDoc::Dump(CDumpContext& dc) const
{
	CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMimeDoc commands
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\mime\mimeview.cpp ===
// mimeview.cpp : implementation of the CMimeView class
//

#include "stdafx.h"
#include "mime.h"

#include "mimedoc.h"
#include "mimeview.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMimeView

IMPLEMENT_DYNCREATE(CMimeView, CFormView)

BEGIN_MESSAGE_MAP(CMimeView, CFormView)
	//{{AFX_MSG_MAP(CMimeView)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMimeView construction/destruction

CMimeView::CMimeView()
	: CFormView(CMimeView::IDD)
{
	//{{AFX_DATA_INIT(CMimeView)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	// TODO: add construction code here

}

CMimeView::~CMimeView()
{
}

void CMimeView::DoDataExchange(CDataExchange* pDX)
{
	CFormView::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CMimeView)
		// NOTE: the ClassWizard will add DDX and DDV calls here
	//}}AFX_DATA_MAP
}

/////////////////////////////////////////////////////////////////////////////
// CMimeView diagnostics

#ifdef _DEBUG
void CMimeView::AssertValid() const
{
	CFormView::AssertValid();
}

void CMimeView::Dump(CDumpContext& dc) const
{
	CFormView::Dump(dc);
}

CMimeDoc* CMimeView::GetDocument() // non-debug version is inline
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CMimeDoc)));
	return (CMimeDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMimeView message handlers

void CMimeView::OnInitialUpdate() 
{
	ResizeParentToFit();
		
	CFormView::OnInitialUpdate();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\mime\mimedoc.h ===
// mimedoc.h : interface of the CMimeDoc class
//
/////////////////////////////////////////////////////////////////////////////

class CMimeDoc : public CDocument
{
protected: // create from serialization only
	CMimeDoc();
	DECLARE_DYNCREATE(CMimeDoc)

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMimeDoc)
	public:
	virtual BOOL OnNewDocument();
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMimeDoc();
	virtual void Serialize(CArchive& ar);   // overridden for document i/o
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CMimeDoc)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\mime\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\mime\mime.cpp ===
// mime.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "mime.h"

#include "mainfrm.h"
#include "mimedoc.h"
#include "mimeview.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CMimeApp

BEGIN_MESSAGE_MAP(CMimeApp, CWinApp)
	//{{AFX_MSG_MAP(CMimeApp)
	ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
	// Standard file based document commands
	ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
	ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CMimeApp construction

CMimeApp::CMimeApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CMimeApp object

CMimeApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CMimeApp initialization

BOOL CMimeApp::InitInstance()
{
	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

	Enable3dControls();

	LoadStdProfileSettings(0);  // Load standard INI file options (including MRU)

	// Register the application's document templates.  Document templates
	//  serve as the connection between documents, frame windows and views.

	CSingleDocTemplate* pDocTemplate;
	pDocTemplate = new CSingleDocTemplate(
		IDR_MAINFRAME,
		RUNTIME_CLASS(CMimeDoc),
		RUNTIME_CLASS(CMainFrame),       // main SDI frame window
		RUNTIME_CLASS(CMimeView));
	AddDocTemplate(pDocTemplate);

	// create a new (empty) document
	OnFileNew();

	if (m_lpCmdLine[0] != '\0')
	{
		// TODO: add command line processing here
	}

	return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

// Implementation
protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//{{AFX_MSG(CAboutDlg)
		// No message handlers
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CMimeApp::OnAppAbout()
{
	CAboutDlg aboutDlg;
	aboutDlg.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CMimeApp commands
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\mime\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	mime.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\mime\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by mime.rc
//
#define IDD_ABOUTBOX                    100
#define IDD_MIME_FORM                   101
#define IDR_MAINFRAME                   128
#define IDC_LIST1                       1000
#define IDC_MIME_ICON                   1001
#define IDC_BUTTON2                     1003
#define IDC_BUTTON3                     1004
#define IDC_HELP                        1005
#define IDC_BUTTON5                     1006

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        130
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1003
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\mime\mimeview.h ===
// mimeview.h : interface of the CMimeView class
//
/////////////////////////////////////////////////////////////////////////////

class CMimeView : public CFormView
{
protected: // create from serialization only
	CMimeView();
	DECLARE_DYNCREATE(CMimeView)

public:
	//{{AFX_DATA(CMimeView)
	enum{ IDD = IDD_MIME_FORM };
		// NOTE: the ClassWizard will add data members here
	//}}AFX_DATA

// Attributes
public:
	CMimeDoc* GetDocument();

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMimeView)
	public:
	virtual void OnInitialUpdate();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMimeView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CMimeView)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in mimeview.cpp
inline CMimeDoc* CMimeView::GetDocument()
   { return (CMimeDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\w3key\cmnkey.cpp ===
// common methods between the old w3key and the new mdkey

#include "stdafx.h"
#include "KeyObjs.h"

#include "CmnKey.h"
#include "resource.h"


//-------------------------------------------------------------
CCmnKey::CCmnKey()
	{
	}

//-------------------------------------------------------------
void CCmnKey::SetName( CString &szNewName )
	{
	m_szName = szNewName;
	UpdateCaption();
	SetDirty( TRUE );
	}

//-------------------------------------------------------------
CString CCmnKey::GetName()
	{
	return m_szName;
	}

//================ properties related methods
//-------------------------------------------------------------
// brings up the key properties dialog
//-------------------------------------------------------------
void CCmnKey::OnUpdateProperties(CCmdUI* pCmdUI)
	{
	pCmdUI->Enable( TRUE );
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\w3key\bindsdlg.h ===
// BindsDlg.h : header file
//


/////////////////////////////////////////////////////////////////////////////
class CBingingRemoval : public CObject
{
public:
	// constructor
	CBingingRemoval( CMDKey* pTargetKey, CString szTargetBinding ) :
			m_pTargetKey( pTargetKey )
		{
		m_szTargetBinding = szTargetBinding;
		}

	// remove the binding
	inline void RemoveBinding();
	CMDKey*	m_pTargetKey;
	CString	m_szTargetBinding;
};

//--------------------------------------------------------
inline void CBingingRemoval::RemoveBinding()
	{
	// tell the key to remove the binding - easy!
	m_pTargetKey->RemoveBinding( m_szTargetBinding );
	// update the key's name
	m_pTargetKey->m_fUpdateBindings = TRUE;
	}


/////////////////////////////////////////////////////////////////////////////
// CBindingsDlg dialog

class CBindingsDlg : public CDialog
{
// Construction
public:
	CBindingsDlg(WCHAR* pszw, CWnd* pParent = NULL);   // standard constructor

	virtual BOOL OnInitDialog();


	// the base key that is being worked on
	CMDKey*		m_pKey;

    // target machine
    WCHAR*      m_pszwMachineName;

	// is a binding string already a part of the list in this dialog?
	BOOL		FContainsBinding( CString sz );

	// add a binding to the list
	void	AddBinding( CString sz );

	// a queue of bindings to be removed if the user says OK
	CTypedPtrArray<CObArray, CBingingRemoval*> rgbRemovals;

// Dialog Data
	//{{AFX_DATA(CBindingsDlg)
	enum { IDD = IDD_BINDINGS };
	CButton	m_cbutton_delete;
	CButton	m_cbutton_edit;
	CListSelRowCtrl	m_clistctrl_list;
	//}}AFX_DATA
//	CListCtrl	m_clistctrl_list;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CBindingsDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CBindingsDlg)
	afx_msg void OnAdd();
	afx_msg void OnDelete();
	afx_msg void OnEdit();
	afx_msg void OnItemchangedList(NMHDR* pNMHDR, LRESULT* pResult);
	virtual void OnOK();
	afx_msg void OnDblclkList(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	// initialize the list
	void FillInBindings();
	BOOL FInitList();
	void UpdateBindingDisplay( DWORD iItem, CString szBinding );

	// enable the buttons as appropriate
	void EnableButtons();

	// edit the selected binding, return a flag for OK
	BOOL FEdit( CString &sz );

	// return the index of the selected item - only one selection allowed
	inline int	GetSelectedIndex();
};



//--------------------------------------------------------
// return the index of the selected item - only one selection allowed
inline int	CBindingsDlg::GetSelectedIndex()
	{
	return m_clistctrl_list.GetNextItem( -1, LVNI_SELECTED );
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\w3key\bindsdlg.cpp ===
// BindsDlg.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"

#include "KeyObjs.h"
#include "wrapmb.h"
#include "cmnkey.h"
#include "mdkey.h"

#include "ListRow.h"
#include "BindsDlg.h"
#include "EdtBindD.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define COL_RAW				0
#define COL_IP				1
#define COL_PORT			2


/////////////////////////////////////////////////////////////////////////////
// CBindingsDlg dialog


CBindingsDlg::CBindingsDlg(WCHAR* pszw, CWnd* pParent /*=NULL*/)
	: CDialog(CBindingsDlg::IDD, pParent),
    m_pszwMachineName( pszw )
	{
	//{{AFX_DATA_INIT(CBindingsDlg)
		// NOTE: the ClassWizard will add member initialization here
	//}}AFX_DATA_INIT
	}


void CBindingsDlg::DoDataExchange(CDataExchange* pDX)
	{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CBindingsDlg)
	DDX_Control(pDX, IDC_DELETE, m_cbutton_delete);
	DDX_Control(pDX, IDC_EDIT, m_cbutton_edit);
	DDX_Control(pDX, IDC_LIST, m_clistctrl_list);
	//}}AFX_DATA_MAP
	}


BEGIN_MESSAGE_MAP(CBindingsDlg, CDialog)
	//{{AFX_MSG_MAP(CBindingsDlg)
	ON_BN_CLICKED(IDC_ADD, OnAdd)
	ON_BN_CLICKED(IDC_DELETE, OnDelete)
	ON_BN_CLICKED(IDC_EDIT, OnEdit)
	ON_NOTIFY(LVN_ITEMCHANGED, IDC_LIST, OnItemchangedList)
	ON_NOTIFY(NM_DBLCLK, IDC_LIST, OnDblclkList)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

//---------------------------------------------------------------------------
BOOL CBindingsDlg::OnInitDialog()
	{
	// call the parental oninitdialog
	BOOL f = CDialog::OnInitDialog();

	// set up the columns
	FInitList();

	// fill in the bindings
	FillInBindings();

	// set the initial states of the buttons
	EnableButtons();

	// return the answer
	return f;
	}

//-----------------------------------------------------------------
BOOL CBindingsDlg::FInitList()
	{
	CString sz;
	int             i;

	// setup the raw field
	sz.LoadString( IDS_IP_ADDRESS );
	i = m_clistctrl_list.InsertColumn( COL_RAW, " ", LVCFMT_LEFT, 0 );

	// setup the alias field
	sz.LoadString( IDS_IP_ADDRESS );
	i = m_clistctrl_list.InsertColumn( COL_IP, sz, LVCFMT_LEFT, 118 );

	// setup the directory field
	sz.LoadString( IDS_PORT_NUMBER );
	i = m_clistctrl_list.InsertColumn( COL_PORT, sz, LVCFMT_LEFT, 118);

	return TRUE;
	}

//--------------------------------------------------------
// This provides us another opportunity to parse the 
void CBindingsDlg::AddBinding( CString sz )
	{
	DWORD	i;
	BOOL	f;

	// add the binding string to the dislpay list
	i = m_clistctrl_list.InsertItem( 0, " " );

	// update the display portion
	UpdateBindingDisplay( i, sz );

	// update the raw portion
	m_clistctrl_list.SetItemText( i, COL_RAW, sz );
	}

//--------------------------------------------------------
// This provides us another opportunity to parse the 
void CBindingsDlg::UpdateBindingDisplay( DWORD iItem, CString szBinding )
	{
	CString		szIP;
	CString		szPort;
	int			iColon;

	// prepare the localized string
	CString		szDefault;
	szDefault.LoadString( IDS_DEFAULT );

		// check for the default
	if ( szBinding == MDNAME_DEFAULT )
		{
		szIP.Empty();
		szIP.Empty();
		}
	else
		{
		// the first thing we are going to do is seperate the IP and PORT into seperate strings

		// look for the : and seperate
		iColon = szBinding.Find(':');

		// if we got the colon, we can seperate easy
		if ( iColon >= 0 )
			{
			szIP = szBinding.Left(iColon);
			szPort = szBinding.Right( szBinding.GetLength() - iColon - 1);
			}
		// we did not get the colon, so it is one or the other, look for a '.' to get the IP
		else
			{
			if ( szBinding.Find('.') >= 0 )
				szIP = szBinding;
			else
				szPort = szBinding;
			}
		}

	// if there any wildcards, show the right thing
	if ( szIP.IsEmpty() )
		szIP.LoadString( IDS_ANY_UNASSIGNED );
	if ( szPort.IsEmpty() )
		szPort.LoadString( IDS_ANY_UNASSIGNED );

	// set the strings into the columns
	m_clistctrl_list.SetItemText( iItem, COL_IP, szIP );
	m_clistctrl_list.SetItemText( iItem, COL_PORT, szPort );
	}

//--------------------------------------------------------
// fill in the bindings into the list
void CBindingsDlg::FillInBindings()
	{
	// just load the binding list from the key into the list. The only
	// exception is that the non-localized "default" key indicator should
	// be displayed as the localed "Default" from the resources

	// get the number of strings that we will be dealing with here.
	DWORD	nStrings = m_pKey->m_rgbszBindings.GetSize();

	// loop the strings and add them to the display list
	for ( DWORD i = 0; i < nStrings; i++ )
		{
		CString	sz = m_pKey->m_rgbszBindings[i];

		// add the binding string to the dislpay list
		AddBinding( sz );
		}
	}

//--------------------------------------------------------
// enable the buttons as appropriate
void CBindingsDlg::EnableButtons()
	{
	// if there is an item selected in the list, then enable
	// the edit and delete buttons. Otherwise, disable them
	if ( m_clistctrl_list.GetSelectedCount() >= 1 )
		{
		// there are items selected
		m_cbutton_edit.EnableWindow( TRUE );
		m_cbutton_delete.EnableWindow( TRUE );
		}
	else
		{
		// nope. Nothing selected
		m_cbutton_edit.EnableWindow( FALSE );
		m_cbutton_delete.EnableWindow( FALSE );
		}
	}

//--------------------------------------------------------
BOOL CBindingsDlg::FEdit( CString &sz ) 
	{
	BOOL			fAnswer = FALSE;
	CEditBindingDlg	dlg( m_pszwMachineName );

	// prepare the dialog
	dlg.m_pBindingsDlg = this;
	dlg.m_szBinding = sz;

	// run the dialog and return if the answer is OK
	if (dlg.DoModal() == IDOK)
		{
		fAnswer = TRUE;
		sz = dlg.m_szBinding;
		}

	// return the answer
	return fAnswer;
	}

//--------------------------------------------------------
// check the local list to see if a binding is already there
BOOL CBindingsDlg::FContainsBinding( CString sz )
	{
	DWORD	iItem, cItems;
	CString	szTest;
	// scan all the items in the list looking for a match
	cItems = m_clistctrl_list.GetItemCount();
	for ( iItem = 0; iItem < cItems; iItem++ )
		{
		szTest = m_clistctrl_list.GetItemText(iItem, COL_RAW);
		if ( sz == szTest )
			return TRUE;
		}
	// we did not find the binding
	return FALSE;
	}


/////////////////////////////////////////////////////////////////////////////
// CBindingsDlg message handlers

//--------------------------------------------------------
void CBindingsDlg::OnAdd() 
	{
	CString szNew;

	// default the new binding to be the default
	szNew = MDNAME_DEFAULT;

	// edit the new string. if the answer is OK, then add it to the list
	if ( FEdit(szNew) )
		{
		// add the binding string to the dislpay list
		AddBinding( szNew );
		}

	// enable the buttons as appropriate
	EnableButtons();
	}

//--------------------------------------------------------
void CBindingsDlg::OnDelete() 
	{
	int	i = GetSelectedIndex();

	// delete the item from the display list
	if ( i >= 0 )
		m_clistctrl_list.DeleteItem ( GetSelectedIndex() );

	// enable the buttons as appropriate
	EnableButtons();
	}

//--------------------------------------------------------
	// edit the selected item
void CBindingsDlg::OnEdit() 
	{
	int	i = GetSelectedIndex();

	// delete the item from the display list
	if ( i >= 0 )
		{
		// get the existing binding text
		CString	sz = m_clistctrl_list.GetItemText(i, COL_RAW);

		// edit the text
		if ( FEdit(sz) )
			{
			// if the edit worked, place the text back into the object
			m_clistctrl_list.SetItemText(i, COL_RAW, sz);
           	// update the display portion
        	UpdateBindingDisplay( i, sz );
			}
		}
	}

//--------------------------------------------------------
void CBindingsDlg::OnItemchangedList(NMHDR* pNMHDR, LRESULT* pResult) 
	{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	*pResult = 0;
	// enable the buttons as appropriate
	EnableButtons();
	}

//--------------------------------------------------------
void CBindingsDlg::OnOK() 
	{
	DWORD		iItem, cItems;
	CString		sz;

	// all the validation work of the bindings is done in the binding edit
	// dialog, not here. So we can just blurt out the bindings back into
	// key's binding list

	// clear the list
	m_pKey->m_rgbszBindings.RemoveAll();

	// blurt out the bindings back into the key and set the bindings changed
	// flag for the key
	cItems = m_clistctrl_list.GetItemCount();
	for ( iItem = 0; iItem < cItems; iItem++ )
		{
		// get the text for the binding
		sz = m_clistctrl_list.GetItemText(iItem, COL_RAW);

		// if it is the default string, add the non-localized version
		if ( sz == MDNAME_DEFAULT )
			m_pKey->m_rgbszBindings.Add( MDNAME_DEFAULT );
		else
		// otherwise, add the string directly
			m_pKey->m_rgbszBindings.Add( (LPCSTR)sz );
		}
	
	// we also need to remove bindings in other keys that this one has taken over
	cItems = rgbRemovals.GetSize();
	for ( iItem = 0; iItem < cItems; iItem++ )
		{
		// remove the binding
		rgbRemovals[iItem]->RemoveBinding();
		// delete the objects as we go
		delete rgbRemovals[iItem];
		}
	rgbRemovals.RemoveAll();

	// tell the key to update the bindings
	m_pKey->m_fUpdateBindings = TRUE;


	// call the parent to close the dialog
	CDialog::OnOK();
	}

//--------------------------------------------------------
void CBindingsDlg::OnDblclkList(NMHDR* pNMHDR, LRESULT* pResult) 
{
    // if something in the list was double clicked, edit it
    if ( m_clistctrl_list.GetSelectedCount() == 1 )
            OnEdit();
	*pResult = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\w3key\cmnkey.h ===
// common methods between the old w3key and the new mdkey
//-------------------------------------------------------------
// This is the key object
class CCmnKey : public CKey
	{
	public:

	CCmnKey();

	// manage the name
	void SetName( CString &szNewName );
	CString GetName();

	// brings up the key properties dialog
	void OnUpdateProperties(CCmdUI* pCmdUI);

	// basic info about the key
	CString	m_szName;		// friendly name
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\w3key\cnctdlg.cpp ===
// CnctDlg.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"

#include "KeyObjs.h"
#include "CmnKey.h"
#include "W3Key.h"
#include "W3Serv.h"

#include "CnctDlg.h"
#include "IPDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CConnectionDlg dialog


CConnectionDlg::CConnectionDlg(CWnd* pParent /*=NULL*/)
    : CDialog(CConnectionDlg::IDD, pParent),
    m_pKey( NULL )
    {
    //{{AFX_DATA_INIT(CConnectionDlg)
    m_int_connection_type = -1;
    //}}AFX_DATA_INIT
    }


void CConnectionDlg::DoDataExchange(CDataExchange* pDX)
    {
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CConnectionDlg)
    DDX_Control(pDX, IDC_BTN_SELECT_IPADDRESS, m_cbutton_choose_ip);
    DDX_Radio(pDX, IDC_BTN_KEYVIEW_NONE, m_int_connection_type);
    //}}AFX_DATA_MAP

    // do the ip address field by hand
    if ( pDX->m_bSaveAndValidate )
        m_szIPAddress = GetIPAddress();
    else
        FSetIPAddress( m_szIPAddress );
    }


BEGIN_MESSAGE_MAP(CConnectionDlg, CDialog)
    //{{AFX_MSG_MAP(CConnectionDlg)
    ON_BN_CLICKED(IDC_BTN_KEYVIEW_DEFAULT, OnBtnKeyviewDefault)
    ON_BN_CLICKED(IDC_BTN_KEYVIEW_IPADDR, OnBtnKeyviewIpaddr)
    ON_BN_CLICKED(IDC_BTN_KEYVIEW_NONE, OnBtnKeyviewNone)
    ON_BN_CLICKED(IDC_BTN_SELECT_IPADDRESS, OnBtnSelectIpaddress)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CConnectionDlg message handlers
//----------------------------------------------------------------
// override virtual oninitdialog
BOOL CConnectionDlg::OnInitDialog( )
    {
    // call the base oninit
    CDialog::OnInitDialog();

    // set enable the ip address as appropriate to start with
    switch( m_int_connection_type )
        {
        case CONNECTION_NONE:
            m_cbutton_choose_ip.EnableWindow( FALSE );
            GetDlgItem(IDC_IPA_IPADDRESS)->EnableWindow(FALSE);
            break;
        case CONNECTION_DEFAULT:
            m_cbutton_choose_ip.EnableWindow( FALSE );
            GetDlgItem(IDC_IPA_IPADDRESS)->EnableWindow(FALSE);
            break;
        case CONNECTION_IPADDRESS:
            m_cbutton_choose_ip.EnableWindow( TRUE );
            GetDlgItem(IDC_IPA_IPADDRESS)->EnableWindow(TRUE);
            break;
        };

    // return 0 to say we set the default item
    // return 1 to just select the default default item
    return 1;
    }

//------------------------------------------------------------------------------
void CConnectionDlg::OnBtnKeyviewNone()
    {
    // clear the address field
    UpdateData( TRUE );
    m_szIPStorage = m_szIPAddress;
    ClearIPAddress();

    // disable the address field and chooser
    m_cbutton_choose_ip.EnableWindow( FALSE );
    GetDlgItem(IDC_IPA_IPADDRESS)->EnableWindow(FALSE);
    }

//------------------------------------------------------------------------------
void CConnectionDlg::OnBtnKeyviewDefault()
    {
    // get the data from the form
    UpdateData( TRUE );
    m_szIPStorage = m_szIPAddress;
    ClearIPAddress();

    // disable the address field and chooser
    m_cbutton_choose_ip.EnableWindow( FALSE );
    GetDlgItem(IDC_IPA_IPADDRESS)->EnableWindow(FALSE);
    }

//------------------------------------------------------------------------------
void CConnectionDlg::OnBtnKeyviewIpaddr()
    {
    // enable the address field and chooser
    m_cbutton_choose_ip.EnableWindow( TRUE );
    GetDlgItem(IDC_IPA_IPADDRESS)->EnableWindow(TRUE);

    // ip address field
    UpdateData( TRUE );
    m_szIPAddress = m_szIPStorage;
    UpdateData( FALSE );
    }


//------------------------------------------------------------------------------
void CConnectionDlg::OnBtnSelectIpaddress()
    {
    // run the choose ip dialog here
    CChooseIPDlg    dlg;

    // set up the ip dialog member variables
    dlg.m_szIPAddress = m_szIPAddress;
    dlg.m_pKey = m_pKey;

    // run the dialog
    if ( dlg.DoModal() == IDOK )
        {
        UpdateData( TRUE );
        m_szIPAddress = dlg.m_szIPAddress;
        UpdateData( FALSE );
        }
    }

//------------------------------------------------------------------------------
// Set and get the ip STRING from the ip edit control
BOOL CConnectionDlg::FSetIPAddress( CString& szAddress )
    {
    DWORD   dword, b1, b2, b3, b4;

    // break the string into 4 numerical bytes (reading left to right)
    dword = sscanf( szAddress, "%d.%d.%d.%d", &b1, &b2, &b3, &b4 );

    // if we didn't get all four, fail
    if ( dword != 4 )
        return FALSE;

    // make the numerical ip address out of the bytes
    dword = (DWORD)MAKEIPADDRESS(b1,b2,b3,b4);

    // set the ip address into the control
    SendDlgItemMessage( IDC_IPA_IPADDRESS, IPM_SETADDRESS, 0, dword );

#ifdef _DEBUG
    dword = 0;
//  dword = SendDlgItemMessage( IDC_IPA_IPADDRESS, IPM_GETADDRESS, 0, 0 );
#endif

    // return success
    return TRUE;
    }

//------------------------------------------------------------------------------
CString CConnectionDlg::GetIPAddress()
    {
    CString szAnswer;
    DWORD   dword, b1, b2, b3, b4;

    // get the ip address from the control
    SendDlgItemMessage( IDC_IPA_IPADDRESS, IPM_GETADDRESS, 0, (LPARAM)&dword );


    // get the constituent parts
    b1 = FIRST_IPADDRESS( dword );
    b2 = SECOND_IPADDRESS( dword );
    b3 = THIRD_IPADDRESS( dword );
    b4 = FOURTH_IPADDRESS( dword );

    // format the string
    if ( dword )
        szAnswer.Format( "%d.%d.%d.%d", b1, b2, b3, b4 );
    else
        szAnswer.Empty();

    return szAnswer;
    }

//------------------------------------------------------------------------------
// Set and get the ip STRING from the ip edit control
void CConnectionDlg::ClearIPAddress()
    {
    // clear the ip address control
    SendDlgItemMessage( IDC_IPA_IPADDRESS, IPM_CLEARADDRESS, 0, 0 );
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\w3key\crackcrt.h ===
class CCrackedCert
	{
	public:
	// constructor
	CCrackedCert();
	~CCrackedCert();

	// give it a cert to crack. If this object was previously used to
	// crack a key, cleanup is automatically done and the new key is
	// cracked. - NOTE: The target key MUST have either a certificate
	// or a certificate request. Those are what get cracked. A return
	// value of 0 indicates success
	BOOL CrackCert( PUCHAR pCert, DWORD cbCert );

	// The rest of the methods access the data in the cracked certificate
	DWORD		GetVersion();
	DWORD*		PGetSerialNumber();	// returns a pointer to a DWORD[4]
	int			GetSignatureAlgorithm();
	FILETIME	GetValidFrom();
	FILETIME	GetValidUntil();
	PVOID		PSafePublicKey();
	DWORD		GetBitLength();

	void		GetIssuer( CString &sz );
	void		GetIssuerCountry( CString &sz );
	void		GetIssuerOrganization( CString &sz );
	void		GetIssuerUnit( CString &sz );

	void		GetSubject( CString &sz );
	void		GetSubjectCountry( CString &sz );
	void		GetSubjectState( CString &sz );
	void		GetSubjectLocality( CString &sz );
	void		GetSubjectCommonName( CString &sz );
	void		GetSubjectOrganization( CString &sz );
	void		GetSubjectUnit( CString &sz );

	protected:

	// string constants for distinguishing names. Not to be localized
	#define		SZ_KEY_COUNTRY			_T("C=")
	#define		SZ_KEY_STATE			_T("S=")
	#define		SZ_KEY_LOCALITY			_T("L=")
	#define		SZ_KEY_ORGANIZATION		_T("O=")
	#define		SZ_KEY_ORGUNIT			_T("OU=")
	#define		SZ_KEY_COMNAME			_T("CN=")

	private:
	void		GetSubjectDN( CString &szDN, LPCSTR szKey );
	void		GetIssuerDN( CString &szDN, LPCSTR szKey );


	// declare the x509 pointer as void so that the
	// files instantiating this don't have to include wincrypt
	PVOID		m_pData;
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\w3key\edtbindd.cpp ===
// EdtBindD.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"

#include "iiscnfg.h"

#include "KeyObjs.h"
#include "wrapmb.h"
#include "cmnkey.h"
#include "mdkey.h"
#include "mdserv.h"

#include "ListRow.h"
#include "BindsDlg.h"
#include "EdtBindD.h"

#include "W3Key.h"
#include "ipdlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CEditBindingDlg dialog


//--------------------------------------------------------
CEditBindingDlg::CEditBindingDlg(WCHAR* pszw, CWnd* pParent /*=NULL*/)
    : CDialog(CEditBindingDlg::IDD, pParent),
    m_fPopulatedPortDropdown( FALSE ),
    m_pszwMachineName( pszw )
    {
    //{{AFX_DATA_INIT(CEditBindingDlg)
    m_int_ip_option = -1;
    m_int_port_option = -1;
    m_cstring_port = _T("");
    //}}AFX_DATA_INIT
    }

//--------------------------------------------------------
void CEditBindingDlg::DoDataExchange(CDataExchange* pDX)
    {
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CEditBindingDlg)
    DDX_Control(pDX, IDC_PORT_DROP, m_ccombobox_port);
    DDX_Radio(pDX, IDC_ANY_IP, m_int_ip_option);
    DDX_Radio(pDX, IDC_ANY_PORT, m_int_port_option);
    DDX_CBString(pDX, IDC_PORT_DROP, m_cstring_port);
    //}}AFX_DATA_MAP
    }

//--------------------------------------------------------
BEGIN_MESSAGE_MAP(CEditBindingDlg, CDialog)
    //{{AFX_MSG_MAP(CEditBindingDlg)
    ON_BN_CLICKED(IDC_RD_IP, OnRdIp)
    ON_BN_CLICKED(IDC_RD_PORT, OnRdPort)
    ON_BN_CLICKED(IDC_ANY_IP, OnAnyIp)
    ON_BN_CLICKED(IDC_ANY_PORT, OnAnyPort)
    ON_CBN_DROPDOWN(IDC_PORT_DROP, OnDropdownPortDrop)
    ON_BN_CLICKED(IDC_BTN_SELECT_IPADDRESS, OnBtnSelectIpaddress)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//--------------------------------------------------------
BOOL CEditBindingDlg::OnInitDialog()
    {
    CString szIP;
    CString szPort;
    int     iColon;

    // call the parental oninitdialog
    BOOL f = CDialog::OnInitDialog();

    // the initial values of the dialog as appropriate
    // for the string that was passed. The easiest case
    // is that of the default string - so do that first.

    // check for the default
    if ( m_szBinding == MDNAME_DEFAULT )
        {
        m_int_ip_option = OPTION_ANY_UNASSIGNED;
        m_int_port_option = OPTION_ANY_UNASSIGNED;
        m_cstring_port.Empty();
        ClearIPAddress();
        }
    else
        {
        // the first thing we are going to do is seperate the IP and PORT into seperate strings

        // look for the : and seperate
        iColon = m_szBinding.Find(':');

        // if we got the colon, we can seperate easy
        if ( iColon >= 0 )
            {
            szIP = m_szBinding.Left(iColon);
            szPort = m_szBinding.Right(m_szBinding.GetLength() - iColon - 1);
            }
        // we did not get the colon, so it is one or the other, look for a '.' to get the IP
        else
            {
            if ( m_szBinding.Find('.') >= 0 )
                szIP = m_szBinding;
            else
                szPort = m_szBinding;
            }

        // put the strings into the appropriate places
        if ( szIP.IsEmpty() )
            {
            ClearIPAddress();
            m_int_ip_option = OPTION_ANY_UNASSIGNED;
            }
        else
            {
            FSetIPAddress( szIP );
            m_int_ip_option = OPTION_SPECIFIED;
            }

        // setting the port string is a bit easier
        m_cstring_port = szPort;
        if ( szPort.IsEmpty() )
            m_int_port_option = OPTION_ANY_UNASSIGNED;
        else
            m_int_port_option = OPTION_SPECIFIED;
        }

    // update the data in the dialog
    UpdateData( FALSE );

    // enable the items as appropriate
    EnableItems();

    // return the answer
    return f;
    }

//--------------------------------------------------------
// enable the itesm as appropriate
void CEditBindingDlg::EnableItems()
    {
    // get the data so we are up-to-date
    UpdateData( TRUE );

    // handle the ip addressing items
    if ( m_int_ip_option == OPTION_ANY_UNASSIGNED )
        {
        GetDlgItem(IDC_IPA_IPADDRESS)->EnableWindow(FALSE);
//      m_cbutton_delete.EnableWindow( FALSE );
        }
    else
        {
        GetDlgItem(IDC_IPA_IPADDRESS)->EnableWindow(TRUE);
//      m_cbutton_delete.EnableWindow( TRUE );
        }

    // handle the port addressing items
    if ( m_int_port_option == OPTION_ANY_UNASSIGNED )
        {
        m_ccombobox_port.EnableWindow( FALSE );
        }
    else
        {
        m_ccombobox_port.EnableWindow( TRUE );
        }
    }

//------------------------------------------------------------------------------
// Set and get the ip STRING from the ip edit control
BOOL CEditBindingDlg::FSetIPAddress( CString& szAddress )
    {
    DWORD   dword, b1, b2, b3, b4;

    // break the string into 4 numerical bytes (reading left to right)
    dword = sscanf( szAddress, "%d.%d.%d.%d", &b1, &b2, &b3, &b4 );

    // if we didn't get all four, fail
    if ( dword != 4 )
        return FALSE;

    // make the numerical ip address out of the bytes
    dword = (DWORD)MAKEIPADDRESS(b1,b2,b3,b4);

    // set the ip address into the control
    SendDlgItemMessage( IDC_IPA_IPADDRESS, IPM_SETADDRESS, 0, dword );

#ifdef _DEBUG
    dword = 0;
//  dword = SendDlgItemMessage( IDC_IPA_IPADDRESS, IPM_GETADDRESS, 0, 0 );
#endif

    // return success
    return TRUE;
    }

//------------------------------------------------------------------------------
CString CEditBindingDlg::GetIPAddress()
    {
    CString szAnswer;
    DWORD   dword, b1, b2, b3, b4;

    // get the ip address from the control
    SendDlgItemMessage( IDC_IPA_IPADDRESS, IPM_GETADDRESS, 0, (LPARAM)&dword );


    // get the constituent parts
    b1 = FIRST_IPADDRESS( dword );
    b2 = SECOND_IPADDRESS( dword );
    b3 = THIRD_IPADDRESS( dword );
    b4 = FOURTH_IPADDRESS( dword );

    // format the string
    if ( dword )
        szAnswer.Format( "%d.%d.%d.%d", b1, b2, b3, b4 );
    else
        szAnswer.Empty();

    return szAnswer;
    }

//------------------------------------------------------------------------------
// Set and get the ip STRING from the ip edit control
void CEditBindingDlg::ClearIPAddress()
    {
    // clear the ip address control
    SendDlgItemMessage( IDC_IPA_IPADDRESS, IPM_CLEARADDRESS, 0, 0 );
    }

//------------------------------------------------------------------------------
BOOL CEditBindingDlg::FIsBindingSafeToUse( CString szBinding )
    {

    // start by testing the binding in the current dialog - uses
    // the localized version of "Default"
    if ( m_pBindingsDlg->FContainsBinding(szBinding) )
        {
        AfxMessageBox( IDS_THIS_KEY_HAS_BINDING, MB_OK );
        return FALSE;
        }

    // now we check to see if any other keys have the specified binding. If
    // they do, we ask the user if they want to give the binding to this key.
    // but first we have to find the key. This means scanning the list of
    // keys and asking each - but not this key - if they have the binding.
    CMDKey* pKeyLocal = m_pBindingsDlg->m_pKey;
    CMDKey* pKey;

    if ( !pKeyLocal->m_pService )
        return FALSE;

    // get the first key in the service list
    pKey = pKeyLocal->m_pService->GetFirstMDKey();

    // loop the keys, testing each in turn
    while ( pKey )
        {
        // if this is not the local key, test it
        if ( pKey != pKeyLocal )
            {
            // test it
            if ( pKey->FContainsBinding( szBinding ) )
                {
                // prepare the message for the user
                CString szMessage;
                AfxFormatString1( szMessage, IDS_ANOTHER_KEY_HAS_BINDING, pKey->m_szName );
                // ask the user what to do
                if ( AfxMessageBox( szMessage, MB_YESNO ) == IDYES )
                    {
                    // create a new removal object
                    CBingingRemoval* pRemoval = new CBingingRemoval( pKey, szBinding );
                    // add it to the queue
                    m_pBindingsDlg->rgbRemovals.Add( pRemoval );
                    // the key is safe use
                    return TRUE;
                    }
                else
                    {
                    // the user has thought better of this
                    return FALSE;
                    }
                }
            }

        // get the next key in the list
        pKey = pKeyLocal->m_pService->GetNextMDKey( pKey );
        }

    // no one else is using the binding. It is safe.
    return TRUE;
    }

/////////////////////////////////////////////////////////////////////////////
// CEditBindingDlg message handlers

//------------------------------------------------------------------------------
void CEditBindingDlg::OnOK()
    {
    CString szIP;
    CString szPort;

    // start by building the final binding string
    CString szBinding;

    // use the current data
    UpdateData( TRUE );


    // first things first. We need to make sure that, if used, the
    // custom fields actually have something in them

    // check the IP address first
    if ( m_int_ip_option == OPTION_SPECIFIED )
        {
        szIP = GetIPAddress();
        if ( szIP.IsEmpty() )
            {
            // tell the user about it
            AfxMessageBox( IDS_INVALID_IP );

            // hilight the IP box
            GetDlgItem( IDC_IPA_IPADDRESS )->SetFocus();

            // return without closing the dialog
            return;
            }
        }

    // check the port address second
    if ( m_int_port_option == OPTION_SPECIFIED )
        {
        if ( m_cstring_port.IsEmpty() )
            {
            // tell the user about it
            AfxMessageBox( IDS_INVALID_PORT );

            // hilight the port box
            m_ccombobox_port.SetFocus();
            m_ccombobox_port.SetEditSel(0,-1);

            // return without closing the dialog
            return;
            }
        }


    // the total default case is the easiest
    if ( m_int_ip_option == OPTION_ANY_UNASSIGNED &&
            m_int_port_option == OPTION_ANY_UNASSIGNED )
        {
        szBinding = MDNAME_DEFAULT;
        }
    else
        {
        // build from the ip and port pieces
        if ( m_int_ip_option == OPTION_SPECIFIED )
            szIP = GetIPAddress();
        if ( m_int_port_option == OPTION_SPECIFIED )
            szPort = m_cstring_port;

        // build the string start with the IP
        szBinding = szIP;

        // if both are there, add a colon
        if ( m_int_ip_option == OPTION_SPECIFIED &&
                m_int_port_option == OPTION_SPECIFIED )
            szBinding += ':';

        // finish with the port
        szBinding += szPort;
        }

    // finally, if the binding is safe to use, we can set the data and
    // close the dialog
    if ( FIsBindingSafeToUse(szBinding) )
        {
        // set the data
        m_szBinding = szBinding;

        // tell the dialog to close
        CDialog::OnOK();
        }
    }

//------------------------------------------------------------------------------
void CEditBindingDlg::OnRdIp()
    {
    EnableItems();
    }

//------------------------------------------------------------------------------
void CEditBindingDlg::OnRdPort()
    {
    EnableItems();
    }

//------------------------------------------------------------------------------
void CEditBindingDlg::OnAnyIp()
    {
    EnableItems();
    }

//------------------------------------------------------------------------------
void CEditBindingDlg::OnAnyPort()
    {
    EnableItems();
    }

//------------------------------------------------------------------------------
void CEditBindingDlg::OnDropdownPortDrop()
    {
    CString     sz;
    DWORD       dwPort;

    // if we have already been here, don't do anything
    if ( m_fPopulatedPortDropdown )
        return;

    // get the metabase going
    if ( !FInitMetabaseWrapper(m_pszwMachineName) )
        return;

    // create the metabase wrapper object
    CWrapMetaBase   mbWrap;
    if ( !mbWrap.FInit() )
        {
        ASSERT( FALSE );
        return;     // can't get to metabase
        }

    // we are now to populate the drop down menu
    m_fPopulatedPortDropdown = TRUE;

    // scan the available virtual servers and populate the drop down with
    // their secure port numbers
    for ( DWORD i = 1; TRUE; i++ )
        {
        // build the object name
        sz.Format( "%s%d", MD_W3BASE, i );

        // attempt to open the object in the metabase
        if ( !mbWrap.Open( sz, METADATA_PERMISSION_READ ) )
            break;      // can't open - leave the loop

        // load the string representing the bindings
        DWORD   cbData;
        PVOID   pData;

        // extract the secure port address from the secure bindings stringlist
        pData = mbWrap.GetData( "", MD_SECURE_BINDINGS, IIS_MD_UT_SERVER, MULTISZ_METADATA, &cbData );
        if ( pData )
            {
            PTCHAR pBinding = (PTCHAR)pData;

            // walk the bindings in the list
            while ( TRUE )
                {
                sz = (PCHAR)pBinding;
                if ( sz.IsEmpty() )
                    break;

                // get the port address
                sz = sz.Right( sz.GetLength() - sz.Find(':') - 1 );
                if ( sz.Find(':') )
                sz = sz.Left( sz.Find(':') );
                if ( !sz.IsEmpty() )
                    {
                    // append the string to the dropdown
                    // but only if it isn't already there
                    if ( m_ccombobox_port.FindStringExact(-1,sz) == CB_ERR )
                        m_ccombobox_port.AddString( sz );
                    }

                // advance the binding pointer
                pBinding += strlen(pBinding)+1;
                }

            // free the buffer
            mbWrap.FreeWrapData( pData );
            }

        // close the object
        mbWrap.Close();
        }

    // now close the metabase again. We will open it when we need it
    FCloseMetabaseWrapper();
    }

//------------------------------------------------------------------------------
void CEditBindingDlg::OnBtnSelectIpaddress()
    {
    // get the metabase going
    if ( !FInitMetabaseWrapper(m_pszwMachineName) )
        return;

    // run the choose ip dialog here
    CChooseIPDlg    dlg;

    // set up the ip dialog member variables
    dlg.m_szIPAddress = GetIPAddress();

    // run the dialog
    if ( dlg.DoModal() == IDOK )
        {
        FSetIPAddress( dlg.m_szIPAddress );
        }

    // now close the metabase again. We will open it when we need it
    FCloseMetabaseWrapper();
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\w3key\cnctdlg.h ===
// CnctDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CConnectionDlg dialog

enum
	{
	CONNECTION_NONE = 0,
	CONNECTION_DEFAULT,
	CONNECTION_IPADDRESS
	};

class CConnectionDlg : public CDialog
	{
// Construction
public:
	CConnectionDlg(CWnd* pParent = NULL);   // standard constructor

	// the IP address
	CString m_szIPAddress;
	// the calling key (needed for the select ip dialog)
	CW3Key*		m_pKey;

// Dialog Data
	//{{AFX_DATA(CConnectionDlg)
	enum { IDD = IDD_KEY_PROP };
	CButton	m_cbutton_choose_ip;
	int		m_int_connection_type;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CConnectionDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

	// Implementation
protected:
	virtual BOOL OnInitDialog( );

	// Generated message map functions
	//{{AFX_MSG(CConnectionDlg)
	afx_msg void OnBtnKeyviewDefault();
	afx_msg void OnBtnKeyviewIpaddr();
	afx_msg void OnBtnKeyviewNone();
	afx_msg void OnBtnSelectIpaddress();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	// the IP address
	CString m_szIPStorage;

	BOOL FSetIPAddress( CString& szAddress );
	CString GetIPAddress();
	void ClearIPAddress();
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\w3key\crackcrt.cpp ===
// implements the exported CKeyCrackedData

#include "stdafx.h"
#include "CrackCrt.h"

extern "C"
{
	#include <wincrypt.h>
	#include <sslsp.h>
}

//-------------------------------------------------
CCrackedCert:: CCrackedCert()
		: m_pData(NULL)
	{}

//-------------------------------------------------
CCrackedCert::~CCrackedCert()
	{
	PX509Certificate	p509 = (PX509Certificate)m_pData;

	// if the cracked data is there, free it
	if ( p509 ) 
		SslFreeCertificate( (PX509Certificate)m_pData );
	}

//-------------------------------------------------
// adds a key to the service. They CKey object is added to the
// array object below. If this Service is connected to a machine,
// then the key is also added to the tree view below the service.
//-------------------------------------------------
BOOL CCrackedCert::CrackCert( PUCHAR pCert, DWORD cbCert )
	{
	PX509Certificate	p509 = NULL;
	BOOL				f;

	// if there already is a cracked cert, get rid of it
	if ( m_pData )
		{
		SslFreeCertificate( (PX509Certificate)m_pData );
		m_pData = NULL;
		}

	// crack the certificate
	f = SslCrackCertificate( pCert, cbCert, CF_CERT_FROM_FILE, &p509 );

	m_pData = (PVOID)p509;
	return f;
	}

//-------------------------------------------------
// The rest of the methods access the data in the cracked certificate
//-------------------------------------------------
DWORD CCrackedCert::GetVersion()
	{
	ASSERT(m_pData);
	PX509Certificate pCert = (PX509Certificate)m_pData;
	return pCert->Version;
	}

//-------------------------------------------------
// returns a pointer to a DWORD[4]
DWORD* CCrackedCert::PGetSerialNumber()
	{
	ASSERT(m_pData);
	PX509Certificate pCert = (PX509Certificate)m_pData;
	return (DWORD*)&pCert->SerialNumber;
	}

//-------------------------------------------------
int CCrackedCert::GetSignatureAlgorithm()
	{
	ASSERT(m_pData);
	PX509Certificate pCert = (PX509Certificate)m_pData;
	return pCert->SignatureAlgorithm;
	}

//-------------------------------------------------
FILETIME CCrackedCert::GetValidFrom()
	{
	PX509Certificate pCert = (PX509Certificate)m_pData;
	ASSERT(m_pData);
	return pCert->ValidFrom;
	}

//-------------------------------------------------
FILETIME CCrackedCert::GetValidUntil()
	{
	PX509Certificate pCert = (PX509Certificate)m_pData;
	ASSERT(m_pData);
	return pCert->ValidUntil;
	}

//-------------------------------------------------
PVOID CCrackedCert::PSafePublicKey()
	{
	PX509Certificate pCert = (PX509Certificate)m_pData;
	ASSERT(m_pData);
	return pCert->pPublicKey;
	}

//-------------------------------------------------
DWORD CCrackedCert::GetBitLength()
	{
	PX509Certificate pCert = (PX509Certificate)m_pData;
	LPPUBLIC_KEY pPubKey = (LPPUBLIC_KEY)(pCert->pPublicKey);
	ASSERT(m_pData);
	return pPubKey->bitlen;
	}

//-------------------------------------------------
void CCrackedCert::GetIssuer( CString &sz )
	{
	PX509Certificate pCert = (PX509Certificate)m_pData;
	ASSERT(m_pData);
	sz = pCert->pszIssuer;
	}

//-------------------------------------------------
void CCrackedCert::GetSubject( CString &sz )
	{
	PX509Certificate pCert = (PX509Certificate)m_pData;
	ASSERT(m_pData);
	sz = pCert->pszSubject;
	}

//-------------------------------------------------
// gets a part of the subject's distinguishing information
void CCrackedCert::GetSubjectDN( CString &szDN, LPCSTR szKey )
	{
	// clear the szDN
	szDN.Empty();

	// start with the dn (aka subject) string
	CString		szSubject;
	GetSubject( szSubject );

	// find the position of the key in the subject
	int cPos = szSubject.Find( szKey );

	// if we got it, get it
	if ( cPos >= 0 )
		{
		szDN = szKey;
		// get the string
		szDN = szSubject.Mid( cPos + szDN.GetLength() );
		// get the comma
		cPos = szDN.Find( _T(',') );
		// truncate at the comma
		if ( cPos >=0 )
			szDN = szDN.Left( cPos );
		}
	}

//-------------------------------------------------
// gets a part of the issuer's distinguishing information
void CCrackedCert::GetIssuerDN( CString &szDN, LPCSTR szKey )
	{
	// clear the szDN
	szDN.Empty();

	// start with the dn (aka subject) string
	CString		szIssuer;
	GetIssuer( szIssuer );

	// find the position of the key in the subject
	int cPos = szIssuer.Find( szKey );

	// if we got it, get it
	if ( cPos >= 0 )
		{
		szDN = szKey;
		// get the string
		szDN = szIssuer.Mid( cPos + szDN.GetLength() );
		// get the comma
		cPos = szDN.Find( _T(',') );
		// truncate at the comma
		if ( cPos >=0 )
			szDN = szDN.Left( cPos );
		}
	}

//-------------------------------------------------
void CCrackedCert::GetSubjectCountry( CString &sz )
	{
	GetSubjectDN( sz, SZ_KEY_COUNTRY );
	}

//-------------------------------------------------
void CCrackedCert::GetSubjectState( CString &sz )
	{
	GetSubjectDN( sz, SZ_KEY_STATE );
	}

//-------------------------------------------------
void CCrackedCert::GetSubjectLocality( CString &sz )
	{
	GetSubjectDN( sz, SZ_KEY_LOCALITY );
	}

//-------------------------------------------------
void CCrackedCert::GetSubjectCommonName( CString &sz )
	{
	GetSubjectDN( sz, SZ_KEY_COMNAME );
	}

//-------------------------------------------------
void CCrackedCert::GetSubjectOrganization( CString &sz )
	{
	GetSubjectDN( sz, SZ_KEY_ORGANIZATION );
	}

//-------------------------------------------------
void CCrackedCert::GetSubjectUnit( CString &sz )
	{
	GetSubjectDN( sz, SZ_KEY_ORGUNIT );
	}


//-------------------------------------------------
void CCrackedCert::GetIssuerCountry( CString &sz )
	{
	GetIssuerDN( sz, SZ_KEY_COUNTRY );
	}

//-------------------------------------------------
void CCrackedCert::GetIssuerOrganization( CString &sz )
	{
	GetIssuerDN( sz, SZ_KEY_ORGANIZATION );
	}

//-------------------------------------------------
void CCrackedCert::GetIssuerUnit( CString &sz )
	{
	GetIssuerDN( sz, SZ_KEY_ORGUNIT );
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\w3key\ipdlg.h ===
// ChooseIPDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CChooseIPDlg dialog
class CChooseIPDlg : public CDialog
{
// Construction
public:
        CChooseIPDlg(CWnd* pParent = NULL);   // standard constructor

        // override the init routine
        BOOL OnInitDialog( );
        // override the OnOK routine
        void OnOK();

		// the ip address in question
		CString		m_szIPAddress;
		CW3Key*		m_pKey;

// Dialog Data
        //{{AFX_DATA(CChooseIPDlg)
        enum { IDD = IDD_CHOOSE_IPADDRESS };
        CListCtrl       m_ctrlList;
        //}}AFX_DATA


// Overrides
        // ClassWizard generated virtual function overrides
        //{{AFX_VIRTUAL(CChooseIPDlg)
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        //}}AFX_VIRTUAL

// Implementation
protected:
        BOOL BuildIPAddressList( void );
		BOOL BuildMetaIPAddressList( void );

        // Generated message map functions
        //{{AFX_MSG(CChooseIPDlg)
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\w3key\edtbindd.h ===
// EdtBindD.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CEditBindingDlg dialog

class CEditBindingDlg : public CDialog
{
// Construction
public:
	CEditBindingDlg(WCHAR* pszw, CWnd* pParent = NULL);   // standard constructor

	virtual BOOL OnInitDialog();

    WCHAR*          m_pszwMachineName;

	// other data from parent
	CBindingsDlg*	m_pBindingsDlg;
	CString			m_szBinding;

// Dialog Data
	//{{AFX_DATA(CEditBindingDlg)
	enum { IDD = IDD_EDT_BINDING };
	CComboBox	m_ccombobox_port;
	int		m_int_ip_option;
	int		m_int_port_option;
	CString	m_cstring_port;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEditBindingDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CEditBindingDlg)
	virtual void OnOK();
	afx_msg void OnRdIp();
	afx_msg void OnRdPort();
	afx_msg void OnAnyIp();
	afx_msg void OnAnyPort();
	afx_msg void OnDropdownPortDrop();
	afx_msg void OnBtnSelectIpaddress();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	// enable the itesm as appropriate
	void EnableItems();

	BOOL FIsBindingSafeToUse( CString szBinding );

	// utilities to access the IP control
	BOOL FSetIPAddress( CString& szAddress );
	CString GetIPAddress();
	void ClearIPAddress();


	BOOL	m_fPopulatedPortDropdown;

#define	OPTION_ANY_UNASSIGNED		0
#define	OPTION_SPECIFIED			1
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\w3key\ipdlg.cpp ===
// ChooseIPDlg.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"

#include "KeyObjs.h"
#include "CmnKey.h"
#include "W3Key.h"
#include "W3Serv.h"

#include "iiscnfg.h"
#include "wrapmb.h"

#include "mdkey.h"
#include "mdserv.h"

#include "IPDlg.h"

#include "inetinfo.h"
#include "inetcom.h"
#include <lmapibuf.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern BOOL    g_fUsingMetabase;

/////////////////////////////////////////////////////////////////////////////
// CChooseIPDlg dialog

CChooseIPDlg::CChooseIPDlg(CWnd* pParent /*=NULL*/)
        : CDialog(CChooseIPDlg::IDD, pParent),
		m_pKey( NULL )
	{
    //{{AFX_DATA_INIT(CChooseIPDlg)
    //}}AFX_DATA_INIT
	}


void CChooseIPDlg::DoDataExchange(CDataExchange* pDX)
	{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CChooseIPDlg)
    DDX_Control(pDX, IDC_LIST_IPADDRESSES, m_ctrlList);
    //}}AFX_DATA_MAP
	}


BEGIN_MESSAGE_MAP(CChooseIPDlg, CDialog)
        //{{AFX_MSG_MAP(CChooseIPDlg)
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CChooseIPDlg message handlers

//----------------------------------------------------------------
// override virtual oninitdialog
BOOL CChooseIPDlg::OnInitDialog( )
    {
    // call the base oninit
    CDialog::OnInitDialog();

    // because we are querying the WWW server here, put up the wait cursor
    CWaitCursor     waitcursor;

    // build the list of ip addresses
    if ( !BuildIPAddressList() )
		EndDialog( 3 );

    // if the item passed in through m_szIPAddress is in the list, select it
    LV_FINDINFO     findInfo;
    findInfo.flags = LVFI_STRING;           // search for a string
    findInfo.psz = m_szIPAddress;           // string to search for
    findInfo.lParam = 0;                            // not used
    int iFound = m_ctrlList.FindItem( &findInfo );

    // if we found something, select it
    if ( iFound >= 0 )
		{
		m_ctrlList.SetItemState( iFound, LVIS_SELECTED, LVIS_SELECTED );
		}

    // return 0 to say we set the default item
    // return 1 to just select the default default item
    return 1;
    }

//----------------------------------------------------------------
// override the on OK routine
void CChooseIPDlg::OnOK()
    {

    // get the selected item
    int     iSelected = m_ctrlList.GetNextItem( -1, LVNI_SELECTED );

    // if nothing is selected, bail
    if ( iSelected < 0 )
            {
            CDialog::OnCancel();
            return;
            }

    // put the text of the selected item in the right place
    m_szIPAddress = m_ctrlList.GetItemText( iSelected, 0 );

    // call the inherited OnOK
    CDialog::OnOK();
    }

//----------------------------------------------------------------
// This routine queries the target server and gets the virtual servers
BOOL CChooseIPDlg::BuildIPAddressList( void )
    {
	// if we are using the new metabase stuff, load it that way
	if ( g_fUsingMetabase )
		return BuildMetaIPAddressList();


    // for now - the downlevel admin is turned off because the infoadmn.lib disappeared on me
    return FALSE;

    /*
    //	    $(BASEDIR)\public\sdk\lib\*\infoadmn.lib \
    //   $(BASEDIR)\public\sdk\lib\*\infocomm.lib \


	// start by getting the host machine. This is the object that
	// owns the service that owns this key.
	ASSERT( m_pKey->HGetTreeItem() );
	// get the parental service object
	CW3KeyService *pServ = (CW3KeyService*)m_pKey->PGetParent();
	ASSERT( pServ );
	// get the service parent, which is the machine
	CMachine *pMachine = (CMachine*)pServ->PGetParent();
	ASSERT( pMachine );
    if ( !pMachine ) return FALSE;

    LPINET_INFO_CONFIG_INFO		pConfig = NULL;
    NET_API_STATUS				apiStatus;
    DWORD						cbNameBuff;
    PWCHAR						szwName = NULL;

    // build the server name afresh instead of reusing the m_pszwMachineName
    // because that variable is only filled out for remote machines. Unlock the LSA
    // package which assumes you mean the local machine if you don't give it a name,
    // the inetinfo routine wants the name in either case.

    // create the unicode name that will be used to access the server
    // first allocate space for it
    cbNameBuff = sizeof(WCHAR) * (MAX_COMPUTERNAME_LENGTH + 1);
    szwName = (WCHAR*)GlobalAlloc( GPTR, cbNameBuff );
    // if the allocation didn't work, return FALSE
    if ( !szwName ) return FALSE;
    
    // if it is a remote machine, just copy over the m_pszwMachineName
    if ( !pMachine->FLocal() )
        {
        wcscpy(szwName, pServ->m_pszwMachineName);
        }
    else
        // a local machine, we need to fill in the correct name of the machine
        {
        char    smallerbuff[MAX_COMPUTERNAME_LENGTH + 1];
        DWORD   cbSmallerBuff = MAX_COMPUTERNAME_LENGTH + 1;
        
        // get the computer name
        GetComputerName( smallerbuff, &cbSmallerBuff );

        // unicodize the name into the buffer
        MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, smallerbuff, -1,
                                                szwName, cbNameBuff/sizeof(WCHAR) );
        }

#ifdef _DEBUG
    CString szTest = szwName;
#endif

    // get the config info of the target server
    apiStatus = InetInfoGetAdminInformation( szwName, INET_HTTP, &pConfig );

    // we don't need the wide name any more, so get rid of it
    GlobalFree( szwName );
    szwName = NULL;
    
    // check if an error ocurred
    if ( apiStatus || !pConfig || !pConfig->VirtualRoots )
		{
		AfxMessageBox( IDS_NO_HTTP );
		return FALSE;
		}

    // check that there are some virtual roots
    if ( !pConfig->VirtualRoots->cEntries )
        {
        NetApiBufferFree( pConfig );
        AfxMessageBox( IDS_NO_VIRT_ROOTS );
        return FALSE;
        }

    // loop through the itmes in the virutal root list
    for ( DWORD i = 0; i < pConfig->VirtualRoots->cEntries; i++ )
        {
        // make life easier and get a pointer to the virtual root entry
        LPINET_INFO_VIRTUAL_ROOT_ENTRY  pVirtualRoot = &pConfig->VirtualRoots->aVirtRootEntry[i];

        // get the string
        CString szAddress = pVirtualRoot->pszAddress;

        // if there is an ip address there, add it to the list
        if ( !szAddress.IsEmpty() )
                m_ctrlList.InsertItem(0, szAddress);
        }

    // clean up the info pointer
    if ( pConfig )
        NetApiBufferFree( pConfig );

    // return success
    return TRUE;
    */
    }

//----------------------------------------------------------------
BOOL CChooseIPDlg::BuildMetaIPAddressList( void )
	{
	CString		sz;

	// create the metabase wrapper object
	CWrapMetaBase	mbWrap;
	if ( !mbWrap.FInit() )
		{
		ASSERT( FALSE );
		return FALSE;		// can't get to metabase
		}

	// scan the available virtual servers and populate the drop down with
	// their secure port numbers
	for ( DWORD i = 1; TRUE; i++ )
		{
		// build the object name
		sz.Format( "%s%d", MD_W3BASE, i );

		// attempt to open the object in the metabase
		if ( !mbWrap.Open( sz, METADATA_PERMISSION_READ ) )
			break;		// can't open - leave the loop

		// load the string representing the bindings
		DWORD	cbData;
	    PVOID   pData;

		pData = mbWrap.GetData( "", MD_SECURE_BINDINGS, IIS_MD_UT_SERVER, MULTISZ_METADATA, &cbData );
		if ( pData )
			{
            PTCHAR pBinding = (PTCHAR)pData;
            LV_FINDINFO findinfo;
            findinfo.flags = LVFI_STRING;
            findinfo.lParam = 0;

            // walk the bindings in the list
            while ( TRUE )
                {
                sz = (PCHAR)pBinding;
                if ( sz.IsEmpty() )
                    break;

                // get the IP address
			    sz = sz.Left( sz.Find(':') );
                if ( !sz.IsEmpty() )
                    {
			        // add the string to the list
                    // but only if it isn't already there
                    findinfo.psz = sz;
                    if ( m_ctrlList.FindItem( &findinfo ) < 0 )
                        m_ctrlList.InsertItem(0, sz);
                    }

                // advance the binding pointer
                pBinding += strlen(pBinding)+1;
                }

		    // free the buffer
		    mbWrap.FreeWrapData( pData );
			}

		// close the object
 		mbWrap.Close();
		}

    // if nothing is in the IP box, tell the user
    if ( m_ctrlList.GetItemCount() == 0 )
        AfxMessageBox( IDS_NO_SECURE_BINDINGS );

	return TRUE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\w3key\kmlsa.h ===
// a record that is just like, the LSA_UNICODE_STRING, except that I can use it
// without having to include all the NT headers


HANDLE	HOpenLSAPolicy( WCHAR *pszwServer, DWORD *pErr );
BOOL	FCloseLSAPolicy( HANDLE hPolicy, DWORD *pErr );

BOOL	FStoreLSASecret( HANDLE hPolicy, WCHAR* pszwSecretName, void* pvData, WORD cbData, DWORD *pErr );
PLSA_UNICODE_STRING	FRetrieveLSASecret( HANDLE hPolicy, WCHAR* pszwSecretName, DWORD *pErr );

void	DisposeLSAData( PVOID pData );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\w3key\keydata.cpp ===
/* Key.cpp : defines the key object.

  This file contains the routines that allow a key to store and restore itself
*/
#include "stdafx.h"
#include "resource.h"

#include "KeyObjs.h"
#include "cmnkey.h"
#include "W3Key.h"



#define		KEY_VERSION		0x102

/*========
The scheme here is to create a handle that contains all the data necessary to
restore the key object. The data contained in that handle is then stored as a
secret on the target machine. This does require that the size of the handle be
less than 65000 bytes, which should be no problem.
*/


//------------------------------------------------------------------------------
// generate a handle containing data that gets stored and then is used to restore
// the key object at a later date. Restore this key by passing this dereferenced
// handle back into the FInitKey routine above.
HANDLE	CW3Key::HGenerateDataHandle( BOOL fIncludePassword )
	{
	DWORD	cbSize;
	DWORD	cbChar = sizeof(TCHAR);
	PUCHAR	p;
	HANDLE	h;

	CString	szReserved;			// save an empty string so that one can be added later
	szReserved.Empty();

	// calculate the size of the handle
	cbSize = 2*sizeof(DWORD) + sizeof(BOOL);
	cbSize += sizeof(DWORD);	// reserved dword
	cbSize += sizeof(DWORD) + szReserved.GetLength() * cbChar + cbChar;

	cbSize += sizeof(DWORD) + m_szName.GetLength() * cbChar + cbChar;
	cbSize += sizeof(DWORD) + m_szPassword.GetLength() * cbChar + cbChar;

	// no longer need to store all the distinguishing info now that crack certificate works
	cbSize += (sizeof(DWORD) + szReserved.GetLength() * cbChar + cbChar) * 6;
/*
	cbSize += sizeof(DWORD) + m_szOrganization.GetLength() * cbChar + cbChar;
	cbSize += sizeof(DWORD) + m_szUnit.GetLength() * cbChar + cbChar;
	cbSize += sizeof(DWORD) + m_szNetAddress.GetLength() * cbChar + cbChar;
	cbSize += sizeof(DWORD) + m_szCountry.GetLength() * cbChar + cbChar;
	cbSize += sizeof(DWORD) + m_szStateProvince.GetLength() * cbChar + cbChar;
	cbSize += sizeof(DWORD) + m_szLocality.GetLength() * cbChar + cbChar;
*/

	cbSize += sizeof(DWORD) + m_szIPAddress.GetLength() * cbChar + cbChar;
	cbSize += sizeof(BOOL);		//m_fDefault
	cbSize += sizeof(DWORD) + m_cbPrivateKey;
	cbSize += sizeof(DWORD) + m_cbCertificate;
	cbSize += sizeof(DWORD) + m_cbCertificateRequest;
	cbSize += sizeof(FILETIME);	// no longer used

	// create the new handle and lock it
	h = GlobalAlloc( GHND, cbSize );
	if ( !h )
		{
		AfxThrowMemoryException();
		return NULL;
		}
	p = (PUCHAR)GlobalLock( h );

	// put in the version, fComplete, and nBits
	*((UNALIGNED DWORD*)p) = KEY_VERSION;
	p += sizeof(DWORD);
	*((UNALIGNED DWORD*)p) = 0;			// no longer used
	p += sizeof(DWORD);
	*((UNALIGNED BOOL*)p) = (m_pCertificate != NULL); // no longer used
	p += sizeof(BOOL);

	// add in a reserved dword for future use.
	*((UNALIGNED DWORD*)p) = 0L;
	p += sizeof(DWORD);

	// now the strings......
	// for each string, first write out the size of the string, then the string data.

	// save the reserved string. If you need to add one later and don't want to
	// invalidate the older keys on a machine, replace this string.
	cbSize = szReserved.GetLength() * cbChar + cbChar;
	*((UNALIGNED DWORD*)p) = cbSize;
	p += sizeof(DWORD);
	CopyMemory( p, LPCTSTR(szReserved), cbSize );
	p += cbSize;

	// save the name
	cbSize = m_szName.GetLength() * cbChar + cbChar;
	*((UNALIGNED DWORD*)p) = cbSize;
	p += sizeof(DWORD);
	CopyMemory( p, LPCTSTR(m_szName), cbSize );
	p += cbSize;

	// save the password
	if ( fIncludePassword )
		{
		cbSize = m_szPassword.GetLength() * cbChar + cbChar;
		*((UNALIGNED DWORD*)p) = cbSize;
		p += sizeof(DWORD);
		CopyMemory( p, LPCTSTR(m_szPassword), cbSize );
		p += cbSize;
		}
	else
		// do not include the password - just put in an empty field
		{
		*((UNALIGNED DWORD*)p) = 0;
		p += sizeof(DWORD);
		}

	// no longer need to store all the distinguishing info now that crack certificate works
	for ( WORD i = 0; i < 6; i++ )
		{
		cbSize = szReserved.GetLength() * cbChar + cbChar;
		*((UNALIGNED DWORD*)p) = cbSize;
		p += sizeof(DWORD);
		CopyMemory( p, LPCTSTR(szReserved), cbSize );
		p += cbSize;
		}

	// save the ip address it is attached to
	cbSize = m_szIPAddress.GetLength() * cbChar + cbChar;
	*((UNALIGNED DWORD*)p) = cbSize;
	p += sizeof(DWORD);
	CopyMemory( p, LPCTSTR(m_szIPAddress), cbSize );
	p += cbSize;

	// put in the m_fDefault flag
	*((UNALIGNED BOOL*)p) = m_fDefault;
	p += sizeof(BOOL);

	// now put in the number of bytes in the private key
	*((UNALIGNED DWORD*)p) = m_cbPrivateKey;
	p += sizeof(DWORD);

	// put in the private key
	CopyMemory( p, m_pPrivateKey, m_cbPrivateKey );
	p += m_cbPrivateKey;

	// now put in the number of bytes in the certificate
	*((UNALIGNED DWORD*)p) = m_cbCertificate;
	p += sizeof(DWORD);

	// put in the certificate key
	CopyMemory( p, m_pCertificate, m_cbCertificate );
	p += m_cbCertificate;

	// now put in the number of bytes in the certificate request
	*((UNALIGNED DWORD*)p) = m_cbCertificateRequest;
	p += sizeof(DWORD);

	// put in the certificate request
	CopyMemory( p, m_pCertificateRequest, m_cbCertificateRequest );
	p += m_cbCertificateRequest;

	// and finally, add the timestamp
	FILETIME	ft;
	memset( &ft, 0, sizeof(ft) );
	*((UNALIGNED FILETIME*)p) = ft;
	p += sizeof(FILETIME);

	// unlock the handle
	GlobalUnlock( h );

	// all done
	return h;
	}


//------------------------------------------------------------------------------
// Given a pointer to a block of data originally created by the above routine, fill
// in the key object
BOOL	CW3Key::InitializeFromPointer( PUCHAR pSrc, DWORD cbSrc )
	{
	DWORD	dword, version;
	DWORD	cbChar = sizeof(TCHAR);
	PUCHAR	p = pSrc;

	ASSERT(pSrc && cbSrc);

	// get the version of the data - just put it into dword for now
	version = *((UNALIGNED DWORD*)p);
	// check the version for validity
	if ( version > KEY_VERSION )
		{
		return FALSE;
		}
	p += sizeof(DWORD);

	// anything below version 0x101 is BAD. Do not accept it
	if ( version < 0x101 )
		{
		AfxMessageBox( IDS_INVALID_KEY, MB_OK|MB_ICONINFORMATION );
		return FALSE;
		}
	
	// get the bits and the complete flag
	// no longer used
	p += sizeof(DWORD);
	p += sizeof(BOOL);
	ASSERT( p < (pSrc + cbSrc) );

	// get the reserved dword - (acutally, just skip over it)
	p += sizeof(DWORD);

	// now the strings......
	// for each string, first get the size of the string, then the data from the string

	// get the reserved string - (actually, just skip over it)
	dword = *((UNALIGNED DWORD*)p);
	p += sizeof(DWORD);
	p += dword;

	// get the name
	dword = *((UNALIGNED DWORD*)p);
	p += sizeof(DWORD);
	m_szName= p;
	p += dword;
	ASSERT( p < (pSrc + cbSrc) );

	// get the password
	dword = *((UNALIGNED DWORD*)p);
	p += sizeof(DWORD);
	// if there is no password, don't worry, just skip it
	if ( dword )
		{
		m_szPassword = p;
		p += dword;
		ASSERT( p < (pSrc + cbSrc) );
		}

	// get the organization
	// no longer used - skip the DN info
	for ( WORD i = 0; i < 6; i++ )
		{
		dword = *((UNALIGNED DWORD*)p);
		p += sizeof(DWORD);
		p += dword;
		ASSERT( p < (pSrc + cbSrc) );
		}

	// get the ip addres it is attached to
	dword = *((UNALIGNED DWORD*)p);
	p += sizeof(DWORD);
	m_szIPAddress = p;
	p += dword;
	ASSERT( p < (pSrc + cbSrc) );

	// get the default flag
	m_fDefault = *((UNALIGNED BOOL*)p);
	p += sizeof(BOOL);

	// now put get the number of bytes in the private key
	m_cbPrivateKey = *((UNALIGNED DWORD*)p);
	p += sizeof(DWORD);
	ASSERT( p < (pSrc + cbSrc) );

	// if the private key already exists, kill it. Then make a new pointer for it
	if ( m_pPrivateKey )
		GlobalFree( (HANDLE)m_pPrivateKey );
	m_pPrivateKey = (PVOID)GlobalAlloc( GPTR, m_cbPrivateKey );
	if ( !m_pPrivateKey ) return FALSE;

	// put in the private key
	CopyMemory( m_pPrivateKey, p, m_cbPrivateKey );
	p += m_cbPrivateKey;
	ASSERT( p < (pSrc + cbSrc) );



	// now put get the number of bytes in the certificate
	m_cbCertificate = *((UNALIGNED DWORD*)p);
	p += sizeof(DWORD);
	ASSERT( p < (pSrc + cbSrc) );

	// if the private key already exists, kill it. Then make a new pointer for it
	if ( m_pCertificate )
		GlobalFree( (HANDLE)m_pCertificate );
	m_pCertificate = NULL;

	// only make a certificate pointer if m_cbCertificate is greater than zero
	if ( m_cbCertificate )
		{
		m_pCertificate = (PVOID)GlobalAlloc( GPTR, m_cbCertificate );
		if ( !m_pCertificate ) return FALSE;

		// put in the private key
		CopyMemory( m_pCertificate, p, m_cbCertificate );
		p += m_cbCertificate;
		if ( version >= KEY_VERSION )
			ASSERT( p < (pSrc + cbSrc) );
		else
			ASSERT( p == (pSrc + cbSrc) );
		}


	// added near the end
	if ( version >= KEY_VERSION )
		{
		// now put get the number of bytes in the certificte request
		m_cbCertificateRequest = *((UNALIGNED DWORD*)p);
		p += sizeof(DWORD);
		ASSERT( p < (pSrc + cbSrc) );

		// if the private key already exists, kill it. Then make a new pointer for it
		if ( m_pCertificateRequest )
			GlobalFree( (HANDLE)m_pCertificateRequest );
		m_pCertificateRequest = NULL;

		// only make a certificate pointer if m_cbCertificate is greater than zero
		if ( m_cbCertificateRequest )
			{
			m_pCertificateRequest = (PVOID)GlobalAlloc( GPTR, m_cbCertificateRequest );
			if ( !m_pCertificateRequest ) return FALSE;

			// put in the private key
			CopyMemory( m_pCertificateRequest, p, m_cbCertificateRequest );
			p += m_cbCertificateRequest;
			ASSERT( p < (pSrc + cbSrc) );
			}

		// finally read in the expiration timestamp
//		m_tsExpires = *((UNALIGNED FILETIME*)p);
		p += sizeof(FILETIME);
		}
	else
		{
		m_cbCertificateRequest = 0;
		if ( m_pCertificateRequest )
			GlobalFree( (HANDLE)m_pCertificateRequest );
		m_pCertificateRequest = NULL;
//		m_tsExpires.dwLowDateTime = 0;
//		m_tsExpires.dwHighDateTime = 0;
		}

	// all done
	return TRUE;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\w3key\kmlsa.cpp ===
// this file provides a wrapper api to get to the NT specific LSA routines

#include "stdafx.h"
#include "KMLsa.h"




//=============================================================

//-------------------------------------------------------------
// pass in a NULL pszwServer name to open the local machine
HANDLE	HOpenLSAPolicy( WCHAR *pszwServer, DWORD *pErr )
	{
	NTSTATUS				ntStatus;
	LSA_OBJECT_ATTRIBUTES	objectAttributs;
	LSA_HANDLE				hPolicy;

	LSA_UNICODE_STRING		unicodeServer;

	// prepare the object attributes
	InitializeObjectAttributes( &objectAttributs, NULL, 0L, NULL, NULL );

	// prepare the lsa_unicode name of the server
	if ( pszwServer )
		{
		unicodeServer.Buffer = pszwServer;
		unicodeServer.Length = wcslen(pszwServer) * sizeof(WCHAR);
		unicodeServer.MaximumLength = unicodeServer.Length + sizeof(WCHAR);
		}


	// attempt to open the policy
	ntStatus = LsaOpenPolicy( pszwServer ? &unicodeServer : NULL,
						&objectAttributs, POLICY_ALL_ACCESS, &hPolicy );

	// check for an error
	if ( !NT_SUCCESS(ntStatus) )
		{
		*pErr = LsaNtStatusToWinError( ntStatus );
		return NULL;
		}

	// success, so return the policy handle as a regular handle
	*pErr = 0;
	return hPolicy;
	}


//-------------------------------------------------------------
BOOL	FCloseLSAPolicy( HANDLE hPolicy, DWORD *pErr )
	{
	NTSTATUS				ntStatus;

	// close the policy
	ntStatus = LsaClose( hPolicy );

	// check for an error
	if ( !NT_SUCCESS(ntStatus) )
		{
		*pErr = LsaNtStatusToWinError( ntStatus );
		return FALSE;
		}

	// success, so return the policy handle as a regular handle
	*pErr = 0;
	return TRUE;
}

//-------------------------------------------------------------
// passing NULL in for pvData deletes the secret
BOOL	FStoreLSASecret( HANDLE hPolicy, WCHAR* pszwSecretName, void* pvData, WORD cbData, DWORD *pErr )
	{
	LSA_UNICODE_STRING		unicodeSecretName;
	LSA_UNICODE_STRING		unicodeData;
	NTSTATUS				ntStatus;
	
	// make sure we have a policy and a secret name
	if ( !hPolicy || !pszwSecretName )
		{
		*pErr = 1;
		return FALSE;
		}

	// prepare the lsa_unicode name of the server
	unicodeSecretName.Buffer = pszwSecretName;
	unicodeSecretName.Length = wcslen(pszwSecretName) * sizeof(WCHAR);
	unicodeSecretName.MaximumLength = unicodeSecretName.Length + sizeof(WCHAR);

	// prepare the unicode data record
	if ( pvData )
		{
		unicodeData.Buffer = (WCHAR*)pvData;
		unicodeData.Length = cbData;
		unicodeData.MaximumLength = cbData;
		}

	// it is now time to store the secret
	ntStatus = LsaStorePrivateData( hPolicy, &unicodeSecretName, pvData ? &unicodeData : NULL );

	// check for an error
	if ( !NT_SUCCESS(ntStatus) )
		{
		*pErr = LsaNtStatusToWinError( ntStatus );
		return FALSE;
		}

	// success, so return the policy handle as a regular handle
	*pErr = 0;
	return TRUE;
	}



//-------------------------------------------------------------
// passing NULL in for pvData deletes the secret
PLSA_UNICODE_STRING	FRetrieveLSASecret( HANDLE hPolicy, WCHAR* pszwSecretName, DWORD *pErr )
{
	LSA_UNICODE_STRING		unicodeSecretName;
	LSA_UNICODE_STRING*		pUnicodeData = NULL;
	NTSTATUS				ntStatus;
	
	// make sure we have a policy and a secret name
	if ( !hPolicy || !pszwSecretName )
		{
		*pErr = 1;
		return FALSE;
		}

	// prepare the lsa_unicode name of the server
	unicodeSecretName.Buffer = pszwSecretName;
	unicodeSecretName.Length = wcslen(pszwSecretName) * sizeof(WCHAR);
	unicodeSecretName.MaximumLength = unicodeSecretName.Length + sizeof(WCHAR);

	// it is now time to store the secret
	ntStatus = LsaRetrievePrivateData( hPolicy, &unicodeSecretName, &pUnicodeData );

	// check for an error
	if ( !NT_SUCCESS(ntStatus) )
		{
		*pErr = LsaNtStatusToWinError( ntStatus );
		return NULL;
		}

	// success, so return the policy handle as a regular handle
	*pErr = 0;
	return (PLSA_UNICODE_STRING)pUnicodeData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\w3key\listrow.cpp ===
// ListRow.cpp : implementation file
//

#include "stdafx.h"
#include "resource.h"
#include "ListRow.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


#define	SZ_RES_COLOR_PREFS		"Control Panel\\Colors"
#define	SZ_RES_COLOR_HILITE		"Hilight"
#define	SZ_RES_COLOR_HILITETEXT	"HilightText"


/////////////////////////////////////////////////////////////////////////////
// CListSelRowCtrl
//-----------------------------------------------------------------------------------
CListSelRowCtrl::CListSelRowCtrl():
		m_StartDrawingCol( 0 )
	{
	}

//-----------------------------------------------------------------------------------
CListSelRowCtrl::~CListSelRowCtrl()
	{
	}


//-----------------------------------------------------------------------------------
BEGIN_MESSAGE_MAP(CListSelRowCtrl, CListCtrl)
	//{{AFX_MSG_MAP(CListSelRowCtrl)
	ON_WM_LBUTTONDOWN()
	ON_WM_LBUTTONDBLCLK()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

//-----------------------------------------------------------------------------------
void CListSelRowCtrl::GetHiliteColors()
	{
    // get the hilite color
    m_colorHilite = GetSysColor( COLOR_HIGHLIGHT );

    // get the hilited text color
    m_colorHiliteText = GetSysColor( COLOR_HIGHLIGHTTEXT );
	}



/////////////////////////////////////////////////////////////////////////////
// CListSelRowCtrl message handlers

//-----------------------------------------------------------------------------------
void CListSelRowCtrl::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct)
	{
	CRect		rcItem = lpDrawItemStruct->rcItem;
	CRect		rcSection;
	UINT		itemID = lpDrawItemStruct->itemID;
	UINT		cpLeft = rcItem.left;
	CString		sz;
	LV_COLUMN	colData;
	COLORREF	colorTextOld;
	COLORREF	colorBackOld;

	// setup the CDC object
	CDC			cdc;
	cdc.Attach( lpDrawItemStruct->hDC );

#ifdef _DEBUG
	if ( m_StartDrawingCol == 0 )
		sz.Empty();
#endif

	// clear the columnd buffer
	ZeroMemory( &colData, sizeof(colData) );
	colData.mask = LVCF_WIDTH;

	// if this is the selected item, prepare the background and the text color
	BOOL fSelected = lpDrawItemStruct->itemState & ODS_SELECTED;
	if ( fSelected )
		{
		GetHiliteColors();
		colorTextOld = cdc.SetTextColor( m_colorHiliteText );
		colorBackOld = cdc.SetBkColor( m_colorHilite );
		}


	// starting with the m_StartDrawingCol column, draw the columns
	// do it in a loop, just skipping until we hit m_StartDrawingCol
	DWORD iCol = 0;
	while ( GetColumn(iCol, &colData) )
		{
		// see if we are ready yet
		if ( iCol < m_StartDrawingCol )
			{
			// set the new left.
			cpLeft += colData.cx;
			// increment the column counter
			iCol++;
			continue;
			}

		// prepare the background but once
		if ( iCol == m_StartDrawingCol )
			{
			// prepare the background
			rcSection = rcItem;
			rcSection.left = cpLeft;
			rcSection.right--;
			CBrush	brush;
			if ( lpDrawItemStruct->itemState & ODS_SELECTED )
				brush.CreateSolidBrush( m_colorHilite );
			else
				brush.CreateSolidBrush( GetSysColor( COLOR_WINDOW ) );
			cdc.FillRect( &rcSection, &brush );
			}


		// display the name
		sz = GetItemText( itemID, iCol );
		if ( !sz.IsEmpty() )
			{
			// figure out the sectional rect
			rcSection = rcItem;
			rcSection.left = cpLeft + 2;
			rcSection.right = cpLeft + colData.cx - 1;
			
			// fit the string into the required space
			FitString( sz, rcSection.right - rcSection.left, &cdc );

			//draw the string
			cdc.DrawText( sz, &rcSection, DT_SINGLELINE|DT_LEFT|DT_BOTTOM|DT_NOPREFIX );
			}

		// set the new left.
		cpLeft += colData.cx;
		// increment the column counter
		iCol++;
		}

	// if this is the selected item, restore the colors
	if ( fSelected )
		{
		cdc.SetTextColor( colorTextOld );
		cdc.SetBkColor( colorBackOld );
		}

	// cleanup the CDC object
	cdc.Detach();
	}


//------------------------------------------------------------------------
void CListSelRowCtrl::FitString( CString &sz, int cpWidth, CDC* pcdc )
	{
	CSize		size;
	UINT		cch;
	CString		szEllipsis;

	// start by testing the existing width
	size = pcdc->GetTextExtent( sz );
	if ( size.cx <= cpWidth ) return;

	// initialize szTrunc and szEllipsis
	cch = sz.GetLength();
	szEllipsis.LoadString( IDS_ELLIPSIS );

	// while we are too big, truncate one letter and add an ellipsis
	while( (size.cx > cpWidth) && (cch > 1) )
		{
		// chop off the last letter of the string - not counting the ...
		cch--;
		sz = sz.Left( cch );

		// add the elipsis (spelling?)
		sz += szEllipsis;

		// get the length
		size = pcdc->GetTextExtent( sz );
		}
	}







//------------------------------------------------------------------------
void CListSelRowCtrl::HiliteSelectedCells()
	{
	int	iList = -1;
	while( (iList = GetNextItem( iList, LVNI_SELECTED )) >= 0 )
		HiliteSelectedCell( iList );
	}

//------------------------------------------------------------------------
void CListSelRowCtrl::HiliteSelectedCell( int iCell, BOOL fHilite )
	{
	// if there is no selected cell, do nothing
	if ( iCell < 0 )
		return;

	// get the rect to draw
	CRect	rect;
	if ( !FGetCellRect(iCell, -1, &rect) )
		{
		ASSERT(FALSE);
		return;
		}

	// get the client rect
	CRect	rectClient;
	GetClientRect( rectClient );

	// make sure it fits ok (problems can occur here when scrolled)
	// don't want it to draw in the column titles
	if ( rect.top < (rect.bottom - rect.top) )
		return;

	// now prepare to draw
	CDC	*pdc = GetDC();

	// clip to the client area
	pdc->IntersectClipRect( rectClient );

	// set up the brush
	CBrush	cbrush;
	if ( fHilite )
		cbrush.CreateSolidBrush( RGB(192,192,192) );
	else
		cbrush.CreateSolidBrush( RGB(0xFF,0xFF,0xFF) );

	// draw the hilite rect
	pdc->FrameRect( rect, &cbrush );

	// cleanup
	ReleaseDC( pdc );
	}

//------------------------------------------------------------------------
BOOL	CListSelRowCtrl::FGetCellRect( LONG iRow, LONG iCol, CRect *pcrect )
	{
	// first, get the rect that the list thinks is appropriate
	if ( !GetItemRect(iRow, pcrect, LVIR_BOUNDS) )
		return FALSE;

	// if iCol < 0, then return the total size of the row
	if ( iCol < 0 )
		return TRUE;

	// trim the horizontal dimension to the correct column positioning
	LONG	cpLeft;
	LONG	cpRight = 0;
	for ( WORD i = 0; i <= iCol; i++ )
		{
		// set the left side
		cpLeft = cpRight;

		// get the right
		LONG cpWidth = GetColumnWidth(i);
		if ( cpWidth < 0 ) return FALSE;
		cpRight += cpWidth;
		}

	// well, now trim it seeing as we have the right values
	pcrect->left = cpLeft;
	pcrect->right = cpRight;
	
	// success!
	return TRUE;
	}

#define MAKE_LPARAM(x,y) ( ((unsigned long)(y)<<16) | ((unsigned long)(x)) )

//------------------------------------------------------------------------
void CListSelRowCtrl::OnLButtonDblClk(UINT nFlags, CPoint point) 
	{
	// force the point to be in the right place
	point.x = 6;
	LPARAM lp = MAKE_LPARAM(point.x, point.y);
//	DefWindowProc(WM_LBUTTONDBLCLK, nFlags, lp );
	CListCtrl::OnLButtonDblClk( nFlags, point);
	}

//------------------------------------------------------------------------
void CListSelRowCtrl::OnLButtonDown(UINT nFlags, CPoint point) 
	{
	point.x = 6;
	LPARAM lp = MAKE_LPARAM(point.x, point.y);
//	DefWindowProc(WM_LBUTTONDOWN, nFlags, lp );
	CListCtrl::OnLButtonDown( nFlags, point);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\w3key\mdkey.h ===
#define		MDNAME_INCOMPLETE	"incomplete"
#define		MDNAME_DISABLED		"disabled"
#define		MDNAME_DEFAULT		"default"

#define	MD_W3BASE			"/lm/w3svc/"

// foward declare the service
class CMDKeyService;

//-------------------------------------------------------------
// This is the key object
class CMDKey : public CCmnKey
	{
	public:
		CMDKey();
		CMDKey(CMDKeyService*  pService);
		~CMDKey();

		void SetName( CString &szNewName );
		virtual void UpdateCaption( void );

		// copy the members from a key into this key
		virtual void CopyDataFrom( CKey* pKey );
		virtual CKey*	PClone( void );

		// install a cert
		virtual BOOL FInstallCertificate( PVOID pCert, DWORD cbCert, CString &szPass );

		void OnProperties();

		// add a binding to the binding list
		void AddBinding( LPCSTR psz );
		// remove a specified binding
		void RemoveBinding( CString szBinding );
		// is a given binding already associated with the key
		BOOL FContainsBinding( CString szBinding );

		// get the unique identifying string for this key. - actually the certificate serial number
		// return false if this is an incomplete key
		BOOL FGetIdentString( CWrapMetaBase* pWrap, PCHAR pszObj, CString &szIdent );
        BOOL FGetIdentString( PVOID pCert, DWORD cbCert, CString &szIdent );
        BOOL FGetIdentString( CString &szIdent );

		// load the key out of the metabase
		BOOL FLoadKey( CWrapMetaBase* pWrap, PCHAR pszObj );
	
		// write the key out to the metabase
		BOOL FWriteKey( CWrapMetaBase* pWrap, DWORD iKey, CStringArray* prgbsz );

		// the list of target binding names for the metabase objects
		CStringArray	m_rgbszBindings;

		// cache the identifier string for faster use later
		CString			m_szIdent;

		// the target port address
//		DWORD		m_dwPort;

		// update flags
		BOOL	m_fUpdateKeys;
		BOOL	m_fUpdateFriendlyName;
		BOOL	m_fUpdateIdent;
		BOOL	m_fUpdateBindings;

	protected:
		// DO declare all this DYNCREATE
		DECLARE_DYNCREATE(CMDKey);

		// write out the data portion to a particular binding
		BOOL FWriteData( CWrapMetaBase* pWrap, CString szBinding, BOOL fWriteAll );

        // the service that created and owns this key
        CMDKeyService*  m_pService;

	private:
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\w3key\mdserv.cpp ===
// This file is the metadata version of the key storage serverice object for the w3 server.
// it knows nothing about the LSA storage and only interacts with the metabase. Likewise,
// it does not convert old keyset.exe keys into a newer format. Any old LSA keys should have
// automatically converted to the new metabase format by the setup utility.

// file created 4/1/1997 by BoydM


#include "stdafx.h"
#include "KeyObjs.h"

#include "iiscnfg.h"
#include "wrapmb.h"

#include "cmnkey.h"
#include "mdkey.h"
#include "mdserv.h"

#include "resource.h"

// the service image index
extern int          g_iServiceImage;
extern HINSTANCE    g_hInstance;

BOOL    g_fUsingMetabase = FALSE;
#define MAX_LEN                 (METADATA_MAX_NAME_LEN * sizeof(WCHAR))


//--------------------------------------------------------
CMDKeyService::CMDKeyService():
        m_pszwMachineName(NULL)
    {
    // specify the resources to use
    HINSTANCE hOldRes = AfxGetResourceHandle();
    AfxSetResourceHandle( g_hInstance );

    // set the icon id
    m_iImage = (WORD)g_iServiceImage;

    // load the service name
    m_szItemName.LoadString( IDS_SERV_NAME );

    // yes, we are using the metabase
    g_fUsingMetabase = TRUE;

    // restore the resources
    AfxSetResourceHandle( hOldRes );
    }

//--------------------------------------------------------
CMDKeyService::~CMDKeyService()
    {
    if ( m_pszwMachineName )
        delete m_pszwMachineName;
    }

//--------------------------------------------------------
void CMDKeyService::SetMachineName( WCHAR* pszw )
    {
    if ( pszw )
        {
        m_pszwMachineName = new WCHAR[wcslen(pszw)+1];
        wcscpy( m_pszwMachineName, pszw );
        }
    else
        {
        m_pszwMachineName = NULL;
        }
    }

//--------------------------------------------------------
void CMDKeyService::LoadKeys( CMachine* pMachine )
    {
    CString     szKeyObject;
    DWORD       index = 0;
    CString     szKeyBase;
    CString     sz;

    // keep a local list of the added keys in some attempt to keep this simpler
    CTypedPtrArray<CObArray, CMDKey*> rgbKeys;
    CString     szIdent;
    BOOL        fLoadTheKey;
    DWORD       iKey;
    DWORD       nKey;

    // create the metabase wrapper object
    CWrapMetaBase   mbWrap;
    if ( !mbWrap.FInit() )
        {
        ASSERT( FALSE );
        goto cleanup;       // can't get to metabase - no keys
        }

    // build the key name
    szKeyBase = SZ_META_BASE;
    szKeyBase += SZ_META_KEYBASE;

    // open the base metabase object that contains all the keys
    // if we were unable to open the object - then there aren't any keys
    if ( !mbWrap.Open( szKeyBase, METADATA_PERMISSION_READ ) )
        goto cleanup;       // can't open metabase

    // read in all the keys and add them to the main list
    while ( mbWrap.EnumObjects("", sz.GetBuffer(MAX_LEN), MAX_LEN, index) )
        {
        sz.ReleaseBuffer();

        // make a new key object
        CMDKey* pKey = new CMDKey(this);
        if ( !pKey ) continue;

        // here's the deal. If this key is a member of a group of IP addresses that actually
        // use the same key, then we need to figure out the groups. We don't want to actually
        // load all the keys. - Just the first from each group. First we get the unique
        // identifier string for the key (the serial number), which should be cached in the
        // metabase for us.
        fLoadTheKey = FALSE;
        if ( pKey->FGetIdentString(&mbWrap, sz.GetBuffer(MAX_LEN), szIdent) )
            {
            sz.ReleaseBuffer();
            // we did get an ident string. Now we need to look through the list of keys we
            // have already loaded and see if there is a parental match for this one. If there
            // is, we add this key's metaname to the list of metanames for the parent and do NOT
            // load the rest of the data for the key - because it is already there for the parent.
            nKey = rgbKeys.GetSize();
            for ( iKey = 0; iKey < nKey; iKey++ )
                {
                CString szTest = rgbKeys[iKey]->m_szIdent;
                if ( szIdent == szTest )
                    {
                    // we found a sub-member! - add it to the parent's list
                    rgbKeys[iKey]->AddBinding( sz );
                    
                    // get out of this sub-loop
                    goto loadkey;
                    }
                }
            // we did not find a parent for the key. Load it
            fLoadTheKey = TRUE;
            }
        else
            {
            sz.ReleaseBuffer();
            // if we did not get the ident string, then this is an incomplete key and
            // won't have multiple bindings anyway. Load it
            fLoadTheKey = TRUE;
            }
        
        // fill in the parts of the key by reading in the relevant info from the metabase       
        // add the key to the tree - if we successfully read it in
loadkey:
        if ( fLoadTheKey && pKey->FLoadKey(&mbWrap, (LPSTR)(LPCSTR)sz) )
            {
            // add it to visible tree view
            pKey->FAddToTree( this );
            // add it to the cached list for easier access as we load the keys
            rgbKeys.Add(pKey);
            }
        else
            delete pKey;

        // increment to the next object
        index++;
        }
        sz.ReleaseBuffer();

    // close the metabase on the target machine
    mbWrap.Close();

    // cleanup the metabase connection
cleanup:
    ;
    }

//--------------------------------------------------------
BOOL CMDKeyService::FCommitChangesNow( )
    {
    BOOL    fAnswer = FALSE;
    DWORD   iKey = 1;
    CMDKey* pKey;
    CString szKeyBase;

    CStringArray    rgbSZ;
    CString     szEnum;
    DWORD   iObject = 0;
    DWORD   iString;
    DWORD   nStrings;
    rgbSZ.SetSize( 0, 8 );
    BOOL    f;

    // get the metabase going
    if ( !FInitMetabaseWrapper(m_pszwMachineName) )
        return FALSE;

    // create the metabase wrapper object
    CWrapMetaBase   mbWrap;
    if ( !mbWrap.FInit() )
        {
        ASSERT( FALSE );
        goto cleanup;       // can't get to metabase - no keys
        }

    // build the key name
    szKeyBase = SZ_META_BASE;
    szKeyBase += SZ_META_KEYBASE;

    // open the base metabase object that contains all the keys
    // if we were unable to open the object - then there aren't any keys
    if ( !mbWrap.Open( szKeyBase, METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ ) )
        {
        // the base object for the keys doesn't exist. This means
        // we have to create it first, then try to open it

        // open up the w3svc base, which is where the key base lives
        if ( !mbWrap.Open( SZ_META_BASE, METADATA_PERMISSION_WRITE ) )
            goto cleanup;       // whoa! this shouldn't happen

        // create the key - if it doesn't work, croak
        if ( !mbWrap.AddObject(SZ_META_KEYBASE) )
            {
            mbWrap.Close();
            goto cleanup;
            }
        mbWrap.Close();
        
        // NOW try to open the base key - and it better work this time
        if ( !mbWrap.Open( szKeyBase, METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ ) )
            goto cleanup;
        }

    // update each of the keys
    pKey = GetFirstMDKey();
    while( pKey )
        {
        // tell the key to write itself out
        pKey->FWriteKey( &mbWrap, iKey, &rgbSZ );

        // get the next key
        pKey = GetNextMDKey( pKey );
        iKey++;
        }

    // scan the metabase looking for objects there were not just saved. If it hasn't
    // been just saved, or marked saved, we get rid of it.
    // read in all the keys and add them to the main list
    nStrings = rgbSZ.GetSize();
    while ( mbWrap.EnumObjects("", szEnum.GetBuffer(MAX_LEN), MAX_LEN, iObject) )
        {
        szEnum.ReleaseBuffer();

        // is it in the saved list?
        for ( iString = 0; iString < nStrings; iString++ )
            {
            if ( rgbSZ[iString] == szEnum )
                {
                // increment to the next object
                iObject++;
                goto nextObject;
                }
            }

        // if it is not in the list, delete the object
        f = mbWrap.DeleteObject( szEnum );
nextObject:
        ;
        }
        szEnum.ReleaseBuffer();

    // close the metabase on the target machine
    mbWrap.Close();

    // write out the changes we made to the metabase
    mbWrap.Save();

    // string memory in a CStringArray object is automatically cleanup up
    // when the main object is deleted.

    // clear the dirty flag
    SetDirty( FALSE );
    fAnswer = TRUE;

    // cleanup the metabase connection
cleanup:
    // now close the metabase again. We will open it when we need it
    FCloseMetabaseWrapper();

    // return the answer
    return fAnswer;
    }

//--------------------------------------------------------
BOOL CMDKeyService::FIsBindingInUse( CString szBinding )
    {
    CMDKey* pKey;

    // get the first key in the service list
    pKey = GetFirstMDKey();

    // loop the keys, testing each in turn
    while ( pKey )
        {
        // test it
        if ( pKey->FContainsBinding( szBinding ) )
            return TRUE;

        // get the next key in the list
        pKey = GetNextMDKey( pKey );
        }

    // nope. Didn't find it.
    return FALSE;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\w3key\listrow.h ===
// ListRow.h : header file
//


#ifndef _LISTROW_
#define _LISTROW_

/////////////////////////////////////////////////////////////////////////////
// CListSelRowCtrl window

class CListSelRowCtrl : public CListCtrl
{
// Construction
public:
	CListSelRowCtrl();

	virtual void DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CListSelRowCtrl)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CListSelRowCtrl();

	// Generated message map functions
protected:
	//{{AFX_MSG(CListSelRowCtrl)
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	void GetHiliteColors();

	void HiliteSelectedCells();
	void HiliteSelectedCell( int iCell, BOOL fHilite = TRUE );
	BOOL FGetCellRect( LONG iRow, LONG iCol, CRect *pcrect );

	void FitString( CString &sz, int cpWidth, CDC* pcdc );

	CBitmap		m_bitmapCheck;
	COLORREF	m_colorHiliteText;
	COLORREF	m_colorHilite;

	DWORD		m_StartDrawingCol;

};

/////////////////////////////////////////////////////////////////////////////
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\w3key\mdkey.cpp ===
// This file is the metadata version of the key storage object for the w3 server.
// it knows nothing about the LSA storage and only interacts with the metabase. Likewise,
// it does not convert old keyset.exe keys into a newer format. Any old LSA keys should have
// automatically converted to the new metabase format by the setup utility.

// file created 4/1/1997 by BoydM

#include "stdafx.h"
#include "KeyObjs.h"

#include "iiscnfgp.h"
#include "wrapmb.h"

#include "cmnkey.h"
#include "mdkey.h"
#include "mdserv.h"

#include "crackcrt.h"

#include "resource.h"

#include "ListRow.h"
#include "bindsdlg.h"

IMPLEMENT_DYNCREATE(CMDKey, CKey);
#define MAX_LEN                 (METADATA_MAX_NAME_LEN * sizeof(WCHAR))

#define		DEFAULT_PORT		443

extern HINSTANCE	g_hInstance;

//--------------------------------------------------------
CMDKey::CMDKey() :
		m_fUpdateKeys( FALSE ),
		m_fUpdateFriendlyName( FALSE ),
		m_fUpdateIdent( FALSE ),
		m_fUpdateBindings( FALSE ),
        m_pService( NULL )
	{}

//--------------------------------------------------------
CMDKey::CMDKey(CMDKeyService*  pService) :
		m_fUpdateKeys( FALSE ),
		m_fUpdateFriendlyName( FALSE ),
		m_fUpdateIdent( FALSE ),
		m_fUpdateBindings( FALSE ),
        m_pService( pService )
	{}

//--------------------------------------------------------
CMDKey::~CMDKey()
	{}

//-------------------------------------------------------------
void CMDKey::SetName( CString &szNewName )
	{
	CCmnKey::SetName( szNewName );
	m_fUpdateFriendlyName = TRUE;
	}

//-------------------------------------------------------------
// update the key's caption
void CMDKey::UpdateCaption( void )
	{
	// specify the resources to use
	HINSTANCE hOldRes = AfxGetResourceHandle();
	AfxSetResourceHandle( g_hInstance );

	CString	sz;
	// the caption is based on the name of the key
	CString szCaption = m_szName;

	// now we tack on info about the server it is attached to
	szCaption += _T(" <");
	switch( m_rgbszBindings.GetSize() )
		{
		case 0:		// there are no bindings, do nothing
			sz.Empty();
			break;
		case 1:		// if there is only one binding, use it in the brackets
			sz = m_rgbszBindings[0];
			// actually, we need to see if it is the non-localized default string
			if ( sz == MDNAME_DEFAULT )
				sz.LoadString( IDS_DEFAULT );	// load the localized default string
			break;
		default:	// there are multiple bindings, say so
			sz.LoadString( IDS_MULTIPLE_BINDINGS );
			break;
		};
	// close the brackets
	szCaption += sz;
	szCaption += _T(">");

	// and setup the caption
	m_szItemName = szCaption;
	FSetCaption(szCaption);

	// update the icon too
	UpdateIcon();

	// restore the resources
	AfxSetResourceHandle( hOldRes );
	}

//-------------------------------------------------------------
		// make a copy of the key
//-------------------------------------------------------------
CKey* CMDKey::PClone( void )
	{
	CMDKey*	pClone = NULL;

	// TRY to make a new key object
	try
		{
		pClone = new CMDKey(m_pService);

		// copy over all the data
		pClone->CopyDataFrom( this );
		}
	catch( CException e )
		{
		// if the object had been made, delete it
		if ( pClone )
			delete pClone;
		return NULL;
		}

	return (CKey*)pClone;
	}

//-------------------------------------------------------------
// copy the members from a key into this key
//-------------------------------------------------------------
void CMDKey::CopyDataFrom( CKey* pKey )
	{
	// copy over the base data
	CKey::CopyDataFrom( pKey );

	// if the key we are copying from is a MD key, copy over
	// the w3MD specific information as well
	if ( pKey->IsKindOf(RUNTIME_CLASS(CMDKey)) )
		{
		CMDKey* pMDKey = (CMDKey*)pKey;
		m_szName = pMDKey->m_szName;
		}
	else
		{
		m_szName = pKey->m_szItemName;
		}
	}


//-------------------------------------------------------------
void CMDKey::OnProperties()
	{
	// specify the resources to use
	HINSTANCE hOldRes = AfxGetResourceHandle();
	AfxSetResourceHandle( g_hInstance );


    // if this key does not have a signed certificate, do not allow the user
    // to make any bindings to it
    if ( !m_pCertificate )
        {
        AfxMessageBox( IDS_DONT_BIND_UNSIGNED );
        // restore the resources
        AfxSetResourceHandle( hOldRes );
        return;
        }

	// the properties of the w3 key invove its ip address relationship
	CBindingsDlg	dlg( m_pService->m_pszwMachineName );

	// give it this key
	dlg.m_pKey = this;

	// set the instance members of the dialog
	// run the dialog
	if ( dlg.DoModal() == IDOK )
		{
		// cause the name to rebuild
		UpdateCaption();

		// set it dirty
		SetDirty( TRUE );
		}

	// restore the resources
	AfxSetResourceHandle( hOldRes );
	}

//--------------------------------------------------------
// add a binding to the binding list
void CMDKey::AddBinding( LPCSTR psz )
	{
	CString	szBinding = psz;

	// filter out disabled or incomplete key bindings
	if ( (szBinding.Find(MDNAME_INCOMPLETE) >= 0) ||
			(szBinding.Find(MDNAME_DISABLED) >= 0) )
		{
		return;
		}
	
	// add the binding to the list
	m_rgbszBindings.Add( psz );

	// update the caption if we need to
	switch( m_rgbszBindings.GetSize() )
		{
		case 1:	// the display changes on these
		case 2:
			UpdateCaption();
		};
	}

//--------------------------------------------------------
// is a given binding already associated with the key
void CMDKey::RemoveBinding( CString szBinding )
	{
	DWORD	nItems, iItem;

	// scan the binding list
	nItems = m_rgbszBindings.GetSize();
	for ( iItem = 0; iItem < nItems; iItem++ )
		{
		// look for the binding
		if ( szBinding == m_rgbszBindings[iItem] )
			{
			// found it!
			m_rgbszBindings.RemoveAt( iItem );
			m_fUpdateBindings = TRUE;

			// update the caption if we need to
			switch( m_rgbszBindings.GetSize() )
				{
				case 0:	// the display changes on these
				case 1:
					UpdateCaption();
				};
			}
		}
	}

//--------------------------------------------------------
// is a given binding already associated with the key
BOOL CMDKey::FContainsBinding( CString szBinding )
	{
	DWORD	nItems, iItem;

	// scan the binding list
	nItems = m_rgbszBindings.GetSize();
	for ( iItem = 0; iItem < nItems; iItem++ )
		{
		// look for the binding
		if ( szBinding == m_rgbszBindings[iItem] )
			{
			// found it!
			return TRUE;
			}
		}

	// we did not find the binding
	return FALSE;
	}

//--------------------------------------------------------
BOOL CMDKey::FGetIdentString( CString &szIdent )
    {
    // make sure the cert is there
    if ( !m_pCertificate || !m_cbCertificate )
        return FALSE;
    return FGetIdentString( m_pCertificate, m_cbCertificate, szIdent );
    }

//--------------------------------------------------------
BOOL CMDKey::FGetIdentString( PVOID pCert, DWORD cbCert, CString &szIdent )
    {
	// declare the cracker object
	CCrackedCert	cracker;
	// crack the cert
	if ( cracker.CrackCert( (PUCHAR)pCert, cbCert ) )
		{
		DWORD*	pdw = cracker.PGetSerialNumber();
		szIdent.Format( "%d:%d:%d:%d", pdw[0], pdw[1], pdw[2], pdw[3] );
		// success
		return TRUE;
		}
    return FALSE;
    }


//--------------------------------------------------------
// does a given key name exist already in the metabase?
BOOL CMDKey::FGetIdentString( CWrapMetaBase* pWrap, PCHAR pszObj, CString &szIdent )
	{
	BOOL		fAnswer = FALSE;
    DWORD		cbData;
    PVOID		pData;
    CString     sz;

    // if this is an incomplete key, fail
    if ( _tcsncmp(MDNAME_INCOMPLETE, pszObj, _tcslen(MDNAME_INCOMPLETE)) == 0 )
        return FALSE;

	// try and ready the cached ident directly.
	BOOL f = pWrap->GetString( pszObj, MD_SSL_IDENT, IIS_MD_UT_SERVER,
            sz.GetBuffer(MAX_LEN), MAX_LEN);
    sz.ReleaseBuffer();
    if ( f )
		{
		// good. It was cached.
		szIdent = sz;
        m_szIdent = szIdent;
		return TRUE;
		}

	// drat. We haven't cached the ident for this key before. we need to get it. This
	// means loading the certificate - and cracking it to get the serial number. If there
	// is no certificate (an incomplete key) we return false.
    pData = pWrap->GetData( pszObj, MD_SSL_PUBLIC_KEY, IIS_MD_UT_SERVER,
                BINARY_METADATA, &cbData, 0 );
	// we got the certificate and can now crack it
    if ( pData )
        {
        m_fUpdateIdent = FGetIdentString( (PUCHAR)pData, cbData, szIdent );
        fAnswer = m_fUpdateIdent;
		// cache the ident in memory. It will get written out on Commit
		m_szIdent = szIdent;
/*
		// declare the cracker object
		CCrackedCert	cracker;
		// crack the cert
		if ( cracker.CrackCert( (PUCHAR)pData, cbData ) )
			{
			DWORD*	pdw = cracker.PGetSerialNumber();
			szIdent.Format( "%d:%d:%d:%d", pdw[0], pdw[1], pdw[2], pdw[3] );
			// cache the ident in memory. It will get written out on Commit
			m_szIdent = szIdent;
			m_fUpdateIdent = TRUE;
			// success
			fAnswer = TRUE;
			}
*/
		// free the buffer
		pWrap->FreeWrapData( pData );
		}
	else
		{
		// we did not get the certificate - return FALSE
		// fAnswer is already set to false
		}

	// return the answer;
	return fAnswer;
	}

//--------------------------------------------------------
BOOL CMDKey::FWriteKey( CWrapMetaBase* pWrap, DWORD iKey, CStringArray* prgbszTracker )
	{
	BOOL		f;
	DWORD		nBindings = m_rgbszBindings.GetSize();
	CString		szBinding;
	BOOL		fUpdateAll = FALSE;

	// if there are no assigned bindings, the key still gets stored with a object
	// name in the format of "disabled{iKey}". and if it is incomplete, then store
	// it with the name "incomplete{iKey}" Because the iKey can change and we don't
	// want any conflicts, re-write them
	if ( nBindings == 0 )
		{
		// build the binding name as appropriate
		if ( m_pCertificate )
			szBinding.Format( "%s%d", MDNAME_DISABLED, iKey );
		else
			szBinding.Format( "%s%d", MDNAME_INCOMPLETE, iKey );

		// set the update flag
		m_fUpdateBindings = TRUE;
		}

	// NOTE: pWrap has already been opened to /LM/W3Svc/SSLKeys
	// if the key is not dirty, its easy
	if ( !m_fUpdateKeys && !m_fUpdateFriendlyName && !m_fUpdateIdent && !m_fUpdateBindings && !FGetDirty() )
		{
		// add names of its bindings so it doesn't get deleted
		DWORD	iBinding;
		for ( iBinding = 0; iBinding < nBindings; iBinding++ )
			prgbszTracker->Add( m_rgbszBindings[iBinding] );
		return TRUE;
		}

	// handle no bindings as a special case first
	if ( nBindings == 0 )
		{
		// tell the server about it
		prgbszTracker->Add((LPCSTR)szBinding);
		// ok. Create the key in the metabase.
		f = pWrap->AddObject( szBinding );
		// and save the data
		f = FWriteData( pWrap, szBinding, TRUE );
		// clear the dirty flag and exit
		SetDirty( FALSE );
		return TRUE;
		}

	// there are bindings to be saved... loop though them and update each
	DWORD	iBinding;
	for ( iBinding = 0; iBinding < nBindings; iBinding++ )
		{
		// get the binding name
		szBinding = m_rgbszBindings[iBinding];


// test code
if ( szBinding.IsEmpty() )
AfxMessageBox( "Empty Binding Alert!" );


		// now that we know where to save it, add the name to list of saved
		// objects being kept track of by the server object - (This is so that
		// the server knows what's been added)
		prgbszTracker->Add((LPCSTR)szBinding);

		// ok. Create the key in the metabase. Really, we may only need to do this
		// if m_fUpdateBindings is set - if the object is new - update all the data
		fUpdateAll = pWrap->AddObject( szBinding ) || m_fUpdateBindings;

		// write out the data
		FWriteData( pWrap, szBinding, fUpdateAll );
		}

	// clear the flags
	m_fUpdateKeys = FALSE;
	m_fUpdateFriendlyName = FALSE;
	m_fUpdateIdent = FALSE;
	m_fUpdateBindings = FALSE;

	// clear the dirty flag
	SetDirty( FALSE );

	return TRUE;
	}

//--------------------------------------------------------
// write out the data portion to a particular binding
BOOL CMDKey::FWriteData( CWrapMetaBase* pWrap, CString szBinding, BOOL fWriteAll )
	{
	BOOL f;
	// write all the parts of the key - start with the certificate

	// start with the secure parts
	if ( m_fUpdateKeys || fWriteAll )
		{
		if ( m_pCertificate )
			f = pWrap->SetData( szBinding, MD_SSL_PUBLIC_KEY, IIS_MD_UT_SERVER, BINARY_METADATA,
										m_pCertificate, m_cbCertificate,
										METADATA_SECURE );

		// write out the private key
		if ( m_pPrivateKey )
			f = pWrap->SetData( szBinding, MD_SSL_PRIVATE_KEY, IIS_MD_UT_SERVER, BINARY_METADATA,
										m_pPrivateKey, m_cbPrivateKey,
										METADATA_SECURE );

		// write out the password - treat is ast secure binary data
		if ( !m_szPassword.IsEmpty() )
			f = pWrap->SetData( szBinding, MD_SSL_KEY_PASSWORD, IIS_MD_UT_SERVER, BINARY_METADATA,
										(PVOID)(LPCSTR)m_szPassword, m_szPassword.GetLength()+1,
										METADATA_SECURE );

		// write out the request
		if ( m_pCertificateRequest )
			f = pWrap->SetData( szBinding, MD_SSL_KEY_REQUEST, IIS_MD_UT_SERVER, BINARY_METADATA,
										m_pCertificateRequest, m_cbCertificateRequest,
										METADATA_SECURE );
		}

	// write out the cached serial number
	if ( m_fUpdateIdent || m_fUpdateKeys || fWriteAll )
		if ( !m_szIdent.IsEmpty() )
			{
			f = pWrap->SetString( szBinding, MD_SSL_IDENT, IIS_MD_UT_SERVER,
								m_szIdent, METADATA_SECURE );
			}

	// write out the friendly name of the key
	if ( m_fUpdateFriendlyName || fWriteAll )
		f = pWrap->SetString( szBinding, MD_SSL_FRIENDLY_NAME, IIS_MD_UT_SERVER,
									m_szName, 0 );

	return TRUE;
	}

//--------------------------------------------------------
BOOL CMDKey::FLoadKey( CWrapMetaBase* pWrap, PCHAR pszObj )
	{
    DWORD		cbData;
    PVOID		pData;

	// start with the public key
    pData = pWrap->GetData( pszObj, MD_SSL_PUBLIC_KEY, IIS_MD_UT_SERVER,
                BINARY_METADATA, &cbData, 0 );
    if ( pData )
        {
        // set the data into place
		m_pCertificate = (PVOID)GlobalAlloc( GPTR, cbData );
		// if we got the pointer, copy the rest of the data into place
		if( m_pCertificate)
			{
			m_cbCertificate = cbData;
			CopyMemory( m_pCertificate, pData, cbData );
			}
		// free the buffer
		pWrap->FreeWrapData( pData );
		}
		
	// now the private key
    pData = pWrap->GetData( pszObj, MD_SSL_PRIVATE_KEY, IIS_MD_UT_SERVER,
                BINARY_METADATA, &cbData, 0 );
    if ( pData )
        {
        // set the data into place
		m_pPrivateKey = (PVOID)GlobalAlloc( GPTR, cbData );
		// if we got the pointer, copy the rest of the data into place
		if( m_pPrivateKey)
			{
			m_cbPrivateKey = cbData;
			CopyMemory( m_pPrivateKey, pData, cbData );
			}
		// free the buffer
		pWrap->FreeWrapData( pData );
		}
		
	// now the password key
    pData = pWrap->GetData( pszObj, MD_SSL_KEY_PASSWORD, IIS_MD_UT_SERVER,
                BINARY_METADATA, &cbData, 0 );
    if ( pData )
        {
        // set the data into place - relatively easy in this case
		m_szPassword = (LPCSTR)pData;
		// free the buffer
		pWrap->FreeWrapData( pData );
		}

	// now the request
    pData = pWrap->GetData( pszObj, MD_SSL_KEY_REQUEST, IIS_MD_UT_SERVER,
                BINARY_METADATA, &cbData, 0 );
    if ( pData )
        {
        // set the data into place
		m_pCertificateRequest = (PVOID)GlobalAlloc( GPTR, cbData );
		// if we got the pointer, copy the rest of the data into place
		if( m_pCertificateRequest)
			{
			m_cbCertificateRequest = cbData;
			CopyMemory( m_pCertificateRequest, pData, cbData );
			}
		// free the buffer
		pWrap->FreeWrapData( pData );
		}

	// finally, retrieve the friendly name
	BOOL f = pWrap->GetString( pszObj, MD_SSL_FRIENDLY_NAME, IIS_MD_UT_SERVER,
                m_szName.GetBuffer(MAX_LEN), MAX_LEN, 0);
    m_szName.ReleaseBuffer();
    if ( !f )
		m_szName.Empty();

	// make this item's metabase name the first name in the list
	AddBinding( pszObj );

	// Success
	return TRUE;
	}

//-------------------------------------------------------------
// install a cert
BOOL CMDKey::FInstallCertificate( PVOID pCert, DWORD cbCert, CString &szPass )
	{
    // first, we should test that the certificate and password are valid
    // for this particular key
	// cache the old certificate in case the new one fails
	DWORD	old_cbCertificate = m_cbCertificate;
	PVOID	old_pCertificate = m_pCertificate;

	// set the new one into place
	m_cbCertificate = cbCert;
	m_pCertificate = pCert;

	// verify the password - verify password puts up any error dialogs
	if ( !FVerifyValidPassword(szPass) )
		{
		// resore the old values
		m_cbCertificate = old_cbCertificate;
		m_pCertificate = old_pCertificate;

		// dispose of the new stuff
		GlobalFree( pCert );

		// return false
		return FALSE;
		}

    // now we need to see if this key has already been installed
    // get the identification string
    CString szIdentThis;
    if ( !FGetIdentString( pCert, cbCert, szIdentThis ) )
        return FALSE;

    // scan the existing keys, looking for one with the same ident string
    // if one is found, tell the user that it already exists and fail
    CString szIdentTest;
    CMDKey* pTestKey = m_pService->GetFirstMDKey();
    while ( pTestKey )
        {
        // if we are testing against this key, continue
        if ( pTestKey == this )
            goto GETNEXTKEY;

        // get the test ident string
        if ( !pTestKey->FGetIdentString( pTestKey->m_pCertificate,
                                pTestKey->m_cbCertificate, szIdentTest ) )
            goto GETNEXTKEY;

        // test the ident strings
        if ( szIdentThis == szIdentTest )
            {
            // the key already exists
            AfxMessageBox( IDS_DUPLICATE_CERT );
            return FALSE;
            }

GETNEXTKEY:
        // get the next key for the loop
        pTestKey = m_pService->GetNextMDKey(pTestKey);
        }

	// run the default action
	BOOL	fDefault = CKey::FInstallCertificate(pCert, cbCert, szPass);

	// set the update keys flag
	m_fUpdateKeys = TRUE;


    // if everything worked so far then check to see if there is a key
    // on this service with the default binding. If there isn't, then
    // set this key to have the default binding.
    if ( fDefault )
        {
        // load the default binding string
        CString szBinding;
        szBinding = MDNAME_DEFAULT;
        // if no key has the default binding, then make it so
        if ( !m_pService->FIsBindingInUse(szBinding) )
            {
			m_rgbszBindings.Add( MDNAME_DEFAULT );
            }
        }


    // if it worked, force the icon to change
    if ( fDefault )
        UpdateIcon();

	// return the default answer
	return fDefault;
	}





=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\w3key\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by W3Key.rc
//
#define IDD_CHOOSE_IPADDRESS            141
#define IDS_SERV_NAME                   10001
#define IDS_DEFAULT                     10002
#define IDS_IMPORT_KEYSET_PRIV_ERROR    10003
#define IDS_IMPORT_KEYSET_PUB_ERROR     10004
#define IDS_IMPORT_KEYSET_PASS_ERROR    10005
#define IDS_COMMIT_ERROR                10006
#define IDS_FOUND_KEYSET_KEYS           10007
#define IDS_UNTITLED                    10008
#define IDS_INVALID_KEY                 10009
#define IDS_NO_VIRT_ROOTS               10010
#define IDS_NO_HTTP                     10011
#define IDS_SelectConnectMsg            10012
#define IDS_MULTIPLE_BINDINGS           10013
#define IDS_THIS_KEY_HAS_BINDING        10014
#define IDS_ANOTHER_KEY_HAS_BINDING     10015
#define IDS_IP_ADDRESS                  10016
#define IDS_PORT_NUMBER                 10017
#define IDS_ANY_UNASSIGNED              10018
#define IDS_ELLIPSIS                    10019
#define IDS_DONT_BIND_UNSIGNED          10020
#define IDS_DUPLICATE_CERT              10021
#define IDS_NO_SECURE_BINDINGS          10022
#define IDS_BAD_CERT_KEY_MATCH          10023
#define IDS_INVALID_IP                  10024
#define IDS_INVALID_PORT                10025
#define IDC_USE_KEY                     10100
#define IDC_ANY_IP                      10101
#define IDC_ANY_PORT                    10102
#define IDC_RD_PORT                     10103
#define IDC_PORT_DROP                   10104
#define IDC_IP_DROP                     10105
#define IDC_RD_IP                       10106
#define IDC_LIST                        10107
#define IDC_ADD                         10109
#define IDC_EDIT                        10110
#define IDC_DELETE                      10111
#define IDB_SERVICE_BMP                 10129
#define IDD_KEY_PROP                    10130
#define IDD_KEY_PROP_IIS4               10131
#define IDD_BINDINGS                    10132
#define IDD_EDT_BINDING                 10133
#define IDC_BTN_KEYVIEW_NONE            11034
#define IDC_BTN_KEYVIEW_DEFAULT         11035
#define IDC_BTN_KEYVIEW_IPADDR          11036
#define IDC_BTN_SELECT_IPADDRESS        11039
#define IDC_LIST_IPADDRESSES            11049
#define IDC_IPA_IPADDRESS               11107

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        10134
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         10112
#define _APS_NEXT_SYMED_VALUE           10101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\w3key\mdserv.h ===
// header for the metadata Service object

// metabase paths
#define	SZ_META_BASE		"/LM/W3Svc"
#define	SZ_META_KEYBASE		"/SSLKeys"


//--------------------------------------------------------
class CMDKeyService : public CService
	{
	public:
		CMDKeyService();
		~CMDKeyService();

		// set the machine name into place
		void SetMachineName( WCHAR* pszw );

		// store and load the keys - all the keys
		virtual void LoadKeys( CMachine* pMachine );
		virtual BOOL FCommitChangesNow();

		// create a new key.
		virtual CKey* PNewKey() {return (CKey*)new CMDKey(this);}

		// wide machine name
		WCHAR*		m_pszwMachineName;

		// helpful utilities for scanning the
		// keys contained by a service object
		CMDKey* GetFirstMDKey()
			{ return (CMDKey*)GetFirstChild(); }
		CMDKey* GetNextMDKey( CMDKey* pKey )
			{ return (CMDKey*)GetNextChild(pKey); }

        // test to see if a key on the service has a particular binding
        BOOL FIsBindingInUse( CString szBinding );

	private:
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\w3key\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	W3Key.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\w3key\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#undef ASSERT

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions

#ifndef _AFX_NO_OLE_SUPPORT
#include <afxole.h>         // MFC OLE classes
#include <afxodlgs.h>       // MFC OLE dialog classes
#include <afxdisp.h>        // MFC OLE automation classes
#endif // _AFX_NO_OLE_SUPPORT


#ifndef _AFX_NO_DB_SUPPORT
#include <afxdb.h>			// MFC ODBC database classes
#endif // _AFX_NO_DB_SUPPORT

#ifndef _AFX_NO_DAO_SUPPORT
#include <afxdao.h>			// MFC DAO database classes
#endif // _AFX_NO_DAO_SUPPORT

#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows 95 Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <afxcview.h>
#include <afxtempl.h>

#include <winnls.h>

extern "C"
	{
	#include <ntsam.h>
	#include <ntlsa.h>
	#include <lm.h>
	#include <lmerr.h>
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\w3key\w3key.cpp ===
#include "stdafx.h"
#include "KeyObjs.h"

#include "CmnKey.h"
#include "W3Key.h"
#include "W3Serv.h"

#include "resource.h"

#include "kmlsa.h"

#include "CnctDlg.h"


extern HINSTANCE    g_hInstance;


// defines taken from the old KeyGen utility
#define MESSAGE_HEADER  "-----BEGIN NEW CERTIFICATE REQUEST-----\r\n"
#define MESSAGE_TRAILER "-----END NEW CERTIFICATE REQUEST-----\r\n"
#define MIME_TYPE       "Content-Type: application/x-pkcs10\r\n"
#define MIME_ENCODING   "Content-Transfer-Encoding: base64\r\n\r\n"


IMPLEMENT_DYNCREATE(CW3Key, CKey);

CW3Key::CW3Key() :
        m_fDefault(FALSE)
    {
    }


CW3Key::~CW3Key()
    {
    }

//-------------------------------------------------------------
// update the key's caption
void CW3Key::UpdateCaption( void )
    {
    // specify the resources to use
    HINSTANCE hOldRes = AfxGetResourceHandle();
    AfxSetResourceHandle( g_hInstance );

    // the caption is based on the name of the key
    CString szCaption = m_szName;

    // if the key is not attached at all, do not put the brackets on at all
    if ( m_fDefault || !m_szIPAddress.IsEmpty() )
        {
        // now we take on info about the server it is attached to
        szCaption += _T(" <");
        if ( m_fDefault )
            {
            CString szDefault;
            szDefault.LoadString( IDS_DEFAULT );
            szCaption += szDefault;
            }
        else
            {
            szCaption += m_szIPAddress;
            }
        szCaption += _T(">");
        }

    // and setup the caption
    m_szItemName = szCaption;
    FSetCaption(szCaption);

    // update the icon too
    UpdateIcon();

    // restore the resources
    AfxSetResourceHandle( hOldRes );
    }

//-------------------------------------------------------------
// init from keyset key
//-------------------------------------------------------------
BOOL CW3Key::FInitKey( HANDLE hPolicy, PWCHAR pwszName )
    {
    ASSERT( hPolicy && pwszName );

    // set the initial strings
    m_szName.LoadString( IDS_UNTITLED );

    // import the w3 key information
    if ( !ImportW3Key(hPolicy, pwszName) )
        return FALSE;

    // bring over the sz_ipaddress for the key
    m_szIPAddress = pwszName;

    // if it is the default key, flip the flag
    if ( m_szIPAddress == _T("Default") )
        {
        m_fDefault = TRUE;
        m_szIPAddress.Empty();
        }

    // build the caption name
    UpdateCaption();

    return TRUE;
    }

//-------------------------------------------------------------
// init from stored keyset key
//-------------------------------------------------------------
BOOL CW3Key::FInitKey( PVOID pData, DWORD cbSrc)
    {
    ASSERT( pData );

    // init from the data
    if ( !InitializeFromPointer( (PUCHAR)pData, cbSrc ) )
        return FALSE;

    // build the caption name
    UpdateCaption();

    return TRUE;
    }

//-------------------------------------------------------------
        // make a copy of the key
//-------------------------------------------------------------
CKey* CW3Key::PClone( void )
    {
    CW3Key* pClone = NULL;

    // TRY to make a new key object
    try
        {
        pClone = new CW3Key;

        // copy over all the data
        pClone->CopyDataFrom( this );
        }
    catch( CException e )
        {
        // if the object had been made, delete it
        if ( pClone )
            delete pClone;
        return NULL;
        }

    return (CKey*)pClone;
    }

//-------------------------------------------------------------
// copy the members from a key into this key
//-------------------------------------------------------------
void CW3Key::CopyDataFrom( CKey* pKey )
    {
    // copy over the base data
    CKey::CopyDataFrom( pKey );

    // if the key we are copying from is a W3 key, copy over
    // the w3 specific information as well
    if ( pKey->IsKindOf(RUNTIME_CLASS(CW3Key)) )
        {
        CW3Key* pW3Key = (CW3Key*)pKey;
        m_szName = pW3Key->m_szName;
        }
    else
        {
        m_szName = pKey->m_szItemName;
        }

    // we do NOT copy over the default-type settings
    m_fDefault = FALSE;
    m_szName.Empty();
    }


//-------------------------------------------------------------
void CW3Key::OnProperties()
    {
    // specify the resources to use
    HINSTANCE hOldRes = AfxGetResourceHandle();
    AfxSetResourceHandle( g_hInstance );

    // the properties of the w3 key invove its ip address relationship
    CConnectionDlg  dlg;

    // set the instance members of the dialog

    dlg.m_int_connection_type = CONNECTION_NONE;
    if ( m_fDefault )
        dlg.m_int_connection_type = CONNECTION_DEFAULT;
    if ( !m_szIPAddress.IsEmpty() )
        dlg.m_int_connection_type = CONNECTION_IPADDRESS;

    dlg.m_szIPAddress = m_szIPAddress;
    dlg.m_pKey = this;

    // run the dialog
    if ( dlg.DoModal() == IDOK )
        {
        // get the ip address
        m_szIPAddress = dlg.m_szIPAddress;

        // get whether or not this is the default and set it
        if ( dlg.m_int_connection_type == CONNECTION_DEFAULT )
            SetDefault();
        else
            m_fDefault = FALSE;
        
        // cause the name to rebuild
        UpdateCaption();

        // set it dirty
        SetDirty( TRUE );
        }

    // restore the resources
    AfxSetResourceHandle( hOldRes );
    }




//-------------------------------------------------------------
// install a cert - mostly just use the default action
BOOL CW3Key::FInstallCertificate( PVOID pCert, DWORD cbCert, CString &szPass )
    {
    // first, we should test that the certificate and password are valid
    // for this particular key
    // cache the old certificate in case the new one fails
    DWORD   old_cbCertificate = m_cbCertificate;
    PVOID   old_pCertificate = m_pCertificate;

    // set the new one into place
    m_cbCertificate = cbCert;
    m_pCertificate = pCert;

    // verify the password - verify password puts up any error dialogs
    if ( !FVerifyValidPassword(szPass) )
        {
        // resore the old values
        m_cbCertificate = old_cbCertificate;
        m_pCertificate = old_pCertificate;

        // dispose of the new stuff
        GlobalFree( pCert );

        // return false
        return FALSE;
        }

    // run the default action
    BOOL    fDefault = CKey::FInstallCertificate(pCert, cbCert, szPass);

    // if the default works, then take into account the ip releationship
    if ( fDefault )
        {
        // get the owning service object
        CW3KeyService*  pService = (CW3KeyService*)PGetParent();

        // if this key is not set to any ip addresses or the default, check to
        // see if there is a default on this service. If there isn't, then set
        // this key to be the default.
        if ( pService && !m_fDefault && m_szIPAddress.IsEmpty() )
            {

            // get the service's default key
            CW3Key* pKeyDefault = pService->PGetDefaultKey();

            // if there is no default key, then this is easy, just set the default flag
            if ( !pKeyDefault )
                m_fDefault = TRUE;
            else
                // tell the user to select a connection option
                AfxMessageBox( IDS_SelectConnectMsg, MB_OK|MB_ICONINFORMATION );

            // cause the name to rebuild
            UpdateCaption();
            }
        }

    // return the default answer
    return fDefault;
    }

//-------------------------------------------------------------
void CW3Key::SetDefault()
    {
    // get the owning service object
    CW3KeyService*  pService = (CW3KeyService*)PGetParent();

    // get the service's default key
    CW3Key* pKeyDefault = pService->PGetDefaultKey();

    // we only need to bother if there is a default key
    if ( pKeyDefault )
        {
        // change the old default key from default to none and update its caption
        pKeyDefault->m_fDefault = FALSE;
        pKeyDefault->UpdateCaption();
        }

    // set the default flag
    m_fDefault = TRUE;
    }


//================ storage related methods

//------------------------------------------------------------------------------
BOOL    CW3Key::WriteKey( HANDLE hPolicy, WORD iKey, PWCHAR pwcharName )
    {
    HGLOBAL hKeyData;
    PVOID   pKeyData;
    SIZE_T  cbKeyData;

    BOOL    f = TRUE;
    DWORD   err;

    // blank out the wide name of the string
    ASSERT( pwcharName );
    wcscpy( pwcharName, L"" );

    // now write out the normal part of the key
    PCHAR   pName = (PCHAR)GlobalAlloc( GPTR, MAX_PATH+1 );
    PWCHAR  pWName = (PWCHAR)GlobalAlloc( GPTR, (MAX_PATH+1) * sizeof(WCHAR) );

    // make sure we got the name buffers
    ASSERT( pName && pWName );
    if ( !pName || !pWName ) return FALSE;


    // if this key should write out W3 compatible keys, then do so
    if ( m_fDefault || !m_szIPAddress.IsEmpty() )
        {
        // if it is the default key, then the name is really easy
        if ( m_fDefault )
            {
            f = WriteW3Keys( hPolicy, KEYSET_DEFAULT );
            wcscpy( pwcharName, KEYSET_DEFAULT );
            }
        else
            {
            // prepare the name
            MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, m_szIPAddress, -1, pWName, MAX_PATH+1 );
            // write the keys
            f = WriteW3Keys( hPolicy, pWName );
            wcscpy( pwcharName, pWName );
            }
        }

        
    // get the data from the key
    hKeyData = HGenerateDataHandle( TRUE );
    if ( !hKeyData )
        {
        GlobalFree( (HGLOBAL)pName );
        GlobalFree( (HGLOBAL)pWName );
        return FALSE;
        }

    // prepare the name of the secret. - Base name plus the number+1
    sprintf( pName, "%s%d", KEY_NAME_BASE, iKey+1 );
    // unicodize the name
    MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, pName, -1, pWName, MAX_PATH+1 );

    // lock it down and get its size
    cbKeyData = GlobalSize(hKeyData);
    pKeyData = GlobalLock(hKeyData);

    ASSERT( cbKeyData < 0xFFFF );

    // write out the secret
    f &= FStoreLSASecret( hPolicy, pWName, pKeyData, (WORD)cbKeyData, &err );

    // unlock the data and get rid of it
    GlobalUnlock(hKeyData);
    GlobalFree( hKeyData );

    // free the string buffers
    GlobalFree( (HANDLE)pName );
    GlobalFree( (HANDLE)pWName );

    // set the dirty flag
    SetDirty( !f );

    // return success
    return f;
    }



//------------------------------------------------------------------------------
// If the key is being initialized from a keyset key, we must import the old W3 info
BOOL    CW3Key::ImportW3Key( HANDLE hPolicy, WCHAR* pWName )
    {
    DWORD   err;
    PWCHAR  pWSecret = (PWCHAR)GlobalAlloc( GPTR, (MAX_PATH+1) * sizeof(WCHAR) );

    PLSA_UNICODE_STRING pLSAData;

#ifdef _DEBUG
CString szName = pWName;
#endif

    // make sure we got the buffers
    ASSERT( pWName && pWSecret );
    if ( !pWSecret )
        {
        AfxThrowMemoryException();
        return FALSE;
        }


    // start by retrieving the private key
    swprintf( pWSecret, KEYSET_PRIV_KEY, pWName );
#ifdef _DEBUG
szName = pWSecret;
#endif
    pLSAData = FRetrieveLSASecret( hPolicy, pWSecret, &err );
    if ( !pLSAData )
        {
        AfxMessageBox( IDS_IMPORT_KEYSET_PRIV_ERROR );
        return FALSE;
        }

    // make room for the public key and put it in its place
    m_cbPrivateKey = pLSAData->Length;
    m_pPrivateKey = GlobalAlloc( GPTR, m_cbPrivateKey );
    if ( !m_pPrivateKey ) AfxThrowMemoryException();
    CopyMemory( m_pPrivateKey, pLSAData->Buffer, m_cbPrivateKey );

    // dispose of the data
    DisposeLSAData( pLSAData );


    // start by retrieving the public key (certificate)
    swprintf( pWSecret, KEYSET_PUB_KEY, pWName );
#ifdef _DEBUG
szName = pWSecret;
#endif
    pLSAData = FRetrieveLSASecret( hPolicy, pWSecret, &err );
    if ( !pLSAData )
        {
        AfxMessageBox( IDS_IMPORT_KEYSET_PUB_ERROR );
        return FALSE;
        }

    // make room for the public key and put it in its place
    m_cbCertificate = pLSAData->Length;
    m_pCertificate = GlobalAlloc( GPTR, m_cbCertificate );
    if ( !m_pCertificate ) AfxThrowMemoryException();
    CopyMemory( m_pCertificate, pLSAData->Buffer, m_cbCertificate );

    // dispose of the data
    DisposeLSAData( pLSAData );


    // lastly, get the password
    swprintf( pWSecret, KEYSET_PASSWORD, pWName );
#ifdef _DEBUG
szName = pWSecret;
#endif
    pLSAData = FRetrieveLSASecret( hPolicy, pWSecret, &err );
    if ( !pLSAData )
        {
        AfxMessageBox( IDS_IMPORT_KEYSET_PASS_ERROR );
        return FALSE;
        }

    // this is actually really easy because CString does the work for us
    // this is NOT stored as UNICODE!!!!
    m_szPassword = (PSTR)pLSAData->Buffer;

    // dispose of the data
    DisposeLSAData( pLSAData );

    // free the buffer for the secret names
    if ( pWSecret )
        GlobalFree( pWSecret );

    // return success
    return TRUE;
    }

//------------------------------------------------------------------------------
// write the important parts of the key out to the server as W3 readable secrets
// the name is put into the list elsewhere
BOOL    CW3Key::WriteW3Keys( HANDLE hPolicy, WCHAR* pWName )
    {
    DWORD   err;
    PWCHAR  pWSecret = (PWCHAR)GlobalAlloc( GPTR, (MAX_PATH+1) * sizeof(WCHAR) );
    BOOL    f;

    // make sure we got the buffer
    ASSERT( pWName && pWSecret );
    if ( !pWSecret )
        {
        AfxThrowMemoryException();
        return FALSE;
        }

    // write out the keys
    swprintf( pWSecret, KEYSET_PRIV_KEY, pWName );
    ASSERT( m_cbPrivateKey < 0xFFFF );
    ASSERT( m_pPrivateKey );
    f = FStoreLSASecret( hPolicy, pWSecret, m_pPrivateKey, (WORD)m_cbPrivateKey, &err );

    swprintf( pWSecret, KEYSET_PUB_KEY, pWName );
    ASSERT( m_cbCertificate < 0xFFFF );
    ASSERT( m_pCertificate );
    if ( f )
        f = FStoreLSASecret( hPolicy, pWSecret, m_pCertificate, (WORD)m_cbCertificate, &err );


    // The password is NOT stored as UNICODE!!!!!!!
    swprintf( pWSecret, KEYSET_PASSWORD, pWName );
    ASSERT( m_szPassword );
    if ( f )
        f = FStoreLSASecret( hPolicy, pWSecret, (void*)LPCSTR(m_szPassword),
                        m_szPassword.GetLength()+1, &err );

    // free the buffer for the secret names
    GlobalFree( (HANDLE)pWSecret );

    // return whether or not we succeeded
    return f;
    }

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\w3key\w3key.h ===
enum
	{
	KEY_EXPIRE_STATUS_INVALIDKEY = 0,
	KEY_EXPIRE_STATUS_OK,
	KEY_EXPIRE_STATUS_EXIRES_SOON,
	KEY_EXPIRE_STATUS_EXPIRED
	};

// forward declare the service class
class CW3KeyService;

//-------------------------------------------------------------
// This is the key object
class CW3Key : public CCmnKey
	{
	public:
		CW3Key();
		~CW3Key();

		void UpdateCaption( void );

		// init from keyset key
		BOOL	FInitKey( HANDLE hPolicy, PWCHAR pwszName );
		// init from stored keyset key
		BOOL	FInitKey( PVOID pData, DWORD cbSrc );

		// copy the members from a key into this key
		virtual void CopyDataFrom( CKey* pKey );
		// make a copy of the key
		virtual CKey*	PClone( void );

		BOOL	FIsDefault( void )
			{ return m_fDefault; }
		void	SetDefault();

		void OnProperties();
		
		// generate a handle containing data that gets stored and then is used to restore
		// the key object at a later date. Restore this key by passing this dereferenced
		// handle back into the FInitKey routine above.
		HANDLE	HGenerateDataHandle( BOOL fIncludePassword );
		BOOL	InitializeFromPointer( PUCHAR pSrc, DWORD cbSrc );

		// install a cert
		BOOL FInstallCertificate( PVOID pCert, DWORD cbCert, CString &szPass );

		// The key dirty routine actually just calls the host machine's dirty routine
//		BOOL FSetDirty( void );

		// save this key out as a set of secrets
		BOOL WriteKey( HANDLE hPolicy, WORD iKey, PWCHAR pwcharName );
		BOOL WriteW3Keys( HANDLE hPolicy, WCHAR* pWName );
		BOOL ImportW3Key( HANDLE hPolicy, WCHAR* pWName );
	
		// data used to maintain links to servers
		BOOL		m_fDefault;
		CString		m_szIPAddress;

	protected:
		// DO declare all this DYNCREATE
		DECLARE_DYNCREATE(CW3Key);

	private:
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\w3key\w3addon.cpp ===
// W3Key.cpp : Defines the initialization routines for the DLL.
//

#include "stdafx.h"
#include "resource.h"
#include <afxdllx.h>

#include "KeyObjs.h"
#include "wrapmb.h"

#include "CmnKey.h"
#include "W3Key.h"
#include "W3Serv.h"

#include "MDKey.h"
#include "MDServ.h"

#include "kmlsa.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

static AFX_EXTENSION_MODULE W3KeyDLL = { NULL, NULL };


// the tree control
CTreeCtrl*  g_pTreeCtrl = NULL;
// the service image index
int         g_iServiceImage = 0;
BOOL        fInitialized = FALSE;
BOOL        fInitMetaWrapper = FALSE;

HINSTANCE   g_hInstance = NULL;

void LoadServiceIcon( CTreeCtrl* pTree );


extern "C" int APIENTRY
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        TRACE0("W3KEY.DLL Initializing!\n");

        // save the instance
        g_hInstance = hInstance;
        
        // Extension DLL one-time initialization
        AfxInitExtensionModule(W3KeyDLL, hInstance);

        // one-time initialization of ip address window
        //IPAddrInit( hInstance );
        //
        // Changed to using common control - RonaldM
        //
        INITCOMMONCONTROLSEX icex;
        icex.dwSize = sizeof(icex);
        icex.dwICC = ICC_INTERNET_CLASSES;
        InitCommonControlsEx(&icex);
        //
        // End of RonaldM changes
        //

        // Insert this DLL into the resource chain
        new CDynLinkLibrary(W3KeyDLL);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        TRACE0("W3KEY.DLL Terminating!\n");
        if ( fInitMetaWrapper )
            FCloseMetabaseWrapper();
        if ( fInitialized )
            CoUninitialize();
    }
    return 1;   // ok
}

//=======================================================
// the main routine called by the keyring application

BOOL  _cdecl LoadService( CMachine* pMachine )
    {
    BOOL    fAnswer = FALSE;
    HRESULT hRes;

    // initialize the ole stuff if necessary
    if ( !fInitialized )
        {
//DebugBreak();
        hRes = CoInitialize( NULL );
        }

    ASSERT( pMachine );
    if ( !pMachine ) return FALSE;


    // specify the resources to use
    HINSTANCE hOldRes = AfxGetResourceHandle();
    AfxSetResourceHandle( g_hInstance );

    // if this is the first time through, initialize the tree control stuff
    if ( !g_pTreeCtrl )
        {
        // get the tree control
        g_pTreeCtrl = pMachine->PGetTreeCtrl();
        ASSERT( g_pTreeCtrl );

        // since we are adding a service icon, we need to do that now too
        LoadServiceIcon( g_pTreeCtrl );
        }

    // see if we can access this machine

    // get the wide name of the machine we intend to target
    CString     szName;
    DWORD   err;
    pMachine->GetMachineName( szName );
    // allocate the cache for the machine name
    WCHAR* pszwMachineName = new WCHAR[MAX_PATH];
    if ( !pszwMachineName ) return FALSE;
    // unicodize the name
    MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, szName, -1, pszwMachineName, MAX_PATH );


    // drat the local name for the metabase should be null, while it should be an empty string
    // for LSA. Make a temp metabase name as appropriate
    WCHAR* pszwMeta;
    if ( szName.IsEmpty() )
        pszwMeta = NULL;
    else
        pszwMeta = pszwMachineName;

    // first we see if we can access the metabase at the proscribed location.
    if ( FInitMetabaseWrapper(pszwMeta) )
        {
        fInitMetaWrapper = TRUE;

        // hey--- the ole interface is there. We can use the metabase
        // now the whole purpose here is to setup a service object on the
        // machine object. So, create the service object
        try {
            CMDKeyService* pKServ = new CMDKeyService;

            // it needs to know the target machine
            pKServ->SetMachineName( pszwMeta );

            // add it to the machine
            pKServ->FAddToTree( pMachine );

            // load the keys
            pKServ->LoadKeys( pMachine );
            }
        catch( CException e )
            {
            goto cleanup;
            }

        // now close the metabase again. We will open it when we need it
        FCloseMetabaseWrapper();

        // success!
        fAnswer = TRUE;
        }
    else
        {
        // try to open the LSA policy. if this fails, then there is no server on the
        // target machine - we return a false
        HANDLE hPolicy = HOpenLSAPolicy( pszwMachineName, &err );
        // if we did not get the policy, then fail
        if ( !hPolicy )
            goto cleanup;

        // we did get the policy, so close it
        FCloseLSAPolicy( hPolicy, &err );

        // now the whole purpose here is to setup a service object on the
        // machine object. So, create the service object
        try {
            CW3KeyService* pKServ = new CW3KeyService;

            // add it to the machine
            pKServ->FAddToTree( pMachine );

            // load the keys
            pKServ->LoadKeys( pMachine );
            }
        catch( CException e )
            {
            goto cleanup;
            }
        
        // success! - well, LSA success anyway
        fAnswer = TRUE;
        }

    // clean up
cleanup:
    delete pszwMachineName;

    // restore the resources
    AfxSetResourceHandle( hOldRes );

    // return successfully
    return fAnswer;
    }

//-------------------------------------------------------------------
void LoadServiceIcon( CTreeCtrl* pTree )
    {
    ASSERT( pTree );

    // get the image list from the tree
    CImageList* pImageList = pTree->GetImageList(TVSIL_NORMAL);
    ASSERT( pImageList );

    // load the service bitmap
    CBitmap bmpService;
    if ( !bmpService.LoadBitmap( IDB_SERVICE_BMP ) )
        {
        ASSERT( FALSE );
        return;
        }

    // connect the bitmap to the image list
    g_iServiceImage = pImageList->Add( &bmpService, 0x00FF00FF );
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\w3key\w3serv.cpp ===
#include "stdafx.h"
#include "KeyObjs.h"

#include "CmnKey.h"
#include "W3Key.h"
#include "W3Serv.h"

#include "resource.h"

#include "kmlsa.h"

// the service image index
extern int          g_iServiceImage;
extern HINSTANCE    g_hInstance;

//--------------------------------------------------------
CW3KeyService::CW3KeyService():
        m_pszwMachineName( NULL )
    {
    // set the icon id
    m_iImage = (WORD)g_iServiceImage;

    // load the service name
    m_szItemName.LoadString( IDS_SERV_NAME );
    }

//--------------------------------------------------------
CW3KeyService::~CW3KeyService()
    {
    // if the machine name has been cached, release it
    if ( m_pszwMachineName )
        {
        delete m_pszwMachineName;
        m_pszwMachineName = NULL;
        }
    }

//--------------------------------------------------------
void CW3KeyService::LoadKeys( CMachine* pMachine )
    {
    // specify the resources to use
    HINSTANCE hOldRes = AfxGetResourceHandle();
    AfxSetResourceHandle( g_hInstance );

    HANDLE  hPolicy;
    DWORD   err;

    // since we use the machine name several times, set it up only once
    if ( !m_pszwMachineName )
        {
        // get the normal name
        CString     szName;
        pMachine->GetMachineName( szName );

        // allocate the cache for the machine name
        m_pszwMachineName = new WCHAR[MAX_PATH];
        if ( !m_pszwMachineName ) goto cleanup;

        // unicodize the name
        MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, szName, -1, m_pszwMachineName, MAX_PATH );
        }

    // attempt to open an LSA policy on the target machine
    hPolicy = HOpenLSAPolicy( m_pszwMachineName, &err );
    // if we did not open a policy, fail
    if ( !hPolicy ) goto cleanup;

    // load the keys that were previously saved by key manager
    FRestoreNormalKeys( hPolicy );

    // load any keys that were created by keyset - not keymanager
    FLoadKeySetKeys( hPolicy );

    // close the policy
    FCloseLSAPolicy( hPolicy, &err );

    // restore the resources
cleanup:
    AfxSetResourceHandle( hOldRes );
    }


//----------------------------------------------------------------
CW3Key* CW3KeyService::PGetDefaultKey( void )
    {
    // get the first key
    CW3Key* pKey = GetFirstW3Key();

    // loop through the keys, looking for the default
    while( pKey )
        {
        // test the key
        if ( pKey->FIsDefault() )
            return pKey;

        // get the next key
        pKey = GetNextW3Key( pKey );
        }

    // we did not find the default key, return NULL
    return NULL;
    }

//----------------------------------------------------------------
// the plan to commit the machine takes place in several steps
// First we write out the current keys to the secrets.
    // The keys are written out using a structured naming sequense.
    // namely, Key1, Key2, Key3, etc...
    // After writing out all the keys, any keys that are still in the
    // secrets but are not current keys (i.e. they were deleted) are
    // removed from the secrets.
// Next, we build the mapping between the keys and the servers. This part
// is basically what KeySet did.
BOOL CW3KeyService::FCommitChangesNow( void )
    {
    HANDLE  hPolicy;
    DWORD   err;

    // if there is nothing to do, then do nothing
    if ( !m_fDirty )
        return TRUE;

    // this can take a few seconds, so set the hourglass cursor
    CWaitCursor waitcursor;

    // open a policy to the target machine
    hPolicy = HOpenLSAPolicy( m_pszwMachineName, &err );
    // make sure it worked
    if( !hPolicy )
        {
        WriteSecretMessageBox();
        return FALSE;
        }

    // commit the changes here
    if ( !DeleteAllW3Keys(hPolicy) )
        {
        FCloseLSAPolicy( hPolicy, &err );
        WriteSecretMessageBox();
        // even though we failed to delete all the old keys, write out the new
        // ones anyway.
        }

    // commit the changes here
    if ( !FWriteOutKeys(hPolicy) )
        {
        FCloseLSAPolicy( hPolicy, &err );
        WriteSecretMessageBox();
        return FALSE;
        }

    // record the new current number of keys in the registry
    // now if all the keys are deleted, the right number of
    // resources will be purged from the registry
    m_nNumKeysRead = GetChildCount();

    // close the policy
    FCloseLSAPolicy( hPolicy, &err );

    // clear the dirty flag
    SetDirty( FALSE );
    return TRUE;
    }

//----------------------------------------------------------------
void CW3KeyService::WriteSecretMessageBox( void )
    {
    CString     szMessage;

    // get the message string
    szMessage.LoadString( IDS_COMMIT_ERROR );

    // tack on the name of the server
    szMessage += m_szItemName;

    // tack on some punctuation
    szMessage += _T(".");

    AfxMessageBox( szMessage );
    }

//----------------------------------------------------------------
// looks for keys that were installed by keyset, not key manager. These
// keys only exist directly in w3 server form and are unnamed.
BOOL CW3KeyService::FLoadKeySetKeys( HANDLE hPolicy )
    {
    PLSA_UNICODE_STRING pLSAData;
    DWORD           err;
    BOOL            fFoundKeySetKeys = FALSE;

    // get the W3 server links data from the secrets database
    pLSAData = FRetrieveLSASecret( hPolicy, KEYSET_LIST, &err );

    // if we get lucky, there won't be any keys to test
    if ( !pLSAData ) return TRUE;

    // allocate the name buffer
    PWCHAR  pWName = (PWCHAR)GlobalAlloc( GPTR, (MAX_PATH+1) * sizeof(WCHAR) );
    ASSERT( pWName );
    if ( !pWName )
        {
        AfxThrowMemoryException();
        return FALSE;
        }

    
    // No such luck. Now we have to walk the list and delete all those secrets
    WCHAR*  pszAddress = (WCHAR*)(pLSAData->Buffer);
    WCHAR*  pchKeys;

    // loop the items in the list, deleting the associated items
    while( pchKeys = wcschr(pszAddress, L',') )
        {
        // ignore empty segments
        if ( *pszAddress != L',' )
            {
            *pchKeys = L'\0';
            
            // put the wide name into a cstring
            CString szTestAddress = pszAddress;

            // see if we need to check for the default key
            BOOL fCheckForDefault = (wcscmp(pszAddress, KEYSET_DEFAULT) == 0);

            // search the keys, looking for the one that matches this
            CW3Key* pKey = GetFirstW3Key();
            while( pKey )
                {
                // if it is the default key, check for that
                if ( fCheckForDefault )
                    {
                    if ( pKey->FIsDefault() )
                        {
                        // this is a keyman key
                        goto incrementKeyList;
                        }
                    }
                else
                    {
                    // otherwise, check the actual ip address
                    if ( pKey->m_szIPAddress == szTestAddress )
                        {
                        // this is a keyman key
                        goto incrementKeyList;
                        }
                    }

                // get the next key
                pKey = GetNextW3Key( pKey );
                }

            // if we get here, then we have found a keyset key
            fFoundKeySetKeys = TRUE;

            // create a new key
            pKey = new CW3Key;

            // initialize it from the wide address of the key
            if ( pKey->FInitKey( hPolicy, pszAddress ) )
                {
                // add the key to the service
                pKey->FAddToTree( this );

                // mark the machine object as dirty
                SetDirty( TRUE );
                }
            }
        
incrementKeyList:
        // increment the pointers
        pchKeys++;
        pszAddress = pchKeys;
        }

    // free the buffer for the names
    GlobalFree( (HANDLE)pWName );

    // delete the list key itself
    // free the list key itself
    if ( pLSAData )
        DisposeLSAData( pLSAData );

    // if we found any keyset keys, tell the user what to expect
    if ( fFoundKeySetKeys )
        AfxMessageBox( IDS_FOUND_KEYSET_KEYS, MB_OK|MB_ICONINFORMATION );

    return TRUE;
    }

//----------------------------------------------------------------
// similar to the routine "DeleteAll" in the KeySet utility

BOOL CW3KeyService::DeleteAllW3Keys( HANDLE hPolicy )
    {
    DWORD           err;
    PLSA_UNICODE_STRING pLSAData;

    // get the secret list of keys
    pLSAData = FRetrieveLSASecret( hPolicy, KEYSET_LIST, &err );

    // if we get lucky, there won't be any keys to get rid of
    if ( !pLSAData ) return TRUE;

    // allocate the name buffer
    PWCHAR  pWName = (PWCHAR)GlobalAlloc( GPTR, (MAX_PATH+1) * sizeof(WCHAR) );
    ASSERT( pWName );
    if ( !pWName )
        {
        AfxThrowMemoryException();
        return FALSE;
        }

    // No such luck. Now we have to walk the list and delete all those secrets
    WCHAR*  pszAddress = (WCHAR*)(pLSAData->Buffer);
    WCHAR*  pchKeys;

    // loop the items in the list, deleting the associated items
    while( pchKeys = wcschr(pszAddress, L',') )
        {
        // ignore empty segments
        if ( *pszAddress != L',' )
            {
            *pchKeys = L'\0';

            // Nuke the secrets, one at a time
            swprintf( pWName, KEYSET_PUB_KEY, pszAddress );
            FStoreLSASecret( hPolicy, pWName, NULL, 0, &err );

            swprintf( pWName, KEYSET_PRIV_KEY, pszAddress );
            FStoreLSASecret( hPolicy, pWName, NULL, 0, &err );

            swprintf( pWName, KEYSET_PASSWORD, pszAddress );
            FStoreLSASecret( hPolicy, pWName, NULL, 0, &err );
            }

        // increment the pointers
        pchKeys++;
        pszAddress = pchKeys;
        }

    // delete the list key itself
    FStoreLSASecret( hPolicy, KEYSET_LIST, NULL, 0, &err );

    // free the buffer for the names
    GlobalFree( (HANDLE)pWName );

    // free the info we originally retrieved from the secret
    if ( pLSAData )
        DisposeLSAData( pLSAData );

    // return success
    return TRUE;
    }


//----------------------------------------------------------------
// utiltiy to append data to an existing handle, thus growing it
BOOL    CW3KeyService::FExpandoHandle( HANDLE* ph, PVOID pData, DWORD cbData )
    {
    HANDLE  hNew;
    HANDLE  hOld = *ph;

    ASSERT( ph && *ph && pData && cbData );
    if ( !ph || !*ph ) return FALSE;
    if ( !pData || !cbData ) return TRUE;

    // calculate the new size of the handle
    SIZE_T cbSizeOld = GlobalSize( *ph );
    SIZE_T cbSizeNew = cbSizeOld + cbData;

    // allocate a new handle at the new size
    hNew = GlobalAlloc( GHND, cbSizeNew );
    // if it didn't work, throw
    if ( !hNew )
        {
        AfxThrowMemoryException();
        return FALSE;
        }

    // lock down the handles and copy over the existing data
    PCHAR pNew = (PCHAR)GlobalLock( hNew );

    // only copy over the old data if there is some
    if ( cbSizeOld > 0 )
        {
        PCHAR pOld = (PCHAR)GlobalLock( hOld );
        CopyMemory( pNew, pOld, cbSizeOld );
        GlobalUnlock( hOld );
        }

    // advance the new pointer and copy in the new data
    pNew += cbSizeOld;
    CopyMemory( pNew, pData, cbData );

    // unlock the new handle
    GlobalUnlock( hNew );

    // it did work, so set the handle
    *ph = hNew;

    // finally, dispose of the old handle
    GlobalFree( hOld );

    // return success
    return TRUE;
    }

//----------------------------------------------------------------
BOOL CW3KeyService::FWriteOutKeys( HANDLE hPolicy )
    {
    WORD    iKey;
    DWORD   err;
    HANDLE  hList = GlobalAlloc( GHND, 0 );
    LONG    cch;
    BOOL    fSomethingInList = FALSE;

    ASSERT( hPolicy );
    ASSERT( hList );
    if ( !hList )
        AfxThrowMemoryException();

    // get the buffer for the wide name
    PWCHAR  pWName = (PWCHAR)GlobalAlloc( GPTR, (MAX_PATH+1) * sizeof(WCHAR) );


    // for each key in the machine, write its data out to the secrets
    iKey = 0;
    CW3Key* pKey = GetFirstW3Key();
    while( pKey )
        {
        // tell the key to store itself
        if ( !pKey->WriteKey(hPolicy, iKey, pWName) )
            return FALSE;

        // if this key has a link, add it to the w3 links list
        cch = wcslen( pWName );
        if ( cch )
            {
            wcscat( pWName, L"," );
            cch++;
            FExpandoHandle( &hList, pWName, cch * sizeof(WCHAR) );  // terminates later
            fSomethingInList = TRUE;
            }

        // get the next key
        pKey = GetNextW3Key( pKey );
        iKey++;
        }

    // save the contents of the list as a secret
    if ( fSomethingInList )
        {
        WORD    word = 0;
        // terminate the list of named keys
        FExpandoHandle( &hList, &word, sizeof(WORD) );

        ASSERT( GlobalSize(hList) < 0xFFFF );
        PVOID   p = GlobalLock(hList);
        FStoreLSASecret( hPolicy, KEYSET_LIST, p, (WORD)GlobalSize(hList), &err );
        GlobalUnlock(hList);
        }

    // free the handle for the list
    GlobalFree( hList );
    hList = NULL;

    // once we get here we have already written out all our keys. However, the case could exist where
    // we now have fewer keys than we started with. This means that there are keys in the secrets database
    // that are no longer needed. If this is the case, get rid of them
    WORD numKeys = GetChildCount();
    if ( numKeys < m_nNumKeysRead )
        {
        PCHAR   pName = (PCHAR)GlobalAlloc( GPTR, MAX_PATH+1 );

        // make sure we got the name buffers
        ASSERT( pName && pWName );
        if ( pName && pWName )
            for ( iKey = numKeys; iKey < m_nNumKeysRead; iKey++ )
                {
                // prepare the name of the secret. - Base name plus the number+1
                sprintf( pName, "%s%d", KEY_NAME_BASE, iKey+1 );
                // unicodize the name
                MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, pName, -1, pWName, MAX_PATH+1 );

                // remove the secret
                FStoreLSASecret( hPolicy, pWName, NULL, 0, &err );
                }

        // free the string buffers
        GlobalFree( (HANDLE)pName );
        }

    // free the string buffers
    GlobalFree( (HANDLE)pWName );

    // return success
    return TRUE;
    }

//----------------------------------------------------------------
BOOL CW3KeyService::FRestoreNormalKeys( HANDLE hPolicy )
    {
    DWORD           iKey = 0;
    PCHAR           pName = (PCHAR)GlobalAlloc( GPTR, MAX_PATH+1 );
    PWCHAR          pWName = (PWCHAR)GlobalAlloc( GPTR, (MAX_PATH+1) * sizeof(WCHAR) );

    PLSA_UNICODE_STRING pLSAData;
    DWORD           err;

    // make sure we got the name buffers
    ASSERT( pName && pWName );
    if ( !pName || !pWName ) return FALSE;

    // clear the number of keys read (we haven't read any yet!)
    m_nNumKeysRead = 0;

    // load keys until we have loaded them all
    while(TRUE)
        {
        // increment the key counter
        iKey++;

        // build the key secret name
        sprintf( pName, "%s%d", KEY_NAME_BASE, iKey );
        // unicodize the name
        MultiByteToWideChar( CP_ACP, MB_PRECOMPOSED, pName, -1, pWName, MAX_PATH+1 );

        // get the secret
        pLSAData = FRetrieveLSASecret( hPolicy, pWName, &err );

        // if we didn't get anything, leave the loop
        if ( !pLSAData )
            break;

        // there is a key here, so count it
        m_nNumKeysRead++;

        // ah, but we did get something. Make a new key and add it to the key list
        CW3Key* pKey = new CW3Key;
        if ( pKey->FInitKey(pLSAData->Buffer, pLSAData->Length) )
            {
            pKey->FAddToTree( this );
            }
        else
            {
            // failed to init key
            delete pKey;
            }

        // dispose of the lsa buffer now that we have loaded from it
        if ( pLSAData )
            DisposeLSAData( pLSAData );
        pLSAData = NULL;
        }
    
    // free the buffers
    GlobalFree( (HANDLE)pName );
    GlobalFree( (HANDLE)pWName );
    if ( pLSAData )
        DisposeLSAData( pLSAData );

    return TRUE;
    }

//-------------------------------------------------------------
void    DisposeLSAData( PVOID pData )
    {
    PLSA_UNICODE_STRING pDataLSA = (PLSA_UNICODE_STRING)pData;
    if ( !pDataLSA || !pDataLSA->Buffer ) return;
    GlobalFree(pDataLSA);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\cfgmnt\cfgmnt.cpp ===
// CfgMnt.cpp : Implementation of WinMain


// Note: Proxy/Stub Information
//		To build a separate proxy/stub DLL, 
//		run nmake -f CfgMntps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "CfgMnt.h"

#include "CfgMnt_i.c"
#include "CfgMntAdmin.h"
#include "CfgMntVersions.h"

#include "CfgMntModule.h"

LONG CExeModule::Unlock()
{
	LONG l = CComModule::Unlock();
	if (l == 0)
	{
#if _WIN32_WINNT >= 0x0400
		if (CoSuspendClassObjects() == S_OK)
			PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
#else
		PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
#endif
	}
	return l;
}

CExeModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_CfgMntVersions, CCfgMntVersions)
	OBJECT_ENTRY(CLSID_CfgMntAdmin, CCfgMntAdmin)
END_OBJECT_MAP()


LPCTSTR FindOneOf(LPCTSTR p1, LPCTSTR p2)
{
	while (*p1 != NULL)
	{
		LPCTSTR p = p2;
		while (*p != NULL)
		{
			if (*p1 == *p++)
				return p1+1;
		}
		p1++;
	}
	return NULL;
}

/////////////////////////////////////////////////////////////////////////////
//
extern "C" int WINAPI _tWinMain(HINSTANCE hInstance, 
	HINSTANCE /*hPrevInstance*/, LPTSTR lpCmdLine, int /*nShowCmd*/)
{
	lpCmdLine = GetCommandLine(); //this line necessary for _ATL_MIN_CRT
//	HRESULT hRes = CoInitialize(NULL);
//  If you are running on NT 4.0 or higher you can use the following call
//	instead to make the EXE free threaded.
//  This means that calls come in on a random RPC thread
	HRESULT hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);
	_ASSERTE(SUCCEEDED(hRes));
	_Module.Init(ObjectMap, hInstance);
	_Module.dwThreadID = GetCurrentThreadId();
	TCHAR szTokens[] = _T("-/");

	int nRet = 0;
	BOOL bRun = TRUE;
	LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens);
	while (lpszToken != NULL)
	{
		if (lstrcmpi(lpszToken, _T("UnregServer"))==0)
		{
			_Module.UpdateRegistryFromResource(IDR_CfgMnt, FALSE);
			nRet = _Module.UnregisterServer();
			bRun = FALSE;
			break;
		}
		if (lstrcmpi(lpszToken, _T("RegServer"))==0)
		{
			_Module.UpdateRegistryFromResource(IDR_CfgMnt, TRUE);
			nRet = _Module.RegisterServer(TRUE);
			bRun = FALSE;
			break;
		}
		lpszToken = FindOneOf(lpszToken, szTokens);
	}

	if (bRun)
	{
		hRes = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, 
			REGCLS_MULTIPLEUSE);
		_ASSERTE(SUCCEEDED(hRes));

////////////////////////////////////////////////////////////
		CCfgMntModule CfgMntModule;
////////////////////////////////////////////////////////////

		MSG msg;
		while (GetMessage(&msg, 0, 0, 0))
			DispatchMessage(&msg);

		_Module.RevokeClassObjects();
	}

	_Module.Term();
	CoUninitialize();
	return nRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\ui\itools\w3key\w3serv.h ===
// header for the W3Service object

#define KEYSET_LIST				L"W3_KEY_LIST"
#define KEYSET_PUB_KEY			L"W3_PUBLIC_KEY_%s"
#define KEYSET_PRIV_KEY			L"W3_PRIVATE_KEY_%s"
#define KEYSET_PASSWORD			L"W3_KEY_PASSWORD_%s"
#define KEYSET_DEFAULT			L"Default"

#define	KEY_NAME_BASE			"W3_KEYMAN_KEY_"
#define	KEY_LINKS_SECRET_W		L"W3_KEYMAN_LINKS"
#define	KEYMAN_LINK_DEFAULT		"DEFAULT"

void	DisposeLSAData( PVOID pData );

//--------------------------------------------------------
class CW3KeyService : public CService
	{
	public:
		CW3KeyService();
		~CW3KeyService();
		void LoadKeys( CMachine* pMachine );
		BOOL FCommitChangesNow();

		// create a new key.
		CKey* PNewKey() {return (CKey*)new CW3Key;}

		// get the key on this machine that is set to be the default key
		CW3Key* PGetDefaultKey( void );

		// cached wide machine name
		WCHAR*		m_pszwMachineName;

	protected:
		// initialize basic stuff from machine - must be called from sub-class
		BOOL FInitMachine( void );

		// restore all the keys that are stored on the target machine
		BOOL FRestoreNormalKeys( HANDLE hPolicy );

		// restore a key that was generated by keyset
		BOOL FLoadKeySetKeys( HANDLE hPolicy );

		// store out all the keys to the target machine
		BOOL FWriteOutKeys( HANDLE hPolicy );

		// delete existing keys that the W3 server references (keyset style keys)
		BOOL DeleteAllW3Keys( HANDLE hPolicy );

		// a smarter secret write error box
		void WriteSecretMessageBox( void );

		// helpful utilities for scanning the
		// keys contained by a service object
		CW3Key* GetFirstW3Key()
			{ return (CW3Key*)GetFirstChild(); }
		CW3Key* GetNextW3Key( CW3Key* pKey )
			{ return (CW3Key*)GetNextChild(pKey); }

	private:
		// number of keys READ from the normal secrets
		long	m_nNumKeysRead;

		BOOL	FExpandoHandle( HANDLE* ph, PVOID pData, DWORD cbData );
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\cfgmnt\autoptr.h ===
// AutoPtr.h: interface for the CAutoPtr class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_AUTOPTR_H__82D00BEB_039E_11D1_A436_00C04FB99B01__INCLUDED_)
#define AFX_AUTOPTR_H__82D00BEB_039E_11D1_A436_00C04FB99B01__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

template <class T>
class CAutoPtr  
{
public:
	CAutoPtr() { m_p = NULL; };
	CAutoPtr(T* p) { m_p = p; };
	CAutoPtr(const CAutoPtr<T>& p) { m_p = p.m_p; };
	virtual ~CAutoPtr() 
		{
			if(m_p)
				delete m_p;
			m_p = NULL;
		};
	operator T*() { return (T*) m_p; };
	T& operator*() 
		{ 
			_ASSERTE(m_p != NULL);	
			return *p;				,
		};							
	// the assert on operator& usually indicates
	// a bug. If this is really what is needed, however
	// take the address of the member m_p explicitly.
	T** operator&() { _ASSERTE(m_p == NULL); return &m_p; };
	T* operator->() { _ASSERTE(m_p != NULL); return m_p; };
	T* operator=(T* p) { return m_p = p; };
	T* operator=(const CAutoPtr<T>& p) { return m_p = p.m_p; };
#if _MSC_VER>1020
	bool operator!(){return (m_p == NULL);}
#else
	BOOL operator!(){return (m_p == NULL) ? TRUE : FALSE;}
#endif
	T* m_p;
};

#endif // !defined(AFX_AUTOPTR_H__82D00BEB_039E_11D1_A436_00C04FB99B01__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\cfgmnt\cfgmntadmin.h ===
// CfgMntAdmin.h : Declaration of the CCfgMntAdmin

#ifndef __CFGMNTADMIN_H_
#define __CFGMNTADMIN_H_

#include "resource.h"       // main symbols
#include "VerEngine.h"
#include "CfgMntModule.h"

/////////////////////////////////////////////////////////////////////////////
// CCfgMntAdmin
class ATL_NO_VTABLE CCfgMntAdmin : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CCfgMntAdmin, &CLSID_CfgMntAdmin>,
	public IDispatchImpl<ICfgMntAdmin, &IID_ICfgMntAdmin, &LIBID_CFGMNTLib>
{
public:
	CCfgMntAdmin()
	{
		_ASSERTE(g_pCfgMntModule);
		m_pVerEngine = &g_pCfgMntModule->m_VerEngine;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_CFGMNTADMIN)

BEGIN_COM_MAP(CCfgMntAdmin)
	COM_INTERFACE_ENTRY(ICfgMntAdmin)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// ICfgMntAdmin
public:
	STDMETHOD(ShutDown)();
	STDMETHOD(Rollback)(/*[in]*/BSTR bstrMDPath,/*[in]*/BSTR bstrDateTime);
	STDMETHOD(GetVersions)(/*[in]*/BSTR bstrMDPath, /*[out,retval]*/IUnknown **hICfgMntVersions);
	STDMETHOD(GetHistory)(/*[in]*/BSTR bstrMDPath);
private:
	CVerEngine * m_pVerEngine;
};

#endif //__CFGMNTADMIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\certutil\fortezza\fortutil\fortutil.cxx ===
/*++


   Copyright    (c)    1996    Microsoft Corporation

   Module  Name :

         fortutil.cxx

   Abstract:

        Utility used to migrate Fortezza certificates from the card to CAPI stores,
        and set the appropriate metabase settings for an instance

   Author:

       Alex Mallet (amallet) 30-April-1998

--*/

#define INITGUID

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}
#include <ole2.h>
#include <windows.h>
#include <stdio.h>
#define USE_CAPI2
#if defined(USE_CAPI2)
#include <wincrypt.h>
#endif

extern "C" {
#define SECURITY_WIN32
#include <sspi.h>
}
#include <spseal.h>
#include <issperr.h>
#include <schnlsp.h>

#include <iadmw.h>
#include <admex.h>
#include <iiscnfgp.h>
#include <mdcommsg.h>

#define RETURNCODETOHRESULT(rc)                             \
            (((rc) < 0x10000)                               \
                ? HRESULT_FROM_WIN32(rc)                    \
                : (rc))

#define MY_STORE_NAME   "MY"
#define CA_STORE_NAME   "CA"
#define ROOT_STORE_NAME "ROOT"
#define SHA1_HASH_SIZE 20
#define TIMEOUT_VALUE 30000 //magic number ...

#define MB_ROOT_PATH L"/LM/W3SVC"

//
// Metabase properties for Fortezza certificates
//
static DWORD adwMetabaseFortCertProperties[] = { MD_SSL_CERT_HASH, 
                                                 BINARY_METADATA,
                                                 MD_SSL_CERT_STORE_NAME, 
                                                 STRING_METADATA,
                                                 MD_SSL_CERT_IS_FORTEZZA, 
                                                 DWORD_METADATA,
                                                 MD_SSL_CERT_FORTEZZA_PIN, 
                                                 STRING_METADATA,
                                                 MD_SSL_CERT_FORTEZZA_SERIAL_NUMBER, 
                                                 STRING_METADATA,
                                                 MD_SSL_CERT_FORTEZZA_PERSONALITY, 
                                                 STRING_METADATA
};

#define cNumCertMetabaseProperties sizeof(adwMetabaseFortCertProperties)/sizeof(DWORD)

#define USAGE "Usage : %s -o:delete|create|check -i:<instance number #1> -n:PIN -s:<serial #> -p:<personality> [-?]"

#define REMOVE 1
#define CREATE 2
#define CHECK 4


//
// Internal declarations
//
HRESULT GetMetabasePointer( OUT IMSAdminBaseW **ppMetabase );

BOOL
CopyFortezzaChainToMachine( LPSTR pszSerialNumber,
                            LPSTR pszPersonality,
                            LPSTR pszPIN,
                            PCCERT_CONTEXT *ppServerCert,
                            HCRYPTPROV *phProv );


BOOL
WriteFortezzaMBProperties( IMSAdminBaseW *pMB,
                           METADATA_HANDLE hMDHandle,
                           PCCERT_CONTEXT pCertContext,
                           LPSTR pszSerialNumber,
                           LPSTR pszPIN,
                           LPSTR pszPersonality );

BOOL
RemoveFortezzaMBProperties( IMSAdminBaseW *pMB,
                            METADATA_HANDLE hMDHandle,
                            LPSTR pszPIN );


VOID
CheckFortezzaMBProperties( IMSAdminBaseW *pMB,
                           METADATA_HANDLE hMDHandle,
                           LPSTR pszPIN );

BOOL BuildFullPath( LPSTR pszSubPath,
                    LPWSTR *ppwszFullPath );

BOOL
IsCorrectPIN( IMSAdminBaseW *pMB,
              METADATA_HANDLE hMD,
              LPWSTR pszPIN,
              BOOL *pfCorrect );


BOOL
HasFortezzaCert( IMSAdminBaseW *pMB,
                 METADATA_HANDLE hMD,
                 BOOL *pfHasCert );


BOOL
IsCertRoot(PBYTE pbCert, DWORD cbCert);


BOOL ConstructCertChain( PCCERT_CONTEXT pcLeafCert,
                         LPSTR pszLeafCertStore,
                         PBOOL pfCompleteChain,
                         PBOOL pfTrustedChain );

BOOL ConvertToUnicode( IN LPSTR pszAsciiStr,
                       OUT LPWSTR *ppwszWideStr );

BOOL ConvertToAscii( IN LPWSTR pwszWideStr,
                     OUT LPSTR *ppszAsciiStr );

BOOL IsSelfSignedCert( IN PCCERT_CONTEXT pCertContext );

BOOL IsNumber( LPCSTR pszName );

int __cdecl main(int argc, char *argv[])
{
    HRESULT hRes = S_OK;
    IMSAdminBase *pMB = NULL;
    DWORD dwRet = 0;
    LPSTR pszInstance = NULL;
    LPSTR pszPIN = NULL;
    LPSTR pszPersonality = NULL;
    LPSTR pszSerialNumber = NULL;
    PCCERT_CONTEXT pServerCert = NULL;
    HCRYPTPROV hFortezzaCSP = NULL;
    DWORD dwAction = 0;
    INT i = 0;
    CHAR chOption = 0;
    LPSTR pszArg = NULL;
    LPWSTR pwszFullPath = NULL;
    METADATA_HANDLE hMDHandle = NULL;

    //
    // Parse argument list
    //

    for ( i = 1; i < argc; i++ )
    {
        //
        // Check for well-formed arguments; must all have a '-' or '/' as first
        // character and be at least 2 characters long
        //
        if ( (argv[i][0] != '-' && argv[i][0] != '/') ||
             ( strlen( argv[i] ) == 2 && argv[i][1] != '?' ) ||
             strlen( argv[i] ) < 3 )
        {
            printf( USAGE, argv[0] );
            exit(1);
        }

        //
        // Check for special case of "/?" and "-?" argument
        //
        if ( !strcmp( argv[i], "/?" ) ||
             !strcmp( argv[i], "-?" ) )
        {
            printf( USAGE, argv[0] );
            exit(0);
        }

        //
        // We know it's an argument of the form hyphen-letter-colon now
        //
        chOption = argv[i][1];
        pszArg = argv[i] + 3;

        switch ( chOption )
        {
        case 'o':
        case 'O':
            if ( !_stricmp( pszArg,"create") )
            {
                dwAction = CREATE;
            }
            else if ( !_stricmp( pszArg, "delete" ) )
            {
                dwAction = REMOVE;
            }
            else if ( !_stricmp( pszArg, "check" ) )
            {
                dwAction = CHECK;
            }
            else
            {
                printf( USAGE, argv[0] );
                goto cleanup;
            }
            break;

        case 'i':
        case 'I':
            pszInstance = pszArg;
            break;
           
        case 'n':
        case 'N':
            pszPIN = pszArg;
            break;
            
        case 's':
        case 'S':
            pszSerialNumber = pszArg;
            break;

        case 'p':
        case 'P':
            pszPersonality = pszArg;
            break;

        default:
            printf( USAGE, argv[0] );
            exit(1);
        }
           
    }

    //
    // Check to make sure we have all necessary data 
    //
    switch ( dwAction )
    {
    case CREATE:
        if ( !pszSerialNumber || !pszPersonality || !pszPIN )
        {
            printf("You must specify a PIN, Card Serial Number and Personality to attach a Fortezza certificate to the web server. \n");
            printf( USAGE, argv[0] );
            exit(1);
        }
        break;

    case REMOVE:
        if ( !pszPIN )
        {
            printf("You must specify the PIN for the Fortezza certificate you wish to remove. \n");
            printf( USAGE, argv[0] );
            exit(1);
        }
        break;

    case CHECK:
        if ( !pszPIN )
        {
            printf("You must specify the PIN for the Fortezza certificate you wish to examine. \n");
            printf( USAGE, argv[0] );
            exit(1);
        }
        break;
        
    default:
        printf( USAGE, argv[0] );
        exit(1);
    }

    hRes = CoInitializeEx( NULL, COINIT_MULTITHREADED );
    if( FAILED(hRes) )
    {
        printf( "Failed to initialize COM 0x%x\n", hRes );
        exit(1);
    }

    if ( SUCCEEDED( hRes = GetMetabasePointer( &pMB ) ) )
    {
        if ( BuildFullPath( pszInstance,
                            &pwszFullPath ) &&
             SUCCEEDED( hRes = pMB->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                                             pwszFullPath,
                                             METADATA_PERMISSION_WRITE | METADATA_PERMISSION_READ,
                                             TIMEOUT_VALUE,
                                             &hMDHandle ) ) )
        {
            switch ( dwAction )
            {
            case CREATE:

                //
                // Copy the certificates from the card to the CAPI stores
                //
                if ( !CopyFortezzaChainToMachine( pszSerialNumber,
                                                  pszPersonality,
                                                  pszPIN,
                                                  &pServerCert,
                                                  &hFortezzaCSP ) )
                {
                    printf("Failed to copy certificates from the Fortezza card to the CAPI stores on the machine, error 0x%x\n", GetLastError());
                    
                    goto cleanup;
                }

                //
                // Write the necessary data to the metabase
                // 
                if ( !WriteFortezzaMBProperties( pMB,
                                                 hMDHandle,
                                                 pServerCert,
                                                 pszSerialNumber,
                                                 pszPIN,
                                                 pszPersonality ) )
                {
                    printf("Failed to write Fortezza metabase properties, error 0x%x\n",
                           GetLastError());
                    
                    goto cleanup;
                    
                }

                printf("Successfully installed Fortezza certificate.\n");
                
                break;
            
            case REMOVE:
                
                if ( !RemoveFortezzaMBProperties( pMB,
                                                  hMDHandle,
                                                  pszPIN ) )
                {
                    printf("Failed to remove Fortezza certificate.\n");
                    goto cleanup;
                }
                else
                {
                    printf("Successfully removed Fortezza certificate.\n");
                }

            break;

            case CHECK:

                CheckFortezzaMBProperties( pMB,
                                           hMDHandle,
                                           pszPIN );

                break;

            default:
                printf( USAGE, argv[0] );
            }
        }
        else
        {
            if ( FAILED( hRes ) )
            {
                printf("Failed to open metabase : 0x%x\n",
                       HRESULTTOWIN32( hRes ) );
            }
        }
    }
    else
    {
        printf("Failed to obtain metabase access : 0x%x\n", HRESULTTOWIN32( hRes ) );
    }


cleanup:

    if ( pwszFullPath )
    {
        delete [] pwszFullPath;
    }
    
    if ( hMDHandle )
    {
        pMB->CloseKey( hMDHandle );
    }

    if ( pServerCert )
    {
        CertFreeCertificateContext( pServerCert );
    }
    
    if ( hFortezzaCSP )
    {
        CryptReleaseContext( hFortezzaCSP,
                             0 );
    }
                             
         
    if ( pMB )
    {
        pMB->Release();
    }

    CoUninitialize();

    return 0;
}




HRESULT GetMetabasePointer( OUT IMSAdminBaseW **ppMetabase )
/*++

Routine Description:

    Get a metabase interface pointer

Arguments:

    ppMetabase - pointer to pointer to metabase object, updated on success

Returns:

    HRESULT indicating success/failure.

--*/

{
    HRESULT hRes = S_OK;
    COSERVERINFO *pcsiParam = NULL;
    IClassFactory * pcsfFactory = NULL;

    //
    // Retrieve class factory for metabase object
    //
    hRes = CoGetClassObject(CLSID_MSAdminBase_W, CLSCTX_SERVER, pcsiParam,
                            IID_IClassFactory, ( void ** ) &pcsfFactory );

    if ( FAILED(hRes) )
    {
        printf("CoGetClassObject failed : hRes : %x, Win32 : 0x%x\n",
               hRes, HRESULTTOWIN32(hRes));
        return hRes;
    }

    //
    // Retrieve the actual metabase object interface
    //
    hRes = pcsfFactory->CreateInstance( NULL,
                                        IID_IMSAdminBase,
                                        (void **) ppMetabase );

    if ( FAILED(hRes) )
    {
        printf("CreateInstance failed : hRes : %x, Win32 : 0x%x\n",
               hRes, HRESULTTOWIN32(hRes));
        return hRes;
    }
    pcsfFactory->Release();

    return hRes;
}



BOOL
CopyFortezzaChainToMachine( IN LPSTR pszSerialNumber,
                            IN LPSTR pszPersonality,
                            IN LPSTR pszPIN,
                            OUT PCCERT_CONTEXT *ppServerCert,
                            OUT HCRYPTPROV *phProv )
/*++

Routine Description:

    Copies the certificates from the card to the CAPI stores on the machine.
    Ripped off from JBanes.

Arguments:

    pszSerialNumber - serial # of card
    pszPersonality - personality [ie certificate] to use as server cert
    pszPIN - PIN for card
    ppServerCert - pointer to pointer to server cert, updated on success
    phProv - pointer to handle to Fortezza CSP, updated on success

Returns:

    BOOL indicating success/failure

--*/

{
    HCRYPTPROV  hProv = 0;
    HCERTSTORE  hMyStore = 0;
    HCERTSTORE  hCaStore = 0;
    HCERTSTORE  hRootStore = 0;
    CRYPT_KEY_PROV_INFO KeyProvInfo;
    PCCERT_CONTEXT pCertContext = NULL;
    PBYTE   pbChain = NULL;
    DWORD   cbChain;
    PBYTE   pbCert = NULL;
    DWORD   cbCert;
    PWSTR   pwszPersonality = NULL;
    PSTR    pszProvider = NULL;
    DWORD   cbProvider;
    PWSTR   pwszProvider = NULL;
    DWORD   cchProvider;
    BOOL    fLeafCert;
    BOOL    fSucceeded = FALSE;
    LPSTR pszCSPString = NULL;
    CERT_ENHKEY_USAGE KeyUsage; 
    DWORD cbPIN = strlen( pszPIN );
    DWORD cbSerialNumber = strlen( pszSerialNumber );
    DWORD cbPersonality = strlen( pszPersonality );
    DWORD cbLen = cbPIN + cbSerialNumber + cbPersonality + 10; //add some slop

    DWORD   dwStoreFlags = CERT_SYSTEM_STORE_LOCAL_MACHINE;

    PSTR rgpszUsageIdentifier[] = { szOID_PKIX_KP_SERVER_AUTH,
                                    szOID_PKIX_KP_CLIENT_AUTH,
                                    szOID_PKIX_KP_EMAIL_PROTECTION
    };
    DWORD cUsageIdentifier = sizeof(rgpszUsageIdentifier)/sizeof(PSTR);


    //
    // Make sure the string with the PIN is allocated in non-pageable memory so the
    // PIN doesn't show up in the page file
    //
    pszCSPString = new CHAR[cbLen];

    if ( !pszCSPString )
    {
        printf("Failed to allocate memory\n");
        return E_FAIL;
    }

    //
    // Build the magic string that will unlock the Fortezza secret ...
    //
    strcpy( pszCSPString, pszSerialNumber );
    strcat( pszCSPString, "\n" );
    strcat( pszCSPString, pszPersonality );
    strcat( pszCSPString, "\n" );
    strcat( pszCSPString, pszPIN );
            

    //
    // Get handle to CSP
    //
    if( !CryptAcquireContext(&hProv, 
                             pszCSPString,
                             NULL, 
                             PROV_FORTEZZA, 
                             CRYPT_SILENT ) )
    {
        printf("**** Error 0x%x returned by CryptAcquireContext\n", 
               GetLastError());
        goto done;
    }

    //
    // Don't leave the info lying around
    //
    memset( pszCSPString, 0, strlen( pszCSPString ) );
    delete [] pszCSPString;
    pszCSPString = NULL;

    //
    // Open certificate stores
    //
    hMyStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_A,
                              0,
                              (HCRYPTPROV) NULL,
                              dwStoreFlags,
                              MY_STORE_NAME );

    if(hMyStore == NULL)
    {
        printf("**** Error 0x%x opening MY store\n", GetLastError());
        goto done;
    }

    hCaStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_A,
                              0,
                              (HCRYPTPROV) NULL,
                              dwStoreFlags,
                              CA_STORE_NAME );
    if(hCaStore == NULL)
    {
        printf("**** Error 0x%x opening CA store\n", GetLastError());
        goto done;
    }

    hRootStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_A,
                                0,
                                (HCRYPTPROV) NULL,
                                dwStoreFlags,
                                ROOT_STORE_NAME );

    if (hRootStore == NULL)
    {
        printf("**** Error 0x%x opening ROOT store\n", GetLastError());
        goto done;
    }


    //
    // Convert container name to unicode.
    //
    if ( !ConvertToUnicode( pszPersonality,
                            &pwszPersonality ) )
    {
        goto done;
    }

    //
    // Read provider name from CSP.
    //
    if( !CryptGetProvParam( hProv, 
                            PP_NAME,
                            NULL,
                            &cbProvider,
                            0 ) )
    {
        printf("**** Error 0x%x reading provider name from CSP\n",
            GetLastError());
        goto done;
    }

    pszProvider = new CHAR[cbProvider];

    if( pszProvider == NULL )
    {
        printf("**** Out of memory\n");
        goto done;
    }

    if( !CryptGetProvParam( hProv, 
                            PP_NAME,
                            (UCHAR *) pszProvider,
                            &cbProvider,
                            0 ) )
    {
        printf("**** Error 0x%x reading provider name from CSP\n",
            GetLastError());
        goto done;
    }

    //
    // Convert provider name to unicode.
    //
    if ( !ConvertToUnicode( pszProvider,
                            &pwszProvider ) )
    { 
        goto done;
    }
   
    //
    // Get length of cert chain.
    //
    if( !CryptGetProvParam( hProv, 
                            PP_CERTCHAIN, 
                            NULL, 
                            &cbChain, 
                            0 ) )
    {
        printf("**** Error 0x%x reading cert chain from CSP\n",
            GetLastError());
        goto done;
    }

    //
    // Allocate memory for chain.
    //
    pbChain = new BYTE[cbChain];
    if( pbChain == NULL )
    {
        printf("**** Out of memory\n");
        goto done;
    }

    //
    // Download certificate chain from CSP.
    //
    if( !CryptGetProvParam( hProv, 
                            PP_CERTCHAIN, 
                            pbChain, 
                            &cbChain, 
                            0 ) )
    {
        printf("**** Error 0x%x reading cert chain from CSP\n",
            GetLastError());
        goto done;
    }


    //
    // Add each certificate in chain to store.
    //
    fLeafCert = TRUE;
    pbCert = pbChain;
    while( pbCert < pbChain + cbChain )
    {
        cbCert = *(PDWORD)pbCert;
        pbCert += sizeof(DWORD);

        if( pbCert + cbCert > pbChain + cbChain )
        {
            // Invalid certificate chain format!
            printf("**** Invalid cert chain format\n");
            goto done;
        }

        if( IsCertRoot( pbCert, 
                        cbCert ) )
        {
            if ( !CertAddEncodedCertificateToStore(hRootStore,
                                                   X509_ASN_ENCODING,
                                                   pbCert,
                                                   cbCert,
                                                   CERT_STORE_ADD_REPLACE_EXISTING,
                                                   NULL ) )
            {
                printf("**** Error 0x%x adding certificate to ROOT store\n",
                    GetLastError());
                goto done;
            }
        }
        else if( fLeafCert )
        {
            //
            // This is the actual server certificate; add certificate to MY store.
            //
            if( !CertAddEncodedCertificateToStore( hMyStore, 
                                                   X509_ASN_ENCODING,
                                                   pbCert,
                                                   cbCert,
                                                   CERT_STORE_ADD_REPLACE_EXISTING,
                                                   ppServerCert ) )
            {
                printf("**** Error 0x%x adding certificate to MY store\n",
                    GetLastError());
                goto done;
            }

            // Set the key provider info property.
            ZeroMemory(&KeyProvInfo, sizeof(KeyProvInfo));
            KeyProvInfo.pwszContainerName = pwszPersonality;
            KeyProvInfo.pwszProvName      = pwszProvider;
            KeyProvInfo.dwProvType        = PROV_FORTEZZA;
            KeyProvInfo.dwFlags           = 0;
            KeyProvInfo.dwKeySpec         = AT_KEYEXCHANGE;
           
            if( !CertSetCertificateContextProperty( *ppServerCert,
                                                    CERT_KEY_PROV_INFO_PROP_ID,
                                                    0,
                                                    &KeyProvInfo ) )
            {
                printf("**** Error 0x%x setting key provider info property\n",
                    GetLastError());
                goto done;
            }

            // Set the enhanced key usage property.
            KeyUsage.cUsageIdentifier = cUsageIdentifier;
            KeyUsage.rgpszUsageIdentifier = rgpszUsageIdentifier;

            if( !CertSetEnhancedKeyUsage( *ppServerCert,
                                          &KeyUsage ) )
            {
                printf("**** Error 0x%x setting enhanced key usage property\n",
                    GetLastError());
                goto done;
            }
        }
        else
        {
            //
            // Intermediate cert, add certificate to CA store.
            //
            if( !CertAddEncodedCertificateToStore( hCaStore, 
                                                   X509_ASN_ENCODING,
                                                   pbCert,
                                                   cbCert,
                                                   CERT_STORE_ADD_REPLACE_EXISTING,
                                                   NULL ) )
            {
                printf("**** Error 0x%x adding certificate to CA store\n",
                    GetLastError());
                goto done;
            }
        }
        
        fLeafCert = FALSE;
        pbCert += cbCert;
    }

    fSucceeded = TRUE;

done:

    if( hProv )
    {
        *phProv = hProv;
    }

    if ( pwszPersonality ) 
    {
        delete [] pwszPersonality; 
    }
       
    if ( pszProvider ) 
    {
        delete [] pszProvider;
    }

    if( pwszProvider ) 
    {
        delete [] pwszProvider;
    }

    if( pbChain ) 
    {
        delete [] pbChain;
    }

    if ( hMyStore ) 
    {
        CertCloseStore( hMyStore, 
                        0 );
    }

    if( hCaStore ) 
    {
        CertCloseStore( hCaStore, 
                        0 );
    }

    if( pCertContext ) 
    {
        CertFreeCertificateContext(pCertContext);
    }

    if ( pszCSPString )
    {
        delete [] pszCSPString;
    }

    return fSucceeded;
}

static 
BOOL
IsCertRoot(PBYTE pbCert, DWORD cbCert)
{
    PCCERT_CONTEXT pCertContext;

    // Decode certificate.
    pCertContext = CertCreateCertificateContext(X509_ASN_ENCODING,
                                                pbCert,
                                                cbCert);
    if(pCertContext == NULL)
    {
        printf("**** Error 0x%x decoding certificate\n", GetLastError());
        return FALSE;
    }

    // Compare subject and issuer.
    if(pCertContext->pCertInfo->Subject.cbData == pCertContext->pCertInfo->Issuer.cbData)
    {
        if(memcmp(pCertContext->pCertInfo->Subject.pbData,
                  pCertContext->pCertInfo->Issuer.pbData,  
                  pCertContext->pCertInfo->Issuer.cbData) == 0)
        {
            CertFreeCertificateContext(pCertContext);
            return TRUE;
        }
    }

    CertFreeCertificateContext(pCertContext);
    return FALSE;
}


BOOL
WriteFortezzaMBProperties( IN IMSAdminBaseW *pMB,
                           IN METADATA_HANDLE hMDHandle,
                           IN PCCERT_CONTEXT pServerCert,
                           IN LPSTR pszSerialNumber,
                           IN LPSTR pszPIN,
                           IN LPSTR pszPersonality )
/*++

Routine Description:

    Writes the necessary metabase properties for a Fortezza certificate. 

Arguments:

    pszInstance - server instance with which cert is to be associated; if NULL,
    assumes /W3SVC.
    pMB - metabase pointer
    pCertContext - server certificate
    pszSerialNumber - serial # of Fortezza card
    pszPIN - PIN for card
    pszPersonality - Fortezza "personality" to be used


Returns:

    BOOL indicating success/failure

--*/
{
    HRESULT hRes = S_OK;
    LPWSTR pwszSerialNumber = NULL;
    LPWSTR pwszPIN = NULL;
    LPWSTR pwszPersonality = NULL;
    BOOL fOK = FALSE;
    METADATA_RECORD mdr;
    BYTE rgbHash[SHA1_HASH_SIZE];
    DWORD cbHash = SHA1_HASH_SIZE;
    DWORD dwFortezza = 0;

    //
    // Metabase interface is Unicode, so convert all the strings to Unicdoe
    //
    if ( !ConvertToUnicode( pszSerialNumber,
                            &pwszSerialNumber ) ||
         !ConvertToUnicode( pszPIN,
                            &pwszPIN ) || 
         !ConvertToUnicode( pszPersonality,
                            &pwszPersonality ) )
    {
        goto cleanup2;
    }

    //
    // Write cert hash to MB
    //
    if ( !CertGetCertificateContextProperty( pServerCert,
                                             CERT_SHA1_HASH_PROP_ID,
                                             rgbHash,
                                             &cbHash ) )
    {
        printf("Couldn't retrieve hash of server certificate, error 0x%x\n",
               GetLastError());
        goto cleanup2;
    }

    
    MD_SET_DATA_RECORD( &mdr, 
                        MD_SSL_CERT_HASH,
                        METADATA_NO_ATTRIBUTES,
                        IIS_MD_UT_SERVER,
                        BINARY_METADATA,
                        cbHash,
                        rgbHash );
                        
                        
    if ( FAILED( hRes = pMB->SetData( hMDHandle,
                                      L"",
                                      &mdr ) ) )
    {
        printf("Failed to write certificate hash to metabase, error 0x%x\n",
               HRESULTTOWIN32( hRes ) );
        goto cleanup2;
    }

    //
    // Write store name to MB
    //
    MD_SET_DATA_RECORD( &mdr,
                        MD_SSL_CERT_STORE_NAME,
                        METADATA_NO_ATTRIBUTES,
                        IIS_MD_UT_SERVER,
                        STRING_METADATA,
                        ( wcslen(L"MY") + 1 ) * sizeof(WCHAR),
                        L"MY" );

    if ( FAILED( hRes = pMB->SetData( hMDHandle,
                                      L"",
                                      &mdr ) ) )
    {
        printf("Failed to write store name to metabase, error 0x%x\n",
               HRESULTTOWIN32( hRes ) );
        goto cleanup2;
    }

    //
    // Write flag indicating it's a Fortezza cert
    //
    dwFortezza  = 1;

    MD_SET_DATA_RECORD( &mdr,
                        MD_SSL_CERT_IS_FORTEZZA,
                        METADATA_NO_ATTRIBUTES,
                        IIS_MD_UT_SERVER,
                        DWORD_METADATA,
                        sizeof(DWORD),
                        &dwFortezza );

    if ( FAILED( hRes = pMB->SetData( hMDHandle,
                                      L"",
                                      &mdr ) ) )
    {
        printf("Failed to write Fortezza flag to metabase, error 0x%x\n",
               HRESULTTOWIN32( hRes ) );
        goto cleanup2;
    }


    //
    // Write PIN
    //
    MD_SET_DATA_RECORD( &mdr,
                        MD_SSL_CERT_FORTEZZA_PIN,
                        METADATA_SECURE,
                        IIS_MD_UT_SERVER,
                        STRING_METADATA,
                        (wcslen( pwszPIN ) + sizeof(WCHAR))*sizeof(WCHAR),
                        pwszPIN );

    if ( FAILED( hRes = pMB->SetData( hMDHandle,
                                      L"",
                                      &mdr ) ) )
    {
        printf("Failed to write PIN to metabase, error 0x%x\n",
               HRESULTTOWIN32( hRes ) );
        goto cleanup2;
    }

    //
    // Write personality
    //
    MD_SET_DATA_RECORD( &mdr,
                        MD_SSL_CERT_FORTEZZA_PERSONALITY,
                        METADATA_SECURE,
                        IIS_MD_UT_SERVER,
                        STRING_METADATA,
                        (wcslen( pwszPersonality ) + 1)*sizeof(WCHAR),
                        pwszPersonality );

    if ( FAILED( hRes = pMB->SetData( hMDHandle,
                                      L"",
                                      &mdr ) ) )
    {
        printf("Failed to write personality to metabase, error 0x%x\n",
               HRESULTTOWIN32( hRes ) );
        goto cleanup2;
    }


    //
    // Write serial number
    //
    MD_SET_DATA_RECORD( &mdr,
                        MD_SSL_CERT_FORTEZZA_SERIAL_NUMBER,
                        METADATA_SECURE,
                        IIS_MD_UT_SERVER,
                        STRING_METADATA,
                        (wcslen( pwszSerialNumber ) + 1)*sizeof(WCHAR),
                        pwszSerialNumber );

    if ( FAILED( hRes = pMB->SetData( hMDHandle,
                                      L"",
                                      &mdr ) ) )
    {
        printf("Failed to write serial number to metabase, error 0x%x\n",
               HRESULTTOWIN32( hRes ) );
        goto cleanup2;
    }


    //
    // Everything succeeded, we're happy
    //
    fOK = TRUE;

cleanup2:   

    if ( pwszSerialNumber )
    {
        delete [] pwszSerialNumber;
    }

    if ( pwszPIN )
    {
        delete [] pwszPIN;
    }

    if ( pwszPersonality )
    {
        delete [] pwszPersonality;
    }

    return fOK;
}


BOOL RemoveFortezzaMBProperties( IMSAdminBaseW *pMB,
                                 METADATA_HANDLE hMDHandle,
                                 LPSTR pszPIN )
/*++

Routine Description:

    Removes Fortezza metabase properties 

Arguments:

    pMB - metabase pointer
    pszInstance - server instance for which data is to be removed; if NULL,
    assumes /W3SVC.
    pszPIN - PIN for card

Returns:

    BOOL indicating success/failure

--*/
{
    METADATA_RECORD mdr;
    HRESULT hRes = S_OK;
    LPWSTR pwszPIN = NULL;
    BOOL fOK = FALSE;
    BOOL fHasCert = FALSE;
    BOOL fCorrectPIN = FALSE;
    DWORD cbRequired = 0;
    BYTE *pbMBPIN = NULL;
    DWORD i = 0;
    DWORD dwFortezza = 0;

    //
    // Metabase interface is Unicode, so convert all the strings to Unicdoe
    //
    if ( !ConvertToUnicode( pszPIN,
                            &pwszPIN ) )
    {
        goto cleanup3;
    }

    //
    // Check that there is a Fortezza cert on this instance
    //
    fHasCert = FALSE;

    if ( !HasFortezzaCert( pMB,
                           hMDHandle,
                           &fHasCert ) )
    {
        printf("Couldn't determine whether this instance has a Fortezza certificate associated with it.\n");
        goto cleanup3;
    }
    else
    {
        if ( !fHasCert )
        {
            printf("No Fortezza certificate associated with this instance.\n");
            goto cleanup3;
        }
    }


    //
    // Before removing anything, make sure the supplied PIN matches the one we have
    // stored, as sort of a poor-man's access check. Of course, this won't stop a
    // brute-force attack...
    //
    if ( !IsCorrectPIN( pMB,
                        hMDHandle,
                        pwszPIN,
                        &fCorrectPIN ) )
    {
        printf("Couldn't determine whether the PIN is correct.\n");
        goto cleanup3;
    }
    else
    {
        if ( !fCorrectPIN )
        {
            printf("The PIN entered does not match the stored PIN.\n");
            goto cleanup3;
        }
    }


    //
    // Run through all the properties and delete them
    //
    for ( i = 0; i < cNumCertMetabaseProperties; i+= 2 )
    {
        if ( FAILED(hRes = pMB->DeleteData( hMDHandle,
                                            L"",
                                            adwMetabaseFortCertProperties[i],
                                            adwMetabaseFortCertProperties[i + 1] ) ) )
        {
            printf("Failed to delete property %d, error 0x%x\n",
                   adwMetabaseFortCertProperties[i],
                   HRESULTTOWIN32( hRes ) );
        }
    }


    //
    // Everything succeeded, we're happy
    //
    fOK = TRUE;

cleanup3:

    if ( pwszPIN )
    {
        delete [] pwszPIN;
    }

    return fOK;
}

#define BUFFER_SIZE 2048

VOID CheckFortezzaMBProperties( IN IMSAdminBaseW *pMB,
                                IN METADATA_HANDLE hMDHandle,
                                IN LPSTR pszPIN )
{
    METADATA_RECORD mdr;
    HRESULT hRes = S_OK;
    LPWSTR pwszPIN = NULL;
    BOOL fOK = FALSE;
    BOOL fHasCert = FALSE;
    BOOL fCompleteChain = FALSE;
    BOOL fTrustedChain = FALSE;
    BOOL fCorrectPIN = FALSE;
    DWORD cbRequired = 0;
    DWORD i = 0;
    DWORD dwFortezza = 0;
    BYTE rgbBuffer[BUFFER_SIZE];
    LPSTR pszPersonality = NULL;
    LPSTR pszSerialNumber = NULL;
    LPSTR pszStoreName = NULL;
    LPSTR pszCSPString = NULL;
    HCRYPTPROV hProv = NULL;
    HCERTSTORE hStore = NULL;
    PCCERT_CONTEXT pServerCert = NULL;
    BYTE rgbCertHash[SHA1_HASH_SIZE];
    
    //
    // Metabase interface is Unicode, so convert all the strings to Unicdoe
    //
    if ( !ConvertToUnicode( pszPIN,
                            &pwszPIN ) )
    {
        goto cleanup4;
    }

    //
    // Check that there is a Fortezza cert on this instance
    //
    fHasCert = FALSE;

    if ( !HasFortezzaCert( pMB,
                           hMDHandle,
                           &fHasCert ) )
    {
        printf("Couldn't determine whether this instance has a Fortezza certificate associated with it.\n");
        goto cleanup4;
    }
    else
    {
        if ( !fHasCert )
        {
            printf("No Fortezza certificate associated with this instance.\n");
            goto cleanup4;
        }
    }


    //
    // Before doing anything, make sure the supplied PIN matches the one we have
    // stored, as sort of a poor-man's access check. Of course, this won't stop a
    // brute-force attack...
    //
    if ( !IsCorrectPIN( pMB,
                        hMDHandle,
                        pwszPIN,
                        &fCorrectPIN ) )
    {
        printf("Couldn't determine whether the PIN is correct.\n");
        goto cleanup4;
    }
    else
    {
        if ( !fCorrectPIN )
        {
            printf("The PIN entered does not match the stored PIN.\n");
            goto cleanup4;
        }
    }

    //
    // Dump all the other Fortezza-specific properties : personality, card serial #
    //
    MD_SET_DATA_RECORD( &mdr,
                        MD_SSL_CERT_FORTEZZA_PERSONALITY,
                        METADATA_SECURE,
                        IIS_MD_UT_SERVER,
                        STRING_METADATA,
                        BUFFER_SIZE,
                        rgbBuffer );

    if ( FAILED( hRes = pMB->GetData( hMDHandle,
                                      L"",
                                      &mdr,
                                      &cbRequired ) ) )
    {
        printf("Failed to read property %d from metabase : 0x%x\n",
               MD_SSL_CERT_FORTEZZA_PERSONALITY,
               HRESULTTOWIN32( hRes ) );
        goto cleanup4;
    }
    
    if ( !ConvertToAscii( (LPWSTR) rgbBuffer,
                          &pszPersonality ) )
    {
        goto cleanup4;
    }

    printf("Fortezza personality associated with this instance : %s\n",
           pszPersonality);

    
    MD_SET_DATA_RECORD( &mdr,
                        MD_SSL_CERT_FORTEZZA_SERIAL_NUMBER,
                        METADATA_SECURE,
                        IIS_MD_UT_SERVER,
                        STRING_METADATA,
                        BUFFER_SIZE,
                        rgbBuffer );

    if ( FAILED( hRes = pMB->GetData( hMDHandle,
                                      L"",
                                      &mdr,
                                      &cbRequired ) ) )
    {
        printf("Failed to read property %d from metabase : 0x%x\n",
               MD_SSL_CERT_FORTEZZA_SERIAL_NUMBER,
               HRESULTTOWIN32( hRes ) );
        goto cleanup4;
    }
    
    if ( !ConvertToAscii( (LPWSTR) rgbBuffer,
                          &pszSerialNumber ) )
    {
        goto cleanup4;
    }

    printf("Serial number of Fortezza card associated with this instance : %s\n",
           pszSerialNumber);


    //
    // Get the store name and cert hash, so we can construct a certificate context
    //
    MD_SET_DATA_RECORD( &mdr,
                        MD_SSL_CERT_STORE_NAME,
                        METADATA_NO_ATTRIBUTES,
                        IIS_MD_UT_SERVER,
                        STRING_METADATA,
                        BUFFER_SIZE,
                        rgbBuffer );

    if ( FAILED( hRes = pMB->GetData( hMDHandle,
                                      L"",
                                      &mdr,
                                      &cbRequired ) ) )
    {
        printf("Failed to read property %d from metabase : 0x%x\n",
               MD_SSL_CERT_STORE_NAME,
               HRESULTTOWIN32( hRes ) );
        goto cleanup4;
    }
    
    if ( !ConvertToAscii( (LPWSTR) rgbBuffer,
                          &pszStoreName ) )
    {
        goto cleanup4;
    }

    MD_SET_DATA_RECORD( &mdr,
                        MD_SSL_CERT_HASH,
                        METADATA_NO_ATTRIBUTES,
                        IIS_MD_UT_SERVER,
                        BINARY_METADATA,
                        SHA1_HASH_SIZE,
                        rgbCertHash );

    if ( FAILED( hRes = pMB->GetData( hMDHandle,
                                      L"",
                                      &mdr,
                                      &cbRequired ) ) )
    {
        printf("Failed to read property %d from metabase : 0x%x\n",
               MD_SSL_CERT_HASH,
               HRESULTTOWIN32( hRes ) );
        goto cleanup4;
    }


    //
    // Check #1 : can we get a handle to the Fortezza CSP with the stored info ?
    //
    pszCSPString = new CHAR[ strlen(pszSerialNumber) + strlen(pszPersonality) +
                             strlen(pszPIN) + 10 ];

    if ( !pszCSPString )
    {
        printf("Out of memory !\n");
        goto cleanup4;
    }

    strcpy( pszCSPString, pszSerialNumber );
    strcat( pszCSPString, "\n" );
    strcat( pszCSPString, pszPersonality );
    strcat( pszCSPString, "\n" );
    strcat( pszCSPString, pszPIN );

    //
    // Get handle to CSP
    //
    if( !CryptAcquireContext(&hProv, 
                             pszCSPString,
                             NULL, 
                             PROV_FORTEZZA, 
                             CRYPT_SILENT ) )
    {
        printf("Couldn't get a handle to the Fortezza CSP\n", 
               GetLastError());
        goto cleanup4;
    }

    //
    // Don't leave the info lying around
    //
    memset( pszCSPString, 0, strlen( pszCSPString ) );
    delete [] pszCSPString;
    pszCSPString = NULL;


    //
    // Check #2 : is the cert hash correct ? 
    //
    if ( !( hStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_A,
                                    0,
                                    hProv,
                                    CERT_SYSTEM_STORE_LOCAL_MACHINE,
                                    pszStoreName ) ) )
    {
        printf("Couldn't open certificate store %s, error 0x%x\n",
               pszStoreName, GetLastError());
        goto cleanup4;
    }
        

    CRYPT_HASH_BLOB HashBlob;
    HashBlob.cbData = SHA1_HASH_SIZE;
    HashBlob.pbData = rgbCertHash;
    
    pServerCert = CertFindCertificateInStore( hStore,
                                              X509_ASN_ENCODING,
                                              0,
                                              CERT_FIND_SHA1_HASH,
                                              (VOID *) &HashBlob,
                                              NULL );
    
    if ( !pServerCert )
    {
        printf("Couldn't find Fortezza certificate in store %s, error 0x%x\n",
               pszStoreName, GetLastError());
        goto cleanup4;
    }
    else
    {
        printf("Found Fortezza certificate in store %s\n",
               pszStoreName);
    }

    //
    // Check #3 : Try to build a complete, trusted chain
    //
    if ( !ConstructCertChain( pServerCert,
                              pszStoreName,
                              &fCompleteChain,
                              &fTrustedChain ) )
    {
        printf("Couldn't build a certificate chain : error %d\n",
               GetLastError());
    }
    else
    {
        if ( fCompleteChain )
        {
            printf("Able to build a complete chain, ending in a self-signed certificate.\n");
        }
        if ( fTrustedChain )
        {
            printf("The chain ends in the trusted ROOT store.\n");
        }

        if ( fTrustedChain && !fCompleteChain )
        {
            printf("WARNING : the chain ends in the ROOT store, but not in a self-signed certificate.\n");
        }
        if ( !fTrustedChain && !fCompleteChain )
        {
            printf("Unable to build a chain that is either complete or trusted.\n");
        }
    }
    
cleanup4:
    
    if ( pServerCert )
    {
        CertFreeCertificateContext( pServerCert );
    }

    if ( hStore )
    {
        CertCloseStore( hStore,
                        0 );
    }

    if ( hProv )
    {
        CryptReleaseContext( hProv,
                             0 );
    }

    if ( pszPersonality )
    {
        delete [] pszPersonality;
    }

    if ( pszSerialNumber )
    {
        delete [] pszSerialNumber;
    }

    if ( pszStoreName )
    {
        delete [] pszStoreName;
    }
}


BOOL ConvertToUnicode( IN LPSTR pszAsciiStr,
                       OUT LPWSTR *ppwszWideStr )
/*++

Routine Description:

    Converts an ASCII string to Unicode, allocating the necessary memory 

Arguments:

     pszAsciiStr - ASCII string to be converted
     ppwszWideStr - pointer to Unicode string, updated on success


Returns:

    BOOL indicating success/failure

--*/

{
    DWORD dwWideStr = MultiByteToWideChar( CP_ACP,
                                           0,
                                           pszAsciiStr,
                                           -1,
                                           NULL,
                                           0 );

    *ppwszWideStr = new WCHAR[dwWideStr];

    if ( !*ppwszWideStr )
    {
        printf("Out of memory !\n");
        return FALSE;
    }

    if ( !(dwWideStr = MultiByteToWideChar( CP_ACP,
                                            0,
                                            pszAsciiStr,
                                            -1,
                                            *ppwszWideStr,
                                            dwWideStr ) ) )
    {
        printf("Error 0x%x converting %s to unicode \n",
               GetLastError(), pszAsciiStr );
        delete [] *ppwszWideStr;
        *ppwszWideStr = NULL;
        return FALSE;
    }

    return TRUE;
}


BOOL ConvertToAscii( IN LPWSTR pwszWideStr,
                     OUT LPSTR *ppszAsciiStr )
/*++

Routine Description:

    Converts a Unicode strint to ASCII, allocating the necessary memory 

Arguments:

     ppwszWideStr - Unicode string to be converted
     ppszAsciiStr - pointer to ASCII string, updated on success

Returns:

    BOOL indicating success/failure

--*/
{
    DWORD dwAsciiStr = WideCharToMultiByte( CP_ACP,
                                            0,
                                            pwszWideStr,
                                            -1,
                                            NULL,
                                            0,
                                            NULL,
                                            NULL );

    if ( !dwAsciiStr )
    {
        printf("Error converting string to ASCII : 0x%x\n",
               GetLastError());
        return FALSE;
    }

    *ppszAsciiStr = new CHAR[dwAsciiStr];

    if ( !*ppszAsciiStr )
    {
        printf("Out of memory !\n");
        return FALSE;
    }

    if ( !WideCharToMultiByte( CP_ACP,
                               0,
                               pwszWideStr,
                               -1,
                               *ppszAsciiStr,
                               dwAsciiStr,
                               NULL,
                               NULL ) )
    {
        printf("Error converting string to ASCII : 0x%x\n",
               GetLastError());
        delete [] *ppszAsciiStr;
        return FALSE;
    }

    return TRUE;
}



BOOL HasFortezzaCert( IMSAdminBaseW *pMB,
                      METADATA_HANDLE hMDHandle,
                      PBOOL pfHasCert )
/*++

Routine Description:

    Checks whether a given existence/value of Fortezza cert flag on a given metadata handle

Arguments:

    pMB - metabase pointer used for reading
    hMDHandle - metadata handle open for read
    pfHasCert - set to TRUE/FALSE if Fortezza cert flag is present and == 1, false otherwise

Returns:

    BOOL indicating success/failure of check 

--*/
{
    HRESULT hRes = S_OK;
    METADATA_RECORD mdr;
    DWORD cbRequired = 0;
    BOOL fOK = TRUE;
    DWORD dwFortezza = 0;

    *pfHasCert = FALSE;

    MD_SET_DATA_RECORD( &mdr,
                        MD_SSL_CERT_IS_FORTEZZA,
                        METADATA_NO_ATTRIBUTES,
                        IIS_MD_UT_SERVER,
                        DWORD_METADATA,
                        sizeof(DWORD),
                        &dwFortezza );

    hRes = pMB->GetData( hMDHandle,
                         L"",
                         &mdr,
                         &cbRequired );


    if ( SUCCEEDED( hRes ) )
    {
        if ( dwFortezza )
        {
            *pfHasCert = TRUE;
        }
    }
    //
    // The only "permissible" error is not finding the flag at all
    //
    else if ( HRESULTTOWIN32( hRes ) != MD_ERROR_DATA_NOT_FOUND )
    {
        fOK = FALSE;
    }

    return fOK;
}


BOOL IsCorrectPIN( IMSAdminBaseW *pMB,
                   METADATA_HANDLE hMDHandle,
                   LPWSTR pwszPIN,
                   PBOOL pfCorrectPIN )
/*++

Routine Description:

    Checks whether supplied PIN matches the PIN stored in the metabase 

Arguments:

    pMB - metabase pointer used for reading
    hMDHandle - metadata handle open for read
    pwszPIN - PIN to be checked against PIN in MB
    pfCorrectPIN - BOOL set to true if PINs match, FALSE otherwise

Returns:

    BOOL indicating success/failure of check 

--*/

{

    HRESULT hRes = S_OK;
    METADATA_RECORD mdr;
    DWORD cbRequired = 0;
    BYTE *pbMBPIN = NULL;
    LPWSTR pwszStoredPIN = NULL;

    MD_SET_DATA_RECORD( &mdr,
                        MD_SSL_CERT_FORTEZZA_PIN,
                        METADATA_SECURE,
                        IIS_MD_UT_SERVER,
                        STRING_METADATA,
                        0,
                        NULL );

    hRes = pMB->GetData( hMDHandle,
                         L"",
                         &mdr,
                         &cbRequired );

    if ( HRESULTTOWIN32( hRes ) != ERROR_INSUFFICIENT_BUFFER )
    {
        printf("Failed trying to read data from metabase : 0x%x\n",
               HRESULTTOWIN32( hRes ) );
        return FALSE;
    }
    else
    {
        pbMBPIN = new BYTE[cbRequired];
        
        if ( !pbMBPIN )
        {
            printf("Out of memory\n");
            return FALSE;
        }
        
        MD_SET_DATA_RECORD( &mdr,
                            MD_SSL_CERT_FORTEZZA_PIN,
                            METADATA_SECURE,
                            IIS_MD_UT_SERVER,
                            STRING_METADATA,
                            cbRequired,
                            pbMBPIN );

        if ( SUCCEEDED( hRes = pMB->GetData( hMDHandle,
                                             L"",
                                             &mdr,
                                             &cbRequired ) ) )
        {
            pwszStoredPIN = (LPWSTR) pbMBPIN;
        
            if ( wcscmp( pwszStoredPIN, pwszPIN ) )
            {
                *pfCorrectPIN = FALSE;
            }
            else
            {
                *pfCorrectPIN = TRUE;
            }
        }
        else
        {
            printf("Failed trying to read data from the metabase : 0x%x\n",
                   HRESULTTOWIN32( hRes ) );
            delete [] pbMBPIN;
            return FALSE;
        }
    }

    if ( pbMBPIN )
    {
        delete [] pbMBPIN;
    }

    return TRUE;
}


BOOL BuildFullPath( IN LPSTR pszSubPath,
                    OUT LPWSTR *ppwszFullPath )
/*++

Routine Description:

    Builds a full metabase path by appending the sub path to the root W3SVC path

Arguments:

    pszSubPath - subpath to be appended to W3SVC path
    ppwszFullPath - pointer to pointer to full path, updated on success

Returns:

    BOOL indicating success/failure of building the path

--*/
{
    LPWSTR pwszSubPath = NULL;

    if ( pszSubPath )
    {
        if ( !ConvertToUnicode( pszSubPath,
                                &pwszSubPath ) )
        {
            return FALSE;
        }

        *ppwszFullPath = new WCHAR[ wcslen( MB_ROOT_PATH ) + wcslen( pwszSubPath ) +
                                    3*sizeof( WCHAR ) ];

        if ( !*ppwszFullPath )
        {
            printf("Out of memory !\n");
            delete [] pwszSubPath;
            return FALSE;
        }

        wcscpy( *ppwszFullPath, MB_ROOT_PATH );
        wcscat( *ppwszFullPath, L"/" );
        wcscat( *ppwszFullPath, pwszSubPath );

    }
    else
    {
        *ppwszFullPath = new WCHAR[ wcslen( MB_ROOT_PATH ) + 1];

        if ( !*ppwszFullPath )
        {
            printf("Out of memory \n");
            return FALSE;
        }

        wcscpy( *ppwszFullPath, MB_ROOT_PATH );
    }

    if ( pwszSubPath )
    {
        delete [] pwszSubPath;
    }

    return TRUE;
}
    

BOOL ConstructCertChain( PCCERT_CONTEXT pcLeafCert,
                         LPSTR pszLeafCertStore,
                         PBOOL pfCompleteChain,
                         PBOOL pfTrustedChain )
/*++

Routine Description:

    Constructs the complete cert chain for the leaf cert passed in

Arguments:

    pcLeafCert - cert for which chain is to be constructed
    pszLeafCertStore - name of store from which pcLeafCert came
    list is pcLeafCert.
    pfCompleteChain - set to TRUE if we constructed a full cert chain ie the constructed chain
    ends with a self-signed cert
    pfTrustedChain - set to TRUE if top of chain is in the ROOT store [ie it's trusted]

Returns:

    BOOL indicating success/failure

--*/
{
    HCERTSTORE hMyStore = NULL;
    HCERTSTORE hCAStore = NULL;
    HCERTSTORE hRootStore = NULL;

    *pfTrustedChain = FALSE;
    *pfCompleteChain = FALSE;

    //
    // Open all the stores we'll search for issuers - MY, CA and ROOT
    //
    hMyStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_A,
                              0,
                              NULL,
                              CERT_SYSTEM_STORE_LOCAL_MACHINE,
                              MY_STORE_NAME );

    if ( !hMyStore )
    {
        printf("Failed to open MY store, error 0x%x\n", GetLastError());
        return FALSE;
    }


   hCAStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_A,
                             0,
                             NULL,
                             CERT_SYSTEM_STORE_LOCAL_MACHINE,
                             CA_STORE_NAME );

    if ( !hCAStore )
    {
        CertCloseStore( hMyStore,
                        0 );
        printf("Failed to open CA store, error 0x%x\n", GetLastError());
        return FALSE;
    }

   hRootStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_A,
                               0,
                               NULL,
                               CERT_SYSTEM_STORE_LOCAL_MACHINE,
                               ROOT_STORE_NAME );

    if ( !hRootStore )
    {
        CertCloseStore( hMyStore,
                        0 );

        CertCloseStore( hCAStore,
                        0 );

        printf("Failed to open ROOT store, error 0x%x\n", GetLastError());
        return FALSE;
    }


    //
    // To build the chain, look for issuers in 4 stores : the store the cert came from,
    // and the "MY", "CA" and "ROOT" stores, cycling through the stores as necessary
    //

    PCCERT_CONTEXT pcIssuer = NULL;
    PCCERT_CONTEXT pcPresentLeaf = pcLeafCert;
    DWORD dwFlags = 0;
    DWORD dwStoresTried = 0;
    *pfCompleteChain = FALSE;
    HCERTSTORE hPresentStore = pcPresentLeaf->hCertStore;
    LPSTR pszPresentStore = pszLeafCertStore;
    LPSTR pszCertStore = NULL;

    while ( 1 )
    {
        //
        // Bail when we get to the top of a chain
        //
        if ( IsSelfSignedCert( pcPresentLeaf ) )
        {
            break;
        }

        pcIssuer = CertGetIssuerCertificateFromStore( hPresentStore,
                                                      pcPresentLeaf,
                                                      NULL,
                                                      &dwFlags );

        //
        // Got an issuer in this store
        //
        if ( pcIssuer )
        {
            //
            // Set up for next round
            //
            dwStoresTried = 0;
            pcPresentLeaf = pcIssuer;
            pszCertStore = pszPresentStore;
        }
        //
        // No issuer in this store, switch to next store to look in
        //
        else
        {

            dwStoresTried++;

            if ( dwStoresTried == 4 ) //we've tried all the stores, time to bail
            {
                break;
            }

            if ( hPresentStore == hMyStore )
            {
                hPresentStore = hCAStore;
                pszPresentStore = CA_STORE_NAME;
            }
            else if ( hPresentStore == hCAStore )
            {
                hPresentStore = hRootStore;
                pszPresentStore = ROOT_STORE_NAME;
            }
            else if ( hPresentStore == hRootStore )
            {
                hPresentStore = pcPresentLeaf->hCertStore;
                pszPresentStore = pszLeafCertStore;
            }
            else
            {
                hPresentStore = hMyStore;
                pszPresentStore = MY_STORE_NAME;
            }
        }
    } //while ( 1 )


    //
    // Set flags indicating status of entire chain
    //
    if ( IsSelfSignedCert( pcPresentLeaf ) )
    {
        *pfCompleteChain = TRUE;
    }

    if ( pszCertStore && !strcmp( pszCertStore, ROOT_STORE_NAME ) )
    {
        *pfTrustedChain = TRUE;
    }

    //
    // Cleanup
    //
    CertCloseStore( hMyStore,
                    0 );
    CertCloseStore( hCAStore,
                    0 );
    CertCloseStore( hRootStore,
                    0 );


    return TRUE;
}

BOOL IsSelfSignedCert( IN PCCERT_CONTEXT pCertContext )
/*++

Routine Description:

    Determines whether a cert is self-signed ie the top of a hierarchy

Arguments:

    pCertContext - cert to be checked

Returns:

    TRUE if cert is self-signed, FALSE otherwise

--*/
{
    //
    // Compare subject and issuer.
    //
    if(pCertContext->pCertInfo->Subject.cbData == pCertContext->pCertInfo->Issuer.cbData)
    {
        if(memcmp(pCertContext->pCertInfo->Subject.pbData,
                  pCertContext->pCertInfo->Issuer.pbData,  
                  pCertContext->pCertInfo->Issuer.cbData) == 0)
        {
            return TRUE;
        }
    }

    return FALSE;
}


BOOL IsNumber( LPCSTR pszName )
{
    return ( atoi( pszName) > 0 ? TRUE : FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\cfgmnt\debug.h ===
/*
 * Some simple debugging macros that look and behave a lot like their
 * namesakes in MFC.  These macros should work in both C and C++ and
 * do something useful with almost any Win32 compiler.
 *
 * George V. Reilly  <georger@microcrafts.com>  <a-georgr@microsoft.com>
 */

#ifndef __DEBUG_H__
#define __DEBUG_H__

#ifdef _DEBUG

# if defined(_MSC_VER)  &&  (_MSC_VER >= 1000)
   /* Use the new debugging tools in Visual C++ 4.x */
#  include <crtdbg.h>
   /* _ASSERTE will give a more meaningful message, but the string takes
    * space.  Use _ASSERT if this is an issue. */
#  define ASSERT(f) _ASSERTE(f)
# else
#  include <assert.h>
#  define ASSERT(f) assert(f)
# endif

# define VERIFY(f)               ASSERT(f)
# define DEBUG_ONLY(f)           (f)
# define TRACE                   Trace
# define TRACE0(psz)             Trace(_T("%s"), _T(psz))
# define TRACE1(psz, p1)         Trace(_T(psz), p1)
# define TRACE2(psz, p1, p2)     Trace(_T(psz), p1, p2)
# define TRACE3(psz, p1, p2, p3) Trace(_T(psz), p1, p2, p3)
# define DEBUG_INIT()            DebugInit()
# define DEBUG_TERM()            DebugTerm()

#else /* !_DEBUG */

  /* These macros should all compile away to nothing */
# define ASSERT(f)               ((void)0)
# define VERIFY(f)               ((void)(f))
# define DEBUG_ONLY(f)           ((void)0)
# define TRACE                   1 ? (void)0 : Trace
# define TRACE0(psz)
# define TRACE1(psz, p1)
# define TRACE2(psz, p1, p2)
# define TRACE3(psz, p1, p2, p3)
# define DEBUG_INIT()            ((void)0)
# define DEBUG_TERM()            ((void)0)

#endif /* !_DEBUG */


#define ASSERT_POINTER(p, type) \
    ASSERT(((p) != NULL)  &&  IsValidAddress((p), sizeof(type), FALSE))

#define ASSERT_NULL_OR_POINTER(p, type) \
    ASSERT(((p) == NULL)  ||  IsValidAddress((p), sizeof(type), FALSE))

	/* t-brianm (6-3-97) Added ASSERT_STRING macros */
#define ASSERT_STRING(s) \
    ASSERT(((s) != NULL)  &&  IsValidString((s), -1))

#define ASSERT_NULL_OR_STRING(s) \
    ASSERT(((s) == NULL)  ||  IsValidString((s), -1))


/* Declarations for non-Windows apps */

#ifndef _WINDEF_
typedef void*           LPVOID;
typedef const void*     LPCVOID;
typedef unsigned int    UINT;
typedef int             BOOL;
typedef const char*     LPCTSTR;
#endif /* _WINDEF_ */

#ifndef TRUE
# define FALSE  0
# define TRUE   1
#endif


#ifdef __cplusplus
extern "C" {

/* Low-level sanity checks for memory blocks */
BOOL IsValidAddress(LPCVOID pv, UINT nBytes, BOOL fReadWrite = TRUE);
BOOL IsValidString(LPCTSTR ptsz, int nLength = -1);

#else /* !__cplusplus */

/* Low-level sanity checks for memory blocks */
BOOL IsValidAddress(LPCVOID pv, UINT nBytes, BOOL fReadWrite);
BOOL IsValidString(LPCTSTR ptsz, int nLength);

#endif /* !__cplusplus */

/* in debug version, writes trace messages to debug stream */
void __cdecl
Trace(
    LPCTSTR pszFormat,
    ...);

/* should be called from main(), WinMain(), or DllMain() */
void
DebugInit();

void
DebugTerm();

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* __DEBUG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\cfgmnt\cfgmntmodule.h ===
// CfgMntModule.h: interface for the CCfgMntModule class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_CFGMNTMODULE_H__7A5D77AB_1982_11D1_A44C_00C04FB99B01__INCLUDED_)
#define AFX_CFGMNTMODULE_H__7A5D77AB_1982_11D1_A44C_00C04FB99B01__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "VerEngine.h"
#include "OperationQueue.h"
#include "DirWatch.h"
#include "SettingsWatch.h"

interface ICfgMntAdmin; // forward declaration

class CCfgMntModule  
{
public:
	CCfgMntModule();
	virtual ~CCfgMntModule();
	void ShutDown();

public:
	CVerEngine m_VerEngine;
	COpQueue m_OpQ;
	CWatchFileSys m_WatchFS;
	CWatchMD m_WatchMD;
	CComPtr<ICfgMntAdmin> m_pICfgMntAdmin;
};

extern CCfgMntModule *g_pCfgMntModule;

#endif // !defined(AFX_CFGMNTMODULE_H__7A5D77AB_1982_11D1_A44C_00C04FB99B01__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\cfgmnt\dirwatch.h ===
// DirWatch.h: interface for the CDirWatch class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_DIRWATCH_H__EC78FB5A_EF1C_11D0_A42F_00C04FB99B01__INCLUDED_)
#define AFX_DIRWATCH_H__EC78FB5A_EF1C_11D0_A42F_00C04FB99B01__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "OperationQueue.h"
#define MAX_BUFFER 1024

class CWatchFileSys; // forward reference

class CWatchFileSys
{
public:
	// adding
	HRESULT Add(LPCTSTR szDir,LPCTSTR szPrj);
	// init/shutdown
	HRESULT NewInit(COpQueue *pOpQ);
	void ShutDown();
	// ctor/dtor
	CWatchFileSys();
	virtual ~CWatchFileSys();

private:
	class CDirInfo 
		{
		public:
			CDirInfo(LPCTSTR szDir,LPCTSTR szPrj) 
				: m_hDir(NULL),m_iBuffer(MAX_BUFFER),m_pNext(NULL)
				{
					_ASSERTE(szDir && szPrj);
					m_szDir = szDir;
					m_szPrj = szPrj;
					memset(&m_Overlapped,0,sizeof(m_Overlapped));
				};
			~CDirInfo() 
				{
					if(m_hDir)
						CloseHandle(m_hDir);
					m_hDir = NULL;
				};
			HANDLE m_hDir;
			wstring m_szDir;
			wstring m_szPrj;
			CHAR m_cBuffer[MAX_BUFFER];
			DWORD m_iBuffer;
			OVERLAPPED m_Overlapped;
			CDirInfo *m_pNext;
		};

	class CWatchInfo
		{
		public:
			CWatchInfo(CWatchFileSys *pWatchFS) 
				: m_pWatchFileSys(pWatchFS), m_hThread(NULL), m_iThreadID(0), 
				  m_hCompPort(NULL),m_pDirInfoHead(NULL),m_pDirInfoTail(NULL) 
				{;};
			~CWatchInfo() 
				{
					CDirInfo *ptmp = NULL;
					while(m_pDirInfoHead)
					{
						ptmp = m_pDirInfoHead->m_pNext;
						delete m_pDirInfoHead;
						m_pDirInfoHead = ptmp;
					}
					m_pDirInfoTail = NULL;
				}
			void AddDirInfo(CDirInfo *pDirInfo)
				{
					if(m_pDirInfoTail == NULL)
					{
						_ASSERT(m_pDirInfoHead == NULL);
						m_pDirInfoHead = pDirInfo;
						m_pDirInfoTail = pDirInfo;
					} else {
						m_pDirInfoTail->m_pNext = pDirInfo;
						m_pDirInfoTail = pDirInfo;
					}
				}

			CWatchFileSys *m_pWatchFileSys;
			CDirInfo *m_pDirInfoHead;
			CDirInfo *m_pDirInfoTail;
			HANDLE m_hThread;
			DWORD m_iThreadID;
			HANDLE m_hCompPort;
		};

	static DWORD WINAPI NotificationThreadProc(LPVOID lpParam);
	BOOL IssueWatch(CDirInfo *pDirInfo);
	bool AddHelper(CWatchInfo &rWatchInfo,CDirInfo *pDirInfo);
	void ShutDownHelper(CWatchInfo &rWatchInfo);

	COpQueue *m_pOpQ;
	CWatchInfo m_WatchInfo;
};

#endif // !defined(AFX_DIRWATCH_H__EC78FB5A_EF1C_11D0_A42F_00C04FB99B01__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\cfgmnt\error.h ===
// Error.h: interface for the CError class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_ERROR_H__0E27E3A0_FD59_11D0_A435_00C04FB99B01__INCLUDED_)
#define AFX_ERROR_H__0E27E3A0_FD59_11D0_A435_00C04FB99B01__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CError  
{
public:
	static void ErrorMsgBox(HRESULT hr);
	static void ErrorTrace(HRESULT hr,LPCSTR szStr,LPCSTR szFile,int iLine);
	static void Trace(LPCSTR szStr);
	static void Trace(LPCTSTR szStr);

	CError();
	virtual ~CError();
};


// @todo make these macros log the errors
#define FAIL_RPT1(hr,str) CError::ErrorTrace(hr,str,__FILE__,__LINE__)
#define FAIL_RTN1(hr,str) { FAIL_RPT1(hr,str); return hr;}
#define IF_FAIL_RTN(hr) if(FAILED(hr)) { FAIL_RTN1(hr,L""); return hr; }
#define IF_FAIL_RTN1(hr,str) if(FAILED(hr)) { FAIL_RTN1(hr,str); return hr; }
#define IF_FAIL_RPT1(hr,str) if(FAILED(hr)) { FAIL_RPT1(hr,str); };

#endif // !defined(AFX_ERROR_H__0E27E3A0_FD59_11D0_A435_00C04FB99B01__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\cfgmnt\error.cpp ===
// Error.cpp: implementation of the CError class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "Error.h"

#include "debug.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CError::CError()
{

}

CError::~CError()
{

}

void CError::ErrorMsgBox(HRESULT hr)
{
	LPTSTR lpMsgBuf;

	FormatMessage( 
		FORMAT_MESSAGE_ALLOCATE_BUFFER | 
		FORMAT_MESSAGE_FROM_SYSTEM | 
		FORMAT_MESSAGE_IGNORE_INSERTS,
		NULL,
		hr,
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
		(LPTSTR) &lpMsgBuf,
		0,
		NULL 
	);

	// Display the string.
	MessageBox( NULL, lpMsgBuf, TEXT("Error"), MB_OK | MB_ICONINFORMATION );

	// Free the buffer.
	LocalFree( lpMsgBuf );
}

void CError::ErrorTrace(HRESULT hr,LPCSTR szStr,LPCSTR szFile,int iLine)
{
	CHAR tmp[2048];
	LPSTR lpMsgBuf;

	DWORD iMsgBuf = FormatMessageA( 
		FORMAT_MESSAGE_ALLOCATE_BUFFER | 
		FORMAT_MESSAGE_FROM_SYSTEM | 
		FORMAT_MESSAGE_IGNORE_INSERTS,
		NULL,
		hr,
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
		(LPSTR) &lpMsgBuf,
		0,
		NULL 
	);

	if(iMsgBuf == 0)
	{
		_ASSERTE(!lpMsgBuf);
		lpMsgBuf = "\n";
	}

	HANDLE hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);
	if(hStdOut != INVALID_HANDLE_VALUE)
	{
		DWORD i = wsprintfA(tmp,"%s: Error [%x] %s",szStr,hr,lpMsgBuf);
		if(i)
		{
			Trace(tmp);
		}
		if(HRESULT_FACILITY(hr) == FACILITY_ITF)
		{
			USES_CONVERSION;
			HRESULT hres = S_OK;
			IErrorInfo *pIErrInfo = NULL;
			hres = GetErrorInfo(NULL,&pIErrInfo);
			if(hres == S_OK)
			{
				BSTR bstr = NULL;
				BSTR bstrHelpFile = NULL;
				hres = pIErrInfo->GetDescription(&bstr);

				hres = pIErrInfo->GetHelpFile(&bstrHelpFile);
				i = wsprintfA(tmp,"IErrInf: %s ",OLE2A(bstr));
				Trace(tmp);
				SysFreeString(bstr);
				SysFreeString(bstrHelpFile);
				pIErrInfo->Release();
			}
		}
		i = wsprintfA(tmp,"in %s line %d.",szFile,iLine);
		if(i)
		{
			Trace(tmp);
		}
		Trace(tmp);
	}

	// Free the buffer.
	if(iMsgBuf > 0)
		LocalFree( lpMsgBuf );
}

void CError::Trace(LPCTSTR szStr)
{
#ifdef TRACE
	::TRACE(szStr);
#else
	USES_CONVERSION;
	LPCSTR szStrA = T2A(szStr);

	HANDLE hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);
	if(hStdOut != INVALID_HANDLE_VALUE)
	{
		DWORD i = strlen(szStrA);
		DWORD j;
		WriteFile(hStdOut,szStrA,i,&j,NULL);
	}
#endif
}

void CError::Trace(LPCSTR szStr)
{
#ifdef TRACE
	USES_CONVERSION;
	LPCTSTR szStrW = A2T(szStr);

	::TRACE(szStrW);
#else
	HANDLE hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);
	if(hStdOut != INVALID_HANDLE_VALUE)
	{
		DWORD i = strlen(szStr);
		DWORD j;
		WriteFile(hStdOut,szStr,i,&j,NULL);
	}
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\cfgmnt\dirwatch.cpp ===
// DirWatch.cpp: implementation of the CWatchFileSys class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "DirWatch.h"
#include "Error.h"
#include "MT.h"
#include "AutoPtr.h"
#include "Error.h"
#include "iadmw.h"		// COM Interface header
#include "iiscnfg.h"	// MD_ & IIS_MD_ #defines

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CWatchFileSys::CWatchFileSys()
	: m_WatchInfo(this), m_pOpQ(NULL)
{

}

CWatchFileSys::~CWatchFileSys()
{
	// verify that thread terminated
	ShutDown();
}

HRESULT CWatchFileSys::NewInit(COpQueue *pOpQ)
{
	_ASSERTE(pOpQ && !m_pOpQ);
	m_pOpQ = pOpQ;
	HRESULT hr = S_OK;
	CComPtr<IMSAdminBase> pIAdminBase;

	// check if we already have a metabase instance
	// create adminbase instance
	hr = CoCreateInstance(CLSID_MSAdminBase,
							NULL, 
							CLSCTX_ALL, 
							IID_IMSAdminBase, 
							(void **) &pIAdminBase);
	IF_FAIL_RTN1(hr,"CoCreateInstance IID_IMSAdminBase");

	METADATA_HANDLE hMD = NULL;
	WCHAR szKeyName[3+6+ 2* METADATA_MAX_NAME_LEN]			// /LM/W3SVC/sitename/vir_dir
		= L"/LM/W3SVC/";
	LPTSTR szSiteKeyName = &szKeyName[wcslen(szKeyName)];	// point to the end of string so we can append it
	DWORD iSiteEnumIndex = 0;
	LPTSTR szVDirKeyName = NULL;
	DWORD iVDirEnumIndex = 0;

	hr = pIAdminBase->OpenKey(METADATA_MASTER_ROOT_HANDLE,
								szKeyName,
								METADATA_PERMISSION_READ,
								20,
								&hMD);
	IF_FAIL_RTN1(hr,"IAdminBase::OpenKey");

	METADATA_RECORD MDRec;
	DWORD iBufLen = 1024;
	DWORD iReqBufLen = 0;
	PBYTE pbBuf = new BYTE[iBufLen];
	if(!pbBuf)
	{
		pIAdminBase->CloseKey(hMD);
		return E_OUTOFMEMORY;
	}
	DWORD iDataIndex = 0;

	while(SUCCEEDED(hr = pIAdminBase->EnumKeys(hMD,TEXT(""),szSiteKeyName,iSiteEnumIndex)))
	{
		// iterate through all virtual sites on this machine
		wcscat(szSiteKeyName,L"/ROOT/");
		szVDirKeyName = szSiteKeyName + wcslen(szSiteKeyName);
		
		iVDirEnumIndex = 0;
		while(SUCCEEDED(hr = pIAdminBase->EnumKeys(hMD,szSiteKeyName,szVDirKeyName,iVDirEnumIndex)))
		{
			// iterate through all virtual directories in each site
			MDRec.dwMDIdentifier = MD_VR_PATH;
			MDRec.dwMDAttributes = METADATA_INHERIT;
			MDRec.dwMDUserType = IIS_MD_UT_FILE;
			MDRec.dwMDDataType = ALL_METADATA;
			MDRec.dwMDDataLen = iBufLen;
			MDRec.pbMDData = pbBuf;
			hr = pIAdminBase->GetData(hMD,szSiteKeyName,&MDRec,&iReqBufLen);
			if(hr == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER))
			{
				delete [] pbBuf;
				pbBuf = new BYTE[iReqBufLen];
				if(!pbBuf)
				{
					pIAdminBase->CloseKey(hMD);
					return E_OUTOFMEMORY;
				}
				iBufLen = iReqBufLen;
				MDRec.dwMDDataLen = iBufLen;
				MDRec.pbMDData = pbBuf;
				hr = pIAdminBase->GetData(hMD,szSiteKeyName,&MDRec,&iReqBufLen);
			}

			// @todo: verify that this dir should be watched
			//        i.e. check if do-not-version flag is set

			if(SUCCEEDED(hr))
			{
				// add 
				wstring szPrj(L"/Files/");			//@todo: decide on prj
					szPrj.append(szSiteKeyName);
				hr = Add((LPCTSTR)MDRec.pbMDData,szPrj.c_str());
				IF_FAIL_RPT1(hr,"CWatchFileSys::Add");
			}
			else
			{
				CError::Trace("Can't get dir for ");
				CError::Trace(szVDirKeyName);
				CError::Trace("\n");
			}
			iVDirEnumIndex++;
		}
		iSiteEnumIndex++;	
	}
	pIAdminBase->CloseKey(hMD);
	delete [] pbBuf;

	return S_OK;
}

void CWatchFileSys::ShutDownHelper(CWatchInfo &rWatchInfo)
{
	if(rWatchInfo.m_hThread)
	{
		// end notification thread
		PostQueuedCompletionStatus(rWatchInfo.m_hCompPort,0,0,NULL);
		// wait for thread to finish
		WaitForSingleObject(rWatchInfo.m_hThread,INFINITE);
		CloseHandle(rWatchInfo.m_hThread);
		rWatchInfo.m_hThread = NULL;
		rWatchInfo.m_iThreadID = 0;
	}
	if(rWatchInfo.m_hCompPort)
	{
		// clean up
		CloseHandle(rWatchInfo.m_hCompPort);
		rWatchInfo.m_hCompPort = NULL;
	}
}

void CWatchFileSys::ShutDown()
{
	ShutDownHelper(m_WatchInfo);
	m_pOpQ = NULL;
}

DWORD WINAPI CWatchFileSys::NotificationThreadProc(LPVOID lpParam)
{
	_ASSERTE(lpParam);
	CWatchInfo *pWI = (CWatchInfo*) lpParam;
	CWatchFileSys *pWatchFileSys = pWI->m_pWatchFileSys;

	// vars for accessing the notification
	DWORD iBytes = 0;
	CDirInfo *pDirInfo = NULL;
	LPOVERLAPPED pOverlapped = NULL;
	PFILE_NOTIFY_INFORMATION pfni = NULL;
	DWORD cbOffset = 0;

	// vars for creating a file op
	HRESULT hr;
	COpFileSys *pOp = NULL;
	LPCTSTR szPrj = NULL;
	LPCTSTR szDir = NULL;
	wstring szFileName;
	wstring szOldFileName;

	do
	{
		_ASSERTE(pWI->m_hCompPort);
		GetQueuedCompletionStatus(pWI->m_hCompPort,
								  &iBytes,
								  (LPDWORD) &pDirInfo,
								  &pOverlapped,
								  INFINITE);
		if(pDirInfo)
		{
			// get ptr to first file_notify_info in buffer
			pfni = (PFILE_NOTIFY_INFORMATION) pDirInfo->m_cBuffer;

			// clean 
			szFileName.erase();			// empty to avoid compare wrong compares
			szOldFileName.erase();		// empty

			// remember dir and prj they are the same for all entries
			szPrj = pDirInfo->m_szPrj.c_str();
			szDir = pDirInfo->m_szDir.c_str();

			// process all file_notify_infos in buffer
			_ASSERTE(pWatchFileSys->m_pOpQ);
			do
			{
				cbOffset = pfni->NextEntryOffset;
				
				// sometime an errorous action #0 is send, let's ignore it
				switch(pfni->Action) {
					case FILE_ACTION_ADDED:
					case FILE_ACTION_REMOVED:
					case FILE_ACTION_MODIFIED:
					case FILE_ACTION_RENAMED_OLD_NAME:
					case FILE_ACTION_RENAMED_NEW_NAME:
						break;
					default:
						// unknown action, let's ignore it
						pfni = (PFILE_NOTIFY_INFORMATION) ((LPBYTE)pfni + cbOffset);// get next offset
						continue;
				}
				
				// on rename remember old filename
				szOldFileName.erase();
				if(pfni->Action == FILE_ACTION_RENAMED_OLD_NAME)
				{
					// make sure next entry exists and is new-name entry
					_ASSERTE(cbOffset);		// there is another entry
					PFILE_NOTIFY_INFORMATION pNextfni = (PFILE_NOTIFY_INFORMATION) ((LPBYTE)pfni + cbOffset);
					_ASSERTE(pNextfni->Action == FILE_ACTION_RENAMED_NEW_NAME); // the next entry contians the new name
					
					// assign old name
					szOldFileName.assign(pfni->FileName,pfni->FileNameLength/2);
					
					// skip to next (new-name) entry
					pfni = pNextfni;
					cbOffset = pNextfni->NextEntryOffset;

					// clear szFileName so it doesn't get skiped in next lines
					szFileName.erase();
				}

				// assign affected filename
				szFileName.assign(pfni->FileName,pfni->FileNameLength/2);

				// create new operation
				pOp = new COpFileSys(pfni->Action,szPrj,szDir,szFileName.c_str(),szOldFileName.c_str());
				if(!pOp)
				{
					// this is bad. no more mem? what to do? need to shutdown entire thread/process
					FAIL_RPT1(E_OUTOFMEMORY,"new COpFile()");

					// continue
					break;
				}

				// add operation
				hr = pWatchFileSys->m_pOpQ->Add(pOp);
				if(FAILED(hr))
				{
					// @todo log err
					FAIL_RPT1(E_FAIL,"COpQueue::Add failed");
					delete pOp;
				}
				if(hr == S_FALSE)	// op was a dupl
					delete pOp;		// so delete and ignore
				pOp = NULL;

				// get next offset
				pfni = (PFILE_NOTIFY_INFORMATION) ((LPBYTE)pfni + cbOffset);
			} while(cbOffset);
			
			// reissue the watch
			if(!pWatchFileSys->IssueWatch(pDirInfo))
			{
				// @todo: log error
			}
		}
	} while( pDirInfo );

	// end of thread
	return 0;
}

bool CWatchFileSys::AddHelper(CWatchInfo &rWatchInfo,CDirInfo *pDirInfo)
{
	// create completion port, or add to it
	rWatchInfo.m_hCompPort = CreateIoCompletionPort(pDirInfo->m_hDir,
													rWatchInfo.m_hCompPort,
													(DWORD)(CDirInfo*) pDirInfo,
													0);
	if(!rWatchInfo.m_hCompPort)
		return false;

	// watch directory
	if(!IssueWatch(pDirInfo))
		return false;

	// create notification thread (if not already exist)
	if(!rWatchInfo.m_hThread)
	{
		rWatchInfo.m_hThread = _beginthreadex(
									NULL,			// no security descriptor
									0,				// default stack size
									NotificationThreadProc,	//thread procedure
									&rWatchInfo,			// thread procedure argument
									0,				// run imideately
									&rWatchInfo.m_iThreadID);	// place to store id
		if(!rWatchInfo.m_hThread)
		return false;
	}
	
	// if everything was successfull, add dirinfo to list
	rWatchInfo.AddDirInfo(pDirInfo);
	return true;
}

HRESULT CWatchFileSys::Add(LPCTSTR szDir,LPCTSTR szRelPrj)
{
	CAutoPtr<CDirInfo> pDirInfo;
	_ASSERTE(szDir && szRelPrj);
	
	// @todo: check that dir is not already part of list (check in subtree as well)
	
	// @todo: convert szDir to Abstolute path
		
	// create dirinfo 
	pDirInfo = new CDirInfo(szDir,szRelPrj);
	if(!pDirInfo)
		FAIL_RTN1(E_OUTOFMEMORY,"new CDirInfo()");

	// get handle to dir
	pDirInfo->m_hDir = CreateFile(szDir,
								  FILE_LIST_DIRECTORY,
 								  FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
								  NULL,
								  OPEN_EXISTING,
								  FILE_FLAG_BACKUP_SEMANTICS|FILE_FLAG_OVERLAPPED,
								  NULL);
	if(pDirInfo->m_hDir == INVALID_HANDLE_VALUE)
		goto _Error;

	if(!AddHelper(m_WatchInfo,pDirInfo))
		goto _Error;
	// @todo: call only if startup flag set. 
	// the following call is slow!!!
	// the following line should only be called if you want to bring the 
	// versioning store to the same state as the file system. I.e. all files
	// will be checked in, and unnecessary files in the version store will be
	// marked deleted.
	
//	pVerEngine->SyncPrj(szPrj.c_str,szDir); // @todo: should only be called when 
	pDirInfo = NULL;

	CError::Trace("Watching: ");
	CError::Trace(szDir);
	CError::Trace("\n");

	return S_OK;

_Error:
	CError::ErrorMsgBox(GetLastError());
	return E_FAIL;
}

BOOL CWatchFileSys::IssueWatch(CDirInfo * pDirInfo)
{
	_ASSERTE(pDirInfo);
	BOOL b;
	DWORD dwNotifyFilter =  FILE_NOTIFY_CHANGE_FILE_NAME	
							| FILE_NOTIFY_CHANGE_DIR_NAME
//							| FILE_NOTIFY_CHANGE_SIZE
//							| FILE_NOTIFY_CHANGE_CREATION
							| FILE_NOTIFY_CHANGE_LAST_WRITE;

	b = ReadDirectoryChangesW(pDirInfo->m_hDir,
								 pDirInfo->m_cBuffer,
								 MAX_BUFFER,
								 TRUE,
								 dwNotifyFilter,
								 & pDirInfo->m_iBuffer,
								 & pDirInfo->m_Overlapped,
								 NULL);
	if(!b)
	{
		CError::ErrorTrace(GetLastError(),"ReadDirectoryChangesW failed",__FILE__,__LINE__);
	}
	return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\cfgmnt\debug.cpp ===
#include "stdafx.h"

#include <stdio.h>
#include <stdarg.h>
#include "debug.h"


//#define ACTIVE_SERVER_PAGES 1


#ifdef _DEBUG

void __cdecl
Trace(
    LPCTSTR ptszFormat,
    ...)
{
    TCHAR tszBuff[2048];
    va_list args;
    
    va_start(args, ptszFormat);
    _vstprintf(tszBuff, ptszFormat, args);
    va_end(args);

    OutputDebugString(tszBuff);
}



# if defined(_MSC_VER)  &&  (_MSC_VER >= 1000)


#  ifdef ACTIVE_SERVER_PAGES

// The default assertion mechanism set up by Visual C++ 4 will not
// work with Active Server Pages because it's running inside a service
// and there is no desktop to interact with.

// Note: for this to work properly, #define _WIN32_WINNT 0x400 before
// including <winuser.h> or MB_SERVICE_NOTIFICATION won't be #define'd.

int __cdecl
AspAssertHandler(
    int   nReportType,
    char* pszErrorText,
    int*  pnReturn)
{
    const char szInfo[] = " (Press ABORT to terminate IIS,"
                          " RETRY to debug this failure,"
                          " or IGNORE to continue.)";
    char* pszMessageTitle = NULL;
    
    // These flags enable message boxes to show up on the user's console
    switch (nReportType)
    {
    case _CRT_WARN:
        pszMessageTitle = "Warning";
        break;
    case _CRT_ERROR:
        pszMessageTitle = "Fatal Error";
        break;
    case _CRT_ASSERT:
        pszMessageTitle = "Assertion Failed";
        break;
    }   
    
    char* pszMessageText =
        static_cast<char*>(_alloca(strlen(pszErrorText) + strlen(szInfo) + 1));

    strcpy(pszMessageText, pszErrorText);
    strcat(pszMessageText, szInfo);
    
    const int n = MessageBoxA(NULL, pszMessageText, pszMessageTitle,
                              (MB_SERVICE_NOTIFICATION | MB_TOPMOST
                               | MB_ABORTRETRYIGNORE | MB_ICONEXCLAMATION));

    if (n == IDABORT)
    {
        exit(1);
    }
    else if (n == IDRETRY)
    {
        *pnReturn = 1;   // tell _CrtDbgReport to start the debugger
        return TRUE;     // tell _CrtDbgReport to run
    }
    
    *pnReturn = 0;       // nothing for _CrtDbgReport to do

    return FALSE;
}

#  endif // ACTIVE_SERVER_PAGES
# endif // _MSC_VER >= 1000



void
DebugInit()
{
# if defined(_MSC_VER)  &&  (_MSC_VER >= 1000)
#  ifdef ACTIVE_SERVER_PAGES
    // If we end up in _CrtDbgReport, don't put up a message box
    _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_DEBUG);
    _CrtSetReportMode(_CRT_WARN,   _CRTDBG_MODE_DEBUG);
    _CrtSetReportMode(_CRT_ERROR,  _CRTDBG_MODE_DEBUG);

    // Use AspAssertHandler to put up a message box instead
    _CrtSetReportHook(AspAssertHandler);
#  endif // ACTIVE_SERVER_PAGES

    // Enable debug heap allocations & check for memory leaks at program exit
    // The memory leak check will not be performed if inetinfo.exe is
    // run directly under a debugger, only if it is run as a service.
    _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF
                   | _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG));
# endif // _MSC_VER >= 1000
}



void
DebugTerm()
{
# if defined(_MSC_VER)  &&  (_MSC_VER >= 1000)
#  ifdef ACTIVE_SERVER_PAGES
    // Turn off AspAssertHandler, so that we don't get numerous message boxes
    // if there are memory leaks on shutdown
    _CrtSetReportHook(NULL);
#  endif // ACTIVE_SERVER_PAGES
# endif // _MSC_VER >= 1000
}

#endif //_DEBUG



BOOL
IsValidString(
    LPCTSTR ptsz,
    int nLength /* =-1 */)
{
    if (ptsz == NULL)
        return FALSE;

    return !IsBadStringPtr(ptsz, nLength);
}



BOOL
IsValidAddress(
    LPCVOID pv,
    UINT nBytes,
    BOOL fReadWrite /* =TRUE */)
{
    return (pv != NULL
            &&  !IsBadReadPtr(pv, nBytes)
            &&  (!fReadWrite  ||  !IsBadWritePtr((LPVOID) pv, nBytes)));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\cfgmnt\iadmw.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.03.0106 */
/* at Fri Aug 01 12:56:48 1997
 */
/* Compiler settings for .\iadmw.idl:
    Oi (OptLev=i0), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __iadmw_h__
#define __iadmw_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IMSAdminBaseW_FWD_DEFINED__
#define __IMSAdminBaseW_FWD_DEFINED__
typedef interface IMSAdminBaseW IMSAdminBaseW;
#endif 	/* __IMSAdminBaseW_FWD_DEFINED__ */


#ifndef __IMSAdminBaseSinkW_FWD_DEFINED__
#define __IMSAdminBaseSinkW_FWD_DEFINED__
typedef interface IMSAdminBaseSinkW IMSAdminBaseSinkW;
#endif 	/* __IMSAdminBaseSinkW_FWD_DEFINED__ */


/* header files for imported files */
#include "mddefw.h"
#include "objidl.h"
#include "ocidl.h"


void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_iadmw_0000
 * at Fri Aug 01 12:56:48 1997
 * using MIDL 3.03.0106
 ****************************************/
/* [local] */ 


/*++
                                                                                
Copyright (c) 1997 Microsoft Corporation
                                                                                
Module Name: iadmw.h
                                                                                
    Admin Objects Interfaces
                                                                                
--*/
#ifndef _ADM_IADMW_
#define _ADM_IADMW_
#include <mdcommsg.h>
#include <mdmsg.h>
/*                                                                              
    Error Codes                                                                 
                                                                                
        Admin api's all return HRESULTS. Since internal results are either   
        winerrors or Metadata specific return codes (see mdmsg.h), they are     
        converted to HRESULTS using the RETURNCODETOHRESULT macro (see          
        commsg.h).                                                              
*/                                                                              
                                                                                
/*                                                                              
    Max Name Length                                                             
        The maximum number of characters in the length of a metaobject name,    
        including the terminating NULL. This refers to each node in the tree,   
        not the entire path.                                                    
        eg. strlen("Root") < ADMINDATA_MAX_NAME_LEN                           
*/                                                                              
#define ADMINDATA_MAX_NAME_LEN           256
                                                                                
#define CLSID_MSAdminBase       CLSID_MSAdminBase_W                             
#define CLSID_MSAdminBaseExe    CLSID_MSAdminBaseExe_W                          
#define IID_IMSAdminBase        IID_IMSAdminBase_W                              
#define IMSAdminBase            IMSAdminBaseW                                   
#define IMSAdminBaseSink        IMSAdminBaseSinkW                               
#define IID_IMSAdminBaseSink    IID_IMSAdminBaseSink_W                          
#define GETAdminBaseCLSID       GETAdminBaseCLSIDW                              
                                                                                
DEFINE_GUID(CLSID_MSAdminBase_W, 0xa9e69610, 0xb80d, 0x11d0, 0xb9, 0xb9, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x50);
DEFINE_GUID(IID_IMSAdminBase_W, 0x70b51430, 0xb6ca, 0x11d0, 0xb9, 0xb9, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x50);
DEFINE_GUID(CLSID_MSAdminBaseExe_W, 0xa9e69611, 0xb80d, 0x11d0, 0xb9, 0xb9, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x50);
DEFINE_GUID(IID_IMSAdminBaseSink_W, 0xa9e69612, 0xb80d, 0x11d0, 0xb9, 0xb9, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x50);
#define GETAdminBaseCLSIDW(IsService) ((IsService) ? CLSID_MSAdminBase_W : CLSID_MSAdminBaseExe_W)
/*                                                                              
The Main Interface, UNICODE                                                     
*/                                                                              


extern RPC_IF_HANDLE __MIDL_itf_iadmw_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_iadmw_0000_v0_0_s_ifspec;

#ifndef __IMSAdminBaseW_INTERFACE_DEFINED__
#define __IMSAdminBaseW_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMSAdminBaseW
 * at Fri Aug 01 12:56:48 1997
 * using MIDL 3.03.0106
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IMSAdminBaseW;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("70B51430-B6CA-11d0-B9B9-00A0C922E750")
    IMSAdminBaseW : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AddKey( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteKey( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteChildKeys( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumKeys( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [size_is][out] */ LPWSTR pszMDName,
            /* [in] */ DWORD dwMDEnumObjectIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CopyKey( 
            /* [in] */ METADATA_HANDLE hMDSourceHandle,
            /* [string][in][unique] */ LPCWSTR pszMDSourcePath,
            /* [in] */ METADATA_HANDLE hMDDestHandle,
            /* [string][in][unique] */ LPCWSTR pszMDDestPath,
            /* [in] */ BOOL bMDOverwriteFlag,
            /* [in] */ BOOL bMDCopyFlag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RenameKey( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [string][in][unique] */ LPCWSTR pszMDNewName) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE SetData( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [in] */ PMETADATA_RECORD pmdrMDData) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetData( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [out][in] */ PMETADATA_RECORD pmdrMDData,
            /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteData( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [in] */ DWORD dwMDIdentifier,
            /* [in] */ DWORD dwMDDataType) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE EnumData( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [out][in] */ PMETADATA_RECORD pmdrMDData,
            /* [in] */ DWORD dwMDEnumDataIndex,
            /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetAllData( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [in] */ DWORD dwMDAttributes,
            /* [in] */ DWORD dwMDUserType,
            /* [in] */ DWORD dwMDDataType,
            /* [out] */ DWORD __RPC_FAR *pdwMDNumDataEntries,
            /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber,
            /* [in] */ DWORD dwMDBufferSize,
            /* [size_is][out] */ unsigned char __RPC_FAR *pbMDBuffer,
            /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteAllData( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [in] */ DWORD dwMDUserType,
            /* [in] */ DWORD dwMDDataType) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CopyData( 
            /* [in] */ METADATA_HANDLE hMDSourceHandle,
            /* [string][in][unique] */ LPCWSTR pszMDSourcePath,
            /* [in] */ METADATA_HANDLE hMDDestHandle,
            /* [string][in][unique] */ LPCWSTR pszMDDestPath,
            /* [in] */ DWORD dwMDAttributes,
            /* [in] */ DWORD dwMDUserType,
            /* [in] */ DWORD dwMDDataType,
            /* [in] */ BOOL bMDCopyFlag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDataPaths( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [in] */ DWORD dwMDIdentifier,
            /* [in] */ DWORD dwMDDataType,
            /* [in] */ DWORD dwMDBufferSize,
            /* [size_is][out] */ WCHAR __RPC_FAR *pszBuffer,
            /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OpenKey( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [in] */ DWORD dwMDAccessRequested,
            /* [in] */ DWORD dwMDTimeOut,
            /* [out] */ PMETADATA_HANDLE phMDNewHandle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CloseKey( 
            /* [in] */ METADATA_HANDLE hMDHandle) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ChangePermissions( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [in] */ DWORD dwMDTimeOut,
            /* [in] */ DWORD dwMDAccessRequested) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SaveData( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHandleInfo( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [out] */ PMETADATA_HANDLE_INFO pmdhiInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetSystemChangeNumber( 
            /* [out] */ DWORD __RPC_FAR *pdwSystemChangeNumber) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDataSetNumber( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLastChangeTime( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [in] */ PFILETIME pftMDLastChangeTime,
            /* [in] */ BOOL bLocalTime) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLastChangeTime( 
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [out] */ PFILETIME pftMDLastChangeTime,
            /* [in] */ BOOL bLocalTime) = 0;
        
        virtual /* [restricted][local] */ HRESULT STDMETHODCALLTYPE KeyExchangePhase1( void) = 0;
        
        virtual /* [restricted][local] */ HRESULT STDMETHODCALLTYPE KeyExchangePhase2( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Backup( 
            /* [string][in][unique] */ LPCWSTR pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion,
            /* [in] */ DWORD dwMDFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Restore( 
            /* [string][in][unique] */ LPCWSTR pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion,
            /* [in] */ DWORD dwMDFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumBackups( 
            /* [size_is][out][in] */ LPWSTR pszMDBackupLocation,
            /* [out] */ DWORD __RPC_FAR *pdwMDVersion,
            /* [out] */ PFILETIME pftMDBackupTime,
            /* [in] */ DWORD dwMDEnumIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteBackup( 
            /* [string][in][unique] */ LPCWSTR pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnmarshalInterface( 
            /* [out] */ IMSAdminBaseW __RPC_FAR *__RPC_FAR *piadmbwInterface) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSAdminBaseWVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMSAdminBaseW __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMSAdminBaseW __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMSAdminBaseW __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddKey )( 
            IMSAdminBaseW __RPC_FAR * This,
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteKey )( 
            IMSAdminBaseW __RPC_FAR * This,
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteChildKeys )( 
            IMSAdminBaseW __RPC_FAR * This,
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumKeys )( 
            IMSAdminBaseW __RPC_FAR * This,
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [size_is][out] */ LPWSTR pszMDName,
            /* [in] */ DWORD dwMDEnumObjectIndex);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CopyKey )( 
            IMSAdminBaseW __RPC_FAR * This,
            /* [in] */ METADATA_HANDLE hMDSourceHandle,
            /* [string][in][unique] */ LPCWSTR pszMDSourcePath,
            /* [in] */ METADATA_HANDLE hMDDestHandle,
            /* [string][in][unique] */ LPCWSTR pszMDDestPath,
            /* [in] */ BOOL bMDOverwriteFlag,
            /* [in] */ BOOL bMDCopyFlag);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RenameKey )( 
            IMSAdminBaseW __RPC_FAR * This,
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [string][in][unique] */ LPCWSTR pszMDNewName);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetData )( 
            IMSAdminBaseW __RPC_FAR * This,
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [in] */ PMETADATA_RECORD pmdrMDData);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetData )( 
            IMSAdminBaseW __RPC_FAR * This,
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [out][in] */ PMETADATA_RECORD pmdrMDData,
            /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteData )( 
            IMSAdminBaseW __RPC_FAR * This,
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [in] */ DWORD dwMDIdentifier,
            /* [in] */ DWORD dwMDDataType);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumData )( 
            IMSAdminBaseW __RPC_FAR * This,
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [out][in] */ PMETADATA_RECORD pmdrMDData,
            /* [in] */ DWORD dwMDEnumDataIndex,
            /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAllData )( 
            IMSAdminBaseW __RPC_FAR * This,
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [in] */ DWORD dwMDAttributes,
            /* [in] */ DWORD dwMDUserType,
            /* [in] */ DWORD dwMDDataType,
            /* [out] */ DWORD __RPC_FAR *pdwMDNumDataEntries,
            /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber,
            /* [in] */ DWORD dwMDBufferSize,
            /* [size_is][out] */ unsigned char __RPC_FAR *pbMDBuffer,
            /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteAllData )( 
            IMSAdminBaseW __RPC_FAR * This,
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [in] */ DWORD dwMDUserType,
            /* [in] */ DWORD dwMDDataType);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CopyData )( 
            IMSAdminBaseW __RPC_FAR * This,
            /* [in] */ METADATA_HANDLE hMDSourceHandle,
            /* [string][in][unique] */ LPCWSTR pszMDSourcePath,
            /* [in] */ METADATA_HANDLE hMDDestHandle,
            /* [string][in][unique] */ LPCWSTR pszMDDestPath,
            /* [in] */ DWORD dwMDAttributes,
            /* [in] */ DWORD dwMDUserType,
            /* [in] */ DWORD dwMDDataType,
            /* [in] */ BOOL bMDCopyFlag);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDataPaths )( 
            IMSAdminBaseW __RPC_FAR * This,
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [in] */ DWORD dwMDIdentifier,
            /* [in] */ DWORD dwMDDataType,
            /* [in] */ DWORD dwMDBufferSize,
            /* [size_is][out] */ WCHAR __RPC_FAR *pszBuffer,
            /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OpenKey )( 
            IMSAdminBaseW __RPC_FAR * This,
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [in] */ DWORD dwMDAccessRequested,
            /* [in] */ DWORD dwMDTimeOut,
            /* [out] */ PMETADATA_HANDLE phMDNewHandle);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CloseKey )( 
            IMSAdminBaseW __RPC_FAR * This,
            /* [in] */ METADATA_HANDLE hMDHandle);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ChangePermissions )( 
            IMSAdminBaseW __RPC_FAR * This,
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [in] */ DWORD dwMDTimeOut,
            /* [in] */ DWORD dwMDAccessRequested);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SaveData )( 
            IMSAdminBaseW __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetHandleInfo )( 
            IMSAdminBaseW __RPC_FAR * This,
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [out] */ PMETADATA_HANDLE_INFO pmdhiInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSystemChangeNumber )( 
            IMSAdminBaseW __RPC_FAR * This,
            /* [out] */ DWORD __RPC_FAR *pdwSystemChangeNumber);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDataSetNumber )( 
            IMSAdminBaseW __RPC_FAR * This,
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLastChangeTime )( 
            IMSAdminBaseW __RPC_FAR * This,
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [in] */ PFILETIME pftMDLastChangeTime,
            /* [in] */ BOOL bLocalTime);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLastChangeTime )( 
            IMSAdminBaseW __RPC_FAR * This,
            /* [in] */ METADATA_HANDLE hMDHandle,
            /* [string][in][unique] */ LPCWSTR pszMDPath,
            /* [out] */ PFILETIME pftMDLastChangeTime,
            /* [in] */ BOOL bLocalTime);
        
        /* [restricted][local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *KeyExchangePhase1 )( 
            IMSAdminBaseW __RPC_FAR * This);
        
        /* [restricted][local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *KeyExchangePhase2 )( 
            IMSAdminBaseW __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Backup )( 
            IMSAdminBaseW __RPC_FAR * This,
            /* [string][in][unique] */ LPCWSTR pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion,
            /* [in] */ DWORD dwMDFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Restore )( 
            IMSAdminBaseW __RPC_FAR * This,
            /* [string][in][unique] */ LPCWSTR pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion,
            /* [in] */ DWORD dwMDFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumBackups )( 
            IMSAdminBaseW __RPC_FAR * This,
            /* [size_is][out][in] */ LPWSTR pszMDBackupLocation,
            /* [out] */ DWORD __RPC_FAR *pdwMDVersion,
            /* [out] */ PFILETIME pftMDBackupTime,
            /* [in] */ DWORD dwMDEnumIndex);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteBackup )( 
            IMSAdminBaseW __RPC_FAR * This,
            /* [string][in][unique] */ LPCWSTR pszMDBackupLocation,
            /* [in] */ DWORD dwMDVersion);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnmarshalInterface )( 
            IMSAdminBaseW __RPC_FAR * This,
            /* [out] */ IMSAdminBaseW __RPC_FAR *__RPC_FAR *piadmbwInterface);
        
        END_INTERFACE
    } IMSAdminBaseWVtbl;

    interface IMSAdminBaseW
    {
        CONST_VTBL struct IMSAdminBaseWVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSAdminBaseW_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSAdminBaseW_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSAdminBaseW_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSAdminBaseW_AddKey(This,hMDHandle,pszMDPath)	\
    (This)->lpVtbl -> AddKey(This,hMDHandle,pszMDPath)

#define IMSAdminBaseW_DeleteKey(This,hMDHandle,pszMDPath)	\
    (This)->lpVtbl -> DeleteKey(This,hMDHandle,pszMDPath)

#define IMSAdminBaseW_DeleteChildKeys(This,hMDHandle,pszMDPath)	\
    (This)->lpVtbl -> DeleteChildKeys(This,hMDHandle,pszMDPath)

#define IMSAdminBaseW_EnumKeys(This,hMDHandle,pszMDPath,pszMDName,dwMDEnumObjectIndex)	\
    (This)->lpVtbl -> EnumKeys(This,hMDHandle,pszMDPath,pszMDName,dwMDEnumObjectIndex)

#define IMSAdminBaseW_CopyKey(This,hMDSourceHandle,pszMDSourcePath,hMDDestHandle,pszMDDestPath,bMDOverwriteFlag,bMDCopyFlag)	\
    (This)->lpVtbl -> CopyKey(This,hMDSourceHandle,pszMDSourcePath,hMDDestHandle,pszMDDestPath,bMDOverwriteFlag,bMDCopyFlag)

#define IMSAdminBaseW_RenameKey(This,hMDHandle,pszMDPath,pszMDNewName)	\
    (This)->lpVtbl -> RenameKey(This,hMDHandle,pszMDPath,pszMDNewName)

#define IMSAdminBaseW_SetData(This,hMDHandle,pszMDPath,pmdrMDData)	\
    (This)->lpVtbl -> SetData(This,hMDHandle,pszMDPath,pmdrMDData)

#define IMSAdminBaseW_GetData(This,hMDHandle,pszMDPath,pmdrMDData,pdwMDRequiredDataLen)	\
    (This)->lpVtbl -> GetData(This,hMDHandle,pszMDPath,pmdrMDData,pdwMDRequiredDataLen)

#define IMSAdminBaseW_DeleteData(This,hMDHandle,pszMDPath,dwMDIdentifier,dwMDDataType)	\
    (This)->lpVtbl -> DeleteData(This,hMDHandle,pszMDPath,dwMDIdentifier,dwMDDataType)

#define IMSAdminBaseW_EnumData(This,hMDHandle,pszMDPath,pmdrMDData,dwMDEnumDataIndex,pdwMDRequiredDataLen)	\
    (This)->lpVtbl -> EnumData(This,hMDHandle,pszMDPath,pmdrMDData,dwMDEnumDataIndex,pdwMDRequiredDataLen)

#define IMSAdminBaseW_GetAllData(This,hMDHandle,pszMDPath,dwMDAttributes,dwMDUserType,dwMDDataType,pdwMDNumDataEntries,pdwMDDataSetNumber,dwMDBufferSize,pbMDBuffer,pdwMDRequiredBufferSize)	\
    (This)->lpVtbl -> GetAllData(This,hMDHandle,pszMDPath,dwMDAttributes,dwMDUserType,dwMDDataType,pdwMDNumDataEntries,pdwMDDataSetNumber,dwMDBufferSize,pbMDBuffer,pdwMDRequiredBufferSize)

#define IMSAdminBaseW_DeleteAllData(This,hMDHandle,pszMDPath,dwMDUserType,dwMDDataType)	\
    (This)->lpVtbl -> DeleteAllData(This,hMDHandle,pszMDPath,dwMDUserType,dwMDDataType)

#define IMSAdminBaseW_CopyData(This,hMDSourceHandle,pszMDSourcePath,hMDDestHandle,pszMDDestPath,dwMDAttributes,dwMDUserType,dwMDDataType,bMDCopyFlag)	\
    (This)->lpVtbl -> CopyData(This,hMDSourceHandle,pszMDSourcePath,hMDDestHandle,pszMDDestPath,dwMDAttributes,dwMDUserType,dwMDDataType,bMDCopyFlag)

#define IMSAdminBaseW_GetDataPaths(This,hMDHandle,pszMDPath,dwMDIdentifier,dwMDDataType,dwMDBufferSize,pszBuffer,pdwMDRequiredBufferSize)	\
    (This)->lpVtbl -> GetDataPaths(This,hMDHandle,pszMDPath,dwMDIdentifier,dwMDDataType,dwMDBufferSize,pszBuffer,pdwMDRequiredBufferSize)

#define IMSAdminBaseW_OpenKey(This,hMDHandle,pszMDPath,dwMDAccessRequested,dwMDTimeOut,phMDNewHandle)	\
    (This)->lpVtbl -> OpenKey(This,hMDHandle,pszMDPath,dwMDAccessRequested,dwMDTimeOut,phMDNewHandle)

#define IMSAdminBaseW_CloseKey(This,hMDHandle)	\
    (This)->lpVtbl -> CloseKey(This,hMDHandle)

#define IMSAdminBaseW_ChangePermissions(This,hMDHandle,dwMDTimeOut,dwMDAccessRequested)	\
    (This)->lpVtbl -> ChangePermissions(This,hMDHandle,dwMDTimeOut,dwMDAccessRequested)

#define IMSAdminBaseW_SaveData(This)	\
    (This)->lpVtbl -> SaveData(This)

#define IMSAdminBaseW_GetHandleInfo(This,hMDHandle,pmdhiInfo)	\
    (This)->lpVtbl -> GetHandleInfo(This,hMDHandle,pmdhiInfo)

#define IMSAdminBaseW_GetSystemChangeNumber(This,pdwSystemChangeNumber)	\
    (This)->lpVtbl -> GetSystemChangeNumber(This,pdwSystemChangeNumber)

#define IMSAdminBaseW_GetDataSetNumber(This,hMDHandle,pszMDPath,pdwMDDataSetNumber)	\
    (This)->lpVtbl -> GetDataSetNumber(This,hMDHandle,pszMDPath,pdwMDDataSetNumber)

#define IMSAdminBaseW_SetLastChangeTime(This,hMDHandle,pszMDPath,pftMDLastChangeTime,bLocalTime)	\
    (This)->lpVtbl -> SetLastChangeTime(This,hMDHandle,pszMDPath,pftMDLastChangeTime,bLocalTime)

#define IMSAdminBaseW_GetLastChangeTime(This,hMDHandle,pszMDPath,pftMDLastChangeTime,bLocalTime)	\
    (This)->lpVtbl -> GetLastChangeTime(This,hMDHandle,pszMDPath,pftMDLastChangeTime,bLocalTime)

#define IMSAdminBaseW_KeyExchangePhase1(This)	\
    (This)->lpVtbl -> KeyExchangePhase1(This)

#define IMSAdminBaseW_KeyExchangePhase2(This)	\
    (This)->lpVtbl -> KeyExchangePhase2(This)

#define IMSAdminBaseW_Backup(This,pszMDBackupLocation,dwMDVersion,dwMDFlags)	\
    (This)->lpVtbl -> Backup(This,pszMDBackupLocation,dwMDVersion,dwMDFlags)

#define IMSAdminBaseW_Restore(This,pszMDBackupLocation,dwMDVersion,dwMDFlags)	\
    (This)->lpVtbl -> Restore(This,pszMDBackupLocation,dwMDVersion,dwMDFlags)

#define IMSAdminBaseW_EnumBackups(This,pszMDBackupLocation,pdwMDVersion,pftMDBackupTime,dwMDEnumIndex)	\
    (This)->lpVtbl -> EnumBackups(This,pszMDBackupLocation,pdwMDVersion,pftMDBackupTime,dwMDEnumIndex)

#define IMSAdminBaseW_DeleteBackup(This,pszMDBackupLocation,dwMDVersion)	\
    (This)->lpVtbl -> DeleteBackup(This,pszMDBackupLocation,dwMDVersion)

#define IMSAdminBaseW_UnmarshalInterface(This,piadmbwInterface)	\
    (This)->lpVtbl -> UnmarshalInterface(This,piadmbwInterface)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMSAdminBaseW_AddKey_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath);


void __RPC_STUB IMSAdminBaseW_AddKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSAdminBaseW_DeleteKey_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath);


void __RPC_STUB IMSAdminBaseW_DeleteKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSAdminBaseW_DeleteChildKeys_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath);


void __RPC_STUB IMSAdminBaseW_DeleteChildKeys_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSAdminBaseW_EnumKeys_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [size_is][out] */ LPWSTR pszMDName,
    /* [in] */ DWORD dwMDEnumObjectIndex);


void __RPC_STUB IMSAdminBaseW_EnumKeys_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSAdminBaseW_CopyKey_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDSourceHandle,
    /* [string][in][unique] */ LPCWSTR pszMDSourcePath,
    /* [in] */ METADATA_HANDLE hMDDestHandle,
    /* [string][in][unique] */ LPCWSTR pszMDDestPath,
    /* [in] */ BOOL bMDOverwriteFlag,
    /* [in] */ BOOL bMDCopyFlag);


void __RPC_STUB IMSAdminBaseW_CopyKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSAdminBaseW_RenameKey_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [string][in][unique] */ LPCWSTR pszMDNewName);


void __RPC_STUB IMSAdminBaseW_RenameKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IMSAdminBaseW_R_SetData_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ PMETADATA_RECORD pmdrMDData);


void __RPC_STUB IMSAdminBaseW_R_SetData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IMSAdminBaseW_R_GetData_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [out][in] */ PMETADATA_RECORD pmdrMDData,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen,
    /* [out] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *__RPC_FAR *ppDataBlob);


void __RPC_STUB IMSAdminBaseW_R_GetData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSAdminBaseW_DeleteData_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ DWORD dwMDIdentifier,
    /* [in] */ DWORD dwMDDataType);


void __RPC_STUB IMSAdminBaseW_DeleteData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IMSAdminBaseW_R_EnumData_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [out][in] */ PMETADATA_RECORD pmdrMDData,
    /* [in] */ DWORD dwMDEnumDataIndex,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen,
    /* [out] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *__RPC_FAR *ppDataBlob);


void __RPC_STUB IMSAdminBaseW_R_EnumData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IMSAdminBaseW_R_GetAllData_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ DWORD dwMDAttributes,
    /* [in] */ DWORD dwMDUserType,
    /* [in] */ DWORD dwMDDataType,
    /* [out] */ DWORD __RPC_FAR *pdwMDNumDataEntries,
    /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber,
    /* [in] */ DWORD dwMDBufferSize,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize,
    /* [out] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *__RPC_FAR *ppDataBlob);


void __RPC_STUB IMSAdminBaseW_R_GetAllData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSAdminBaseW_DeleteAllData_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ DWORD dwMDUserType,
    /* [in] */ DWORD dwMDDataType);


void __RPC_STUB IMSAdminBaseW_DeleteAllData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSAdminBaseW_CopyData_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDSourceHandle,
    /* [string][in][unique] */ LPCWSTR pszMDSourcePath,
    /* [in] */ METADATA_HANDLE hMDDestHandle,
    /* [string][in][unique] */ LPCWSTR pszMDDestPath,
    /* [in] */ DWORD dwMDAttributes,
    /* [in] */ DWORD dwMDUserType,
    /* [in] */ DWORD dwMDDataType,
    /* [in] */ BOOL bMDCopyFlag);


void __RPC_STUB IMSAdminBaseW_CopyData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSAdminBaseW_GetDataPaths_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ DWORD dwMDIdentifier,
    /* [in] */ DWORD dwMDDataType,
    /* [in] */ DWORD dwMDBufferSize,
    /* [size_is][out] */ WCHAR __RPC_FAR *pszBuffer,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize);


void __RPC_STUB IMSAdminBaseW_GetDataPaths_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSAdminBaseW_OpenKey_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ DWORD dwMDAccessRequested,
    /* [in] */ DWORD dwMDTimeOut,
    /* [out] */ PMETADATA_HANDLE phMDNewHandle);


void __RPC_STUB IMSAdminBaseW_OpenKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSAdminBaseW_CloseKey_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle);


void __RPC_STUB IMSAdminBaseW_CloseKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSAdminBaseW_ChangePermissions_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [in] */ DWORD dwMDTimeOut,
    /* [in] */ DWORD dwMDAccessRequested);


void __RPC_STUB IMSAdminBaseW_ChangePermissions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSAdminBaseW_SaveData_Proxy( 
    IMSAdminBaseW __RPC_FAR * This);


void __RPC_STUB IMSAdminBaseW_SaveData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSAdminBaseW_GetHandleInfo_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [out] */ PMETADATA_HANDLE_INFO pmdhiInfo);


void __RPC_STUB IMSAdminBaseW_GetHandleInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSAdminBaseW_GetSystemChangeNumber_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *pdwSystemChangeNumber);


void __RPC_STUB IMSAdminBaseW_GetSystemChangeNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSAdminBaseW_GetDataSetNumber_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber);


void __RPC_STUB IMSAdminBaseW_GetDataSetNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSAdminBaseW_SetLastChangeTime_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ PFILETIME pftMDLastChangeTime,
    /* [in] */ BOOL bLocalTime);


void __RPC_STUB IMSAdminBaseW_SetLastChangeTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSAdminBaseW_GetLastChangeTime_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [out] */ PFILETIME pftMDLastChangeTime,
    /* [in] */ BOOL bLocalTime);


void __RPC_STUB IMSAdminBaseW_GetLastChangeTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IMSAdminBaseW_R_KeyExchangePhase1_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in][unique] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *pClientKeyExchangeKeyBlob,
    /* [in][unique] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *pClientSignatureKeyBlob,
    /* [out] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *__RPC_FAR *ppServerKeyExchangeKeyBlob,
    /* [out] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *__RPC_FAR *ppServerSignatureKeyBlob,
    /* [out] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *__RPC_FAR *ppServerSessionKeyBlob);


void __RPC_STUB IMSAdminBaseW_R_KeyExchangePhase1_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IMSAdminBaseW_R_KeyExchangePhase2_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in][unique] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *pClientSessionKeyBlob,
    /* [in][unique] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *pClientHashBlob,
    /* [out] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *__RPC_FAR *ppServerHashBlob);


void __RPC_STUB IMSAdminBaseW_R_KeyExchangePhase2_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSAdminBaseW_Backup_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [string][in][unique] */ LPCWSTR pszMDBackupLocation,
    /* [in] */ DWORD dwMDVersion,
    /* [in] */ DWORD dwMDFlags);


void __RPC_STUB IMSAdminBaseW_Backup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSAdminBaseW_Restore_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [string][in][unique] */ LPCWSTR pszMDBackupLocation,
    /* [in] */ DWORD dwMDVersion,
    /* [in] */ DWORD dwMDFlags);


void __RPC_STUB IMSAdminBaseW_Restore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSAdminBaseW_EnumBackups_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [size_is][out][in] */ LPWSTR pszMDBackupLocation,
    /* [out] */ DWORD __RPC_FAR *pdwMDVersion,
    /* [out] */ PFILETIME pftMDBackupTime,
    /* [in] */ DWORD dwMDEnumIndex);


void __RPC_STUB IMSAdminBaseW_EnumBackups_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSAdminBaseW_DeleteBackup_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [string][in][unique] */ LPCWSTR pszMDBackupLocation,
    /* [in] */ DWORD dwMDVersion);


void __RPC_STUB IMSAdminBaseW_DeleteBackup_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSAdminBaseW_UnmarshalInterface_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [out] */ IMSAdminBaseW __RPC_FAR *__RPC_FAR *piadmbwInterface);


void __RPC_STUB IMSAdminBaseW_UnmarshalInterface_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSAdminBaseW_INTERFACE_DEFINED__ */


#ifndef __IMSAdminBaseSinkW_INTERFACE_DEFINED__
#define __IMSAdminBaseSinkW_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IMSAdminBaseSinkW
 * at Fri Aug 01 12:56:48 1997
 * using MIDL 3.03.0106
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IMSAdminBaseSinkW;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A9E69612-B80D-11d0-B9B9-00A0C922E750")
    IMSAdminBaseSinkW : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SinkNotify( 
            /* [in] */ DWORD dwMDNumElements,
            /* [size_is][in] */ MD_CHANGE_OBJECT_W __RPC_FAR pcoChangeList[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShutdownNotify( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IMSAdminBaseSinkWVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IMSAdminBaseSinkW __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IMSAdminBaseSinkW __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IMSAdminBaseSinkW __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SinkNotify )( 
            IMSAdminBaseSinkW __RPC_FAR * This,
            /* [in] */ DWORD dwMDNumElements,
            /* [size_is][in] */ MD_CHANGE_OBJECT_W __RPC_FAR pcoChangeList[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShutdownNotify )( 
            IMSAdminBaseSinkW __RPC_FAR * This);
        
        END_INTERFACE
    } IMSAdminBaseSinkWVtbl;

    interface IMSAdminBaseSinkW
    {
        CONST_VTBL struct IMSAdminBaseSinkWVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IMSAdminBaseSinkW_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IMSAdminBaseSinkW_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IMSAdminBaseSinkW_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IMSAdminBaseSinkW_SinkNotify(This,dwMDNumElements,pcoChangeList)	\
    (This)->lpVtbl -> SinkNotify(This,dwMDNumElements,pcoChangeList)

#define IMSAdminBaseSinkW_ShutdownNotify(This)	\
    (This)->lpVtbl -> ShutdownNotify(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IMSAdminBaseSinkW_SinkNotify_Proxy( 
    IMSAdminBaseSinkW __RPC_FAR * This,
    /* [in] */ DWORD dwMDNumElements,
    /* [size_is][in] */ MD_CHANGE_OBJECT_W __RPC_FAR pcoChangeList[  ]);


void __RPC_STUB IMSAdminBaseSinkW_SinkNotify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IMSAdminBaseSinkW_ShutdownNotify_Proxy( 
    IMSAdminBaseSinkW __RPC_FAR * This);


void __RPC_STUB IMSAdminBaseSinkW_ShutdownNotify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IMSAdminBaseSinkW_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_iadmw_0166
 * at Fri Aug 01 12:56:48 1997
 * using MIDL 3.03.0106
 ****************************************/
/* [local] */ 


#endif


extern RPC_IF_HANDLE __MIDL_itf_iadmw_0166_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_iadmw_0166_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* [local] */ HRESULT STDMETHODCALLTYPE IMSAdminBaseW_SetData_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ PMETADATA_RECORD pmdrMDData);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IMSAdminBaseW_SetData_Stub( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ PMETADATA_RECORD pmdrMDData);

/* [local] */ HRESULT STDMETHODCALLTYPE IMSAdminBaseW_GetData_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [out][in] */ PMETADATA_RECORD pmdrMDData,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IMSAdminBaseW_GetData_Stub( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [out][in] */ PMETADATA_RECORD pmdrMDData,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen,
    /* [out] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *__RPC_FAR *ppDataBlob);

/* [local] */ HRESULT STDMETHODCALLTYPE IMSAdminBaseW_EnumData_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [out][in] */ PMETADATA_RECORD pmdrMDData,
    /* [in] */ DWORD dwMDEnumDataIndex,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IMSAdminBaseW_EnumData_Stub( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [out][in] */ PMETADATA_RECORD pmdrMDData,
    /* [in] */ DWORD dwMDEnumDataIndex,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredDataLen,
    /* [out] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *__RPC_FAR *ppDataBlob);

/* [local] */ HRESULT STDMETHODCALLTYPE IMSAdminBaseW_GetAllData_Proxy( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ DWORD dwMDAttributes,
    /* [in] */ DWORD dwMDUserType,
    /* [in] */ DWORD dwMDDataType,
    /* [out] */ DWORD __RPC_FAR *pdwMDNumDataEntries,
    /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber,
    /* [in] */ DWORD dwMDBufferSize,
    /* [size_is][out] */ unsigned char __RPC_FAR *pbMDBuffer,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IMSAdminBaseW_GetAllData_Stub( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in] */ METADATA_HANDLE hMDHandle,
    /* [string][in][unique] */ LPCWSTR pszMDPath,
    /* [in] */ DWORD dwMDAttributes,
    /* [in] */ DWORD dwMDUserType,
    /* [in] */ DWORD dwMDDataType,
    /* [out] */ DWORD __RPC_FAR *pdwMDNumDataEntries,
    /* [out] */ DWORD __RPC_FAR *pdwMDDataSetNumber,
    /* [in] */ DWORD dwMDBufferSize,
    /* [out] */ DWORD __RPC_FAR *pdwMDRequiredBufferSize,
    /* [out] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *__RPC_FAR *ppDataBlob);

/* [restricted][local] */ HRESULT STDMETHODCALLTYPE IMSAdminBaseW_KeyExchangePhase1_Proxy( 
    IMSAdminBaseW __RPC_FAR * This);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IMSAdminBaseW_KeyExchangePhase1_Stub( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in][unique] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *pClientKeyExchangeKeyBlob,
    /* [in][unique] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *pClientSignatureKeyBlob,
    /* [out] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *__RPC_FAR *ppServerKeyExchangeKeyBlob,
    /* [out] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *__RPC_FAR *ppServerSignatureKeyBlob,
    /* [out] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *__RPC_FAR *ppServerSessionKeyBlob);

/* [restricted][local] */ HRESULT STDMETHODCALLTYPE IMSAdminBaseW_KeyExchangePhase2_Proxy( 
    IMSAdminBaseW __RPC_FAR * This);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IMSAdminBaseW_KeyExchangePhase2_Stub( 
    IMSAdminBaseW __RPC_FAR * This,
    /* [in][unique] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *pClientSessionKeyBlob,
    /* [in][unique] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *pClientHashBlob,
    /* [out] */ struct _IIS_CRYPTO_BLOB __RPC_FAR *__RPC_FAR *ppServerHashBlob);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\cfgmnt\iiscnfg.h ===
/*++

   Copyright (c) 1997 Microsoft Corporation

   Module  Name :

       iiscnfg.h

   Abstract:

        Contains public Metadata IDs used by IIS.

   Environment:

      Win32 User Mode

--*/

#ifndef _IISCNFG_H_
#define _IISCNFG_H_


//
// Paths
//

#define IIS_MD_LOCAL_MACHINE_PATH       "LM"

//
// Name of the default publishing root under an instance
//

#define IIS_MD_INSTANCE_ROOT            "Root"

//
//  ISAPI Filters are kept in a list under the instances and the service (for
//  global filters) in the following format:
//
//  LM/W3Svc/<Instance>/Filters
//      MD_FILTER_LOAD_ORDER  "Filter1, Filter2, Filter3"
//
//  LM/W3Svc/<Instance>/Filters/Filter1
//      MD_FILTER_IMAGE_PATH  "d:\inetsrv\myfilter.dll"
//
//  LM/W3Svc/<Instance>/Filters/Filter2
//      MD_FILTER_IMAGE_PATH  "d:\inetsrv\otherfilter.dll"
//

#define IIS_MD_ISAPI_FILTERS            "/Filters"

//
// user types
//
// There are two user types:
//
//   Server configuration - All the properties for configuring the server that
//      are not applicable to files and directories - such as Port, Host name,
//      Server comment, Connection timeout etc.
//
//  File/Dir configuration - All the properties that can be configured down to
//      the files and directories - such as Access permissions (Read, Write etc),
//      Extension mapping, IP Security etc.
//

#define IIS_MD_UT_SERVER                1   // Server configuration parameters
#define IIS_MD_UT_FILE                  2   // File/Dir inheritable properties
#define IIS_MD_UT_WAM                 100   // Web Application configuration parameters
#define ASP_MD_UT_APP                 101   // ASP application configuration parameters
#define IIS_MD_UT_END_RESERVED       2000   // All user types below this are
                                            // reserved for IIS services


//
//  Metabase property IDs must be unique.  This table defines reserved ranges
//

#define IIS_MD_ID_BEGIN_RESERVED    0x00000001      // IIS reserved range
#define IIS_MD_ID_END_RESERVED      0x00007fff
#define ASP_MD_ID_BEGIN_RESERVED    0x00007000      // ASP reserved range, subrange of IIS.
#define ASP_MD_ID_END_RESERVED      0x000074ff
#define WAM_MD_ID_BEGIN_RESERVED    0x00007500      // ASP reserved range, subrange of IIS.
#define WAM_MD_ID_END_RESERVED      0x00007fff
#define FP_MD_ID_BEGIN_RESERVED     0x00008000      // Front page reserved range
#define FP_MD_ID_END_RESERVED       0x00008fff
#define SMTP_MD_ID_BEGIN_RESERVED   0x00009000      
#define SMTP_MD_ID_END_RESERVED     0x00009fff
#define POP3_MD_ID_BEGIN_RESERVED   0x0000a000      
#define POP3_MD_ID_END_RESERVED     0x0000afff
#define NNTP_MD_ID_BEGIN_RESERVED   0x0000b000      
#define NNTP_MD_ID_END_RESERVED     0x0000bfff
#define IMAP_MD_ID_BEGIN_RESERVED   0x0000c000      
#define IMAP_MD_ID_END_RESERVED     0x0000cfff


//
//  General server related attributes - these should be added in the metabase
//  with a user type of IIS_MD_UT_SERVER
//

#define IIS_MD_SERVER_BASE              1000

//
//  These are global to all services and should only be set at
//  the IIS root
//

#define MD_MAX_BANDWIDTH                (IIS_MD_SERVER_BASE+0  )
#define MD_MEMORY_CACHE_SIZE            (IIS_MD_SERVER_BASE+1  )
#define MD_KEY_TYPE                     (IIS_MD_SERVER_BASE+2  )
#define MD_MAX_BANDWIDTH_BLOCKED        (IIS_MD_SERVER_BASE+3  )

//
//  These properties are applicable to both HTTP and FTP virtual
//  servers
//

// #define MD_spare1                       (IIS_MD_SERVER_BASE+10 )
// #define MD_spare2                       (IIS_MD_SERVER_BASE+11 )
#define MD_SERVER_COMMAND               (IIS_MD_SERVER_BASE+12 )
#define MD_CONNECTION_TIMEOUT           (IIS_MD_SERVER_BASE+13 )
#define MD_MAX_CONNECTIONS              (IIS_MD_SERVER_BASE+14 )
#define MD_SERVER_COMMENT               (IIS_MD_SERVER_BASE+15 )
#define MD_SERVER_STATE                 (IIS_MD_SERVER_BASE+16 )
#define MD_SERVER_AUTOSTART             (IIS_MD_SERVER_BASE+17 )
#define MD_SERVER_SIZE                  (IIS_MD_SERVER_BASE+18 )
#define MD_SERVER_LISTEN_BACKLOG        (IIS_MD_SERVER_BASE+19 )
#define MD_SERVER_LISTEN_TIMEOUT        (IIS_MD_SERVER_BASE+20 )
#define MD_DOWNLEVEL_ADMIN_INSTANCE     (IIS_MD_SERVER_BASE+21 )
#define MD_LEVELS_TO_SCAN               (IIS_MD_SERVER_BASE+22 )
#define MD_SERVER_BINDINGS              (IIS_MD_SERVER_BASE+23 )
#define MD_MAX_ENDPOINT_CONNECTIONS     (IIS_MD_SERVER_BASE+24 )
#define MD_CLUSTER_ENABLED              (IIS_MD_SERVER_BASE+25 )
#define MD_CLUSTER_SERVER_COMMAND       (IIS_MD_SERVER_BASE+26 )
#define MD_SERVER_CONFIGURATION_INFO    (IIS_MD_SERVER_BASE+27 )
#define MD_IISADMIN_EXTENSIONS          (IIS_MD_SERVER_BASE+28 )


//
//  These properties are specific to HTTP and belong to the website
//

#define IIS_MD_HTTP_BASE                2000

#define MD_SECURE_PORT                  (IIS_MD_HTTP_BASE+20 )  // OBSOLETE!
#define MD_SECURE_BINDINGS              (IIS_MD_HTTP_BASE+21 )

#define MD_SSL_MINSTRENGTH              (IIS_MD_HTTP_BASE+30)
#define MD_SSL_ALG                      (IIS_MD_HTTP_BASE+31)
#define MD_SSL_PROTO                    (IIS_MD_HTTP_BASE+32)
#define MD_SSL_CA                       (IIS_MD_HTTP_BASE+33)

#define MD_FILTER_LOAD_ORDER            (IIS_MD_HTTP_BASE+40 )
#define MD_FILTER_IMAGE_PATH            (IIS_MD_HTTP_BASE+41 )
#define MD_FILTER_STATE                 (IIS_MD_HTTP_BASE+42 )
#define MD_FILTER_ENABLED               (IIS_MD_HTTP_BASE+43 )
#define MD_FILTER_FLAGS                 (IIS_MD_HTTP_BASE+44 )
#define MD_FILTER_DESCRIPTION           (IIS_MD_HTTP_BASE+45 )

#define MD_ADV_NOTIFY_PWD_EXP_IN_DAYS   (IIS_MD_HTTP_BASE+63 )
#define MD_ADV_CACHE_TTL                (IIS_MD_HTTP_BASE+64 )
#define MD_NET_LOGON_WKS                (IIS_MD_HTTP_BASE+65 )
#define MD_USE_HOST_NAME                (IIS_MD_HTTP_BASE+66 )
#define MD_AUTH_CHANGE_FLAGS            (IIS_MD_HTTP_BASE+68 )

#define MD_PROCESS_NTCR_IF_LOGGED_ON    (IIS_MD_HTTP_BASE+70 )
#define MD_ENABLE_CLUSTER_SUPPORT       (IIS_MD_HTTP_BASE+71 )

#define MD_FRONTPAGE_WEB                (IIS_MD_HTTP_BASE+72 )
#define MD_IN_PROCESS_ISAPI_APPS        (IIS_MD_HTTP_BASE+73 )


// Empty Slot IIS_MD_HTTP_BASE+100
#define MD_APP_FRIENDLY_NAME			(IIS_MD_HTTP_BASE+102)
#define MD_APP_ROOT                     (IIS_MD_HTTP_BASE+103)
#define MD_APP_ISOLATED                 (IIS_MD_HTTP_BASE+104)
#define MD_APP_WAM_CLSID                (IIS_MD_HTTP_BASE+105)
#define MD_APP_PACKAGE_ID               (IIS_MD_HTTP_BASE+106)
#define MD_APP_PACKAGE_NAME             (IIS_MD_HTTP_BASE+107)
#define MD_APP_LAST_OUTPROC_PID         (IIS_MD_HTTP_BASE+108)
#define MD_APP_STATE					(IIS_MD_HTTP_BASE+109)
#define MD_APP_OOP_CRASH_LIMIT          (IIS_MD_HTTP_BASE+110)

#define MD_ADMIN_INSTANCE               (IIS_MD_HTTP_BASE+115)



#define MD_CUSTOM_ERROR_DESC            (IIS_MD_HTTP_BASE+120)

//
//  Site Server properties
//

#define MD_MD_SERVER_SS_AUTH_MAPPING    (IIS_MD_HTTP_BASE+200)


#define MD_CERT_CHECK_MODE      (IIS_MD_HTTP_BASE+140)

//
// valid values for MD_CERT_CHECK_MODE
//

#define MD_CERT_NO_REVOC_CHECK  0x00000001

//
// Generic property indicating a failure status code - Can be used under
// any component that can fail (virtual directory, filters, applications etc)
//

#define MD_WIN32_ERROR                  (IIS_MD_SERVER_BASE+99 )

//
// Virtual root properties - note MD_ACCESS_PERM is also generally set at
// the virtual directory.  These are used for both HTTP and FTP
//

#define IIS_MD_VR_BASE                  3000

#define MD_VR_PATH                      (IIS_MD_VR_BASE+1 )
#define MD_VR_USERNAME                  (IIS_MD_VR_BASE+2 )
#define MD_VR_PASSWORD                  (IIS_MD_VR_BASE+3 )
#define MD_VR_ACL                       (IIS_MD_VR_BASE+4 )
#define MD_VR_PASSTHROUGH               (IIS_MD_VR_BASE+6 )
//
// This is used to flag down updated vr entries - Used for migrating vroots
//

#define MD_VR_UPDATE                    (IIS_MD_VR_BASE+5 )

//
//  Logging related attributes
//

#define IIS_MD_LOG_BASE                 4000

#define MD_LOG_TYPE                     (IIS_MD_LOG_BASE+0  )
#define MD_LOGFILE_DIRECTORY            (IIS_MD_LOG_BASE+1  )
#define MD_LOG_UNUSED1                  (IIS_MD_LOG_BASE+2  )
#define MD_LOGFILE_PERIOD               (IIS_MD_LOG_BASE+3  )
#define MD_LOGFILE_TRUNCATE_SIZE        (IIS_MD_LOG_BASE+4  )
#define MD_LOG_PLUGIN_MOD_ID            (IIS_MD_LOG_BASE+5  )
#define MD_LOG_PLUGIN_UI_ID             (IIS_MD_LOG_BASE+6  )
#define MD_LOGSQL_DATA_SOURCES          (IIS_MD_LOG_BASE+7  )
#define MD_LOGSQL_TABLE_NAME            (IIS_MD_LOG_BASE+8  )
#define MD_LOGSQL_USER_NAME             (IIS_MD_LOG_BASE+9  )
#define MD_LOGSQL_PASSWORD              (IIS_MD_LOG_BASE+10 )
#define MD_LOG_PLUGIN_ORDER             (IIS_MD_LOG_BASE+11 )
#define MD_LOG_PLUGINS_AVAILABLE        (IIS_MD_LOG_BASE+12 )
#define MD_LOGEXT_FIELD_MASK            (IIS_MD_LOG_BASE+13 )
#define MD_LOGEXT_FIELD_MASK2           (IIS_MD_LOG_BASE+14 )

#define IIS_MD_LOG_LAST                 MD_LOGEXT_FIELD_MASK2

//
// Log type
//

#define MD_LOG_TYPE_DISABLED            0
#define MD_LOG_TYPE_ENABLED             1

//
// LOGGING values
//

#define MD_LOGFILE_PERIOD_NONE      0
#define MD_LOGFILE_PERIOD_MAXSIZE   0
#define MD_LOGFILE_PERIOD_DAILY     1
#define MD_LOGFILE_PERIOD_WEEKLY    2
#define MD_LOGFILE_PERIOD_MONTHLY   3

//
// Field masks for extended logging
//      Fields are logged in order of increasing mask value
//

#define MD_EXTLOG_DATE                  0x00000001
#define MD_EXTLOG_TIME                  0x00000002
#define MD_EXTLOG_CLIENT_IP             0x00000004
#define MD_EXTLOG_USERNAME              0x00000008
#define MD_EXTLOG_SITE_NAME             0x00000010
#define MD_EXTLOG_COMPUTER_NAME         0x00000020
#define MD_EXTLOG_SERVER_IP             0x00000040
#define MD_EXTLOG_METHOD                0x00000080
#define MD_EXTLOG_URI_STEM              0x00000100
#define MD_EXTLOG_URI_QUERY             0x00000200
#define MD_EXTLOG_HTTP_STATUS           0x00000400
#define MD_EXTLOG_WIN32_STATUS          0x00000800
#define MD_EXTLOG_BYTES_SENT            0x00001000
#define MD_EXTLOG_BYTES_RECV            0x00002000
#define MD_EXTLOG_TIME_TAKEN            0x00004000
#define MD_EXTLOG_SERVER_PORT           0x00008000
#define MD_EXTLOG_USER_AGENT            0x00010000
#define MD_EXTLOG_COOKIE                0x00020000
#define MD_EXTLOG_REFERER               0x00040000

#define MD_DEFAULT_EXTLOG_FIELDS        (MD_EXTLOG_CLIENT_IP | \
                                         MD_EXTLOG_TIME      | \
                                         MD_EXTLOG_METHOD    | \
                                         MD_EXTLOG_URI_STEM  | \
                                         MD_EXTLOG_HTTP_STATUS)

//
//  Notification Flags
//

#define MD_NOTIFY_SECURE_PORT           0x00000001
#define MD_NOTIFY_NONSECURE_PORT        0x00000002

#define MD_NOTIFY_READ_RAW_DATA         0x00008000
#define MD_NOTIFY_PREPROC_HEADERS       0x00004000
#define MD_NOTIFY_AUTHENTICATION        0x00002000
#define MD_NOTIFY_URL_MAP               0x00001000
#define MD_NOTIFY_ACCESS_DENIED         0x00000800
#define MD_NOTIFY_SEND_RESPONSE         0x00000040
#define MD_NOTIFY_SEND_RAW_DATA         0x00000400
#define MD_NOTIFY_LOG                   0x00000200
#define MD_NOTIFY_END_OF_REQUEST        0x00000080
#define MD_NOTIFY_END_OF_NET_SESSION    0x00000100

//
//  Filter ordering flags
//

#define MD_NOTIFY_ORDER_HIGH            0x00080000
#define MD_NOTIFY_ORDER_MEDIUM          0x00040000
#define MD_NOTIFY_ORDER_LOW             0x00020000
#define MD_NOTIFY_ORDER_DEFAULT         MD_NOTIFY_ORDER_LOW

#define MD_NOTIFY_ORDER_MASK            (MD_NOTIFY_ORDER_HIGH   |    \
                                         MD_NOTIFY_ORDER_MEDIUM |    \
                                         MD_NOTIFY_ORDER_LOW)


//
//  These are FTP specific properties
//

#define IIS_MD_FTP_BASE                 5000

#define MD_EXIT_MESSAGE                 (IIS_MD_FTP_BASE+1  )
#define MD_GREETING_MESSAGE             (IIS_MD_FTP_BASE+2  )
#define MD_MAX_CLIENTS_MESSAGE          (IIS_MD_FTP_BASE+3  )
#define MD_MSDOS_DIR_OUTPUT             (IIS_MD_FTP_BASE+4  )
#define MD_ALLOW_ANONYMOUS              (IIS_MD_FTP_BASE+5  )
#define MD_ANONYMOUS_ONLY               (IIS_MD_FTP_BASE+6  )
#define MD_LOG_ANONYMOUS                (IIS_MD_FTP_BASE+7  )
#define MD_LOG_NONANONYMOUS             (IIS_MD_FTP_BASE+8  )
#define MD_ALLOW_REPLACE_ON_RENAME      (IIS_MD_FTP_BASE+9  )


//
//  These are SSL specific properties
//

#define IIS_MD_SSL_BASE                 5500

#define MD_SSL_PUBLIC_KEY               ( IIS_MD_SSL_BASE+0 )
#define MD_SSL_PRIVATE_KEY              ( IIS_MD_SSL_BASE+1 )
#define MD_SSL_KEY_PASSWORD             ( IIS_MD_SSL_BASE+2 )
#define MD_SSL_KEY_REQUEST              ( IIS_MD_SSL_BASE+3 )
#define MD_SSL_FRIENDLY_NAME            ( IIS_MD_SSL_BASE+4 )
#define MD_SSL_IDENT                    ( IIS_MD_SSL_BASE+5 )


//
//  File and Directory related properties - these should be added in the
//  metabase with a user type of IIS_MD_UT_FILE
//

#define IIS_MD_FILE_PROP_BASE           6000

#define MD_AUTHORIZATION                (IIS_MD_FILE_PROP_BASE )
#define MD_REALM                        (IIS_MD_FILE_PROP_BASE+1 )
#define MD_HTTP_EXPIRES                 (IIS_MD_FILE_PROP_BASE+2 )
#define MD_HTTP_PICS                    (IIS_MD_FILE_PROP_BASE+3 )
#define MD_HTTP_CUSTOM                  (IIS_MD_FILE_PROP_BASE+4 )
#define MD_DIRECTORY_BROWSING           (IIS_MD_FILE_PROP_BASE+5 )
#define MD_DEFAULT_LOAD_FILE            (IIS_MD_FILE_PROP_BASE+6 )
#define MD_CONTENT_NEGOTIATION          (IIS_MD_FILE_PROP_BASE+7 )
#define MD_CUSTOM_ERROR                 (IIS_MD_FILE_PROP_BASE+8 )
#define MD_FOOTER_DOCUMENT              (IIS_MD_FILE_PROP_BASE+9 )
#define MD_FOOTER_ENABLED               (IIS_MD_FILE_PROP_BASE+10 )
#define MD_HTTP_REDIRECT                (IIS_MD_FILE_PROP_BASE+11 )
#define MD_DEFAULT_LOGON_DOMAIN         (IIS_MD_FILE_PROP_BASE+12 )
#define MD_LOGON_METHOD                 (IIS_MD_FILE_PROP_BASE+13 )
#define MD_SCRIPT_MAPS                  (IIS_MD_FILE_PROP_BASE+14 )
#define MD_MIME_MAP                     (IIS_MD_FILE_PROP_BASE+15 )
#define MD_ACCESS_PERM                  (IIS_MD_FILE_PROP_BASE+16 )
#define MD_HEADER_DOCUMENT              (IIS_MD_FILE_PROP_BASE+17 )
#define MD_HEADER_ENABLED               (IIS_MD_FILE_PROP_BASE+18 )
#define MD_IP_SEC                       (IIS_MD_FILE_PROP_BASE+19 )
#define MD_ANONYMOUS_USER_NAME          (IIS_MD_FILE_PROP_BASE+20 )
#define MD_ANONYMOUS_PWD                (IIS_MD_FILE_PROP_BASE+21 )
#define MD_ANONYMOUS_USE_SUBAUTH        (IIS_MD_FILE_PROP_BASE+22 )
#define MD_DONT_LOG                     (IIS_MD_FILE_PROP_BASE+23 )
#define MD_ADMIN_ACL                    (IIS_MD_FILE_PROP_BASE+27 )
#define MD_SSI_EXEC_DISABLED            (IIS_MD_FILE_PROP_BASE+28 )
#define MD_DO_REVERSE_DNS               (IIS_MD_FILE_PROP_BASE+29 )
#define MD_SSL_ACCESS_PERM              (IIS_MD_FILE_PROP_BASE+30 )
#define MD_AUTHORIZATION_PERSISTENCE    (IIS_MD_FILE_PROP_BASE+31 )
#define MD_NTAUTHENTICATION_PROVIDERS   (IIS_MD_FILE_PROP_BASE+32 )
#define MD_SCRIPT_TIMEOUT               (IIS_MD_FILE_PROP_BASE+33 )
#define MD_CACHE_EXTENSIONS             (IIS_MD_FILE_PROP_BASE+34 )
#define MD_CREATE_PROCESS_AS_USER       (IIS_MD_FILE_PROP_BASE+35 )
#define MD_CREATE_PROC_NEW_CONSOLE      (IIS_MD_FILE_PROP_BASE+36 )
#define MD_POOL_IDC_TIMEOUT             (IIS_MD_FILE_PROP_BASE+37 )
#define MD_ALLOW_KEEPALIVES             (IIS_MD_FILE_PROP_BASE+38 )
#define MD_IS_CONTENT_INDEXED           (IIS_MD_FILE_PROP_BASE+39 )
#define MD_NOTIFY_EXAUTH                (IIS_MD_FILE_PROP_BASE+40 )
#define MD_CC_NO_CACHE                  (IIS_MD_FILE_PROP_BASE+41 )
#define MD_CC_MAX_AGE                   (IIS_MD_FILE_PROP_BASE+42 )
#define MD_CC_OTHER                     (IIS_MD_FILE_PROP_BASE+43 )
#define MD_REDIRECT_HEADERS             (IIS_MD_FILE_PROP_BASE+44 )
#define MD_UPLOAD_READAHEAD_SIZE        (IIS_MD_FILE_PROP_BASE+45 )
#define MD_PUT_READ_SIZE                (IIS_MD_FILE_PROP_BASE+46 )


#define ASP_MD_SERVER_BASE                  7000

#define MD_ASP_BUFFERINGON                  (ASP_MD_SERVER_BASE + 0)
#define MD_ASP_LOGERRORREQUESTS             (ASP_MD_SERVER_BASE + 1)
#define MD_ASP_SCRIPTERRORSSENTTOBROWSER    (ASP_MD_SERVER_BASE + 2)
#define MD_ASP_SCRIPTERRORMESSAGE           (ASP_MD_SERVER_BASE + 3)
#define MD_ASP_SCRIPTFILECACHESIZE          (ASP_MD_SERVER_BASE + 4)
#define MD_ASP_SCRIPTENGINECACHEMAX         (ASP_MD_SERVER_BASE + 5)
#define MD_ASP_SCRIPTTIMEOUT                (ASP_MD_SERVER_BASE + 6)
#define MD_ASP_SESSIONTIMEOUT               (ASP_MD_SERVER_BASE + 7)
#define MD_ASP_ENABLEPARENTPATHS            (ASP_MD_SERVER_BASE + 8)
#define MD_ASP_MEMFREEFACTOR                (ASP_MD_SERVER_BASE + 9)
#define MD_ASP_MINUSEDBLOCKS                (ASP_MD_SERVER_BASE + 10)
#define MD_ASP_ALLOWSESSIONSTATE            (ASP_MD_SERVER_BASE + 11)
#define MD_ASP_SCRIPTLANGUAGE               (ASP_MD_SERVER_BASE + 12)
// Empty slot
#define MD_ASP_ALLOWOUTOFPROCCMPNTS         (ASP_MD_SERVER_BASE + 14)
#define MD_ASP_ALLOWOUTOFPROCCOMPONENTS     (MD_ASP_ALLOWOUTOFPROCCMPNTS)
#define MD_ASP_EXCEPTIONCATCHENABLE         (ASP_MD_SERVER_BASE + 15)
#define MD_ASP_CODEPAGE                     (ASP_MD_SERVER_BASE + 16)
#define MD_ASP_SCRIPTLANGUAGELIST           (ASP_MD_SERVER_BASE + 17)
#define MD_ASP_ENABLESERVERDEBUG            (ASP_MD_SERVER_BASE + 18)
#define MD_ASP_ENABLECLIENTDEBUG            (ASP_MD_SERVER_BASE + 19)
#define MD_ASP_TRACKTHREADINGMODEL          (ASP_MD_SERVER_BASE + 20)

#define MD_ASP_ID_LAST                      (ASP_MD_SERVER_BASE + 20)

//
//  Valid values for WAM
//
#define WAM_MD_SERVER_BASE                  7500

#define MD_WAM_USER_NAME                (WAM_MD_SERVER_BASE+1)
#define MD_WAM_PWD                      (WAM_MD_SERVER_BASE+2)

//
//  Valid values for MD_AUTHORIZATION
//

#define MD_AUTH_ANONYMOUS               0x00000001
#define MD_AUTH_BASIC                   0x00000002
#define MD_AUTH_NT                      0x00000004    // Use NT auth provider (like NTLM)
#define MD_AUTH_MD5                     0x00000010
#define MD_AUTH_MAPBASIC                0x00000020

//
//  Valid values for MD_AUTHORIZATION_PERSISTENCE
//


#define MD_AUTH_SINGLEREQUEST           0x00000040
#define MD_AUTH_SINGLEREQUESTIFPROXY    0x00000080

//
//  Valid values for MD_ACCESS_PERM
//

#define MD_ACCESS_READ                  0x00000001    // Allow for Read
#define MD_ACCESS_WRITE                 0x00000002    // Allow for Write
#define MD_ACCESS_EXECUTE               0x00000004    // Allow for Execute
#define MD_ACCESS_SCRIPT                0x00000200    // Allow for Script execution
#define MD_ACCESS_NO_REMOTE_WRITE       0x00000400    // Local host access only
#define MD_ACCESS_NO_REMOTE_READ        0x00001000    // Local host access only
#define MD_ACCESS_NO_REMOTE_EXECUTE     0x00002000    // Local host access only
#define MD_ACCESS_NO_REMOTE_SCRIPT      0x00004000    // Local host access only

#define MD_NONSLL_ACCESS_MASK           (MD_ACCESS_READ|                \
                                         MD_ACCESS_WRITE|               \
                                         MD_ACCESS_EXECUTE|             \
                                         MD_ACCESS_SCRIPT|              \
                                         MD_ACCESS_NO_REMOTE_READ|      \
                                         MD_ACCESS_NO_REMOTE_WRITE|     \
                                         MD_ACCESS_NO_REMOTE_EXECUTE|   \
                                         MD_ACCESS_NO_REMOTE_SCRIPT     \
                                         )
//
//  Valid values for MD_SSL_ACCESS_PERM
//

#define MD_ACCESS_SSL                   0x00000008    // Require SSL
#define MD_ACCESS_NEGO_CERT             0x00000020    // Allow client SSL certs
#define MD_ACCESS_REQUIRE_CERT          0x00000040    // Require client SSL certs
#define MD_ACCESS_MAP_CERT              0x00000080    // Map SSL cert to NT account
#define MD_ACCESS_SSL128                0x00000100    // Require 128 bit SSL

#define MD_SSL_ACCESS_MASK              (MD_ACCESS_SSL|\
                                         MD_ACCESS_NEGO_CERT|\
                                         MD_ACCESS_REQUIRE_CERT|\
                                         MD_ACCESS_MAP_CERT|\
                                         MD_ACCESS_SSL128)

#define MD_ACCESS_MASK                  0x00007fff

//
//  Valid values for MD_DIRECTORY_BROWSING
//

#define MD_DIRBROW_SHOW_DATE            0x00000002
#define MD_DIRBROW_SHOW_TIME            0x00000004
#define MD_DIRBROW_SHOW_SIZE            0x00000008
#define MD_DIRBROW_SHOW_EXTENSION       0x00000010
#define MD_DIRBROW_LONG_DATE            0x00000020

#define MD_DIRBROW_ENABLED              0x80000000  // Allow directory browsing
#define MD_DIRBROW_LOADDEFAULT          0x40000000  // Load default doc if exists

#define MD_DIRBROW_MASK                 (MD_DIRBROW_SHOW_DATE      |    \
                                         MD_DIRBROW_SHOW_TIME      |    \
                                         MD_DIRBROW_SHOW_SIZE      |    \
                                         MD_DIRBROW_SHOW_EXTENSION |    \
                                         MD_DIRBROW_LONG_DATE      |    \
                                         MD_DIRBROW_LOADDEFAULT    |    \
                                         MD_DIRBROW_ENABLED)



//
//  Valid values for MD_LOGON_METHOD
//

#define MD_LOGON_INTERACTIVE    0
#define MD_LOGON_BATCH          1
#define MD_LOGON_NETWORK        2

//
// Valid values for MD_NOTIFY_EXAUTH
//

#define MD_NOTIFEXAUTH_NTLMSSL  1

//
//  Valid values for MD_FILTER_STATE
//

#define MD_FILTER_STATE_LOADED          1
#define MD_FILTER_STATE_UNLOADED        4

//
//  Valid values for MD_SERVER_STATE
//

#define MD_SERVER_STATE_STARTING        1
#define MD_SERVER_STATE_STARTED         2
#define MD_SERVER_STATE_STOPPING        3
#define MD_SERVER_STATE_STOPPED         4
#define MD_SERVER_STATE_PAUSING         5
#define MD_SERVER_STATE_PAUSED          6
#define MD_SERVER_STATE_CONTINUING      7

//
//  Valid values for MD_SERVER_COMMAND
//

#define MD_SERVER_COMMAND_START         1
#define MD_SERVER_COMMAND_STOP          2
#define MD_SERVER_COMMAND_PAUSE         3
#define MD_SERVER_COMMAND_CONTINUE      4

//
//  Valid values for MD_SERVER_SIZE
//

#define MD_SERVER_SIZE_SMALL            0
#define MD_SERVER_SIZE_MEDIUM           1
#define MD_SERVER_SIZE_LARGE            2

//
// Valid values for MD_SERVER_CONFIG_INFO
//

#define MD_SERVER_CONFIG_SSL_40         0x00000001
#define MD_SERVER_CONFIG_SSL_128        0x00000002
#define MD_SERVER_CONFIG_ALLOW_ENCRYPT  0x00000004
#define MD_SERVER_CONFIG_AUTO_PW_SYNC   0x00000008

#define MD_SERVER_CONFIGURATION_MASK   (MD_SERVER_CONFIG_SSL_40       | \
                                        MD_SERVER_CONFIG_SSL_128      | \
                                        MD_SERVER_CONFIG_ENCRYPT      | \
                                        MD_SERVER_CONFIG_AUTO_PW_SYNC)

//
// Valid values for MD_SCRIPT_MAPS flag field
//

#define MD_SCRIPTMAPFLAG_SCRIPT                     0x00000001
#define MD_SCRIPTMAPFLAG_CHECK_PATH_INFO            0x00000004

//
//  Bogus value - do not use
//
#define MD_SCRIPTMAPFLAG_ALLOWED_ON_READ_DIR        0x00000001


//
// Valid values for MD_AUTH_CHANGE_ENABLE
//

#define MD_AUTH_CHANGE_UNSECURE     0x00000001
#define MD_AUTH_CHANGE_DISABLE      0x00000002
#define MD_AUTH_ADVNOTIFY_DISABLE   0x00000004

//
// Valid values for MD_NET_LOGON_WKS
//

#define MD_NETLOGON_WKS_NONE        0
#define MD_NETLOGON_WKS_IP          1
#define MD_NETLOGON_WKS_DNS         2

//
//  Valide substatus errors for MD_CUSTOM_ERROR
//

#define MD_ERROR_SUB401_LOGON                   1
#define MD_ERROR_SUB401_LOGON_CONFIG            2
#define MD_ERROR_SUB401_LOGON_ACL               3
#define MD_ERROR_SUB401_FILTER                  4
#define MD_ERROR_SUB401_APPLICATION             5

#define MD_ERROR_SUB403_EXECUTE_ACCESS_DENIED   1
#define MD_ERROR_SUB403_READ_ACCESS_DENIED      2
#define MD_ERROR_SUB403_WRITE_ACCESS_DENIED     3
#define MD_ERROR_SUB403_SSL_REQUIRED            4
#define MD_ERROR_SUB403_SSL128_REQUIRED         5
#define MD_ERROR_SUB403_ADDR_REJECT             6
#define MD_ERROR_SUB403_CERT_REQUIRED           7
#define MD_ERROR_SUB403_SITE_ACCESS_DENIED      8
#define MD_ERROR_SUB403_TOO_MANY_USERS          9
#define MD_ERROR_SUB403_INVALID_CNFG           10
#define MD_ERROR_SUB403_PWD_CHANGE             11
#define MD_ERROR_SUB403_MAPPER_DENY_ACCESS     12
#define MD_ERROR_SUB403_CA_NOT_ALLOWED         13

#define MD_ERROR_SUB502_TIMEOUT                 1
#define MD_ERROR_SUB502_PREMATURE_EXIT          2

//
// Delimiter in MD_VR_PATH
//

#define MD_VR_PATH_DELIMITER        '|'
#define MD_VR_PATH_DELIMITER_STRING     "|"

#if 0

// NEED ISAPI App updates

#endif

//
// MD_IP_SEC binary format description
//

/*

  This object is composed of 4 lists : 2 lists ( deny & grant ) of network addresses,
  the only allowed family is AF_INET.
  Each of this list is composed of sublists, one for each ( network address family,
  significant subnet mask ) combination. The significant subnet mask is stored as
  ( number of bytes all 1 ( 0xff ), bitmask in last byte ).
  This is followed by 2 lists ( deny & grant ) of DNS names. Each of these lists is
  composed of sublists, based on then number of components in the DNS name
  e.g. "microsoft.com" has 2 components, "www.msft.com" has 3.

Header:
    SELFREFINDEX    iDenyAddr;      // address deny list
                                    // points to ADDRESS_HEADER
    SELFREFINDEX    iGrantAddr;     // address grant list
                                    // points to ADDRESS_HEADER
    SELFREFINDEX    iDenyName;      // DNS name deny list
                                    // points to NAME_HEADER
    SELFREFINDEX    iGrantName;     // DNS name grant list
                                    // points to NAME_HEADER
    DWORD           dwFlags;
    DWORD           cRefSize;       // size of reference area ( in bytes )

ADDRESS_HEADER :
    DWORD               cEntries;   // # of Entries[]
    DWORD               cAddresses; // total # of addresses in all
                                    // ADDRESS_LIST_ENTRY
    ADDRESS_LIST_ENTRY  Entries[];

ADDRESS_LIST_ENTRY :
    DWORD           iFamily;
    DWORD           cAddresses;
    DWORD           cFullBytes;
    DWORD           LastByte;
    SELFREFINDEX    iFirstAddress;  // points to array of addresses

NAME_HEADER :
    DWORD           cEntries;
    DWORD           cNames;         // total # of names for all Entries[]
    NAME_LIST_ENTRY Entries[];

Name list entry :
    DWORD           cComponents;    // # of DNS components
    DWORD           cNames;
    SELFREFINDEX    iName[];        // array of references to DNS names

This is followed by address arrays & names pointed to by iFirstAddress & iName
Names are '\0' delimited

SELFREFINDEX is a DWORD offset from start of structure with high bit set to 1

*/

//
// Macros
//

#define MD_SET_DATA_RECORD(_pMDR, _id, _attr, _utype, _dtype, _dlen, _pData) \
            { \
            (_pMDR)->dwMDIdentifier=(_id);      \
            (_pMDR)->dwMDAttributes=(_attr);    \
            (_pMDR)->dwMDUserType=(_utype);     \
            (_pMDR)->dwMDDataType=(_dtype);     \
            (_pMDR)->dwMDDataLen=(_dlen);       \
            (_pMDR)->pbMDData=(LPBYTE)(_pData); \
            }

#endif // _IISCNFG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\cfgmnt\locks.h ===
//*****************************************************************************
// locks.h
//
// This class provides a number of locking primitives for multi-threaded
// programming.  The main class of interest are:
//	CCritLock			Critical section based lock wrapper class.
//	CExclLock			A Spin lock class for classic test & set behavior.
//  CSingleLock			A spin lock with no nesting capabilities.
//	CAutoLock			A helper class to lock/unlock in ctor/dtor.
//
//	CMReadSWrite		A highly efficient lock for multiple readers and
//							single writer behavior.
//	CAutoReadLock		A helper for read locking in ctor/dtor.
//	CAutoWriteLock		A helper for write locking in ctor/dtor.
//
// Copyright (c) 1996, Microsoft Corp.  All rights reserved.
//*****************************************************************************
#ifndef __LOCKS_H__
#define __LOCKS_H__


//*****************************************************************************
// This lock implements a spin lock that does not support nesting.  It is very
// lean because of this, but locks cannot be nested.
//*****************************************************************************
class CSingleLock
{
	long volatile	m_iLock;				// Test and set spin value.

public:
	inline CSingleLock() :
		m_iLock(0)
	{ }
	
	inline ~CSingleLock()
	{ 
		m_iLock = 0; 
	}
	
//*****************************************************************************
// This version spins forever until it wins.  Nested calls to Lock from the
// same thread are not supported.
//*****************************************************************************
	inline void Lock()
	{
		// Spin until we win.
		while (InterlockedExchange((long*)&m_iLock, 1L) == 1L)
			;
	}
	
//*****************************************************************************
// This version spins until it wins or times out.  Nested calls to Lock from 
// the same thread are supported.
//*****************************************************************************
	HRESULT	 Lock(						// S_OK, or E_FAIL.
		DWORD	dwTimeout)				// Millisecond timeout value, 0 is forever.
	{
		DWORD		dwTime = 0;

		// Keep spinning until we get the lock.
		while (InterlockedExchange((long*)&m_iLock, 1L) == 1L)
		{
			// Wait for 1/10 a second.
			Sleep(100);

			// See if we have gone over the timeout value.
			if (dwTimeout)
			{
				if ((dwTime += 100) >= dwTimeout)
					return (E_FAIL);
			}
		}
		return (S_OK);
	}
	
//*****************************************************************************
// Assigning to 0 is thread safe and yields much faster performance than
// an Interlocked* operation.
//*****************************************************************************
	inline void Unlock()
	{ 
		m_iLock = 0; 
	}
};



//*****************************************************************************
// This lock class is based on NT's critical sections and has all of their
// semantics.
//*****************************************************************************
class CCritLock
{
private:
	CRITICAL_SECTION m_sCrit;			// The critical section to block on.
	#ifdef _DEBUG
	BOOL			m_bInit;			// Track init status.
	int				m_iLocks;			// Count of locks.
	#endif

public:
	inline CCritLock()
	{ 
		#ifdef _DEBUG
		m_bInit = TRUE;
		m_iLocks = 0;
		#endif
		InitializeCriticalSection(&m_sCrit); 
	}
	
	inline ~CCritLock()
	{ 
		_ASSERTE(m_bInit);
		_ASSERTE(m_iLocks == 0);
		DeleteCriticalSection(&m_sCrit); 
	}
	
	inline void Lock()
	{ 
		_ASSERTE(m_bInit);
		EnterCriticalSection(&m_sCrit); 
		_ASSERTE(++m_iLocks > 0);
	}

	inline void Unlock()
	{
		_ASSERTE(m_bInit);
		_ASSERTE(--m_iLocks >= 0);
		LeaveCriticalSection(&m_sCrit);
	}

#ifdef _DEBUG
	inline int GetLockCnt()
		{ return (m_iLocks); }
	inline BOOL IsLocked()
		{ return (m_iLocks != 0); }
#endif
};



//*****************************************************************************
// Provides a mututal exclusion lock for a resource through a spin lock.  This
// type of lock does not keep a queue, so thread starvation is theoretically
// possible.  In addition, thread priority could cause a potential dead lock if
// a low priority thread got the lock but didn't get enough time to eventually
// free it.
// NOTE: There is a bug in the Pentium cache that InterlockedExchange will
//	force a cache flush of the value.  For this reason, doing an assignment
//	to free the lock is much, much faster than using an Interlocked instruction.
//*****************************************************************************
class CExclLock
{
	long volatile m_iLock;				// Test and set spin value.
	long		m_iNest;				// Nesting count.
	DWORD		m_iThreadId;			// The thread that owns the lock.

public:
	inline CExclLock() :
		m_iLock(0),
		m_iNest(0),
		m_iThreadId(0)
	{ }
	
	inline ~CExclLock()
	{ 
		m_iNest = 0;
		m_iThreadId = 0;
		m_iLock = 0; 
	}
	
//*****************************************************************************
// This version spins forever until it wins.  Nested calls to Lock from the
// same thread are supported.
//*****************************************************************************
	inline void Lock()
	{
		DWORD		iThread;			// Local thread ID.

		// Allow nested calls to lock in the same thread.
		if ((iThread = GetCurrentThreadId()) == m_iThreadId && m_iLock)
		{
			++m_iNest;
			return;
		}

		// Spin until we win.
		while (InterlockedExchange((long*)&m_iLock, 1L) == 1L)
			;

		// Store our thread ID and nesting count now that we've won.
		m_iThreadId = iThread;
		m_iNest = 1;
	}
	
//*****************************************************************************
// This version spins until it wins or times out.  Nested calls to Lock from 
// the same thread are supported.
//*****************************************************************************
	HRESULT	 Lock(						// S_OK, or E_FAIL.
		DWORD	dwTimeout)				// Millisecond timeout value, 0 is forever.
	{
		DWORD		dwTime = 0;
		DWORD		iThread;			// Local thread ID.

		// Allow nested calls to lock in the same thread.
		if (m_iLock && (iThread = GetCurrentThreadId()) == m_iThreadId)
		{
			++m_iNest;
			return (S_OK);
		}

		// Keep spinning until we get the lock.
		while (InterlockedExchange((long*)&m_iLock, 1L) == 1L)
		{
			// Wait for 1/10 a second.
			Sleep(100);

			// See if we have gone over the timeout value.
			if (dwTimeout)
			{
				if ((dwTime += 100) >= dwTimeout)
					return (E_FAIL);
			}
		}

		// Store our thread ID and nesting count now that we've won.
		m_iThreadId = iThread;
		m_iNest = 1;
		return (S_OK);
	}
	
//*****************************************************************************
// Assigning to 0 is thread safe and yields much faster performance than
// an Interlocked* operation.
//*****************************************************************************
	inline void Unlock()
	{ 
		_ASSERTE(m_iThreadId == GetCurrentThreadId() && m_iNest > 0);
		
		// Unlock outer nesting level.
		if (--m_iNest == 0)
		{
			m_iThreadId = 0;
			m_iLock = 0; 
		}
	}

#ifdef _DEBUG
	inline BOOL IsLocked()
		{ return (m_iLock); }
#endif
};



//*****************************************************************************
// This helper class automatically locks the given lock object in the ctor and
// frees it in the dtor.  This makes your code slightly cleaner by not 
// requiring an unlock in all failure conditions.
//*****************************************************************************
class CAutoLock
{
	CExclLock		*m_psLock;			// The lock object to free up.
	CCritLock		*m_psCrit;			// Crit lock.
	CSingleLock		*m_psSingle;		// Single non-nested lock.
	int				m_iNest;			// Nesting count for the item.

public:
//*****************************************************************************
// Use this ctor with the assignment operators to do deffered locking.
//*****************************************************************************
	CAutoLock() :
		m_psLock(NULL),
		m_psCrit(NULL),
		m_psSingle(NULL),
		m_iNest(0)
	{
	}

//*****************************************************************************
// This version handles a spin lock.
//*****************************************************************************
	CAutoLock(CExclLock *psLock) :
		m_psLock(psLock),
		m_psCrit(NULL),
		m_psSingle(NULL),
		m_iNest(1)
	{ 
		_ASSERTE(psLock != NULL);
		psLock->Lock();
	}
	
//*****************************************************************************
// This version handles a critical section lock.
//*****************************************************************************
	CAutoLock(CCritLock *psLock) :
		m_psLock(NULL),
		m_psCrit(psLock),
		m_psSingle(NULL),
		m_iNest(1)
	{ 
		_ASSERTE(psLock != NULL);
		psLock->Lock();
	}
	
//*****************************************************************************
// This version handles a critical section lock.
//*****************************************************************************
	CAutoLock(CSingleLock *psLock) :
		m_psLock(NULL),
		m_psCrit(NULL),
		m_psSingle(psLock),
		m_iNest(1)
	{ 
		_ASSERTE(psLock != NULL);
		psLock->Lock();
	}

//*****************************************************************************
// Free the lock we actually have.
//*****************************************************************************
	~CAutoLock()
	{
		// If we actually took a lock, unlock it.
		if (m_iNest != 0)
		{
			if (m_psLock)
			{
				while (m_iNest--)
					m_psLock->Unlock();
			}
			else if (m_psCrit)
			{
				while (m_iNest--)
					m_psCrit->Unlock();
			}
			else if (m_psSingle)
			{
				while (m_iNest--)
					m_psSingle->Unlock();
			}
		}
	}

//*****************************************************************************
// Lock after ctor runs with NULL.
//*****************************************************************************
	void Lock(
		CSingleLock *psLock)
	{
		m_psSingle = psLock;
		psLock->Lock();
		m_iNest = 1;
	}

//*****************************************************************************
// Assignment causes a lock to occur.  dtor will free the lock.  Nested
// assignments are allowed.
//*****************************************************************************
	CAutoLock & operator=(				// Reference to this class.
		CExclLock	*psLock)			// The lock.
	{
		_ASSERTE(m_psCrit == NULL && m_psSingle == NULL);
		++m_iNest;
		m_psLock = psLock;
		psLock->Lock();
		return (*this);
	}

//*****************************************************************************
// Assignment causes a lock to occur.  dtor will free the lock.  Nested
// assignments are allowed.
//*****************************************************************************
	CAutoLock & operator=(				// Reference to this class.
		CCritLock	*psLock)			// The lock.
	{
		_ASSERTE(m_psSingle == NULL && m_psLock == NULL);
		++m_iNest;
		m_psCrit = psLock;
		psLock->Lock();
		return (*this);
	}

//*****************************************************************************
// Assignment causes a lock to occur.  dtor will free the lock.  Nested
// assignments are allowed.
//*****************************************************************************
	CAutoLock & operator=(				// Reference to this class.
		CSingleLock	*psLock)			// The lock.
	{
		_ASSERTE(m_psCrit == NULL && m_psLock == NULL);
		++m_iNest;
		m_psSingle = psLock;
		psLock->Lock();
		return (*this);
	}
};

#endif //  __LOCKS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\cfgmnt\mt.cpp ===
// MT.cpp: implementation of the CMT class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "MT.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CMT::CMT()
{

}

CMT::~CMT()
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\cfgmnt\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by CfgMnt.rc
//
#define IDS_PROJNAME                    100
#define IDR_CfgMnt                      100
#define IDR_CFGMNTADMIN                 101
#define IDR_CfgMntVersions              102
#define IDS_CFGMNTVERSIONS_DESC         103

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           105
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\cfgmnt\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\cfgmnt\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__0F219CB5_15C1_11D1_A449_00C04FB99B01__INCLUDED_)
#define AFX_STDAFX_H__0F219CB5_15C1_11D1_A449_00C04FB99B01__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define STRICT


#define _WIN32_WINNT 0x0400
#define _ATL_APARTMENT_THREADED

#define UNICODE
#ifndef _MT
#error "Use Multithreaded run-time library"
#endif
#include <crtdbg.h>
#include <string>
using namespace std;

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
class CExeModule : public CComModule
{
public:
	LONG Unlock();
	DWORD dwThreadID;
};
extern CExeModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__0F219CB5_15C1_11D1_A449_00C04FB99B01__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\cfgmnt\ssauto.h ===
/* This header file machine-generated by mktyplib.exe */
/* Interface to type library: SourceSafeTypeLib */

#ifndef _SourceSafeTypeLib_H_
#define _SourceSafeTypeLib_H_

DEFINE_GUID(LIBID_SourceSafeTypeLib,0x783CD4E0L,0x9D54,0x11CF,0xB8,0xEE,0x00,0x60,0x8C,0xC9,0xA7,0x1F);
#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif

typedef enum _VSSFlags {
    VSSFLAG_USERRONO = 1,
    VSSFLAG_USERROYES = 2,
    VSSFLAG_TIMENOW = 4,
    VSSFLAG_TIMEMOD = 8,
    VSSFLAG_TIMEUPD = 12,
    VSSFLAG_EOLCR = 16,
    VSSFLAG_EOLLF = 32,
    VSSFLAG_EOLCRLF = 48,
    VSSFLAG_REPASK = 64,
    VSSFLAG_REPREPLACE = 128,
    VSSFLAG_REPSKIP = 192,
    VSSFLAG_REPMERGE = 256,
    VSSFLAG_CMPFULL = 512,
    VSSFLAG_CMPTIME = 1024,
    VSSFLAG_CMPCHKSUM = 1536,
    VSSFLAG_CMPFAIL = 2048,
    VSSFLAG_RECURSNO = 4096,
    VSSFLAG_RECURSYES = 8192,
    VSSFLAG_FORCEDIRNO = 16384,
    VSSFLAG_FORCEDIRYES = 32768,
    VSSFLAG_KEEPNO = 65536,
    VSSFLAG_KEEPYES = 131072,
    VSSFLAG_DELNO = 262144,
    VSSFLAG_DELYES = 524288,
    VSSFLAG_DELNOREPLACE = 786432,
    VSSFLAG_BINTEST = 1048576,
    VSSFLAG_BINBINARY = 2097152,
    VSSFLAG_BINTEXT = 3145728,
    VSSFLAG_DELTAYES = 4194304,
    VSSFLAG_DELTANO = 8388608,
    VSSFLAG_UPDASK = 16777216,
    VSSFLAG_UPDUPDATE = 33554432,
    VSSFLAG_UPDUNCH = 50331648,
    VSSFLAG_GETYES = 67108864,
    VSSFLAG_GETNO = 134217728,
    VSSFLAG_CHKEXCLUSIVEYES = 268435456,
    VSSFLAG_CHKEXCLUSIVENO = 536870912,
    VSSFLAG_HISTIGNOREFILES = 1073741824
} VSSFlags;

typedef enum _VSSFileStatus {
    VSSFILE_NOTCHECKEDOUT = 0,
    VSSFILE_CHECKEDOUT = 1,
    VSSFILE_CHECKEDOUT_ME = 2
} VSSFileStatus;

typedef enum _VSSItemType {
    VSSITEM_PROJECT = 0,
    VSSITEM_FILE = 1
} VSSItemType;

interface IVSSItems;

interface IVSSVersions;

interface IVSSVersion;

interface IVSSCheckouts;

interface IVSSCheckout;

DEFINE_GUID(IID_IVSSItem,0x783CD4E1L,0x9D54,0x11CF,0xB8,0xEE,0x00,0x60,0x8C,0xC9,0xA7,0x1F);

/* Definition of interface: IVSSItem */
#undef INTERFACE
#define INTERFACE IVSSItem

DECLARE_INTERFACE_(IVSSItem, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IVSSItem methods */
    STDMETHOD(get_Spec)(THIS_ BSTR FAR* pSpec) PURE;
    STDMETHOD(get_Binary)(THIS_ VARIANT_BOOL FAR* pbBinary) PURE;
    STDMETHOD(put_Binary)(THIS_ VARIANT_BOOL bBinary) PURE;
    STDMETHOD(get_Deleted)(THIS_ VARIANT_BOOL FAR* pbDeleted) PURE;
    STDMETHOD(put_Deleted)(THIS_ VARIANT_BOOL bDeleted) PURE;
    STDMETHOD(get_Type)(THIS_ int FAR* piType) PURE;
    STDMETHOD(get_LocalSpec)(THIS_ BSTR FAR* pLocal) PURE;
    STDMETHOD(put_LocalSpec)(THIS_ BSTR Local) PURE;
    STDMETHOD(get_Name)(THIS_ BSTR FAR* pName) PURE;
    STDMETHOD(put_Name)(THIS_ BSTR Name) PURE;
    STDMETHOD(get_Parent)(THIS_ IVSSItem FAR* FAR* ppIParent) PURE;
    STDMETHOD(get_VersionNumber)(THIS_ long FAR* piVersion) PURE;
    STDMETHOD(get_Items)(THIS_ VARIANT_BOOL IncludeDeleted, IVSSItems FAR* FAR* ppIItems) PURE;
    STDMETHOD(Get)(THIS_ BSTR FAR* Local, long iFlags) PURE;
    STDMETHOD(Checkout)(THIS_ BSTR Comment, BSTR Local, long iFlags) PURE;
    STDMETHOD(Checkin)(THIS_ BSTR Comment, BSTR Local, long iFlags) PURE;
    STDMETHOD(UndoCheckout)(THIS_ BSTR Local, long iFlags) PURE;
    STDMETHOD(get_IsCheckedOut)(THIS_ long FAR* piStatus) PURE;
    STDMETHOD(get_Checkouts)(THIS_ IVSSCheckouts FAR* FAR* ppICheckouts) PURE;
    STDMETHOD(get_IsDifferent)(THIS_ BSTR Local, VARIANT_BOOL FAR* pbDifferent) PURE;
    STDMETHOD(Add)(THIS_ BSTR Local, BSTR Comment, long iFlags, IVSSItem FAR* FAR* ppIItem) PURE;
    STDMETHOD(NewSubproject)(THIS_ BSTR Name, BSTR Comment, IVSSItem FAR* FAR* ppIItem) PURE;
    STDMETHOD(Share)(THIS_ IVSSItem FAR* pIItem, BSTR Comment, long iFlags) PURE;
    STDMETHOD(Destroy)(THIS) PURE;
    STDMETHOD(Move)(THIS_ IVSSItem FAR* pINewParent) PURE;
    STDMETHOD(Label)(THIS_ BSTR Label, BSTR Comment) PURE;
    STDMETHOD(get_Versions)(THIS_ long iFlags, IVSSVersions FAR* FAR* pIVersions) PURE;
    STDMETHOD(get_Version)(THIS_ VARIANT Version, IVSSItem FAR* FAR* ppIItem) PURE;
};

DEFINE_GUID(IID_IVSSVersions,0x783CD4E7L,0x9D54,0x11CF,0xB8,0xEE,0x00,0x60,0x8C,0xC9,0xA7,0x1F);

/* Definition of interface: IVSSVersions */
#undef INTERFACE
#define INTERFACE IVSSVersions

DECLARE_INTERFACE_(IVSSVersions, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IVSSVersions methods */
    STDMETHOD(_NewEnum)(THIS_ IUnknown * FAR* ppIEnum) PURE;
};

DEFINE_GUID(IID_IVSSVersion,0x783CD4E8L,0x9D54,0x11CF,0xB8,0xEE,0x00,0x60,0x8C,0xC9,0xA7,0x1F);

/* Definition of interface: IVSSVersion */
#undef INTERFACE
#define INTERFACE IVSSVersion

DECLARE_INTERFACE_(IVSSVersion, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IVSSVersion methods */
    STDMETHOD(get_Username)(THIS_ BSTR FAR* pUsername) PURE;
    STDMETHOD(get_VersionNumber)(THIS_ long FAR* piVersion) PURE;
    STDMETHOD(get_Action)(THIS_ BSTR FAR* pAction) PURE;
    STDMETHOD(get_Date)(THIS_ DATE FAR* pDate) PURE;
    STDMETHOD(get_Comment)(THIS_ BSTR FAR* pComment) PURE;
    STDMETHOD(get_Label)(THIS_ BSTR FAR* pLabel) PURE;
    STDMETHOD(get_VSSItem)(THIS_ IVSSItem FAR* FAR* ppIItem) PURE;
};

DEFINE_GUID(IID_IVSSItems,0x783CD4E5L,0x9D54,0x11CF,0xB8,0xEE,0x00,0x60,0x8C,0xC9,0xA7,0x1F);

/* Definition of interface: IVSSItems */
#undef INTERFACE
#define INTERFACE IVSSItems

DECLARE_INTERFACE_(IVSSItems, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IVSSItems methods */
    STDMETHOD(get_Count)(THIS_ long FAR* piCount) PURE;
    STDMETHOD(get_Item)(THIS_ VARIANT sItem, IVSSItem FAR* FAR* ppIItem) PURE;
    STDMETHOD(_NewEnum)(THIS_ IUnknown * FAR* ppIEnum) PURE;
};

DEFINE_GUID(IID_IVSSCheckouts,0x8903A770L,0xF55F,0x11CF,0x92,0x27,0x00,0xAA,0x00,0xA1,0xEB,0x95);

/* Definition of interface: IVSSCheckouts */
#undef INTERFACE
#define INTERFACE IVSSCheckouts

DECLARE_INTERFACE_(IVSSCheckouts, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IVSSCheckouts methods */
    STDMETHOD(get_Count)(THIS_ long FAR* piCount) PURE;
    STDMETHOD(get_Item)(THIS_ VARIANT sItem, IVSSCheckout FAR* FAR* ppICheckout) PURE;
    STDMETHOD(_NewEnum)(THIS_ IUnknown * FAR* ppIEnum) PURE;
};

DEFINE_GUID(IID_IVSSCheckout,0x783CD4E6L,0x9D54,0x11CF,0xB8,0xEE,0x00,0x60,0x8C,0xC9,0xA7,0x1F);

/* Definition of interface: IVSSCheckout */
#undef INTERFACE
#define INTERFACE IVSSCheckout

DECLARE_INTERFACE_(IVSSCheckout, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IVSSCheckout methods */
    STDMETHOD(get_Username)(THIS_ BSTR FAR* pUsername) PURE;
    STDMETHOD(get_Date)(THIS_ DATE FAR* pDate) PURE;
    STDMETHOD(get_LocalSpec)(THIS_ BSTR FAR* pLocal) PURE;
    STDMETHOD(get_Machine)(THIS_ BSTR FAR* pMachine) PURE;
    STDMETHOD(get_Project)(THIS_ BSTR FAR* pProject) PURE;
    STDMETHOD(get_Comment)(THIS_ BSTR FAR* pComment) PURE;
    STDMETHOD(get_VersionNumber)(THIS_ long FAR* piVersion) PURE;
};

DEFINE_GUID(IID_IVSSDatabase,0x783CD4E2L,0x9D54,0x11CF,0xB8,0xEE,0x00,0x60,0x8C,0xC9,0xA7,0x1F);

/* Definition of interface: IVSSDatabase */
#undef INTERFACE
#define INTERFACE IVSSDatabase

DECLARE_INTERFACE_(IVSSDatabase, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IVSSDatabase methods */
    STDMETHOD(Open)(THIS_ BSTR SrcSafeIni, BSTR Username, BSTR Password) PURE;
    STDMETHOD(get_SrcSafeIni)(THIS_ BSTR FAR* pSrcSafeIni) PURE;
    STDMETHOD(get_DatabaseName)(THIS_ BSTR FAR* pDatabaseName) PURE;
    STDMETHOD(get_UserName)(THIS_ BSTR FAR* pUsername) PURE;
    STDMETHOD(get_CurrentProject)(THIS_ BSTR FAR* pPrj) PURE;
    STDMETHOD(put_CurrentProject)(THIS_ BSTR Prj) PURE;
    STDMETHOD(get_VSSItem)(THIS_ BSTR Spec, VARIANT_BOOL Deleted, IVSSItem FAR* FAR* ppIVSSItem) PURE;
};

DEFINE_GUID(CLSID_VSSItem,0x783CD4E3L,0x9D54,0x11CF,0xB8,0xEE,0x00,0x60,0x8C,0xC9,0xA7,0x1F);

#ifdef __cplusplus
class VSSItem;
#endif

DEFINE_GUID(CLSID_VSSVersion,0x783CD4ECL,0x9D54,0x11CF,0xB8,0xEE,0x00,0x60,0x8C,0xC9,0xA7,0x1F);

#ifdef __cplusplus
class VSSVersion;
#endif

DEFINE_GUID(CLSID_VSSCheckout,0x2A0DE0E0L,0x2E9F,0x11D0,0x92,0x36,0x00,0xAA,0x00,0xA1,0xEB,0x95);

#ifdef __cplusplus
class VSSCheckout;
#endif

DEFINE_GUID(CLSID_VSSDatabase,0x783CD4E4L,0x9D54,0x11CF,0xB8,0xEE,0x00,0x60,0x8C,0xC9,0xA7,0x1F);

#ifdef __cplusplus
class VSSDatabase;
#endif

DEFINE_GUID(IID_IVSSEvents,0x783CD4E9L,0x9D54,0x11CF,0xB8,0xEE,0x00,0x60,0x8C,0xC9,0xA7,0x1F);

/* Definition of interface: IVSSEvents */
#undef INTERFACE
#define INTERFACE IVSSEvents

DECLARE_INTERFACE_(IVSSEvents, IUnknown)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;
#endif

    /* IVSSEvents methods */
    STDMETHOD(BeforeAdd)(THIS_ IVSSItem FAR* pIPrj, BSTR Local, VARIANT_BOOL FAR* pbContinue) PURE;
    STDMETHOD(AfterAdd)(THIS_ IVSSItem FAR* pIItem, BSTR Local) PURE;
    STDMETHOD(BeforeCheckout)(THIS_ IVSSItem FAR* pIItem, BSTR Local, VARIANT_BOOL FAR* pbContinue) PURE;
    STDMETHOD(AfterCheckout)(THIS_ IVSSItem FAR* pIItem, BSTR Local) PURE;
    STDMETHOD(BeforeCheckin)(THIS_ IVSSItem FAR* pIItem, BSTR Local, VARIANT_BOOL FAR* pbContinue) PURE;
    STDMETHOD(AfterCheckin)(THIS_ IVSSItem FAR* pIItem, BSTR Local) PURE;
    STDMETHOD(BeforeUndoCheckout)(THIS_ IVSSItem FAR* pIItem, BSTR Local, VARIANT_BOOL FAR* pbContinue) PURE;
    STDMETHOD(AfterUndoCheckout)(THIS_ IVSSItem FAR* pIItem, BSTR Local) PURE;
    STDMETHOD(BeforeRename)(THIS_ IVSSItem FAR* pIItem, BSTR NewName, VARIANT_BOOL FAR* pbContinue) PURE;
    STDMETHOD(AfterRename)(THIS_ IVSSItem FAR* pIItem, BSTR OldName) PURE;
    STDMETHOD(BeforeBranch)(THIS_ IVSSItem FAR* pIItem, VARIANT_BOOL FAR* pbContinue) PURE;
    STDMETHOD(AfterBranch)(THIS_ IVSSItem FAR* pIItem) PURE;
    STDMETHOD(BeforeEvent)(THIS_ long iEvent, IVSSItem FAR* pIItem, BSTR Str, VARIANT var, VARIANT_BOOL FAR* pbContinue) PURE;
    STDMETHOD(AfterEvent)(THIS_ long iEvent, IVSSItem FAR* pIItem, BSTR Str, VARIANT var) PURE;
};

DEFINE_GUID(IID_IVSS,0x783CD4EBL,0x9D54,0x11CF,0xB8,0xEE,0x00,0x60,0x8C,0xC9,0xA7,0x1F);

/* Definition of interface: IVSS */
#undef INTERFACE
#define INTERFACE IVSS

DECLARE_INTERFACE_(IVSS, IDispatch)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;

    /* IDispatch methods */
    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo) PURE;

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo) PURE;

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid) PURE;

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr) PURE;
#endif

    /* IVSS methods */
    STDMETHOD(get_VSSDatabase)(THIS_ IVSSDatabase FAR* FAR* ppIVSSDatabase) PURE;
};

DEFINE_GUID(IID_IVSSEventHandler,0x783CD4EAL,0x9D54,0x11CF,0xB8,0xEE,0x00,0x60,0x8C,0xC9,0xA7,0x1F);

/* Definition of interface: IVSSEventHandler */
#undef INTERFACE
#define INTERFACE IVSSEventHandler

DECLARE_INTERFACE_(IVSSEventHandler, IUnknown)
{
BEGIN_INTERFACE
#ifndef NO_BASEINTERFACE_FUNCS

    /* IUnknown methods */
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef)(THIS) PURE;
    STDMETHOD_(ULONG, Release)(THIS) PURE;
#endif

    /* IVSSEventHandler methods */
    STDMETHOD(Init)(THIS_ IVSS FAR* pIVSS) PURE;
};

DEFINE_GUID(CLSID_VSSApp,0x2A0DE0E1L,0x2E9F,0x11D0,0x92,0x36,0x00,0xAA,0x00,0xA1,0xEB,0x95);

#ifdef __cplusplus
class VSSApp;
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\cfgmnt\mt.h ===
// MT.h: interface for the CMT class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_MT_H__1D7004F3_0458_11D1_A438_00C04FB99B01__INCLUDED_)
#define AFX_MT_H__1D7004F3_0458_11D1_A438_00C04FB99B01__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include <process.h>

class CMT  
{
public:
	CMT();
	virtual ~CMT();

};



// typedefs and inline func to handle buggy _beginthreadex prototype
typedef unsigned (WINAPI *P_BEGINTHREADEX_THREADPROC)(LPVOID lpThreadParameter);
typedef unsigned *P_BEGINTHREADEX_THREADID;

inline HANDLE _beginthreadex(
	LPSECURITY_ATTRIBUTES lpThreadAttributes,	// pointer to thread security attributes  
	DWORD dwStackSize,							// initial thread stack size, in bytes  
	LPTHREAD_START_ROUTINE lpStartAddress,		// pointer to thread function  
	LPVOID lpParameter,							// argument for new thread  
	DWORD dwCreationFlags,						// creation flags  
	LPDWORD lpThreadId							// pointer to returned thread identifier  
)
{
	return (HANDLE)::_beginthreadex(
		lpThreadAttributes,
		dwStackSize,
		(P_BEGINTHREADEX_THREADPROC)lpStartAddress,
		lpParameter,
		dwCreationFlags,
		(P_BEGINTHREADEX_THREADID)lpThreadId
		);
}


#endif // !defined(AFX_MT_H__1D7004F3_0458_11D1_A438_00C04FB99B01__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\cfgmnt\ssauterr.h ===
//*****************************************************************************
// ssauterr.h
//
//
// Copyright (c) 1995 by Microsoft Corporation, All Rights Reserved
//*****************************************************************************

#define MAKEHR(iStat) MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, (USHORT) (iStat))

#define ESS_CORRUPT					MAKEHR(-10600)	// File %s may be corrupt
#define ESS_DT_BADDATESTR			MAKEHR(-10159)	// Invalid date string: "%s"
#define ESS_DT_INVALID				MAKEHR(-10161)	// Invalid time or date string
#define ESS_NOMORE_HANDLES			MAKEHR(-10164)	// Too many file handles open.
#define ESS_FILE_ACCESSDENIED		MAKEHR(-10165)	// Access to file "%s" denied
#define ESS_FILE_BADDRIVE			MAKEHR(-10166)	// Invalid drive: %s
#define ESS_FILE_BADHANDLE			MAKEHR(-10167)	// Invalid handle.
#define ESS_FILE_BADNAME			MAKEHR(-10168)	// Invalid filename: "%s"
#define ESS_FILE_BADPARAM			MAKEHR(-10170)	// Invalid access code (bad parameter)
#define ESS_FILE_BADPATH			MAKEHR(-10171)	// Invalid DOS path: %s
#define ESS_FILE_CURRENTDIR			MAKEHR(-10172)	// Folder %s is in use
#define ESS_FILE_DISKFULL			MAKEHR(-10173)	// Disk full
#define ESS_FILE_EXISTS				MAKEHR(-10175)	// File "%s" already exists
#define ESS_FILE_LOCKED				MAKEHR(-10176)	// File "%s" is locked
#define ESS_FILE_NOTFOUND			MAKEHR(-10178)	// File "%s" not found
#define ESS_FILE_READ				MAKEHR(-10180)	// Error reading from file
#define ESS_FILE_SHARE				MAKEHR(-10181)	// File %s is already open
#define ESS_FILE_TOOMANY			MAKEHR(-10182)	// Too many file handles open
#define ESS_FILE_VOLNOTSAME			MAKEHR(-10183)	// Cannot rename to another volume
#define ESS_FILE_WRITE				MAKEHR(-10184)	// Error writing to file
#define ESS_INI_BADBOOL				MAKEHR(-10200)	// Initialization variable "%s" must be set to "Yes" or "No"
#define ESS_INI_BADLINE				MAKEHR(-10201)	// Invalid syntax on line %d of file %s
#define ESS_INI_BADNUMBER			MAKEHR(-10202)	// Initialization variable ""%s"" set to invalid number
#define ESS_INI_BADPATH				MAKEHR(-10203)	// Initialization variable ""%s"" set to invalid path
#define ESS_INI_BADVALUE			MAKEHR(-10205)	// Initialization variable ""%s"" set to invalid value
#define ESS_INI_NOSUCHVAR			MAKEHR(-10206)	// Cannot find initialization variable "%s"
#define ESS_INI_NUMRANGE			MAKEHR(-10207)	// Initialization variable "%s" must be between %d and %d
#define ESS_INI_TOO_MANY_ENV		MAKEHR(-10208)	// Too many SS.INI environment strings
#define ESS_LOCK_TIMEOUT			MAKEHR(-10266)	// Timeout locking file: %s
#define ESS_MEM_NOMEMORY			MAKEHR(-10270)	// Out of memory
#define ESS_NO_TWEAK_CHKDOUT		MAKEHR(-10625)	// You cannot modify the properties of a file that is checked out.
#define ESS_NOMERGE_BIN_NODELTA		MAKEHR(-10279)	// You cannot perform a merge on a binary file, or a file that stores latest version only.
#define ESS_NOMULTI_BINARY			MAKEHR(-10280)	// Cannot check out %s. It is binary and is already checked out.
#define ESS_NOMULTI_NODELTA			MAKEHR(-10281)	// %s stores only the latest version and is already checked out.
#define ESS_OS_NOT_EXE				MAKEHR(-10285)	// Error executing: %s
#define ESS_SS_ADDPRJASSOCFILE		MAKEHR(-10626)	// %s is a SourceSafe configuration file and cannot be added.
#define ESS_SS_ADMIN_LOCKOUT		MAKEHR(-10456)	// The SourceSafe database has been locked by the Administrator.
#define ESS_SS_BADRENAME			MAKEHR(-10402)	// Unable to rename %s to %s.
#define ESS_SS_CANT_FIND_SSINI		MAKEHR(-10403)	// Cannot find SS.INI file for user %s
#define ESS_SS_CHECKED_OUT			MAKEHR(-10405)	// File %s is currently checked out by %s
#define ESS_SS_CHECKED_OUT_YOU		MAKEHR(-10406)	// You currently have file %s checked out
#define ESS_SS_CHECKOUT_OLD			MAKEHR(-10408)	// Cannot check out an old version of a file
#define ESS_SS_CHKOUT_USER			MAKEHR(-10413)	// File %s is currently checked out by %s
#define ESS_SS_CONFLICTS			MAKEHR(-10415)	// An automatic merge has occurred and there are conflicts.\nEdit %s to resolve them.
#define ESS_SS_DEL_ROOT				MAKEHR(-10418)	// Cannot delete the root project
#define ESS_SS_DEL_SHARED			MAKEHR(-10419)	// A deleted link to %s already exists
#define ESS_SS_FILE_NOTFOUND		MAKEHR(-10421)	// File ""%s"" not found
#define ESS_SS_HISTOPEN				MAKEHR(-10404)	// A history operation is already in progress
#define ESS_SS_INSUFRIGHTS			MAKEHR(-10423)	// You do not have access rights to %s
#define ESS_SS_LATERCHKEDOUT		MAKEHR(-10426)	// A more recent version is checked out
#define ESS_SS_LOCALRW				MAKEHR(-10427)	// A writable copy of %s already exists
#define ESS_SS_MOVE_CHANGENAME		MAKEHR(-10428)	// Move does not change the name of a project
#define ESS_SS_MOVE_NOPARENT		MAKEHR(-10429)	// Project %s does not exist
#define ESS_SS_MOVE_ROOT			MAKEHR(-10430)	// Cannot move the root project
#define ESS_SS_MUST_USE_VERS		MAKEHR(-10431)	// Cannot roll back to the most recent version of %s
#define ESS_SS_NOCOMMANCESTOR		MAKEHR(-10432)	// Files have no common ancestor
#define ESS_SS_NOCONFLICTS2			MAKEHR(-10434)	// %s has been merged with no conflicts.
#define ESS_SS_NODOLLAR				MAKEHR(-10435)	// File %s is invalid. Files may not begin with $.
#define ESS_SS_NOT_CHKEDOUT			MAKEHR(-10436)	// File %s is not checked out
#define ESS_SS_NOT_SHARED			MAKEHR(-10437)	// File %s is not shared by any other projects
#define ESS_SS_NOTSEPARATED			MAKEHR(-10438)	// Files are not branched
#define ESS_SS_OPEN_LOGGIN			MAKEHR(-10457)	// Unable to open user login file %s.
#define ESS_SS_PATHTOOLONG			MAKEHR(-10439)	// Path %s too long
#define ESS_SS_RENAME_MOVE			MAKEHR(-10442)	// Rename does not move an item to another project
#define ESS_SS_RENAME_ROOT			MAKEHR(-10443)	// Cannot Rename the root project
#define ESS_SS_ROLLBACK_NOTOLD		MAKEHR(-10447)	// Cannot Rollback to the most recent version of %s
#define ESS_SS_SHARE_ANCESTOR		MAKEHR(-10449)	// A project cannot be shared under a descendant.
#define ESS_SS_SHARED				MAKEHR(-10450)	// File %s is already shared by this project
#define ESS_SSPEC_SYNTAX			MAKEHR(-10515)	// Invalid SourceSafe syntax: "%s"
#define ESS_UM_BAD_CHAR				MAKEHR(-10550)	// Bad username syntax: "%s"
#define ESS_UM_BAD_PASSWORD			MAKEHR(-10551)	// Invalid password
#define ESS_UM_BADVERSION			MAKEHR(-10552)	// Incompatible database version
#define ESS_UM_DEL_ADMIN			MAKEHR(-10553)	// Cannot delete the Admin user
#define ESS_UM_PERM_DENIED			MAKEHR(-10554)	// Permission denied
#define ESS_UM_RENAME_ADMIN			MAKEHR(-10555)	// Can not rename the Admin user
#define ESS_UM_TOO_LONG				MAKEHR(-10556)	// Username too long
#define ESS_UM_USER_EXISTS			MAKEHR(-10557)	// User "%s" already exists
#define ESS_UM_USER_NOT_FOUND		MAKEHR(-10558)	// User "%s" not found
#define ESS_URL_BADPATH				MAKEHR(-10192)	// The URL for project %s was not set properly.
#define ESS_VS_CHECKED_OUT			MAKEHR(-10601)	// File %s checked out
#define ESS_VS_CHILD_NOT_FOUND		MAKEHR(-10602)	// Subproject or file not found
#define ESS_VS_COLLISION			MAKEHR(-10603)	// Collision accessing database, please try again.
#define ESS_VS_EXCLUSIVE_CHECKED_OUT MAKEHR(-10614)	// File %s is exclusively checked out.
#define ESS_VS_ITEMEXISTS			MAKEHR(-10604)	// An item with the name %s already exists
#define ESS_VS_LONGNAME				MAKEHR(-10605)	// %s is an invalid %s name
#define ESS_VS_MOVE_CYCLE			MAKEHR(-10606)	// You can not move a project under itself
#define ESS_VS_NO_DELTA				MAKEHR(-10607)	// File %s does not retain old versions of itself
#define ESS_VS_NOT_CHECKED_OUT		MAKEHR(-10608)	// File %s cannot be checked into this project
#define ESS_VS_NOT_FOUND			MAKEHR(-10609)	// File or project not found
#define ESS_VS_PARENT_NOT_FOUND		MAKEHR(-10610)	// Parent not found
#define ESS_VS_VERS_NOT_FOUND		MAKEHR(-10615)	// Version not found
#define ESS_VS_WANT_FILE			MAKEHR(-10616)	// This command only works on files.
#define ESS_VS_WANT_PRJ				MAKEHR(-10617)	// This command only works on projects.
#define ESS_URL_BUFOVERFLOW			MAKEHR(-10194)	// A link in %s was ignored because it was longer than SourceSafe can understand
#define ESS_URL_CANTCHECKHTML		MAKEHR(-10193)	// An error occurred while  trying to check hyperlinks for %s
#define ESS_SS_ADDINFAILED			MAKEHR(-10440)	// Error loading SourceSafe add-in: %s
#define ESS_CANCEL					MAKEHR(-32766)
#define ESS_LOADSTRING_FAILED		MAKEHR(-10999)	// Error loading resource string

// SourceSafe questions answered affirmatively.
//
// A deleted copy of this %s file already exists in this project.\nDo you want to recover the existing file?
// Folder %s not found, create?
// Have any conflicts in %s been properly resolved?
// File %s is currently checked out by %s.\nProceed anyway?
// File %s was checked out to folder %s.\nProceed in %s?
// File %s is checked out to project %s, and you are in %s.\nProceed anyway?
// File %s is currently checked out by %s.  Delete anyway?
// You currently have file %s checked out.  Delete anyway?
// An item named %s was already deleted from this project.\nPurge the old item and delete this one now?
// This version of %s already has a label: overwrite?
// The label %s is already used.  Remove the old label?
// %s has been merged with no conflicts.\nCheck in now?
// Redo the automatic merge?
// Delete local file: %s?
// %s is already checked out, continue?
// File %s has been destroyed, and cannot be rebuilt.\nContinue anyway?
// Project $%s has been destroyed, and cannot be rebuilt.\nContinue anyway?
// $%s was moved out of this project, and cannot be rebuilt.\nContinue anyway?
// %s has changed. Undo check out and lose changes?
//
// SourceSafe questions answered in the negative.
//
// A deleted file of the same name already exists in this SourceSafe project.\nDo you want to recover the deleted file instead of adding your local %s?
// %s is writable, replace?
// %s is checked out, replace?
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\cfgmnt\verengine.h ===
// VerEngine.h: interface for the CVerEngine class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_VERENGINE_H__EC78FB59_EF1C_11D0_A42F_00C04FB99B01__INCLUDED_)
#define AFX_VERENGINE_H__EC78FB59_EF1C_11D0_A42F_00C04FB99B01__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "ssauto.h"
#include <list>
using namespace std;

class CVerEngine  
{
public:
	// thee methods
	HRESULT SyncPrj(LPCTSTR szBasePrj,LPCTSTR szDir);
	
	// dir versioning methods
	HRESULT AddPrj(LPCTSTR szBasePrj,LPCTSTR szRelSpec);
	HRESULT RenamePrj(LPCTSTR szBasePrj,LPCTSTR szRelSpec,LPCTSTR szRelSpecOld);

	// file versioning methods
	HRESULT Rename(LPCTSTR szBasePrj,LPCTSTR szDir,LPCTSTR szRelSpec,LPCTSTR szRelSpecOld);
	HRESULT CheckOut(LPCTSTR szFileSpec,LPCTSTR szBasePrj,LPCTSTR szRelSpec);
	HRESULT Delete(LPCTSTR szBasePrj,LPCTSTR szRelSpec);
	HRESULT Sync(LPCTSTR szBasePrj,LPCTSTR szDir,LPCTSTR szRelSpec,LPCTSTR szFileSpec = NULL);
	HRESULT Sync2(LPCTSTR szPrj,LPCTSTR szFileName,LPCTSTR szFileSpec);
	HRESULT GetLocalWritable(LPCTSTR szFileSpec,LPCTSTR szBasePrj,LPCTSTR szRelSpec);
	
	// init/shutdown
	HRESULT NewInit(LPCTSTR szVSSRootPrj);
	HRESULT ShutDown();
	
	// ctor/dtor
	CVerEngine();
	virtual ~CVerEngine();

private:
	// private methods
	HRESULT GetPrjEx(LPCTSTR szPrj,IVSSItem **hIPrj,bool bCreate);
	HRESULT GetItemEx(LPCTSTR szItem,IVSSItem **hIItem,bool bCreate);
	HRESULT Add(LPCTSTR szItem,LPCTSTR szFileSpec);
	HRESULT CheckIn(IVSSItem *pIItem,LPCTSTR szFileSpec);
	HRESULT CheckOutNoGet(IVSSItem *pIItem);
	HRESULT CheckOutGet(IVSSItem *pIItem);
	HRESULT CheckOutLocal(IVSSItem *pIItem,LPCTSTR szFileSpec);
	
	// helper
	void MakePrjSpec(wstring &szDest,LPCTSTR szSource);
	void EliminateCommon(list<wstring> &ListOne, list<wstring> &ListTwo);


	CComPtr<IVSSDatabase> m_pIDB;
	CComBSTR m_bstrSrcSafeIni;
	CComBSTR m_bstrUsername;
	CComBSTR m_bstrPassword;
	wstring m_szVSSRootPrj;
};

#endif // !defined(AFX_VERENGINE_H__EC78FB59_EF1C_11D0_A42F_00C04FB99B01__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\mdtools\custerr\custerr.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    custerr.cxx

Abstract:

    Custom Error Utility

Author:

    Keith Moore (keithmo)        04-Sep-1997

Revision History:

--*/


#include "precomp.hxx"
#pragma hdrstop


//
// Private constants.
//

#define TEST_HRESULT(api,hr,fatal)                                          \
            if( FAILED(hr) ) {                                              \
                                                                            \
                wprintf(                                                    \
                    L"%S:%lu failed, error %lx %S\n",                       \
                    (api),                                                  \
                    __LINE__,                                               \
                    (result),                                               \
                    (fatal)                                                 \
                        ? "ABORTING"                                        \
                        : "CONTINUING"                                      \
                    );                                                      \
                                                                            \
                if( fatal ) {                                               \
                                                                            \
                    goto cleanup;                                           \
                                                                            \
                }                                                           \
                                                                            \
            } else

#define ALLOC( cb ) (PVOID)LocalAlloc( LPTR, (cb) )
#define FREE( ptr ) (VOID)LocalFree( (HLOCAL)(ptr) )


//
// Private types.
//


//
// Private globals.
//


//
// Private prototypes.
//

VOID
Usage(
    VOID
    );

VOID
SetCustomError(
    IMSAdminBase * AdmCom,
    LPWSTR MetaPath,
    LPWSTR FileName
    );

VOID
DumpCustomError(
    IMSAdminBase * AdmCom,
    LPWSTR MetaPath
    );


//
// Public functions.
//


INT
__cdecl
wmain(
    INT argc,
    LPWSTR argv[]
    )
{

    HRESULT result;
    IMSAdminBase * admCom;
    LPWSTR metaPath;
    LPWSTR fileName;
    LPWSTR arg;
    INT i;

    //
    // Setup locals so we know how to cleanup on exit.
    //

    admCom = NULL;

    //
    // Establish defaults.
    //

    metaPath = L"w3svc";
    fileName = NULL;

    //
    // Validate the command line arguments.
    //

    for( i = 1 ; i < argc ; i++ ) {
        arg = argv[i];

        if( arg[0] != L'-' ||
            arg[1] == L'\0' ||
            arg[2] != L':' ||
            arg[3] == L'\0' ) {
            Usage();
            return 1;
        }

        switch( arg[1] ) {
        case L'h' :
        case L'H' :
        case L'?' :
            Usage();
            return 1;

        case L'p' :
        case L'P' :
            metaPath = arg + 3;
            break;

        case L'f' :
        case L'F' :
            fileName = arg + 3;
            break;

        default :
            Usage();
            return 1;
        }

    }

    //
    // Initialize COM.
    //

    result = CoInitializeEx(
                 NULL,
                 COINIT_MULTITHREADED
                 );

    TEST_HRESULT( "CoInitializeEx()", result, TRUE );

    //
    // Get the admin object.
    //

    result = MdGetAdminObject( &admCom );

    TEST_HRESULT( "MdGetAdminObject()", result, TRUE );

    //
    // Do it.
    //

    if( fileName == NULL ) {
        DumpCustomError( admCom, metaPath );
    } else {
        SetCustomError( admCom, metaPath, fileName );
    }

cleanup:

    //
    // Release the admin object.
    //

    if( admCom != NULL ) {

        result = MdReleaseAdminObject( admCom );
        TEST_HRESULT( "MdReleaseAdminObject()", result, FALSE );

    }

    //
    // Shutdown COM.
    //

    CoUninitialize();
    return 0;

}   // main


//
// Private functions.
//

VOID
Usage(
    VOID
    )
{

    wprintf(
        L"use: custerr [options]\n"
        L"\n"
        L"valid options are:\n"
        L"\n"
        L"    -p:meta_path\n"
        L"    -f:error_file\n"
        L"\n"
        );

}   // Usage

VOID
SetCustomError(
    IMSAdminBase * AdmCom,
    LPWSTR MetaPath,
    LPWSTR FileName
    )
{

    HANDLE fileHandle;
    DWORD length;
    DWORD lengthHigh;
    DWORD bytesRemaining;
    HANDLE mappingHandle;
    PCHAR view;
    PCHAR viewScan;
    PWCHAR multiSz;
    PWCHAR multiSzScan;
    HRESULT result;
    BOOL gotOne;
    METADATA_HANDLE metaHandle;
    METADATA_RECORD metaRecord;
    DWORD err;
    CHAR ansiFileName[MAX_PATH];
    WCHAR fullMetaPath[MAX_PATH];

    //
    // Setup locals so we know how to cleanup on exit.
    //

    fileHandle = INVALID_HANDLE_VALUE;
    mappingHandle = NULL;
    view = NULL;
    multiSz = NULL;
    metaHandle = 0;

    //
    // Open the file, get its length.
    //

    sprintf(
        ansiFileName,
        "%S",
        FileName
        );

    fileHandle = CreateFileA(
                     ansiFileName,
                     GENERIC_READ,
                     FILE_SHARE_READ,
                     NULL,
                     OPEN_EXISTING,
                     FILE_ATTRIBUTE_NORMAL,
                     NULL
                     );

    if( fileHandle == INVALID_HANDLE_VALUE ) {
        err = GetLastError();
        wprintf(
            L"custerr: cannot open %s, error %lu\n",
            FileName,
            err
            );
        goto cleanup;
    }

    length = GetFileSize( fileHandle, &lengthHigh );

    if( length == 0xFFFFFFFF || lengthHigh > 0 ) {
        err = GetLastError();
        wprintf(
            L"custerr: cannot read %s, error %lu\n",
            FileName,
            err
            );
        goto cleanup;
    }

    //
    // Map it in.
    //

    mappingHandle = CreateFileMapping(
                        fileHandle,
                        NULL,
                        PAGE_READONLY,
                        0,
                        0,
                        NULL
                        );

    if( mappingHandle == NULL ) {
        err = GetLastError();
        wprintf(
            L"custerr: cannot read %s, error %lu\n",
            FileName,
            err
            );
        goto cleanup;
    }

    view = (PCHAR)MapViewOfFile(
                      mappingHandle,
                      FILE_MAP_READ,
                      0,
                      0,
                      0
                      );

    if( view == NULL ) {
        err = GetLastError();
        wprintf(
            L"custerr: cannot read %s, error %lu\n",
            FileName,
            err
            );
        goto cleanup;
    }

    //
    // Allocate the multisz buffer. Assume it will be roughly the same
    // size as the file.
    //

    multiSz = (PWCHAR) ALLOC( length * sizeof(WCHAR) );

    if( multiSz == NULL ) {
        wprintf(
            L"custerr: not enough memory\n"
            );
        goto cleanup;
    }

    //
    // Build the multisz.
    //

    viewScan = view;
    multiSzScan = multiSz;
    bytesRemaining = length;

    while( bytesRemaining > 0 ) {

        //
        // Skip leading whitespace.
        //

        while( bytesRemaining > 0 &&
               ( *viewScan == ' ' || *viewScan == '\t' ||
                 *viewScan == '\r' || *viewScan == '\n' ) ) {
            bytesRemaining--;
            viewScan++;
        }

        //
        // Copy it over, collapse embedded whitespace, perform
        // cheesy ANSI-to-UNICODE conversion.
        //

        gotOne = FALSE;

        while( bytesRemaining > 0 &&
               ( *viewScan != '\r' && *viewScan != '\n' ) ) {
            bytesRemaining--;
            if( *viewScan != ' ' && *viewScan != '\t' ) {
                *multiSzScan++ = (WCHAR)*viewScan;
                gotOne = TRUE;
            }
            viewScan++;
        }

        if( gotOne ) {
            *multiSzScan++ = L'\0';
        }

    }

    *multiSzScan++ = L'\0';

    //
    // Open the metabase.
    //

    swprintf(
        fullMetaPath,
        L"/%S/%s",
        IIS_MD_LOCAL_MACHINE_PATH,
        MetaPath
        );

    result = AdmCom->OpenKey(
                 METADATA_MASTER_ROOT_HANDLE,
                 fullMetaPath,
                 METADATA_PERMISSION_WRITE,
                 METABASE_OPEN_TIMEOUT,
                 &metaHandle
                 );

    TEST_HRESULT( "AdmCom->OpenKey()", result, TRUE );

    //
    // Write the new custom error value.
    //

    length = ( multiSzScan - multiSz ) * sizeof(WCHAR);

    INITIALIZE_METADATA_RECORD(
        &metaRecord,
        MD_CUSTOM_ERROR,
        METADATA_INHERIT,
        IIS_MD_UT_SERVER,
        MULTISZ_METADATA,
        length,
        multiSz
        );

    result = AdmCom->SetData(
                 metaHandle,
                 L"",
                 &metaRecord
                 );

    TEST_HRESULT( "AdmCom->SetData()", result, TRUE );

cleanup:

    if( metaHandle != 0 ) {
        AdmCom->CloseKey( metaHandle );
    }

    if( multiSz != NULL ) {
        FREE( multiSz );
    }

    if( view != NULL ) {
        UnmapViewOfFile( view );
    }

    if( mappingHandle != NULL ) {
        CloseHandle( mappingHandle );
    }

    if( fileHandle != INVALID_HANDLE_VALUE ) {
        CloseHandle( fileHandle );
    }

}   // SetCustomError

VOID
DumpCustomError(
    IMSAdminBase * AdmCom,
    LPWSTR MetaPath
    )
{


    HRESULT result;
    METADATA_HANDLE metaHandle;
    METADATA_RECORD metaRecord;
    DWORD bytesRequired;
    PWCHAR buffer;
    PWCHAR bufferScan;
    WCHAR fullMetaPath[MAX_PATH];

    //
    // Setup locals so we know how to cleanup on exit.
    //

    metaHandle = 0;
    buffer = NULL;

    //
    // Open the metabase.
    //

    swprintf(
        fullMetaPath,
        L"/%S/%s",
        IIS_MD_LOCAL_MACHINE_PATH,
        MetaPath
        );

    result = AdmCom->OpenKey(
                 METADATA_MASTER_ROOT_HANDLE,
                 fullMetaPath,
                 METADATA_PERMISSION_READ,
                 METABASE_OPEN_TIMEOUT,
                 &metaHandle
                 );

    TEST_HRESULT( "AdmCom->OpenKey()", result, TRUE );

    //
    // Get the data size.
    //

    INITIALIZE_METADATA_RECORD(
        &metaRecord,
        MD_CUSTOM_ERROR,
        METADATA_INHERIT,
        IIS_MD_UT_SERVER,
        MULTISZ_METADATA,
        2,
        L""
        );

    result = AdmCom->GetData(
                 metaHandle,
                 L"",
                 &metaRecord,
                 &bytesRequired
                 );

    if( result != RETURNCODETOHRESULT( ERROR_INSUFFICIENT_BUFFER ) ) {
        TEST_HRESULT( "AdmCom->GetData()", result, TRUE );
    }

    //
    // Allocate our data buffer.
    //

    buffer = (PWCHAR)ALLOC( bytesRequired );

    if( buffer == NULL ) {
        wprintf(
            L"custerr: not enough memory\n"
            );
        goto cleanup;
    }

    //
    // Now actually read it.
    //

    INITIALIZE_METADATA_RECORD(
        &metaRecord,
        MD_CUSTOM_ERROR,
        METADATA_INHERIT,
        IIS_MD_UT_SERVER,
        MULTISZ_METADATA,
        bytesRequired,
        buffer
        );

    result = AdmCom->GetData(
                 metaHandle,
                 L"",
                 &metaRecord,
                 &bytesRequired
                 );

    TEST_HRESULT( "AdmCom->GetData()", result, TRUE );

    //
    // Print it.
    //

    bufferScan = buffer;

    while( *bufferScan != L'\0' ) {
        wprintf( L"%s\n", bufferScan );
        bufferScan += wcslen( bufferScan ) + 1;
    }

cleanup:

    if( buffer != NULL ) {
        FREE( buffer );
    }

    if( metaHandle != 0 ) {
        AdmCom->CloseKey( metaHandle );
    }

}   // DumpCustomError
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\mdtools\guid\guid.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    guid.cxx

Abstract:

    Defines global GUIDs.

Author:

    Keith Moore (keithmo)        31-Jan-1996

Revision History:

--*/

#include <windows.h>
#define INITGUID
#include <ole2.h>
#include <iadmw.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\cfgmnt\verengine.cpp ===
// VerEngine.cpp: implementation of the CVerEngine class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "VerEngine.h"
#include "ssauterr.h"
#include "Error.h"
#include <COMDEF.h>

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CVerEngine::CVerEngine()
{

}

CVerEngine::~CVerEngine()
{

}

HRESULT CVerEngine::NewInit(LPCTSTR szVSSRootPrj)
{
	// save the root prj
	m_szVSSRootPrj = szVSSRootPrj;

	HRESULT hr = E_FAIL;

	// check if we already have a db instance
	if(!m_pIDB)
	{
		// create db instance
		hr = CoCreateInstance(CLSID_VSSDatabase,
							  NULL,
							  CLSCTX_INPROC_SERVER,
							  IID_IVSSDatabase,
							  (void**)&m_pIDB);
		if(FAILED(hr))
			return hr;
	}

	// Open the database
	hr = m_pIDB->Open(m_bstrSrcSafeIni,m_bstrUsername,m_bstrPassword);
	if(FAILED(hr))
		return hr;

	return hr;
}

HRESULT CVerEngine::ShutDown()
{
	// release of interface ptr here and not during destructor,
	// since CVerEngine could live on stack in the same frame that CoUninitialize() is called,
	// i.e. CoUninitialize() would be called before the destructor calls release and gets 
	// an Access Violation.
	m_pIDB.Release();
	return S_OK;
}

HRESULT CVerEngine::AddPrj(LPCTSTR szBasePrj,LPCTSTR szRelSpec)
{
	_ASSERT(szBasePrj && szRelSpec);
	HRESULT hr = S_OK;
	CComPtr<IVSSItem> pIItem;
	wstring szPrj(szBasePrj);
	MakePrjSpec(szPrj,szRelSpec);

	// see if the item exists
	CError::Trace(szPrj.c_str()); CError::Trace(" Add ");
	hr = GetPrjEx(szPrj.c_str(),&pIItem,true);
	if( SUCCEEDED(hr) )
	{
		if(hr == S_FALSE)
			CError::Trace("created ");
	}
	else
		FAIL_RTN1(hr,"\nGetPrjEx");

	CError::Trace("\n");
	return hr;
}

HRESULT CVerEngine::RenamePrj(LPCTSTR szBasePrj,LPCTSTR szRelSpec,LPCTSTR szRelSpecOld)
{
	_ASSERTE(szBasePrj && szRelSpec && szRelSpecOld);
	HRESULT hr;
	CComPtr<IVSSItem> pIItem;
	wstring szItem(szBasePrj); 
	MakePrjSpec(szItem,szRelSpecOld);

	// see if the item exists
	CError::Trace(szRelSpecOld); CError::Trace(" Rename to "); CError::Trace(szRelSpec);
	hr = GetPrjEx(szItem.c_str(),&pIItem,true);
	if(SUCCEEDED(hr))
	{
		wstring szFileName(szRelSpec);
		int iFileNameIndex = szFileName.find_last_of(L"\\/");
		if(iFileNameIndex == wstring::npos)
			iFileNameIndex = 0;
		else iFileNameIndex++;
		hr = pIItem->put_Name(_bstr_t(szFileName.substr(iFileNameIndex).c_str()));
		IF_FAIL_RTN1(hr,"\nput_Name");
	}
	else
		FAIL_RTN1(hr,"\nGetPrjEx");

	CError::Trace("\n");
	return hr;
}
	
HRESULT CVerEngine::Rename(LPCTSTR szBasePrj,LPCTSTR szDir,LPCTSTR szRelSpec,LPCTSTR szRelSpecOld)
{
	_ASSERTE(szBasePrj && szRelSpec && szRelSpecOld);
	HRESULT hr;
	CComPtr<IVSSItem> pIItem;
	wstring szOldItem(szBasePrj);
	MakePrjSpec(szOldItem,szRelSpecOld);

	// see if the item exists
	CError::Trace(szRelSpecOld); CError::Trace(" Rename to "); CError::Trace(szRelSpec);
	hr = GetItemEx(szOldItem.c_str(),&pIItem,true);
	if(SUCCEEDED(hr))
	{
		if(hr == S_FALSE) 
		{
			CError::Trace(" created ");
			// file was created, therefore let's checkin the old version
			_ASSERTE(szDir);
			wstring szFileSpec(szDir);
			szFileSpec.append(L"\\").append(szRelSpec);
			hr = Sync2(szBasePrj,szRelSpecOld,szFileSpec.c_str());
			IF_FAIL_RTN1(hr,"\nSync");
		}
		
		wstring szItem(szRelSpec);
		int iFileNameIndex = szItem.find_last_of(L"\\/");
		if(iFileNameIndex == wstring::npos)
			iFileNameIndex = 0;
		else
			iFileNameIndex++;
		CComBSTR bstrFileName(szItem.substr(iFileNameIndex).c_str());
		hr = pIItem->put_Name(bstrFileName);
		IF_FAIL_RTN1(hr,"\nput_Name");
	}
	else
		FAIL_RTN1(hr,"\nGetItemEx");

	CError::Trace("\n");
	return hr;
}

HRESULT CVerEngine::Sync2(LPCTSTR szPrj,LPCTSTR szFileName,LPCTSTR szFileSpec)
{
//	return Sync(szPrj,NULL,szFileName,szFileSpec);

	// @todo: handle errors
	HRESULT hr;
	CComPtr<IVSSItem> pIItem;
	wstring szItem(szPrj);
	MakePrjSpec(szItem,szFileName);

	// complete file/prj specs
	wstring szFSpec;
	szFSpec = szFileSpec;
	
	// see if the item exists
	CError::Trace(szItem.c_str()); CError::Trace(" Sync ");
	hr = GetItemEx(szItem.c_str(),&pIItem,true);
	if(SUCCEEDED(hr))
	{ 
		hr = CheckIn(pIItem,szFSpec.c_str());
		if(hr == ESS_FILE_SHARE)
		{
			// File %s is already open, meaning is held open by other process
			// Let's hope they close the file and we can try to add it agian,
			// so let's ignore it for now
			CError::Trace("not checked in(isopen)\n");
			return S_FALSE;
		} 
		else 
			IF_FAIL_RTN1(hr,"\nCheckin");

		CError::Trace("synced ");
	} 
	else
		FAIL_RTN1(hr,"\nget_VSSItem");

	CError::Trace("\n");
	return hr;
}

HRESULT CVerEngine::Sync(LPCTSTR szBasePrj,LPCTSTR szDir,LPCTSTR szRelSpec,LPCTSTR szFileSpec)
{
	// @todo: handle errors
	_ASSERT(m_pIDB && szBasePrj && szRelSpec);
	_ASSERTE(szDir||szFileSpec);
	HRESULT hr;
	CComPtr<IVSSItem> pIItem;
	wstring szItem(szBasePrj);
	MakePrjSpec(szItem,szRelSpec);

	// complete file/prj specs
	wstring szFSpec;
	if(szDir)
	{
		szFSpec = szDir;
		szFSpec.append(L"\\").append(szRelSpec);
	}
	else 
	{
		_ASSERTE(szFileSpec);
		szFSpec = szFileSpec;
	}
	
	// see if the item exists
	CError::Trace(szRelSpec); CError::Trace(" Sync ");
	hr = GetItemEx(szItem.c_str(),&pIItem,false);
	if(SUCCEEDED(hr))
	{ 
		hr = CheckIn(pIItem,szFSpec.c_str());
		if(hr == ESS_FILE_SHARE)
		{
			// File %s is already open, meaning is held open by other process
			// Let's hope they close the file and we can try to add it agian,
			// so let's ignore it for now
			CError::Trace("not checked in(isopen)\n");
			return S_FALSE;
		} 
		else 
			IF_FAIL_RTN1(hr,"\nCheckin");

		CError::Trace("synced ");
	} 
	else if(hr == ESS_VS_NOT_FOUND)
	{
		hr = Add(szItem.c_str(),szFSpec.c_str());
		if(hr == ESS_FILE_SHARE)
		{
			// File %s is already open, meaning is held open by other process
			// Let's hope they close the file and we can try to add it agian,
			// so let's ignore it for now
			CError::Trace("not added(isopen)\n");
			return S_FALSE;
		} 
		else 
			IF_FAIL_RTN1(hr,"\nAdd");

		CError::Trace("added ");
	}
	else
		FAIL_RTN1(hr,"\nget_VSSItem");

	CError::Trace("\n");
	return hr;
}

HRESULT CVerEngine::Delete(LPCTSTR szBasePrj,LPCTSTR szRelSpec)
{
	_ASSERT(m_pIDB && szBasePrj && szRelSpec);
	HRESULT hr = S_OK;
	CComPtr<IVSSItem> pIItem;
	wstring szItem(szBasePrj);
	MakePrjSpec(szItem,szRelSpec);
	
	// see if the item exists
	CError::Trace(szItem.c_str()); CError::Trace(" Delete ");
	hr = GetItemEx(szItem.c_str(),&pIItem,false);
	if( SUCCEEDED(hr) )
	{ 
		CError::Trace("exists ");
		// delete the file
		hr = pIItem->put_Deleted(true);
		IF_FAIL_RTN1(hr,"\nput_Delete");
		CError::Trace("deleted ");
	} 
	else if( hr == ESS_VS_NOT_FOUND )
	{
		CError::Trace("not-exist ");
		// This is bad. The file should have been in version control.
		// We can't add the file and delete it from VSS since the file
		// might no longer exist. We could create an empty dummy file,
		// but that's more confusing than helpfull.
		// Let's just log this error
		
		// @todo: log condition that file doesn't exist in VSS
		hr = S_OK;
	} 
	else 
		// This is really bad. There is some other error. Maybe we should try and
		// shutdown the srcsafe db and start it up again (this is slooowww!!!)
		// or maybe just write the failure to the log
		FAIL_RTN1(hr,"\nGetItemEx");

	CError::Trace("\n");
	return hr;
}

void CVerEngine::MakePrjSpec(wstring &szDest,LPCTSTR szSource)
{
	// szDest = m_szVSSRootPrj + [/]
	if(m_szVSSRootPrj[m_szVSSRootPrj.length()-1] != L'/' && szDest[0] != L'/')
		szDest.insert(0,L"/");
	szDest.insert(0,m_szVSSRootPrj.c_str());
	
	// szDest = szDest + [/] + szSource
	if(szDest[szDest.length()-1] != L'/' && szSource[0] != L'/')
		szDest.append(L"/");
	szDest.append(szSource);
	
	// convert all backslashes with slashes
	int pos = 0;
	while((pos = szDest.find(L'\\',pos)) != wstring::npos)
	{
		szDest[pos] = L'/';
		pos++;
	}
}

HRESULT CVerEngine::Add(LPCTSTR szItem,LPCTSTR szFileSpec)
{
	_ASSERTE(szItem && szFileSpec);
	HRESULT hr = S_OK;
	CComPtr<IVSSItem> pIPrj;
	CComPtr<IVSSItem> pIItem;
	
	// get prj
	wstring szTmp = szItem;
	int iFileNameIndex = szTmp.find_last_of(L"/");
	if(iFileNameIndex == wstring::npos)
		return E_FAIL;
	hr = GetPrjEx(szTmp.substr(0,iFileNameIndex).c_str(),&pIPrj,true);
	IF_FAIL_RTN1(hr,"GetPrjEx");
	CComBSTR bstrFileSpec(szFileSpec);
	hr = pIPrj->Add(bstrFileSpec,NULL,VSSFLAG_USERRONO|VSSFLAG_GETNO,&pIItem);	// VSSFLAG_KEEPYES
	if(hr == 0x80040000)	// @todo tmp fix, since pIPrj->Add has a bug when called with VSSFLAG_KEEPYES
		hr = S_OK;
	IF_FAIL_RTN1(hr,"Add");
	return hr;
}

HRESULT CVerEngine::GetLocalWritable(LPCTSTR szFileSpec,LPCTSTR szBasePrj,LPCTSTR szRelSpec)
{
	_ASSERTE(m_pIDB && szFileSpec && szBasePrj && szRelSpec);

	HRESULT hr = S_OK;
	CComPtr<IVSSItem> pIItem;
	wstring szItem(szBasePrj);
	MakePrjSpec(szItem,szRelSpec);

	// see if the item exists
	CError::Trace(szBasePrj); CError::Trace(L"/"); CError::Trace(szRelSpec); CError::Trace(" Get ");
	hr = GetItemEx(szItem.c_str(),&pIItem,false);
	if(SUCCEEDED(hr))
	{ 
		CError::Trace("exists ");
		// checkout file
		CComBSTR bstrFileSpec(szFileSpec);
		hr = pIItem->Get(&bstrFileSpec,VSSFLAG_REPREPLACE|VSSFLAG_USERRONO);
		IF_FAIL_RTN1(hr,"\nGet");
		CError::Trace("gotten ");
	} 
	else if(hr == ESS_VS_NOT_FOUND)
	{
		HANDLE hFile = NULL;
		hFile = CreateFile(szFileSpec,
							 GENERIC_READ|GENERIC_WRITE,
							 0,
							 NULL,
							 CREATE_ALWAYS,
							 FILE_ATTRIBUTE_TEMPORARY|FILE_FLAG_SEQUENTIAL_SCAN,
							 NULL);
		if(hFile == INVALID_HANDLE_VALUE)
		{
			hFile = NULL;
			hr = GetLastError();
			FAIL_RTN1(hr,"\nCreateFile");
		}
		CloseHandle(hFile);
		hFile = NULL;
		hr = S_OK;
	}

	CError::Trace("\n");
	return hr;
}

HRESULT CVerEngine::CheckOut(LPCTSTR szFileSpec,LPCTSTR szBasePrj,LPCTSTR szRelSpec)
{
	_ASSERTE(m_pIDB && szFileSpec && szBasePrj && szRelSpec);

	HRESULT hr = S_OK;
	CComPtr<IVSSItem> pIItem;
	wstring szItem(szBasePrj);
	MakePrjSpec(szItem,szRelSpec);

	// see if the item exists
	CError::Trace(szBasePrj); CError::Trace(L"/"); CError::Trace(szRelSpec); CError::Trace(" Checkout ");
	hr = GetItemEx(szItem.c_str(),&pIItem,true);
	if( SUCCEEDED(hr) )
	{ 
		CError::Trace("exists ");
		// checkout file
		hr = CheckOutLocal(pIItem,szFileSpec);
		IF_FAIL_RTN1(hr,"\nCheckout");
		CError::Trace("gotten ");
	} 
	else 
		FAIL_RTN1(hr,"\nGetItemEx");

	CError::Trace("\n");
	return hr;
}

HRESULT CVerEngine::CheckOutNoGet(IVSSItem *pIItem)
{
	_ASSERTE(pIItem);
	HRESULT hr = S_OK;
	long iStatus = 0;

	// is files checked out?
	hr = pIItem->get_IsCheckedOut(&iStatus);
	IF_FAIL_RTN1(hr,"\nget_IsCheckOut");

	// check it out to me
	if(iStatus != VSSFILE_CHECKEDOUT_ME)
	{ 
		hr = pIItem->Checkout(NULL,NULL,VSSFLAG_GETNO);
		IF_FAIL_RTN1(hr,"\nCheckout");
	}
	return hr;
}

HRESULT CVerEngine::CheckIn(IVSSItem *pIItem,LPCTSTR szFileSpec)
{
	_ASSERTE(pIItem && szFileSpec);
	HRESULT hr = S_OK;

	hr = CheckOutNoGet(pIItem);
	if(FAILED(hr))
		return hr;

	// checkin
	hr = pIItem->Checkin(NULL,_bstr_t(szFileSpec),VSSFLAG_KEEPYES);
	return hr;
}

HRESULT CVerEngine::CheckOutGet(IVSSItem *pIItem)
{
	_ASSERTE(pIItem);
	HRESULT hr = S_OK;
	long iStatus = 0;

	// is files checked out?
	hr = pIItem->get_IsCheckedOut(&iStatus);
	if(FAILED(hr))
		return hr;

	// check it out to me
	if(iStatus != VSSFILE_CHECKEDOUT_ME)
		hr = pIItem->Checkout(NULL,NULL,0);

	return hr;
}

HRESULT CVerEngine::CheckOutLocal(IVSSItem *pIItem,LPCTSTR szFileSpec)
{
	_ASSERTE(pIItem);
	HRESULT hr = S_OK;
	long iStatus = 0;

	// is files checked out?
	hr = pIItem->get_IsCheckedOut(&iStatus);
	if(FAILED(hr))
		return hr;

	// check it out to me
	if(iStatus != VSSFILE_CHECKEDOUT_ME)
	{
		hr = pIItem->Checkout(NULL,_bstr_t(szFileSpec),0);
	}
	else
	{
		CComBSTR bstrFileSpec(szFileSpec);
		hr = pIItem->Get(&bstrFileSpec,0);
	}
	return hr;
}

HRESULT CVerEngine::GetPrjEx(LPCTSTR szPrj,IVSSItem **hIPrj,bool bCreate)
{
	_ASSERTE(hIPrj && szPrj);
	HRESULT hr = S_OK;
	*hIPrj = NULL;
	_bstr_t bstrPrj(szPrj);
	
	hr = m_pIDB->get_VSSItem(bstrPrj,false,hIPrj);
	if( hr == ESS_VS_NOT_FOUND 
		&& bCreate )
	{
		// does it exist as delete
		hr = m_pIDB->get_VSSItem(bstrPrj,true,hIPrj);
		if(SUCCEEDED(hr))
		{
			hr = (*hIPrj)->put_Deleted(false);	// make sure it's not deleted
		} 
		else if(hr == ESS_VS_NOT_FOUND)
		{
			// find the top-most prj that exists
			CComPtr<IVSSItem> pItmp;
			wstring sztmp = szPrj;
			int iPos = wstring::npos;
			while( hr == ESS_VS_NOT_FOUND )
			{
				iPos = sztmp.find_last_of(L"/");
				if(iPos == wstring::npos)
					return E_FAIL;
				sztmp = sztmp.substr(0,iPos).c_str();
				if(sztmp.size() == 1)			// if we reached $/
					sztmp = L"$/";				// we need to have the / in $/
				hr = m_pIDB->get_VSSItem(_bstr_t(sztmp.c_str()),false,&pItmp);
			}
			IF_FAIL_RTN1(hr,"get_VSSItem");

			// add recursivly the remaining subprojects
			CComPtr<IVSSItem> pItmp2;
			int iPos2 = 0;
			sztmp = szPrj;
			_bstr_t bstrSubPrj;
			while( iPos2 != wstring::npos )
			{
				++iPos;
				iPos2 = sztmp.find_first_of(L"/",iPos);
				if(iPos2 == wstring::npos)
					bstrSubPrj = sztmp.substr(iPos,sztmp.length()-iPos).c_str();
				else
					bstrSubPrj = sztmp.substr(iPos,iPos2-iPos).c_str();
				hr = pItmp->NewSubproject(bstrSubPrj,NULL,&pItmp2);
				IF_FAIL_RTN1(hr,"NewSubproject");
				iPos = iPos2;
				pItmp.Release();
				pItmp = pItmp2;
				pItmp2.Release();
			}
			*hIPrj = pItmp;
			(*hIPrj)->AddRef();
			pItmp.Release();
			hr = S_FALSE; // signal that we created it
		}
	}
	IF_FAIL_RTN1(hr,"get_VSSItem");
	
	return hr;
}

HRESULT CVerEngine::GetItemEx(LPCTSTR szItem,IVSSItem **hIItem,bool bCreate)
{
	_ASSERTE(hIItem && szItem);
	HRESULT hr = S_OK;
	*hIItem = NULL;
	_bstr_t bstrItem(szItem);

	hr = m_pIDB->get_VSSItem(bstrItem,false,hIItem);
	if( hr == ESS_VS_NOT_FOUND 
		&& bCreate )
	{
		// does it exist as delete
		hr = m_pIDB->get_VSSItem(bstrItem,true,hIItem);
		if(SUCCEEDED(hr))
		{
			hr = (*hIItem)->put_Deleted(false);		// make sure it's not deleted
			IF_FAIL_RTN1(hr,"put_Deleted");
			hr = S_FALSE;
		}
		else if(hr == ESS_VS_NOT_FOUND)
		{
			CComPtr<IVSSItem> pIPrj;
			
			// get prj
			wstring szItem = szItem;
			int iFileNameIndex = szItem.find_last_of(L"/");
			if(iFileNameIndex == wstring::npos)
				return E_FAIL;
			hr = GetPrjEx(_bstr_t(szItem.substr(0,iFileNameIndex).c_str()),&pIPrj,bCreate);
			IF_FAIL_RTN1(hr,"GetPrjEx");

			// add the file to the prj
			HANDLE hFile = NULL;
			TCHAR szTmpSpec[MAX_PATH];
			BOOL b = FALSE;
			CComBSTR bstrFileSpec;
			
			// create an empty file szFileName in tmp dir
			GetTempPath(MAX_PATH,szTmpSpec);
			GetTempFileName(szTmpSpec,L"",0,szTmpSpec);		// creates tmp file
			b = DeleteFile(szTmpSpec);						// delete tmp file since we want tmp dir
			b = CreateDirectory(szTmpSpec,NULL);			// create tmp dir
			bstrFileSpec = szTmpSpec;
			bstrFileSpec.Append(L"\\");
			bstrFileSpec.Append(szItem.substr(iFileNameIndex+1).c_str());
			hFile = CreateFile(bstrFileSpec,				// create file in tmp dir
					   GENERIC_READ|GENERIC_WRITE,
					   0,
					   NULL,
					   CREATE_ALWAYS,
					   FILE_ATTRIBUTE_TEMPORARY,
					   NULL);
			CloseHandle(hFile);
			// add this file
			hr = pIPrj->Add(bstrFileSpec,NULL,VSSFLAG_KEEPYES,hIItem);
			b = DeleteFile(bstrFileSpec);
			b = RemoveDirectory(szTmpSpec);
			hr = S_FALSE;
		}
	}
	else if(hr == ESS_VS_NOT_FOUND)
		return hr;
	IF_FAIL_RTN1(hr,"get_VSSItem");

	return hr;
}

void CVerEngine::EliminateCommon(list<wstring> &ListOne, list<wstring> &ListTwo)
{
	int sizeOne = ListOne.size();
	int sizeTwo = ListTwo.size();

	if(sizeOne == 0 || sizeTwo == 0)
		return;

	list<wstring> &List1 = ListTwo;
	list<wstring> &List2 = ListOne;
	if(sizeOne >= sizeTwo)
	{
		List1 = ListOne;
		List2 = ListTwo;
	} 

	list<wstring>::iterator i;
	list<wstring>::iterator j;

	for(i = List1.begin(); i != List1.end(); ++i)
	{
		for(j = List2.begin(); j != List2.end(); ++j)
		{
			if((*i).compare(*j) == 0)
			{
				List1.erase(i);
				List2.erase(j);
				break;
			}
		}
	}
}

HRESULT CVerEngine::SyncPrj(LPCTSTR szBasePrj,LPCTSTR szDir)
{
	bool result = true;
	typedef list<wstring> wstringlist;
	wstringlist FileList;
	wstringlist DirList;

	WIN32_FIND_DATA finddata;
    HANDLE hFind = FindFirstFile( wstring(szDir).append(L"\\*.*").c_str(), &finddata);
	if(hFind == INVALID_HANDLE_VALUE && GetLastError() != ERROR_NO_MORE_FILES)
		return GetLastError();
	do
	{
		if(finddata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
			DirList.insert(DirList.end(),finddata.cFileName);
		else
			FileList.insert(FileList.end(),finddata.cFileName);
	}
	while(FindNextFile(hFind,&finddata));
	FindClose(hFind);
	hFind = 0;

	HRESULT hr;
	wstringlist::iterator i;
	for(i = FileList.begin(); i != FileList.end(); ++i)
	{
		hr = Sync(szBasePrj,
					szDir,
					(*i).c_str());
		IF_FAIL_RTN1(hr,"Sync");
	}
		
	for(i = DirList.begin(); i != DirList.end(); ++i)
	{
	}

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\mdtools\iisnet\main.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    main.cxx

Abstract:

    Server Instance Controller.

Author:

    Keith Moore (keithmo)        05-Feb-1997

Revision History:

--*/


#include "precomp.hxx"
#pragma hdrstop


//
// Private constants.
//

#define TEST_HRESULT(api,hr,fatal)                                          \
            if( FAILED(hr) ) {                                              \
                                                                            \
                wprintf(                                                    \
                    L"%S:%lu failed, error %lx %S\n",                       \
                    (api),                                                  \
                    __LINE__,                                               \
                    (result),                                               \
                    (fatal)                                                 \
                        ? "ABORTING"                                        \
                        : "CONTINUING"                                      \
                    );                                                      \
                                                                            \
                if( fatal ) {                                               \
                                                                            \
                    goto cleanup;                                           \
                                                                            \
                }                                                           \
                                                                            \
            } else


//
// Private types.
//


//
// Private globals.
//

COMMAND_TABLE CommandTable[] =
    {
        { L"Start",     &StartCommand       },
        { L"Stop",      &StopCommand        },
        { L"Pause",     &PauseCommand       },
        { L"Continue",  &ContinueCommand    },
        { L"Query",     &QueryCommand       }
    };

#define NUM_COMMANDS ( sizeof(CommandTable) / sizeof(CommandTable[0]) )


//
// Private prototypes.
//

VOID
Usage(
    VOID
    );


//
// Public functions.
//


INT
__cdecl
wmain(
    IN INT argc,
    IN LPWSTR argv[]
    )
{

    HRESULT result;
    ADMIN_SINK * sink;
    IMSAdminBase * admCom;
    DWORD i;
    PCOMMAND_TABLE command;

    //
    // Setup locals so we know how to cleanup on exit.
    //

    admCom = NULL;
    sink = NULL;

    //
    // Validate the arguments.
    //

    if( argc == 1 ) {

        Usage();
        return 1;

    }

    for( i = 0, command = CommandTable ;
         i < NUM_COMMANDS ;
         i++, command++ ) {

        if( !_wcsicmp( argv[1], command->Name ) ) {

            break;

        }

    }

    if( i == NUM_COMMANDS ) {

        Usage();
        return 1;

    }

    argc -= 2;      // Skip the program name...
    argv += 2;      // ...and the command name.

    //
    // Initialize COM.
    //

    result = CoInitializeEx(
                 NULL,
                 COINIT_MULTITHREADED
                 );

    TEST_HRESULT( "CoInitializeEx()", result, TRUE );

    //
    // Get the admin object.
    //

    result = MdGetAdminObject( &admCom );

    TEST_HRESULT( "MdGetAdminObject()", result, TRUE );

    //
    // Setup the advise sink.
    //

    sink = new ADMIN_SINK();

    if( sink == NULL ) {

        result = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );

    } else {

        sink->AddRef();
        result = sink->Initialize( (IUnknown *)admCom );

    }

    TEST_HRESULT( "sink->Initialize()", result, TRUE );

    //
    // Let the command handler do the dirty work.
    //

    command->Handler(
        admCom,
        sink,
        argc,
        argv
        );

cleanup:

    if( sink != NULL ) {
        sink->Unadvise();
        sink->Release();
    }

    //
    // Release the admin object.
    //

    if( admCom != NULL ) {
        result = MdReleaseAdminObject( admCom );
        TEST_HRESULT( "MdReleaseAdminObject()", result, FALSE );
    }

    //
    // Shutdown COM.
    //

    CoUninitialize();

    return 0;

}   // main


//
// Private functions.
//

VOID
Usage(
    VOID
    )
{

    wprintf(
        L"Use: iisnet operation service/instance\n"
        L"\n"
        L"Valid operations are:\n"
        L"\n"
        L"    start\n"
        L"    stop\n"
        L"    pause\n"
        L"    continue\n"
        L"    query\n"
        L"\n"
        L"For example:\n"
        L"\n"
        L"    iisnet pause w3svc/1\n"
        );

}   // Usage
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\mdtools\iisnet\cmds.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    cmds.cxx

Abstract:

    IISNET command handlers.

Author:

    Keith Moore (keithmo)        05-Feb-1997

Revision History:

--*/


#include "precomp.hxx"
#pragma hdrstop


//
// Private constants.
//

#define WAIT_FOR_STATE_CHANGE_TIMEOUT   1000    // ms


//
// Private types.
//

typedef struct _ENUM_CONTEXT {

    BOOL ShowAll;
    LPWSTR Instance;
    WCHAR Service[MAX_PATH];

} ENUM_CONTEXT, *PENUM_CONTEXT;


//
// Private globals.
//


//
// Private prototypes.
//

VOID
PerformStateChange(
    IN IMSAdminBase * AdmCom,
    IN ADMIN_SINK * Sink,
    IN LPWSTR InstanceName,
    IN DWORD Command,
    IN DWORD TransientState
    );

VOID
EnumInstances(
    IN IMSAdminBase * AdmCom,
    IN BOOL ShowAll
    );

BOOL
WINAPI
ServerLevelCallback(
    IN IMSAdminBase * AdmCom,
    IN LPWSTR ObjectName,
    IN VOID * Context
    );

BOOL
WINAPI
InstanceLevelCallback(
    IN IMSAdminBase * AdmCom,
    IN LPWSTR ObjectName,
    IN VOID * Context
    );


//
// Public functions.
//

VOID
WINAPI
StartCommand(
    IN IMSAdminBase * AdmCom,
    IN ADMIN_SINK * Sink,
    IN INT argc,
    IN LPWSTR argv[]
    )
{

    if( argc == 0 ) {

        EnumInstances(
            AdmCom,
            FALSE       // ShowAll
            );

    } else
    if( argc == 1 ) {

        PerformStateChange(
            AdmCom,
            Sink,
            *argv,
            MD_SERVER_COMMAND_START,
            MD_SERVER_STATE_STARTING
            );

    } else {

        wprintf(
            L"use: iisnet start [service/instance]\n"
            );

    }

}   // StartCommand

VOID
WINAPI
StopCommand(
    IN IMSAdminBase * AdmCom,
    IN ADMIN_SINK * Sink,
    IN INT argc,
    IN LPWSTR argv[]
    )
{

    if( argc != 1 ) {

        wprintf(
            L"use: iisnet stop service/instance\n"
            );

    } else {

        PerformStateChange(
            AdmCom,
            Sink,
            *argv,
            MD_SERVER_COMMAND_STOP,
            MD_SERVER_STATE_STOPPING
            );

    }

}   // StopCommand

VOID
WINAPI
PauseCommand(
    IN IMSAdminBase * AdmCom,
    IN ADMIN_SINK * Sink,
    IN INT argc,
    IN LPWSTR argv[]
    )
{

    if( argc != 1 ) {

        wprintf(
            L"use: iisnet pause service/instance\n"
            );

    } else {

        PerformStateChange(
            AdmCom,
            Sink,
            *argv,
            MD_SERVER_COMMAND_PAUSE,
            MD_SERVER_STATE_PAUSING
            );

    }

}   // PauseCommand

VOID
WINAPI
ContinueCommand(
    IN IMSAdminBase * AdmCom,
    IN ADMIN_SINK * Sink,
    IN INT argc,
    IN LPWSTR argv[]
    )
{

    if( argc != 1 ) {

        wprintf(
            L"use: iisnet continue service/instance\n"
            );

    } else {

        PerformStateChange(
            AdmCom,
            Sink,
            *argv,
            MD_SERVER_COMMAND_CONTINUE,
            MD_SERVER_STATE_CONTINUING
            );

    }

}   // ContinueCommand

VOID
WINAPI
QueryCommand(
    IN IMSAdminBase * AdmCom,
    IN ADMIN_SINK * Sink,
    IN INT argc,
    IN LPWSTR argv[]
    )
{

    if( argc == 0 ) {

        EnumInstances(
            AdmCom,
            TRUE        // ShowAll
            );

    } else
    if( argc == 1 ) {

        HRESULT result;

        result = MdDisplayInstanceState(
                     AdmCom,
                     *argv
                     );

        if( FAILED(result) ) {

            wprintf(
                L"iisnet: cannot get instance state, error %lx\n",
                result
                );

        }

    } else {

        wprintf(
            L"use: iisnet query [server/instance]\n"
            );

    }

}   // QueryCommand


//
// Private functions.
//

VOID
PerformStateChange(
    IN IMSAdminBase * AdmCom,
    IN ADMIN_SINK * Sink,
    IN LPWSTR InstanceName,
    IN DWORD Command,
    IN DWORD TransientState
    )
{

    HRESULT result;
    DWORD status;
    DWORD currentState;
    DWORD currentWin32Status;

    result = MdDisplayInstanceState(
                 AdmCom,
                 InstanceName
                 );

    if( FAILED(result) ) {

        wprintf(
            L"Cannot query server state, error %lx\n",
            result
            );

        return;

    }

    result = MdControlInstance(
                 AdmCom,
                 InstanceName,
                 Command
                 );

    if( FAILED(result) ) {

        wprintf(
            L"Cannot set server state, error %lu\n",
            result
            );

        return;

    }

    wprintf(
        L"Waiting for state change..."
        );

    currentState = TransientState;

    do {

        status = Sink->WaitForStateChange( WAIT_FOR_STATE_CHANGE_TIMEOUT );

        if( status == WAIT_TIMEOUT ) {
            wprintf( L"." );
            continue;
        }

        result = MdGetInstanceState(
                     AdmCom,
                     InstanceName,
                     &currentState,
                     &currentWin32Status
                     );

        if( FAILED(result) ) {

            wprintf(
                L"Cannot query server state, error %lx\n",
                result
                );

            break;

        }

    } while( currentState == TransientState );

    wprintf( L"\n" );

    MdDisplayInstanceState(
        AdmCom,
        InstanceName
        );

}   // PerformStateChange

VOID
EnumInstances(
    IN IMSAdminBase * AdmCom,
    IN BOOL ShowAll
    )
{

    HRESULT result;
    ENUM_CONTEXT context;

    context.ShowAll = ShowAll;

    result = MdEnumMetaObjects(
                 AdmCom,
                 L"LM",
                 &ServerLevelCallback,
                 (VOID *)&context
                 );

    if( FAILED(result) ) {

        wprintf(
            L"iisnet: cannot enumerate servers, error %lx\n",
            result
            );

    }

}   // EnumRunningInstances

BOOL
WINAPI
ServerLevelCallback(
    IN IMSAdminBase * AdmCom,
    IN LPWSTR ObjectName,
    IN VOID * Context
    )
{

    HRESULT result;
    PENUM_CONTEXT context = (PENUM_CONTEXT)Context;
    WCHAR path[MAX_PATH];

    swprintf(
        path,
        L"%S/%s",
        IIS_MD_LOCAL_MACHINE_PATH,
        ObjectName
        );

    wcscpy(
        context->Service,
        ObjectName
        );

    context->Instance = context->Service + wcslen( ObjectName );

    result = MdEnumMetaObjects(
                 AdmCom,
                 path,
                 &InstanceLevelCallback,
                 Context
                 );

    return TRUE;

}   // ServerLevelCallback

BOOL
WINAPI
InstanceLevelCallback(
    IN IMSAdminBase * AdmCom,
    IN LPWSTR ObjectName,
    IN VOID * Context
    )
{

    HRESULT result;
    PENUM_CONTEXT context = (PENUM_CONTEXT)Context;
    DWORD currentState;
    DWORD currentWin32Status;

    swprintf(
        context->Instance,
        L"/%s",
        ObjectName
        );

    result = MdGetInstanceState(
                 AdmCom,
                 context->Service,
                 &currentState,
                 &currentWin32Status
                 );

    if( SUCCEEDED(result) ) {

        if( context->ShowAll || currentState == MD_SERVER_STATE_STARTED ) {

            wprintf(
                L"%s: state = %lu (%s), status = %lu\n",
                context->Service,
                currentState,
                MdInstanceStateToString( currentState ),
                currentWin32Status
                );

        }

    }

    return TRUE;

}   // InstanceLevelCallback
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\mdtools\lib\admin.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    admin.cxx

Abstract:

    General metadata utility functions.

Author:

    Keith Moore (keithmo)        05-Feb-1997

Revision History:

--*/


#include "precomp.hxx"
#pragma hdrstop


//
// Private constants.
//


//
// Private types.
//


//
// Private globals.
//


//
// Private prototypes.
//


//
// Public functions.
//

HRESULT
MdGetAdminObject(
    OUT IMSAdminBase ** AdmCom
    )
{

    HRESULT result;
    IClassFactory * classFactory;

    //
    // Get the admin class factory.
    //

    result = CoGetClassObject(
                 GETAdminBaseCLSID(TRUE),
                 CLSCTX_SERVER,
                 NULL,
                 IID_IClassFactory,
                 (VOID **)&classFactory
                 );

    if( SUCCEEDED(result) ) {

        //
        // Create the admin object.
        //

        result = classFactory->CreateInstance(
                     NULL,
                     IID_IMSAdminBase,
                     (VOID **)AdmCom
                     );

        classFactory->Release();

    }

    return result;

}   // MdGetAdminObject

HRESULT
MdReleaseAdminObject(
    IN IMSAdminBase * AdmCom
    )
{

    //
    // Terminate the admin object.
    //

    AdmCom->Release();

    return NO_ERROR;

}   // MdReleaseAdminObject


//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\mdtools\lib\data.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    enum.cxx

Abstract:

    General metadata utility functions.

Author:

    Keith Moore (keithmo)        05-Feb-1997

Revision History:

--*/


#include "precomp.hxx"
#pragma hdrstop


//
// Private constants.
//

#define INITIAL_BUFFER_SIZE 64


//
// Private types.
//


//
// Private globals.
//


//
// Private prototypes.
//


//
// Public functions.
//

HRESULT
MdGetAllMetaData(
    IN IMSAdminBase * AdmCom,
    IN METADATA_HANDLE Handle,
    IN LPWSTR Path,
    IN DWORD Attributes,
    OUT METADATA_GETALL_RECORD ** Data,
    OUT DWORD * NumEntries
    )
{

    HRESULT result;
    DWORD dataSet;
    DWORD bytesRequired;
    DWORD bufferLength;
    LPVOID buffer;

    bufferLength = INITIAL_BUFFER_SIZE;
    buffer = NULL;

    while( TRUE ) {

        if( buffer != NULL ) {
            MdpFreeMem( buffer );
        }

        buffer = MdpAllocMem( bufferLength );

        if( buffer == NULL ) {
            result = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
            break;
        }

        result = AdmCom->GetAllData(
                     Handle,
                     Path,
                     Attributes,
                     ALL_METADATA,
                     ALL_METADATA,
                     NumEntries,
                     &dataSet,
                     bufferLength,
                     (BYTE *)buffer,
                     &bytesRequired
                     );

        if( SUCCEEDED(result) ) {
            break;
        }

        if( result != RETURNCODETOHRESULT( ERROR_INSUFFICIENT_BUFFER ) ) {
            break;
        }

        bufferLength = bytesRequired;

    }

    if( SUCCEEDED(result) ) {
        *Data = (METADATA_GETALL_RECORD *)buffer;
    } else if( buffer != NULL ) {
        MdpFreeMem( buffer );
    }

    return result;

}   // MdGetAllMetaData

HRESULT
MdFreeMetaDataBuffer(
    IN VOID * Data
    )
{

    MdpFreeMem( Data );
    return NO_ERROR;

}   // MdFreeMetaDataBuffer

//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\mdtools\lib\enum.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    enum.cxx

Abstract:

    General metadata utility functions.

Author:

    Keith Moore (keithmo)        05-Feb-1997

Revision History:

--*/


#include "precomp.hxx"
#pragma hdrstop


//
// Private constants.
//


//
// Private types.
//


//
// Private globals.
//


//
// Private prototypes.
//


//
// Public functions.
//

HRESULT
MdEnumMetaObjects(
    IN IMSAdminBase * AdmCom,
    IN LPWSTR KeyName,
    IN PFN_ADMIN_ENUM_CALLBACK Callback,
    IN VOID * Context
    )
{

    HRESULT result;
    METADATA_HANDLE handle;
    DWORD index;
    WCHAR path[MAX_PATH];

    //
    // Setup locals so we know how to cleanup on exit.
    //

    handle = 0;

    //
    // Open the metabase.
    //

    result = AdmCom->OpenKey(
                 METADATA_MASTER_ROOT_HANDLE,
                 KeyName,
                 METADATA_PERMISSION_READ,
                 METABASE_OPEN_TIMEOUT,
                 &handle
                 );

    if( FAILED(result) ) {
        goto Cleanup;
    }

    //
    // Enumerate the objects.
    //

    for( index = 0 ; ; index++ ) {

        result = AdmCom->EnumKeys(
                     handle,
                     L"",
                     path,
                     index
                     );

        if( FAILED(result) ) {
            break;
        }

        if( !(Callback)(
                AdmCom,
                path,
                Context
                ) ) {
            break;
        }

    }

    result = NO_ERROR;

Cleanup:

    if( handle != 0 ) {
        (VOID)AdmCom->CloseKey( handle );
    }

    return result;

}   // MdEnumMetaObjects


//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\mdtools\iisnet\sink.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    sink.cxx

Abstract:

    Implements the ADMIN_SINK object.

Author:

    Keith Moore (keithmo)        05-Feb-1997

Revision History:

--*/


#include "precomp.hxx"
#pragma hdrstop


//
// Private constants.
//


//
// Private types.
//


//
// Private globals.
//


//
// Private prototypes.
//


//
// Public functions.
//

ADMIN_SINK::ADMIN_SINK()
{

    //
    // Put everything into a known state.
    //

    m_StateChangeEvent = NULL;

}   // ADMIN_SINK::ADMIN_SINK

ADMIN_SINK::~ADMIN_SINK()
{

    //
    // Zap the state change event.
    //

    if( m_StateChangeEvent != NULL ) {

        CloseHandle( m_StateChangeEvent );
        m_StateChangeEvent = NULL;

    }

}   // ADMIN_SINK::~ADMIN_SINK

HRESULT
ADMIN_SINK::Initialize(
    IN IUnknown * Object
    )
{

    HRESULT result;

    result = BASE_ADMIN_SINK::Initialize( Object );

    if( SUCCEEDED(result) ) {

        m_StateChangeEvent = CreateEvent(
                                 NULL,          // lpEventAttributes
                                 FALSE,         // bManualReset
                                 FALSE,         // bInitialState
                                 NULL           // lpName
                                 );

        if( m_StateChangeEvent == NULL ) {
            DWORD err = GetLastError();
            result = HRESULT_FROM_WIN32( err );
        }

    }

    return result;

}   // ADMIN_SINK::Initialize

HRESULT
STDMETHODCALLTYPE
ADMIN_SINK::SinkNotify(
    IN DWORD NumElements,
    IN MD_CHANGE_OBJECT ChangeList[]
    )
{

    DWORD numIds;
    DWORD *idList;

    //
    // Scan the change list. If MD_SERVER_STATE has changed, set the
    // change event so the polling loop will exit.
    //

    for( ; NumElements > 0 ; NumElements--, ChangeList++ ) {

        numIds = ChangeList->dwMDNumDataIDs;
        idList = ChangeList->pdwMDDataIDs;

        for( ; numIds > 0 ; numIds--, idList++ ) {

            if( *idList == MD_SERVER_STATE ) {

                SetEvent( m_StateChangeEvent );
                break;

            }

        }

    }

    return NO_ERROR;

}   // ADMIN_SINK::SinkNotify

DWORD
ADMIN_SINK::WaitForStateChange(
    IN DWORD Timeout
    )
{

    return WaitForSingleObject(
               m_StateChangeEvent,
               Timeout
               );

}   // ADMIN_SINK::WaitForStateChange


//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\mdtools\lib\instance.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    instance.cxx

Abstract:

    General server instance control utility functions.

Author:

    Keith Moore (keithmo)        05-Feb-1997

Revision History:

--*/


#include "precomp.hxx"
#pragma hdrstop


//
// Private constants.
//


//
// Private types.
//


//
// Private globals.
//


//
// Private prototypes.
//


//
// Public functions.
//

HRESULT
MdGetInstanceState(
    IN IMSAdminBase * AdmCom,
    IN LPWSTR InstanceName,
    OUT DWORD * CurrentState,
    OUT DWORD * CurrentWin32Status
    )
{

    DWORD length;
    METADATA_HANDLE handle;
    HRESULT result;
    METADATA_RECORD record;
    WCHAR path[MAX_PATH];

    //
    // Setup locals so we know how to cleanup on exit.
    //

    handle = 0;

    //
    // Build the instance path.
    //

    swprintf(
        path,
        L"/%S/%s",
        IIS_MD_LOCAL_MACHINE_PATH,
        InstanceName
        );

    //
    // Open the metabase.
    //

    result = AdmCom->OpenKey(
                 METADATA_MASTER_ROOT_HANDLE,
                 path,
                 METADATA_PERMISSION_READ,
                 METABASE_OPEN_TIMEOUT,
                 &handle
                 );

    if( FAILED(result) ) {
        goto Cleanup;
    }

    //
    // Read the server state.
    //

    length = sizeof(*CurrentState);

    INITIALIZE_METADATA_RECORD(
        &record,
        MD_SERVER_STATE,
        METADATA_INHERIT,
        IIS_MD_UT_SERVER,
        DWORD_METADATA,
        length,
        CurrentState
        );

    result = AdmCom->GetData(
                 handle,
                 L"",
                 &record,
                 &length
                 );

    if( FAILED(result) ) {
        goto Cleanup;
    }

    //
    // Read the win32 status.
    //

    length = sizeof(*CurrentWin32Status);

    INITIALIZE_METADATA_RECORD(
        &record,
        MD_WIN32_ERROR,
        METADATA_INHERIT,
        IIS_MD_UT_SERVER,
        DWORD_METADATA,
        length,
        CurrentWin32Status
        );

    result = AdmCom->GetData(
                 handle,
                 L"",
                 &record,
                 &length
                 );

    if( FAILED(result) ) {

        if( result == MD_ERROR_DATA_NOT_FOUND ) {
            *CurrentWin32Status = NO_ERROR;
            result = NO_ERROR;
        } else {
            goto Cleanup;
        }

    }

Cleanup:

    if( handle != 0 ) {
        (VOID)AdmCom->CloseKey( handle );
    }

    return result;

}   // MdGetInstanceState

HRESULT
MdControlInstance(
    IN IMSAdminBase * AdmCom,
    IN LPWSTR InstanceName,
    IN DWORD Command
    )
{

    METADATA_HANDLE handle;
    HRESULT result;
    METADATA_RECORD record;
    WCHAR path[MAX_PATH];

    //
    // Setup locals so we know how to cleanup on exit.
    //

    handle = 0;
    result = NO_ERROR;

    //
    // Build the instance path.
    //

    swprintf(
        path,
        L"/%S/%s",
        IIS_MD_LOCAL_MACHINE_PATH,
        InstanceName
        );

    //
    // Open the metabase.
    //

    result = AdmCom->OpenKey(
                 METADATA_MASTER_ROOT_HANDLE,
                 path,
                 METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                 METABASE_OPEN_TIMEOUT,
                 &handle
                 );

    if( SUCCEEDED(result) ) {

        //
        // Send the command.
        //

        INITIALIZE_METADATA_RECORD(
            &record,
            MD_SERVER_COMMAND,
            METADATA_INHERIT,
            IIS_MD_UT_SERVER,
            DWORD_METADATA,
            sizeof(Command),
            &Command
            );

        result = AdmCom->SetData(
                     handle,
                     L"",
                     &record
                     );

        //
        // Close the meta object handle.
        //

        (VOID)AdmCom->CloseKey( handle );

    }

    return result;

}   // MdControlInstance

HRESULT
MdDisplayInstanceState(
    IN IMSAdminBase * AdmCom,
    IN LPWSTR InstanceName
    )
{

    DWORD currentState;
    DWORD currentWin32Status;
    HRESULT result;

    //
    // Get the current state.
    //

    result = MdGetInstanceState(
                 AdmCom,
                 InstanceName,
                 &currentState,
                 &currentWin32Status
                 );

    if( SUCCEEDED(result) ) {

        wprintf(
            L"%s: state = %lu (%s), status = %lu\n",
            InstanceName,
            currentState,
            MdInstanceStateToString( currentState ),
            currentWin32Status
            );

    }

    return result;

}   // MdDisplayInstanceState

LPWSTR
MdInstanceStateToString(
    IN DWORD State
    )
{

    static WCHAR invalidState[sizeof("INVALID STATE 4294967296")];

    switch( State ) {

    case MD_SERVER_STATE_STARTING :
        return L"Starting";

    case MD_SERVER_STATE_STARTED :
        return L"Started";

    case MD_SERVER_STATE_STOPPING :
        return L"Stopping";

    case MD_SERVER_STATE_STOPPED :
        return L"Stopped";

    case MD_SERVER_STATE_PAUSING :
        return L"Pausing";

    case MD_SERVER_STATE_PAUSED :
        return L"Paused";

    case MD_SERVER_STATE_CONTINUING :
        return L"Continuing";

    }

    swprintf(
        invalidState,
        L"INVALID STATE %lu",
        State
        );

    return invalidState;

}   // MdInstanceStateToString


//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\mdtools\lib\beta2\admin.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    admin.cxx

Abstract:

    General metadata utility functions.

Author:

    Keith Moore (keithmo)        05-Feb-1997

Revision History:

--*/


#include "precomp.hxx"
#pragma hdrstop


//
// Private constants.
//


//
// Private types.
//


//
// Private globals.
//


//
// Private prototypes.
//


//
// Public functions.
//

HRESULT
MdGetAdminObject(
    OUT IMSAdminBase ** AdmCom
    )
{

    HRESULT result;
    IClassFactory * classFactory;

    //
    // Get the admin class factory.
    //

    result = CoGetClassObject(
                 GETAdminBaseCLSID(TRUE),
                 CLSCTX_SERVER,
                 NULL,
                 IID_IClassFactory,
                 (VOID **)&classFactory
                 );

    if( SUCCEEDED(result) ) {

        //
        // Create the admin object.
        //

        result = classFactory->CreateInstance(
                     NULL,
                     IID_IMSAdminBase,
                     (VOID **)AdmCom
                     );

        classFactory->Release();

    }

    return result;

}   // MdGetAdminObject

HRESULT
MdReleaseAdminObject(
    IN IMSAdminBase * AdmCom
    )
{

    HRESULT result;

    //
    // Terminate the admin object.
    //

    AdmCom->Release();

    return result;

}   // MdReleaseAdminObject


//
// Private functions.
//


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\mdtools\lib\sink.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    sink.cxx

Abstract:

    Implements the BASE_ADMIN_SINK object.

Author:

    Keith Moore (keithmo)        05-Feb-1997

Revision History:

--*/


#include "precomp.hxx"
#pragma hdrstop


//
// Private constants.
//


//
// Private types.
//


//
// Private globals.
//


//
// Private prototypes.
//


//
// Public functions.
//

BASE_ADMIN_SINK::BASE_ADMIN_SINK()
{

    //
    // Put everything into a known state.
    //

    m_ReferenceCount = 0;
    m_SinkCookie = 0;
    m_ConnectionPoint = NULL;

}   // BASE_ADMIN_SINK::BASE_ADMIN_SINK

BASE_ADMIN_SINK::~BASE_ADMIN_SINK()
{

    //
    // Unadvise if necessary.
    //

    Unadvise();

    //
    // Release the connection point.
    //

    RELEASE_INTERFACE( m_ConnectionPoint );

}   // BASE_ADMIN_SINK::~BASE_ADMIN_SINK

HRESULT
BASE_ADMIN_SINK::Initialize(
    IN IUnknown * Object
    )
{

    HRESULT result;
    IConnectionPointContainer * container;

    //
    // Get the connection point container from the given interface.
    //

    result = Object->QueryInterface(
                 IID_IConnectionPointContainer,
                 (VOID **)&container
                 );

    if( SUCCEEDED(result) ) {

        //
        // Find the necessary connection point.
        //

        result = container->FindConnectionPoint(
                     IID_IMSAdminBaseSink,
                     &m_ConnectionPoint
                     );

        if( SUCCEEDED(result) ) {

            //
            // Setup the advise association.
            //

            result = m_ConnectionPoint->Advise(
                         (IUnknown *)this,
                         &m_SinkCookie
                         );


        }

        container->Release();

    }

    return result;

}   // BASE_ADMIN_SINK::Initialize

HRESULT
BASE_ADMIN_SINK::Unadvise(
    VOID
    )
{

    HRESULT result = NO_ERROR;
    DWORD tmpCookie;

    //
    // Unadvise if necessary.
    //

    tmpCookie = (DWORD)InterlockedExchange(
                    (LPLONG)&m_SinkCookie,
                    0
                    );

    if( tmpCookie != 0 ) {
        result = m_ConnectionPoint->Unadvise( tmpCookie );
    }

    return result;

}   // BASE_ADMIN_SINK::Unadvise

HRESULT
STDMETHODCALLTYPE
BASE_ADMIN_SINK::QueryInterface(
    IN REFIID InterfaceId,
    OUT VOID ** Object
    )
{

    //
    // This class supports IUnknown and IADMCOMSINK. If it's one of these,
    // just return "this". Otherwise, fail it.
    //

    if( InterfaceId == IID_IUnknown ||
        InterfaceId == IID_IMSAdminBaseSink ) {

        *Object = (VOID *)this;
        AddRef();
        return NO_ERROR;

    }

    return E_NOINTERFACE;

}   // BASE_ADMIN_SINK::QueryInterface

ULONG
STDMETHODCALLTYPE
BASE_ADMIN_SINK::AddRef()
{

    ULONG newCount;

    //
    // Increment our ref count and return the updated value.
    //

    newCount = (ULONG)InterlockedIncrement( &m_ReferenceCount );
    return newCount;

}   // BASE_ADMIN_SINK::AddRef

ULONG
STDMETHODCALLTYPE
BASE_ADMIN_SINK::Release()
{

    ULONG newCount;

    //
    // Decrement our ref count. It it becomes zero, delete the current
    // object. In any case, return the updated value.
    //

    newCount = (ULONG)InterlockedDecrement( &m_ReferenceCount );

    if( newCount == 0 ) {
        delete this;
    }

    return newCount;

}   // BASE_ADMIN_SINK::Release


//
// Private functions.
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\metautil\debug.cpp ===
#include "stdafx.h"

#include <stdio.h>
#include <stdarg.h>
#include "debug.h"


//#define ACTIVE_SERVER_PAGES 1


#ifdef _DEBUG

void __cdecl
Trace(
    LPCTSTR ptszFormat,
    ...)
{
    TCHAR tszBuff[2048];
    va_list args;
    
    va_start(args, ptszFormat);
    _vstprintf(tszBuff, ptszFormat, args);
    va_end(args);

    OutputDebugString(tszBuff);
}



# if defined(_MSC_VER)  &&  (_MSC_VER >= 1000)


#  ifdef ACTIVE_SERVER_PAGES

// The default assertion mechanism set up by Visual C++ 4 will not
// work with Active Server Pages because it's running inside a service
// and there is no desktop to interact with.

// Note: for this to work properly, #define _WIN32_WINNT 0x400 before
// including <winuser.h> or MB_SERVICE_NOTIFICATION won't be #define'd.

int __cdecl
AspAssertHandler(
    int   nReportType,
    char* pszErrorText,
    int*  pnReturn)
{
    const char szInfo[] = " (Press ABORT to terminate IIS,"
                          " RETRY to debug this failure,"
                          " or IGNORE to continue.)";
    char* pszMessageTitle = NULL;
    
    // These flags enable message boxes to show up on the user's console
    switch (nReportType)
    {
    case _CRT_WARN:
        pszMessageTitle = "Warning";
        break;
    case _CRT_ERROR:
        pszMessageTitle = "Fatal Error";
        break;
    case _CRT_ASSERT:
        pszMessageTitle = "Assertion Failed";
        break;
    }   
    
    char* pszMessageText =
        static_cast<char*>(_alloca(strlen(pszErrorText) + strlen(szInfo) + 1));

    strcpy(pszMessageText, pszErrorText);
    strcat(pszMessageText, szInfo);
    
    const int n = MessageBoxA(NULL, pszMessageText, pszMessageTitle,
                              (MB_SERVICE_NOTIFICATION | MB_TOPMOST
                               | MB_ABORTRETRYIGNORE | MB_ICONEXCLAMATION));

    if (n == IDABORT)
    {
        exit(1);
    }
    else if (n == IDRETRY)
    {
        *pnReturn = 1;   // tell _CrtDbgReport to start the debugger
        return TRUE;     // tell _CrtDbgReport to run
    }
    
    *pnReturn = 0;       // nothing for _CrtDbgReport to do

    return FALSE;
}

#  endif // ACTIVE_SERVER_PAGES
# endif // _MSC_VER >= 1000



void
DebugInit()
{
# if defined(_MSC_VER)  &&  (_MSC_VER >= 1000)
#  ifdef ACTIVE_SERVER_PAGES
    // If we end up in _CrtDbgReport, don't put up a message box
    _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_DEBUG);
    _CrtSetReportMode(_CRT_WARN,   _CRTDBG_MODE_DEBUG);
    _CrtSetReportMode(_CRT_ERROR,  _CRTDBG_MODE_DEBUG);

    // Use AspAssertHandler to put up a message box instead
    _CrtSetReportHook(AspAssertHandler);
#  endif // ACTIVE_SERVER_PAGES

    // Enable debug heap allocations & check for memory leaks at program exit
    // The memory leak check will not be performed if inetinfo.exe is
    // run directly under a debugger, only if it is run as a service.
    _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF
                   | _CrtSetDbgFlag(_CRTDBG_REPORT_FLAG));
# endif // _MSC_VER >= 1000
}



void
DebugTerm()
{
# if defined(_MSC_VER)  &&  (_MSC_VER >= 1000)
#  ifdef ACTIVE_SERVER_PAGES
    // Turn off AspAssertHandler, so that we don't get numerous message boxes
    // if there are memory leaks on shutdown
    _CrtSetReportHook(NULL);
#  endif // ACTIVE_SERVER_PAGES
# endif // _MSC_VER >= 1000
}

#endif //_DEBUG



BOOL
IsValidString(
    LPCTSTR ptsz,
    int nLength /* =-1 */)
{
    if (ptsz == NULL)
        return FALSE;

    return !IsBadStringPtr(ptsz, nLength);
}



BOOL
IsValidAddress(
    LPCVOID pv,
    UINT nBytes,
    BOOL fReadWrite /* =TRUE */)
{
    return (pv != NULL
            &&  !IsBadReadPtr(pv, nBytes)
            &&  (!fReadWrite  ||  !IsBadWritePtr((LPVOID) pv, nBytes)));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\metautil\debug.h ===
/*
 * Some simple debugging macros that look and behave a lot like their
 * namesakes in MFC.  These macros should work in both C and C++ and
 * do something useful with almost any Win32 compiler.
 *
 * George V. Reilly  <georger@microcrafts.com>  <a-georgr@microsoft.com>
 */

#ifndef __DEBUG_H__
#define __DEBUG_H__

#ifdef _DEBUG

# if defined(_MSC_VER)  &&  (_MSC_VER >= 1000)
   /* Use the new debugging tools in Visual C++ 4.x */
#  include <crtdbg.h>
   /* _ASSERTE will give a more meaningful message, but the string takes
    * space.  Use _ASSERT if this is an issue. */
#  define ASSERT(f) _ASSERTE(f)
# else
#  include <assert.h>
#  define ASSERT(f) assert(f)
# endif

# define VERIFY(f)               ASSERT(f)
# define DEBUG_ONLY(f)           (f)
# define TRACE                   Trace
# define TRACE0(psz)             Trace(_T("%s"), _T(psz))
# define TRACE1(psz, p1)         Trace(_T(psz), p1)
# define TRACE2(psz, p1, p2)     Trace(_T(psz), p1, p2)
# define TRACE3(psz, p1, p2, p3) Trace(_T(psz), p1, p2, p3)
# define DEBUG_INIT()            DebugInit()
# define DEBUG_TERM()            DebugTerm()

#else /* !_DEBUG */

  /* These macros should all compile away to nothing */
# define ASSERT(f)               ((void)0)
# define VERIFY(f)               ((void)(f))
# define DEBUG_ONLY(f)           ((void)0)
# define TRACE                   1 ? (void)0 : Trace
# define TRACE0(psz)
# define TRACE1(psz, p1)
# define TRACE2(psz, p1, p2)
# define TRACE3(psz, p1, p2, p3)
# define DEBUG_INIT()            ((void)0)
# define DEBUG_TERM()            ((void)0)

#endif /* !_DEBUG */


#define ASSERT_POINTER(p, type) \
    ASSERT(((p) != NULL)  &&  IsValidAddress((p), sizeof(type), FALSE))

#define ASSERT_NULL_OR_POINTER(p, type) \
    ASSERT(((p) == NULL)  ||  IsValidAddress((p), sizeof(type), FALSE))

	/* t-brianm (6-3-97) Added ASSERT_STRING macros */
#define ASSERT_STRING(s) \
    ASSERT(((s) != NULL)  &&  IsValidString((s), -1))

#define ASSERT_NULL_OR_STRING(s) \
    ASSERT(((s) == NULL)  ||  IsValidString((s), -1))


/* Declarations for non-Windows apps */

#ifndef _WINDEF_
typedef void*           LPVOID;
typedef const void*     LPCVOID;
typedef unsigned int    UINT;
typedef int             BOOL;
typedef const char*     LPCTSTR;
#endif /* _WINDEF_ */

#ifndef TRUE
# define FALSE  0
# define TRUE   1
#endif


#ifdef __cplusplus
extern "C" {

/* Low-level sanity checks for memory blocks */
BOOL IsValidAddress(LPCVOID pv, UINT nBytes, BOOL fReadWrite = TRUE);
BOOL IsValidString(LPCTSTR ptsz, int nLength = -1);

#else /* !__cplusplus */

/* Low-level sanity checks for memory blocks */
BOOL IsValidAddress(LPCVOID pv, UINT nBytes, BOOL fReadWrite);
BOOL IsValidString(LPCTSTR ptsz, int nLength);

#endif /* !__cplusplus */

/* in debug version, writes trace messages to debug stream */
void __cdecl
Trace(
    LPCTSTR pszFormat,
    ...);

/* should be called from main(), WinMain(), or DllMain() */
void
DebugInit();

void
DebugTerm();

#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* __DEBUG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\metautil\chkerror.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: MetaUtil object

File: ChkError.h

Owner: t-BrianM

This file contains the headers for the CheckError collection.
===================================================================*/

#if !defined(AFX_CHKERROR_H__A4FA4E13_EF45_11D0_9E65_00C04FB94FEF__INCLUDED_)
#define AFX_CHKERROR_H__A4FA4E13_EF45_11D0_9E65_00C04FB94FEF__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"       // main symbols

class CCheckError;

/*
 * C C h e c k E r r o r C o l l e c t i o n
 *
 * Implements the error collection for CheckSchema and CheckKey
 */

class CCheckErrorCollection : 
	public IDispatchImpl<ICheckErrorCollection, &IID_ICheckErrorCollection, &LIBID_MetaUtil>,
	public ISupportErrorInfo,
	public CComObjectRoot
{
public:

BEGIN_COM_MAP(CCheckErrorCollection)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ICheckErrorCollection)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE(CCheckErrorCollection) 

	CCheckErrorCollection();
	~CCheckErrorCollection();

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// ICheckErrorCollection
	STDMETHOD(get_Count)(/*[out, retval]*/ long *plReturn);
	STDMETHOD(get_Item)(/*[in]*/ long lIndex, /*[out, retval]*/ LPDISPATCH * ppIReturn);
	STDMETHOD(get__NewEnum)(/*[out, retval]*/ LPUNKNOWN *ppIReturn);

// No Interface
	HRESULT AddError(long lId, long lSeverity, LPCTSTR tszDescription, LPCTSTR tszKey, long lProperty);

private:
	int m_iNumErrors;

	CComObject<CCheckError> *m_pCErrorList;
	CComObject<CCheckError> *m_pCErrorListEnd;
};


/*
 * C C h e c k E r r o r E n u m
 *
 * Implements error enumeration for CheckSchema and CheckKey
 */

class CCheckErrorEnum : 
	public IEnumVARIANT,
	public CComObjectRoot
{
public:
	CCheckErrorEnum();
	HRESULT Init(CComObject<CCheckError> *pCErrorList);
	~CCheckErrorEnum();

BEGIN_COM_MAP(CCheckErrorEnum)
	COM_INTERFACE_ENTRY(IEnumVARIANT)
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE(CCheckErrorEnum) 

//IEnumVARIANT
	STDMETHOD(Next)(unsigned long ulNumToGet, 
					VARIANT FAR* rgvarDest, 
					unsigned long FAR* pulNumGot);
	STDMETHOD(Skip)(unsigned long ulNumToSkip);
	STDMETHOD(Reset)();
	STDMETHOD(Clone)(IEnumVARIANT FAR* FAR* ppIReturn);

private:
	CComObject<CCheckError> *m_pCErrorList;
	CComObject<CCheckError> *m_pCErrorListPos;
};


/*
 * C C h e c k E r r o r
 *
 * Implements CheckError objects for CheckSchema and CheckKey
 */

class CCheckError : 
	public IDispatchImpl<ICheckError, &IID_ICheckError, &LIBID_MetaUtil>,
	public ISupportErrorInfo,
	public CComObjectRoot
{
public:
	CCheckError();
	HRESULT Init(long lId, long lSeverity, LPCTSTR tszDescription, LPCTSTR tszKey, long lProperty);
	~CCheckError();

BEGIN_COM_MAP(CCheckError)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ICheckError)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE(CCheckError) 

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// ICheckError
	STDMETHOD(get_Id)(/*[out, retval]*/ long *plId);
	STDMETHOD(get_Severity)(/*[out, retval]*/ long *plSeverity);
	STDMETHOD(get_Description)(/*[out, retval]*/ BSTR *pbstrDescription);
	STDMETHOD(get_Key)(/*[out, retval]*/ BSTR *pbstrKey);
	STDMETHOD(get_Property)(/*[out, retval]*/ long *plProperty);

// No Interface
	CComObject<CCheckError> *GetNextError() {
		ASSERT_NULL_OR_POINTER(m_pNextError, CComObject<CCheckError>);
		return m_pNextError;
	}
	void SetNextError(CComObject<CCheckError> *pNextError) { 
		ASSERT_NULL_OR_POINTER(pNextError, CComObject<CCheckError>);
		m_pNextError = pNextError; 
	}

private:
	long m_lId;
	long m_lSeverity;
	LPTSTR m_tszDescription;
	LPTSTR m_tszKey;
	long m_lProperty;

	CComObject<CCheckError> *m_pNextError;
};
#endif // !defined(AFX_CHKERROR_H__A4FA4E13_EF45_11D0_9E65_00C04FB94FEF__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\mdtools\mddmp\mddmp.cxx ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    mddmp.cxx

Abstract:

    Meta Data Dump Utility.

Author:

    Keith Moore (keithmo)        03-Feb-1997

Revision History:

--*/


#include "precomp.hxx"
#pragma hdrstop


//
// Private constants.
//

#define TEST_HRESULT(api,hr,fatal)                                          \
            if( FAILED(hr) ) {                                              \
                                                                            \
                wprintf(                                                    \
                    L"%S:%lu failed, error %lx %S\n",                       \
                    (api),                                                  \
                    __LINE__,                                               \
                    (result),                                               \
                    (fatal)                                                 \
                        ? "ABORTING"                                        \
                        : "CONTINUING"                                      \
                    );                                                      \
                                                                            \
                if( fatal ) {                                               \
                                                                            \
                    goto cleanup;                                           \
                                                                            \
                }                                                           \
                                                                            \
            } else


//
// Private types.
//

typedef struct _ENUM_CONTEXT {

    LPWSTR Leaf;
    WCHAR Path[MAX_PATH];

} ENUM_CONTEXT, *PENUM_CONTEXT;


//
// Private globals.
//


//
// Private prototypes.
//

VOID
DumpTree(
    IMSAdminBase * AdmCom,
    PENUM_CONTEXT Context
    );

BOOL
WINAPI
EnumCallback(
    IMSAdminBase * AdmCom,
    LPWSTR ObjectName,
    VOID * Context
    );


//
// Public functions.
//


INT
__cdecl
wmain(
    INT argc,
    LPWSTR argv[]
    )
{

    HRESULT result;
    IMSAdminBase * admCom;
    ENUM_CONTEXT context;

    //
    // Setup locals so we know how to cleanup on exit.
    //

    admCom = NULL;

    //
    // Initialize COM.
    //

    result = CoInitializeEx(
                 NULL,
                 COINIT_MULTITHREADED
                 );

    TEST_HRESULT( "CoInitializeEx()", result, TRUE );

    //
    // Get the admin object.
    //

    result = MdGetAdminObject( &admCom );

    TEST_HRESULT( "MdGetAdminObject()", result, TRUE );

    //
    // Dump the metabase tree.
    //

    wcscpy(
        context.Path,
        L"/"
        );

    DumpTree(
        admCom,
        &context
        );

cleanup:

    //
    // Release the admin object.
    //

    if( admCom != NULL ) {

        result = MdReleaseAdminObject( admCom );
        TEST_HRESULT( "MdReleaseAdminObject()", result, FALSE );

    }

    //
    // Shutdown COM.
    //

    CoUninitialize();
    return 0;

}   // main


//
// Private functions.
//

VOID
DumpTree(
    IMSAdminBase * AdmCom,
    PENUM_CONTEXT Context
    )
{

    HRESULT result;
    METADATA_GETALL_RECORD * data;
    METADATA_GETALL_RECORD * scan;
    DWORD numEntries;
    INT pathLen;
    LPWSTR leaf;

    result = MdGetAllMetaData(
                 AdmCom,
                 METADATA_MASTER_ROOT_HANDLE,
                 Context->Path,
                 0,
                 &data,
                 &numEntries
                 );

    if( FAILED(result) ) {

        wprintf(
            L"Cannot get metadata for %s, error %lx\n",
            Context->Path,
            result
            );

        return;

    }

    if( numEntries > 0 ) {
        wprintf( L"%s\n", Context->Path );
    }

    pathLen = wcslen( Context->Path );

    for( scan = data ; numEntries > 0 ; numEntries--, scan++ ) {

        wprintf( L"%*cIdentifier = %lu\n",   pathLen, ' ', scan->dwMDIdentifier );
        wprintf( L"%*cAttributes = %08lx\n", pathLen, ' ', scan->dwMDAttributes );
        wprintf( L"%*cUserType   = %lu\n",   pathLen, ' ', scan->dwMDUserType   );
        wprintf( L"%*cDataType   = %lu\n",   pathLen, ' ', scan->dwMDDataType   );
        wprintf( L"\n" );

    }

    MdFreeMetaDataBuffer( (VOID *)data );

    leaf = Context->Leaf;
    Context->Leaf = Context->Path + wcslen( Context->Path );

    result = MdEnumMetaObjects(
                 AdmCom,
                 Context->Path,
                 &EnumCallback,
                 (VOID *)Context
                 );

    Context->Leaf = leaf;

    if( FAILED(result) ) {

        wprintf(
            L"Cannot enumerate meta objects, error %lx\n",
            result
            );

        return;

    }

}   // DumpTree

BOOL
WINAPI
EnumCallback(
    IMSAdminBase * AdmCom,
    LPWSTR ObjectName,
    VOID * Context
    )
{

    PENUM_CONTEXT context;
    LPWSTR leaf;

    if( *ObjectName != '\0' ) {

        context = (PENUM_CONTEXT)Context;

        leaf = context->Leaf;
        if( leaf > ( context->Path + 1 ) ) {
            *leaf++ = L'/';
        }

        wcscpy(
            leaf,
            ObjectName
            );

        DumpTree(
            AdmCom,
            context
            );

    }

    return TRUE;

}   // EnumCallback
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\metautil\chkerror.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: MetaUtil object

File: ChkError.cpp

Owner: t-BrianM

This file contains implementation of the check error collection for
CheckSchema and CheckKey.

Notes:
	I implemented the error stuff as a linked list of COM CheckError
	objects.  It is assumed that the error collection will be 
	created, all elements added to it, then used.  No changes after
	creation!  Because of the static nature of the list, the links
	are physicaly located in the CheckError objects, no node wrapping
	needed.  This design cuts down on the copying and redundancy.
===================================================================*/

#include "stdafx.h"
#include "MetaUtil.h"
#include "MUtilObj.h"
#include "ChkError.h"

/*------------------------------------------------------------------
 * C C h e c k E r r o r C o l l e c t i o n
 */

/*===================================================================
CCheckErrorCollection::CCheckErrorCollection

Constructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CCheckErrorCollection::CCheckErrorCollection() : m_iNumErrors(0),
												 m_pCErrorList(NULL),
												 m_pCErrorListEnd(NULL)
{
}

/*===================================================================
CCheckErrorCollection::~CCheckErrorCollection

Destructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CCheckErrorCollection::~CCheckErrorCollection() 
{
	// Release all of the elements
	CComObject<CCheckError> *pCLoop;
	CComObject<CCheckError> *pCRelease;

	pCLoop = m_pCErrorList;
	while (pCLoop != NULL) {
		pCRelease = pCLoop;
		pCLoop = pCLoop->GetNextError();
		pCRelease->Release();
	}
}

/*===================================================================
CCheckErrorCollection::InterfaceSupportsErrorInfo

Standard ATL implementation

===================================================================*/
STDMETHODIMP CCheckErrorCollection::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ICheckErrorCollection,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

/*===================================================================
CCheckErrorCollection::get_Count

Get method for Count property.  Counts the number of errors in the
collection.

Parameters:
	plReturn	[out, retval] Value to return to client.

Returns:
	E_INVALIDARG if plReturn == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CCheckErrorCollection::get_Count(long *plReturn) 
{
	TRACE0("MetaUtil: CCheckErrorCollection::get_Count\n");
	ASSERT_NULL_OR_POINTER(plReturn, long);

	if (plReturn == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	*plReturn = m_iNumErrors;

	return S_OK;
}

/*===================================================================
CCheckErrorCollection::get_Item

Get method for Item property.  Returns a CheckError given its index.

Parameters:
	varId		[in] 1 based index or Name of the CheckError to get
	ppIReturn	[out, retval] Interface for the property object

Returns:
	E_INVALIDARG if ppIReturn == NULL or lIndex <= 0
	S_OK on success
===================================================================*/
STDMETHODIMP CCheckErrorCollection::get_Item(long lIndex, 
											 LPDISPATCH * ppIReturn) 
{
	TRACE0("MetaUtil: CCheckErrorCollection::get_Item\n");
	ASSERT_NULL_OR_POINTER(ppIReturn, LPDISPATCH);

	if ((lIndex <= 0) || (ppIReturn == NULL)) {
		// 0 or less, too small  OR  ppIReturn == NULL
		return ::ReportError(E_INVALIDARG);
	}
	else if (lIndex >= m_iNumErrors) {
		// Too large
		return ::ReportError(ERROR_NO_MORE_ITEMS);
	}
	else {
		// Get the requested error
		HRESULT hr;
		CComObject<CCheckError> *pCLoop;

		pCLoop = m_pCErrorList;
		while ((lIndex > 1) && (pCLoop != NULL)) {
			lIndex--;
			pCLoop = pCLoop->GetNextError();
		}

		// Set the interface to IDispatch
		hr = pCLoop->QueryInterface(IID_IDispatch, (void **) ppIReturn);
		if (FAILED(hr)) {
			return ::ReportError(hr);
		}
		ASSERT(*ppIReturn != NULL);

		return S_OK;
	}
}

/*===================================================================
CCheckErrorCollection::get__NewEnum

Get method for _NewEnum property.  Returns an enumeration object for
the CheckErrors.

Parameters:
	ppIReturn	[out, retval] Interface for the enumeration object

Returns:
	E_INVALIDARG if ppIReturn == NULL
	E_OUTOFMEMORY if allocation failed
	S_OK on success
===================================================================*/
STDMETHODIMP CCheckErrorCollection::get__NewEnum(LPUNKNOWN *ppIReturn) 
{
	TRACE0("MetaUtil: CCheckErrorCollection::get__NewEnum\n");
	ASSERT_NULL_OR_POINTER(ppIReturn, LPUNKNOWN);

	if (ppIReturn == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	HRESULT hr;

	// Create the check error enumeration
	CComObject<CCheckErrorEnum> *pObj = NULL;
	ATLTRY(pObj = new CComObject<CCheckErrorEnum>);
	if (pObj == NULL) {
		return ::ReportError(E_OUTOFMEMORY);
	}
	hr = pObj->Init(m_pCErrorList);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	// Set the interface to IUnknown
	hr = pObj->QueryInterface(IID_IUnknown, (void **) ppIReturn);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}
	ASSERT(*ppIReturn != NULL);

	return S_OK;
}

/*===================================================================
CCheckErrorCollection::AddError(

Adds an error to the error collection.

Parameters:
	lId				Identifier for this error
	lSeverity		Severity of the error
	tszDescription	Description of error for users
	tszKey			Key where error occurred
	lProperty		Property where error occurred

Returns:
	E_OUTOFMEMORY if allocation fails
	S_OK on success

Notes:
	It is assumed that the CheckError collection will be created 
	then all of the errors will be added before the collection is 
	sent to the client.  Similar to Init(), however it could be
	called multiple times.
===================================================================*/
HRESULT CCheckErrorCollection::AddError(long lId, 
										long lSeverity, 
										LPCTSTR tszDescription, 
										LPCTSTR tszKey, 
										long lProperty) 
{
	ASSERT(lId > 0);
	ASSERT(lSeverity > 0);
	ASSERT_STRING(tszDescription);
	ASSERT_STRING(tszKey);
	ASSERT(lProperty >= 0);

	HRESULT hr;

	// Create the new element
	CComObject<CCheckError> *pNewError = NULL;
	ATLTRY(pNewError = new CComObject<CCheckError>);
	if (pNewError == NULL) {
		return ::ReportError(E_OUTOFMEMORY);
	}
	hr = pNewError->Init(lId, lSeverity, tszDescription, tszKey, lProperty);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	// AddRef it
	pNewError->AddRef();

	// Add it to the end of the list
	if (m_pCErrorList == NULL) {
		m_pCErrorList = pNewError;
		m_pCErrorListEnd = pNewError;
	}
	else {
		m_pCErrorListEnd->SetNextError(pNewError);
		m_pCErrorListEnd = pNewError;
	}

	// Count it
	m_iNumErrors++;

	return S_OK;
}


/*------------------------------------------------------------------
 * C C h e c k E r r o r E n u m
 */

/*===================================================================
CCheckErrorEnum::CCheckErrorEnum()

Constructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CCheckErrorEnum::CCheckErrorEnum() : m_pCErrorList(NULL),
									 m_pCErrorListPos(NULL)
{
}

/*===================================================================
CCheckErrorEnum::Init

Constructor

Parameters:
	pCErrorList		Pointer to first element in list to enumerate.

Returns:
	S_OK on success
===================================================================*/
HRESULT CCheckErrorEnum::Init(CComObject<CCheckError> *pCErrorList) 
{
	ASSERT_NULL_OR_POINTER(pCErrorList, CComObject<CCheckError>);

	// Set list head and current position
	m_pCErrorList = pCErrorList;
	m_pCErrorListPos = pCErrorList;

	// AddRef all of the elements
	CComObject<CCheckError> *pCLoop;

	pCLoop = m_pCErrorList;
	while (pCLoop != NULL) {
		pCLoop->AddRef();
		pCLoop = pCLoop->GetNextError();
	}

	return S_OK; 
}

/*===================================================================
CCheckErrorEnum::~CCheckErrorEnum

Destructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CCheckErrorEnum::~CCheckErrorEnum() 
{
	// Release all of the elements
	CComObject<CCheckError> *pCLoop;
	CComObject<CCheckError> *pCRelease;

	pCLoop = m_pCErrorList;
	while (pCLoop != NULL) {
		pCRelease = pCLoop;
		pCLoop = pCLoop->GetNextError();
		pCRelease->Release();
	}
}

/*===================================================================
CCheckErrorEnum::Next

Gets the next n items from the enumberation.

Parameters:
	ulNumToGet	[in] Number of elements to get
	rgvarDest	[out] Array to put them in
	pulNumGot	[out] If not NULL, number of elements rgvarDest got

Returns:
	E_INVALIDARG if rgvarDest == NULL
	S_FALSE if outputs less than ulNumToGet items
	S_OK if outputs ulNumToGet items
===================================================================*/
STDMETHODIMP CCheckErrorEnum::Next(unsigned long ulNumToGet, 
								   VARIANT FAR* rgvarDest, 
								   unsigned long FAR* pulNumGot) 
{ 
	TRACE0("MetaUtil: CCheckErrorEnum::Next\n");
	ASSERT_NULL_OR_POINTER(pulNumGot, unsigned long);
	// Make sure the array is big enough and we can write to it
	ASSERT((rgvarDest == NULL) || IsValidAddress(rgvarDest, ulNumToGet * sizeof(VARIANT), TRUE));

	if (pulNumGot != NULL) {
		pulNumGot = 0;
	}

	if (rgvarDest == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	HRESULT hr;
	unsigned int uiDestIndex;
	IDispatch *pIDispatch;

	// While we have more to get and have more left
	uiDestIndex = 0;
	while ((uiDestIndex < ulNumToGet) && (m_pCErrorListPos != NULL)) {
		// Set the interface to IDispatch
		hr = m_pCErrorListPos->QueryInterface(IID_IDispatch, (void **) &pIDispatch);
		if (FAILED(hr)) {
			return ::ReportError(hr);
		}
		ASSERT(pIDispatch != NULL);

		// Put it in the output array
		VariantInit(&(rgvarDest[uiDestIndex]));
		rgvarDest[uiDestIndex].vt = VT_DISPATCH;
		rgvarDest[uiDestIndex].pdispVal = pIDispatch;

		// Next element
		m_pCErrorListPos = m_pCErrorListPos->GetNextError();
		uiDestIndex++;
	}

	// If pulNumGot isn't NULL, set it
	if (pulNumGot != NULL) {
		*pulNumGot = uiDestIndex;
	}

	if (uiDestIndex == ulNumToGet) {
		// Returned the requested number of elements
		TRACE0("MetaUtil: CCheckErrorEnum::Next Ok\n");
		return S_OK;
	}
	else {
		// Returned less than the requested number of elements
		TRACE0("MetaUtil: CCheckErrorEnum::Next False\n");
		return S_FALSE;
	}
}

/*===================================================================
CCheckErrorEnum::Skip

Skips the next n items in an enumeration

Parameters:
	ulNumToSkip	[in] Number of elements to skip

Returns:
	S_OK always
===================================================================*/
STDMETHODIMP CCheckErrorEnum::Skip(unsigned long ulNumToSkip) 
{ 
	TRACE0("MetaUtil: CCheckErrorEnum::Skip\n");

	unsigned long ulIndex;

	ulIndex = ulNumToSkip;
	while ((ulIndex != 0) && (m_pCErrorListPos != NULL)) {
		m_pCErrorListPos = m_pCErrorListPos->GetNextError();
		ulIndex--;
	}

	return S_OK; 
}

/*===================================================================
CCheckErrorEnum::Reset

Rests the enumeration to the first item

Parameters:
	None

Returns:
	S_OK always
===================================================================*/
STDMETHODIMP CCheckErrorEnum::Reset() 
{
	TRACE0("MetaUtil: CCheckErrorEnum::Reset\n");

	// Set our position back to the first element
	m_pCErrorListPos = m_pCErrorList;

	return S_OK;
}

/*===================================================================
CCheckErrorEnum::Clone

Gets an interface pointer to a copy of the enumeration at its
current state.

Parameters:
	ppIReturn	[out] Pointer to interface for copy

Returns:
	E_INVALIDARG if ppIReturn == NULL
	E_OUTOFMEMORY if not enough memory to create clone
	S_OK on success
===================================================================*/
STDMETHODIMP CCheckErrorEnum::Clone(IEnumVARIANT FAR* FAR* ppIReturn) 
{
	TRACE0("MetaUtil: CCheckErrorEnum::Clone\n");
	ASSERT_NULL_OR_POINTER(ppIReturn, LPUNKNOWN);

	if (ppIReturn == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	HRESULT hr;

	// Create a copy of the enumeration
	CComObject<CCheckErrorEnum> *pObj = NULL;
	ATLTRY(pObj = new CComObject<CCheckErrorEnum>);
	if (pObj == NULL) {
		return ::ReportError(E_OUTOFMEMORY);
	}
	hr = pObj->Init(m_pCErrorList);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	// Set the interface to IEnumVARIANT
	hr = pObj->QueryInterface(IID_IEnumVARIANT, (void **) ppIReturn);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}
	ASSERT(*ppIReturn != NULL);

	return S_OK; 
}


/*------------------------------------------------------------------
 * C C h e c k E r r o r
 */

/*===================================================================
CCheckError::CCheckError

Constructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CCheckError::CCheckError() : m_lId(0),
							 m_lSeverity(0),
							 m_tszDescription(NULL),
							 m_tszKey(NULL),
							 m_lProperty(0),
							 m_pNextError(NULL)
{
}

/*===================================================================
CCheckError::Init

Constructor

Parameters:
	lId				Identifier for this error
	lSeverity		Severity of the error
	tszDescription	Description of error for users
	tszKey			Key where error occurred
	lProperty		Property where error occurred

Returns:
	E_OUTOFMEMORY if allocation fails
	S_OK on success
===================================================================*/
HRESULT CCheckError::Init(long lId,
						  long lSeverity,
						  LPCTSTR tszDescription,
						  LPCTSTR tszKey,
						  long lProperty) 
{
	ASSERT(lId > 0);
	ASSERT(lSeverity > 0);
	ASSERT_STRING(tszDescription);
	ASSERT_STRING(tszKey);
	ASSERT(lProperty >= 0);

	m_lId = lId;
	m_lSeverity = lSeverity;

	// Copy tszDescription to m_tszDescription
	m_tszDescription = new TCHAR[_tcslen(tszDescription) + 1];
		if (m_tszDescription == NULL) {
			return ::ReportError(E_OUTOFMEMORY);
		}
	_tcscpy(m_tszDescription, tszDescription);

	// Copy tszKey to m_tszKey
	m_tszKey = new TCHAR[_tcslen(tszKey) + 1];
		if (m_tszKey == NULL) {
			return ::ReportError(E_OUTOFMEMORY);
		}
	_tcscpy(m_tszKey, tszKey);

	m_lProperty = lProperty;

	return S_OK; 
}

/*===================================================================
CCheckError::~CCheckError

Destructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CCheckError::~CCheckError() 
{
	if (m_tszDescription != NULL) {
		delete m_tszDescription;
	}
	if (m_tszKey != NULL) {
		delete m_tszKey;
	}
}

/*===================================================================
CCheckError::InterfaceSupportsErrorInfo

Standard ATL implementation

===================================================================*/
STDMETHODIMP CCheckError::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_ICheckError,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

/*===================================================================
CCheckError::get_Id

Get method for Id property.  Gets the Id for this error, so it can
be easily processed by recovery logic.

Parameters:
	plId	[out, retval] Value to return to client.

Returns:
	E_INVALIDARG if plId == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CCheckError::get_Id(long *plId)
{
	TRACE0("MetaUtil: CCheckError::get_Id\n");
	ASSERT_NULL_OR_POINTER(plId, long);

	if (plId == NULL) {
		return E_INVALIDARG;
	}

	*plId = m_lId;

	return S_OK;
}

/*===================================================================
CCheckError::get_Severity

Get method for Severity property.  Gets the severity for this error, 
so it can be filtered.

Parameters:
	plSeverity	[out, retval] Value to return to client.

Returns:
	E_INVALIDARG if plSeverity == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CCheckError::get_Severity(long *plSeverity)
{
	TRACE0("MetaUtil: CCheckError::get_Severity\n");
	ASSERT_NULL_OR_POINTER(plSeverity, long);

	if (plSeverity == NULL) {
		return E_INVALIDARG;
	}

	*plSeverity = m_lSeverity;

	return S_OK;
}

/*===================================================================
CCheckError::get_Description

Get method for Description property.  Gets the description for this 
error, so users can understand it.

Parameters:
	pbstrDescription	[out, retval] Value to return to client.

Returns:
	E_INVALIDARG if pbstrDescription == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CCheckError::get_Description(BSTR *pbstrDescription)
{
	TRACE0("MetaUtil: CCheckError::get_Description\n");
	ASSERT_NULL_OR_POINTER(pbstrDescription, BSTR);

	if (pbstrDescription == NULL) {
		return E_INVALIDARG;
	}

	USES_CONVERSION;

	*pbstrDescription = T2BSTR(m_tszDescription);

	return S_OK;
}

/*===================================================================
CCheckError::get_Key

Get method for Key property.  Gets the key where the error occurred.

Parameters:
	pbstrKey	[out, retval] Value to return to client.

Returns:
	E_INVALIDARG if pbstrKey == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CCheckError::get_Key(BSTR * pbstrKey)
{
	TRACE0("MetaUtil: CCheckError::get_Key\n");
	ASSERT_NULL_OR_POINTER(pbstrKey, BSTR);

	if (pbstrKey == NULL) {
		return E_INVALIDARG;
	}

	USES_CONVERSION;

	*pbstrKey = T2BSTR(m_tszKey);

	return S_OK;
}

/*===================================================================
CCheckError::get_Property

Get method for Property property.  Gets the property where the error 
occurred.

Parameters:
	pbstrProperty	[out, retval] Value to return to client.

Returns:
	E_INVALIDARG if pbstrProperty == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CCheckError::get_Property(long * plProperty)
{
	TRACE0("MetaUtil: CCheckError::get_Property\n");
	ASSERT_NULL_OR_POINTER(plProperty, long);

	if (plProperty == NULL) {
		return E_INVALIDARG;
	}

	*plProperty = m_lProperty;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\metautil\chkmeta.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: MetaUtil object

File: ChkMeta.cpp

Owner: t-BrianM

This file contains the headers for the objects related to the
CheckSchema and CheckKey methods.
===================================================================*/

#include "stdafx.h"
#include "MetaUtil.h"
#include "MUtilObj.h"

#define NAME_TABLE_HASH_SIZE	1559

class CNameTable;

class CNameTableEntry {

	friend CNameTable;

public:
	CNameTableEntry() : m_tszName(NULL),
						m_pCHashNext(NULL) { }

	HRESULT Init(LPCTSTR tszName);

	~CNameTableEntry() {
		if (m_tszName != NULL) {
			delete m_tszName;
		}
	}

private:
	LPTSTR m_tszName;
	CNameTableEntry *m_pCHashNext;
};


class CNameTable {

public:
	CNameTable();
	~CNameTable();

	BOOL IsCaseSenDup(LPCTSTR tszName);
	BOOL IsCaseInsenDup(LPCTSTR tszName);
	HRESULT Add(LPCTSTR tszName);

private:
	CNameTableEntry *m_rgpNameTable[NAME_TABLE_HASH_SIZE];

	int Hash(LPCTSTR tszName);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\metautil\keycol.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: MetaUtil object

File: KeyCol.cpp

Owner: t-BrianM

This file contains implementation of the key collections.
===================================================================*/

#include "stdafx.h"
#include "MetaUtil.h"
#include "MUtilObj.h"
#include "keycol.h"

/*------------------------------------------------------------------
 * C F l a t K e y C o l l e c t i o n
 */

/*===================================================================
CFlatKeyCollection::CFlatKeyCollection

Constructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CFlatKeyCollection::CFlatKeyCollection() : m_tszBaseKey(NULL)
{
}

/*===================================================================
CFlatKeyCollection::Init

Constructor

Parameters:
	pIMeta		ATL Smart pointer to the metabase admin base object
	tszBaseKey	Name of key to enumerate from

Returns:
	E_OUTOFMEMORY if allocation fails
	S_OK on success
===================================================================*/
HRESULT CFlatKeyCollection::Init(const CComPtr<IMSAdminBase> &pIMeta, LPCTSTR tszBaseKey) 
{
	ASSERT(pIMeta.p != NULL);
	ASSERT_NULL_OR_STRING(tszBaseKey);

	m_pIMeta = pIMeta;

	// Copy tszBaseKey to m_tszBaseKey
	if (tszBaseKey == NULL) {
		// BaseKey is root
		m_tszBaseKey = NULL;
	}
	else {
		// Allocate and copy the passed string to the member string
		m_tszBaseKey = new TCHAR[_tcslen(tszBaseKey) + 1];
		if (m_tszBaseKey == NULL) {
			return ::ReportError(E_OUTOFMEMORY);
		}
		_tcscpy(m_tszBaseKey, tszBaseKey);
		CannonizeKey(m_tszBaseKey);
	}

	return S_OK;
}

/*===================================================================
CFlatKeyCollection::~CFlatKeyCollection

Destructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CFlatKeyCollection::~CFlatKeyCollection() 
{
	if (m_tszBaseKey != NULL)
		delete m_tszBaseKey;
}

/*===================================================================
CFlatKeyCollection::InterfaceSupportsErrorInfo

Standard ATL implementation

===================================================================*/
STDMETHODIMP CFlatKeyCollection::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IKeyCollection,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

/*===================================================================
CFlatKeyCollection::get_Count

Get method for Count property.  Counts the number of subkeys

Parameters:
	plReturn	[out, retval] Value to return to client.

Returns:
	E_INVALIDARG if plReturn == NULL
	S_OK on success

Notes:
	Actually counts all of the subkeys.  Do not call in a loop!
===================================================================*/
STDMETHODIMP CFlatKeyCollection::get_Count(long * plReturn)
{
	TRACE0("MetaUtil: CFlatKeyCollection::get_Count\n");

	ASSERT_NULL_OR_POINTER(plReturn, long);

	if (plReturn == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	USES_CONVERSION;
	HRESULT hr;

	*plReturn = 0;

	// Count the subkeys
	wchar_t wszSubKey[ADMINDATA_MAX_NAME_LEN];
	int iIndex;

	iIndex = 0;
	for (;;) {  // FOREVER, will return from loop
		hr = m_pIMeta->EnumKeys(METADATA_MASTER_ROOT_HANDLE, 
								T2W(m_tszBaseKey), 
								wszSubKey, 
								iIndex);
		if (FAILED(hr)) {
			if (HRESULT_CODE(hr) == ERROR_NO_MORE_ITEMS) {
				// Ran out of items, return the number we counted
				*plReturn = iIndex;
				return S_OK;
			}
			else {
				return ::ReportError(hr);
			}
		}
		iIndex++;
	}
}

/*===================================================================
CFlatKeyCollection::get_Item

Get method for Item property.  Returns a key given its index.

Parameters:
	lIndex		[in] 1 based index of the key to get
	pbstrRetKey	[out, retval] Retrived key

Returns:
	E_INVALIDARG if pbstrRetKey == NULL or lIndex <= 0
	S_OK on success
===================================================================*/
STDMETHODIMP CFlatKeyCollection::get_Item(long lIndex, BSTR *pbstrRetKey)
{
	TRACE0("MetaUtil: CFlatKeyCollection::get_Item\n");

	ASSERT_NULL_OR_POINTER(pbstrRetKey, BSTR);

	if ((pbstrRetKey == NULL) || (lIndex <= 0)) {
		return ::ReportError(E_INVALIDARG);
	}

	*pbstrRetKey = NULL;

	USES_CONVERSION;
	HRESULT hr;
	
	wchar_t wszSubKey[ADMINDATA_MAX_NAME_LEN];

	hr = m_pIMeta->EnumKeys(METADATA_MASTER_ROOT_HANDLE, 
							T2W(m_tszBaseKey), 
							wszSubKey, 
							lIndex - 1);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	*pbstrRetKey = W2BSTR(wszSubKey);

	return S_OK;
}

/*===================================================================
CFlatKeyCollection::get__NewEnum

Get method for _NewEnum property.  Returns an enumeration object for
the subkeys.

Parameters:
	ppIReturn	[out, retval] Interface for the enumberation object

Returns:
	E_OUTOFMEMORY if allocation fails.
	E_INVALIDARG if ppIReturn == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CFlatKeyCollection::get__NewEnum(LPUNKNOWN * ppIReturn)
{
	TRACE0("MetaUtil: CFlatKeyCollection::get__NewEnum\n");

	ASSERT_NULL_OR_POINTER(ppIReturn, LPUNKNOWN);

	if (ppIReturn == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	HRESULT hr;

	// Create the flat key enumeration
	CComObject<CFlatKeyEnum> *pObj = NULL;
	ATLTRY(pObj = new CComObject<CFlatKeyEnum>);
	if (pObj == NULL) {
		return ::ReportError(E_OUTOFMEMORY);
	}
	hr = pObj->Init(m_pIMeta, m_tszBaseKey, 0);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	// Set the interface to IUnknown
	hr = pObj->QueryInterface(IID_IUnknown, (void **) ppIReturn);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}
	ASSERT(*ppIReturn != NULL);

	return S_OK;
}

/*===================================================================
CFlatKeyCollection::Add

Adds a key to the metabase relative to the collection's base key

Parameters:
	bstrRelKey	[in] Relative key to add

Returns:
	E_INVALIDARG if bstrRelKey == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CFlatKeyCollection::Add(BSTR bstrRelKey)
{
	TRACE0("MetaUtil: CFlatKeyCollection::Add\n");

	ASSERT_NULL_OR_POINTER(bstrRelKey, OLECHAR);

	if (bstrRelKey == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	// Build the full key
	USES_CONVERSION;
	TCHAR tszFullKey[ADMINDATA_MAX_NAME_LEN];

	if (m_tszBaseKey == NULL) {
		_tcscpy(tszFullKey, OLE2T(bstrRelKey));
	}
	else {
		_tcscpy(tszFullKey, m_tszBaseKey);
		_tcscat(tszFullKey, _T("/"));
		_tcscat(tszFullKey, OLE2T(bstrRelKey));
	}
	CannonizeKey(tszFullKey);

	return ::CreateKey(m_pIMeta, tszFullKey);
}

/*===================================================================
CFlatKeyCollection::Remove

Removes a key from the metabase relative to the collection's base key

Parameters:
	bstrRelKey	[in] Relative key to remove

Returns:
	E_INVALIDARG if bstrRelKey == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CFlatKeyCollection::Remove(BSTR bstrRelKey)
{
	TRACE0("MetaUtil: CFlatKeyCollection::Remove\n");

	ASSERT_NULL_OR_POINTER(bstrRelKey, OLECHAR);

	if (bstrRelKey == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	// Build the full key
	USES_CONVERSION;
	TCHAR tszFullKey[ADMINDATA_MAX_NAME_LEN];

	if (m_tszBaseKey == NULL) {
		_tcscpy(tszFullKey, OLE2T(bstrRelKey));
	}
	else {
		_tcscpy(tszFullKey, m_tszBaseKey);
		_tcscat(tszFullKey, _T("/"));
		_tcscat(tszFullKey, OLE2T(bstrRelKey));
	}
	CannonizeKey(tszFullKey);

	return ::DeleteKey(m_pIMeta, tszFullKey);
}

/*------------------------------------------------------------------
 * C F l a t K e y E n u m
 */

/*===================================================================
CFlatKeyEnum::CFlatKeyEnum

Constructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/

CFlatKeyEnum::CFlatKeyEnum() : m_tszBaseKey(NULL),
							   m_iIndex(0)
{
}

/*===================================================================
CFlatKeyEnum::Init

Constructor

Parameters:
	pIMeta		ATL Smart pointer to the metabase
	tszBaseKey	Name of key to enumerate from
	iIndex		Index of next element in enumeration

Returns:
	E_OUTOFMEMORY if allocation fails
	S_OK on success
===================================================================*/
HRESULT CFlatKeyEnum::Init(const CComPtr<IMSAdminBase> &pIMeta, LPCTSTR tszBaseKey, int iIndex) 
{
	ASSERT(pIMeta.p != NULL);
	ASSERT_NULL_OR_STRING(tszBaseKey);
	ASSERT(iIndex >= 0);

	m_pIMeta = pIMeta;

	// Copy tszBaseKey to m_tszBaseKey
	if (tszBaseKey == NULL) {
		// BaseKey is root
		m_tszBaseKey = NULL;
	}
	else {
		// Allocate and copy the passed string to the member string
		m_tszBaseKey = new TCHAR[_tcslen(tszBaseKey) + 1];
		if (m_tszBaseKey == NULL) {
			return ::ReportError(E_OUTOFMEMORY);
		}
		_tcscpy(m_tszBaseKey, tszBaseKey);
		CannonizeKey(m_tszBaseKey);
	}

	m_iIndex = iIndex;

	return S_OK;
}

/*===================================================================
CFlatKeyEnum::~CFlatKeyEnum

Destructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CFlatKeyEnum::~CFlatKeyEnum()
{
	if (m_tszBaseKey != NULL) {
		delete m_tszBaseKey;
	}
}

/*===================================================================
CFlatKeyEnum::Next

Gets the next n items from the enumberation.

Parameters:
	ulNumToGet	[in] Number of elements to get
	rgvarDest	[out] Array to put them in
	pulNumGot	[out] If not NULL, number of elements rgvarDest got

Returns:
    E_INVALIDARG if rgvarDest == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CFlatKeyEnum::Next(unsigned long ulNumToGet, 
								VARIANT FAR* rgvarDest, 
								unsigned long FAR* pulNumGot) 
{
	TRACE0("MetaUtil: CFlatKeyEnum::Next\n");
	ASSERT_NULL_OR_POINTER(pulNumGot, unsigned long);
	// Make sure the array is big enough and we can write to it
	ASSERT((rgvarDest == NULL) || IsValidAddress(rgvarDest, ulNumToGet * sizeof(VARIANT), TRUE));

	if (rgvarDest == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	USES_CONVERSION;
	HRESULT hr;
	wchar_t wszSubKey[ADMINDATA_MAX_NAME_LEN];
	unsigned int uiDestIndex;

	// Clear the output array
	for(uiDestIndex = 0; uiDestIndex < ulNumToGet; uiDestIndex++) {
		VariantInit(&(rgvarDest[uiDestIndex]));
	}

	// For each subkey to get
	uiDestIndex = 0;
	while (uiDestIndex < ulNumToGet) {
		// Get a subkey
		hr = m_pIMeta->EnumKeys(METADATA_MASTER_ROOT_HANDLE, 
								T2W(m_tszBaseKey), 
								wszSubKey, 
								m_iIndex);
		if (FAILED(hr)) {
			if (HRESULT_CODE(hr) == ERROR_NO_MORE_ITEMS) {
				if (pulNumGot != NULL) {
					*pulNumGot = uiDestIndex;
				}
				return S_FALSE;
			}
			else {
				return ::ReportError(hr);
			}
		}

		// Output the subkey
		rgvarDest[uiDestIndex].vt = VT_BSTR;
		rgvarDest[uiDestIndex].bstrVal = W2BSTR(wszSubKey);

		// Setup next iteration
		m_iIndex++;
		uiDestIndex++;
	}

	if (pulNumGot != NULL) {
		*pulNumGot = uiDestIndex;
	}

	return S_OK;
}

/*===================================================================
CFlatKeyEnum::Skip

Skips the next n items in an enumeration

Parameters:
	ulNumToSkip	[in] Number of elements to skip

Returns:
	S_OK always
===================================================================*/
STDMETHODIMP CFlatKeyEnum::Skip(unsigned long ulNumToSkip) 
{
	TRACE0("MetaUtil: CFlatKeyEnum::Skip\n");

	m_iIndex += ulNumToSkip;

	return S_OK;
}

/*===================================================================
CFlatKeyEnum::Reset

Rests the enumeration to the first item

Parameters:
	None

Returns:
	S_OK always
===================================================================*/
STDMETHODIMP CFlatKeyEnum::Reset() 
{
	TRACE0("MetaUtil: CFlatKeyEnum::Reset\n");

	m_iIndex = 0;

	return S_OK; 
}

/*===================================================================
CFlatKeyEnum::Clone

Gets an interface pointer to a copy of the enumeration at its
current state.

Parameters:
	ppIReturn	[out] Pointer to interface for copy

Returns:
	E_OUTOFMEMORY if allocation fails.
	E_INVALIDARG if ppIReturn == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CFlatKeyEnum::Clone(IEnumVARIANT FAR* FAR* ppIReturn) 
{
	TRACE0("MetaUtil: CFlatKeyEnum::Clone\n");

	ASSERT_NULL_OR_POINTER(ppIReturn, LPUNKNOWN);

	if (ppIReturn == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	HRESULT hr;

	// Create a copy of the enumeration
	CComObject<CFlatKeyEnum> *pObj = NULL;
	ATLTRY(pObj = new CComObject<CFlatKeyEnum>);
	if (pObj == NULL) {
		return ::ReportError(E_OUTOFMEMORY);
	}
	hr = pObj->Init(m_pIMeta, m_tszBaseKey, m_iIndex);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	// Set the interface to IEnumVARIANT
	hr = pObj->QueryInterface(IID_IEnumVARIANT, (void **) ppIReturn);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}
	ASSERT(*ppIReturn != NULL);

	return S_OK;
}


/*------------------------------------------------------------------
 * C K e y S t a c k N o d e
 */

/*===================================================================
CKeyStackNode::Init

Constructor

Parameters:
	tszRelKey	Relative key for the enumeration level, NULL for root
	iIndex		0-based index for the next element

Returns:
	E_OUTOFMEMORY if allocation fails.
	E_INVALIDARG if iIndex < 0
	S_OK on success
===================================================================*/
HRESULT CKeyStackNode::Init(LPCTSTR tszRelKey, int iIndex)
{
	ASSERT_NULL_OR_STRING(tszRelKey);
	ASSERT(iIndex >= 0);

	// Copy the relative key string
	if (tszRelKey == NULL) {
		// RelKey is empty
		m_tszRelKey = NULL;
	}
	else {
		// Allocate and copy the passed string to the member string
		m_tszRelKey = new TCHAR[_tcslen(tszRelKey) + 1];
		if (m_tszRelKey == NULL) {
			return E_OUTOFMEMORY;
		}
		_tcscpy(m_tszRelKey, tszRelKey);
	}

	m_iIndex = iIndex;

	return S_OK;
}

/*===================================================================
CKeyStackNode::~CKeyStackNode

Destructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CKeyStackNode::~CKeyStackNode() 
{
	if (m_tszRelKey != NULL) {
		delete m_tszRelKey;
	}
}

/*===================================================================
CKeyStackNode::Clone

Copies the node, except for the next pointer, which is NULL.

Parameters:
	None

Returns:
	NULL on failure
	Pointer to copy of node on success
===================================================================*/
CKeyStackNode *CKeyStackNode::Clone()
{
	HRESULT hr;
	CKeyStackNode *pCRet;

	pCRet = new CKeyStackNode();
	if (pCRet == NULL) {
		return NULL;
	}

	hr = pCRet->Init(m_tszRelKey, m_iIndex);
	if (FAILED(hr)) {
		delete pCRet;
		return NULL;
	}

	return pCRet;
}

/*------------------------------------------------------------------
 * C K e y S t a c k
 */

/*===================================================================
CKeyStack::~CKeyStack

Destructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CKeyStack::~CKeyStack()
{
	// Delete the remaining nodes
	CKeyStackNode *pCDelete;

	while(m_pCTop != NULL) {
		ASSERT_POINTER(m_pCTop, CKeyStackNode);

		pCDelete = m_pCTop;
		m_pCTop = m_pCTop->m_pCNext;
		delete pCDelete;
	}
}

/*===================================================================
CKeyStack::Push

Pushes a CKeyStackNode onto the stack

Parameters:
	pNew	Pointer to CKeyStackNode to push on the stack

Returns:
	Nothing, never fails

Notes:
	CKeyStack "owns" the memory pointed to by pNew after call.
	CKeyStack or a later caller will delete it when done with it.
===================================================================*/
void CKeyStack::Push(CKeyStackNode *pCNew)
{
	ASSERT_POINTER(pCNew, CKeyStackNode);

	pCNew->m_pCNext = m_pCTop;
	m_pCTop = pCNew;
}

/*===================================================================
CKeyStack::Pop

Pops a CKeyStackNode from the stack

Parameters:
	None

Returns:
	Pointer to the top element or NULL if the stack is empty

Notes:
	Caller "owns" the memory pointed to by pNew after call.
	Caller is expected to delete it when it is done with it.
===================================================================*/
CKeyStackNode *CKeyStack::Pop()
{
	CKeyStackNode *pCRet;

	pCRet = m_pCTop;
	if (m_pCTop != NULL) {
		m_pCTop = m_pCTop->m_pCNext;
		ASSERT_NULL_OR_POINTER(m_pCTop, CKeyStackNode);
	}

	return pCRet;
}

/*===================================================================
CKeyStack::Clone

Copies the stack, including all of the nodes.

Parameters:
	Sheep

Returns:
	NULL on failure
	Pointer to copy of stack on success
===================================================================*/
CKeyStack *CKeyStack::Clone()
{
	CKeyStack *pCRet;

	// Build the container
	pCRet = new CKeyStack();
	if (pCRet == NULL) {
		return NULL;
	}

	// Copy the nodes
	CKeyStackNode *pCSource;
	CKeyStackNode **ppCDest;

	pCSource = m_pCTop;
	ppCDest = &(pCRet->m_pCTop);
	while(pCSource != NULL) {
		ASSERT_POINTER(pCSource, CKeyStackNode);

		*ppCDest = pCSource->Clone();
		if ((*ppCDest) == NULL) {
			delete pCRet;
			return NULL;
		}

		ppCDest = &((*ppCDest)->m_pCNext);
		pCSource = pCSource->m_pCNext;
	}
	*ppCDest = NULL;

	return pCRet;
}


/*------------------------------------------------------------------
 * C D e e p K e y C o l l e c t i o n
 */

/*===================================================================
CDeepKeyCollection::CDeepKeyCollection

Constructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CDeepKeyCollection::CDeepKeyCollection() : m_tszBaseKey(NULL) 
{
}

/*===================================================================
CDeepKeyCollection::Init

Constructor

Parameters:
	pIMeta		ATL Smart pointer to the metabase
	tszBaseKey	Name of key to enumerate from

Returns:
	E_OUTOFMEMORY if allocation fails
	S_OK on success
===================================================================*/
HRESULT CDeepKeyCollection::Init(const CComPtr<IMSAdminBase> &pIMeta, LPCTSTR tszBaseKey) 
{
	ASSERT(pIMeta.p != NULL);
	ASSERT_NULL_OR_STRING(tszBaseKey);

	m_pIMeta = pIMeta;

	// Copy tszBaseKey to m_tszBaseKey
	if (tszBaseKey == NULL) {
		// BaseKey is root
		m_tszBaseKey = NULL;
	}
	else {
		// Allocate and copy the passed string to the member string
		m_tszBaseKey = new TCHAR[_tcslen(tszBaseKey) + 1];
		if (m_tszBaseKey == NULL) {
			return ::ReportError(E_OUTOFMEMORY);
		}
		_tcscpy(m_tszBaseKey, tszBaseKey);
		CannonizeKey(m_tszBaseKey);
	}

	return S_OK;
}

/*===================================================================
CDeepKeyCollection::~CDeepKeyCollection

Destructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CDeepKeyCollection::~CDeepKeyCollection() 
{
	if (m_tszBaseKey != NULL)
		delete m_tszBaseKey;
}

/*===================================================================
CDeepKeyCollection::InterfaceSupportsErrorInfo

Standard ATL implementation

===================================================================*/
STDMETHODIMP CDeepKeyCollection::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IKeyCollection,
	};

	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}

/*===================================================================
CDeepKeyCollection::get_Count

Get method for Count property.  Counts the number of subkeys

Parameters:
	plReturn	[out, retval] Value to return to client.

Returns:
	E_INVALIDARG if pVal == NULL
	S_OK on success

Notes:
	Actually counts all of the subkeys recursivly.  Very slow, do 
	not put in a loop!
===================================================================*/
STDMETHODIMP CDeepKeyCollection::get_Count(long * pVal)
{
	TRACE0("MetaUtil: CDeepKeyCollection::get_Count\n");

	ASSERT_NULL_OR_POINTER(pVal, long);

	if (pVal == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	HRESULT hr;

	hr = CountKeys(m_tszBaseKey, pVal);
	
	return hr;
}

/*===================================================================
CDeepKeyCollection::get_Item

Get method for Item property.  Returns a key given its index.

Parameters:
	lIndex		[in] 1 based index of the key to get
	pbstrRetKey	[out, retval] Interface for the enumberation object

Returns:
	E_INVALIDARG if lIndex <= 0 or pbstrRetKey == NULL
	ERROR_NO_MORE_ITEMS if index is > count
	S_OK on success

Notes:
	This method is slow.  Deep enumerations are much faster.  Might 
	be able to do some hacking with a stack object and cached location 
	to speed up sequential calls.  
===================================================================*/
STDMETHODIMP CDeepKeyCollection::get_Item(long lIndex, BSTR *pbstrRetKey)
{
	TRACE0("MetaUtil: CDeepKeyCollection::get_Item\n");
	
	ASSERT_NULL_OR_POINTER(pbstrRetKey, BSTR);

	if ((lIndex <= 0) || (pbstrRetKey == NULL)) {
		return ::ReportError(E_INVALIDARG);
	}

	HRESULT hr;
	TCHAR tszRetKey[ADMINDATA_MAX_NAME_LEN];
	long lCurIndex;

	lCurIndex = 1;
	tszRetKey[0] = _T('\0');

	hr = IndexItem(NULL, lIndex, &lCurIndex, tszRetKey);
	if (hr == S_FALSE) {
		// Ran out of items before we found it
		return ::ReportError(ERROR_NO_MORE_ITEMS);
	}
	else if (hr == S_OK) {
		// Found it
		*pbstrRetKey = T2BSTR(tszRetKey);
	}
	else {
		return ::ReportError(hr);
	}

	return hr;
}

/*===================================================================
CDeepKeyCollection::get__NewEnum

Get method for _NewEnum property.  Returns an enumeration object for
the subkeys.

Parameters:
	ppIReturn	[out, retval] Interface for the enumberation object

Returns:
	E_INVALIDARG if ppIReturn == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CDeepKeyCollection::get__NewEnum(LPUNKNOWN * ppIReturn)
{
	TRACE0("MetaUtil: CDeepKeyCollection::get__NewEnum\n");

	ASSERT_NULL_OR_POINTER(ppIReturn, LPUNKNOWN);

	if (ppIReturn == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	HRESULT hr;

	// Create the deep key enumeration
	CComObject<CDeepKeyEnum> *pObj = NULL;
	ATLTRY(pObj = new CComObject<CDeepKeyEnum>);
	if (pObj == NULL) {
		return ::ReportError(E_OUTOFMEMORY);
	}
	hr = pObj->Init(m_pIMeta, m_tszBaseKey, NULL);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	// Set the interface to IUnknown
	hr = pObj->QueryInterface(IID_IUnknown, (void **) ppIReturn);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}
	ASSERT(*ppIReturn != NULL);

	return S_OK;
}

/*===================================================================
CDeepKeyCollection::Add

Adds a key to the metabase relative to the collection's base key

Parameters:
	bstrRelKey	[in] Relative key to add

Returns:
	E_INVALIDARG if bstrRelKey == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CDeepKeyCollection::Add(BSTR bstrRelKey)
{
	TRACE0("MetaUtil: CDeepKeyCollection::Add\n");

	ASSERT_NULL_OR_POINTER(bstrRelKey, OLECHAR);

	if (bstrRelKey == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	// Build the full key
	USES_CONVERSION;
	TCHAR tszFullKey[ADMINDATA_MAX_NAME_LEN];

	if (m_tszBaseKey == NULL) {
		_tcscpy(tszFullKey, OLE2T(bstrRelKey));
	}
	else {
		_tcscpy(tszFullKey, m_tszBaseKey);
		_tcscat(tszFullKey, _T("/"));
		_tcscat(tszFullKey, OLE2T(bstrRelKey));
	}
	CannonizeKey(tszFullKey);

	return ::CreateKey(m_pIMeta, tszFullKey);
}

/*===================================================================
CDeepKeyCollection::Remove

Removes a key from the metabase relative to the collection's base key

Parameters:
	bstrRelKey	[in] Relative key to remove

Returns:
	E_INVALIDARG if bstrRelKey == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CDeepKeyCollection::Remove(BSTR bstrRelKey)
{
	TRACE0("MetaUtil: CDeepKeyCollection::Remove\n");

	ASSERT_NULL_OR_POINTER(bstrRelKey, OLECHAR);

	if (bstrRelKey == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	// Build the full key
	USES_CONVERSION;
	TCHAR tszFullKey[ADMINDATA_MAX_NAME_LEN];

	if (m_tszBaseKey == NULL) {
		_tcscpy(tszFullKey, OLE2T(bstrRelKey));
	}
	else {
		_tcscpy(tszFullKey, m_tszBaseKey);
		_tcscat(tszFullKey, _T("/"));
		_tcscat(tszFullKey, OLE2T(bstrRelKey));
	}
	CannonizeKey(tszFullKey);

	return ::DeleteKey(m_pIMeta, tszFullKey);
}

/*===================================================================
CDeepKeyCollection::CountKeys

Private, recursive method for counting keys

Parameters:
	tszBaseKey	[in] Key to begin counting with (but not to count)
				NULL can represent the root key.
	plNumKeys	[out] Number of keys counter, not including the base
	
Returns:
	S_OK on success
===================================================================*/
HRESULT CDeepKeyCollection::CountKeys(LPTSTR tszBaseKey, long *plNumKeys) 
{
	ASSERT_NULL_OR_STRING(tszBaseKey);
	ASSERT_POINTER(plNumKeys, long);

	*plNumKeys = 0;

	USES_CONVERSION;
	HRESULT hr;
	wchar_t wszSubKey[ADMINDATA_MAX_NAME_LEN];
	wchar_t wszFullSubKey[ADMINDATA_MAX_NAME_LEN];
	int iIndex;

	iIndex = 0;
	for (;;) {  // FOREVER, will return from loop
		hr = m_pIMeta->EnumKeys(METADATA_MASTER_ROOT_HANDLE, 
								T2W(tszBaseKey), 
								wszSubKey, 
								iIndex);
		if (FAILED(hr)) {
			if ((HRESULT_CODE(hr) == ERROR_NO_MORE_ITEMS) ||
				(HRESULT_CODE(hr) == ERROR_PATH_NOT_FOUND)) {
				// Ran out of items, break
				return S_OK;
			}
			else {
				return ::ReportError(hr);
			}
		}
		else { // SUCCEEDED(hr)
			// Build the full subkey
			if ((tszBaseKey == NULL) ||
				(tszBaseKey[0] == _T('\0')) ) {
				wcscpy(wszFullSubKey, wszSubKey);
			}
			else {
				wcscpy(wszFullSubKey, T2W(tszBaseKey));
				wcscat(wszFullSubKey, L"/");
				wcscat(wszFullSubKey, wszSubKey);
			}

			// Count this key
			(*plNumKeys)++;

			// Count the subkeys
			long lNumSubKeys;
			hr = CountKeys(W2T(wszFullSubKey), &lNumSubKeys);
			if (FAILED(hr)) {
				return hr;
			}
			(*plNumKeys) += lNumSubKeys;

		}
		iIndex++;
	}
}

/*===================================================================
CDeepKeyCollection::IndexItem

Private, recursive method for indexing keys

Parameters:
	tszRelKey	Relative key to index from
	lDestIndex	Destination index
	plCurIndex	Current (working) index
	tszRet		Result from search	

Returns:
	S_OK if the destination index was reached
	S_FALSE if the destination index was not reached
===================================================================*/
HRESULT CDeepKeyCollection::IndexItem(LPTSTR tszRelKey, long lDestIndex, long *plCurIndex, LPTSTR tszRet) 
{
	ASSERT_NULL_OR_STRING(tszRelKey);
	ASSERT_POINTER(plCurIndex, long);
	ASSERT_STRING(tszRet);

	USES_CONVERSION;
	HRESULT hr;
	wchar_t wszSubKey[ADMINDATA_MAX_NAME_LEN];
	wchar_t wszRelSubKey[ADMINDATA_MAX_NAME_LEN];
	int iIndex;

	// Open the base key
	METADATA_HANDLE hMDBaseKey;

	hr = m_pIMeta->OpenKey(METADATA_MASTER_ROOT_HANDLE,
						   T2W(m_tszBaseKey),
						   METADATA_PERMISSION_READ,
					       MUTIL_OPEN_KEY_TIMEOUT,
						   &hMDBaseKey);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	iIndex = 0;
	for (;;) {  // FOREVER, will return from loop
		hr = m_pIMeta->EnumKeys(hMDBaseKey, 
								T2W(tszRelKey), 
								wszSubKey, 
								iIndex);
		if (FAILED(hr)) {
			m_pIMeta->CloseKey(hMDBaseKey);
			if ((HRESULT_CODE(hr) == ERROR_NO_MORE_ITEMS) ||
				(HRESULT_CODE(hr) == ERROR_PATH_NOT_FOUND)) {
				// Ran out of items, break
				return S_FALSE;
			}
			else {
				return ::ReportError(hr);
			}
		}
		else {
			// Build the full subkey
			if ((tszRelKey == NULL) ||
				(tszRelKey[0] == _T('\0')) ) {
				wcscpy(wszRelSubKey, wszSubKey);
			}
			else {
				wcscpy(wszRelSubKey, T2W(tszRelKey));
				wcscat(wszRelSubKey, L"/");
				wcscat(wszRelSubKey, wszSubKey);
			}

			// Is this the destination?
			if ((*plCurIndex) == lDestIndex) {
				//Found it, copy it to the return buffer
				_tcscpy(tszRet, W2T(wszRelSubKey));

				m_pIMeta->CloseKey(hMDBaseKey);
				return S_OK;
			}

			// Count this key
			(*plCurIndex)++;

			// Check the subkeys
			hr = IndexItem(W2T(wszRelSubKey), lDestIndex, plCurIndex, tszRet);
			if (hr == S_OK) {
				//Found it
				m_pIMeta->CloseKey(hMDBaseKey);
				return S_OK;
			}
			else if (FAILED(hr)) {
				m_pIMeta->CloseKey(hMDBaseKey);
				return hr;
			}
		}
		iIndex++;
	}

	// Close the base key
	m_pIMeta->CloseKey(hMDBaseKey);

	return S_OK;
}

/*------------------------------------------------------------------
 * C D e e p K e y E n u m
 */

/*===================================================================
CDeepKeyEnum::CDeepKeyEnum

Constructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CDeepKeyEnum::CDeepKeyEnum() : m_tszBaseKey(NULL),
							   m_pCKeyStack(NULL)
{
}

/*===================================================================
CDeepKeyEnum::Init

Constructor

Parameters:
	pIMeta		ATL Smart pointer to the metabase
	tszBaseKey	Name of key to enumerate from
	pKeyStack	pointer to a stack containing the state to copy or
				NULL to start from the begining

Returns:
	E_OUTOFMEMORY if allocation fails
	S_OK on success
===================================================================*/
HRESULT CDeepKeyEnum::Init(const CComPtr<IMSAdminBase> &pIMeta, 
						   LPCTSTR tszBaseKey, 
						   CKeyStack *pCKeyStack) 
{
	ASSERT(pIMeta.p != NULL);
	ASSERT_NULL_OR_STRING(tszBaseKey);
	ASSERT_NULL_OR_POINTER(pCKeyStack, CKeyStack);

	HRESULT hr;

	m_pIMeta = pIMeta;
	
	// Copy the base string
	if (tszBaseKey == NULL) {
		// BaseKey is root
		m_tszBaseKey = NULL;
	}
	else {
		// Allocate and copy the passed string to the member string
		m_tszBaseKey = new TCHAR[_tcslen(tszBaseKey) + 1];
		if (m_tszBaseKey == NULL) {
			return ::ReportError(E_OUTOFMEMORY);
		}
		_tcscpy(m_tszBaseKey, tszBaseKey);
		CannonizeKey(m_tszBaseKey);
	}

	// Setup the stack
	if (pCKeyStack == NULL) {
		// Build a new stack
		CKeyStackNode *pCNew;

		m_pCKeyStack = new CKeyStack();
		if (m_pCKeyStack == NULL) {
			return ::ReportError(E_OUTOFMEMORY);
		}

		// Create the first node
		pCNew = new CKeyStackNode();
		if (pCNew == NULL) {
			delete m_pCKeyStack;
			m_pCKeyStack = NULL;
			return ::ReportError(E_OUTOFMEMORY);
		}
		hr = pCNew->Init(NULL, 0);
		if (FAILED(hr)) {
			delete m_pCKeyStack;
			m_pCKeyStack = NULL;
			return ::ReportError(E_OUTOFMEMORY);
		}

		// Put the first node onto the stack
		m_pCKeyStack->Push(pCNew);
	}
	else {
		// Clone the stack we were passed
		m_pCKeyStack = pCKeyStack->Clone();
		if (m_pCKeyStack == NULL) {
			return ::ReportError(E_OUTOFMEMORY);
		}
	}

	return S_OK;
}

/*===================================================================
CDeepKeyEnum::~CDeepKeyEnum

Destructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CDeepKeyEnum::~CDeepKeyEnum()
{
	if (m_tszBaseKey != NULL) {
		delete m_tszBaseKey;
	}
	if (m_pCKeyStack != NULL) {
		delete m_pCKeyStack;
	}
}

/*===================================================================
CDeepKeyEnum::Next

Gets the next n items from the enumberation.

Parameters:
	ulNumToGet	[in] Number of elements to get
	rgvarDest	[out] Array to put them in
	pulNumGot	[out] If not NULL, number of elements rgvarDest got

Returns:
	S_OK if outputs ulNumToGet items
	S_FALSE if outputs less than ulNumToGet items
	E_OUTOFMEMORY if allocation failed
===================================================================*/
STDMETHODIMP CDeepKeyEnum::Next(unsigned long ulNumToGet, 
								VARIANT FAR* rgvarDest, 
								unsigned long FAR* pulNumGot) 
{
	TRACE0("MetaUtil: CDeepKeyEnum::Next\n");

	ASSERT_NULL_OR_POINTER(pulNumGot, unsigned long);
	// Make sure the array is big enough and we can write to it
	ASSERT((rgvarDest == NULL) || IsValidAddress(rgvarDest, ulNumToGet * sizeof(VARIANT), TRUE));

	if (pulNumGot != NULL) {
		pulNumGot = 0;
	}

	USES_CONVERSION;
	HRESULT hr;
	unsigned int i;
	CKeyStackNode *pCKeyNode;
	CKeyStackNode *pCSubKeyNode;
	wchar_t wszSubKey[ADMINDATA_MAX_NAME_LEN];
	wchar_t wszRelSubKey[ADMINDATA_MAX_NAME_LEN];

	// Open the base key
	METADATA_HANDLE hMDBaseKey;

	hr = m_pIMeta->OpenKey(METADATA_MASTER_ROOT_HANDLE,
						   T2W(m_tszBaseKey),
						   METADATA_PERMISSION_READ,
					       MUTIL_OPEN_KEY_TIMEOUT,
						   &hMDBaseKey);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	// For each element to retrive
	for (i=0; i < ulNumToGet; i++) {
		// Get a subkey
		do {
			// Pop a key off the stack
			pCKeyNode = m_pCKeyStack->Pop();

			// if the stack is empty, we're done return S_FALSE
			if (pCKeyNode == NULL) {
				m_pIMeta->CloseKey(hMDBaseKey);
				if (pulNumGot != NULL) {
					*pulNumGot = i;
				}
				return S_FALSE;
			}

			// Attempt to Enum the next key
			hr = m_pIMeta->EnumKeys(hMDBaseKey, 
									T2W(pCKeyNode->GetBaseKey()), 
									wszSubKey, 
									pCKeyNode->GetIndex());

			// If failed delete the stack entry
			if (FAILED(hr)) {
				delete pCKeyNode;

				if ((HRESULT_CODE(hr) != ERROR_NO_MORE_ITEMS) &&
					(HRESULT_CODE(hr) != ERROR_PATH_NOT_FOUND)) {
					// Got an unexpected Error
					m_pIMeta->CloseKey(hMDBaseKey);
					return ::ReportError(hr);
				}
				
			}

		} while (FAILED(hr));

		// Build the relative subkey
		if ((pCKeyNode->GetBaseKey() == NULL) ||
			((pCKeyNode->GetBaseKey())[0] == _T('\0')) ) {
			wcscpy(wszRelSubKey, wszSubKey);
		}
		else {
			wcscpy(wszRelSubKey, T2W(pCKeyNode->GetBaseKey()));
			wcscat(wszRelSubKey, L"/");
			wcscat(wszRelSubKey, wszSubKey);
		}

		// Output the relative subkey
		VariantInit(&(rgvarDest[i]));
		rgvarDest[i].vt = VT_BSTR;
		rgvarDest[i].bstrVal = W2BSTR(wszRelSubKey);

		// Increment the key index
		pCKeyNode->SetIndex(pCKeyNode->GetIndex() + 1);

		// Push the key back onto the stack
		m_pCKeyStack->Push(pCKeyNode);

		// Create a stack node for the subkey
		pCSubKeyNode = new CKeyStackNode();
		if (pCSubKeyNode == NULL) {
			m_pIMeta->CloseKey(hMDBaseKey);
			return ::ReportError(E_OUTOFMEMORY);
		}
		hr = pCSubKeyNode->Init(W2T(wszRelSubKey), 0);
		if (FAILED(hr)) {
			m_pIMeta->CloseKey(hMDBaseKey);
			return ::ReportError(hr);
		}

		// Push the subkey onto the stack
		m_pCKeyStack->Push(pCSubKeyNode);
	}

	// Close the base key
	m_pIMeta->CloseKey(hMDBaseKey);

	if (pulNumGot != NULL) {
		*pulNumGot = i;
		}

	return S_OK;
}

/*===================================================================
CDeepKeyEnum::Skip

Skips the next n items in an enumeration

Parameters:
	ulNumToSkip	[in] Number of elements to skip

Returns:
	S_OK if outputs ulNumToGet items
	E_OUTOFMEMORY if allocation failed
===================================================================*/
STDMETHODIMP CDeepKeyEnum::Skip(unsigned long ulNumToSkip) 
{
	TRACE0("MetaUtil: CDeepKeyEnum::Skip\n");

	USES_CONVERSION;
	HRESULT hr;
	unsigned long i;
	CKeyStackNode *pCKeyNode;
	CKeyStackNode *pCSubKeyNode;
	wchar_t wszSubKey[ADMINDATA_MAX_NAME_LEN];
	wchar_t wszRelSubKey[ADMINDATA_MAX_NAME_LEN];

	// Open the base key
	METADATA_HANDLE hMDBaseKey;

	hr = m_pIMeta->OpenKey(METADATA_MASTER_ROOT_HANDLE,
						   T2W(m_tszBaseKey),
						   METADATA_PERMISSION_READ,
					       MUTIL_OPEN_KEY_TIMEOUT,
						   &hMDBaseKey);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	// For each element to stip
	for (i=0; i < ulNumToSkip; i++) {
		// Get a subkey
		do {
			// Pop a key off the stack
			pCKeyNode = m_pCKeyStack->Pop();

			// if the stack is empty, we're done return S_OK
			if (pCKeyNode == NULL) {
				m_pIMeta->CloseKey(hMDBaseKey);
				return S_OK;
			}

			// Attempt to Enum the next key
			hr = m_pIMeta->EnumKeys(METADATA_MASTER_ROOT_HANDLE, 
									T2W(pCKeyNode->GetBaseKey()), 
									wszSubKey, 
									pCKeyNode->GetIndex());

			// If failed delete the stack entry
			if (FAILED(hr)) {
				delete pCKeyNode;

				if ((HRESULT_CODE(hr) != ERROR_NO_MORE_ITEMS) &&
					(HRESULT_CODE(hr) != ERROR_PATH_NOT_FOUND)) {
					// Got an unexpected Error
					m_pIMeta->CloseKey(hMDBaseKey);
					return ::ReportError(hr);
				}
			}

		} while (FAILED(hr));

		// Build the relative subkey
		if ((pCKeyNode->GetBaseKey() == NULL) ||
			((pCKeyNode->GetBaseKey())[0] == _T('\0')) ) {
			wcscpy(wszRelSubKey, wszSubKey);
		}
		else {
			wcscpy(wszRelSubKey, T2W(pCKeyNode->GetBaseKey()));
			wcscat(wszRelSubKey, L"/");
			wcscat(wszRelSubKey, wszSubKey);
		}

		// Increment the key index
		pCKeyNode->SetIndex(pCKeyNode->GetIndex() + 1);

		// Push the key back on the stack
		m_pCKeyStack->Push(pCKeyNode);

		// Create a stack node for the subkey
		pCSubKeyNode = new CKeyStackNode();
		if (pCSubKeyNode == NULL) {
			m_pIMeta->CloseKey(hMDBaseKey);
			return ::ReportError(E_OUTOFMEMORY);
		}
		hr = pCSubKeyNode->Init(W2T(wszRelSubKey), 0);
		if (FAILED(hr)) {
			m_pIMeta->CloseKey(hMDBaseKey);
			return ::ReportError(hr);
		}

		// Push the subkey onto the stack
		m_pCKeyStack->Push(pCSubKeyNode);
	}

	// Close the base key
	m_pIMeta->CloseKey(hMDBaseKey);

	return S_OK;
}

/*===================================================================
CDeepKeyEnum::Reset

Rests the enumeration to the first item

Parameters:
	None

Returns:
	E_OUTOFMEMORY if not enough memory to build a new stack
	S_OK on success
===================================================================*/
STDMETHODIMP CDeepKeyEnum::Reset() 
{
	TRACE0("MetaUtil: CDeepKeyEnum::Reset\n");

	HRESULT hr;

	// Build a new stack (if this fails we still have the old stack)
	CKeyStack *pCNewStack;
	CKeyStackNode *pCNewNode;

	pCNewStack = new CKeyStack();
	if (pCNewStack == NULL) {
		return ::ReportError(E_OUTOFMEMORY);
	}

	// Create the first node
	pCNewNode = new CKeyStackNode();
	if (pCNewNode == NULL) {
		delete pCNewStack;
		return ::ReportError(E_OUTOFMEMORY);
	}
	hr = pCNewNode->Init(NULL, 0);
	if (FAILED(hr)) {
		delete pCNewStack;
		return ::ReportError(E_OUTOFMEMORY);
	}

	// Put the first node onto the new stack
	pCNewStack->Push(pCNewNode);

	// Replace the old stack
	delete m_pCKeyStack;
	m_pCKeyStack = pCNewStack;

	return S_OK; 
}

/*===================================================================
CDeepKeyEnum::Clone

Gets an interface pointer to a copy of the enumeration at its
current state.

Parameters:
	ppIReturn	[out] Pointer to interface for copy

Returns:
	E_INVALIDARG if ppIReturn == NULL
	E_OUTOFMEMORY if not enough memory to create clone
	S_OK on success
===================================================================*/
STDMETHODIMP CDeepKeyEnum::Clone(IEnumVARIANT FAR* FAR* ppIReturn) 
{
	TRACE0("MetaUtil: CDeepKeyEnum::Clone\n");

	ASSERT_NULL_OR_POINTER(ppIReturn, LPUNKNOWN);

	if (ppIReturn == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	HRESULT hr;

	// Create a copy of the enumeration
	CComObject<CDeepKeyEnum> *pObj = NULL;
	ATLTRY(pObj = new CComObject<CDeepKeyEnum>);
	if (pObj == NULL) {
		return ::ReportError(E_OUTOFMEMORY);
	}
	hr = pObj->Init(m_pIMeta, m_tszBaseKey, m_pCKeyStack);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	// Set the interface to IEnumVARIANT
	hr = pObj->QueryInterface(IID_IEnumVARIANT, (void **) ppIReturn);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}
	ASSERT(*ppIReturn != NULL);

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\metautil\keycol.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: MetaUtil object

File: KeyCol.h

Owner: t-BrianM

This file contains the headers for the key collections.
===================================================================*/

#ifndef __KEYCOL_H_
#define __KEYCOL_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"       // main symbols

/*
 * C F l a t K e y C o l l e c t i o n
 *
 * Implements non-recursive subkey collections.
 */

class CFlatKeyCollection : 
	public IDispatchImpl<IKeyCollection, &IID_IKeyCollection, &LIBID_MetaUtil>,
	public ISupportErrorInfo,
	public CComObjectRoot
{
public:

BEGIN_COM_MAP(CFlatKeyCollection)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IKeyCollection)	
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE(CFlatKeyCollection)

	CFlatKeyCollection();
	HRESULT Init(const CComPtr<IMSAdminBase> &pIMeta, LPCTSTR tszBaseKey);
	~CFlatKeyCollection();

// IKeyCollection
	STDMETHOD(get_Count)(/*[out, retval]*/ long *plReturn);
	STDMETHOD(get_Item)(/*[in]*/ long lIndex, /*[out, retval]*/ BSTR *pbstrRetKey);
	STDMETHOD(get__NewEnum)(/*[out, retval]*/ LPUNKNOWN *ppIReturn);
	STDMETHOD(Add)(/*[in]*/ BSTR bstrRelKey);
	STDMETHOD(Remove)(/*[in]*/ BSTR bstrRelKey);

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

private:
	LPTSTR m_tszBaseKey;

	// Pointer to IMSAdminBase so we don't have to recreate it multiple times
	CComPtr<IMSAdminBase> m_pIMeta;
};


/*
 * C F l a t K e y E n u m
 *
 * Implements non-recursive subkey enumerations.
 */

class CFlatKeyEnum :
	public IEnumVARIANT,
	public CComObjectRoot
{

public:
	CFlatKeyEnum();
	HRESULT Init(const CComPtr<IMSAdminBase> &pIMeta, LPCTSTR tszBaseKey, int iIndex);
	~CFlatKeyEnum();

BEGIN_COM_MAP(CFlatKeyEnum)
	COM_INTERFACE_ENTRY(IEnumVARIANT)
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE(CFlatKeyEnum)  

//IEnumVARIANT
	STDMETHOD(Next)(unsigned long ulNumToGet, 
					VARIANT FAR* rgvarDest, 
					unsigned long FAR* pulNumGot);
	STDMETHOD(Skip)(unsigned long ulNumToSkip);
	STDMETHOD(Reset)();
	STDMETHOD(Clone)(IEnumVARIANT FAR* FAR* ppIReturn);


private:
	int m_iIndex;
	LPTSTR m_tszBaseKey;

	// Pointer to IMSAdminBase so we don't have to recreate it multiple times
	CComPtr<IMSAdminBase> m_pIMeta;
};

/*
 * C K e y S t a c k
 *
 * C K e y S t a c k N o d e
 *
 * Internal classes used to maintain and clone the state for a
 * deep key enumberation.
 */
class CKeyStack;

class CKeyStackNode {

	friend CKeyStack;

public:
	CKeyStackNode() { m_tszRelKey = NULL; m_iIndex = 0; m_pCNext = NULL; }
	HRESULT Init(LPCTSTR tszRelKey, int iIndex);
	~CKeyStackNode();

	int GetIndex() { return m_iIndex; }
	void SetIndex(int iIndex) { ASSERT(iIndex >= 0); m_iIndex = iIndex; }

	LPTSTR GetBaseKey() { return m_tszRelKey; }

	CKeyStackNode *Clone();

private:
	LPTSTR m_tszRelKey;
	int m_iIndex;

	CKeyStackNode *m_pCNext;
};

class CKeyStack {
public:
	CKeyStack() { m_pCTop = NULL; }
	~CKeyStack();

	void Push(CKeyStackNode *pCNew);
	CKeyStackNode *Pop();

	BOOL IsEmpty() { return (m_pCTop == NULL); }

	CKeyStack *Clone();

private:
	CKeyStackNode *m_pCTop;

};


/*
 * C D e e p K e y C o l l e c t i o n
 *
 * Implements recursive (depth first) subkey collections.
 */

class CDeepKeyCollection : 
	public IDispatchImpl<IKeyCollection, &IID_IKeyCollection, &LIBID_MetaUtil>,
	public ISupportErrorInfo,
	public CComObjectRoot
{
public:
BEGIN_COM_MAP(CDeepKeyCollection)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IKeyCollection)	
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE(CDeepKeyCollection)

	CDeepKeyCollection();
	HRESULT Init(const CComPtr<IMSAdminBase> &pIMeta, LPCTSTR tszBaseKey);
	~CDeepKeyCollection();

// IKeyCollection
	STDMETHOD(get_Count)(/*[out, retval]*/ long *plReturn);
	STDMETHOD(get_Item)(/*[in]*/ long lIndex, /*[out, retval]*/ BSTR *pbstrRetKey);
	STDMETHOD(get__NewEnum)(/*[out, retval]*/ LPUNKNOWN *ppIReturn);
	STDMETHOD(Add)(/*[in]*/ BSTR bstrRelKey);
	STDMETHOD(Remove)(/*[in]*/ BSTR bstrRelKey);
	
// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

private:
	LPTSTR m_tszBaseKey;

	// Pointer to IMSAdminBase so we don't have to recreate it multiple times
	CComPtr<IMSAdminBase> m_pIMeta;

	HRESULT CountKeys(LPTSTR tszBaseKey, long *plNumKeys);
	HRESULT IndexItem(LPTSTR tszRelKey, long lDestIndex, long *plCurIndex, LPTSTR ptszRet);
};


/*
 * C D e e p K e y E n u m
 *
 * Implements recursive (depth first) subkey enumerations.
 */

class CDeepKeyEnum :
	public IEnumVARIANT,
	public CComObjectRoot
{

public:
	CDeepKeyEnum();
	HRESULT Init(const CComPtr<IMSAdminBase> &pIMeta, LPCTSTR tszBaseKey, CKeyStack *pCKeyStack);
	~CDeepKeyEnum();

BEGIN_COM_MAP(CDeepKeyEnum)
	COM_INTERFACE_ENTRY(IEnumVARIANT)
END_COM_MAP()
DECLARE_NOT_AGGREGATABLE(CDeepKeyEnum)  

//IEnumVARIANT
	STDMETHOD(Next)(unsigned long ulNumToGet, 
					VARIANT FAR* rgvarDest, 
					unsigned long FAR* pulNumGot);
	STDMETHOD(Skip)(unsigned long ulNumToSkip);
	STDMETHOD(Reset)();
	STDMETHOD(Clone)(IEnumVARIANT FAR* FAR* ppenum);


private:
	LPTSTR m_tszBaseKey;
	CKeyStack *m_pCKeyStack;

	// Pointer to IMSAdminBase so we don't have to recreate it multiple times
	CComPtr<IMSAdminBase> m_pIMeta;
};

#endif //__KEYCOL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\metautil\chkmeta.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: MetaUtil object

File: ChkMeta.cpp

Owner: t-BrianM

This file contains implementations of the CheckSchema and CheckKey
methods of the main MetaUtil class.
===================================================================*/

#include "stdafx.h"
#include "MetaUtil.h"
#include "MUtilObj.h"
#include "ChkMeta.h"

/*------------------------------------------------------------------
 * C M e t a U t i l  (check portion)
 */

/*===================================================================
CMetaUtil::CheckSchema

Check the schema of a given machine for errors.

Directly Generates:
	MUTIL_CHK_NO_SCHEMA
	MUTIL_CHK_NO_PROPERTIES
	MUTIL_CHK_NO_PROP_NAMES
	MUTIL_CHK_NO_PROP_TYPES
	MUTIL_CHK_NO_CLASSES

Parameters:
    bstrMachine	[in] Base key of the machine to check
	ppIReturn	[out, retval] interface for the output error collection

Returns:
	E_OUTOFMEMORY if allocation fails.
	E_INVALIDARG ppIReturn == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CMetaUtil::CheckSchema(BSTR bstrMachine, 
									ICheckErrorCollection **ppIReturn)
{
	TRACE0("MetaUtil: CMetaUtil::CheckSchema\n");

	ASSERT_NULL_OR_POINTER(ppIReturn, ICheckErrorCollection *);

	if ((ppIReturn == NULL)) {
		return ::ReportError(E_INVALIDARG);
	}

	USES_CONVERSION;
	HRESULT hr;
	TCHAR tszMachine[ADMINDATA_MAX_NAME_LEN];

    if (bstrMachine) {
      	_tcscpy(tszMachine, OLE2T(bstrMachine));
	    CannonizeKey(tszMachine);
    }
    else {
        tszMachine[0] = _T('\0');
    }

	// Create the CheckErrorCollection
	CComObject<CCheckErrorCollection> *pCErrorCol = NULL;

	ATLTRY(pCErrorCol = new CComObject<CCheckErrorCollection>);
	if (pCErrorCol == NULL) {
		return ::ReportError(E_OUTOFMEMORY);
	}

	// Open the Machine Key
	METADATA_HANDLE hMDMachine = NULL;

	hr = m_pIMeta->OpenKey(METADATA_MASTER_ROOT_HANDLE,
						   L"",
						   METADATA_PERMISSION_READ,
					       MUTIL_OPEN_KEY_TIMEOUT,
						   &hMDMachine);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	// Make sure "Schema" exists
	if (!KeyExists(hMDMachine, _T("Schema"))) {
		AddError(pCErrorCol,
				 MUTIL_CHK_NO_SCHEMA,
				 MUTIL_CHK_NO_SCHEMA_S,
				 tszMachine,
				 NULL,
				 0);
		
		goto LDone; // Can't do anything else
	}

	// Make sure "Schema/Properties" exists
	if (!KeyExists(hMDMachine, _T("Schema/Properties"))) {
		AddError(pCErrorCol,
				 MUTIL_CHK_NO_PROPERTIES,
				 MUTIL_CHK_NO_PROPERTIES_S,
				 tszMachine,
				 _T("Schema"),
				 0);
		
		goto LClasses; // Can't do anything else with properties
	}

	// Make sure "Schema/Properties/Names" exists
	if (!KeyExists(hMDMachine, _T("Schema/Properties/Names"))) {
		AddError(pCErrorCol,
				 MUTIL_CHK_NO_PROP_NAMES,
				 MUTIL_CHK_NO_PROP_NAMES_S,
				 tszMachine,
				 _T("Schema/Properties"),
				 0);
		
		goto LPropTypes; // Can't do anything else with names
	}

	// Check property names
	hr = CheckPropertyNames(pCErrorCol, hMDMachine, tszMachine);
	if (FAILED(hr)) {
		goto LError;
	}

LPropTypes:

	// Make sure "Schema/Properties/Types" exists
	if (!KeyExists(hMDMachine, _T("Schema/Properties/Types"))) {
		AddError(pCErrorCol,
				 MUTIL_CHK_NO_PROP_TYPES,
				 MUTIL_CHK_NO_PROP_TYPES_S,
				 tszMachine,
				 _T("Schema/Properties"),
				 0);
		
		goto LClasses; // Can't do anything else with types
	}

	// Check property types
	hr = CheckPropertyTypes(pCErrorCol, hMDMachine, tszMachine);
	if (FAILED(hr)) {
		goto LError;
	}

LClasses:

	// Make sure "Schema/Classes" exists
	if (!KeyExists(hMDMachine, _T("Schema/Classes"))) {
		AddError(pCErrorCol,
				 MUTIL_CHK_NO_CLASSES,
				 MUTIL_CHK_NO_CLASSES_S,
				 tszMachine,
				 _T("Schema"),
				 0);
		
		goto LDone; // Can't do anything else
	}

	// Check classes
	hr = CheckClasses(pCErrorCol, hMDMachine, tszMachine);
	if (FAILED(hr)) {
		goto LError;
	}

LDone:

	// Close the Machine Key
	m_pIMeta->CloseKey(hMDMachine);

	// Set the interface to ICheckErrorCollection
	hr = pCErrorCol->QueryInterface(IID_ICheckErrorCollection, (void **) ppIReturn);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}
	ASSERT(*ppIReturn != NULL);

	return S_OK;

LError:

	if (pCErrorCol != NULL) {
		delete pCErrorCol;
	}
	if (hMDMachine != NULL) {
		m_pIMeta->CloseKey(hMDMachine);
	}

	return hr;
}

/*===================================================================
CMetaUtil::CheckPropertyNames

Private function to check the "Schema/Properties/Names" key of a 
given machine.
	o Make sure that each name entry is of type STRING_METADATA
	o Make sure that each name is unique

Directly Generates:
	MUTIL_CHK_PROP_NAME_BAD_TYPE
	MUTIL_CHK_PROP_NAME_NOT_UNIQUE
	MUTIL_CHK_PROP_NAME_NOT_CASE_UNIQUE

Parameters:
	pCErrorCol	Pointer to the error collection to put errors in
	hMDMachine	Open metabase handle for the machine key
	tszMachine	Name of the machine key

Returns:
	E_OUTOFMEMORY if allocation fails.
	S_OK on success
===================================================================*/
HRESULT CMetaUtil::CheckPropertyNames(CComObject<CCheckErrorCollection> *pCErrorCol, 
									  METADATA_HANDLE hMDMachine, 
									  LPTSTR tszMachine)
{
	ASSERT_POINTER(pCErrorCol, CComObject<CCheckErrorCollection>);
	ASSERT_STRING(tszMachine);

	USES_CONVERSION;
	HRESULT hr;
	int iDataIndex;
	METADATA_RECORD mdr;
	DWORD dwReqDataLen;
	DWORD dwDataBufLen;
	BYTE *lpDataBuf = NULL;
	LPTSTR tszName;
	CNameTable CPropNameTable;


	//Setup the return buffer
	dwDataBufLen = 256;
	lpDataBuf = new BYTE[dwDataBufLen];
	if (lpDataBuf == NULL) {
		return E_OUTOFMEMORY;
	}

	// For Each Data Item
	iDataIndex = 0;
	mdr.dwMDIdentifier = 0;
	mdr.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    mdr.dwMDUserType = ALL_METADATA;
	mdr.dwMDDataType = ALL_METADATA;
	mdr.dwMDDataLen = dwDataBufLen;
	mdr.pbMDData = (PBYTE) lpDataBuf;
	mdr.dwMDDataTag = 0;
	hr = m_pIMeta->EnumData(hMDMachine, 
			                L"Schema/Properties/Names", 
						    &mdr, 
						    iDataIndex, 
						    &dwReqDataLen);
	while (SUCCEEDED(hr)) {

		// Datatype must be STRING_METADATA
		if (mdr.dwMDDataType != STRING_METADATA) {
			AddError(pCErrorCol,
					 MUTIL_CHK_PROP_NAME_BAD_TYPE,
					 MUTIL_CHK_PROP_NAME_BAD_TYPE_S,
					 tszMachine,
					 _T("Schema/Properties/Names"),
					 mdr.dwMDIdentifier);
		}
		else { // mdr.dwMDDataType == STRING_METADATA

			// Check uniqueness of the name
			tszName = W2T(reinterpret_cast<LPWSTR> (lpDataBuf));

			if (CPropNameTable.IsCaseSenDup(tszName)) { 
				// Not unique
				AddError(pCErrorCol,
					 MUTIL_CHK_PROP_NAME_NOT_UNIQUE,
					 MUTIL_CHK_PROP_NAME_NOT_UNIQUE_S,
					 tszMachine,
					 _T("Schema/Properties/Names"),
					 mdr.dwMDIdentifier);
			}
			else if (CPropNameTable.IsCaseInsenDup(tszName)) { 
				// Case sensitive unique
				AddError(pCErrorCol,
					 MUTIL_CHK_PROP_NAME_NOT_CASE_UNIQUE,
					 MUTIL_CHK_PROP_NAME_NOT_CASE_UNIQUE_S,
					 tszMachine,
					 _T("Schema/Properties/Names"),
					 mdr.dwMDIdentifier);
				// Add it to pick up case sensitive collisions
				hr = CPropNameTable.Add(tszName);
				if (FAILED(hr)) {
					goto LError;
				}
			}
			else { 
				// Unique
				hr = CPropNameTable.Add(tszName);
				if (FAILED(hr)) {
					goto LError;
				}
			}
		}

		// Next data item
		iDataIndex++;
		mdr.dwMDIdentifier = 0;
		mdr.dwMDAttributes = METADATA_NO_ATTRIBUTES;
		mdr.dwMDUserType = ALL_METADATA;
		mdr.dwMDDataType = ALL_METADATA;
		mdr.dwMDDataLen = dwDataBufLen;
		mdr.pbMDData = (PBYTE) lpDataBuf;
		mdr.dwMDDataTag = 0;
		hr = m_pIMeta->EnumData(hMDMachine, 
								L"Schema/Properties/Names", 
							    &mdr, 
							    iDataIndex, 
							    &dwReqDataLen);
	}

	// Make sure we ran out of items
	if (HRESULT_CODE(hr) != ERROR_NO_MORE_ITEMS) {
		goto LError;
	}

	delete lpDataBuf;

	return S_OK;

LError:

	if (lpDataBuf != NULL) {
		delete lpDataBuf;
	}

	return hr;
}

/*===================================================================
CMetaUtil::CheckPropertyTypes

Private function to check the "Schema/Properties/Types" key of a 
given machine.
	o Make sure that each type entry is of type BINARY_METADATA
	o Make sure that the type data is valid
		o mdrDataRec.dwMDDataLen == sizeof(PropValue)
		o PropValue.dwMetaID != 0
		o PropValue.dwMetaType != ALL_METADATA
		o PropValue.dwUserGroup != ALL_METADATA
		o (PropValue.dwMetaFlags & METADATA_PARTIAL_PATH) != METADATA_PARTIAL_PATH
		o (PropValue.dwMetaFlags & METADATA_ISINHERITED) != METADATA_ISINHERITED

Directly Generates:
	MUTIL_CHK_PROP_TYPE_BAD_TYPE
	MUTIL_CHK_PROP_TYPE_BAD_DATA

Parameters:
	pCErrorCol	Pointer to the error collection to put errors in
	hMDMachine	Open metabase handle for the machine key
	tszMachine	Name of the machine key

Returns:
	E_OUTOFMEMORY if allocation fails.
	S_OK on success
===================================================================*/
HRESULT CMetaUtil::CheckPropertyTypes(CComObject<CCheckErrorCollection> *pCErrorCol, 
									  METADATA_HANDLE hMDMachine, 
									  LPTSTR tszMachine)
{
	ASSERT_POINTER(pCErrorCol, CComObject<CCheckErrorCollection>);
	ASSERT_STRING(tszMachine);

	USES_CONVERSION;
	HRESULT hr;
	int iDataIndex;
	METADATA_RECORD mdr;
	DWORD dwReqDataLen;
	DWORD dwDataBufLen;
	UCHAR *lpDataBuf = NULL;
	PropValue *pPropType;

	//Setup the return buffer
	dwDataBufLen = 256;
	lpDataBuf = new UCHAR[dwDataBufLen];
	if (lpDataBuf == NULL) {
		return E_OUTOFMEMORY;
	}

	// For Each Data Item
	iDataIndex = 0;
	mdr.dwMDIdentifier = 0;
	mdr.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    mdr.dwMDUserType = ALL_METADATA;
	mdr.dwMDDataType = ALL_METADATA;
	mdr.dwMDDataLen = dwDataBufLen;
	mdr.pbMDData = (PBYTE) lpDataBuf;
	mdr.dwMDDataTag = 0;
	hr = m_pIMeta->EnumData(hMDMachine, 
			                L"Schema/Properties/Types", 
						    &mdr, 
						    iDataIndex, 
						    &dwReqDataLen);
	while (SUCCEEDED(hr)) {

		// Datatype must be BINARY_METADATA
		if (mdr.dwMDDataType != BINARY_METADATA) {
			AddError(pCErrorCol,
					 MUTIL_CHK_PROP_TYPE_BAD_TYPE,
					 MUTIL_CHK_PROP_TYPE_BAD_TYPE_S,
					 tszMachine,
					 _T("Schema/Properties/Types"),
					 mdr.dwMDIdentifier);
		}
		else { // mdr.dwMDDataType == BINARY_METADATA

			// Validate the data
			pPropType = reinterpret_cast<PropValue *> (lpDataBuf);

			if ((mdr.dwMDDataLen != sizeof(PropValue)) || 
				(pPropType->dwMetaID == 0) ||
				(pPropType->dwMetaType == ALL_METADATA) ||
				(pPropType->dwUserGroup == ALL_METADATA) ||
				((pPropType->dwMetaFlags & METADATA_PARTIAL_PATH) == METADATA_PARTIAL_PATH) ||
				((pPropType->dwMetaFlags & METADATA_ISINHERITED) == METADATA_ISINHERITED)) {
				AddError(pCErrorCol,
					 MUTIL_CHK_PROP_TYPE_BAD_DATA,
					 MUTIL_CHK_PROP_TYPE_BAD_DATA_S,
					 tszMachine,
					 _T("Schema/Properties/Types"),
					 mdr.dwMDIdentifier);
			}

		}

		// Next data item
		iDataIndex++;
		mdr.dwMDIdentifier = 0;
		mdr.dwMDAttributes = METADATA_NO_ATTRIBUTES;
		mdr.dwMDUserType = ALL_METADATA;
		mdr.dwMDDataType = ALL_METADATA;
		mdr.dwMDDataLen = dwDataBufLen;
		mdr.pbMDData = (PBYTE) lpDataBuf;
		mdr.dwMDDataTag = 0;
		hr = m_pIMeta->EnumData(hMDMachine, 
								L"Schema/Properties/Types", 
							    &mdr, 
							    iDataIndex, 
							    &dwReqDataLen);
	}

	// Make sure we ran out of items
	if (HRESULT_CODE(hr) != ERROR_NO_MORE_ITEMS) {
		goto LError;
	}

	delete lpDataBuf;

	return S_OK;

LError:
	if (lpDataBuf != NULL) {
		delete lpDataBuf;
	}

	return hr;
}

/*===================================================================
CMetaUtil::CheckClasses

Private method to check the "Schema/Classes" key of a given machine.
	o Make sure that each class name is unique
	o Make sure that each class has a MANDATORY subkey
	o Make sure that each class has a OPTIONAL subkey
	o Make sure that each default property value is valid

Directly Generates:
	MUTIL_CHK_CLASS_NOT_CASE_UNIQUE
	MUTIL_CHK_CLASS_NO_MANDATORY
	MUTIL_CHK_CLASS_NO_OPTIONAL

Parameters:
	pCErrorCol	Pointer to the error collection to put errors in
	hMDMachine	Open metabase handle for the machine key
	tszMachine	Name of the machine key

Returns:
	E_OUTOFMEMORY if allocation fails.
	S_OK on success
===================================================================*/
HRESULT CMetaUtil::CheckClasses(CComObject<CCheckErrorCollection> *pCErrorCol, 
								METADATA_HANDLE hMDMachine, 
								LPTSTR tszMachine)
{
	ASSERT_POINTER(pCErrorCol, CComObject<CCheckErrorCollection>);
	ASSERT_STRING(tszMachine);

	USES_CONVERSION;
	HRESULT hr;
	int iKeyIndex;
	wchar_t wszSubKey[ADMINDATA_MAX_NAME_LEN];
	LPTSTR tszSubKey;
	CNameTable CClassNameTable;

	// For each Class key
	iKeyIndex = 0;
	hr = m_pIMeta->EnumKeys(hMDMachine, 
			                L"Schema/Classes", 
						    wszSubKey, 
						    iKeyIndex);
	while (SUCCEEDED(hr)) {
		tszSubKey = W2T(wszSubKey);

		// Build the full key
		TCHAR tszFullKey[ADMINDATA_MAX_NAME_LEN];
		_tcscpy(tszFullKey, _T("/Schema/Classes/"));
		_tcscat(tszFullKey, tszSubKey);

		// Class name is unique
		if (CClassNameTable.IsCaseInsenDup(tszSubKey)) { 
			// Case sensitive unique
			AddError(pCErrorCol,
					 MUTIL_CHK_CLASS_NOT_CASE_UNIQUE,
					 MUTIL_CHK_CLASS_NOT_CASE_UNIQUE_S,
					 tszFullKey,
					 NULL,
					 0);
		}
		else { 
			// Unique
			hr = CClassNameTable.Add(tszSubKey);
			if (FAILED(hr)) {
				goto LError;
			}
		}

		// Open the class key
		METADATA_HANDLE hMDClass = NULL;

		hr = m_pIMeta->OpenKey(METADATA_MASTER_ROOT_HANDLE,
						   T2W(tszFullKey),
						   METADATA_PERMISSION_READ,
					       MUTIL_OPEN_KEY_TIMEOUT,
						   &hMDClass);
		if (FAILED(hr)) {
			return ::ReportError(hr);
		}

		// Mandatory key exists
		if (!KeyExists(hMDClass, _T("Mandatory"))) {
			AddError(pCErrorCol,
					 MUTIL_CHK_CLASS_NO_MANDATORY,
					 MUTIL_CHK_CLASS_NO_MANDATORY_S,
					 tszFullKey,
					 NULL,
					 0);
		}
		else {
			// Make sure default mandatory settings make sense
			CheckClassProperties(pCErrorCol,
								 hMDClass,
								 tszFullKey,
								 _T("Mandatory"));
		}

		// Optional key exits
		if (!KeyExists(hMDClass, _T("Optional"))) {
			AddError(pCErrorCol,
					 MUTIL_CHK_CLASS_NO_OPTIONAL,
					 MUTIL_CHK_CLASS_NO_OPTIONAL_S,
					 tszFullKey,
					 NULL,
					 0);
		}
		else {
			// Make sure default optional settings make sense
			CheckClassProperties(pCErrorCol,
								 hMDClass,
								 tszFullKey,
								 _T("Optional"));
		}

		// Close the class key
		m_pIMeta->CloseKey(hMDClass);

		// Next key
		iKeyIndex++;
		hr = m_pIMeta->EnumKeys(hMDMachine, 
								L"Schema/Classes", 
								wszSubKey, 
								iKeyIndex);
	}

	// Make sure we ran out of items
	if (HRESULT_CODE(hr) != ERROR_NO_MORE_ITEMS) {
		goto LError;
	}

	return S_OK;

LError:

	return ::ReportError(hr);
}

/*===================================================================
CMetaUtil::CheckClassProperties

Private method to check the properties under 
"Schema/Classes/_Class_/Madatory" and "Schema/Classes/_Class_/Optional".

	o Make sure that the class property type is compatible with the
	  type under "Schema/Properties/Types"
		o DataType must match
		o UserType must match
		o Attributes must be a superset of the type attributes

Directly Generates:
	MUTIL_CHK_CLASS_PROP_BAD_TYPE

Parameters:
	pCErrorCol		Pointer to the error collection to put errors in
	hMDClassKey		Open metabase handle for the "Schema/Classes/_Class_" key
	tszClassKey		Full path of the "Schema/Classes/_Class_" key
	tszClassSubKey	Name of the specific class sub-key ("Mandatory"
					or "Optional")

Returns:
	E_OUTOFMEMORY if allocation fails.
	S_OK on success
===================================================================*/
HRESULT CMetaUtil::CheckClassProperties(CComObject<CCheckErrorCollection> *pCErrorCol, 
										METADATA_HANDLE hMDClassKey, 
										LPTSTR tszClassKey, 
										LPTSTR tszClassSubKey)
{
	ASSERT_POINTER(pCErrorCol, CComObject<CCheckErrorCollection>);
	ASSERT_STRING(tszClassKey);
	ASSERT_STRING(tszClassSubKey);

	USES_CONVERSION;
	HRESULT hr;
	int iDataIndex;
	METADATA_RECORD mdr;
	DWORD dwReqDataLen;
	DWORD dwDataBufLen;
	BYTE *lpDataBuf = NULL;

	// Setup the return buffer
	dwDataBufLen = 1024;
	lpDataBuf = new BYTE[dwDataBufLen];
	if (lpDataBuf == NULL) {
		return ::ReportError(E_OUTOFMEMORY);
	}

	// For each property
	iDataIndex = 0;
	mdr.dwMDIdentifier = 0;
	mdr.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    mdr.dwMDUserType = ALL_METADATA;
	mdr.dwMDDataType = ALL_METADATA;
	mdr.dwMDDataLen = dwDataBufLen;
	mdr.pbMDData = (PBYTE) lpDataBuf;
	mdr.dwMDDataTag = 0;
	hr = m_pIMeta->EnumData(hMDClassKey,
			                T2W(tszClassSubKey), 
						    &mdr,
						    iDataIndex, 
						    &dwReqDataLen);
	while (SUCCEEDED(hr) || (HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER)) {

		if (HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER) {
			delete lpDataBuf;
			dwDataBufLen = dwReqDataLen;
			lpDataBuf = new BYTE[dwDataBufLen];
			if (lpDataBuf == NULL) {
				return ::ReportError(E_OUTOFMEMORY);
			}
		
		}
		else {
			// Get the property information
			CPropInfo *pCPropInfo;
			PropValue *pTypeInfo;

			// Get the property info from the Schema Table
			pCPropInfo = m_pCSchemaTable->GetPropInfo(tszClassKey, mdr.dwMDIdentifier);

			if ((pCPropInfo == NULL) ||
				(pCPropInfo->GetTypeInfo() == NULL)) {

				// Error: no property type information for class property
				AddError(pCErrorCol,
						 MUTIL_CHK_CLASS_PROP_NO_TYPE,
						 MUTIL_CHK_CLASS_PROP_NO_TYPE_S,
						 tszClassKey,
						 tszClassSubKey,
						 mdr.dwMDIdentifier);
			}
			else {
				pTypeInfo = pCPropInfo->GetTypeInfo();

				// Validate the property defaults :
				//		DataType must match
				//		UserType must match
				//		Attributes must be a superset of the type attributes
				if (mdr.dwMDDataType != pTypeInfo->dwMetaType) {
					AddError(pCErrorCol,
							 MUTIL_CHK_CLASS_PROP_BAD_DATA_TYPE,
							 MUTIL_CHK_CLASS_PROP_BAD_DATA_TYPE_S,
							 tszClassKey,
							 tszClassSubKey,
							 mdr.dwMDIdentifier);
				}
				if (mdr.dwMDUserType != pTypeInfo->dwUserGroup) {
					AddError(pCErrorCol,
							 MUTIL_CHK_CLASS_PROP_BAD_USER_TYPE,
							 MUTIL_CHK_CLASS_PROP_BAD_USER_TYPE_S,
							 tszClassKey,
							 tszClassSubKey,
							 mdr.dwMDIdentifier);
				}
				if ((mdr.dwMDAttributes & pTypeInfo->dwMetaFlags) != pTypeInfo->dwMetaFlags) {
					AddError(pCErrorCol,
							 MUTIL_CHK_CLASS_PROP_BAD_ATTR,
							 MUTIL_CHK_CLASS_PROP_BAD_ATTR_S,
							 tszClassKey,
							 tszClassSubKey,
							 mdr.dwMDIdentifier);
				}		
			}

			// Next property
			iDataIndex++;
		}
		mdr.dwMDIdentifier = 0;
		mdr.dwMDAttributes = METADATA_NO_ATTRIBUTES;
		mdr.dwMDUserType = ALL_METADATA;
		mdr.dwMDDataType = ALL_METADATA;
		mdr.dwMDDataLen = dwDataBufLen;
		mdr.pbMDData = (PBYTE) lpDataBuf;
		mdr.dwMDDataTag = 0;
		hr = m_pIMeta->EnumData(hMDClassKey, 
								T2W(tszClassSubKey), 
								&mdr, 
								iDataIndex, 
								&dwReqDataLen);
	}

	// Make sure we ran out of items
	if (HRESULT_CODE(hr) != ERROR_NO_MORE_ITEMS) {
		delete lpDataBuf;
		return ::ReportError(hr);
	}

	delete lpDataBuf;
	return S_OK;
}

/*===================================================================
CMetaUtil::CheckKey

Check a given key for errors.

Directly Generates:
	MUTIL_CHK_DATA_TOO_BIG
	MUTIL_CHK_NO_NAME_ENTRY
	MUTIL_CHK_NO_TYPE_ENTRY
	MUTIL_CHK_BAD_TYPE
	MUTIL_CHK_CLSID_NOT_FOUND
	MUTIL_CHK_MTX_PACK_ID_NOT_FOUND
	MUTIL_CHK_KEY_TOO_BIG
	
Parameters:
    bstrKey		[in] Key to check
	ppIReturn	[out, retval] interface for the output error collection

Returns:
	E_OUTOFMEMORY if allocation fails.
	E_INVALIDARG if bstrKey == NULL or ppIReturn == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CMetaUtil::CheckKey(BSTR bstrKey, 
								 ICheckErrorCollection **ppIReturn)
{
	TRACE0("MetaUtil: CMetaUtil::CheckKey\n");

	ASSERT_NULL_OR_POINTER(bstrKey, OLECHAR);
	ASSERT_NULL_OR_POINTER(ppIReturn, ICheckErrorCollection *);

	if ((bstrKey == NULL) || (ppIReturn == NULL)) {
		return ::ReportError(E_INVALIDARG);
	}

	USES_CONVERSION;
	HRESULT hr;
	TCHAR tszKey[ADMINDATA_MAX_NAME_LEN];
	METADATA_HANDLE hMDKey = NULL;
	BYTE *lpDataBuf = NULL;
	DWORD dwKeySize = 0;

	_tcscpy(tszKey, OLE2T(bstrKey));
	CannonizeKey(tszKey);

	// Create the CheckErrorCollection
	CComObject<CCheckErrorCollection> *pCErrorCol = NULL;

	ATLTRY(pCErrorCol = new CComObject<CCheckErrorCollection>);
	if (pCErrorCol == NULL) {
		return ::ReportError(E_OUTOFMEMORY);
	}

	// If it's in the schema or IISAdmin, don't check
	if (::KeyIsInSchema(tszKey) || ::KeyIsInIISAdmin(tszKey)) {
		goto LDone;
	}

	// Open the key
	hr = m_pIMeta->OpenKey(METADATA_MASTER_ROOT_HANDLE,
						   T2W(tszKey),
						   METADATA_PERMISSION_READ,
					       MUTIL_OPEN_KEY_TIMEOUT,
						   &hMDKey);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}


	// TODO: Hard coded checks for expected subkeys

	int iDataIndex;
	METADATA_RECORD mdrDataRec;
	DWORD dwReqDataLen;
	DWORD dwDataBufLen;

	//Setup the return buffer
	dwDataBufLen = 1024;
	lpDataBuf = new BYTE[dwDataBufLen];
	if (lpDataBuf == NULL) {
		return ::ReportError(E_OUTOFMEMORY);
	}

	// For each property
	iDataIndex = 0;
	mdrDataRec.dwMDIdentifier = 0;
	mdrDataRec.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    mdrDataRec.dwMDUserType = ALL_METADATA;
	mdrDataRec.dwMDDataType = ALL_METADATA;
	mdrDataRec.dwMDDataLen = dwDataBufLen;
	mdrDataRec.pbMDData = (PBYTE) lpDataBuf;
	mdrDataRec.dwMDDataTag = 0;
	hr = m_pIMeta->EnumData(hMDKey,
			                NULL, 
						    &mdrDataRec, 
						    iDataIndex, 
						    &dwReqDataLen);
	while (SUCCEEDED(hr) || (HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER)) {
		if (HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER) {
			delete lpDataBuf;
			dwDataBufLen = dwReqDataLen;
			lpDataBuf = new BYTE[dwDataBufLen];
			if (lpDataBuf == NULL) {
				hr = E_OUTOFMEMORY;
				goto LError;
			}
			hr = S_OK; // Loop again
		}
		else {
			// Check property data size
			if (mdrDataRec.dwMDDataLen > m_dwMaxPropSize) {
				AddError(pCErrorCol,
						 MUTIL_CHK_DATA_TOO_BIG,
						 MUTIL_CHK_DATA_TOO_BIG_S,
						 tszKey,
						 NULL,
						 mdrDataRec.dwMDIdentifier);
			}

			// Add to the key size
			dwKeySize += mdrDataRec.dwMDDataLen;
	
			CPropInfo *pCPropInfo;
			PropValue *pTypeInfo;

			pCPropInfo = m_pCSchemaTable->GetPropInfo(tszKey, mdrDataRec.dwMDIdentifier);

			// Property should have a name entry
			if ((pCPropInfo == NULL) || (pCPropInfo->GetName() == NULL)) {
				AddError(pCErrorCol,
						 MUTIL_CHK_NO_NAME_ENTRY,
						 MUTIL_CHK_NO_NAME_ENTRY_S,
						 tszKey,
						 NULL,
						 mdrDataRec.dwMDIdentifier);
			}

			// Property should have a type entry
			if ((pCPropInfo == NULL) || (pCPropInfo->GetTypeInfo() == NULL)) {
				AddError(pCErrorCol,
						 MUTIL_CHK_NO_TYPE_ENTRY,
						 MUTIL_CHK_NO_TYPE_ENTRY_S,
						 tszKey,
						 NULL,
						 mdrDataRec.dwMDIdentifier);
			}
			else { 
				// Check property type
				//		DataType must match
				//		UserType must match
				//		Attributes must be a superset of the type attributes
				pTypeInfo = pCPropInfo->GetTypeInfo();

				if (mdrDataRec.dwMDDataType != pTypeInfo->dwMetaType) {
					AddError(pCErrorCol,
						 MUTIL_CHK_BAD_DATA_TYPE,
						 MUTIL_CHK_BAD_DATA_TYPE_S,
						 tszKey,
						 NULL,
						 mdrDataRec.dwMDIdentifier);
				}
				if (mdrDataRec.dwMDUserType != pTypeInfo->dwUserGroup) {
					AddError(pCErrorCol,
						 MUTIL_CHK_BAD_USER_TYPE,
						 MUTIL_CHK_BAD_USER_TYPE_S,
						 tszKey,
						 NULL,
						 mdrDataRec.dwMDIdentifier);
				}
				if ((mdrDataRec.dwMDAttributes & pTypeInfo->dwMetaFlags) != pTypeInfo->dwMetaFlags) {
					AddError(pCErrorCol,
						 MUTIL_CHK_BAD_ATTR,
						 MUTIL_CHK_BAD_ATTR_S,
						 tszKey,
						 NULL,
						 mdrDataRec.dwMDIdentifier);
				}
			}
			
			// Hard coded property checks (hard coded logic)
			if ((mdrDataRec.dwMDIdentifier == MD_APP_WAM_CLSID) ||
				(mdrDataRec.dwMDIdentifier == MD_LOG_PLUGIN_ORDER)) {

				// If property is a CLSID 
				if (!CheckCLSID(W2T(reinterpret_cast<LPWSTR> (lpDataBuf)))) {
					AddError(pCErrorCol,
						 MUTIL_CHK_CLSID_NOT_FOUND,
						 MUTIL_CHK_CLSID_NOT_FOUND_S,
						 tszKey,
						 NULL,
						 mdrDataRec.dwMDIdentifier);
				}
			}
			else if (mdrDataRec.dwMDIdentifier == MD_APP_PACKAGE_ID) {

				// Property is a Transaction Server package
				if (!CheckMTXPackage(W2T(reinterpret_cast<LPWSTR> (lpDataBuf)))) {
					AddError(pCErrorCol,
						 MUTIL_CHK_MTX_PACK_ID_NOT_FOUND,
						 MUTIL_CHK_MTX_PACK_ID_NOT_FOUND_S,
						 tszKey,
						 NULL,
						 mdrDataRec.dwMDIdentifier);
				}
			}
			else if ((mdrDataRec.dwMDIdentifier == MD_VR_PATH) ||
					 (mdrDataRec.dwMDIdentifier == MD_FILTER_IMAGE_PATH))  {

				// Property is a path
				BOOL fResult;
				hr = CheckIfFileExists(W2T(reinterpret_cast<LPWSTR> (lpDataBuf)), &fResult);
				if (SUCCEEDED(hr) && !fResult) {
					AddError(pCErrorCol,
						 MUTIL_CHK_PATH_NOT_FOUND,
						 MUTIL_CHK_PATH_NOT_FOUND_S,
						 tszKey,
						 NULL,
						 mdrDataRec.dwMDIdentifier);
				}
			}

			// Next property
			iDataIndex++;
		}
		mdrDataRec.dwMDIdentifier = 0;
		mdrDataRec.dwMDAttributes = METADATA_NO_ATTRIBUTES;
		mdrDataRec.dwMDUserType = ALL_METADATA;
		mdrDataRec.dwMDDataType = ALL_METADATA;
		mdrDataRec.dwMDDataLen = dwDataBufLen;
		mdrDataRec.pbMDData = (PBYTE) lpDataBuf;
		mdrDataRec.dwMDDataTag = 0;
		hr = m_pIMeta->EnumData(hMDKey, 
								NULL, 
								&mdrDataRec, 
								iDataIndex, 
								&dwReqDataLen);
	}
	// Make sure we ran out of items
	if (HRESULT_CODE(hr) != ERROR_NO_MORE_ITEMS) {
		goto LError;
	}

	// Check total size of key
	if (dwKeySize > m_dwMaxKeySize) {
		AddError(pCErrorCol,
				 MUTIL_CHK_KEY_TOO_BIG,
				 MUTIL_CHK_KEY_TOO_BIG_S,
				 tszKey,
				 NULL,
				 0);
	}

	// Check the KeyType property against schema class information
	hr = CheckKeyType(pCErrorCol, hMDKey, tszKey);
	if (FAILED(hr)) {
		goto LError;
	}

	delete lpDataBuf;

	// Close the key
	m_pIMeta->CloseKey(hMDKey);

LDone:

	// Set the interface to ICheckErrorCollection
	hr = pCErrorCol->QueryInterface(IID_ICheckErrorCollection, (void **) ppIReturn);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}
	ASSERT(*ppIReturn != NULL);

	return S_OK;

LError:

	if (pCErrorCol != NULL) {
		delete pCErrorCol;
	}
	if (hMDKey != NULL) {
		m_pIMeta->CloseKey(hMDKey);
	}
	if (lpDataBuf != NULL) {
		delete lpDataBuf;
	}

	return hr;
}

/*===================================================================
CMetaUtil::AddError

Add an error to a given error collection.  Uses the string table to
get the error description.

Parameters:
	pCErrorCol	Pointer to the error collection to put errors in
	lId			Identifing constant of the type of error
	lSeverity	Severity of the error
	tszKey		Base part of the key where the error occurred
	tszSubKey	NULL or second part of the key where the error occured
	dwProperty	Id of the property where the error occured or 0

Returns:
	E_OUTOFMEMORY if allocation fails.
	E_INVALIDARG if bstrMachine == NULL or ppIReturn == NULL
	S_OK on success

Notes:
	I split the key parameter into 2 parts, because of the nature of
	the metabase API's taking 2 part keys, often you are working
	with keys in 2 parts.  This takes the responsibility for combining
	them from the caller, simplifying the caller and eliminating
	redundancy.
===================================================================*/
void CMetaUtil::AddError(CComObject<CCheckErrorCollection> *pCErrorCol,
						 long lId, 
						 long lSeverity, 
						 LPCTSTR tszKey,
						 LPCTSTR tszSubKey,
						 DWORD dwProperty) 
{
	ASSERT_POINTER(pCErrorCol, CComObject<CCheckErrorCollection>);
	ASSERT_STRING(tszKey);
	ASSERT_NULL_OR_STRING(tszSubKey);

	long lNumErrors;

	pCErrorCol->get_Count(&lNumErrors);
	if (((DWORD) lNumErrors) == m_dwMaxNumErrors) {
		lId = MUTIL_CHK_TOO_MANY_ERRORS;
		lSeverity = MUTIL_CHK_TOO_MANY_ERRORS_S;
		tszKey = _T("");
		tszSubKey = NULL;
		dwProperty = 0;
	}
	else if (((DWORD) lNumErrors) > m_dwMaxNumErrors) {
		// Too many errors, bail
		return;
	}

	// Get the description
	TCHAR tszDescription[1024];
	LoadString(_Module.GetResourceInstance(), IDS_CHK_BASE + lId, tszDescription, 1024);

	// Build the full key
	TCHAR tszFullKey[ADMINDATA_MAX_NAME_LEN];

	if (tszSubKey == NULL) {
		_tcscpy(tszFullKey, tszKey);
	}
	else {
		_tcscpy(tszFullKey, tszKey);
		_tcscat(tszFullKey, _T("/"));
		_tcscat(tszFullKey, tszSubKey);
	}

	// Report the error
	pCErrorCol->AddError(lId, lSeverity, tszDescription, tszFullKey, dwProperty);
}

/*===================================================================
CMetaUtil::KeyExists

Private function to see if a given key exists.

Parameters:
    hMDKey		Open metabase read handle
	tszSubKey	Subkey to check relatetive to hMDKey

Returns:
	TRUE if the key exists.  A key is considered to exist if on
		an open call, it is opened or ERROR_PATH_BUSY or 
		ERROR_ACCESS_DENIED is returned.
	FALSE otherwise
===================================================================*/
BOOL CMetaUtil::KeyExists(METADATA_HANDLE hMDKey, LPTSTR tszSubKey) 
{
	ASSERT_NULL_OR_STRING(tszSubKey);

	//Attempt to open the key
	USES_CONVERSION;
	HRESULT hr;
	METADATA_HANDLE hMDSubKey;

	hr = m_pIMeta->OpenKey(hMDKey,
						   T2W(tszSubKey),
						   METADATA_PERMISSION_READ,
					       MUTIL_OPEN_KEY_TIMEOUT,
						   &hMDSubKey);
	if (FAILED(hr)) {
		// Why?
		if ((HRESULT_CODE(hr) == ERROR_PATH_BUSY) ||
			(HRESULT_CODE(hr) == ERROR_ACCESS_DENIED)) {
			// It exists, just can't get to it
			return TRUE;
		}
		else {
			// Assume that it doesn't exist
			return FALSE;
		}
	}
	else { // SUCCEEDED(hr)
		m_pIMeta->CloseKey(hMDSubKey);
		return TRUE;
	}
}

/*===================================================================
CMetaUtil::PropertyExists

Private function to see if a given property exists.

Parameters:
    hMDKey		Open metabase read handle
	tszSubKey	Subkey to check relatetive to hMDKey
	dwId		Id of the property to check

Returns:
	TRUE if the property exists.  A property is considered to exist if 
		on an GetData call, it is retrived or ERROR_INSUFFICENT_BUFFER 
		or ERROR_ACCESS_DENIED is returned.
	FALSE otherwise
===================================================================*/
BOOL CMetaUtil::PropertyExists(METADATA_HANDLE hMDKey, 
							   LPTSTR tszSubKey, 
							   DWORD dwId) 
{
	ASSERT_NULL_OR_STRING(tszSubKey);

	USES_CONVERSION;
	HRESULT hr;
	LPWSTR wszSubKey;
	METADATA_RECORD mdr;
	BYTE *lpDataBuf = NULL;
	DWORD dwDataBufLen;
	DWORD dwReqDataLen;

	if (tszSubKey == NULL) {
		wszSubKey = NULL;
	}
	else {
		wszSubKey = T2W(tszSubKey);
	}

	//Setup the return buffer
	dwDataBufLen = 256;
	lpDataBuf = new BYTE[dwDataBufLen];
	if (lpDataBuf == NULL) {
		return FALSE;
	}

	// See if there is a KeyType property  MD_KEY_TYPE
	mdr.dwMDIdentifier = dwId;
	mdr.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    mdr.dwMDUserType = ALL_METADATA;
	mdr.dwMDDataType = ALL_METADATA;
	mdr.dwMDDataLen = dwDataBufLen;
	mdr.pbMDData = (PBYTE) lpDataBuf;
	mdr.dwMDDataTag = 0;

	hr = m_pIMeta->GetData(hMDKey, wszSubKey, &mdr, &dwReqDataLen);

	delete lpDataBuf;

	if (SUCCEEDED(hr) || 
		(HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER) || 
		(HRESULT_CODE(hr) == ERROR_ACCESS_DENIED)) {
		return TRUE;
	}
	else {
		return FALSE;
	}
}

/*===================================================================
CMetaUtil::CheckCLSID

Private function to look up a CLSID in the local registry.

Parameters:
	tszCLSID	CLSID to check in string format.

Returns:
	TRUE if the CLSID is in the local registry
	FALSE otherwise
===================================================================*/
BOOL CMetaUtil::CheckCLSID(LPCTSTR tszCLSID) {
	ASSERT_STRING(tszCLSID);

	HKEY hCLSIDsKey;
	HKEY hCLSIDKey;
	LONG lRet;

	// Open HKEY_CLASSES_ROOT\CLSID
	lRet = RegOpenKeyEx(HKEY_CLASSES_ROOT,
					   _T("CLSID"),
					   0,
					   KEY_READ,
					   &hCLSIDsKey);
	if (lRet != ERROR_SUCCESS) {
		return FALSE;
	}

	// Open the specific CLSID
	lRet = RegOpenKeyEx(hCLSIDsKey,
					   tszCLSID,
					   0,
					   KEY_READ,
					   &hCLSIDKey);
	if (lRet != ERROR_SUCCESS) {
		RegCloseKey(hCLSIDsKey);
		return FALSE;
	}

	// Close the keys
	RegCloseKey(hCLSIDsKey);
	RegCloseKey(hCLSIDKey);

	return TRUE;
}

/*===================================================================
CMetaUtil::CheckMTXPackage

Private function to look up a Microsoft Transaction Server package 
identifier (GUID) in the local registry.

Parameters:
	tszPackId	MTX package identifier (GUID) in string format

Returns:
	TRUE if the package id is in the local registry
	FALSE otherwise
===================================================================*/
BOOL CMetaUtil::CheckMTXPackage(LPCTSTR tszPackId) {
	ASSERT_STRING(tszPackId);

	HKEY hMTSPackKey;
	HKEY hPackIdKey;
	LONG lRet;

	// Open HKEY_LOCAL_MACHINE\Software\Microsoft\Transaction Server\Packages
	lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
					   _T("Software\\Microsoft\\Transaction Server\\Packages"),
					   0,
					   KEY_READ,
					   &hMTSPackKey);
	if (lRet != ERROR_SUCCESS) {
		return FALSE;
	}

	// Open the specific package id
	lRet = RegOpenKeyEx(hMTSPackKey,
					   tszPackId,
					   0,
					   KEY_READ,
					   &hPackIdKey);
	if (lRet != ERROR_SUCCESS) {
		RegCloseKey(hMTSPackKey);
		return FALSE;
	}

	// Close the keys
	RegCloseKey(hMTSPackKey);
	RegCloseKey(hPackIdKey);

	return TRUE;
}

/*===================================================================
CMetaUtil::CheckKeyType

Private method to check class information on a non-schema key via
the KeyType property.

Directly Generates:
	MUTIL_CHK_NO_KEYTYPE
	MUTIL_CHK_NO_KEYTYPE_NOT_FOUND

Parameters:
	pCErrorCol	Pointer to the error collection to put errors in
	hMDKey		Open metabase handle for the key to check
	tszKey		Full path of the key to check

Returns:
	E_OUTOFMEMORY if allocation fails.
	S_OK on success
===================================================================*/
HRESULT CMetaUtil::CheckKeyType(CComObject<CCheckErrorCollection> *pCErrorCol, 
								METADATA_HANDLE hMDKey, 
								LPTSTR tszKey) 
{
	ASSERT_POINTER(pCErrorCol, CComObject<CCheckErrorCollection>);
	ASSERT_STRING(tszKey);

	USES_CONVERSION;
	HRESULT hr;
	METADATA_RECORD mdr;
	BYTE *lpDataBuf = NULL;
	DWORD dwDataBufLen;
	DWORD dwReqDataLen;

	//Setup the return buffer
	dwDataBufLen = 256;
	lpDataBuf = new BYTE[dwDataBufLen];
	if (lpDataBuf == NULL) {
		return ::ReportError(E_OUTOFMEMORY);
	}

	// See if there is a KeyType property  MD_KEY_TYPE
	mdr.dwMDIdentifier = MD_KEY_TYPE;
	mdr.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    mdr.dwMDUserType = ALL_METADATA;
	mdr.dwMDDataType = ALL_METADATA;
	mdr.dwMDDataLen = dwDataBufLen;
	mdr.pbMDData = (PBYTE) lpDataBuf;
	mdr.dwMDDataTag = 0;

	hr = m_pIMeta->GetData(hMDKey, NULL, &mdr, &dwReqDataLen);

	if (HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER) {
		// Try a bigger buffer
		delete lpDataBuf;
		dwDataBufLen = dwReqDataLen;
		lpDataBuf = new BYTE[dwDataBufLen];
		if (lpDataBuf == NULL) {
			hr = E_OUTOFMEMORY;
			goto LError;
		}

		mdr.dwMDIdentifier = MD_KEY_TYPE;
		mdr.dwMDAttributes = METADATA_NO_ATTRIBUTES;
		mdr.dwMDUserType = ALL_METADATA;
		mdr.dwMDDataType = ALL_METADATA;
		mdr.dwMDDataLen = dwDataBufLen;
		mdr.pbMDData = (PBYTE) lpDataBuf;
		mdr.dwMDDataTag = 0;

		hr = m_pIMeta->GetData(hMDKey, NULL, &mdr, &dwReqDataLen);
	}

	if (hr == MD_ERROR_DATA_NOT_FOUND) {
		// Error: KeyType property not found
		AddError(pCErrorCol,
				 MUTIL_CHK_NO_KEYTYPE,
				 MUTIL_CHK_NO_KEYTYPE_S,
				 tszKey,
				 NULL,
				 0);
		goto LDone;
	}
	else if (FAILED(hr)) {
		// Unexpected error
		goto LError;
	}
	else {  
		// KeyType property exists, get class information
		LPTSTR tszClassName;
		CClassInfo *pCClassInfo;
		
		tszClassName = W2T(reinterpret_cast<LPWSTR> (lpDataBuf));
		pCClassInfo = m_pCSchemaTable->GetClassInfo(tszKey, tszClassName);

		if (pCClassInfo == NULL) {
			// Error: KeyType does not map to a class
			AddError(pCErrorCol,
					 MUTIL_CHK_NO_KEYTYPE_NOT_FOUND,
					 MUTIL_CHK_NO_KEYTYPE_NOT_FOUND_S,
					 tszKey,
					 NULL,
					 MD_KEY_TYPE);
			goto LDone;
		}
		else { // KeyType maps to a class name
			// Check mandatory properties
			CClassPropInfo *pCMandatoryList;

			pCMandatoryList = m_pCSchemaTable->GetMandatoryClassPropList(tszKey, tszClassName);
			while (pCMandatoryList != NULL) {
				// Make sure the property exists
				if (!PropertyExists(hMDKey, NULL, pCMandatoryList->GetId())) {
					AddError(pCErrorCol,
							 MUTIL_CHK_MANDATORY_PROP_MISSING,
							 MUTIL_CHK_MANDATORY_PROP_MISSING_S,
							 tszKey,
							 NULL,
							 pCMandatoryList->GetId());
				}

				// Next mandatory list element
				pCMandatoryList = pCMandatoryList->GetListNext();
			}
		}
	}
	
LDone:

	delete lpDataBuf;

	return S_OK;

LError:
	if (lpDataBuf != NULL) {
		delete lpDataBuf;
	}

	return hr;
}

/*===================================================================
CMetaUtil::CheckIfFileExists

Private function to check if there is indeed a file or dir at the 
path indicated. 

Parameters:
tszFSPath   The filesystem path to check.
pfExists    Returns true if the file or dir at the path exists,
            false if it does not. Indeterminate in error cases.

Returns:
    S_OK on success.
    other HRESULTs from subroutines otherwise.
===================================================================*/
HRESULT CMetaUtil::CheckIfFileExists(LPCTSTR tszFSPath,
                                     BOOL *pfExists)
{
    ASSERT_STRING(tszFSPath);

    DWORD dwResult; 
    DWORD dwLastError;
    HRESULT hr = S_OK;

    dwResult = GetFileAttributes(tszFSPath);

    if (dwResult == 0xFFFFFFFF) {

        dwLastError = GetLastError();

        if ((dwLastError == ERROR_FILE_NOT_FOUND) || (dwLastError == ERROR_PATH_NOT_FOUND)) {

            // The file or dir doesn't exist
            *pfExists = FALSE;

        } else {

            // Some other error occurred (access denied, etc.)
            hr = HRESULT_FROM_WIN32(dwLastError);
            *pfExists = FALSE;      // Callers shouldn't be looking at this
        }
        
    } else {

        // The file or dir is there
        *pfExists = TRUE;
    }

    return hr;
}


/*------------------------------------------------------------------
 * C N a m e T a b l e E n t r y
 */


/*===================================================================
CNameTableEntry::Init

Constructor

Parameters:
    tszName		Name to add to the table

Returns:
	E_OUTOFMEMORY if allocation failed
	S_OK on success
===================================================================*/
HRESULT CNameTableEntry::Init(LPCTSTR tszName) 
{
	ASSERT_STRING(tszName);

	m_tszName = new TCHAR[_tcslen(tszName) + 1];
	if (m_tszName == NULL) {
		return E_OUTOFMEMORY;
	}
	_tcscpy(m_tszName, tszName);

	return S_OK;
}


/*------------------------------------------------------------------
 * C N a m e T a b l e
 */

/*===================================================================
CNameTable::CNameTable

Constructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CNameTable::CNameTable() 
{
	// Clear the hash table
	memset(m_rgpNameTable, 0, NAME_TABLE_HASH_SIZE * sizeof(CNameTableEntry *));
}

/*===================================================================
CNameTable::~CNameTable

Destructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CNameTable::~CNameTable()
{
	int iIndex;
	CNameTableEntry *pCDelete;

	// For each hash table entry
	for (iIndex =0; iIndex < NAME_TABLE_HASH_SIZE; iIndex++) {
		// While the entry is not empty
		while (m_rgpNameTable[iIndex] != NULL) {
			// Nuke the first table entry
			ASSERT_POINTER(m_rgpNameTable[iIndex], CNameTableEntry);
			pCDelete = m_rgpNameTable[iIndex];
			m_rgpNameTable[iIndex] = pCDelete->m_pCHashNext;
			delete pCDelete;
		}
	}
}

/*===================================================================
CNameTable::IsCaseSenDup

Checks for a name table entry with the same case sensitive name.

Parameters:
	tszName		Name to check for a duplicate entry

Returns:
	TRUE if a duplicate entry is found
	FALSE otherwise
===================================================================*/
BOOL CNameTable::IsCaseSenDup(LPCTSTR tszName) 
{
	ASSERT_STRING(tszName);

	int iPos;
	CNameTableEntry *pCLoop;

	iPos = Hash(tszName);
	pCLoop = m_rgpNameTable[iPos];
	while (pCLoop != NULL) {
		ASSERT_POINTER(pCLoop, CNameTableEntry);
		ASSERT_STRING(pCLoop->m_tszName);
		if (_tcscmp(tszName, pCLoop->m_tszName) == 0) {
			return TRUE;
		}
		pCLoop = pCLoop->m_pCHashNext;
	}

	return FALSE;
}

/*===================================================================
CNameTable::IsCaseInsenDup

Checks for a name table entry with the same case insensitive name.

Parameters:
	tszName		Name to check for a duplicate entry

Returns:
	TRUE if a duplicate entry is found
	FALSE otherwise
===================================================================*/
BOOL CNameTable::IsCaseInsenDup(LPCTSTR tszName) 
{
	ASSERT_STRING(tszName);

	int iPos;
	CNameTableEntry *pCLoop;

	iPos = Hash(tszName);
	pCLoop = m_rgpNameTable[iPos];
	while (pCLoop != NULL) {
		ASSERT_POINTER(pCLoop, CNameTableEntry);
		ASSERT_STRING(pCLoop->m_tszName);
		if (_tcsicmp(tszName, pCLoop->m_tszName) == 0) {
			return TRUE;
		}
		pCLoop = pCLoop->m_pCHashNext;
	}

	return FALSE;
}

/*===================================================================
CNameTable::Add

Adds an entry to the name table

Parameters:
	tszName		Name to add to table

Returns:
	E_OUTOFMEMORY on allocation failure
	S_OK on success
===================================================================*/
HRESULT CNameTable::Add(LPCTSTR tszName)
{
	ASSERT_STRING(tszName);

	// Create an entry
	HRESULT hr;
	CNameTableEntry *pCNew;

	pCNew = new CNameTableEntry;
	if (pCNew == NULL) {
		return E_OUTOFMEMORY;
	}
	hr = pCNew->Init(tszName);
	if (FAILED(hr)){
		delete pCNew;
		return hr;
	}

	// Add it to the table
	int iPos;

	iPos = Hash(tszName);
	pCNew->m_pCHashNext = m_rgpNameTable[iPos];
	m_rgpNameTable[iPos] = pCNew;

	return S_OK;
}

/*===================================================================
CNameTable::Hash

Private hash function for the name table.  The hash is case 
insensitive.

Parameters:
	tszName		Name to hash

Returns:
	Hash value for the input name.
===================================================================*/
int CNameTable::Hash(LPCTSTR tszName)
{
	ASSERT_STRING(tszName);

	unsigned int uiSum;
	unsigned int uiIndex;

	uiSum = 0;
	for (uiIndex=0; uiIndex < _tcslen(tszName); uiIndex++) {
		// Make CharUpper do single character conversions
		uiSum += _totlower(tszName[uiIndex]);
	}

	return (uiSum % NAME_TABLE_HASH_SIZE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\metautil\metaschm.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: MetaUtil object

File: MetaSchm.cpp

Owner: t-BrianM

This file contains implementation of the CMetaSchemaTable object and
other schema related objects.

The CMetaSchemaTable object has COM style reference counting so it 
can service objects created by CMetaUtil.  I didn't make it a full
blown COM object because all of the class stuff would be a pain to
export.

To reduce the overhead of maintaining this object (which may or
may not be used), all information is loaded on demand, then set
dirty or unloaded when portions of the metabase associated with it
are modified.
===================================================================*/

#include "stdafx.h"
#include "MetaUtil.h"
#include "MUtilObj.h"
#include "MetaSchm.h"

/*------------------------------------------------------------------
 * C P r o p I n f o
 */

/*===================================================================
CPropInfo::Init

Constructor

Parameters:
	dwId		Id of property

Returns:
	S_OK on success
===================================================================*/
HRESULT CPropInfo::Init(DWORD dwId) 
{
	m_dwId = dwId;

	return S_OK;
}

/*===================================================================
CPropInfo::SetName

Sets the property name.

Parameters:
	tszName		Name of property

Returns:
	E_OUTOFMEMORY if allocation fails
	S_OK on success
===================================================================*/
HRESULT CPropInfo::SetName(LPCTSTR tszName) 
{
	ASSERT_STRING(tszName);
	ASSERT(m_tszName == NULL); // m_tszName not yet set

	m_tszName = new TCHAR[_tcslen(tszName) + 1];
	if (m_tszName == NULL) {
		return E_OUTOFMEMORY;
	}
	_tcscpy(m_tszName, tszName);

	return S_OK;
}

/*===================================================================
CPropInfo::SetTypeInfo

Sets the property name.

Parameters:
	pType	PropValue structure containing type information.

Returns:
	E_OUTOFMEMORY if allocation fails
	S_OK on success
===================================================================*/
HRESULT CPropInfo::SetTypeInfo(PropValue *pType)
{
	ASSERT_POINTER(pType, PropValue);
	ASSERT(m_pType == NULL); // m_pType not yet set

	m_pType = new PropValue;
	if (m_pType == NULL) {
		return E_OUTOFMEMORY;
	}
	memcpy(m_pType, pType, sizeof(PropValue));

	return S_OK;
}


/*------------------------------------------------------------------
 * C P r o p I n f o T a b l e
 */

/*===================================================================
CPropInfoTable::CPropInfoTable

Constructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CPropInfoTable::CPropInfoTable() : m_fLoaded(FALSE)
{
	// Clear the hash tables
	memset(m_rgCPropIdTable, 0, PROPERTY_HASH_SIZE * sizeof(CPropInfo *));
	memset(m_rgCPropNameTable, 0, PROPERTY_HASH_SIZE * sizeof(CPropInfo *));
}

/*===================================================================
CPropInfoTable::~CPropInfoTable

Destructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CPropInfoTable::~CPropInfoTable() 
{
	if (m_fLoaded) {
		Unload();
	}
}

/*===================================================================
CPropInfoTable::Load

Loads properties from the "_Machine_/Schema/Properties" key into the
property information table.  On failure, recovers by unloading 
everything.

Parameters:
	pIMeta		ATL Smart pointer to the metabase
	hMDComp		Open metabase handle to "_Machine_" key

Returns:
	E_OUTOFMEMORY on allocation failure
	S_OK on success
===================================================================*/
HRESULT CPropInfoTable::Load(CComPtr<IMSAdminBase> &pIMeta, 
							 METADATA_HANDLE hMDComp) 
{
	//If it's already loaded, unload then reload
	if (m_fLoaded) {
		Unload();
	}

	USES_CONVERSION;
	HRESULT hr;
	int iDataIndex;
	METADATA_RECORD mdrDataRec;
	DWORD dwReqDataLen;
	DWORD dwReturnBufLen;
	UCHAR *lpReturnBuf = NULL;
	unsigned int uiLoc;
	CPropInfo *pCNewProp;
	METADATA_HANDLE hMDNames = NULL;
	METADATA_HANDLE hMDTypes = NULL;

	//Setup the return buffer
	dwReturnBufLen = 1024;
	lpReturnBuf = new UCHAR[dwReturnBufLen];
	if (lpReturnBuf == NULL)
		return E_OUTOFMEMORY;	

	// Open the Schema/Properties/Names subkey
	hr = pIMeta->OpenKey(hMDComp, 
			             L"Schema/Properties/Names", 
						 METADATA_PERMISSION_READ, 
					     MUTIL_OPEN_KEY_TIMEOUT,
					     &hMDNames);
	if (FAILED(hr)) {
		delete lpReturnBuf;
		return hr;
	};

	// For each name	
	iDataIndex = 0;
	mdrDataRec.dwMDIdentifier = 0;
	mdrDataRec.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    mdrDataRec.dwMDUserType = ALL_METADATA;
	mdrDataRec.dwMDDataType = ALL_METADATA;
	mdrDataRec.dwMDDataLen = dwReturnBufLen;
	mdrDataRec.pbMDData = (PBYTE) lpReturnBuf;
	mdrDataRec.dwMDDataTag = 0;
	hr = pIMeta->EnumData(hMDNames, 
						  NULL, 
						  &mdrDataRec, 
						  iDataIndex, 
						  &dwReqDataLen);
	while (SUCCEEDED(hr)) {

		// Make sure we got a string
		if (mdrDataRec.dwMDDataType != STRING_METADATA) {
			hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
			goto LError;
		}

		// Create the property object
		pCNewProp = new CPropInfo;
		if (pCNewProp == NULL) {
			hr = E_OUTOFMEMORY;
			goto LError;
		}
		hr = pCNewProp->Init(mdrDataRec.dwMDIdentifier); 
		if (FAILED(hr)) {
			delete pCNewProp;
			goto LError;
		}
		hr = pCNewProp->SetName(W2T(reinterpret_cast<LPWSTR> (lpReturnBuf))); 
		if (FAILED(hr)) {
			delete pCNewProp;
			goto LError;
		}

		// Add it to the Id hash table
		uiLoc = IdHash(mdrDataRec.dwMDIdentifier);
		pCNewProp->m_pCIdHashNext = m_rgCPropIdTable[uiLoc];
		m_rgCPropIdTable[uiLoc] = pCNewProp;

		// Add it to the Name hash table
		uiLoc = NameHash(pCNewProp->m_tszName);
		pCNewProp->m_pCNameHashNext = m_rgCPropNameTable[uiLoc];
		m_rgCPropNameTable[uiLoc] = pCNewProp;

		iDataIndex++;
		mdrDataRec.dwMDIdentifier = 0;
		mdrDataRec.dwMDAttributes = METADATA_NO_ATTRIBUTES;
		mdrDataRec.dwMDUserType = ALL_METADATA;
		mdrDataRec.dwMDDataType = ALL_METADATA;
		mdrDataRec.dwMDDataLen = dwReturnBufLen;
		mdrDataRec.pbMDData = (PBYTE) lpReturnBuf;
		mdrDataRec.dwMDDataTag = 0;
		hr = pIMeta->EnumData(hMDNames, 
							  NULL, 
							  &mdrDataRec, 
							  iDataIndex, 
							  &dwReqDataLen);
	}

	// Make sure we ran out of items
	if (HRESULT_CODE(hr) != ERROR_NO_MORE_ITEMS) {
		goto LError;
	}

	// Close the Schema/Properties/Names sub-key
	pIMeta->CloseKey(hMDNames);
	hMDNames = NULL;


	// Open the Schema/Properties/Types sub-key
	hr = pIMeta->OpenKey(hMDComp, 
			             L"Schema/Properties/Types", 
						 METADATA_PERMISSION_READ, 
					     MUTIL_OPEN_KEY_TIMEOUT,
					     &hMDTypes);
	if (FAILED(hr)) {
		goto LError;
	};

	// For each type
	iDataIndex = 0;
	mdrDataRec.dwMDIdentifier = 0;
	mdrDataRec.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    mdrDataRec.dwMDUserType = ALL_METADATA;
	mdrDataRec.dwMDDataType = ALL_METADATA;
	mdrDataRec.dwMDDataLen = dwReturnBufLen;
	mdrDataRec.pbMDData = (PBYTE) lpReturnBuf;
	mdrDataRec.dwMDDataTag = 0;
	hr = pIMeta->EnumData(hMDTypes, 
						  NULL, 
						  &mdrDataRec, 
						  iDataIndex, 
						  &dwReqDataLen);
	while (SUCCEEDED(hr)) {

		// Make sure we got binary data
		if (mdrDataRec.dwMDDataType != BINARY_METADATA) {
			hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
			goto LError;
		}

		// Look for an existing property object for this Id
		pCNewProp = GetPropInfo(mdrDataRec.dwMDIdentifier);
		if (pCNewProp == NULL) {
			// Create the property object
			pCNewProp = new CPropInfo;
			if (pCNewProp == NULL) {
				hr = E_OUTOFMEMORY;
				goto LError;
			}
			hr = pCNewProp->Init(mdrDataRec.dwMDIdentifier);
			if (FAILED(hr)) {
				delete pCNewProp;
				goto LError;
			}

			// Add it to the Id hash table
			uiLoc = IdHash(mdrDataRec.dwMDIdentifier);
			pCNewProp->m_pCIdHashNext = m_rgCPropIdTable[uiLoc];
			m_rgCPropIdTable[uiLoc] = pCNewProp;
		}

		// Add type information to the property object
		pCNewProp->SetTypeInfo(reinterpret_cast<PropValue *> (lpReturnBuf));

		iDataIndex++;
		mdrDataRec.dwMDIdentifier = 0;
		mdrDataRec.dwMDAttributes = METADATA_NO_ATTRIBUTES;
		mdrDataRec.dwMDUserType = ALL_METADATA;
		mdrDataRec.dwMDDataType = ALL_METADATA;
		mdrDataRec.dwMDDataLen = dwReturnBufLen;
		mdrDataRec.pbMDData = (PBYTE) lpReturnBuf;
		mdrDataRec.dwMDDataTag = 0;
		hr = pIMeta->EnumData(hMDTypes, 
							  NULL, 
							  &mdrDataRec, 
							  iDataIndex, 
							  &dwReqDataLen);
	}

	// Make sure we ran out of items
	if (HRESULT_CODE(hr) != ERROR_NO_MORE_ITEMS) {
		goto LError;
	}

	// Close the Schema/Properties/Types sub-key
	pIMeta->CloseKey(hMDTypes);
	hMDTypes = NULL;

	delete lpReturnBuf;

	m_fLoaded = TRUE;

	return S_OK;

LError:
	if (hMDNames != NULL) {
		pIMeta->CloseKey(hMDNames);
	}
	if (hMDTypes != NULL) {
		pIMeta->CloseKey(hMDTypes);
	}

	if (lpReturnBuf != NULL) {
		delete lpReturnBuf;
	}

	// Cleanup the entries we loaded
	Unload();

	return hr;
}

/*===================================================================
CPropInfoTable::Unload

Unloads the property information table.

Parameters:
	None

Returns:
	Nothing
===================================================================*/
void CPropInfoTable::Unload() 
{
	int iIndex;
	CPropInfo *pCDeleteProp;

	//Clear the Name table
	memset(m_rgCPropNameTable, 0, PROPERTY_HASH_SIZE * sizeof(CPropInfo *));

	// For each Id hash table entry
	for (iIndex =0; iIndex < PROPERTY_HASH_SIZE; iIndex++) {
		// While the entry is not empty
		while (m_rgCPropIdTable[iIndex] != NULL) {
			// Nuke the first table entry
			pCDeleteProp = m_rgCPropIdTable[iIndex];
			m_rgCPropIdTable[iIndex] = pCDeleteProp->m_pCIdHashNext;
			delete pCDeleteProp;
		}
	}

	m_fLoaded = FALSE;
}

/*===================================================================
CPropInfoTable::GetPropInfo

Gets property information from the table based on property id

Parameters:
	dwId	Id of property to get

Returns:
	NULL if property not found or error
	Pointer to CPropInfo class on success
===================================================================*/
CPropInfo *CPropInfoTable::GetPropInfo(DWORD dwId) 
{
	CPropInfo *pCCurProp;

	// Go to the table location
	pCCurProp = m_rgCPropIdTable[IdHash(dwId)];

	// Look at all of the entries
	while ((pCCurProp != NULL) && (pCCurProp->m_dwId != dwId)) {
		pCCurProp = pCCurProp->m_pCIdHashNext;
	}

	return pCCurProp; // Will be NULL if not found
}

/*===================================================================
CPropInfoTable::GetPropInfo

Gets property information from the table based on property name.
Case insensitive.

Parameters:
	tszName		Name of property to get

Returns:
	NULL if property not found or error
	Pointer to CPropInfo class on success
===================================================================*/
CPropInfo *CPropInfoTable::GetPropInfo(LPCTSTR tszName) 
{
	CPropInfo *pCCurProp;

	// Go to the table location
	pCCurProp = m_rgCPropNameTable[NameHash(tszName)];

	// Look at all of the entries
	while ((pCCurProp != NULL) && 
		   (_tcsicmp(pCCurProp->m_tszName, tszName) != 0)) {
		pCCurProp = pCCurProp->m_pCNameHashNext;
	}

	return pCCurProp; // Will be NULL if not found
}

/*===================================================================
CPropInfoTable::NameHash

Private function to get a hash value from a property name for the
name table.  Case insensitive.

Parameters:
	tszName		Name to hash

Returns:
	Hash value of name
===================================================================*/
unsigned int CPropInfoTable::NameHash(LPCTSTR tszName) 
{
	ASSERT_STRING(tszName);

	unsigned int uiSum;
	unsigned int uiIndex;

	uiSum = 0;
	for (uiIndex=0; uiIndex < _tcslen(tszName); uiIndex++) {
		uiSum += _totlower(tszName[uiIndex]);
	}

	return (uiSum % PROPERTY_HASH_SIZE);
}

/*------------------------------------------------------------------
 * C C l a s s P r o p I n f o
 */

// Everything is inline

/*------------------------------------------------------------------
 * C C l a s s I n f o
 */

/*===================================================================
CClassInfo::CClassInfo

Constructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CClassInfo::CClassInfo() : m_tszName(NULL),
						   m_pCHashNext(NULL),
						   m_fLoaded(FALSE),
						   m_pCOptionalPropList(NULL),
						   m_pCMandatoryPropList(NULL)
{
	// Clear the hash table
	memset(m_rgCPropTable, 0, CLASS_PROPERTY_HASH_SIZE * sizeof(CClassPropInfo *));
}

/*===================================================================
CClassInfo::Init

Constructor

Parameters:
	tszName		Name of the class

Returns:
	E_OUTOFMEMORY on allocation failure
	S_OK on success
===================================================================*/
HRESULT CClassInfo::Init(LPCTSTR tszName) 
{
	ASSERT_STRING(tszName);

	m_tszName = new TCHAR[_tcslen(tszName) + 1];
	if (m_tszName == NULL) {
		return E_OUTOFMEMORY;
	}
	_tcscpy(m_tszName, tszName);

	return S_OK;
}

/*===================================================================
CClassInfo::~CClassInfo

Destructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CClassInfo::~CClassInfo() 
{
	Unload();

	if (m_tszName != NULL) {
		delete m_tszName;
	}
}

/*===================================================================
CClassInfo::Load

Loads class properties from the "_Machine_/Schema/Classes/_Class_/Mandatory"
and "_Machine_/Schema/Classes/_Class_/Optional" keys into the class 
property information table, mandatory list and optional list.  On 
failure, recovers by unloading everything.

Parameters:
	pIMeta		ATL Smart pointer to the metabase
	hMDClasses	Open metabase handle to "_Machine_/Schema/Classes" key

Returns:
	E_OUTOFMEMORY on allocation failure
	S_OK on success
===================================================================*/
HRESULT CClassInfo::Load(CComPtr<IMSAdminBase> &pIMeta, 
						 METADATA_HANDLE hMDClasses)
{
	USES_CONVERSION;
	HRESULT hr;

	//If it's already loaded, unload then reload
	if (m_fLoaded) {
		Unload();
	}

	// Open the class key
	METADATA_HANDLE hMDClass = NULL;
	hr = pIMeta->OpenKey(hMDClasses, 
			             T2W(m_tszName),
						 METADATA_PERMISSION_READ, 
					     1000,
					     &hMDClass);
	if (FAILED(hr)) {
		return hr;
	}

	// Load the class properties
	METADATA_HANDLE hMDClassProp = NULL;
	int iDataIndex;
	METADATA_RECORD mdr;
	DWORD dwReqDataLen;
	DWORD dwReturnBufLen;
	UCHAR *lpReturnBuf = NULL;
	unsigned int uiLoc;
	CClassPropInfo *pCNewClassProp;

	//Setup the return buffer
	dwReturnBufLen = 1024;
	lpReturnBuf = new UCHAR[dwReturnBufLen];
	if (lpReturnBuf == NULL) {
		hr = E_OUTOFMEMORY;
		goto LError;
	}


	// Load the mandatory class properties
	// Open the Mandatory key
	hr = pIMeta->OpenKey(hMDClass, 
			             L"Mandatory", 
						 METADATA_PERMISSION_READ, 
					     1000,
					     &hMDClassProp);
	if (FAILED(hr)) {
		goto LError;
	}

	// For each Mandatory property	
	iDataIndex = 0;
	mdr.dwMDIdentifier = 0;
	mdr.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    mdr.dwMDUserType = ALL_METADATA;
	mdr.dwMDDataType = ALL_METADATA;
	mdr.dwMDDataLen = dwReturnBufLen;
	mdr.pbMDData = (PBYTE) lpReturnBuf;
	mdr.dwMDDataTag = 0;
	hr = pIMeta->EnumData(hMDClassProp, 
						  NULL, 
						  &mdr, 
						  iDataIndex, 
						  &dwReqDataLen);
	while (SUCCEEDED(hr)|| (HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER)) {

		// Handle insufficent buffer errors
		if ((HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER)) {
			// Allocate more memory
			delete lpReturnBuf;
			dwReturnBufLen = dwReqDataLen;
			lpReturnBuf = new UCHAR[dwReturnBufLen];
			if (lpReturnBuf == NULL) {
				hr = E_OUTOFMEMORY;
				goto LError;
			}
			// Loop again
			hr = S_OK;
		}
		else { //Buffer is big enough, proceed to add the class property
			// Create the Class Property object
			pCNewClassProp = new CClassPropInfo;
			if (pCNewClassProp == NULL) {
				hr = E_OUTOFMEMORY;
				goto LError;
			}
			hr = pCNewClassProp->Init(mdr.dwMDIdentifier, TRUE);
			if (FAILED(hr)) {
				delete pCNewClassProp;
				goto LError;
			}

			//Add it to the mandatory list
			pCNewClassProp->m_pCListNext = m_pCMandatoryPropList;
			m_pCMandatoryPropList = pCNewClassProp;
		
			//Add it to the hash table
			uiLoc = Hash(mdr.dwMDIdentifier);
			pCNewClassProp->m_pCHashNext = m_rgCPropTable[uiLoc];
			m_rgCPropTable[uiLoc] = pCNewClassProp;

			iDataIndex++;
		}

		mdr.dwMDIdentifier = 0;
		mdr.dwMDAttributes = METADATA_NO_ATTRIBUTES;
		mdr.dwMDUserType = ALL_METADATA;
		mdr.dwMDDataType = ALL_METADATA;
		mdr.dwMDDataLen = dwReturnBufLen;
		mdr.pbMDData = (PBYTE) lpReturnBuf;
		mdr.dwMDDataTag = 0;
		hr = pIMeta->EnumData(hMDClassProp, 
							  NULL, 
							  &mdr, 
							  iDataIndex, 
							  &dwReqDataLen);
	}
	
	// Make sure we ran out of items
	if (HRESULT_CODE(hr) != ERROR_NO_MORE_ITEMS) {
		goto LError;
	}

	// Close the Mandatory key
	pIMeta->CloseKey(hMDClassProp);
	hMDClassProp = NULL;
	

	// Load the optional class properties
	// Open the Optional key
	hr = pIMeta->OpenKey(hMDClass, 
			             L"Optional", 
						 METADATA_PERMISSION_READ, 
					     1000,
					     &hMDClassProp);
	if (FAILED(hr)) {
		goto LError;
	}

	// For each Optional property
	iDataIndex = 0;
	mdr.dwMDIdentifier = 0;
	mdr.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    mdr.dwMDUserType = ALL_METADATA;
	mdr.dwMDDataType = ALL_METADATA;
	mdr.dwMDDataLen = dwReturnBufLen;
	mdr.pbMDData = (PBYTE) lpReturnBuf;
	mdr.dwMDDataTag = 0;
	hr = pIMeta->EnumData(hMDClassProp, 
						  NULL, 
						  &mdr, 
						  iDataIndex, 
						  &dwReqDataLen);
	while (SUCCEEDED(hr)|| (HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER)) {

		// Handle insufficent buffer errors
		if ((HRESULT_CODE(hr) == ERROR_INSUFFICIENT_BUFFER)) {
			// Allocate more memory
			delete lpReturnBuf;
			dwReturnBufLen = dwReqDataLen;
			lpReturnBuf = new UCHAR[dwReturnBufLen];
			if (lpReturnBuf == NULL) {
				hr = E_OUTOFMEMORY;
				goto LError;
			}

			// Loop again
			hr = S_OK;
		}
		else { //Buffer is big enough, proceed to add the class property
			// Create the Class Property object
			pCNewClassProp = new CClassPropInfo;
			if (pCNewClassProp == NULL) {
				hr = E_OUTOFMEMORY;
				goto LError;
				}
			hr = pCNewClassProp->Init(mdr.dwMDIdentifier, FALSE);
			if (FAILED(hr)) {
				delete pCNewClassProp;
				goto LError;
			}

			//Add it to the optional list
			pCNewClassProp->m_pCListNext = m_pCOptionalPropList;
			m_pCOptionalPropList = pCNewClassProp;
			
		
			//Add it to the hash table
			uiLoc = Hash(mdr.dwMDIdentifier);
			pCNewClassProp->m_pCHashNext = m_rgCPropTable[uiLoc];
			m_rgCPropTable[uiLoc] = pCNewClassProp;

			iDataIndex++;
		}

		mdr.dwMDIdentifier = 0;
		mdr.dwMDAttributes = METADATA_NO_ATTRIBUTES;
		mdr.dwMDUserType = ALL_METADATA;
		mdr.dwMDDataType = ALL_METADATA;
		mdr.dwMDDataLen = dwReturnBufLen;
		mdr.pbMDData = (PBYTE) lpReturnBuf;
		mdr.dwMDDataTag = 0;
		hr = pIMeta->EnumData(hMDClassProp, 
							  NULL, 
							  &mdr, 
							  iDataIndex, 
							  &dwReqDataLen);
	}

	// Make sure we ran out of items
	if (HRESULT_CODE(hr) != ERROR_NO_MORE_ITEMS) {
		goto LError;
	}

	// Close the Optional key
	pIMeta->CloseKey(hMDClassProp);

	delete lpReturnBuf;
	
	// Close the Class key
	pIMeta->CloseKey(hMDClass);

	m_fLoaded = TRUE;

	return S_OK;

//Error durring loading, back out
LError:
	if (hMDClassProp != NULL) {
		pIMeta->CloseKey(hMDClassProp);
	}
	if (hMDClass != NULL) {
		pIMeta->CloseKey(hMDClass);
	}

	if (lpReturnBuf != NULL) {
		delete lpReturnBuf;
	}

	Unload();

	return hr;
}

/*===================================================================
CClassInfo::Unload

Unloads the class property information table.

Parameters:
	None

Returns:
	Nothing
===================================================================*/
void CClassInfo::Unload() 
{
	int iIndex;
	CClassPropInfo *pCDeleteProp;

	// Clear the lists
	m_pCOptionalPropList = NULL;
	m_pCMandatoryPropList = NULL;

	// For each hash table entry
	for (iIndex =0; iIndex < CLASS_PROPERTY_HASH_SIZE; iIndex++) {
		// While the entry is not empty
		while (m_rgCPropTable[iIndex] != NULL) {
			// Nuke the first table entry
			pCDeleteProp = m_rgCPropTable[iIndex];
			m_rgCPropTable[iIndex] = pCDeleteProp->m_pCHashNext;
			delete pCDeleteProp;
		}
	}

	m_fLoaded = FALSE;
}

/*===================================================================
CClassInfo::GetProperty

Get the CClassPropInfo (class property info) object from the hash 
table given the property id.

Parameters:
	dwId	Identifier of the property to get

Returns:
	NULL on failure
	Pointer to the CClassPropInfo object on success
===================================================================*/
CClassPropInfo *CClassInfo::GetProperty(DWORD dwId) {
	CClassPropInfo *pCCurProp;

	// Go to the table location
	pCCurProp = m_rgCPropTable[Hash(dwId)];

	// Look at all of the entries
	while ((pCCurProp != NULL) && (pCCurProp->m_dwId != dwId)) {
		pCCurProp = pCCurProp->m_pCHashNext;
	}

	return pCCurProp; // Will be NULL if not found
}


/*------------------------------------------------------------------
 * C C l a s s I n f o T a b l e
 */

/*===================================================================
CClassInfoTable::CClassInfoTable

Constructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CClassInfoTable::CClassInfoTable() : m_fLoaded(FALSE) 
{
	// Clear the hash table
	memset(m_rgCClassTable, 0, CLASS_HASH_SIZE * sizeof(CClassInfo *));
}

/*===================================================================
CClassInfoTable::~CClassInfoTable

Destructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CClassInfoTable::~CClassInfoTable() 
{
	if (m_fLoaded) {
		Unload();
	}
}

/*===================================================================
CClassInfoTable::Load

Loads classes from the "_Machine_/Schema/Classes" key into the class 
information table.  On failure, recovers by unloading everything.

Parameters:
	pIMeta		ATL Smart pointer to the metabase
	hMDComp		Open metabase handle to "_Machine_" key

Returns:
	E_OUTOFMEMORY on allocation failure
	S_OK on success
===================================================================*/
HRESULT CClassInfoTable::Load(CComPtr<IMSAdminBase> &pIMeta, 
							  METADATA_HANDLE hMDComp) 
{
	ASSERT(pIMeta.p != NULL);

	USES_CONVERSION;
	HRESULT hr;

	//If it's already loaded, unload then reload
	if (m_fLoaded) {
		Unload();
	}
	
	int iKeyIndex;
	wchar_t wszSubKey[ADMINDATA_MAX_NAME_LEN];
	LPTSTR tszSubKey;
	int iLoc;
	CClassInfo *pCNewClass;

	//Load the classes
	METADATA_HANDLE hMDClasses = NULL;

	// Open the Schema/Classes subkey
	hr = pIMeta->OpenKey(hMDComp, 
			             L"Schema/Classes", 
						 METADATA_PERMISSION_READ, 
					     1000,
					     &hMDClasses);
	if (FAILED(hr)) {
		return hr;
	};

	// For each subkey
	iKeyIndex = 0;
	hr = pIMeta->EnumKeys(hMDClasses, 
						  NULL, 
						  wszSubKey, 
						  iKeyIndex);
	while (SUCCEEDED(hr)) {
		tszSubKey = W2T(wszSubKey);

		// Create the new class	
		pCNewClass = new CClassInfo;
		if (pCNewClass == NULL) {
			hr = E_OUTOFMEMORY;
			goto LError;
		}
		hr = pCNewClass->Init(tszSubKey); 
		if (FAILED(hr)) {
			delete pCNewClass;
			goto LError;
		}

		// Load the class properties
		hr = pCNewClass->Load(pIMeta, hMDClasses);
		if (FAILED(hr)) {
			delete pCNewClass;
			goto LError;
		}

		// Add it to the hash table
		iLoc = Hash(tszSubKey);
		pCNewClass->m_pCHashNext = m_rgCClassTable[iLoc];
		m_rgCClassTable[iLoc] = pCNewClass;

		iKeyIndex++;
		hr = pIMeta->EnumKeys(hMDClasses, 
							  NULL, 
							  wszSubKey, 
							  iKeyIndex);
	}

	//Make sure we ran out of items
	if (!(HRESULT_CODE(hr) == ERROR_NO_MORE_ITEMS)) {
		goto LError;
	}

	// Close the schema properties key
	pIMeta->CloseKey(hMDClasses);

	m_fLoaded = TRUE;

	return S_OK;

LError:
	if (hMDClasses != NULL) {
		pIMeta->CloseKey(hMDClasses);
	}

	// Cleanup the entries we loaded
	Unload();

	return hr;
}

/*===================================================================
CClassInfo::Unload

Unloads the class information table.

Parameters:
	None

Returns:
	Nothing
===================================================================*/
void CClassInfoTable::Unload() 
{
	int iIndex;
	CClassInfo *pCDeleteClass;

	// For each hash table entry
	for (iIndex =0; iIndex < CLASS_HASH_SIZE; iIndex++) {
		// While the entry is not empty
		while (m_rgCClassTable[iIndex] != NULL) {
			// Nuke the first table entry
			pCDeleteClass = m_rgCClassTable[iIndex];
			m_rgCClassTable[iIndex] = pCDeleteClass->m_pCHashNext;
			delete pCDeleteClass;
		}
	}

	m_fLoaded = FALSE;
}

/*===================================================================
CCClasssInfoTable::GetClassInfo

Get the CClassInfo (class info) object from the hash table given
the class name

Parameters:
	tszClassName	Name of the class to get info for

Returns:
	NULL on failure
	Pointer to the CClassInfo object on success
===================================================================*/
CClassInfo *CClassInfoTable::GetClassInfo(LPCTSTR tszName) 
{
	ASSERT_STRING(tszName);

	CClassInfo *pCCurClass;

	// Go to the table location
	pCCurClass = m_rgCClassTable[Hash(tszName)];

	// Look at all of the entries
	while ((pCCurClass != NULL) && 
		   (_tcscmp(pCCurClass->m_tszName, tszName) != 0)) {
		pCCurClass = pCCurClass->m_pCHashNext;
	}

	return pCCurClass; // Will be NULL if not found
}

/*===================================================================
CClassInfoTable::Hash

Private function to get a hash value from a class name for the
class table.

Parameters:
	tszName		Name to hash

Returns:
	Hash value of name
===================================================================*/
unsigned int CClassInfoTable::Hash(LPCTSTR tszName) 
{
	ASSERT_STRING(tszName);

	unsigned int uiSum;
	unsigned int uiIndex;

	uiSum = 0;
	for (uiIndex=0; uiIndex < _tcslen(tszName); uiIndex++) {
		uiSum += tszName[uiIndex];
	}

	return (uiSum % CLASS_HASH_SIZE);
}


/*------------------------------------------------------------------
 * C M e t a S c h e m a
 */

/*===================================================================
CMetaSchema::Init

Constructor

Parameters:
	pIMeta			ATL Smart pointer to the metabase
	tszMachineName	Name of machine the schema is for

Returns:
	E_OUTOFMEMORY if allocation fails
	S_OK on success
===================================================================*/
HRESULT CMetaSchema::Init(const CComPtr<IMSAdminBase> &pIMeta, 
						  LPCTSTR tszMachineName) 
{
	ASSERT(pIMeta.p != NULL);
	ASSERT_STRING(tszMachineName);

	m_pIMeta = pIMeta;

	m_tszMachineName = new TCHAR[_tcslen(tszMachineName) + 1];
	if (m_tszMachineName == NULL)
		return E_OUTOFMEMORY;
	_tcscpy(m_tszMachineName, tszMachineName);

	return S_OK;
}

/*===================================================================
CMetaSchema::GetPropInfo

Get the CPropInfo (property info) object for a given id

Parameters:
	dwId	Id of property to get info for

Returns:
	NULL on failure
	Pointer to the CPropInfo object on success
===================================================================*/
CPropInfo *CMetaSchema::GetPropInfo(DWORD dwId) 
{
	// Make sure the property table is up to date
	if (m_fPropTableDirty) {
		HRESULT hr;

		hr = LoadPropTable();
		if (FAILED(hr)) {
			return NULL;
		}
	}

	// Pass on the call
	return m_CPropInfoTable.GetPropInfo(dwId);
}

/*===================================================================
CMetaSchema::GetPropInfo

Get the CPropInfo (property info) object for a given name

Parameters:
	tszName		Name of property to get info for

Returns:
	NULL on failure
	Pointer to the CPropInfo object on success
===================================================================*/
CPropInfo *CMetaSchema::GetPropInfo(LPCTSTR tszName) 
{
	ASSERT_STRING(tszName);

	// Make sure the property table is up to date
	if (m_fPropTableDirty) {
		HRESULT hr;

		hr = LoadPropTable();
		if (FAILED(hr)) {
			return NULL;
		}
	}

	// Pass on the call
	return m_CPropInfoTable.GetPropInfo(tszName);
}

/*===================================================================
CMetaSchema::GetClassInfo

Get the CClassInfo (class info) object for a given class name

Parameters:
	tszClassName	Name of the class to get info for

Returns:
	NULL on failure
	Pointer to the CClassInfo object on success
===================================================================*/
CClassInfo *CMetaSchema::GetClassInfo(LPCTSTR tszClassName) {
	ASSERT_STRING(tszClassName);

	// Make sure the class table is up to date
	if (m_fClassTableDirty) {
		HRESULT hr;

		hr = LoadClassTable();
		if (FAILED(hr)) {
			return NULL;
		}
	}

	// Pass on the call
	return m_CClassInfoTable.GetClassInfo(tszClassName);
}

/*===================================================================
CMetaSchema:::GetClassPropInfo

Get the CClassPropInfo (class property info) object for a given 
class name and property id.

Parameters:
	tszClassName	Name of the class get property from
	dwPropId		Id of property to get info for

Returns:
	NULL on failure
	Pointer to the CClassPropInfo object on success
===================================================================*/
CClassPropInfo *CMetaSchema::GetClassPropInfo(LPCTSTR tszClassName, 
											  DWORD dwPropId) 
{
	// Make sure the class table is up to date
	if (m_fClassTableDirty) {
		HRESULT hr;

		hr = LoadClassTable();
		if (FAILED(hr)) {
			return NULL;
		}
	}

	// Get the class
	CClassInfo *pCClassInfo;

	pCClassInfo = m_CClassInfoTable.GetClassInfo(tszClassName);
	
	if (pCClassInfo == NULL) {
		return NULL;
	}
	else {
		// Pass on the call
		return pCClassInfo->GetProperty(dwPropId);
	}
}

/*===================================================================
CMetaSchema::GetMandatoryClassPropList

Get the list of optional class properties for a class name.

Parameters:
	tszClassName	Name of the class get the properties from

Returns:
	NULL on failure
	Pointer to the first optional CClassPropInfo object on success
===================================================================*/
CClassPropInfo *CMetaSchema::GetMandatoryClassPropList(LPCTSTR tszClassName) 
{
	// Make sure the class table is up to date
	if (m_fClassTableDirty) {
		HRESULT hr;

		hr = LoadClassTable();
		if (FAILED(hr)) {
			return NULL;
		}
	}

	// Get the class
	CClassInfo *pCClassInfo;

	pCClassInfo = m_CClassInfoTable.GetClassInfo(tszClassName);
	
	if (pCClassInfo == NULL) {
		return NULL;
	}
	else {
		// Pass on the call
		return pCClassInfo->GetMandatoryPropList();
	}
}

/*===================================================================
CMetaSchema::GetOptionalClassPropList

Get the list of optional class properties for a class name.

Parameters:
	tszClassName	Name of the class get the properties from

Returns:
	NULL on failure
	Pointer to the first optional CClassPropInfo object on success
===================================================================*/
CClassPropInfo *CMetaSchema::GetOptionalClassPropList(LPCTSTR tszClassName) 
{
	// Make sure the class table is up to date
	if (m_fClassTableDirty) {
		HRESULT hr;

		hr = LoadClassTable();
		if (FAILED(hr)) {
			return NULL;
		}
	}

	// Get the class
	CClassInfo *pCClassInfo;

	pCClassInfo = m_CClassInfoTable.GetClassInfo(tszClassName);
	
	if (pCClassInfo == NULL) {
		return NULL;
	}
	else {
		// Pass on the call
		return pCClassInfo->GetOptionalPropList();
	}
}

/*===================================================================
CMetaSchema::ChangeNotification

Processes change events effecting the machine where the schema is
located.  If the dirty flag for the property and class tables is not 
already set a call to Unload() is made to free up memory no longer 
needed.

Parameters:
	tszChangedKey		Cannonized key where change took place
	pcoChangeObject		Pointer to the change event information

Returns:
	Nothing
===================================================================*/
void CMetaSchema::ChangeNotification(LPTSTR tszKey,
									 MD_CHANGE_OBJECT *pcoChangeObject) 
{
	ASSERT_POINTER(pcoChangeObject, MD_CHANGE_OBJECT);

	USES_CONVERSION;
	LPTSTR tszChangedKey;

	tszChangedKey = tszKey;

    // Skip the slash 
    if (*tszChangedKey != _T('\0') && *tszChangedKey == _T('/')) {
        tszChangedKey++;
    }

	if (_tcsnicmp(tszChangedKey, _T("schema/"), 7) == 0) {
		// It effects a "Schema" subkey
		if ((_tcsnicmp(tszChangedKey, _T("schema/properties/"), 18) == 0) ||
			(_tcsicmp(tszChangedKey, _T("schema/properties")) == 0)) {
			// It effects "Schema/Properties"
			if (!m_fPropTableDirty) {
				// Unload the prop table
				m_CPropInfoTable.Unload();
			}
			m_fPropTableDirty = TRUE;
		}
		else if ((_tcsnicmp(tszChangedKey, _T("schema/classes/"), 15) == 0) ||
				 (_tcsicmp(tszChangedKey, _T("schema/classes")) == 0)) {
			// It effects "Schema/Classes"
			if (!m_fClassTableDirty) {
				// Unload the class table
				m_CClassInfoTable.Unload();
			}
			m_fClassTableDirty = TRUE;
		}
	}
	else if (_tcsicmp(tszChangedKey, _T("schema")) == 0) {
		// Just the "Schema" key was changed
		if (!m_fPropTableDirty) {
			// Unload the prop table
			m_CPropInfoTable.Unload();
		}
		m_fPropTableDirty = TRUE;

		if (!m_fClassTableDirty) {
			// Unload the class table
			m_CClassInfoTable.Unload();
		}
		m_fClassTableDirty = TRUE;
	}
}

/*===================================================================
CMetaSchema::LoadPropTable

(Re)loads a dirty property table

Parameters:
	None

Returns:
	S_OK on success
===================================================================*/
HRESULT CMetaSchema::LoadPropTable() 
{
	USES_CONVERSION;
	HRESULT hr;

	// Open the Machine key
	METADATA_HANDLE hMDKey;

	hr = m_pIMeta->OpenKey(METADATA_MASTER_ROOT_HANDLE,
						   L"",              // schema path moved to /schema
						   METADATA_PERMISSION_READ,
					       MUTIL_OPEN_KEY_TIMEOUT,
						   &hMDKey);
	if (FAILED(hr)) {
		return hr;
	}

	// Load the properties
	hr = m_CPropInfoTable.Load(m_pIMeta, hMDKey);
	if (FAILED(hr)) {
		return hr;
	}

	// Close the Machine key
	m_pIMeta->CloseKey(hMDKey);

	m_fPropTableDirty = FALSE;

	return S_OK;
}

/*===================================================================
CMetaSchema::LoadClassTable

(Re)loads a dirty class table

Parameters:
	None

Returns:
	S_OK on success
===================================================================*/
HRESULT CMetaSchema::LoadClassTable() 
{
	USES_CONVERSION;
	HRESULT hr;

	// Open the Machine key
	METADATA_HANDLE hMDKey;

	hr = m_pIMeta->OpenKey(METADATA_MASTER_ROOT_HANDLE,
						   L"",              // schema path moved to /schema
						   METADATA_PERMISSION_READ,
					       MUTIL_OPEN_KEY_TIMEOUT,
						   &hMDKey);
	if (FAILED(hr)) {
		return hr;
	}

	// Load the properties
	hr = m_CClassInfoTable.Load(m_pIMeta, hMDKey);
	if (FAILED(hr)) {
		return hr;
	}

	// Close the Machine key
	m_pIMeta->CloseKey(hMDKey);

	m_fClassTableDirty = FALSE;

	return S_OK;
}


/*------------------------------------------------------------------
 * C M e t a S c h e m a T a b l e
 */

/*===================================================================
CMetaSchemaTable::CMetaSchemaTable

Constructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CMetaSchemaTable::CMetaSchemaTable() : m_dwNumRef(1),
									   m_fLoaded(FALSE)
{
	m_CMSAdminBaseSink = new CComObject<CMSAdminBaseSink>;
	m_CMSAdminBaseSink->AddRef();

	// Clear the hash table
	memset(m_rgCSchemaTable, 0, SCHEMA_HASH_SIZE * sizeof(CMetaSchema *));
}

/*===================================================================
CMetaSchemaTable::~CMetaSchemaTable

Destructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CMetaSchemaTable::~CMetaSchemaTable() 
{
	TRACE0("MetaUtil: CMetaSchemaTable::~CMetaSchemaTable\n");

	if (m_fLoaded) {
		Unload();
	}

	DWORD dwTemp;

	if (m_CMSAdminBaseSink != NULL) {
		dwTemp = m_CMSAdminBaseSink->Release();

		TRACE1("MetaUtil: CMetaSchemaTable::~CMetaSchemaTable Release Sink %i\n", dwTemp);
	}
}

/*===================================================================
CMetaSchemaTable::Load

Loads/Creates the schema information for all of the machines

Parameters:
	None

Returns:
	Nothing
===================================================================*/
void CMetaSchemaTable::Load() 
{
	USES_CONVERSION;
	HRESULT hr;

	if (m_fLoaded) {
		Unload();
	}

	// Create an instance of the Metabase Admin Base Object
	// Need a seperate instance so we pick up changes made
	// by our "parent" MetaUtil object family.
	hr = ::CoCreateInstance(CLSID_MSAdminBase,
						    NULL,
						    CLSCTX_ALL,
					        IID_IMSAdminBase,
						    (void **)&m_pIMeta);
	if (FAILED(hr)) {
		m_pIMeta = NULL;
		return;
	}

	// Build the schema list
	int iKeyIndex;
	wchar_t wszMDSubKey[ADMINDATA_MAX_NAME_LEN];
	CMetaSchema *pCNewSchema;
	int iLoc;

	// For each subkey of root
	iKeyIndex = 0;
	hr = m_pIMeta->EnumKeys(METADATA_MASTER_ROOT_HANDLE, 
							NULL, 
							wszMDSubKey, 
							iKeyIndex);
	while (SUCCEEDED(hr)) {
		// Create the new schema
		pCNewSchema = new CMetaSchema;
		if (pCNewSchema == NULL) {
			goto LError;
		}
		hr = pCNewSchema->Init(m_pIMeta, W2T(wszMDSubKey));
		if (FAILED(hr)) {
			delete pCNewSchema;
			goto LError;
		}

		// Add it to the hash table
		iLoc = Hash(W2T(wszMDSubKey));
		pCNewSchema->m_pCNextSchema = m_rgCSchemaTable[iLoc];
		m_rgCSchemaTable[iLoc] = pCNewSchema;

		// Next
		iKeyIndex++;
		hr = m_pIMeta->EnumKeys(METADATA_MASTER_ROOT_HANDLE, 
								NULL, 
								wszMDSubKey, 
								iKeyIndex);
	}

	// Make sure we ran out of items
	if (HRESULT_CODE(hr) != ERROR_NO_MORE_ITEMS) {
		goto LError;
	}

	// Setup notification
	if (m_CMSAdminBaseSink != NULL) {
		m_CMSAdminBaseSink->Connect(m_pIMeta, this);
	}

	m_fLoaded = TRUE;

	return;

LError:
	// Back out of the load
	Unload();	
}

/*===================================================================
CMetaSchemaTable::Unload

Unloads the schema table.

Parameters:
	None

Returns:
	Nothing
===================================================================*/
void CMetaSchemaTable::Unload() {
	int iIndex;
	CMetaSchema *pCDelete;

	// Stop notification
	if (m_CMSAdminBaseSink != NULL) {
		m_CMSAdminBaseSink->Disconnect();
	}

	m_pIMeta = NULL;

	// For each hash table entry
	for (iIndex =0; iIndex < SCHEMA_HASH_SIZE; iIndex++) {
		// While the entry is not empty
		while (m_rgCSchemaTable[iIndex] != NULL) {
			// Nuke the first table entry
			pCDelete = m_rgCSchemaTable[iIndex];
			m_rgCSchemaTable[iIndex] = pCDelete->m_pCNextSchema;
			delete pCDelete;
		}
	}

	m_fLoaded = FALSE;
}

/*===================================================================
CMetaSchemaTable::GetPropInfo

Get the CPropInfo (property info) object for a given key and id

Parameters:
	tszKey		Key the property is located under
	dwPropId	Id of the property to get info for

Returns:
	NULL on failure
	Pointer to the CPropInfo object on success
===================================================================*/
CPropInfo *CMetaSchemaTable::GetPropInfo(LPCTSTR tszKey, 
										 DWORD dwPropId) 
{
	ASSERT_STRING(tszKey);

	if (!m_fLoaded) {
		Load();
	}

	CMetaSchema *pCSchema;
	pCSchema = GetSchema(tszKey);

	// If found then pass the call on
	if (pCSchema != NULL) {
		return pCSchema->GetPropInfo(dwPropId);
	}
	else {
		return NULL;
	}
}

/*===================================================================
CMetaSchemaTable::GetPropInfo

Get the CPropInfo (property info) object for a given key and name

Parameters:
	tszKey		Key the property is located under
	tszPropName	Name of the property to get info for

Returns:
	NULL on failure
	Pointer to the CPropInfo object on success
===================================================================*/
CPropInfo *CMetaSchemaTable::GetPropInfo(LPCTSTR tszKey, 
										 LPCTSTR tszPropName) 
{
	ASSERT_STRING(tszKey);
	ASSERT_STRING(tszPropName);

	if (!m_fLoaded) {
		Load();
	}

	CMetaSchema *pCSchema;
	pCSchema = GetSchema(tszKey);

	// If found then pass the call on
	if (pCSchema != NULL) {
		return pCSchema->GetPropInfo(tszPropName);
	}
	else {
		return NULL;
	}
}

/*===================================================================
CMetaSchemaTable::GetClassInfo

Get the CClassInfo (class info) object for a given key and class name

Parameters:
	tszKey			Approxiamte key the class is located under.  Used 
					to get the machine name.
	tszClassName	Name of the class to get info for

Returns:
	NULL on failure
	Pointer to the CClassInfo object on success
===================================================================*/
CClassInfo *CMetaSchemaTable::GetClassInfo(LPCTSTR tszKey, 
										   LPCTSTR tszClassName) 
{
	ASSERT_STRING(tszKey);
	ASSERT_STRING(tszClassName);

	if (!m_fLoaded) {
		Load();
	}

	CMetaSchema *pCSchema;
	pCSchema = GetSchema(tszKey);

	// If found then pass the call on
	if (pCSchema != NULL) {
		return pCSchema->GetClassInfo(tszClassName);
	}
	else {
		return NULL;
	}	
}

/*===================================================================
CMetaSchemaTable::GetClassPropInfo

Get the CClassPropInfo (class property info) object for a given 
key, class name and property id.

Parameters:
	tszKey			Approxiamte key the class is located under.  Used 
					to get the machine name.
	tszClassName	Name of the class get property from
	dwPropId		Id of property to get info for

Returns:
	NULL on failure
	Pointer to the CClassPropInfo object on success
===================================================================*/
CClassPropInfo *CMetaSchemaTable::GetClassPropInfo(LPCTSTR tszKey, 
												   LPCTSTR tszClassName, 
												   DWORD dwPropId) 
{
	ASSERT_STRING(tszKey);
	ASSERT_STRING(tszClassName);

	if (!m_fLoaded) {
		Load();
	}

	CMetaSchema *pCSchema;
	pCSchema = GetSchema(tszKey);

	// If found then pass the call on
	if (pCSchema != NULL) {
		return pCSchema->GetClassPropInfo(tszClassName, dwPropId);
	}
	else {
		return NULL;
	}	
}

/*===================================================================
CMetaSchemaTable::GetMandatoryClassPropList

Get the list of mandatory class properties for a given key and class
name.

Parameters:
	tszKey			Approxiamte key the class is located under.  Used 
					to get the machine name.
	tszClassName	Name of the class get the properties from

Returns:
	NULL on failure
	Pointer to the first mandatory CClassPropInfo object on success
===================================================================*/
CClassPropInfo *CMetaSchemaTable::GetMandatoryClassPropList(LPCTSTR tszKey, 
															LPCTSTR tszClassName) 
{
	ASSERT_STRING(tszKey);
	ASSERT_STRING(tszClassName);

	if (!m_fLoaded) {
		Load();
	}

	CMetaSchema *pCSchema;
	pCSchema = GetSchema(tszKey);

	// If found then pass the call on
	if (pCSchema != NULL) {
		return pCSchema->GetMandatoryClassPropList(tszClassName);
	}
	else {
		return NULL;
	}	
}

/*===================================================================
CMetaSchemaTable::GetOptionalClassPropList

Get the list of optional class properties for a given key and class
name.

Parameters:
	tszKey			Approxiamte key the class is located under.  Used 
					to get the machine name.
	tszClassName	Name of the class get the properties from

Returns:
	NULL on failure
	Pointer to the first optional CClassPropInfo object on success
===================================================================*/
CClassPropInfo *CMetaSchemaTable::GetOptionalClassPropList(LPCTSTR tszKey, 
														   LPCTSTR tszClassName) 
{
	ASSERT_STRING(tszKey);
	ASSERT_STRING(tszClassName);

	if (!m_fLoaded) {
		Load();
	}
	
	CMetaSchema *pCSchema;
	pCSchema = GetSchema(tszKey);

	// If found then pass the call on
	if (pCSchema != NULL) {
		return pCSchema->GetOptionalClassPropList(tszClassName);
	}
	else {
		return NULL;
	}	
}

/*===================================================================
CMetaSchemaTable::SinkNotify

Metabase change notification callback from CMSAdminBaseSink.  Either
determines a need to reload all of the schema information or sends
the message on to the appropriate CMetaSchema object.

Parameters:
	dwMDNumElements		Number of change events
	pcoChangeObject		Array of change events

Returns:
	S_OK always
===================================================================*/
HRESULT CMetaSchemaTable::SinkNotify(DWORD dwMDNumElements, 
									 MD_CHANGE_OBJECT pcoChangeObject[]) 
{
	ASSERT(IsValidAddress(pcoChangeObject, dwMDNumElements * sizeof(MD_CHANGE_OBJECT), FALSE));

	USES_CONVERSION;
	DWORD dwIndex;
	CMetaSchema *pCMetaSchema;

	// For each event
	for (dwIndex = 0; dwIndex < dwMDNumElements; dwIndex++) {
		// Figure out what machine it's for
		TCHAR tszKey[ADMINDATA_MAX_NAME_LEN];
		_tcscpy(tszKey, W2T(pcoChangeObject[dwIndex].pszMDPath));
		CannonizeKey(tszKey);
		pCMetaSchema = GetSchema(tszKey);

		// If the machine is not found
		if (pCMetaSchema == NULL) {
			// Reload the schema table
			Load();
		}
		else {
			// Send it to the appropriate machine
			pCMetaSchema->ChangeNotification(tszKey, &(pcoChangeObject[dwIndex]));
		}
	}

	return S_OK;
}

/*===================================================================
CMetaSchemaTable::GetSchema

Get the schema object that contains information on the given key.

Parameters:
	tszKey			Approxiamte key to get schema information for.

Returns:
	NULL on failure
	Pointer to the CMetaSchema object on success
===================================================================*/
CMetaSchema *CMetaSchemaTable::GetSchema(LPCTSTR tszKey) {

	// Extract the machine name
	TCHAR tszMachineName[ADMINDATA_MAX_NAME_LEN];
	::GetMachineFromKey(tszKey, tszMachineName);

	// Find the right schema
	CMetaSchema *pCCurSchema;
	
	pCCurSchema =m_rgCSchemaTable[Hash(tszMachineName)];
	while ((pCCurSchema != NULL) && 
		   (_tcsicmp(pCCurSchema->m_tszMachineName, tszMachineName) != 0)) {
		pCCurSchema = pCCurSchema->m_pCNextSchema;
	}

	return pCCurSchema; // Will be NULL if not found
}

/*===================================================================
CMetaSchemaTable::Hash

Private function to get a hash value from a machine name for the
schema table.

Parameters:
	tszName		Machinea name to hash

Returns:
	Hash value of name
===================================================================*/
unsigned int CMetaSchemaTable::Hash(LPCTSTR tszName) {
	ASSERT_STRING(tszName);

	unsigned int uiSum;
	unsigned int uiIndex;

	uiSum = 0;
	for (uiIndex=0; uiIndex < _tcslen(tszName); uiIndex++) {
		uiSum += _totlower(tszName[uiIndex]);
	}

	return (uiSum % SCHEMA_HASH_SIZE);
}

/*------------------------------------------------------------------
 * C M S A d m i n B a s e S i n k
 */

/*===================================================================
CMSAdminBaseSink::CMSAdminBaseSink

Constructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CMSAdminBaseSink::CMSAdminBaseSink() : m_fConnected(FALSE),
									   m_dwCookie(0),
									   m_pCMetaSchemaTable(NULL)
{
}

/*===================================================================
CMSAdminBaseSink::~CMSAdminBaseSink

Destructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CMSAdminBaseSink::~CMSAdminBaseSink() 
{
	TRACE0("MetaUtil: CMSAdminBaseSink::~CMSAdminBaseSink !!!!!!!!!!!\n");

	// Make sure we disconnected
	if (m_fConnected) {
		Disconnect();
	}
}

/*===================================================================
CMSAdminBaseSink::SinkNotify

Entry point for notification events from the metabase admin base
object.

Parameters:
	dwMDNumElements		Number of change events
	pcoChangeObject		Array of change events

Returns:
	E_FAIL	if m_pCMetaSchemaTable == NULL
	S_OK	on success
===================================================================*/
STDMETHODIMP CMSAdminBaseSink::SinkNotify(DWORD dwMDNumElements, 
										  MD_CHANGE_OBJECT pcoChangeObject[]) 
{
	TRACE0("MetaUtil: CMSAdminBaseSink::SinkNotify\n");
	ASSERT(IsValidAddress(pcoChangeObject, dwMDNumElements * sizeof(MD_CHANGE_OBJECT), FALSE));

	if (m_pCMetaSchemaTable == NULL) {
		return E_FAIL;
	}

	// Pass on the notification
	return m_pCMetaSchemaTable->SinkNotify(dwMDNumElements, pcoChangeObject);	
}

/*===================================================================
CMSAdminBaseSink::ShutdownNotify

Entry point for the shutdown notification event from the metabase 
admin base object.

Parameters:
	None

Returns:
	ERROR_NOT_SUPPORTE always
===================================================================*/
STDMETHODIMP CMSAdminBaseSink::ShutdownNotify() {
	return HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
}

/*===================================================================
CMSAdminBaseSink::Connect

Begins notification of change events.  Connects to the metabase admin
base object.

Parameters:
	pIMeta				Pointer to the metabase admin base object
	pCMetaSchemaTable	Pointer to the schema table so that events
						can be sent back to it.

Returns:
	E_NOINTERFACE if can not convert IMSAdminBase to 
		IConnectionPointContainer.
	S_OK on success
===================================================================*/
HRESULT CMSAdminBaseSink::Connect(CComPtr<IMSAdminBase> &pIMeta, 
							      CMetaSchemaTable *pCMetaSchemaTable)
{
	ASSERT(pIMeta.p != NULL);
	ASSERT_POINTER(pCMetaSchemaTable, CMetaSchemaTable);

	HRESULT hr;

	if (m_fConnected) {
		Disconnect();
	}

	m_pCMetaSchemaTable = pCMetaSchemaTable;

	// Get the connection container
	CComQIPtr<IConnectionPointContainer, &IID_IConnectionPointContainer> pIMetaConnContainer;

	pIMetaConnContainer = pIMeta;
	if (pIMetaConnContainer == NULL) {
		// Failure to change interfaces
		return E_NOINTERFACE;
	}

	// Get the connection point
	hr = pIMetaConnContainer->FindConnectionPoint(IID_IMSAdminBaseSink, &m_pIMetaConn);
	if (FAILED(hr)) {
		return hr;
	}

	// Advise (connect)
	AddRef();
	m_pIMetaConn->Advise((IMSAdminBaseSink *) this, &m_dwCookie);

	m_fConnected = TRUE;

	return S_OK;
}

/*===================================================================
CMSAdminBaseSink::Disconnect

Stops notification of change events.  Disconnects from the metabase
admin base object.

Parameters:
	None

Returns:
	Nothing
===================================================================*/
void CMSAdminBaseSink::Disconnect()
{
	if (!m_fConnected) {
		// Not connected
		return;
	}

	// Stop notification
	m_pIMetaConn->Unadvise(m_dwCookie);

	// No longer needed
	m_pIMetaConn = NULL;
	m_pCMetaSchemaTable = NULL;

	m_fConnected = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\metautil\metaschm.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: MetaUtil object

File: MetaSchm.h

Owner: t-BrianM

This file contains the headers for the CMetaSchemaTable object and
other schema related objects.
===================================================================*/

#ifndef __METASCHM_H_
#define __METASCHM_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "resource.h"       // main symbols

// Ripped from schemini.hxx
struct PropValue {
	DWORD dwMetaID;
	DWORD dwSynID;
	DWORD dwMetaType;
	DWORD dwFlags;
	DWORD dwMask;
	DWORD dwMetaFlags;
	DWORD dwUserGroup;
	BOOL fMultiValued;
};

// All hash table sizes are prime numbers between powers of 2
// and are ~10x larger than the expected number of items.
#define SCHEMA_HASH_SIZE          181
#define PROPERTY_HASH_SIZE       1559
#define CLASS_HASH_SIZE           181
#define CLASS_PROPERTY_HASH_SIZE  709

/*
 * C P r o p I n f o
 *
 * C P r o p I n f o T a b l e
 *
 * Internal classes used to store and represent property information
 */

class CPropInfoTable;

class CPropInfo {

	friend CPropInfoTable;

public:
    CPropInfo() : m_dwId(0), 
				  m_tszName(NULL), 
				  m_pType(NULL),
				  m_pCIdHashNext(NULL),
				  m_pCNameHashNext(NULL) { }
	HRESULT Init(DWORD dwId);
	HRESULT SetName(LPCTSTR tszName);
	HRESULT SetTypeInfo(PropValue *pType);
	~CPropInfo() { 
		if (m_tszName != NULL) delete m_tszName; 
		if (m_pType != NULL) delete m_pType;
	}

	DWORD GetId() { return m_dwId; }
	LPCTSTR GetName()  { return m_tszName; }
	PropValue *GetTypeInfo() { return m_pType; }

private:
	DWORD m_dwId;
	LPTSTR m_tszName;
	PropValue *m_pType;

	CPropInfo *m_pCNameHashNext;
	CPropInfo *m_pCIdHashNext;

};

class CPropInfoTable {
public:
	CPropInfoTable();
	~CPropInfoTable();

	HRESULT Load(CComPtr<IMSAdminBase> &pIMeta, METADATA_HANDLE hMDComp);
	void Unload();

	CPropInfo *GetPropInfo(DWORD dwId);
	CPropInfo *GetPropInfo(LPCTSTR tszName);

private:
	BOOL m_fLoaded;
	CPropInfo *m_rgCPropIdTable[PROPERTY_HASH_SIZE];
	CPropInfo *m_rgCPropNameTable[PROPERTY_HASH_SIZE];


	unsigned int IdHash(DWORD dwId) { return dwId % PROPERTY_HASH_SIZE; }
	unsigned int NameHash(LPCTSTR tszName);
};


/*
 * C C l a s s P r o p I n f o
 *
 * C C l a s s I n f o
 *
 * C C l a s s I n f o T a b l e
 *
 * Internal classes used to store and represent class information
 */

class CClassInfoTable;
class CClassInfo;

class CClassPropInfo {

	friend CClassInfo;

public:
	CClassPropInfo() : m_dwId(0),
					   m_fMandatory(FALSE),
					   m_pCHashNext(NULL),
					   m_pCListNext(NULL) {}
	HRESULT Init(DWORD dwId, BOOL fMandatory) {
		m_dwId = dwId;
		m_fMandatory = fMandatory;
		return S_OK;
	}

	DWORD GetId() { return m_dwId; }
	BOOL IsMandatory() { return m_fMandatory; }
	CClassPropInfo *GetListNext() { return m_pCListNext; }

private:
	DWORD m_dwId;
	BOOL m_fMandatory;
	// Property default information could also be added...

	CClassPropInfo *m_pCHashNext;
	CClassPropInfo *m_pCListNext;
};

class CClassInfo {

	friend CClassInfoTable;

public:
	CClassInfo();
	HRESULT Init(LPCTSTR tszName);
	~CClassInfo();

	HRESULT Load(CComPtr<IMSAdminBase> &pIMeta, METADATA_HANDLE hMDClasses);
	void Unload();

	CClassPropInfo *GetProperty(DWORD dwId);
	CClassPropInfo *GetOptionalPropList() { return m_pCOptionalPropList; }
	CClassPropInfo *GetMandatoryPropList() { return m_pCMandatoryPropList; }

private:
	LPTSTR m_tszName;
	CClassInfo *m_pCHashNext;

	BOOL m_fLoaded;
	CClassPropInfo *m_rgCPropTable[CLASS_PROPERTY_HASH_SIZE];
	CClassPropInfo *m_pCOptionalPropList;
	CClassPropInfo *m_pCMandatoryPropList;

	unsigned int Hash(DWORD dwId) { return dwId % CLASS_PROPERTY_HASH_SIZE; }
};

class CClassInfoTable {
public:
	CClassInfoTable();
	~CClassInfoTable();

	HRESULT Load(CComPtr<IMSAdminBase> &pIMeta, METADATA_HANDLE hMDComp);
	void Unload();

	CClassInfo *GetClassInfo(LPCTSTR tszName);

private:
	BOOL m_fLoaded;
	CClassInfo *m_rgCClassTable[CLASS_HASH_SIZE];

	unsigned int Hash(LPCTSTR tszName);
};


/*
 * C M e t a S c h e m a
 *
 * Internal class used to store schema information for a machine
 */

class CMetaSchemaTable;

class CMetaSchema {

	friend CMetaSchemaTable;

public:
	CMetaSchema() : m_fPropTableDirty(TRUE), 
		            m_fClassTableDirty(TRUE),
		            m_tszMachineName(NULL),
					m_pCNextSchema(NULL) { }
	HRESULT Init(const CComPtr<IMSAdminBase> &pIMeta, LPCTSTR tszMachineName);
	~CMetaSchema() { if (m_tszMachineName != NULL) delete m_tszMachineName; }

	CPropInfo *GetPropInfo(DWORD dwId);
	CPropInfo *GetPropInfo(LPCTSTR tszName);

	CClassInfo *GetClassInfo(LPCTSTR tszClassName);
	CClassPropInfo *GetClassPropInfo(LPCTSTR tszClassName, DWORD dwPropId);
	CClassPropInfo *GetMandatoryClassPropList(LPCTSTR tszClassName);
	CClassPropInfo *GetOptionalClassPropList(LPCTSTR tszClassName);
	void ChangeNotification(LPTSTR tszKey, MD_CHANGE_OBJECT *pcoChangeObject);


private:
	LPTSTR m_tszMachineName;

	BOOL m_fPropTableDirty;
	BOOL m_fClassTableDirty;

	CPropInfoTable m_CPropInfoTable;
	CClassInfoTable m_CClassInfoTable;

	// Pointer to IMSAdminBase so we don't have to recreate it multiple times
	CComPtr<IMSAdminBase> m_pIMeta;

	CMetaSchema *m_pCNextSchema;

	HRESULT LoadPropTable();
	HRESULT LoadClassTable();
};


/*
 * C M e t a S c h e m a T a b l e
 *
 * Implements IMetaSchemaTable.  Stores all of the schema information
 * for all of the machines.  I made it global so it can persist after 
 * CMetaUtil is destructed.
 */
class CMSAdminBaseSink;

class CMetaSchemaTable {
public:
	CMetaSchemaTable();
	~CMetaSchemaTable();

	DWORD AddRef() { return ++m_dwNumRef; }
	DWORD Release() { 
		m_dwNumRef--; 
		if (!m_dwNumRef) {
			delete this;
            return 0;
        }
		return m_dwNumRef;
	}

	void Load();
	void Unload();

	CPropInfo *GetPropInfo(LPCTSTR tszKey, DWORD dwPropId);
	CPropInfo *GetPropInfo(LPCTSTR tszKey, LPCTSTR tszPropName);

	CClassInfo *GetClassInfo(LPCTSTR tszKey, LPCTSTR tszClassName);
	CClassPropInfo *GetClassPropInfo(LPCTSTR tszKey, LPCTSTR tszClassName, DWORD dwPropId);
	CClassPropInfo *GetMandatoryClassPropList(LPCTSTR tszKey, LPCTSTR tszClassName);
	CClassPropInfo *GetOptionalClassPropList(LPCTSTR tszKey, LPCTSTR tszClassName);

	// Event sink callback
	HRESULT SinkNotify(DWORD dwMDNumElements, MD_CHANGE_OBJECT pcoChangeObject[]);


private:
	DWORD m_dwNumRef;
	BOOL m_fLoaded;
	CMetaSchema *m_rgCSchemaTable[SCHEMA_HASH_SIZE];
	CComObject<CMSAdminBaseSink> *m_CMSAdminBaseSink;

	// Pointer to IMSAdminBase so we don't have to recreate it multiple times
	CComPtr<IMSAdminBase> m_pIMeta;

	CMetaSchema *GetSchema(LPCTSTR tszKey);
	unsigned int Hash(LPCTSTR tszName);
};


/*
 * C M S A d m i n B a s e S i n k
 *
 * Minimal ATL COM object that catches change notification events from the
 * metabase object and passes them on to the CMetaSchemaTable object.
 */

class CMSAdminBaseSink :
	public IMSAdminBaseSink,
	public CComObjectRoot
{
public:
	CMSAdminBaseSink();
	~CMSAdminBaseSink();

BEGIN_COM_MAP(CMSAdminBaseSink)
	COM_INTERFACE_ENTRY(IMSAdminBaseSink)
END_COM_MAP()
// DECLARE_NOT_AGGREGATABLE(CMSAdminBaseSink)

// IMSAdminBaseSink
	STDMETHOD(SinkNotify)(DWORD dwMDNumElements, MD_CHANGE_OBJECT pcoChangeObject[]);
	STDMETHOD(ShutdownNotify)(void);

// No Interface
	HRESULT Connect(CComPtr<IMSAdminBase> &pIMeta, CMetaSchemaTable *pCMetaSchemaTable);
	void Disconnect();

private:
	BOOL m_fConnected;
	DWORD m_dwCookie;
	CComPtr<IConnectionPoint> m_pIMetaConn;
	CMetaSchemaTable *m_pCMetaSchemaTable;
};

#endif // #ifndef __METASCHM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\metautil\metautil.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: MetaUtil object

File: MetaUtil.cpp

Owner: t-BrianM

This file contains the DLL interface.  Generated by the ATL wizard.
I just added the debugging stuff.
===================================================================*/

#include "stdafx.h"
#include "resource.h"
#include "initguid.h"
#include "MetaUtil.h"

#include "MetaUtil_i.c"
#include "MUtilObj.h"
#include "propcol.h"
#include "ChkError.h"
#include "MetaSchm.h"

#ifdef _NO_TRACING_
DECLARE_DEBUG_PRINTS_OBJECT();
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
	OBJECT_ENTRY(CLSID_MetaUtil, CMetaUtil)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
	if (dwReason == DLL_PROCESS_ATTACH)
	{
		_Module.Init(ObjectMap, hInstance);
		DisableThreadLibraryCalls(hInstance);
		IRTL_DEBUG_INIT();
	}
	else if (dwReason == DLL_PROCESS_DETACH)
	{
		IRTL_DEBUG_TERM();
		_Module.Term();
	}
	return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
	return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
	// registers object, typelib and all interfaces in typelib
	return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
	_Module.UnregisterServer();
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\utils\metautil\mutilobj.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: MetaUtil object

File: MUtilObj.cpp

Owner: t-BrianM

This file contains implementation of the main MetaUtil class.
Except CheckSchema is in ChkSchm.cpp and CheckKey is in ChkKey.cpp
===================================================================*/

#include "stdafx.h"
#include "MetaUtil.h"
#include "MUtilObj.h"
#include "keycol.h"

/*------------------------------------------------------------------
 * C M e t a U t i l  (edit and general portions)
 */

/*===================================================================
CMetaUtil::CMetaUtil

Constructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
CMetaUtil::CMetaUtil() : m_dwMaxPropSize(10 * 1024), //  10k
						 m_dwMaxKeySize(100 * 1024), // 100k
						 m_dwMaxNumErrors(100)
{
}

/*===================================================================
CMetaUtil::FinalConstruct

Constructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
HRESULT CMetaUtil::FinalConstruct() 
{
	HRESULT hr;

	// Create the metabase admin base object
	hr = ::CoCreateInstance(CLSID_MSAdminBase,
						    NULL,
						    CLSCTX_ALL,
					        IID_IMSAdminBase,
						    (void **)&m_pIMeta);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	// Create a schema table
	m_pCSchemaTable = new CMetaSchemaTable;
	if (m_pCSchemaTable == NULL) {
		return ::ReportError(E_OUTOFMEMORY);
	}
	
	return S_OK;
}

/*===================================================================
CMetaUtil::FinalRelease

Destructor

Parameters:
	None

Returns:
	Nothing
===================================================================*/
void CMetaUtil::FinalRelease() 
{
	m_pIMeta = NULL;

	if (m_pCSchemaTable != NULL)
		m_pCSchemaTable->Release();
}

/*===================================================================
CMetaUtil::InterfaceSupportsErrorInfo

Standard ATL implementation

===================================================================*/

STDMETHODIMP CMetaUtil::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IMetaUtil,
	};
	for (int i=0;i<sizeof(arr)/sizeof(arr[0]);i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}

	return S_FALSE;
}

/*===================================================================
CMetaUtil::EnumKeys

Do a flat (non-recursive) enumeration of subkeys

Parameters:
    bstrBaseKey	[in] Key to enumerate the subkeys of
	ppIReturn	[out, retval] interface for the ouput key collection

Returns:
	E_OUTOFMEMORY if allocation fails.
	E_INVALIDARG if ppIReturn == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CMetaUtil::EnumKeys(BSTR bstrBaseKey, 
								 IKeyCollection ** ppIReturn)
{
	TRACE0("MetaUtil: CMetaUtil::EnumKeys\n");

	ASSERT_NULL_OR_POINTER(bstrBaseKey, OLECHAR);
	ASSERT_NULL_OR_POINTER(ppIReturn, IKeyCollection *);

	if (ppIReturn == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	USES_CONVERSION;
	HRESULT hr;

	// Create the Flat Keys Collection
	CComObject<CFlatKeyCollection> *pObj = NULL;
	ATLTRY(pObj = new CComObject<CFlatKeyCollection>);
	if (pObj == NULL) {
		return ::ReportError(E_OUTOFMEMORY);
	}
	hr = pObj->Init(m_pIMeta, OLE2T(bstrBaseKey));
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	// Set the interface to IKeyCollection
	hr = pObj->QueryInterface(IID_IKeyCollection, (void **) ppIReturn);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}
	ASSERT(ppIReturn != NULL);

	return S_OK;
}

/*===================================================================
CMetaUtil::EnumAllKeys

Do a deep (recursive) enumeration of subkeys

Parameters:
    bstrBaseKey	[in] Key to enumerate the subkeys of
	ppIReturn	[out, retval] interface for the ouput key collection

Returns:
	E_OUTOFMEMORY if allocation fails.
	E_INVALIDARG if ppIReturn == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CMetaUtil::EnumAllKeys(BSTR bstrBaseKey, 
									IKeyCollection ** ppIReturn)
{
	TRACE0("MetaUtil: CMetaUtil::EnumAllKeys\n");

	ASSERT_NULL_OR_POINTER(bstrBaseKey, OLECHAR);
	ASSERT_NULL_OR_POINTER(ppIReturn, IKeyCollection *);

	if (ppIReturn == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	USES_CONVERSION;
	HRESULT hr;

	// Create the Flat Keys Collection
	CComObject<CDeepKeyCollection> *pObj = NULL;
	ATLTRY(pObj = new CComObject<CDeepKeyCollection>);
	if (pObj == NULL) {
		return ::ReportError(E_OUTOFMEMORY);
	}
	hr = pObj->Init(m_pIMeta, OLE2T(bstrBaseKey));
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	// Set the interface to IKeyCollection
	hr = pObj->QueryInterface(IID_IKeyCollection, (void **) ppIReturn);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}
	ASSERT(ppIReturn != NULL);

	return S_OK;
}

/*===================================================================
CMetaUtil::EnumProperties

Do an enumeration of properties

Parameters:
    bstrBaseKey	[in] Key to enumerate the properties of
	ppIReturn	[out, retval] interface for the ouput property collection

Returns:
	E_OUTOFMEMORY if allocation fails.
	E_INVALIDARG if ppIReturn == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CMetaUtil::EnumProperties(BSTR bstrKey, 
									   IPropertyCollection **ppIReturn)
{
	TRACE0("MetaUtil: CMetaUtil::EnumProperties\n");

	ASSERT_NULL_OR_POINTER(bstrKey, OLECHAR);
	ASSERT_NULL_OR_POINTER(ppIReturn, IKeyCollection *);

	if (ppIReturn == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	USES_CONVERSION;
	HRESULT hr;

	// Create the Flat Keys Collection
	CComObject<CPropertyCollection> *pObj = NULL;
	ATLTRY(pObj = new CComObject<CPropertyCollection>);
	if (pObj == NULL) {
		return ::ReportError(E_OUTOFMEMORY);
	}
	hr = pObj->Init(m_pIMeta, m_pCSchemaTable, OLE2T(bstrKey));
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	// Set the interface to IPropertyCollection
	hr = pObj->QueryInterface(IID_IPropertyCollection, (void **) ppIReturn);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}
	ASSERT(ppIReturn != NULL);

	return S_OK;
}

/*===================================================================
CMetaUtil::CreateKey

Create a new key

Parameters:
    bstrKey		[in] Key to create

Returns:
	E_INVALIDARG if bstrKey == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CMetaUtil::CreateKey(BSTR bstrKey)
{
	TRACE0("MetaUtil: CMetaUtil::CreateKey\n");

	ASSERT_NULL_OR_POINTER(bstrKey, OLECHAR);

	if (bstrKey == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	USES_CONVERSION;
	TCHAR tszKey[ADMINDATA_MAX_NAME_LEN];

	_tcscpy(tszKey,OLE2T(bstrKey));
	CannonizeKey(tszKey);

	return ::CreateKey(m_pIMeta, tszKey);
}

/*===================================================================
CMetaUtil::DeleteKey

Delete a key

Parameters:
    bstrKey		[in] Key to delete

Returns:
	E_INVALIDARG if bstrKey == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CMetaUtil::DeleteKey(BSTR bstrKey)
{
	TRACE0("MetaUtil: CMetaUtil::DeleteKey\n");

	ASSERT_NULL_OR_POINTER(bstrKey, OLECHAR);

	if (bstrKey == NULL) {
		return ::ReportError(E_INVALIDARG);
	}

	USES_CONVERSION;
	TCHAR tszKey[ADMINDATA_MAX_NAME_LEN];

	_tcscpy(tszKey,OLE2T(bstrKey));
	CannonizeKey(tszKey);

	return ::DeleteKey(m_pIMeta, tszKey);
}

/*===================================================================
CMetaUtil::RenameKey

Rename a key

Parameters:
    bstrOldName		[in] Original Key Name
	bstrNewName		[in] New key name

Returns:
	E_INVALIDARG if bstrOldName == NULL OR bstrNewName == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CMetaUtil::RenameKey(BSTR bstrOldName, BSTR bstrNewName)
{
	TRACE0("MetaUtil: CMetaUtil::RenameKey\n");
	ASSERT_NULL_OR_POINTER(bstrOldName, OLECHAR);
	ASSERT_NULL_OR_POINTER(bstrNewName, OLECHAR);

	if ((bstrOldName == NULL) || (bstrNewName == NULL)) {
		return ::ReportError(E_INVALIDARG);
	}

	USES_CONVERSION;
	HRESULT hr;
	TCHAR tszOldName[ADMINDATA_MAX_NAME_LEN];
	TCHAR tszNewName[ADMINDATA_MAX_NAME_LEN];

	_tcscpy(tszOldName, OLE2T(bstrOldName));
	CannonizeKey(tszOldName);

	_tcscpy(tszNewName, OLE2T(bstrNewName));
	CannonizeKey(tszNewName);

	// Figure out the key's common root
	TCHAR tszParent[ADMINDATA_MAX_NAME_LEN];
	int i;

	i = 0;
	while ((tszOldName[i] != _T('\0')) && (tszNewName[i] != _T('\0')) &&
		   (tszOldName[i] == tszNewName[i])) {
		tszParent[i] = tszOldName[i];
		i++;
	}
	if (i == 0) {
		// Nothing in common
		tszParent[i] = _T('\0');
	}
	else {
		// Back up to the first slash
		while ((i > 0) && (tszParent[i] != _T('/'))) {
			i--;
		}

		// Cut it off at the slash
		tszParent[i] = _T('\0');
	}

	int iParentKeyLen;
	iParentKeyLen = _tcslen(tszParent);

	LPTSTR tszRelOldName;
	LPTSTR tszRelNewName;

	// Figure out the relative new and old names
	tszRelOldName = tszOldName + iParentKeyLen;
	if (*tszRelOldName == _T('/')) {
		tszRelOldName++;
	}

	tszRelNewName = tszNewName + iParentKeyLen;
	if (*tszRelNewName == _T('/')) {
		tszRelNewName++;
	}

	// Open the parent
	METADATA_HANDLE hMDParentKey;

	hr = m_pIMeta->OpenKey(METADATA_MASTER_ROOT_HANDLE,
						   T2W(tszParent),
						   METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
					       MUTIL_OPEN_KEY_TIMEOUT,
						   &hMDParentKey);
	if (FAILED(hr)) {
		return ::ReportError(hr);
	}

	// Rename the key
	hr = m_pIMeta->RenameKey(hMDParentKey,
							 T2W(tszRelOldName), 
							 T2W(tszRelNewName));
	if (FAILED(hr)) {
		m_pIMeta->CloseKey(hMDParentKey);
		return ::ReportError(hr);
	}

	// Close the parent
	m_pIMeta->CloseKey(hMDParentKey);

	return S_OK;
}

/*===================================================================
CMetaUtil::CopyKey

Copy a key

Parameters:
    bstrSrcKey		[in] Source Key Name
	bstrDestKey		[in] Destination key name
	fOverwrite		[in] If true then already existing properties
					at destination are overwritten.

Returns:
	E_INVALIDARG if bstrSrcKey == NULL OR bstrDestKey == NULL
	S_OK on success
===================================================================*/
STDMETHODIMP CMetaUtil::CopyKey(BSTR bstrSrcKey, BSTR bstrDestKey, 